<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>使用神经网络预测股价：失败了！！！</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/110903464">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-458b0dc5e527e1fb9893ee609555ba64_b.jpg" alt=""></div><p>编译：1+1=6</p><h2><b><i><u>0、</u></i>前言</b></h2><p>当我们说起金融时间序列的预测，大家可能第一个想到的是预测股票价格。然而，Chollet 的《Deep Learning with Python》一书强调，<b>人们不应该尝试使用时间序列预测方法去预测股票价格</b>。他解释道，在股市中过去的数据并不是估计未来的一个好的基础。</p><p>那么，有没有可能用神经网络来预测股价呢？今天公众号带你来探讨。</p><h2><b><i><u>1、</u></i>案例</b></h2><p>我们将训练一个神经网络，它将使用n个已知值（过去的价格）来预测(n+1)-th的价格。我们假设两次价格测量之间的时间是常数。</p><p>我们将使用前几天的收盘价来预测收盘价。使用yfinance Python包获取数据。</p><div class="highlight"><pre><code class="language-python"><span class="n">pip</span> <span class="n">install</span> <span class="n">yfinance</span></code></pre></div><p>下一步：<br/></p><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">yfinance</span> <span class="kn">as</span> <span class="nn">yf</span>
<span class="c1"># create the object that represents Maersk stock data</span>
<span class="c1"># here MAERSK-B.CO -- is the Maerks&#39;s ticker</span>
<span class="n">maersk</span> <span class="o">=</span> <span class="n">yf</span><span class="o">.</span><span class="n">Ticker</span><span class="p">(</span><span class="s1">&#39;MAERSK-B.CO&#39;</span><span class="p">)</span></code></pre></div><p>我们还没有下载任何数据，只创建了可以用来请求数据的对象。雅虎财经为Maersk提供了股息数据，我们知道，<b>股息（股票的利息）会影响股票价格</b>。因此，我们希望神经网络在预测价格时考虑股息。这意味着，当我们告诉网络使用前几天的一组价格来预测某一天的收盘价时，我们还需要为它提供一个标记，告诉它当天是否支付了股息。</p><p>要获得支付股息的日期，请查看maersk.dividends。为了得到股票价格，我们调用history方法。这个方法有几个参数，我们用到的是period和interval。</p><p>Period参数定义我们请求数据的时间段。该参数支持一些预定义的字符串值，我们将使用其中的一个。我们传递字符串&#39;max’ ，它告诉我们所有可用的数据。使用开始和结束参数可以定义确切的周期。但是，因为我们将使用所有可用的数据，所以我们将使用 period 参数并传递&#39;max&#39;。</p><p>Interval 参数告诉方法两个后续值之间的间隔。 它取一个预先定义的值，我们将通过&#39;1d&#39; ，因为我们要使用每日价格。</p><div class="highlight"><pre><code class="language-python"><span class="n">history</span> <span class="o">=</span> <span class="n">maersk</span><span class="o">.</span><span class="n">history</span><span class="p">(</span><span class="n">period</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="s1">&#39;1d&#39;</span><span class="p">)</span></code></pre></div><p>看看dataframe：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-92249b293bff25e67db5978244a2ed01_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="659" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-92249b293bff25e67db5978244a2ed01_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-92249b293bff25e67db5978244a2ed01_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="659" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-92249b293bff25e67db5978244a2ed01_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-92249b293bff25e67db5978244a2ed01_b.jpg"/></figure><p>当设计一个神经网络来预测时间序列时，应该决定网络将有多少input。在我们的例子中，我们必须选择输入网络的价格数量来预测下一个价格。由于我们现在还不知道这个数字，所以最好能够生成具有不同数量输入的数据集。幸运的是，Keras开发人员已经考虑到了这一点，现在Keras提供了一个时间序列生成器，可以生成具有不同输入量的数据集。在时间序列预测的情况下，输入值和目标值都来自同一个序列。这意味着我们使用大小为j的移动窗口，其中j是我们用来预测(j+1)-th值的值的个数。</p><p>换句话说，我们获取时间序列的 j 后续元素({ x1，x2，... xj }) ，然后取(j + 1) th元素(x₍ⱼ₊₁₎)并将它设置为目标值。这对(j，(j+1)-th)构成一个单独的训练示例。为了生成另一个训练示例，我们将移动窗口一个step，并使用{x₂x₃,……x₍ⱼ₊₁₎}作为输入，x₍ⱼ₊₂₎作为目标值。</p><p>Keras为我们提供了TimeseriesGenerator类，我们将使用这个类来生成训练集。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-466d68cf17dfcad8a9f450a984b754d1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="315" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-466d68cf17dfcad8a9f450a984b754d1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-466d68cf17dfcad8a9f450a984b754d1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="315" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-466d68cf17dfcad8a9f450a984b754d1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-466d68cf17dfcad8a9f450a984b754d1_b.jpg"/></figure><p><a href="https://link.zhihu.com/?target=https%3A//keras.io/preprocessing/sequence/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">keras.io/preprocessing/</span><span class="invisible">sequence/</span><span class="ellipsis"></span></a></p><p>这里唯一的困难是我们还希望网络考虑股息。因此，我们必须编写一个函数，该函数使用TimeseriesGenerator类生成训练集，然后使用关于股息的信息丰富生成器的输出。</p><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">generate_series</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">value_num</span><span class="p">):</span>
    <span class="n">close</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Close&#39;</span><span class="p">]</span>
    <span class="n">dividends</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Dividends&#39;</span><span class="p">]</span>
    <span class="n">tsg</span> <span class="o">=</span> <span class="n">TimeseriesGenerator</span><span class="p">(</span><span class="n">close</span><span class="p">,</span> <span class="n">close</span><span class="p">,</span>
                              <span class="n">length</span><span class="o">=</span><span class="n">value_num</span><span class="p">,</span>
                              <span class="n">batch_size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">close</span><span class="p">))</span>
    <span class="n">global_index</span> <span class="o">=</span> <span class="n">value_num</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tsg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">has_dividends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">b_row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">b_row</span><span class="p">]</span> <span class="o">-</span> <span class="n">close</span><span class="p">[</span><span class="n">global_index</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mf">0.001</span><span class="p">)</span>
        <span class="n">has_dividends</span><span class="p">[</span><span class="n">b_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">dividends</span><span class="p">[</span><span class="n">global_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">global_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">has_dividends</span><span class="p">])),</span>
                           <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">t</span>
</code></pre></div><p>该函数接受两个参数：我们希望它处理的数据集（data参数）和序列应该具有的输入值的数量（value_num 参数）。</p><p>如你所知，神经网络是用梯度下降法训练的，采用梯度的成本函数。最简单的方法是假设我们使用整个数据集来计算成本函数梯度。然而，也有不利的一面。首先，数据集可能非常大，这使得计算梯度非常耗时。其次，如果数据集非常大，那么梯度值也可以非常大，非常大！以至于它根本不适合机器精度。一些人会指出，我们实际上并不需要确切的梯度值。我们只需要它的估计值来决定我们应该朝哪个方向移动，以最小化成本函数。因此，我们可以利用训练样本的一个小子集来估计梯度。当然，我们最终会遍历整个数据集，但是不需要一次计算整个数据集的梯度。我们可以将数据集划分为几个称为batch的子集，一次只处理一个batch。我们使用单批计算的梯度来更新网络的权值。一旦我们处理了所有的批次，我们可以说我们运行了一个单独的训练周期。在一次训练中，可能有多个epoch，具体的epoch数量取决于任务。同时，训练的例子必须打乱。这意味着随后的两个训练示例不能属于同一批。让我们测试这个函数并生成一个使用四个输入值的数据集。</p><div class="highlight"><pre><code class="language-python"><span class="n">inputs</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="n">generate_series</span><span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span></code></pre></div><p>让我们看一个例子：</p><div class="highlight"><pre><code class="language-python"><span class="c1"># print(inputs[3818])</span>
<span class="n">array</span><span class="p">([</span><span class="mf">1.246046e+04</span><span class="p">,</span> <span class="mf">1.232848e+04</span><span class="p">,</span> <span class="mf">1.244496e+04</span><span class="p">,</span> <span class="mf">1.274000e+04</span><span class="p">,</span>
       <span class="mf">1.000000e+00</span><span class="p">])</span></code></pre></div><p>我们可以看到，一个训练示例是一个带有4个价格和5个附加值的向量，该值表示当天是否支付股息。注意，值比较大。的确，价格范围从767.7到12740.0的神经网络在这样的范围内不能很好地工作，所以我们必须将数据归一化。我们将使用最简单的归一化方法：MinMax。</p><div class="highlight"><pre><code class="language-python"><span class="n">h_min</span> <span class="o">=</span> <span class="n">history</span><span class="o">.</span><span class="nb">min</span><span class="p">()</span>
<span class="n">normalized_h</span> <span class="o">=</span> <span class="p">(</span><span class="n">history</span> <span class="o">-</span> <span class="n">h_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">history</span><span class="o">.</span><span class="nb">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">h_min</span><span class="p">)</span></code></pre></div><p>重新生成数据集：</p><div class="highlight"><pre><code class="language-python"><span class="n">inputs</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="n">generate_series</span><span class="p">(</span><span class="n">normalized_h</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span></code></pre></div><p>看看数据归一化后的结果：<br/></p><div class="highlight"><pre><code class="language-python"><span class="c1"># print(inputs[3818])</span>
<span class="n">array</span><span class="p">([</span><span class="mf">0.9766511</span> <span class="p">,</span> <span class="mf">0.96562732</span><span class="p">,</span> <span class="mf">0.97535645</span><span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">])</span></code></pre></div><p>正如我们所看到的，这些值现在的范围是从0到1。这使得任务更容易了。然而，我们现在必须保留h.min()和h.max()，以便在预测价格时对网络输入进行规一化，并对其输出进行反规一化以获得准确的值。</p><p>最后，神经网络该出场了！网络将有(n+1)输入，n表示价格，1表示股息指标和一个输出。我们仍然需要确定n。为此，我们将编写一个函数来创建具有指定数量输入的神经网络。我们使用input_shape=(n+1,)表达式来包含股息指示器。</p><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">create_model</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Sequential</span><span class="p">()</span>
    <span class="n">m</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,)))</span>
    <span class="n">m</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
    <span class="n">m</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">m</span></code></pre></div><p>在训练网络之前，我们将数据集划分为两部分：训练集和测试集。在训练网络时，我们不会使用测试集的例子。</p><div class="highlight"><pre><code class="language-python"><span class="n">train_inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1000</span><span class="p">]</span>
<span class="n">val_inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="o">-</span><span class="mi">1000</span><span class="p">:]</span>
<span class="n">train_targets</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[:</span><span class="o">-</span><span class="mi">1000</span><span class="p">]</span>
<span class="n">val_targets</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="o">-</span><span class="mi">1000</span><span class="p">:]</span></code></pre></div><p>我们再写一个函数。这个函数将帮助我们决定网络应该有多少输入。这个函数接受输入的数量来检查要训练的epoch的数量。该函数将创建一个网络，为其准备数据，然后对网络进行训练，并在测试集中评估其性能。</p><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">select_inputs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
    <span class="n">models</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">inputs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Using {} inputs&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>
        <span class="n">model_inputs</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="n">generate_series</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
        
        <span class="n">train_inputs</span> <span class="o">=</span> <span class="n">model_inputs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1000</span><span class="p">]</span>
        <span class="n">val_inputs</span> <span class="o">=</span> <span class="n">model_inputs</span><span class="p">[</span><span class="o">-</span><span class="mi">1000</span><span class="p">:]</span>
        <span class="n">train_targets</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[:</span><span class="o">-</span><span class="mi">1000</span><span class="p">]</span>
        <span class="n">val_targets</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="o">-</span><span class="mi">1000</span><span class="p">:]</span>
        
        <span class="n">m</span> <span class="o">=</span> <span class="n">create_model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Training&#39;</span><span class="p">)</span>
        <span class="n">m</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;mse&#39;</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_inputs</span><span class="p">,</span> <span class="n">train_targets</span><span class="p">,</span>
                  <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
                  <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
                  <span class="n">validation_data</span><span class="o">=</span><span class="p">(</span><span class="n">val_inputs</span><span class="p">,</span> <span class="n">val_targets</span><span class="p">))</span>
        <span class="n">model_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;model&#39;</span><span class="p">:</span> <span class="n">m</span><span class="p">,</span> <span class="s1">&#39;history&#39;</span><span class="p">:</span> <span class="n">h</span><span class="o">.</span><span class="n">history</span><span class="p">}</span>
        <span class="n">models</span><span class="p">[</span><span class="n">inputs</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_info</span>
    <span class="k">return</span> <span class="n">models</span></code></pre></div><p>现在，让我们用2到10个输入为20个epoch训练网络：</p><div class="highlight"><pre><code class="language-python"><span class="n">dtrained_models</span> <span class="o">=</span> <span class="n">select_inputs</span><span class="p">(</span><span class="n">normalized_h</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span></code></pre></div><p>当训练完成后，我们可以用下面的代码得到一个简短的总结：</p><div class="highlight"><pre><code class="language-python"><span class="n">model_stats</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">trained_models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">train_history</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">]</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">train_history</span><span class="p">[</span><span class="s1">&#39;loss&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">val_loss</span> <span class="o">=</span> <span class="n">train_history</span><span class="p">[</span><span class="s1">&#39;val_loss&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">model_stats</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="n">loss</span><span class="p">,</span> <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="n">val_loss</span><span class="p">}</span></code></pre></div><p>打印model_stats值，我们可以看到摘要：</p><div class="highlight"><pre><code class="language-python"><span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="mf">6.159038594863468e-05</span><span class="p">,</span>
  <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="mf">0.0006709674960002303</span><span class="p">},</span>
 <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="mf">7.425233190960614e-05</span><span class="p">,</span>
  <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="mf">0.00021176348975859583</span><span class="p">},</span>
 <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
  <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="mf">7.471898652647588e-05</span><span class="p">,</span>
  <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="mf">0.00022580388654023408</span><span class="p">},</span>
 <span class="mi">5</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="mf">8.866131339595126e-05</span><span class="p">,</span>
  <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="mf">0.00027424713294021784</span><span class="p">},</span>
 <span class="mi">6</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
  <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="mf">7.322355930846842e-05</span><span class="p">,</span>
  <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="mf">0.0003323734663426876</span><span class="p">},</span>
 <span class="mi">7</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
  <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="mf">8.709070955596233e-05</span><span class="p">,</span>
  <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="mf">0.0004295352199114859</span><span class="p">},</span>
 <span class="mi">8</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
  <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="mf">8.170129280188121e-05</span><span class="p">,</span>
  <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="mf">0.00024587249546311797</span><span class="p">},</span>
 <span class="mi">9</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
  <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="mf">7.327485314296024e-05</span><span class="p">,</span>
  <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="mf">0.0003118165017804131</span><span class="p">},</span>
 <span class="mi">10</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="mf">8.064566193526276e-05</span><span class="p">,</span>
  <span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="mf">0.0003668071269057691</span><span class="p">}}</span></code></pre></div><p>我们可以看到，使用测试集计算的错误总是略大于为训练集计算的值。这意味着网络处理已知数据比处理未知数据稍微好一些。</p><p>现在，我们可以根据网络的输入值来绘制测试误差图。</p><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">val_loss</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">model_stats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">val_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;val_loss&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">val_loss</span><span class="p">)</span></code></pre></div><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-9ec9628e13d82f8e09b7eaf3f0a9bee3_b.jpg" data-caption="" data-size="normal" data-rawwidth="766" data-rawheight="480" class="origin_image zh-lightbox-thumb" width="766" data-original="https://pic4.zhimg.com/v2-9ec9628e13d82f8e09b7eaf3f0a9bee3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-9ec9628e13d82f8e09b7eaf3f0a9bee3_b.jpg" data-caption="" data-size="normal" data-rawwidth="766" data-rawheight="480" class="origin_image zh-lightbox-thumb lazy" width="766" data-original="https://pic4.zhimg.com/v2-9ec9628e13d82f8e09b7eaf3f0a9bee3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-9ec9628e13d82f8e09b7eaf3f0a9bee3_b.jpg"/></figure><p>通过这个图，我们可以看到哪个网络显示的测试错误最少。确切的结果可能会随着时间的推移而变化，这取决于雅虎财经历史数据的数量。</p><p>有一个有趣的现象。如果一个人运行这个脚本两次，那么他们将收到不同的结果。换句话说，最小的测试错误是由不同的网络产生的。由于网络之间的唯一区别是输入的数量，那么我们可以得出结论：<b>测试误差并不依赖于输入的数量有多少。这反过来支持了最初的推测，即我们无法用神经网络预测股价</b>。显然，网络训练忽略一些输入，结论是输出并不依赖于它们。</p><p>我们已经把数据进行了标准化。现在我们来计算网络的精确误差。</p><div class="highlight"><pre><code class="language-python"><span class="n">close_min</span> <span class="o">=</span> <span class="n">history</span><span class="p">[</span><span class="s1">&#39;Close&#39;</span><span class="p">]</span><span class="o">.</span><span class="nb">min</span><span class="p">()</span>
<span class="n">close_max</span> <span class="o">=</span> <span class="n">history</span><span class="p">[</span><span class="s1">&#39;Close&#39;</span><span class="p">]</span><span class="o">.</span><span class="nb">max</span><span class="p">()</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">model_stats</span><span class="p">:</span>
    <span class="n">e</span> <span class="o">=</span> <span class="p">((</span><span class="n">close_max</span> <span class="o">-</span> <span class="n">close_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">model_stats</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;val_loss&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">close_min</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span></code></pre></div><p>输出：</p><div class="highlight"><pre><code class="language-python"><span class="mf">2771.0400773414451</span>
<span class="mf">3770.341964375037</span>
<span class="mf">4771.6538168560887</span>
<span class="mf">5771.9637314503287</span>
<span class="mf">6770.3164239349957</span>
<span class="mf">7771.5147973106168</span>
<span class="mf">8778.0784490537151</span>
<span class="mf">9779.7546236891968</span>
<span class="mf">10770.8432766947052</span>
</code></pre></div><p>误差非常大！即使对于测试误差最小的网络，精确误差也是非常大的。反正，我们是不会相信用这样一个网络去买卖股票。</p><p>现在，我们画一个图来比较精确的价格和预测的价格。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-5c590c040a987ac726d3887c9e5271b8_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="529" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-5c590c040a987ac726d3887c9e5271b8_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-5c590c040a987ac726d3887c9e5271b8_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="529" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-5c590c040a987ac726d3887c9e5271b8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-5c590c040a987ac726d3887c9e5271b8_b.jpg"/></figure><h2><b><u><i>2、</i></u>总结</b></h2><p>对于未知数据，我们得到了较大的误差。这意味着该网络未能预测收盘价。或许，我们可以通过改变现有的网络结构来改善这一结果。但，我们不认为我们可以得到更多的数据，因为我们已经使用了所有可用的数据。使用不同公司的数据来训练一个网络是可能的，但是由于这些公司可能有不同的属性，它们的股价可能会根据不同的规律变化，这只会使网络混乱。</p><p>值得注意的是，<b>网络本身并不能预测股价</b>。相反，它它尝试使用给定的值猜测一个序列的下一个值是什么。这是因为价格没有编码下一次它会如何变化。如果价格上涨一段时间，就不能保证下一分钟不会下跌。<b>价格受外部事件的影响很大，这是网络所不知的。</b></p><p>或许，我们将能够使用神经网络进行<b>短期预测</b>，来确定<b>未来几分钟内的价格变化</b>。这可能是因为我们预测的时间段越短，外部事件发生的变化就越小。然而，在这种情况下，<b>最好使用线性回归模型来预测价格变化的方向。</b></p><p>如果我们仔细观察股价曲线，我们会发现它的变化是随机的。如果我们只有价格而不知道外部事件，这就是事实。因此，<b>股价看起来就像一个鞅</b>，这一个我们无法预测的过程。</p><p><b>鞅（Martingale）</b>于博弈论中的表示公平博弈的数学模型，在概率论中是满足下述条件的随机过程：已知过去某一时刻s以及之前所有时刻的观测值，若某一时刻t的观测值的条件期望等于过去某一时刻s的观测值，则称这一随机过程是鞅。所以</p><p><b>最好不要用神经网络来预测股价</b></p><p>参考资料</p><p>1、Bugorskij, V. Ispol’zovanie nejronnyh setej dlya modelirovaniya prognoza kotirovok cennyh bumag / V. Bugorskij, A. Sergienko // Prikladnaya informatika. — 2008. — T. № 3(15). (in Russian)</p><p>2、Chollet, F. Deep learning with python — 2017. — Manning Publications.</p><p>3、Elliot, A. Time Series Prediction : Predicting Stock Price / A. Elliot, C. H. Hsu // ArXiv e-prints. — 2017.</p><p>4、Ian Goodfellow. Deep Learning / Ian Goodfellow, Yoshua Bengio, Aaron Courville — MIT Press, 2016.</p><p>量化投资与机器学习微信公众号，是业内垂直于<b>Quant、MFE、Fintech、AI、ML</b>等领域的<b>量化类主流自媒体。</b>公众号拥有来自<b>公募、私募、券商、期货、银行、保险资管、海外</b>等众多圈内<b>18W+</b>关注者。每日发布行业前沿研究成果和最新量化资讯。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
