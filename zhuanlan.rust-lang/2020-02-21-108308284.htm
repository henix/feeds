<div class="title-image"><img src="https://pic4.zhimg.com/v2-3dfc36e0e68d4715ec042b5f3f8562a9_b.jpg" alt=""></div><p>稍作配置，同一份代码横跨 Android &amp; IOS，相比于 React Native 方案更加高性能。除此之外，得益于 Rust 跨平台加持，Rust 部分的代码可在种种场合复用。</p><p>这篇文章旨在记录作者尝试结合 Rust 和 Flutter 的过程，且仅为初步尝试。不会涉及诸如：</p><p> 如何搭建一个 Flutter 开发环境，以及 Dart 语言怎么用 </p><p> 如何搭建一个 Rust 开发环境，以及 Rust 语言怎么学</p><p class="ztext-empty-paragraph"><br/></p><p>开头给自己博客打波广告👇</p><a href="https://link.zhihu.com/?target=https%3A//blog.idx0.dev/2020/02/15/flutter-rust-1/" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-3dfc36e0e68d4715ec042b5f3f8562a9_180x120.jpg" data-image-width="1356" data-image-height="1070" class=" wrap external" target="_blank" rel="nofollow noreferrer">Rust + Flutter 高性能的跨端尝试</a><h2>Environment</h2><ul><li>Flutter: Android, IOS 工具配置妥当   </li></ul><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-c58477665a91f3af41629d66930fb2e2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1344" data-rawheight="420" class="origin_image zh-lightbox-thumb" width="1344" data-original="https://pic3.zhimg.com/v2-c58477665a91f3af41629d66930fb2e2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-c58477665a91f3af41629d66930fb2e2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1344" data-rawheight="420" class="origin_image zh-lightbox-thumb lazy" width="1344" data-original="https://pic3.zhimg.com/v2-c58477665a91f3af41629d66930fb2e2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-c58477665a91f3af41629d66930fb2e2_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><ul><li>Rust: Stable 就好   </li></ul><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-0370ff9fd40521e643ed14fa41c7186e_b.jpg" data-caption="" data-size="normal" data-rawwidth="1026" data-rawheight="204" class="origin_image zh-lightbox-thumb" width="1026" data-original="https://pic3.zhimg.com/v2-0370ff9fd40521e643ed14fa41c7186e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-0370ff9fd40521e643ed14fa41c7186e_b.jpg" data-caption="" data-size="normal" data-rawwidth="1026" data-rawheight="204" class="origin_image zh-lightbox-thumb lazy" width="1026" data-original="https://pic3.zhimg.com/v2-0370ff9fd40521e643ed14fa41c7186e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-0370ff9fd40521e643ed14fa41c7186e_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><h2>Rust Part</h2><h3>Prepare cross-platform toolchains &amp; deps</h3><h3>IOS</h3><div class="highlight"><pre><code class="language-text"># Download targets for IOS ( 64 bit targets (real device &amp; simulator) )
rustup target add aarch64-apple-ios x86_64-apple-ios 

# Install cargo-lipo to generate the iOS universal library
cargo install cargo-lipo</code></pre></div><h3>Android</h3><p><a href="https://link.zhihu.com/?target=https%3A//github.com/kennytm/rust-ios-android" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a>有一些行之有效的辅助脚本用于更加快捷配置交叉编译工具。</p><ol><li> 获取 Android NDK<br/> <code>sh sdkmanager --verbose ndk-bundle</code> 如果已经准备好了 Android NDK ，则设置环境变量 <code>$ANDROID_NDK_HOME</code> ```sh<br/> example:<br/> export ANDROID_NDK_HOME=/Users/yinsiwei/Downloads/android-ndk-r20b <code>2. Create the standalone NDK</code>sh<br/> $(pwd) == ~/Downloads<br/> git clone <a href="https://link.zhihu.com/?target=https%3A//github.com/kennytm/rust-ios-android.git" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/kennytm/rust</span><span class="invisible">-ios-android.git</span><span class="ellipsis"></span></a> cd rust-ios-android ./create-ndk-standalone.sh <code>3. 在 Cargo default config VS 配置 Android 交叉编译工具</code>sh cat cargo-config.toml &gt;&gt; ~/.cargo/config <code>执行上述命令后会在 Cargo 默认配置中，增加有关 Android 跨平台目标 (targets, `aarch64-linux-android`, `armv7-linux-androideabi`, `i686-linux-android`) 的工具信息，指向刚刚创建的 `standalone NDK`。</code>ini [target.aarch64-linux-android] ar = ... linker = ..<br/> [target.armv7-linux-androideabi] ...<br/> [target.i686-linux-android] .. <code>4. 下载 Rust 支持 Android 交叉编译的依赖</code>sh rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android ```<br/> </li></ol><h3>Start a simple rust library</h3><ol><li> 创建一个 Rust 项目<br/> <code>sh  cargo init my-app-base --lib</code><br/> </li><li> 编辑 <code>Cargo.toml</code> 修改 <code>crate-type</code><br/> <code>ini [lib] name = &#34;my_app_base&#34; crate-type = [&#34;staticlib&#34;, &#34;cdylib&#34;]</code> Rust 构建出来的二进制库，在 IOS 中是静态链接进最终的程序之中，需要对构建 <code>staticlib</code> 的支持；在 Android 是通过动态链接在运行时装在进程序运行空间的，需要对构建 <code>cdylib</code> 的支持。<br/> </li><li> 写一些符合 C ABI 的函数 <code>src/lib.rs</code><br/> ```rust use std::os::raw::c_char; use std::ffi::CString;<br/> [no_mangle]<br/> pub unsafe extern fn hello() -&gt; *const c_char {     let s = CString::new(&#34;world&#34;).unwrap();     s.into_raw() } ```<br/> 在上述代码中，每次当外部调用 <code>hello</code> 函数时，会在晋城堆空间中创建一个字符串 ( <code>CString</code> )，并将所有权 ( 释放该字符串所占堆空间的权利 ) 移交给<b>调用者</b>。<br/> </li></ol><h3>Build libraries</h3><div class="highlight"><pre><code class="language-text"># IOS
cargo lipo --release

# Android
cargo build --target aarch64-linux-android --release
cargo build --target armv7-linux-androideabi --release
cargo build --target i686-linux-android --release</code></pre></div><p>然后在 <code>target</code> 目录下会得到以下有用的物料。</p><div class="highlight"><pre><code class="language-text">target
    ├── aarch64-linux-android
    │   └── release
    │       ├── libmy_app_base.a
    │       └── libmy_app_base.so
    ├── armv7-linux-androideabi
    │   └── release
    │       ├── libmy_app_base.a
    │       └── libmy_app_base.so
    ├── i686-linux-android
    │   └── release
    │       ├── libmy_app_base.a
    │       └── libmy_app_base.so
    ├── universal
    │   └── release
    │       └── libmy_app_base.a</code></pre></div><p>至此， <code>Rust</code> 部分就告于段落了。</p><h2>Flutter Part</h2><h3>Copy build artifacts to flutter project</h3><div class="highlight"><pre><code class="language-text">from: target/universal/release/libmy_app_base.a 
to: ios/

from: target/aarch64-linux-android/release/libmy_app_base.so 
to: android/app/src/main/jniLibs/arm64-v8a/

from: target/armv7-linux-androideabi/release/libmy_app_base.so 
to: android/app/src/main/jniLibs/armeabi-v7a/

from: target/i686-linux-android/release/libmy_app_base.so 
to: android/app/src/main/jniLibs/x86/</code></pre></div><h3>Call FFI function in Dart</h3><ol><li> 添加依赖<br/> <code>pubspec.yaml</code> -&gt; <code>dev_dependencies:</code> += <code>ffi: ^0.1.3</code><br/> </li><li> 添加代码<br/> (直接在生成的项目上修改，暂不考虑代码设计问题，就简简单单的先把项目跑起来 ) ```dart import &#39;dart:ffi&#39;; import &#39;package:ffi/ffi.dart&#39;;<br/> // ... final dylib = Platform.isAndroid ? DynamicLibrary.open(&#39;libmy_app_base.so&#39;) :DynamicLibrary.process(); var hello = dylib.lookupFunction Function(),Pointer Function()&gt;(&#39;hello&#39;);<br/> // ... hello();  // -&gt; world ```<br/> </li></ol><h3>Build Android Project</h3><div class="highlight"><pre><code class="language-text">flutter run # 如果连接着 Android 设备就直接运行了起来</code></pre></div><h3>Build IOS Project</h3><p>( 复杂了许多 )</p><ol><li>跟随 <code>Flutter</code> <a href="https://link.zhihu.com/?target=https%3A//flutter.dev/docs/get-started/install/macos%23ios-setup" class=" wrap external" target="_blank" rel="nofollow noreferrer">官方文档</a>，配置 <code>XCode</code> 项目。</li><li>在 <code>Build Phases</code> 中 <code>Link Binary With Libraries</code> 添加 <code>libmy_app_base.a</code> 文件     (按照图上箭头点...)     </li></ol><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-62c13d1d4d69a0722b905ee192e71d27_b.jpg" data-caption="" data-size="normal" data-rawwidth="2280" data-rawheight="854" class="origin_image zh-lightbox-thumb" width="2280" data-original="https://pic4.zhimg.com/v2-62c13d1d4d69a0722b905ee192e71d27_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-62c13d1d4d69a0722b905ee192e71d27_b.jpg" data-caption="" data-size="normal" data-rawwidth="2280" data-rawheight="854" class="origin_image zh-lightbox-thumb lazy" width="2280" data-original="https://pic4.zhimg.com/v2-62c13d1d4d69a0722b905ee192e71d27_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-62c13d1d4d69a0722b905ee192e71d27_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><ol><li>在 <code>Build Settings</code> 中 <code>Other Linker Flags</code> 中添加 <code>force_load</code> 的参数。     </li></ol><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-042670ee855d25046ec7f98b8d0ed5cc_b.jpg" data-caption="" data-size="normal" data-rawwidth="1710" data-rawheight="680" class="origin_image zh-lightbox-thumb" width="1710" data-original="https://pic1.zhimg.com/v2-042670ee855d25046ec7f98b8d0ed5cc_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-042670ee855d25046ec7f98b8d0ed5cc_b.jpg" data-caption="" data-size="normal" data-rawwidth="1710" data-rawheight="680" class="origin_image zh-lightbox-thumb lazy" width="1710" data-original="https://pic1.zhimg.com/v2-042670ee855d25046ec7f98b8d0ed5cc_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-042670ee855d25046ec7f98b8d0ed5cc_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>这是由于在 Dart 中通过动态的方式调用了该库的相关函数，但在编译期间静态分析的时候，这些都是未曾被调用过的无用函数，就被剪裁掉了。要通过 <code>force_load</code> 方式解决这个问题。</p><h2>Result</h2><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-5dbdfd2f43bf2186abe37c802bee0815_b.gif" data-caption="" data-size="normal" data-rawwidth="904" data-rawheight="1710" data-thumbnail="https://pic2.zhimg.com/v2-5dbdfd2f43bf2186abe37c802bee0815_b.jpg" class="origin_image zh-lightbox-thumb" width="904" data-original="https://pic2.zhimg.com/v2-5dbdfd2f43bf2186abe37c802bee0815_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-5dbdfd2f43bf2186abe37c802bee0815_b.gif" data-caption="" data-size="normal" data-rawwidth="904" data-rawheight="1710" data-thumbnail="https://pic2.zhimg.com/v2-5dbdfd2f43bf2186abe37c802bee0815_b.jpg" class="origin_image zh-lightbox-thumb lazy" width="904" data-original="https://pic2.zhimg.com/v2-5dbdfd2f43bf2186abe37c802bee0815_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-5dbdfd2f43bf2186abe37c802bee0815_b.gif"/></figure><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-cac9f12ced5e34e3c14a8d5406fcea89_b.jpg" data-caption="" data-size="normal" data-rawwidth="1032" data-rawheight="1342" class="origin_image zh-lightbox-thumb" width="1032" data-original="https://pic2.zhimg.com/v2-cac9f12ced5e34e3c14a8d5406fcea89_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-cac9f12ced5e34e3c14a8d5406fcea89_b.jpg" data-caption="" data-size="normal" data-rawwidth="1032" data-rawheight="1342" class="origin_image zh-lightbox-thumb lazy" width="1032" data-original="https://pic2.zhimg.com/v2-cac9f12ced5e34e3c14a8d5406fcea89_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-cac9f12ced5e34e3c14a8d5406fcea89_b.jpg"/></figure><h2>Troubleshooting</h2><h3>XCode &amp; IOS</h3><h3>Error getting attached iOS device: ideviceinfo could not find device</h3><div class="highlight"><pre><code class="language-text">sudo xattr -d com.apple.quarantine ~/flutter/bin/cache/artifacts/libimobiledevice/ideviceinfo</code></pre></div><p>将后面的路径替换成你的</p><h3>dyld: Library not loaded</h3><div class="highlight"><pre><code class="language-text">dyld: Library not loaded: /b/s/w/ir/k/homebrew/Cellar/libimobiledevice-flutter/HEAD-398c120_3/lib/libimobiledevice.6.dylib
  Referenced from: /Users/hey/flutter/bin/cache/artifacts/libimobiledevice/idevice_id
  Reason: image not found</code></pre></div><p>删除&amp;重新下载</p><div class="highlight"><pre><code class="language-text">rm -rf /Users/hey/flutter/bin/cache &amp;&amp; flutter doctor -v</code></pre></div><h3>真机无法启动 Flutter 程序</h3><p>参见 <a href="https://link.zhihu.com/?target=https%3A//github.com/flutter/flutter/issues/49504%23issuecomment-581554697" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/flutter/flut</span><span class="invisible">ter/issues/49504#issuecomment-581554697</span><span class="ellipsis"></span></a> 不要升级到 IOS 13.3.1 系统</p><h2>What&#39;s next</h2><ul><li> 如何高效的实现 Rust &amp; Dart 部分的通信<br/> 我们知道 Flutter 和广大 GUI 库类似，属于单线程模型结合事件系统，因此在主线程中使用 FFI 调用 Rust 部分的代码不能阻塞线程。Dart 语言提供 async/await 语法特性用于在 Flutter 中处理网络请求等阻塞任务。而 Rust 也在最近版本中提供了 async/await 语法支持，如何优雅的把两部分结合起来，这是一个问题。<br/> </li><li> 对 MacOS Windows Linux 桌面端的支持<br/> Flutter 已经有了对桌面端的实验性支持，可以研究下如何结合在一起，实现跨 6 个端共享代码。<br/> </li></ul><h2>References</h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//github.com/kennytm/rust-ios-android" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/kennytm/rust</span><span class="invisible">-ios-android</span><span class="ellipsis"></span></a></li></ul><p>介绍了如何构建出 Android, IOS 库，并提供了例子 - <a href="https://link.zhihu.com/?target=https%3A//github.com/TimNN/cargo-lipo" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/TimNN/cargo-</span><span class="invisible">lipo</span><span class="ellipsis"></span></a></p><p>用于构建 universal library - <a href="https://link.zhihu.com/?target=https%3A//github.com/hanabi1224/flutter_native_extensions" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/hanabi1224/f</span><span class="invisible">lutter_native_extensions</span><span class="ellipsis"></span></a></p>