<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Coq 入门级技巧</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/54164515">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-f0468e697d9fd64d5729bfd4f46a770a_b.jpg" alt=""></div><p>我第一次听说 Coq 是在本科的时候。从那以后我就一直很想学 Coq，但是并不知道怎么开始。大部分的 Coq 教程都是在讲逻辑，我觉得并不是很有趣。</p><p>上个学期我选了 <a href="http://link.zhihu.com/?target=https%3A//sites.google.com/cs.washington.edu/cse-505-18au/home" class=" wrap external" target="_blank" rel="nofollow noreferrer">UW CSE505</a> 这门课。<a href="http://link.zhihu.com/?target=https%3A//homes.cs.washington.edu/%7Eztatlock/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Prof. Zach Tatlock</a> 和 TA <a href="http://link.zhihu.com/?target=https%3A//tlringer.github.io/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Talia Ringer</a> 设计了一系列非常棒的作业来帮我们学习 Coq。在这个课里面，我们证明了一些更加实际的东西，包括一个简单的编程语言的解释器还有一个简单的正则表达式引擎。事实上，我发现我对在 Coq 里面写证明还蛮在行的（但是写规范就完全是另外一回事了），至少在做作业的时候我是这么觉得的。</p><p>如果你在自学 Coq，我推荐以下资源：</p><ul><li><a href="http://link.zhihu.com/?target=https%3A//sites.google.com/cs.washington.edu/cse-505-18au/home" class=" wrap external" target="_blank" rel="nofollow noreferrer">UW CSE505</a> 的作业</li><li><a href="http://link.zhihu.com/?target=http%3A//adam.chlipala.net/frap/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Formal Reasoning About Programs</a> 这本书是我们上课的教材。这本书很短，边距很大，空白很多，每一章附带了详细的 Coq 代码。这本书还自带了一个很好用的 Coq 库 <code>frap</code>。</li><li><a href="http://link.zhihu.com/?target=https%3A//softwarefoundations.cis.upenn.edu/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Software Foundations</a> 如果你真的对形式化验证很感兴趣的话。</li></ul><p>我非常高兴我终于能把 Coq 从我的愿望单里面划掉了。不过我并不是形式化验证的狂热粉丝，我觉得我之后也不用用到 Coq。我决定趁我还没完全忘记 Coq，赶紧把我做作业时学会的 Coq 技巧写下来，万一以后哪天我又用到 Coq 了呢，希望也对读者有所帮助。</p><h2>Tactics</h2><p>虽然说我并不是很能理解 Coq 官方的文档，但是有问题的时候看看还是有帮助的：<a href="http://link.zhihu.com/?target=https%3A//coq.inria.fr/refman/coq-tacindex.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">coq.inria.fr/refman/coq</span><span class="invisible">-tacindex.html</span><span class="ellipsis"></span></a>.</p><h2><code>intros</code></h2><p><code>intros</code> 从目标中按照顺序引入假设。每一次它会消耗 <code>forall</code> 里面的一个自由变量，或者是一个 <code>-&gt;</code> 前面的命题（也就是前提条件）。举个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Theorem</span> <span class="n">Transform_transform</span><span class="o">:</span>
  <span class="k">forall</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">,</span>
    <span class="n">Transform</span> <span class="n">c1</span> <span class="n">c2</span> <span class="o">-&gt;</span>
    <span class="n">transform</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span>
</code></pre></div><p><code>intros c1 c2 H.</code> 之后：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">c1</span> <span class="n">c2</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">transform</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span>
</code></pre></div><p>另外，你也可以用 <code>intros.</code> 来引入所有的假设，Coq 会自动给他们命名。</p><h2><code>simpl</code></h2><p><code>simpl.</code> 能化简目标。 <code>simpl in H.</code> 化简假设 <code>H</code>. <code>simpl in *.</code> 化简所有的假设和目标。当你不知道证明下一步怎么走的时候，总是可以试试 <code>simpl in *.</code>，看有没有发生什么变化。</p><h2><code>simplify</code> (Frap Tactic)</h2><p><code>simplify.</code> 是 <code>frap</code> 库里面一个更强版本的 <code>simpl in *.</code>。我个人总是使用 <code>simplify</code> 来替代 <code>simpl</code>，如果有引入 <code>frap</code> 库的话。</p><h2><code>destruct</code></h2><p>假设 <code>x</code> 是一个归纳类型，当你 <code>destruct x.</code>，Coq 会为每一个构造函数生成一个小目标。换句话说，<code>destruct</code> 让你可以分类讨论所有可能的情况。</p><p>让我们先看一个简单的例子。假设我们有这么一个递归类型：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Inductive</span> <span class="n">cmd</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">Skip</span>
<span class="o">|</span> <span class="n">Assign</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">arith</span><span class="o">)</span>
<span class="o">|</span> <span class="n">Sequence</span> <span class="o">(</span><span class="n">c1</span> <span class="n">c2</span> <span class="o">:</span> <span class="n">cmd</span><span class="o">)</span>
<span class="o">|</span> <span class="n">If</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">arith</span><span class="o">)</span> <span class="o">(</span><span class="n">then_</span> <span class="n">else_</span> <span class="o">:</span> <span class="n">cmd</span><span class="o">)</span>
<span class="o">|</span> <span class="n">While</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">arith</span><span class="o">)</span> <span class="o">(</span><span class="n">body</span> <span class="o">:</span> <span class="n">cmd</span><span class="o">).</span>
</code></pre></div><p>我们想要证明：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Theorem</span> <span class="n">transform_Transform</span><span class="o">:</span>
  <span class="k">forall</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">,</span>
    <span class="n">transform</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-&gt;</span>
    <span class="n">Transform</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">.</span>
</code></pre></div><p>如果我们 <code>destruct c2.</code>，我们会看到 <code>c2</code> 被各个构造函数替换掉了:</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="mi">5</span> <span class="n">subgoals</span>
<span class="n">c1</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="o">)</span>
<span class="n">transform</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">Skip</span> <span class="o">-&gt;</span> <span class="n">Transform</span> <span class="n">c1</span> <span class="n">Skip</span>
<span class="o">______________________________________(</span><span class="mi">2</span><span class="o">/</span><span class="mi">5</span><span class="o">)</span>
<span class="n">transform</span> <span class="n">c1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Assign</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Transform</span> <span class="n">c1</span> <span class="o">(</span><span class="n">Assign</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span>
<span class="o">______________________________________(</span><span class="mi">3</span><span class="o">/</span><span class="mi">5</span><span class="o">)</span>
<span class="n">transform</span> <span class="n">c1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">c2_1</span> <span class="n">c2_2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Transform</span> <span class="n">c1</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">c2_1</span> <span class="n">c2_2</span><span class="o">)</span>
<span class="o">______________________________________(</span><span class="mi">4</span><span class="o">/</span><span class="mi">5</span><span class="o">)</span>
<span class="n">transform</span> <span class="n">c1</span> <span class="o">=</span> <span class="o">(</span><span class="n">If</span> <span class="n">e</span> <span class="n">c2_1</span> <span class="n">c2_2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Transform</span> <span class="n">c1</span> <span class="o">(</span><span class="n">If</span> <span class="n">e</span> <span class="n">c2_1</span> <span class="n">c2_2</span><span class="o">)</span>
<span class="o">______________________________________(</span><span class="mi">5</span><span class="o">/</span><span class="mi">5</span><span class="o">)</span>
<span class="n">transform</span> <span class="n">c1</span> <span class="o">=</span> <span class="o">(</span><span class="n">While</span> <span class="n">e</span> <span class="n">c2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Transform</span> <span class="n">c1</span> <span class="o">(</span><span class="n">While</span> <span class="n">e</span> <span class="n">c2</span><span class="o">)</span>
</code></pre></div><p>注意到，Coq 里面许多东西都是归纳类型，你可以用 <code>destruct</code> 来“打开”他们，比如这个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H</span> <span class="o">:</span> <span class="k">exists</span> <span class="n">a</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">,</span> <span class="n">In</span> <span class="n">a</span> <span class="o">(</span><span class="n">wl</span> <span class="o">++</span> <span class="n">adjacent</span> <span class="n">t</span> <span class="n">g</span><span class="o">)</span> <span class="o">/\</span> <span class="n">Reachable</span> <span class="n">g</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div><p>假设 <code>H</code> 告诉我们存在一个 <code>a</code> 能够使得后面的命题成立，但是我们如何把这个实例给取出来呢？如果我们关闭 Coq 的记号显示（<i>notation display</i>），我们可以看到 <code>H</code> 实际上是：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H</span> <span class="o">:</span> <span class="n">ex</span> <span class="o">(</span><span class="k">fun</span> <span class="n">a</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">=&gt;</span> <span class="n">and</span> <span class="o">(</span><span class="n">In</span> <span class="n">a</span> <span class="o">(</span><span class="n">app</span> <span class="n">wl</span> <span class="o">(</span><span class="n">adjacent</span> <span class="n">t</span> <span class="n">g</span><span class="o">)))</span> <span class="o">(</span><span class="n">Reachable</span> <span class="n">g</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
</code></pre></div><p>然后如果你 <code>Print ex.</code>：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Inductive</span> <span class="n">ex</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">_</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="n">ex_intro</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(_</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span><span class="o">),</span> <span class="n">ex</span> <span class="n">P</span>
</code></pre></div><p><code>ex</code> 也是一个归纳类型。所以说我们可以用 <code>destruct H.</code> 把这个实例取出来：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">x</span> <span class="o">:</span> <span class="kn">Set</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">In</span> <span class="n">x</span> <span class="o">(</span><span class="n">wl</span> <span class="o">++</span> <span class="n">adjacent</span> <span class="n">t</span> <span class="n">g</span><span class="o">)</span> <span class="o">/\</span> <span class="n">Reachable</span> <span class="n">g</span> <span class="n">x</span> <span class="n">b</span>
</code></pre></div><p>现在我们有了这个实例，虽然说它叫做 <code>x</code> 而不是 <code>a</code>。然后我们现在怎么把 <code>/\</code> 打开呢？再来一次 <code>destruct H.</code>：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">x</span> <span class="o">:</span> <span class="kn">Set</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">In</span> <span class="n">x</span> <span class="o">(</span><span class="n">wl</span> <span class="o">++</span> <span class="n">adjacent</span> <span class="n">t</span> <span class="n">g</span><span class="o">)</span>
<span class="n">H1</span> <span class="o">:</span> <span class="n">Reachable</span> <span class="n">g</span> <span class="n">x</span> <span class="n">b</span>
</code></pre></div><p>这是因为 <code>and</code> 也是一个归纳类型。你可以用 <code>Print and.</code> 验证一下:</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Inductive</span> <span class="n">and</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">conj</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">/\</span> <span class="n">B</span><span class="o">.</span>
</code></pre></div><p>那 <code>\/</code> 怎么样呢？<code>Print or.</code>：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Inductive</span> <span class="n">or</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">or_introl</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">\/</span> <span class="n">B</span>
<span class="o">|</span> <span class="n">or_intror</span> <span class="o">:</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">\/</span> <span class="n">B</span><span class="o">.</span>
</code></pre></div><p>所以说你也一样可以用 <code>destruct</code> 打开一个 <code>\/</code>，然后它会变成两个小目标。这很合理，从逻辑上来说，当你知道 <code>A \/ B</code> 成立，你需要讨论两个情况：<code>A</code> 成立以及 <code>B</code> 成立.</p><h2><code>induction</code></h2><p><code>induction</code> 是总重要的招数之一。你可以 <code>induction</code> 一个归纳类型（<i>inductive type</i>），会产生和这个归纳类型的构造函数数量一样多的小目标。如果构造函数里面用到了这个归纳类型本身，那么在归纳的过程中会产生相应的归纳假设。</p><p>一开始的时候，我把 <code>induction</code> 和数学归纳法搞混了。要用数学归纳法证明一个命题 <code>P</code>，你需要先证明一个基础步骤 <code>P(0)</code>，然后在 <code>P(n)</code> 成立的情况下证明一个递推步骤 <code>P(n+1)</code>。但是在 <code>induction</code> 里面没有“基础步骤”和“递推步骤”之分，甚至 <code>induction</code> 产生的小目标的数量都不一定等于2。</p><p>之后，我发现你可以把 <code>induction</code> 理解成数学归纳法的一种扩展。数学归纳法是作用在自然数上面的，而自然数是一种递归定义的归纳类型：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Inductive</span> <span class="kt">nat</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">O</span> <span class="o">:</span> <span class="kt">nat</span>
<span class="o">|</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">nat</span> <span class="o">-&gt;</span> <span class="kt">nat</span><span class="o">.</span>
</code></pre></div><p>所以说当你在 <code>induction</code> 一个 <code>nat</code> 的时候，你实际上就是在进行数学归纳法。另外一方面，你也可以把 <code>induction</code> 想成作用在结构上面。</p><p>先举一个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Lemma</span> <span class="n">len_repeat</span><span class="o">:</span>
  <span class="k">forall</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="o">(</span><span class="kr">repeat</span> <span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="n">s</span><span class="o">.</span>
</code></pre></div><p>在 <code>induction</code> 一个变量的时候，Coq <code>intros</code> 直到这个变量出现在假设中。所以说我们可以直接 <code>induction n.</code>，这等同于 <code>intros s n. induction n.</code>。</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">s</span> <span class="o">:</span> <span class="n">var</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span>
<span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="o">(</span><span class="kr">repeat</span> <span class="n">s</span> <span class="mi">0</span><span class="o">)</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="n">s</span>
<span class="o">______________________________________(</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span>
<span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="o">(</span><span class="kr">repeat</span> <span class="n">s</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">))</span> <span class="o">=</span> <span class="n">S</span> <span class="n">n</span> <span class="o">*</span> <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="n">s</span>
</code></pre></div><p>你可以看到这里变成了两个小目标。一个是 <code>0</code>，另一个是 <code>S n</code>。注意到在第一个小目标里面没有归纳假设，因为 <code>O</code> 不是递归定义的。完成了第一个小目标之后，我们可以看到第二个小目标：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">s</span> <span class="o">:</span> <span class="n">var</span>
<span class="n">n</span> <span class="o">:</span> <span class="kt">nat</span>
<span class="n">IHn</span> <span class="o">:</span> <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="o">(</span><span class="kr">repeat</span> <span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="n">s</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="o">(</span><span class="kr">repeat</span> <span class="n">s</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">))</span> <span class="o">=</span> <span class="n">S</span> <span class="n">n</span> <span class="o">*</span> <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="n">s</span>
</code></pre></div><p>因为 <code>S</code> 是递归定义的，所以这里就出现了归纳假设 <code>IHn</code>。</p><p>让我们再看另一个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Inductive</span> <span class="n">Transform</span>  <span class="o">:</span> <span class="n">cmd</span> <span class="o">-&gt;</span> <span class="n">cmd</span> <span class="o">-&gt;</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">TransformSkip</span><span class="o">:</span> 
    <span class="n">Transform</span> <span class="n">Skip</span> <span class="n">Skip</span>
<span class="o">|</span> <span class="n">TransformAssign</span><span class="o">:</span> <span class="k">forall</span> <span class="n">v</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">Transform</span> <span class="o">(</span><span class="n">Assign</span> <span class="n">v</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">Assign</span> <span class="n">v</span> <span class="n">e</span><span class="o">)</span>
<span class="o">|</span> <span class="n">TransformSeq</span><span class="o">:</span> <span class="k">forall</span> <span class="n">c1</span> <span class="n">c2</span> <span class="n">tc1</span> <span class="n">tc2</span><span class="o">,</span>
    <span class="n">Transform</span> <span class="n">c1</span> <span class="n">tc1</span> <span class="o">-&gt;</span>
    <span class="n">Transform</span> <span class="n">c2</span> <span class="n">tc2</span> <span class="o">-&gt;</span>
    <span class="n">Transform</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">)</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">tc1</span> <span class="n">tc2</span><span class="o">)</span>
<span class="o">|</span> <span class="n">TransformIf</span><span class="o">:</span> <span class="k">forall</span> <span class="n">e</span> <span class="n">then_</span> <span class="n">else_</span> <span class="n">tthen</span> <span class="n">telse</span><span class="o">,</span>
    <span class="n">Transform</span> <span class="n">then_</span> <span class="n">tthen</span> <span class="o">-&gt;</span>
    <span class="n">Transform</span> <span class="n">else_</span> <span class="n">telse</span> <span class="o">-&gt;</span>
    <span class="n">Transform</span> <span class="o">(</span><span class="n">If</span> <span class="n">e</span> <span class="n">then_</span> <span class="n">else_</span><span class="o">)</span> <span class="o">(</span><span class="n">If</span> <span class="n">e</span> <span class="n">telse</span> <span class="n">tthen</span><span class="o">)</span>
<span class="o">|</span> <span class="n">TransformWhile</span><span class="o">:</span> <span class="k">forall</span> <span class="n">e</span> <span class="n">body</span> <span class="n">tbody</span><span class="o">,</span>
    <span class="n">Transform</span> <span class="n">body</span> <span class="n">tbody</span> <span class="o">-&gt;</span>
    <span class="n">Transform</span> <span class="o">(</span><span class="n">While</span> <span class="n">e</span> <span class="n">body</span><span class="o">)</span> <span class="o">(</span><span class="n">While</span> <span class="n">e</span> <span class="n">tbody</span><span class="o">).</span>

<span class="kn">Theorem</span> <span class="n">Transform_transform</span><span class="o">:</span>
  <span class="k">forall</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">,</span>
    <span class="n">Transform</span> <span class="n">c1</span> <span class="n">c2</span> <span class="o">-&gt;</span>
    <span class="n">transform</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span>
</code></pre></div><p>我们可以用 <code>induction 1.</code> 来开始证明。<code>induction n</code> 会不断地 <code>intros</code> 直到第 <code>n</code> 个命题已经引入到了假设里面，然后对这个命题进行归纳。在这个例子里面，<code>induction 1.</code> 和 <code>intros c1 c2 H. induction H.</code> 是一样的效果。然后我们可以看到：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="mi">5</span> <span class="n">subgoals</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="o">)</span>
<span class="n">transform</span> <span class="n">Skip</span> <span class="o">=</span> <span class="n">Skip</span>
<span class="o">______________________________________(</span><span class="mi">2</span><span class="o">/</span><span class="mi">5</span><span class="o">)</span>
<span class="n">transform</span> <span class="o">(</span><span class="n">Assign</span> <span class="n">v</span> <span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="n">Assign</span> <span class="n">v</span> <span class="n">e</span>
<span class="o">______________________________________(</span><span class="mi">3</span><span class="o">/</span><span class="mi">5</span><span class="o">)</span>
<span class="n">transform</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">)</span> <span class="o">=</span> <span class="n">Sequence</span> <span class="n">tc1</span> <span class="n">tc2</span>
<span class="o">______________________________________(</span><span class="mi">4</span><span class="o">/</span><span class="mi">5</span><span class="o">)</span>
<span class="n">transform</span> <span class="o">(</span><span class="n">If</span> <span class="n">e</span> <span class="n">then_</span> <span class="n">else_</span><span class="o">)</span> <span class="o">=</span> <span class="n">If</span> <span class="n">e</span> <span class="n">telse</span> <span class="n">tthen</span>
<span class="o">______________________________________(</span><span class="mi">5</span><span class="o">/</span><span class="mi">5</span><span class="o">)</span>
<span class="n">transform</span> <span class="o">(</span><span class="n">While</span> <span class="n">e</span> <span class="n">body</span><span class="o">)</span> <span class="o">=</span> <span class="n">While</span> <span class="n">e</span> <span class="n">tbody</span>
</code></pre></div><p>对于每一个 <code>Transform</code> 的构造函数，我们都有一个对应的小目标。让我们看一下第四个小目标：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">e</span> <span class="o">:</span> <span class="n">arith</span>
<span class="n">then_</span><span class="o">,</span> <span class="n">else_</span><span class="o">,</span> <span class="n">tthen</span><span class="o">,</span> <span class="n">telse</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">then_</span> <span class="n">tthen</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">else_</span> <span class="n">telse</span>
<span class="n">IHTransform1</span> <span class="o">:</span> <span class="n">transform</span> <span class="n">then_</span> <span class="o">=</span> <span class="n">tthen</span>
<span class="n">IHTransform2</span> <span class="o">:</span> <span class="n">transform</span> <span class="n">else_</span> <span class="o">=</span> <span class="n">telse</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">transform</span> <span class="o">(</span><span class="n">If</span> <span class="n">e</span> <span class="n">then_</span> <span class="n">else_</span><span class="o">)</span> <span class="o">=</span> <span class="n">If</span> <span class="n">e</span> <span class="n">telse</span> <span class="n">tthen</span>
</code></pre></div><p>我们可以看到这里有两个归纳假设（<code>IHTransform1</code> 和 <code>IHTransform2</code>），因为构造函数 <code>TransformIf</code> 有两个递归定义的前提条件。</p><h2><code>inversion</code></h2><p>在我看来，<code>inversion</code> 是最常用最强大的招数之一。我对 <code>inversion H.</code> 的理解是，它让 Coq 找出来要让 <code>H</code> 成立还有哪些事情要成立。它有可能会添加新的假设，也可能会添加新的小目标。</p><p>一个常见的用途是说明一个等式两边的构造函数里面的对应的部分是相同的。你也可以把 <code>inversion</code> 理解成“打开盒子”。举个例子，这里 <code>If</code> 是一个归纳类型的构造函数：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H</span> <span class="o">:</span> <span class="n">If</span> <span class="n">e</span> <span class="o">(</span><span class="n">transform</span> <span class="n">c1_2</span><span class="o">)</span> <span class="o">(</span><span class="n">transform</span> <span class="n">c1_1</span><span class="o">)</span> <span class="o">=</span> <span class="n">If</span> <span class="n">e0</span> <span class="n">c2_1</span> <span class="n">c2_2</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">Transform</span> <span class="o">(</span><span class="n">If</span> <span class="n">e</span> <span class="n">c1_1</span> <span class="n">c1_2</span><span class="o">)</span> <span class="o">(</span><span class="n">If</span> <span class="n">e0</span> <span class="n">c2_1</span> <span class="n">c2_2</span><span class="o">)</span>
</code></pre></div><p>在 <code>inversion H.</code> 之后变成:</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H</span> <span class="o">:</span> <span class="n">If</span> <span class="n">e</span> <span class="o">(</span><span class="n">transform</span> <span class="n">c1_2</span><span class="o">)</span> <span class="o">(</span><span class="n">transform</span> <span class="n">c1_1</span><span class="o">)</span> <span class="o">=</span> <span class="n">If</span> <span class="n">e0</span> <span class="n">c2_1</span> <span class="n">c2_2</span>
<span class="n">H1</span> <span class="o">:</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e0</span>
<span class="n">H2</span> <span class="o">:</span> <span class="n">transform</span> <span class="n">c1_2</span> <span class="o">=</span> <span class="n">c2_1</span>
<span class="n">H3</span> <span class="o">:</span> <span class="n">transform</span> <span class="n">c1_1</span> <span class="o">=</span> <span class="n">c2_2</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">Transform</span> <span class="o">(</span><span class="n">If</span> <span class="n">e0</span> <span class="n">c1_1</span> <span class="n">c1_2</span><span class="o">)</span> <span class="o">(</span><span class="n">If</span> <span class="n">e0</span> <span class="o">(</span><span class="n">transform</span> <span class="n">c1_2</span><span class="o">)</span> <span class="o">(</span><span class="n">transform</span> <span class="n">c1_1</span><span class="o">))</span>
</code></pre></div><p><code>Coq</code> 为我们找到了三个非常有用的关系。顺带一提，<code>inversion</code> 和 <code>subst</code> 搭配使用效果更佳，因为 <code>subst</code> 可以把 <code>inversion</code> 发现的等式带入并化简，让假设看起来更加清楚。另外，如果在 <code>inversion H; subst.</code> 之后你发现假设列表里面唯一的变化就是多了一条和 <code>H</code> 一模一样的假设，那么你就知道说这个时候 <code>inversion H.</code> 完全没有作用。</p><p>实际上，<code>=</code> 没有任何特殊之处，因为它只不过是一个叫做 <code>eq</code> 的归纳类型。让我们看看一个稍微复杂一点的例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Inductive</span> <span class="n">Transform</span>  <span class="o">:</span> <span class="n">cmd</span> <span class="o">-&gt;</span> <span class="n">cmd</span> <span class="o">-&gt;</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">TransformSkip</span><span class="o">:</span> 
    <span class="n">Transform</span> <span class="n">Skip</span> <span class="n">Skip</span>
<span class="o">|</span> <span class="n">TransformSeq</span><span class="o">:</span> <span class="k">forall</span> <span class="n">c1</span> <span class="n">c2</span> <span class="n">tc1</span> <span class="n">tc2</span><span class="o">,</span>
    <span class="n">Transform</span> <span class="n">c1</span> <span class="n">tc1</span> <span class="o">-&gt;</span>
    <span class="n">Transform</span> <span class="n">c2</span> <span class="n">tc2</span> <span class="o">-&gt;</span>
    <span class="n">Transform</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">)</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">tc1</span> <span class="n">tc2</span><span class="o">)</span>
<span class="o">|</span> <span class="n">TransformIf</span><span class="o">:</span> <span class="k">forall</span> <span class="n">e</span> <span class="n">then_</span> <span class="n">else_</span> <span class="n">tthen</span> <span class="n">telse</span><span class="o">,</span>
    <span class="n">Transform</span> <span class="n">then_</span> <span class="n">tthen</span> <span class="o">-&gt;</span>
    <span class="n">Transform</span> <span class="n">else_</span> <span class="n">telse</span> <span class="o">-&gt;</span>
    <span class="n">Transform</span> <span class="o">(</span><span class="n">If</span> <span class="n">e</span> <span class="n">then_</span> <span class="n">else_</span><span class="o">)</span> <span class="o">(</span><span class="n">If</span> <span class="n">e</span> <span class="n">telse</span> <span class="n">tthen</span><span class="o">)</span>
<span class="c">(* Other constructors omitted *)</span><span class="o">.</span>

<span class="kn">Inductive</span> <span class="n">step_buggy</span> <span class="o">:</span> <span class="n">valuation</span> <span class="o">*</span> <span class="n">cmd</span> <span class="o">-&gt;</span> <span class="n">valuation</span> <span class="o">*</span> <span class="n">cmd</span> <span class="o">-&gt;</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">StepBuggySeq1</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">v</span> <span class="n">c1</span> <span class="n">c2</span> <span class="n">v'</span> <span class="n">c1'</span><span class="o">,</span>
    <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">c1</span><span class="o">)</span> <span class="o">(</span><span class="n">v'</span><span class="o">,</span> <span class="n">c1'</span><span class="o">)</span>
    <span class="o">-&gt;</span> <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">Sequence</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">)</span> <span class="o">(</span><span class="n">v'</span><span class="o">,</span> <span class="n">Sequence</span> <span class="n">c1'</span> <span class="n">c2</span><span class="o">)</span>
<span class="o">|</span> <span class="n">StepBuggySeq2</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">v</span> <span class="n">c2</span><span class="o">,</span>
    <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">Sequence</span> <span class="n">Skip</span> <span class="n">c2</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span>
<span class="c">(* Other constructors omitted *)</span><span class="o">.</span>
</code></pre></div><p>假设我们有：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="mi">1</span> <span class="n">subgoal</span>
<span class="n">v</span> <span class="o">:</span> <span class="n">valuation</span>
<span class="n">c2</span><span class="o">,</span> <span class="n">c1'</span><span class="o">,</span> <span class="n">c2'</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">Transform</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">Skip</span> <span class="n">c2</span><span class="o">)</span> <span class="n">c1'</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">c1'</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">c2'</span><span class="o">)</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">Transform</span> <span class="n">c2</span> <span class="n">c2'</span>
</code></pre></div><p>在 <code>inversion H; subst.</code> 之后:</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">v</span> <span class="o">:</span> <span class="n">valuation</span>
<span class="n">c2</span><span class="o">,</span> <span class="n">c2'</span><span class="o">,</span> <span class="n">tc1</span><span class="o">,</span> <span class="n">tc2</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">Transform</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">Skip</span> <span class="n">c2</span><span class="o">)</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">tc1</span> <span class="n">tc2</span><span class="o">)</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">tc1</span> <span class="n">tc2</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">c2'</span><span class="o">)</span>
<span class="n">H3</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">Skip</span> <span class="n">tc1</span>
<span class="n">H5</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">c2</span> <span class="n">tc2</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">Transform</span> <span class="n">c2</span> <span class="n">c2'</span>
</code></pre></div><p>让我来解释一下发生了什么。<code>H</code> 匹配上了 <code>TransformSeq</code> 构造函数，所以我们多了两个假设，也就是 <code>TransformSeq</code> 的两个前提条件（<code>H3</code> 和 <code>H5</code>）。从这个构造函数里面，我们还知道了 <code>c1'</code> 一定也是一个 <code>Sequence</code>，所以说这里 <code>c1'</code> 被替换成了 <code>(Sequence tc1 tc2)</code>。现在，让我们进入下一步，<code>inversion H3; subst.</code>：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">v</span> <span class="o">:</span> <span class="n">valuation</span>
<span class="n">c2</span><span class="o">,</span> <span class="n">c2'</span><span class="o">,</span> <span class="n">tc2</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">Transform</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">Skip</span> <span class="n">c2</span><span class="o">)</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">Skip</span> <span class="n">tc2</span><span class="o">)</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">Skip</span> <span class="n">tc2</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">c2'</span><span class="o">)</span>
<span class="n">H3</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">Skip</span> <span class="n">Skip</span>
<span class="n">H5</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">c2</span> <span class="n">tc2</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">Transform</span> <span class="n">c2</span> <span class="n">c2'</span>
</code></pre></div><p>我们可以看到 <code>tc1</code> 被替换成了 <code>Skip</code>，因为我们知道 <code>H3 : Transform Skip tc1</code> 成立，而唯一能匹配的就是 <code>TransformSkip</code> 构造函数，从这里面我们可以知道 <code>tc1</code> 就是 <code>Skip</code>。现在让我们 <code>inversion H0; subst.</code>：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">v</span> <span class="o">:</span> <span class="n">valuation</span>
<span class="n">c2</span><span class="o">,</span> <span class="n">tc2</span><span class="o">,</span> <span class="n">c1'</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">Transform</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">Skip</span> <span class="n">c2</span><span class="o">)</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">Skip</span> <span class="n">tc2</span><span class="o">)</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">Skip</span> <span class="n">tc2</span><span class="o">))</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">c1'</span> <span class="n">tc2</span><span class="o">))</span>
<span class="n">H2</span> <span class="o">:</span> <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">Skip</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">c1'</span><span class="o">)</span>
<span class="n">H3</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">Skip</span> <span class="n">Skip</span>
<span class="n">H5</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">c2</span> <span class="n">tc2</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span>
<span class="n">Transform</span> <span class="n">c2</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">c1'</span> <span class="n">tc2</span><span class="o">)</span>
<span class="o">______________________________________(</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span>
<span class="n">Transform</span> <span class="n">c2</span> <span class="n">c2'</span>
</code></pre></div><p>因为这里有两个 <code>step_buggy</code> 构造函数能匹配上 <code>H0</code>，所以这两个情况我们都需要讨论，所以说这里产生了两个小目标。这种分类讨论的感觉就有点像 <code>destruct</code>。</p><p>那如果一个构造函数都匹配不上呢？比方说下面这个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H</span> <span class="o">:</span> <span class="n">None</span> <span class="o">=</span> <span class="n">Some</span> <span class="bp">true</span>
</code></pre></div><p>这个时候 <code>inversion H.</code> 就能结束证明，因为这种情况根本不可能出现。</p><h2><code>f_equal</code></h2><p>当目标是一个归纳类型的构造函数等于同一个构造函数的时候，你可以用 <code>f_equal.</code> 转换成证明其中对应的部分是相同的。比方说，</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">v</span> <span class="o">:</span> <span class="n">valuation</span>
<span class="n">e</span> <span class="o">:</span> <span class="n">arith</span>
<span class="n">body</span><span class="o">,</span> <span class="n">tbody</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">Sequence</span> <span class="o">(</span><span class="n">transform</span> <span class="n">body</span><span class="o">)</span> <span class="o">(</span><span class="n">While</span> <span class="n">e</span> <span class="o">(</span><span class="n">transform</span> <span class="n">body</span><span class="o">))</span> <span class="o">=</span>
<span class="n">Sequence</span> <span class="n">tbody</span>            <span class="o">(</span><span class="n">While</span> <span class="n">e</span> <span class="n">tbody</span><span class="o">)</span>
</code></pre></div><p>在 <code>f_equal.</code> 之后会变成：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">v</span> <span class="o">:</span> <span class="n">valuation</span>
<span class="n">e</span> <span class="o">:</span> <span class="n">arith</span>
<span class="n">body</span><span class="o">,</span> <span class="n">tbody</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span>
<span class="n">transform</span> <span class="n">body</span> <span class="o">=</span> <span class="n">tbody</span>
<span class="o">______________________________________(</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span>
<span class="n">While</span> <span class="n">e</span> <span class="o">(</span><span class="n">transform</span> <span class="n">body</span><span class="o">)</span> <span class="o">=</span> <span class="n">While</span> <span class="n">e</span> <span class="n">tbody</span>
</code></pre></div><p>显然，如果你在第二个小目标里面运行 <code>f_equal.</code>，它会进一步变成：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">transform</span> <span class="n">body</span> <span class="o">=</span> <span class="n">tbody</span>
</code></pre></div><p>注意到，尽管 <code>f_equal</code> 可以把目标转化成更小的问题，但是在使用的时候你一定要确信其中对应的部分是相等的，不然你会产生错误的结论，比方说这个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">s</span> <span class="o">:</span> <span class="n">var</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">s</span><span class="o">)</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="n">s</span>
</code></pre></div><p>在这个例子里面，我们想要证明一个字符串翻转过来之后的长度和原来的长度是一样的。如果我们用 <code>f_equal.</code>：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">s</span> <span class="o">:</span> <span class="n">var</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">reverse</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span>
</code></pre></div><p>目标变成了证明一个任意的字符串翻转过来和原字符串是一样的，这完全讲不通。</p><h2><code>assumption</code></h2><p>如果目标已经出现在假设里面了，你可以用 <code>assumption.</code> 来结束证明。另外，你也可以使用 <code>auto</code> 或者 <code>exact</code>。</p><h2><code>constructor</code></h2><p>当目标是一个归纳类型的时候，结束证明的方法一般来说是用构造函数。<code>constructor.</code> 会按照定义的顺序逐个尝试这个归纳类型的构造函数，直到第一个匹配上的为止。因为 <code>constructor.</code> 用的是第一个匹配上的构造函数，所以并不一定是正确的，如果遇到了这种情况，你需要使用 <code>apply</code>。</p><p>举一个简单的例子，假设我们有这么一个归纳类型：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Inductive</span> <span class="n">eval_unop</span> <span class="o">:</span> <span class="n">op1</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">-&gt;</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">eval_neg</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">eval_unop</span> <span class="n">Oneg</span> <span class="o">(</span><span class="n">Vint</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Vint</span> <span class="o">(</span><span class="n">Z</span><span class="o">.</span><span class="n">opp</span> <span class="n">i</span><span class="o">))</span>
<span class="o">|</span> <span class="n">eval_not</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">eval_unop</span> <span class="n">Onot</span> <span class="o">(</span><span class="n">Vbool</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">Vbool</span> <span class="o">(</span><span class="n">negb</span> <span class="n">b</span><span class="o">)).</span>
</code></pre></div><p>现在我们有：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">b</span> <span class="o">:</span> <span class="kt">bool</span>
<span class="n">v'</span> <span class="o">:</span> <span class="n">val</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">eval_unop</span> <span class="n">Onot</span> <span class="o">(</span><span class="n">Vbool</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">Vbool</span> <span class="o">(</span><span class="n">negb</span> <span class="n">b</span><span class="o">))</span>
</code></pre></div><p>现在我们用 <code>consturctor.</code>， Coq 会匹配上第二个构造函数 <code>eval_not</code>。</p><h2><code>apply</code></h2><p><code>apply</code> 也可以用来应用构造函数。实际上，你可以 <code>apply</code> 任何定理，你可以认为构造函数就是一种定理。比方说，在前面 <code>constructor</code> 的例子里面，你也可以 <code>apply eval_not.</code> 来代替 <code>constructor.</code>。</p><p>让我来用一个稍微复杂一点的例子来讲解 <code>apply</code>，假设我们有这么一个归纳类型和一个定理：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Inductive</span> <span class="n">eval_e</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">store</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">heap</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">-&gt;</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="c">(* Omitted *)</span><span class="o">.</span>

<span class="kn">Inductive</span> <span class="n">eval_s</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">env</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">store</span> <span class="o">-&gt;</span> <span class="n">heap</span> <span class="o">-&gt;</span> <span class="n">stmt</span> <span class="o">-&gt;</span> <span class="n">store</span> <span class="o">-&gt;</span> <span class="n">heap</span> <span class="o">-&gt;</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">eval_ifelse_t</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="n">s</span> <span class="n">h</span> <span class="n">e</span> <span class="n">p1</span> <span class="n">p2</span> <span class="n">s'</span> <span class="n">h'</span><span class="o">,</span>
      <span class="n">eval_e</span> <span class="n">s</span> <span class="n">h</span> <span class="n">e</span> <span class="o">(</span><span class="n">Vbool</span> <span class="bp">true</span><span class="o">)</span>                  <span class="o">-&gt;</span>
      <span class="n">eval_s</span>  <span class="n">env</span>  <span class="n">s</span> <span class="n">h</span> <span class="n">p1</span>                  <span class="n">s'</span> <span class="n">h'</span> <span class="o">-&gt;</span>
      <span class="n">eval_s</span>  <span class="n">env</span>  <span class="n">s</span> <span class="n">h</span> <span class="o">(</span><span class="n">Sifelse</span> <span class="n">e</span> <span class="n">p1</span> <span class="n">p2</span><span class="o">)</span>   <span class="n">s'</span> <span class="n">h'</span>
<span class="o">|</span> <span class="n">eval_ifelse_f</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="n">s</span> <span class="n">h</span> <span class="n">e</span> <span class="n">p1</span> <span class="n">p2</span> <span class="n">s'</span> <span class="n">h'</span><span class="o">,</span>
      <span class="n">eval_e</span> <span class="n">s</span> <span class="n">h</span> <span class="n">e</span> <span class="o">(</span><span class="n">Vbool</span> <span class="bp">false</span><span class="o">)</span>                 <span class="o">-&gt;</span>
      <span class="n">eval_s</span>  <span class="n">env</span>  <span class="n">s</span> <span class="n">h</span> <span class="n">p2</span>                  <span class="n">s'</span> <span class="n">h'</span> <span class="o">-&gt;</span>
      <span class="n">eval_s</span>  <span class="n">env</span>  <span class="n">s</span> <span class="n">h</span> <span class="o">(</span><span class="n">Sifelse</span> <span class="n">e</span> <span class="n">p1</span> <span class="n">p2</span><span class="o">)</span>   <span class="n">s'</span> <span class="n">h'</span>
<span class="o">|</span> <span class="n">eval_seq</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="n">s1</span> <span class="n">h1</span> <span class="n">p1</span> <span class="n">s2</span> <span class="n">h2</span> <span class="n">p2</span> <span class="n">s3</span> <span class="n">h3</span><span class="o">,</span>
      <span class="n">eval_s</span>  <span class="n">env</span>  <span class="n">s1</span> <span class="n">h1</span> <span class="n">p1</span>             <span class="n">s2</span> <span class="n">h2</span> <span class="o">-&gt;</span>
      <span class="n">eval_s</span>  <span class="n">env</span>  <span class="n">s2</span> <span class="n">h2</span> <span class="n">p2</span>             <span class="n">s3</span> <span class="n">h3</span> <span class="o">-&gt;</span>
      <span class="n">eval_s</span>  <span class="n">env</span>  <span class="n">s1</span> <span class="n">h1</span> <span class="o">(</span><span class="n">Sseq</span> <span class="n">p1</span> <span class="n">p2</span><span class="o">)</span>   <span class="n">s3</span> <span class="n">h3</span><span class="o">.</span>

<span class="kn">Lemma</span> <span class="n">interp_e_eval_e</span> <span class="o">:</span>
  <span class="k">forall</span> <span class="n">s</span> <span class="n">h</span> <span class="n">e</span> <span class="n">v</span><span class="o">,</span>
    <span class="n">interp_e</span> <span class="n">s</span> <span class="n">h</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Some</span> <span class="n">v</span> <span class="o">-&gt;</span>
    <span class="n">eval_e</span> <span class="n">s</span> <span class="n">h</span> <span class="n">e</span> <span class="n">v</span><span class="o">.</span>
</code></pre></div><p>现在我们有：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">IHfuel</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">env</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">store</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">heap</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">(</span><span class="n">s'</span> <span class="o">:</span> <span class="n">store</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">heap</span><span class="o">),</span>
         <span class="n">interp_s</span> <span class="n">fuel</span> <span class="n">env</span> <span class="n">s</span> <span class="n">h</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Some</span> <span class="o">(</span><span class="n">s'</span><span class="o">,</span> <span class="n">h'</span><span class="o">)</span> <span class="o">-&gt;</span>
         <span class="n">eval_s</span> <span class="n">env</span> <span class="n">s</span> <span class="n">h</span> <span class="n">p</span> <span class="n">s'</span> <span class="n">h'</span>
<span class="n">Heqo</span> <span class="o">:</span> <span class="n">interp_e</span> <span class="n">s</span> <span class="n">h</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Some</span> <span class="o">(</span><span class="n">Vbool</span> <span class="bp">true</span><span class="o">)</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">interp_s</span> <span class="n">fuel</span> <span class="n">env</span> <span class="n">s</span> <span class="n">h</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">Some</span> <span class="o">(</span><span class="n">s'</span><span class="o">,</span> <span class="n">h'</span><span class="o">)</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">eval_s</span> <span class="n">env</span> <span class="n">s</span> <span class="n">h</span> <span class="o">(</span><span class="n">Sifelse</span> <span class="n">e</span> <span class="n">p1</span> <span class="n">p2</span><span class="o">)</span> <span class="n">s'</span> <span class="n">h'</span>
</code></pre></div><p>在构造函数里面有一些 <code>-&gt;</code>，如果你是第一次接触 Coq 的话，这看起来很吓人，不过一旦你理解了 <code>apply</code> 和 <code>constructor</code> 的原理，事情就很容易了。</p><p>在这个例子里面，我们想要用构造函数 <code>eval_ifelse_t</code>。为什么呢？首先，看一下目标，这是一个 <code>eval_s</code> 所以我们要找找 <code>eval_s</code> 的构造函数。我们怎么知道要的不是构造函数 <code>eval_seq</code> 呢？因为我们的目标从结构上匹配不上 <code>eval_seq</code>。但是 <code>eval_ifelse_t</code> 和 <code>eval_ifelse_f</code> 的结论有完全一样的形式 <code>eval_s  env  s h (Sifelse e p1 p2)   s' h'</code>，要用哪个呢，以及要怎么处理这些前提条件呢？</p><p>从逻辑上来说，要使用 <code>eval_ifelse_t</code> 的话，我们需要证明它的前提条件。实际上，如果你 <code>constructor.</code> 或者 <code>apply eval_ifelse_t.</code>，就会变成两个小目标，这符合逻辑，因为这里有两个前提条件：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span>
<span class="n">eval_e</span> <span class="n">s</span> <span class="n">h</span> <span class="n">e</span> <span class="o">(</span><span class="n">Vbool</span> <span class="bp">true</span><span class="o">)</span>
<span class="o">______________________________________(</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span>
<span class="n">eval_s</span> <span class="n">env</span> <span class="n">s</span> <span class="n">h</span> <span class="n">p1</span> <span class="n">s'</span> <span class="n">h'</span>
</code></pre></div><p>其实第二个小目标是显然的，你可以用 <code>apply IHfuel. assumption.</code> 解决掉它。让我再讲解一遍这个显然的情况，加深对 <code>apply</code> 的理解。<code>IHfuel</code> 的最后一个命题的形式（<code>eval_s env s h p s' h'</code>）能匹配上第二个小目标的形式（<code>eval_s env s h p1 s' h'</code>）。注意到在 <code>IHfuel</code> 里面有一个 <code>forall</code>，在 <code>apply IHfuel.</code> 的时候，Coq 能自己搞清楚这些自由变量是什么。所以说第二个小目标变成了  <code>interp_s fuel env s h p1 = Some (s', h')</code>，这就是 <code>Heqo</code>.</p><p>我说第二个小目标是显然的，因为你也可以 <code>auto.</code> 而不用 <code>apply IHfuel. assumption.</code>。甚至更简单地，如果你一开始就 <code>constructor; auto.</code> 或者 <code>apply eval_ifelse_t; auto.</code>，第二个小目标根本就不会出现。</p><p>至于第一个小目标，我们可以用 <code>apply interp_e_eval_e. assumption.</code> 来完成证明。想想这是为什么。其实是一样的。</p><p>除了转化目标以外，<code>apply</code> 也可以作用在假设上面，只要你加上 <code>in H</code>。比方说：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Theorem</span> <span class="n">Transform_transform</span><span class="o">:</span>
  <span class="k">forall</span> <span class="n">c1</span> <span class="n">c2</span><span class="o">,</span>
    <span class="n">Transform</span> <span class="n">c1</span> <span class="n">c2</span> <span class="o">-&gt;</span>
    <span class="n">transform</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span>
</code></pre></div><p>现在我们有：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H</span> <span class="o">:</span> <span class="n">Transform</span> <span class="o">(</span><span class="n">Assign</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span> <span class="n">c1'</span>
</code></pre></div><p><code>apply Transform_transform in H.</code> 可以把 <code>H</code> 变成：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H</span> <span class="o">:</span> <span class="n">transform</span> <span class="o">(</span><span class="n">Assign</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="n">c1'</span>
</code></pre></div><h2><code>exists</code></h2><p>证明全称量词的一个方法是直接告诉 Coq 这些变量到底是什么。举个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H3</span> <span class="o">:</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">EmptySet</span>
<span class="n">H4</span> <span class="o">:</span> <span class="n">s2</span> <span class="o">=~</span> <span class="n">re1</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">String</span> <span class="n">a</span> <span class="o">(</span><span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span><span class="o">)</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s0</span> <span class="n">s3</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s3</span> <span class="o">/\</span>
  <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">EmptySet</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s3</span> <span class="o">=~</span> <span class="n">re1</span>
</code></pre></div><p>我们可以告诉 Coq <code>exists s1, s2.</code>：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H3</span> <span class="o">:</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">EmptySet</span>
<span class="n">H4</span> <span class="o">:</span> <span class="n">s2</span> <span class="o">=~</span> <span class="n">re1</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">String</span> <span class="n">a</span> <span class="o">(</span><span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span><span class="o">)</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">EmptySet</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s2</span> <span class="o">=~</span> <span class="n">re1</span>
</code></pre></div><p>然后一个 <code>first_order</code> 就能结束证明。</p><h2><code>reflexivity</code></h2><p>正如这个名字本身的含义，当目标类似 <code>x = x</code> 的形式，使用 <code>reflexivity.</code> 就能结束证明。</p><h2><code>discriminate</code></h2><p>如果有一个假设是一个等式，但是等式两边结构不同，可以使用 <code>discriminate.</code> 来结束证明，无论要证明的结论是什么，因为逻辑上一个错误的假设可以推导出任何结论。举个例子，</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H</span> <span class="o">:</span> <span class="n">None</span> <span class="o">=</span> <span class="n">Some</span> <span class="n">v'</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">eval_unop</span> <span class="n">Oneg</span> <span class="o">(</span><span class="n">Vbool</span> <span class="n">b</span><span class="o">)</span> <span class="n">v'</span>
</code></pre></div><p><code>discriminate.</code> 就能结束证明。</p><p>再来一个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">c1_1</span><span class="o">,</span> <span class="n">c1_2</span><span class="o">,</span> <span class="n">c2</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">Sequence</span> <span class="o">(</span><span class="n">transform</span> <span class="n">c1_1</span><span class="o">)</span> <span class="o">(</span><span class="n">transform</span> <span class="n">c1_2</span><span class="o">)</span> <span class="o">=</span> <span class="n">c2</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">Transform</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">c1_1</span> <span class="n">c1_2</span><span class="o">)</span> <span class="n">c2</span>
</code></pre></div><p>这里 <code>cmd</code> 是一个归纳类型，<code>Sequence</code> 是其中的一个构造函数。显然，<code>c2</code> 也必须是一个 <code>Sequence</code>. 如果你运行 <code>destruct c2; try discriminate.</code>：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">c1_1</span><span class="o">,</span> <span class="n">c1_2</span><span class="o">,</span> <span class="n">c2_1</span><span class="o">,</span> <span class="n">c2_2</span> <span class="o">:</span> <span class="n">cmd</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">Sequence</span> <span class="o">(</span><span class="n">transform</span> <span class="n">c1_1</span><span class="o">)</span> <span class="o">(</span><span class="n">transform</span> <span class="n">c1_2</span><span class="o">)</span> <span class="o">=</span> <span class="n">Sequence</span> <span class="n">c2_1</span> <span class="n">c2_2</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">Transform</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">c1_1</span> <span class="n">c1_2</span><span class="o">)</span> <span class="o">(</span><span class="n">Sequence</span> <span class="n">c2_1</span> <span class="n">c2_2</span><span class="o">)</span>
</code></pre></div><p>这就符合我们的预期。这个效果类似于 <code>inversion H; subst.</code>。</p><h2><code>congruence</code></h2><p>我发现 <code>congruence</code> 好像是一个更强版本的 <code>discriminate</code>。前面 <code>discriminate</code> 的两个例子都可以用 <code>congruence.</code> 替代。但是 <code>congruence</code> 可以做更多的事情，比方说：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H</span> <span class="o">:</span> <span class="n">x1</span> <span class="o">&lt;&gt;</span> <span class="n">x1</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">Some</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">Some</span> <span class="n">t1</span>
</code></pre></div><p>在这个例子里面，<code>congruence.</code> 可以发现 <code>H</code> 不成立，所以证明就结束了，但是 <code>discriminate.</code> 就不能。</p><h2><code>auto</code></h2><p>我一开始的时候以为 <code>auto</code> 是一个非常强力的招数，但是后来我发现其实它只能解决一些简单的情况。我对它的理解就是把它当做自动地尝试 <code>assumptions</code>、 <code>reflexivity</code>、 <code>congruence</code>，以及尝试应用假设里面的定理。</p><h2><code>econstructor</code> / <code>eapply</code> / <code>eauto</code> / <code>edestruct</code> / <code>eexists</code></h2><p>带有 <code>e</code> 版本的这些招数做的事情和不带 <code>e</code> 的版本一样，只不过当找不到某些变量的时候，带 <code>e</code> 的版本会引入像未知数一样的变量，而不是直接失败。而后随着证明的推进，Coq 有可能会自动地搞清楚这些引入的变量是什么。</p><h2><code>rewrite</code></h2><p>如果你有一个等式，你可以用它来转化其他假设或者目标。<code>rewrite H.</code> 把等式 <code>H</code> 左边的表达式替换成等式右边的。如果要反过来，你可以使用 <code>rewrite &lt;- H.</code>。如果你想要改变一个假设 <code>H1</code> 而不是目标，使用 <code>rewrite H in H1.</code>。如果你想要改变所有的假设和目标，使用 <code>in *</code>.</p><p>举个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H1</span> <span class="o">:</span> <span class="n">length</span> <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="n">ht</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">length</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">(</span><span class="n">snoc</span> <span class="n">ht</span> <span class="n">t0</span><span class="o">)</span>
</code></pre></div><p>在 <code>rewrite H1.</code> 之后：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H1</span> <span class="o">:</span> <span class="n">length</span> <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="n">ht</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">length</span> <span class="n">ht</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">(</span><span class="n">snoc</span> <span class="n">ht</span> <span class="n">t0</span><span class="o">)</span>
</code></pre></div><p>再举一个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H1</span> <span class="o">:</span> <span class="n">length</span> <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="n">ht</span>
<span class="n">H8</span> <span class="o">:</span> <span class="n">nth</span> <span class="o">(</span><span class="n">length</span> <span class="n">ht</span><span class="o">)</span> <span class="o">(</span><span class="n">snoc</span> <span class="n">ht</span> <span class="n">t0</span><span class="o">)</span> <span class="n">TBool</span> <span class="o">=</span> <span class="n">t0</span>
</code></pre></div><p>在 <code>rewrite &lt;-H1 in H8.</code> 之后：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H1</span> <span class="o">:</span> <span class="n">length</span> <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="n">ht</span>
<span class="n">H8</span> <span class="o">:</span> <span class="n">nth</span> <span class="o">(</span><span class="n">length</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">snoc</span> <span class="n">ht</span> <span class="n">t0</span><span class="o">)</span> <span class="n">TBool</span> <span class="o">=</span> <span class="n">t0</span>
</code></pre></div><p>另外，如果你不确定应该用哪边替换另一边，就带和不带 <code>&lt;-</code> 两个都试一下，总有一个是对的。</p><h2><code>unfold</code></h2><p>有时候一个命题里面包含了抽象的定义，要把这层抽象去掉，可以用 <code>unfold</code>。举个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="mi">1</span> <span class="n">subgoal</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">derives</span> <span class="n">derive</span>
</code></pre></div><p>面对这个目标，我们并没有任何的招式可用。但是在 <code>unfold derives.</code> 之后：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="k">forall</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">ascii</span><span class="o">)</span> <span class="o">(</span><span class="n">re</span> <span class="o">:</span> <span class="n">reg_exp</span><span class="o">),</span> <span class="n">is_der</span> <span class="n">re</span> <span class="n">a</span> <span class="o">(</span><span class="n">derive</span> <span class="n">a</span> <span class="n">re</span><span class="o">)</span>
</code></pre></div><p>现在看来就好多了，我们可以进一步 <code>unfold is_der.</code>：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="k">forall</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">ascii</span><span class="o">)</span> <span class="o">(</span><span class="n">re</span> <span class="o">:</span> <span class="n">reg_exp</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="kt">string</span><span class="o">),</span>
<span class="n">String</span> <span class="n">a</span> <span class="n">s</span> <span class="o">=~</span> <span class="n">re</span> <span class="o">&lt;-&gt;</span> <span class="n">s</span> <span class="o">=~</span> <span class="n">derive</span> <span class="n">a</span> <span class="n">re</span>
</code></pre></div><p>现在我们就可以对它进行变换了（<code>intros. split.</code>）。</p><p>和 <code>rewrite</code> 类似, <code>unfold</code> 默认应用到目标上。要应用到一个假设 <code>H</code> 上，使用 <code>in H</code>。要应用到所有假设和目标，用 <code>in *</code>。</p><h2><code>specialize</code></h2><p>如果有个假设以 <code>forall</code> 开头，你可以用 <code>specialize</code> 来代入这些自由变量。</p><p>如果有个假设是若干个命题用 <code>-&gt;</code> 连接起来的，而这些前提条件又正好都在你的假设里面，那你就可以用 <code>specialize</code> 把这个假设里面的这些前提条件去掉。</p><p>举个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">IHstep</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">c1'</span> <span class="o">:</span> <span class="n">cmd</span><span class="o">,</span>
         <span class="n">c1'</span> <span class="o">=</span> <span class="n">c1'</span> <span class="o">-&gt;</span>
         <span class="n">Transform</span> <span class="n">c1</span> <span class="n">c1'</span> <span class="o">-&gt;</span>
         <span class="k">exists</span> <span class="n">c2'</span> <span class="o">:</span> <span class="n">cmd</span><span class="o">,</span> <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">c1'</span><span class="o">)</span> <span class="o">(</span><span class="n">v'</span><span class="o">,</span> <span class="n">c2'</span><span class="o">)</span>
<span class="n">H3</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">c1</span> <span class="n">tc1</span>
</code></pre></div><p>在 <code>specialize (IHstep tc1).</code> 之后：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">IHstep</span> <span class="o">:</span> <span class="n">tc1</span> <span class="o">=</span> <span class="n">tc1</span> <span class="o">-&gt;</span>
         <span class="n">Transform</span> <span class="n">c1</span> <span class="n">tc1</span> <span class="o">-&gt;</span>
         <span class="k">exists</span> <span class="n">c2'</span> <span class="o">:</span> <span class="n">cmd</span><span class="o">,</span> <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">tc1</span><span class="o">)</span> <span class="o">(</span><span class="n">v'</span><span class="o">,</span> <span class="n">c2'</span><span class="o">)</span>
<span class="n">H3</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">c1</span> <span class="n">tc1</span>
</code></pre></div><p>如果你转而使用 <code>specialize (IHstep tc1 (eq_refl tc1) H3).</code> 就会有如下结果：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">IHstep</span> <span class="o">:</span> <span class="k">exists</span> <span class="n">c2'</span> <span class="o">:</span> <span class="n">cmd</span><span class="o">,</span> <span class="n">step_buggy</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">tc1</span><span class="o">)</span> <span class="o">(</span><span class="n">v'</span><span class="o">,</span> <span class="n">c2'</span><span class="o">)</span>
<span class="n">H3</span> <span class="o">:</span> <span class="n">Transform</span> <span class="n">c1</span> <span class="n">tc1</span>
</code></pre></div><h2><code>pose proof</code></h2><p><code>pose proof</code> 可以做 <code>specialize</code> 能做的事情，但有一点点不同。<code>pose proof</code> 会添加一个新的假设，而 <code>specialize</code> 则是原地修改原来假设。</p><p>因为 <code>pose proof</code> 能够添加新的假设，所以它可以做更多的事情。特别地，你可以使用一个引理来添加一个假设。</p><p>下面是两个例子：</p><ul><li><code>pose proof (IHstep tc1 (eq_refl tc1) H3).</code></li><li><code>pose proof (step_step_buggy p1 p2 H c1' H0).</code></li></ul><h2><code>split</code></h2><p>如果目标是若干个命题 <code>/\</code> 连起来的，也就是一个和取范式，那你可以使用 <code>split.</code> 把它们拆开变成若干个小目标。</p><p>如果目标是一个当且仅当 <code>iff</code>，你也可以使用 <code>split.</code> 来把它拆成两个方向。</p><h2><code>left</code> / <code>right</code></h2><p>另外一方面，如果目标是一个析取范式，使用 <code>left.</code> 或者 <code>right.</code> 来选择你要证明哪一边。</p><h2><code>exact</code></h2><p>如果你的目标已经在假设里面了，你可以用 <code>exact</code> 来结束证明。另外，你也可以用 <code>exact</code> 来替代 <code>pose proof</code> 和 <code>assumption</code> 的组合。</p><p>两个例子：</p><ul><li><code>exact H7.</code></li><li><code>exact (ReachRefl g b).</code></li></ul><h2><code>assert</code></h2><p><code>assert</code> 可以往假设里面添加一个命题，当然你要证明它。<code>assert P.</code> 会产生两个小目标：一个是给定当前已知的假设，证明 <code>P</code>；另一个是给定当前已知的假设和 <code>P</code>，证明原来的目标。</p><p>这么做的动机可能是因为你想要复制一份现有的假设，因为你后面打算对它进行修改。还有一个常见的情况就是你看出来一些假设是成立的，但是 Coq 没有。</p><p>几个例子：</p><ul><li><code>assert (H8 := Heqo0).</code></li><li><code>assert (a &lt; length h); try omega.</code></li><li><code>assert ("" = "" ++ ""). equality.</code></li><li><code>assert (~ free e1 x).</code></li></ul><h2><code>first_order</code></h2><p><code>first_order</code> 可以用来打开假设和目标中的 <code>/\</code>、<code>\/</code>、<code>-&gt;</code>、<code>&lt;-&gt;</code> 以及很多其他东西。</p><p>举个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="s2">""</span> <span class="o">=~</span> <span class="n">re1</span><span class="o">)</span> <span class="o">/\</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s</span> <span class="o">=~</span> <span class="n">re2</span> <span class="o">\/</span>
    <span class="o">(</span><span class="k">exists</span> <span class="n">s0</span> <span class="n">s1</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s1</span> <span class="o">/\</span>
    <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re1</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">re2</span><span class="o">)</span>
<span class="n">H0</span> <span class="o">:</span> <span class="s2">""</span> <span class="o">=~</span> <span class="n">re1</span> <span class="o">&lt;-&gt;</span> <span class="bp">true</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">s</span> <span class="o">=~</span> <span class="n">Union</span> <span class="o">(</span><span class="n">derive</span> <span class="n">a</span> <span class="n">re2</span><span class="o">)</span> <span class="o">(</span><span class="n">App</span> <span class="o">(</span><span class="n">derive</span> <span class="n">a</span> <span class="n">re1</span><span class="o">)</span> <span class="n">re2</span><span class="o">)</span>
</code></pre></div><p><code>first_order</code> 会把复杂的 <code>H</code> and <code>H0</code> 打开。因为 <code>H</code> 里面有一个 <code>\/</code>，所以会变成两个小目标：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H1</span><span class="o">,</span> <span class="n">H</span> <span class="o">:</span> <span class="s2">""</span> <span class="o">=~</span> <span class="n">re1</span>
<span class="n">H2</span> <span class="o">:</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s</span> <span class="o">=~</span> <span class="n">re2</span>
<span class="n">H0</span> <span class="o">:</span> <span class="bp">true</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">s</span> <span class="o">=~</span> <span class="n">Union</span> <span class="o">(</span><span class="n">derive</span> <span class="n">a</span> <span class="n">re2</span><span class="o">)</span> <span class="o">(</span><span class="n">App</span> <span class="o">(</span><span class="n">derive</span> <span class="n">a</span> <span class="n">re1</span><span class="o">)</span> <span class="n">re2</span><span class="o">)</span>
</code></pre></div><p>以及</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H1</span> <span class="o">:</span> <span class="s2">""</span> <span class="o">=~</span> <span class="n">re1</span>
<span class="n">x</span><span class="o">,</span> <span class="n">x0</span> <span class="o">:</span> <span class="kt">string</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">s</span> <span class="o">=</span> <span class="n">x</span> <span class="o">++</span> <span class="n">x0</span>
<span class="n">H2</span> <span class="o">:</span> <span class="n">String</span> <span class="n">a</span> <span class="n">x</span> <span class="o">=~</span> <span class="n">re1</span>
<span class="n">H3</span> <span class="o">:</span> <span class="n">x0</span> <span class="o">=~</span> <span class="n">re2</span>
<span class="n">H0</span> <span class="o">:</span> <span class="bp">true</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">s</span> <span class="o">=~</span> <span class="n">Union</span> <span class="o">(</span><span class="n">derive</span> <span class="n">a</span> <span class="n">re2</span><span class="o">)</span> <span class="o">(</span><span class="n">App</span> <span class="o">(</span><span class="n">derive</span> <span class="n">a</span> <span class="n">re1</span><span class="o">)</span> <span class="n">re2</span><span class="o">)</span>
</code></pre></div><p>再举一个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H4</span> <span class="o">:</span> <span class="n">heap_typ_extends</span> <span class="n">x</span> <span class="n">ht</span> <span class="o">/\</span> <span class="n">typed</span> <span class="n">E0</span> <span class="n">x</span> <span class="n">e'</span> <span class="n">t0</span> <span class="o">/\</span> <span class="n">heap_typed</span> <span class="n">x</span> <span class="n">h'</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">heap_typ_extends</span> <span class="n">x</span> <span class="n">ht</span> <span class="o">/\</span> <span class="n">typed</span> <span class="n">E0</span> <span class="n">x</span> <span class="o">(</span><span class="n">ref</span> <span class="n">e'</span><span class="o">)</span> <span class="o">(</span><span class="n">TRef</span> <span class="n">t0</span><span class="o">)</span> <span class="o">/\</span> <span class="n">heap_typed</span> <span class="n">x</span> <span class="n">h'</span>
</code></pre></div><p>在 <code>first_order</code> 之后会变成：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H4</span> <span class="o">:</span> <span class="n">heap_typ_extends</span> <span class="n">x</span> <span class="n">ht</span>
<span class="n">H7</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">E0</span> <span class="n">x</span> <span class="n">e'</span> <span class="n">t0</span>
<span class="n">H8</span> <span class="o">:</span> <span class="n">heap_typed</span> <span class="n">x</span> <span class="n">h'</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">typed</span> <span class="n">E0</span> <span class="n">x</span> <span class="o">(</span><span class="n">ref</span> <span class="n">e'</span><span class="o">)</span> <span class="o">(</span><span class="n">TRef</span> <span class="n">t0</span><span class="o">)</span>
</code></pre></div><p>尽管原先的目标由三个命题组成，但是 <code>first_order</code> 之后依然只有一个目标而不是三个，这是因为另外两个命题已经在假设 <code>H4</code> 里面了。顺带一提，<code>first_order</code> 会进一步把 <code>heap_typed</code> 的前提条件拆出来，但是我这里为了简单就假装没有发生。</p><h2><code>admit</code></h2><p>在有多个小目标的情况下，有时候你想要跳过其中的几个小目标。这可能是因为你暂时不知道怎么证明；有可能是因为你觉得这太简单现在不想证；也有可能你不确定现在走的这条路对不对，想要先看一眼后面的其他几个小目标。</p><p>这时候，你可以用 <code>admit.</code> 来跳过当前的小目标。当然了，一旦你有了一个 <code>admit.</code>，你这个证明就不能 <code>Qed.</code>，你只能 <code>Admitted</code>.</p><h2><code>symmetry</code></h2><p>如果目标是一个等式，而且你想要翻转它，你可以使用 <code>symmetry.</code>。举个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">env2</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Some</span> <span class="n">t</span>
</code></pre></div><p>在 <code>symmetry</code> 之后：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">Some</span> <span class="n">t</span> <span class="o">=</span> <span class="n">env2</span> <span class="n">x</span>
</code></pre></div><h2><code>revert</code></h2><p><code>revert</code> 可以把你之前 <code>intros</code> 引入的假设放回去。为什么放回去？因为有时候你需要把归纳假设变得更强一些。比方说：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Lemma</span> <span class="n">extends_lookup</span> <span class="o">:</span>
  <span class="k">forall</span> <span class="n">h</span> <span class="n">h'</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">a</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="n">h</span> <span class="o">-&gt;</span>
    <span class="n">heap_typ_extends</span> <span class="n">h'</span> <span class="n">h</span> <span class="o">-&gt;</span>
    <span class="n">lookup_typ</span> <span class="n">h'</span> <span class="n">a</span> <span class="o">=</span> <span class="n">lookup_typ</span> <span class="n">h</span> <span class="n">a</span><span class="o">.</span>
</code></pre></div><p>如果我们直接 <code>induction a; intros.</code>，第二个小目标会是这样的：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">h</span> <span class="o">:</span> <span class="kt">list</span> <span class="n">typ</span>
<span class="n">h'</span> <span class="o">:</span> <span class="n">heap_typ</span>
<span class="n">a</span> <span class="o">:</span> <span class="kt">nat</span>
<span class="n">IHa</span> <span class="o">:</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="n">h</span> <span class="o">-&gt;</span>
      <span class="n">heap_typ_extends</span> <span class="n">h'</span> <span class="n">h</span> <span class="o">-&gt;</span>
      <span class="n">lookup_typ</span> <span class="n">h'</span> <span class="n">a</span> <span class="o">=</span> <span class="n">lookup_typ</span> <span class="n">h</span> <span class="n">a</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">S</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="n">h</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">heap_typ_extends</span> <span class="n">h'</span> <span class="n">h</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">lookup_typ</span> <span class="n">h'</span> <span class="o">(</span><span class="n">S</span> <span class="n">a</span><span class="o">)</span> <span class="o">=</span> <span class="n">lookup_typ</span> <span class="n">h</span> <span class="o">(</span><span class="n">S</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div><p>然而，如果我们 <code>intros h h' a. revert h h'. induction a; intros.</code>，我们的第二个小目标会变成这样：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">a</span> <span class="o">:</span> <span class="kt">nat</span>
<span class="n">IHa</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="kt">list</span> <span class="n">typ</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">heap_typ</span><span class="o">),</span>
      <span class="n">a</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="n">h</span> <span class="o">-&gt;</span>
      <span class="n">heap_typ_extends</span> <span class="n">h'</span> <span class="n">h</span> <span class="o">-&gt;</span>
      <span class="n">lookup_typ</span> <span class="n">h'</span> <span class="n">a</span> <span class="o">=</span> <span class="n">lookup_typ</span> <span class="n">h</span> <span class="n">a</span>
<span class="n">h</span> <span class="o">:</span> <span class="kt">list</span> <span class="n">typ</span>
<span class="n">h'</span> <span class="o">:</span> <span class="n">heap_typ</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">S</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="n">h</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">heap_typ_extends</span> <span class="n">h'</span> <span class="n">h</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="n">lookup_typ</span> <span class="n">h'</span> <span class="o">(</span><span class="n">S</span> <span class="n">a</span><span class="o">)</span> <span class="o">=</span> <span class="n">lookup_typ</span> <span class="n">h</span> <span class="o">(</span><span class="n">S</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div><p>可以看到，后面这个版本里面的归纳假设 <code>IHa</code> 比没有 <code>revert</code> 的那个版本的更强。如果不 <code>revert</code> 的话，<code>IHa</code> 就不足以证明这个命题（我当时浪费了很长时间在这个上面）。</p><p>所以怎么知道要不要 <code>revert</code> 呢？我觉得我们可以先想简单一点，不要 <code>revert</code>。当你发现你的归纳假设不够强之后，再来想想 <code>revert</code>。</p><h2><code>remember</code></h2><p>我遇到的关于 <code>induction</code> 的另一个问题是这样的：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">a</span> <span class="o">:</span> <span class="kt">ascii</span>
<span class="n">s</span> <span class="o">:</span> <span class="kt">string</span>
<span class="n">re</span> <span class="o">:</span> <span class="n">reg_exp</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s0</span> <span class="n">s1</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s1</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re</span>
</code></pre></div><p>这里 <code>=~</code> 只是一个归纳类型的记号，<code>x =~ y</code> 的意思是 <code>exp_match x y</code>。尽管直觉上我们知道我们需要对 <code>H</code> 进行归纳，但如果我们直接 <code>induction H</code>，我们会得到一大堆无法证明的东西：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="mi">8</span> <span class="n">subgoals</span>
<span class="n">a</span> <span class="o">:</span> <span class="kt">ascii</span>
<span class="n">s</span> <span class="o">:</span> <span class="kt">string</span>
<span class="n">re</span> <span class="o">:</span> <span class="n">reg_exp</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s0</span> <span class="n">s1</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s1</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">EmptyStr</span>
<span class="o">______________________________________(</span><span class="mi">2</span><span class="o">/</span><span class="mi">8</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s0</span> <span class="n">s1</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s1</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">Char</span> <span class="n">x</span>
<span class="o">______________________________________(</span><span class="mi">3</span><span class="o">/</span><span class="mi">8</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s0</span> <span class="n">s1</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s1</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">Dot</span>
<span class="o">______________________________________(</span><span class="mi">4</span><span class="o">/</span><span class="mi">8</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s0</span> <span class="n">s3</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s3</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s3</span> <span class="o">=~</span> <span class="n">App</span> <span class="n">re1</span> <span class="n">re2</span>
<span class="o">______________________________________(</span><span class="mi">5</span><span class="o">/</span><span class="mi">8</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s2</span> <span class="o">=~</span> <span class="n">Union</span> <span class="n">re1</span> <span class="n">re2</span>
<span class="o">______________________________________(</span><span class="mi">6</span><span class="o">/</span><span class="mi">8</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s2</span> <span class="o">=~</span> <span class="n">Union</span> <span class="n">re1</span> <span class="n">re2</span>
<span class="o">______________________________________(</span><span class="mi">7</span><span class="o">/</span><span class="mi">8</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s0</span> <span class="n">s1</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s1</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re0</span>
<span class="o">______________________________________(</span><span class="mi">8</span><span class="o">/</span><span class="mi">8</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s2</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re0</span>
</code></pre></div><p>我听说这是因为当构造函数的参数不是变量的时候，<code>induction</code> 就会表现得很糟糕。这个例子里面 <code>String a s</code> and <code>Star re</code> 都是表达式，不是变量。</p><p>在这种情况下，我们可以使用 <code>remember (String a s). remember (Star re).</code> 来把这两个表达式替换成变量：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">a</span> <span class="o">:</span> <span class="kt">ascii</span>
<span class="n">s</span> <span class="o">:</span> <span class="kt">string</span>
<span class="n">re</span> <span class="o">:</span> <span class="n">reg_exp</span>
<span class="n">s0</span> <span class="o">:</span> <span class="kt">string</span>
<span class="n">Heqs0</span> <span class="o">:</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s</span>
<span class="n">r</span> <span class="o">:</span> <span class="n">reg_exp</span>
<span class="n">Heqr</span> <span class="o">:</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Star</span> <span class="n">re</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">r</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s2</span> <span class="o">=~</span> <span class="n">r</span>
</code></pre></div><p>现在我们就可以 <code>induction H; try discriminate.</code>，现在就只剩下一个可以证明的目标了：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">a</span> <span class="o">:</span> <span class="kt">ascii</span>
<span class="n">s</span> <span class="o">:</span> <span class="kt">string</span>
<span class="n">re</span> <span class="o">:</span> <span class="n">reg_exp</span>
<span class="n">s0</span><span class="o">,</span> <span class="n">sk</span> <span class="o">:</span> <span class="kt">string</span>
<span class="n">Heqs0</span> <span class="o">:</span> <span class="n">sk</span> <span class="o">++</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s</span>
<span class="n">re0</span> <span class="o">:</span> <span class="n">reg_exp</span>
<span class="n">Heqr</span> <span class="o">:</span> <span class="n">Star</span> <span class="n">re0</span> <span class="o">=</span> <span class="n">Star</span> <span class="n">re</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re0</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">sk</span> <span class="o">=~</span> <span class="n">re0</span>
<span class="n">IHexp_match1</span> <span class="o">:</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s</span> <span class="o">-&gt;</span>
               <span class="n">Star</span> <span class="n">re0</span> <span class="o">=</span> <span class="n">Star</span> <span class="n">re</span> <span class="o">-&gt;</span>
               <span class="k">exists</span> <span class="n">s0</span> <span class="n">s1</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s1</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re0</span>
<span class="n">IHexp_match2</span> <span class="o">:</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s</span> <span class="o">-&gt;</span>
               <span class="n">re0</span> <span class="o">=</span> <span class="n">Star</span> <span class="n">re</span> <span class="o">-&gt;</span>
               <span class="k">exists</span> <span class="n">s0</span> <span class="n">s1</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s1</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">re0</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s2</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re0</span>
</code></pre></div><h2><code>induct</code> (Frap Tactic)</h2><p><code>induct</code> 是 <code>frap</code> 库里面一个更强版本的 <code>induction</code>。你不需要使用 <code>remember</code>，而且甚至可以得到更强的结论。比如上面的例子，如果我们直接 <code>induct H.</code>，我们就会有：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">re</span> <span class="o">:</span> <span class="n">reg_exp</span>
<span class="n">s0</span><span class="o">,</span> <span class="n">sk</span> <span class="o">:</span> <span class="kt">string</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re</span>
<span class="n">H0</span> <span class="o">:</span> <span class="n">sk</span> <span class="o">=~</span> <span class="n">re</span>
<span class="n">IHexp_match1</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">ascii</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="kt">string</span><span class="o">)</span> <span class="o">(</span><span class="n">re0</span> <span class="o">:</span> <span class="n">reg_exp</span><span class="o">),</span>
               <span class="n">s0</span> <span class="o">=</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s</span> <span class="o">-&gt;</span>
               <span class="n">Star</span> <span class="n">re</span> <span class="o">=</span> <span class="n">Star</span> <span class="n">re0</span> <span class="o">-&gt;</span>
               <span class="k">exists</span> <span class="n">s0</span> <span class="n">s1</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s1</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re0</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re0</span>
<span class="n">IHexp_match2</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">ascii</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="kt">string</span><span class="o">)</span> <span class="o">(</span><span class="n">re0</span> <span class="o">:</span> <span class="n">reg_exp</span><span class="o">),</span>
               <span class="n">sk</span> <span class="o">=</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s</span> <span class="o">-&gt;</span>
               <span class="n">re</span> <span class="o">=</span> <span class="n">Star</span> <span class="n">re0</span> <span class="o">-&gt;</span>
               <span class="k">exists</span> <span class="n">s0</span> <span class="n">s1</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">++</span> <span class="n">s1</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s0</span> <span class="o">=~</span> <span class="n">re0</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re0</span>
<span class="n">a</span> <span class="o">:</span> <span class="kt">ascii</span>
<span class="n">s</span> <span class="o">:</span> <span class="kt">string</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">sk</span> <span class="o">++</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">String</span> <span class="n">a</span> <span class="n">s</span>
<span class="o">______________________________________(</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">)</span>
<span class="k">exists</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">:</span> <span class="kt">string</span><span class="o">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span> <span class="o">/\</span> <span class="o">(</span><span class="n">String</span> <span class="n">a</span> <span class="n">s1</span> <span class="o">=~</span> <span class="n">re</span><span class="o">)</span> <span class="o">/\</span> <span class="n">s2</span> <span class="o">=~</span> <span class="n">Star</span> <span class="n">re</span>
</code></pre></div><p>这里的归纳假设比原来更强了。所以说如果有可能的话，我都会使用 <code>induct</code> 来替代 <code>induction</code>。</p><h2>Vernacular Commands</h2><h2><code>Print</code></h2><p>你可以用 <code>Print</code> 来检查定义。比方说 <code>Print or.</code>：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Inductive</span> <span class="n">or</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">|</span> <span class="n">or_introl</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">\/</span> <span class="n">B</span>
<span class="o">|</span> <span class="n">or_intror</span> <span class="o">:</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">\/</span> <span class="n">B</span><span class="o">.</span>
</code></pre></div><h2><code>Search</code></h2><p>要想找到一个你想要的 Coq 内置的定理是很难的。有一次我遇到了一个情况，我需要翻转一个不等于关系：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">H1</span> <span class="o">:</span> <span class="n">x1</span> <span class="o">&lt;&gt;</span> <span class="n">x2</span>
<span class="n">H5</span> <span class="o">:</span> <span class="n">x2</span> <span class="o">&lt;&gt;</span> <span class="n">x1</span> <span class="o">-&gt;</span> <span class="o">~</span> <span class="n">free</span> <span class="n">e1</span> <span class="n">x2</span>
</code></pre></div><p>虽然说这个对人类来说非常的显然，但是对 Coq 来说并不是。后来，我发现，只要我知道怎么表达我需要的定理，我就可以用 <code>Search</code> 来找到它。在这个例子里面，我想要的定理是这样的：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Search</span> <span class="o">(</span><span class="k">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">&lt;&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">&lt;&gt;</span> <span class="n">a</span><span class="o">).</span>
</code></pre></div><p>然后 Coq 就会神奇般地告诉我：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">not_eq_sym</span><span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">&lt;&gt;</span> <span class="n">x</span>
</code></pre></div><p>再举一个我遇到的情况：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">IHtyped</span> <span class="o">:</span> <span class="n">E0</span> <span class="o">=</span> <span class="n">E0</span> <span class="o">-&gt;</span>
          <span class="n">heap_typed</span> <span class="n">ht</span> <span class="n">h</span> <span class="o">-&gt;</span>
          <span class="o">(</span><span class="k">exists</span> <span class="o">(</span><span class="n">e'</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">heap</span><span class="o">),</span> <span class="n">h</span><span class="o">;</span> <span class="n">e</span> <span class="o">==&gt;</span> <span class="n">h'</span><span class="o">;</span> <span class="n">e'</span><span class="o">)</span> <span class="o">\/</span> <span class="n">isValue</span> <span class="n">e</span>
</code></pre></div><p>我怎么才能告诉 Coq 所有东西都会等于自身呢？</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Search</span> <span class="o">(</span><span class="k">forall</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">).</span>
</code></pre></div><p>于是我知道了：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="n">eq_refl</span><span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
</code></pre></div><p>不过有时候你不确定怎么表达一个定理（比方说，我就不知道怎么表达“<code>x = y</code> 和 <code>x &lt;&gt; y</code> 两者必有一个成立”），在这种情况下，你可以尝试搜索名字，比方说 <code>Search "eq".</code>。Coq 会告诉你所有沾有 <code>eq</code> 两字的定理，然后你就可以一条条地看过去。</p><h2>Tricks</h2><h2>对什么进行归纳？</h2><p>归纳一般来说会反映定义。比方说：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Lemma</span> <span class="n">len_app_plus</span><span class="o">:</span>
  <span class="k">forall</span> <span class="n">s1</span> <span class="n">s2</span><span class="o">,</span>
    <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="o">(</span><span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span><span class="o">)</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="n">s2</span><span class="o">.</span>
</code></pre></div><p>要证明 <code>len_app_plus</code>，就对 <code>s1</code> 进行归纳，因为 <code>String.length</code> 在每次迭代中会消耗字符串的第一个字符。当你对 <code>s1</code> 进行归纳的时候，第二个情况会是 <code>s1 = String ch s</code>，也就是一个字符后面跟着一个字符串，这就对应了 <code>String.length</code> 的定义，所以说我们就可以应用归纳假设。</p><p>再举一个例子：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Lemma</span> <span class="n">len_repeat</span><span class="o">:</span>
  <span class="k">forall</span> <span class="n">s</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="o">(</span><span class="kr">repeat</span> <span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">String</span><span class="o">.</span><span class="n">length</span> <span class="n">s</span><span class="o">.</span>
</code></pre></div><p>类似地，要证明 <code>len_repeat</code>，我们就要对 <code>n</code> 进行归纳，因为 <code>repeat</code> 是定义在 <code>n</code> 上的一个递归。</p><h2>缩进和子弹点</h2><p>我不确定 Coq 社区是如何看待缩进的，但是我来自一个很强的编程背景，所以我就会希望我的证明也能有缩进来反映证明的结构。</p><p>Coq 会忽略空白字符和空行，但是 Coq 提供了子弹点来区分不同的小目标：<code>+</code>、<code>-</code>、<code>*</code>、以上符号的重复（<code>++</code>、<code>***</code>、……）以及一对 <code>{}</code>。所以你可以这么写证明：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Proof</span><span class="o">.</span>
<span class="n">tactic</span><span class="o">.</span>             <span class="c">(* become two subgoals after this *)</span>
<span class="o">+</span> <span class="n">tactic</span><span class="o">.</span>           <span class="c">(* enter "+", level 1, focus only one subgoal *)</span>
  <span class="n">tactic</span><span class="o">.</span>           <span class="c">(* become three subgoals after this *)</span>
  <span class="o">-</span> <span class="n">tactic</span><span class="o">.</span>         <span class="c">(* enter "-", level 2, focus only one subgoal, and prove it *)</span>
  <span class="o">-</span> <span class="n">tactic</span><span class="o">.</span>         <span class="c">(* focus another level 2 subgoal, and prove it *)</span>
  <span class="o">-</span> <span class="n">tactic</span><span class="o">.</span>         <span class="c">(* focus another L2 subgoal, become two subgoals after this *)</span>
    <span class="o">*</span> <span class="n">tactic</span><span class="o">.</span>       <span class="c">(* enter "*", level 3, focus only one subgoal *)</span>
      <span class="n">tactic</span><span class="o">.</span>       <span class="c">(* become two subgoals after this *)</span>
      <span class="o">{</span> <span class="n">tactic</span><span class="o">.</span>     <span class="c">(* enter "{}", level 4, focus only one subgoal *)</span>
        <span class="n">tactic</span><span class="o">.</span>     <span class="c">(* become two subgoals after this *)</span>
        <span class="o">-</span> <span class="n">tactic</span><span class="o">.</span>   <span class="c">(* enter "-" inside "{}", level 5, focus only one subgoal *)</span>
          <span class="n">tactic</span><span class="o">.</span>
          <span class="o">+</span> <span class="n">tactic</span><span class="o">.</span> <span class="c">(* level 6 *)</span>
          <span class="o">+</span> <span class="n">tactic</span><span class="o">.</span>
        <span class="o">-</span> <span class="n">tactic</span><span class="o">.</span> <span class="o">}</span> <span class="c">(* prove another "-" inside "{}" and finish the first "{}" *)</span>
      <span class="o">{</span> <span class="n">tactic</span><span class="o">.</span>     <span class="c">(* enter another "{}" subgoal *)</span>
        <span class="n">tactic</span><span class="o">.</span> <span class="o">}</span>   <span class="c">(* finish the subgoal *)</span>
    <span class="o">*</span> <span class="n">tactic</span><span class="o">.</span>
<span class="o">+</span> <span class="n">tactic</span><span class="o">.</span>           <span class="c">(* come back to the very first level *)</span>
<span class="kn">Qed</span><span class="o">.</span>
</code></pre></div><p>虽然说不用子弹点也能完成证明，但是我发现子弹点可以帮助我们追踪证明的结构。在你进入了一个子弹点之后，目标就会变成只有一个。在你结束了这个小目标之后，Coq 会告诉你还有多少这个级别的小目标要证。</p><p>另外，我个人喜欢避免在简单的情况分叉，不然的话这个证明就会看起来往一边偏：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="o">+</span> <span class="n">tactic</span><span class="o">.</span>
<span class="o">+</span> <span class="n">tactic</span><span class="o">.</span>
  <span class="o">-</span> <span class="n">tactic</span><span class="o">.</span>
  <span class="o">-</span> <span class="n">tactic</span><span class="o">.</span>
    <span class="o">*</span> <span class="n">tactic</span><span class="o">.</span>
    <span class="o">*</span> <span class="n">tactic</span><span class="o">.</span>
      <span class="o">++</span> <span class="n">tactic</span><span class="o">.</span>
      <span class="o">++</span> <span class="n">tactic</span><span class="o">.</span>
         <span class="o">**</span> <span class="n">tactic</span><span class="o">.</span>
         <span class="o">**</span> <span class="n">tactic</span><span class="o">.</span>
            <span class="o">--</span> <span class="n">tactic</span><span class="o">.</span>
            <span class="o">--</span> <span class="n">tactic</span><span class="o">.</span>
               <span class="o">{</span> <span class="n">tactic</span><span class="o">.</span> <span class="o">}</span>
               <span class="o">{</span> <span class="n">tactic</span><span class="o">.</span>
                 <span class="o">+</span> <span class="n">tactic</span><span class="o">.</span>
                 <span class="o">+</span> <span class="n">tactic</span><span class="o">.</span>
                   <span class="o">-</span> <span class="n">tactic</span><span class="o">.</span>
                   <span class="o">-</span> <span class="n">tactic</span><span class="o">.</span> <span class="o">}</span>
</code></pre></div><p>要避免这种无意义的分叉有若干种办法：</p><ul><li>如果有若干个情况，但是只有一个是有意义的</li><li>用 <code>;</code> 和 <code>try</code>，比方说 <code>destruct c2; try discriminate.</code></li><li>如果恰好只有两个情况</li><li>如果显然的情况是在第一个，那就直接证明，不要用子弹点</li><li>如果显然的情况是在第二个，可以用 <code>2:</code> 跳到第二个情况，比方说 <code>destruct s2. 2: inversion x.</code> 还有 <code>cases (ascii_dec a0 a0). 2: congruence.</code></li></ul><h2>在一行里面写多个招式</h2><p>我发现把紧密相关的几句话写在一行里面实际上会让证明看起来更清楚。比方说：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="k">inversion</span> <span class="n">H</span><span class="o">.</span> <span class="k">subst</span><span class="o">.</span>
<span class="n">cases</span> <span class="o">(</span><span class="n">ascii_dec</span> <span class="n">a0</span> <span class="n">a0</span><span class="o">).</span> <span class="mi">2</span><span class="o">:</span> <span class="kp">congruence</span><span class="o">.</span>
<span class="k">econstructor</span><span class="o">;</span> <span class="k">eauto</span><span class="o">.</span>
</code></pre></div><p>看起来就比下面这个好：</p><div class="highlight"><pre><code class="language-coq"><span></span><span class="k">inversion</span> <span class="n">H</span><span class="o">.</span>
<span class="k">subst</span><span class="o">.</span>
<span class="n">cases</span> <span class="o">(</span><span class="n">ascii_dec</span> <span class="n">a0</span> <span class="n">a0</span><span class="o">).</span>
<span class="mi">2</span><span class="o">:</span> <span class="kp">congruence</span><span class="o">.</span>
<span class="k">econstructor</span><span class="o">.</span>
<span class="k">eauto</span><span class="o">.</span>
</code></pre></div><p>尤其是当证明很长、子弹点很多的时候。</p><h2>向前证明和向后证明</h2><p>有两种证明的风格，向前和向后。向前证明就是一直加入假设，直到目标已经在假设里面了。向后证明就是一直对目标进行变换，直到目标已经在假设里面了。</p><p>一般来说这两者会混着来，因为有时候 <code>pose proof</code> 更容易，有时候 <code>apply</code> 定理更容易，或者用 <code>e</code> 系列的招数让 Coq 自动把问题解决。</p><h2>显示记号</h2><p>一开始看到 Coq 里面奇奇怪怪的符号的时候非常吓人，但其实他们一般来说就只是记号（<i>notation</i>）而已，并不是什么特殊的东西，你甚至可以为你自己的归纳类型添加记号。</p><p>但是当记号妨碍你理解的时候，你可以选择不显示它们。在 CoqIDE 里面，这个选项是在 <i>View / Display notations</i>。</p><h2>FAQ</h2><h2>已知 <code>Some x = Some y</code>，怎么变成 <code>x = y</code>？</h2><p><code>inversion</code>.</p><h2>求证 <code>Some x = Some y</code>，怎么转变成证明 <code>x = y</code>？</h2><p><code>f_equal</code>.</p><h2>已知 <code>x &lt;&gt; y</code>，怎么变成 <code>y &lt;&gt; x</code>？</h2><div class="highlight"><pre><code class="language-coq"><span></span><span class="kn">Search</span> <span class="o">(</span><span class="k">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">&lt;&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">&lt;&gt;</span> <span class="n">a</span><span class="o">).</span>

<span class="n">not_eq_sym</span><span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">&lt;&gt;</span> <span class="n">x</span>
</code></pre></div><h2>怎么说明要么 <code>x = y</code>，要么 <code>x &lt;&gt; y</code>？</h2><p>一般来说这个是叫做 <code>_dec</code>，比方说：</p><ul><li><code>ascii_dec</code></li><li><code>string_dec</code></li><li><code>Nat.eq_dec</code></li></ul><p>你可以用 <code>destruct (string_dec x y).</code> 来分类讨论这两种情况。</p><h2>我的假设里面有 <code>/\</code> 或 <code>\/</code> 怎么办？</h2><p><code>first_order</code> 或者 <code>destruct</code>。</p><h2>我的目标里面有 <code>/\</code> 或 <code>&lt;-&gt;</code> 怎么办？</h2><p><code>first_order</code> 或者 <code>split</code>。</p><h2>我的目标里面有 <code>\/</code> 怎么办？</h2><p>用 <code>left.</code> 或者 <code>right.</code> 来证明两者中的其中一个。</p><h2>怎么样复制一份假设？</h2><p><code>assert</code>。</p><h2>怎么样把一个命题加到假设里面？</h2><p><code>assert</code>。</p><h2>我的假设里面有矛盾怎么办？</h2><p>比方说现在有一个 <code>H : False</code> 或者任何能被转化成 <code>False</code> 的假设（比方说 <code>Some x = None</code>、<code>1 = 2</code> 或者 <code>True = False</code>），那么恭喜，试试看 <code>discriminate.</code> 或者 <code>congruence.</code>，这个证明就结束了。</p><p>这是因为从逻辑上说，一个假的命题可以推导出任何东西。</p><h2>我的假设里面的前提条件有矛盾怎么办？</h2><p>比方说现在有一个 <code>H : Some x = None -&gt; P</code>，那么现在你就只能 <code>clear H.</code> 把它删掉了，因为你永远没有办法使用 <code>H</code>。这跟前面的条件不一样，因为你没办法证明 <code>Some x = None</code> 所以你没办法去掉 <code>H</code> 里面的前提条件，所以 <code>P</code> 无法成立。</p><h2>目标是个矛盾怎么办？不可证怎么办？</h2><p>如果你的目标是 <code>False</code> 或者 <code>Some x = None</code> 或者任何类似的不可证的东西，别慌张，先检查一下假设里面有没有任何能导出矛盾的地方，因为假命题可以推导出任何东西，包括假命题。</p><p>如果所有的假设都很合理，那就说明你在之前的步骤中做错了事情。把它找出来，改掉。</p><h2>目标里面有 <code>-&gt;</code> 怎么办？</h2><p><code>intros</code>。</p><h2>目标以 <code>forall</code> 开头怎么办？</h2><p><code>intros</code>。</p><h2>目标以 <code>exists</code> 开头怎么办？</h2><p>一般来时我会用 <code>exists</code> 告诉 Coq 这些变量是什么，但是你也可以用 <code>eexists.</code> 向前推进证明，然后到某个时刻 Coq 会自动推导出来这个变量是什么。</p><h2>我的假设以 <code>forall</code> 开头怎么办？</h2><p><code>specialize</code> 或者 <code>pose proof</code>。</p><h2>我的假设以 <code>exists</code> 开头怎么办？</h2><p><code>destruct</code> 来把这个变量取出来。</p><h2>我的假设里面有 <code>-&gt;</code> 怎么办？</h2><p><code>specialize</code> 或者 <code>pose proof</code>。</p><h2>怎么样才能跳过这个小目标去证下一个？</h2><p><code>admit</code>。</p><hr><p>首发于博客</p><a href="http://link.zhihu.com/?target=https%3A//abcdabcd987.com/coq/" data-draft-node="block" data-draft-type="link-card" class=" wrap external" target="_blank" rel="nofollow noreferrer">Coq 小技巧</a><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
