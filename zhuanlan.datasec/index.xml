<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>数据安全、隐私保护与密码学技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/</link>
<description>本专栏主要发布如下内容： 1. 国际黑帽子大会（… 本专栏主要发布如下内容： 1. 国际黑帽子大会（Black Hat），国际黑客大会（Def Con）上的演讲内容分析； 2. 密码学、网络安全相关的源代码分析； 3. 密码学、网络安全相关的知识介绍； 4. 业内可公开的安全架构思想； 5. 其他与信息安全相关的内容或转载文章； 欢迎投稿，欢迎指出任何错误~ 希望我们能够一起为普及、分享、研究信息安全相关理论和知识贡献自己的一份力量！</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 08 Aug 2019 11:51:55 +0800</lastBuildDate>
<item>
<title>传输短秘密值的条件下提高OT扩展协议的效率</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-08-05-76647738.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/76647738&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7b01b1ba136277a4576b00ee4b38443b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;最近收到了一位知友的私信，询问能否把《Winter School on Cryptography 2012: Lattice-Based Cryptography》的一系列字幕也发布出来，供参考和学习。经过与 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b&quot; data-hash=&quot;60a93d8892402f3493146a4fd54c5f2b&quot; data-hovercard=&quot;p$b$60a93d8892402f3493146a4fd54c5f2b&quot;&gt;@i春秋学院&lt;/a&gt; 当时字幕负责人的讨论，由于相关字幕已经发布了很长时间，我已经可以将字幕发布出来供知友们学习了！因此，在接下来一段时间，我会集中整理《Winter School on Cryptography 2012: Lattice-Based Cryptography》的字幕，重新压制视频并放出。感谢 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b&quot; data-hash=&quot;60a93d8892402f3493146a4fd54c5f2b&quot; data-hovercard=&quot;p$b$60a93d8892402f3493146a4fd54c5f2b&quot;&gt;@i春秋学院&lt;/a&gt; 一直以来的支持！&lt;/p&gt;&lt;p&gt;虽然会集中整理之前的字幕，但是我也会不断听写新的视频，如果有任何顶级安全会议中数据安全相关讲座的听译需求，还请知友们私信我，或者直接在评论区留言。对于一些很大工作量的听译工作（如《Winter School on Cryptography 2015: Practical Secure Multi-Party Computation》这类），我也会持续坚持听译，到合适的时间再对外发布，敬请知友们耐心等待。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为知友们带来的视频是CRYPTO 2013论文《Improved OT Extension for Transferring Short Secrets》。OT Extension协议是安全多方计算中最重要、也是最核心的协议。熟悉OT的知友们可能知道，OT Extension中最核心的论文应该是CRYPTO 2003的《Extending Oblivious Transfer Efficiently》以及CCS 2013的《More Efficient Oblivious Transfer and Extensions for Faster Secure Computation》。不过我一直没有找到这两个讲座的视频，如果哪位知友知道视频链接，也可以在评论区告诉我。&lt;/p&gt;&lt;p&gt;《Improved OT Extension for Transferring Short Secrets》的重要程度相对这两篇论文来说没有那么高，但这篇论文是优化GMW协议的重要理论基础。如果想实现基于GMW协议的安全多方计算应用，这篇论文的阅读和实现也是必不可少的。CRYPTO 2013对应的演讲视频介绍了《Improved OT Extension for Transferring Short Secrets》的基本思想，观看视频后再去读论文会有更深入的理解。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DAgPZVecLuXs&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=AgPZVecLuXs&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av62237491/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av62&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;237491/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/CRYPTO%25202013/Improved%2520OT%2520Extension%2520for%2520Transferring%2520Short%2520Secrets&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/CRYPTO%202013/Improved%20OT%20Extension%20for%20Transferring%20Short%20Secrets&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1141506723897516032&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png&quot; data-lens-id=&quot;1141506723897516032&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1141506723897516032&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢主持人的介绍。此工作是我与来自贝尔实验室的Vladimir Kalashnikov所共同完成的。我们工作针对的目标是安全计算，这是密码学上一个非常典型、非常普遍的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当前有很多重要的研究进展，尝试让安全计算从理论走向实际。这些工作的目标不仅是要提高协议的渐进效率，还要提高协议的真实执行效率。还有一些工作的方向是具体协议的实现，解决系统层面的问题。&lt;/p&gt;&lt;p&gt;在过去的5年，无论是理论角度还是实际角度，此领域都诞生了极多的突破性成果。从理论角度，我们得到了很多惊人的结论。我们现在只需要引入常数级额外开销，即可完成安全计算或安全函数求值。另一个突破是全同态加密。对于多种类型的函数，我们甚至可以在最优通信复杂度下构建安全计算协议。还可以使用基于ORAM的安全计算协议，利用RAM计算模型的优势完成安全计算，这样我们就能在次线性时间复杂度下完成安全计算。在实践角度，针对姚氏协议和GMW协议，学者们提出了很多算法或实现层面的优化，也尝试混合使用姚氏协议和GMW协议。特别地，姚氏协议的实现结果令人印象深刻。现在，我们可以在637毫秒内执行完AES的乱码电路。&lt;/p&gt;&lt;p&gt;虽然在实现层面和理论层面我们都得到了令人惊讶的成果，但在右侧，效率最高的协议仍然是20世纪80年代提出的姚氏协议和GMW协议。之所以这样，有一个很直观的原因：理论成果虽然引入常数复杂度，但这个常数可能非常大。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际应用时，可能存在这样一个复杂度与效率的层级关系。FHE的复杂度目前、以后也总会比公钥密码学原语的复杂度高几个量级。公钥密码学原语的复杂度目前、以后也总会比对称密码学原语的复杂度高几个量级。对称密码学原语的复杂度目前、以后也总会比一次一密的复杂度高几个量级。本次演讲的主题是OT扩展，其出发点就是减小公钥操作和对称密码操作的效率鸿沟。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在第一部分演讲中，我会详细介绍OT扩展的研究出发点，并解释OT扩展面临的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;诸如密钥协商、不经意传输等公钥密码学原语一般都很难高效实现。公钥密码学原语天生要依赖于某类代数结构，因此也会遭受很多密码学攻击。因此，相应的参数需要设置得比较大。这导致公钥密码学的计算复杂度也相对较高。另一方面，我们更容易实现伪随机数生成器或哈希函数等对称密码学运算。学者们设计出了很多算法，相应的参数要比公钥密码学小得多，实际中也可以更容易、更轻量级地实现对称密码学运算。这个结论背后还有相应的理论支撑。理论上，无法通过黑盒方式应用对称密码学原语构造大多数公钥密码学原语。这意味着公钥密码学原语和对称密码学原语的性能差约为3至4个数量级。对于诸如AES等被广泛使用的特定对称密码学操作，Intel专门提供了对应的指令集，进一步提高了这类运算的执行效率。因此，我们无法通过对称密码学原语实现公钥密码学原语。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那接下来该怎么办？或许可以用少量公钥原语实例和大量对称密码学操作，生成大量公钥实例。这一技术称为“扩展原语”。我们已经知道，很容易扩展公钥加密体制，具体过程是用对称加密算法加密具体的明文，用公钥加密算法加密对称加密的密钥。这样一来，我们只需要执行一次公钥操作。这一技术在我们每天使用的加密过程中起到了非常重要的作用。我们可以很自然地把这个问题展开：是否可以扩展其它公钥密码学原语。如OT？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;回忆一下不经意传输要解决的问题。发送方有两个输入： &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_0&quot; alt=&quot;x_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1&quot; alt=&quot;x_1&quot; eeimg=&quot;1&quot;/&gt; 。接收方有一个输入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。协议执行完毕后，发送方无法得到任何信息，接收方可以得到与其选择比特关联的发送方输入。OT是SFE的基础构建模块。姚氏电路中应用不经意传输实现了乱码密钥的2选1过程。在GMW协议中，OT的用途更加广泛，每个AND门的求值过程都要使用一次OT协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们知道OT的执行开销非常大，我们无法通过对称密码学操作实现OT。但假设我们有一个可以传输短字符串的OT，通过使用标准的伪随机数生成器，我们能得到可以传输长字符串的OT。这一技术称为“OT长度扩展”。&lt;/p&gt;&lt;p&gt;还有一个更难解决的问题，称为“OT实例扩展”，简称“OT扩展”。幸运的是，我们知道OT扩展是可行的。我们只需要 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个公钥密码学操作，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个种子OT，再加上 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 次对称密码学操作。应用这 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 次公钥密码学操作，我们就可以执行任意多项式大小次的OT操作。这一技术大幅降低了公钥密码学运算次数，对SFE的实际应用起到了重要的作用。近期大多数SFE的实现都应用了OT扩展协议，从而提高协议的执行效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Beaver在1996年提出了第一个OT扩展协议。第一个高效的OT扩展协议由Ishai、Kilian、Nissim和Petrank给出。此协议也称为IKNP协议，对应的论文发表在CRYPTO 2003上。后续，学者们期望在恶意攻击场景下提高OT扩展协议的执行效率。学者们同时也在加深对OT扩展协议的理解，从而知道OT扩展协议的上限是什么。在本工作中，我们将在半可信场景下提高IKNP协议的效率。我们给出了协议的渐进优化方法和实际优化方法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在接下来的讲座中，我们会描述Ishai等人的OT扩展协议构造。实际上，我们将直接使用Ishai等人CRYPTO 2003的演讲幻灯片。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;IKNP第一个、也是最重要的步骤是将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT归约为传输 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 比特字符串的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT。这一步骤将引入额外的、线性数量级的对称密码学操作。下一步是长度扩展步骤，我们之前已经讲解过这一步骤了。这可以让我们把长字符串OT协议归约为短字符串OT协议。这一步骤进一步引入了线性数量级的对称密码学操作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在核心归约步骤中，我们让接收方选择一个随机的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5Ctimes+k&quot; alt=&quot;n\times k&quot; eeimg=&quot;1&quot;/&gt; 矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 。随后，发送方选择一个随机的行向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;/&gt; 。接下来，接收方和发送方执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT协议，但此OT协议中两个参与方的角色互换。在每个OT协议中，接收方要选择长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 的两列比特值。每对比特值中。第一列为矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 中的某一列，第二列为第一列比特值与选择向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 的异或结果。发送方实际上应用它随机选择的行向量在接收方的两列比特值中选择一列。&lt;/p&gt;&lt;p&gt;这样，发送方通过OT协议得到了一个矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; 。我们来看看矩阵 Q 满足何种性质。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D0&quot; alt=&quot;r_i=0&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，收到的每对比特值就不太一样了。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，在IKNP协议中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i%5Coplus+s&quot; alt=&quot;q_i=t_i\oplus s&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;注意到，在第一种情况下，接收方知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+&quot; alt=&quot;t_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; 。因此，在第一种情况下，接收方能得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。在第二种情况下， 接收方能得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s+&quot; alt=&quot;q_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; ，也就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 。这意味着我们或许可以使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 作为OT协议中的数据加密密钥。但需要注意的是，我们必须要破坏矩阵中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的相互关系。我们应用随机预言机 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H&quot; alt=&quot;H&quot; eeimg=&quot;1&quot;/&gt; 来破坏 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的相互关系。最后，接收方根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 选择得到它的输出，也就是应用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 进行解密。&lt;/p&gt;&lt;p&gt;IKNP协议非常简单、非常优雅、效率极高。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们考虑 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT协议所需要的通信开销。其中发送方输入的长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L&quot; alt=&quot;L&quot; eeimg=&quot;1&quot;/&gt; 。大家已经了解到，核心归约步骤就是对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_%7Bi%2C0%7D&quot; alt=&quot;x_{i,0}&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_%7Bi%2C1%7D&quot; alt=&quot;x_{i,1}&quot; eeimg=&quot;1&quot;/&gt; 加密，这需要发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nL&quot; alt=&quot;2nL&quot; eeimg=&quot;1&quot;/&gt; 比特的数据。在长度扩展步骤中，我们要应用一个PRG，这需要发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nk&quot; alt=&quot;2nk&quot; eeimg=&quot;1&quot;/&gt; 比特的数据。&lt;/p&gt;&lt;p&gt;在姚氏电路中，我们需要传输长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3Dk&quot; alt=&quot;L=k&quot; eeimg=&quot;1&quot;/&gt; 的密钥，因此核心归约步骤和长度扩展步骤中的通信开销相同。在GMW中，我们只需要传输 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3D1&quot; alt=&quot;L=1&quot; eeimg=&quot;1&quot;/&gt; 的信息。令人惊讶的是，这一场景下长度扩展步骤的通信开销远高于核心归约步骤的通信开销。这就是一个问题了，我们可能可以在这一场景下对通信开销进行优化。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在讲座的后半部分，我们会提出IKNP的通用框架。我们也会向大家展示如何提高IKNP的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们先来详细分析一下IKNP协议。可以看到，接收方要选择这个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5Ctimes+k&quot; alt=&quot;n\times k&quot; eeimg=&quot;1&quot;/&gt; 的随机矩阵。随后，接收方要生成另一个矩阵，这个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列为第一个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列异或选择向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。换句话说， &lt;img src=&quot;https://www.zhihu.com/equation?tex=U%3D+T+%5Coplus+R&quot; alt=&quot;U= T \oplus R&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 是所有列均相等的矩阵，每个列都为接收方的选择向量。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果我们从行的视角看，就会发现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 行为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; ，这意味着 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 的每一行都是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 的一种编码。在IKNP协议中， &lt;img src=&quot;https://www.zhihu.com/equation?tex=0&quot; alt=&quot;0&quot; eeimg=&quot;1&quot;/&gt; 被映射为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=0%5Ek&quot; alt=&quot;0^k&quot; eeimg=&quot;1&quot;/&gt; ，而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 被映射为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1%5Ek&quot; alt=&quot;1^k&quot; eeimg=&quot;1&quot;/&gt; 。因此，我们可以看到IKNP这一高效协议在底层执行了一次逐行重复编码。这自然引出了一个问题：我们是否可以使用更复杂的编码？毕竟，重复编码是一种最简单的编码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;假设我们使用编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; ，并且我们假定 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 属于一个很大的域，域为从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 。我们用编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 映射成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29+&quot; alt=&quot;C(r_i) &quot; eeimg=&quot;1&quot;/&gt; ，这是一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 比特长字符串。现在，接收方需要用选择比特 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 构建矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 。我们来看看，在这个理论框架下IKNP协议的执行过程。&lt;/p&gt;&lt;p&gt;第一步，接收方获得了矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 。随后，接收方用加法秘密分享方案将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 分享为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29%3D+T+%5Coplus+U&quot; alt=&quot;C(R)= T \oplus U&quot; eeimg=&quot;1&quot;/&gt; 。接下来，接收方和发送方角色互换，执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT协议。在第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 个OT中，接收方的输入是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t%5Ei&quot; alt=&quot;t^i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u%5Ei&quot; alt=&quot;u^i&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列。执行完OT协议后，发送方得到矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; 。在IKNP协议中，我们知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 或者等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，或者等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+&quot; alt=&quot;t_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; 。在这一理论框架中，我们可以知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+%28C%28r_i%29+%5Codot+s%29&quot; alt=&quot;q_i=t_i \oplus (C(r_i) \odot s)&quot; eeimg=&quot;1&quot;/&gt; ，结果不算太复杂。&lt;/p&gt;&lt;p&gt;我们可以验证一下，当C是重复编码时 此框架对应的协议就是IKNP协议。特别地，当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D0&quot; alt=&quot;r_i=0&quot; eeimg=&quot;1&quot;/&gt; 时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29&quot; alt=&quot;C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 是一个全 &lt;img src=&quot;https://www.zhihu.com/equation?tex=0&quot; alt=&quot;0&quot; eeimg=&quot;1&quot;/&gt; 向量，因此我们得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; 时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29&quot; alt=&quot;C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 是一个全 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 向量，此时我们可以得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+s&quot; alt=&quot;q_i=t_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。这样一来，我们得到了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 个密钥。后面的执行过程就完全一样了，密钥生成算法为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+%28C%28r%29+%5Codot+s%29&quot; alt=&quot;q_i \oplus (C(r) \odot s)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们仍然可以证明接收方只能知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 。因此接收方只能解密对应的密文，从而得到对应的输入。核心归约步骤在恶意发送方的攻击下是完美安全的。特别地，恶意发送方只能得到矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; ，这是编码的随机独立分享结果。核心归约步骤在半诚实接收方的攻击下是统计安全的。这是因为除了在加密过程中使用了随机预言机之外，核心归约步骤没有安全性损失。因此，整个协议的安全性损失为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 的取值范围，以及 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-d%7D&quot; alt=&quot;2^{-d}&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=d&quot; alt=&quot;d&quot; eeimg=&quot;1&quot;/&gt; 是线性编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 的最小距离。&lt;/p&gt;&lt;p&gt;注意到在此理论框架下，我们可以从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选取消息，因此从效果上看，我们可以实现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT，而不是2选1-OT。但在这种情况下，核心归约步骤的通信开销会从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nL&quot; alt=&quot;2nL&quot; eeimg=&quot;1&quot;/&gt; 提高到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=nmL&quot; alt=&quot;nmL&quot; eeimg=&quot;1&quot;/&gt; 。随后，我们将标准的2选1-OT转换为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%2F%5Clog%28m%29&quot; alt=&quot;n/\log(m)&quot; eeimg=&quot;1&quot;/&gt; 个字符串长度稍长的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT实例，这也允许我们将通信开销表示为与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 相关的函数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我们有了一个自由变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; ，用它来平衡核心归约步骤和长度扩展步骤的开销。具体来说，如果我们使用的是最小距离为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%2F2&quot; alt=&quot;k/2&quot; eeimg=&quot;1&quot;/&gt; 的Hadamard编码，在这种情况下，2选1-OT的通信开销可以降低2倍。在多方GMW协议中，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%3D256&quot; alt=&quot;k=256&quot; eeimg=&quot;1&quot;/&gt; ，则通信开销也可以降低2倍。&lt;/p&gt;&lt;p&gt;也可以进一步优化长度扩展步骤的通信开销，此开销的优化程度是算法层面的，而不是渐进层面的。结合Hadamard编码后，与未优化的IKNP协议相比，新协议的通信开销要降低3.5倍。Asharov等人也独立发现了这一优化点，他们的论文将发表在CCS 2013上。&lt;/p&gt;&lt;p&gt;与IKNP相比，我们从渐进层面降低了每一个OT的通信开销。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3D1&quot; alt=&quot;L=1&quot; eeimg=&quot;1&quot;/&gt; 时，IKNP需要通信 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28k%29&quot; alt=&quot;O(k)&quot; eeimg=&quot;1&quot;/&gt; 比特，而我们需要通信 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28k%2F%5Clog%28k%29%29&quot; alt=&quot;O(k/\log(k))&quot; eeimg=&quot;1&quot;/&gt; 比特。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总结一下，为了平衡公钥密码学原语和对称密码学原语的性能鸿沟，学者们提出了OT扩展协议，这一协议在安全函数求值的实例落地中产生了巨大的影响。在本次讲座中，我们提出了IKNP的编码理论框架。可以在随机预言模型下证明此框架的安全性。随机预言模型也可以换为特定类型哈希函数假设，即相关性健壮哈希函数，这沿用了IKNP中安全性所依赖的相关性健壮哈希函数假设。当使用复杂编码时，此框架提高了多方GMW中2选1-OT和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT的性能。&lt;/p&gt;&lt;p&gt;我想用GMW和姚氏电路的性能对比问题作为讲座的结尾。近期的安全多方计算研究主要关注恶意模型下姚氏电路的性能优化问题。在半可信安全模型下，学者们也提出了很多姚氏电路的优化方法。但近期的一些工作也表明，GMW协议也有很多算法层面的优化点。我们的工作适用于GMW协议。谢谢大家。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-08-05-76647738</guid>
<pubDate>Mon, 05 Aug 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>ObliVM：安全计算编程框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-07-15-73618400.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/73618400&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-83f24da35d88aef9a1bc7d522f42c2cf_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;使用新的方法撰写密码学会议视频分享文章后，虽然点赞和阅读量并没有提升很多，但是根据知友们的反馈，这样做确实可以大幅度提高阅读体验。更开心的是，向知乎反馈后，知乎的工程师们也是大力配合，现在终于支持上传长度不超过60分钟的视频了，撒花庆祝！接下来的视频分享文章中，我会同时在知乎和B站上传翻译视频。知友们可以根据自己的习惯选择在哪个地方观看。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2015年安全顶级会议Security and Privacy 2015的演讲视频《ObliVM：安全计算编程框架》，对应的论文是《ObliVM: A Programming Framework for Secure Computation》。&lt;/p&gt;&lt;p&gt;上一篇文章《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot; class=&quot;internal&quot;&gt;SoK：安全多方计算通用框架&lt;/a&gt;》的视频中，作者调研了9个开源的通用安全计算框架，而ObliVM就是其中的一个。我个人对于“把Alice和Bob作为编程语言的关键词”这一点仍然记忆犹新。这一次，我们就来详细了解一下ObliVM到底是什么。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DQ2QLRcj0Mio%26t%3D92s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=Q2QLRcj0Mio&amp;amp;t=92s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av59239482/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av59&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;239482/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202015/ObliVM%2520A%2520Programming%2520Framework%2520for%2520Secure%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202015/ObliVM%20A%20Programming%20Framework%20for%20Secure%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1134043543998984192&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;ObliVM：安全计算编程框架&quot; data-poster=&quot;https://pic2.zhimg.com/v2-f3c6c88bc65211e0a5428862604b6751.jpg&quot; data-lens-id=&quot;1134043543998984192&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-f3c6c88bc65211e0a5428862604b6751.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;ObliVM：安全计算编程框架&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1134043543998984192&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）大家好，我很高兴能在这里为大家介绍我们的工作：ObliVM，这是一个安全计算的编程框架。这是我和我的队友们一同完成的工作，队友有Xiao Wang，坐在那里的Kartik，还有Yan Huang，还有Elaine Shi。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;很高兴自己在前面的一个演讲中为大家充分介绍了什么是安全计算，或安全函数求值。我这里只需给出一个简短的介绍。例如，Sheldon和Amy希望互相确认自己是不是对方的另一半。他们都相信基因匹配的效果。因此，他们可以执行一个分析过程，看看他们是否匹配。一个很关键的安全问题是：他们不想把敏感的基因数据泄露给对方。我在前面已经讲过了，安全计算是这一问题的绝佳解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以把这个问题抽象成下述形式：给定两个参与方Alice和Bob，以及他们的秘密输入&lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt;，他们希望联合计算一个公开函数&lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28x%2Cy%29&quot; alt=&quot;f(x,y)&quot; eeimg=&quot;1&quot;/&gt;，得到函数的计算结果。同时，除了计算结果&lt;img src=&quot;https://www.zhihu.com/equation?tex=z&quot; alt=&quot;z&quot; eeimg=&quot;1&quot;/&gt;外，涉及两个秘密输入的计算过程不会向对方泄露任何其它信息。这就是安全计算的概念。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家已经知道，安全计算的解决方案有姚氏乱码电路，还有GMW协议。我们关注什么地方呢？我们的关注点是：如何让安全计算能在实际中得到应用？例如，一个开发者希望开发一个安全计算应用。他们肯定不想把函数写成电路的形式。他们想用C语言、Java语言、或者Python语言编写代码。因此，源程序和安全计算协议之间存在很大的鸿沟。这就是我们ObliVM框架要做的事情。我们的ObliVM是一个工具，可以将源代码转换成实际的安全计算协议。这是ObliVM的框架概览。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里面最主要的问题是什么？Kartik已经提到，主要问题是开发人员喜欢用Python等语言模型编写代码。幻灯片左侧是开发人员撰写的源程序。但实际上，大多数安全计算协议是在电路模型下实现的。因此，在高层语言程序和电路程序之间存在很大的鸿沟。我们的问题是，如何将左侧的代码转换为右侧的协议？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢Kartik的讲解，你已经提出了我们工作的出发点。这里的关键挑战是，如何能让动态内存访问过程不泄露信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是一个不太容易解决的挑战。我们的解决方案是：把RAM模型下的问题转换到不经意RAM模型中。不经意的意思是内存访问和指令追踪过程不依赖于秘密输入。这样一来，不经意程序就可以被进一步转换为电路了。我们可以看到，在转换链路中，后一部分相对比较简单，前一部分非常有挑战性。本次讲座主要关注前一部分，解释如何做到这一点。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有一个非常平凡，也不能说非常平凡的解决方案。这个方案于2013年首先提出，基本思想是使用不经意RAM。不经意RAM，又称ORAM，可以把任意程序编译成不经意程序。基于这一思想，我们去年提出了SCVAM框架。此框架可以仿真通用ORAM。可以证明，我们的渐进性能比所有之前的解决方案都要好。这一解决方案是通用的，也很容易实现。但问题在于，这个方案可能不是最高效的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在过去的几年间，我们观察到研究人员提出了很多定制化安全计算协议。这方面的工作有很多，我实在没办法在幻灯片上把所有相关工作都列出来。这些定制化安全计算协议都很高效，可以这么说，这些协议比我们去年的工作都高效。但问题在于，这些协议的设计成本很高。例如，我们与Nina Taft聊了聊，她是我们的合作方。我们私下针对CCS 2013上面发表的隐私矩阵分解算法进行了讨论。她告诉我们，她们组织了5位研究人员，花费了大约4个月的时间才完成了全部的实现。也就是说，整个过程花费了超过1.5年的研究时间。这里涉及到巨大的工作量。我们的问题是：我们能不能做得更好？我们能否构建一个通用框架，但仍然获得定制化协议的执行效率？这就是我们ObliVM的目标。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们希望非领域专家，例如非密码学家，可以用它实现一些安全计算协议，同时获得定制化协议的执行效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何做到这一点？关键思想是：在ObliVM内部，我们提供很多编程抽象接口。我在幻灯片上具体列举了一些，如不经意数据结构、MapReduce、循环合并等。我后面会介绍其中一个抽象接口。如果想了解更多的细节，请阅读我们的论文。我还想提及的是，Kartik刚刚讲解的GraphSC论文也是一个并行计算编程接口抽象。总之，我们提供了一些编程接口抽象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我这里想简单介绍一下编程接口抽象到底是什么。我们来看看分布式计算社区。我估计绝大多数人都听说过MapReduce，这是谷歌于2004年在OSDI会议上发表的论文。在这篇论文发表之前，并行计算、或者说分布式计算，是一个很困难的任务。但通过MapReduce，开发者只需要将计算过程编码在Mapper和Reducer框架中。开发者不需要关注分布式计算方法，MapReduce框架会实现整个分布式计算过程。因此，与之前的工作相比，使用MapReduce涉及的开发工作量会非常小。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们想用与之非常类似的方法解决这一问题。我们希望提供一些抽象接口，允许开发者将计算任务编码在抽象接口中，这样他们就不需要关注底层的密码学原语，但仍然获得相同的计算性能。这就是我们的目标，这就是我们的解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何对外提供这些编程接口抽象？我们希望实现一个新的语言支持体系。例如，我们想为我们的开发者实现一个新的编程语言。在开发这个语言时，我们脑海中有两个目标。第一个目标是：领域专家或密码学家可以很容易地应用此语言实现不同的编程接口。另一方面，对于非专家来说，他们可能不是特别了解密码学技术，他们可以很容易地使用这些编程语言抽象构建他们自己的应用程序。&lt;/p&gt;&lt;p&gt;结合脑海中的这两个目标，我们的解决方案是构建新的语言特性，支持之前系统未无法支持的功能。我这里列举了一些特性，请大家阅读论文，了解相应的技术细节。后续我们会在幻灯片给出的地址上开源我们的编译器，这样大家可以更好地了解编译器的实现细节。我认为这些特性都很不错。例如，我们可以使用随机类型、虚函数等，从源代码阶段，而不是从后端原语阶段，实现不经意RAM协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有了这些编程接口抽象，开发人员该怎么做呢？例如，我们希望实现一个稀疏图算法。我们已经有了编程接口抽象这样一个武器库了。假设我们想要实现稀疏Dijkstra最短距离算法，我们可以选取适当的不经意数据结构，这里要选择不经意堆。随后，我们使用循环合并抽象实现相应的算法。通过使用这些工具，我们实现了3个不同的稀疏图算法。&lt;/p&gt;&lt;p&gt;整个流程好像都走得通，但我们得到了一个超出期望的结果：我们实现的算法从理论角度也得到了突破，所有3个算法的渐进复杂度都比当前最优算法的渐进复杂度低。这个结论令我们感到十分惊讶。如果想了解算法的更多细节，请阅读我们的论文。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;开发人员具体该做些什么呢？我在几分钟之前已经向大家许诺过了，我会为大家介绍一个编程接口抽象：循环合并。这是非常细节的内容了。在安全计算中，实现秘密循环是非常有挑战性的工作，因为循环次数本身就会泄露信息。这里我们允许编程人员编写有上界循环次数限制的循环语句。例如，我们允许协议保护循环次数，但我们要求开发人员公开告知循环次数的上限。&lt;/p&gt;&lt;p&gt;这是一个嵌套循环代码。这里有趣的地方在于，第4行到第7行的内部循环中，循环次数上界m并不是外部循环中每次迭代的最大迭代次数上界，而是两层嵌套代码中，内部循环的总执行次数上界。这样我们可以避免重复的执行过程。例如，如果我们按照传统方法给出上界，则总迭代次数是n•m，但这样设置的总迭代次数是n+m。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们的编译器会分析这段代码，自动将此类形式的代码转换成右下的代码形式。这段代码看起来像是一个状态机，这样就不会为算法引入额外的复杂度了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;应用所有这些技术以后，我们能得到什么呢？我之前已经提到，实现矩阵分解算法涉及的人力开销大约为1年1.5个研究者。如果使用ObliVM呢？结果非常令人惊讶，只需要一天就够了。一个博士研究生只需要一天就可以实现全部功能。&lt;/p&gt;&lt;p&gt;你可能会想，实现结果是否高效？可能自动化的实现结果并不高效。事实上，我们的实现的算法效率要高10到20倍，因此实现结果甚至更高效了。这就是我们现在得到的优化结果。我相信ObliVM对于所有安全计算开发者来说都是一个福音。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们深入解析一下各个优化点所带来的性能提升情况。我们这里给出的是Dijkstra算法的实现结果。论文中给出了更多的实现结果。虽然我们这里只关注ObliVM的编程语言部分，但实际上ObliVM拥有一个经过深度优化的后端ObliVM-SC。此后端代码也开源了，大家可以访问我们的网站，获取源代码链接。&lt;/p&gt;&lt;p&gt;我们实现了一个当前最优的电路ORAM，此ORAM专门为安全计算进行优化。我们将我们的系统和之前在CCS 2012上公开的最佳结果进行了对比，电路ORAM本身可以为我们带来50倍的性能提升。编程语言和编译器可以为我们带来2500倍的性能提升。我们进一步对后后端的其它部分进行了深度优化，可以在我们的论文中找到相应的技术细节描述。这些深度优化可以为我们带来7倍的性能提升。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总体来说，我们获得了大约100,000倍的性能提升，这是很大的性能提升倍数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里给大家一个更直观的方案效率描述。2012年在同一篇论文中，他们在1GB数据集上执行了二分搜索算法。一次单独问询的计算时间大约为12小时。现在情况又怎么样呢？使用我们的ObliVM框架，每次问询的执行时间仅为7.3秒。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还将我们的SCVM框架与不安全的解决方案进行了效率对比。也就是说，我们直接在计算机上执行明文程序，从而对比效率。我们计算了效率损失量，效率损失量相对还是可以接受的。对于分布式GWAS，效率损失仅为130倍。我们可以期待，未来这一数字可能会进一步降低。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有很多合作方都与我们合作，ObliVM已经在多个场景下得到了应用。我们刚刚赢得了3月份举办的基因分析竞赛，这是大约2个月前举办的竞赛。未来，我们希望在ObliVM框架的基础上实现更多的密码学计算任务，如同态加密等。&lt;/p&gt;&lt;p&gt;非常感谢大家，这就是我讲座的全部内容了，接下来我可以回答一些问题。&lt;/p&gt;&lt;p&gt;（提问者）在演讲开始阶段你给出了一个二分搜索的例子，开发人员应该怎么实现二分搜索？开发人员需要写什么代码？&lt;/p&gt;&lt;p&gt;（演讲者）你指的是哪个例子？&lt;/p&gt;&lt;p&gt;（提问者）在最开始的地方，你给出了一个二分搜索的例子，那时候你提到…&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）这张图中左侧是开发人员实现循环合并时要编写的代码。你提到了二分搜索的例子，对吧？&lt;/p&gt;&lt;p&gt;（提问者）是的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）我觉得用二分搜索举例子会比较好。开发人员要做的事情是…我们回到那页幻灯片上。在这里。&lt;/p&gt;&lt;p&gt;（提问者）就是这里。&lt;/p&gt;&lt;p&gt;（演讲者）这就是开发人员需要编写的代码…我看看这个代码能不能编译通过…是的，可以用我们的ObliVM编译器编译这个程序。编译器会自主处理内存访问过程。&lt;/p&gt;&lt;p&gt;（提问者）是的&lt;/p&gt;&lt;p&gt;（演讲者）是的，编译器会识别相应的模块，判断哪些部分要替换为ORAM，哪些部分不需要替换。&lt;/p&gt;&lt;p&gt;（提问者）ObliVM是不是有一种潜在使用方法，就是让ObliVM输出C代码，而不是电路，这样我们就可以把任意一个程序输入给ObliVM，使得程序无法被旁路攻击？&lt;/p&gt;&lt;p&gt;（演讲者）这是一个非常好的问题。一个非常有趣的事实是，我们的ObliVM编译器输出的是Java代码。&lt;/p&gt;&lt;p&gt;（提问者）明白。&lt;/p&gt;&lt;p&gt;（演讲者）随后，执行Java代码，会生成一个电路。所以我觉得你提的问题非常好。我认为未来一个很有趣的研究方向是，如何阻止ObliVM编译器遭到旁路攻击。&lt;/p&gt;&lt;p&gt;（提问者）好的，谢谢。&lt;/p&gt;&lt;p&gt;（演讲者）谢谢你。&lt;/p&gt;&lt;p&gt;（演讲者）什么？你可以使用麦克风的。&lt;/p&gt;&lt;p&gt;（合作者）我们的编译器没办法被旁路攻击。如果你直接编写类似这样的代码，编译的输出结果是通用ORAM程序。但你也可以调用我们提供的不经意数据结构。我们在不经意数据结构中实现了二分搜索树，如果直接调用不经意数据结构抽象接口，编译时间会减少log(n)倍。&lt;/p&gt;&lt;p&gt;（提问者）明白。&lt;/p&gt;&lt;p&gt;（合作者）很容易让编译器输出C代码，修改后端编译器即可。比较困难的点在于前端，如何编译得到一个高效的电路。&lt;/p&gt;&lt;p&gt;（主持人）感谢Elaine的解释。&lt;/p&gt;&lt;p&gt;（演讲者）是的，感谢Elaine。&lt;/p&gt;&lt;p&gt;（主持人）再次感谢我们的演讲者。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-07-15-73618400</guid>
<pubDate>Mon, 15 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>SoK：安全多方计算通用框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-07-15-72119587.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b38297e2e605b6e0c3739b6eee4bb1e8_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;有段时间没有为知友们带来安全会议的演讲视频翻译了，主要原因是我发现这类文章阅读量并不是很高。业余时间我自己反思了一下，可能是因为知乎到底还是一个问答类社区，文字类型的描述可能更适合知友们快速感知到安全会议演讲视频的内容。为此，在接下来的安全演讲视频文章中，我做了如下几个改变：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;不在知乎上传视频，而是根据视频主讲人的幻灯片展示情况，将对应的演讲稿发出。&lt;/li&gt;&lt;li&gt;演讲视频还是会上传，不过会上传到B站这个专门播放视频的地方。这样，如果有翻译错误，或者有更好的建议，知友或者B站的朋友可以通过弹幕、评论的形式更快地反馈。&lt;/li&gt;&lt;li&gt;演讲视频的中文字幕、时间轴文件（ass格式）、相应的截图等，我会公开在我的GitHub下面，方便知友们下载。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;希望这种方式可以让知友们各取所需。&lt;b&gt;如果知友们还想了解哪些演讲视频，也可以通过知乎评论、GitHub、B站等方式给我留言。我会尽可能满足大家的要求。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2019年5月23日刚刚召开的安全顶级会议Security and Privacy 2019的一个演讲视频《SoK：安全多方计算通用框架》，对应的论文是《SoK: General Purpose Frameworks for Secure Multi-Party Computation》。&lt;/p&gt;&lt;p&gt;这里需要介绍一个背景知识：如果一篇论文的开头是“SoK”，则代表这篇论文是一篇综述论文。SoK的全称是“Systematization of Knowledge Papers&lt;b&gt;”&lt;/b&gt;，Security and Privacy的官方网站（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ieee-security.org/TC/SP2013/cfp.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;ieee-security.org/TC/SP&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;2013/cfp.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;）给出了一个很详尽的解释：&lt;/p&gt;&lt;blockquote&gt;Following the success of the previous years&amp;#39; conferences, we are also soliciting papers focused on systematization of knowledge (SoK). The goal of this call is to encourage work that evaluates, systematizes, and contextualizes existing knowledge. These papers can provide a high value to our community but may not be accepted because of a lack of novel research contributions. Suitable papers include survey papers that provide useful perspectives on major research areas, papers that support or challenge long-held beliefs with compelling evidence, or papers that provide an extensive and realistic evaluation of competing approaches to solving specific problems. Submissions are encouraged to analyze the current research landscape: identify areas that have enjoyed much research attention, point out open areas with unsolved challenges, and present a prioritization that can guide researchers to make progress on solving important challenges.&lt;b&gt;Submissions must be distinguished by a checkbox on the submission form. In addition, the paper title must have the prefix &amp;#34;SoK:&amp;#34;&lt;/b&gt;. They will be reviewed by the full PC and held to the same standards as traditional research papers, except instead of emphasizing novel research contributions the emphasis will be on value to the community. Accepted papers will be presented at the symposium and included in the proceedings.&lt;/blockquote&gt;&lt;p&gt;简单来说，SoK论文的目标是系统化、结构化地评估已有知识体系的论文。这类论文虽然工作量很大，但由于缺乏必要的创新性贡献，所以一般不会被会议所接收。但是，随着相应知识的不断提出和完善，这类论文会对他人进一步的研究带来非常大的帮助。所以，越来越多的会议开始接收SoK论文了。SoK论文的最大特点是：这类论文的题目必须以“SoK”开头。&lt;/p&gt;&lt;p&gt;《SoK: General Purpose Frameworks for Secure Multi-Party Computation》这篇论文非常详尽的分析了现有的安全多方计算通用框架，从各种维度评估了各个框架的优缺点，在不同场景下给出了使用建议。特别地，作者成功构建了所有的通用框架，并把构建环境打包在Docker中。我个人用了一下Docker，样例程序都可以跑通，作者也针对各个框架给出了进一步的文档和注释。这篇文章特别适合准备研究安全多方计算协议，或者准备在实际中使用安全多方计算的研究人员。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DI0bremwQ_ns%26t%3D40s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=I0bremwQ_ns&amp;amp;t=40s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av57765218&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av57&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;765218&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202019/SoK%2520General%2520Purpose%2520Frameworks%2520for%2520Secure%2520Multi-Party%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202019/SoK%20General%20Purpose%20Frameworks%20for%20Secure%20Multi-Party%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;p&gt;感谢知乎工程师们的辛勤工作，知乎现在可以上传60分钟的视频了。为了文章的完整性，我把视频也同步发布在知乎专栏上面。&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1134055356077580288&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic4.zhimg.com/v2-56be736bd7d245f4652fb021facd0c27.jpg&quot; data-lens-id=&quot;1134055356077580288&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic4.zhimg.com/v2-56be736bd7d245f4652fb021facd0c27.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1134055356077580288&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（主讲人）非常感谢主持人的介绍。我是Marcela Hastings。这是一篇SoK论文。我将讲解我们的调研结果。我们考察的工具是安全多方计算。这是一个密码学工具，允许互不信任的参与方根据自己的输入计算任意一个函数，计算过程不泄露除输出结果以外的任何信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;安全多方计算实际应用中最著名的实例是丹麦甜菜拍卖系统。在这个场景中，售卖方是丹麦种田菜的农民，而购买方只有一个，即丹麦唯一的一个甜菜加工公司。售卖方为甜菜出价，表示他们希望按照这个价格售卖甜菜，购买方希望得知市场出清价（即保证供求关系平衡的售卖价格）。但售卖方不希望泄露自己的具体出价。如果常年泄露出价，则其它人就会得知自己的甜菜种植能力和做生意的能力了。因此，他们使用安全多方计算协议，在不泄露售卖方出价的条件下计算市场出清价。&lt;/p&gt;&lt;p&gt;另一个例子是波士顿妇女劳动委员会与企业的合作项目。此项目研究员工性别是否会影响到其实际的工资。公司不希望、从法律角度也不能够对外泄露自己雇员的收入或金融类信息。但通过安全多方计算，他们可以在不给出具体数据的条件下计算相应的统计分析结果。&lt;/p&gt;&lt;p&gt;所有这些例子都告诉我们安全多方计算已经足够高效，可以在实际场景中得到应用了。然而，我们之前看到的所有实际应用实例中，项目方都需要组织一个密码学专家团队，针对特定用例实现专用MPC引擎。如果想让MPC得到更广泛的应用，我们需要让不懂密码学的外行也能使用这一工具。虽然二十世纪八十年代，密码学家就提出了MPC算法，但一直以来MPC协议的效率都很低，无法在实际中使用，直到2004年“公平参与”编译器的提出改变了这一现状。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;“公平参与”是第一个通用MPC框架，可以通过MPC执行任意函数的计算。在接下来的10年，这一框架掀起了学者们针对MPC协议性能优化的浪潮。直至现在，无论从算法角度还是从实现层面，MPC协议得到了巨大的优化。在过去十年间，学者们提出了很多端到端MPC框架。在本工作中，我们重点考察通用端到端MPC框架。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;端到端框架的架构如幻灯片所示。框架一般实现了两个阶段的功能：编译器、执行器。这是因为大多数MPC算法只支持有限的算子，如模质数下的加法和乘法。开发者很难应用这些有限的算子实现所需的计算函数。因此，我们重点考察包含一个编译器的框架。编译器的输入是用高级语言描述的函数。编译器会把函数编译成算法可执行的协议。接下来，执行器会具体执行编译好的协议。协议会在多个参与方上同时执行。每个参与方都以编译器的输出结果和自己的秘密值作为输入，计算得到函数输出结果。当然了，不同框架的架构各不相同，但是它们基本都是这样的结构。&lt;/p&gt;&lt;p&gt;在本综述中，我们想回答这样一些问题：目前都有哪些框架？谁在使用这些框架？这些框架是否可以实现实际的计算过程？这些框架是否可以支持所需函数的计算？这些框架是否可以在实际中使用？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为了回答这些问题，我们调查了9个端到端框架和2个电路编译器。我们记录了这些框架的不同特性，包括框架所实现的协议、框架所支持的数据类型和运算操作、以及其它一些实现的具体细节。我们通过多种可用性标准对这些协议进行评价。为了收集这些数据，我们在每个框架上实现3个样例程序。我们把每个框架的完整构建环境及其对应的样例程序都放在了开源的代码仓库中。结合这些框架的使用经验，我们为各个框架补充了相应的文档。构建代码仓库的总时间约为750人小时。此仓库是开源的。我们仍然在积极地维护这一仓库，非常希望大家能看看这个代码仓库。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我想简单介绍一下完成这些工作后我们所得到的一些结论。总的来说，几乎所有的框架做得都不错。各种框架在不同的安全模型下实现了不同的协议。根据具体用例的不同，框架也提供了一些协议和安全模型的选项。我们可以在几乎所有的框架上实现我们的样例程序。这意味着对于绝大多数场景来说，框架的高层语言具有较好的可表达性。总的来说，大多数框架都是开源的、可编译的、可用的。然而，我们发现了两个重要的改进方向。第一个方向是：框架的工程局限性较高。例如，框架的系统构建环境过于复杂。第二个方向是：框架的可用性较差。其根本原因主要在于框架缺失相应的文档。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在具体讲解这些问题之前，我想先从宏观层面介绍我们的发现。我们考察了9个框架。最下方是2个电路编译器。大家可以从表格中看到框架支持的参与方数量、支持的安全模型。我们有两种安全模型。在半诚实模型中，攻击者会正确执行协议，但是攻击者会尝试得到其它参与方的输入。在恶意模型中，攻击者不会遵从约定执行协议，以错误的协议执行结果中推断信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还对不同的协议进行了简单的分类，这里需要简单解释一下。第一类协议是乱码电路协议，最初由姚期智于二十世纪八十年代提出。自姚期智提出此协议以来，学者们持续不断地对协议进行改进。理论密码学家从不同角度对乱码电路进行了优化。从实际中我们发现，几乎所有的框架都实现了半诚实两方协议，一个参与方对电路加密后将结果发送给另一个参与方，另一个参与方根据输入对电路求值。在乱码电路中，需要把函数表示为布尔电路的形式。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二类协议包含很多不同的协议。我们称这类协议为基于电路的多方计算协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这些协议拥有两个共同的特性。第一个特性是，需要把函数表示为代数电路或者布尔电路的形式。第二个特性是，数据需要用线性秘密分享的形式表示。线性秘密分享意味着协议支持任意数量的参与方。参与方协同工作，依次对门电路求值，将秘密分享输入转换为秘密分享输出。然而，在基于电路的多方计算模型下，不同协议将输入转换为输出的方式不太相同，可以基于信息论安全模型下转换，也可以基于密码安全模型下转换。&lt;/p&gt;&lt;p&gt;我们认为这两类协议可以涵盖大多数框架的基础协议。在理论层面，大多数理论密码学家用非常有限的运算操作定义MPC协议，涉及的运算操作只包含模整数下的加法和乘法，或者逐比特与预算和异或运算。这两类运算操作都是图灵完备的，任何函数都可以用这两种运算操作表示。然而，在实际中我们需要为代数模型下的除法、比较等公共函数定义更优的子协议，这样我们就不用把所有函数都表示为基本运算操作，从而提高函数表达的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们发现有3个框架实现了特定的子协议。我们称这类协议为混合协议。在最下方，大家可以看到2个电路编译器。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当选择适当的框架时，人们需要着重考虑的是：高层语言对协议的抽象能力。不同框架都实现了协议的抽象。我们对这些高层语言展开了考察。我们测试的其中一个样例程序是内积运算。内积运算是指逐位计算乘积，再对各个结果求和。&lt;/p&gt;&lt;p&gt;Frigate是一个电路编译器，它的高层语言是非常传统的C语言风格抽象。大家可以看一下幻灯片上给出的内积运算代码实现。初始化结果变量，在向量上构建循环语句，循环中依次取出向量中的每一个元素，计算各个元素的乘积，最后对乘积求和。实现过程非常直观、通俗易懂。然而，如果你熟悉MPC，你可能会知道在线性秘密分享模型中，我们可以通过一轮交互并行处理所有的乘法运算。如果你希望得到优化后的协议，你可能就需要使用PICCO等框架了。&lt;/p&gt;&lt;p&gt;PICCO会对内积运算的乘法进行了并行优化，它们实现了一个针对内积运算的自定义算子。所以PICCO是一个混合协议框架。大家可以看到，可以用这个非常简单的自定义算子求两个任意长向量的内积结果。即使你不熟悉密码学，也可以很方便地直接使用自定义算子，你也不需要关注底层到底做了什么。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，如果你是一个密码学家，你想实现一个比内积更复杂的函数，你可能会希望对生成的电路做更深度的控制和修改。这种情况下，你可能会使用ABY这样的框架。ABY是一个端到端框架，在C语言上实现了一个函数库。大家可以看到，我们用一个share类管理秘密数据。我们随后放置一个乘法门，ABY会帮助我们实现乘法的并行优化。我们需要一个乘法门对整个向量逐位计算乘法。随后，我们把向量展开，对所有乘法运算结果求和。这可以给我们更大的自由，实现我们想实现的函数。但如果你对密码背景不熟悉，你可能就不想具备这些自定义的能力。这就是我们考察的前后端高层语言的范围。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们下一个想讨论的内容是这些框架的一些限制。正如我前面提到的，软件工程是这些框架中最主要的问题。大家一定要记住，大多数框架都是在学术研究场景下开发的。因此，这些框架在工程落地时会有很多的限制。在我讲解下面内容的过程中，大家要把这一点牢记于心。&lt;/p&gt;&lt;p&gt;最主要的痛点是构建系统。系统的整个构建过程非常复杂。你需要从源代码层面编译特定版本的OpenSSL库，这就要花费很长的时间，或者你需要建立一个自定义的证书认证机构，从而建立秘密通信信道。光编译每一个框架平均就要花费我们1-2周的时间。这个过程苦不堪言。但是大家很幸运，我们已经把编译好的环境放在了Docker仓库里，所以大家不需要再重复一遍此项工作了。&lt;/p&gt;&lt;p&gt;在系统构建之上，要使用这些软件框架项目，我们还需要很多的软件开发工作。正确实现密码学协议已经很困难了，但在这之上，开发者还需要实现很多支持系统，例如分布式通信、用安全语言实现与其它通信系统的交互。这方面的结论虽然比较细节，但仍然令人沮丧。例如，在ObliVM中，我们无法编写一个返回结果超过32比特的计算函数。我们可以通过进一步的代码开发来解决这个问题。由于框架都是在学术层面上开发的，框架在实现层面上都不太完美。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个比较严重的问题是可用性，尤其是文档比较匮乏。如幻灯片所示，我们定义了5类文档，一半框架都缺失了至少3类文档。我这里不详细介绍每一类文档的细节，而是想给大家展示几个例子，从而证明语言文档的缺失极大地影响框架的可用性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;语言文档指的是描述如何使用高层语言的文档。CBMC-GC是一个电路编译器，可以将代码编译成乱码电路。大多数人都熟悉C语言。假设我们要实现这样一个简单的程序：把两个数直接相乘。这个代码感觉上是正确的。然而，我们会得到一个编译错误：我们忘记返回一个值。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上，在CBMC-GC中，计算过程中的所有秘密输入的变量名都需要以input开头。这根本不算是一个问题，但是并没有文档说明这一点，我们有必要告诉大家。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个例子来自于ObliVM，这是一个将类Java语言作为高层语言的端到端框架。与前面相同，我们的程序是计算两个数的乘积，但我们碰上了解析错误。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;事实上，Alice和Bob是此高层语言中的保留关键词。因此，我们不能把这两个词作为变量名。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Wisteria是开发编程语言的人所撰写的端到端框架。此框架使用函数式语言来描述计算函数。此框架包含了一个详尽的语言指南，告诉大家如何使用函数式语言编写计算函数。然而，语言文档没有考虑到解析器的限制要求。开发者需要在代码中放置很多的括号，编译器才能编译通过。&lt;/p&gt;&lt;p&gt;EMP-toolkit是一个我们非常喜欢使用的框架。这是一个基于乱码电路的框架。然而，我们发现平均600行代码才会有1行注释，并且没有单独的代码解释文档。这些问题都会导致框架难以使用。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，有一些框架的文档工作做得很好，我真挚地感谢这些框架的作者。对于那些维护一个较大开源项目框架的开发者，我想给出两个重要的建议。&lt;/p&gt;&lt;p&gt;第一个建议是，即使针对不同方面的很简单的文档，也会大幅提高框架的可用性。不同类型的文档指的是，可能有一个文档解释框架的架构，另一个文档是带注释的样例程序，演示一些高层语言的特性。&lt;/p&gt;&lt;p&gt;第二个建议是在线资源，例如提供一个邮件列表或在GitHub上开启问题追踪。这是一个持续生成、持续更新框架文档的好方法。问题追踪就像一个在线问答平台，这样你就不用通过邮件重复回答相同的问题了。问题追踪也是用户之间相互交流的平台，他们可以互相回答遇到的问题。如果你不再想维护你的框架，用户仍然可以相互讨论，解答相应的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;即使有这些工程和可用性方面的问题，MPC框架的实现情况还是非常乐观的。我们可以在框架上实现很多样例程序。总体来说，实现过程还是很顺利的。社区也发现了框架可用性的问题。IARPA HECTOR项目正在赞助下一代MPC框架的实现。在赞助中，它们专门提出了可用性评价标准。&lt;/p&gt;&lt;p&gt;我们强烈建议后续的开发者们可以与编程语言研究者合作。大多数框架都是由密码学家实现的，因此前后端语言的设计可能不是很规范。编译器经验充分的开发人员介入，会对语言设计有更好的帮助。&lt;/p&gt;&lt;p&gt;插播一条广告，我们仍然在积极维护我们的代码仓库，我们随时准备接受新框架、已有框架的提交请求。如果你在维护其中一些框架，或者想在学术项目中使用这些框架，建议看看此代码仓库。&lt;/p&gt;&lt;p&gt;最后一条广告，我们在寻找MPC的落地项目，如果你是潜在合作方，如果你有一个有趣的项目，请稍后与我们联系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢。&lt;/p&gt;&lt;p&gt;（主持人）非常感谢。如果有问题的话，请用麦克风提问。&lt;/p&gt;&lt;p&gt;（提问者）你好，首先非常感谢你们所做的工作。社区迫切需要你们所做的工作，这个工作非常令人激动。我知道你们完成了这一概览性的工作。你们也得到了一些好的结论，一些不好的结论。但你们没有给出类似这样的结论：这是正确的框架，社区应该在这个框架的基础上继续构建，或者类似的结论。这样的结论可能会非常重要，因为如果没有这样的结论，最后的情况可能就是：哦不，这里有12个标准，我们要尝试构建一个标准，然后我们就得到了第13个标准。你能给出类似这样的结论吗？&lt;/p&gt;&lt;p&gt;（演讲人）当然可以。在论文中，我们明确给出了建议，推荐使用哪些框架。如果你在为某个特定场景寻求建议，我这里可以给出4个不同场景下的推荐。对于乱码电路框架来说，Obliv-C是一个不错的通用框架。如果你一些密码学专业知识，EMP-toolkit会更适合你。SCALE-MAMBA最适合多参与方场景，或者说这是一个混合协议框架。因此，这是最好的线性秘密分享协议框架。此框架的适用性很广泛，更新仍然很活跃。如果你有特定的安全需求，你可能会对Sharemind感兴趣，这是唯一一个付费开发者维护的框架，而且开发者是学术领域的研究人员。这就是我给出的推荐建议。&lt;/p&gt;&lt;p&gt;（主持人）谢谢，我绝对也会开发一个将Alice和Bob作为保留关键词的编程语言，这太酷了。再次感谢你的精彩演讲。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-07-15-72119587</guid>
<pubDate>Mon, 15 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>SoK：安全多方计算通用框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-07-04-72119587.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b38297e2e605b6e0c3739b6eee4bb1e8_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;有段时间没有为知友们带来安全会议的演讲视频翻译了，主要原因是我发现这类文章阅读量并不是很高。业余时间我自己反思了一下，可能是因为知乎到底还是一个问答类社区，文字类型的描述可能更适合知友们快速感知到安全会议演讲视频的内容。为此，在接下来的安全演讲视频文章中，我做了如下几个改变：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;不在知乎上传视频，而是根据视频主讲人的幻灯片展示情况，将对应的演讲稿发出。&lt;/li&gt;&lt;li&gt;演讲视频还是会上传，不过会上传到B站这个专门播放视频的地方。这样，如果有翻译错误，或者有更好的建议，知友或者B站的朋友可以通过弹幕、评论的形式更快地反馈。&lt;/li&gt;&lt;li&gt;演讲视频的中文字幕、时间轴文件（ass格式）、相应的截图等，我会公开在我的GitHub下面，方便知友们下载。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;希望这种方式可以让知友们各取所需。&lt;b&gt;如果知友们还想了解哪些演讲视频，也可以通过知乎评论、GitHub、B站等方式给我留言。我会尽可能满足大家的要求。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2019年5月23日刚刚召开的安全定义会议Security and Privacy 2019的一个演讲视频《SoK：安全多方计算通用框架》，对应的论文是《SoK: General Purpose Frameworks for Secure Multi-Party Computation》。&lt;/p&gt;&lt;p&gt;这里需要介绍一个背景知识：如果一篇论文的开头是“SoK”，则代表这篇论文是一篇综述论文。SoK的全称是“Systematization of Knowledge Papers&lt;b&gt;”&lt;/b&gt;，Security and Privacy的官方网站（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ieee-security.org/TC/SP2013/cfp.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;ieee-security.org/TC/SP&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;2013/cfp.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;）给出了一个很详尽的解释：&lt;/p&gt;&lt;blockquote&gt;Following the success of the previous years&amp;#39; conferences, we are also soliciting papers focused on systematization of knowledge (SoK). The goal of this call is to encourage work that evaluates, systematizes, and contextualizes existing knowledge. These papers can provide a high value to our community but may not be accepted because of a lack of novel research contributions. Suitable papers include survey papers that provide useful perspectives on major research areas, papers that support or challenge long-held beliefs with compelling evidence, or papers that provide an extensive and realistic evaluation of competing approaches to solving specific problems. Submissions are encouraged to analyze the current research landscape: identify areas that have enjoyed much research attention, point out open areas with unsolved challenges, and present a prioritization that can guide researchers to make progress on solving important challenges.&lt;b&gt;Submissions must be distinguished by a checkbox on the submission form. In addition, the paper title must have the prefix &amp;#34;SoK:&amp;#34;&lt;/b&gt;. They will be reviewed by the full PC and held to the same standards as traditional research papers, except instead of emphasizing novel research contributions the emphasis will be on value to the community. Accepted papers will be presented at the symposium and included in the proceedings.&lt;/blockquote&gt;&lt;p&gt;简单来说，SoK论文的目标是系统化、结构化地评估已有知识体系的论文。这类论文虽然工作量很大，但由于缺乏必要的创新性贡献，所以一般不会被会议所接收。但是，随着相应知识的不断提出和完善，这类论文会对他人进一步的研究带来非常大的帮助。所以，越来越多的会议开始接收SoK论文了。SoK论文的最大特点是：这类论文的题目必须以“SoK”开头。&lt;/p&gt;&lt;p&gt;《SoK: General Purpose Frameworks for Secure Multi-Party Computation》这篇论文非常详尽的分析了现有的安全多方计算通用框架，从各种维度评估了各个框架的优缺点，在不同场景下给出了使用建议。特别地，作者成功构建了所有的通用框架，并把构建环境打包在Docker中。我个人用了一下Docker，样例程序都可以跑通，作者也针对各个框架给出了进一步的文档和注释。这篇文章特别适合准备研究安全多方计算协议，或者准备在实际中使用安全多方计算的研究人员。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DI0bremwQ_ns%26t%3D40s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=I0bremwQ_ns&amp;amp;t=40s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av57765218&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av57&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;765218&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202019/SoK%2520General%2520Purpose%2520Frameworks%2520for%2520Secure%2520Multi-Party%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202019/SoK%20General%20Purpose%20Frameworks%20for%20Secure%20Multi-Party%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（主讲人）非常感谢主持人的介绍。我是Marcela Hastings。这是一篇SoK论文。我将讲解我们的调研结果。我们考察的工具是安全多方计算。这是一个密码学工具，允许互不信任的参与方根据自己的输入计算任意一个函数，计算过程不泄露除输出结果以外的任何信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;安全多方计算实际应用中最著名的实例是丹麦甜菜拍卖系统。在这个场景中，售卖方是丹麦种田菜的农民，而购买方只有一个，即丹麦唯一的一个甜菜加工公司。售卖方为甜菜出价，表示他们希望按照这个价格售卖甜菜，购买方希望得知市场出清价（即保证供求关系平衡的售卖价格）。但售卖方不希望泄露自己的具体出价。如果常年泄露出价，则其它人就会得知自己的甜菜种植能力和做生意的能力了。因此，他们使用安全多方计算协议，在不泄露售卖方出价的条件下计算市场出清价。&lt;/p&gt;&lt;p&gt;另一个例子是波士顿妇女劳动委员会与企业的合作项目。此项目研究员工性别是否会影响到其实际的工资。公司不希望、从法律角度也不能够对外泄露自己雇员的收入或金融类信息。但通过安全多方计算，他们可以在不给出具体数据的条件下计算相应的统计分析结果。&lt;/p&gt;&lt;p&gt;所有这些例子都告诉我们安全多方计算已经足够高效，可以在实际场景中得到应用了。然而，我们之前看到的所有实际应用实例中，项目方都需要组织一个密码学专家团队，针对特定用例实现专用MPC引擎。如果想让MPC得到更广泛的应用，我们需要让不懂密码学的外行也能使用这一工具。虽然二十世纪八十年代，密码学家就提出了MPC算法，但一直以来MPC协议的效率都很低，无法在实际中使用，直到2004年“公平参与”编译器的提出改变了这一现状。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;“公平参与”是第一个通用MPC框架，可以通过MPC执行任意函数的计算。在接下来的10年，这一框架掀起了学者们针对MPC协议性能优化的浪潮。直至现在，无论从算法角度还是从实现层面，MPC协议得到了巨大的优化。在过去十年间，学者们提出了很多端到端MPC框架。在本工作中，我们重点考察通用端到端MPC框架。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;端到端框架的架构如幻灯片所示。框架一般实现了两个阶段的功能：编译器、执行器。这是因为大多数MPC算法只支持有限的算子，如模质数下的加法和乘法。开发者很难应用这些有限的算子实现所需的计算函数。因此，我们重点考察包含一个编译器的框架。编译器的输入是用高级语言描述的函数。编译器会把函数编译成算法可执行的协议。接下来，执行器会具体执行编译好的协议。协议会在多个参与方上同时执行。每个参与方都以编译器的输出结果和自己的秘密值作为输入，计算得到函数输出结果。当然了，不同框架的架构各不相同，但是它们基本都是这样的结构。&lt;/p&gt;&lt;p&gt;在本综述中，我们想回答这样一些问题：目前都有哪些框架？谁在使用这些框架？这些框架是否可以实现实际的计算过程？这些框架是否可以支持所需函数的计算？这些框架是否可以在实际中使用？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为了回答这些问题，我们调查了9个端到端框架和2个电路编译器。我们记录了这些框架的不同特性，包括框架所实现的协议、框架所支持的数据类型和运算操作、以及其它一些实现的具体细节。我们通过多种可用性标准对这些协议进行评价。为了收集这些数据，我们在每个框架上实现3个样例程序。我们把每个框架的完整构建环境及其对应的样例程序都放在了开源的代码仓库中。结合这些框架的使用经验，我们为各个框架补充了相应的文档。构建代码仓库的总时间约为750人小时。此仓库是开源的。我们仍然在积极地维护这一仓库，非常希望大家能看看这个代码仓库。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我想简单介绍一下完成这些工作后我们所得到的一些结论。总的来说，几乎所有的框架做得都不错。各种框架在不同的安全模型下实现了不同的协议。根据具体用例的不同，框架也提供了一些协议和安全模型的选项。我们可以在几乎所有的框架上实现我们的样例程序。这意味着对于绝大多数场景来说，框架的高层语言具有较好的可表达性。总的来说，大多数框架都是开源的、可编译的、可用的。然而，我们发现了两个重要的改进方向。第一个方向是：框架的工程局限性较高。例如，框架的系统构建环境过于复杂。第二个方向是：框架的可用性较差。其根本原因主要在于框架缺失相应的文档。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在具体讲解这些问题之前，我想先从宏观层面介绍我们的发现。我们考察了9个框架。最下方是2个电路编译器。大家可以从表格中看到框架支持的参与方数量、支持的安全模型。我们有两种安全模型。在半诚实模型中，攻击者会正确执行协议，但是攻击者会尝试得到其它参与方的输入。在恶意模型中，攻击者不会遵从约定执行协议，以错误的协议执行结果中推断信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还对不同的协议进行了简单的分类，这里需要简单解释一下。第一类协议是乱码电路协议，最初由姚期智于二十世纪八十年代提出。自姚期智提出此协议以来，学者们持续不断地对协议进行改进。理论密码学家从不同角度对乱码电路进行了优化。从实际中我们发现，几乎所有的框架都实现了半诚实两方协议，一个参与方对电路加密后将结果发送给另一个参与方，另一个参与方根据输入对电路求值。在乱码电路中，需要把函数表示为布尔电路的形式。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二类协议包含很多不同的协议。我们称这类协议为基于电路的多方计算协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这些协议拥有两个共同的特性。第一个特性是，需要把函数表示为代数电路或者布尔电路的形式。第二个特性是，数据需要用线性秘密分享的形式表示。线性秘密分享意味着协议支持任意数量的参与方。参与方协同工作，依次对门电路求值，将秘密分享输入转换为秘密分享输出。然而，在基于电路的多方计算模型下，不同协议将输入转换为输出的方式不太相同，可以基于信息论安全模型下转换，也可以基于密码安全模型下转换。&lt;/p&gt;&lt;p&gt;我们认为这两类协议可以涵盖大多数框架的基础协议。在理论层面，大多数理论密码学家用非常有限的运算操作定义MPC协议，涉及的运算操作只包含模整数下的加法和乘法，或者逐比特与预算和异或运算。这两类运算操作都是图灵完备的，任何函数都可以用这两种运算操作表示。然而，在实际中我们需要为代数模型下的除法、比较等公共函数定义更优的子协议，这样我们就不用把所有函数都表示为基本运算操作，从而提高函数表达的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们发现有3个框架实现了特定的子协议。我们称这类协议为混合协议。在最下方，大家可以看到2个电路编译器。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当选择适当的框架时，人们需要着重考虑的是：高层语言对协议的抽象能力。不同框架都实现了协议的抽象。我们对这些高层语言展开了考察。我们测试的其中一个样例程序是内积运算。内积运算是指逐位计算乘积，再对各个结果求和。&lt;/p&gt;&lt;p&gt;Frigate是一个电路编译器，它的高层语言是非常传统的C语言风格抽象。大家可以看一下幻灯片上给出的内积运算代码实现。初始化结果变量，在向量上构建循环语句，循环中依次取出向量中的每一个元素，计算各个元素的乘积，最后对乘积求和。实现过程非常直观、通俗易懂。然而，如果你熟悉MPC，你可能会知道在线性秘密分享模型中，我们可以通过一轮交互并行处理所有的乘法运算。如果你希望得到优化后的协议，你可能就需要使用PICCO等框架了。&lt;/p&gt;&lt;p&gt;PICCO会对内积运算的乘法进行了并行优化，它们实现了一个针对内积运算的自定义算子。所以PICCO是一个混合协议框架。大家可以看到，可以用这个非常简单的自定义算子求两个任意长向量的内积结果。即使你不熟悉密码学，也可以很方便地直接使用自定义算子，你也不需要关注底层到底做了什么。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，如果你是一个密码学家，你想实现一个比内积更复杂的函数，你可能会希望对生成的电路做更深度的控制和修改。这种情况下，你可能会使用ABY这样的框架。ABY是一个端到端框架，在C语言上实现了一个函数库。大家可以看到，我们用一个share类管理秘密数据。我们随后放置一个乘法门，ABY会帮助我们实现乘法的并行优化。我们需要一个乘法门对整个向量逐位计算乘法。随后，我们把向量展开，对所有乘法运算结果求和。这可以给我们更大的自由，实现我们想实现的函数。但如果你对密码背景不熟悉，你可能就不想具备这些自定义的能力。这就是我们考察的前后端高层语言的范围。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们下一个想讨论的内容是这些框架的一些限制。正如我前面提到的，软件工程是这些框架中最主要的问题。大家一定要记住，大多数框架都是在学术研究场景下开发的。因此，这些框架在工程落地时会有很多的限制。在我讲解下面内容的过程中，大家要把这一点牢记于心。&lt;/p&gt;&lt;p&gt;最主要的痛点是构建系统。系统的整个构建过程非常复杂。你需要从源代码层面编译特定版本的OpenSSL库，这就要花费很长的时间，或者你需要建立一个自定义的证书认证机构，从而建立秘密通信信道。光编译每一个框架平均就要花费我们1-2周的时间。这个过程苦不堪言。但是大家很幸运，我们已经把编译好的环境放在了Docker仓库里，所以大家不需要再重复一遍此项工作了。&lt;/p&gt;&lt;p&gt;在系统构建之上，要使用这些软件框架项目，我们还需要很多的软件开发工作。正确实现密码学协议已经很困难了，但在这之上，开发者还需要实现很多支持系统，例如分布式通信、用安全语言实现与其它通信系统的交互。这方面的结论虽然比较细节，但仍然令人沮丧。例如，在ObliVM中，我们无法编写一个返回结果超过32比特的计算函数。我们可以通过进一步的代码开发来解决这个问题。由于框架都是在学术层面上开发的，框架在实现层面上都不太完美。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个比较严重的问题是可用性，尤其是文档比较匮乏。如幻灯片所示，我们定义了5类文档，一半框架都缺失了至少3类文档。我这里不详细介绍每一类文档的细节，而是想给大家展示几个例子，从而证明语言文档的缺失极大地影响框架的可用性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;语言文档指的是描述如何使用高层语言的文档。CBMC-GC是一个电路编译器，可以将代码编译成乱码电路。大多数人都熟悉C语言。假设我们要实现这样一个简单的程序：把两个数直接相乘。这个代码感觉上是正确的。然而，我们会得到一个编译错误：我们忘记返回一个值。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上，在CBMC-GC中，计算过程中的所有秘密输入的变量名都需要以input开头。这根本不算是一个问题，但是并没有文档说明这一点，我们有必要告诉大家。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个例子来自于ObliVM，这是一个将类Java语言作为高层语言的端到端框架。与前面相同，我们的程序是计算两个数的乘积，但我们碰上了解析错误。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;事实上，Alice和Bob是此高层语言中的保留关键词。因此，我们不能把这两个词作为变量名。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Wisteria是开发编程语言的人所撰写的端到端框架。此框架使用函数式语言来描述计算函数。此框架包含了一个详尽的语言指南，告诉大家如何使用函数式语言编写计算函数。然而，语言文档没有考虑到解析器的限制要求。开发者需要在代码中放置很多的括号，编译器才能编译通过。&lt;/p&gt;&lt;p&gt;EMP-toolkit是一个我们非常喜欢使用的框架。这是一个基于乱码电路的框架。然而，我们发现平均600行代码才会有1行注释，并且没有单独的代码解释文档。这些问题都会导致框架难以使用。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，有一些框架的文档工作做得很好，我真挚地感谢这些框架的作者。对于那些维护一个较大开源项目框架的开发者，我想给出两个重要的建议。&lt;/p&gt;&lt;p&gt;第一个建议是，即使针对不同方面的很简单的文档，也会大幅提高框架的可用性。不同类型的文档指的是，可能有一个文档解释框架的架构，另一个文档是带注释的样例程序，演示一些高层语言的特性。&lt;/p&gt;&lt;p&gt;第二个建议是在线资源，例如提供一个邮件列表或在GitHub上开启问题追踪。这是一个持续生成、持续更新框架文档的好方法。问题追踪就像一个在线问答平台，这样你就不用通过邮件重复回答相同的问题了。问题追踪也是用户之间相互交流的平台，他们可以互相回答遇到的问题。如果你不再想维护你的框架，用户仍然可以相互讨论，解答相应的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;即使有这些工程和可用性方面的问题，MPC框架的实现情况还是非常乐观的。我们可以在框架上实现很多样例程序。总体来说，实现过程还是很顺利的。社区也发现了框架可用性的问题。IARPA HECTOR项目正在赞助下一代MPC框架的实现。在赞助中，它们专门提出了可用性评价标准。&lt;/p&gt;&lt;p&gt;我们强烈建议后续的开发者们可以与编程语言研究者合作。大多数框架都是由密码学家实现的，因此前后端语言的设计可能不是很规范。编译器经验充分的开发人员介入，会对语言设计有更好的帮助。&lt;/p&gt;&lt;p&gt;插播一条广告，我们仍然在积极维护我们的代码仓库，我们随时准备接受新框架、已有框架的提交请求。如果你在维护其中一些框架，或者想在学术项目中使用这些框架，建议看看此代码仓库。&lt;/p&gt;&lt;p&gt;最后一条广告，我们在寻找MPC的落地项目，如果你是潜在合作方，如果你有一个有趣的项目，请稍后与我们联系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢。&lt;/p&gt;&lt;p&gt;（主持人）非常感谢。如果有问题的话，请用麦克风提问。&lt;/p&gt;&lt;p&gt;（提问者）你好，首先非常感谢你们所做的工作。社区迫切需要你们所做的工作，这个工作非常令人激动。我知道你们完成了这一概览性的工作。你们也得到了一些好的结论，一些不好的结论。但你们没有给出类似这样的结论：这是正确的框架，社区应该在这个框架的基础上继续构建，或者类似的结论。这样的结论可能会非常重要，因为如果没有这样的结论，最后的情况可能就是：哦不，这里有12个标准，我们要尝试构建一个标准，然后我们就得到了第13个标准。你能给出类似这样的结论吗？&lt;/p&gt;&lt;p&gt;（演讲人）当然可以。在论文中，我们明确给出了建议，推荐使用哪些框架。如果你在为某个特定场景寻求建议，我这里可以给出4个不同场景下的推荐。对于乱码电路框架来说，Obliv-C是一个不错的通用框架。如果你一些密码学专业知识，EMP-toolkit会更适合你。SCALE-MAMBA最适合多参与方场景，或者说这是一个混合协议框架。因此，这是最好的线性秘密分享协议框架。此框架的适用性很广泛，更新仍然很活跃。如果你有特定的安全需求，你可能会对Sharemind感兴趣，这是唯一一个付费开发者维护的框架，而且开发者是学术领域的研究人员。这就是我给出的推荐建议。&lt;/p&gt;&lt;p&gt;（主持人）谢谢，我绝对也会开发一个将Alice和Bob作为保留关键词的编程语言，这太酷了。再次感谢你的精彩演讲。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-07-04-72119587</guid>
<pubDate>Thu, 04 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>详细解读《数据安全管理办法（征求意见稿）》十大亮点（上）</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-06-01-67678553.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/67678553&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-772cf29145340fd65893bd50821ab1e5_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1.概述《数据安全管理办法（征求意见稿）》（下称：办法）&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;性质：&lt;/b&gt;办法效力高于《信息安全技术个人信息安全规范》（下称《规范》）、《互联网个人信息安全保护指南》（下称指南），规范与指南本身没有强制约束力，而办法相当于部门规章（部级立法），在全国范围内具有强制约束力，如果办法与地方性法规（地方人大立法）冲突的话，终极裁决权在全国人大常委会手中。&lt;/p&gt;&lt;p&gt;&lt;b&gt;保护客体：&lt;/b&gt;个人信息、重要数据&lt;/p&gt;&lt;p&gt;&lt;b&gt;依据：&lt;/b&gt;主要是《网络安全法》&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;&lt;b&gt;亮点一&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;收集使用规则&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;亮点：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;仅当用户知悉收集使用规则并明确同意后，网络运营者方可收集个人信息；可包含于隐私政策中，但要集中展示，不能散见于各条款中。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;收集使用规则要体现数据安全责任人姓名，根据《网络安全法》第六十三条规定，因网络安全问题受过行政处罚五年内不得担任，受到刑事处罚的终身不得担任。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;用户在使用过程中享有撤销同意权、删除权，意味着用户可以随时不同意网络运营者收集其信息，并要求删除。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;《办法》第7、8、9、10条&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;第七条&lt;/b&gt; 网络运营者通过网站、应用程序等产品收集使用个人信息，应当分别制定并公开收集使用规则。收集使用规则可以包含在网站、应用程序等产品的隐私政策中，也可以其他形式提供给用户。&lt;br/&gt;&lt;b&gt;第八条&lt;/b&gt; 收集使用规则应当明确具体、简单通俗、易于访问，突出以下内容：&lt;br/&gt;　　（一）网络运营者基本信息；&lt;br/&gt;　　（二）网络运营者主要负责人、数据安全责任人的姓名及联系方式；&lt;br/&gt;　　（三）收集使用个人信息的目的、种类、数量、频度、方式、范围等；&lt;br/&gt;　　（四）个人信息保存地点、期限及到期后的处理方式；&lt;br/&gt;　　（五）向他人提供个人信息的规则，如果向他人提供的；&lt;br/&gt;　　（六）个人信息安全保护策略等相关信息；&lt;br/&gt;　　（七）个人信息主体撤销同意，以及查询、更正、删除个人信息的途径和方法；&lt;br/&gt;　　（八）投诉、举报渠道和方法等；&lt;br/&gt;　　（九）法律、行政法规规定的其他内容。&lt;br/&gt;&lt;b&gt;第九条&lt;/b&gt; 如果收集使用规则包含在隐私政策中，应相对集中，明显提示，以方便阅读。另仅当用户知悉收集使用规则并明确同意后，网络运营者方可收集个人信息。&lt;br/&gt;&lt;b&gt;第十条&lt;/b&gt; 网络运营者应当严格遵守收集使用规则，网站、应用程序收集或使用个人信息的功能设计应同隐私政策保持一致，同步调整。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不足：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果允许用户任意撤回同意或者删除信息，一方面对数据进行改动成本可能非常大，特别是底层的数据，几个用户申请尚可，如果是千万级别的用户同时申请，必然会影响网络运营者的正常运行。&lt;/p&gt;&lt;p&gt;收集使用协议一般晦涩难懂，应当以表格形式对收集信息进行分门别类展示，具体可参考《规范》：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ff838f74130a1d0d446267f68c31d832_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1019&quot; data-rawheight=&quot;500&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1019&quot; data-original=&quot;https://pic3.zhimg.com/v2-ff838f74130a1d0d446267f68c31d832_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ff838f74130a1d0d446267f68c31d832_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1019&quot; data-rawheight=&quot;500&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1019&quot; data-original=&quot;https://pic3.zhimg.com/v2-ff838f74130a1d0d446267f68c31d832_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ff838f74130a1d0d446267f68c31d832_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;建议：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;将第八条第七款修改为：&lt;/b&gt;个人信息主体撤销同意，以及查询、更正、删除个人信息的途径和方法，但网络运营者可以设定合理的操作期限；&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;增加：收集使用协议对收集的信息应当以表格形式展示，并分类列举。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;&lt;b&gt;亮点二&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;不得因用户拒绝非核心条款而拒绝用户使用产品&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;亮点：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;用户享有真正的否决权，有权拒绝或者撤销同意收集非核心功能信息，而网络运营者不得拒绝提供核心业务功能服务。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;以往，各类APP虽然会提示用户认真阅读隐私条款，但真正会去看的用户少之又少，就连美国大法官都公开表示自己平时用这些产品的时候压根不会去看所谓的隐私协议，包括我本人在内也是闭着眼睛点同意就开始用。即使现实中是这种情况，那为什么政府部门与各大网络运营者还是不留余力的“推销”隐私政策，企业夸自己的隐私政策多么透明，多么规范。在我看来，这样的隐私政策不过是信息保护的一块遮羞布，只管形式上的合规，不管用户真正的利益与体验。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我也时常在想，为什么会出现这种情况？后来我发现真正的原因不是用户懒，不是用户不重视自己的隐私，而是用户知道即使自己不同意其中的条款，也法改变什么，不点同意，意味着让你出门左拐，连用都不让你用。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;而现在的《办法》有望解决这个痛点，并且网络运营者不能再以提升用户体验的“漂亮话”默认用户授权，意思是，非核心功能的信息收集必须列出来让用户明确同意。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;《办法》第11条&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;第十一条 &lt;/b&gt;网络运营者不得以改善服务质量、提升用户体验、定向推送信息、研发新产品等为由，以默认授权、功能捆绑等形式强迫、误导个人信息主体同意其收集个人信息。&lt;br/&gt;个人信息主体同意收集保证网络产品核心业务功能运行的个人信息后，网络运营者应当向个人信息主体提供核心业务功能服务，不得因个人信息主体拒绝或者撤销同意收集上述信息以外的其他信息，而拒绝提供核心业务功能服务。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不足：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如何甄别网站、应用中哪些是核心功能？哪些是非核心功能？如果这个没有明确的解决方式，那么这个条款可能会沦为僵尸条款，因为这个问题属于业务层面问题，企业拥有绝对的主动权。虽然《规范》中规定：“个人信息控制者应根据一般用户对上述因素的最可能的认识和理解，而非自身想法来确定用户的主要需求和期待来划定基本业务功能。一般来说，如果产品或服务不提供基本业务功能，个人信息主体将不会选择使用该产品或服务。”，该规定本质上还是主观判定，可操作空间较大。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;建议：&lt;/p&gt;&lt;p&gt;增加：网络运营者应当明确列明核心业务功能，并说明理由，并接受监督。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;&lt;b&gt;亮点三&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;用户有权关掉精准广告&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;亮点：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;精准广告其实已经相当成熟了，并且也向市场证明了其商业价值，但早在精准广告刚进入用户视线的时候，还是有不少用户感到恐慌，认为自己被监控了，一举一动都暴露在网络运营者的眼中，刚浏览过减肥的信息，马上打开其他应用时，就会有一波减肥产品的广告砸框而来。这次《办法》让用户有权永久性关掉精准广告。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;《办法》第23条&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;第二十三条&lt;/b&gt; 网络运营者利用用户数据和算法推送新闻信息、商业广告等（以下简称“定向推送”），应当以明显方式标明“定推”字样，为用户提供停止接收定向推送信息的功能；用户选择停止接收定向推送信息时，应当停止推送，并删除已经收集的设备识别码等用户数据和个人信息。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不足：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;该细则从某种程度上来说，已经否定了“定向广告”（精准广告）这种商业模式。用户不仅有权选择停止接收定向广告，网络运营者还必须将已经收集的设备识别码等用户数据和个人信息删除，这基本上把定向广告的后路全部堵死。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;至于定向广告的商业价值不必多说，但以法规的形式直接否定一种商业模式的行为却是值得商榷的，当然，我个人是反对的。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;何为“利用用户数据和算法”推送广告？用户数据仅指个人信息还是？该规定过于模糊。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果说定向广告侵犯了用户的隐私权，甚至说只是使用了用户的个人信息，那关停定向广告尚有一定依据；倘若通过技术手段，或者以法律认为不侵犯用户权益的方式（朱烨诉百度案，法院认为cookie不属于可识别个人的信息）进行定向广告的推送，那这种定向广告是否还应当被禁止？或者说，用户是否还有权利禁止？我认为答案是否定的，因为此种情况下，用户与网络运营者之间就是正常的平等主体关系，法律法规无理由再干涉二者间的意思自治。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;另外，该细则规定，用户关停定向广告后，网络运营者必须删除已经收集的设备识别码等用户数据和个人信息，这个规定忽略了，设备识别码等用户数据和个人信息不仅仅用于定向广告，还可能用于其他各项服务，所以不能仅因用户关停定向广告，就要求删掉所有设备识别码等信息。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;说个题外话，即使用户关停了定向广告，网络运营者同样可以给用户发送普通广告，所以，用户关停定向广告的这个动作同时也是一个选择动作，即选择了普通广告。所以，从这点出发，网络运营者在草拟相关条款与设置相应操作界面的时候，可以着重向用户提示清楚这层含义，毕竟相比普通广告，相信用户更喜欢看定向广告。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;建议：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;将第二十三条修改为：&lt;/p&gt;&lt;p&gt;网络运营者利用用户数据和算法推送新闻信息、商业广告等（以下简称“定向推送”），应当以明显方式标明“定推”字样，为用户提供停止接收定向推送信息的功能，但不利用用户个人信息或未侵犯用户隐私的可不予提供停止接收定向推送信息的功能，但仍应标明“定推”字样；用户选择停止接收定向推送信息时，应当停止推送，并删除已经收集的设备识别码等用户数据和个人信息，但提供其他服务确实需要使用的可不予删除，但应当告知用户。&lt;/p&gt;&lt;hr/&gt;&lt;blockquote&gt;解读人 | 姜斯勇  &lt;br/&gt;首发 | 公号「 摇滚大数据 」&lt;br/&gt;个人交流微信 | scottlawyer&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;接下来我们将在公号陆续推出：&lt;br/&gt;&lt;b&gt;详细解读《数据安全管理办法（征求意见稿）》十大亮点（中）&lt;/b&gt;&lt;br/&gt;&lt;b&gt;详细解读《数据安全管理办法（征求意见稿）》十大亮点（下）&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>姜斯勇</author>
<guid isPermaLink="false">2019-06-01-67678553</guid>
<pubDate>Sat, 01 Jun 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>谈（公钥）密码学入门材料</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-03-30-60604123.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60604123&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a977411a75fbf92ff5a7d74ff804bc79_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;封面图片来源：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//m.dongao.com/zckjs/ksjy/201604/286502.shtml&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;2016注会：打好基础 全力备考&lt;/a&gt;。&lt;/blockquote&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;卧龙岗大学的Fuchun Guo老师作为主编，开设了《卧村密码学报》（Journal of WoCrypt，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.uow.edu.au/~fuchun/jow.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;uow.edu.au/~fuchun/jow.&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;）。这是一个用论文方式探讨非学术但和学术相关的密码“学术刊物”（其实是一个虚拟刊物）。该刊物的初衷是为了帮助以密码为研究对象的学生。澳大利亚卧龙岗市的卧龙岗大学（University of Wollongong）是Fuchun Guo老师创刊时期的工作单位，因此取名《卧村密码学报》。《卧村密码学报》欢迎一切和密码人相关的非学术论文。可以匿名或假名投稿。 可以吐槽，可以经验分享。只要你的目的是为了帮助长江后起之浪。投稿请发送文章至fuchun@uow.edu.au。&lt;/p&gt;&lt;p&gt;截至2019年03月26日，《卧村密码学报》已经发表了三篇文章：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第01期：《致我公钥密码研究生的一封信》。作者：郭福春。发表日期：2019年02月19日。链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.uow.edu.au/~fuchun/jow/001-OUWNZBACW.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;uow.edu.au/~fuchun/jow/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;001-OUWNZBACW.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;第02期：《一种新型公钥研究取题方法》。作者：赵臻，吴戈，王皓，郭福春。发表日期：2019年03月02日。链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.uow.edu.au/~fuchun/jow/002-UTSHWNZTA.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;uow.edu.au/~fuchun/jow/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;002-UTSHWNZTA.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;第03期：《&amp;lt;Introduction to Security Reduction&amp;gt;使用指南》。作者：郭福春。发表日期：2019年03月20日。链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.uow.edu.au/~fuchun/jow/003-AVSGWSK.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;uow.edu.au/~fuchun/jow/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;003-AVSGWSK.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;风趣幽默的文章风格和中肯的相关意见吸引了很多国内密码学研究人员的关注。特别推荐阅读第01期的文章，干货满满。我们强烈安利一波《卧村密码学报》，作为密码学科研之路的一个陪伴。&lt;b&gt;感兴趣的知友可以关注官方链接，也可以关注《卧村密码学报》的微信（在公众号搜索栏搜索“卧村密码学报”或“gh_712744288ac2”）即可找到&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;作为知乎上的三位密码学领域答主， &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/d543743c88797978a0a8c453f8768974&quot; data-hash=&quot;d543743c88797978a0a8c453f8768974&quot; data-hovercard=&quot;p$b$d543743c88797978a0a8c453f8768974&quot;&gt;@刘巍然-学酥&lt;/a&gt; 、 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/9cec268fa4cf3647f54f57703f8cc3d8&quot; data-hash=&quot;9cec268fa4cf3647f54f57703f8cc3d8&quot; data-hovercard=&quot;p$b$9cec268fa4cf3647f54f57703f8cc3d8&quot;&gt;@玄星&lt;/a&gt; 、 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/c65c83f0b15f8f9abf2566477ec1e0e7&quot; data-hash=&quot;c65c83f0b15f8f9abf2566477ec1e0e7&quot; data-hovercard=&quot;p$b$c65c83f0b15f8f9abf2566477ec1e0e7&quot;&gt;@是不懂啊&lt;/a&gt; 向《卧村密码学报》投稿文章《谈（公钥）密码学入门材料》。经过审阅与修改，此篇文章于2019年03月28日在《卧村密码学报》与大家见面了！PDF链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.uow.edu.au/~fuchun/jow/004-UYSTWNXKS.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;uow.edu.au/~fuchun/jow/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;004-UYSTWNXKS.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。微信公众号链接：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU2OTgzOTYxMg%3D%3D%26mid%3D2247483806%26idx%3D1%26sn%3Dd617ae5057c20e6442227ea67b3a91eb%26chksm%3Dfcf9db0dcb8e521b87363bc2d060a785c4f8c3bfadc5d78fc27a1115caaabb7795ae3223d584%26mpshare%3D1%26scene%3D1%26srcid%3D%26key%3Daa412f9ce4a2058d99cef0bcbbc18e8bbeb2517da4b965f76f356f5c89d5b23022d36522260c237e9bdef9301a3b6687cfd4d889f0dc6e1b537c97412754a236c06a4b98c0725e3800d17586fe69a93c%26ascene%3D1%26uin%3DMTQ5MTEzNTg2MA%253D%253D%26devicetype%3DWindows%2B7%26version%3D62060739%26lang%3Dzh_CN%26pass_ticket%3DyuI%252FmYR8VXlm3I4B7T%252FkUNF6IPvkEhuQoa996GmtUYU%252FBAh86qcyJlZk8f1hVjVn&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;第4期 《谈（公钥）密码学入门材料》--刘巍然，段立，罗宁&lt;/a&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;之所以撰写这样一篇文章，是因为很多研究（公钥）密码学的学生朋友都受困于密码学入门：不知道从哪本教材看起，不知道如何学习可证明安全技术，不知道应该阅读哪些论文。公钥密码学的发展还不到40年，门槛高、难度大，高质量的入门材料相对比较少。实际上，几乎每一位做密码学研究的老师都有过“满地找论文”、“乱看一气”的痛苦经历。为此， &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/d543743c88797978a0a8c453f8768974&quot; data-hash=&quot;d543743c88797978a0a8c453f8768974&quot; data-hovercard=&quot;p$b$d543743c88797978a0a8c453f8768974&quot;&gt;@刘巍然-学酥&lt;/a&gt; 、 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/9cec268fa4cf3647f54f57703f8cc3d8&quot; data-hash=&quot;9cec268fa4cf3647f54f57703f8cc3d8&quot; data-hovercard=&quot;p$b$9cec268fa4cf3647f54f57703f8cc3d8&quot;&gt;@玄星&lt;/a&gt; 、 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/c65c83f0b15f8f9abf2566477ec1e0e7&quot; data-hash=&quot;c65c83f0b15f8f9abf2566477ec1e0e7&quot; data-hovercard=&quot;p$b$c65c83f0b15f8f9abf2566477ec1e0e7&quot;&gt;@是不懂啊&lt;/a&gt; 根据自己的研（Shi）究（Bai）经历，总结了一些（公钥）密码学相关入门材料，如公开课、教材、书籍等。希望后续国内研究密码学的同学可以少走我们的弯路，快速定位到自己所需的入门材料，尽快走向科研之路。作为投身应用领域的小透明，我本身也感受到此领域招聘的困难：很难招聘到满足职位描述要求的候选人，现在只能自己养。我们希望更多有志于科研的同学投身于密码学的研究中，为数据安全领域做出自己的贡献。&lt;/p&gt;&lt;p&gt;&lt;b&gt;由于三位作者均以知乎密码学领域回答者的身份投稿。为回馈知乎平台，在与《卧村密码学报》主编沟通后，后置在知乎上发表。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;文章信息&lt;/h2&gt;&lt;h3&gt;作者信息&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;刘巍然，知乎昵称： &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/d543743c88797978a0a8c453f8768974&quot; data-hash=&quot;d543743c88797978a0a8c453f8768974&quot; data-hovercard=&quot;p$b$d543743c88797978a0a8c453f8768974&quot;&gt;@刘巍然-学酥&lt;/a&gt;（E-mail：&lt;a href=&quot;mailto:footman_900217@126.com&quot;&gt;footman_900217@126.com&lt;/a&gt;）。&lt;/li&gt;&lt;li&gt;段立，知乎昵称： &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/9cec268fa4cf3647f54f57703f8cc3d8&quot; data-hash=&quot;9cec268fa4cf3647f54f57703f8cc3d8&quot; data-hovercard=&quot;p$b$9cec268fa4cf3647f54f57703f8cc3d8&quot;&gt;@玄星&lt;/a&gt; （E-mail：&lt;a href=&quot;mailto:liduan@mail.upb.de&quot;&gt;liduan@mail.upb.de&lt;/a&gt;）。&lt;/li&gt;&lt;li&gt;罗宁，知乎昵称： &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/c65c83f0b15f8f9abf2566477ec1e0e7&quot; data-hash=&quot;c65c83f0b15f8f9abf2566477ec1e0e7&quot; data-hovercard=&quot;p$b$c65c83f0b15f8f9abf2566477ec1e0e7&quot;&gt;@是不懂啊&lt;/a&gt; 。E-mail：&lt;a href=&quot;mailto:nluo.sdu@gmail.com&quot;&gt;nluo.sdu@gmail.com&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;撰写时间&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;开搞时间：2019年03月02日&lt;/li&gt;&lt;li&gt;搞完时间：2019年03月27日&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;摘要&lt;/h3&gt;&lt;p&gt;在刚开始进入一个领域时，入门材料的选择会对今后的学习与研究带来巨大的影响。好的入门材料深入浅出、引人入胜，不仅介绍了必要的知识和方法，还会引发读者学习的兴趣；反之，不适当的入门材料或者难度较大、或者过于抽象，会让读者产生挫败感。本文针对初入（公钥）密码领域的研究人员在阅读材料选择和甄别方面的先天不足问题，基于作者的学习经验，采用了分级、分类的方式，提纲挈领式地分析并推介一些入门素材以及学习心得，希望能引导初学者更高效地捕捉到密码学习的有效路径。本文的目标读者是初入公钥密码学领域的研究人员。此外，大部分基础材料适用于初入对称密码学、应用密码学、隐私保护基础领域的研究人员。&lt;/p&gt;&lt;h3&gt;关键词&lt;/h3&gt;&lt;p&gt;密码学；公开课；教材和书籍；入门论文&lt;/p&gt;&lt;h2&gt;1 引言&lt;/h2&gt;&lt;p&gt;刚开始进入一个领域时，入门材料的选择非常重要。密码学是一个数学、计算机、电子信息的交叉学科。具有数学背景的同学往往无法理解计算复杂度、数据结构与算法等计算机学科的相关知识，在面对安全性证明、原型系统实现时会一筹莫展；具有计算机背景的同学可能会受困于群论、格等相对复杂的数学理论，在设计密码学方案时毫无办法；具有电子信息背景的同学虽具有两个学科的背景知识，但无论从深度还是从广度看，背景知识的掌握可能无法达到要求。如果没有掌握必要的基础知识，在阅读密码学论文，特别是三大密码学顶级会议（CRYPTO、EUROCRYPT、ASIACRYPT）和四大安全类会议（Security &amp;amp; Privacy、USENIX Security、CCS、NDSS）论文时或许会遇到困难，如难以理解约定俗成的符号表示，难以适应相关知识点的描述方式。在理解密码学概念时，背景知识的欠缺也可能导致理解出现偏差或错误，而这些最终会反应到所撰写的论文中。如果基本的定义描述出现偏差或错误，审稿人有理由相信论文中可能存在更严重的错误，对论文产生负面印象，甚至导致拒稿。&lt;/p&gt;&lt;p&gt;我们给出一个例子来说明这个问题。为了推广差分隐私（Differential Privacy）技术，差分隐私定义的提出者，微软研究院Cynthia Dwork研究员与美国宾夕法尼亚大学的助理教授Aaron Roth撰写了一本名为《The Algorithmic Foundations of Differential Privacy》的书籍[22]。此书给出的差分隐私定义如下：&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定义1（差分隐私）&lt;/b&gt;．给定一个定义在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathbb%7BN%7D%5E%7B%7C%5Cmathcal%7BX%7D%7C%7D&quot; alt=&quot;\mathbb{N}^{|\mathcal{X}|}&quot; eeimg=&quot;1&quot;/&gt; 上的随机化算法 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BM%7D&quot; alt=&quot;\mathcal{M}&quot; eeimg=&quot;1&quot;/&gt; ，如果对于所有的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BS%7D+%5Csubseteq+%5Ctext%7BRange%7D%28%5Cmathcal%7BM%7D%29&quot; alt=&quot;\mathcal{S} \subseteq \text{Range}(\mathcal{M})&quot; eeimg=&quot;1&quot;/&gt; ，以及所有满足 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Cx-y%5C%7C_%7B1%7D+%5Cleq+1&quot; alt=&quot;\|x-y\|_{1} \leq 1&quot; eeimg=&quot;1&quot;/&gt; 的输入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%2Cy+%5Cin+%5Cmathbb%7BN%7D%5E%7B%7C%5Cmathcal%7BX%7D%7C%7D&quot; alt=&quot;x,y \in \mathbb{N}^{|\mathcal{X}|}&quot; eeimg=&quot;1&quot;/&gt; ：&lt;br/&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CPr%5B%5Cmathcal%7BM%7D%28x%29+%5Cin+%5Cmathcal%7BS%7D%5D+%5Cleq+e%5E%7B%5Cepsilon%7D+%5Ccdot+%5CPr%5B%5Cmathcal%7BM%7D%28y%29+%5Cin+%5Cmathcal%7BS%7D%5D+%2B+%5Cdelta&quot; alt=&quot;\Pr[\mathcal{M}(x) \in \mathcal{S}] \leq e^{\epsilon} \cdot \Pr[\mathcal{M}(y) \in \mathcal{S}] + \delta&quot; eeimg=&quot;1&quot;/&gt; &lt;br/&gt;则称随机化算法 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BM%7D&quot; alt=&quot;\mathcal{M}&quot; eeimg=&quot;1&quot;/&gt; 满足 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cepsilon%2C+%5Cdelta%29&quot; alt=&quot;(\epsilon, \delta)&quot; eeimg=&quot;1&quot;/&gt; -差分隐私性。&lt;/blockquote&gt;&lt;p&gt;这个定义看上去非常简单，但如果深入剖析就会发现其非常严谨：算法 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BM%7D&quot; alt=&quot;\mathcal{M}&quot; eeimg=&quot;1&quot;/&gt; 定义为一个随机化算法，而不是定义为算法； &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BS%7D&quot; alt=&quot;\mathcal{S}&quot; eeimg=&quot;1&quot;/&gt; 的定义写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BS%7D+%5Csubseteq+%5Ctext%7BRange%7D%28%5Cmathcal%7BM%7D%29&quot; alt=&quot;\mathcal{S} \subseteq \text{Range}(\mathcal{M})&quot; eeimg=&quot;1&quot;/&gt; ，而非写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BS%7D+%5Cin+%5Ctext%7BRange%7D%28%5Cmathcal%7BM%7D%29&quot; alt=&quot;\mathcal{S} \in \text{Range}(\mathcal{M})&quot; eeimg=&quot;1&quot;/&gt; 。如果缺乏相应的基础知识，则这些细微的差别会导致对定义产生错误的理解。&lt;/p&gt;&lt;p&gt;有位老师曾提到：想要学成下山独立写论文，至少需要花费一整年的时间（每天10个小时）[85]。既然已经决定要研究密码学领域，花费一整年的时间学习基础知识是必要的。然而，应该如何花费这一整年的时间高效地完成基础知识的学习？在知乎上，我们时常收到私信或回答邀请，询问是否可以推荐一些密码学入门材料。我们在本篇文章就尝试介绍相关入门材料，以供参考。&lt;/p&gt;&lt;p&gt;由于作者水平有限，所能接触到的材料主要涉及公钥密码学和部分隐私保护技术，因此本文主要关注此方面的入门材料。某位研究对称加密侧信道攻击的博士研究生指出，如果主要研究方向为对称密码学的攻击领域，本文所介绍的大部分基础材料仍然适用，特此注明。&lt;/p&gt;&lt;p&gt;本文组织结构如下。第二章将介绍一些必学材料。无论未来将要研究（公钥）密码学的哪一个领域，都需要浏览这些必学材料，掌握必备的基础知识。第三章将介绍一些高质量的密码学分支领域入门材料，这些入门材料可以帮助我们快速了解核心思想，快速定位必读论文。第四章将介绍密码学关联学科的入门材料，如抽象代数、计算复杂性原理、数据结构与算法等。第五章将包含一些零散的意见和建议，如我们熟知领域的一些入门论文，部分难度较大、不适于入门的材料。第六章将对全文进行总结。图1为全文内容概览。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e49d4b3ee180e663148c8d6efc66d501_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1644&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1644&quot; data-original=&quot;https://pic2.zhimg.com/v2-e49d4b3ee180e663148c8d6efc66d501_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e49d4b3ee180e663148c8d6efc66d501_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1644&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1644&quot; data-original=&quot;https://pic2.zhimg.com/v2-e49d4b3ee180e663148c8d6efc66d501_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e49d4b3ee180e663148c8d6efc66d501_b.jpg&quot;/&gt;&lt;figcaption&gt;图1：全文概览&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;2 必学材料&lt;/h2&gt;&lt;p&gt;当我们以在三大密码学会议或四大信息安全会议上发表论文为核心目标，从导师或者师兄师姐处得到密码学科研之路的第一篇学术论文，兴致勃勃地打印出论文并毫无阻碍地读完引言部分，信心满满地准备开始自己的科研之路时，我们可能会突然发现：从论文的预备知识部分就开始读不懂了。举个例子，为了帮助密码学研究者理解仿真证明技术，Yehuda Lindell教授于2018年发布了一篇题目为《How To Simulate It – A Tutorial on the Simulation Proof Technique》的文章[53]。在相对轻松地阅读完引言后，我们在第二章，也就是预备知识和符号表示部分，遇到了这篇“指南”的第一个定义：计算不可区分性。下方的&lt;b&gt;定义2&lt;/b&gt;为翻译结果，我们建议直接阅读原文的描述。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定义2（计算不可区分性）．&lt;/b&gt;一个&lt;b&gt;概率总体&lt;/b&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=X%3D%5C%7BX%28a%2Cn%29%5C%7D_%7Ba+%5Cin+%5C%7B0%2C1%5C%7D%5E%2A%3B+n+%5Cin+%5Cmathbb%7BN%7D%7D&quot; alt=&quot;X=\{X(a,n)\}_{a \in \{0,1\}^*; n \in \mathbb{N}}&quot; eeimg=&quot;1&quot;/&gt; 是一个无穷随机变量序列，对应的索引为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%5Cin+%5C%7B0%2C1%5C%7D%5E%2A&quot; alt=&quot;a \in \{0,1\}^*&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n+%5Cin+%5Cmathbb%7BN%7D&quot; alt=&quot;n \in \mathbb{N}&quot; eeimg=&quot;1&quot;/&gt; 。在安全多方计算场景下， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 表示参与方的输入， &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 表示安全参数。给定两个概率总体 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X%3D%5C%7BX%28a%2Cn%29%5C%7D_%7Ba+%5Cin+%5C%7B0%2C1%5C%7D%5E%2A%3B+n+%5Cin+%5Cmathbb%7BN%7D%7D&quot; alt=&quot;X=\{X(a,n)\}_{a \in \{0,1\}^*; n \in \mathbb{N}}&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Y%3D%5C%7BY%28a%2Cn%29%5C%7D_%7Ba+%5Cin+%5C%7B0%2C1%5C%7D%5E%2A%3B+n+%5Cin+%5Cmathbb%7BN%7D%7D&quot; alt=&quot;Y=\{Y(a,n)\}_{a \in \{0,1\}^*; n \in \mathbb{N}}&quot; eeimg=&quot;1&quot;/&gt; ，如果对于所有非均匀多项式时间算法 &lt;img src=&quot;https://www.zhihu.com/equation?tex=D&quot; alt=&quot;D&quot; eeimg=&quot;1&quot;/&gt; ，存在一个可忽略函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%28n%29&quot; alt=&quot;\mu(n)&quot; eeimg=&quot;1&quot;/&gt; ，使得对于所有的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%5Cin+%5C%7B0%2C1%5C%7D%5E%2A&quot; alt=&quot;a \in \{0,1\}^*&quot; eeimg=&quot;1&quot;/&gt; 和所有的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n+%5Cin+%5Cmathbb%7BN%7D&quot; alt=&quot;n \in \mathbb{N}&quot; eeimg=&quot;1&quot;/&gt; ：&lt;br/&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cleft%7C%5CPr%5BD%5Cleft%28X%28a%2Cn%29%5Cright%29+%3D+1%5D+-+%5CPr%5BD%5Cleft%28Y%28a%2Cn%29%5Cright%29+%3D+1%5D%5Cright%7C+%5Cleq+%5Cmu%28n%29&quot; alt=&quot;\left|\Pr[D\left(X(a,n)\right) = 1] - \Pr[D\left(Y(a,n)\right) = 1]\right| \leq \mu(n)&quot; eeimg=&quot;1&quot;/&gt; &lt;br/&gt;则称这两个概率总体&lt;b&gt;计算不可区分&lt;/b&gt;，表示为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X%5Cequiv+Y&quot; alt=&quot;X\equiv Y&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/blockquote&gt;&lt;p&gt;什么是随机变量序列的索引？怎么理解安全参数？什么是非均匀多项式时间算法？开始时我们或许认为可能是自己的英语功底不够，无法熟练地阅读专业英语材料。然而，即使是翻译成母语，这段话也我们来说可能也完全不知所云。理解这些定义需要一定的基础知识。在时间有限的条件下，我们可以查阅维基百科快速了解相关的定义内容。但是，如果想在以后的研究过程中走得更长、走得更稳，有必要深入理解这些定义的内涵。否则，总有一天我们会不得不回过头来重新补充那些当时我们没有认真探究的知识。&lt;/p&gt;&lt;p&gt;本章我们着重解决基础知识问题，推荐必学公开课和必学教材。公开课对基础知识的学习带来很大的帮助：（1）每节公开课的时长相对固定，这可以帮助我们合理安排时间，制定相应的学习计划；（2）可以将公开课看作教材的索引，帮助我们定位知识点，加深理解；（3）与阅读教材相比，观看公开课相对可能更有趣一些。优质的教材会帮助我们建立正确的密码学思维方式，了解约定俗成的符号定义和描述方法，为阅读论文扫清障碍。如果推荐的材料有对应的中文翻译版本，我们会进行注明。如果中文翻译材料为书籍，我们一并给出豆瓣读书的评分。如果感觉直接使用英文材料较为困难，可以先阅读对应的中文翻译版本。但我们想强调的是，早晚有一天我们需要阅读和撰写英文论文。因此，不如对自己狠一点，直接阅读英文教材。&lt;/p&gt;&lt;h3&gt;2.1 密码学导论&lt;/h3&gt;&lt;p&gt;说到密码学导论，必须要推荐Dan Boneh教授的公开课“Cryptography I”[10]。虽然目前只推出了第一部分，但这门课程已经包含密码学中常见概念的介绍，包括Stream Cipher、Block Cipher、Message Integrity、Authenticated Encryption、Basic Key Exchange、以及Public-Key Encryption。这门课程可以极大地提高我们的英语听力水平。Dan Boneh教授的语速如机关枪一般，这可能也是我们一直没有翻译巴伊兰大学冬令营《密码学中的双线性群》讲座视频的原因[35]：讲座的听写难度太大了。这门课程另外一个有意思的地方是每一部分的编程作业。学生需要通过编程的方式解决实际中的密码学问题，加深相关知识点的理解。例如，需要应用Padding Oracle Attack破解用Cipher Block Chaining（CBC）模式加密的密文；需要应用Baby-Step-Giant-Step法解决一个给定的离散对数问题；需要应用Birthday Attack得到一组前50比特哈希结果相同的消息。完成这些作业将帮助我们更好地理解相关的概念。&lt;/p&gt;&lt;p&gt;有关密码学导论的相关教材，我们必须要推荐Jonathan Katz教授和Yehuda Lindell教授撰写的《Introduction to Modern Cryptography, 2nd Edition》[45]。这本书足够新，写得足够好、论述得足够深。最为重要的是，这本书通俗易懂地讲解了密码学的核心概念，以及安全性证明的核心思路。无论未来将从事哪方面密码学方向的研究，这本书都可以作为必读教材。如果想把里面的内容完全学懂学透，至少也需要1年至2年的时间。但我们认为，如果想在未来长期从事密码学的研究工作，这个时间的花费是必要的。遗憾的是，这本教材的第二版尚无中文版本。这本教材的第一版，即《现代密码学：原理与协议》（Introduction to Modern Cryptography: Principles and Protocols）[45]有对应的中文版本，由任伟老师翻译[47]，豆瓣读书尚无评分。&lt;/p&gt;&lt;p&gt;主讲“Cryptography I”公开课的Dan Boneh教授正在联合著名密码学家Victor Shoup教授撰写面向研究生的密码学教材《A Graduate Course in Applied Cryptography》[17]。这本教材与前面提到的《Introduction to Modern Cryptography, 2nd Edition》教材风格类似，但由于是面向研究生的教材，其难度相对会更大，安全性证明的描述更加全面。&lt;/p&gt;&lt;h3&gt;2.2 （公钥）密码学安全性证明&lt;/h3&gt;&lt;p&gt;研究公钥密码学相关领域，安全性证明是不可避免的门槛。正如Yehuda Lindell在文章《How To Simulate It – A Tutorial on the Simulation Proof Technique》的摘要中所描述：然而，构造仿真算法、应用仿真技术证明安全性，这不是一件简单的任务。绝大多数刚进入密码学领域的研究人员都认为这非常困难[53]。在此，我们推荐一些优秀的安全性证明阅读材料。希望这些材料可以帮助刚进入密码学领域的研究人员高效学习安全性证明的基本思想和基本方法。&lt;/p&gt;&lt;p&gt;实际上，通过密码学导论相关读物，我们已经或多或少地知晓了安全性证明的基本思路，也阅读到了一些密码学方案的安全性证明。但是，学习已有的证明是一方面，是否可以独立自主地撰写安全性证明又是另一个难题。如果不知道如何为哪怕一个简单的方案撰写安全性证明，可以阅读Victor Shoup教授的论文《Sequences of Games: A Tool for Taming Complexity in Security Proofs》[75]。这篇论文不会让安全性证明变得简单，但是会讲解怎么更系统地整理证明思路，把细节一步步有调理的放在一串攻击者与仿真者的游戏里。读完里面关于RSA和ElGamal安全性证明的“改写”，会对原先的证明过程有全新认识。&lt;/p&gt;&lt;p&gt;如果仍然对安全性证明一筹莫展，可以考虑阅读Fuchun Guo、Willy Susilo、Yi Mu的著作《Introduction to Security Reduction》[32]。这本书最突出的特点是对几乎所有安全性证明写得非常好的方案进行了完整的讲解，如数字签名中随机预言模型下的Boneh-Lynn-Shacham方案[15]、标准模型下的Boneh-Boyen方案[13]；公钥加密方案中第一个选择密文安全的Cramer-Shoup方案[20]、第一个基于身份加密（Identity-Based Encryption，IBE）方案Boneh-Franklin方案[14]、标准模型下两个IBE方案Waters方案[83]和Gentry方案[26]。这几个方案所对应原始论文的安全性证明都写得非常清晰，建议精读。&lt;/p&gt;&lt;p&gt;特别要注意的是，很多论文都有会议版本和期刊版本。如果论文只有会议版本，作者一般也会将论文的扩展版本（或称完整版本）上传至国际密码学研究协会（International Association for Cryptologic Research，IACR）的网站上。如果想精读一篇论文，建议寻找发表在IACR上的版本，此版本的内容可能会更加全面。&lt;/p&gt;&lt;blockquote&gt;IACR的官方网站是&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.iacr.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;www.iacr.org&lt;/a&gt;。此网站还会发布与密码学相关的众多资讯，强烈建议申请此网站的邮件订阅。&lt;/blockquote&gt;&lt;p&gt;相对于加密方案或安全协议的安全性证明，我们更推荐先从数字签名方案的安全性证明入手。与加密方案和安全协议相比，数字签名方案的安全模型相对比较简单。数字签名方案的安全性一般依赖于计算性困难假设。与判定性困难假设相比，计算性困难假设更容易理解一些。建议阅读Boneh-Lynn-Shacham方案的会议版本[15]，因为会议版本是以逐个游戏迭代的模式撰写的，是一个学习此种证明方式的好论文，而期刊版本是以单个游戏的模式撰写的[16]。不可否认，期刊版本也是非常好的学习材料。强烈建议阅读Boneh-Boyen签名方案的期刊版本论文[13]。论文写得非常全面，作者几乎把所有能想到的点都写到了。从这篇论文可以领略顶级密码学家“走自己的路，让别人无路可走”的论文写作方法。&lt;/p&gt;&lt;p&gt;有关公钥加密方案的安全性证明，首先推荐Cramer-Shoup方案的论文[20]。相比于近些年来动辄数十页甚至上百页的论文来说，这篇论文的长度会短得多，阅读起来会显得轻松不少。这篇论文的安全性证明堪称范本，应用单个游戏的模式完成了安全性证明，描述非常清晰，很容易理解证明思路。有关逐个游戏迭代模式的安全性证明，推荐阅读Lewko-Waters方案论文[50]。这篇论文应用对偶证明方法，在合数阶双线性群下将Boneh-Boyen-Goh选择性安全（Selectively Secure）的层次基于身份加密（Hierarchical Identity-Based Encryption，HIBE）方案转换成了适应性安全（Adaptively Secure）的HIBE方案[12]。对偶证明方法需要以逐个游戏迭代模式完成证明，证明难度不大，但是符号特别多，可以尝试列举一下这篇论文一共使用了多少种不同的符号。&lt;/p&gt;&lt;p&gt;通用密码学协议（General Cryptographic Protocol）是为实现任意函数的计算，通过安全地组合各种密码学原语而形成的安全计算协议。有关通用密码学协议的安全性证明学习，我们推荐Yehuda Lindell的文章《How To Simulate It – A Tutorial on the Simulation Proof Technique》[53]。这是目前为止唯一一个针对密码学协议，以教程（Tutorial）的形式分析仿真安全性证明方法的文章。全文从半诚实攻击者攻击下安全的不经意传输协议（Oblivious Transfer Secure against Semi-Honest Adversary）这一最基础的协议开始，到混合模型下的证明（Security in Hybrid Model），再到顺序组合定理（Sequential Composition Theorem）和针对恶意攻击者攻击的转换方法，最后在结尾简要介绍了通用组合性（Universal Composition）的概念，每一步的讲解都极尽精准和详细。但需要注意的是，这篇文章的阅读可能需要花费较长的时间。静下心来慢慢读、多读几遍，每一次阅读都一定会有新的收获。&lt;/p&gt;&lt;h2&gt;3 分支领域推荐入门材料&lt;/h2&gt;&lt;p&gt;学习完必学材料后，我们可能就会切入到具体的研究方向中，开展自己的密码学研究了。然而，每一个密码学领域或多或少都有一定的差异，对应的经典论文也不尽相同。如何快速把握某一分支领域的核心思想和关键论文就成为了接下来的难题。接下来，我们介绍一些可以快速了解密码学分支领域的材料。&lt;/p&gt;&lt;h3&gt;3.1 巴伊兰大学冬令营演讲视频&lt;/h3&gt;&lt;p&gt;讲到密码学分支领域，不得不提巴伊兰大学的密码学冬令营（BIU Winter School on Cryptography）。这可能是密码学研究者们为全世界带来的最佳密码学分支领域科普材料。自2011年起，以色列巴伊兰大学每年冬天都会选择一个密码学主题，邀请这个主题下全世界最著名的密码学家来到巴伊兰大学带来精彩的讲座。巴伊兰应用密码学和网络安全研究中心（The BIU Research Center on Applied Cryptography and Cyber Security）在YouTube上传了全部讲座的视频录像。可以在对应的官方网站上找到所有视频的幻灯片。&lt;/p&gt;&lt;p&gt;安全多方计算领域的两位著名学者Yehuda Lindell和Benny Pinkas在巴伊兰大学任职。因此，2011年第一届密码学冬令营毫无悬念地选择了“Secure Computation And Efficiency”作为主题，举办时间为2011年01月30日至2011年02月01日[33]。由于这是第一年组织冬令营，此系列视频录制的质量相对较低，讲解的内容较为分散。&lt;/p&gt;&lt;p&gt;第二届密码学冬令营于2012年02月19日至2019年02月22日召开，主题为“Lattice-Based Cryptography”。[34]此次冬令营邀请到了Oded Regev（提出了著名密码学假设Learning With Error[65]）、Chris Peikert（提出了基于格的陷门构造方法[63]，2019年提出了基于格的非交互式零知识证明构造方法[62]）、Vadim Lyubashevshy（提出了理想格和理想格上的Learning With Error困难问题[56]）、以及Craig Gentry（第一个全同态加密方案的构造者[25]）。巴伊兰大学后续组织的冬令营主题和举办时间列举如下。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;“Bilinear Pairing in Cryptography”[35]，2013年02月04日至2013年02月07日。&lt;/li&gt;&lt;li&gt;“Symmetric Encryption in Theory and in Practice”[36]，2014年01月27日至2014年01月30日。&lt;/li&gt;&lt;li&gt;“Advances in Practical Multiparty Computation”[37]，2015年02月15日至2015年02月19日。&lt;/li&gt;&lt;li&gt;“Cryptography in the Cloud – Verifiable Computation and Special Encryption”[38]，2016年01月04日至2016年01月07日。&lt;/li&gt;&lt;li&gt;“Differential Privacy: From Theory to Practice”[39]，2017年02月12日至2017年02月16日。&lt;/li&gt;&lt;li&gt;“Secret Key Exchange”[42]，2018年01月11日至2018年01月15日。&lt;/li&gt;&lt;li&gt;“Zero Knowledge”[49]，2019年02月18日至2019年02月19日。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;巴伊兰大学的密码学冬令营的讲座主题已经涵盖了密码学领域几乎所有的分支。相关视频也成为了密码学入门的宝贵资料。在多方的共同努力下，我们目前已经完成了“Lattice-Based Cryptography”全部视频、“Differential Privacy: From Theory to Practice”除博弈论外其余所有视频的听写和翻译工作。在i春秋的赞助下，“Lattice-Based Cryptography”视频已经发布在i春秋课程库中的《世界上最顶级的密码学课程》中[87]。由于尚未找到合适的视频发行方，“Differential Privacy: From Theory to Practice”尚未发布。当前，我们在进行“Advances in Practical Multiparty Computation”视频的听写和翻译工作，但由于视频较长、难度较大，进度并不乐观。我们衷心希望对此有兴趣的密码学研究人员可以加入我们，共同翻译这一系列课程。&lt;/p&gt;&lt;h3&gt;3.2 密码学基础指南&lt;/h3&gt;&lt;p&gt;Oded Goldreich教授是密码学先驱科学家，为密码学理论做出了卓越的贡献。他也指导出了大批优秀的密码学研究人员。为了纪念这位密码学先驱，他的学生们联合起来，于2017年撰写了一本有关高级密码学理论和计算复杂性的研究生教材，教材名称为《Tutorials on the Foundations of Cryptography》[54]。&lt;/p&gt;&lt;p&gt;这本教材涵盖了当前密码学的几大分支领域：安全多方计算中的乱码电路、公钥密码学、伪随机函数、单向函数、同态加密、仿真证明技术、差分隐私，对应的章节名称分别为：《Garbled Circuits as Randomized Encodings of Functions: a Primer》、《The Complexity of Public-Key Cryptography》、《Pseudorandom Functions: Three Decades Later》、《The Many Entropies in One-Way Functions》、《Homomorphic Encryption》、《How to Simulate It: A Tutorial on the Simulation Proof Technique》、《The Complexity of Differential Privacy》。前面多次提到的《How to Simulate It: A Tutorial on the Simulation Proof Technique》[53]就是这本教材的其中一个章节。这本教材偏向于密码学理论，涵盖了各个领域的基本思想、定义、当前主要研究成果。既然偏向于理论，这本教材的缺点是学习曲线比较陡峭。即使是《How to Simulate It: A Tutorial on the Simulation Proof Technique》[53]，读起来也并不轻松。但是，能够完整理解这本教材的撰写内容，会对后续的研究起到可观的促进作用。因此，我们仍然推荐密码学理论研究人员阅读这本教材。&lt;/p&gt;&lt;h3&gt;3.3 信息安全、隐私与信任系列讲义&lt;/h3&gt;&lt;p&gt;既然有面向理论研究人员的教材，也就必然有面向应用研究人员的教材。我们推荐Elisa Bertino和Ravi Sandhu主编的系列丛书《Synthesis Lectures on Information Security, Privacy, and Trust》。这套系列丛书的目的是围绕信息安全、隐私和信任这一主题，为每一个网络安全分支领域推出一本50至100页的书籍。截至2019年03月，此系列书籍已经涵盖了异常检测、智能电网安全、区块链与密码货币、差分隐私、隐私风险分析、安全外包计算、数据库隐私、社交网络安全、RFID安全、隐私信息检索、操作系统安全等多个领域。&lt;/p&gt;&lt;p&gt;目前，我们正在尝试翻译Ninghui Li、Min Lyu、Dong Su、Weining Yang老师撰写的《Differential Privacy: From Theory to Practice》[51]。这本书站在工程师的角度介绍了差分隐私的基本定义、基本概念，以及可以在数据库应用系统中可以使用的差分隐私技术。书籍中所介绍的技术并非来自于诸如STOC、FOCS、TCC等偏向于计算机理论的会议论文，而是来自于SIGMOD、VLDB、ICDE等数据库领域会议论文。由此可见，此书轻理论、重应用，是一本很不错的差分隐私分支领域阅读材料。遗憾的是，由于篇幅原因，这本书没有介绍 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cepsilon%2C+%5Cdelta%29&quot; alt=&quot;(\epsilon, \delta)&quot; eeimg=&quot;1&quot;/&gt; -差分隐私、图数据集差分隐私、本地差分隐私等内容。作者在引言部分指出，本书的第二卷将涵盖这些方面。&lt;/p&gt;&lt;h3&gt;3.4 细分领域入门材料&lt;/h3&gt;&lt;p&gt;密码学领域可以进一步细分为更为分支的研究方向，每一个研究方向又包含其独有的核心入门材料。本节，我们列举一些我们所熟知领域的优秀入门材料，仅供参考。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.4.1 密钥协商与密钥交换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于非通用密码学协议，尤其是认证密钥协商（Authenticated Key Exchange），更常见的仍是和加密方案类似、使用基于游戏的证明（Game-Based Proof）方法。对于已经学习过密码学基础的同学，我们推荐Mihir Bellare、David Pointcheval和Philip Rogaway撰写的论文《Authenticated Key Exchange Secure against Dictionary Attacks》[8]和Tibor Jager、Florian Kohlar、Sven Schäge、Jörg Schwenk撰写的论文《On the Security of TLS-DHE in the Standard Model》[43]。推荐的首要原因是这两篇论文具有极高的易读性，所需要的前置知识只有判定性Diffie-Hellman假设（Decisional Diffie-Hellman Assumption）、哈希函数、伪随机函数（Pseudo-Random Function）和数字签名的安全概念。前者仔细剖析了如何通过定义参与方（Parties）、通信进程（Process | Session）、攻击者的能力（Queries）来定义一个密钥交换协议的执行环境（Exexution Environment），以及如何才算一个有效的攻击（Freshness、Forward Secrecy、Key Indistinguishability）。论文中提到的基于口令的密钥交换是以低熵值种子作为基础，通过互动逐步提升整体安全性的最佳例子之一。后者针对TLS 1.2这个应用最广泛的安全通信协议，扩展了前者的模型，定义了认证信道（Authenticated Channel）的概念。论文的完整版给出了极其详尽的安全性证明。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.4.2 差分隐私&lt;/b&gt;&lt;/p&gt;&lt;p&gt;差分隐私属于隐私保护研究领域，但由于此技术具有严密的数学逻辑，可以通过形式化安全证明论述方案的隐私保护程度，因此差分隐私已经逐渐成为密码学领域中的一个独立的分支。&lt;/p&gt;&lt;p&gt;差分隐私最大的特点是入门门槛较高，此技术既包含了与公钥密码学类似的安全性证明技术，又包含了数理统计方面的内容。如果想入门差分隐私技术，建议直接阅读Kunal Talwar和Frank McSherry撰写的论文《Mechanism Design via Differential Privacy》[57]。这篇论文提出了差分隐私中最重要的机制之一，指数机制（Exponential Mechanism）。几乎所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon&quot; alt=&quot;\epsilon&quot; eeimg=&quot;1&quot;/&gt; -差分隐私机制都可以看成指数机制的特例，因此理解指数机制也意味着基本可以理解差分隐私的核心思想。本篇论文虽然发表在计算机领域顶级会议FOCS上，但论文的描述相对容易理解，但又不失严格，是一篇优秀的入门论文。如果仍然不能很好地理解差分隐私的概念，可以尝试阅读Ninghui Li、Wahbeh H. Qardaji、Dong Su等人的论文《Membership Privacy: A Unifying Framework for Privacy Definitions》[52]。此篇论文提出了成员隐私（Membership Privacy）的定义。相比差分隐私，成员隐私应用先验概率和后验概率之间的关系描述隐私保护程度。这篇论文可以帮助我们从更广义的层面理解差分隐私。&lt;/p&gt;&lt;p&gt;差分隐私的一个重要定理是组合性定理（Composition Theorem）。组合性定理在隐私保护技术和数理统计之间建立了数学意义上的关联。建议直接阅读Peter Kairouz、Oh Sewoong、Pramod Viswanath撰写的论文《The Composition Theorem for Differential Privacy》[44]。这篇论文详细论述了差分隐私和假设检验之间的关系。阅读此篇论文不仅可以更深入的理解差分隐私，也可以理解差分隐私的另一个重要定义， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cepsilon%2C+%5Cdelta%29&quot; alt=&quot;(\epsilon, \delta)&quot; eeimg=&quot;1&quot;/&gt; -差分隐私的概念，为研究差分隐私机器学习做好准备。&lt;/p&gt;&lt;p&gt;本地差分隐私（Local Differential Privacy）是差分隐私的另一大研究分支，主要关注于数据采集过程中的隐私保护技术。目前苹果和谷歌公司所使用的差分隐私技术就属于本地差分隐私的范畴。如果想系统地学习本地差分隐私技术，特别是理解苹果和谷歌公司所使用的本地差分隐私技术，可以阅读Tianhao Wang、Jeremiah Blocki、Ninghui Li等人的论文《Locally Differentially Private Protocols for Frequency Estimation》[82]。这篇论文详细讨论了应用本地差分隐私技术实现隐私保护频率估计的方法，并给出了不同场景下的最优解。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.4.3 不经意随机存取机&lt;/b&gt;&lt;/p&gt;&lt;p&gt;加密方案通过加密信息的内容，也就是加密明文来实现信息保护；差分隐私则通过在计算的结果中加入噪音来实现个体信息保护；而不经意随机存取机（Oblivious Random Access Machine，ORAM）则是通过隐藏访问路径来实现信息保护。&lt;/p&gt;&lt;p&gt;对想了解ORAM的同学来说，建议从Oded Goldreich和Rafail Ostrovsky的论文《Software Protection and Simulation on Oblivious RAMs》[28]开始。这篇论文首次提出了ORAM的概念，虽然篇幅稍长，但无论是RAM模型（RAM Model）或者是不经意性（Obliviousness），论文中都给出了非常详细的定义和解释，即使是没有相关基础的同学也可以直接上手。这篇论文用了较大的篇幅证明ORAM和软件保护（Software Protection）的等价关系，可以看情况决定是否直接跳过这一部分的内容。此外，这篇论文还给出了ORAM运行代价（Overhead）的下界及其证明，刚入门的同学了解结论即可。&lt;/p&gt;&lt;p&gt;单服务器（Single-Server）ORAM的构造方案主要分为两大类：分级式的ORAM（Hierarchical ORAM）方案和树状ORAM（Tree Based ORAM）。《Software protection and simulation on oblivious RAMs》[28]中提出了分级式的ORAM。很多后续方案也是在此基础上进行优化的。对于想要了解ORAM的同学来说，Emil Stefanov、Marten van Dijk、Elaine Shi等人的《Path ORAM: An Extremely Simple Oblivious RAM Protocol》[81]是另外一篇必读的论文。Path ORAM作为树状ORAM的一种，构造非常简单和经典，建议已有密码学基础的同学精读。&lt;/p&gt;&lt;p&gt;ORAM的一个重要的应用是RAM模型下的安全多方计算。对这方面感兴趣的同学，建议在掌握了安全多方计算和ORAM的基础知识后，阅读Samee Zahur、Xiao Wang、Mariana Raykova等人的论文《Revisiting Square Root ORAM and Low Leakage Secure Boolean Queries》[84]。没有相关基础的同学，也可以先看一下Mariana Raykova在“The Alan Turing Institute”做的报告“Secure Computation with RAMs: Revisiting Square Root ORAM and Low Leakage Secure Boolean Queries”[64]，里面提到了一些生动的例子，可以帮助理解相关概念。&lt;/p&gt;&lt;h2&gt;4 基础学科推荐入门材料&lt;/h2&gt;&lt;p&gt;密码学是一门数学、计算机、通信领域的交叉学科。研究密码学，不可避免地要掌握这三个关联学科的基础知识。例如，密码学方案的构造离不开离散数学与抽象代数的应用；方案的安全性分析和计算复杂度分析要用到计算复杂度相关的知识；方案的实现需要一定的编程基础，如果仿真实现涉及到物联网、移动设备等特定的平台，则还需要一定的通信知识。&lt;/p&gt;&lt;p&gt;本章，我们尝试推荐一些基础学科的入门材料，主要为优质的公开课和教材。我们聚焦于离散数学与抽象代数、计算复杂性、编程基础这三门基础学科。它们是几乎所有密码学研究人员都需要了解和学习的领域。特定的密码学分支领域可能需要特定的入门知识。例如，隐私保护机器学习需要一定的机器学习基础知识；安全多方计算和同态加密需要一定的电路基础知识。由于能力有限，我们无法涵盖或逐一考察各个分支领域的入门材料。我们呼吁相关密码学研究人员可以分享出优质的入门材料。&lt;/p&gt;&lt;h3&gt;4.1 离散数学与抽象代数&lt;/h3&gt;&lt;p&gt;密码学的学习与研究离不开离散数学与抽象代数的知识。离散数学是抽象代数的基础，一般数学和计算机学院都会开设离散数学这门课程，但电子信息学院可能不会开设。进一步，可能只有数学学院会开设抽象代数课程，计算机学院和电子信息学院一般会开设编码理论。&lt;/p&gt;&lt;p&gt;如果需要学习离散数学，我们推荐阅读AT&amp;amp;T实验室Kenneth H. Rosen撰写的教材《Discrete Mathematics and Its Applications, Seventh Edition》[69]。这本教材已经由徐六通、杨娟、吴斌老师翻译并出版，教材名称为《离散数学及其应用，原书第7版》[70]。这是一本高中生都可以看懂的离散数学教材，里面包含了详尽的讲解、丰富的实例、大量的习题。屈婉玲、耿素云、张立昂老师所著的《离散数学（第2版）》也是相当优秀的教材[89]。教材的第3部分讲解了代数结构，第6部分讲解了初等数论，这两部分内容将对后续密码学数学基础的学习带来很大的帮助。在哔哩哔哩网站上可以找到屈婉玲老师讲解的“代数结构与组合数学”公开课视频[88]，相关评价非常正面。&lt;/p&gt;&lt;p&gt;与离散数学相比，抽象代数的学习就没有那么轻松了。我们推荐哈佛大学Benedict Gross教授的公开课“Abstract Algebra”[31]。Benedict Gross教授的讲解激情四射，引人入胜，唯一的遗憾就是他的课堂笔记实在有一些凌乱。可以在网络上找到这门课程的笔记，这可能会对学习有所帮助。&lt;/p&gt;&lt;blockquote&gt;在此课程的官方网站上无法找到课程笔记，需要访问归档网页&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//wayback.archive-it.org/3671/20150528171650/https%3A//www.extension.harvard.edu/open-learning-initiative/abstract-algebra&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;wayback.archive-it.org/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;3671/20150528171650/https://www.extension.harvard.edu/open-learning-initiative/abstract-algebra&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;下载。&lt;/blockquote&gt;&lt;p&gt;我们推荐的抽象代数教材为麻省理工学院Michael Artin撰写的《Algebra, Second Edition》[3]。这也是Benedict Gross教授的公开课所使用的教材。这本教材已经由姚海楼、平艳茹老师翻译并出版，教材名称为《代数（原书第2版）》[4]。由于补充抽象代数的时间节点不太相同，我们对于这本教材的评价有一些初入。总体来说，学习这本教材需要一定的离散数学或抽象代数背景知识，不是特别适合零基础入门。换句话说，这本教材所讲解的内容已经大大超出密码学研究所需的知识。如果需要一本离散数学和抽象代数的中间教材，可以阅读Joseph Silverman撰写的《Friendly Introduction to Number Theory (4th Edition)》[77]。从书名就可以看出这本教材相比于《Algebra, Second Edition》会更适合入门一些。这本教材的中文版本《数论概论，第四版》由孙志伟、吴克俭、卢青林、曹惠琴老师翻译[78]，豆瓣读书评分为9.2。这本书涵盖了初等数论直接用于密码学的所有部分，包含素数理论、费马小定理、二次剩余、椭圆曲线，可读性非常好。&lt;/p&gt;&lt;h3&gt;4.2 计算复杂性&lt;/h3&gt;&lt;p&gt;无论是方案的计算复杂性分析，还是密码学的安全理论，都需要用到计算复杂性的知识。理解计算复杂性的相关概念将对密码学的理解带来很大的帮助。&lt;/p&gt;&lt;p&gt;我们寻找了计算复杂性的相关公开课。经过对比，我们推荐来自卡耐基梅隆大学的Ryan O’Donnel教授的计算复杂性课程。Ryan O’Donnel教授分别为本科生开设了课程“Undergraduate Complexity Theory”[59]，为研究生开设了课程“Graduate Computational Complexity Theory”[58]。这两门课程最大的区别是：本科生课程不讲解概率多项式时间算法。由于密码学领域经常涉及这一概念，因此我们推荐直接学习研究生课程。当然，如果感觉难度比较大，也可以先学习本科生课程。可以在YouTube上找到课程的相关视频。在YouTube上还可以找到Ryan O’Donnel教授讲解的“Quantum Computation and Information”课程、以及“Analysis of Boolean Function”课程，如果需要也可以听一听。&lt;/p&gt;&lt;p&gt;我们推荐Ryan O’Donnel教授这两门公开课所使用的教材，分别是Michael Sipser撰写的《Introduction to the Theory of Computation，3rd Edition》[79]以及Sanjeev Arora和Boaz Barak撰写的《Computational Complexity: A Modern Approach》[1]。前一本教材的中文版本由段磊、唐常杰等老师翻译[80]，豆瓣读书评分为9.4。后一本教材的中文版本由骆吉州老师翻译[2]，豆瓣读书尚无评分。我们认为，《Computational Complexity: A Modern Approach》虽然足够优秀，但不太适合计算复杂性理论的初学者，其更像是一本专门为计算机复杂性理论研究人员撰写的专业教材。相比来说，《Introduction to the Theory of Computation，3rd Edition》更适合入门。可以配合北京大学刘田老师的视频课程“理论计算机科学基础”学习这本教材。在哔哩哔哩上可以观看相应的课程视频[86]。&lt;/p&gt;&lt;h3&gt;4.3 编程基础&lt;/h3&gt;&lt;p&gt;现在密码学领域越来越重视方案的具体实现，在论文中包含原型系统的实现并给出方案在实际环境下的执行情况，会为论文增光添彩。Ben Lynn在斯坦福大学攻读博士学位时的研究方向就是双线性群映射的实现。他撰写的双线性映射密码学函数库PBC Library代码简洁、文档详尽、是密码学函数库的经典实现范例之一[55]。目前在Visa研究院担任科学家的Peter Rindal聚焦于密码学和安全计算方案的实现。他的libOTe[66]和libPSI[67]密码学函数库已被广泛应用。但我们想强调的是，如果是简单地研究方案在通用平台上的性能，密码学方案的实现并不需要过于高深的编程能力。例如，如果阅读John Bethencourt、Amit Sahai、Brent Waters撰写的cpabe toolkit函数库，你会发现其代码的质量并没有想象得那么高。只要可以通过编程实现自己的方案就足够了。当然，密码学方案最佳编程实践也是密码学的一个分支研究领域，FSE和CHES这两个会议专门收录针对各种方案最佳编程实践的论文。&lt;/p&gt;&lt;p&gt;有关编程的学习，可以在知乎平台搜索到大量的意见和建议。从编程语言的入门角度，如果完全没有任何编程基础，我们推荐阅读“Head First”系列教材。这本教材使用大量的图画完成知识的讲解，使得知识的学习就像阅读漫画一般轻松。仅从编程语言角度，这一系列教材的中文版本已经推出了：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;《Head First Java》（豆瓣读书评分8.7）[76]；&lt;/li&gt;&lt;li&gt;《Head First Python》（豆瓣读书评分7.9）[5]；&lt;/li&gt;&lt;li&gt;《Head First HTML与CSS》（豆瓣读书评分9.3）[68]；&lt;/li&gt;&lt;li&gt;《Head First Servlets &amp;amp; JSP》（豆瓣读书评分8.8）[6]；&lt;/li&gt;&lt;li&gt;《Head First PHP &amp;amp; MySQL》（豆瓣读书评分8.5）[7]；&lt;/li&gt;&lt;li&gt;《Head First C》（豆瓣读书评分9.3）[30]；&lt;/li&gt;&lt;li&gt;《Head First HTML5 Programming》（豆瓣读书评分8.5）[24]。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过阅读“Head First”系列教材，可以在很短的时间内掌握编程语言的基本知识，达到快速上手的目的。&lt;/p&gt;&lt;p&gt;学习了编程语言的基本知识后，可能还需要掌握一定的数据结构与算法知识。我们只推荐一本教材，即Robert Sedgewick和Kevin Wayne撰写的《Algorithms, 4th Edition》[73]，中文版本由谢路云老师翻译[74]，豆瓣读书评分为9.3。这本书既讲解了Java编程语言的基础知识，又讲解了数据结构，同时深入浅出地讲解了计算机科学中的50个经典算法，包含了Java语言的完整实现。同时，两位作者还在Coursera上面开设了对应的公开课“Algorithms, Part I”和“Algorithms, Part II”。课程讲解非常清晰，编程题目还可以帮助纠正代码中存在的负面习惯。需要提醒的是，公开课中并不会介绍Java语言本身，因此在参加公开课前，最好阅读《Algorithms, 4th Edition》的第一章，快速学习Java编程语言。&lt;/p&gt;&lt;h2&gt;5 其它相关材料介绍&lt;/h2&gt;&lt;h3&gt;5.1 其它推荐材料&lt;/h3&gt;&lt;p&gt;前面的章节中，我们推荐了与密码学相关的公开课与教材。本节，我们列举其它一些或者有趣、或者对相应密码学领域有帮助的材料。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;《An Introduction to Mathematical Cryptography》，Jeffery Hoffstein、Jill Pipher、Joseph Silverman著[41]。第三位作者是前面章节提到的《数论概论，第四版》的作者。这本书用很容易理解的语言和实例讲解了各种用于解决因数分解和离散对数的算法。其中一部分算法可能在《现代密码学（第二版）》中看到过，但这本书里解释得更具体、更生动。这本书另外的一个亮点是，提供了格加密算法的清晰讲解和具体实例。&lt;/li&gt;&lt;li&gt;《Understanding Cryptography: A Textbook for Students and Practitioners》，Chirstof Paar、Jan Pelzl等著[61]。这是一本什么都讲，什么都没讲完的“系统性书籍”。这本书的优点是对于私钥加密部分的理论和实现讲得非常具体，把DES、AES、SHA-1都从里到外“拆开”看了。如果研究方向是分组密码、哈希函数、伪随机函数，或者是侧信道攻击（Side-Channel Attack），这本书将会成为入门必读书。对应的进阶书籍是Lars R. Knudesen和Matthew Robshaw的《The Block Cipher Companion》[48]。&lt;/li&gt;&lt;li&gt;“A Few Thoughts on Cryptographic Engineering”，Matthew Green[29]。著名密码学家Matthew Green的博客。他在博客中经常更新有关密码学的相关文章，尤其是当顶级会议出现了有趣的论文后，他会把一些想法放在博客中与读者们分享。如果教材、论文读累了，可以读一读他的博客，很有意思。我们比较推荐的几篇博客：（1）“Hash-based Signatures: An Illustrated Primer”。图文并茂地解释了基于哈希签名的原理和优点。（2）“Zero Knowledge Prrofs: An Illustrated Primer”。这篇文章分为两个部分，形象解释了交互式零知识证明的原理和安全性证明方法。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;5.2 建议入门后精读的材料&lt;/h3&gt;&lt;p&gt;有些材料写得浅显易懂、引人入胜，而有些材料主要面向专业研究人员，内容相对晦涩难懂。下面是一些我们建议入门后精读的学习材料。下列材料入选的标准仅仅是“阅读难度远超标题的字面意思”。请注意，这些材料非常优秀且通常无法替代，但需要读者具备一定的背景知识，或对此领域具有较深的理解后才能更好地阅读。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;《Foundations of Cryptography》，Oded Goldreich著[27]。这本书是Oded Goldreich撰写的重量级著作，分为两卷，第一卷讲解基础工具，第二卷讲解基础应用。这本书适合资深科研人员，概念密度很大，表述略显精简，需要一句一句精读。这本书是入门时学习的必备辅助材料，尤其研究安全多方计算，这本书是不可或缺的。举例来说，在完成某项翻译工作时，我们对安全多方计算协议中的两类攻击者：半诚实/被动/诚实但好奇（Semi-Honest / Passive / Honest-but-Curious）攻击者、恶意/主动（Active / Malicious）攻击者进行了讨论。最初我们认为这些名词并不等价。后续我们发现，《Foundations of Cryptography》第二册的第603页指出，半诚实/被动/诚实但好奇表达的是相同的意思，而恶意/主动表达的是相同的意思。磨刀不误砍柴功，所有想避开的困难问题，最后都需要回过头来返工。因此，如果想脚踏实地的夯实基础，我们强烈建议学习《Foundations of Cryptography》这本书，解决遇到的所有问题。&lt;/li&gt;&lt;li&gt;《The Algorithmic Foundations of Differential Privacy》，Cynthia Dwork、Aaron Roth著[22]。虽然是差分隐私提出者Cynthia Dwork研究员本人亲自撰写的书籍，书籍的描述非常严谨、准确，但这本书的阅读难度非常大。建议直接阅读相应技术的论文，当在相关公式、引理、定理等的推导过程中遇到困难时，再尝试从这本书找到答案。&lt;/li&gt;&lt;li&gt;《Universally Composable Security: A New Paradigm for Cryptographic Protocols》，Ran Canetti著[19][21]。只要研究密码学协议，就一定听说过广义可组合性（Universal Composition）。由于UC安全证明里涵盖环境（Environment）、参与方（Parties）、理想功能模块（Ideal Functionality，记为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BF%7D&quot; alt=&quot;\mathcal{F}&quot; eeimg=&quot;1&quot;/&gt; ）、仿真者（Simulator）和攻击者（Adversary）这5类实体，并使用了：（1）多带互动图灵机作为基本计算模型；（2）带有三个限定量词（Quantifier）的两个序列来定义安全性；（3）多重标识（sid、ssid、qid）来标记一个会话（session），导致协议安全定义和安全模型的使用都过于复杂。UC论文发表在2001年的计算机领域顶级会议FOCS上，而作者Ran Canetti即使在2018年12月仍然在修改这篇论文的完整版，也从侧面反映出这个模型的复杂程度。著名密码学家Matthew Green于2018年12月13日在推特上写到：“如果我必须在‘可组合安全’和‘把自己的脸拍在木头板上’这两者间选择一个，而前者要求我理解sid、ssid和函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BF%7D_%7B%5Ctext%7Bschmoo%7D%7D&quot; alt=&quot;\mathcal{F}_{\text{schmoo}}&quot; eeimg=&quot;1&quot;/&gt; ，我会选择后者。”&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;推特链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/matthew_d_green/status/1073319905741733888&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;twitter.com/matthew_d_g&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;reen/status/1073319905741733888&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;h2&gt;6 总结&lt;/h2&gt;&lt;p&gt;本文总结了经典的（公钥）密码学入门材料，初入密码学领域的研究人员可以参考给出的材料高效地学习密码学以及相关领域的知识，更快地度过入门阶段，投入到密码学的实际研究中。&lt;/p&gt;&lt;h2&gt;7 后记与致谢&lt;/h2&gt;&lt;p&gt;感谢卧村密码学报的编委会对本篇文章的大力支持。感谢@陈小胖老师为本篇文章提供支持和帮助。感谢知乎数学领域优秀回答者王希对文章中出现的数学词汇提供了翻译建议。&lt;/p&gt;&lt;p&gt;感谢编委会的匿名审稿专家们为本篇文章提出中肯而细致建议，并进一步推荐了高质量的教材与书籍，使这篇文章变得更加优秀。由于我们无法短时间内精读这些教材与书籍，因此无法针对它们给出恰当、准确的推荐意见。我们将这些推荐材料列举在此。&lt;/p&gt;&lt;p&gt;某位研究通用密码学协议的老师推荐阅读Carmit Hazay和Yehuda Lindell的书籍《Efficient Secure Two-Party Protocols》[40]。这本书虽然只讲解两方安全计算，但是内容中涵盖了多方安全计算协议的正明思想。换句话说，这本书以两方安全计算为例讲解多方安全计算协议。我们找到了Maria C. Onete在2013年为这本书撰写的评语[60]。评语中的章节“你是否会推荐这本书？”（Would you recommend this book?）中写到：“如果你对可证明安全和安全多方计算感兴趣，尤其如果你是一个刚开始接触密码学领域的学生，我强烈推荐你阅读这本书。这本书不仅介绍了相关主题的内容，更是尝试教授一种新的方法来学习和分析密码学方案，即通过形式化描述对方案进行论述，但又不局限于形式化描述中。自顶向下的论述方法使学习曲线变得平滑。前述章节所用的术语会被频繁提及，保证读者顺利掌握相关概念。然而，如果你只对最新的协议和两方计算协议的应用感兴趣，这本书就不适合你了。这本书的目的并不是总结已有的协议，而是一个为困惑于可证明安全技术的读者所撰写的教学材料。”&lt;/p&gt;&lt;p&gt;反之，如果只对最新的协议和安全多方计算应用感兴趣，推荐阅读David Evans、Vladimir Kolesnikov、Mike Rosulek撰写的书籍《A Pragmatic Introduction to Secure Multi-Party Computation》[23]。这本书于2018年10月出版，其目的就是介绍目前最新的安全多方计算协议和应用场景。这本书并不包含任何安全性证明，只有简单的安全性描述。目前我们正在翻译这本书籍。不久的将来，这本书籍的中文版本就会与读者见面。&lt;/p&gt;&lt;p&gt;某位从事密钥协商和密钥交换领域的老师推荐了Colin Boyd和Anish Mathuria的书籍《Protocols for Authentication and Key Establishment》[18]。从亚马逊官方网站用户“Plunkett”的评价看，希望学习或研究此领域的人员需要阅读此书籍。然而，这本书是2013年出版的，因此这本书无法覆盖最新的研究成果，可以作为参考资料阅读和学习。&lt;/p&gt;&lt;h2&gt;参考文献&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;Arora, S., Barak, B. Computational Complexity: A Modern Approach[M]. Cambridge University Press, 2009.&lt;/li&gt;&lt;li&gt;Arora, S.等著, 骆吉州译. 计算复杂性：现代方法[M]. 机械工业出版社, 2016.&lt;/li&gt;&lt;li&gt;Artin, M. Algebra (2nd edition)[M]. Pearson, 2010.&lt;/li&gt;&lt;li&gt;Artin, M.著, 姚海楼等译. 代数（原书第2版）[M]. 机械工业出版社, 2015.&lt;/li&gt;&lt;li&gt;Barry, P.著, 林琪等译. Head First Python（中文版）[M]. 中国电力出版社, 2012.&lt;/li&gt;&lt;li&gt;Basham, B.等著, 苏钰函等译. Head First Servlets &amp;amp; JSP（中文版）[M]. 中国电力出版社, 2006.&lt;/li&gt;&lt;li&gt;Beighley, L.等著, 苏金国等译. Head First PHP &amp;amp; MySQL（中文版）. 中国电力出版社, 2010.&lt;/li&gt;&lt;li&gt;Bellare, M., Pointcheval, D., Rogaway, P. Authenticated Key Exchange Secure against Dictionary Attacks[C]. EUROCRYPT 2000, Springer, 139-155.&lt;/li&gt;&lt;li&gt;Bethencourt, J., Sahai, A., Waters, B. Ciphertext-Policy Attribute-Based Encryption[EB/OL]. Advanced Crypto Software Collection, 2011. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//acsc.cs.utexas.edu/cpabe/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Advanced Crypto Software Collection&lt;/a&gt;. Access Date: 2019-03-21.&lt;/li&gt;&lt;li&gt;Boneh, D. Cryptography I[EB/OL]. Coursera, 2012. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.coursera.org/learn/crypto&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;coursera.org/learn/cryp&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;. Access Date: 2019-03-03.&lt;/li&gt;&lt;li&gt;Boneh, D. Cryptography II[EB/OL]. Coursera, 2012. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.coursera.org/learn/crypto2&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cryptography II | Coursera&lt;/a&gt;. Access Date: 2019-03-03.&lt;/li&gt;&lt;li&gt;Boneh, D., Boyen, X, Goh, E. J. Hierarchical Identity Based Encryption with Constant Size Ciphertext[C]. EUROCRYPT 2005, 440-456.&lt;/li&gt;&lt;li&gt;Boneh, D., Boyen, X. Short Signatures without Random Oracles and the SDH Assumption in Bilinear Groups[J]. Journal of Cryptology, 2008, 21(2): 149-177.&lt;/li&gt;&lt;li&gt;Boneh, D., Franklin, M. Identity-Based Encryption from the Weil Pairing[C]. CRYPTO 2001, Springer, 213-229.&lt;/li&gt;&lt;li&gt;Boneh, D., Lynn, B., Shacham, H. Short Signatures from the Weil Pairing[C]. ASIACRYPT 2001, Springer, 514–532.&lt;/li&gt;&lt;li&gt;Boneh, D., Lynn, B., Shacham, H. Short Signatures from the Weil Pairing[J]. Journal of cryptology, 2004, 17(4): 297-319.&lt;/li&gt;&lt;li&gt;Boneh, D., Shoup, V. A Graduate Crouse in Applied Cryptography[M]. Manuscript, 2017, &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//crypto.stanford.edu/~dabo/cryptobook/BonehShoup_0_4.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;crypto.stanford.edu/~da&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;bo/cryptobook/BonehShoup_0_4.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Boyd, C., Mathuria, A. Protocols for Authentication and Key Establishment[M]. Springer Science &amp;amp; Business Media, 2013.&lt;/li&gt;&lt;li&gt;Canetti, R. Universally Composable Security: A New Paradigm for Cryptographic Protocols[C]. FOCS 2001, IEEE Computer Society, 136.&lt;/li&gt;&lt;li&gt;Cramer, R., Shoup, V. A Practical Public Key Cryptosystem Provably Secure against Adaptive Chosen Ciphertext Attack[C], CRYPTO 1998, Springer, 13-25.&lt;/li&gt;&lt;li&gt;Canetti, R. Universally Composable Security: A New Paradigm for Cryptographic Protocols[J]. IACR Cryptology ePrint Archive, 2000, 2000:067.&lt;/li&gt;&lt;li&gt;Dwork, C., Roth, A. The Algorithmic Foundations of Differential Privacy[J]. Foundations and Trends in Theoretical Computer Science, 2014, 9(3–4): 211-407.&lt;/li&gt;&lt;li&gt;Evans, D., Kolesnikov, V., Rosulek, M. A Pragmatic Introduction to Secure Multi-Party Computation[J]. Foundations and Trends in Privacy and Security, 2018, 2(2-3): 70-246.&lt;/li&gt;&lt;li&gt;Freeman, E.等著, 林琪等译. Head First HTML 5 Programming（中文版）. 中国电力出版社, 2012.&lt;/li&gt;&lt;li&gt;Gentry, C. Fully Homomorphic Encryption Using Ideal Lattices[C]. STOC 2009, ACM, 9: 169-178.&lt;/li&gt;&lt;li&gt;Gentry, C. Practical Identity-Based Encryption without Random Oracles[C]. EUROCRYPT 2006, Springer, 445-464.&lt;/li&gt;&lt;li&gt;Goldreich, O. Foundations of Cryptography[M]. Cambridge University Press, 2009.&lt;/li&gt;&lt;li&gt;Goldreich, O., Ostrovsky, R. Software Protection and Simulation on Oblivious RAMs[J]. Journal of the ACM, 1996, 34(3): 431-473.&lt;/li&gt;&lt;li&gt;Green, M. A Few Thoughts on Cryptographic Engineering[EB/OL]. CryptographyEngineering, 2019. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.cryptographyengineering.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;blog.cryptographyengineering.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;. Access Date: 2019-03-21.&lt;/li&gt;&lt;li&gt;Griffiths, D.等著, 程亦超译. 嗨翻C语言[M]. 人民邮电出版社, 2013.&lt;/li&gt;&lt;li&gt;Gross, B. Abstract Algebra Open Learning Course[EB/OL]. Harvard University, 2014, &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.extension.harvard.edu/open-learning-initiative/abstract-algebra&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Abstract Algebra Open Learning Course&lt;/a&gt;. Access Date: 2019-03-03.&lt;/li&gt;&lt;li&gt;Guo, F., Susilo, W., Mu, Y. Introduction to Security Reduction[M]. Springer, 2018.&lt;/li&gt;&lt;li&gt;Hamer, G. The 1st BIU Winter School: Secure Computation and Efficiency[EB/OL]. Bar-Ilan University, 2016. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cyber.biu.ac.il/event/the-1st-biu-winter-school&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The 1st BIU Winter School&lt;/a&gt;. Access Date: 2019-03-02.&lt;/li&gt;&lt;li&gt;Hamer, G. The 2nd BIU Winter School: Lattice-Based Cryptography and Applications[EB/OL]. Bar-Ilan University, 2016. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cyber.biu.ac.il/event/the-2nd-biu-winter-school&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The 2nd BIU Winter School&lt;/a&gt;. Access Date: 2019-03-02.&lt;/li&gt;&lt;li&gt;Hamer, G. The 3rd BIU Winter School: Bilinear Pairings in Cryptography[EB/OL]. Bar-Ilan University, 2016. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cyber.biu.ac.il/event/the-3rd-biu-winter-school&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cyber.biu.ac.il/event/t&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;he-3rd-biu-winter-school&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;. Access Date: 2019-03-02.&lt;/li&gt;&lt;li&gt;Hamer, G. The 4th BIU Winter School: Symmetric Encryption in Theory and in Practice[EB/OL]. Bar-Ilan University, 2016. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cyber.biu.ac.il/event/the-4th-biu-winter-school&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The 4th BIU Winter School&lt;/a&gt;. Access Date: 2019-03-02.&lt;/li&gt;&lt;li&gt;Hamer, G. The 5th BIU Winter School: Advances in Practical Multiparty Computation[EB/OL]. Bar-Ilan University, 2016. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cyber.biu.ac.il/event/the-5th-biu-winter-school&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The 5th BIU Winter School&lt;/a&gt;. Access Date: 2019-03-02.&lt;/li&gt;&lt;li&gt;Hamer, G. The 6th BIU Winter School: Cryptography in the Cloud – Verifiable Computation and Special Encryption[EB/OL]. Bar-Ilan University, 2016. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cyber.biu.ac.il/event/the-6th-biu-winter-school&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The 6th BIU Winter School&lt;/a&gt;. Access Date: 2019-03-02.&lt;/li&gt;&lt;li&gt;Hamer, G. The 7th BIU Winter School on Cryptography: Differential Privacy: from Theory to Practice[EB/OL]. Bar-Ilan University, 2016. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cyber.biu.ac.il/event/the-7th-biu-winter-school&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The 7th BIU Winter School on Cryptography&lt;/a&gt;. Access Date: 2019-03-02.&lt;/li&gt;&lt;li&gt;Hazay, C., Lindell, Y. Efficient Secure Two-Party Protocols[M]. Springer, 2010.&lt;/li&gt;&lt;li&gt;Hoffstrein, J., Pipher, J., Silverman, J. An Introduction to Mathematical Cryptography, 2nd Edition[M]. Springer, 2014.&lt;/li&gt;&lt;li&gt;Homburger, Y. The 8th BIU Winter School on Cryptography: Secure Key Exchange[EB/OL]. Bar-Ilan University, 2017. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cyber.biu.ac.il/event/8th-biu-winter-school&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The 8th BIU Winter School on Cryptography&lt;/a&gt;. Access Date: 2019-03-02.&lt;/li&gt;&lt;li&gt;Jager, T., Kohlar, F., Schäge, S., Schwenk, J. On the Security of TLS-DHE in the Standard Model. CRYPTO 2012, Springer, 273-293.&lt;/li&gt;&lt;li&gt;Kairouz, P., Oh, S., Viswanath, P. The Composition Theorem for Differential Privacy[J]. IEEE Transactions on Information Theory, 2017, 63(6): 4037-4049.&lt;/li&gt;&lt;li&gt;Katz, J., Lindell, Y. Introduction to Modern Cryptography, 2nd Edition[M]. CRC Press, 2014.&lt;/li&gt;&lt;li&gt;Katz, J., Lindell, Y. Introduction to Modern Cryptography: Principles and Protocols[M]. CRC Press, 2007.&lt;/li&gt;&lt;li&gt;Katz, J.等著, 任伟译. 现代密码学：原理与协议. 国防工业出版社, 2012.&lt;/li&gt;&lt;li&gt;Knudsen, L. R., Robshaw, M. The Block Cipher Companion[M]. Springer, 2011.&lt;/li&gt;&lt;li&gt;Krolzig, N. The 9th BIU Winter School on Cryptography: Zero Knowledge[EB/OL]. Bar-Ilan University, 2018. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The 9th BIU Winter School on Cryptography&lt;/a&gt;. Access Date: 2019-03-02.&lt;/li&gt;&lt;li&gt;Lewko, A., Waters, B. New Techniques for Dual System Encryption and Fully Secure HIBE with Short Ciphertexts[C]. CRYPTO 2010, Springer, 455-479.&lt;/li&gt;&lt;li&gt;Li, N., Lyn, M., Su, D., Yang, W. Differential Privacy: from Theory to Practice[M]. Synthesis Lectures on Information Security, Privacy&amp;amp; Trust, 8(4): 1-138.&lt;/li&gt;&lt;li&gt;Li, N., Qardaji, W., Su, D., et al. Membership Privacy: A Unifying Framework for Privacy Definitions[C]. CCS 2013 ACM, 889-900.&lt;/li&gt;&lt;li&gt;Lindell, Y. How to Simulate It – A Tutorial on the Simulation Proof Technique[M]. Tutorials on the Foundations of Cryptography. Springer, Cham, 2017: 277-346.&lt;/li&gt;&lt;li&gt;Lindell, Y. Tutorials on the Foundations of Cryptography: Dedicated to Oded Goldreich[M]. Springer, 2017.&lt;/li&gt;&lt;li&gt;Lynn, B. PBC Library: The Pairing-Based Cryptography Library[EB/OL]. Standford University, 2013. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//crypto.stanford.edu/pbc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PBC Library - Pairing-Based Cryptography - About&lt;/a&gt;. Access Date: 2019-03-21.&lt;/li&gt;&lt;li&gt;Lyubashevsky, V., Peikert, C., Regev, O. On Ideal Lattices and Learning With Errors over Rings[J]. Journal of the ACM (JACM), 2013, 60(6): 43.&lt;/li&gt;&lt;li&gt;McSherry, F., Talwar, K. Mechanism Design via Differential Privacy[C]. FOCS 2007, IEEE, 94-103.&lt;/li&gt;&lt;li&gt;O’Donnell, R. Graduate Computational Complexity Theory[EB/OL]. Carnegie Mellon University, 2017. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.cmu.edu/~odonnell/complexity17&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;15-855: Graduate Computational Complexity Theory, Fall 2017&lt;/a&gt;. Access Date: 2019-03-03.&lt;/li&gt;&lt;li&gt;O’Donnell, R. Undergraduate Complexity Theory[EB/OL]. Carnegie Mellon University, 2017. &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.cmu.edu/~odonnell/15455-s17&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;15-455: Undergraduate Complexity Theory, Spring 2017&lt;/a&gt;. Access Date: 2019-03-03.&lt;/li&gt;&lt;li&gt;Onete, M. C. Review of the Book “Efficient Secure Two-Party Protocols” by Carmit Hazay, Yehuda Lindell, Springer, 2010[EB/OL]. IACR ePrint Archive, 2013. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.iacr.org/books/2013_sp_HazayLindell_Two-Party.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;iacr.org/books/2013_sp_&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;HazayLindell_Two-Party.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;. Access Date: 2019-03-27.&lt;/li&gt;&lt;li&gt;Paar, C., Pelzl, J. Understanding Cryptography: A Textbook for Students and Practitioners[M]. Springer, 2010.&lt;/li&gt;&lt;li&gt;Peikert, C., Shiehian, S. Noninteractive Zero Knowledge for NP from (Plain) Learning With Errors[J]. IACR Cryptology ePrint Archive, 2019, 2019:158.&lt;/li&gt;&lt;li&gt;Peikert, C., Waters, B. Lossy Trapdoor Functions and Their Applications[J]. SIAM Journal on Computing, 2011, 40(6): 1803-1844.&lt;/li&gt;&lt;li&gt;Raykova, M. Secure Computation with RAMs: Revisiting Square Root ORAM and Low Leakage Secure Boolean Queries[EB/OL]. YouTube, 2017. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3D8EmFRbZAElM&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=8EmFRbZAElM&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;. Access Date: 2019-03-23.&lt;/li&gt;&lt;li&gt;Regev, O. On Lattices, Learning With Errors, Random Linear Codes, and Cryptography[J]. Journal of the ACM (JACM), 2009, 56(6): 34.&lt;/li&gt;&lt;li&gt;Rindal, P. LibOTe: A Fast, Portable, and Easy to Use Oblivious Transfer Library[EB/OL]. GitHub, 2019. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/osu-crypto/libOTe&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;osu-crypto/libOTe&lt;/a&gt;. Access Date: 2019-03-21.&lt;/li&gt;&lt;li&gt;Rindal, P. LibPSI: A Repository for Private Set Intersection[EB/OL]. GitHub, 2019. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/osu-crypto/libPSI&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;osu-crypto/libPSI&lt;/a&gt;. Access Date: 2019-03-21.&lt;/li&gt;&lt;li&gt;Robson, E.等著, 徐阳等译. Head First HTML与CSS（第2版）. 中国电力出版社, 2013.&lt;/li&gt;&lt;li&gt;Rosen, K. H. Discrete Mathematics and Its Applications[M]. McGraw-Hill Education, 2011.&lt;/li&gt;&lt;li&gt;Rosen, K. H.著, 徐六通等译. 离散数学及其应用（原书第7版）[M]. 机械工业出版社, 2015.&lt;/li&gt;&lt;li&gt;Sedgewick, R., Wayne, K. Algorithm, Part I[EB/OL]. Coursera, 2013. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.coursera.org/learn/algorithms-part1&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;coursera.org/learn/algo&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;rithms-part1&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;. Access Date: 2019-03-21.&lt;/li&gt;&lt;li&gt;Sedgewick, R., Wayne, K. Algorithm, Part II[EB/OL]. Coursera, 2013. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.coursera.org/learn/algorithms-part2&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;coursera.org/learn/algo&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;rithms-part2&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;. Access Date: 2019-03-21.&lt;/li&gt;&lt;li&gt;Sedgewick, R., Wayne, K. Algorithms (4th Edition)[M]. Addison-Wesley Professional, 2011.&lt;/li&gt;&lt;li&gt;Sedgewick, R.等著, 谢路云译. 算法（第四版）[M]. 人民邮电出版社, 2012.&lt;/li&gt;&lt;li&gt;Shoup, V. Sequences of Games: A Tool for Taming Complexity in Security Proofs[J]. IACR Cryptology ePrint Archive, 2004, 2004: 332.&lt;/li&gt;&lt;li&gt;Sierra, K.等著, 杨尊一译. Head first Java（第二版•中文版）[M]. 中国电力出版社, 2007.&lt;/li&gt;&lt;li&gt;Silverman, J. Friendly Introduction to Number Theory (4th Edition)[M]. Pearson, 2014.&lt;/li&gt;&lt;li&gt;Silverman, J.著, 孙志伟等译. 数论概论（原书第4版）[M]. 机械工业出版社, 2016.&lt;/li&gt;&lt;li&gt;Sipser, M. Introduction to the Theory of Computation, 3rd Edition[M]. Cengage Learning, 2012.&lt;/li&gt;&lt;li&gt;Siper, M.著, 唐常杰等译. 计算理论导引（原书第三版）[M]. 机械工业出版社, 2015.&lt;/li&gt;&lt;li&gt;Stefanov, E., van Dijk, M., Shi, E., et al. Path ORAM: An Extremely Simple Oblivious RAM Protocol[C]. CCS 2013, ACM, 299-310.&lt;/li&gt;&lt;li&gt;Wang, T., Blocki, J., Li, N., et al. Locally Differentially Private Protocols for Frequency Estimation[C]. USENIX Security 2017, USENIX, 729-745.&lt;/li&gt;&lt;li&gt;Waters, B. Efficient Identity-Based Encryption without Random Oracles[C]. EUROCRYPT 2005, Springer, 114-127.&lt;/li&gt;&lt;li&gt;Zahur, S., Wang, X., Raykova, M., et al. Revisiting Square-Root ORAM: Efficient Random Access in Multi-Party Computation[C]. S &amp;amp; P 2016, IEEE, 218-234.&lt;/li&gt;&lt;li&gt;郭福春. 致我公钥密码研究生的一封信[J]. 卧村密码学报, 第1期, 2019.&lt;/li&gt;&lt;li&gt;刘田. 理论计算机科学基础[EB/OL]. 哔哩哔哩, 2017. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av17253679/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av17&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;253679/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;. Access Date: 2019-12-14.&lt;/li&gt;&lt;li&gt;刘巍然, Scalers听力狂练小组. 世界上最顶级的密码学课程[EB/OL]. i春秋, 2015. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.ichunqiu.com/course/50433&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;基于密码学中格的基础知识相关介绍_视频教程_i春秋_培育信息时代的安全感！&lt;/a&gt;. Access Date: 2019-03-03.&lt;/li&gt;&lt;li&gt;屈婉玲. 代数结构与组合数学[EB/OL]. 哔哩哔哩, 2017. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av9536834&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av95&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;36834&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;. Access Date: 2019-03-25.&lt;/li&gt;&lt;li&gt;屈婉玲, 耿素云, 张立昂. 离散数学（第2版）[M]. 高等教育出版社, 2015.&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;附录A：推荐公开课汇总&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-77e0847aa6066d4d4bacd306387481cc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1085&quot; data-rawheight=&quot;414&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1085&quot; data-original=&quot;https://pic1.zhimg.com/v2-77e0847aa6066d4d4bacd306387481cc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-77e0847aa6066d4d4bacd306387481cc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1085&quot; data-rawheight=&quot;414&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1085&quot; data-original=&quot;https://pic1.zhimg.com/v2-77e0847aa6066d4d4bacd306387481cc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-77e0847aa6066d4d4bacd306387481cc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;附录B：推荐教材与书籍汇总&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a740f6ef6cc1903fdf4eecfd10f8ee2a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;685&quot; data-rawheight=&quot;871&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;685&quot; data-original=&quot;https://pic3.zhimg.com/v2-a740f6ef6cc1903fdf4eecfd10f8ee2a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a740f6ef6cc1903fdf4eecfd10f8ee2a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;685&quot; data-rawheight=&quot;871&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;685&quot; data-original=&quot;https://pic3.zhimg.com/v2-a740f6ef6cc1903fdf4eecfd10f8ee2a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-a740f6ef6cc1903fdf4eecfd10f8ee2a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-03-30-60604123</guid>
<pubDate>Sat, 30 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>安全机器学习：可扩展隐私保护机器学习系统</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-01-05-54108699.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/54108699&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d93ddfcf2db7be0818d187a604cfada4_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;引言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这次为各位知友带来的视频是Yupeng Zhang在2017年信息安全旗舰会议《Security &amp;amp; Privacy》上的论文演讲，论文的题目是《安全机器学习：可扩展隐私保护机器学习系统》（SecureML: A System for Scalable Privacy-Preserving Machine Learning）。&lt;/p&gt;&lt;p&gt;这篇论文是数据安全技术领域的一位好朋友向我推荐。他建议我仔细阅读论文，有相关想法就一起讨论。可惜的是，目前我的日常工作和前沿数据安全技术关系比较小，因此论文阅读的进度比较慢。在浏览了讲座视频后，我初步感觉应用安全多方计算（Secure Multi-Party Computation，SMPC）技术解决数据流转，特别是B2B场景下的数据流转，是未来一个非常重要、也是值得深挖的方向。因此，我先把视频听译并分享出来，希望有更多的知友了解到这个领域。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;视频与论文链接&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;之前发布视频时，我会截取视频中比较重要的段落，并在专栏中会为每个截图撰写一段简介。但我发现这个过程其实意义不大。一方面，仅读简介是无法了解到具体细节的，有必要仔细浏览视频，或者阅读原始论文。另一方面，简介本身实际上是视频翻译稿的整理，而发布的视频已经包含了全部的翻译稿内容。&lt;/p&gt;&lt;p&gt;为此，我这次提供一些我认为可以帮助理解视频内容的资料，感兴趣的知友可以详细阅读。同时，我会直接提供视频中重要内容的截图，也帮助知友快速判断此视频内容是否值得观看和研究。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;论文链接：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//eprint.iacr.org/2017/396&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cryptology ePrint Archive: Report 2017/396&lt;/a&gt;&lt;/li&gt;&lt;li&gt;视频链接：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DCQxwdqzlgWI&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SecureML: A System for Scalable Privacy-Preserving Machine Learning&lt;/a&gt;&lt;/li&gt;&lt;li&gt;解释论文工作更全面的PPT：&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//legacydirs.umiacs.umd.edu/%7Ezhangyp/presentations/SecureML.pptx&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;legacydirs.umiacs.umd.edu&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/~zhangyp/presentations/SecureML.pptx&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;背景知识：安全多方计算及其问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;安全多方计算要研究的问题是：在无可信第三方的情况下，多个参与方如何安全地计算一个约定函数的输出结果。以安全多方计算提出者姚期智院士的百万富翁问题为例：有两个百万富翁Alice和Bob，他们相对比一下互相之间谁的资产更多，但又不想向对方透露自己的资产数额。在这个场景下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;百万富翁Alice的输入为Alice的资产量A。&lt;/li&gt;&lt;li&gt;百万富翁Bob的输入为Bob的资产量B。&lt;/li&gt;&lt;li&gt;约定的函数为：如果A&amp;gt;B，返回1，如果A&amp;lt;B，返回-1，否则返回0。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在完成计算后，Alice（Bob）获得了约定函数的计算结果，但无法得知B（或者A）的具体值。&lt;/p&gt;&lt;p&gt;在当前互联网场景下，各个公司都拥有海量的数据，但是尚不能完成数据之间的安全流转。安全多方计算协议的应用很可能解决此类问题，各公司在不对外明确提供数据的条件下，与其它公司共同完成数据计算，从而得到更好的数据计算结果。&lt;/p&gt;&lt;p&gt;目前，密码学家已经提出了多个实现任意函数的安全多方计算协议。从理论上讲，给定任意一个函数，我们都可以构造一个安全多方计算协议。然而，目前提出的安全多方协议有如下几个尚未解决的问题：（1）实现比较复杂的计算任务时效率较低（如实现高次多项式求值）；（2）安全多方计算协议会引入比较大的通信开销。目前来看，通用优化方案寻找起来相对比较困难。但在特定的计算场景下，是否可以找到比较好的优化方案，是一个非常有意思的研究领域。&lt;/p&gt;&lt;p&gt;本论文就在特定计算场景下实现了安全多方计算的优化。针对线性回归、逻辑回归、神经网络训练问题，本论文给出了优化方案，并通过理论证明和实际验证说明了方案的可行性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;视频翻译&lt;/b&gt;&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1064879902632771584&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;第一部分：背景知识，线性回归&quot; data-poster=&quot;https://pic4.zhimg.com/80/v2-0bbf86361540528d5a08bc7eaafc8c17_b.jpg&quot; data-lens-id=&quot;1064879902632771584&quot;&gt;              &lt;img class=&quot;thumbnail&quot; src=&quot;https://pic4.zhimg.com/80/v2-0bbf86361540528d5a08bc7eaafc8c17_b.jpg&quot;&gt;              &lt;span class=&quot;content&quot;&gt;                &lt;span class=&quot;title&quot;&gt;第一部分：背景知识，线性回归&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;                &lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1064879902632771584&lt;/span&gt;              &lt;/span&gt;            &lt;/a&gt;            &lt;a class=&quot;video-box&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1064879985323651072&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;第二部分：逻辑回归，实验结果&quot; data-poster=&quot;https://pic2.zhimg.com/80/v2-b94f6d4dbf255ff86898bb81cb41e839_b.jpg&quot; data-lens-id=&quot;1064879985323651072&quot;&gt;              &lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/80/v2-b94f6d4dbf255ff86898bb81cb41e839_b.jpg&quot;&gt;              &lt;span class=&quot;content&quot;&gt;                &lt;span class=&quot;title&quot;&gt;第二部分：逻辑回归，实验结果&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;                &lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1064879985323651072&lt;/span&gt;              &lt;/span&gt;            &lt;/a&gt;            &lt;h2&gt;&lt;b&gt;主要截图&lt;/b&gt;&lt;/h2&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fcb47c9cb097b389471105f4e1874e58_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-fcb47c9cb097b389471105f4e1874e58_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fcb47c9cb097b389471105f4e1874e58_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-fcb47c9cb097b389471105f4e1874e58_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fcb47c9cb097b389471105f4e1874e58_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f64e56cb0bfdbc46465072275fd87b6b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-f64e56cb0bfdbc46465072275fd87b6b_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f64e56cb0bfdbc46465072275fd87b6b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-f64e56cb0bfdbc46465072275fd87b6b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f64e56cb0bfdbc46465072275fd87b6b_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-89f2c1bc75fe2cb2d0f0d5a534f5330c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-89f2c1bc75fe2cb2d0f0d5a534f5330c_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-89f2c1bc75fe2cb2d0f0d5a534f5330c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-89f2c1bc75fe2cb2d0f0d5a534f5330c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-89f2c1bc75fe2cb2d0f0d5a534f5330c_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a92718717e2c34b3f8640c95f8eae6ac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-a92718717e2c34b3f8640c95f8eae6ac_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a92718717e2c34b3f8640c95f8eae6ac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-a92718717e2c34b3f8640c95f8eae6ac_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a92718717e2c34b3f8640c95f8eae6ac_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b5293b4413449cd168b8dbbc5a4cb2b3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b5293b4413449cd168b8dbbc5a4cb2b3_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b5293b4413449cd168b8dbbc5a4cb2b3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b5293b4413449cd168b8dbbc5a4cb2b3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b5293b4413449cd168b8dbbc5a4cb2b3_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0a66d52d8cd43d4a98545556cf545f37_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-0a66d52d8cd43d4a98545556cf545f37_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0a66d52d8cd43d4a98545556cf545f37_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-0a66d52d8cd43d4a98545556cf545f37_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0a66d52d8cd43d4a98545556cf545f37_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-faa2bc5c5734ba05a218289b1f401c77_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-faa2bc5c5734ba05a218289b1f401c77_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-faa2bc5c5734ba05a218289b1f401c77_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-faa2bc5c5734ba05a218289b1f401c77_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-faa2bc5c5734ba05a218289b1f401c77_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d0dff1c045d504d7760097160acf63fc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-d0dff1c045d504d7760097160acf63fc_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d0dff1c045d504d7760097160acf63fc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-d0dff1c045d504d7760097160acf63fc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d0dff1c045d504d7760097160acf63fc_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4deea992def251b951fb6f83cadb02da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-4deea992def251b951fb6f83cadb02da_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4deea992def251b951fb6f83cadb02da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-4deea992def251b951fb6f83cadb02da_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4deea992def251b951fb6f83cadb02da_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-373450e157271cf4af6f9b1694639e73_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-373450e157271cf4af6f9b1694639e73_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-373450e157271cf4af6f9b1694639e73_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-373450e157271cf4af6f9b1694639e73_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-373450e157271cf4af6f9b1694639e73_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-01-05-54108699</guid>
<pubDate>Sat, 05 Jan 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>工作量证明区块链系统的安全性与可用性讨论</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2018-11-13-49494558.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49494558&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d1052fe2de5f4f35365976c6851db443_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;引言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;现在工作是越来越繁忙了，听译视频的频率降得越来越低。为了尽可能跟上最新的研究进展，还是有必要坚持听译的。今天为大家带来的是来自密码学顶级会议CCS 2016的演讲视频《工作量证明区块链系统的安全性与可用性讨论》（On the Security and Performance of Proof ow Work Blockchains）。&lt;/p&gt;&lt;p&gt;如果对比特币和区块链技术有深入了解，就会发现比特币和区块链技术更多地涉及到了经济学和博弈论的相关知识。我们来看几个简单的例子：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;比特币可以遭受51%算力攻击（51% Attack）。然而，如果攻击者真的发起51%攻击，虽然它可以篡改交易信息、获得大量的比特币，但这也要付出大量的算力成本。更重要的是，比特币账本的篡改很可能会导致人们对比特币系统丧失信心，使得比特币价格大跌，反而让攻击者遭受更大的损失。因此，虽然51%攻击理论上是可行的，但由于比特币已经牵涉到巨大的算力投入，实施51%攻击从经济角度讲是一件吃力不讨好的事情。&lt;/li&gt;&lt;li&gt;公链系统还可以遭受自私挖矿攻击（Selfish Mining Attack）。这是Eyal和Sirer在密码学著名会议Financial Cryptography 2014上提出的一种攻击方法。其基本思想是：攻击者在成功挖到一个区块后可以暂时不公开此区块，而是默默地在这个区块上挖下一个区块。当其它诚实节点挖到了这个区块后，攻击者再把自己挖到的这个区块公开出去。这样做的好处在于，攻击者由于先挖到了区块，他可以优先在这个区块之后继续挖矿，而诚实节点会把算力浪费在已经有下一个区块的区块上。这么做看似可行，但攻击者也有很大的风险：如果攻击者区块发布的速度不够快，全网可能会很快接受诚实节点挖到的区块，攻击者就会蒙受巨大的损失，还不如早早公开挖到的区块为妙。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为此，衡量区块链是否安全，不应该只从密码学或者协议的角度去分析，更应该把博弈论的思想引入其中，通过衡量攻击者的行为是否对自己最有利来判断区块链系统的安全性。而这正是本次视频的核心思想。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;视频翻译&lt;/b&gt;&lt;/h2&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic2.zhimg.com/80/v2-c64a120bcab8cb9d6fc8db0e11c2e771_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/1045465487869313024&quot; data-name=&quot;第一部分：定义、核心思想&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;1045465487869313024&quot;&gt;&lt;/video&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic4.zhimg.com/80/v2-62875d2219f934f2740d21951b5f9a3b_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/1045465605104279552&quot; data-name=&quot;第二部分：主要贡献、主要结论&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;1045465605104279552&quot;&gt;&lt;/video&gt;&lt;h2&gt;&lt;b&gt;内容简介&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a53d783842bf4f45722aa3359fe99993_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a53d783842bf4f45722aa3359fe99993&quot; data-watermark-src=&quot;v2-1a46bc951e30ec61c830619e9cddfa1e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;要说区块链系统最大的问题就是交易吞吐量不足了。一般用系统所能支持的每秒交易量（Transactions per Second，TPS）衡量交易吞吐量。而影响交易吞吐量的核心参数有两个：（1）区块生成时间（Block Generation Time），即平均每隔多长时间可以生成一个区块；（2）区块大小（Block Size），侧面表示每隔区块所能容纳的交易数量。例如，比特币的区块生成时间为10分钟，区块大小为1MB，而比特币的每个交易所需要消耗的存储量大约为0.25KB，因此比特币的TPS为1000KB/0.25KB/60s=6.67。以太坊的区块生成时间大约为15秒，虽然以太坊没有规定每个区块的大小限制，但是由于区块越大，区块在网络中的传播速度越慢，因此以太坊实际的TPS约为20。从定性角度讲，我们可以很直观地得到下面的结论：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;区块生成时间越短，出块速度越快，交易速度也就越快&lt;/li&gt;&lt;li&gt;区块大小越大，每个区块所能容纳的交易量越大，交易速度也会变快&lt;/li&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1e0060514cb3821e92acce2cb2d7519c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1e0060514cb3821e92acce2cb2d7519c&quot; data-watermark-src=&quot;v2-fd29f89e43c5c0b69546651f3d33466d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;如果区块链系统的点对点（Peer-to-Peer，P2P）网络没有网络延迟，所有区块都可以瞬间同步给全网所有节点，我们就可以把区块生成时间设置得足够小，区块大小设置得足够大，使得区块链系统支持任意高的交易吞吐量。但是，由于网络延迟的存在，全网所有节点并不总能很快地获得最新的区块信息，这就会导致竞争区块的出现。当全网挖出了两个区块时，两个区块就需要根据规则进行竞争，最终只有一个区块会胜出，而另一个区块将被废弃，成为废区块（Stale Block）此区块关联的算力也就被浪费了。&lt;/p&gt;&lt;p&gt;不仅是算力浪费的问题，竞争区块是区块链出现各种共识协议攻击的核心原因。正是由于竞争区块的存在，只要攻击者可以在篡改交易时确保被篡改交易所关联的区块可以竞争成为合法区块，攻击就可以成功。这就引入了区块链中针对共识协议的经典攻击：自私挖矿攻击，双花攻击（Double Spending Attack）。&lt;/p&gt;&lt;p&gt;直观来看，区块成为废区块的比率，即废块率（Stale Block Rate）越高，区块链遭受攻击的概率也就越高。实际测试表明，比特币的废块率约为0.4%（感谢比特币极慢的出块时间和严格的区块大小限制）；以太坊的废块率约为6.8%（但由于以太坊中有叔区块的概念，因此虽然区块率被废弃，但关联的算力仍然起作用）；狗币的废块率是0.6%，莱特币的废块率是0.3%。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e8b52cc661e510ebbafbc43ef5a14978_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e8b52cc661e510ebbafbc43ef5a14978&quot; data-watermark-src=&quot;v2-ca07af6b5dac92bccd750be6d6893acb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;有了这样的结论，区块链系统设计者们就要做出权衡了：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;提高区块生成时间、增加区块大小，则交易吞吐量会显著提高，但区块链的安全性就会降低。&lt;/li&gt;&lt;li&gt;反之，降低区块生成时间、减小区块大小，交易吞吐量就会降低，但区块链安全性会提高。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们要解决的问题是：不同的区块链系统会设置不同的参数，参与节点数量、算力分布、出块时间、区块大小、乃至攻击者所拥有的算力都不一样，如何横向对比各个区块链系统的安全性，从而选择最优的参数呢？&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4649ef2b4090c05bcbdc42d2a30f454f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4649ef2b4090c05bcbdc42d2a30f454f&quot; data-watermark-src=&quot;v2-d0cb5878c8b58a5669b43ba167d16fe8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;本视频对应的论文的主要贡献为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;提出了一种量化衡量指标，可以客观分析工作量证明区块链系统在抵御双花攻击、自私挖矿攻击方面的能力。&lt;/li&gt;&lt;li&gt;设计并实现了一个区块链仿真器，可以仿真区块链系统的各个参数，得到对应的废块率，从而帮助衡量区块链系统的安全性。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这一工作可以得到很多有意思的结果，例如：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可以把比特币的出块时间从10分钟提高到1分钟，使得比特币的TPS从6.67提高到66.7，同时不会牺牲比特币的安全性。&lt;/li&gt;&lt;li&gt;37个以太坊的区块确认量等价于6个比特币的区块确认量。考虑到以太坊的出块时间为15秒，而比特币的出块时间为10分钟，因此当交易被以太坊区块确认后，只需等待大约10分钟，其交易的安全性就等价于比特币等待60分钟的安全性。&lt;/li&gt;&lt;li&gt;自私挖矿攻击不一定是一个理智行为。在特定的场景下，与其实施自私挖矿，不如诚实挖矿的收益大。&lt;/li&gt;&lt;li&gt;区块挖矿回报率越高（用代币所具有的实际价格衡量），则区块链系统本身的安全性也会越高。&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bc328c0c439adaee5a7c403e562b68a6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bc328c0c439adaee5a7c403e562b68a6&quot; data-watermark-src=&quot;v2-02b47c974c93e35cd7f49f0d0c69e00b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;系统主要有2部分组成：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;区块链仿真器，可以配置相应的参数实现区块链系统的仿真，得到废块率。支持设置的参数有：区块生成时间、各节点算力分布情况、区块大小、各节点的地理位置（即节点之间的网络延时）、节点维护的TCP连接数量（即各节点的网络吞吐量）、区块传播协议等。&lt;/li&gt;&lt;li&gt;安全模型，可以得到相应的安全量化指标。支持设置的参数有：攻击者所拥有的算力、攻击者的网络连接情况、攻击者分隔全网算力的能力（即日蚀攻击，参见我之间分享的视频：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/42446193&quot;&gt;比特币点对点网络中的日蚀攻击&lt;/a&gt;）、全网默认交易的确认次数。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过对比量化指标，我们就能横向对比各个区块链系统的安全性了。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f815477132fe0f01f8fa85f76dd57d83_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f815477132fe0f01f8fa85f76dd57d83&quot; data-watermark-src=&quot;v2-8b2f70fa5bc7a06389ae6a07ca0b70a6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;论文作者们将区块链仿真器开源，感兴趣的知友们可以下载下来试一试。下载链接在上图中，不过应知友们的要求，我还是把链接写在文章里面的好：&lt;a href=&quot;http://arthurgervais.github.io/Bitcoin-Simulator/index.html&quot;&gt;Bitcoin Simulator&lt;/a&gt;。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2018-11-13-49494558</guid>
<pubDate>Tue, 13 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>数字货币的30年发展史</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2018-09-19-44868083.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44868083&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fdce2228af36e630e223f002513c11f8_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;引言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这周处于无业游民状态，刚好可以为知友们带来新的数据安全技术视频了。今天为大家带来的是一个邀请演讲。著名密码学家Matthew Green接受了国际旗舰密码学会议EUROCRYPT 2018组委会的邀请，在会议上给出一个题目为《数字货币的30年发展史——从电子现金到区块链》（Thirty Years of Digital Currency: From DigiCash to the Blockchain）的演讲。&lt;/p&gt;&lt;p&gt;Matthew Green是何方神圣？如果熟悉数字货币的知友们可能会知道，Matthew Green是两个著名密码货币“零币”（ZCoin）和“零现金”（ZCash）的提出者，也是零现金项目的科学家之一。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cdfc6d20be136b11a5a0d005ca027c15_r.jpg&quot; data-caption=&quot;从ZCoin的官方网站上可以看到，Matthew Green是ZCoin理论论文的作者之一&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1658&quot; data-rawheight=&quot;949&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cdfc6d20be136b11a5a0d005ca027c15&quot; data-watermark-src=&quot;v2-6d11e4d3baf903b354e0fb4b30728576&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-151df921e6380f016135be60e411e5ee_r.jpg&quot; data-caption=&quot;从ZCash的官方网站上可以看到，Matthew Green是ZCash团队的科学家&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1660&quot; data-rawheight=&quot;951&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-151df921e6380f016135be60e411e5ee&quot; data-watermark-src=&quot;v2-f7fab90673c2b717a4ebff472304785c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;如此重量级嘉宾的演讲，我们自然需要好好学习一下。遗憾的是，Green在演讲中给出的很多观点都是负面的。不过，如果你是一个密码学、安全协议的研究者，在深入了解区块链相关技术后，可能你也会隐隐约约地看到区块链辉煌的背后所隐藏的一些危机。这次，我也希望借着Green的这次邀请演讲，呼吁知友们冷静看待区块链技术。区块链虽好，但它不是万能的。&lt;/p&gt;&lt;p&gt;此次听译工作也是困难重重。观看视频就会知道，视频的音频原声质量比较低，经常出现爆音、电流音等情况，很影响正常的听译工作。因此，如果视频中有听译错误的地方，还请知友们见谅。本次视频的听译非常感谢@橙皮书（专栏链接：&lt;a href=&quot;https://zhuanlan.zhihu.com/orangepaper&quot;&gt;橙皮书&lt;/a&gt;）团队的大力支持。上一篇专栏文章中，我曾提到“Nervos创始人Jan的采访是由橙皮书团队完成并原创的”。此次@橙皮书团队为视频的听写和校对工作带来了较大的帮助，特为团队点赞！&lt;/p&gt;&lt;p&gt;Matthew Green的演讲视频内容比较多也比较杂，因此这篇专栏文章就不对视频进行简单的介绍了（因为简单的介绍就意味着要把视频完全复述一遍）。如果没有时间观看视频，感兴趣的知友可以直接查看Matthew Green的邀请视频演讲PPT，链接为：&lt;a href=&quot;https://eurocrypt.iacr.org/2018/Slides/Wednesday/InvitedTalk.pdf&quot;&gt;https://eurocrypt.iacr.org/2018/Slides/Wednesday/InvitedTalk.pdf&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;相关信息&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;演讲视频链接：&lt;a href=&quot;https://www.youtube.com/watch?v=FaakN6MK6mc&quot;&gt;https://www.youtube.com/watch?v=FaakN6MK6mc&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;演讲PPT链接：&lt;a href=&quot;https://eurocrypt.iacr.org/2018/Slides/Wednesday/InvitedTalk.pdf&quot;&gt;https://eurocrypt.iacr.org/2018/Slides/Wednesday/InvitedTalk.pdf&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;视频翻译&lt;/b&gt;&lt;/h2&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic3.zhimg.com/80/v2-11e35870812561f76d9be8675e57b1e6_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/1025547721662492672&quot; data-name=&quot;数字货币30年发展史——第一部分&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;1025547721662492672&quot;&gt;&lt;/video&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic3.zhimg.com/80/v2-d830d030f4d3c6735161e6c7aad2165e_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/1025549108853014528&quot; data-name=&quot;数字货币30年发展史——第二部分&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;1025549108853014528&quot;&gt;&lt;/video&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic1.zhimg.com/80/v2-5b02c647648a9bbdff01ad8aa9447ca4_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/1025549946677784576&quot; data-name=&quot;数字货币30年发展史——第三部分&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;1025549946677784576&quot;&gt;&lt;/video&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic2.zhimg.com/80/v2-5326fad15d1c6d9a3964252bee605bcd_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/1025550254216687616&quot; data-name=&quot;数字货币30年发展史——第四部分&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;1025550254216687616&quot;&gt;&lt;/video&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2018-09-19-44868083</guid>
<pubDate>Wed, 19 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Ouroboros：可证明安全的权益证明协议</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2018-08-27-43005995.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43005995&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4b90b274ea0062a31690c5d092b90f1d_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;引言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;今天给各位知友带来另外一个存货视频《Ourboros：可证明安全的权益证明协议》。替代工作量证明机制（Proof of Work，PoW）的权益证明机制（Proof of Stake，PoS）已经成为了区块链领域的一个重点研究方向。与PoW相比，PoS具有下述优势（&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Proof of Stake FAQs&lt;/a&gt;）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不需要消耗大量的电力来保证区块链的安全性。&lt;/li&gt;&lt;li&gt;由于不需要大量电力消耗，参与方不需要得到更多的代币奖励即可参与到网络中。&lt;/li&gt;&lt;li&gt;权益证明的使用可以进一步在区块链中引入博弈论机制，从而形成市场经济体制。&lt;/li&gt;&lt;li&gt;降低系统中心化的风险。&lt;/li&gt;&lt;li&gt;有能力应用经济学惩罚措施使得51%的攻击代价变得更高。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;以太坊权益证明机制优势的原始英文描述如下，供参考：&lt;br&gt;1. &lt;b&gt;No need to consume large quantities of electricity&lt;/b&gt; in order to secure a blockchain (e.g. it&#39;s estimated that both Bitcoin and Ethereum burn over $1 million worth of electricity and hardware costs per day as part of their consensus mechanism).&lt;br&gt;2. Because of the lack of high electricity consumption, there is &lt;b&gt;not as much need to issue as many new coins&lt;/b&gt; in order to motivate participants to keep participating in the network. It may theoretically even be possible to have &lt;i&gt;negative&lt;/i&gt; net issuance, where a portion of transaction fees is &quot;burned&quot; and so the supply goes down over time.&lt;br&gt;3. Proof of stake opens the door to a wider array of techniques that use game-theoretic mechanism design in order to better &lt;b&gt;discourage centralized cartels&lt;/b&gt; from forming and, if they do form, from acting in ways that are harmful to the network (e.g. like &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.cs.cornell.edu/%7Eie53/publications/btcProcFC.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;selfish mining&lt;/a&gt; in proof of work).&lt;br&gt;4. &lt;b&gt;Reduced centralization risks&lt;/b&gt;, as economies of scale are much less of an issue. $10 million of coins will get you exactly 10 times higher returns than $1 million of coins, without any additional disproportionate gains because at the higher level you can afford better mass-production equipment, which is an advantage for Proof-of-Work.&lt;br&gt;5. Ability to use economic penalties to &lt;b&gt;make various forms of 51% attacks vastly more expensive&lt;/b&gt;to carry out than proof of work - to paraphrase Vlad Zamfir, &quot;it&#39;s as though your ASIC farm burned down if you participated in a 51% attack&quot;.&lt;/blockquote&gt;&lt;p&gt;PoS的这些优势使得著名区块链平台以太坊（Ethereum）都宣布要用PoS代替PoW，并且已经提出了两种替代方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;综合使用PoS和PoW的协议：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/ethereum/research/blob/master/papers/casper-basics/casper_basics.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Casper the Friendly Finality Gadget&lt;/a&gt;，由Vitalik Buterin（以太坊创始人）和Virgil Griffith提出。&lt;/li&gt;&lt;li&gt;不应用PoW，完全的PoS协议：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/ethereum/research/blob/master/papers/CasperTFG/CasperTFG.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Casper the Firendly GHOST: Correct by Construction&lt;/a&gt;，由Vlad Zamfir提出。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但是，如何构造一个可证明安全的PoS机制是区块链社区、也是学术界研究的一个重点方向。在密码学最顶级的会议CRYPTO 2017上，Aggelos Kiayias、Alexander Russell、Bernardo David、Roman Oliynykow给出了一个证明安全的PoS协议：Ouroboros。而本次带来的视频，就是论文作者之一Aggelos Kiayias在CRYPTO 2016会议上的论文演讲视频。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;相关信息&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文下载链接：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//eprint.iacr.org/2016/889.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2016/88&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;9.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。ePrint是国际密码学研究协会（International Association for Cryptologic Research，IACR）设置的一个密码学开放论文获取平台，有点像著名的ArXiv。现在密码学顶级会议的论文作者都会在ePrint上公开会议论文的完整版本。如果对密码学感兴趣，可以时常查看ePrint上的论文，可以有很多很不错的发现。&lt;/li&gt;&lt;li&gt;演讲视频连接：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DfBKCbhX-dXI%26t%3D983s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=fBKCbhX-dXI&amp;amp;t=983s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。现在IACR已经在YouTube上开创了频道。最近IACR放出了著名密码学家Matthew Green在著名密码学会议EUROCRYPT 2018上的演讲《数字货币的三十年：从电子现金到区块链》（Thirty Years of Digital Currency: From Digicash to the Blockchain）。后面有时间的话我也希望能和知友们分享这个视频，不过这个视频听译起来难度有点大…&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;视频翻译&lt;/b&gt;&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1017192966431105024&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;第一部分：方案描述&quot; data-poster=&quot;https://pic2.zhimg.com/80/v2-7037591c6b16311348e48172195ff499_b.jpg&quot; data-lens-id=&quot;1017192966431105024&quot;&gt;              &lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/80/v2-7037591c6b16311348e48172195ff499_b.jpg&quot;&gt;              &lt;span class=&quot;content&quot;&gt;                &lt;span class=&quot;title&quot;&gt;第一部分：方案描述&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;                &lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1017192966431105024&lt;/span&gt;              &lt;/span&gt;            &lt;/a&gt;            &lt;a class=&quot;video-box&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1017193045200150528&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;第二部分：安全证明&quot; data-poster=&quot;https://pic2.zhimg.com/80/v2-88fa6f8b9b51b6abe441c4b11d7618ad_b.jpg&quot; data-lens-id=&quot;1017193045200150528&quot;&gt;              &lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/80/v2-88fa6f8b9b51b6abe441c4b11d7618ad_b.jpg&quot;&gt;              &lt;span class=&quot;content&quot;&gt;                &lt;span class=&quot;title&quot;&gt;第二部分：安全证明&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;                &lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1017193045200150528&lt;/span&gt;              &lt;/span&gt;            &lt;/a&gt;            &lt;h2&gt;&lt;b&gt;视频介绍&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;区块链技术所要解决的核心问题是：在没有可信第三方的条件下，互不信任的参与方维护一个一致的、公开可验证的账本（Ledger）。&lt;/p&gt;&lt;p&gt;区块链技术通过两种思想来实现这一目标：区块链数据结构、共识协议。如果对数据结构本身有一定的了解，相信各位知友可以认识到，区块链这种账本记录方式的核心就是一种链表数据结构。链表的节点就是所谓的区块（Block），而链表的指针由内存中的地址替换为前一个区块的哈希值。这种特殊的链表结构使得区块链本身具有了公开可验证性，即存在一种高效的验证方法，使得任意一个参与方都可以验证其它参与方是否按照既定的规则存储交易信息。&lt;/p&gt;&lt;p&gt;区块链数据结构本身只能实现账本的公开可验证性。为了实现账本的一致性，还要在区块链数据结构上应用一个协议，使得只要大多数参与方都遵守这一协议，则大多数参与方都可以存储并维护一个相同的区块链数据结构。这个协议就是所谓的共识协议（Consensus Protocol）。&lt;/p&gt;&lt;p&gt;但是，如何从数学角度、或者用一种模型描述区块链技术要实现的目标呢？为了让技术具有较好的健壮性，我们总需要应用一个形式化的模型来描述技术要达到的目标、达到目标所关联的指标。如果没有模型描述，我们也就没办法用非常科学的手段实现区块链技术，当然也就没有所谓的可证明安全了。实际上，演讲者早在2014年就给出了区块链所要实现的核心目标：健壮的交易账本。后续研究者进一步扩展了这一定义。如果想深入理解区块链技术，建议感兴趣的知友阅读图中给出的相关论文，具体论文名称如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;GKL15：The Bitcoin Backbone Protocol: Analysis and Applications. EUROCRYPT 2015, &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//eprint.iacr.org/2014/765.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2014/76&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;5.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;KP15：Speed-Security Tradeos in Blockchain Protocols. &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//eprint.iacr.org/2015/1019.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2015/10&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;19.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;PSS17：Analysis of the Blockchain Protocol in Asynchronous Networks. EUROCRYPT 2017, &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//eprint.iacr.org/2016/454.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2016/45&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;4.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;BMTZ17：Bitcoin as a Transaction Ledger: A Composable Treatment. CRYPTO 2017, &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//eprint.iacr.org/2017/149.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2017/14&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;9.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-25d3a649860a495fdbe845053097690e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-25d3a649860a495fdbe845053097690e_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-25d3a649860a495fdbe845053097690e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-25d3a649860a495fdbe845053097690e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-25d3a649860a495fdbe845053097690e_b.jpg&quot;&gt;&lt;figcaption&gt;区块链交易账本的核心目标&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;除了PoS以外，区块链技术还存在2类共识机制：（1）比特币、以太坊等使用的工作量证明机制（Proof of Work，PoW）；（2）超级账本使用的拜占庭容错协议（Byzantine Fault-Tolerant，BFT）。这几种共识机制实际上是去中心化和效率之间的各种权衡方案。PoW几乎实现了完全的去中心化，但效率较低；BFT实现了部分去中心化（即联盟链的多中心化形式），从而提高了效率；传统中心化数据库效率最高，但达到了完全中心化。而如果我们可以构造一个安全的PoS机制，我们理论上可以做到双赢：既实现了去中心化，又满足效率要求。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-27bcd0980f0894b1e5d68ac6954a854c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-27bcd0980f0894b1e5d68ac6954a854c_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-27bcd0980f0894b1e5d68ac6954a854c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-27bcd0980f0894b1e5d68ac6954a854c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-27bcd0980f0894b1e5d68ac6954a854c_b.jpg&quot;&gt;&lt;figcaption&gt;各种共识机制的去中心化程度与效率对比&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;然而，PoS由于其设计理念，天生就会遇到2种攻击，分别是粉碎攻击（Grinding Attack）、无权益攻击（Nothing-at-stake Attack）。这里我们简单介绍一下这两种攻击。&lt;/p&gt;&lt;p&gt;&lt;b&gt;粉碎攻击&lt;/b&gt;。PoW的本质实际上是应用困难问题的解决概率实现了随机选举（Random Election）过程。困难问题的解决是一个概率事件，拥有越多算力的人越有更高的概率最先决困难问题，但某一个问题由谁最终解决是一个随机问题。举个例子，假定全网有3个参与方，各占有10%、50%、40%的算力。给定一个困难问题，则理论上三个人分别有10%、50%、40%的概率最先解决困难问题。但是，对于一个具体的困难问题来说，最终谁能够解决成功并不确定。PoS移除了算力的要求，因此PoS需要设计一个随机选举过程实现PoW相同的目标。但是，实际执行协议时，此选举过程并不能做到完全随机，而是应用伪随机过程来实现。一旦知道了这一点，某个恶意攻击者就可以利用数学知识，尝试提高自己被选举上的概率。解决这个问题的方法是有很多，理论上最优的方法是设计出一个叫做Verifiable Delay Function（VDF）的密码学工具。这个工具的目标是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在特定时间内，每个人生成的随机数都是可验证的。&lt;/li&gt;&lt;li&gt;只有在特定时间内，参与方才能知道自己和别人的随机数是什么。在特定时间之外，任何人都没办法预测出自己的随机数。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这是一个新的密码学研究方向，此工具的形式化定义和第一个构造方案由密码学顶级研究人员Dan Boneh在2018年提出，相关论文发表在CRYPTO 2018上（&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//eprint.iacr.org/2018/601.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2018/60&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;1.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;）。后续有很多学者构造出了其它VDF方案，感兴趣的知友可以带ePrint上查阅。&lt;/p&gt;&lt;p&gt;&lt;b&gt;无权益攻击&lt;/b&gt;。区块链中如果出现不一致的情况，就会导致分叉。当出现分叉时，PoW应用最长链规则（Longest Chain Rule）或者最重链规则（GHOST）选择出有效的区块链。由于生成一个区块需要消耗算力，因此就算是攻击者也只能选择一个链进行扩展，否则它需要再消耗1倍的算力为另一个链生成新区块。但在PoS中，区块的生成不需要消耗算力，因此攻击者、甚至非攻击者为了让自己的利益最大化，可以为各个分叉生成区块，不考虑哪个区块在未来可能是有效的。目前这一问题的解决方法是让生成区块时要消耗一定的代币，或者如果某个参与方生成了多个分叉，则对其进行惩罚。&lt;/p&gt;&lt;p&gt;此外，PoS的安全性实际上依赖于区块链的安全性，因为PoS中决定哪个参与方生成下一个区块的依据就是区块链本身。反过来，区块链的安全性又依赖于PoS的安全性，只有PoS安全了，生成的区块链才是安全的。这似乎会陷入到一个自证的困境中去。这个问题目前还没有特别好的解决方案。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-94b3ef28d2026c73161665232e445e66_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-94b3ef28d2026c73161665232e445e66_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-94b3ef28d2026c73161665232e445e66_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-94b3ef28d2026c73161665232e445e66_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-94b3ef28d2026c73161665232e445e66_b.jpg&quot;&gt;&lt;figcaption&gt;PoS协议涉及面临的难题和挑战&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;面对这些挑战，论文作者提出了Ouroboros。具体执行过程非常简单：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在创始区块中约定好各个参与方所拥有的权益，并在创始区块中约定一个随机数。&lt;/li&gt;&lt;li&gt;将时间划分成时间槽，结合创始区块中约定的随机数、每个参与方的权益，机算每个时间槽由哪个参与方生成区块。&lt;/li&gt;&lt;li&gt;各个参与方依次生成区块，用区块用最长链规则确定全网中的有效区块链。&lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-019325a30929f2fc486ae33e11defff9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-019325a30929f2fc486ae33e11defff9_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-019325a30929f2fc486ae33e11defff9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-019325a30929f2fc486ae33e11defff9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-019325a30929f2fc486ae33e11defff9_b.jpg&quot;&gt;&lt;figcaption&gt;Ouroboro协议描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这个协议如此简单，如何分析协议的安全性呢？为了证明安全性，论文作者定义了一个概念：特征字符串。当区块链中一个时间槽出现了分叉，则将此时间槽的特征字符串标注为1。如果没有出现分叉，则特征字符串标注为0。如下图：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;时间槽0为创始区块，需要假定创始区块是安全的，这也是合理的假定，特征字符串为0。&lt;/li&gt;&lt;li&gt;时间槽1只包含一个区块，没有分叉，特征字符串为0。&lt;/li&gt;&lt;li&gt;时间槽2包含了两个区块（上方和中间），出现分叉，特征字符串为1。&lt;/li&gt;&lt;li&gt;时间槽3只包含一个区块（上方），没有分叉，特征字符串为0。&lt;/li&gt;&lt;li&gt;时间槽4包含了两个区块（中间和下方），特征字符串为1。&lt;/li&gt;&lt;li&gt;......&lt;/li&gt;&lt;li&gt;时间槽9只包含一个区块（中间），没有分叉，特征字符串为0。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当出现分叉，则这个时间槽就是不安全的，因此特征字符串为1的时间槽都不安全。因此，区块链是否安全这个问题就转换成了一个等价问题：任意给定一个特征字符串w，它安全的概率有多大？不安全的概率有多大？&lt;/p&gt;&lt;p&gt;为了计算相应的概率，论文作者引入了两个参数：到达量（Reach）、边缘量（Margin）。所谓到达量，可以理解为攻击者让分叉区块链成为主链所需的时间槽个数。举例来说（这里论文作者给出的到达量都为负数，根据论文的描述，我认为这应该是作者的笔误）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;图中上方的分叉与主链间隔了4个区块（gap=4），间隔中的所有6个时间槽中，有3个时间槽（时间槽4、时间槽7、时间槽8）的特征字符串为1（Reserve=3），因此到达量为4-3=1。&lt;/li&gt;&lt;li&gt;图中下方的分叉与主链间隔了3个区块（gap=3），间隔中的所有4个时间槽中，有2个时间槽（时间槽7、时间槽8）的特征字符串为1（Reserve=2），因此到达量为3-2=1。&lt;/li&gt;&lt;li&gt;图中中间的主链与主链间隔了0个区块（gap=0），攻击者未控制任何时间槽（Reserve=0），因此到达量为0。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这样，可以把到达量理解为：&lt;b&gt;攻击者让这个分叉成为主链的概率大小&lt;/b&gt;。到达量越大于等于0，攻击者实现攻击的概率越高。而边缘量（Margin）指的就是到达量第二大的分叉（第一大的就是主链了）。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-032786c1811133ef0ed163eea105fc2e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-032786c1811133ef0ed163eea105fc2e_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-032786c1811133ef0ed163eea105fc2e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-032786c1811133ef0ed163eea105fc2e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-032786c1811133ef0ed163eea105fc2e_b.jpg&quot;&gt;&lt;figcaption&gt;安全证明的核心：到达量、边缘量的定义&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;那么，到达量和边缘量如何变化呢？论文作者给出了一个递归公式，其原理为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;当特征字符串为1时，到达量和边缘量同时增加。&lt;/li&gt;&lt;li&gt;当特征字符串为0时：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;攻击者可以通过牺牲到达量，来降低边缘量。&lt;/li&gt;&lt;li&gt;到达量永远不能减小到0以下。&lt;/li&gt;&lt;li&gt;如果到达量和边缘量均大于0，则两个值同时降低。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;这样一来，到达量和边缘量就成为了由特征字符串决定的二维随机游走过程。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-13cb810648425a0c89e5714f2f4fa418_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-13cb810648425a0c89e5714f2f4fa418_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-13cb810648425a0c89e5714f2f4fa418_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-13cb810648425a0c89e5714f2f4fa418_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-13cb810648425a0c89e5714f2f4fa418_b.jpg&quot;&gt;&lt;figcaption&gt;到达量和边缘量变化的递归公式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;通过应用概率建模，论文作者证明：给定任意一个特征字符串，到达量和边缘量最终状态使得区块链安全的概率是常数，而到达量和边缘量最终状态使得区块链不安全的概率会随着区块链中区块个数的增加而指数级下降。因此，随着区块链长度的增加，区块链不安全的概率指数下降，这就得到了协议安全性的证明了。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cce21f105f40ec1a2d23fd5837323a24_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-cce21f105f40ec1a2d23fd5837323a24_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cce21f105f40ec1a2d23fd5837323a24_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-cce21f105f40ec1a2d23fd5837323a24_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cce21f105f40ec1a2d23fd5837323a24_b.jpg&quot;&gt;&lt;figcaption&gt;协议安全性的证明结论&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;一些思考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;从数学角度看，PoS协议是可以做到可证明安全的。但是，从非数学角度看，PoS是可证明安全的吗？其核心点在于我们如何定义权益？权益到底是什么？在没有公认锚点的情况下，权益的定义一旦有问题，整个区块链的机制似乎就不成立了。在此，我仅引入“橙皮书”对Nervos创始人Jan的采访。&lt;/p&gt;&lt;blockquote&gt;2018年08月27日更新：感谢匿名知友指出的问题，对Nervos创始人Jan的访谈不是由“区块链头条”采访的，是由“橙皮书”采访并原创的，原链接为：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/giniWFxxAFGT0fr2qbZc_Q&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;对话Nervos：中国最懂以太坊的人，却选择了一条和以太坊截然不同的道路&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;知友们可以结合Jan的观点和PoS本身、再结合自己所具有的区块链相关知识，得到自己的结论：&lt;/p&gt;&lt;blockquote&gt;橙皮书：为什么不看好 PoS ？&lt;br&gt;&lt;br&gt;Jan：我总觉得 PoS有点问题。因为共识是要创造信任，信任是不可能自己创造自己。你想象一条蛇在咬自己的尾巴。PoS用系统自己发布的资产作为押金，去保证这个系统的安全。它没有锚定任何的东西，是漂浮在空中的。我没有看到任何的信任是通过 PoS这样的方式创造出来的。我觉得信任的创造还是要锚定能量。美元锚定是美国的军事实力。如果哪天美国没有这种军事实力，那美元的价值我觉得要打很多问号。PoW是相当于用军队锚定，PoS 是用美元锚定美元。&lt;br&gt;&lt;br&gt;这个问题你会思考很久。因为你可能又会想，归根到底这两种方式，好像都是用资本去锚定，因为电力本质上也是一种资本。但再想想，这两种资本好像是不太一样的。PoW 是体系外的资本。所以，PoS 我总觉得有点问题。&lt;/blockquote&gt;&lt;p&gt;那么为什么以太坊还要引入PoS呢？我个人的观点是：PoS本身的权益是漂浮在空中的，但是&lt;b&gt;如果PoS权益之前已经被认定为是一个有价值的东西（以太坊中的Eth），用一个公认有价值的东西反过来做为权益，PoS似乎就不漂浮在空中了&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;但是，Eth有价值吗？这个问题，有点深奥… 欢迎知友在评论区讨论。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2018-08-27-43005995</guid>
<pubDate>Mon, 27 Aug 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
