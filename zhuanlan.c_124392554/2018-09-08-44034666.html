<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>德·布鲁因（de Bruijn）有向图和德·布鲁因序列</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/44034666">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-768aa806b2d179f06be37dd93bf696e7_r.jpg" alt=""></div><p>在上一篇文章“<a href="https://zhuanlan.zhihu.com/p/43960965">存储器轮</a>”中，曾经引入了两个图： </p><img src="https://pic4.zhimg.com/v2-fa4ced3add12bfb8984a67d6459a7f67_r.jpg" data-caption="" data-size="normal" data-rawwidth="845" data-rawheight="574" data-watermark="watermark" data-original-src="v2-fa4ced3add12bfb8984a67d6459a7f67" data-watermark-src="v2-8ae7a1926681a31c6ac6cd87dbaa2c1e" data-private-watermark-src=""><p>事实上，这样的图的顶点集是 <equation>V=\{x_1x_2... x_n|x_i\in\{0, 1\}，i=1, 2, ..., n\}</equation> ，从任意顶点 <equation>x_1x_2... x_n</equation> 到2个其他顶点 <equation>x_2...x_n0</equation> 和 <equation>x_2...x_n1</equation> 分别各有一条有向边，它们称作<b>德•布鲁因（de Bruijn）有向图</b> <equation>B(2, n)</equation> 。</p><hr><p><equation>B(2, n)</equation> 还有其他两种等价定义。</p><p><b>定义2：</b> <equation>B(2, n)</equation> 的顶点集合定义为 <equation>V=\{0, 1, ..., 2^n-1\}</equation> ，有向边集合定义为 <equation>E=\{(x, y)|y\equiv2x(\bmod 2^n)或y\equiv2x+1(\bmod 2^n)\}</equation> 。（它和之前定义的等价性是明显的）</p><p>例如上述两图等价于下图：</p><img src="https://pic4.zhimg.com/v2-5bd0be321d2dab41b618a789c85820d8_r.jpg" data-caption="" data-size="normal" data-rawwidth="754" data-rawheight="476" data-watermark="watermark" data-original-src="v2-5bd0be321d2dab41b618a789c85820d8" data-watermark-src="v2-2441463dd7e3502e3f3386d6700cd81e" data-private-watermark-src=""><hr><p>介绍定义3之前需要先有向图上的“线图”：若在有向图 <equation>D</equation> 中有两条有向边 <equation>(u, v)</equation> 和 <equation>(v, w)</equation> ，则在新的图 <equation>L(D)</equation> 中画一条从代表边 <equation>(u, v)</equation> 的顶点到代表边 <equation>(v, w)</equation> 的顶点的有向边（如下图所示）。</p><img src="https://pic1.zhimg.com/v2-03b2418258970e8d9b9a09f54c8b35b0_r.jpg" data-caption="" data-size="normal" data-rawwidth="1025" data-rawheight="214" data-watermark="watermark" data-original-src="v2-03b2418258970e8d9b9a09f54c8b35b0" data-watermark-src="v2-ea81729517811c62d3e5a80c7c55730e" data-private-watermark-src=""><p><br></p><p>得到的 <equation>L(D)</equation> 就称作 <equation>D</equation> 的<b>线图（line graph）</b>。</p><p>例如下图上的线图就是下图下：</p><img src="https://pic4.zhimg.com/v2-9a31c97de1772d42ab4e552dfc403055_r.jpg" data-caption="" data-size="normal" data-rawwidth="568" data-rawheight="409" data-watermark="watermark" data-original-src="v2-9a31c97de1772d42ab4e552dfc403055" data-watermark-src="v2-1dfd2ef3ae55991717e01490c70e0d5f" data-private-watermark-src=""><hr><p><b>定义3：</b></p><p>(1) 定义 <equation>B(2, 1)</equation> 如下图所示：</p><img src="https://pic2.zhimg.com/v2-9dbd1b57149f9dffa2f27de373cf5c2f_r.jpg" data-caption="" data-size="normal" data-rawwidth="405" data-rawheight="100" data-watermark="watermark" data-original-src="v2-9dbd1b57149f9dffa2f27de373cf5c2f" data-watermark-src="v2-45d8139706fb0232b829e5530d2a9268" data-private-watermark-src=""><p>(2) <equation>n\geq2</equation> 时， <equation>B(2, n)</equation> 为 <equation>B(2, n-1)</equation> 的线图，即 <equation>B(2, n)=L(B(2, n-1))</equation> ，在 <equation>B(2, n-1)</equation> 中由顶点 <equation>x_1x_2...x_n</equation> 指向顶点 <equation>x_2...x_nx_{n+1}</equation> 的有向边在 <equation>B(2, n)</equation> 中命名为顶点 <equation>x_1x_2...x_nx_{n+1}</equation> 。（例如 <equation>B(2, 2)</equation> 如下图左所示， <equation>B(2, 3)</equation> 如下图右所示）</p><img src="https://pic1.zhimg.com/v2-0d07be00c3f781a424141cbe21225cc0_r.jpg" data-caption="" data-size="normal" data-rawwidth="809" data-rawheight="432" data-watermark="watermark" data-original-src="v2-0d07be00c3f781a424141cbe21225cc0" data-watermark-src="v2-45fc3b90e5abb5b5567d4437a5ebfef2" data-private-watermark-src=""><hr><p>由 <equation>B(2, n)</equation> 中欧拉回路得到的0-1串称作长度 <equation>2^n</equation> 的<b>德·布鲁因（de Bruijn）序列</b>。例如由下图左得到长度16的德·布鲁因序列1111011001010000。</p><img src="https://pic2.zhimg.com/v2-9e4670d59cd994b0d3834a087686fdb6_r.jpg" data-caption="" data-size="normal" data-rawwidth="860" data-rawheight="438" data-watermark="watermark" data-original-src="v2-9e4670d59cd994b0d3834a087686fdb6" data-watermark-src="v2-6816b822bd218a1fab6cb0330b34d2d3" data-private-watermark-src=""><hr><p>长度 <equation>2^n</equation> 的德·布鲁因序列还有其他的构造方法，举例如下。</p><p><b>其他方法1：</b></p><p>令 <equation>m=2^{n-1}</equation> ，第一行写下 <equation>m</equation> 个“1”和 <equation>m</equation> 个“0”，第二行写下 <equation>m</equation> 个“10”， <equation>n=3</equation> 的情况如下图所示：</p><img src="https://pic2.zhimg.com/v2-803384dd95818e925d01bb044c88def7_r.jpg" data-caption="" data-size="normal" data-rawwidth="319" data-rawheight="273" data-watermark="watermark" data-original-src="v2-803384dd95818e925d01bb044c88def7" data-watermark-src="v2-ee9c83b03561ee6358066995a2f5bc47" data-private-watermark-src=""><p>上一行编号和“1”或“0”之间的映射关系为： <equation>f(i)=1，f(m+i)=0，1\leq i\leq m</equation> 。</p><p>之后将第一行和第二行的“1”自左而右依次一一相连、将第一行和第二行的“0”也自左而右依次一一相连。连线实际上构成了位置编号的置换 <equation>p(i)=2i-1，p(m+i)=2i，1\leq i\leq m</equation> 。</p><p><equation>n=3</equation> 的情况如下图所示：</p><img src="https://pic2.zhimg.com/v2-6102635816ba638c9589f466387ca596_r.jpg" data-caption="" data-size="normal" data-rawwidth="319" data-rawheight="273" data-watermark="watermark" data-original-src="v2-6102635816ba638c9589f466387ca596" data-watermark-src="v2-3d22387b1f390c0fc6e91a498dfcd995" data-private-watermark-src=""><p>将这个置换写成轮换的乘积的形式（每个轮换中最小的数值是递增的，且每个轮换都满足其中最小数值在第一个位置）。自左而右逐个写出各个轮换中数值对应第一行各个位置的“1”或“0”，则得到有 <equation>2^n</equation> 个元素的德·布鲁因序列。</p><p><equation>n=3</equation> 的情况如下图所示：</p><img src="https://pic4.zhimg.com/v2-8553267c3d7f3a844cf33a86e00841c0_r.jpg" data-caption="" data-size="normal" data-rawwidth="319" data-rawheight="273" data-watermark="watermark" data-original-src="v2-8553267c3d7f3a844cf33a86e00841c0" data-watermark-src="v2-2450e84997e7f291afcf9c1e17388c53" data-private-watermark-src=""><p>置换分解为轮换的乘积后，符合要求的表示为(1)(235)(476)(8)，对应的序列为 <equation>f(1)f(2)f(3)f(5)f(4)f(7)f(6)f(8)=11101000</equation> 。</p><p><equation>n=2</equation> 时如下图所示，置换分解为轮换的乘积后，符合要求的表示为(1)(23)(4)，对应的序列为 <equation>f(1)f(2)f(3)f(4)=1100</equation> 。</p><img src="https://pic2.zhimg.com/v2-bca9e4176e89c0ff2be2aed05418411e_r.jpg" data-caption="" data-size="normal" data-rawwidth="168" data-rawheight="271" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p><equation>n=4</equation> 时的情况如下图所示。置换分解为轮换的乘积后，符合要求的表示为(1)(2, 3, 5, 9)(4, 7, 13, 10)(6, 11)(8, 15, 14, 12)(16)，对应的序列为 <equation>f(1)f(2)f(3)f(5)f(9)f(4)f(7)f(13)f(10)f(6)f(11)f(8)f(15)f(14)f(12)f(16)=1111011001010000</equation> 。</p><img src="https://pic1.zhimg.com/v2-026d4e86bc662b3b9b3d986cde975133_r.jpg" data-caption="" data-size="normal" data-rawwidth="622" data-rawheight="255" data-watermark="watermark" data-original-src="v2-026d4e86bc662b3b9b3d986cde975133" data-watermark-src="v2-7844c8b7343e9ac09d7d9e49b04ac7c4" data-private-watermark-src=""><p><b>其他方法2：</b></p><p>马丁（M.A.Martin）1934证明了以下贪婪算法对所有的 <equation>n\geq2</equation> 都可以构造出一个长度 <equation>2^n</equation> 的德·布鲁因序列：</p><p>1. 写出 <equation>n</equation> 个0构成序列开始的 <equation>n</equation> 项；</p><p>2. 如果在序列尾部添加一个1后，和前 <equation>n-1</equation> 项相连构成已经出现过的长为 <equation>n</equation> 的0-1子串，则在序列尾部添加一个0；否则在序列尾部添加一个1。</p><p>3. 序列若还不够 <equation>2^n</equation> 项，则返回步骤2；否则序列就是一个长度 <equation>2^n</equation> 的德·布鲁因序列。</p><p><equation>n=3</equation> 时算法过程的情况如下表所示：</p><img src="https://pic2.zhimg.com/v2-ffdb8550934f114a0bb18102ab25c110_r.jpg" data-caption="" data-size="normal" data-rawwidth="848" data-rawheight="380" data-watermark="watermark" data-original-src="v2-ffdb8550934f114a0bb18102ab25c110" data-watermark-src="v2-31750571fc7f063ce7ba630533e32fec" data-private-watermark-src=""><p><equation>n= 4</equation> 时算法过程的情况如下表所示：</p><img src="https://pic4.zhimg.com/v2-01d75279892dc5345a0a40c25c503576_r.jpg" data-caption="" data-size="normal" data-rawwidth="848" data-rawheight="547" data-watermark="watermark" data-original-src="v2-01d75279892dc5345a0a40c25c503576" data-watermark-src="v2-897f8c411a422f08dce28adb04b49970" data-private-watermark-src=""><hr><p>德·布鲁因有向图在并行计算的网络拓扑方面得到了很多研究和应用。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
