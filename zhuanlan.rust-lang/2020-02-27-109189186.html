<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Rust中的零成本抽象（二）（部分翻译）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/109189186">原文</a></p>
<p>时间有限，翻译了关键的部分</p><p>大意是，Rust中的抽象的可读性高的代码和手动优化代码在调试时是有区别的，但是在发布时没有区别。当然手动优化的编译更快。</p><p>原文译自</p><a href="https://link.zhihu.com/?target=https%3A//carette.xyz/posts/zero_cost_abstraction/" data-draft-node="block" data-draft-type="link-card" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">carette.xyz/posts/zero_</span><span class="invisible">cost_abstraction/</span><span class="ellipsis"></span></a><p><a href="https://link.zhihu.com/?target=https%3A//carette.xyz/posts/zero_cost_abstraction/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Zero-cost abstractions in Rust</a></p><a href="https://link.zhihu.com/?target=https%3A//carette.xyz/posts/zero_cost_abstraction/" data-draft-node="block" data-draft-type="link-card" class=" wrap external" target="_blank" rel="nofollow noreferrer">Zero-cost abstractions in Rust</a><p>上一周, <a href="https://link.zhihu.com/?target=https%3A//idursun.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Ibrahim Dursun</a>发布了一篇关于Rust零成本抽象的文章。<br/>不幸的是，除了文章的一小部分, 这篇文章并没有正确地体现（我的拙见）什么是零抽象。</p><p>确实，零成本抽象（zero-cost abstraction）或者零开销原则（zero-overhead），是很难理解，并与编译优化分离，这导致它很容易被误解。</p><p>在这篇文章中，我会讨论它，并且给出Rust如何对抽象过的项目进行优化的例子。</p><p>注意：去年关于零成本抽象已经有篇好文（<a href="https://zhuanlan.zhihu.com/p/109517672" class="internal">零成本抽象，作者：withoutboats</a>），本文作为它的补充。</p><h2>什么是零成本抽象</h2><p>当你编程的时候，项目越来越复杂，通常你会增加抽象来让项目容易维护并增加功能。你肯定希望你的抽象不要在运行时增加成本。</p><p>所以，你的2个原则是：</p><ul><li>项目的可读性和易管理性比复杂的手写优化更重要</li><li>但至少能在运行时发挥非常良好的性能</li></ul><p>确实，改进代码可读性会限制优化和内存开销，并间接迟滞运行时的性能。</p><p>零成本抽象来自C++，由C++创始人Bjarne Stroustrup定义：</p><blockquote><i>通常，C++的实现遵循零开销原则：你不使用的，你不负担成本。更进一步：你使用的，你也没法更优化。</i></blockquote><p>总结他说的：</p><ol><li>你不使用的功能，你不承担额外开销</li><li>高层的抽象会被编译成机器代码，这些代码很难更进一步优化</li></ol><p>Rust最主要的抽象（或者说标准库）不会增加运行时成本。</p><p>在Rust中，零成本抽象是一种核心原则，尤其对下面的这些特性：</p><ul><li>编译时内存检查和静态垃圾回收（借用和所有权） - 作为提醒, Rust 在运行时不通过引用计数检查和回收内存，而是在编译时通过生命周期检查</li><li><a href="https://link.zhihu.com/?target=https%3A//blog.rust-lang.org/2015/05/11/traits.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">traits</a>, 是非常让人印象深刻的功能，来拓展你的类型</li><li>generics（泛型）,</li><li>iterators（迭代器）,</li><li>etc（其它）.</li></ul><p>This can explain why <a href="https://link.zhihu.com/?target=https%3A//diesel.rs/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Diesel</a>, a famous Rust ORM, <a href="https://link.zhihu.com/?target=https%3A//www.reddit.com/r/Rust/comments/5hmya5/diesel_is_30_faster_than_Rustpostgres_in/" class=" wrap external" target="_blank" rel="nofollow noreferrer">was 30% faster than the raw postgres solution for Rust</a>, using more abstractions.</p><h2>两个例子</h2><p>我们用两个例子来解释Rust中的零成本抽象。</p><p>从1开始、小于自然数n的，所有的奇数的和。</p><p>两个版本的代码</p><p>第一个是通常的抽象版本</p><p>第二个是手写优化版本</p><div class="highlight"><pre><code class="language-text">fn sum_odd_numbers(n: u64) -&gt; u64 {
    let mut acc = 0;
    for element in 0.. {
        if element &gt;= n {
            break;
        }
        if element.is_odd() {
            acc += element;
        }
    }
    acc
}</code></pre></div><p>, or</p><div class="highlight"><pre><code class="language-text">fn sum_odd_numbers(n: u64) -&gt; u64 {
    (0..)
        .take_while(|element| element &lt; &amp;n)
        .filter(|n| n.is_odd())
        .fold(0, |sum, element| sum + element)
}</code></pre></div><p>下面一段解释了第二个代码使用了函数式编程，都干了什么：</p><p>The second code sample borrows functional programming concepts to compute the sum, and is seems more “compact” (and easier to understand) than the first one.<br/>However, if we decompose this second sample, we can make wrong assumptions here:</p><ol><li>create an iterator that begins with a zero value,</li><li>take all elements lower than <code>n</code>, a number passed as parameter by the user - as a reminder, if we explicit the final of the iterator, the compiler could decide to compute the final number at compile time, and store it in the executable -, and store the result in another array,</li><li>loop all over the last array of elements to get only the odds, and store the result in another array,</li><li>loop over the odds array to compute the sum, and return finaly return the value.</li></ol><p>So, multiple array allocations just to compute a simple sum…</p><p>Fortunately, <b>Rust does not do that</b>: instead, the compiler writes as great code as the first solution provided here, by itself!</p><p>Let’s demonstrate it using benchmarks.</p><h3>性能对比（Benchmarks）</h3><p>以下的性能对比使用Intel Core i5 (3 GHz, 6 cores * 2 threads / core), 对于手写优化和抽象版使用不同的n都运行了10次，然后取中间数。</p><p><br/>I used the <code>time</code> program to measure the user + system execution times each time, and computed the median of those values.</p><p>包括编译和发布运行时间对比。</p><p><b>发布是使用</b><code>cargo build --release</code>的版本：</p><div class="highlight"><pre><code class="language-text">cargo build --release # in the root of your cargo project</code></pre></div><p>代码库见 <a href="https://link.zhihu.com/?target=https%3A//github.com/k0pernicus/Rust_zero_cost_abstraction_illustration" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/k0pernicus/R</span><span class="invisible">ust_zero_cost_abstraction_illustration</span><span class="ellipsis"></span></a>。</p><p><b>性能对比</b></p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-a0a832c2c89d838d82dce7b38a9cfd0b_b.jpg" data-caption="" data-size="normal" data-rawwidth="796" data-rawheight="381" class="origin_image zh-lightbox-thumb" width="796" data-original="https://pic4.zhimg.com/v2-a0a832c2c89d838d82dce7b38a9cfd0b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-a0a832c2c89d838d82dce7b38a9cfd0b_b.jpg" data-caption="" data-size="normal" data-rawwidth="796" data-rawheight="381" class="origin_image zh-lightbox-thumb lazy" width="796" data-original="https://pic4.zhimg.com/v2-a0a832c2c89d838d82dce7b38a9cfd0b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-a0a832c2c89d838d82dce7b38a9cfd0b_b.jpg"/></figure><p>抽象版本在发布时被大大优化了，以至于和手写优化没有区别。（译者注：标准库中的功能可能大多数如此）</p><h2>编译时间</h2><p>Unfortunately, zero-cost abstractions has a consequence: as the compiler has more work to do to optimize itself the abstracted code, it will run more longer.</p><p>If you take a look at the compile time of each versions below, you can observe that the abstracted version compiles more slower than the hand-written version, even for a simple program like this…</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-ce32aca2e8f1dc614e64450ad9e6b6ab_b.jpg" data-caption="" data-size="normal" data-rawwidth="802" data-rawheight="156" class="origin_image zh-lightbox-thumb" width="802" data-original="https://pic4.zhimg.com/v2-ce32aca2e8f1dc614e64450ad9e6b6ab_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-ce32aca2e8f1dc614e64450ad9e6b6ab_b.jpg" data-caption="" data-size="normal" data-rawwidth="802" data-rawheight="156" class="origin_image zh-lightbox-thumb lazy" width="802" data-original="https://pic4.zhimg.com/v2-ce32aca2e8f1dc614e64450ad9e6b6ab_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-ce32aca2e8f1dc614e64450ad9e6b6ab_b.jpg"/></figure><h2>总结</h2><p>当你需要抽象的时候，不要犹豫。在Rust中，你永远不需要首先进行手写优化，而应该考虑抽象性、架构和设计、代码可读性。即使你十分在意运行时性能。<br/>当然，手写优化的版本编译起来要快很多（即使这么简单的程序都能差这么多）。</p><p>Thanks to Robert Syme <a href="https://link.zhihu.com/?target=https%3A//github.com/k0pernicus/website/pull/1" class=" wrap external" target="_blank" rel="nofollow noreferrer">for his contribution</a>.</p><p><a href="https://zhuanlan.zhihu.com/p/109517672" class="internal">雾色：Rust中的零成本抽象（一）（译）</a>（另外一人写的）</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
