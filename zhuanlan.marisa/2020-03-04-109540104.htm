<div class="title-image"><img src="https://pic4.zhimg.com/v2-143b2fade44bed352dfd081dbe478cd7_b.jpg" alt=""></div><p>上一篇 <a href="https://zhuanlan.zhihu.com/p/108759696" class="internal">LdBeth：NuPRL 中的证明{x:N|2&lt;x&lt;3}--virtual evidence</a></p><p>Constructive proof assistant 有个需求，</p><p><a href="https://zhuanlan.zhihu.com/p/74410702" class="internal">千里冰封 你懂吗：dependent type 下的类型推导 (meta variables)</a></p><p>比如 Agda 中</p><div class="highlight"><pre><code class="language-agda">id&#39; : forall (x : Prop) -&gt; x -&gt; x
id&#39; _ x = x</code></pre></div><p>的第一个参数是不参与计算的，就可以写成 implicit argument</p><div class="highlight"><pre><code class="language-text">id : forall {x : Prop} -&gt; x -&gt; x
id x = x</code></pre></div><p>在用了 implicit argument 以后，id 就是个 polymorphic function。</p><p>NuPRL 是如何实现这样的功能的呢。众所周知 universal qualification 是用 dependent function type (Pi type) 实现的。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+x%3A%5Cmathbb%7BP%7D.+P%28x%29++%3D%3D+%5Cprod_%7Bx%3A%5Cmathbb%7BP%7D%7D%7BP%28x%29%7D" alt="\forall x:\mathbb{P}. P(x)  == \prod_{x:\mathbb{P}}{P(x)}" eeimg="1"/> </p><p>那在不引入 metavariable 的设计下，implicit argument 要如何表示？各位是否还记得 intersection over a family of types? recall 在第一节中出现的</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+A+%3A+Type%2C+B+%3A+A+%5Crightarrow+Type%2C+a+%3A+A+.%28%5Ccap+x%3AA.B%28x%29%29+%5Csubseteq+B%28a%29" alt="\forall A : Type, B : A \rightarrow Type, a : A .(\cap x:A.B(x)) \subseteq B(a)" eeimg="1"/></p><p>因而可以有 implicit universal qualification 定义如下</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall%5Bx%3A%5Cmathbb%7BP%7D%5D.P%28x%29+%3D%3D+%5Cbigcap_%7Bx%3A%5Cmathbb%7BP%7D%7DP%28x%29" alt="\forall[x:\mathbb{P}].P(x) == \bigcap_{x:\mathbb{P}}P(x)" eeimg="1"/></p><p>证明 intersection over a family 的要点在于在 [ ] 中的 hidden hypothesis 的 computation content 沒有在 conclusion 中使用到。这样 extract 出来的 program 自然不包含 implicit argument。</p><p>这个原则叫做 unhide hypothesis。在上一节中证明 <img src="https://www.zhihu.com/equation?tex=%5C%7BP%5C%7D+%5Cimplies+%5Cneg%5Cneg+P" alt="\{P\} \implies \neg\neg P" eeimg="1"/> 也是利用这个原则，因为一个返回类型为 Void 的 function 的 computation content 显然是 trivial 的，因此那个证明中 derive 出 <img src="https://www.zhihu.com/equation?tex=%5C%7BP%5C%7D+%5Cimplies+P" alt="\{P\} \implies P" eeimg="1"/> 是允许的，因为实际上 P 是个 hidden hypothesis。</p><p>这么说有些抽象，用个具体的例子就是 NuPRL 可以证明 </p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5BT%3AType%5D.+%5Cforall%5BP%3A+T+%5Crightarrow+%5Cmathbb%7BP%7D%5D.+%5Cforall+a%2C+b%3AT.+P%5C%3B+a+%5Clor+P%5C%3B+b%5Cimplies+%5Cexists+x%3A+T.P%5C%3B+x" alt="\forall [T:Type]. \forall[P: T \rightarrow \mathbb{P}]. \forall a, b:T. P\; a \lor P\; b\implies \exists x: T.P\; x" eeimg="1"/> </p><p>但是不能证明 implicit 版的</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5BT%3AType%5D.+%5Cforall%5BP%3A+T+%5Crightarrow+%5Cmathbb%7BP%7D%5D.+%5Cforall+%5Ba%2C+b%3AT%5D.+P%5C%3B+a+%5Clor+P%5C%3B+b%5Cimplies+%5Cexists+x%3A+T.P%5C%3B+x" alt="\forall [T:Type]. \forall[P: T \rightarrow \mathbb{P}]. \forall [a, b:T]. P\; a \lor P\; b\implies \exists x: T.P\; x" eeimg="1"/> </p><p>原因在哪里呢？非 implicit 版的 witness 是</p><p><img src="https://www.zhihu.com/equation?tex=%5Clambda+a%2Cb%2C%5C%25.+case%5C%3B+%5C%25%5C%3B+of%5C%3B+inl%28%5C%251%29+%5Crightarrow+%5Clangle+a%2C+%5C%251+%5Crangle%5C%3B+%7C%5C%3B+inr%28%5C%252%29+%5Crightarrow+%5Clangle+b%2C+%5C%252+%5Crangle" alt="\lambda a,b,\%. case\; \%\; of\; inl(\%1) \rightarrow \langle a, \%1 \rangle\; |\; inr(\%2) \rightarrow \langle b, \%2 \rangle" eeimg="1"/> </p><p>term a 和 b 出現在了返回的表达式中，也就说明了对应的 hypothesis 的 computation content 使用到了 conclusion 中。而 T 和 P 的 term 并沒有出现在 witness 中，就可以作为实现了 polymorphism 的 implicit argument。 非 implicit 版的 witness 是个合法的接受三个参数的 lambda，而 implicit 版需要的</p><p><img src="https://www.zhihu.com/equation?tex=%5Clambda+%5C%25.+case%5C%3B+%5C%25%5C%3B+of%5C%3B+inl%28%5C%251%29+%5Crightarrow+%5Clangle+a%2C+%5C%251+%5Crangle%5C%3B+%7C%5C%3B+inr%28%5C%252%29+%5Crightarrow+%5Clangle+b%2C+%5C%252+%5Crangle" alt="\lambda \%. case\; \%\; of\; inl(\%1) \rightarrow \langle a, \%1 \rangle\; |\; inr(\%2) \rightarrow \langle b, \%2 \rangle" eeimg="1"/> </p><p>中的 a b 成了 free variable 了。</p><p>当然，诚然 Agda 中可以证明使用 implicit argument 的形式，但是使用的时候同样不能 infer 出 implicit 参数。</p><div class="highlight"><pre><code class="language-agda">lemma : ∀{T : Set}{P : T → Set}{a b : T} → P a ⊎ P b → ∃[ x ] P x
lemma {a = a} (inj₁ i) = a , i
lemma {b = b} (inj₂ i) = b , i

neg : Bool → Set
neg true = ⊤
neg false = ⊥

-- 需要提供 metavariable a b 才能 tc
_ : ∃[ x ] neg x
_ = lemma {a = true} {b = false} (inj₁ tt)</code></pre></div><p>当然，在 NuPRL 如果一定要用 implicit universal qualification 证明 <img src="https://www.zhihu.com/equation?tex=P%5C%3B+a+%5Clor+P%5C%3B+b%5Cimplies+%5Cexists+x.P%5C%3B+x" alt="P\; a \lor P\; b\implies \exists x.P\; x" eeimg="1"/> 还有別的方法，还记得上一篇讲的用于证明 classical proposition 的方法吗？</p><p>如果写成</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5BT%3AType%5D.+%5Cforall%5BP%3A+T+%5Crightarrow+%5Cmathbb%7BP%7D%5D.+%5Cforall+%5Ba%2C+b%3AT%5D.+%5C%7BP%5C%3B+a+%5Clor+P%5C%3B+b%5Cimplies+%5Cexists+x%3A+T.P%5C%3B+x%5C%7D" alt="\forall [T:Type]. \forall[P: T \rightarrow \mathbb{P}]. \forall [a, b:T]. \{P\; a \lor P\; b\implies \exists x: T.P\; x\}" eeimg="1"/> </p><p>就可以证啦，具体的证明就给读者作习題了。(bushi</p><p></p>