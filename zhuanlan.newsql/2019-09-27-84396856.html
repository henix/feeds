<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TiKV Rust Client 迁移记 - Futures 0.1 至 0.3</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/84396856">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-3720eff25c56733a55c449121fa18c93_b.jpg" alt=""></div><blockquote>作者介绍：Nick Cameron，PingCAP 研发工程师，Rust core team 成员，专注于分布式系统、数据库领域和 Rust 语言的进展。</blockquote><p>最近我将一个中小型的 crate 从 futures 库的 0.1 迁移至了 0.3 版本。过程本身不是特别麻烦，但还是有些地方或是微妙棘手，或是没有很好的文档说明。这篇文章里，我会把迁移经验总结分享给大家。</p><p>我所迁移的 crate 是 TiKV 的 <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Ftikv%252Fclient-rust" class=" wrap external" target="_blank" rel="nofollow noreferrer">Rust Client</a>。该 crate 的规模约为 5500 行左右代码，通过 gRPC 与 TiKV 交互，采用异步接口实现。因此，对于 futures 库的使用颇为重度。</p><p>异步编程是 Rust 语言中影响广泛的一块领域，已有几年发展时间，其核心部分就是 <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Frust-lang-nursery%252Ffutures-rs" class=" wrap external" target="_blank" rel="nofollow noreferrer">futures</a> 库。作为一个标准 Rust 库，futures 库为使用 futures 编程提供所需数据类型以及功能。虽然它是异步编程的关键，但并非你所需要的一切 - 你仍然需要可以推进事件循环 (event loop) 以及与操作系统交互的其他库。</p><p><code>futures</code> 库在这几年中变化很大。最新的版本为 0.3（crates.io 发布的 <code>futures</code> 预览版）。然而，有许多早期代码是 futures 0.1 系列版本，且一直没有更新。这样的分裂事出有因 - 0.1 和 0.3 版本之间变化太大。0.1 版本相对稳定，而 0.3 版本一直处于快速变化中。长远来看，0.3 版本最终会演进为 1.0。有一部分代码会进入 Rust 标准库，其中的第一部分已在最近发布了稳定版，也就是 <code>Future</code> trait。</p><p>为了让 Rust Client 跑在稳定的编译器上，我们将核心库限制为仅使用稳定或即将稳定的特性。我们在文档和示例中确实使用了 async/await，因为 async/await 更符合工程学要求，而且将来也一定会成为使用 Rust 进行异步编程的推荐方法。除了在核心库中避免使用 async/await，我们对使用 futures 0.1 的 crate 也有依赖，这也意味着我们需要经常用到兼容层。从这个角度说，我们这次迁移其实并不够典型。</p><p>我不是异步编程领域的专家，或许有其他方法能让我们这次迁移（以及所涉及的代码）更符合大家的使用习惯。如果您有好的建议，可以在 <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Ftwitter.com%252Fnick_r_cameron" class=" wrap external" target="_blank" rel="nofollow noreferrer">Twitter</a> 上联系我。如果您想要贡献 PR 就更赞了，我们期待越来越多的力量加入到 <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Ftikv%252Fclient-rust" class=" wrap external" target="_blank" rel="nofollow noreferrer">TiKV Client</a> 项目里。</p><h2>机械性变化</h2><p>此类变化是指那些 “查询替换类” ，或其他无需复杂思考的变化。</p><p>这一类别中最大的变化莫过于 0.1 版本的 <code>Future</code> 签名中包含了一个 <code>Error</code> 关联类型，而且 <code>poll</code> 总是会返回一个 <code>Result</code>。0.3 版本里该错误类型已被移除，对于错误需要显式处理。为了保持行为上的一致性，我们需要将代码里所有 <code>Future&lt;Item=Foo, Error=Bar&gt;</code> 替换为 <code>Future&lt;Output=Result&lt;Foo, Bar&gt;&gt;</code>（留意 <code>Item</code> 到 <code>Output</code> 的名称变化）。替换后， <code>poll</code> 就可以返回和以前一样的类型，这样在使用 futures 的时候无需任何变化。</p><p>如果你定义了自己的 futures，那就需要根据是否需要处理错误的需求更新 futures 的定义。</p><p>futures 0.3 中支持 <code>TryFuture</code> 类型，基本上可以看作 <code>Future&lt;Output=Result&lt;...&gt;&gt;</code> 的替代。使用这个类型，意味着你需要在 <code>Future</code> 与 <code>TryFuture</code> 之间转换，因此最好还是尽量避免吧。<code>TryFuture</code> 类型包含了一个 blanket implementation，这使它可以通过 <code>TryFutureEx</code> trait 轻松将某些函数应用于此类 futures。</p><p>futures 0.3 中，<code>Future::poll</code> 方法会接受一个新的上下文参数。这基本上只需要调用 <code>poll</code> 方法即可完成传递（偶尔也会忽略）。</p><p>我们的依赖包依然使用了 futures 0.1，所以我们必须在两个版本的库之间转换。0.3 版本包含了一些兼容层以及其他实用工具（例如 <code>Compat01As03</code>）。我们在调用依赖关系时会用到这些。</p><p><code>wait</code> 方法已被从 <code>Future</code> trait 中移除。这是让人拍手称快的变化，因为该方法确实够反人性，而且本身可以用 <code>.await</code> 或 <code>executor::block_on</code> 代替（需要注意的是后者可能会阻断整个进程，而并不只是当前执行的 future）。</p><h2>Pin</h2><p>futures 0.3 中， <code><a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fdoc.rust-lang.org%252Fnightly%252Fstd%252Fpin%252Findex.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Pin</a></code> 是一个频繁使用的类型， <code>Future::poll</code> 方法签名的 <code>self</code> 类型对其尤为青睐。除了对这些签名进行一些机械性的处理之外，我还得借助于 <code>Pin::get_unchecked_mut</code> 与 <code>Pin::new_unchecked</code> 这两种方法（均为不安全方法）对 futures 的项目字段做一些变更。</p><p>指针定位（pinning）是一个微妙又复杂的概念，我至今也不敢说自己已经掌握了多少。我能提供的最好的参考是 <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fdoc.rust-lang.org%252Fnightly%252Fstd%252Fpin%252Findex.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">std::pin docs</a>。下面是我整理的一些要点（有一些重要的细节此处不会涉及，这里本意也并非提供一个关于指针定位的教程）。</p><ul><li><code>Pin</code> 作为一个类型构造，只有用于指针类型（如 <code>Pin&lt;Box&lt;_&gt;&gt;</code>）时才会生效。</li><li>Pin 本身是一种“标识/封装”类型（有一点像 <code><a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fdoc.rust-lang.org%252Fnightly%252Fstd%252Fptr%252Fstruct.NonNull.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">NonNull</a></code>），并不是指针类型。</li><li>如果一个指针类型被“定位”了，意味着指针指向的值不可移动（当一个非拷贝对象通过数值传入，或者调用 <code>mem::swap</code> 时会发生移动）。需要注意的移动只能发生在指针被定位之前，而非之后。</li><li>如果某个类型使用了 <code>Unpin</code> trait，这意味着无论此类型移动与否都不会有任何影响。换句话说，即使指向该类型的指针没有被定位，我们也可以放心把它当作被定位的。</li><li><code>Pin</code> 与 <code>Unpin</code> 并没有置入 Rust 语言，虽然某些特性会对指针定位有间接依赖。指针定位由编译器强制执行，但编译器本身却不自知（这点非常酷，也体现了 Rust 特性系统对此类处理的强大之处）。它是这样工作的：<code>Pin&lt;P&lt;T&gt;&gt;</code> 只允许对于 <code>P</code> 的安全访问，禁止移动 <code>P</code> 指向的任何数值，除非 <code>T</code> 应用了 <code>Unpin</code>（代码编写者已宣称 <code>T</code> 并不在意是否被移动）。任何允许删除没有执行 <code>Unpin</code> 数值的操作（可变访问）都是 <code>unsafe</code> 的，且应该由程序编写者决定是否要移动任何数值，并保证之后的安全代码中不可删除任何数值。</li></ul><p>让我们回到 futures 迁移的话题上。如果你对 <code>Pin</code> 使用了不安全的方法，你就需要考虑上面的要点，以保证指针定位的稳定。<a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fdoc.rust-lang.org%252Fnightly%252Fstd%252Fpin%252Findex.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">std::pin docs</a> 提供了更多的解释。我在许多地方通过字段投射的方式为另外一个 future 调用 <code>poll</code> 方法（有时是间接的），为了达到这个目的，你需要一个已定位的指针，这也意味着能你需要结构性指针定位。如，你可以将 <code>Pin&lt;&amp;mut T&gt;</code> 字段投射至 <code>Pin&lt;&amp;mut FieldType&gt;</code>。</p><h2>函数</h2><p>迁移中比较让人不爽的一点是 futures 库里有许多函数（与类型）的名称改变了。有的名称和标准库里的通用名重复，这让用自动化的手段处理变更的难度变大。比如，<code>Async</code> 变成了 <code>Poll</code>，<code>Ok</code> 变成了 <code>ready</code>，<code>for_each</code> 变成 <code>then</code>，<code>then</code> 变成 <code>map</code>，<code>Either::A</code> 变成 <code>Either::Left</code>。</p><p>有时名称没有变化，但其代表的功能语义变了（或者两方面都变了）。一个较为普遍的变化就是 closure 函数现在会返回可以使用 <code>T</code> 类型生成数值的 future，而不会直接返回数值本身。</p><p>有许多组合子函数从 <code>Future</code> trait 移至扩展 crate 里。这个问题本身不难修复，只是有时候不容易从错误信息中判定。</p><h2>LoopFn</h2><p>0.1 版本的 futures 库包含了 <code>LoopFn</code> 这个 future 构造，用于处理多次执行某动作的 futures。<code>LoopFn</code> 在 0.3 版本中被移除，这样做的原因个人认为可能是 <code>for</code> 循环本身是 <code>async</code> 的函数，或者 streams 才是长远看来的更佳解决方案。为了让我们的迁移过程简单化，我为 futures 0.3 写了我们自己版本的 <code>LoopFn</code> future，其实大部分也都是复制粘贴的工作，加上一些调整（如处理指针定位投射）：<a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Ftikv%252Fclient-rust%252Fpull%252F41%252Fcommits%252F6353dbcfe391d66714686aafab9a49e593259dfb%2523diff-eeffc045326f81d4c46c22f225d3df90R28" class=" wrap external" target="_blank" rel="nofollow noreferrer">code</a>。后来我将几处 <code>LoopFn</code> 用法转换为 streams，对代码似乎有一定改进。</p><h2>Sink::send_all</h2><p>我们在项目中几个地方使用了 sink。我发现对于它们对迁移和 futures 相比要有难度不少，其中最麻烦的问题就是 <code>Sink::send_all</code> 结构变了。0.1 版本里，<code>Sink::send_all</code> 会获取 stream 的所有权，并在确定所有 future 都完成后返回 sink 以及 stream。0.3 版本里， <code>Sink::send_all</code> 会接受一个对 stream 的可变引用，不返回任何值。我自己写了一个 <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Ftikv%252Fclient-rust%252Fpull%252F41%252Fcommits%252F6353dbcfe391d66714686aafab9a49e593259dfb%2523diff-eeffc045326f81d4c46c22f225d3df90R68" class=" wrap external" target="_blank" rel="nofollow noreferrer">兼容层</a> 在 futures 0.3 里模拟 0.1 版本的 sink。这不是很难，但也许有更好的方式来做这件事。</p><p>大家可以在 <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Ftikv%252Fclient-rust%252Fpull%252F41" class=" wrap external" target="_blank" rel="nofollow noreferrer">这个 PR</a> 里看到整个迁移的细节。本文最初发表在 <a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fwww.ncameron.org%252Fblog%252Fmigrating-a-crate-from-futures-0-1-to-0-3%252F" class=" wrap external" target="_blank" rel="nofollow noreferrer">www.ncameron.org</a>。</p><p><b>阅读英文版原文：</b></p><a href="https://link.zhihu.com/?target=https%3A//www.ncameron.org/blog/migrating-a-crate-from-futures-0-1-to-0-3/" data-draft-node="block" data-draft-type="link-card" data-image="https://pic1.zhimg.com/v2-12cee5ba5a2a0a60b146d43606cc0b8c_ipico.jpg" data-image-width="250" data-image-height="250" class=" wrap external" target="_blank" rel="nofollow noreferrer">Migrating a crate from futures 0.1 to 0.3</a><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
