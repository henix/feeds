<p>回想<a href="https://zhuanlan.zhihu.com/p/104929162" class="internal">上一篇</a>，我们有了<b>高阶归纳类型（Higher Inductive Type）</b>和它们的运算和性质，然后大概看了一下 <code>isoToPath</code> 函数。</p><div class="highlight"><pre><code class="language-agda">{-# OPTIONS --cubical --allow-unsolved-metas #-}
module 2019-10-14-Cutt3 where
open import Cubical.Core.Everything
open import Cubical.Foundations.Prelude

open import Agda.Builtin.Nat

variable A : Set</code></pre></div><p>在文章的最后我给出了另一个 HIT 的整数定义，它是配备了像「<code>a - b</code> 等于 <code>suc a - suc b</code>」这样的路径的自然数减法的集合。</p><div class="highlight"><pre><code class="language-text">infixl 5 _⊝_
data DeltaInt : Set where
  _⊝_    : Nat -&gt; Nat -&gt; DeltaInt
  cancel : ∀ a b -&gt; a ⊝ b ≡ suc a ⊝ suc b</code></pre></div><p>问题随之而来：<b>如何证明以下命题？</b></p><div class="highlight"><pre><code class="language-text">question = ∀ a b i → cancel a b i ≡ cancel (suc a) (suc b) i</code></pre></div><p>我们可以把它画出来（我们叫它<b>「问题方形」</b>。记住它，我们很快就会用到！）：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-12de2a75773fbc2b344997fa5427b10f_b.jpg" data-caption="" data-size="normal" data-rawwidth="441" data-rawheight="562" class="origin_image zh-lightbox-thumb" width="441" data-original="https://pic4.zhimg.com/v2-12de2a75773fbc2b344997fa5427b10f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-12de2a75773fbc2b344997fa5427b10f_b.jpg" data-caption="" data-size="normal" data-rawwidth="441" data-rawheight="562" class="origin_image zh-lightbox-thumb lazy" width="441" data-original="https://pic4.zhimg.com/v2-12de2a75773fbc2b344997fa5427b10f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-12de2a75773fbc2b344997fa5427b10f_b.jpg"/></figure><p>（注意我们用 <code>ssa</code> 来表示 <code>suc (suc a)</code>，用 <code>sa</code> 表示 <code>suc a</code> 以节省图中的空间，<code>b</code> 也是同样的简写）</p><p>问题方形中涉及三个不同的端点值，因而无法用我们已知的三种运算（<code>∧</code>、<code>∨</code> 和 <code>~</code>）把它构造出来，这三种运算基本上只是把一条路径「扩张」成了方形，而我们的新方形是有几条路径组合而成的。</p><blockquote>换言之，前面的方形是由一条线扫出来的，而这个没盖子的方形是由三条线首尾相接连出来的。</blockquote><p>为此我们需要另一种运算——<code>hcomp</code>，它是<b>齐次组合（Homogeneous Composition）</b>的简写。</p><h2>齐次组合</h2><p>在我读过的立方类型论教程中，<code>hcomp</code> 运算符是通过「Kan 运算（Kan operation）」 「Kan-填充运算（Kan-filling operation）」这样可怕的术语来描述的。它们也试图将该运算描述为：</p><blockquote><b>一个开方形（open square）的组合</b></blockquote><p>或：</p><blockquote><b>得到开方形的盖子（cap）</b></blockquote><p>或类似的东西。我读过这些句子，但从未真正理解 <code>hcomp</code> 应该传入什么参数。我找到的唯一还算可读的是 Anders 基于 cubicaltt 的教程。cubicaltt 是一个实现了立方类型论的最小依赖类型语言，但它也只是 cubicaltt，并不是 Agda。</p><p>下面是我对 <code>hcomp</code> 的介绍，我希望你们能够理解它。</p><h2>方形</h2><p>首先，想象三条路径 <code>p</code>、<code>q</code> 和 <code>r</code>：</p><div class="highlight"><pre><code class="language-text">module SquareHcomp
  (a b c d : A)
  (p : a ≡ b)
  (q : a ≡ c)
  (r : b ≡ d)
where</code></pre></div><p>使用 <code>hcomp</code> 运算，我们可以从给定的三条路径获得路径 <code>c ≡ d</code>（<code>hcomp</code> 如此设计的原因超出了本文讨论的范围）。</p><p>下面是一个 <code>hcomp</code> 的具体例子，我会写出它的代码并画出对应的图（你可以看一眼），然后告诉你如何阅读它们（不过现请先<b>不要</b>深入语法细节）。我们先从它的图像开始，对它有个直观的理解，然后再回到 Agda 具体的语法上来。</p><p>代码：</p><div class="highlight"><pre><code class="language-text">newPath : c ≡ d
newPath i = hcomp (λ j -&gt; λ
  { (i = i0) -&gt; q j
  ; (i = i1) -&gt; r j
  }) (p i)</code></pre></div><p>其语法的解释（本文剩下的部分并不依赖本段，是否阅读请自行斟酌）： 我们编写了一个函数，它对形参 <code>i</code> 进行模式匹配，并返回一个表达式。该表达式以两个参数调用了 <code>hcomp</code>：第一个参数是一个 λ-表达式，它接受一个参数 <code>j</code>，返回另一个特殊的 λ-表达式，它看起来像一个模式匹配 λ（我们称之为「系统（system）」），但并不相同；另一个参数则是 <code>p i</code>。</p><p>不要去看 <code>hcomp</code> 的函数签名，因为目前并无帮助（我知道你很好奇，但请不要看它）。</p><p>图像：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-e9294305e0686173a1831bad1bca744f_b.jpg" data-caption="" data-size="normal" data-rawwidth="457" data-rawheight="451" class="origin_image zh-lightbox-thumb" width="457" data-original="https://pic4.zhimg.com/v2-e9294305e0686173a1831bad1bca744f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-e9294305e0686173a1831bad1bca744f_b.jpg" data-caption="" data-size="normal" data-rawwidth="457" data-rawheight="451" class="origin_image zh-lightbox-thumb lazy" width="457" data-original="https://pic4.zhimg.com/v2-e9294305e0686173a1831bad1bca744f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-e9294305e0686173a1831bad1bca744f_b.jpg"/></figure><p>上图中的虚线就是我们的 <code>newPath</code>，它的间点由 <code>hcomp</code> 构造。注意图中标出了 <code>q j</code>、<code>r j</code> 和 <code>p i</code> 所对应的路径。</p><p>现在暂且先忘掉前面的语法吧，我们来看图。<code>hcomp</code> 运算接受三条路径并返回一条路径。我们把这个由三条给定的路径构成的不完整方形叫做 <b>开图形（open shape）</b>，在这里它是二维的，因此我们也叫它<b>开方形（open square）</b>。注意三条路径是首尾相连的（「首尾相连」的意思是有一个公共端点），这样才能构成一个开图形。<code><b>hcomp</b></code> <b>所做的就是把开图形缺失的部分盖上</b>，而这里它是一个方形，因此 <code>hcomp</code> 给出的就是开方形顶部缺失的路径。</p><p>这看起来很简单，但之所以简单只是因为我们在处理方形。如果再加一个维度呢？</p><p><code>hcomp</code> 实际上可用于任意维度。记住 <code>hcomp</code> 所做的就是把开图形缺失的部分给盖上，而由于它是一个开<b>立方体（cube）</b>（带有五个给定的方形），因此 <code>hcomp</code> 可以给出顶部缺失的<b>方形</b>！因此，如果我们想要一个拥有特定四个端点的方形，那么可以找出一个开立方体，它缺失的盖子刚好拥有这四个端点，然后用 <code>hcomp</code> 来得到想要的方形！</p><p>回忆问题方形，它的四个顶点是已知的，因此我们可以把它想象成一个立方体的方形盖子。该立方体共有 8 个端点和 6 个面，其中：</p><ul><li>顶面的四个端点由问题方形构成</li><li>底面的四个端点我们可自由选择</li><li>顶部的方形是我们所求的，即 <code>hcomp</code> 的输出</li><li>另外五个方形则是 <code>hcomp</code> 的输入</li></ul><p><b>我们需要选出四个特定的底面的端点，让五个输入方形能足够简单地构造出来。</b>「足够简单」的意思是「可通过已知路径以及运算 <code>∧</code>、<code>∨</code> 和 <code>~</code> 来构造」。</p><p>我们先画出一个一般的立方体：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-47e9c39ae69ef83f5b67f980e0434256_b.jpg" data-caption="" data-size="normal" data-rawwidth="415" data-rawheight="417" class="content_image" width="415"/></noscript><img src="https://pic3.zhimg.com/v2-47e9c39ae69ef83f5b67f980e0434256_b.jpg" data-caption="" data-size="normal" data-rawwidth="415" data-rawheight="417" class="content_image lazy" width="415" data-actualsrc="https://pic3.zhimg.com/v2-47e9c39ae69ef83f5b67f980e0434256_b.jpg"/></figure><p>（抱歉这图画得不够好，我已经尽力了。另外 <code>i</code>、<code>j</code> 和 <code>k</code> 的方向很重要，记住路径是有方向的）</p><p>虚线边的方形是 <code>hcomp</code> 所求的。我们将 <code>a ⊝ b</code>、<code>suc a ⊝ suc b</code>、<code>suc (suc a) ⊝ suc (suc b)</code> 和 <code>suc a ⊝ suc b</code> 分别赋予问题方形 <code>question</code> 的 <code>w</code>、<code>x</code>、<code>y</code>、<code>z</code>。下面列出了赋予变量的项：</p><div class="highlight"><pre><code class="language-text">点             项
w            a ⊝ b
x        suc a ⊝ suc b
y  suc (suc a) ⊝ suc (suc b)
z        suc a ⊝ suc b</code></pre></div><p>你可以自己画出替换后的图，我并不会给出所有的中间步骤。</p><p><code>a</code>、<code>b</code>、<code>c</code>、<code>d</code> 的值有很多可行的选择，不过我在这里选择了以下组合 （为了更好地练习，你也可以选择不同的组合）：</p><div class="highlight"><pre><code class="language-text">点       项
a      a ⊝ b
b  suc a ⊝ suc b
c  suc a ⊝ suc b
d  suc a ⊝ suc b</code></pre></div><p>（注意列表中左栏中的 <code>a</code> 和 <code>b</code> 是点，而右栏中的 <code>a</code> 和 <code>b</code> 是 <code>Int</code> 的实例）</p><p>现在我们把这个立方体补完了，剩下的步骤就是填出这五个方形。我们来观察一下立方体上这五个方形的特点（强烈建议你把这个立方体画出来）：</p><div class="highlight"><pre><code class="language-text">方形     特点
abcd   max 方形
abxw    refl
bcyx   min 方形
adzw    refl
cdzy   min 方形</code></pre></div><p>注：</p><ul><li>「max 方形」表示由 <code>cancel</code> 路径构成的最大方形，「min 方形」与此类型。</li><ul><li>如果你忘记了「max 方形」的定义，请回顾本系列文章的<a href="https://zhuanlan.zhihu.com/p/103565709" class="internal">第二篇</a>。</li></ul><li>「refl」表示 <code>λ i -&gt; some-path</code>（也可以是 <code>λ i j -&gt; cancel i</code>），即一个端点也是路径的常量路径，或者是它旋转后的版本。</li></ul><p>有了这五个方形，我们的立方体可以简单地构造而成，可以说是呼之欲出了（只是还缺少顶部的方形）！</p><p>下面是最终的方形：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-82818bfa5687acc317b645e90d2b5d4f_b.jpg" data-caption="" data-size="normal" data-rawwidth="444" data-rawheight="439" class="origin_image zh-lightbox-thumb" width="444" data-original="https://pic4.zhimg.com/v2-82818bfa5687acc317b645e90d2b5d4f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-82818bfa5687acc317b645e90d2b5d4f_b.jpg" data-caption="" data-size="normal" data-rawwidth="444" data-rawheight="439" class="origin_image zh-lightbox-thumb lazy" width="444" data-original="https://pic4.zhimg.com/v2-82818bfa5687acc317b645e90d2b5d4f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-82818bfa5687acc317b645e90d2b5d4f_b.jpg"/></figure><h2>描述一个开图形</h2><p>现在是时候介绍 Agda 中 <code>hcomp</code> 的具体语法了。</p><p>一般来说，当我们调用 <code>hcomp</code> 去创建一个 n-维的路径时，函数会类似于（以二维路径为例）：</p><div class="highlight"><pre><code class="language-text">test i j = hcomp blabla</code></pre></div><p>假设上下文中已有两个间点变量。然而，我们描述的开图形还有一个维度 （记住当你需要一个路径时，<code>hcomp</code> 是一个方形，当你需要一个方形时，<code>hcomp</code> 是一个立方体，以此类推）。额外的间点变量并不在 <code>hcomp</code> 所给出的顶部缺失的图形中，但它们可以从侧面的图形中访问到。此开图形的底部与顶部缺失的图形平行，它与额外的维度彼此独立。</p><p>总而言之，<code>hcomp</code> 的参数应该有：</p><ul><li>一个底部</li><li>一个函数，它从一个间点（代表额外的维度）映射到该图形所有的侧面</li></ul><p>对于一个立方体来说，该函数应该返回四个侧面，每一个都是方形； 对于一个方形来说，它应该返回两个侧边，每一个都是路径。</p><p>我们从解释上面的 <code>newPath</code> 开始，逐步推进到问题方形（你大概需要看一下前面 <code>newPath</code> 的图片，我不想再复制一份了）。</p><div class="highlight"><pre><code class="language-text">newPath2 : c ≡ d
 newPath2 i = hcomp
       -- ^ 原始的维度
  (\ j -&gt;
  -- ^ 额外的维度
   \ { (i = i0) -&gt; q j
               --  ^^^ 路径 `a ≡ c`，从 `j = i0` 到 `j = i1`
    --  ^^^^^^ 路径 `a ≡ c` 的起点
     ; (i = i1) -&gt; r j
               --  ^^^ 路径 `b ≡ d`，从 `j = i0` 到 `j = i1`
    --  ^^^^^^ 路径 `b ≡ d` 的起点
     })
   (p i)
 -- ^^^ 底面 `a ≡ b`</code></pre></div><p>我们用模式匹配语法来描述开图形的侧面。以 <code>q j</code> 为例：</p><ul><li>路径 <code>a ≡ b</code> 为 <code>p i</code></li><li>路径 <code>a ≡ c</code> 为 <code>q j</code></li><li>当 <code>i = i0</code> 时，路径 <code>p i</code> 归约到 <code>a</code>，我们将 <code>i = i0</code> 称为 <code>p i</code> 的 <i><code>a</code>-面</i></li><li>路径 <code>q j</code> 从路径 <code>p i</code> 的 <code>a</code> 面开始（换言之就是「连接到它」）</li><li>我们用语法 <code>(i = i0) -&gt; q j</code> 来描述</li></ul><p><code>(i = i1) -&gt; r j</code> 也与此类似，这就是完整的 <code>newPath</code> 了。</p><p>有趣的事实：你可以对零维进行 <code>hcomp</code>，它就是恒等函数：</p><div class="highlight"><pre><code class="language-text">id : ∀ {ℓ} {A : Set ℓ} -&gt; A -&gt; A
id a = hcomp {φ = i0} (λ i ()) a</code></pre></div><h2>回到 <code>question</code> 上来</h2><p>我们先准备好 <code>cancel</code> 给出的 min/max 方形:</p><div class="highlight"><pre><code class="language-text">maxSq : (a b : Nat) -&gt; (i j : I) -&gt; DeltaInt
maxSq a b i j = cancel a b (i ∨ j)

minSq : (a b : Nat) -&gt; (i j : I) -&gt; DeltaInt
minSq a b i j = cancel a b (i ∧ j)</code></pre></div><p>接着实现 <code>question</code>：</p><div class="highlight"><pre><code class="language-text">questionImpl : question
questionImpl a b i j = hcomp
  (λ k -&gt; λ -- the extra dimension
  { (i = i0) -&gt; cancel a b j
  -- ^ 当 `i = i0`，时它是左侧的方形 adzw
  ; (i = i1) -&gt; minSq (suc a) (suc b) j k
  -- ^ 当 `i = i1`，时它是右侧的方形 bcyx
  ; (j = i0) -&gt; cancel a b i
  -- ^ 当 `j = i0`，时它是前面的方形 abxw
  ; (j = i1) -&gt; minSq (suc a) (suc b) i k
  -- ^ 当 `j = i1`，时它是后面的方形 cdzy
  })
  (maxSq a b i j) -- 方形 abcd</code></pre></div><p>搞定！</p><h2>传递性</h2><p>函数 <code>compPath</code>，即路径具有传递性，也是通过 <code>hcomp</code> 来证明的。<code>transitivity</code> 的类型签名为：</p><div class="highlight"><pre><code class="language-text">transitivity : {a b c : A} -&gt; a ≡ b -&gt; b ≡ c -&gt; a ≡ c</code></pre></div><p>我们从引入变量并从方形的 <code>hcomp</code> 开始：</p><div class="highlight"><pre><code class="language-text">transitivity {a = a} p q i = hcomp</code></pre></div><p>我们构造了这样一个方形：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-144a8479c7fd82f4fc2c950c241ea141_b.jpg" data-caption="" data-size="normal" data-rawwidth="444" data-rawheight="465" class="origin_image zh-lightbox-thumb" width="444" data-original="https://pic2.zhimg.com/v2-144a8479c7fd82f4fc2c950c241ea141_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-144a8479c7fd82f4fc2c950c241ea141_b.jpg" data-caption="" data-size="normal" data-rawwidth="444" data-rawheight="465" class="origin_image zh-lightbox-thumb lazy" width="444" data-original="https://pic2.zhimg.com/v2-144a8479c7fd82f4fc2c950c241ea141_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-144a8479c7fd82f4fc2c950c241ea141_b.jpg"/></figure><p>将此图翻译成 Agda 就是：</p><div class="highlight"><pre><code class="language-text">(λ j -&gt; λ
  { (i = i0) -&gt; a
  ; (i = i1) -&gt; q j
  })
 (p i)</code></pre></div><p>这样就证明传递性了！</p><h3>后记</h3><p>感谢 Anders Mörtberg 在 CMU 的 <a href="https://link.zhihu.com/?target=https%3A//hott.github.io/HoTT-2019//summer-school/" class=" wrap external" target="_blank" rel="nofollow noreferrer">HoTT 2019 Summer School</a> 上教会了我 <code>hcomp</code>。</p><p>我从 David Leduc 和 Donnacha Oisín Kidney 那收到了邮件，将他们的建议融合在了 「凉爽的 CuTT 介绍」系列文章中，他们的建议给了我很多帮助。我也非常感谢你们能阅读我的拙作！</p><p>此外，如果你正在寻找相关的资料，并且希望让我知道，也可以联系我！</p>