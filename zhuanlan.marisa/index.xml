<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Sun, 26 May 2019 20:50:29 +0800</lastBuildDate>
<item>
<title>Cubical Type Theory 实现 contributor 招募</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-25-66954600.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66954600&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hello....&lt;/p&gt;&lt;p&gt;本人正在写一个cartisian cubical type theory的实现 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/molikto/mlang&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/molikto/mlan&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt; ..&lt;/p&gt;&lt;p&gt;已经实现了基本的 MLTT, path type, 部分的 comp 和 coe, implicit arguments.&lt;/p&gt;&lt;p&gt;目前还没有 hit 和 univalance; comp, coe 也没有对 sum type 实现. 也没有 HIT 和 univalance. termination checking 和 coverage checking 也没有.&lt;/p&gt;&lt;p&gt;还很不完善, 比如 implicit arguments 和 context restriction 的实现还没有经过仔细的推敲, 所以有一些我已知但是没有解决的 bug.&lt;/p&gt;&lt;p&gt;基本的一些例子现在基本在这两个文件夹: &lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/molikto/mlang/tree/master/tests/pass&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/molikto/mlan&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;g/tree/master/tests/pass&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/molikto/mlang/tree/master/library/01_foundations&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-373df4b256abdb6bf3208b3dbaed10ed_ipico.jpg&quot; data-image-width=&quot;354&quot; data-image-height=&quot;353&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;molikto/mlang&lt;/a&gt;&lt;p&gt;其中的tests文件名可以看作部分feature的概览...&lt;/p&gt;&lt;p&gt;现在欢迎大家 contribute 实现代码...&lt;/p&gt;&lt;p&gt;如果 bug 解决的差不多了, 并且也实现了 HIT 和 univalance 之后, 就可以 contribute 库代码了 (移植 Cubical Agda 的 library). 但感觉现在还不是时候.&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;或者欢迎对 dependent type 实现有兴趣的同学去 Gitter 闲聊...&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/mlang-discuess/community%3Futm_source%3Dbadge%26utm_medium%3Dbadge%26utm_campaign%3Dpr-badge%26utm_content%3Dbadge&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gitter.im/mlang-discues&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;s/community?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/mlang-discuess/community%3Futm_source%3Dbadge%26utm_medium%3Dbadge%26utm_campaign%3Dpr-badge%26utm_content%3Dbadge&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;mlang-discuess/community&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/mlang-discuess/community%3Futm_source%3Dbadge%26utm_medium%3Dbadge%26utm_campaign%3Dpr-badge%26utm_content%3Dbadge&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;mlang-discuess/community&lt;/a&gt;&lt;/p&gt;</description>
<author>Minghao Liu</author>
<guid isPermaLink="false">2019-05-25-66954600</guid>
<pubDate>Sat, 25 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>超市买菜</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-20-66349646.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66349646&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;几天前，有个人来找我，问我：‘我这语言语法设计得怎么样？’&lt;/p&gt;&lt;p&gt;我连语法都没看，就问：‘你这语言的设计&lt;b&gt;目的&lt;/b&gt;是什么？’&lt;/p&gt;&lt;p&gt;&amp;#39;我希望设计一个语言，融合FP跟OOP，这样我可以既有FP的表达力，也有OOP的易用性&amp;#39;&lt;/p&gt;&lt;p&gt;我忍着吐槽的欲望，问：‘那你有继承吧？’&lt;/p&gt;&lt;p&gt;‘有’&lt;/p&gt;&lt;p&gt;‘那Subtyping呢？’&lt;/p&gt;&lt;p&gt;‘当然也有’&lt;/p&gt;&lt;p&gt;‘那你打算怎么做类型推导？’&lt;/p&gt;&lt;p&gt;‘Algorithm W’&lt;/p&gt;&lt;p&gt;‘你该知道，Algorithm W是靠unification做推导的，你如果有subtyping，跟Algorithm W不相容，你想好这么解了吗？’&lt;/p&gt;&lt;p&gt;‘啊。。没有’&lt;/p&gt;&lt;p&gt;其实如果答出来，还有很多相近的设计问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OOP提倡extensibility，但是FP的ADT是封闭的，无法扩展新类型 - 而Class/Object无法在类型安全且不更改以前代码的前提下扩展新的method，这个语言该怎么提高扩展性？&lt;/li&gt;&lt;li&gt;Invariant/Covariant/Contravariant/Recursive Type/Existential Universal Quantification/Module的Subtyping怎么做？&lt;/li&gt;&lt;li&gt;Ad Hoc Polymorphism呢？如果靠Typeclass，这套东西怎么跟OOP的Class System整合？如果靠implicit Coherent问题怎么解决？&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些问题不是不能解，毕竟融合FP跟OOP的语言一大推，OCaml跟Scala不说，往早说，Luca的一推paper全是这个套路，&lt;b&gt;但是问题是，当你要设计语言的时候，这些东西要先考虑清楚，而不是先去考虑语法&lt;/b&gt;。比如说Subtyping可以看F&amp;lt;:跟MLSub，Extensibility可以看MLPolyR/Data a la carte/Object Algebra。&lt;/p&gt;&lt;p&gt;另一个我想吐槽的事情，就是‘超市买菜’模型。很多人在设计语言的时候，都会有如下的思路：‘X是好的，Y是好的，Z是好的，我也刚好都需要，所以我这个语言要有X, Y, Z。’,比如上面那个人，就认为‘FP是好的，OOP是好的，我都需要，于是我去设计语法去了’&lt;/p&gt;&lt;p&gt;这样做的问题是完全没考虑到各种feature之间的互相影响-而这才是设计语言最麻烦的地方。&lt;/p&gt;&lt;p&gt;比如说，某个语言是Dynamically Typed的，但是有个叫Type Stability的概念：如果我能静态用Dataflow Analysis分析出类型，我就会用Type Directed Compilation做传统静态类型的优化。同时，我提供Type Annotation，所以如果分析不出来还可以手动加类型。&lt;/p&gt;&lt;p&gt;那好，这语言有Reference（指针），这再加上Higher Order Function，跟Dataflow Analysis很合不来，随便写点高阶的东西推不出，性能突然暴死怎么办？而Type Annotation则因为这个语言有Subtyping，同时Type Annotation选择会runtime check/convert的原因，导致没有Arrow Type，所以无法给高阶函数加Annotation，而这又恰巧是最需要的时候。。（Gradual Typing性能坑，而且他们还有Union Type，这下不止性能有问题，连做都不好做，见&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//dl.acm.org/citation.cfm%3Fid%3D3276504&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The root cause of blame: contracts for intersection and union types&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;IMO，如果设计语言，应该正好反过来：很多人都是先设计语法，然后再写实现，最后interaction管都不管听天由命的。如果是这个顺序：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先去考虑我这个语言的&lt;b&gt;目的&lt;/b&gt;是什么（提示：如果你不是GRAIL，Scratch，APL，那答案不会是‘语法’）（提示：答案九成是‘我在设计这个领域的DSL’。）&lt;/li&gt;&lt;li&gt;然后去找可以实现目的的&lt;b&gt;最小&lt;/b&gt;feature set-不可以被desugar的feature set越大，设计如上所说，越多坑，静态分析/类型推导/Partial Evaluation等操作也越难实现（要处理的case更多是一码事，不好处理的特性也是一码事（比如高阶语言不适合静态分析，指针不适合Partial Eval，Lambda Cube越往上爬越不好推类型，Subtyping更不好推等等））&lt;/li&gt;&lt;li&gt;想想看自己要实现的Pass，脑袋里面建个大概的蓝图，想想要采用啥算法，看看有没有坑（要用Dataflow analysis做分析？跟高阶函数说再见吧。HM？Subtyping不相容。想在Effectful Language里面做Dead Code Elimination？你还是高阶的？好好想想Effect Analysis怎么设计吧）&lt;/li&gt;&lt;li&gt;如果上一步发现&lt;b&gt;冲突&lt;/b&gt;，移除一定的Feature/Pass，看看能不能被啥弥补，或者直接不要，然后接着找冲突&lt;/li&gt;&lt;li&gt;好了，开始实现各种Pass吧&lt;/li&gt;&lt;li&gt;到了最后，才到实现Surface Language/Concrete Syntax/Parser/Pretty Printing/IDE Support这些外观上的东西的地步。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那才可以在第零时间发现这些特性/Pass interact的坑，也可以有个明确的目的，而不是看到啥好的特性，就往语言里面乱塞，最后做出一个跟C++一样复杂坑多又不好扩展的语言。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2019-05-20-66349646</guid>
<pubDate>Mon, 20 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>类型系统简介</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-20-65626985.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65626985&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11e1ed02fda8354157f6711554a721d4_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;类型系统是编程语言的重要组成部分，本文是对&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//lucacardelli.name/papers/typesystems.pdf&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;type system&lt;/a&gt;&lt;p&gt;的阅读笔记和梗概，强烈推荐感兴趣的同学阅读文章本身。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;h2&gt;类型系统的目的&lt;/h2&gt;&lt;p&gt;&lt;b&gt;类型系统(type system)&lt;/b&gt;的基本目标是防止程序在运行时发生类型错误。当且仅当语言运行时不存在任何形式的类型错误，那么它就是&lt;b&gt;sound&lt;/b&gt;的。soundness是类型系统研究的重要目标。&lt;/p&gt;&lt;h2&gt;对类型系统的描述&lt;/h2&gt;&lt;p&gt;描述类型系统使用的是一种符号系统，它来自于&lt;b&gt;自然推演&lt;/b&gt;(Natural Deduction)。有如下几个组成部分：&lt;/p&gt;&lt;h3&gt;Judgments&lt;/h3&gt;&lt;p&gt;Judgement是一条断言，一般具有如下形式:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+%5CIm&quot; alt=&quot;\Gamma \vdash \Im&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 表示&lt;b&gt;已知的事实&lt;/b&gt;，&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvdash&quot; alt=&quot;\vdash&quot; eeimg=&quot;1&quot;/&gt; 表示&lt;b&gt;推导出&lt;/b&gt;，&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CIm&quot; alt=&quot;\Im&quot; eeimg=&quot;1&quot;/&gt; 表示&lt;b&gt;推导的结果&lt;/b&gt;，类型断言一般用来表示变量具有指定类型。例如：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+M%3AA&quot; alt=&quot;\Gamma \vdash M:A&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;表示在类型环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 中，自由变量M具有类型A。&lt;/p&gt;&lt;p&gt;有一条常用的通用断言：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+%5Cdiamond&quot; alt=&quot;\Gamma \vdash \diamond&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;表示类型环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 是&lt;b&gt;形式良好(well formed)的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;还有一种语义： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma%2C%5C+%5CGamma%27+%5Cvdash+e&quot; alt=&quot;\Gamma,\ \Gamma&amp;#39; \vdash e&quot; eeimg=&quot;1&quot;/&gt; ,这表示了已知环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 加上一个本地环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma%27&quot; alt=&quot;\Gamma&amp;#39;&quot; eeimg=&quot;1&quot;/&gt;，可以推导出e。&lt;/p&gt;&lt;h3&gt;Type rules&lt;/h3&gt;&lt;p&gt;类型规则通过一条或多条断言来决定一条断言的正确性，一般有如下形式：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Rule%5C+name%29%5C+%5C+%28Annotations%29+%5C+%5CGamma_1+%5Cvdash+%5CIm_1+%E2%80%A6+%5CGamma_n+%5Cvdash+%5CIm_n%5C+%28Annotations%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5CIm%7D&quot; alt=&quot;\frac{\begin{gather} (Rule\ name)\ \ (Annotations) \ \Gamma_1 \vdash \Im_1 … \Gamma_n \vdash \Im_n\ (Annotations) \end{gather} }{\Gamma \vdash \Im}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;横线上方是一条或多条判断，描述了规则的&lt;b&gt;前提(premise)&lt;/b&gt;。下方只能有一个判断，描述了规则的&lt;b&gt;结论(conclusion)&lt;/b&gt;。顶部可以标注规则的名称和注释。前提的右边也可以写一些注释。&lt;/p&gt;&lt;p&gt;我们来举个例子：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+n%29%5C+%5C+%28n+%3D+0%2C%5C+1%2C%5C+%E2%80%A6%29+%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+n%3ANat%7D%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+%2B%29+%5C+%5CGamma+%5Cvdash+M%3ANat%5C+%5C+%5C+%5CGamma+%5Cvdash+N%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+M%2BN%3ANat%7D&quot; alt=&quot;\frac {\begin{gather} (Val\ n)\ \ (n = 0,\ 1,\ …) \ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash n:Nat}\ \ \  \frac {\begin{gather} (Val\ +) \ \Gamma \vdash M:Nat\ \ \ \Gamma \vdash N:Nat \end{gather} } {\Gamma \vdash M+N:Nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这个例子认为在一个行为良好的类型环境中，所有的自然数都有类型Nat，两个类型同为Nat的表达式M和N相加的结果也为一个自然数。&lt;/p&gt;&lt;p&gt;有一条基本规则：空的环境是类型良好的，不需要任何假设：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D&quot; alt=&quot;\frac{\begin{gather} (Env\ \varnothing)\ \  \end{gather} }{\varnothing \vdash \diamond}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;一系列类型规则组成的集合称为一个正式的类型系统。&lt;/p&gt;&lt;h3&gt;Type derivations&lt;/h3&gt;&lt;p&gt;&lt;b&gt;类型导出(Type derivations)&lt;/b&gt;在一个给定的类型系统中，是一颗树，它的底部的根节点和顶部的叶节点都是类型断言，且每条断言都可以由它上方的断言结合类型系统的规则直接获得。给定一个类型断言，我们可以将它放置在类型导出的根部（底部），利用类型规则一步一步向上推导，如果能够顺利推出，说明断言是合法的。&lt;/p&gt;&lt;p&gt;例如根据我们此前的规则，可以判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvarnothing+%5Cvdash+1%2B2%3ANat&quot; alt=&quot;\varnothing \vdash 1+2:Nat&quot; eeimg=&quot;1&quot;/&gt; 是否合法：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B+%5Cfrac%7B%7D%7B%5Cfrac%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D%7B%5Cvarnothing+%5Cvdash+1%3ANat%7D%7D+%5C+%5C++%5Cfrac%7B%7D%7B%5Cfrac%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D%7B%5Cvarnothing+%5Cvdash+2%3ANat%7D%7D+%7D%7B%5Cvarnothing+%5Cvdash+1+%2B+2%3A+Nat%7D&quot; alt=&quot;\frac{ \frac{}{\frac{\varnothing \vdash \diamond}{\varnothing \vdash 1:Nat}} \ \  \frac{}{\frac{\varnothing \vdash \diamond}{\varnothing \vdash 2:Nat}} }{\varnothing \vdash 1 + 2: Nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Type inference&lt;/h3&gt;&lt;p&gt;给定一个项M，如果它在类型环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 中是&lt;b&gt;良型的(well typed)&lt;/b&gt;，那么存在一个类型A可以赋给M。通过类型导出为M确定A，称为&lt;b&gt;类型推导(Type inference)&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; &lt;/h2&gt;&lt;h2&gt;基础构成&lt;/h2&gt;&lt;h3&gt;语法&lt;/h3&gt;&lt;p&gt;&lt;b&gt;一阶类型化的&lt;/b&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot; eeimg=&quot;1&quot;/&gt; &lt;b&gt;演算(first-order typed &lt;/b&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot; eeimg=&quot;1&quot;/&gt; &lt;b&gt;-calculus)&lt;/b&gt;被称作System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 。我们可以给 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot; eeimg=&quot;1&quot;/&gt; 演算添加类型注释，它的语法如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+A%2C+B+%26%3A%3A%3D%5C+types+%5C%5C+%26K%5C+%5C+%5C+%5C+K+%5Cin+Basic+%26basic%5C+types+%5C%5C+%26A+%5Crightarrow+B+%26function%5C+types+%5C%5C+M%2CN+%26%3A%3A%3D%5C+terms+%5C%5C+%26x+%26variable+%5C%5C+%26%5Clambda+x%3AA.M+%26function+%5C%5C+%26M+N+%26application+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} A, B &amp;amp;::=\ types \\ &amp;amp;K\ \ \ \ K \in Basic &amp;amp;basic\ types \\ &amp;amp;A \rightarrow B &amp;amp;function\ types \\ M,N &amp;amp;::=\ terms \\ &amp;amp;x &amp;amp;variable \\ &amp;amp;\lambda x:A.M &amp;amp;function \\ &amp;amp;M N &amp;amp;application \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;断言&lt;/h3&gt;&lt;p&gt;对于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 我们只需要三条简单的断言：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\Gamma \vdash \diamond\\ &amp;amp;\Gamma \vdash A \\ &amp;amp;\Gamma \vdash M:A \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;规则&lt;/h3&gt;&lt;p&gt;有了这三条断言，我们可以写出它的类型规则：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C++%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+x+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C%5C+x%3AA+%5Cvdash+%5Cdiamond%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Const%29%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond%5C+%5C+%5C+%5C+K+%5Cin+Basic+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+K%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Arrow%29%5C%5C+%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A+%5Crightarrow+B%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+x%29%5C%5C+%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+x%3AA%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun%29%5C%5C+%5CGamma%2C%5C+x%3AA+%5Cvdash+M%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+x%3AA.M%3AA+%5Crightarrow+B%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl%29%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Crightarrow+B%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M+N%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac{\begin{gather} (Env\ \varnothing)\\ \  \end{gather} }{\varnothing \vdash \diamond} \ \ \ \  \frac{\begin{gather} (Env\ x)\\  \Gamma \vdash A\ \ \ \ x \notin dom(\Gamma) \end{gather} }{\Gamma,\ x:A \vdash \diamond} \\ \\ &amp;amp;\frac{\begin{gather} (Type\ Const)\\ \Gamma \vdash \diamond\ \ \ \ K \in Basic \end{gather} }{\Gamma \vdash K}\ \ \ \  \frac{\begin{gather} (Type\ Arrow)\\ \Gamma \vdash A\ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash A \rightarrow B} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ x)\\ \Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash \diamond \end{gather} }{\Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash x:A}\ \ \ \  \frac{\begin{gather} (Val\ Fun)\\ \Gamma,\ x:A \vdash M:B \end{gather} }{\Gamma \vdash \lambda x:A.M:A \rightarrow B}\ \ \ \  \frac{\begin{gather} (Val\ Appl)\\ \Gamma \vdash M:A \rightarrow B\ \ \ \  \Gamma \vdash N:A \end{gather} }{\Gamma \vdash M N:B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;基础类型&lt;/h2&gt;&lt;p&gt;我们有了System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 的基础骨架后，就可以给它增加一些基础类型。&lt;/p&gt;&lt;h3&gt;Unit Type&lt;/h3&gt;&lt;p&gt;Unit Type很常见，在很多语言中它又叫&lt;code&gt;Void&lt;/code&gt;或&lt;code&gt;Null&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Unit%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Unit%7D%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Unit%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+unit%3AUnit%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Unit) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Unit}\ \ \  \frac {\begin{gather} (Val\ Unit) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash unit:Unit}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Bool Type&lt;/h3&gt;&lt;p&gt;Bool Type也很常见，它是布尔值的类型，它一般拥有一个有用的操作，即通常语言中的&lt;code&gt;if else&lt;/code&gt;语句，我们在这里称为&lt;code&gt;cond&lt;/code&gt;:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Bool%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Bool%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+True%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+true%3ABool%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+False%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+false%3ABool%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Cond%29+%5C%5C+%5CGamma+%5Cvdash+M%3ABool+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N_1%3AA+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N_2%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28if_A%5C+M%5C+then%5C+N_1%5C+else%5C+N_2%29%3AA%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Bool) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Bool} \ \ \ \   \frac {\begin{gather} (Val\ True) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash true:Bool} \ \ \ \   \frac {\begin{gather} (Val\ False) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash false:Bool} \\ \\ \frac {\begin{gather} (Val\ Cond) \\ \Gamma \vdash M:Bool \ \ \ \  \Gamma \vdash N_1:A \ \ \ \  \Gamma \vdash N_2:A \end{gather} } {\Gamma \vdash (if_A\ M\ then\ N_1\ else\ N_2):A}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;在Cond中我们需要通过下标A来告诉类型检查器，结果应该是类型A，来消除潜在的类型检查困难。&lt;/p&gt;&lt;h3&gt;Nat Type&lt;/h3&gt;&lt;p&gt;Nat Type就是自然数的类型。假设我们有0和&lt;code&gt;Succ&lt;/code&gt;，则1为&lt;code&gt;Succ 0&lt;/code&gt;，2为&lt;code&gt;Succ Succ 0&lt;/code&gt;。Nat还存在两种计算：&lt;code&gt;pred&lt;/code&gt;和&lt;code&gt;isZero&lt;/code&gt;，前者用来得到当前自然数前一位的自然数，后者用来判断自然数是否为0.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Nat%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Nat%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Zero%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+0%3ANat%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Succ%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+succ%5C+M%3ANat%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pred%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+pred%5C+M%3ANat%7D%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+IsZero%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+isZero%5C+M%3ABool%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Nat) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Nat} \ \ \ \   \frac {\begin{gather} (Val\ Zero) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash 0:Nat} \ \ \ \   \frac {\begin{gather} (Val\ Succ) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash succ\ M:Nat} \\ \\ \frac {\begin{gather} (Val\ Pred) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash pred\ M:Nat}\ \ \ \  \frac {\begin{gather} (Val\ IsZero) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash isZero\ M:Bool}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;结构类型&lt;/h2&gt;&lt;h3&gt;Product Types&lt;/h3&gt;&lt;p&gt;Product Types是一对类型，由两个类型构成，例如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1+%5Ctimes+A_2&quot; alt=&quot;A_1 \times A_2&quot; eeimg=&quot;1&quot;/&gt; 就是一个product type。这两个类型可以通过&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;second&lt;/code&gt;操作符来提取出来。通过&lt;code&gt;with&lt;/code&gt;语句，我们可以把product type解构为两个单独的变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1&quot; alt=&quot;x_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_2&quot; alt=&quot;x_2&quot; eeimg=&quot;1&quot;/&gt; ，应用在作用域N中。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Product%29%5C%5C+%5CGamma+%5Cvdash+A_1%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A_1+%5Ctimes+A_2%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pair%29%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_2%3AA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clangle+M1%2CM2+%5Crangle%3A+A_1+%5Ctimes+A_2%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+First%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2++%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+first%5C+M%3AA_1%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Second%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2++%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+second%5C+M%3AA_2%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+With%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_1%3AA_1%2C%5C+x_2%3AA_2+%5Cvdash+N%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%28with+%28x_1%3AA_1%2C+x_2%3AA_2%29+%3A%3D+M%5C+do%5C+N%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac{\begin{gather} (Type\ Product)\\ \Gamma \vdash A_1\ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash A_1 \times A_2}\ \ \ \  \frac{\begin{gather} (Val\ Pair)\\ \Gamma \vdash M_1:A_1\ \ \ \  \Gamma \vdash M_2:A_2 \end{gather} }{\Gamma \vdash \langle M1,M2 \rangle: A_1 \times A_2} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ First)\\ \Gamma \vdash M:A_1 \times A_2  \end{gather} }{\Gamma \vdash first\ M:A_1}\ \ \ \  \frac{\begin{gather} (Val\ Second)\\ \Gamma \vdash M:A_1 \times A_2  \end{gather} }{\Gamma \vdash second\ M:A_2} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ With)\\ \Gamma \vdash M:A_1 \times A_2\ \ \ \  \Gamma,\ x_1:A_1,\ x_2:A_2 \vdash N:B \end{gather} }{\Gamma \vdash (with (x_1:A_1, x_2:A_2) := M\ do\ N):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Union Types&lt;/h3&gt;&lt;p&gt;Union Types指的是结合类型。例如一个union type &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1%2BA_2&quot; alt=&quot;A_1+A_2&quot; eeimg=&quot;1&quot;/&gt; 可以认为是一个带有left标记的类型为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1&quot; alt=&quot;A_1&quot; eeimg=&quot;1&quot;/&gt; 的元素或带有right的类型为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_2&quot; alt=&quot;A_2&quot; eeimg=&quot;1&quot;/&gt; 的元素。这一标记可以由&lt;code&gt;isLeft&lt;/code&gt;和&lt;code&gt;isRight&lt;/code&gt;来进行测试，相应的类型可以由&lt;code&gt;asLeft&lt;/code&gt;或&lt;code&gt;asRight&lt;/code&gt;来提取。和之前Bool Type的Cond语句类似，&lt;code&gt;asLeft&lt;/code&gt;和&lt;code&gt;asRight&lt;/code&gt;也需要下标来帮助类型检查器进行判断。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Union%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A_1+%2B+A_2%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+inLeft%29+%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+inLeft_%7BA_2%7D+M_1%3AA_1+%2B+A_2%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+inRight%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_2%3AA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+inRight_%7BA_1%7D+M_2%3AA_1+%2B+A_2%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+isLeft%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+isLeft%5C+M%3ABool%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+isRight%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+isRight%5C+M%3ABool%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+asLeft%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+asLeft%5C+M%3AA_1%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+asRight%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+asRight%5C+M%3AA_2%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Case%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_1%3AA_1+%5Cvdash+N_1%3AB+%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_2%3AA_2+%5Cvdash+N_2%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%28case_B+M%5C+of%5C+x_1%3AA_1%5C+then%5C+N_1%5C+%7C%5C+x_2%3AA_2%5C+then%5C+N_2%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Union) \\ \Gamma \vdash A_1 \ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash A_1 + A_2} \ \ \ \  \frac {\begin{gather} (Val\ inLeft) \\ \Gamma \vdash M_1:A_1 \ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash inLeft_{A_2} M_1:A_1 + A_2} \ \ \ \  \frac {\begin{gather} (Val\ inRight) \\ \Gamma \vdash A_1 \ \ \ \  \Gamma \vdash M_2:A_2 \end{gather} }{\Gamma \vdash inRight_{A_1} M_2:A_1 + A_2} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ isLeft) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash isLeft\ M:Bool} \ \ \ \  \frac {\begin{gather} (Val\ isRight) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash isRight\ M:Bool} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ asLeft) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash asLeft\ M:A_1} \ \ \ \  \frac {\begin{gather} (Val\ asRight) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash asRight\ M:A_2} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Case) \\ \Gamma \vdash M:A_1+A_2 \ \ \ \  \Gamma,\ x_1:A_1 \vdash N_1:B \ \ \ \  \Gamma,\ x_2:A_2 \vdash N_2:B \end{gather} }{\Gamma \vdash (case_B M\ of\ x_1:A_1\ then\ N_1\ |\ x_2:A_2\ then\ N_2):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;如果&lt;code&gt;asRight&lt;/code&gt;被错误的应用在了由&lt;code&gt;isLeft&lt;/code&gt;标记的元素上，那么我们就得到了一个被捕获的异常，这个异常不属于forbidden error。因此有了union Type，我们可以定义一个典型的被捕获的错误类型：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=error_A+%3D+asRight%28inLeft_A%28unit%29%29%3AA&quot; alt=&quot;error_A = asRight(inLeft_A(unit)):A&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;我们可以用它来表示任何类型的异常。&lt;/p&gt;&lt;h3&gt;Record Types&lt;/h3&gt;&lt;p&gt;Record Types是product types的升级版，它由product types迭代而来。对于record M中的每个组成变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1+%E2%80%A6+x_2&quot; alt=&quot;x_1 … x_2&quot; eeimg=&quot;1&quot;/&gt; ，都有名称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=l_1+%E2%80%A6+l_2&quot; alt=&quot;l_1 … l_2&quot; eeimg=&quot;1&quot;/&gt; 和它绑定。与product types相似，record types也有with语句。Product types &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1+%5Ctimes+A_2&quot; alt=&quot;A_1 \times A_2&quot; eeimg=&quot;1&quot;/&gt; 在record types中可以定义为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Record%28first%3A+A_1%2C+second%3A+A_2%29&quot; alt=&quot;Record(first: A_1, second: A_2)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Record%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+Record%28l_1%3AA_1%2C+%E2%80%A6%2C+l_n%3AA_n%29%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val+Record%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1+%E2%80%A6+%5CGamma+%5Cvdash+M_n%3AA_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+record%28l_1%3DM_1%2C%E2%80%A6%2Cl_n%3DM_n%29%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%7D%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Record%5C+Select%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M.l_j%3AA_j%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Record%5C+With%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C++%5CGamma%2Cx_1%3AA_1%2C%E2%80%A6%2Cx_n%3AA_n+%5Cvdash+N%3AB+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+%28with+%28l_1%3Dx_1%3AA_1%2C%E2%80%A6%2Cl_n%3Dx_n%3AA_n%29+%3A%3D+M%5C+do%5C+N%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Record)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \end{gather}} {\Gamma \vdash Record(l_1:A_1, …, l_n:A_n)} \ \ \ \  \frac {\begin{gather} (Val Record)\ \ \ \  (l_i distinct) \\ \Gamma \vdash M_1:A_1 … \Gamma \vdash M_n:A_n \end{gather}} {\Gamma \vdash record(l_1=M_1,…,l_n=M_n):Record(l_1:A_1,…,l_n:A_n)}\\ \\ &amp;amp;\frac {\begin{gather} (Val\ Record\ Select) \\ \Gamma \vdash M:Record(l_1:A_1,…,l_n:A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M.l_j:A_j} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Record\ With) \\ \Gamma \vdash M:Record(l_1:A_1,…,l_n…A_n)\ \ \ \  \Gamma,x_1:A_1,…,x_n:A_n \vdash N:B \end{gather}} {\Gamma \vdash (with (l_1=x_1:A_1,…,l_n=x_n:A_n) := M\ do\ N):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Variant Types&lt;/h3&gt;&lt;p&gt;与recotd types和product的关系类似，variant types也由union types迭代而来。Union types &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1+%2B+A_2&quot; alt=&quot;A_1 + A_2&quot; eeimg=&quot;1&quot;/&gt; 在variant types中可以被定义为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Variant%28left%3AA_1%2C+right%3AA_2%29&quot; alt=&quot;Variant(left:A_1, right:A_2)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Variant%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+Variant%28l_1%3AA_1%2C+%E2%80%A6%2C+l_n%3AA_n%29%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_j%3AA_j+%5C+%5C+%5C+%5C++j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+variant_%7Bl_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%7D%28l_j%3DM_j%29%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%7D%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+Is%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M%5C+is%5C+l_j%3ABool%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+As%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M%5C+as%5C+l_j%3AA_j%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+Case%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C++%5CGamma%2C+x_1%3AA_1+%5Cvdash+N_1%3AB+%E2%80%A6+%5CGamma%2Cx_n%3AA_n+%5Cvdash+N_n%3AB+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+%28case_B%5C+M%5C+of%5C+l_1%3Dx_1%3AA_1%5C+then%5C+N_1%5C+%7C%E2%80%A6%7C%5C+l_n%3Dx_n%3AA_n%5C+then%5C+N_n%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Variant)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \end{gather}} {\Gamma \vdash Variant(l_1:A_1, …, l_n:A_n)} \ \ \ \  \frac {\begin{gather} (Val\ Variant)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \ \ \ \  \Gamma \vdash M_j:A_j \ \ \ \  j \in 1..n \end{gather}} {\Gamma \vdash variant_{l_1:A_1,…,l_n:A_n}(l_j=M_j):Variant(l_1:A_1,…,l_n:A_n)}\\ \\ &amp;amp;\frac {\begin{gather} (Val\ Variant\ Is) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n:A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M\ is\ l_j:Bool} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Variant\ As) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n…A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M\ as\ l_j:A_j} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Variant\ Case) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n…A_n)\ \ \ \  \Gamma, x_1:A_1 \vdash N_1:B … \Gamma,x_n:A_n \vdash N_n:B \end{gather}} {\Gamma \vdash (case_B\ M\ of\ l_1=x_1:A_1\ then\ N_1\ |…|\ l_n=x_n:A_n\ then\ N_n):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Reference Types&lt;/h3&gt;&lt;p&gt;引用类型在命令式语言中很常见，它用来包裹地址可变的元素。可以由&lt;code&gt;ref&lt;/code&gt;分配，由&lt;code&gt;assign&lt;/code&gt;更新，并由&lt;code&gt;deref&lt;/code&gt;解除。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Ref%29+%5C%5C+%5CGamma+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Ref%5C+A%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Ref%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+ref%5C+M%3ARef%5C+A%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Deref%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARef%5C+A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+deref%5C+M%3AA%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Assign%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARef%5C+A+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+M%3A%3DN%3AUnit%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Ref) \\ \Gamma \vdash A \end{gather} }{\Gamma \vdash Ref\ A} \ \ \ \   \frac {\begin{gather} (Val\ Ref) \\ \Gamma \vdash M:A \end{gather} } {\Gamma \vdash ref\ M:Ref\ A} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Deref) \\ \Gamma \vdash M:Ref\ A \end{gather} } {\Gamma \vdash deref\ M:A} \ \ \ \  \frac {\begin{gather} (Val\ Assign) \\ \Gamma \vdash M:Ref\ A \ \ \ \  \Gamma \vdash N:A \end{gather} } {\Gamma \vdash M:=N:Unit} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Recursive Types&lt;/h3&gt;&lt;p&gt;递归类型需要为环境中扩展一个&lt;b&gt;类型变量X&lt;/b&gt;。类型变量的应用形式为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu+X.A&quot; alt=&quot;\mu X.A&quot; eeimg=&quot;1&quot;/&gt; 。例如有一个树类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+%3D+unit+%2B+int+%5Ctimes+%5Calpha+%5Ctimes+%5Calpha&quot; alt=&quot;\alpha = unit + int \times \alpha \times \alpha&quot; eeimg=&quot;1&quot;/&gt; ，我们可以将等式写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+%3D+%5Ctau&quot; alt=&quot;\alpha = \tau&quot; eeimg=&quot;1&quot;/&gt; ，如果存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau&quot; alt=&quot;\tau&quot; eeimg=&quot;1&quot;/&gt; 不是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha&quot; alt=&quot;\alpha&quot; eeimg=&quot;1&quot;/&gt; ，且有唯一解使等式成立的情况。那么我们将这个解写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu+%5Calpha+.+%5Ctau&quot; alt=&quot;\mu \alpha . \tau&quot; eeimg=&quot;1&quot;/&gt; 。我们通过方式表示这个recursive type。由于在这里 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+%3D+%5Ctau&quot; alt=&quot;\alpha = \tau&quot; eeimg=&quot;1&quot;/&gt; ，那么等式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu+%5Calpha+.+%5Ctau+%3D+%5Ctau+%7B%5Cfrac+%7B%5Cmu+%5Calpha+.+%5Ctau%7D+%7B%5Calpha%7D%7D&quot; alt=&quot;\mu \alpha . \tau = \tau {\frac {\mu \alpha . \tau} {\alpha}}&quot; eeimg=&quot;1&quot;/&gt; 是成立的。我们把从左向右变换的操作称为&lt;code&gt;unfold&lt;/code&gt;，把从右向左变换的过程称为&lt;code&gt;fold&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Env%5C+X%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5C+%5C+%5C+%5C++X+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C+X+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Rec%29+%5C%5C+%5CGamma%2C+X+%5Cvdash+A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%5Cmu+X.A%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fold%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5B%5Cmu+X.A%2FX%5DA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+fold_%7B%5Cmu+X.A%7D+M%3A%5Cmu+X.A%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Unfold%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cmu+X.A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+unfold_%7B%5Cmu+X.A%7D+M%3A%5B%5Cmu+X.A+%2F+X%5D+A%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Env\ X) \\ \Gamma \vdash \diamond \ \ \ \  X \notin dom(\Gamma) \end{gather} }{\Gamma, X \vdash \diamond} \ \ \ \   \frac {\begin{gather} (Type\ Rec) \\ \Gamma, X \vdash A \end{gather} } {\Gamma \vdash \mu X.A} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Fold) \\ \Gamma \vdash M:[\mu X.A/X]A \end{gather} } {\Gamma \vdash fold_{\mu X.A} M:\mu X.A} \ \ \ \  \frac {\begin{gather} (Val\ Unfold) \\ \Gamma \vdash M:\mu X.A \end{gather} } {\Gamma \vdash unfold_{\mu X.A} M:[\mu X.A / X] A} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; &lt;/h2&gt;&lt;h2&gt;Type Parameters&lt;/h2&gt;&lt;p&gt;我们使用一种新语法来表示类型的参数： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+X.M&quot; alt=&quot;\lambda X.M&quot; eeimg=&quot;1&quot;/&gt; ，表示程序M中有类型变量X，例如对于&lt;code&gt;id&lt;/code&gt;函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+x%3AA.x&quot; alt=&quot;\lambda x:A.x&quot; eeimg=&quot;1&quot;/&gt; 就可以被写为带有类型变量的： &lt;img src=&quot;https://www.zhihu.com/equation?tex=id+%5Ctriangleq+%5Clambda+X.%5Clambda+x%3AX.x&quot; alt=&quot;id \triangleq \lambda X.\lambda x:X.x&quot; eeimg=&quot;1&quot;/&gt; ，将类型A代入X，写为&lt;code&gt;id A&lt;/code&gt;，就可以得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+x%3AA.x&quot; alt=&quot;\lambda x:A.x&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;h3&gt;Universally Quantified Types&lt;/h3&gt;&lt;p&gt;对应新的项： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+X.M&quot; alt=&quot;\lambda X.M&quot; eeimg=&quot;1&quot;/&gt; ，我们有新的&lt;b&gt;universally quantified types&lt;/b&gt;，前式可写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+X.A&quot; alt=&quot;\forall X.A&quot; eeimg=&quot;1&quot;/&gt; ，表示对于所有的X，程序体M都有类型A。例如上文中的&lt;code&gt;id&lt;/code&gt;为： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+X.X+%5Crightarrow+X&quot; alt=&quot;\forall X.X \rightarrow X&quot; eeimg=&quot;1&quot;/&gt; ，表示对于所有的X，&lt;code&gt;id X&lt;/code&gt;都有类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X+%5Crightarrow+X&quot; alt=&quot;X \rightarrow X&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;h2&gt;基础构成&lt;/h2&gt;&lt;h3&gt;语法&lt;/h3&gt;&lt;p&gt;System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; 的类型如下，由于我们有了类型参数，所以System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 中的基础类型K被去掉了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+A%2C+B+%26%3A%3A%3D%5C+types+%5C%5C+%26X+%26type%5C+variable+%5C%5C+%26A+%5Crightarrow+B+%26function%5C+type+%5C%5C+%26%5Cforall+X.A+%26universally%5C+quantified%5C+type+%5C%5C+M%2CN+%26%3A%3A%3D%5C+terms+%5C%5C+%26x+%26variable+%5C%5C+%26%5Clambda+x%3AA.M+%26function+%5C%5C+%26M+N+%26application+%5C%5C+%26%5Clambda+X.M+%26polymorphic%5C+abstraction+%5C%5C+%26M+A+%26type%5C+instantiation+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} A, B &amp;amp;::=\ types \\ &amp;amp;X &amp;amp;type\ variable \\ &amp;amp;A \rightarrow B &amp;amp;function\ type \\ &amp;amp;\forall X.A &amp;amp;universally\ quantified\ type \\ M,N &amp;amp;::=\ terms \\ &amp;amp;x &amp;amp;variable \\ &amp;amp;\lambda x:A.M &amp;amp;function \\ &amp;amp;M N &amp;amp;application \\ &amp;amp;\lambda X.M &amp;amp;polymorphic\ abstraction \\ &amp;amp;M A &amp;amp;type\ instantiation \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;断言&lt;/h3&gt;&lt;p&gt;对于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; ，断言和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 完全相同：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\Gamma \vdash \diamond\\ &amp;amp;\Gamma \vdash A \\ &amp;amp;\Gamma \vdash M:A \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;规则&lt;/h3&gt;&lt;p&gt;相比 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; 的类型环境添加了类型变量X。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C++%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+x+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C%5C+x%3AA+%5Cvdash+%5Cdiamond%7D%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5C+%5C+%5C+%5C+X+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%2C+X+%5Cvdash+%5Cdiamond%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+X%29%5C%5C+%5CGamma%27%2C+X%2C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C+X%2C+%5CGamma%27%27+%5Cvdash+X%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Arrow%29%5C%5C+%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A+%5Crightarrow+B%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Forall%29%5C%5C+%5CGamma+X%2C+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Cforall+X.A%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+x%29%5C%5C+%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+x%3AA%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun%29%5C%5C+%5CGamma%2C%5C+x%3AA+%5Cvdash+M%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+x%3AA.M%3AA+%5Crightarrow+B%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl%29%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Crightarrow+B%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M+N%3AB%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun2%29%5C%5C+%5CGamma%2C+X+%5Cvdash+M%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+X.M%3A%5Cforall+X.A%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl2%29%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cforall+X.A+%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M%5C+B+%3A+%5BB%2FX%5DA%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac{\begin{gather} (Env\ \varnothing)\\ \  \end{gather} }{\varnothing \vdash \diamond} \ \ \ \  \frac{\begin{gather} (Env\ x)\\  \Gamma \vdash A\ \ \ \ x \notin dom(\Gamma) \end{gather} }{\Gamma,\ x:A \vdash \diamond}\ \ \ \  \frac {\begin{gather} (Env\ x)\\ \Gamma \vdash \diamond \ \ \ \ X \notin dom(\Gamma) \end{gather}} {\Gamma , X \vdash \diamond} \\ \\ &amp;amp;\frac{\begin{gather} (Type\ X)\\ \Gamma&amp;#39;, X, \Gamma&amp;#39;&amp;#39; \vdash \diamond \end{gather} }{\Gamma&amp;#39;, X, \Gamma&amp;#39;&amp;#39; \vdash X}\ \ \ \  \frac{\begin{gather} (Type\ Arrow)\\ \Gamma \vdash A\ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash A \rightarrow B} \ \ \ \  \frac{\begin{gather} (Type\ Forall)\\ \Gamma X, \vdash A \end{gather} }{\Gamma \vdash \forall X.A} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ x)\\ \Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash \diamond \end{gather} }{\Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash x:A}\ \ \ \  \frac{\begin{gather} (Val\ Fun)\\ \Gamma,\ x:A \vdash M:B \end{gather} }{\Gamma \vdash \lambda x:A.M:A \rightarrow B}\ \ \ \  \frac{\begin{gather} (Val\ Appl)\\ \Gamma \vdash M:A \rightarrow B\ \ \ \  \Gamma \vdash N:A \end{gather} }{\Gamma \vdash M N:B} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ Fun2)\\ \Gamma, X \vdash M:A \end{gather} }{\Gamma \vdash \lambda X.M:\forall X.A}\ \ \ \  \frac{\begin{gather} (Val\ Appl2)\\ \Gamma \vdash M:\forall X.A \ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash M\ B : [B/X]A} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;Appl2中的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5BB%2FX%5DA&quot; alt=&quot;[B/X]A&quot; eeimg=&quot;1&quot;/&gt; 是指用B替换A中出现的X。&lt;/p&gt;&lt;h3&gt;Existentially Quantified Types&lt;/h3&gt;&lt;p&gt;与universally quantified types相反，existentially quantified types表示存在某个类型可以满足等式。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Exists%29+%5C%5C+%5CGamma%2C+X+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Cexists+X.A%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pack%29+%5C%5C+%5CGamma+%5Cvdash+%5BB%2FX%5DM%3A%5BB%2FX%5DA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28pack_%7B%5Cexists+X.A%7DX+%3D+B%5C+with%5C+M%29%3A+%5Cexists+X.A%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Open%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cexists+X.A+%5C+%5C+%5C+%5C++%5CGamma%2CX%2Cx%3AA+%5Cvdash+N%3AB+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28open_B%5C+M%5C+as%5C+X%2C+x%3AA%5C+in%5C+N%29%3AB%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Exists) \\ \Gamma, X \vdash A \end{gather} }{\Gamma \vdash \exists X.A} \ \ \ \   \frac {\begin{gather} (Val\ Pack) \\ \Gamma \vdash [B/X]M:[B/X]A \end{gather} } {\Gamma \vdash (pack_{\exists X.A}X = B\ with\ M): \exists X.A} \\ \\ \frac {\begin{gather} (Val\ Open) \\ \Gamma \vdash M:\exists X.A \ \ \ \  \Gamma,X,x:A \vdash N:B \ \ \ \  \Gamma \vdash B \end{gather} } {\Gamma \vdash (open_B\ M\ as\ X, x:A\ in\ N):B}&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于pack和open，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65626985/%5Bhttp://notebook.xyli.me/TAPL/type-system/%5D(http://notebook.xyli.me/TAPL/type-system/)&quot; class=&quot;internal&quot;&gt;这篇文章&lt;/a&gt;的解释非常详细，推荐阅读。&lt;/p&gt;&lt;h2&gt;子类型&lt;/h2&gt;&lt;p&gt;子类型的定义很简单：如果A是B的子类型，则任何A中的元素都属于B，记为： &lt;img src=&quot;https://www.zhihu.com/equation?tex=A+%3C%3A+B&quot; alt=&quot;A &amp;lt;: B&quot; eeimg=&quot;1&quot;/&gt; 。带有子类型的系统的断言如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+A+%3C%3A+B+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\Gamma \vdash \diamond\\ &amp;amp;\Gamma \vdash A \\ &amp;amp;\Gamma \vdash A &amp;lt;: B \\ &amp;amp;\Gamma \vdash M:A \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Contravariant &amp;amp; Covariant&lt;/h3&gt;&lt;p&gt;&lt;b&gt;逆变(contravariant)和协变(covariant)&lt;/b&gt;是与子类型密切相关。如果有函数类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A+%5Crightarrow+B&quot; alt=&quot;A \rightarrow B&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%27+%5Crightarrow+B%27&quot; alt=&quot;A&amp;#39; \rightarrow B&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; ，前者是后者的子类型。那么A一定接受任何A&amp;#39;，所以A&amp;#39;是A的子类型，而产生的B一定属于任何B&amp;#39;，那么B是B&amp;#39;的子类型。可以看出参数的子类型方向变化和函数整体是相反的，所以A是逆变的。而返回结果则是一致的，所以B是协变的。&lt;/p&gt;&lt;p&gt;总是出现在第奇数个箭头左边的类型是函数类型的逆变。&lt;/p&gt;&lt;p&gt;子类型可以与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; 结合，没有难以理解的部分，推荐阅读原文 。&lt;/p&gt;</description>
<author>mirone</author>
<guid isPermaLink="false">2019-05-20-65626985</guid>
<pubDate>Mon, 20 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>类型系统简介</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-14-65626985.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65626985&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11e1ed02fda8354157f6711554a721d4_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;类型系统是编程语言的重要组成部分，本文是对&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//lucacardelli.name/papers/typesystems.pdf&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;type system&lt;/a&gt;&lt;p&gt;的阅读笔记和梗概，强烈推荐感兴趣的同学阅读文章本身。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;h2&gt;类型系统的目的&lt;/h2&gt;&lt;p&gt;&lt;b&gt;类型系统(type system)&lt;/b&gt;的基本目标是防止程序在运行时发生类型错误。当且仅当语言运行时不存在任何形式的类型错误，那么它就是&lt;b&gt;sound&lt;/b&gt;的。soundness是类型系统研究的重要目标。&lt;/p&gt;&lt;h2&gt;对类型系统的描述&lt;/h2&gt;&lt;p&gt;描述类型系统使用的是一种符号系统，它来自于&lt;b&gt;自然推演&lt;/b&gt;(Natural Deduction)。有如下几个组成部分：&lt;/p&gt;&lt;h3&gt;Judgments&lt;/h3&gt;&lt;p&gt;Judgement是一条断言，一般具有如下形式:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+%5CIm&quot; alt=&quot;\Gamma \vdash \Im&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 表示&lt;b&gt;已知的事实&lt;/b&gt;，&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvdash&quot; alt=&quot;\vdash&quot; eeimg=&quot;1&quot;/&gt; 表示&lt;b&gt;推导出&lt;/b&gt;，&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CIm&quot; alt=&quot;\Im&quot; eeimg=&quot;1&quot;/&gt; 表示&lt;b&gt;推导的结果&lt;/b&gt;，类型断言一般用来表示变量具有指定类型。例如：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+M%3AA&quot; alt=&quot;\Gamma \vdash M:A&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;表示在类型环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 中，自由变量M具有类型A。&lt;/p&gt;&lt;p&gt;有一条常用的通用断言：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+%5Cdiamond&quot; alt=&quot;\Gamma \vdash \diamond&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;表示类型环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 是&lt;b&gt;形式良好(well formed)的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;还有一种语义： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma%2C%5C+%5CGamma%27+%5Cvdash+e&quot; alt=&quot;\Gamma,\ \Gamma&amp;#39; \vdash e&quot; eeimg=&quot;1&quot;/&gt; ,这表示了已知环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 加上一个本地环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma%27&quot; alt=&quot;\Gamma&amp;#39;&quot; eeimg=&quot;1&quot;/&gt;，可以推导出e。&lt;/p&gt;&lt;h3&gt;Type rules&lt;/h3&gt;&lt;p&gt;类型规则通过一条或多条断言来决定一条断言的正确性，一般有如下形式：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Rule%5C+name%29%5C+%5C+%28Annotations%29+%5C+%5CGamma_1+%5Cvdash+%5CIm_1+%E2%80%A6+%5CGamma_n+%5Cvdash+%5CIm_n%5C+%28Annotations%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5CIm%7D&quot; alt=&quot;\frac{\begin{gather} (Rule\ name)\ \ (Annotations) \ \Gamma_1 \vdash \Im_1 … \Gamma_n \vdash \Im_n\ (Annotations) \end{gather} }{\Gamma \vdash \Im}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;横线上方是一条或多条判断，描述了规则的&lt;b&gt;前提(premise)&lt;/b&gt;。下方只能有一个判断，描述了规则的&lt;b&gt;结论(conclusion)&lt;/b&gt;。顶部可以标注规则的名称和注释。前提的右边也可以写一些注释。&lt;/p&gt;&lt;p&gt;我们来举个例子：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+n%29%5C+%5C+%28n+%3D+0%2C%5C+1%2C%5C+%E2%80%A6%29+%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+n%3ANat%7D%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+%2B%29+%5C+%5CGamma+%5Cvdash+M%3ANat%5C+%5C+%5C+%5CGamma+%5Cvdash+N%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+M%2BN%3ANat%7D&quot; alt=&quot;\frac {\begin{gather} (Val\ n)\ \ (n = 0,\ 1,\ …) \ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash n:Nat}\ \ \  \frac {\begin{gather} (Val\ +) \ \Gamma \vdash M:Nat\ \ \ \Gamma \vdash N:Nat \end{gather} } {\Gamma \vdash M+N:Nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这个例子认为在一个行为良好的类型环境中，所有的自然数都有类型Nat，两个类型同为Nat的表达式M和N相加的结果也为一个自然数。&lt;/p&gt;&lt;p&gt;有一条基本规则：空的环境是类型良好的，不需要任何假设：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D&quot; alt=&quot;\frac{\begin{gather} (Env\ \varnothing)\ \  \end{gather} }{\varnothing \vdash \diamond}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;一系列类型规则组成的集合称为一个正式的类型系统。&lt;/p&gt;&lt;h3&gt;Type derivations&lt;/h3&gt;&lt;p&gt;&lt;b&gt;类型导出(Type derivations)&lt;/b&gt;在一个给定的类型系统中，是一颗树，它的底部的根节点和顶部的叶节点都是类型断言，且每条断言都可以由它上方的断言结合类型系统的规则直接获得。给定一个类型断言，我们可以将它放置在类型导出的根部（底部），利用类型规则一步一步向上推导，如果能够顺利推出，说明断言是合法的。&lt;/p&gt;&lt;p&gt;例如根据我们此前的规则，可以判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvarnothing+%5Cvdash+1%2B2%3ANat&quot; alt=&quot;\varnothing \vdash 1+2:Nat&quot; eeimg=&quot;1&quot;/&gt; 是否合法：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B+%5Cfrac%7B%7D%7B%5Cfrac%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D%7B%5Cvarnothing+%5Cvdash+1%3ANat%7D%7D+%5C+%5C++%5Cfrac%7B%7D%7B%5Cfrac%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D%7B%5Cvarnothing+%5Cvdash+2%3ANat%7D%7D+%7D%7B%5Cvarnothing+%5Cvdash+1+%2B+2%3A+Nat%7D&quot; alt=&quot;\frac{ \frac{}{\frac{\varnothing \vdash \diamond}{\varnothing \vdash 1:Nat}} \ \  \frac{}{\frac{\varnothing \vdash \diamond}{\varnothing \vdash 2:Nat}} }{\varnothing \vdash 1 + 2: Nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Type inference&lt;/h3&gt;&lt;p&gt;给定一个项M，如果它在类型环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 中是&lt;b&gt;良型的(well typed)&lt;/b&gt;，那么存在一个类型A可以赋给M。通过类型导出为M确定A，称为&lt;b&gt;类型推导(Type inference)&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; &lt;/h2&gt;&lt;h2&gt;基础构成&lt;/h2&gt;&lt;h3&gt;语法&lt;/h3&gt;&lt;p&gt;&lt;b&gt;一阶类型化的&lt;/b&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot; eeimg=&quot;1&quot;/&gt; &lt;b&gt;演算(first-order typed &lt;/b&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot; eeimg=&quot;1&quot;/&gt; &lt;b&gt;-calculus)&lt;/b&gt;被称作System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 。我们可以给 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot; eeimg=&quot;1&quot;/&gt; 演算添加类型注释，它的语法如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+A%2C+B+%26%3A%3A%3D%5C+types+%5C%5C+%26K%5C+%5C+%5C+%5C+K+%5Cin+Basic+%26basic%5C+types+%5C%5C+%26A+%5Crightarrow+B+%26function%5C+types+%5C%5C+M%2CN+%26%3A%3A%3D%5C+terms+%5C%5C+%26x+%26variable+%5C%5C+%26%5Clambda+x%3AA.M+%26function+%5C%5C+%26M+N+%26application+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} A, B &amp;amp;::=\ types \\ &amp;amp;K\ \ \ \ K \in Basic &amp;amp;basic\ types \\ &amp;amp;A \rightarrow B &amp;amp;function\ types \\ M,N &amp;amp;::=\ terms \\ &amp;amp;x &amp;amp;variable \\ &amp;amp;\lambda x:A.M &amp;amp;function \\ &amp;amp;M N &amp;amp;application \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;断言&lt;/h3&gt;&lt;p&gt;对于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 我们只需要三条简单的断言：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\Gamma \vdash \diamond\\ &amp;amp;\Gamma \vdash A \\ &amp;amp;\Gamma \vdash M:A \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;规则&lt;/h3&gt;&lt;p&gt;有了这三条断言，我们可以写出它的类型规则：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C++%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+x+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C%5C+x%3AA+%5Cvdash+%5Cdiamond%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Const%29%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond%5C+%5C+%5C+%5C+K+%5Cin+Basic+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+K%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Arrow%29%5C%5C+%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A+%5Crightarrow+B%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+x%29%5C%5C+%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+x%3AA%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun%29%5C%5C+%5CGamma%2C%5C+x%3AA+%5Cvdash+M%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+x%3AA.M%3AA+%5Crightarrow+B%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl%29%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Crightarrow+B%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M+N%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac{\begin{gather} (Env\ \varnothing)\\ \  \end{gather} }{\varnothing \vdash \diamond} \ \ \ \  \frac{\begin{gather} (Env\ x)\\  \Gamma \vdash A\ \ \ \ x \notin dom(\Gamma) \end{gather} }{\Gamma,\ x:A \vdash \diamond} \\ \\ &amp;amp;\frac{\begin{gather} (Type\ Const)\\ \Gamma \vdash \diamond\ \ \ \ K \in Basic \end{gather} }{\Gamma \vdash K}\ \ \ \  \frac{\begin{gather} (Type\ Arrow)\\ \Gamma \vdash A\ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash A \rightarrow B} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ x)\\ \Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash \diamond \end{gather} }{\Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash x:A}\ \ \ \  \frac{\begin{gather} (Val\ Fun)\\ \Gamma,\ x:A \vdash M:B \end{gather} }{\Gamma \vdash \lambda x:A.M:A \rightarrow B}\ \ \ \  \frac{\begin{gather} (Val\ Appl)\\ \Gamma \vdash M:A \rightarrow B\ \ \ \  \Gamma \vdash N:A \end{gather} }{\Gamma \vdash M N:B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;基础类型&lt;/h2&gt;&lt;p&gt;我们有了System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 的基础骨架后，就可以给它增加一些基础类型。&lt;/p&gt;&lt;h3&gt;Unit Type&lt;/h3&gt;&lt;p&gt;Unit Type很常见，在很多语言中它又叫&lt;code&gt;Void&lt;/code&gt;或&lt;code&gt;Null&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Unit%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Unit%7D%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Unit%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+unit%3AUnit%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Unit) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Unit}\ \ \  \frac {\begin{gather} (Val\ Unit) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash unit:Unit}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Bool Type&lt;/h3&gt;&lt;p&gt;Bool Type也很常见，它是布尔值的类型，它一般拥有一个有用的操作，即通常语言中的&lt;code&gt;if else&lt;/code&gt;语句，我们在这里称为&lt;code&gt;cond&lt;/code&gt;:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Bool%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Bool%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+True%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+true%3ABool%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+False%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+false%3ABool%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Cond%29+%5C%5C+%5CGamma+%5Cvdash+M%3ABool+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N_1%3AA+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N_2%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28if_A%5C+M%5C+then%5C+N_1%5C+else%5C+N_2%29%3AA%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Bool) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Bool} \ \ \ \   \frac {\begin{gather} (Val\ True) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash true:Bool} \ \ \ \   \frac {\begin{gather} (Val\ False) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash false:Bool} \\ \\ \frac {\begin{gather} (Val\ Cond) \\ \Gamma \vdash M:Bool \ \ \ \  \Gamma \vdash N_1:A \ \ \ \  \Gamma \vdash N_2:A \end{gather} } {\Gamma \vdash (if_A\ M\ then\ N_1\ else\ N_2):A}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;在Cond中我们需要通过下标A来告诉类型检查器，结果应该是类型A，来消除潜在的类型检查困难。&lt;/p&gt;&lt;h3&gt;Nat Type&lt;/h3&gt;&lt;p&gt;Nat Type就是自然数的类型。假设我们有0和&lt;code&gt;Succ&lt;/code&gt;，则1为&lt;code&gt;Succ 0&lt;/code&gt;，2为&lt;code&gt;Succ Succ 0&lt;/code&gt;。Nat还存在两种计算：&lt;code&gt;pred&lt;/code&gt;和&lt;code&gt;isZero&lt;/code&gt;，前者用来得到当前自然数前一位的自然数，后者用来判断自然数是否为0.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Nat%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Nat%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Zero%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+0%3ANat%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Succ%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+succ%5C+M%3ANat%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pred%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+pred%5C+M%3ANat%7D%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+IsZero%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+isZero%5C+M%3ABool%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Nat) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Nat} \ \ \ \   \frac {\begin{gather} (Val\ Zero) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash 0:Nat} \ \ \ \   \frac {\begin{gather} (Val\ Succ) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash succ\ M:Nat} \\ \\ \frac {\begin{gather} (Val\ Pred) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash pred\ M:Nat}\ \ \ \  \frac {\begin{gather} (Val\ IsZero) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash isZero\ M:Bool}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;结构类型&lt;/h2&gt;&lt;h3&gt;Product Types&lt;/h3&gt;&lt;p&gt;Product Types是一对类型，由两个类型构成，例如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1+%5Ctimes+A_2&quot; alt=&quot;A_1 \times A_2&quot; eeimg=&quot;1&quot;/&gt; 就是一个product type。这两个类型可以通过&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;second&lt;/code&gt;操作符来提取出来。通过&lt;code&gt;with&lt;/code&gt;语句，我们可以把product type解构为两个单独的变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1&quot; alt=&quot;x_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_2&quot; alt=&quot;x_2&quot; eeimg=&quot;1&quot;/&gt; ，应用在作用域N中。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Product%29%5C%5C+%5CGamma+%5Cvdash+A_1%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A_1+%5Ctimes+A_2%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pair%29%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_2%3AA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clangle+M1%2CM2+%5Crangle%3A+A_1+%5Ctimes+A_2%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+First%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2++%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+first%5C+M%3AA_1%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Second%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2++%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+second%5C+M%3AA_2%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+With%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_1%3AA_1%2C%5C+x_2%3AA_2+%5Cvdash+N%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%28with+%28x_1%3AA_1%2C+x_2%3AA_2%29+%3A%3D+M%5C+do%5C+N%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac{\begin{gather} (Type\ Product)\\ \Gamma \vdash A_1\ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash A_1 \times A_2}\ \ \ \  \frac{\begin{gather} (Val\ Pair)\\ \Gamma \vdash M_1:A_1\ \ \ \  \Gamma \vdash M_2:A_2 \end{gather} }{\Gamma \vdash \langle M1,M2 \rangle: A_1 \times A_2} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ First)\\ \Gamma \vdash M:A_1 \times A_2  \end{gather} }{\Gamma \vdash first\ M:A_1}\ \ \ \  \frac{\begin{gather} (Val\ Second)\\ \Gamma \vdash M:A_1 \times A_2  \end{gather} }{\Gamma \vdash second\ M:A_2} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ With)\\ \Gamma \vdash M:A_1 \times A_2\ \ \ \  \Gamma,\ x_1:A_1,\ x_2:A_2 \vdash N:B \end{gather} }{\Gamma \vdash (with (x_1:A_1, x_2:A_2) := M\ do\ N):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Union Types&lt;/h3&gt;&lt;p&gt;Union Types指的是结合类型。例如一个union type &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1%2BA_2&quot; alt=&quot;A_1+A_2&quot; eeimg=&quot;1&quot;/&gt; 可以认为是一个带有left标记的类型为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1&quot; alt=&quot;A_1&quot; eeimg=&quot;1&quot;/&gt; 的元素或带有right的类型为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_2&quot; alt=&quot;A_2&quot; eeimg=&quot;1&quot;/&gt; 的元素。这一标记可以由&lt;code&gt;isLeft&lt;/code&gt;和&lt;code&gt;isRight&lt;/code&gt;来进行测试，相应的类型可以由&lt;code&gt;asLeft&lt;/code&gt;或&lt;code&gt;asRight&lt;/code&gt;来提取。和之前Bool Type的Cond语句类似，&lt;code&gt;asLeft&lt;/code&gt;和&lt;code&gt;asRight&lt;/code&gt;也需要下标来帮助类型检查器进行判断。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Union%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A_1+%2B+A_2%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+inLeft%29+%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+inLeft_%7BA_2%7D+M_1%3AA_1+%2B+A_2%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+inRight%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_2%3AA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+inRight_%7BA_1%7D+M_2%3AA_1+%2B+A_2%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+isLeft%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+isLeft%5C+M%3ABool%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+isRight%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+isRight%5C+M%3ABool%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+asLeft%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+asLeft%5C+M%3AA_1%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+asRight%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+asRight%5C+M%3AA_2%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Case%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_1%3AA_1+%5Cvdash+N_1%3AB+%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_2%3AA_2+%5Cvdash+N_2%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%28case_B+M%5C+of%5C+x_1%3AA_1%5C+then%5C+N_1%5C+%7C%5C+x_2%3AA_2%5C+then%5C+N_2%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Union) \\ \Gamma \vdash A_1 \ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash A_1 + A_2} \ \ \ \  \frac {\begin{gather} (Val\ inLeft) \\ \Gamma \vdash M_1:A_1 \ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash inLeft_{A_2} M_1:A_1 + A_2} \ \ \ \  \frac {\begin{gather} (Val\ inRight) \\ \Gamma \vdash A_1 \ \ \ \  \Gamma \vdash M_2:A_2 \end{gather} }{\Gamma \vdash inRight_{A_1} M_2:A_1 + A_2} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ isLeft) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash isLeft\ M:Bool} \ \ \ \  \frac {\begin{gather} (Val\ isRight) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash isRight\ M:Bool} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ asLeft) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash asLeft\ M:A_1} \ \ \ \  \frac {\begin{gather} (Val\ asRight) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash asRight\ M:A_2} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Case) \\ \Gamma \vdash M:A_1+A_2 \ \ \ \  \Gamma,\ x_1:A_1 \vdash N_1:B \ \ \ \  \Gamma,\ x_2:A_2 \vdash N_2:B \end{gather} }{\Gamma \vdash (case_B M\ of\ x_1:A_1\ then\ N_1\ |\ x_2:A_2\ then\ N_2):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;如果&lt;code&gt;asRight&lt;/code&gt;被错误的应用在了由&lt;code&gt;isLeft&lt;/code&gt;标记的元素上，那么我们就得到了一个被捕获的异常，这个异常不属于forbidden error。因此有了union Type，我们可以定义一个典型的被捕获的错误类型：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=error_A+%3D+asRight%28inLeft_A%28unit%29%29%3AA&quot; alt=&quot;error_A = asRight(inLeft_A(unit)):A&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;我们可以用它来表示任何类型的异常。&lt;/p&gt;&lt;h3&gt;Record Types&lt;/h3&gt;&lt;p&gt;Record Types是product types的升级版，它由product types迭代而来。对于record M中的每个组成变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1+%E2%80%A6+x_2&quot; alt=&quot;x_1 … x_2&quot; eeimg=&quot;1&quot;/&gt; ，都有名称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=l_1+%E2%80%A6+l_2&quot; alt=&quot;l_1 … l_2&quot; eeimg=&quot;1&quot;/&gt; 和它绑定。与product types相似，record types也有with语句。Product types &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1+%5Ctimes+A_2&quot; alt=&quot;A_1 \times A_2&quot; eeimg=&quot;1&quot;/&gt; 在record types中可以定义为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Record%28first%3A+A_1%2C+second%3A+A_2%29&quot; alt=&quot;Record(first: A_1, second: A_2)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Record%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+Record%28l_1%3AA_1%2C+%E2%80%A6%2C+l_n%3AA_n%29%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val+Record%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1+%E2%80%A6+%5CGamma+%5Cvdash+M_n%3AA_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+record%28l_1%3DM_1%2C%E2%80%A6%2Cl_n%3DM_n%29%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%7D%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Record%5C+Select%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M.l_j%3AA_j%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Record%5C+With%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C++%5CGamma%2Cx_1%3AA_1%2C%E2%80%A6%2Cx_n%3AA_n+%5Cvdash+N%3AB+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+%28with+%28l_1%3Dx_1%3AA_1%2C%E2%80%A6%2Cl_n%3Dx_n%3AA_n%29+%3A%3D+M%5C+do%5C+N%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Record)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \end{gather}} {\Gamma \vdash Record(l_1:A_1, …, l_n:A_n)} \ \ \ \  \frac {\begin{gather} (Val Record)\ \ \ \  (l_i distinct) \\ \Gamma \vdash M_1:A_1 … \Gamma \vdash M_n:A_n \end{gather}} {\Gamma \vdash record(l_1=M_1,…,l_n=M_n):Record(l_1:A_1,…,l_n:A_n)}\\ \\ &amp;amp;\frac {\begin{gather} (Val\ Record\ Select) \\ \Gamma \vdash M:Record(l_1:A_1,…,l_n:A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M.l_j:A_j} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Record\ With) \\ \Gamma \vdash M:Record(l_1:A_1,…,l_n…A_n)\ \ \ \  \Gamma,x_1:A_1,…,x_n:A_n \vdash N:B \end{gather}} {\Gamma \vdash (with (l_1=x_1:A_1,…,l_n=x_n:A_n) := M\ do\ N):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Variant Types&lt;/h3&gt;&lt;p&gt;与recotd types和product的关系类似，variant types也由union types迭代而来。Union types &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1+%2B+A_2&quot; alt=&quot;A_1 + A_2&quot; eeimg=&quot;1&quot;/&gt; 在variant types中可以被定义为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Variant%28left%3AA_1%2C+right%3AA_2%29&quot; alt=&quot;Variant(left:A_1, right:A_2)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Variant%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+Variant%28l_1%3AA_1%2C+%E2%80%A6%2C+l_n%3AA_n%29%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_j%3AA_j+%5C+%5C+%5C+%5C++j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+variant_%7Bl_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%7D%28l_j%3DM_j%29%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%7D%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+Is%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M%5C+is%5C+l_j%3ABool%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+As%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M%5C+as%5C+l_j%3AA_j%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+Case%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C++%5CGamma%2C+x_1%3AA_1+%5Cvdash+N_1%3AB+%E2%80%A6+%5CGamma%2Cx_n%3AA_n+%5Cvdash+N_n%3AB+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+%28case_B%5C+M%5C+of%5C+l_1%3Dx_1%3AA_1%5C+then%5C+N_1%5C+%7C%E2%80%A6%7C%5C+l_n%3Dx_n%3AA_n%5C+then%5C+N_n%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Variant)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \end{gather}} {\Gamma \vdash Variant(l_1:A_1, …, l_n:A_n)} \ \ \ \  \frac {\begin{gather} (Val\ Variant)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \ \ \ \  \Gamma \vdash M_j:A_j \ \ \ \  j \in 1..n \end{gather}} {\Gamma \vdash variant_{l_1:A_1,…,l_n:A_n}(l_j=M_j):Variant(l_1:A_1,…,l_n:A_n)}\\ \\ &amp;amp;\frac {\begin{gather} (Val\ Variant\ Is) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n:A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M\ is\ l_j:Bool} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Variant\ As) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n…A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M\ as\ l_j:A_j} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Variant\ Case) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n…A_n)\ \ \ \  \Gamma, x_1:A_1 \vdash N_1:B … \Gamma,x_n:A_n \vdash N_n:B \end{gather}} {\Gamma \vdash (case_B\ M\ of\ l_1=x_1:A_1\ then\ N_1\ |…|\ l_n=x_n:A_n\ then\ N_n):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Reference Types&lt;/h3&gt;&lt;p&gt;引用类型在命令式语言中很常见，它用来包裹地址可变的元素。可以由&lt;code&gt;ref&lt;/code&gt;分配，由&lt;code&gt;assign&lt;/code&gt;更新，并由&lt;code&gt;deref&lt;/code&gt;解除。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Ref%29+%5C%5C+%5CGamma+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Ref%5C+A%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Ref%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+ref%5C+M%3ARef%5C+A%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Deref%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARef%5C+A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+deref%5C+M%3AA%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Assign%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARef%5C+A+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+M%3A%3DN%3AUnit%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Ref) \\ \Gamma \vdash A \end{gather} }{\Gamma \vdash Ref\ A} \ \ \ \   \frac {\begin{gather} (Val\ Ref) \\ \Gamma \vdash M:A \end{gather} } {\Gamma \vdash ref\ M:Ref\ A} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Deref) \\ \Gamma \vdash M:Ref\ A \end{gather} } {\Gamma \vdash deref\ M:A} \ \ \ \  \frac {\begin{gather} (Val\ Assign) \\ \Gamma \vdash M:Ref\ A \ \ \ \  \Gamma \vdash N:A \end{gather} } {\Gamma \vdash M:=N:Unit} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Recursive Types&lt;/h3&gt;&lt;p&gt;递归类型需要为环境中扩展一个&lt;b&gt;类型变量X&lt;/b&gt;。类型变量的应用形式为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu+X.A&quot; alt=&quot;\mu X.A&quot; eeimg=&quot;1&quot;/&gt; 。例如有一个树类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+%3D+unit+%2B+int+%5Ctimes+%5Calpha+%5Ctimes+%5Calpha&quot; alt=&quot;\alpha = unit + int \times \alpha \times \alpha&quot; eeimg=&quot;1&quot;/&gt; ，我们可以将等式写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+%3D+%5Ctau&quot; alt=&quot;\alpha = \tau&quot; eeimg=&quot;1&quot;/&gt; ，如果存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau&quot; alt=&quot;\tau&quot; eeimg=&quot;1&quot;/&gt; 不是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha&quot; alt=&quot;\alpha&quot; eeimg=&quot;1&quot;/&gt; ，且有唯一解使等式成立的情况。那么我们将这个解写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu+%5Calpha+.+%5Ctau&quot; alt=&quot;\mu \alpha . \tau&quot; eeimg=&quot;1&quot;/&gt; 。我们通过方式表示这个recursive type。由于在这里 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+%3D+%5Ctau&quot; alt=&quot;\alpha = \tau&quot; eeimg=&quot;1&quot;/&gt; ，那么等式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu+%5Calpha+.+%5Ctau+%3D+%5Ctau+%7B%5Cfrac+%7B%5Cmu+%5Calpha+.+%5Ctau%7D+%7B%5Calpha%7D%7D&quot; alt=&quot;\mu \alpha . \tau = \tau {\frac {\mu \alpha . \tau} {\alpha}}&quot; eeimg=&quot;1&quot;/&gt; 是成立的。我们把从做向右变换的操作称为&lt;code&gt;unfold&lt;/code&gt;，把从右向左变换的过程称为&lt;code&gt;fold&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Env%5C+X%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5C+%5C+%5C+%5C++X+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C+X+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Rec%29+%5C%5C+%5CGamma%2C+X+%5Cvdash+A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%5Cmu+X.A%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fold%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5B%5Cmu+X.A%2FX%5DA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+fold_%7B%5Cmu+X.A%7D+M%3A%5Cmu+X.A%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Unfold%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cmu+X.A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+unfold_%7B%5Cmu+X.A%7D+M%3A%5B%5Cmu+X.A+%2F+X%5D+A%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Env\ X) \\ \Gamma \vdash \diamond \ \ \ \  X \notin dom(\Gamma) \end{gather} }{\Gamma, X \vdash \diamond} \ \ \ \   \frac {\begin{gather} (Type\ Rec) \\ \Gamma, X \vdash A \end{gather} } {\Gamma \vdash \mu X.A} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Fold) \\ \Gamma \vdash M:[\mu X.A/X]A \end{gather} } {\Gamma \vdash fold_{\mu X.A} M:\mu X.A} \ \ \ \  \frac {\begin{gather} (Val\ Unfold) \\ \Gamma \vdash M:\mu X.A \end{gather} } {\Gamma \vdash unfold_{\mu X.A} M:[\mu X.A / X] A} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; &lt;/h2&gt;&lt;h2&gt;Type Parameters&lt;/h2&gt;&lt;p&gt;我们使用一种新语法来表示类型的参数： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+X.M&quot; alt=&quot;\lambda X.M&quot; eeimg=&quot;1&quot;/&gt; ，表示程序M中有类型变量X，例如对于&lt;code&gt;id&lt;/code&gt;函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+x%3AA.x&quot; alt=&quot;\lambda x:A.x&quot; eeimg=&quot;1&quot;/&gt; 就可以被写为带有类型变量的： &lt;img src=&quot;https://www.zhihu.com/equation?tex=id+%5Ctriangleq+%5Clambda+X.%5Clambda+x%3AX.x&quot; alt=&quot;id \triangleq \lambda X.\lambda x:X.x&quot; eeimg=&quot;1&quot;/&gt; ，将类型A代入X，写为&lt;code&gt;id A&lt;/code&gt;，就可以得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+x%3AA.x&quot; alt=&quot;\lambda x:A.x&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;h3&gt;Universally Quantified Types&lt;/h3&gt;&lt;p&gt;对应新的项： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+X.M&quot; alt=&quot;\lambda X.M&quot; eeimg=&quot;1&quot;/&gt; ，我们有新的&lt;b&gt;universally quantified types&lt;/b&gt;，前式可写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+X.A&quot; alt=&quot;\forall X.A&quot; eeimg=&quot;1&quot;/&gt; ，表示对于所有的X，程序体M都有类型A。例如上文中的&lt;code&gt;id&lt;/code&gt;为： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+X.X+%5Crightarrow+X&quot; alt=&quot;\forall X.X \rightarrow X&quot; eeimg=&quot;1&quot;/&gt; ，表示对于所有的X，&lt;code&gt;id X&lt;/code&gt;都有类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X+%5Crightarrow+X&quot; alt=&quot;X \rightarrow X&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;h2&gt;基础构成&lt;/h2&gt;&lt;h3&gt;语法&lt;/h3&gt;&lt;p&gt;System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; 的类型如下，由于我们有了类型参数，所以System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 中的基础类型K被去掉了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+A%2C+B+%26%3A%3A%3D%5C+types+%5C%5C+%26X+%26type%5C+variable+%5C%5C+%26A+%5Crightarrow+B+%26function%5C+type+%5C%5C+%26%5Cforall+X.A+%26universally%5C+quantified%5C+type+%5C%5C+M%2CN+%26%3A%3A%3D%5C+terms+%5C%5C+%26x+%26variable+%5C%5C+%26%5Clambda+x%3AA.M+%26function+%5C%5C+%26M+N+%26application+%5C%5C+%26%5Clambda+X.M+%26polymorphic%5C+abstraction+%5C%5C+%26M+A+%26type%5C+instantiation+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} A, B &amp;amp;::=\ types \\ &amp;amp;X &amp;amp;type\ variable \\ &amp;amp;A \rightarrow B &amp;amp;function\ type \\ &amp;amp;\forall X.A &amp;amp;universally\ quantified\ type \\ M,N &amp;amp;::=\ terms \\ &amp;amp;x &amp;amp;variable \\ &amp;amp;\lambda x:A.M &amp;amp;function \\ &amp;amp;M N &amp;amp;application \\ &amp;amp;\lambda X.M &amp;amp;polymorphic\ abstraction \\ &amp;amp;M A &amp;amp;type\ instantiation \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;断言&lt;/h3&gt;&lt;p&gt;对于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; ，断言和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 完全相同：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\Gamma \vdash \diamond\\ &amp;amp;\Gamma \vdash A \\ &amp;amp;\Gamma \vdash M:A \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;规则&lt;/h3&gt;&lt;p&gt;相比 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; 的类型环境添加了类型变量X。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C++%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+x+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C%5C+x%3AA+%5Cvdash+%5Cdiamond%7D%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5C+%5C+%5C+%5C+X+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%2C+X+%5Cvdash+%5Cdiamond%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+X%29%5C%5C+%5CGamma%27%2C+X%2C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C+X%2C+%5CGamma%27%27+%5Cvdash+X%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Arrow%29%5C%5C+%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A+%5Crightarrow+B%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Forall%29%5C%5C+%5CGamma+X%2C+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Cforall+X.A%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+x%29%5C%5C+%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+x%3AA%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun%29%5C%5C+%5CGamma%2C%5C+x%3AA+%5Cvdash+M%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+x%3AA.M%3AA+%5Crightarrow+B%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl%29%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Crightarrow+B%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M+N%3AB%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun2%29%5C%5C+%5CGamma%2C+X+%5Cvdash+M%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+X.M%3A%5Cforall+X.A%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl2%29%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cforall+X.A+%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M%5C+B+%3A+%5BB%2FX%5DA%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac{\begin{gather} (Env\ \varnothing)\\ \  \end{gather} }{\varnothing \vdash \diamond} \ \ \ \  \frac{\begin{gather} (Env\ x)\\  \Gamma \vdash A\ \ \ \ x \notin dom(\Gamma) \end{gather} }{\Gamma,\ x:A \vdash \diamond}\ \ \ \  \frac {\begin{gather} (Env\ x)\\ \Gamma \vdash \diamond \ \ \ \ X \notin dom(\Gamma) \end{gather}} {\Gamma , X \vdash \diamond} \\ \\ &amp;amp;\frac{\begin{gather} (Type\ X)\\ \Gamma&amp;#39;, X, \Gamma&amp;#39;&amp;#39; \vdash \diamond \end{gather} }{\Gamma&amp;#39;, X, \Gamma&amp;#39;&amp;#39; \vdash X}\ \ \ \  \frac{\begin{gather} (Type\ Arrow)\\ \Gamma \vdash A\ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash A \rightarrow B} \ \ \ \  \frac{\begin{gather} (Type\ Forall)\\ \Gamma X, \vdash A \end{gather} }{\Gamma \vdash \forall X.A} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ x)\\ \Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash \diamond \end{gather} }{\Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash x:A}\ \ \ \  \frac{\begin{gather} (Val\ Fun)\\ \Gamma,\ x:A \vdash M:B \end{gather} }{\Gamma \vdash \lambda x:A.M:A \rightarrow B}\ \ \ \  \frac{\begin{gather} (Val\ Appl)\\ \Gamma \vdash M:A \rightarrow B\ \ \ \  \Gamma \vdash N:A \end{gather} }{\Gamma \vdash M N:B} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ Fun2)\\ \Gamma, X \vdash M:A \end{gather} }{\Gamma \vdash \lambda X.M:\forall X.A}\ \ \ \  \frac{\begin{gather} (Val\ Appl2)\\ \Gamma \vdash M:\forall X.A \ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash M\ B : [B/X]A} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;Appl2中的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5BB%2FX%5DA&quot; alt=&quot;[B/X]A&quot; eeimg=&quot;1&quot;/&gt; 是指用B替换A中出现的X。&lt;/p&gt;&lt;h3&gt;Existentially Quantified Types&lt;/h3&gt;&lt;p&gt;与universally quantified types相反，existentially quantified types表示存在某个类型可以满足等式。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Exists%29+%5C%5C+%5CGamma%2C+X+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Cexists+X.A%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pack%29+%5C%5C+%5CGamma+%5Cvdash+%5BB%2FX%5DM%3A%5BB%2FX%5DA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28pack_%7B%5Cexists+X.A%7DX+%3D+B%5C+with%5C+M%29%3A+%5Cexists+X.A%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Open%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cexists+X.A+%5C+%5C+%5C+%5C++%5CGamma%2CX%2Cx%3AA+%5Cvdash+N%3AB+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28open_B%5C+M%5C+as%5C+X%2C+x%3AA%5C+in%5C+N%29%3AB%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Exists) \\ \Gamma, X \vdash A \end{gather} }{\Gamma \vdash \exists X.A} \ \ \ \   \frac {\begin{gather} (Val\ Pack) \\ \Gamma \vdash [B/X]M:[B/X]A \end{gather} } {\Gamma \vdash (pack_{\exists X.A}X = B\ with\ M): \exists X.A} \\ \\ \frac {\begin{gather} (Val\ Open) \\ \Gamma \vdash M:\exists X.A \ \ \ \  \Gamma,X,x:A \vdash N:B \ \ \ \  \Gamma \vdash B \end{gather} } {\Gamma \vdash (open_B\ M\ as\ X, x:A\ in\ N):B}&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于pack和open，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65626985/%5Bhttp://notebook.xyli.me/TAPL/type-system/%5D(http://notebook.xyli.me/TAPL/type-system/)&quot; class=&quot;internal&quot;&gt;这篇文章&lt;/a&gt;的解释非常详细，推荐阅读。&lt;/p&gt;&lt;h2&gt;子类型&lt;/h2&gt;&lt;p&gt;子类型的定义很简单：如果A是B的子类型，则任何A中的元素都属于B，记为： &lt;img src=&quot;https://www.zhihu.com/equation?tex=A+%3C%3A+B&quot; alt=&quot;A &amp;lt;: B&quot; eeimg=&quot;1&quot;/&gt; 。带有子类型的系统的断言如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+A+%3C%3A+B+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\Gamma \vdash \diamond\\ &amp;amp;\Gamma \vdash A \\ &amp;amp;\Gamma \vdash A &amp;lt;: B \\ &amp;amp;\Gamma \vdash M:A \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Contravariant &amp;amp; Covariant&lt;/h3&gt;&lt;p&gt;&lt;b&gt;逆变(contravariant)和协变(covariant)&lt;/b&gt;是与子类型密切相关。如果有函数类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A+%5Crightarrow+B&quot; alt=&quot;A \rightarrow B&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%27+%5Crightarrow+B%27&quot; alt=&quot;A&amp;#39; \rightarrow B&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; ，前者是后者的子类型。那么A一定接受任何A&amp;#39;，所以A&amp;#39;是A的子类型，而产生的B一定属于任何B&amp;#39;，那么B是B&amp;#39;的子类型。可以看出参数的子类型方向变化和函数整体是相反的，所以A是逆变的。而返回结果则是一致的，所以B是协变的。&lt;/p&gt;&lt;p&gt;总是出现在第奇数个箭头左边的类型是函数类型的逆变。&lt;/p&gt;&lt;p&gt;子类型可以与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; 结合，没有难以理解的部分，推荐阅读原文 。&lt;/p&gt;</description>
<author>mirone</author>
<guid isPermaLink="false">2019-05-14-65626985</guid>
<pubDate>Tue, 14 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>PFPL 读书笔记 2 —— 归纳定义</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-03-64552881.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64552881&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f4edfb308976de77bfa5f49c860421cc_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;归纳定义&lt;/h2&gt;&lt;p&gt;在学习编程语言的过程中，归纳定义是必不可少的工具。一个归纳定义是由各种各样 &lt;i&gt;判断&lt;/i&gt; 的推导过程形成的 &lt;i&gt;规则&lt;/i&gt; 集合组成的。判断是某个特定类别的语法对象的表达式。规则表述了一条判断有效的充分必要条件。&lt;/p&gt;&lt;h2&gt;判断&lt;/h2&gt;&lt;p&gt;判断是一个语法对象的表达式，举例来说：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5f9c554affc4db186c94c6d3224a687c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1640&quot; data-rawheight=&quot;434&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1640&quot; data-original=&quot;https://pic1.zhimg.com/v2-5f9c554affc4db186c94c6d3224a687c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5f9c554affc4db186c94c6d3224a687c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1640&quot; data-rawheight=&quot;434&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1640&quot; data-original=&quot;https://pic1.zhimg.com/v2-5f9c554affc4db186c94c6d3224a687c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5f9c554affc4db186c94c6d3224a687c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（不支持表格图又糊得要死。。）&lt;/p&gt;&lt;p&gt;一条判断表示语法对象具有某种性质或者几个语法对象直接有某种关系。这种性质或者关系被称为 &lt;i&gt;判断式&lt;/i&gt;，这里的语法对象称为这种判断形式的 &lt;i&gt;实例&lt;/i&gt;。判断式也被称为 &lt;i&gt;谓语&lt;/i&gt;，对应的实例被称为 &lt;i&gt;主语&lt;/i&gt;。我们用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a+~+J+&quot; alt=&quot; a ~ J &quot; eeimg=&quot;1&quot;/&gt; 表示断言 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; 对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 成立。不需要关心判断的主语时，用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; 来表示不确定的判断。为了能够更直观地表达，可能会使用前缀，中缀或混合词缀表示一条特定的判断。&lt;/p&gt;&lt;h2&gt;推理规则&lt;/h2&gt;&lt;p&gt;一个判断式的 &lt;i&gt;归纳定义&lt;/i&gt; 由一组规则组成。一条 &lt;i&gt;规则&lt;/i&gt; 可以表示为&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7BJ_1+~+%E2%80%A6+~++J_k%7D%7BJ%7D+%5Ctag%7B2.1%7D+%5C&quot; alt=&quot;\frac{J_1 ~ … ~  J_k}{J} \tag{2.1} \&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;在横线以上的称为这条规则的 &lt;i&gt;假设&lt;/i&gt;，横线以下的称为它的 &lt;i&gt;结论&lt;/i&gt;。如果一条规则没有假设，那么这条规则被称为 &lt;i&gt;公理&lt;/i&gt;。一条规则所表示的意思是它的假设是它的结论的 &lt;i&gt;充分条件&lt;/i&gt;：要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; ，只需要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J_1%2C%E2%80%A6%2CJ_k&quot; alt=&quot;J_1,…,J_k&quot; eeimg=&quot;1&quot;/&gt; 。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7Bzero%7D&quot; alt=&quot;\text{zero}&quot; eeimg=&quot;1&quot;/&gt; 时，它的结论永远都是成立的。一般地，可能会有多条规则拥有同样的结论，因此一条规则的结论成立不一定意味着它的假设也成立，结论可能可以由其它的规则推导出来。&lt;/p&gt;&lt;p&gt;举例来说，以下规则是一条判断 $a ~ \text{nat}$ 的归纳定义：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7D%7B%5Ctext%7Bzero%7D+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.2a%7D+%5C+&quot; alt=&quot;\frac{}{\text{zero} ~ \text{nat}} \tag{2.2a} \ &quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+~+%5Ctext%7Bnat%7D%7D%7Bsucc%28a%29+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.2b%7D+%5C&quot; alt=&quot;\frac{a ~ \text{nat}}{succ(a) ~ \text{nat}} \tag{2.2b} \&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这两条规则说明了当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7Bzero%7D&quot; alt=&quot;\text{zero}&quot; eeimg=&quot;1&quot;/&gt; 或者是另一个自然数的后继时，是一个自然数。类似地，也可以给出一棵二叉树的定义：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7D%7B%5Ctext%7Bempty%7D+~+%5Ctext%7Btree%7D%7D+%5Ctag%7B2.3a%7D+&quot; alt=&quot;\frac{}{\text{empty} ~ \text{tree}} \tag{2.3a} &quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba_1+~+%5Ctext%7Btree%7D+~~+a_2+~+%5Ctext%7Btree%7D%7D%7Bnode%28a_1%3Ba_2%29+~+%5Ctext%7Btree%7D%7D+%5Ctag%7B2.3b%7D&quot; alt=&quot;\frac{a_1 ~ \text{tree} ~~ a_2 ~ \text{tree}}{node(a_1;a_2) ~ \text{tree}} \tag{2.3b}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这两条规则说明一棵二叉树要么为空，要么两个节点都是一棵二叉树。&lt;/p&gt;&lt;p&gt;表示自然数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;/&gt;  相等的判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a%3Db&quot; alt=&quot;a=b&quot; eeimg=&quot;1&quot;/&gt; 可以定义为：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7D%7B%5Ctext%7Bzero%7D+%3D+%5Ctext%7Bzero%7D+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.4a%7D&quot; alt=&quot;\frac{}{\text{zero} = \text{zero} ~ \text{nat}} \tag{2.4a}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+%3D+b+~+%5Ctext%7Bnat%7D%7D%7Bsucc%28a%29+%3D+succ%28b%29+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.4b%7D+&quot; alt=&quot;\frac{a = b ~ \text{nat}}{succ(a) = succ(b) ~ \text{nat}} \tag{2.4b} &quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;在这些例子中我们都使用有限的形式声明了无限个规则。&lt;/p&gt;&lt;p&gt;如果有一些规则，通过这些规则可以推导出一条判断，就说这条判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; 闭合与这些规则。如果这些规则同时还是&lt;i&gt;必要&lt;/i&gt; 的，称判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; 强闭合于这些规则。&lt;/p&gt;&lt;h2&gt;推导过程&lt;/h2&gt;&lt;p&gt;要证明一条归纳定义的判断成立，只需要列出它的 &lt;i&gt;推导过程&lt;/i&gt;。推导过程从公理开始，结束于要证明的判断。它可以被看成是一棵树，一个节点的子树就是它的假设的推导过程。如果&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7BJ_1+~+%E2%80%A6+~++J_k%7D%7BJ%7D++%5C%5C&quot; alt=&quot;\frac{J_1 ~ … ~  J_k}{J}  \\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CDelta_1%2C%E2%80%A6%2C%5CDelta_k&quot; alt=&quot;\Delta_1,…,\Delta_k&quot; eeimg=&quot;1&quot;/&gt; 分别是这些假设的推导过程，可以将 $J$ 的推导过程写为 &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cfrac%7B%5CDelta_1+~+%E2%80%A6+~++%5CDelta_k%7D%7BJ%7D+%5C%5C&quot; alt=&quot; \frac{\Delta_1 ~ … ~  \Delta_k}{J} \\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;例如， &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28succ%28succ%28zero%29%29%29+~+%5Ctext%7Bnat%7D&quot; alt=&quot;succ(succ(succ(zero))) ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 的推导过程写为&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cfrac%7B%5Cfrac%7B%5Cfrac%7B%7D%7Bzero+~+%5Ctext%7Bnat%7D%7D%7D%7Bsucc%28zero%29+~+%5Ctext%7Bnat%7D%7D%7D%7Bsucc%28succ%28zero%29%29+~+%5Ctext%7Bnat%7D%7D%7D%7Bsucc%28succ%28succ%28zero%29%29%29+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.5%7D+%5C%5C&quot; alt=&quot;\frac{\frac{\frac{\frac{}{zero ~ \text{nat}}}{succ(zero) ~ \text{nat}}}{succ(succ(zero)) ~ \text{nat}}}{succ(succ(succ(zero))) ~ \text{nat}} \tag{2.5} \\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;要证明一条判断能被推导出来，只需要找到一个推导过程。主要有两种方法用于得到推导过程。一个是 &lt;i&gt;正向查询&lt;/i&gt;，从公理出发，直到推导出最终结论。另一个是 &lt;i&gt;反向查询&lt;/i&gt;，是从结论出发直到顶层的假设都为公理。正向查询维护一个判断的集合，初始为空，然后找到所有假设都在该集合中的规则，将它的结论也加入集合，直到需要推导的判断出现在这个集合中。如果一条判断是可推导的，那么这个方法总是可以找到它的推导过程，但是如果一条判断无法被推导，那么运算永远不会终止，此时无法判断它是否可以推导。反向查询则维护一个队列，初始时只有这条需要推导的判断，随后每一次操作都移除队列中的一条判断，将它的假设加入队列中，如果有多条规则可以推导出这条判断，那么需要分别执行这个过程，知道队列为空。如果一条判断是可推导的，这个方法也能找到它的推导过程，但是同样地，如果一条判断不可被推导，那么可能会有无限条规则加入到队列中，永远不会被清空。&lt;/p&gt;&lt;h2&gt;规则归纳&lt;/h2&gt;&lt;p&gt;如果当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28J_1%29%2C%E2%80%A6%2CP%28J_k%29&quot; alt=&quot;P(J_1),…,P(J_k)&quot; eeimg=&quot;1&quot;/&gt; 成立时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28J%29&quot; alt=&quot;P(J)&quot; eeimg=&quot;1&quot;/&gt; 也成立，那么称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P&quot; alt=&quot;P&quot; eeimg=&quot;1&quot;/&gt; 闭合于规则&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7BJ_1+~+%E2%80%A6+~++J_k%7D%7BJ%7D+%5C%5C&quot; alt=&quot;\frac{J_1 ~ … ~  J_k}{J} \\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;规则归纳表示如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P&quot; alt=&quot;P&quot; eeimg=&quot;1&quot;/&gt; 闭合于一些规则，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P&quot; alt=&quot;P&quot; eeimg=&quot;1&quot;/&gt; 对于任何由这些规则定义的判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; 是成立的。例如对于规则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.2%29%7D&quot; alt=&quot;\text{(2.2)}&quot; eeimg=&quot;1&quot;/&gt; 要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(a ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; ，只要证明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28zero+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(zero ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; ，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28zero+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(zero ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28a%29+~+%5Ctext%7Bnat%7D+&quot; alt=&quot;succ(a) ~ \text{nat} &quot; eeimg=&quot;1&quot;/&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28succ%28a%29+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(succ(a) ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这个与数学归纳法很像，它是规则归纳的一个特例。&lt;/p&gt;&lt;p&gt;类似地对于规则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%282.3%29&quot; alt=&quot;(2.3)&quot; eeimg=&quot;1&quot;/&gt; ，要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Btree%7D%29&quot; alt=&quot;P(a ~ \text{tree})&quot; eeimg=&quot;1&quot;/&gt; 对于任何 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Btree%7D&quot; alt=&quot;a ~ \text{tree}&quot; eeimg=&quot;1&quot;/&gt; 成立，只需要证明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28empty+~+%5Ctext%7Btree%7D%29&quot; alt=&quot;P(empty ~ \text{tree})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1&quot; alt=&quot;a_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_2&quot; alt=&quot;a_2&quot; eeimg=&quot;1&quot;/&gt; ，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1+~+%5Ctext%7Btree%7D&quot; alt=&quot;a_1 ~ \text{tree}&quot; eeimg=&quot;1&quot;/&gt; ，&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a_1+~+%5Ctext%7Btree%7D%29+&quot; alt=&quot;P(a_1 ~ \text{tree}) &quot; eeimg=&quot;1&quot;/&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_2+~+%5Ctext%7Btree%7D&quot; alt=&quot;a_2 ~ \text{tree}&quot; eeimg=&quot;1&quot;/&gt; ，&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a_2+~+%5Ctext%7Btree%7D%29&quot; alt=&quot;P(a_2 ~ \text{tree})&quot; eeimg=&quot;1&quot;/&gt; ，那么可以得出 &lt;img src=&quot;https://www.zhihu.com/equation?tex=node%28a_1%3Ba_2%29+~+%5Ctext%7Btree%7D&quot; alt=&quot;node(a_1;a_2) ~ \text{tree}&quot; eeimg=&quot;1&quot;/&gt; 与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28node%28a_1%3Ba_2%29+~+%5Ctext%7Btree%7D%29&quot; alt=&quot;P(node(a_1;a_2) ~ \text{tree})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这被称为树形归纳，也是规则归纳的一种形式。&lt;/p&gt;&lt;p&gt;用这种方法可以证明很多性质，比如：&lt;/p&gt;&lt;p&gt;&lt;b&gt;引理. &lt;/b&gt; 如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a = a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;i&gt;证明&lt;/i&gt;：根据规则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%282.4a%29&quot; alt=&quot;(2.4a)&quot; eeimg=&quot;1&quot;/&gt; ，&lt;img src=&quot;https://www.zhihu.com/equation?tex=zero+%3D+zero+~+%5Ctext%7Bnat%7D&quot; alt=&quot;zero = zero ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 。假设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a = a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; ，那么根据规则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%282.4b%29&quot; alt=&quot;(2.4b)&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28a%29+%3D+succ%28a%29+~+%5Ctext%7Bnat%7D&quot; alt=&quot;succ(a) = succ(a) ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 成立。&lt;/p&gt;&lt;p&gt;类似地也能证明如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28a_1%29+%3D+succ%28a_2%29&quot; alt=&quot;succ(a_1) = succ(a_2)&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1+%3D+a_2+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a_1 = a_2 ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;h2&gt;迭代归纳与相互归纳&lt;/h2&gt;&lt;p&gt;归纳定义经常是迭代定义的，即一条归纳定义是在另一条的基础上构成的。在迭代归纳定义中，一条规则的假设即可能是之前有定义的判断，也可以是当前定义的判断，例如定义一个自然数列表 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Blist%7D&quot; alt=&quot;a ~ \text{list}&quot; eeimg=&quot;1&quot;/&gt; ：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7D%7Bnil+~+%5Ctext%7Blist%7D%7D+%5Ctag%7B2.7a%7D&quot; alt=&quot;\frac{}{nil ~ \text{list}} \tag{2.7a}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+~+%5Ctext%7Bnat%7D+~~+b+~+%5Ctext%7Blist%7D%7D%7Bcons%28a%3Bb%29+~+%5Ctext%7Blist%7D%7D+%5Ctag%7B2.7b%7D&quot; alt=&quot;\frac{a ~ \text{nat} ~~ b ~ \text{list}}{cons(a;b) ~ \text{list}} \tag{2.7b}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;第一条假设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 是前面定义过的判断，而第二条 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Blist%7D&quot; alt=&quot;b ~ \text{list}&quot; eeimg=&quot;1&quot;/&gt; 则是当前正在定义的。&lt;/p&gt;&lt;p&gt;很多时候，有两条或者更多判断使用相互归纳的方式同时定义。相互归纳定义推导出多条判断，其中每一条判断都可能出现在其中一些规则的假设中。因为它们在定义的时候彼此依赖，所以只能同时给出它们的定义。例如定义一个自然数是奇数或者偶数：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7D%7Bzero+~+%5Ctext%7Beven%7D%7D+%5Ctag%7B2.8a%7D&quot; alt=&quot;\frac{}{zero ~ \text{even}} \tag{2.8a}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+~+%5Ctext%7Bodd%7D%7D%7Bsucc%28a%29+~+%5Ctext%7Beven%7D%7D+%5Ctag%7B2.8b%7D&quot; alt=&quot;\frac{a ~ \text{odd}}{succ(a) ~ \text{even}} \tag{2.8b}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+~+%5Ctext%7Beven%7D%7D%7Bsucc%28a%29+~+%5Ctext%7Bodd%7D%7D+%5Ctag%7B2.8c%7D&quot; alt=&quot;\frac{a ~ \text{even}}{succ(a) ~ \text{odd}} \tag{2.8c}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;类似地根据规则归纳，如果要证明对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Beven%7D&quot; alt=&quot;a ~ \text{even}&quot; eeimg=&quot;1&quot;/&gt; 有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Beven%7D%29&quot; alt=&quot;P(a ~ \text{even})&quot; eeimg=&quot;1&quot;/&gt; ，对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bodd%7D&quot; alt=&quot;a ~ \text{odd}&quot; eeimg=&quot;1&quot;/&gt; 有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bodd%7D%29&quot; alt=&quot;P(a ~ \text{odd})&quot; eeimg=&quot;1&quot;/&gt; ，只需要证明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28zero+~+%5Ctext%7Beven%7D%29&quot; alt=&quot;P(zero ~ \text{even})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bodd%7D%29&quot; alt=&quot;P(a ~ \text{odd})&quot; eeimg=&quot;1&quot;/&gt; 那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28succ%28a%29+~+%5Ctext%7Beven%7D%29&quot; alt=&quot;P(succ(a) ~ \text{even})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Beven%7D%29&quot; alt=&quot;P(a ~ \text{even})&quot; eeimg=&quot;1&quot;/&gt; 那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28succ%28a%29+~+%5Ctext%7Bodd%7D%29&quot; alt=&quot;P(succ(a) ~ \text{odd})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;举一个最简单的例子，证明 (1) 如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Beven%7D&quot; alt=&quot;a ~ \text{even}&quot; eeimg=&quot;1&quot;/&gt; 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; ，(2) 如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bodd%7D&quot; alt=&quot;a ~ \text{odd}&quot; eeimg=&quot;1&quot;/&gt; 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; ：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.2a%29%7D&quot; alt=&quot;\text{(2.2a)}&quot; eeimg=&quot;1&quot;/&gt; 显然 &lt;img src=&quot;https://www.zhihu.com/equation?tex=zero+~+%5Ctext%7Bnat%7D&quot; alt=&quot;zero ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.2b%29%7D&quot; alt=&quot;\text{(2.2b)}&quot; eeimg=&quot;1&quot;/&gt; ，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bodd%7D&quot; alt=&quot;a ~ \text{odd}&quot; eeimg=&quot;1&quot;/&gt; 时有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28a%29+~+%5Ctext%7Bnat%7D&quot; alt=&quot;succ(a) ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.2b%29%7D&quot; alt=&quot;\text{(2.2b)}&quot; eeimg=&quot;1&quot;/&gt; ，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Beven%7D&quot; alt=&quot;a ~ \text{even}&quot; eeimg=&quot;1&quot;/&gt; 时有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28a%29+~+%5Ctext%7Bnat%7D&quot; alt=&quot;succ(a) ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因此得证。&lt;/p&gt;&lt;h2&gt;用规则定义函数&lt;/h2&gt;&lt;p&gt;归纳定义也经常被用来定义函数，这时只需要给出输入与输出的对应关系，并且证明输出是由输入唯一确定的即可。例如定义一个自然数的加法 $sum(a;b;c)$，表示 $c$ 为 $a$ 与 $b$ 的和：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Bb+~+%5Ctext%7Bnat%7D%7D%7Bsum%28zero%3Bb%3Bb%29%7D%5Ctag%7B2.9a%7D&quot; alt=&quot;\frac{b ~ \text{nat}}{sum(zero;b;b)}\tag{2.9a}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Bsum%28a%3Bb%3Bc%29%7D%7Bsum%28succ%28a%29%3Bb%3Bsucc%28c%29%29%7D%5Ctag%7B2.9b%7D&quot; alt=&quot;\frac{sum(a;b;c)}{sum(succ(a);b;succ(c))}\tag{2.9b}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这两条规则定义了一个自然数的三元关系，我们需要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 是由 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;/&gt; 确定的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理.&lt;/b&gt; 对于任意的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 都存在唯一的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 符合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;&lt;i&gt;证明&lt;/i&gt;：这里的证明分为两个部分：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;（存在性）如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; ，存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;（唯一性）如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%27%29&quot; alt=&quot;sum(a;b;c&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c%3Dc%27&quot; alt=&quot;c=c&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;存在性：设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(a ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; 的含义为 对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7Bzero%7D&quot; alt=&quot;\text{zero}&quot; eeimg=&quot;1&quot;/&gt; 时，根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.9a%29%7D&quot; alt=&quot;\text{(2.9a)}&quot; eeimg=&quot;1&quot;/&gt; 显然成立，此时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c+%3D+b&quot; alt=&quot;c = b&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/li&gt;&lt;li&gt;假设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(a ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; 成立，需要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28succ%28a%29+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(succ(a) ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; 成立，即对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28succ%28a%29%3Bb%3Bc%29&quot; alt=&quot;sum(succ(a);b;c)&quot; eeimg=&quot;1&quot;/&gt; 。因为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(a ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; ，因此对于这个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;/&gt; 存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c%27&quot; alt=&quot;c&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%27%29&quot; alt=&quot;sum(a;b;c&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; 。根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.9b%29%7D+&quot; alt=&quot;\text{(2.9b)} &quot; eeimg=&quot;1&quot;/&gt; 有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28succ%28a%29%3Bb%3Bsucc%28c%27%29%29&quot; alt=&quot;sum(succ(a);b;succ(c&amp;#39;))&quot; eeimg=&quot;1&quot;/&gt; ，因此可令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c%3Dsucc%28c%27%29&quot; alt=&quot;c=succ(c&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;唯一性：我们证明如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc_1%29&quot; alt=&quot;sum(a;b;c_1)&quot; eeimg=&quot;1&quot;/&gt; 与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc_2%29&quot; alt=&quot;sum(a;b;c_2)&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1+%3D+c_2+~+%5Ctext%7Bnat%7D&quot; alt=&quot;c_1 = c_2 ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+%5Ctext%7Bzero%7D&quot; alt=&quot;a = \text{zero}&quot; eeimg=&quot;1&quot;/&gt; 时，根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.9a%29%7D+&quot; alt=&quot;\text{(2.9a)} &quot; eeimg=&quot;1&quot;/&gt; 有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1+%3D+b&quot; alt=&quot;c_1 = b&quot; eeimg=&quot;1&quot;/&gt; 与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_2+%3D+b&quot; alt=&quot;c_2 = b&quot; eeimg=&quot;1&quot;/&gt; 。根据前面的引理可得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1+%3D+c_2&quot; alt=&quot;c_1 = c_2&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/li&gt;&lt;li&gt;设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%27%3Bb%3Bc_1%27%29&quot; alt=&quot;sum(a&amp;#39;;b;c_1&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+succ%28a%27%29&quot; alt=&quot;a = succ(a&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1+%3D+succ%28c_1%27%29&quot; alt=&quot;c_1 = succ(c_1&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc_2%29&quot; alt=&quot;sum(a;b;c_2)&quot; eeimg=&quot;1&quot;/&gt; ，根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.9b%29%7D+&quot; alt=&quot;\text{(2.9b)} &quot; eeimg=&quot;1&quot;/&gt; 有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28succ%28a%27%29%3Bb%3Bsucc%28c_1%27%29%29&quot; alt=&quot;sum(succ(a&amp;#39;);b;succ(c_1&amp;#39;))&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc_1%29&quot; alt=&quot;sum(a;b;c_1)&quot; eeimg=&quot;1&quot;/&gt; ，因为它们来源于同一条规则所以 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1+%3D+c_2&quot; alt=&quot;c_1 = c_2&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;模式&lt;/h2&gt;&lt;p&gt;在一条判断中，一些参数是由另外参数决定的，这被称为判断的 &lt;i&gt;模式声明&lt;/i&gt;。例如自然数加法 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 具有模式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cforall%2C+%5Cforall%2C+%5Cexists%29&quot; alt=&quot;(\forall, \forall, \exists)&quot; eeimg=&quot;1&quot;/&gt; 。它表示对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 与任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 都存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 。如果要说明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 是唯一确定的，就写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cforall%2C%5Cforall%2C%5Cexists%21%29&quot; alt=&quot;(\forall,\forall,\exists!)&quot; eeimg=&quot;1&quot;/&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 不一定存在，写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cforall%2C%5Cforall%2C%5Cexists%5E%7B%5Cle1%7D%29&quot; alt=&quot;(\forall,\forall,\exists^{\le1})&quot; eeimg=&quot;1&quot;/&gt; ，意为对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 与任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;b&gt;最多&lt;/b&gt;存在一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;可以看到，一条判断可能同时满足多个模式声明。一般来说，全称量词修饰的参数被当做是输入，而存在量词修饰的参数当做输出。但是一般会有一个我们希望的主要的模式，一般使用等号来表达输入和输出的关系，例如重新定义加法：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+~+%5Ctext%7Bnat%7D%7D%7Ba+%2B+zero+%3D+a+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.10a%7D&quot; alt=&quot;\frac{a ~ \text{nat}}{a + zero = a ~ \text{nat}} \tag{2.10a}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+%2B+b+%3D+c+~+%5Ctext%7Bnat%7D%7D%7Ba+%2B+succ%28b%29+%3D+succ%28c%29+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.10b%7D&quot; alt=&quot;\frac{a + b = c ~ \text{nat}}{a + succ(b) = succ(c) ~ \text{nat}} \tag{2.10b}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;用这种方式表示等号右侧的参数是由左边的参数决定的。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%2B+b+%3D+c+~+%5Ctext%7Bnat%7D+&quot; alt=&quot;a + b = c ~ \text{nat} &quot; eeimg=&quot;1&quot;/&gt; 时，可以直接使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%2B+b&quot; alt=&quot;a + b&quot; eeimg=&quot;1&quot;/&gt; 来表示 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;这部分介绍了归纳定义以及它的一些使用。我们不仅可以使用归纳的方法定义一些判断，同时还可以使用归纳的方法证明它们的一些性质。其中基于自然数定义的归纳方法就是通常情况下所说的数学归纳法，另外还可以通过类似的方法把归纳法推广到任何拥有类似结构的定义，如上面提到的树形归纳和相互归纳。归纳定义也可以用来定义函数，一条判断中的一些参数可能由另一些参数决定，它们分别可以看成函数的输入与输出，这些性质决定了它符合哪些模式声明。&lt;/p&gt;</description>
<author>Means88</author>
<guid isPermaLink="false">2019-05-03-64552881</guid>
<pubDate>Fri, 03 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>下一代编程语言范式？</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-03-64492626.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64492626&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5b3d234fd8d6654988fc9ae93ea1dda4_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;前言&lt;/b&gt;&lt;/p&gt;&lt;p&gt;最近状态不太好，有点懒，啥都不想干（可能发现自己岁数大了，有点闹情绪－ －|||）。想出去玩，风太大了，电视剧和动漫也看得“呕心沥血”了，因此切换下思路，就看了看下面这篇文章。我简单念叨念叨，大家看看就好，有想法的就想一想。&lt;/p&gt;&lt;p&gt;&lt;b&gt;正题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;PL知名学者Yannis Smaragdakis教授前两天在他的主页上放了一篇挺有意思的paper draft，题目是&lt;/p&gt;&lt;blockquote&gt;“Next-Paradigm Programming Languages: &lt;br/&gt;What Will They Look Like and What Changes Will They Bring?”&lt;/blockquote&gt;&lt;p&gt;嗯，题目有点大。&lt;/p&gt;&lt;p&gt;简单介绍一下这篇文章作者的背景。&lt;/p&gt;&lt;p&gt;Yannis这个人呢，是个实用语言主义者，他以前是美国佐治亚理工的教授，后来去了马萨诸塞(UMass)做教授，貌似12年左右被希腊引进回国了，现在是雅典大学的教授。他在PL的理论和应用方面都有所涉猎，具体研究内容如下所示。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Program analysis&lt;/b&gt; (static analysis, test generation, invariant inference, symbolic execution)&lt;br/&gt;&lt;b&gt;Language mechanisms for abstraction&lt;/b&gt; (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming)&lt;br/&gt;&lt;b&gt;Languages and tools for systems&lt;/b&gt; (programming models for concurrency, language support for distributed computing, memory management and program locality)&lt;/blockquote&gt;&lt;p&gt;最近10年，Yannis主要在基础程序分析方面建树较大。他是前ACM SIGPLAN 执行委员会的成员，OOPSLA&amp;#39;16的PC Chair，TOSEM的Editor，SPLASH&amp;#39;19的GC。主页在这里：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//yanniss.github.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://yanniss.github.io&lt;/a&gt;（介绍这么多是想说，他这篇文章，尽管题目大且显而易见没有标准答案，但是还是可以看一看，想一想，引发一些思考的）&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;接下来，为了方便理解题目，我先简单介绍一下编程语言范式（Programming Paradigm）。&lt;/p&gt;&lt;p&gt;实际上，我理解编程语言的范式主要有三种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Imperative Programming (IP) 命令式编程&lt;/li&gt;&lt;li&gt;Functional Programming (FP) 函数式编程&lt;/li&gt;&lt;li&gt;Logic Programming (LP) 逻辑式编程&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;简单来说&lt;/p&gt;&lt;p&gt;&lt;b&gt;IP基于时序&lt;/b&gt;：在IP中，指令一个一个给出，用条件、循环等来控制逻辑（指令执行的顺序），同时这些逻辑通过程序变量不断修改程序状态，最终计算出结果。我觉得，尽管IP现在都是高级语言了，但是本质上并没有太脱离那种“类似汇编的，通过读取、写入等指令操作内存数据”的编程方式。也许是C语言的成功和后续历史的机缘巧合，让程序员们不断适应了这种编程方式吧。国内高等教育中接触的绝大多数编程语言都是IP的，比如Java, C, C++等。&lt;/p&gt;&lt;p&gt;&lt;b&gt;FP基于抽象：&lt;/b&gt;在FP中，逻辑（用函数来表达）可以像数据一样抽象起来，复杂的逻辑（高阶函数）可以通过操纵（传递、调用、返回）简单的逻辑（低阶函数）和数据来表达，没有了时序与状态，隐藏了计算的很多细节。不同的逻辑因为没有被时序和状态耦合在一起，程序本身模块化更强，也更利于不同逻辑被并行的处理。（我应该举个栗子的，但是我懒，见前言）&lt;/p&gt;&lt;p&gt;&lt;b&gt;LP基于表达：&lt;/b&gt;LP抽象的能力就更强了，计算细节干脆不见了。把你想表达的逻辑直观说出来就好了：如，“第三代火影的徒弟” 且 不是“女性” 且 “其徒弟也是火影” ==&amp;gt; ”自来也“。嗯，学会”与或非“，编程都不怕。 &lt;/p&gt;&lt;p&gt;总结一下就是IP强调计算的过程，而FP和LP更倾向于表达计算的目的（其中FP和LP抽象计算的方式不同）。由于IP比FP、LP对计算细节的把控能力更强，它常常能表达并实现出更高性能的计算。相应的，FP和LP因为抽象能力更好，在表达很多复杂计算时会更方便和简洁。当然，很多流行的编程语言都是将它们不同的能力结合起来设计使用的，其中IP和FP结合比较常见，例如JavaScript, Python, Scala等，Java 8之后也有一些糖化FP的改进了。至于IP、FP与LP的结合也有，但据我所知并不多。&lt;/p&gt;&lt;p&gt;我不太喜欢将”面向对象“（OO）也说成是一种单独的编程语言范式（貌似Martin Odersky也是这个观点），因为我觉得把OO加进来就很难特征鲜明地区分语言类别了（实际上OO可以分别和上述三类语言范式结合起来）。当然，讨论这个意义不大，学界也没有统一论调，你说它是也是可以的，能够方便交流就好。&lt;/p&gt;&lt;p&gt;以上是一些背景。&lt;/p&gt;&lt;p&gt;“Next-Paradigm Programming Languages”这篇文章，虽然通篇拿Datalog语言来举例子，但是我觉得其观点和很多内容也适用其它语言。文章不是特别容易理解，这里我把最核心的几个观点拿出来总结一下，按照我的理解描述一下，方便大家参考。&lt;/p&gt;&lt;p&gt;文章在介绍中就先给出了“免死金牌”，作者说：&lt;/p&gt;&lt;blockquote&gt;下一代编程语言范式可能是基于那种通过训练大规模代码实例的“机器学习或统计技术”，或者是通过符号推理和复杂约束求解的“程序生成技术”，或者是在大规模计算和存储能力下的新的“高阶语言设计技术”，或者很多其他技术...... &lt;br/&gt;但是，无论这些未来编程范式基于什么技术，作者觉得一些基本的原则是不可避免的，他这篇文章就是来阐述这些所谓的基本原则（Principles）&lt;/blockquote&gt;&lt;p&gt;嗯，作者在说，他并不是在预测下一代编程语言范式到底是什么（所以你不用因为不同意而激动），他只是根据过去20年来对编程语言研究和使用的经验，总结一些他觉得下一代编程语言范式可能需要具备的基本原则。&lt;/p&gt;&lt;p&gt;那么都有哪些原则呢？&lt;/p&gt;&lt;p&gt;原则1&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Principle 1&lt;/b&gt; (&lt;b&gt;Productivity and Performance Tied Together&lt;/b&gt;). &lt;br/&gt;If a language can give orders-of-magnitude improvements in &lt;b&gt;productivity&lt;/b&gt; then its implementation has the potential for orders-of-magnitude changes in &lt;b&gt;performance&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;作者进一步解释到&lt;/p&gt;&lt;blockquote&gt;Large variations in both productivity and performance are functions of a language being abstract. Neither is possible with the current, ultra-concrete mainstream languages. &lt;b&gt;If one needs to explicitly specify “loops and arrays”, neither large productivity gains, nor large performance variations are possible&lt;/b&gt;. Instead, the language implementation (or “compiler” for short) of a high-productivity, next-paradigm language will likely be able to effect orders-of-magnitude performance differences via dynamic or static optimization.&lt;/blockquote&gt;&lt;p&gt;我简单解释一下，作者觉得，下一代编程范式应该是侧重“高生产力”（high-productivity）的，即“编程应该是越来越容易的”，进而“编程开发效率是越来越高的”。他说如果一个编程语言让程序员显示地规定“循环和数组”应该怎么设计使用，那么这个语言既不能高效（high-productivity），也不会容许程序的性能有太大的改变空间（毕竟数据结构和执行逻辑都被程序员定死了）。&lt;/p&gt;&lt;p&gt;我个人觉得作者在这里就是剑指Imperative Programming（IP）的，他可能觉得IP的这种编程方式没法让程序员从编程中解放生产力（“生产力是编程发展的第一要素”，嗯，我从他全文中都嗅出这样的口号，虽然他没说的那么直白...）。作者觉得，编程语言应该抽象得易于使用（嗯，这里他应该是在更偏向于Functional和Logic Programming，我觉得LP更多一些），很多实现的细节应该交由以后的Compiler来自动地处理，这里的Compiler作者是一个泛指，它可能包括&lt;b&gt;interpreter&lt;/b&gt; or &lt;b&gt;compiler&lt;/b&gt; (ahead-of-time or just-int-time) and a &lt;b&gt;runtime system&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，有了下面的见解&lt;/p&gt;&lt;blockquote&gt;Programs ≠ Algorithms + Data Structures. Instead,&lt;br/&gt;Compiler(Program) = Algorithms + Data Structures&lt;/blockquote&gt;&lt;p&gt;总结一下原则1就是，下一代编程语言范式应该注重High-productivity和Convenient编程，程序的性能在当今“丰富计算能力和资源”的背景下，可以让语言实现系统本身（如上面提到的Compiler）来发挥，进而解放编程生产力。&lt;/p&gt;&lt;p&gt;原则2&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Principle 2&lt;/b&gt; (&lt;b&gt;Need For Firm Mental Grounding&lt;/b&gt;). &lt;br/&gt;The programming model of next-paradigm languages will offer strong semantic guarantees (about what code can do and how new code can affect old).&lt;/blockquote&gt;&lt;p&gt;原则2提出的背景，实际上也是基于原则1的。想象一下，一个编程语言如果使用起来高效方便，会不免依赖很多语言实现系统背后的自动化技术。这样一来，相比于传统语言编写的程序，程序的一点变动可能会变得更不可控。因此，语言和语言系统本身应该提供一下基本的Invariant和properties以让程序员在开发时对语言能做什么，改动之后有什么变化等问题有一定的了解甚至保证。&lt;/p&gt;&lt;p&gt;比如，Datalog就有很强的一种semantic invariant，那就是monotonicity。有了monotonicity，在程序中添加rules就保证不会invalidate先前rules的输出，由此，就可以通过local inspection来非常方便地理解和编写程序。下一代编程语言范式应该有更多有用的关于语言本身的semantic guarantees来支撑语言的易用性。&lt;/p&gt;&lt;p&gt;原则3&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Principle 3 &lt;/b&gt;(&lt;b&gt;Workflows Will Change&lt;/b&gt;). &lt;br/&gt;Next-paradigm programming languages will change well-established patterns in current programming workflow.&lt;/blockquote&gt;&lt;p&gt;选择什么样的编程语言实际上并不会从本质上影响传统的软件开发流程，比如需求分析，架构设计，编码实现，测试等等。然而，作者觉得，如果使用的是一个high-productivity和high-abstraction的编程语言，尽管软件开发流程整体不会受太大影响，但是这个流程的每一个环节会产生很大的变化。作者是这样解释的：&lt;/p&gt;&lt;blockquote&gt;Orders-of-magnitude productivity improvements will, very likely, disrupt the established workflow of program development&lt;b&gt;. Code will be much more terse and abstract, resembling a formal specification&lt;/b&gt;. Small changes will have a huge impact on both functionality and performance. It is hard to fully grasp precisely how today’s common practices will evolve.&lt;/blockquote&gt;&lt;p&gt;编码实现更接近于formal specification本身（开发更容易了），但是对于程序的调试、分析、测试会变得更有难度（可能更多依托于自动化技术）。不难看出，实际上原则3也是原则1的一个衍生物。我觉得作者是想说，在设计新的编程范式时，也应该考虑它对于整个软件开发过程的影响。&lt;/p&gt;&lt;p&gt;以上，就是文中系统阐述的下一代编程语言范式需要考虑的三个主要原则。&lt;/p&gt;&lt;p&gt;&lt;b&gt;我对于这篇文章的看法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;实际上，以我对作者的了解，他是倾向于将下一代编程语言范式向logic programming，比如Datalog靠拢的，毕竟他最近十多年一直在从事这方面的研究和工作。我在读博士的前几年也是用Datalog写分析器的，确实好用，把算法想清楚了，按照语言的语法语义写rules比较直观，不用纠结背后的数据结构和执行系统，把逻辑想清楚表达出来就好了。在这一方面我是支持作者观点的。&lt;/p&gt;&lt;p&gt;但是实际上也有一些弊端，比如，Datalog在表达部分逻辑时，例如universal quatification时就很不方便，需要通过negation来实现，当然，这一点是可以通过语言层面的，比如语法语义的改进来修补的。此外，因为不太明确执行Datalog的engine的执行顺序和原则，有的时候添加修改rules时会带来一些性能上的问题（虽然不多见，但是确实遇到过几次，很无奈）。如此一来，让我想到，如果程序员真的要编好这样的程序with high-producitivity，还需要理解好背后语言运行系统的执行策略，这本身就是一种对于解放编程生产力的束缚（虽然一旦摆脱了这种束缚，就有可能编的飞起...）&lt;/p&gt;&lt;p&gt;此外，我对于文中一些小的观点有些不同看法，比如Corollary 3.3关于Different balance of formal reasoning and coding（有兴趣的同学可以看一下，虽然code和specification更近了，但是这种alleviation的一部分是通过转嫁到对compiler和runtime system更heavy的reasoning而获得的）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;我关于下一代编程语言范式的看法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我倾向于主流imperative programming（IP）这种编程方式在以后会有较大的转变，因为很多应用下的程序，相比于逻辑，更多服务于数据，这样一部分需求可以被functional programming (FP) 或者 logic programming (LP) 更好的消化，实际上很多主流语言也支持或开始支持FP了（IP+FP）。我觉得随着一些新的需求和应用的出现，IP+LP或IP+FP+LP也会越来越多，估计会在一些专家领域或特别的应用中先出现。有的人可能会问，为什么新的语言范式都要加一个IP？因为利益啊，遗留的系统，遗留的知识，遗留的固守成规。。。至于说有没有可能有一种或几种全新的编程范式在未来出现并惠及天下，我的答案是当然。&lt;/p&gt;&lt;p&gt;说到这里又不得不惋惜一叹啊，希望咱们国家更重视一下编程语言的教育和科研，每年输出这么多程序员，每年又输入这么多对编程好奇、感兴趣的学生，于国于民，千秋万代啊。&lt;/p&gt;&lt;p&gt;嗯，就唠叨这么多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>啥玩应啊</author>
<guid isPermaLink="false">2019-05-03-64492626</guid>
<pubDate>Fri, 03 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Haskell的生成OpenCL调用代码的实践</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-01-64420931.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64420931&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b062ca1c4dce747076060362eabda24b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;这是一篇关于Haskell在日常开发过程中的实践的文章，主要介绍了Haskell在代码生成方面的实现和使用。&lt;/p&gt;&lt;p&gt;现在常用的高性能计算中，使用GPU来加速是一种非常重要的方法，而OpenCL因为其良好的跨平台特性，可以在Windows、Linux、macOS、Android和嵌入式Linux系统上使用，可以在多种硬件平台上运行，比如AMD、Nvidia、高通、ARM mali的GPU上运行，甚至可以在FPGA上运行。因此，在工程实践中大量使用OpenCL来实现并行化的高性能计算。&lt;/p&gt;&lt;p&gt;当我们在写一个需要大量使用OpenCL来加速计算的项目时，会有很多个OpenCL的kernel函数来实现这些并行化的加速计算。这个时候我们就需要写大量的调用OpenCL的kernel函数的代码，而且这些代码都是很机械的设置kernel的参数，然后调用函数clEnqueueNDRangeKernel。如下所示：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;cl_int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clSetKernelArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cl_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clSetKernelArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cl_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clSetKernelArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cl_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clSetKernelArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intt32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clSetKernelArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intt32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;chk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;matrixMul&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clEnqueueNDRangeKernel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;globalSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;localSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;chk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;matrixMul clEnqueueNDRangeKernel&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;写这些代码是很枯燥乏味的，那有没有工具可以自动生成这些代码呢？我看了不少工程项目，都没有使用自动生成代码的方式，也没有找到这样的工具。于是就决定自己做一个这样的工具，而Haskell有一个很好用的C/C++语言解析的包，是language-c，这是一个历史悠久的包，里面的作者都是Haskell的高手。但是这个language-c的包目前不支持OpenCL的解析，我看了一下代码，觉得可以自己加上支持OpenCL的解析的功能。于是就花了几个晚上修改了language-c的代码，顺利的增加了OpenCL解析的功能。&lt;/p&gt;&lt;p&gt;有了language-c的支持后，接下来就开始写解析OpenCL的kernel源代码的*.cl文件并生成上面的调用OpenCL的kernel函数的代码了。得益于language-c的良好设计，并参考了一个解析C语言的范例，很快就写好了这个工具的代码。加上脚本的配合，现在已经可以从kernel源代码的*.cl文件自动生成调用OpenCL的kernel函数的代码了。&lt;/p&gt;&lt;p&gt;使用如下从这个链接&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.olcf.ornl.gov/tutorials/opencl-game-of-life/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;olcf.ornl.gov/tutorials&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/opencl-game-of-life/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;拿到的GOL-kernels.cl文件，这个文件如下所示：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;n&quot;&gt;__kernel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ghostRows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;__global&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// We want id to range from 1 to dim
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_global_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Copy first real row to bottom ghost row
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Copy last real row to top ghost row
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;n&quot;&gt;__kernel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ghostCols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;__global&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// We want id to range from 0 to dim+1
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_global_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Copy first real column to right most ghost column
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Copy last real column to left most ghost column
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;n&quot;&gt;__kernel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;__global&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;__global&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_global_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_global_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Get the number of neighbors for a given grid point
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//upper lower
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;                 &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;//right left
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;                 &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//diagonals
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;                 &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt;
 
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Here we have explicitly all of the game rules
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用这个工具后，可以生成如下的OpenCL的kernel的调用代码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

int oclGOL(
	cl_command_queue command_queu,
	const size_t* globalSize,
	const size_t* localSize,
	intt32_t dim,
	cl_mem grid,
	cl_mem newGrid)
{
	cl_int status = 0;

	status |= clSetKernelArg(GOL, 0, sizeof(intt32_t), &amp;amp;dim);
	status |= clSetKernelArg(GOL, 1, sizeof(cl_mem), &amp;amp;grid);
	status |= clSetKernelArg(GOL, 2, sizeof(cl_mem), &amp;amp;newGrid);
	chk(status, &amp;#34;GOL&amp;#34;);

#ifdef DEBUG_KERNEL
	cl_event debug_event;
	status = clEnqueueNDRangeKernel(command_queue, GOL,
		2, NULL, globalSize, localSize, 0, NULL, &amp;amp;debug_event);
	chk(status, &amp;#34;GOL clEnqueueNDRangeKernel&amp;#34;);
	CheckKernelEvent(debug_event, &amp;#34;GOL&amp;#34;);
	clReleaseEvent(debug_event);
#else
	status = clEnqueueNDRangeKernel(command_queue, GOL,
		2, NULL, globalSize, localSize, 0, NULL, NULL);
	chk(status, &amp;#34;GOL clEnqueueNDRangeKernel&amp;#34;);
#endif
	return (int)status;
}

int oclghostCols(
	cl_command_queue command_queu,
	const size_t* globalSize,
	const size_t* localSize,
	intt32_t dim,
	cl_mem grid)
{
	cl_int status = 0;

	status |= clSetKernelArg(ghostCols, 0, sizeof(intt32_t), &amp;amp;dim);
	status |= clSetKernelArg(ghostCols, 1, sizeof(cl_mem), &amp;amp;grid);
	chk(status, &amp;#34;ghostCols&amp;#34;);

#ifdef DEBUG_KERNEL
	cl_event debug_event;
	status = clEnqueueNDRangeKernel(command_queue, ghostCols,
		2, NULL, globalSize, localSize, 0, NULL, &amp;amp;debug_event);
	chk(status, &amp;#34;ghostCols clEnqueueNDRangeKernel&amp;#34;);
	CheckKernelEvent(debug_event, &amp;#34;ghostCols&amp;#34;);
	clReleaseEvent(debug_event);
#else
	status = clEnqueueNDRangeKernel(command_queue, ghostCols,
		2, NULL, globalSize, localSize, 0, NULL, NULL);
	chk(status, &amp;#34;ghostCols clEnqueueNDRangeKernel&amp;#34;);
#endif
	return (int)status;
}

int oclghostRows(
	cl_command_queue command_queu,
	const size_t* globalSize,
	const size_t* localSize,
	intt32_t dim,
	cl_mem grid)
{
	cl_int status = 0;

	status |= clSetKernelArg(ghostRows, 0, sizeof(intt32_t), &amp;amp;dim);
	status |= clSetKernelArg(ghostRows, 1, sizeof(cl_mem), &amp;amp;grid);
	chk(status, &amp;#34;ghostRows&amp;#34;);

#ifdef DEBUG_KERNEL
	cl_event debug_event;
	status = clEnqueueNDRangeKernel(command_queue, ghostRows,
		2, NULL, globalSize, localSize, 0, NULL, &amp;amp;debug_event);
	chk(status, &amp;#34;ghostRows clEnqueueNDRangeKernel&amp;#34;);
	CheckKernelEvent(debug_event, &amp;#34;ghostRows&amp;#34;);
	clReleaseEvent(debug_event);
#else
	status = clEnqueueNDRangeKernel(command_queue, ghostRows,
		2, NULL, globalSize, localSize, 0, NULL, NULL);
	chk(status, &amp;#34;ghostRows clEnqueueNDRangeKernel&amp;#34;);
#endif
	return (int)status;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样我们就可以直接调用这些封装好的OpenCL的kernel的调用函数，直接传入C/C++中的普通的参数即可。当有大量（好几十个）的kernel函数需要调用时，可以让我们少写很多这种枯燥无味的调用OpenCL的kernel的代码，减少写这些代码的时间，并且不会在参数较多的情况下出现参数设置错误的情况，正确性有保障。&lt;/p&gt;&lt;p&gt;这个工具的实现比较简单，总共只有195行代码。首先，写一个handler，响应language-c中解析*.cl文件时的事件。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;usage&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;give file to parse&amp;#34;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;opts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;c_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;liftM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getArgs&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compiler&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newGCC&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;gcc&amp;#34;&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;ast&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseCFile&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compiler&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;opts&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;c_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;checkResult&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;[parsing]&amp;#34;&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;runTrav&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withExtDeclHandler&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;analyseAST&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
         &lt;span class=&quot;kt&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;errs&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;errors: &amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;concat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;errToString&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;errs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
         &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;header&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;takeWhile&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;takeBaseName&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;c_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                    &lt;span class=&quot;nf&quot;&gt;mapM_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;putStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;outputFunDef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;userState&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                    &lt;span class=&quot;nf&quot;&gt;putStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;footer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;funName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;userState&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;handler函数如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DeclEvent&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Trav&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DeclEvent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FunctionDef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;FunctionDef not implemented&amp;#34;&lt;/span&gt;
           &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DeclEvent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Declaration&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;VarDecl&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;varName&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;declAttr&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getVarDecl&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;d&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FunctionType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FunType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isVaradic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;makeOclCallFun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asS&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;varName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isVaradic&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                  &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
                       &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
                       &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;modifyUserState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                     &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，通过函数makeOclCallFun生成中间的OclCallDef数据结构&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallParamType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;OclCallParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;makeOclCallFun&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ParamDecl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Attributes&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;makeOclCallFun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isVaradic&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;attrs&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rtype&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;s&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;toOclCallDef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;traverse&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getOclCallParam&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;toOclCallDef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ps&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ps&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;rtype&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;oclParamType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnType&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，搜集到所有的OclCallDef后，通过函数outputFunDef生成调用OpenCL的kernel的C代码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;outputFunDef&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;outputFunDef&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;int ocl&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; 
  &lt;span class=&quot;s&quot;&gt;&amp;#34;cl_command_queue command_queu,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;const size_t* globalSize,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;const size_t* localSize,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;intercalate&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;{&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;cl_int status = 0;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;concat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printSetKernelArg&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;chk(status, &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#ifdef DEBUG_KERNEL&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;cl_event debug_event;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;status = clEnqueueNDRangeKernel(command_queue, &amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2, NULL, globalSize, localSize, 0, NULL, &amp;amp;debug_event);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;chk(status, &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34; clEnqueueNDRangeKernel&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;CheckKernelEvent(debug_event, &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;clReleaseEvent(debug_event);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;#else&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;status = clEnqueueNDRangeKernel(command_queue, &amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2, NULL, globalSize, localSize, 0, NULL, NULL);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;chk(status, &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34; clEnqueueNDRangeKernel&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;#endif&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;return (int)status;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Haskell在代码生成方面还是比较好用的，有着很多好用的基础库，可以很方便的写出类似的代码生成的功能。&lt;/p&gt;</description>
<author>parker liu</author>
<guid isPermaLink="false">2019-05-01-64420931</guid>
<pubDate>Wed, 01 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Evolvable Programming</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-01-64386866.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64386866&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：这跟genetic programming毫无关系。&lt;/p&gt;&lt;p&gt;最近，我有一个任务：我要写一个Partial Evaluator。&lt;/p&gt;&lt;p&gt;更具体的，这是个Simply Typed Lambda Calculus加上Reference/ADT的Partial Evaluator（PE）。Lambda Calculus上的PE很多人都做过，但是加上Reference就不好办了。我找了很多Scheme/ML的PE的paper，但是在里面，很多都对Effect闭口不提。就算提Effect，也是‘遇到Effect不做PE，跳过就好’。&lt;/p&gt;&lt;p&gt;没办法，我只好自己设计。凭借着我对Partial Evaluation跟Staging的理解，我弄了一个这样的设计：&lt;/p&gt;&lt;p&gt;0：我们先写一个Definitional Interpreter。&lt;/p&gt;&lt;p&gt;1：我们reify the Store。&lt;/p&gt;&lt;p&gt;2：我们利用MetaOCaml式的LetList写一个ANF converter。&lt;/p&gt;&lt;p&gt;3：我们把Definitional Interpreter的Value lift上Partially Static Domain，然后跟ANF converter‘合并’- 这样，Partially Evaluated Code会生成ANF代码，于是就没有code duplication跟capture avoidance substitution的问题。&lt;/p&gt;&lt;p&gt;别急，我们来一步步来看这是啥意思。&lt;/p&gt;&lt;blockquote&gt;0：我们先写一个Definitional Interpreter。&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type (&amp;#39;a, &amp;#39;b) sum = Left of &amp;#39;a | Right of &amp;#39;b

type var = Var of int

type term =
  | Let of (var * term * term)
  | FromVar of var
  | Abs of (var * term)
  | App of (term * term)
  | Unit
  | Int of int
  | Add of (term * term)
  | Mult of (term * term)
  | IfZero of (term * term * term)
  | MkProd of (term * term)
  | Zro of term
  | Fst of term
  | MkRef of term
  | SetRef of (term * term)
  | GetRef of term
  | TLeft of term
  | TRight of term
  | Match of term * term * term

type &amp;#39;a env = int -&amp;gt; &amp;#39;a

let emptyStore _ = raise Not_found

let extend e v x = function i when i == v -&amp;gt; x | i -&amp;gt; e i

let genCounter () =
  let cnt = ref 0 in
  let gen () =
    let ret = !cnt in
    cnt := ret + 1 ;
    ret
  in
  gen

let freshVar = genCounter ()

type value =
  | VFun of (value -&amp;gt; value)
  | VUnit
  | VInt of int
  | VProd of value * value
  | VRef of value ref
  | VSum of (value, value) sum

(* The standard metacircular evaluator. *)
let rec evalAux (e : value env) : term -&amp;gt; value =
  let recurse t = evalAux e t in
  let app x y = match x with VFun f -&amp;gt; f y in
  function
  | Let (Var var, v, body) -&amp;gt;
      let rv = recurse v in
      evalAux (extend e var rv) body
  | FromVar (Var v) -&amp;gt; e v
  | Abs (Var v, b) -&amp;gt; VFun (fun p -&amp;gt; evalAux (extend e v p) b)
  | App (f, x) -&amp;gt; app (recurse f) (recurse x)
  | Unit -&amp;gt; VUnit
  | Int f -&amp;gt; VInt f
  | Add (x, y) -&amp;gt; (
      let rx = recurse x in
      let ry = recurse y in
      match (rx, ry) with VInt x, VInt y -&amp;gt; VInt (x + y) )
  | Mult (x, y) -&amp;gt; (
      let rx = recurse x in
      let ry = recurse y in
      match (rx, ry) with VInt x, VInt y -&amp;gt; VInt (x * y) )
  | IfZero (i, z, nz) -&amp;gt; (
    match recurse i with VInt 0 -&amp;gt; recurse z | VInt _ -&amp;gt; recurse nz )
  | MkProd (x, y) -&amp;gt;
      let rx = recurse x in
      let ry = recurse y in
      VProd (rx, ry)
  | Zro x -&amp;gt; ( match recurse x with VProd (x, _) -&amp;gt; x )
  | Fst x -&amp;gt; ( match recurse x with VProd (_, y) -&amp;gt; y )
  | MkRef x -&amp;gt; VRef (ref (recurse x))
  | SetRef (r, v) -&amp;gt; (
      let vr = recurse r in
      let vv = recurse v in
      match vr with VRef r -&amp;gt;
        r := vv ;
        VUnit )
  | GetRef r -&amp;gt; ( match recurse r with VRef r -&amp;gt; !r )
  | TLeft x -&amp;gt; VSum (Left (recurse x))
  | TRight x -&amp;gt; VSum (Right (recurse x))
  | Match (s, lcase, rcase) -&amp;gt; (
      let ps = recurse s in
      let pl = recurse lcase in
      let pr = recurse rcase in
      match ps with VSum (Left x) -&amp;gt; app pl x | VSum (Right x) -&amp;gt; app pr x )

let eval = evalAux emptyStore&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就是个标准，中规中矩的Definitional Interpreter。&lt;/p&gt;&lt;blockquote&gt;1：我们reify the Store。&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let freshStoreId = genCounter ()

type storeId = StoreId of int

type rValue =
  | RFun of (rValue -&amp;gt; rValue)
  | RUnit
  | RInt of int
  | RProd of rValue * rValue
  | RRef of storeId
  | RSum of (rValue, rValue) sum

(* The evaluator, but with the store reified -
   it is now represented and manipulated explicitly. *)
let rec rEvalAux (curStore : rValue env ref) (e : rValue env) : term -&amp;gt; rValue
    =
  let recurse t = rEvalAux curStore e t in
  let app x y = match x with RFun f -&amp;gt; f y in
  function
  | Let (Var var, v, body) -&amp;gt;
      let rv = recurse v in
      rEvalAux curStore (extend e var rv) body
  | FromVar (Var v) -&amp;gt; e v
  | Abs (Var v, b) -&amp;gt; RFun (fun p -&amp;gt; rEvalAux curStore (extend e v p) b)
  | App (f, x) -&amp;gt; app (recurse f) (recurse x)
  | Unit -&amp;gt; RUnit
  | Int f -&amp;gt; RInt f
  | Add (x, y) -&amp;gt; (
      let rx = recurse x in
      let ry = recurse y in
      match (rx, ry) with RInt x, RInt y -&amp;gt; RInt (x + y) )
  | Mult (x, y) -&amp;gt; (
      let rx = recurse x in
      let ry = recurse y in
      match (rx, ry) with RInt x, RInt y -&amp;gt; RInt (x * y) )
  | IfZero (i, z, nz) -&amp;gt; (
    match recurse i with RInt 0 -&amp;gt; recurse z | RInt _ -&amp;gt; recurse nz )
  | MkProd (x, y) -&amp;gt;
      let rx = recurse x in
      let ry = recurse y in
      RProd (rx, ry)
  | Zro x -&amp;gt; ( match recurse x with RProd (x, _) -&amp;gt; x )
  | Fst x -&amp;gt; ( match recurse x with RProd (_, y) -&amp;gt; y )
  | MkRef x -&amp;gt;
      let rx = recurse x in
      let id = freshStoreId () in
      curStore := extend !curStore id rx ;
      RRef (StoreId id)
  | SetRef (r, v) -&amp;gt;
      let rr = recurse r in
      let rv = recurse v in
      (match rr with RRef (StoreId s) -&amp;gt; curStore := extend !curStore s rv) ;
      RUnit
  | GetRef r -&amp;gt; ( match recurse r with RRef (StoreId s) -&amp;gt; !curStore s )
  | TLeft x -&amp;gt; RSum (Left (recurse x))
  | TRight x -&amp;gt; RSum (Right (recurse x))
  | Match (s, lcase, rcase) -&amp;gt; (
      let rs = recurse s in
      let rl = recurse lcase in
      let rr = recurse rcase in
      match rs with RSum (Left x) -&amp;gt; app rl x | RSum (Right x) -&amp;gt; app rr x )

let rEval = rEvalAux (ref emptyStore) emptyStore&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们不用OCaml原生的reference，而是自己建一个数据结构来实现reference。reference的Value则从metalevel的reference，成为这个数据结构的一个索引。这就是reification的意思：我们把一个抽象的概念（heap）变成具体的代码（我们的reference的实现）。&lt;/p&gt;&lt;blockquote&gt;2：我们利用MetaOCaml式的LetList写一个ANF converter。&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(* letList bind complex expression to a simple variable,
   so one can construct some complex expression, and use it
   as a variable by storing a binding in the letlist. *)
type letList = (term -&amp;gt; term) ref

let withLetList f =
  let l = ref (fun x -&amp;gt; x) in
  let res = f l in
  !l res

let pushVar l v x =
  let lv = !l in
  l := fun t -&amp;gt; lv (Let (v, x, t))

let push l x =
  let v = Var (freshVar ()) in
  pushVar l v x ; FromVar v

(* Using the letList to do anf conversion by &amp;#39;running&amp;#39; the program in compile time. *)
let rec anfAux (l : letList) : term -&amp;gt; term =
  let recurse t = anfAux l t in
  function
  | Let (Var var, v, body) -&amp;gt;
      pushVar l (Var var) (recurse v) ;
      recurse body
  | FromVar (Var v) -&amp;gt; FromVar (Var v)
  | Abs (Var v, b) -&amp;gt; push l (Abs (Var v, withLetList (fun l -&amp;gt; anfAux l b)))
  | App (f, x) -&amp;gt; push l (App (recurse f, recurse x))
  | Unit -&amp;gt; Unit
  | Int f -&amp;gt; Int f
  | Add (x, y) -&amp;gt; push l (Add (recurse x, recurse y))
  | Mult (x, y) -&amp;gt; push l (Mult (recurse x, recurse y))
  | IfZero (i, z, nz) -&amp;gt; push l (IfZero (recurse i, recurse z, recurse nz))
  | MkProd (x, y) -&amp;gt; push l (MkProd (recurse x, recurse y))
  | Zro x -&amp;gt; push l (Zro (recurse x))
  | Fst x -&amp;gt; push l (Fst (recurse x))
  | MkRef x -&amp;gt; push l (MkRef (recurse x))
  | SetRef (r, v) -&amp;gt; push l (SetRef (recurse r, recurse v))
  | GetRef r -&amp;gt; push l (GetRef (recurse r))
  | TLeft x -&amp;gt; push l (TLeft (recurse x))
  | TRight x -&amp;gt; push l (TRight (recurse x))
  | Match (s, lcase, rcase) -&amp;gt;
      push l (Match (recurse s, recurse lcase, recurse rcase))

let anf x = withLetList (fun l -&amp;gt; anfAux l x)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ANF的意思是说代码中没有compound expression：1 + 2 + 3这样的代码不可能出现，而是需要写成let a = 1 + 2 in let b = a + 3 in b这样形式的。这样，我们的所有表达式都会有一个binding。（注：ANF容许let a = 1 + 2 in a + 3，但我们不容许，因为这样最后表达式没binding，不满足我们等下的需求）&lt;/p&gt;&lt;blockquote&gt;3：我们把Definitional Interpreter的Value lift上Partially Static Domain，然后。。。&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(* The partially-static value is just like value with store reified, but might be empty,
   and always come with a term that is semantically equivalent to the original expression.
   The term must not be a compound expression as it duplicate computation and effect. *)
type sValue =
  | SFun of (letList -&amp;gt; pValue -&amp;gt; pValue)
  | SUnit
  | SInt of int
  | SProd of pValue * pValue
  | SRef of storeId
  | SSum of (pValue, pValue) sum

and pValue = {pStatic: sValue option; dynVal: term}

let static s d = {pStatic= Some s; dynVal= d}

let staticInt i = static (SInt i) (Int i)

let dynamic d = {pStatic= None; dynVal= d}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;partially static data是partial evaluator界的一个常规操作，具体就是一个value可以是‘普通’的value（static），或者可以是代码（dynamic）。为了简化，我们强制一定有dynamic（dynVal）。这也同时保证一个value不会被多次转成code。同时，我们限制dynamic为atomic term - 也就是说，dynVal的term只能有场数大小。那复合term怎么样？存进LetList里。&lt;/p&gt;&lt;blockquote&gt;跟ANF converter‘合并’- 这样，Partially Evaluated Code会生成ANF代码，于是就没有code duplication跟capture avoidance substitution的问题。&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(* rEval on the static part(if exist), anf on the dynamic part.
   Will try to recurse aggressively to optimize even with value/control unknown.
   Must clear curStore when unknown code is executed, as the store is contaminated. *)
let rec peAux (curStore : pValue env ref) (e : pValue env) (l : letList) :
    term -&amp;gt; pValue =
  let recurse t = peAux curStore e l t in
  let app x y =
    match x.pStatic with
    | Some (SFun f) -&amp;gt; f l y
    | _ -&amp;gt;
        curStore := emptyStore ;
        dynamic (push l (App (x.dynVal, y.dynVal)))
  in
  function
  | Let (Var var, v, body) -&amp;gt;
      let pv = recurse v in
      pushVar l (Var var) pv.dynVal ;
      peAux curStore (extend e var pv) l body
  | FromVar (Var v) -&amp;gt; e v
  | Abs (Var v, b) -&amp;gt;
      static
        (SFun (fun l p -&amp;gt; peAux curStore (extend e v p) l b))
        (push l
           (Abs
              ( Var v
              , withLetList (fun l -&amp;gt;
                    (peAux (ref emptyStore)
                       (extend e v (dynamic (FromVar (Var v))))
                       l b)
                      .dynVal ) )))
  | App (f, x) -&amp;gt; app (recurse f) (recurse x)
  | Unit -&amp;gt; static SUnit Unit
  | Int f -&amp;gt; staticInt f
  | Add (x, y) -&amp;gt; (
      let px = recurse x in
      let py = recurse y in
      match (px.pStatic, py.pStatic) with
      | Some (SInt x), Some (SInt y) -&amp;gt; staticInt (x + y)
      | _ -&amp;gt; dynamic (push l (Add (px.dynVal, py.dynVal))) )
  | Mult (x, y) -&amp;gt; (
      let px = recurse x in
      let py = recurse y in
      match (px.pStatic, py.pStatic) with
      | Some (SInt x), Some (SInt y) -&amp;gt; staticInt (x * y)
      | _ -&amp;gt; dynamic (push l (Mult (px.dynVal, py.dynVal))) )
  | IfZero (i, z, nz) -&amp;gt; (
      let pi = recurse i in
      match pi.pStatic with
      | Some (SInt 0) -&amp;gt; recurse z
      | Some (SInt _) -&amp;gt; recurse nz
      | _ -&amp;gt;
          let res =
            dynamic
              (push l
                 (IfZero
                    ( pi.dynVal
                    , (peAux (ref !curStore) e l z).dynVal
                    , (peAux (ref !curStore) e l nz).dynVal )))
          in
          curStore := emptyStore ;
          res )
  | MkProd (x, y) -&amp;gt;
      let px = recurse x in
      let py = recurse y in
      static (SProd (px, py)) (push l (MkProd (px.dynVal, py.dynVal)))
  | Zro x -&amp;gt; (
      let px = recurse x in
      match px.pStatic with
      | Some (SProd (x, _)) -&amp;gt; x
      | _ -&amp;gt; dynamic (push l (Zro px.dynVal)) )
  | Fst x -&amp;gt; (
      let px = recurse x in
      match px.pStatic with
      | Some (SProd (_, y)) -&amp;gt; y
      | _ -&amp;gt; dynamic (push l (Fst px.dynVal)) )
  | MkRef x -&amp;gt;
      let px = recurse x in
      let id = freshStoreId () in
      curStore := extend !curStore id px ;
      static (SRef (StoreId id)) (push l (MkRef px.dynVal))
  | SetRef (r, v) -&amp;gt;
      let pr = recurse r in
      let pv = recurse v in
      let _ = push l (SetRef (pr.dynVal, pv.dynVal)) in
      ( match pr.pStatic with
      | Some (SRef (StoreId s)) -&amp;gt; curStore := extend !curStore s pv
      | _ -&amp;gt; curStore := emptyStore ) ;
      static SUnit Unit
  | GetRef r -&amp;gt; (
      let pr = recurse r in
      try
        match pr.pStatic with
        | Some (SRef (StoreId s)) -&amp;gt; !curStore s
        | _ -&amp;gt; raise Not_found
      with _ -&amp;gt; dynamic (push l (GetRef pr.dynVal)) )
  | TLeft x -&amp;gt;
      let px = recurse x in
      static (SSum (Left px)) (push l (TLeft px.dynVal))
  | TRight x -&amp;gt;
      let px = recurse x in
      static (SSum (Right px)) (push l (TRight px.dynVal))
  | Match (s, lcase, rcase) -&amp;gt; (
      let ps = recurse s in
      let pl = recurse lcase in
      let pr = recurse rcase in
      match ps.pStatic with
      | Some (SSum (Left x)) -&amp;gt; app pl x
      | Some (SSum (Right x)) -&amp;gt; app pr x
      | _ -&amp;gt;
          curStore := emptyStore ;
          dynamic (push l (Match (ps.dynVal, pl.dynVal, pr.dynVal))) )

let pe x = withLetList (fun l -&amp;gt; (peAux (ref emptyStore) emptyStore l x).dynVal)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;剩下的代码。当Definitional Interpreter可以跑的时候，用之simplify，否则就用ANF生成dynamic term。在执行未知代码的时候，我们会利用store被reify的特性，直接复制/清空 store。&lt;/p&gt;&lt;p&gt;你可以看到，在这个代码中，我们做了三件事：reify the store，然后跟ANF合并，最后，在一定情况special case，清空store。&lt;/p&gt;&lt;p&gt;但是，有一个问题：我们这个‘更改’，‘合并’，都是在语言外进行的，所以我们的代码中，也许不会有一个reified evaluator，但是一定会有一个简单的interpreter，会有一个ANF convertor，然后还需要特定的去写一个partial evaluator。&lt;/p&gt;&lt;p&gt;为什么我们不能在一个语言中，写一个evaluator，然后写‘对reference如此这般改一下’，得到一个reified evaluator，然后写一个ANF Convertor，然后写‘合并ANF跟rEval’，然后再写‘对lambda, if else，setref，match special case一下，清空store’？这几个步骤是毫无二义性的，也不需要任何搜索，应该可以做进语言啊。&lt;/p&gt;&lt;p&gt;如果在什么语言里面，的确可以这样写，请告诉我。&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//arxiv.org/abs/0910.2654&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MLPolyR&lt;/a&gt;好像能做一半，但是merge做不了。&lt;/p&gt;&lt;p&gt;再多说点，在静态分析（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//matt.might.net/papers/might2006gcfa.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Abstract Garbage Collection&lt;/a&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//matt.might.net/papers/vanhorn2010abstract.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Abstracting Abstract Machine&lt;/a&gt;）里，往往会从一个Abstract Machine出发，一步步修改该Abstract Machine。Program Transformation（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.brics.dk/RS/01/23/BRICS-RS-01-23.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Defunctionalization At Work&lt;/a&gt;，The Algebra of Programming）里面，也会同样先出现一个简单的算法，然后一步步，通过各自手段（CPS Conversion，Defunctionalization，Fusion）得出最后的算法。这些估计更难做，但大体idea还是一样的。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2019-05-01-64386866</guid>
<pubDate>Wed, 01 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Philis的LLVM魔导书（1）：实现一个简单的Function Pass来优化你的IR</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-04-24-63568031.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/63568031&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-804f905d148966c695b4bd50c3a78db8_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;中文网络上能找到许多介绍LLVM的文章，但大多是概览类。这个系列的目的是用更加具体的实例来让对编译器知识有一定了解的读者掉入LLVM这个史瓦西半径甚大的坑。&lt;/p&gt;&lt;p&gt;比起内部组织形式晦涩难懂的gcc，优化过程不对用户透明的jvm、.net等虚拟机，LLVM的优化pass提供了一种清晰易懂的优化过程组织方式。每个pass对LLVM来说都是一个小的库，用户可以以即插即用的方式来为自己的编译器添加新的优化过程，也可以自由地在已有的优化pass中选择想要的部分。在这篇文章里，我们将要实现一个简单的pass，&lt;code&gt;Dead Blocks Elimination&lt;/code&gt;，来优化我们生成的LLVM IR。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;环境设置&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先，我们需要设置build环境，根据你的LLVM版本不同，具体过程也会有些区别。旧版的LLVM使用&lt;code&gt;gmake&lt;/code&gt;作为其主要的build工具，后续的版本中逐渐在向&lt;code&gt;cmake&lt;/code&gt;迁移。默认读者采用的是笔者写文章时的最新的发布版本&lt;code&gt;8.0.0&lt;/code&gt;，请同时参考对应版本文档中官方手册的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//llvm.org/docs/WritingAnLLVMPass.html%23setting-up-the-build-environment&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这一节&lt;/a&gt;来配置。&lt;/p&gt;&lt;p&gt;在&lt;code&gt;&amp;lt;你的LLVM安装目录&amp;gt;/lib/Transforms/&lt;/code&gt;下建立一个名为&lt;code&gt;DeadBlock&lt;/code&gt;的目录，进入并新建&lt;code&gt;CMakeLists.txt&lt;/code&gt;，将以下代码复制入：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cmake&quot;&gt;&lt;span class=&quot;nb&quot;&gt;add_llvm_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;DeadBlock&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;MODULE&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;DeadBlock.cpp&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;PLUGIN_TOOL&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;opt&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;随后，退入到上级目录，打开&lt;code&gt;&amp;lt;你的LLVM安装目录&amp;gt;/lib/Transforms/CMakeLists.txt&lt;/code&gt;，并添加:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cmake&quot;&gt;&lt;span class=&quot;nb&quot;&gt;add_subdirectory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此，LLVM的build工具就可以正常地读取我们添加的新pass了。&lt;/p&gt;&lt;blockquote&gt;题外话：众所周之，软件行业每年进步最快的永远是版本号，笔者实际用的是14年的远古版本3.5.0（为了编译一个远古项目），还在用Makefile来构建pass。而现在开发中的版本号已经爬到了9.0.0+，趴&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Dead Blocks Elimination是什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这其实是一个原理非常简单的优化过程，常常出现在优化链的中段。假设在对代码进行了一定优化之后，我们得到了如下的IR：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;; ModuleID = &amp;#39;test.bc&amp;#39;
​
define i32 @main() {
b1:
  br label %b2
​
dead:                                             ; No predecessors!
  br label %b3
​
b2:                                               ; preds = %b1
  br label %b3
​
b3:                                               ; preds = %dead, %b2
  %b = phi i32 [ 1, %b2 ], [ 2, %dead ]
  ret i32 %b
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意，由于之前已经进行了一些神秘的优化或者代码本身如此，名为&lt;code&gt;dead&lt;/code&gt;的这个base block实际是无法被访问到的！&lt;code&gt;b1&lt;/code&gt;中的无条件&lt;code&gt;br&lt;/code&gt;永远只会跳转到&lt;code&gt;b2&lt;/code&gt;，而不是&lt;code&gt;dead&lt;/code&gt;。我们现在要实现的&lt;code&gt;DeadBlock&lt;/code&gt; pass正是要消去这样的base block。&lt;/p&gt;&lt;p&gt;不过，并不是直接删掉&lt;code&gt;dead&lt;/code&gt;就完事了，在&lt;code&gt;b3&lt;/code&gt;之中，我们有一个&lt;code&gt;phi node&lt;/code&gt;。为了让原来的代码保持正确，我们还需要调整或者删除受影响的&lt;code&gt;phi node&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;如果你不了解LLVM IR和phi node的话，可以阅读&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-cn/%25E9%259D%2599%25E6%2580%2581%25E5%258D%2595%25E8%25B5%258B%25E5%2580%25BC%25E5%25BD%25A2%25E5%25BC%258F&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这篇wiki&lt;/a&gt;来了解什么是SSA形式的IR，阅读&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//releases.llvm.org/3.5.0/docs/LangRef.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;LLVM的手册&lt;/a&gt;来了解LLVM IR的基本语法。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;第一铲土&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在了解要做什么之后，我们就可以开始动工了。在刚刚建立的&lt;code&gt;DeadBlock&lt;/code&gt;目录下添加&lt;code&gt;DeadBlock.cpp&lt;/code&gt;，这将是我们编写pass的地方，大部分LLVM优化pass都将代码组织在单个&lt;code&gt;.cpp&lt;/code&gt;文件中。和所有C++项目一样，讨厌的第一步总是添加所需的header：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/Pass.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/IR/Function.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/Support/raw_ostream.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/ADT/DepthFirstIterator.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/IR/CFG.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;set&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个pass的主干将看起来是这个样子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;llvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;DeadBlock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionPass&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runOnFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;llvm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// pass的入口
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 下一小节，我们将在这里添加代码
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// LLVM会利用pass的地址来为这个id赋值，所以初始值并不重要
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 注册pass，这个pass可能会改变CFG，所以将第三个参数设为true
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegisterPass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;deadblock&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;Dead blocks elimination pass&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;LLVM的pass有许多种，本次要实现的是一个&lt;code&gt;FunctionPass&lt;/code&gt;，也就是说这个pass将会在每个函数上运行一次。因此，我们的&lt;code&gt;DeadBlock&lt;/code&gt;构造体需要继承&lt;code&gt;FunctionPass&lt;/code&gt;。在搭建完骨架之后，我们就可以在&lt;code&gt;runOnFunction&lt;/code&gt;中逐步添加代码来实现具体的功能了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;造楼&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们需要一些本地变量来暂时存放需要的值：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;changed&lt;/code&gt;: 用来指示这个pass是否改变了目标function，如果改变了，则要标记为&lt;code&gt;true&lt;/code&gt;。这个值将是我们的返回值&lt;/li&gt;&lt;li&gt;&lt;code&gt;visitedSet&lt;/code&gt;： 我们将会从这个函数的root block开始，遍历这个root block可能会达到的block，被遍历到的block将会存放到这个set中&lt;/li&gt;&lt;li&gt;&lt;code&gt;unreachableSet&lt;/code&gt;：在得到&lt;code&gt;visitedSet&lt;/code&gt;之后，我们可以将其和这个函数中所有block做比较，如果有不在&lt;code&gt;visitedSet&lt;/code&gt;中的block，就将其添加到&lt;code&gt;unreachableSet&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;了解要做什么之后，就来一起向&lt;code&gt;visitedSet&lt;/code&gt;和&lt;code&gt;unreachableSet&lt;/code&gt;里加内容吧：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 从EntryBlock开始深度优先遍历整个函数内可以访问的BaseBlock
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 将已被访问过的BaseBlock存放在visitedSet中
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_ext_begin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_ext_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 遍历函数内所有BaseBlock，将不在vistitedSet中的BaseBlock添加到unreachableSet中
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;BB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然只是短短几行代码，LLVM库的强大可见一斑。我们无需自己手动实现深度优先遍历，只需调用&lt;code&gt;DepthFirstIterator.h&lt;/code&gt;里的&lt;code&gt;df_ext_begin&lt;/code&gt;和&lt;code&gt;df_ext_end&lt;/code&gt;两个模板，就能轻松遍历整个函数，并将访问过的block添加到&lt;code&gt;visitedSet&lt;/code&gt;之中。有了&lt;code&gt;unreachableSet&lt;/code&gt;之后，我们就可以判断是否会修改目标函数了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 标记目标函数是否会被修改
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后只要删除掉不想要的block并返回&lt;code&gt;changed&lt;/code&gt;，就大功告成：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;BB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;succ_begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;succ_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removePredecessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eraseFromParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这时，细心的读者可能会说：“诶诶？！是不是漏掉了什么？刚才说要处理受影响的phi node的呢？”不要着急，这段代码里其实已经处理了这部分啦。&lt;code&gt;removePredecessor()&lt;/code&gt;函数会通知该block有predecessor已被移除，随后这个block会检查自己是否有会受到影响的phi node并自动做出修改。怎么样，是不是觉得LLVM的库用起来很方便？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;测试结果&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面，就来编译并测试一下我们的成果吧。退回到LLVM安装目录的根目录下，在控制台里输入&lt;code&gt;make&lt;/code&gt;来编译刚完成的新pass。如果一切顺利的话，你就能在&lt;code&gt;Debug+Asserts/lib/&lt;/code&gt;下看到新生成的&lt;code&gt;DeadBlock.so&lt;/code&gt;了。&lt;/p&gt;&lt;p&gt;就来用一开始提到的示例IR作为测试代码好了，用LLVM自带的assembler来编译IR到bytecode：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;llvm-as test.ll&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，我们用LLVM自带的&lt;code&gt;opt&lt;/code&gt;工具来动态载入新pass并执行。重新进到&lt;code&gt;&amp;lt;你的LLVM安装目录&amp;gt;/lib/Transforms/DeadBlock&lt;/code&gt;下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;opt -load ../../../Debug+Asserts/lib/DeadBlock.so -deadblock &amp;lt; test.bc &amp;gt; optimized.bc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用&lt;code&gt;llvm-dis&lt;/code&gt;来看一下优化过的代码吧：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;llvm-dis optimized.bc
; ModuleID = &amp;#39;optimized.bc&amp;#39;
​
define i32 @main() {
b1:
  br label %b2
​
b2:                                               ; preds = %b1
  br label %b3
​
b3:                                               ; preds = %b2
  ret i32 1
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和原来的代码对比一下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-llvm&quot;&gt;&lt;span class=&quot;c&quot;&gt;; ModuleID = &amp;#39;test.bc&amp;#39;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;@main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;b1:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%b2&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;dead:&lt;/span&gt;                                             &lt;span class=&quot;c&quot;&gt;; No predecessors!
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%b3&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;b2:&lt;/span&gt;                                               &lt;span class=&quot;c&quot;&gt;; preds = %b1
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%b3&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;b3:&lt;/span&gt;                                               &lt;span class=&quot;c&quot;&gt;; preds = %dead, %b2
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;%b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%b2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%dead&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%b&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，&lt;code&gt;dead&lt;/code&gt;已经被移除，多余的phi node也被去除，替换成了常量。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;完整代码&lt;/b&gt;&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/Pass.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/IR/Function.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/Support/raw_ostream.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/ADT/DepthFirstIterator.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/IR/CFG.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;set&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;llvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;DeadBlock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionPass&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runOnFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;llvm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// visitedSet 用于存放已经被访问过的BaseBlock
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// unreachableSet 则在最后用于存放无法被访问到的block
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 从EntryBlock开始深度优先遍历整个函数内可以访问的BaseBlock
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 将已被访问过的BaseBlock存放在visitedSet中
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_ext_begin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_ext_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 遍历函数内所有BaseBlock，将不在vistitedSet中的BaseBlock添加到unreachableSet中
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;BB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 标记目标函数是否会被修改
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 遍历unreachableSet，通知其successor移除多余的phi node
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;BB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;succ_begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;succ_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removePredecessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eraseFromParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// LLVM会利用pass的地址来为这个id赋值，所以初始值并不重要
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 注册pass，这个pass可能会改变CFG，所以将第三个参数设为true
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegisterPass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;deadblock&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;Dead blocks elimination pass&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原载于&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//monetaphilis.github.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;自己的博客&lt;/a&gt;，欢迎来玩～&lt;/p&gt;</description>
<author>李愚</author>
<guid isPermaLink="false">2019-04-24-63568031</guid>
<pubDate>Wed, 24 Apr 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>计算春秋： MOS 6502</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-04-24-63566404.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/63566404&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2bc988d6f4958d7291ab1e9445387702_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&amp;#34;我们把6502装在罐子里卖，实际上只有罐子最上面那层能用&amp;#34;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;滥觞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;1974年，查尔斯·“恰克”·佩德尔将手里的计划书丢进垃圾桶，愤然离开摩托罗拉公司的大门。就在一年之前，恰克参与了摩托罗拉6800微处理器的设计。嗅觉敏锐的他早就闻到了价值300美金的6800给市场带来的真空——是的，6800太昂贵了。1974年的300美金购买力相当于2019年的1200美金，要用这个价位的处理器构建一台独立的计算机，至少也要2500美金上下，一台普通的家用轿车也不过是这两倍价格罢了。很难想象会有家庭或个人心甘情愿掏出如此巨款购买这样一台奇怪臃肿、不知应该用来做什么的机器，寥寥的潜在买家大多是感兴趣的企业和高校。他想着，如果微处理器的价格能降到50美金以下，必定能填补家用计算机这一片巨大的蓝色海洋。恰克将自己的想法告诉了摩托罗拉的上层，得到的回复却十分简单：&lt;/p&gt;&lt;blockquote&gt;&amp;#34;请放弃吧。&amp;#34;&lt;/blockquote&gt;&lt;p&gt;恰克离开了，但他并非是孤身一人，和他一起离开的还有原6800团队的不少成员。我们无法得知他率部加入MOS科技这家当时并不知名的年轻公司时的确切心情：或有对前上司无知的愤怒，或有对自己怀才不遇的叹息，抑或有对新东家的期待。但不论是哪种心情，这种心情并没有熄灭他的才华和斗志。3年之后，一颗名为6502的芯片将从这个不起眼的公司中诞生，扬起家用计算机的燎原之火。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5208cf59ba3f13f29d39ff64afb9f204_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;600&quot; data-original=&quot;https://pic1.zhimg.com/v2-5208cf59ba3f13f29d39ff64afb9f204_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5208cf59ba3f13f29d39ff64afb9f204_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;600&quot; data-original=&quot;https://pic1.zhimg.com/v2-5208cf59ba3f13f29d39ff64afb9f204_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5208cf59ba3f13f29d39ff64afb9f204_b.jpg&quot;/&gt;&lt;figcaption&gt;MOS 6502的手绘蓝图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;汇流&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;一年之后，1975年的威斯康星，一本杂志刊出了一则奇怪的广告，宣称一家科技公司将在本地的电子技术爱好者展会上以及其低廉的价格出售微处理器，刊登广告的正是恰克本人。这也是MOS 6502在市场——如果这种爱好者集会也算是市场的话，上的第一次亮相。&lt;/p&gt;&lt;p&gt;从现在的视角来看，那天的恰克不论是人力还是物力的准备都是不足的。为了节约资金，他甚至打算直接摆地摊出售，直至赶到现场时才被主办方通知禁止，最后无奈的恰克只好乖乖掏钱买了一个正规摊位。而为了张罗人手，他甚至拉上了自己的妻子一起来叫卖。贩卖的6502芯片更是连像样的包装都没有，一块块封装在DIP-40中的芯片像是酱黄瓜一样挤在一个透明玻璃罐头里。最过分的是那一大堆芯片中只有最上面的一层能正常工作，剩下都是滥竽充数的空壳——正因此有了文章最开始的那段话。实际上这种“充门面”的手段并不新鲜，雅达利之前就用过木头做的的假Pong游戏机在展会上冒充真货。摊位虽然寒酸，但恰克和伙伴们知道，他们有一个制胜的武器——那就是6502那仅有25美元的低廉价格——而他们也只需要这唯一的武器，便能一招制敌。&lt;/p&gt;&lt;p&gt;那天，来买新鲜出炉的6502的人中，有一个圆脸络腮胡的极客、一个年轻英俊的商人、还有一位方脸的工程师。前二者正是史蒂夫·沃兹尼亚克和史蒂夫·乔布斯，而后者是雅达利2600的缔造者约瑟夫·德奎尔。第二年，在高登·法兰奇家的车库里，神奇沃兹将6502接上主电路板。一百一十伏特的电源接通，三万两千七百六十八个DRAM单元苏醒，四十个针脚间信息流转；Apple-1型电脑的心脏颤动了第一下，随后开始以一兆赫兹的频率跳动。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6c54941cc9b487dcd11713f6bac431b5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;728&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1200&quot; data-original=&quot;https://pic2.zhimg.com/v2-6c54941cc9b487dcd11713f6bac431b5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6c54941cc9b487dcd11713f6bac431b5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;728&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1200&quot; data-original=&quot;https://pic2.zhimg.com/v2-6c54941cc9b487dcd11713f6bac431b5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-6c54941cc9b487dcd11713f6bac431b5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;滔滔&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果说6502是酵母，而70年代末的市场就像是30摄氏度的新鲜面团。仅仅25美元的价格让一切变得可能，市场上基于6502的微型电脑如雨后春笋般出现，Atari 2600、Apple ][、NES、Commodore 64、BBC Micro⋯⋯从数千美金一台的商用微型计算机，到只有几百美金的家用计算机，曾经只属于军队、大型企业、大学的计算机正是在这段时间内走入了寻常百姓家。而家用计算机的普及也推动了应用软件的演进：字处理软件、电子表格软件、图形界面、BASIC语言、电子游戏⋯⋯那个时代的普通人几乎全都是从搭载着6502的家用计算机上首次接触到这些现代青年习以为常的概念。&lt;/p&gt;&lt;p&gt;恰克可能没有预见到自己并没有花太长时间设计的这块芯片会统治家庭计算机十数年之久，也让这块芯片成为了摩尔定律支配下计算史上最常青的一块微处理器。时至今日，依然有诸多爱好者仿制6502和用它搭建怀旧电脑。即使和同时代的英特尔8080, 摩托罗拉6800相比，它也是平平无奇的：3510个晶体管，56个指令，最高3 MHz的主频。看似平庸的6502依靠着仅有对手15%的价格、亲民的姿态、和车库文化交融的理念构成了美国60到70一代年轻计算机爱好者的集体记忆。今日在顶级会议上投稿的计算机学者们，又有多少是在一台Apple ][或是Commodore 64里敲下他们的第一行代码呢？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9d0994071015856712223516a48ffbc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;306&quot; class=&quot;content_image&quot; width=&quot;389&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9d0994071015856712223516a48ffbc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;306&quot; class=&quot;content_image lazy&quot; width=&quot;389&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9d0994071015856712223516a48ffbc9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;原载于&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//monetaphilis.github.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;自己的博客&lt;/a&gt;，欢迎来玩～&lt;/p&gt;</description>
<author>李愚</author>
<guid isPermaLink="false">2019-04-24-63566404</guid>
<pubDate>Wed, 24 Apr 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
