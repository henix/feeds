<div class="title-image"><img src="https://pic3.zhimg.com/v2-c9d6722460086c35f984571254f16343_b.jpg" alt=""></div><p>上回我们讲完了类型推导,<b>HM</b>类型推断中遇到的所有的困难都是来自于自身的短板,但是不使用子类型我们也可以使用无数的类型进行类型海作战达到这一目的,显然这是我们开发者和用户都不想看到的 (瞄一眼我们的垃圾JAWA)</p><p>因为<b>ML</b>的变体太多了<b>MLf  </b>,  <b>MLext-row  </b>,  <b>MLrec  </b>等 所以不介意我们再多加一种实现呢(笑嘻嘻)</p><p>所以下面就是作者给<b>MLsub</b>定义的语法</p><p><img src="https://www.zhihu.com/equation?tex=e+%3A%3A%3D+x%5C%5C+%7C%5Clambda+x.e%5C%5C+%7Ce_1+e_2%5C%5C+%7C%5C%7Bl_1+%3D+e_1%2Cl_2%3De_2%2C...%2Cl_n+%3D+e_n%5C%7D%5C%5C+%7Ce.l%5C%5C+%7C%5Chat%7Bx%7D%5C%5C+%7Clet+%5C+%5Chat%7Bx%7D+%5C+%3D+%5C+e_1+%5C+in+%5C+e_2" alt="e ::= x\\ |\lambda x.e\\ |e_1 e_2\\ |\{l_1 = e_1,l_2=e_2,...,l_n = e_n\}\\ |e.l\\ |\hat{x}\\ |let \ \hat{x} \ = \ e_1 \ in \ e_2" eeimg="1"/> </p><p>解释一下啊,<b>{}</b>包裹的是一个记录的构造器</p><p>然后环境变量的规则是</p><p><img src="https://www.zhihu.com/equation?tex=%5CGamma+%3A%3A%3D+e%5C%5C+%7C%5CGamma%2Cx%3A%5Ctau%5C%5C+%7C%5CGamma%2C%5Chat%7Bx%7D%3A%5Cforall%5Cvec%5Calpha.%5Ctau" alt="\Gamma ::= e\\ |\Gamma,x:\tau\\ |\Gamma,\hat{x}:\forall\vec\alpha.\tau" eeimg="1"/></p><h2><b>定义类型</b></h2><p>基本的有函数类型,记录类型,我可以添加基础的布尔类型,我们还有最大最小类型,还有那个上限下限类型运算符.</p><p>使用递归类型和<b>subtyping</b>还有最大最小类型我们定义一个<b>Y组合子</b>试试</p><p><img src="https://www.zhihu.com/equation?tex=Y%28%5Clambda+f.%5Clambda+x.f%29" alt="Y(\lambda f.\lambda x.f)" eeimg="1"/> </p><p>这个的类型我们写作 <img src="https://www.zhihu.com/equation?tex=%5Ctop+%5Crightarrow+%28%5Ctop+%5Crightarrow+%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow....%29" alt="\top \rightarrow (\top \rightarrow (\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow....)" eeimg="1"/> </p><p>很好,写不下</p><p>么我们姑且吧<i>α</i>当作递归类型处理吧,所以这个东西的类型是: <img src="https://www.zhihu.com/equation?tex=%5Ctop+%5Crightarrow+%5Calpha" alt="\top \rightarrow \alpha" eeimg="1"/> 为了写的爽,干脆类型的语法也就这么来吧</p><p><img src="https://www.zhihu.com/equation?tex=%5Ctau+%3A%3A%3D+%5Ctau_1+%5Crightarrow+%5Ctau_2%5C%5C+%7C%5C%7Bl1%3A%5Ctau_1%2C...%5C%7D%5C%5C+%7C%5Calpha%5C%5C+%7C%5Ctop%5C%5C+%7C%5Cbot%5C%5C+%7C%5Ctau+%5Csqcap%5Ctau%5C%5C+%7C%5Ctau+%5Csqcup+%5Ctau" alt="\tau ::= \tau_1 \rightarrow \tau_2\\ |\{l1:\tau_1,...\}\\ |\alpha\\ |\top\\ |\bot\\ |\tau \sqcap\tau\\ |\tau \sqcup \tau" eeimg="1"/> </p><p>好了,我们有了类型构造的语法,那么我们想一下,对于这些记录(record)该怎么搞</p><p>如果我们有 <img src="https://www.zhihu.com/equation?tex=%5C%7Bl_1%3A%5Ctau_1%2Cl_2%3A%5Ctau_2%5C%7D" alt="\{l_1:\tau_1,l_2:\tau_2\}" eeimg="1"/>我们可以写成 <img src="https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D" alt="\{f\}" eeimg="1"/>其 <img src="https://www.zhihu.com/equation?tex=dom%5C+f+%3D+%5C%7Bl_1%2Cl_2%5C%7D" alt="dom\ f = \{l_1,l_2\}" eeimg="1"/> 我们就可以用这个操作获取类型 <img src="https://www.zhihu.com/equation?tex=f%28l_1%29+%3D+%5Ctau_1" alt="f(l_1) = \tau_1" eeimg="1"/>,好的这个问题处理完了,我们接着处理函数的问题.</p><p>我们可以让语法树的类型部分是无限的,但是我们需要采用限制操作符就不是,比如 <img src="https://www.zhihu.com/equation?tex=bool+%5Crightarrow+%28bool+%5Crightarrow%28bool+%5Crightarrow%28bool+%5Crightarrow%28....%29%29" alt="bool \rightarrow (bool \rightarrow(bool \rightarrow(bool \rightarrow(....))" eeimg="1"/>是合法的代码但是 <img src="https://www.zhihu.com/equation?tex=bool+%5Csqcap+%28bool+%5Csqcap%28bool+%5Csqcap%28bool+%5Csqcap%28....%29%29" alt="bool \sqcap (bool \sqcap(bool \sqcap(bool \sqcap(....))" eeimg="1"/>并不是合法的代码.</p><p>但是一般人是写不出来这种无限长的类型定义的,所以我们使用 <b>polar type</b>进行操作,现在这一章先不讲,这是一种有限类型的子集,你知道方便写和推导就行了.</p><p>那么接着上一章提到的<b>分配格</b>来讲,我们也设计一套规则</p><p><img src="https://www.zhihu.com/equation?tex=%5Ctau+%5Csqcup+%5Ctau+%5Cequiv+%5Ctau+%5Cqquad+%5Ctau+%5Csqcap+%5Ctau+%5Cequiv+%5Ctau%5C%5C+%5Ctau_1+%5Csqcup+%5Ctau_2+%5Cequiv+%5Ctau_2+%5Csqcup+%5Ctau_1+%5Cqquad+%5Ctau_1+%5Csqcap+%5Ctau_2+%5Cequiv+%5Ctau_2+%5Csqcap+%5Ctau_1%5C%5C+%5Ctau_1+%5Csqcup+%28%5Ctau_2+%5Csqcup+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcup%5Ctau_2%29+%5Csqcup+%5Ctau_1+%5Cqquad+%5Ctau_1+%5Csqcap+%28%5Ctau_2+%5Csqcap+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcap%5Ctau_2%29+%5Csqcap+%5Ctau_1%5C%5C+%5Ctau_1+%5Csqcup+%28%5Ctau_1+%5Csqcap+%5Ctau_2%29+%5Cequiv+%5Ctau_1+%5Cqquad+%5Ctau_1+%5Csqcap+%28%5Ctau_1+%5Csqcup+%5Ctau_2%29+%5Cequiv+%5Ctau_1%5C%5C+%5Cbot+%5Csqcup+%5Ctau+%5Cequiv+%5Ctau+%5Cqquad+%5Cbot+%5Csqcap+%5Ctau+%5Cequiv+%5Cbot%5C%5C+%5Ctop+%5Csqcup+%5Ctau+%5Cequiv+%5Ctop+%5Cqquad+%5Ctop+%5Csqcap+%5Ctau+%5Cequiv+%5Ctau%5C%5C+%5Ctau_1+%5Csqcup+%28%5Ctau_2+%5Csqcap+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcup%5Ctau_2%29%5Csqcap%28%5Ctau_1%5Csqcup%5Ctau_3%29%5C%5C+%5Ctau_1+%5Csqcap+%28%5Ctau_2+%5Csqcup+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcap%5Ctau_2%29%5Csqcup%28%5Ctau_1%5Csqcap%5Ctau_3%29%5C%5C" alt="\tau \sqcup \tau \equiv \tau \qquad \tau \sqcap \tau \equiv \tau\\ \tau_1 \sqcup \tau_2 \equiv \tau_2 \sqcup \tau_1 \qquad \tau_1 \sqcap \tau_2 \equiv \tau_2 \sqcap \tau_1\\ \tau_1 \sqcup (\tau_2 \sqcup \tau_3) \equiv (\tau_1\sqcup\tau_2) \sqcup \tau_1 \qquad \tau_1 \sqcap (\tau_2 \sqcap \tau_3) \equiv (\tau_1\sqcap\tau_2) \sqcap \tau_1\\ \tau_1 \sqcup (\tau_1 \sqcap \tau_2) \equiv \tau_1 \qquad \tau_1 \sqcap (\tau_1 \sqcup \tau_2) \equiv \tau_1\\ \bot \sqcup \tau \equiv \tau \qquad \bot \sqcap \tau \equiv \bot\\ \top \sqcup \tau \equiv \top \qquad \top \sqcap \tau \equiv \tau\\ \tau_1 \sqcup (\tau_2 \sqcap \tau_3) \equiv (\tau_1\sqcup\tau_2)\sqcap(\tau_1\sqcup\tau_3)\\ \tau_1 \sqcap (\tau_2 \sqcup \tau_3) \equiv (\tau_1\sqcap\tau_2)\sqcup(\tau_1\sqcap\tau_3)\\" eeimg="1"/> </p><p>...是不是跟布尔运算规则一个样<br/>下面是函数和记录的构造函数限制</p><p><img src="https://www.zhihu.com/equation?tex=%28%5Ctau_1+%5Crightarrow+%5Ctau_2%29%5Csqcup%28%5Ctau_1%27+%5Crightarrow+%5Ctau_2%27%29+%5Cequiv+%28%5Ctau_1%5Csqcap%5Ctau_1%27%29%5Crightarrow%28%5Ctau_2%5Csqcup%5Ctau_2%27%29%5C%5C+%28%5Ctau_1+%5Crightarrow+%5Ctau_2%29%5Csqcap%28%5Ctau_1%27+%5Crightarrow+%5Ctau_2%27%29+%5Cequiv+%28%5Ctau_1%5Csqcup%5Ctau_1%27%29%5Crightarrow%28%5Ctau_2%5Csqcap%5Ctau_2%27%29%5C%5C++" alt="(\tau_1 \rightarrow \tau_2)\sqcup(\tau_1&#39; \rightarrow \tau_2&#39;) \equiv (\tau_1\sqcap\tau_1&#39;)\rightarrow(\tau_2\sqcup\tau_2&#39;)\\ (\tau_1 \rightarrow \tau_2)\sqcap(\tau_1&#39; \rightarrow \tau_2&#39;) \equiv (\tau_1\sqcup\tau_1&#39;)\rightarrow(\tau_2\sqcap\tau_2&#39;)\\  " eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D+%5Csqcup+%5C%7Bg%5C%7D+%5Cequiv+%5C%7Bh%5C%7D%5C%5C+%5Cqquad+where+%5C++dom+%5C+h++%3D+dom+%5C+f+%5Ccap+dom+%5C+g%5C%5C+%5Cqquad+and+%5C+h%28l%29+%3D+f%28l%29+%5Csqcup+g%28l%29%5C%5C" alt="\{f\} \sqcup \{g\} \equiv \{h\}\\ \qquad where \  dom \ h  = dom \ f \cap dom \ g\\ \qquad and \ h(l) = f(l) \sqcup g(l)\\" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D+%5Csqcap+%5C%7Bg%5C%7D+%5Cequiv+%5C%7Bh%5C%7D%5C%5C+%5Cqquad+where+%5C++dom+%5C+h++%3D+dom+%5C+f+%5Ccup+dom+%5C+g%5C%5C+%5Cqquad+and+%5C+h%28l%29+%3D+%5Cleft%5C%7B+++++%5Cbegin%7Bmatrix%7D+++++++++++++f%28l%29+%5Csqcap+g%28l%29+%5Cquad+if+%5C+l+%5C+%5Cin+dom+%5C+f+%5Ccap+dom+%5C+g%5C%5C+++++++++++++f%28l%29+%5Cqquad+if+%5C+l+%5C+%5Cin+dom+%5C+f+-+dom+%5C+g%5C%5C+++++++++++++g%28l%29+%5Cqquad+if+%5C+l+%5C+%5Cin+dom+%5C+g+-+dom+%5C+f%5C%5C+++++%5Cend%7Bmatrix%7D+++++%5Cright%5C%7D" alt="\{f\} \sqcap \{g\} \equiv \{h\}\\ \qquad where \  dom \ h  = dom \ f \cup dom \ g\\ \qquad and \ h(l) = \left\{     \begin{matrix}             f(l) \sqcap g(l) \quad if \ l \ \in dom \ f \cap dom \ g\\             f(l) \qquad if \ l \ \in dom \ f - dom \ g\\             g(l) \qquad if \ l \ \in dom \ g - dom \ f\\     \end{matrix}     \right\}" eeimg="1"/></p><h2><b>递归类型</b></h2><p><b>MLsub</b>作为一个牛*的语言,肯定是要支持递归类型的!</p><p>经典的递归类型的处理方法是:首先我们有一个类型 <img src="https://www.zhihu.com/equation?tex=%5Cmu%5Calpha.%5Ctau" alt="\mu\alpha.\tau" eeimg="1"/>我们会把他当成一个映射的不动点 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau%27%29+%3D+%5Ctau%5B%5Ctau%27%2F%5Calpha%5D" alt="\phi(\tau&#39;) = \tau[\tau&#39;/\alpha]" eeimg="1"/>这个就确定了 <img src="https://www.zhihu.com/equation?tex=%5Cmu" alt="\mu" eeimg="1"/>的约束和 <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="\alpha" eeimg="1"/>,并获得了一下的推理原则:</p><p><img src="https://www.zhihu.com/equation?tex=%5Ctau%5B%5Ctau_0%2F%5Calpha%5D+%3D+%5Ctau_0+%5CRightarrow+%5Cmu%5Calpha.%5Ctau+%3D+%5Ctau_0" alt="\tau[\tau_0/\alpha] = \tau_0 \Rightarrow \mu\alpha.\tau = \tau_0" eeimg="1"/></p><p>但是,我们并不是传统的<b>ML</b>我们是<b>MLsub</b>是有<b>subtyping</b>的<b>ML</b>,所以这个不⭐ 我们需要一种可以支持<b>subtyping</b>的比如这样 </p><p><img src="https://www.zhihu.com/equation?tex=%5Ctau%5B%5Ctau_0%2F%5Calpha%5D+%5Cleq+%5Ctau_0+%5CRightarrow+%5Cmu%5Calpha.%5Ctau+%5Cleq+%5Ctau_0" alt="\tau[\tau_0/\alpha] \leq \tau_0 \Rightarrow \mu\alpha.\tau \leq \tau_0" eeimg="1"/> </p><p>这个就需要 <img src="https://www.zhihu.com/equation?tex=%5Cmu%5Calpha.%5Ctau" alt="\mu\alpha.\tau" eeimg="1"/>是一个 <img src="https://www.zhihu.com/equation?tex=%5Cphi" alt="\phi" eeimg="1"/>最小的不动点, 简单(数学)的术语来描述就是映射 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau%27%29+%3D+%5Ctau%5B%5Ctau%27%2F%5Calpha%5D" alt="\phi(\tau&#39;) = \tau[\tau&#39;/\alpha]" eeimg="1"/>单调的时候 <img src="https://www.zhihu.com/equation?tex=%5Calpha%2C%5Ctau" alt="\alpha,\tau" eeimg="1"/>协变,用人话讲就是所有的 <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="\alpha" eeimg="1"/>都出现在偶数的 <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="\rightarrow" eeimg="1"/>的左侧. <br/>这里带来了两个引论: </p><p><b>引论一</b>,如果<img src="https://www.zhihu.com/equation?tex=%5Calpha%2C%5Ctau" alt="\alpha,\tau" eeimg="1"/>协变,那么<img src="https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau%27%29+%3D+%5Ctau%5B%5Ctau%27%2F%5Calpha%5D" alt="\phi(\tau&#39;) = \tau[\tau&#39;/\alpha]" eeimg="1"/>就是有一个最小的前不动点,那么我们可以写作 <img src="https://www.zhihu.com/equation?tex=%5Cmu%5E%2B%5Calpha.%5Ctau" alt="\mu^+\alpha.\tau" eeimg="1"/> 相对的,最大的后不动点就是 <img src="https://www.zhihu.com/equation?tex=%5Cmu%5E-%5Calpha.%5Ctau" alt="\mu^-\alpha.\tau" eeimg="1"/>但是,残念有问题 <i>α</i>和<i>α</i>是逆变的,所以我们需要引入</p><p><img src="https://www.zhihu.com/equation?tex=%5C%5C%5Cmu%5E%2B%5Calpha.%5Ctau+%3D+%5Cbot%5C%5C%5Cmu%5E-%5Calpha.%5Ctau+%3D+%5Ctop%5C%5C" alt="\\\mu^+\alpha.\tau = \bot\\\mu^-\alpha.\tau = \top\\" eeimg="1"/> </p><p>(您家的haskell就是这样的),那么假如所有的<i>α</i>都有至少一种类型构造器,<i>α</i>被<i>τ</i>保护,这样凑合就能用了</p><p><b>引论二</b>,如果<img src="https://www.zhihu.com/equation?tex=%5Calpha%2C%5Ctau" alt="\alpha,\tau" eeimg="1"/>协变同时被他保护,那么 <img src="https://www.zhihu.com/equation?tex=%5Cmu%5E%2B%5Calpha.%5Ctau+%3D+%5Cmu%5E-%5Calpha.%5Ctau" alt="\mu^+\alpha.\tau = \mu^-\alpha.\tau" eeimg="1"/>这种情况下<i>α</i>没用 似乎看起来减少了需要处理的类型,那么就很好,然而有个叫<b>Bekic</b>的科学家发现我们可以找到一种类型成立表达式 <img src="https://www.zhihu.com/equation?tex=%5Ctau+%5Cequiv+%5Ctau+%5Crightarrow+%5Ctau" alt="\tau \equiv \tau \rightarrow \tau" eeimg="1"/> (当然连我觉得都很扯,这都是什么烂七八糟的东西,不过人家有理有据,看看他是怎么搞得)所以按照他的思路我们可以写出这个东西 <img src="https://www.zhihu.com/equation?tex=%5C%5C%5Ctau_1%3D%5Ctau_2+%5Crightarrow+%5Ctau_1+%5Cqquad+%5Ctau_2%3D%5Ctau_1+%5Crightarrow+%5Ctau_2%5C%5C" alt="\\\tau_1=\tau_2 \rightarrow \tau_1 \qquad \tau_2=\tau_1 \rightarrow \tau_2\\" eeimg="1"/> </p><p>顺着这个思路带入<i>μ</i></p><p><img src="https://www.zhihu.com/equation?tex=%5C%5C%5Ctau_1%3D%5Cmu%5Calpha.%5Ctau_2+%5Crightarrow+%5Calpha+%5Cqquad+%5Ctau_2%3D%5Cmu%5Cbeta.%5Ctau_1+%5Crightarrow+%5Cbeta%5C%5C" alt="\\\tau_1=\mu\alpha.\tau_2 \rightarrow \alpha \qquad \tau_2=\mu\beta.\tau_1 \rightarrow \beta\\" eeimg="1"/> </p><p>替换一下就可以得到</p><p><img src="https://www.zhihu.com/equation?tex=%5C%5C%5Ctau_1%3D%5Cmu%5Calpha.%28%5Cmu%5Cbeta.%5Calpha+%5Crightarrow+%5Cbeta%29+%5Crightarrow+%5Calpha+%5Cqquad+%5Ctau_2%3D%5Cmu%5Cbeta.%28%5Cmu%5Calpha.%5Cbeta+%5Crightarrow+%5Calpha%29+%5Crightarrow+%5Cbeta%5C%5C" alt="\\\tau_1=\mu\alpha.(\mu\beta.\alpha \rightarrow \beta) \rightarrow \alpha \qquad \tau_2=\mu\beta.(\mu\alpha.\beta \rightarrow \alpha) \rightarrow \beta\\" eeimg="1"/> </p><p>然后我们说过这种情况下<i>α</i>,<i>β</i>没蛋的用,所以利用模式匹配总结一下</p><p><img src="https://www.zhihu.com/equation?tex=%5Ctau_1+%5Cequiv+%5Ctau_2" alt="\tau_1 \equiv \tau_2" eeimg="1"/>所以....推出来了这个脑残的表达式 <img src="https://www.zhihu.com/equation?tex=%5Ctau+%5Cequiv+%5Ctau+%5Crightarrow+%5Ctau" alt="\tau \equiv \tau \rightarrow \tau" eeimg="1"/>我们为了纪念他,给他放个特例叫他 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau_1%2C%5Ctau_2%29" alt="\phi(\tau_1,\tau_2)" eeimg="1"/>他的不动点就是 <img src="https://www.zhihu.com/equation?tex=%5C%5C%5Cmu.%5Calpha.%5Cphi%28%5Cmu%5Cbeta.%5Cphi%28%5Calpha%2C%5Cbeta%29%2C%5Calpha%29%5C%5C" alt="\\\mu.\alpha.\phi(\mu\beta.\phi(\alpha,\beta),\alpha)\\" eeimg="1"/></p><p>我知道我知道,里面可以继续展开我就不展开了....</p><p class="ztext-empty-paragraph"><br/></p><h2><b>稳健性(Soundness)</b></h2><p>我们的<b>MLsub</b>的<b>subtyping</b>并不是一个由案例来定义的,同时靠着案例反演呀并不是一个非常有意义的操作(所以这就是我unsound的理由,咳咳咳) 实际上,仅仅给出 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1+%5Cleq+%5Ctau_2+%5Crightarrow+%5Ctau_3" alt="\tau_1 \leq \tau_2 \rightarrow \tau_3" eeimg="1"/>我们可以得到 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1+%3D+%5Cbot" alt="\tau_1 = \bot" eeimg="1"/> 或者是 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1+%3D+%28%5Calpha+%5Crightarrow+%5Cbeta%29%5Csqcap+%5Calpha" alt="\tau_1 = (\alpha \rightarrow \beta)\sqcap \alpha" eeimg="1"/></p><p><b>引论三(反转性)</b>, 如果 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1%5Crightarrow%5Ctau_2%5Cleq%5Ctau_1%27%5Crightarrow%5Ctau_2%27" alt="\tau_1\rightarrow\tau_2\leq\tau_1&#39;\rightarrow\tau_2&#39;" eeimg="1"/> 则 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1%27%5Cleq%5Ctau_1%2C%5Ctau_2%27%5Cleq%5Ctau_2" alt="\tau_1&#39;\leq\tau_1,\tau_2&#39;\leq\tau_2" eeimg="1"/>,如果 <img src="https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D+%5Cleq+%5C%7Bg%5C%7D" alt="\{f\} \leq \{g\}" eeimg="1"/>则对于 <img src="https://www.zhihu.com/equation?tex=l+%5Cin+dom%5C+g" alt="l \in dom\ g" eeimg="1"/>里 <img src="https://www.zhihu.com/equation?tex=f%28l%29%5Cleq+g%28l%29" alt="f(l)\leq g(l)" eeimg="1"/>幸好这个有proof.<br/><br/> <b>理论四(进展性),</b>如果 <img src="https://www.zhihu.com/equation?tex=%5Cvdash+e%3A%5Ctau" alt="\vdash e:\tau" eeimg="1"/> ,要么<i>e</i>是个值,要么是 <img src="https://www.zhihu.com/equation?tex=e+%5Crightarrow+e%27+forsome%5C+e" alt="e \rightarrow e&#39; forsome\ e" eeimg="1"/></p><p><b>理论五(保留性)</b>如果 <img src="https://www.zhihu.com/equation?tex=%5Cvdash+e%3A%5Ctau" alt="\vdash e:\tau" eeimg="1"/> ,同时 <img src="https://www.zhihu.com/equation?tex=e+%5Crightarrow+e%27+forsome%5C+e" alt="e \rightarrow e&#39; forsome\ e" eeimg="1"/> , <img src="https://www.zhihu.com/equation?tex=%5Cvdash+e%27%3A%5Ctau" alt="\vdash e&#39;:\tau" eeimg="1"/> </p><p class="ztext-empty-paragraph"><br/></p><h2><b>最后再吹一下牛逼的类型推导</b></h2><p>我们知道<b>MLsub</b>是一个非常的强大的东西,刚才我提到过<b>MLrec</b>那么<b>MLsub</b>是严格的包含了整个<b>MLrec</b>的存在,所以看不懂很正常咳咳咳.</p><p>假如我们有个函数:</p><p><img src="https://www.zhihu.com/equation?tex=%5Clambda+f.%5Clambda+x.f%28f+x%29" alt="\lambda f.\lambda x.f(f x)" eeimg="1"/> </p><p>在一般的<b>ML</b>下的类型回事这样式(shai)儿的 <img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha.%28%5Calpha+%5Crightarrow+%5Calpha%29+%5Crightarrow+%5Calpha+%5Crightarrow+%5Calpha" alt="\forall \alpha.(\alpha \rightarrow \alpha) \rightarrow \alpha \rightarrow \alpha" eeimg="1"/> 我们<b>MLsub</b>能带来更加符合直觉,更好看的类型 <img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha%2C%5Cbeta.%28%28%5Calpha+%5Csqcup+%5Cbeta%29%5Crightarrow+%5Cbeta%29%5Crightarrow%28%5Calpha+%5Crightarrow+%5Cbeta%29" alt="\forall \alpha,\beta.((\alpha \sqcup \beta)\rightarrow \beta)\rightarrow(\alpha \rightarrow \beta)" eeimg="1"/> 这个栗子不是特别突出</p><p>再举一个栗子,大家都知道这个函数吧 <img src="https://www.zhihu.com/equation?tex=%5Clambda+x.+xx" alt="\lambda x. xx" eeimg="1"/> 我们蠢萌的<b>ML</b>没法举出这个东西的类型,但是我们<b>MLsub</b>就可以差不多的推出来个这样的东西</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha%2C%5Cbeta.%28%28%5Calpha+%5Crightarrow+%5Cbeta%29%5Csqcap+%5Calpha%29%5Crightarrow+%5Cbeta" alt="\forall \alpha,\beta.((\alpha \rightarrow \beta)\sqcap \alpha)\rightarrow \beta" eeimg="1"/> </p><p>一看,哇,漂亮对吧,一个 <img src="https://www.zhihu.com/equation?tex=%5Csqcap" alt="\sqcap" eeimg="1"/>就解决了这个<i>x</i>的类型归属问题,同时解决了递归. </p><p class="ztext-empty-paragraph"><br/></p><hr/><p>这一章稍微有点长,有的没的的东西讲的有点多,还是老规矩,大佬觉得错了就赶紧评论</p>