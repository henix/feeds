<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>机器学习资产配置</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/51426250">原文</a></p>
<p>作者：Marcos Lopez de Prado。AQR Capital Management, LLC; Cornell University - Operations Research &amp; Industrial Engineering; RCC - Harvard University</p><p><i>摘要：</i>介绍了<b>分层风险平价（Hierarchical Risk Parity HRP）</b>方法。HRP组合涉及二次优化器的三个主要问题，特别是Markowitz的关键线算法（Critical Line Algorithm CLA）：不稳定性，集中度和性能不佳。HRP应用现代数学（图论和机器学习技术），根据协方差矩阵中包含的信息构建多元化投资组合。然而，与二次优化器不同，HRP不需要协方差矩阵的可逆性。实际上，HRP可以在一个恶化的甚至是奇异的协方差矩阵上计算投资组合，这对于二次优化器来说是不可能的。蒙特卡罗实验表明，尽管最小方差是CLA的优化目标，但HRP提供的样本间差异小于CLA。与传统的风险平价方法相比，HRP在样本外产生的风险较低的投资组合。历史分析还表明，HRP的表现优于标准方法（Kolanovic等[2017]，Raffinot [2017]）。<b>HRP的实际应用是确定跨多个机器学习策略的权重分配。</b></p><h2><b>1.介绍</b></h2><p>投资组合构建可能是最经常出现的金融问题。投资经理必须每天建立投资组合，包含他们对风险和回报的看法和预测。这是24岁的马科维茨在六十多年前试图回答的原始问题。他深刻的洞察力是认识到风险调整后的收益与不同的最优投资组合有关，因此提出了“有效前沿”的概念（Markowitz [1952]）。其中一个含义是，将所有资产分配给预期回报最高的投资很少是最优的。相反，我们应该考虑替代投资之间的相互关系，以建立多元化的投资组合。</p><p>在1954年获得博士学位之前，Markowitz离开了学术界，为兰德公司工作，在那里他开发了关键线算法(CLA)。CLA是一种二次优化程序，专门针对不等式约束的投资组合优化问题而设计。该算法值得注意的是，它保证了在已知次数的迭代之后找到精确解，并且它巧妙地绕过了Karush-Kuhn-Tucker条件。该算法的描述和开源实现可以在Bailey和Lo pez de Prado [2013]中找到。令人惊讶的是，大多数金融从业者似乎仍然没有意识到CLA，因为他们经常依赖通用的二次规划方法，这些方法无法保证正确的解决方案或停止时间。</p><p>尽管马科维茨理论的辉煌，但许多实际问题使得CLA解决方案有些不可靠。一个主要的警告是，预测回报的微小偏差将导致CLA产生非常不同的投资组合（Michaud [1998]）。鉴于很少能够以足够的准确度预测回报，许多作者选择完全放弃回归并专注于协方差矩阵。这导致了基于风险的资产配置方法，其中“风险平价”就是一个突出的例子（Jurczenko [2015]）。降低对回报的预测会改善，但不会阻止不稳定性问题。原因是二次规划方法需要正定协方差矩阵的逆（所有特征值必须为正）。当协方差矩阵在数值上受到病态调节时，即当它具有高条件数时（Bailey和Lo pez de Prado [2012]），这种求逆容易出现大的误差。</p><p><b>2.马科维茨曲线</b></p><p>     协方差，相关矩阵的条件数是其最大和最小特征值之间的比率的绝对值。图1绘制了几个相关矩阵的分类特征值，其中条件数是每条线的第一个和最后一个值之间的比率。这个数字对于对角线相关矩阵是最低的，这是它自己的逆矩阵。随着我们添加相关（多线性）投资，条件数量也会增加。在某些时候，条件数很高，数值误差使得逆矩阵太不稳定：任何条目的微小变化都会导致非常不同的逆。这是Markowitz的诅咒：投资越相关，多样化的需求就越大，但我们越有可能获得不稳定的解决方案。多样化的好处往往被估计错误所抵消。</p><img src="https://pic3.zhimg.com/v2-7bfb526ca0437bf98e76f0cfdc104df9_r.jpg" data-caption="图1 Markowitz诅咒的可视化。对角线相关矩阵具有最低的条件数。 当我们添加相关投资时，最大特征值更大，最小特征值更低。条件数迅速上升，导致逆相关矩阵不稳定。在某些时候，多样化的好处远远超过估计误差。" data-size="normal" data-rawwidth="710" data-rawheight="558" data-watermark="watermark" data-original-src="v2-7bfb526ca0437bf98e76f0cfdc104df9" data-watermark-src="v2-6d612d3fc07aec228b68545a325d4d2f" data-private-watermark-src=""><p>增加协方差矩阵的大小只会使事情变得更糟，因为每个协方差系数都用较少的自由度进行估计。通常，我们需要至少N(N+1)/2个独立且相同分布（IID）的观测，以便估计大小为N的非单数的协方差矩阵。例如，估计大小为50的可逆协方差矩阵需要至少5年的日IID数据。正如大多数投资者所知，相关结构在这么长的时间内不会因任何合理的置信水平而保持不变。这些挑战的严重性体现在这样一个事实上：甚至简单1/N投资组合已被证明能够超出均值-方差和基于风险的优化样本（De Miguel等人[2009]）。</p><p><b>3.从几何到分层关系</b></p><p>近年来，这些不稳定性问题受到了极大关注。大多数替代方案试图通过引入额外约束（Clarke等人[2002]），引入贝叶斯先验（Black and Litterman [1992]）或改进协方差矩阵逆的数值稳定性来实现稳健性（Ledoit和Wolf [2003]）。</p><p>到目前为止所讨论的所有方法，尽管近年来发表，都是从（非常）经典的数学领域得出的：几何学，线性代数和微积分。相关矩阵是线性代数对象，其测量由返回序列形成的向量空间中的任意两个向量之间的角度的余弦（参见Calkin和Lo pez de Prado [2014a，2015b]）。二次优化器不稳定的一个原因是向量空间被建模为完全图，其中每个节点都是替代另一个节点的潜在候选者。在算法术语中，矩阵求逆意味着评估整个图形中的部分相关性。图16.2（a）显示了50×50的协方差矩阵所暗示的关系，即50个节点和1225个边缘。这种复杂的结构放大了小的估计误差，导致不正确的解决方案。直观地说，希望丢弃不必要的边缘。</p><p>让我们暂时考虑这种拓扑结构的实际意义。假设投资者希望建立多元化的证券组合，包括数百种股票，债券，对冲基金，房地产，私募等。一些投资看起来更接近彼此，其他投资似乎相互补充。例如，可以根据流动性，规模，行业和地区对股票进行分组，其中给定组中的股票竞争分配。在决定向像摩根大通这样的大型上市美国金融股进行分配时，我们会考虑增加或减少分配给另一家大型公开交易的美国银行，如高盛，而不是瑞士的一家小型社区银行或持有的房地产银行。加勒比。然而，对于相关矩阵，所有投资都是彼此的潜在替代品。换句话说，相关矩阵缺乏层次结构的概念。缺乏层次结构允许权重以非预期的方式自由变化，这是CLA不稳定的根本原因。图16.2（b）显示了称为树的层次结构。树结构引入了两个理想的特征：（1）它只有N-1个边连接N个节点，因此权重只在不同层次级别的对等体之间重新平衡; （2）权重从上到下分布，与有多少资产管理者建立其投资组合（例如，从资产类别到部门到个别证券）一致。由于这些原因，层次结构的设计更好，不仅可以提供稳定而且直观的结果。</p><p>在本章中，我们将研究一种新的投资组合构建方法，该方法使用现代数学解决CLA的陷阱：图论和机器学习。该分层风险奇偶校验方法使用协方差矩阵中包含的信息，而不需要其反演或正定性。HRP甚至可以基于奇异协方差矩阵来计算投资组合。该算法分三个阶段运行：树聚类，准对角化和递归二分法.</p><img src="https://pic4.zhimg.com/v2-7c4a47f4c34540863fdcef46d45f853a_r.jpg" data-caption="" data-size="normal" data-rawwidth="708" data-rawheight="740" data-watermark="watermark" data-original-src="v2-7c4a47f4c34540863fdcef46d45f853a" data-watermark-src="v2-85b53990e02d318d7e18c72274de3d9a" data-private-watermark-src=""><img src="https://pic3.zhimg.com/v2-30b549ec40239bc032e3b5afbd0a0047_r.jpg" data-caption="图 2完全图和树图结构。相关矩阵可以表示为完全图，缺少层次结构的概念：每个投资都可以替代另一个投资；相反，树结构包含层次关系。" data-size="normal" data-rawwidth="702" data-rawheight="532" data-watermark="watermark" data-original-src="v2-30b549ec40239bc032e3b5afbd0a0047" data-watermark-src="v2-d74a1b4bab82c1ad5842625a6863b247" data-private-watermark-src=""><p><b>3.1树聚类</b></p><p>考虑一个T*N阶的观测矩阵X，比如N个变量在T个周期上的收益序列。我们希望将这N个列向量组合成簇的分层结构，以便分配可以通过树图向下游流动。</p><p>(1)计算协方差矩阵和距离矩阵：</p><p>根据收益率序列计算相关系数矩阵： <equation>\rho = \left\{ \rho_{i,j} \right\}_{i,j=1,2,...,N}</equation> 其中 <equation>\rho_{i,j}= \rho(X_i,X_j)</equation> </p><p>定义距离度量：</p><p><equation>d:(X_i,X_j)\subset B\rightarrow d_{i,j}=d(X_i,X_j)=\sqrt{\frac{1}{2}(1-\rho_{i,j})}, d_{i,j}\in[0,1]</equation> </p><p>其中B是集合{1,2,...,N}中项的笛卡尔积。</p><p>可以计算得到N*N阶距离矩阵D， <equation>D = \left\{ d_{i,j} \right\}_{i,j=1,2,...,N}</equation> </p><p>矩阵D是一个合适的度量空间，度量空间(Metric Space)，在数学中是指一个集合，并且该集合中的任意元素之间的距离是可定义的，也称距离空间。即满足：</p><p>(i)正定性： <equation>d(x,y)\geq0,d(x,y)=0\Leftrightarrow x=y</equation> </p><p>(ii)对称性： <equation>d(x,y)=d(y,x)</equation> </p><p>(iii)三角不等式： <equation>d(x,z)\leq d(x,y) +d(y,z)</equation> </p><p>证明略</p><p>例：</p><p><equation>{\rho_{i,j}}=\left (\begin{smallmatrix} 1 &amp; 0.7 &amp;0.2 \\  0.7 &amp; 1 &amp; -0.2\\  0.2 &amp;-0.2  &amp;1  \end{smallmatrix}\right )\rightarrow  {d_{i,j}}=\left (\begin{smallmatrix} 0 &amp; 0.5659 &amp;0.9747 \\  0.5659 &amp; 0 &amp; 1.1225\\  0.9747 &amp;1.1225  &amp;0  \end{smallmatrix}\right )</equation> </p><p>(2)计算距离矩阵D中两两列向量的欧几里得距离</p><p><equation>\tilde{d}:(D_i,D_j)\subset B \rightarrow \mathbb{R}\in[0,\sqrt{N}]</equation> </p><p><equation>\tilde{d}_{i,j}=\tilde{d}(D_i,D_j)=\sqrt{\sum_{n=1}^{N}{(d_{n,i}-d_{n,j})^{2}}}</equation> </p><p><b>注意到 <equation>d_{i,j}</equation> 和 <equation>\tilde{d}_{i,j}</equation> 的不同：</b> <equation>d_{i,j}</equation> 定义在矩阵X的列向量上， <equation>\tilde{d}_{i,j}</equation> 定义在矩阵D的列向量上(距离的距离)，因此， <equation>\bar{d}</equation> 是在定义在整个度量空间D上的距离，每个 <equation>\bar{d}_{i,j}</equation> 是整个相关矩阵(而不是特定的互相关对)的函数。</p><p>例：</p><p><equation>{d_{i,j}}=\left (\begin{smallmatrix} 0 &amp; 0.3873 &amp;0.6325 \\  0.3873 &amp; 0 &amp; 0.7746\\  0.6325 &amp;0.7746  &amp;0  \end{smallmatrix}\right )\rightarrow  {\tilde{d}_{i,j}}=\left (\begin{smallmatrix} 0 &amp; 0.5659 &amp;0.9747 \\  0.5659 &amp; 0 &amp; 1.1225\\  0.9747 &amp;1.1225  &amp;0  \end{smallmatrix}\right )</equation> </p><p>(3)将一对 <equation>(i^*,j^*)</equation> 聚类在一起，使得 <equation>(i^*,j^*)=argmin_{(i,j),i\ne j} \left\{ \tilde{d}_{i,j} \right\}</equation> ，并将该聚类表示为 <equation>u(1)</equation> </p><p>例：</p><p><equation>{\tilde{d}_{i,j}}=\left (\begin{smallmatrix} 0 &amp; 0.5659 &amp;0.9747 \\  0.5659 &amp; 0 &amp; 1.1225\\  0.9747 &amp;1.1225  &amp;0  \end{smallmatrix}\right )\rightarrow u(1)=(1,2)</equation> </p><p>(4)需要定义新形成的簇u(1)和单个项(非簇)之间的距离，以便可以更新 <equation>\left\{ \tilde{d}_{i,j} \right\}</equation>。在层次聚类分析中，这被称为“链接标准”。例如，我们可以将 <equation>\tilde{d}</equation>的项i和新簇u(1)之间的距离定义为： <equation>\dot{d}_{i,u(1)}=min\left[ \left\{ \tilde{d}_{i,j} \right\} \right]</equation> (最近点算法)</p><p>例：</p><p><equation>u(1)=(1,2)\rightarrow \left\{ \dot{d}_{i,u(1)} \right\}=\begin{bmatrix} min[0,0.5969]\\  min[0.5969,0]\\  min[0.9747,1.1225]\end{bmatrix}=\begin{bmatrix} 0\\  0\\  0.9747\end{bmatrix}</equation> </p><p>(5)更新矩阵 <equation>\left\{ \tilde{d}_{i,j} \right\}</equation>通过附加 <equation> \dot{d}_{i,u(1)} </equation> ，之后删除被聚类的行和列 <equation>j\in u(1)</equation> </p><p>例：</p><p><equation>\left\{ \tilde{d}_{i,j} \right\}_{i,j={1,2,3,4}}  = \begin{bmatrix} 0&amp; 0.5659 &amp;0.9747 &amp;0 \\   0.5659&amp; 0&amp; 1.1225&amp; 0\\   0.9747&amp; 1.1225 &amp; 0 &amp; 0.9747\\   0&amp;0  &amp;0.9747  &amp;0  \end{bmatrix}\rightarrow\left\{ \tilde{d}_{i,j} \right\}_{i,j={3,4}} = \begin{bmatrix}  0&amp; 0.9747\\  0.9747 &amp;0  \end{bmatrix}</equation> </p><p><br></p><p>(6)递归应用，步骤3,4和5允许将N-1个这样的簇附加到矩阵D，此时最终的簇包含所有原始项，聚类算法终止：</p><p><equation>\left\{ \tilde{d}_{i,j} \right\}_{i,j={3,4}} = \begin{bmatrix}  0&amp; 0.9747\\  0.9747 &amp;0  \end{bmatrix}\rightarrow u(2)=(3,4)\rightarrow Stop</equation> </p><p>图3显示了此示例在每次迭代时形成的聚类，以及触发每个聚类的距离（第三步）。此过程可应用于各种距离度量，参见Rokach和Maimon [2005]的替代指标，关于Fiedler矢量的讨论和Stewart在Brualdi [2010]中的谱聚类方法，以及scipy库中的算法。</p><img src="https://pic4.zhimg.com/v2-bd0f39328217a321d156db8fdaa6e2e4_r.jpg" data-caption="图3簇形成的顺序。数值示例导出的树结构，此处绘制为树形图。 y轴测量两个合并叶片之间的距离。" data-size="normal" data-rawwidth="698" data-rawheight="560" data-watermark="watermark" data-original-src="v2-bd0f39328217a321d156db8fdaa6e2e4" data-watermark-src="v2-cf72a00ddaf4e64cfb745d18f40bc98c" data-private-watermark-src=""><p>在这个阶段，允许我们将链接矩阵定义为(N-1)*4阶矩阵，具有结构 <equation>Y=\left\{ y_{m,1},y_{m,2},y_{m,3},y_{m,4} \right\}_{m=1,2,...,N-1}</equation> </p><p>项 <equation>\left( y_{m,1},y_{m,2} \right)</equation> 报告成分，项 <equation>y_{m,3}</equation> 报告 <equation>y_{m,1}</equation> 和 <equation>y_{m,2}</equation> 的距离,项 <equation>y_{m,4}</equation> 报告聚类m中包含的原始项数</p><p><b>3.2准对角化</b></p><p>此阶段重新组织协方差矩阵的行和列，以便最大值位于对角线上。协方差矩阵的这种准对角化（不需要改变基础）提供了一个有用的特性：类似的投资被放在一起，不同的投资相隔很远(例如，参见图5和图6)。该算法的工作原理如下：我们知道链接矩阵的每一行将两个分支合并为一个。我们用递归的方式替换 <equation>\left( y_{N-1,1},y_{N-1,2} \right)</equation>中的聚类，直到没有聚类为止。这些替换保留了聚类的顺序。输出是原始（非聚集）项目的排序列表。</p><p><b>3.3递归二分法</b></p><p>阶段2提供了准对角矩阵,逆方差分配对于对角协方差矩阵是最优的。阶段3将权重与子集的变量成反比分配，当协方差矩阵是对角线时，这种分配是最优的，证明如下：</p><p>考虑大小为N的标准二次优化问题：</p><p><equation>min_{w}\left\{ w^TVw \right\} </equation> </p><p><equation>s.t.:w^Ta=1</equation> </p><p>解为: <equation>w=\frac{V^{-1}a}{a^TV^{-1}a}</equation> ，对特征向量 <equation>a=1_N</equation> ,解是最小方差组合。</p><p>如果V是对角矩阵，那么 <equation>w_n=\frac{V^{-1}_{n,n}}{\sum_{i=1}^{N}{V^{-1}_{i,i}}}</equation> </p><p>特别地，当N=2时： <equation>w_1=\frac{V^{-1}_{1,1}}{V^{-1}_{1,1}+V^{-1}_{2,2}}=1-\frac{V_{1,1}}{V_{1,1}+V_{2,2}}</equation> </p><p>我们可以用两种不同的方式利用这些事实：自下而上，将连续子集的方差定义为逆方差分配的方差; 或者自上而下，将相邻子集之间的分配与其聚合方差成反比。以下算法形式化了这个想法：</p><p>(1)算法初始化为：</p><p>(a)设定项清单： <equation>L=\left\{ L_0 \right\},L_0=\left\{ n \right\}_{n=1,2,...,N}</equation> </p><p>(b)为所有项分配单位权重： <equation>w_n=1,\forall n=1,2,...,N</equation> </p><p>(2)如果 <equation>\left| L_i \right|=1, \forall L_i\in L</equation>，那么算法终止；</p><p>(3)对每个 <equation>\left| L_i \right|&gt;1, \forall L_i\in L</equation> :</p><p>(a)把 <equation>L_{i}</equation>二分为两个子集 <equation>L^{(1)}_i\cup L^{(2)}_i =L_i</equation>，其中 <equation>\left| L^{(1)}_i \right|=int\left( \frac{1}{2}\left| L_i \right| \right)</equation> ，顺序被保留；</p><p>(b)定义 <equation>L^{(j)}_i,j=1,2</equation>的方差为二次型 <equation>\tilde{V^{(j)}_i}\equiv (\tilde{w}^{(j)}_i)^TV^i_j\tilde{w}^{(j)}_i</equation> ，其中 <equation>V^{(j)}_i</equation> 是二分 <equation>L^{(j)}_i</equation>的成分的协方差矩阵：</p><p><equation>w^{(j)}_i= diag\left[ V^{(j)}_i \right] ^{-1}\frac{1}{tr \left[ diag\left[ V^{(j)}_i \right] ^{-1} \right]}</equation> </p><p>其中：diag[A]表示取出矩阵A的对角元然后构建一个以对角元为对角的对角矩阵；</p><p>tr[A]表示矩阵A的迹</p><p>(c)计算分裂因子： <equation>\alpha_i = 1-\frac{V^1_i}{V^1_i + V^2_i},0 \leq\alpha_i\leq1</equation> </p><p>(d)对 <equation>\forall n\in L^1_i</equation>,重新调整分配 <equation>w_n</equation> 的因子为 <equation>\alpha_i</equation> </p><p>对 <equation>\forall n\in L^2_i</equation>，重新调整分配 <equation>w_n</equation> 的因子为 <equation>1-\alpha_i</equation></p><p>(4)回到步骤2；</p><p>步骤3b利用准对角化自下而上，因为它使用逆方差加权来定义划分的方差。步骤3c利用准对角化自顶向下，因为它将权重与群集的方差成反比分割。该算法保证 <equation>0\leq w_i\leq1,\forall n=1,2,...,N</equation> 和 <equation>\sum_{i=1}^{N}{w_i}=1</equation> ，因为在每次迭代中分割从较高层级接收的权重。通过根据用户的偏好替换步骤3c，3d和3e中的等式，可以在该阶段容易地引入约束。</p><p><br></p><p><b>4.数值例子：</b></p><p><b>数值例子1：上证50</b></p><p>下面考虑上证50：2013-01-01～2018-12-01采样5日的价格数据，数据来源ricequant，简单起见，成分股取2013-01-01的成分股，在此期间保持不变</p><p><b>取最近120天数据为窗口(约6月)，根据最近120天的数据计算权重，在未来20天以此权重配比，每隔20日重配权重，对比1/N，IVP，HRP方法,下面计算年化收益和波动率时以每年245日计，年化收益为年化复合收益，无风险收益率以0%计</b></p><p>1.数据预处理：生成收益序列、协方差矩阵、相关系数矩阵、距离矩阵、链接矩阵</p><img src="https://pic1.zhimg.com/v2-1a2058c7d5a391db3ba7228a24ee5a41_r.jpg" data-caption="上证50 2013-01-01 到 2015-01-27相关系数矩阵热力图，可以看见上证50之间的相关性都比较强，甚至没有负相关..." data-size="normal" data-rawwidth="830" data-rawheight="686" data-watermark="watermark" data-original-src="v2-1a2058c7d5a391db3ba7228a24ee5a41" data-watermark-src="v2-da25c898d2705e96a6117cffe9311190" data-private-watermark-src=""><p>2.准对角化：</p><img src="https://pic2.zhimg.com/v2-aaeaf89070d2340bbd9b3b740173c745_r.jpg" data-caption="准对角化后的相关系数矩阵，相关系数矩阵的这种准对角化提供了一个有用的特性：类似的投资被放在一起，不同的投资相隔很远" data-size="normal" data-rawwidth="830" data-rawheight="684" data-watermark="watermark" data-original-src="v2-aaeaf89070d2340bbd9b3b740173c745" data-watermark-src="v2-fe6d461f30df4390141a02e58865391a" data-private-watermark-src=""><p>3.HRP分配：</p><img src="https://pic4.zhimg.com/v2-fe98cb3e8029e4bbdda860badd3bf951_r.jpg" data-caption="窗口120日 超前预测20日 每隔20日调仓。1/N:年化收益:13.01%,年化标准差:24.97%,年化夏普:0.52IVP:年化收益:17.15%,年化标准差:23.26%,年化夏普:0.74HRP:年化收益:18.38%,年化标准差:23.26%,年化夏普:0.79" data-size="normal" data-rawwidth="716" data-rawheight="468" data-watermark="watermark" data-original-src="v2-fe98cb3e8029e4bbdda860badd3bf951" data-watermark-src="v2-f0d2649cd7255e6267bae22af1f33915" data-private-watermark-src=""><img src="https://pic1.zhimg.com/v2-fc04554bfb05bd9600cd2ae4f4a11a9e_r.jpg" data-caption="窗口120日 超前预测10日 每隔10日调仓。1/N:年化收益:12.58%,年化标准差:24.25%,年化夏普:0.52IVP:年化收益:15.91%,年化标准差:22.87%,年化夏普:0.70HRP:年化收益:15.99%,年化标准差:22.87%,年化夏普:0.70" data-size="normal" data-rawwidth="716" data-rawheight="482" data-watermark="watermark" data-original-src="v2-fc04554bfb05bd9600cd2ae4f4a11a9e" data-watermark-src="v2-34e4aa6279928ea015f399083b447c31" data-private-watermark-src=""><img src="https://pic3.zhimg.com/v2-1c31162f7278ea10be976eb3e7d94264_r.jpg" data-caption="窗口120日 超前预测30日 每隔30日调仓。1/N:年化收益:12.50%,年化标准差:27.97%,年化夏普:0.45IVP:年化收益:16.38%,年化标准差:25.47%,年化夏普:0.64HRP:年化收益:18.16%,年化标准差:25.47%,年化夏普:0.71" data-size="normal" data-rawwidth="710" data-rawheight="482" data-watermark="watermark" data-original-src="v2-1c31162f7278ea10be976eb3e7d94264" data-watermark-src="v2-45d6a2d33e5acb08a923ae1cbae0550d" data-private-watermark-src=""><p><br></p><p>此处仅测试了一下，没有进一步增加约束，还有很大改进空间，只利用了历史收益数据，比如可以将对收益的预测加入，权重低的都近乎为0，可以加入最小最大权重约束和基数约束</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
