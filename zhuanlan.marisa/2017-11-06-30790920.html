<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Agda 中的证明，从一点五到二</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/30790920">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-043f810573d217996a346e86be90677f_r.jpg" alt=""></div><p>最近突然忙了起来。这篇文章只是填一下上篇文章的坑。原文链接 <a href="http://ice1000.org/2017/11/06/ProofInAgda3/">Agda 中的证明，从一点五到二</a></p><p>上一篇说了很多只有一种情况的证明，这一篇说个有两种情况的。 到目前为止，按理说所有的字符都还能正常显示。</p><h2>前置知识</h2><ul><li><a href="http://ice1000.org/2017/11/02/ProofInAgda2/">上一篇文章</a></li></ul><p>以及，由于 Agda 语言的特殊性，本文将继续使用 LaTeX 和代码块来共同展示代码。 代码块唯一的作用在于便于复制，主要的呈现途径为 LaTeX 。</p><h2>上一篇的习题</h2><p>上一篇文章我留下了一个没提供证明的命题，现在给出完整答案：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp; {\land}{-}{\assoc}_0 : \forall \{P\ Q\ R\} \rightarrow ((P \land Q) \land R) \rightarrow (P \land (Q \land R)) \\ &amp; {\land}{-}{\assoc}_0 \ ({\land}{-}{\intro}\ ({\land}{-}{\intro}\ p\ q)\ r) = {\land}{-}{\intro}\ p\ ({\land}{-}{\intro}\ q\ r) \\ &amp; \\ &amp; {\land}{-}{\assoc}_1 : \forall \{P\ Q\ R\} \rightarrow (P \land (Q \land R)) \rightarrow ((P \land Q) \land R) \\ &amp; {\land}{-}{\assoc}_1 \ ({\land}{-}{\intro}\ p\ ({\land}{-}{\intro}\ q\ r)) = {\land}{-}{\intro}\ ({\land}{-}{\intro}\ p\ q)\ r \\ &amp; \\ &amp; {\land}{-}{\assoc} : \forall \{P\ Q\ R\} \rightarrow (P \land (Q \land R)) \Leftrightarrow ((P \land Q) \land R) \\ &amp; {\land}{-}{\assoc} ={\land}{-}{\intro} \ {\land}{-}{\assoc}_1 \ {\land}{-}{\assoc}_0 \end{align*}</equation> </p><code lang="agda">∧-assoc₀ : ∀ {P Q R} → ((P ∧ Q) ∧ R) → (P ∧ (Q ∧ R))
∧-assoc₀ (∧-intro (∧-intro p q) r) = ∧-intro p (∧-intro q r)

∧-assoc₁ : ∀ {P Q R} → (P ∧ (Q ∧ R)) → ((P ∧ Q) ∧ R)
∧-assoc₁ (∧-intro p (∧-intro q r)) = ∧-intro (∧-intro p q) r

∧-assoc : ∀ {P Q R} → (P ∧ (Q ∧ R)) ⇔ ((P ∧ Q) ∧ R)
∧-assoc = ∧-intro ∧-assoc₁ ∧-assoc₀ </code><p>确实没什么好说的，所以才能说是即得易见平凡，仿照上例显然。</p><h2>或相关的证明</h2><p>上一篇我有个东西没讲完，就是 “或” 。 它和 “与” 相对，它只要求两个命题中的一个成立。</p><p>因此，它对应着两个不同的情况：</p><p><equation>p \rightarrow (p \lor q) \\ q \rightarrow (p \lor q)</equation> </p><h2>定义 GADT</h2><p>把这个关系写成 GADT ，就是这样：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp; \data\ \_{\lor}\_\ (P\ Q : \Set) : \Set \where \\ &amp; \ \ {\lor}{-}{\intro}_0 : P \rightarrow P \lor Q \\ &amp; \ \ {\lor}{-}{\intro}_1 : Q \rightarrow P \lor Q \end{align*}</equation> </p><code lang="agda">data _∨_ (P Q : Set) : Set where
  ∨-intro₀ : P → P ∨ Q
  ∨-intro₁ : Q → P ∨ Q </code><p>这里我们遇到了一种和之前不一样的情况： 我们的 GADT 有了两种 instance 。 这意味着我们需要在证明的时候考虑两种不同的情况，分别针对这两种 instance 。</p><h2>证明一</h2><p>比如，我们可以证明一下这个命题：</p><p><equation>(p \rightarrow r) \land (q \rightarrow r) \land (p \lor q) \rightarrow r </equation> </p><p>它的逻辑很简单，在 <code class="inline">p</code> 和 <code class="inline">q</code> 都能推出 <code class="inline">r</code> 的时候， <code class="inline">p</code> <code class="inline">q</code> 只需要成立一个， <code class="inline">r</code> 就成立。 这个命题写成 Agda 的类型，就是：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\lor}{-}{\elim} : \forall \{P\ Q\} \{R : \Set\} \rightarrow (P \rightarrow R) \rightarrow (Q \rightarrow R) \rightarrow (P \lor Q) \rightarrow R</equation> </p><code lang="agda">∨-elim : ∀ {P Q} {R : Set} → (P → R) → (Q → R) → (P ∨ Q) → R </code><p>我们在证明中，需要同时对 <equation>(P \lor Q)</equation> 的两种可能的情况进行处理 （因为这个类型的东西既可以是通过 <code class="inline">P</code> 构造的，也可以是通过 <code class="inline">Q</code> 构造的）， 不然 Agda 的 exhaustiveness check 会报错的 （这也是为什么 <code class="inline">postulate</code> 不被推荐使用）。</p><p>首先考虑 <code class="inline">P</code> 成立的情况，我们有：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\lor}{-}{\elim}\pr \_ \ ({\lor}{-}{\elim}_0 \ p) = \pr p </equation> </p><code lang="agda">∨-elim pr _ (∨-intro₀ p) = pr p </code><p>然后考虑 <code class="inline">Q</code> 成立的情况，我们有：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} {\lor}{-}{\elim}\ \_ \qr \ ({\lor}{-}{\elim}_1 \ q) = \qr q </equation> </p><code lang="agda">∨-elim _ qr (∨-intro₁ q) = qr q </code><p>放在一起，就是：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp; {\lor}{-}{\elim} : \forall \{P\ Q\} \{R : \Set\} \rightarrow (P \rightarrow R) \rightarrow (Q \rightarrow R) \rightarrow (P \lor Q) \rightarrow R \\ &amp; {\lor}{-}{\elim}\pr \_ \ ({\lor}{-}{\elim}_0 \ p) = \pr p \\ &amp; {\lor}{-}{\elim}\ \_ \qr \ ({\lor}{-}{\elim}_1 \ q) = \qr q \end{align*}</equation> </p><code lang="agda">∨-elim : ∀ {P Q} {R : Set} → (P → R) → (Q → R) → (P ∨ Q) → R
∨-elim pr _ (∨-intro₀ p) = pr p
∨-elim _ qr (∨-intro₁ q) = qr q </code><p>这样，就 check 了。 十分简单。</p><h2>证明二</h2><p>和 <equation>\land</equation> 一样， <equation>\lor</equation> 也有交换律：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{where}{where} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{pr}{pr} \DeclareMathOperator{qr}{qr} \DeclareMathOperator{intro}{intro} \DeclareMathOperator{comm}{comm} \DeclareMathOperator{assoc}{assoc} \DeclareMathOperator{elim}{elim} \begin{align*} &amp; {\lor}{-}{\comm}' : \forall \{P\ Q\} \rightarrow (P \lor Q) \rightarrow (Q \lor R) \\ &amp; {\lor}{-}{\comm}' \ ({\lor}{-}{\intro}_0 \ p) = {\lor}{-}{\intro}_1 \ p \\ &amp; {\lor}{-}{\comm}' \ ({\lor}{-}{\intro}_1 \ q) = {\lor}{-}{\intro}_0 \ q \\ \\ &amp; {\lor}{-}{\comm} : \forall \{P\ Q\} \rightarrow (P \lor Q) \Leftrightarrow (Q \lor R) \\ &amp; {\lor}{-}{\comm} = {\land}{-}{\intro} \ {\lor}{-}{\comm}' \ {\lor}{-}{\comm}' \end{align*}</equation> </p><code lang="agda">∨-comm′ : ∀ {P Q} → (P ∨ Q) → (Q ∨ P)
∨-comm′ (∨-intro₀ p) = ∨-intro₁ p
∨-comm′ (∨-intro₁ q) = ∨-intro₀ q

∨-comm : ∀ {P Q} → (P ∨ Q) ⇔ (Q ∨ P)
∨-comm = ∧-intro ∨-comm′ ∨-comm′ </code><h2>结束</h2><p>这么快就没了？</p><p>其实只是填一下上一篇留下的坑。</p><p>是的，我说完了。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
