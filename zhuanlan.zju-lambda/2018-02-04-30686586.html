<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Agda 中的证明，从零到一</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/30686586">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-461e72ecf40a21b6804d43e7201d21de_b.jpg" alt=""></div><p>最近在学 Agda ，感觉摸到了定理证明的门，希望各路大神不吝赐教。这是一个系列，这篇文章讲的太基础是因为它是第一篇哈。原文链接：<a href="http://link.zhihu.com/?target=http%3A//ice1000.org/2017/11/01/ProofInAgda/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Agda 中的证明，从零到一</a></p><p>类型则命题，程序则证明。这句话表达了定理证明的一个很重要的思想。</p><p>我一开始就没有搞懂这句话在说什么。 在我自认为搞懂的时候，我把我以前没有搞懂的原因归结为我看的教程太垃圾了。</p><p>一开始我理解这个问题的同时，我以为我也理解了之前一个 Haskell 关于 <code>IO Monad</code> 的问题，但实际上不是我想的那样。 <a href="https://zhuanlan.zhihu.com/p/30686586/h%3Ccode%3Ettps://h%3C/code%3Eackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-1173" class="internal">Haskell 的 IO Monad 的实现</a> 比我想象的要复杂一些，因此本文不谈 Haskell 。</p><h2>前置知识</h2><p>这是一篇面向略懂 dependent type 的人的定理证明教程，然后你要看得懂类 Haskell 的语法。 因为我在学这个的时候就是只会点 Haskell ，然后用过 GADT 和 type family 模拟过 dependent type 。</p><p>给出一些参考资料：</p><ul><li><a href="http://link.zhihu.com/?target=http%3A//learn%253Ci%253Eyouahaskell.com/cha%253C/i%253Epters" class=" wrap external" target="_blank" rel="nofollow noreferrer">一个比较简单的 Haskell 入门教程 Learn you a Haskell</a></li><li><a href="https://www.zhihu.com/question/67043774/answer/249019401" class="internal">虎哥介绍的 GADT</a></li><li><a href="http://link.zhihu.com/?target=https%3A//www.codewars.com/kata/singletons" class=" wrap external" target="_blank" rel="nofollow noreferrer">介绍 GADT 的 CodeWars Kata: Singletons</a></li><li><a href="http://link.zhihu.com/?target=https%3A//www.codewars.com/kata/scott-encoding" class=" wrap external" target="_blank" rel="nofollow noreferrer">介绍 GADT 的 CodeWars Kata: Scott Encoding</a></li></ul><h2>声明在前面</h2><p>由于 Agda 语言的特殊性，本文将使用 LaTeX 和代码块来共同展示代码。 前者是为了保证字符的正确显示，后者是为了方便读者复制代码。</p><p>本文不讲 Agda 基本语法和 Emacs 的使用。可能以后会有另外的文章。</p><p>本文主要内容是帮助一个没接触过定理证明但是接触过 dependent type 的人（这就是我接触定理证明之前的状态）理解一个非常非常简单的定理证明的例子。</p><h2>如何理解定理证明</h2><p>首先，我们已经知道，我们这是要用类型表达命题，类型对应的实现来证明这个命题的正确性。</p><p>命题中的基本元素一般是值的类型(而且很多时候都是代数数据类型)，也就是 <img src="https://www.zhihu.com/equation?tex=%5CDeclareMathOperator%7BSet%7D%7BSet%7D+%5CDeclareMathOperator%7Brefl%7D%7Brefl%7D+%5CDeclareMathOperator%7Bproof%7D%7Bproof%7D+%5CDeclareMathOperator%7Bdata%7D%7Bdata%7D+%5CDeclareMathOperator%7Bwhere%7D%7Bwhere%7D+%5CDeclareMathOperator%7Bwith%7D%7Bwith%7D+%5CDeclareMathOperator%7BVect%7D%7BVect%7D+p+%5Crightarrow+q" alt="\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} p \rightarrow q" eeimg="1"> 的那个 <img src="https://www.zhihu.com/equation?tex=p" alt="p" eeimg="1"> 或者 <img src="https://www.zhihu.com/equation?tex=q" alt="q" eeimg="1"> 。 而这个 <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="\rightarrow" eeimg="1"> 对应的就是 “函数” 这一概念，它组合了两个类型，表达了 “蕴含” 这一逻辑概念。</p><p>比如，我实现了一个这样的类型的函数：</p><p><img src="https://www.zhihu.com/equation?tex=p+%5Crightarrow+q" alt="p \rightarrow q" eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span>p <span class="ow">→</span> q 
</code></pre></div><p>那么这个函数的实现就是</p><blockquote>如果 p 成立，则 q 成立</blockquote><p>，或者说，</p><blockquote><img src="https://www.zhihu.com/equation?tex=p+%5Crightarrow+q" alt="p \rightarrow q" eeimg="1"> </blockquote><p>这个命题的证明。</p><p>再比如，我实现了一个这样的类型的函数：</p><p><img src="https://www.zhihu.com/equation?tex=p+%5Crightarrow+q+%5Crightarrow+r+" alt="p \rightarrow q \rightarrow r " eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span>p <span class="ow">→</span> q <span class="ow">→</span> r 
</code></pre></div><p>那么这个函数的实现就是</p><blockquote>如果 p 成立，那么 “如果 q 成立，那么 r 成立” 这一命题成立</blockquote><p>，或者说，</p><blockquote><img src="https://www.zhihu.com/equation?tex=p+%5Crightarrow+%28+q+%5Crightarrow+r+%29" alt="p \rightarrow ( q \rightarrow r )" eeimg="1"> </blockquote><p>这个命题的证明。</p><p>其实我们原本想表达的意思是</p><blockquote><img src="https://www.zhihu.com/equation?tex=+p%5C+%5Cland+%5C+q%5Crightarrow+r+" alt=" p\ \land \ q\rightarrow r " eeimg="1"> </blockquote><p>但是这个 <img src="https://www.zhihu.com/equation?tex=%5Cland" alt="\land" eeimg="1"> 关系暂时没讲所以先就这样。</p><p>这就是 “类型则命题，程序则证明” 的含义。</p><p>在 Agda 中，上面的代码应该写成这样：</p><p><img src="https://www.zhihu.com/equation?tex=+%5CDeclareMathOperator%7BSet%7D%7BSet%7D+%5CDeclareMathOperator%7Brefl%7D%7Brefl%7D+%5CDeclareMathOperator%7Bproof%7D%7Bproof%7D+%5CDeclareMathOperator%7Bdata%7D%7Bdata%7D+%5CDeclareMathOperator%7Bwhere%7D%7Bwhere%7D+%5CDeclareMathOperator%7Bwith%7D%7Bwith%7D+%5CDeclareMathOperator%7BVect%7D%7BVect%7D+%5Cproof+%3A+%5C%7Bp%5C+q%5C+r+%3A+%5CSet%5C%7D+%5Crightarrow+p+%5Crightarrow+q+%5Crightarrow+r+" alt=" \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \proof : \{p\ q\ r : \Set\} \rightarrow p \rightarrow q \rightarrow r " eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span><span class="nf">proof</span> <span class="ow">:</span> <span class="o">{</span>p q r <span class="ow">:</span> <span class="kt">Set</span><span class="o">}</span> <span class="ow">→</span> p <span class="ow">→</span> q <span class="ow">→</span> r 
</code></pre></div><p>下面我们看一些实例。</p><h2>refl 与相等性</h2><p>之所以我没有再学习 Idris 就是因为那些教程没说 <code>Refl</code> 是啥 (Idris 叫 <code>Refl</code> ， Agda 叫 <code>refl</code>) 就直接在代码里面用了，我看的时候就一脸蒙蔽，还以为是我智商太低没看懂他 implicit 的东西。 但是好在我看了一坨很友好的 Agda 代码后民白了。</p><p>首先，我们可以定义这样一个用来表示相等关系的 GADT ，它对于任何一个 Level 的任何一个实例都成立。 这里我们用了 Universal Polymorphism 表达这个 “对于任何一个 Level “ 的概念。</p><p>然后我们使用 <code>refl</code> 这个类型构造器表达 “这个相等关系成立” 这一事实。</p><p>我们用 <img src="https://www.zhihu.com/equation?tex=%5Cequiv" alt="\equiv" eeimg="1"> 表示他（标准库的定义在 <code><a href="http://link.zhihu.com/?target=http%3A//agda.readthedocs.io/en/v2.5.3/language/built-ins.html%23equality" class=" wrap external" target="_blank" rel="nofollow noreferrer">Agda.Builtin.Equality</a></code> 中）：</p><p><img src="https://www.zhihu.com/equation?tex=+%5CDeclareMathOperator%7BSet%7D%7BSet%7D+%5CDeclareMathOperator%7Brefl%7D%7Brefl%7D+%5CDeclareMathOperator%7Bproof%7D%7Bproof%7D+%5CDeclareMathOperator%7Bdata%7D%7Bdata%7D+%5CDeclareMathOperator%7Bwhere%7D%7Bwhere%7D+%5CDeclareMathOperator%7Bwith%7D%7Bwith%7D+%5CDeclareMathOperator%7BVect%7D%7BVect%7D+%5Cbegin%7Balign%2A%7D+%26+%5Cdata%5C+%5C_%7B%5Cequiv%7D%5C_%5C+%5C%7Ba%5C%7D+%5C%7BA+%3A+%5CSet+a%5C%7D+%28x+%3A+A%29+%3A+A+%5Crightarrow+%5CSet+a%5Cwhere+%5C%5C+%26%5C+%5C+%5Crefl+%3A+x+%5Cequiv+x+%5Cend%7Balign%2A%7D" alt=" \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \begin{align*} &amp; \data\ \_{\equiv}\_\ \{a\} \{A : \Set a\} (x : A) : A \rightarrow \Set a\where \\ &amp;\ \ \refl : x \equiv x \end{align*}" eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span><span class="kr">data</span> _≡_ <span class="o">{</span>a<span class="o">}</span> <span class="o">{</span>A <span class="ow">:</span> <span class="kt">Set</span> a<span class="o">}</span> <span class="o">(</span>x <span class="ow">:</span> A<span class="o">)</span> <span class="ow">:</span> A <span class="ow">→</span> <span class="kt">Set</span> a <span class="kr">where</span>
  <span class="nf">refl</span> <span class="ow">:</span> x ≡ x 
</code></pre></div><p>如果你看不懂这个类型签名也没有关系，只需要接受”这个 GADT 只有一个叫 <code>refl</code> 的类型构造器”这一事实就好了。</p><p>然后我们可以用它进行一些证明。比如我们来证明相等性的传递性，也就是</p><blockquote>如果 a <img src="https://www.zhihu.com/equation?tex=%5Cequiv" alt="\equiv" eeimg="1"> b 并且 b <img src="https://www.zhihu.com/equation?tex=%5Cequiv" alt="\equiv" eeimg="1"> c ，那么 a <img src="https://www.zhihu.com/equation?tex=%5Cequiv" alt="\equiv" eeimg="1"> c</blockquote><p>。然后我们来看看这个命题对应的类型：</p><p><img src="https://www.zhihu.com/equation?tex=+%5CDeclareMathOperator%7BSet%7D%7BSet%7D+%5CDeclareMathOperator%7Brefl%7D%7Brefl%7D+%5CDeclareMathOperator%7Bproof%7D%7Bproof%7D+%5CDeclareMathOperator%7Bdata%7D%7Bdata%7D+%5CDeclareMathOperator%7Bwhere%7D%7Bwhere%7D+%5CDeclareMathOperator%7Bwith%7D%7Bwith%7D+%5CDeclareMathOperator%7BVect%7D%7BVect%7D+%5C_%7B%5Cleftrightarrows%7D%5C_+%3A+%5C%7BA+%3A+%5CSet%5C%7D+%5C%7Ba%5C+b%5C+c+%3A+A%5C%7D+%5Crightarrow+a+%5Cequiv+b+%5Crightarrow+b+%5Cequiv+c+%5Crightarrow+a+%5Cequiv+c+" alt=" \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_ : \{A : \Set\} \{a\ b\ c : A\} \rightarrow a \equiv b \rightarrow b \equiv c \rightarrow a \equiv c " eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span><span class="nf">_⇆_</span> <span class="ow">:</span> <span class="o">{</span>A <span class="ow">:</span> <span class="kt">Set</span><span class="o">}</span> <span class="o">{</span>a b c <span class="ow">:</span> A<span class="o">}</span> <span class="ow">→</span> a ≡ b <span class="ow">→</span> b ≡ c <span class="ow">→</span> a ≡ c 
</code></pre></div><p>那么我们要怎么实现它，也就是证明它呢？</p><p>我一开始写下了这样的东西：</p><p><img src="https://www.zhihu.com/equation?tex=+%5CDeclareMathOperator%7BSet%7D%7BSet%7D+%5CDeclareMathOperator%7Brefl%7D%7Brefl%7D+%5CDeclareMathOperator%7Bproof%7D%7Bproof%7D+%5CDeclareMathOperator%7Bdata%7D%7Bdata%7D+%5CDeclareMathOperator%7Bwhere%7D%7Bwhere%7D+%5CDeclareMathOperator%7Bwith%7D%7Bwith%7D+%5CDeclareMathOperator%7BVect%7D%7BVect%7D+%5C_%7B%5Cleftrightarrows%7D%5C_%5C+ab%5C+bc+%3D+%3F+" alt=" \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_\ ab\ bc = ? " eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span>_⇆_ ab bc <span class="ow">=</span> ? 
</code></pre></div><p>然后我就不知道该怎么办了。</p><p>事实上，这个原本就很简单的证明被我想复杂了。 因为这个定理是不证则明的，那么我们要如何表达，如何通过 <code>ab</code>, <code>bc</code> 这两个模式匹配出来的结果进行变换得到这个不证则明的定理呢？</p><p>首先这个模式匹配的参数就不应该这样通配地用 <code>ab</code>, <code>bc</code> 来表达。 我们应该把这两个相等关系 (他们的本质是 GADT) 给模式匹配出来。</p><p>由于直接写 <code>ab</code>, <code>bc</code> 什么都得不出来，我于是尝试将 <code>ab</code> <code>bc</code> 用模式匹配消耗掉，然后 Agda 直接在右边给我自动填入了 <code>refl</code> ，然后好像就 Q.E.D 了：</p><p><img src="https://www.zhihu.com/equation?tex=%5CDeclareMathOperator%7BSet%7D%7BSet%7D+%5CDeclareMathOperator%7Brefl%7D%7Brefl%7D+%5CDeclareMathOperator%7Bproof%7D%7Bproof%7D+%5CDeclareMathOperator%7Bdata%7D%7Bdata%7D+%5CDeclareMathOperator%7Bwhere%7D%7Bwhere%7D+%5CDeclareMathOperator%7Bwith%7D%7Bwith%7D+%5CDeclareMathOperator%7BVect%7D%7BVect%7D+%5C_%7B%5Cleftrightarrows%7D%5C_%5C+%5Crefl%5C+%5Crefl+%3D%5Crefl+" alt="\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_\ \refl\ \refl =\refl " eeimg="1"> </p><div class="highlight"><pre><code class="language-text"><span></span>_⇆_ refl refl = refl -- 编译通过！ 
</code></pre></div><p>这是为什么呢？我们来分别看下这两种写法的含义。</p><h2>使用 ab bc</h2><p>这样的话实际上是把 <img src="https://www.zhihu.com/equation?tex=a+%5Cequiv+b" alt="a \equiv b" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=+b+%5Cequiv+c" alt=" b \equiv c" eeimg="1"> 两个条件当成了”变量”而不是作为”条件”。 也就是说，当使用 <code>abbc</code> 时，右边就需要”通过 <img src="https://www.zhihu.com/equation?tex=a+%5Cequiv+b" alt="a \equiv b" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=b+%5Cequiv+c" alt="b \equiv c" eeimg="1"> 这两个条件，再对这两个条件套用一些变换，得出 <img src="https://www.zhihu.com/equation?tex=a+%5Cequiv+c" alt="a \equiv c" eeimg="1"> ”。</p><p>在这个时候，编译器并没有把 <img src="https://www.zhihu.com/equation?tex=a+%5Cequiv+b" alt="a \equiv b" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=b+%5Cequiv+c+" alt="b \equiv c " eeimg="1"> 当成既成条件，而是当成了 “变量” 。</p><p>这就回到了我们原本的需求，我们原本就是需要写出一个 <img src="https://www.zhihu.com/equation?tex=a+%5Cequiv+b%5C+%5Cland%5C+b+%5Cequiv+c+%5Crightarrow+a+%5Cequiv+c" alt="a \equiv b\ \land\ b \equiv c \rightarrow a \equiv c" eeimg="1"> 的变换。</p><p>如果要用变换强行实现的话，可以使用 <code>with</code> 语句（就是 Agda 的 <code>case of</code>）把这两个变量模式匹配出来，然后直接得证。 这里给出一个代码实现。</p><p><img src="https://www.zhihu.com/equation?tex=+%5Cbegin%7Beqnarray%7D+%5C_%7B%5Cleftrightarrows%7D_1%5C_%5C+ab%5C+bc+%5Cwith+ab%5C+%26%7C%26bc+%5C%5C+...+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%7C%5C+%5C+%5Crefl%5C+%26%7C%26%5Crefl+%3D+%5Crefl+%5Cend%7Beqnarray%7D" alt=" \begin{eqnarray} \_{\leftrightarrows}_1\_\ ab\ bc \with ab\ &amp;|&amp;bc \\ ... \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \refl\ &amp;|&amp;\refl = \refl \end{eqnarray}" eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span>_⇆₁_ ab bc <span class="kr">with</span> ab   <span class="ow">|</span> bc
<span class="ow">...</span>           <span class="ow">|</span> refl <span class="ow">|</span> refl <span class="ow">=</span> refl 
</code></pre></div><p>这种方法和下面的做法是等价的。</p><p>如果你没有看懂这一坨，可以尝试继续读下去，说不定看完下面那坨你就懂了。</p><h2>使用 refl</h2><p>由于 <img src="https://www.zhihu.com/equation?tex=a+%5Cequiv+b" alt="a \equiv b" eeimg="1"> 已经是一个条件了，我们直接把它的值取出来。 这时，右边的代码就 <b>已经是建立在</b> <img src="https://www.zhihu.com/equation?tex=a+%5Cequiv+b" alt="a \equiv b" eeimg="1"> <b>和</b> <img src="https://www.zhihu.com/equation?tex=b+%5Cequiv+c" alt="b \equiv c" eeimg="1"> <b>这两个既成条件下</b> 的了，因此这时 Agda 已经认为 <code>a</code> <code>b</code> <code>c</code> 三者相等了。</p><p>利用这一点，我们直接使用 <code>refl</code> 是没有问题的。</p><p><img src="https://www.zhihu.com/equation?tex=%5C_%7B%5Cleftrightarrows%7D_0%5C_%5C+%5Crefl%5C+%5Crefl+%3D+%5Crefl+" alt="\_{\leftrightarrows}_0\_\ \refl\ \refl = \refl " eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span>_⇆₀_ refl refl <span class="ow">=</span> refl 
</code></pre></div><h2>顺带一提</h2><p>当然我们也可以这样写，这是一个语法糖：</p><p><img src="https://www.zhihu.com/equation?tex=%5CDeclareMathOperator%7BSet%7D%7BSet%7D+%5CDeclareMathOperator%7Brefl%7D%7Brefl%7D+%5CDeclareMathOperator%7Bproof%7D%7Bproof%7D+%5CDeclareMathOperator%7Bdata%7D%7Bdata%7D+%5CDeclareMathOperator%7Bwhere%7D%7Bwhere%7D+%5CDeclareMathOperator%7Bwith%7D%7Bwith%7D+%5CDeclareMathOperator%7BVect%7D%7BVect%7D+%5Crefl+%7B%5Cleftrightarrows%7D_0%5Crefl+%3D+%5Crefl+" alt="\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \refl {\leftrightarrows}_0\refl = \refl " eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span>refl ⇆₀ refl <span class="ow">=</span> refl
</code></pre></div><p>之前那个比较 trivial 的模式匹配也可以这样写：</p><p><img src="https://www.zhihu.com/equation?tex=%5CDeclareMathOperator%7BSet%7D%7BSet%7D+%5CDeclareMathOperator%7Brefl%7D%7Brefl%7D+%5CDeclareMathOperator%7Bproof%7D%7Bproof%7D+%5CDeclareMathOperator%7Bdata%7D%7Bdata%7D+%5CDeclareMathOperator%7Bwhere%7D%7Bwhere%7D+%5CDeclareMathOperator%7Bwith%7D%7Bwith%7D+%5CDeclareMathOperator%7BVect%7D%7BVect%7D%5Cbegin%7Beqnarray%7D+ab%5C+%7B%5Cleftrightarrows%7D_1%5C+ab+%5Cwith+ab%5C+%26%7C%26bc+%5C%5C+...+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%5C+%7C%5C+%5C+%5Crefl%5C+%26%7C%26%5Crefl+%3D+%5Crefl+%5Cend%7Beqnarray%7D" alt="\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect}\begin{eqnarray} ab\ {\leftrightarrows}_1\ ab \with ab\ &amp;|&amp;bc \\ ... \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \refl\ &amp;|&amp;\refl = \refl \end{eqnarray}" eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span>ab ⇆₁ bc <span class="kr">with</span> ab   <span class="ow">|</span> bc
<span class="ow">...</span>         <span class="ow">|</span> refl <span class="ow">|</span> refl <span class="ow">=</span> refl 
</code></pre></div><h2>另一个例子</h2><p>现在你肯定有点感觉了，但是这个例子太 trivial 你又感觉自己有点没懂， 那么我们再来看看这个稍微复杂点的例子帮你加深一下理解。</p><p>首先：</p><p><img src="https://www.zhihu.com/equation?tex=%5CDeclareMathOperator%7BSet%7D%7BSet%7D+%5CDeclareMathOperator%7Brefl%7D%7Brefl%7D+%5CDeclareMathOperator%7Bproof%7D%7Bproof%7D+%5CDeclareMathOperator%7Bdata%7D%7Bdata%7D+%5CDeclareMathOperator%7Bwhere%7D%7Bwhere%7D+%5CDeclareMathOperator%7Bwith%7D%7Bwith%7D+%5CDeclareMathOperator%7BVect%7D%7BVect%7D+%5Cforall%5C+%5C%7B+a+%5C%7D%5C+%5C%7B+A+%3A+%5CSet+a+%5C%7D+" alt="\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \forall\ \{ a \}\ \{ A : \Set a \} " eeimg="1"> </p><p>表示 Universal Polymorphism 。然后考虑一个函数，我们有：</p><p><img src="https://www.zhihu.com/equation?tex=%5CDeclareMathOperator%7BSet%7D%7BSet%7D+%5CDeclareMathOperator%7Brefl%7D%7Brefl%7D+%5CDeclareMathOperator%7Bproof%7D%7Bproof%7D+%5CDeclareMathOperator%7Bdata%7D%7Bdata%7D+%5CDeclareMathOperator%7Bwhere%7D%7Bwhere%7D+%5CDeclareMathOperator%7Bwith%7D%7Bwith%7D+%5CDeclareMathOperator%7BVect%7D%7BVect%7D+%5Cbegin%7Balign%2A%7D+%26+%5Cggg+%3A+%5Cforall%5C+%5C%7Ba%5C+b%5C%7D%5C+%5C%7BA+%3A+%5CSet+a%5C%7D%5C+%5C%7BB+%3A+%5CSet+b%5C%7D+%5C%7Bm%5C+n%5C%7D+%5C%7Bf+%3A+A+%5Crightarrow+B%5C%7D+%5Crightarrow+m+%5Cequiv+n+%5Crightarrow+f%5C+m+%5Cequiv+f%5C+n+%5C%5C+%26+%5Cggg+%5Crefl+%3D+%5Crefl+%5Cend%7Balign%2A%7D" alt="\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \begin{align*} &amp; \ggg : \forall\ \{a\ b\}\ \{A : \Set a\}\ \{B : \Set b\} \{m\ n\} \{f : A \rightarrow B\} \rightarrow m \equiv n \rightarrow f\ m \equiv f\ n \\ &amp; \ggg \refl = \refl \end{align*}" eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span><span class="nf">⋙</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>a b<span class="o">}</span> <span class="o">{</span>A <span class="ow">:</span> <span class="kt">Set</span> a<span class="o">}</span> <span class="o">{</span>B <span class="ow">:</span> <span class="kt">Set</span> b<span class="o">}</span> <span class="o">{</span>m n<span class="o">}</span> <span class="o">{</span>f <span class="ow">:</span> A <span class="ow">→</span> B<span class="o">}</span> <span class="ow">→</span> m ≡ n <span class="ow">→</span> f m ≡ f n
⋙ refl <span class="ow">=</span> refl 
</code></pre></div><p>和上面一样，在建立了 <img src="https://www.zhihu.com/equation?tex=m+%5Cequiv+n" alt="m \equiv n" eeimg="1"> 的基础上，可以直接用 <code>refl</code> 表达他们对于同一个函数应用的结果相等。</p><p>我是在 <a href="http://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/27091668/refl-in-agda-explaining-congruence-property" class=" wrap external" target="_blank" rel="nofollow noreferrer">这个 StackOverflow 问题</a> 里看到这个代码的，唯一的回答里面还有更多的解释。</p><p>这个我就暂时不作过多讲解了，以后再说。</p><h2>结束</h2><p>这个证明太简单了，只有一步，没有什么实际意义，仅用于入门理解。 下一篇文章我们将会进行一个稍微复杂点的关于与或关系的证明。</p><p>我说完了。</p><p><br></p><p><br></p><p>执壶的代码块高亮竟然支持 Agda ，感动中国简直</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
