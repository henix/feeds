<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>WebAssembly 为什么比 asm.js 快？</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/25865972">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-30df629011a7d4213d8559db94e00415_r.jpg" alt=""></div><blockquote><p>本文作者：Alon Zakai</p><p>翻译原文：<a href="http://huziketang.com/blog/posts/detail?postId=58ce80d2a6d8a07e449fdd28" data-editable="true" data-title="WebAssembly 为什么比 asm.js 快？" class="">http://huziketang.com/blog/posts/detail?postId=58ce80d2a6d8a07e449fdd28</a></p><p>英文连接：<a href="https://hacks.mozilla.org/2017/03/why-webassembly-is-faster-than-asm-js/" data-editable="true" data-title="Why WebAssembly is Faster Than asm.js" class="">Why WebAssembly is Faster Than asm.js</a></p></blockquote><p><a href="http://webassembly.org/" data-editable="true" data-title="WebAssembly" class="">WebAssembly</a> 是为 Web 而设计的、可以生成浏览器可执行的二进制文件的编程语言。并且于2017 年 2 月 28 日，四个主要的浏览器<a href="http://huziketang.com/blog/posts/detail?postId=58ce7fd3a6d8a07e449fdd26" data-editable="true" data-title="一致同意宣布" class="">一致同意宣布</a> WebAssembly 的 MVP 版本已经完成，即将推出一个<a href="https://hacks.mozilla.org/2017/03/firefox-52-introducing-web-assembly-css-grid-and-the-grid-inspector/" data-editable="true" data-title="浏览器可以搭载的稳定版本" class="">浏览器可以搭载的稳定版本</a>。WebAssembly 的一个主要目标就是变<strong>快</strong>。本文将给出一些它如何变快的技术细节。</p><p>当然，“快”是相对的概念。相比于 JavaScript 和其他动态语言，WebAssembly 的快主要是因为它的<a href="https://zhuanlan.zhihu.com/p/25773367" data-editable="true" data-title="静态类型特性和方便优化特性" class="">静态类型特性和方便优化特性</a>。WebAssembly 意在速度上能够达到和本地执行一样快，其实 <a href="http://asmjs.org/" data-editable="true" data-title="asm.js">asm.js</a> 已经比较<a href="https://hacks.mozilla.org/2013/12/gap-between-asm-js-and-native-performance-gets-even-narrower-with-float32-optimizations/" data-editable="true" data-title="接近这一目标">接近这一目标</a>了，但是 WebAssembly 要进一步缩短和本地执行速度之间的差距。因此本文着重介绍为什么 WebAssembly 比 asm.js 更快。</p><p>在开始介绍之前，先做一些说明：新的技术总是有一些还没来得及优化的情况，所以目前来说，并不是所有情况下 WebAssembly 都是最快的。本文主要表达的是 WebAssembly 为什么<strong>应该</strong>是更快的。对于它还不是那么快的一些情况，也是未来需要 fix 的问题。</p><p>那么有了这些标准以后，我们来介绍为什么 WebAssembly 更快。</p><h2><b>1. 启动</b></h2><p>WebAssembly 设计之初就定位在：体积更小、下载更快、解析更快，这样即使应用于一个大型的 web 应用上启动也会很快。</p><p>JavaScript 代码通过 gzip 进行压缩，与<a href="http://mozakai.blogspot.com/2011/11/code-size-when-compiling-to-javascript.html" data-editable="true" data-title="本地代码相比它已经压缩了很多">本地代码相比它已经压缩了很多</a>，想要进一步缩小它的体积确实不是一件容易的事情。但是通过对 WebAssembly 文件大小的精心设计（<a href="https://en.wikipedia.org/wiki/LEB128" data-editable="true" data-title="LEB128">LEB128</a> 指标），<a href="https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md" data-editable="true" data-title="二进制格式的 WebAssembly" class="">二进制格式的 WebAssembly</a> 的文件大小要比压缩后的 JavaScript 文件更小。通常来讲，要比 gzip 压缩后的小 <a href="http://kripken.github.io/talks/emwasm.html#/9" data-editable="true" data-title="10% - 20%">10% - 20%</a>。</p><p>WebAssembly 在解析过程有更大的进步：它的解析速度要<a href="http://webassembly.org/docs/faq/#why-create-a-new-standard-when-there-is-already-asmjs" data-editable="true" data-title="比 JavaScript 快一个数量级" class="">比 JavaScript 快一个数量级</a>。这得益于 WebAssembly 的二进制格式就是为更适合解析而设计的。同时 WebAssembly 的解析和优化函数也更容易实现并行，这一特点在多核机器上的体现更好。</p><p>影响启动时间的因素除了下载和解析以外还有很多，比如代码的 VM 完全优化、执行之前下载所必须的额外文件等。但是<strong>下载和解析</strong>步骤是无论如何都不可避免的步骤，因此要尽可能地对它们进行优化。不论是对于浏览器还是 app，其他的影响因素都有办法避免或者缓和它们的影响（例如代码的完全优化，可以通过 WebAssembly 的<a href="http://huziketang.com/blog/posts/detail?postId=58c12f36a6d8a07e449fdd22" data-editable="true" data-title="基线编译器或解释器" class="">基线编译器或解释器</a>来避免）。</p><h2><b>2. CPU 特性</b></h2><p>使得 asm.js 这么快的技巧之一是利用好 CPU 特性。JavaScript 数字类型都是 double 型的，在 asm.js 中加法操作后会有一个按位与的操作，这使得 double 加法这个操作，在逻辑上和 CPU 做简单的 int 加法（CPU 做简单 int 加操作很快）是等价的。而 asm.js 巧妙地通过这种方式使得 VM 可以更加有效地利用 CPU。</p><p>但是有一些 JavaScript 中表达的东西，asm.js 是表达不了的。 </p><p>WebAssembly 则不受 JavaScript 的约束，我们一起来看一下更多的可利用的 CPU 特性：</p><ul><li>64 位整型。基于 64 位整型的操作速度可以快 <a href="http://kripken.github.io/talks/emwasm.html#/11" data-editable="true" data-title="4 倍" class="">4 倍</a>。例如可以增加哈希算法和加密算法的速度。</li><li><a href="http://webassembly.org/docs/rationale/#loadstore-addressing" data-editable="true" data-title="加载和存储偏移量" class="">内存读写偏移量</a>。它的用处特别广泛，基本上所有包含字段的内存对象都涉及到偏移量的问题（如 C 语言中 struct 等）。</li><li>非对齐内存读写。这避免了 asm.js 所需要的 mask（asm.js 为 Typed Array 兼容而做的操作），同时这在几乎所有的内存读写问题都用得上。</li><li>多种 CPU 指令，例如 popcount，copysign 等。每一个指令都有助于某种具体使用场景（例如，popcount 在<a href="https://en.wikipedia.org/wiki/Hamming_weight#Processor_support" data-editable="true" data-title="密码分析">密码分析</a>这个场景下很有用）。</li></ul><p>在每一种具体场景下到底能起到多大作用，要依赖于如何使用上面提到的特性。和正常使用 asm.js 相比，我们的统计是大概比 asm.js 提升了 5% 的速率。未来还有更多可挖掘的 CPU 特性来提高速率，例如<a href="http://huziketang.com/blog/posts/detail?postId=58ce7fd3a6d8a07e449fdd26" data-editable="true" data-title="SIMD" class="">SIMD</a>。</p><h2><b>3. 工具链改进</b></h2><p>WebAssembly 是编译器生成的主要目标，所以它的运行主要包含两个部分：生成它的编译器（工具链端）和运行它的虚拟机（浏览器端）。优良的性能全都依赖于这两部分。</p><p>对于 asm.js，情况也类似，并且 <a href="http://kripken.github.io/emscripten-site/" data-editable="true" data-title="Emscripten">Emscripten</a> 做了一系列对工具链的优化，还做了运行 LLVM 的优化器和 Emscripten 的 asm.js 优化器。对 WebAssembly 的优化都是<a href="http://kripken.github.io/emscripten-site/" data-editable="true" data-title="在这些的基础上">在这些的基础上</a>来设计的，并且同时还加入了一些专门针对 WebAssembly 的改进。我们自己在学习 asm.js 的过程对我们改善 WebAssembly 很有帮助，尤其体现在一下几个方面：</p><ul><li>我们使用 <a href="https://github.com/WebAssembly/binaryen" data-editable="true" data-title="Binaryen">Binaryen</a> WebAssembly 优化器来代替 Emscripten asm.js 优化器，前者是专门为速度而设计，其速度的提升是以更多优化步骤为代价的。例如在优化的过程中会<a href="https://github.com/WebAssembly/binaryen/blob/master/src/passes/DuplicateFunctionElimination.cpp" data-editable="true" data-title="移除重复函数">移除重复函数</a>，这样会使 C++ 编译代码整体减小 5% 左右。</li><li><a href="https://github.com/WebAssembly/binaryen/blob/master/src/passes/RelooperJumpThreading.cpp" data-editable="true" data-title="对冗余、复杂的控制流进行更好的优化">对冗余、复杂的控制流进行更好的优化</a>，这可以提升 <a href="https://github.com/WebAssembly/binaryen/blob/master/src/cfg/Relooper.h" data-editable="true" data-title="Relooper 算法" class="">Relooper 算法</a>的效率，对于编译解释类型循环也很有帮助。</li><li>Binaryen 优化器是在试验中不断设计和完善的，<a href="https://github.com/WebAssembly/binaryen/pull/900#issuecomment-279186640" data-editable="true" data-title="通过超级优化器做的实验">通过超级优化器做的实验</a>也会带来各种情况的微妙改进——我想 asm.js 也做过同样的事情。</li></ul><p>总的来说，这些工具链的改进，在 asm.js 的基础上进一步提升了 WebAssembly 的速度（<a href="http://kripken.github.io/talks/emwasm.html#/10" data-editable="true" data-title="Box2D 速度评测中，WebAssembly 的速度分别提升了 5% 和 7%" class="">Box2D 速度评测中，WebAssembly 的速度分别提升了 5% 和 7%</a>）。</p><h2><b>4. 可预见的优良性能</b></h2><p>asm.js 的速度很<a href="https://hacks.mozilla.org/2013/12/gap-between-asm-js-and-native-performance-gets-even-narrower-with-float32-optimizations/" data-editable="true" data-title="接近本地执行的速度" class="">接近本地执行的速度</a>了，但是它不可能在所有的浏览器中都达到同样的标准。因为在使用 asm.js 的过程中，一些人尝试用一种方法来优化 asm.js，而另一些人用另一种方法优化，这导致了不同人有不同的版本和结果。虽然随着时间的推移，大家对于 asm.js 也<a href="https://hacks.mozilla.org/2015/03/asm-speedups-everywhere/" data-editable="true" data-title="达成了某种共识">达成了某种共识</a>，但是对于 asm.js 来讲，本质问题是它还是没有一个统一的标准。它只是一个由一个厂商推出的，非标准的 JavaScript 子集而已，而它的使用者根据自己的偏好和习惯来使用它。</p><p>WebAssembly 则不同，它是由几大主要的浏览器厂商共同设计的。与 JavaScript相比，JavaScript 只能通过一些<a href="https://hacks.mozilla.org/2017/02/what-makes-webassembly-fast/" data-editable="true" data-title="创新方法">创新方法</a>或者 asm.js 这种方法来提高速度，而不论哪种方法都不可能适用于所有浏览器。WebAssembly 的优化方案则得到了大多数厂商的认可。对于 WebAssembly 来讲，对于不同的 VM 依旧有很大的提升空间（如 AOT、JIT 有不同编译方式）。不过能够基本断定的是，可以应用于整个网络的优良性能是指日可期的。</p><p>想了解更多关于 WebAssembly 的知识，请移步下面 WebAssembly 系列文章。</p><h3><b>背景知识：</b></h3><ul><li><a href="http://huziketang.com/blog/posts/detail?postId=58ce8036a6d8a07e449fdd27" data-title="WebAssembly 系列（一）生动形象地介绍 WebAssembly" class="" data-editable="true">WebAssembly 系列（一）生动形象地介绍 WebAssembly</a><br></li><li><a href="http://huziketang.com/blog/posts/detail?postId=58c12f36a6d8a07e449fdd22" class="" data-editable="true" data-title="WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理">WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理</a></li><li><a href="http://huziketang.com/blog/posts/detail?postId=58c55a3ba6d8a07e449fdd23" class="" data-editable="true" data-title="WebAssembly 系列（三）编译器如何生成汇编">WebAssembly 系列（三）编译器如何生成汇编</a></li></ul><h3><b>当前 WebAssembly 的状况：</b></h3><ul><li><a href="http://huziketang.com/blog/posts/detail?postId=58c77641a6d8a07e449fdd24" class="" data-editable="true" data-title="WebAssembly 系列（四）WebAssembly 工作原理">WebAssembly 系列（四）WebAssembly 工作原理</a></li><li><a href="http://huziketang.com/blog/posts/detail?postId=58c8b98da6d8a07e449fdd25" class="" data-editable="true" data-title="WebAssembly 系列（五）为什么 WebAssembly 更快？">WebAssembly 系列（五）为什么 WebAssembly 更快？</a></li></ul><h3><b>WebAssembly 的未来：</b></h3><ul><li><a href="http://huziketang.com/blog/posts/detail?postId=58ce7fd3a6d8a07e449fdd26" class="" data-editable="true" data-title="WebAssembly 系列（六）WebAssembly 的现在与未来">WebAssembly 系列（六）WebAssembly 的现在与未来</a></li></ul><br><p><strong>转载请注明出处，保留原文链接以及作者信息</strong></p><p>欢迎大家关注我的<a href="https://zhuanlan.zhihu.com/qianduandaha" data-editable="true" data-title="前端大哈 - 知乎专栏">前端大哈 - 知乎专栏</a>，定期发布高质量前端文章。</p><p>点击<a href="http://huziketang.com/blog/posts/detail?postId=58ce80d2a6d8a07e449fdd28" data-title="《WebAssembly 为什么比 asm.js 快？》" class="">《WebAssembly 为什么比 asm.js 快？》</a>阅读原文。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
