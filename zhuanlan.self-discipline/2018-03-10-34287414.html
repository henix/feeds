<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>递归函数（二）：编写递归函数的思路和技巧</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34287414">原文</a></p>
<p></p><img src="https://pic2.zhimg.com/v2-bc103055d4f8d209a9087df68eeddf49_r.jpg" data-caption="" data-size="normal" data-rawwidth="680" data-rawheight="310"><p>递归，是一个熟悉而陌生的概念，说它熟悉，是因为人们经常提起它，<br>而说它陌生，指的是人们在实际编程中几乎不会主动使用它。</p><p>给定一个问题，如果本质上它能看做一个调用自身的规模较小的一个子问题来求解，<br>那么给出一个递归的算法解，就是很自然的。<br>然而，即使是这样，编制一个递归函数也是一件令人头疼的事情。</p><p>本系列文章的目的，可能并不局限于指出如何编写一个递归函数，<br>而是期望想从递归函数开始，了解它相关的科学知识，以达到对不同领域触类旁通的效果。</p><h2><b>1. 从一个简单的例子开始</b></h2><p>首先，我们来重温一下递归的概念，<br>维基百科上是这样描述的，</p><blockquote>递归（recursion），在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。</blockquote><p>我们来看一个简单的例子吧。（<a href="https://www.haskell.org/">Haskell</a>代码</p><code lang="haskell">fact :: Int -&gt; Int
fact 1 = 1
fact n = n * fact (n-1)</code><p>在这个例子中，<br>第一行<code class="inline">fact :: Int -&gt; Int</code>表示了<code class="inline">fact</code>函数的类型，<br>第二行和第三行定义了函数<code class="inline">fact</code>，<br>我们看到第三行，在对<code class="inline">fact</code>函数定义的时候，等式右边又出现了<code class="inline">fact</code>，<br>这样定义的函数<code class="inline">fact</code>是递归的。</p><p>我们调用一下<code class="inline">fact</code>，来看看结果，</p><code lang="haskell">fact 10
3628800</code><p>嗯嗯，<code class="inline">fact</code>就是阶乘函数。</p><h2><b>2. 写递归函数的步骤</b></h2><p>那么，给定一个问题，我们编写一个递归函数，要如何开始呢？</p><p><b>（1）递推式</b></p><p>首先，我们要找到“递推式”。</p><p>例如，在数学上阶乘的定义是， <equation>f(n)=n!</equation> ，这样的表述形式，不具有递推性。<br>我们先要想办法把 <equation>f(n)</equation> 用 <equation>f(n-1)</equation> 表示出来。</p><p>经过思考之后，我们可以证明， <equation>f(n)=n*f(n-1)</equation> ，<br>于是，我们就走出了关键的第一步，得到了“递推式”。</p><p><b>（2）找出终止条件</b></p><p>有了“递推式”还不行，我们还需要确定递推在什么时候终止。<br>我们知道 <equation>f(1)=1</equation> ， <equation>f(2)=2*f(1)</equation> ， <equation>f(3)=3*f(2)</equation> ，等等，<br>因此，我们只需要指定 <equation>f(1)=1</equation> ，那么递推就会在 <equation>f(n)</equation> ，当 <equation>n=1</equation> 的时候终止了。</p><p>终止，就是不再调用规模更小的问题了。<br>这时，终止条件是 <equation>f(1)=1</equation> 。</p><p><b>（3）用数学归纳法证明解的正确性</b></p><p>这一步是很重要的，有很多人都缺少证明递推式正确性的环节，<br>但是，考虑到介绍<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95">数学归纳法</a>及其扩展会占用不少篇幅，<br>这里先略去，下一篇我们再回来讨论它。</p><p>这里，我们先假定，根据“递推式”和“终止条件”，使用数学归纳法，<br>我们已经证明了这样定义的 <equation>f(n)</equation> 就是 <equation>n!</equation> 。</p><p><b>（4）根据递推式和终止条件，编写程序</b></p><p>有了“递推式”和“终止条件”，再编写程序就水到渠成了。<br>很多人一上来就开始编码，就会感觉毫无头绪。</p><p>我们再来看下那段程序，</p><code lang="haskell">fact :: Int -&gt; Int
fact 1 = 1
fact n = n * fact (n-1)</code><p>这不就是“递推式”和“终止条件”的忠实表示吗？<br>我们用<code class="inline">fact 1 = 1</code>表示了 <equation>f(1)=1</equation> ，<br>用<code class="inline">fact n = n * fact (n-1)</code>表示了 <equation>f(n)=n*f(n-1)</equation> 。</p><h2><b>3. 小技巧</b></h2><p>我们再看个复杂一点的例子。</p><p>在实际项目中，我们可能会遇到循环 <equation>n</equation> 次的场景，<br>在循环过程中，我们会根据索引进行运算，然后将某些符合条件的运算放到最终的结果中。</p><p>例如，我们选择10以内的所有偶数，</p><code lang="haskell">[x|x &lt;- [0..9], x `mod` 2 == 0]
[0,2,4,6,8]</code><p>使用以上列表解析（<a href="http://www.haskell.org/haskellwiki/List_comprehension">list comprehension</a>）的方法，我们可以快速得到结果。<br>但是这里，我们想要拿它来举例，介绍一个编写递归函数常用的小技巧。</p><p>为了通用性，我们考虑循环<code class="inline">n</code>次，将索引传入函数<code class="inline">fn</code>，<br>根据<code class="inline">fn</code>的返回值，将结果放入一个列表中，完成这个功能的函数我们记为<code class="inline">myLoop</code> 。</p><p><b>（1）困境</b></p><p>根据前文介绍的编写步骤，我们需要先找到“递推式”和“终止条件”。</p><p>“终止条件”怎么写呢？<br>假如我们定义的递归函数称为<code class="inline">myLoop</code>，那么 <equation>myLoop(0,fn)</equation> 就是终止条件，它应该返回一个列表。但是这个列表在参数中没有，它随着递归调用的过程“积累”得到的。</p><p>好吧，那我们看“递推式”。<br><equation>myLoop(n,fn)</equation> 要用 <equation>myLoop(n-1,fn)</equation> 的结果计算出来，<br>我们需要先用索引调用<code class="inline">fn</code>，然后再根据<code class="inline">fn</code>的返回值，放入结果列表，再继续调用 <equation>myLoop(n-1,fn)</equation> 。可是，索引从哪来呢？<br>（<code class="inline">n</code>不是索引，因为索引从0开始，而<code class="inline">n</code>是逐渐变小的。</p><p>这是两个典型的困难，<br>其一，我们在递归的过程中“积累”了某些东西，<br>其二，我们需要传递和递归过程相关的“索引”。</p><p><b>（2）解法</b></p><p>这时候，我们的小技巧就有用武之地了。</p><blockquote>我们可以编写一个辅助的递归函数，通过增加参数的办法，提高灵活性。</blockquote><p>例如，我们可以编写一个辅助函数<code class="inline">myLoop'</code>，然后用<code class="inline">myLoop'</code>来实现<code class="inline">myLoop</code>。</p><code lang="haskell">myLoop :: Int -&gt; (Int -&gt; Maybe a) -&gt; [a]
myLoop n fn = myLoop' n 0 fn []

myLoop' :: Int -&gt; Int -&gt; (Int -&gt; Maybe a) -&gt; [a] -&gt; [a]
myLoop' 0 i fn lst = lst
myLoop' n i fn lst = case fn i of
  Just x -&gt; myLoop' (n-1) (i+1) fn (lst++[x])
  Nothing -&gt; myLoop' (n-1) (i+1) fn lst</code><p>以上，我们为<code class="inline">myLoop'</code>增加了参数<code class="inline">i</code>和<code class="inline">lst</code>，分别表示“索引”和“积累”的列表。<br>然后，<code class="inline">myLoop</code>就可以用<code class="inline">myLoop'</code>来实现了。</p><p>别忘了测试一下最终的结果，</p><code lang="haskell">myLoop 10 (\x -&gt; if x `mod` 2 == 0 then Just x else Nothing)
[0,2,4,6,8]</code><p><b>（3）其他考虑</b></p><p>合理的利用递归函数的返回值，会减少附加参数的数量，例如，</p><code lang="haskell">myLoop :: Int -&gt; (Int -&gt; Maybe a) -&gt; [a]
myLoop n fn = myLoop' n 0 fn

myLoop' :: Int -&gt; Int -&gt; (Int -&gt; Maybe a) -&gt; [a]
myLoop' 0 i fn = []
myLoop' n i fn = case fn i of
  Just x -&gt; x:(myLoop' (n-1) (i+1) fn)
  Nothing -&gt; myLoop' (n-1) (i+1) fn</code><p>但最终得到的递归函数就不是<a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8">尾递归</a>了，<br>关于尾递归，我们将在后续文章中讨论它。</p><hr><h2><b>参考</b></h2><p><a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92">维基百科 - 递归</a> <br><a href="https://zh.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E9%97%9C%E4%BF%82%E5%BC%8F">维基百科 - 递推关系式</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
