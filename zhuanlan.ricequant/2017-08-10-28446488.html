<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>PonderDNC处理高频长时间序列模型简介</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/28446488">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-cc86a624bca19026085931f7ac8cdf76_r.jpg" alt=""></div><p>ACT模型通过在每时间步(时间序列节点)进行多次计算来模拟复杂问题的思考过程。这种算法尤其有价值在使用包含外存储器的RNN变种（如DNC、NTM等）计算架构处理长时间序列的时候。</p><p>下面简单形象的介绍一下本文模型（这不是很准确的描述，但是足够形象）。我们假设VanillaRNN模型为一个考生，在进行英语听力考试，这个考生被要求“干听”，也就是不能使用纸笔记录，并且所有的听力内容问题和答案全部都是以口头形式进行的。当然在排除天纵奇才的情况下，这个考生的答案是惨不忍睹的。</p><p><br></p><img src="https://pic3.zhimg.com/v2-e8a3c4609f3823b127a523aedd16a435_r.jpg" data-rawwidth="496" data-rawheight="471"><p>下面我们来看第二个名叫LSTM的考生，这个考生在进行听力考试的时候有一块磁铁画板，可以记录一定量的信息。但是这个考生在超过30min的听力考试中只能使用这个画板记录一点点信息，如果想要写入新的信息就必须要清除之前的信息。也就是这个叫做LSTM的考生可以记录有限的信息。当然对于长时间的听力考试这点笔记也是杯水车薪。</p><p><br></p><img src="https://pic1.zhimg.com/v2-0d971606cd41a0fe3a4950b7f49183c6_r.jpg" data-rawwidth="710" data-rawheight="473"><p>下面我们来看第三个叫做DNC的考生，这个考生使用一个更高级的画板(E人E本)，这个画板可以记录更多的信息，甚至可以记录所有的听力信息（当DNC的外存储器足够大的时候）。</p><p><br></p><img src="https://pic3.zhimg.com/v2-65500ee5e58d5e4cf7ae1e29fe44c8da_r.jpg" data-rawwidth="1514" data-rawheight="1314"><p>以上的三个考生都是在加强自己的记忆能力，针对听力考试（长时间序列）进行信息处理。这三个考生都是按照听力播放顺序进行答题，虽然第三个考生(DNC)可以记录几乎所有的听力信息，但是它并没有额外的时间去翻阅所有记录下来的信息，只能够根据大脑（短期记忆）中的印象和自己写字顺序在非常短的时间内翻阅一下记录本。</p><p>下面介绍第四个考生，一个叫做PonderDNC的带着时间机器作弊器的考生。PonderDNC不但带着E人E本，而且还带着时间静止机器。这也就是说这名考生在进行听力考试的时候，可以在任何自己觉得可以的地方让时间静止，注意不能回溯，然后从容的翻阅自己在E人E本上面的记录进行答题。</p><p><br></p><img src="https://pic1.zhimg.com/v2-c98b850f7a86d81f17d71d687772b9aa_r.jpg" data-rawwidth="1024" data-rawheight="768"><p>毫无疑问PonderDNC是在理论上面最有可能在听力考试总获取高分的考生。</p><h2><b>PonderDNC</b></h2><p>通过将DNC计算单元进行嵌入ACT计算架构，PonderDNC可以实现在每个时间步骤多次进行运算。这意味着在时间步t，DNC在获得时刻t的外部输入之后不用立刻输出信息，而是可以在时刻t反复进行思考计算之后再做出判定输出，然后再进入下一时刻t+1。如下图</p><p><br></p><img src="https://pic2.zhimg.com/v2-39b6d7d4a6a2a000daf210d4b5faaba1_r.png" data-rawwidth="916" data-rawheight="526"><p>ACT (Adaptive Computation Time for Recurrent Neural Networks ) 计算架构在时间步t，RNN模型经过多次计算(思考)之后，形成多个输出 <equation>y_t^1,...,y_t^N</equation> 和隐藏状态 <equation>h_t^1,...,h_t^N</equation> ，RNN在时刻t的输出以及传递到下一时刻t+1的隐藏状态通过权重系数累加获得。</p><p><br></p><img src="https://pic1.zhimg.com/v2-4427554d0aef69fe17d24fc4b4cee00d_r.png" data-rawwidth="93" data-rawheight="110"><p>这种计算架构通过在时刻t进行多次运算取权重系数累加和的方式模拟思考过程。这对于使用DNC这种带有外存储器的计算单元来处理超长序列尤其有意义。这意味着对于一个具有超大外存储器记忆(如1K行记忆)的DNC而言，在时间步t 计算单元DNC基于外部输入信息 <equation>x_t</equation> 可以多次反复的读取外记忆矩阵信息进行反复权衡思考之后再做出判定。</p><p>原始的DNC模型一般使用一个500行的外记忆矩阵，在每个时间步t通过1~3写头控制，2~6读头控制与外记忆矩阵进行信息(记忆)交互。也就是DNC模型在时刻t一般只与不超过10个记忆位置有信息交互。这对于简单的问题，例如记忆复现具有较好的效果，但是对于那些与前面信息交互复杂而且时间跨度很长的判定问题则效果欠佳。通过将DNC计算单元嵌入ACT计算架构之后形成的PonderDNC计算单元，在每个时间步骤可以多次与外记忆矩阵进行信息交互。例如一个具有2写头控制，4读头控制，具有1000行外存储记忆的PonderDNC在时刻t运算50次，最多可以与外记忆矩阵的300个位置进行交互，在时刻t 最多可以基于50个短期记忆以及200个读头记忆做出推断输出。也就是在时刻t 计算单元PonderDNC可以基于前面记忆总量的20%进行推断判定。</p><p>通俗的讲，假设这几个模型被看做是不同操盘手的话，LSTM操盘手就是基于过去两周的K线图对未来行情进行判断，而PonderDNC则是基于过去一季度的多种技术分析指标对未来进行判定。</p><p><br></p><p>这个PonderDNC模型适合处理长序列任务以及回溯复杂的任务，如处理期货的高频数据。模型需要比较大的可训练权重参数才更容易获得更好的效果。在使用的时候注意加大训练数据量以及尽量消除输入因素多重共线性。</p><p><a href="https://www.ricequant.com/community/topic/3856/ponderdnc">代码示例见链接</a></p><p>注：PonderDNC每个时间步t传递给下一个时间步t+1的信息为 累加的控制器状态、累加的读头读取记忆向量、以及在时刻t进行N(t)次运算之后的外存储记忆矩阵(这个不是权重累加和而是最后一次运算之后的记忆矩阵直接传递下去)。</p><p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``</p><p><a href="https://www.ricequant.com/community/topic/3868//2">2017-08-13更新 简单的应用到期货的模型代码示例</a></p><p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>2017-08-18 更新期货日频回测</p><p>样本内回测</p><p>2017-09-29 更新L2正则化示例</p><p><br></p><img src="https://pic1.zhimg.com/v2-72ea614300511a97b228a4ee312aa391_r.png" data-rawwidth="1206" data-rawheight="653"><p>样本外回测2017-01-01 ~ 2018-08-01，应该说泛化能力还不错</p><p><br></p><img src="https://pic1.zhimg.com/v2-67bfc9c0b8acd4f14bb8ae6217b701b5_r.png" data-rawwidth="1195" data-rawheight="655"><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
