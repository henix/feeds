<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>JSR292: InvokeDynamic和MethodHandle的优化</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/30936412">原文</a></p>
<p>这篇是接着前篇 <a href="https://zhuanlan.zhihu.com/p/26389041">Invokedynamic 和 MethodHandle的缘由</a>, 这两天趁着闲着补上。</p><p>描述的内容主要基于IBM J9中Java 7 和Java 8部分MethodHandle的优化部分(HotSpot采用的是LambdaForm实现)。为方便理解，本文不涉及代码。</p><h2>背景：</h2><p>invokedynamic是 JSR 292中提出来的一个 JVM bytecode instruction. 这条指令主要是针对dynamic method invocations, which are prevalent in dynamically typed languages. </p><p>在程序运行时，当JVM第一次遇到invokedynamic指令时，他将去调用一个bootstrap方法，这个方法动态创建一个Method Handle Graph。这个过程叫做resolve。Method Handle Graph的地位在于在程序运行中，通过一系列的转化，将一个动态方法链接到具体的一个或者多个方法的实现。</p><p><br></p><h2>1, invokedyanmic</h2><p>正如和其它传统的方法调用指令(invokevirtual, invokestatic)一样, 主要的一个优化方法是inline caching。核心的思想是将Method handle graph that is linked at the dynamic call site直接取代 invokedynamic指令，而不是进行方法函数调用。这种好处是显而易见的，尤其是对于ConstantCallSite。它的不利之处是在于MutableCallSite。一个Mutable Call Site所对影的Method Handle可能会动态的被更改(modified or invalidated)，J9中是通过CAS来实现在Mutable Call Site的多个MHG的swap.</p><p>由于invokedynamic第一次调用才会涉及到方法link,因此，inline caching往往是 dynamic call site被调用多次之后才发生的。</p><p>当涉及到inline caching, 涉及到的问题是what to inline 和 When to inline. </p><h2>2, What to Inline. </h2><p>根据前一篇文章，JVM看到invokedynamic，会先去执行相对应bootstrap method。在这个被执行的bootstrap method中，invokedynamic call site会被resolved 一个method handle (或者method handle graph). 因此，用来inline的目标是mehtodhandle (这里面其实对应的是：Inline a method handle at a call site, and inline a method handle to another method handle). </p><p> 在J9中，是将Method Handle的Machine Code version直接inline 到dynamic call site中。在J9中，Method Handle对应着三种状态: Interpretation, SharedThunk, CustomThunk. </p><ul><li>Interpretation: JVM解释执行Method Handle. </li><li>SharedThunk: A data structure, which points to the address that the native code of this method handle starts. </li><li>CustomThunk: Same to the sharedThunk, except the native code block represents the transformation that the whole sub-graph from the method handle has. </li></ul><p>一个Method Handle (or method handle graph)的状态转变主要取决于这个method handle's invocationCounter. The larger invocationCounter that a method handle has, the more likelyhood that the method handle is promoted to the CustomThunk. </p><p>从SharedThunk到CustomThunk的原因参考下图：</p><img src="https://pic1.zhimg.com/v2-8f3825423eb73910abecee3372812535_r.jpg" data-caption="" data-rawwidth="888" data-rawheight="360"><p><br></p><p>在Method Handle Graph的一条路径中，JVM先看到第一个method handle ，执行其SharedThunk，然后再回到解释状态到了第二个Method Handle, 发现其有SharedThunk,　于是又进入执行状态，依次类推。这种JVM在不断的Interpretation和Execution mode切换，尤其是对MethodHandle这种简单的transformation, 代价比较高。因此CustomThunk则是讲上图中的浅蓝色的CompiledThunk (sharedThunk) inline成一份Compiled Code: </p><img src="https://pic1.zhimg.com/v2-6e79374a7a1e45ba1b52e064252cc0ed_r.jpg" data-caption="" data-rawwidth="760" data-rawheight="384"><p><br></p><p><br></p><h2>3, When to Inline</h2><p>该项取决于每个MethodHandle的 hotness or invocationCounter. 当一个MethodHandle的invocationCounter超过了给定的阈值时候，inline就会被启动激活。</p><p>－－－</p><p>大概的基本思想是这样子，然而并不是所有的优化都是很如意的。在这个基本方法中，TR JIT对Method Handle Graph整体的IC操作内存的消耗比较大，同时还有性能没有达到最优。因此又出来个GraphJIT. 大概思路是在MethodHandle从Intrepretation-&gt;SharedThunk之前进行。</p><p>For an MHG is on interpretation mode, the graph traversal is necessary every time when the dynamic method handle is called. The traversal cost can be reduced by fusing graph internal nodes, so that JVM can spent less time on the path from the root to a leaf. </p><p>例子如图：原先的MHG G0中，从１到７需要经过４个中间节点，经过不断的合并，最后得到新的MHG G3, 并且用G3在运行时候来代替G0。</p><p><br></p><img src="https://pic2.zhimg.com/v2-97d40692a6a3543bbcfc519cf1670b6d_r.jpg" data-caption="" data-rawwidth="1162" data-rawheight="606"><p>整个过程大概分为两步：　</p><ul><li>内部节点动态生成相对应的字节码</li><li>相邻节点的字节码进行合并，并生成新的MethodHandle.　使用GraphJIT</li></ul><p>这种方法在早期的HotSpot中也有类似的概念，差别在于GraphJIT会动态根据InvocationCounter和transformation函数题的大小来决定是否进行fusion. </p><p><br></p><p>主要的参考文献：</p><p>1， <a href="http://openjdk.java.net/jeps/160">JEP 160: Lambda-Form Representation for Method Handles</a></p><p>2， <a href="http://video.oracle.com/detail/videos/featured-videos/video/1785383257001">JVMLS 2012: Lambda Forms</a></p><p>3， Dan hedinga, MethodHandle compilation pipeline.</p><p>4,  Shijie Xu, David Bremner, Dan Heidinga. Fusing Method Handle Graphs for Efficient Dynamic JVM Language Implementations, VMIL@SPLASH, Vancouver, Canada, 2017. </p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
