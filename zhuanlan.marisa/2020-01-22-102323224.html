<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>凉爽的 CuTT 介绍（0）--路径与间点</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/102323224">原文</a></p>
<blockquote>文本译自 <a class="member_mention" href="https://www.zhihu.com/people/67ebe1bd8e4a63f17a42572e40afaac7" data-hash="67ebe1bd8e4a63f17a42572e40afaac7" data-hovercard="p$b$67ebe1bd8e4a63f17a42572e40afaac7">@千里冰封 你懂吗</a> 介绍<a href="https://link.zhihu.com/?target=https%3A//ice1000.org/2019/08-01-Cutt0.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">立方类型论</a>的文章。</blockquote><h2>动机</h2><p>我打算写一系列介绍立方类型论（Cubical Type Theory，简称 CuTT）的文章， 文中会使用 Agda 证明助理。我的动机是现有的立方类型论（以及 Cubical Agda） 的教程都不可避免地需要同伦类型论（Homotopy Type Theory，简称 HoTT）方面的知识。 然而，我始终认为没有 HoTT 的背景也是可以学习 CuTT 的，只是需要一个理解 Cubical 的引路者把教程写出来而已。</p><blockquote>注：Cubical 是指 <a href="https://link.zhihu.com/?target=https%3A//ncatlab.org/nlab/show/model%2Bstructure%2Bon%2Bcubical%2Bsets" class=" wrap external" target="_blank" rel="nofollow noreferrer">立方集合模型（Cubical sets model）</a>, CuTT 即是建立在该集合模型上的类型论。与此对应的还有 <a href="https://link.zhihu.com/?target=https%3A//ncatlab.org/nlab/show/model%2Bstructure%2Bon%2Bsimplicial%2Bsets" class=" wrap external" target="_blank" rel="nofollow noreferrer">单纯形集合模型（Simplical sets model）</a></blockquote><p>我参加了 <a href="https://link.zhihu.com/?target=https%3A//hott.github.io/HoTT-2019/summer-school/" class=" wrap external" target="_blank" rel="nofollow noreferrer">HoTT 2019</a> 的暑期班，在 Anders Mörtberg 关于 Cubical 模型的演讲中 解决了很多疑惑。我觉得现在是时候成为 Cubical 的传道者，编写一份真正易读的 立方类型论介绍了。</p><p>这个介绍一点也不「热（HoTT）」，所以我称之为「凉爽（Cold）」的 CuTT 介绍。</p><h2>前置知识</h2><ul><li>非 Cubical 的 Agda（即原版 Agda）的经验</li><ul><li>（私货：可参阅《<a href="https://link.zhihu.com/?target=https%3A//agda-zh.github.io/PLFA-zh/" class=" wrap external" target="_blank" rel="nofollow noreferrer">编程语言基础：Agda 语言描述</a>》）</li></ul><li>λ-演算的基本概念，如柯里化（Currying）等</li><li>小学几何（线段、正方形、立方体）</li></ul><div class="highlight"><pre><code class="language-agda">{-# OPTIONS --cubical --omega-in-omega #-}
module 2019-8-1-Cutt0 where
open import Cubical.Core.Everything</code></pre></div><h2>走起！</h2><p>我们先从一个问题入手：<b>如何用编程语言表示证明？</b></p><p>在 Agda 的根基，Martin-Löf 类型论（MLTT）中，相等性关系使用名为 <code>_≡_</code> 的类型来表示， 它只有一个<b>居留元（Inhabitant）</b><code>refl</code>，被定义为<b>自反性（Reflexivity）</b>的证明，我们可通过此元素来参数化并索引该类型。而 CuTT 则引入了另一种相等性类型，它比起 MLTT 来说更适合 HoTT。由于这是一个「凉爽」的介绍，所以我们不会在这里解释 「为什么要用 CuTT」。</p><blockquote>译注：类型索引（Indexed）和参数化（Parameterized）参见<a href="https://link.zhihu.com/?target=https%3A//wiki.haskell.org/GHC/Type_families" class=" wrap external" target="_blank" rel="nofollow noreferrer">类型族（Type Families）</a></blockquote><h2>间点</h2><p>有种类型在论文中叫做<b>间点（Interval）</b>，在 Agda 中则被称为 <code>I</code>。 你可以点击<a href="https://link.zhihu.com/?target=https%3A//ice1000.org/lagda/Agda.Primitive.Cubical.html%2386" class=" wrap external" target="_blank" rel="nofollow noreferrer">此处</a>或原文代码中的 <code>I</code> 查看它的定义。</p><div class="highlight"><pre><code class="language-text">--         ↓
interval = I
--         ↑</code></pre></div><p>类型 <code>I</code> 的最佳解释是，一条<b>路径（Path）</b>上的点（Point）所属的类型。 想象一下 <code>i : I</code>，我们可以画图将 <code>i</code> 表示出来：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-a9bed0e1cacb96422c64b32b16b016ff_b.jpg" data-caption="" data-size="normal" data-rawwidth="458" data-rawheight="87" class="origin_image zh-lightbox-thumb" width="458" data-original="https://pic4.zhimg.com/v2-a9bed0e1cacb96422c64b32b16b016ff_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-a9bed0e1cacb96422c64b32b16b016ff_b.jpg" data-caption="" data-size="normal" data-rawwidth="458" data-rawheight="87" class="origin_image zh-lightbox-thumb lazy" width="458" data-original="https://pic4.zhimg.com/v2-a9bed0e1cacb96422c64b32b16b016ff_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-a9bed0e1cacb96422c64b32b16b016ff_b.jpg"/></figure><p>从几何上来说，我们有一条从 0 到 1 的路径，路径上的每点都是 <code>I</code> 的一个实例。 当然，0 和 1 也是 <code>I</code> 的有效实例。间点的性质如下：</p><ul><li>间点上可以使用量词——例如，<code>∀ (i : I), blabla</code>。</li><li>它们总是大于或等于 0，小于或等于 1。</li></ul><p>在 Agda 中，我们用 <code>i0</code> 来表示 0，用 <code>i1</code> 来表示 1：</p><div class="highlight"><pre><code class="language-text">_ : I
_ = i0

_ : I
_ = i1</code></pre></div><p>间点上没什么原语操作，至少无法对它们下<b>断言（Predicate）</b>，例如 <code>λ i → if i == 0 then bla else rua</code> 是不行的（不过我们可以在其它结构上对间点下断言）。不过我们还是有几个基本操作的：</p><ul><li><code>min</code> 接受两个间点，返回更接近 0 的那个</li><li><code>max</code> 接受两个间点，返回更接近 1 的那个</li><li><code>neg</code> 接受一个间点，返回与它对称的点</li></ul><p>在 Agda 中，它们用让人有点慌的数学符号来表记：</p><div class="highlight"><pre><code class="language-text">min : I → I → I
min = _∧_

max : I → I → I
max = _∨_

neg : I → I
neg = ~_</code></pre></div><p>它们遵循<b>德摩根定律（De Morgan&#39;s theorem）</b>，就是说了<code>~ (i ∧ j)</code>等价于<code>~ i ∨ ~ j</code> 的那个。端点的行为相当于：<code>i ∧ 0</code> 等于 <code>0</code>，<code>i ∨ 0</code> 等于 <code>i</code>，诸如此类。 然而，间点并非布尔值，它们是路径上的点，路径上存在无穷多的点， 而布尔值只有两个。</p><blockquote>译注：在 C-H 同构中，类型即命题，而该类型若存在<b>居留元（Inhabitant）</b>，也就意味着其对应的命题得证。在 MLTT 中，由于包含 K 公理，因此<b>相等性（Equality）</b>类型只有一个居留元 <code>refl</code>，于是 MLTT 直接放弃了讨论相等性证明本身的内容。然而 HoTT 认为，相等性证明可以被视为 Path，而 Path 和 Path 可以是不同的，于是我们就有了这样一种类型来建立起新的相等性关系：它拥有无穷多的证明， 而每一个证明都是这个相等性关系的居留元。在 CuTT 中，这样的相等性关系叫做<b>路径（Path）</b>，而其上的居留元就是<b>间点（Interval）</b>。</blockquote><p>我们可以构造一些有趣的东西：</p><div class="highlight"><pre><code class="language-text">andNot : I → I → I
andNot i j = ~ (i ∧ j)</code></pre></div><p>它等价于：</p><div class="highlight"><pre><code class="language-text">andNot&#39; : I → I → I
andNot&#39; i j = ~ i ∨ ~ j</code></pre></div><p>现在我们已经对间点有了直观的理解。很好！</p><h2>路径类型</h2><p>之所以有这样一个奇怪的类型 <code>I</code> 的原因是我们需要引入<b>路径（Path）</b>类型。 从几何上来说，每一条路径都由两个值来定义，即它的两个端点。</p><p>想象一个类型 <code>A</code> 和它的两个居留元 <code>a</code> 和 <code>b</code>，</p><div class="highlight"><pre><code class="language-text">myImagination
  : (A : Set)
  → (a b : A)</code></pre></div><p>在类型 <code>A</code> 上的 <code>a</code> 和 <code>b</code> 之间，我们可以有一个<b>路径类型</b>（我把它的参数柯里化了）：</p><div class="highlight"><pre><code class="language-text">  → Set
  myImagination = Path</code></pre></div><p><code>a</code> 和 <code>b</code> 之间<b>路径</b>的类型写作 <code>Path A a b</code>，其中 <code>A</code> 是 <code>a</code> 和 <code>b</code> 的类型。 路径的居留元是接受间点作为参数的 λ-表达式。我们称之为<b>路径-λ（Path lambda）</b>。 通常的函数也可以接受间点作为参数，然而 路径-λ 相对于普通的 λ-表达式 来说有更加特殊的构造。</p><h2>自反性</h2><p>例如，我们可以有<b>常量路径-λ（Constant Path Lambda）</b></p><div class="highlight"><pre><code class="language-agda">-- 希望在你的设备上能正常显示

constantPathLam : (A : Set) → (a : A) → Path A a a
constantPathLam    A           a        i = a
--                 ↑           ↑        ↑
--               类型          |       间点
--                       两个端点都是 `a`</code></pre></div><p>当 Agda 针对类型 <code>Path A a b</code> 检查你的路径-λ <code>p</code>（也就是定型判断 <code>Gamma |- p : Path A a b</code>）时，它会检查 <code>p i0</code> 的返回值在定义上是否等于 <code>a</code>， 以及 <code>p i1</code> 的返回值在定义上是否等于 <code>b</code>。（这里的 <code>p</code> 是接受一个间点作为参数的 λ，我们可以把它应用到一个实参上！） 由于 <code>λ i → a</code> 是 <code>Path A a a</code> 的一个有效实例，因此 <code>(λ i → a) i0</code> 本质上就是 <code>a</code>（同理 <code>(λ i → a) i1</code> 也是）。</p><p>我们可以把 <code>constantPathLam</code> 路径画成这样：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-ea492113221cbc4ab8d93bb13d7f892c_b.jpg" data-caption="" data-size="normal" data-rawwidth="431" data-rawheight="68" class="origin_image zh-lightbox-thumb" width="431" data-original="https://pic1.zhimg.com/v2-ea492113221cbc4ab8d93bb13d7f892c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-ea492113221cbc4ab8d93bb13d7f892c_b.jpg" data-caption="" data-size="normal" data-rawwidth="431" data-rawheight="68" class="origin_image zh-lightbox-thumb lazy" width="431" data-original="https://pic1.zhimg.com/v2-ea492113221cbc4ab8d93bb13d7f892c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-ea492113221cbc4ab8d93bb13d7f892c_b.jpg"/></figure><p>我们将 <code>a ≡ b</code> 作为 <code>Path _ a b</code> 的简写，因为<b>路径类型就是 CuTT 版的相等性类型</b>。</p><p>使用 <code>≡</code> 重写以上定义：</p><div class="highlight"><pre><code class="language-text">constantPathLam′ : (A : Set) → (a : A) → a ≡ a
constantPathLam′ A a i = a</code></pre></div><p>这里的 <code>constantPathLam′</code> 就是立方类型论中对自反性的证明。 它已经在 Cubical Agda 的库中了：</p><div class="highlight"><pre><code class="language-text">import Cubical.Foundations.Prelude as Prelude
_ : {A : Set} {a : A} → a ≡ a
_ = Prelude.refl</code></pre></div><p>我们可以把路径当作一个大小无限的只读数组，其索引就是间点，它由数组元素的 getter 来定义。</p><h2>对称性</h2><p>正如我们可以找到间点的对称点一样，我们也可以反转一条路径 （代码中的参数重新对齐了，以便与类型签名一致）：</p><div class="highlight"><pre><code class="language-text">invert : (A : Set) (a b : A) (p : a ≡ b) → b ≡ a
invert    A         a b       p = λ i → p (~ i)</code></pre></div><p>为解释此函数，想象一条类型为 <code>a ≡ b</code> 的路径 <code>p</code>。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-eb21a23a83557bb96cfe3055e339aba7_b.jpg" data-caption="" data-size="normal" data-rawwidth="440" data-rawheight="101" class="origin_image zh-lightbox-thumb" width="440" data-original="https://pic4.zhimg.com/v2-eb21a23a83557bb96cfe3055e339aba7_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-eb21a23a83557bb96cfe3055e339aba7_b.jpg" data-caption="" data-size="normal" data-rawwidth="440" data-rawheight="101" class="origin_image zh-lightbox-thumb lazy" width="440" data-original="https://pic4.zhimg.com/v2-eb21a23a83557bb96cfe3055e339aba7_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-eb21a23a83557bb96cfe3055e339aba7_b.jpg"/></figure><p>我们构造了一个新的路径-λ，它将每一个间点都映射到「<code>p</code> 上对称的间点」上， 因此它的类型就是「与 <code>a ≡ b</code> 对称的路径」也就是 <code>b ≡ a</code>。下面是它的图解， 其中一条从 <code>i</code> 到 <code>~ i</code> 的映射被显式地画了出来（你需要自己脑补上方路径上所有的间点， 例如 <code>i</code>，都被映射到了下方路径对应的点上，例如 <code>~ i</code>）：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-19ac6bc5c36a72d3bec130a98f553f11_b.jpg" data-size="normal" data-rawwidth="483" data-rawheight="423" class="origin_image zh-lightbox-thumb" width="483" data-original="https://pic2.zhimg.com/v2-19ac6bc5c36a72d3bec130a98f553f11_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-19ac6bc5c36a72d3bec130a98f553f11_b.jpg" data-size="normal" data-rawwidth="483" data-rawheight="423" class="origin_image zh-lightbox-thumb lazy" width="483" data-original="https://pic2.zhimg.com/v2-19ac6bc5c36a72d3bec130a98f553f11_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-19ac6bc5c36a72d3bec130a98f553f11_b.jpg"/><figcaption>在此图中，从路径 p 上的间点 i 开始指向某个 a 的箭头表示 「与 i 对应的值（或者说点）为 a 」或「p i 的求值结果为 a」</figcaption></figure><p>我们刚才做了什么？我们创建了一个新的路径-λ，它返回某种由一个给定路径和 它接受的间点构成的复合表达式。利用类似的技术和一点函数式编程，我们可以再玩两个魔法。</p><h2>合同性</h2><p>首先，我们可以在 MLTT 中证明<b>合同性（Congruence）</b>。我们创建一个函数，</p><div class="highlight"><pre><code class="language-text">congruence
  : {A B : Set}</code></pre></div><p>它接受一个从 <code>A</code> 到 <code>B</code> 的函数，</p><div class="highlight"><pre><code class="language-text">→ (f : A → B)</code></pre></div><p>和一条 <code>A</code> 上两个居留元之间的路径，</p><div class="highlight"><pre><code class="language-text">→ {x y : A}
  → (p : x ≡ y)</code></pre></div><p>之后返回一条类型为 <code>f x ≡ f y</code> 的路径。</p><div class="highlight"><pre><code class="language-text">→ f x ≡ f y</code></pre></div><p>我们要如何证明它？嗯…通过创建一条路径，然后对它接受的间点和其它提供的变量施一些魔法，就像这样：</p><div class="highlight"><pre><code class="language-text">congruence f p = λ i → f (p i)</code></pre></div><p>这段代码做了什么？它：</p><ol><li>创建了一个路径-λ，于是我们有了一个间点 <code>i</code></li><li>把<code>i</code> 传给 <code>p</code> ，注意我们的路径 <code>p</code> 上全都是类型为 <code>A</code> 的值，它在 <code>a</code> 和 <code>b</code> 之间</li></ol><p>把从 <code>p</code> 中提取的值传给函数 <code>f</code>，该函数接受一个 <code>A</code> 的实例并返回一个 <code>B</code> 的实例。</p><p>就是这样！我们可以可视化此过程。 首先我们将间点传给 <code>p</code>：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-8ee61c27be761b10003af417ee245bc6_b.jpg" data-caption="" data-size="normal" data-rawwidth="503" data-rawheight="437" class="origin_image zh-lightbox-thumb" width="503" data-original="https://pic3.zhimg.com/v2-8ee61c27be761b10003af417ee245bc6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-8ee61c27be761b10003af417ee245bc6_b.jpg" data-caption="" data-size="normal" data-rawwidth="503" data-rawheight="437" class="origin_image zh-lightbox-thumb lazy" width="503" data-original="https://pic3.zhimg.com/v2-8ee61c27be761b10003af417ee245bc6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-8ee61c27be761b10003af417ee245bc6_b.jpg"/></figure><p>接着我们在其结果上应用了 <code>f</code> 后返回来：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-19adbd1b69e65d8eba27e9bcc32d31f4_b.jpg" data-caption="" data-size="normal" data-rawwidth="489" data-rawheight="426" class="origin_image zh-lightbox-thumb" width="489" data-original="https://pic1.zhimg.com/v2-19adbd1b69e65d8eba27e9bcc32d31f4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-19adbd1b69e65d8eba27e9bcc32d31f4_b.jpg" data-caption="" data-size="normal" data-rawwidth="489" data-rawheight="426" class="origin_image zh-lightbox-thumb lazy" width="489" data-original="https://pic1.zhimg.com/v2-19adbd1b69e65d8eba27e9bcc32d31f4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-19adbd1b69e65d8eba27e9bcc32d31f4_b.jpg"/></figure><p>搞定！</p><h2>函数外延性</h2><p><b>函数外延性（Function Extensionality）</b>是这样一个命题：若两函数上的每一点都等价， 则两函数等价。以前我们无法结构化地证明它，然而现在有了 CuTT，我们就可以证明它了。 我们可以将函数外延性表示为一个函数：</p><div class="highlight"><pre><code class="language-text">functionExtensionality
  : {A B : Set}</code></pre></div><p>它接受两个从 <code>A</code> 到 <code>B</code> 的函数：</p><div class="highlight"><pre><code class="language-text">→ {f g : A → B}</code></pre></div><p>以及一个二者上的每一点都相等的证明 <code>p</code>：</p><div class="highlight"><pre><code class="language-text">→ (p : ∀ a → f a ≡ g a)</code></pre></div><p>并返回一个两函数等价的证明：</p><div class="highlight"><pre><code class="language-text">→ f ≡ g</code></pre></div><p>我们可以构造一条返回一个函数的路径，其中的函数用 <code>p</code> 来实现，从而证明函数外延性：</p><div class="highlight"><pre><code class="language-text">functionExtensionality p i = λ a → p a i</code></pre></div><p>这一次，我们：</p><ol><li>创建了一个路径-λ，因此有了一个间点 <code>i</code></li><li>它返回的另一个 λ 接受一个类型为 <code>A</code> 的参数 <code>a</code>，就像 <code>f</code> 和 <code>g</code> 那样</li><li>在 <code>a</code> 上应用 <code>p</code>，我们就得到了一条类型为 <code>f a ≡ g a</code> 的路径 （注意 <code>f a</code> 和 <code>g a</code> 的类型为 <code>B</code>）</li><li>在 <code>i</code> 上应用该路径，我们就得到了一个 <code>B</code> 的实例</li></ol><p>为了图示此证明，我们首先画出 <code>p</code>，即每一点相等的证明，它是一个返回一条路径的函数：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-200c3c2e6ac6b70cd459c857d5c37c57_b.jpg" data-size="normal" data-rawwidth="438" data-rawheight="271" class="origin_image zh-lightbox-thumb" width="438" data-original="https://pic4.zhimg.com/v2-200c3c2e6ac6b70cd459c857d5c37c57_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-200c3c2e6ac6b70cd459c857d5c37c57_b.jpg" data-size="normal" data-rawwidth="438" data-rawheight="271" class="origin_image zh-lightbox-thumb lazy" width="438" data-original="https://pic4.zhimg.com/v2-200c3c2e6ac6b70cd459c857d5c37c57_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-200c3c2e6ac6b70cd459c857d5c37c57_b.jpg"/><figcaption>图中从路径以外的任意一点开始，到路径上间点的每一根箭头都是一个函数</figcaption></figure><p>其中的 <code>p</code> 是一个从 <code>a</code> 到一条路径的函数，如果我们用间点来表示它原本会返回的点， 那么我们可以将它特化为一个从 <code>a</code> 到路径上任意特定的点上的函数。 这样我们就创建了一条新的路径，它将每一个间点 <code>i</code> 都映射成了一个通过 <code>i</code> 将 <code>p</code> 特化后所得到的函数。下面是它的图示：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-b3168f6dc66397c7b4d91591cb6e817a_b.jpg" data-caption="" data-size="normal" data-rawwidth="463" data-rawheight="375" class="origin_image zh-lightbox-thumb" width="463" data-original="https://pic3.zhimg.com/v2-b3168f6dc66397c7b4d91591cb6e817a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-b3168f6dc66397c7b4d91591cb6e817a_b.jpg" data-caption="" data-size="normal" data-rawwidth="463" data-rawheight="375" class="origin_image zh-lightbox-thumb lazy" width="463" data-original="https://pic3.zhimg.com/v2-b3168f6dc66397c7b4d91591cb6e817a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-b3168f6dc66397c7b4d91591cb6e817a_b.jpg"/></figure><blockquote>译注：我们可以换一种描述：<code>p</code> 通过将任意类型为 <code>A</code> 的值 <code>a</code> 分别代入 <code>f</code> 和 <code>g</code>， 为 <code>f a</code> 和 <code>g a</code> 建立了一条证明二者等价的路径，而每一个具体的 <code>a</code> 都可以被映射到 这条路径上的一个间点，把这样的每一个映射本身都看做一个个间点，这些间点连缀而成的路径也就成了 <code>f≡g</code> 的证明。</blockquote><h2>小结</h2><p>现在我们相当熟悉简单的路径了（希望如此）。 作为练习，请定义「高阶」路径，它的端点也是路径，这意味着我们的路径-λ 也会返回路径-λ， 例如，<code>λ i j → a</code> 其中的 <code>a</code> 包含自由变量 <code>i</code> 和 <code>j</code>。 请思考一下这样的路径，我们会在下一章中讨论它。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
