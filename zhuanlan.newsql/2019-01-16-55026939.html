<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TiDB 在转转的业务实战</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/55026939">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-eb4578b6386a0021b17d7c418e728fbe_b.jpg" alt=""></div><blockquote><b>作者介绍</b><br>陈维，转转优品技术部 RD。</blockquote><p>世界级的开源分布式数据库 TiDB 自 2016 年 12 月正式发布第一个版本以来，业内诸多公司逐步引入使用，并取得广泛认可。</p><p>对于互联网公司，数据存储的重要性不言而喻。在 NewSQL 数据库出现之前，一般采用单机数据库（比如 MySQL）作为存储，随着数据量的增加，“分库分表”是早晚面临的问题，即使有诸如 MyCat、ShardingJDBC 等优秀的中间件，“分库分表”还是给 RD 和 DBA 带来较高的成本；NewSQL 数据库出现后，由于它不仅有 NoSQL 对海量数据的管理存储能力、还支持传统关系数据库的 ACID 和 SQL，所以对业务开发来说，存储问题已经变得更加简单友好，进而可以更专注于业务本身。而 TiDB，正是 NewSQL 的一个杰出代表！</p><p>站在业务开发的视角，TiDB 最吸引人的几大特性是：</p><ol><li>支持 MySQL 协议（开发接入成本低）；</li><li>100% 支持事务（数据一致性实现简单、可靠）；</li><li>无限水平拓展（不必考虑分库分表）。</li></ol><p>基于这几大特性，TiDB 在业务开发中是值得推广和实践的，但是，它毕竟不是传统的关系型数据库，以致我们对关系型数据库的一些使用经验和积累，在 TiDB 中是存在差异的，现主要阐述“事务”和“查询”两方面的差异。</p><h2><b>TiDB 事务和 MySQL 事务的差异</b></h2><ul><li><b>MySQL 事务和 TiDB 事务对比</b></li></ul><figure><noscript><img src="https://pic2.zhimg.com/v2-f0bc66dc787eead6082fb48e978407d1_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="400" class="origin_image zh-lightbox-thumb" width="864" data-original="https://pic2.zhimg.com/v2-f0bc66dc787eead6082fb48e978407d1_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-f0bc66dc787eead6082fb48e978407d1_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="400" class="origin_image zh-lightbox-thumb lazy" width="864" data-original="https://pic2.zhimg.com/v2-f0bc66dc787eead6082fb48e978407d1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-f0bc66dc787eead6082fb48e978407d1_b.jpg"></figure><p>在 TiDB 中执行的事务 b，返回影响条数是 1（认为已经修改成功），但是提交后查询，status 却不是事务 b 修改的值，而是事务 a 修改的值。</p><p>可见，MySQL 事务和 TiDB 事务存在这样的差异：</p><p>MySQL 事务中，可以通过影响条数，作为写入（或修改）是否成功的依据；而在 TiDB 中，这却是不可行的！</p><p>作为开发者我们需要考虑下面的问题：</p><ol><li>同步 RPC 调用中，如果需要严格依赖影响条数以确认返回值，那将如何是好？</li><li>多表操作中，如果需要严格依赖某个主表数据更新结果，作为是否更新（或写入）其他表的判断依据，那又将如何是好？</li></ol><ul><li><b>原因分析及解决方案</b></li></ul><p>对于 MySQL，当更新某条记录时，会先获取该记录对应的行级锁（排他锁），获取成功则进行后续的事务操作，获取失败则阻塞等待。</p><p>对于 TiDB，使用 Percolator 事务模型：可以理解为乐观锁实现，事务开启、事务中都不会加锁，而是在提交时才加锁。参见 <u><a href="http://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247484286%26idx%3D2%26sn%3D45b7d9e29af3965567f1743f0c2b536c%26chksm%3Deb162414dc61ad02877378fb97d1790a946c72f4c344260c037d1ae0f9817f2e4d14d1c6233e%26scene%3D21%23wechat_redirect" class=" wrap external" target="_blank" rel="nofollow noreferrer">这篇文章</a></u>（TiDB 事务算法）。</p><p>其简要流程如下：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-480a8128457b1092c4e9df41caf07b69_b.jpg" data-caption="" data-size="normal" data-rawwidth="733" data-rawheight="618" class="origin_image zh-lightbox-thumb" width="733" data-original="https://pic2.zhimg.com/v2-480a8128457b1092c4e9df41caf07b69_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-480a8128457b1092c4e9df41caf07b69_b.jpg" data-caption="" data-size="normal" data-rawwidth="733" data-rawheight="618" class="origin_image zh-lightbox-thumb lazy" width="733" data-original="https://pic2.zhimg.com/v2-480a8128457b1092c4e9df41caf07b69_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-480a8128457b1092c4e9df41caf07b69_b.jpg"></figure><p>在事务提交的 PreWrite 阶段，当“锁检查”失败时：如果开启冲突重试，事务提交将会进行重试；如果未开启冲突重试，将会抛出写入冲突异常。</p><p>可见，对于 MySQL，由于在写入操作时加上了排他锁，变相将并行事务从逻辑上串行化；而对于 TiDB，属于乐观锁模型，在事务提交时才加锁，并使用事务开启时获取的“全局时间戳”作为“锁检查”的依据。</p><p>所以，在业务层面避免 TiDB 事务差异的本质在于避免锁冲突，即，当前事务执行时，不产生别的事务时间戳（无其他事务并行）。处理方式为事务串行化。</p><ul><li><b>TiDB 事务串行化</b></li></ul><p>在业务层，可以借助分布式锁，实现串行化处理，如下：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-4e5f59504ec0e644ff5f2da424de4e65_b.jpg" data-caption="" data-size="normal" data-rawwidth="714" data-rawheight="350" class="origin_image zh-lightbox-thumb" width="714" data-original="https://pic2.zhimg.com/v2-4e5f59504ec0e644ff5f2da424de4e65_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-4e5f59504ec0e644ff5f2da424de4e65_b.jpg" data-caption="" data-size="normal" data-rawwidth="714" data-rawheight="350" class="origin_image zh-lightbox-thumb lazy" width="714" data-original="https://pic2.zhimg.com/v2-4e5f59504ec0e644ff5f2da424de4e65_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-4e5f59504ec0e644ff5f2da424de4e65_b.jpg"></figure><p><b>基于 Spring 和分布式锁的事务管理器拓展</b></p><p>在 Spring 生态下，spring-tx 中定义了统一的事务管理器接口：<code>PlatformTransactionManager</code>，其中有获取事务（getTransaction）、提交（commit）、回滚（rollback）三个基本方法；使用装饰器模式，事务串行化组件可做如下设计：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-058e6ce48a070e242e7ce42c2eb97cc5_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="647" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic2.zhimg.com/v2-058e6ce48a070e242e7ce42c2eb97cc5_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-058e6ce48a070e242e7ce42c2eb97cc5_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="647" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic2.zhimg.com/v2-058e6ce48a070e242e7ce42c2eb97cc5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-058e6ce48a070e242e7ce42c2eb97cc5_b.jpg"></figure><p>其中，关键点有：</p><ol><li>超时时间：为避免死锁，锁必须有超时时间；为避免锁超时导致事务并行，事务必须有超时时间，而且锁超时时间必须大于事务超时时间（时间差最好在秒级）。</li><li>加锁时机：TiDB 中“锁检查”的依据是事务开启时获取的“全局时间戳”，所以加锁时机必须在事务开启前。</li></ol><p><b>事务模板接口设计</b></p><p>隐藏复杂的事务重写逻辑，暴露简单友好的 API：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-41d1ac47b69b440efa9b5af6646980cf_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="257" class="origin_image zh-lightbox-thumb" width="864" data-original="https://pic4.zhimg.com/v2-41d1ac47b69b440efa9b5af6646980cf_r.jpg"></noscript><img src="https://pic4.zhimg.com/v2-41d1ac47b69b440efa9b5af6646980cf_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="257" class="origin_image zh-lightbox-thumb lazy" width="864" data-original="https://pic4.zhimg.com/v2-41d1ac47b69b440efa9b5af6646980cf_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-41d1ac47b69b440efa9b5af6646980cf_b.jpg"></figure><u><figure><noscript><img src="https://pic1.zhimg.com/v2-2332bab1107b2161a427057787b243b0_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="213" class="origin_image zh-lightbox-thumb" width="864" data-original="https://pic1.zhimg.com/v2-2332bab1107b2161a427057787b243b0_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-2332bab1107b2161a427057787b243b0_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="213" class="origin_image zh-lightbox-thumb lazy" width="864" data-original="https://pic1.zhimg.com/v2-2332bab1107b2161a427057787b243b0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-2332bab1107b2161a427057787b243b0_b.jpg"></figure></u><h2><b>TiDB 查询和 MySQL 的差异</b></h2><p>在 TiDB 使用过程中，偶尔会有这样的情况，某几个字段建立了索引，但是查询过程还是很慢，甚至不经过索引检索。</p><ul><li><b>索引混淆型（举例）</b></li></ul><p><b>表结构：</b></p><div class="highlight"><pre><code class="language-text"><span></span>CREATE TABLE `t_test` (
	  `id` bigint(20) NOT NULL DEFAULT '0' COMMENT '主键id',
	  `a` int(11) NOT NULL DEFAULT '0' COMMENT 'a',
	  `b` int(11) NOT NULL DEFAULT '0' COMMENT 'b',
	  `c` int(11) NOT NULL DEFAULT '0' COMMENT 'c',
	  PRIMARY KEY (`id`),
	  KEY `idx_a_b` (`a`,`b`),
	  KEY `idx_c` (`c`)
	) ENGINE=InnoDB;
</code></pre></div><p><b>查询：</b>如果需要查询 (a=1 且 b=1）或 c=2 的数据，在 MySQL 中，sql 可以写为：<code>SELECT id from t_test where (a=1 and b=1) or (c=2);</code>，MySQL 做查询优化时，会检索到 <code>idx_a_b</code> 和<code>idx_c</code> 两个索引；但是在 TiDB（v2.0.8-9）中，这个 sql 会成为一个慢 SQL，需要改写为：</p><div class="highlight"><pre><code class="language-text"><span></span>SELECT id from t_test where (a=1 and b=1) UNION SELECT id from t_test where (c=2);
</code></pre></div><p>小结：导致该问题的原因，可以理解为 TiDB 的 sql 解析还有优化空间（官方回复已在优化计划中）。</p><ul><li><b>冷热数据型（举例）</b></li></ul><p><b>表结构：</b></p><div class="highlight"><pre><code class="language-text"><span></span>CREATE TABLE `t_job_record` (
	  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
	  `job_code` varchar(255) NOT NULL DEFAULT '' COMMENT '任务code',
	  `record_id` bigint(20) NOT NULL DEFAULT '0' COMMENT '记录id',
	  `status` tinyint(3) NOT NULL DEFAULT '0' COMMENT '执行状态:0 待处理',
	  `execute_time` bigint(20) NOT NULL DEFAULT '0' COMMENT '执行时间（毫秒）',
	  PRIMARY KEY (`id`),
	  KEY `idx_status_execute_time` (`status`,`execute_time`),
	  KEY `idx_record_id` (`record_id`)
	) ENGINE=InnoDB COMMENT='异步任务job'
</code></pre></div><p><b>数据说明：</b></p><p>a. 冷数据，<code>status=1</code> 的数据（已经处理过的数据）；</p><p>b. 热数据，<code>status=0 并且 execute_time&lt;= 当前时间</code> 的数据。</p><p><b>慢查询</b>：对于热数据，数据量一般不大，但是查询频度很高，假设当前（毫秒级）时间为：1546361579646，则在 MySQL 中，查询 sql 为：</p><div class="highlight"><pre><code class="language-text"><span></span>SELECT * FROM t_job_record where status=0 and execute_time&lt;= 1546361579646
</code></pre></div><p>这个在 MySQL 中很高效的查询，在 TiDB 中虽然也可从索引检索，但其耗时却不尽人意（百万级数据量，耗时百毫秒级）。</p><p><b>原因分析：</b>在 TiDB 中，底层索引结构为 LSM-Tree，如下图：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-28159187b532d99a7ac34059f1ab04e1_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="206" class="origin_image zh-lightbox-thumb" width="864" data-original="https://pic2.zhimg.com/v2-28159187b532d99a7ac34059f1ab04e1_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-28159187b532d99a7ac34059f1ab04e1_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="206" class="origin_image zh-lightbox-thumb lazy" width="864" data-original="https://pic2.zhimg.com/v2-28159187b532d99a7ac34059f1ab04e1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-28159187b532d99a7ac34059f1ab04e1_b.jpg"></figure><p>当从内存级的 C0 层查询不到数据时，会逐层扫描硬盘中各层；且 merge 操作为异步操作，索引数据更新会存在一定的延迟，可能存在无效索引。由于逐层扫描和异步 merge，使得查询效率较低。</p><p>优化方式：尽可能缩小过滤范围，比如结合异步 job 获取记录频率，在保证不遗漏数据的前提下，合理设置 execute_time 筛选区间，例如 1 小时，sql 改写为：</p><div class="highlight"><pre><code class="language-text"><span></span>SELECT * FROM t_job_record  where status=0 and execute_time&gt;1546357979646 and execute_time&lt;= 1546361579646
</code></pre></div><p><b>优化效果：</b>耗时 10 毫秒级别（以下）。</p><ul><li><b>关于查询的启发</b></li></ul><p>在基于 TiDB 的业务开发中，先摒弃传统关系型数据库带来的对 sql 先入为主的理解或经验，谨慎设计每一个 sql，如 DBA 所提倡：设计 sql 时务必关注执行计划，必要时请教 DBA。</p><p>和 MySQL 相比，TiDB 的底层存储和结构决定了其特殊性和差异性；但是，TiDB 支持 MySQL 协议，它们也存在一些共同之处，比如在 TiDB 中使用“预编译”和“批处理”，同样可以获得一定的性能提升。</p><h2><b>服务端预编译</b></h2><p>在 MySQL 中，可以使用 <code>PREPARE stmt_name FROM preparable_stm</code>  对 sql 语句进行预编译，然后使用 <code>EXECUTE stmt_name [USING @var_name [, @var_name] ...]</code> 执行预编译语句。如此，同一 sql 的多次操作，可以获得比常规 sql 更高的性能。</p><p>mysql-jdbc 源码中，实现了标准的 <code>Statement</code> 和 <code>PreparedStatement</code> 的同时，还有一个<code>ServerPreparedStatement</code> 实现，<code>ServerPreparedStatement</code> 属于<code>PreparedStatement</code>的拓展，三者对比如下：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-7b504d262d5b9e2d941a312f8798e02a_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="320" class="origin_image zh-lightbox-thumb" width="864" data-original="https://pic3.zhimg.com/v2-7b504d262d5b9e2d941a312f8798e02a_r.jpg"></noscript><img src="https://pic3.zhimg.com/v2-7b504d262d5b9e2d941a312f8798e02a_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="320" class="origin_image zh-lightbox-thumb lazy" width="864" data-original="https://pic3.zhimg.com/v2-7b504d262d5b9e2d941a312f8798e02a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-7b504d262d5b9e2d941a312f8798e02a_b.jpg"></figure><p>容易发现，<code>PreparedStatement</code> 和  <code>Statement</code>的区别主要区别在于参数处理，而对于发送数据包，调用服务端的处理逻辑是一样（或类似）的；经测试，二者速度相当。其实，<code>PreparedStatement</code> 并不是服务端预处理的；<code>ServerPreparedStatement</code> 才是真正的服务端预处理，速度也较 <code>PreparedStatement</code> 快；其使用场景一般是：频繁的数据库访问，sql 数量有限（有缓存淘汰策略，使用不宜会导致两次 IO）。</p><h2><b>批处理</b></h2><p>对于多条数据写入，常用 sql 为 <code>insert … values(…),(…)</code>；而对于多条数据更新，亦可以使用<code>update … case … when… then… end</code> 来减少 IO 次数。但它们都有一个特点，数据条数越多，sql 越加复杂，sql 解析成本也更高，耗时增长可能高于线性增长。而批处理，可以复用一条简单 sql，实现批量数据的写入或更新，为系统带来更低、更稳定的耗时。</p><p>对于批处理，作为客户端，<code>java.sql.Statement</code> 主要定义了两个接口方法，<code>addBatch</code>  和  <code>executeBatch</code>  来支持批处理。</p><p>批处理的简要流程说明如下：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-f134ea114f7ac12f6120f484dea108ce_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="525" class="origin_image zh-lightbox-thumb" width="864" data-original="https://pic3.zhimg.com/v2-f134ea114f7ac12f6120f484dea108ce_r.jpg"></noscript><img src="https://pic3.zhimg.com/v2-f134ea114f7ac12f6120f484dea108ce_b.jpg" data-caption="" data-size="normal" data-rawwidth="864" data-rawheight="525" class="origin_image zh-lightbox-thumb lazy" width="864" data-original="https://pic3.zhimg.com/v2-f134ea114f7ac12f6120f484dea108ce_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-f134ea114f7ac12f6120f484dea108ce_b.jpg"></figure><p>经业务中实践，使用批处理方式的写入（或更新），比常规 <code>insert … values (…),(…)</code>（或  <code>update … case … when… then… end</code>）性能更稳定，耗时也更低。</p><p><br></p><p><i><b>本文转载自“转转技术”，原文链接：</b></i></p><a href="http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/Qyvy_YBIBhZJo1uYHTL93g%3Fscene%3D25%23wechat_redirect" data-draft-node="block" data-draft-type="link-card" data-image="https://pic1.zhimg.com/v2-4a5821a1189a52c4708ad4a65139e744_180x120.jpg" data-image-width="470" data-image-height="200" class=" wrap external" target="_blank" rel="nofollow noreferrer">TiDB业务实战</a><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
