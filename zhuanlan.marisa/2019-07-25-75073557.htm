<p>AST是用来表示语法构造的数据结构，而在大多数语言中都有“变量”的概念。</p><ul><li>那么应在AST中用什么方式表示一个“变量”呢？</li><li>怎么进行变量的替换呢？</li><li>怎么进行变量作用域的检查呢？</li></ul><h2>First-Order Abstract Syntax</h2><p>最简单直接的方法就是直接用字符串保存变量名，以lambda calculus为例：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="kt">Name</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">data</span> <span class="kt">Expr</span>
  <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">Name</span> 
  <span class="o">|</span> <span class="kt">App</span> <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">Lam</span> <span class="kt">Name</span> <span class="kt">Expr</span></code></pre></div><p>这种AST被称为FOAS，一般是parse完得到的。但这种裸的AST几乎不包含任何信息，变量和作用域之间<i>没有直接的关系</i>，bindings也只是由<i>匹配字符串</i>来表示。</p><p><b>在这个层面上对AST操作是十分不安全的，稍不注意就可能改变了语义</b>。比如说不带更名的substitution：<code>(λy.λx.y)x</code>→<code>λx.x</code>。</p><p>若要写出正确的substitution还得花点小心思，这是wiki上lambda calculus的substitution的定义（少了一种情况）：</p><div class="highlight"><pre><code class="language-text">x[x := N]       ≡ N
y[x := N]       ≡ y, if x ≠ y
(M1 M2)[x := N] ≡ (M1[x := N]) (M2[x := N])
(λx.M)[x := N]  ≡ λx.M
(λy.M)[x := N]  ≡ λy.(M[x := N]), if x ≠ y, provided y ∉ FV(N)</code></pre></div><p>“翻译到”haskell：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">freeVars</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Name</span><span class="p">]</span>
<span class="nf">freeVars</span> <span class="p">(</span><span class="kt">Var</span> <span class="nf">v</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span><span class="nf">v</span><span class="p">]</span>
<span class="nf">freeVars</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">freeVars</span> <span class="nf">f</span> <span class="p">`</span><span class="nf">union</span><span class="p">`</span> <span class="nf">freeVars</span> <span class="nf">x</span> 
<span class="nf">freeVars</span> <span class="p">(</span><span class="kt">Lam</span> <span class="nf">n</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">freeVars</span> <span class="nf">b</span> <span class="o">\\</span> <span class="p">[</span><span class="nf">n</span><span class="p">]</span>

<span class="nf">allVars</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Name</span><span class="p">]</span>
<span class="nf">allVars</span> <span class="p">(</span><span class="kt">Var</span> <span class="nf">v</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span><span class="nf">v</span><span class="p">]</span>
<span class="nf">allVars</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">allVars</span> <span class="nf">f</span> <span class="p">`</span><span class="nf">union</span><span class="p">`</span> <span class="nf">allVars</span> <span class="nf">x</span>
<span class="nf">allVars</span> <span class="p">(</span><span class="kt">Lam</span> <span class="nf">n</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">allVars</span> <span class="nf">b</span>

<span class="nf">subst</span> <span class="ow">::</span> <span class="kt">Name</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span>
<span class="nf">subst</span> <span class="nf">x</span> <span class="nf">s</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">sub</span> <span class="nf">vs0</span> <span class="nf">b</span> <span class="kr">where</span>
  <span class="nf">sub</span> <span class="kr">_</span> <span class="nf">e</span><span class="o">@</span><span class="p">(</span><span class="kt">Var</span> <span class="nf">v</span><span class="p">)</span>
    <span class="o">|</span> <span class="nf">v</span> <span class="o">==</span> <span class="nf">x</span>    <span class="ow">=</span> <span class="nf">s</span>
    <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="nf">e</span>
  <span class="nf">sub</span> <span class="nf">vs</span> <span class="nf">e</span><span class="o">@</span><span class="p">(</span><span class="kt">Lam</span> <span class="nf">v</span> <span class="nf">e&#39;</span><span class="p">)</span>
    <span class="o">|</span> <span class="nf">v</span> <span class="o">==</span> <span class="nf">x</span>       <span class="ow">=</span> <span class="nf">e</span>
    <span class="o">|</span> <span class="nf">v</span> <span class="p">`</span><span class="nf">elem</span><span class="p">`</span> <span class="nf">fvs</span> <span class="ow">=</span> <span class="kt">Lam</span> <span class="nf">v&#39;</span> <span class="p">(</span><span class="nf">sub</span> <span class="p">(</span><span class="nf">v&#39;</span><span class="kt">:</span><span class="nf">vs</span><span class="p">)</span> <span class="nf">e&#39;&#39;</span><span class="p">)</span>
    <span class="o">|</span> <span class="nf">otherwise</span>    <span class="ow">=</span> <span class="kt">Lam</span> <span class="nf">v</span> <span class="p">(</span><span class="nf">sub</span> <span class="nf">vs</span> <span class="nf">e&#39;</span><span class="p">)</span> <span class="kr">where</span>
    <span class="nf">v&#39;</span> <span class="ow">=</span> <span class="nf">newName</span> <span class="nf">vs</span>
    <span class="nf">e&#39;&#39;</span> <span class="ow">=</span> <span class="nf">subst</span> <span class="nf">v</span> <span class="p">(</span><span class="kt">Var</span> <span class="nf">v&#39;</span><span class="p">)</span> <span class="nf">e&#39;</span>
  <span class="nf">sub</span> <span class="nf">vs</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">sub</span> <span class="nf">vs</span> <span class="nf">f</span> <span class="p">`</span><span class="kt">App</span><span class="p">`</span> <span class="nf">sub</span> <span class="nf">vs</span> <span class="nf">x</span>

  <span class="nf">fvs</span> <span class="ow">=</span> <span class="nf">freeVars</span> <span class="nf">s</span>
  <span class="nf">vs0</span> <span class="ow">=</span> <span class="nf">fvs</span> <span class="p">`</span><span class="nf">union</span><span class="p">`</span> <span class="nf">allVars</span> <span class="nf">b</span> 

<span class="nf">newName</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Name</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Name</span>
<span class="nf">newName</span> <span class="nf">vs</span> <span class="ow">=</span> <span class="nf">head</span> <span class="p">(</span><span class="nf">names</span> <span class="o">\\</span> <span class="nf">vs</span><span class="p">)</span>

<span class="nf">names</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Name</span><span class="p">]</span>
<span class="nf">names</span> <span class="ow">=</span> <span class="p">[</span><span class="sc">&#39;x&#39;</span> <span class="kt">:</span> <span class="nf">show</span> <span class="nf">j</span> <span class="o">|</span> <span class="nf">j</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]]</span></code></pre></div><p>同时，这种替换效率很低。</p><p>我认为AST里面带上scope的信息是很必要的（本身字符串就表达不了变量名“指代”这样的语义），或许可以为之后的分析和优化提供更多的信息，主要是防止AST变换导致语义发生改变。</p><h2>High-Other Abstract Syntax</h2><p>HOAS一种十分简洁的带有scope信息的AST：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Expr</span> 
  <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span><span class="p">)</span>
  <span class="o">|</span> <span class="kt">App</span> <span class="kt">Expr</span> <span class="kt">Expr</span></code></pre></div><p>它直接将meta language的binding借了过去：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">s</span>     <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\f</span> <span class="ow">-&gt;</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\g</span> <span class="ow">-&gt;</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\x</span> <span class="ow">-&gt;</span> <span class="kt">App</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">g</span> <span class="nf">x</span><span class="p">))))</span>
<span class="nf">k</span>     <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\x</span> <span class="ow">-&gt;</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\y</span> <span class="ow">-&gt;</span> <span class="nf">x</span><span class="p">))</span>
<span class="nf">i</span>     <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\x</span> <span class="ow">-&gt;</span> <span class="nf">x</span><span class="p">)</span>
<span class="nf">omega</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">self</span> <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\x</span> <span class="ow">-&gt;</span> <span class="kt">App</span> <span class="nf">x</span> <span class="nf">x</span><span class="p">)</span> <span class="kr">in</span> <span class="kt">App</span> <span class="nf">self</span> <span class="nf">self</span>
<span class="nf">zero</span>  <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\f</span> <span class="ow">-&gt;</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\x</span> <span class="ow">-&gt;</span> <span class="nf">x</span><span class="p">))</span>
<span class="nf">suc</span>   <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\n</span> <span class="ow">-&gt;</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">\z</span> <span class="ow">-&gt;</span> <span class="kt">App</span> <span class="nf">s</span> <span class="p">(</span><span class="kt">App</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">n</span> <span class="nf">s</span><span class="p">)</span> <span class="nf">z</span><span class="p">))))</span></code></pre></div><p>甚至将求值器也借了过来。substitution直接就是apply。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">whnf</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span>
<span class="nf">whnf</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="nf">whnf</span> <span class="nf">f</span> <span class="kr">of</span>
  <span class="kt">Lam</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">whnf</span> <span class="p">(</span><span class="nf">b</span> <span class="nf">x</span><span class="p">)</span>
  <span class="nf">f&#39;</span>    <span class="ow">-&gt;</span> <span class="kt">App</span> <span class="nf">f&#39;</span> <span class="nf">x</span>
<span class="nf">whnf</span> <span class="nf">e</span> <span class="ow">=</span> <span class="nf">e</span>

<span class="nf">nf</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span>
<span class="nf">nf</span> <span class="p">(</span><span class="kt">Lam</span> <span class="nf">f</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">nf</span> <span class="o">.</span> <span class="nf">f</span><span class="p">)</span>
<span class="nf">nf</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="nf">whnf</span> <span class="nf">f</span> <span class="kr">of</span>
  <span class="kt">Lam</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">nf</span> <span class="p">(</span><span class="nf">b</span> <span class="nf">x</span><span class="p">)</span>
  <span class="nf">f&#39;</span> <span class="ow">-&gt;</span> <span class="nf">nf</span> <span class="nf">f&#39;</span> <span class="p">`</span><span class="kt">App</span><span class="p">`</span> <span class="nf">nf</span> <span class="nf">x</span>
<span class="nf">nf</span> <span class="nf">v</span> <span class="ow">=</span> <span class="nf">v</span></code></pre></div><p>而且HOAS的这种substitution特别的快。</p><p>不过HOAS的缺点也是十分明显的，我们不能“看进”一颗HOAS里，于是就不能对其做很多操作，比如pretty print、优化等。当然现在有一个比较简单的方法，为HOAS开个“洞”，通过这个“洞”看到里面的东西：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Expr</span> <span class="nf">a</span>
  <span class="ow">=</span> <span class="kt">Hole</span> <span class="nf">a</span> <span class="c1">-- store some meta objects</span>
  <span class="o">|</span> <span class="kt">Lam</span> <span class="p">(</span><span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span><span class="p">)</span>
  <span class="o">|</span> <span class="kt">App</span> <span class="p">(</span><span class="kt">Expr</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Expr</span> <span class="nf">a</span><span class="p">)</span></code></pre></div><p>现在就可以写一个pretty print了：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">pretty</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">pretty</span> <span class="ow">=</span> <span class="nf">go</span> <span class="mi">0</span> <span class="kr">where</span>
  <span class="nf">go</span> <span class="nf">ident</span> <span class="p">(</span><span class="kt">Hole</span> <span class="nf">var</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">var</span>
  <span class="nf">go</span> <span class="nf">ident</span> <span class="p">(</span><span class="kt">Lam</span> <span class="nf">f</span><span class="p">)</span>    <span class="ow">=</span> 
    <span class="kr">let</span> <span class="nf">var</span> <span class="ow">=</span> <span class="sc">&#39;x&#39;</span><span class="kt">:</span><span class="nf">show</span> <span class="nf">ident</span> <span class="kr">in</span> 
    <span class="s">&#34;(lam &#34;</span> <span class="o">++</span> <span class="nf">var</span> <span class="o">++</span> <span class="s">&#34;. &#34;</span> <span class="o">++</span> <span class="nf">go</span> <span class="p">(</span><span class="nf">succ</span> <span class="nf">ident</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="kt">Hole</span> <span class="nf">var</span><span class="p">))</span> <span class="o">++</span> <span class="s">&#34;)&#34;</span>
  <span class="nf">go</span> <span class="nf">ident</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>  <span class="ow">=</span> <span class="s">&#34;(&#34;</span> <span class="o">++</span> <span class="nf">go</span> <span class="nf">ident</span> <span class="nf">f</span> <span class="o">++</span> <span class="s">&#34; &#34;</span> <span class="o">++</span>  <span class="nf">go</span> <span class="nf">ident</span> <span class="nf">x</span> <span class="o">++</span> <span class="s">&#34;)&#34;</span></code></pre></div><p>但就算是这样，HOAS的性质还是极差的（顺便还有PHOAS这样的改版，连evaluator都写不顺）：</p><ul><li>无法实现Functor, Travesable, Foldable等typeclass，更不要说Monad了</li><li>在有dt的语言里，HOAS过不了strictly positive check(Agda, Coq)，也过不了total check。</li></ul><p>所以一般只把HOAS用临时要求值的情况下，比如dt的type checker里可以用到，<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Normalisation_by_evaluation" class=" wrap external" target="_blank" rel="nofollow noreferrer">HOAS可以拿到normal form</a>。</p><h2>De Bruijn Indices</h2><p>在LC(lambda calculus)中，这是一种用索引来指代变量的表示法：</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-8f4a16126b728854fcea13ba95b71a74_b.jpg" data-size="normal" data-rawwidth="208" data-rawheight="61" class="content_image" width="208"/></noscript><img src="https://pic1.zhimg.com/v2-8f4a16126b728854fcea13ba95b71a74_b.jpg" data-size="normal" data-rawwidth="208" data-rawheight="61" class="content_image lazy" width="208" data-actualsrc="https://pic1.zhimg.com/v2-8f4a16126b728854fcea13ba95b71a74_b.jpg"/><figcaption>λx. (λy. y (λz. z)) (λy. x y)</figcaption></figure><p class="ztext-empty-paragraph"><br/></p><p>代表一个变量的索引 为 距离 该变量所定义的 作用域之间 的距离（之间嵌套了多少个作用域），比如：</p><ul><li><code>λx. x</code>就是<code>λ 1</code></li><li><code>λx. λy. λz. x z (y z)</code>就是<code>λ λ λ 3 1 (2 1)</code></li></ul><p>这种表示法不仅干掉了α-conversion，还干掉了shadow和capture，处理起来会方便不少（疑似）。当然，这种表示法不单单可以用在LC上，在所有有“变量”/“作用域”的语言中都可以用这样一种方式来表示变量。</p><p>（其实用索引代表变量是一个很常见的操作）（对了 除了dbi，还有co-dbi）</p><p>将DBI应用在AST上，我们将变量区分为“绑定”/“自由”变量：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Expr</span>
  <span class="ow">=</span> <span class="kt">FV</span> <span class="kt">String</span>
  <span class="o">|</span> <span class="kt">BV</span> <span class="o">!</span><span class="kt">Int</span>
  <span class="o">|</span> <span class="kt">Lam</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">App</span> <span class="kt">Expr</span> <span class="kt">Expr</span></code></pre></div><p>稍微抽象一下：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">Scope</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="kt">Show</span><span class="p">,</span><span class="kt">Read</span><span class="p">,</span><span class="kt">Functor</span><span class="p">,</span><span class="kt">Foldable</span><span class="p">,</span><span class="kt">Traversable</span><span class="p">)</span>
<span class="c1">-- 表示有一个Bound Var的作用域</span>
<span class="kr">data</span> <span class="kt">Expr</span> <span class="nf">a</span> 
  <span class="ow">=</span> <span class="kt">FV</span> <span class="nf">a</span> <span class="c1">-- 自由变量不一定用String表示</span>
  <span class="o">|</span> <span class="kt">BV</span> <span class="o">!</span><span class="kt">Int</span>
  <span class="o">|</span> <span class="kt">App</span> <span class="p">(</span><span class="kt">Exp</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Exp</span> <span class="nf">a</span><span class="p">)</span>
  <span class="o">|</span> <span class="kt">Lam</span> <span class="p">(</span><span class="kt">Scope</span> <span class="kt">Exp</span> <span class="nf">a</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="kt">Show</span><span class="p">,</span><span class="kt">Read</span><span class="p">,</span><span class="kt">Functor</span><span class="p">,</span><span class="kt">Foldable</span><span class="p">,</span><span class="kt">Traversable</span><span class="p">)</span></code></pre></div><p>顺便定义两个组合子，一个用于将自由变量提出，一个用于替换：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">abstract</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span> <span class="kt">Expr</span> <span class="nf">a</span>
<span class="nf">abstract</span> <span class="nf">var</span> <span class="nf">expr</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="p">(</span><span class="nf">go</span> <span class="mi">0</span> <span class="nf">expr</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">FV</span> <span class="nf">fv</span><span class="p">)</span> <span class="o">|</span> <span class="nf">fv</span> <span class="o">==</span> <span class="nf">var</span> <span class="ow">=</span> <span class="kt">BV</span> <span class="nf">dbi</span>
                 <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="kt">FV</span> <span class="nf">fv</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">BV</span> <span class="nf">bv</span><span class="p">)</span>             <span class="ow">=</span> <span class="kt">BV</span> <span class="nf">bv</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>           <span class="ow">=</span> <span class="nf">go</span> <span class="nf">dbi</span> <span class="nf">f</span> <span class="p">`</span><span class="kt">App</span><span class="p">`</span> <span class="nf">go</span> <span class="nf">dbi</span> <span class="nf">x</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">Lam</span> <span class="p">(</span><span class="kt">Scope</span> <span class="nf">body</span><span class="p">))</span>  <span class="ow">=</span> <span class="kt">Lam</span> <span class="o">$</span> <span class="kt">Scope</span> <span class="o">$</span> <span class="nf">go</span> <span class="p">(</span><span class="nf">succ</span> <span class="nf">dbi</span><span class="p">)</span> <span class="nf">body</span>

<span class="nf">instantiate</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span>
<span class="nf">instantiate</span> <span class="nf">val</span> <span class="p">(</span><span class="kt">Scope</span> <span class="nf">body</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">go</span> <span class="mi">0</span> <span class="nf">body</span> <span class="kr">where</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">BV</span> <span class="nf">bv</span><span class="p">)</span> <span class="o">|</span> <span class="nf">dbi</span> <span class="o">==</span> <span class="nf">bv</span> <span class="ow">=</span> <span class="nf">val</span>
                 <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="kt">BV</span> <span class="nf">bv</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">FV</span> <span class="nf">fv</span><span class="p">)</span>             <span class="ow">=</span> <span class="kt">FV</span> <span class="nf">fv</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>           <span class="ow">=</span> <span class="nf">go</span> <span class="nf">dbi</span> <span class="nf">f</span> <span class="p">`</span><span class="kt">App</span><span class="p">`</span> <span class="nf">go</span> <span class="nf">dbi</span> <span class="nf">x</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">Lam</span> <span class="p">(</span><span class="kt">Scope</span> <span class="nf">body</span><span class="p">))</span>  <span class="ow">=</span> <span class="kt">Lam</span> <span class="o">$</span> <span class="kt">Scope</span> <span class="o">$</span> <span class="nf">go</span> <span class="p">(</span><span class="nf">succ</span> <span class="nf">dbi</span><span class="p">)</span> <span class="nf">body</span></code></pre></div><p>比如可以用来定义一些smart constructor和evaluator：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">var</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span>
<span class="nf">var</span> <span class="ow">=</span> <span class="kt">FV</span>

<span class="kr">infixl</span> <span class="mi">9</span> <span class="o">@@</span>
<span class="p">(</span><span class="o">@@</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span>
<span class="p">(</span><span class="o">@@</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">App</span>

<span class="nf">lam</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span>
<span class="nf">lam</span> <span class="nf">var</span> <span class="ow">=</span> <span class="kt">Lam</span> <span class="o">.</span> <span class="nf">abstract</span> <span class="nf">var</span>

<span class="nf">whnf</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span>
<span class="nf">whnf</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="nf">whnf</span> <span class="nf">f</span> <span class="kr">of</span>
  <span class="kt">Lam</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">whnf</span> <span class="p">(</span><span class="nf">instantiate</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">)</span>
  <span class="nf">f&#39;</span>    <span class="ow">-&gt;</span> <span class="kt">App</span> <span class="nf">f&#39;</span> <span class="nf">a</span>
<span class="nf">whnf</span> <span class="nf">e</span> <span class="ow">=</span> <span class="nf">e</span>

<span class="nf">nf</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span>
<span class="nf">nf</span> <span class="nf">fv</span><span class="o">@</span><span class="p">(</span><span class="kt">FV</span> <span class="kr">_</span><span class="p">)</span>   <span class="ow">=</span> <span class="nf">fv</span>
<span class="nf">nf</span> <span class="nf">bv</span><span class="o">@</span><span class="p">(</span><span class="kt">BV</span> <span class="kr">_</span><span class="p">)</span>   <span class="ow">=</span> <span class="nf">bv</span>
<span class="nf">nf</span> <span class="p">(</span><span class="kt">Lam</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Lam</span> <span class="o">$</span> <span class="kt">Scope</span> <span class="o">$</span> <span class="nf">nf</span> <span class="o">$</span> <span class="nf">unScope</span> <span class="nf">b</span>
<span class="nf">nf</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="nf">whnf</span> <span class="nf">f</span> <span class="kr">of</span>
  <span class="kt">Lam</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">eval</span> <span class="p">(</span><span class="nf">instantiate</span> <span class="nf">x</span> <span class="nf">b</span><span class="p">)</span>
  <span class="nf">f&#39;</span> <span class="ow">-&gt;</span> <span class="kt">App</span> <span class="p">(</span><span class="nf">nf</span> <span class="nf">f&#39;</span><span class="p">)</span> <span class="p">(</span><span class="nf">nf</span> <span class="nf">x</span><span class="p">)</span></code></pre></div><p>现在这个AST可以看做一个放着FV的容器，并实现了Functor，Foldable，Traversable（甚至可以实现Monad），可以通过一些通用的函数对AST进行操作，比如说判定一颗语法树对应的项是否是闭项：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">isClosed</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isClosed</span> <span class="ow">=</span> <span class="nf">all</span> <span class="p">(</span><span class="nf">const</span> <span class="kt">False</span><span class="p">)</span>

<span class="nf">isClosed</span> <span class="p">(</span><span class="nf">lam</span> <span class="s">&#34;x&#34;</span> <span class="p">(</span><span class="nf">var</span> <span class="s">&#34;x&#34;</span><span class="p">))</span> <span class="c1">-- True</span>
<span class="nf">isClosed</span> <span class="p">(</span><span class="nf">lam</span> <span class="s">&#34;x&#34;</span> <span class="p">(</span><span class="nf">var</span> <span class="s">&#34;y&#34;</span><span class="p">))</span> <span class="c1">-- False</span></code></pre></div><p>DBI是一个很好的让变量带上作用域信息的方案，但是就上面定义的AST的定义来说还不够安全，还无法禁止构造像<code>Lam (BV 2)</code>这样的不合法项。</p><h2>DBI in dependent type</h2><p>如果在有dependent type的语言下，上面的问题就很好解决了，只需要限制DBI在每个项的大小就好：</p><div class="highlight"><pre><code class="language-haskell"><span class="kt">Index</span> <span class="kt">:</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
<span class="kt">Index</span> <span class="ow">=</span> <span class="kt">Fin</span>

<span class="c1">-- 新的作用域 变量的索引可以加一</span>
<span class="kt">Scope</span> <span class="kt">:</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
<span class="kt">Scope</span> <span class="nf">n</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">n</span><span class="p">)</span> <span class="nf">a</span>
<span class="c1">-- 是否可以实现 Monad (Scope n f)?</span>

<span class="kr">infixl</span> <span class="mi">9</span> <span class="kt">:@</span>
<span class="kr">data</span> <span class="kt">Expr</span> <span class="kt">:</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="kt">FV</span> <span class="kt">:</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span>
  <span class="c1">-- Bound Variable, 限制index小于n</span>
  <span class="kt">BV</span> <span class="kt">:</span> <span class="kt">Index</span> <span class="nf">n</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span>
  <span class="kt">Lam</span> <span class="kt">:</span> <span class="kt">Scope</span> <span class="nf">n</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span>
  <span class="p">(</span><span class="kt">:@</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span>

<span class="c1">-- 闭项</span>
<span class="kt">Closed</span> <span class="kt">:</span> <span class="kt">Type</span>
<span class="kt">Closed</span> <span class="ow">=</span> <span class="kt">Expr</span> <span class="mi">0</span> <span class="kt">Void</span>

<span class="c1">-- demo</span>
<span class="nf">demo1</span> <span class="kt">:</span> <span class="kt">Expr</span> <span class="mi">0</span> <span class="kt">String</span>
<span class="nf">demo1</span> <span class="ow">=</span> <span class="kt">Lam</span> <span class="o">$</span> <span class="kt">Lam</span> <span class="o">$</span> <span class="kt">BV</span> <span class="mi">1</span> <span class="kt">:@</span> <span class="kt">BV</span> <span class="mi">0</span> <span class="kt">:@</span> <span class="kt">FV</span> <span class="s">&#34;z&#34;</span>

<span class="nf">demo2</span> <span class="kt">:</span> <span class="kt">Closed</span>
<span class="nf">demo2</span> <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="kt">BV</span> <span class="mi">0</span><span class="p">)</span>

<span class="nf">demo3</span> <span class="kt">:</span> <span class="kt">Expr</span> <span class="mi">1</span> <span class="kt">Void</span>
<span class="nf">demo3</span> <span class="ow">=</span> <span class="kt">BV</span> <span class="mi">0</span></code></pre></div><p>加上那两个重要的组合子，但这里需要点证明：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">weakenDBI</span> <span class="kt">:</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">n</span><span class="p">)</span> <span class="nf">a</span>
<span class="nf">weakenDBI</span> <span class="p">(</span><span class="kt">FV</span> <span class="nf">fv</span><span class="p">)</span>     <span class="ow">=</span> <span class="kt">FV</span> <span class="nf">fv</span>
<span class="nf">weakenDBI</span> <span class="p">(</span><span class="kt">BV</span> <span class="nf">dbi</span><span class="p">)</span>    <span class="ow">=</span> <span class="kt">BV</span> <span class="p">(</span><span class="nf">weaken</span> <span class="nf">dbi</span><span class="p">)</span>
<span class="nf">weakenDBI</span> <span class="p">(</span><span class="kt">Lam</span> <span class="nf">body</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">weakenDBI</span> <span class="nf">body</span><span class="p">)</span>
<span class="nf">weakenDBI</span> <span class="p">(</span><span class="nf">f</span> <span class="kt">:@</span> <span class="nf">x</span><span class="p">)</span>    <span class="ow">=</span> <span class="nf">weakenDBI</span> <span class="nf">f</span> <span class="kt">:@</span> <span class="nf">weakenDBI</span> <span class="nf">x</span>

<span class="nf">abstract</span> <span class="kt">:</span> <span class="kt">Eq</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span> <span class="nf">n</span> <span class="kt">Expr</span> <span class="nf">a</span>
<span class="nf">abstract</span> <span class="nf">var</span> <span class="nf">expr</span> <span class="ow">=</span> <span class="nf">go</span> <span class="mi">0</span> <span class="nf">expr</span> <span class="kr">where</span>
  <span class="nf">go</span> <span class="kt">:</span> <span class="kt">Fin</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">n</span><span class="p">)</span> <span class="nf">a</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">FV</span> <span class="nf">fv</span><span class="p">)</span> <span class="nf">with</span> <span class="p">(</span><span class="nf">fv</span> <span class="o">==</span> <span class="nf">var</span><span class="p">)</span>
                  <span class="o">|</span> <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">BV</span> <span class="nf">dbi</span>
                  <span class="o">|</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">FV</span> <span class="nf">fv</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">BV</span> <span class="nf">bv</span><span class="p">)</span>            <span class="ow">=</span> <span class="kt">BV</span> <span class="p">(</span><span class="nf">weaken</span> <span class="nf">bv</span><span class="p">)</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="nf">f</span> <span class="kt">:@</span> <span class="nf">x</span><span class="p">)</span>           <span class="ow">=</span> <span class="nf">go</span> <span class="nf">dbi</span> <span class="nf">f</span> <span class="kt">:@</span> <span class="nf">go</span> <span class="nf">dbi</span> <span class="nf">x</span>
  <span class="nf">go</span> <span class="nf">dbi</span> <span class="p">(</span><span class="kt">Lam</span> <span class="nf">body</span><span class="p">)</span>         <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="kt">FS</span> <span class="nf">dbi</span><span class="p">)</span> <span class="nf">body</span><span class="p">)</span>

<span class="nf">instantiate</span> <span class="kt">:</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span> <span class="nf">n</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">n</span> <span class="nf">a</span>
<span class="nf">instantiate</span> <span class="nf">val</span> <span class="p">(</span><span class="kt">BV</span> <span class="nf">bv</span><span class="p">)</span> <span class="nf">with</span> <span class="p">(</span><span class="nf">last</span> <span class="p">`</span><span class="nf">decEq</span><span class="p">`</span> <span class="nf">bv</span><span class="p">)</span>
                        <span class="o">|</span> <span class="p">(</span><span class="kt">Yes</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">val</span>
                        <span class="o">|</span> <span class="p">(</span><span class="kt">No</span> <span class="nf">cf</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">BV</span> <span class="p">(</span><span class="nf">believe_me</span> <span class="nf">bv</span><span class="p">)</span> 
                        <span class="c1">-- 抱歉，我偷懒了</span>
<span class="nf">instantiate</span> <span class="nf">val</span> <span class="p">(</span><span class="kt">FV</span> <span class="nf">fv</span><span class="p">)</span>           <span class="ow">=</span> <span class="kt">FV</span> <span class="nf">fv</span>
<span class="nf">instantiate</span> <span class="nf">val</span> <span class="p">(</span><span class="nf">f</span> <span class="kt">:@</span> <span class="nf">x</span><span class="p">)</span>          <span class="ow">=</span> <span class="nf">instantiate</span> <span class="nf">val</span> <span class="nf">f</span> <span class="kt">:@</span> <span class="nf">instantiate</span> <span class="nf">val</span> <span class="nf">x</span>
<span class="nf">instantiate</span> <span class="nf">val</span> <span class="p">(</span><span class="kt">Lam</span> <span class="nf">body</span><span class="p">)</span>        <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">instantiate</span> <span class="p">(</span><span class="nf">weakenDBI</span> <span class="nf">val</span><span class="p">)</span> <span class="nf">body</span><span class="p">)</span></code></pre></div><p>这是一种简单直接的方法，非要说缺点的话，就是有dt的语言实在是太少了。不过用上了dt，限制也会很大，这里就很难进一步抽象，abstract和instantiate就只能依赖于Expr了。</p><p>一个类型index上一个值之后，就很难实现其它的typeclass了。</p><h2>DBI as a nested datatype</h2><p>有些dt是可以编码进数据结构里的：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Vec</span> <span class="kt">:</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
  <span class="kt">Nil</span>  <span class="kt">:</span> <span class="kt">Vec</span> <span class="kt">Z</span> <span class="nf">a</span>
  <span class="p">(</span><span class="ow">::</span><span class="p">)</span> <span class="kt">:</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="nf">n</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">n</span><span class="p">)</span> <span class="nf">a</span></code></pre></div><p>可以编码为：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">S</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">S</span> <span class="nf">a</span> <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Functor</span><span class="p">,</span> <span class="kt">Foldable</span><span class="p">,</span> <span class="kt">Traversable</span><span class="p">)</span>
<span class="kr">infixr</span> <span class="kt">:-</span>
<span class="kr">data</span> <span class="kt">Vec</span> <span class="nf">a</span> <span class="kr">where</span> 
  <span class="kt">Nil</span>  <span class="ow">::</span> <span class="kt">Vec</span> <span class="nf">a</span>
  <span class="p">(</span><span class="kt">:-</span><span class="p">)</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">a</span><span class="p">)</span>

<span class="c1">-- 长度为3的vec</span>
<span class="nf">vec</span> <span class="ow">::</span> <span class="kt">Vec</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Int</span><span class="p">)))</span>
<span class="nf">vec</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">S</span> <span class="o">.</span> <span class="kt">S</span><span class="p">)</span> <span class="mi">1</span> <span class="kt">:-</span> <span class="kt">S</span> <span class="mi">2</span> <span class="kt">:-</span> <span class="mi">3</span> <span class="kt">:-</span> <span class="kt">Nil</span></code></pre></div><p>当然，下面这种要麻烦得多，且一些关于长度的性质会很难表达（要上TypeFamilies，DataKinds等等扩展）。但是用于限制长度来说，这种足够了。</p><p>可以受此启发，dbi也可以编码到结构中：</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- Nothing             =&gt; 0</span>
<span class="c1">-- Just Nothing        =&gt; 1</span>
<span class="c1">-- Just (Just Nothing) =&gt; 2</span>
<span class="c1">-- Just (Just (Just a)) =&gt; Free var</span>
<span class="c1">-- :: Maybe (Maybe (Maybe a)) -- &lt; 3</span>

<span class="kr">data</span> <span class="kt">Expr</span> <span class="nf">a</span>
  <span class="ow">=</span> <span class="kt">Var</span> <span class="nf">a</span>
  <span class="o">|</span> <span class="kt">Lam</span> <span class="p">(</span><span class="kt">Expr</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="nf">a</span><span class="p">))</span>
  <span class="o">|</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="kt">:@</span> <span class="kt">Expr</span> <span class="nf">a</span>
  <span class="kr">deriving</span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Functor</span><span class="p">,</span> <span class="kt">Foldable</span><span class="p">,</span> <span class="kt">Traversable</span><span class="p">)</span>
<span class="kr">infixl</span> <span class="mi">9</span> <span class="kt">:@</span>

<span class="c1">-- λx.λy.x</span>
<span class="c1">-- Lam (Lam (BV 1)) </span>
<span class="c1">-- Lam (Lam (Var (Just Nothing)))</span>

<span class="c1">-- λx.λy.x y z</span>
<span class="c1">-- Lam (Lam (BV 1 @@ BV 0 @@ FV &#34;z&#34;))</span>
<span class="c1">-- Lam (Lam (Var (Just Nothing) @@ Var Nothing @@ Var (Just (Just &#34;z&#34;))))</span>

<span class="c1">-- Lam _ </span>
<span class="c1">-- hole 的类型是 Expr (Maybe a)，能填Var Nothing，也就是BV 0</span>

<span class="c1">-- Lam (Lam _)</span>
<span class="c1">-- hole 的类型是 Expr (Maybe (Maybe a))</span>
<span class="c1">-- 能填Var (Just Nothing)，也就是BV 1</span>
<span class="c1">-- 或者填 Var Nothing，也就是BV 0</span></code></pre></div><p>（注：<code>forall a. Expr a</code>或者<code>Expr Void</code>是闭项）</p><p>像之前那样稍作抽象，将Scope拿出来：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">Scope</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="p">{</span> <span class="nf">unScope</span> <span class="ow">::</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="nf">a</span><span class="p">)</span> <span class="p">}</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">,</span> <span class="kt">Foldable</span><span class="p">,</span> <span class="kt">Traversable</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Scope</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
    <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="o">.</span> <span class="nf">return</span> <span class="o">.</span> <span class="kt">Just</span>
    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">ap</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Scope</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">return</span> <span class="ow">=</span> <span class="nf">pure</span>
  <span class="kt">Scope</span> <span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="o">$</span> <span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="nf">maybe</span> <span class="p">(</span><span class="nf">return</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="p">(</span><span class="nf">unScope</span> <span class="o">.</span> <span class="nf">f</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">MonadTrans</span> <span class="kt">Scope</span> <span class="kr">where</span>
  <span class="nf">lift</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="o">.</span> <span class="nf">liftM</span> <span class="kt">Just</span></code></pre></div><p>现在，那两个组合子也只需要依赖于Scope就可以了：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">abstract</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="nf">f</span><span class="p">,</span> <span class="kt">Eq</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span> <span class="nf">f</span> <span class="nf">a</span>
<span class="nf">abstract</span> <span class="nf">x</span> <span class="ow">=</span> <span class="kt">Scope</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="nf">go</span> <span class="kr">where</span>
  <span class="nf">go</span> <span class="nf">y</span> <span class="ow">=</span> <span class="nf">y</span> <span class="o">&lt;$</span> <span class="nf">guard</span> <span class="p">(</span><span class="nf">x</span> <span class="o">/=</span> <span class="nf">y</span><span class="p">)</span>

<span class="nf">instantiate</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Scope</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">a</span>
<span class="nf">instantiate</span> <span class="nf">x</span> <span class="p">(</span><span class="kt">Scope</span> <span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="nf">go</span> <span class="kr">where</span>
  <span class="nf">go</span> <span class="kt">Nothing</span>  <span class="ow">=</span> <span class="nf">x</span>
  <span class="nf">go</span> <span class="p">(</span><span class="kt">Just</span> <span class="nf">y</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">return</span> <span class="nf">y</span></code></pre></div><p>那么AST就可以这样定义了：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Expr</span> <span class="nf">a</span>
  <span class="ow">=</span> <span class="kt">Var</span> <span class="nf">a</span>
  <span class="o">|</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="kt">:@</span> <span class="kt">Expr</span> <span class="nf">a</span>
  <span class="o">|</span> <span class="kt">Lam</span> <span class="p">(</span><span class="kt">Scope</span> <span class="kt">Expr</span> <span class="nf">a</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">,</span> <span class="kt">Foldable</span><span class="p">,</span> <span class="kt">Traversable</span><span class="p">)</span>
<span class="kr">infixl</span> <span class="mi">9</span> <span class="kt">:@</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Expr</span> <span class="kr">where</span>
    <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">Var</span>
    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">ap</span>

<span class="c1">-- 这个monad可用来遍历Expr里的Free var</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Expr</span> <span class="kr">where</span>
  <span class="nf">return</span> <span class="ow">=</span> <span class="nf">pure</span>
  <span class="kt">Var</span> <span class="nf">a</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span>    <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="nf">l</span> <span class="kt">:@</span> <span class="nf">r</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span>   <span class="ow">=</span> <span class="p">(</span><span class="nf">l</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span><span class="p">)</span> <span class="kt">:@</span> <span class="p">(</span><span class="nf">r</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span><span class="p">)</span>
  <span class="kt">Lam</span> <span class="nf">body</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Lam</span> <span class="p">(</span><span class="nf">body</span> <span class="o">&gt;&gt;=</span> <span class="nf">lift</span> <span class="o">.</span> <span class="nf">f</span><span class="p">)</span>

<span class="c1">-- smart constructor</span>
<span class="nf">lam</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span>
<span class="nf">lam</span> <span class="nf">v</span> <span class="ow">=</span> <span class="kt">Lam</span> <span class="o">.</span> <span class="nf">abstract</span> <span class="nf">v</span> 

<span class="nf">var</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="nf">a</span>
<span class="nf">var</span> <span class="ow">=</span> <span class="kt">Var</span></code></pre></div><p>就很inductive，很abstract，很safe，很nice。（来自于<a href="https://link.zhihu.com/?target=http%3A//www.cs.ox.ac.uk/richard.bird/online/BirdPaterson99DeBruijn.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">paper</a>）</p><p>到目前为止，我们就得到了一个比较完整的在AST中表示“变量”/“作用域”的方案（并不）。haskell的<a href="https://link.zhihu.com/?target=http%3A//hackage.haskell.org/package/bound" class=" wrap external" target="_blank" rel="nofollow noreferrer">bound</a>包就有很完整的实现。</p><h2>Scope Check</h2><p>我们当然可以这样scope check：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="kt">Name</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">data</span> <span class="kt">Expr</span>
  <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">Name</span> 
  <span class="o">|</span> <span class="kt">App</span> <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">Lam</span> <span class="kt">Name</span> <span class="kt">Expr</span>

<span class="nf">isClosed</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isClosed</span> <span class="ow">=</span> <span class="nf">go</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="nf">go</span> <span class="nf">vs</span> <span class="p">(</span><span class="kt">Var</span> <span class="nf">v</span><span class="p">)</span>   <span class="ow">=</span> <span class="nf">v</span> <span class="p">`</span><span class="nf">elem</span><span class="p">`</span> <span class="nf">vs</span>
  <span class="nf">go</span> <span class="nf">vs</span> <span class="p">(</span><span class="kt">Lam</span> <span class="nf">v</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">go</span> <span class="p">(</span><span class="nf">v</span><span class="kt">:</span><span class="nf">vs</span><span class="p">)</span>  <span class="nf">b</span>
  <span class="nf">go</span> <span class="nf">vs</span> <span class="p">(</span><span class="kt">App</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">go</span> <span class="nf">vs</span> <span class="nf">f</span> <span class="o">&amp;&amp;</span> <span class="nf">go</span> <span class="nf">vs</span> <span class="nf">x</span></code></pre></div><p>但这样操作稍微low了一点。如果能将裸的AST转换为上面介绍的几种带Scope的AST，相当于“证明了”原表达式是个闭项，也就是过了scope check：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Expr</span> 
  <span class="ow">=</span> <span class="kt">VarE</span> <span class="kt">String</span>
  <span class="o">|</span> <span class="kt">AppE</span> <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">LamE</span> <span class="kt">String</span> <span class="kt">Expr</span>
  <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="nf">a</span>
  <span class="ow">=</span> <span class="kt">VarT</span> <span class="nf">a</span>
  <span class="o">|</span> <span class="kt">AppT</span> <span class="p">(</span><span class="kt">Term</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Term</span> <span class="nf">a</span><span class="p">)</span>
  <span class="o">|</span> <span class="kt">LamT</span> <span class="p">(</span><span class="kt">Scope</span> <span class="kt">Term</span> <span class="nf">a</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">,</span> <span class="kt">Foldable</span><span class="p">,</span> <span class="kt">Traversable</span><span class="p">)</span>

<span class="c1">-- 为原AST附加上scope信息，也相当于证明了原表达式是闭项</span>
<span class="nf">fromExpr</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Term</span> <span class="nf">a</span><span class="p">)</span>
<span class="nf">fromExpr</span> <span class="ow">=</span> <span class="nf">go</span> <span class="kt">HM</span><span class="o">.</span><span class="nf">empty</span> <span class="kr">where</span>
  <span class="nf">go</span> <span class="ow">::</span> <span class="kt">HM</span><span class="o">.</span><span class="kt">HashMap</span> <span class="kt">String</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Term</span> <span class="nf">a</span><span class="p">)</span>
  <span class="nf">go</span> <span class="nf">m</span> <span class="p">(</span><span class="kt">VarE</span> <span class="nf">v</span><span class="p">)</span>   <span class="ow">=</span> <span class="kt">VarT</span> <span class="o">&lt;$&gt;</span> <span class="kt">HM</span><span class="o">.</span><span class="nf">lookup</span> <span class="nf">v</span> <span class="nf">m</span>
  <span class="nf">go</span> <span class="nf">m</span> <span class="p">(</span><span class="kt">LamE</span> <span class="nf">v</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">LamT</span> <span class="o">&lt;$&gt;</span> <span class="kt">Scope</span> <span class="o">&lt;$&gt;</span> <span class="nf">go</span> <span class="p">(</span><span class="kt">HM</span><span class="o">.</span><span class="nf">insert</span> <span class="nf">v</span> <span class="kt">Nothing</span> <span class="o">$</span> <span class="nf">fmap</span> <span class="kt">Just</span> <span class="nf">m</span><span class="p">)</span> <span class="nf">b</span>
  <span class="nf">go</span> <span class="nf">m</span> <span class="p">(</span><span class="kt">AppE</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">AppT</span> <span class="o">&lt;$&gt;</span> <span class="nf">go</span> <span class="nf">m</span> <span class="nf">f</span> <span class="o">&lt;*&gt;</span> <span class="nf">go</span> <span class="nf">m</span> <span class="nf">x</span></code></pre></div><p>我们还可以进一步从dbi的AST的到HOAS。因为HOAS和dbi带有的信息是一致的，所以它们之间还能互转。这里留作习题。</p><p>当一个AST过了scope check之后，就可以着手type check了，接下来的事情也是十分有趣的，先给自己挖个坑，再写一篇AST with Type。</p><p>有一个很有意思的<a href="https://link.zhihu.com/?target=https%3A//github.com/AndrasKovacs/elaboration-zoo" class=" wrap external" target="_blank" rel="nofollow noreferrer">项目</a>，讲的是dt的type check和elaboration，有兴趣可以去看一下。</p>