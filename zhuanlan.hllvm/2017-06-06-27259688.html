<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Value type and Packaged Object for Java</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/27259688">原文</a></p>
<p>前段时间有人问了我下关于Java 中Value Type的概念，并转了我一篇王垠去年的一篇博客<a href="http://www.yinwang.org/blog-cn/2016/06/08/java-value-type" data-editable="true" data-title="Java 有值类型吗？">Java 有值类型吗？</a> </p><p>Java语言层面上并不能算是支持value type。Java有两种类型： primitive type and object type。前者如我们大家经常见到的 `int`  `float`，从JVM的角度上看，变量的数据是直接在JVM operand stack上面的。而后者，所有的对象则是从heap上申请，每个对象的field则是通过reference 来联系起来。</p><p>当然这篇博文主要不是针对王垠的博文(自己个人理解垠神在PL 的Type System方面的学识远远超过了本人)。这篇文章还是还是比较value type and packaged object. <br></p><h2><b>Value Type</b></h2><p>最早关于Java Value Type这个词的时候是先前有一次旁听Doug lea和某博士的关于Packaged object的讨论会，后来我的合作方给我稍微普及, 并给了IBM clear过的链接 <a href="http://openjdk.java.net/projects/valhalla/" data-title="Valhalla" class="" data-editable="true">Valhalla</a>(Open JDK experiment项目)以及他们最新的 <a href="http://cr.openjdk.java.net/%7Ejrose/values/shady-values.html" data-editable="true" data-title="Minimal Value Types" class="">Minimal Value Types</a>.　</p><p>Value Type的思想是关于Object Model。每个Java Object有一个Header(有的地方叫做Metadata)：包含lock-word, ptr, 等信息。通过lock-word 可以实现object synchronization (e.g., lock-word)，而　ptr可以获取object相应的相Class信息。Value Type的目标是Headerless that is no more header( or no identify ) for an object on the heap. The benefits would be on GC, memory usage, potential cache locality (Refer Valhalla home for more). </p><p>当然，任何的好处都不是没有代价的。Because of no header and identify, it would be problem to call methods of a value type object: hashcode, getClass, wait, notify. Another problem is about the object synchronization, which strongly depends on marker bit of an object's header that is no longer available. </p><p>对于普通的开发人员来讲，value type的出炉需要保持对原有Java应用的支持，数据模型的变更应该对使用者是透明的。<br></p><h2><b>Packaged Object</b></h2><p>Packaged Object is an experimental enhancement for J9 JVM to improve serialization, Java object I/O cross on-heap and off-heap (native memory), and object layout alignment. In the packaged object data model, data are organized in a multi-tier manner (like the nested C structs), in which the object’s data is nested in its enclosing Packed Object instead of being pointed to by an object reference as in the traditional Java object data model.  </p><p>This project stopped at 2014(?). The main disclosure document is Marcel Mitran's ``IBM Java PackedObjects: An Overview`` (You get get it via google), and some publications  about synchronization from IBM CAS. My post will only based on these document. </p><p>The packaged object's goals：</p><ul><li>Remove object metadata. This point is similar to the Value Type. <br></li><li>Off-head and on-head serialization. As what is shown at marcel's slides，the copy and serialization can be avoided avoided by using a packaged header at on-heap to reference the packaged object at off-heap directly. </li><li>... <br></li></ul><p>Because the header(the lock-word) is removed, the existing Java synchronization does not work for packaged object directly. Developer has to achieve the thread-safe via: </p><ul><li>在packaged object上一层使用java 已有的lock机制。　</li><li>Concurrent Multi-way tree 以及其衍生的方法。这个方法主要是IBM CAS中的Dr Bing Yang提出来实现的，大概意思是将根据multi-tier PackedObject data structure来构建一个multiple-way tree, 在读写 packaged data 的时候通过操作(Search, add, remove)这个multiple-way tree来实现同步。具体的方式可以参考下CASCON 2016 best paper: Bing Yang: <b>A concurrent multiway tree using the lazy locking mechanism. <br></b></li></ul><p>本来这篇博文还安排了一部分关于GraphJIT, a jit bytecode compiler that simplify graph structure. GraphJIT 也能达到类似Packaged object和value type的部分效果。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
