<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>反射型DLL注入工具-sRDI</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/96484140">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-241f58bad8b2b3d68da48e35e921a461_b.jpg" alt=""></div><h2>反射型DLL注入💉</h2><p><b>DLL 注入</b></p><p>首先，我们需要了解什么是反射型DLL注入。</p><blockquote>DLL 注入<br/>就是将 DLL（动态链接库，是一个包含可由多个程序，同时使用的代码和数据的库。例如，在 Windows 操作系统中，Comdlg32.dll 执行与对话框有关的常见函数。）放进某个进程的地址空间里，让它成为那个进程的一部分。要实现 DLL 注入，首先需要打开目标进程。</blockquote><p>DLL 注入也被很多合法软件广泛的使用，但恶意软件通常采用 DLL 注入在另一进程的存储空间内伪装其操作。DLL 注入是一个过程，该过程使另一个正在运行的进程加载并执行注入者的任何代码。看上去相当的危险，但它也有很多合法用途。例如，没有它，debug 调试器就不能运行。</p><figure data-size="small"><noscript><img src="https://pic3.zhimg.com/v2-f59f2948668591193efd91837a2c76c2_b.jpg" data-caption="" data-size="small" data-rawwidth="817" data-rawheight="1057" class="origin_image zh-lightbox-thumb" width="817" data-original="https://pic3.zhimg.com/v2-f59f2948668591193efd91837a2c76c2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-f59f2948668591193efd91837a2c76c2_b.jpg" data-caption="" data-size="small" data-rawwidth="817" data-rawheight="1057" class="origin_image zh-lightbox-thumb lazy" width="817" data-original="https://pic3.zhimg.com/v2-f59f2948668591193efd91837a2c76c2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-f59f2948668591193efd91837a2c76c2_b.jpg"/></figure><p>实现 DLL 注入可参考：<a href="https://link.zhihu.com/?target=http%3A//blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">blog.opensecurityresearch.com</span><span class="invisible">/2013/01/windows-dll-injection-basics.html</span><span class="ellipsis"></span></a></p><p><b>反射型 DLL 注入</b></p><p>反射DLL注入用于将DLL加载到进程中，而不必将其放置在主机的文件系统上。</p><p>反射 DLL 注入的过程如下：</p><ol><li>使用 RWX 权限打开目标进程，并为 DLL 分配足够大的内存。</li><li>将 DLL 复制到分配的内存空间中。</li><li>计算 DLL 中用于执行反射加载的导出的内存偏移量。</li><li>使用反射性加载器函数的偏移地址作为入口，调用 CreateRemoteThread（或等效的未公开的 API 函数，如 RtlCreateUserThread）开始在远程进程中执行。</li><li>反射式加载器功能使用适当的 CPU 寄存器查找目标进程的进程环境块（PEB），并使用该寄存器在内存 kernel32.dll 和任何其他所需库中查找地址。</li><li>解析的 KERNEL32 出口目录中找到所需的 API 功能，如内存地址 LoadLibraryA，GetProcAddress和VirtualAlloc。</li><li>然后使用这些函数将 DLL（自身）正确加载到内存中，并调用其入口点 DllMain。</li></ol><p>这一过程比较复杂，值得深思。</p><blockquote>反射型 DLL 注入：<a href="https://link.zhihu.com/?target=https%3A//github.com/stephenfewer/ReflectiveDLLInjection" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/stephenfewer</span><span class="invisible">/ReflectiveDLLInjection</span><span class="ellipsis"></span></a></blockquote><p>反射型 DLL 注入的假设是，调用 DLL 的入口点足以执行 DLL 的全部功能。但是，往往并非如此。Microsoft 建议开发人员尽量减少在 DllMain 中的工作量，并进行“延迟初始化”，避免加载其他库或创建新线程。然后，主要入口点位于另一个函数中，该函数在 DLL 加载后将单独调用。</p><p>有人提出一种更强大的 DLL 注入技术，该技术试图遵循 Microsoft 概述的 DLL 最佳实践。它通过向目标进程动态写入一些引导程序 Shellcode 来实现此目的，该进程将加载 DLL（使用LoadLibraryA），然后查找并调用另一个导出的入口点函数（使用 GetProcAddress）。尽管这是对传统 DLL 注入的重大改进，但不是反射型的。</p><p>因此，将这一技术进行改进，来实现更完美的反射型 DLL 注入。</p><blockquote>来源：<a href="https://link.zhihu.com/?target=https%3A//disman.tl/2015/01/30/an-improved-reflective-dll-injection-technique.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">disman.tl/2015/01/30/an</span><span class="invisible">-improved-reflective-dll-injection-technique.html</span><span class="ellipsis"></span></a></blockquote><p><b>怎样实现反射型 DLL 注入？</b></p><p>其基本过程如下：</p><ol><li>打开目标进程并分配内存。</li><li>将 DLL 复制到分配的内存中。</li><li>将入口点函数名称的哈希值和该函数的所有参数复制到 DLL 之后的内存空间中。</li><li>复制一些引导程序的 shellcode，该 shellcode 调用带有指向在第3步中复制的数据的指针的修改的反射式加载器。</li><li>使用 shellcode 开头的地址作为入口点，在目标进程中创建一个远程线程。</li></ol><p>需要引导程序 Shellcode 的原因是由于我们能够使用 Stephen Fewer 的原始反射 DLL 注入技术传递给反射加载器的数据量有限。</p><p>CreateRemoteThread 具有以下声明：</p><div class="highlight"><pre><code class="language-text">HANDLE WINAPI CreateRemoteThread(
  _In_   HANDLE hProcess,
  _In_   LPSECURITY_ATTRIBUTES lpThreadAttributes,
  _In_   SIZE_T dwStackSize,
  _In_   LPTHREAD_START_ROUTINE lpStartAddress,
  _In_   LPVOID lpParameter,
  _In_   DWORD dwCreationFlags,
  _Out_  LPDWORD lpThreadId
);</code></pre></div><p>其中 LPTHREAD_START_ROUTINE lpStartAddress 是所创建的线程的执行入口点。该函数的原型为：</p><div class="highlight"><pre><code class="language-text">typedef DWORD (__stdcall *LPTHREAD_START_ROUTINE) (
[in] LPVOID lpThreadParameter
);</code></pre></div><p>如上，这仅需要一个 LPVOID 参数。反射型 DLL 注入技术将反射型加载器的地址 CreateRemoteThread 作为 lpStartAddress 参数传递，因此它只能传递单个 void 指针。这将有利于反射型加载器仅调用 DllMain，而后者将 void 指针作为其 lpvReserved 参数。</p><p>但是，如果我们希望反射型加载器在加载 DLL 之后调用其他导出，则需要为其提供更多信息！我们将通过使用一些引导程序 Shellcode 将其他参数传递给反射型加载器函数来实现。因此反射型加载器函数将声明：</p><div class="highlight"><pre><code class="language-text">DWORD WINAPI ReflectiveLoader( LPVOID lpParameter, LPVOID lpLibraryAddress, DWORD dwFunctionHash, LPVOID lpUserData, DWORD nUserdataLen );</code></pre></div><p>在这里的 dwFunctionHash 是要调用的导出函数名称的哈希值，lpUserData 是一堆数据（大小为nUserdataLen），当反射加载程序调用导出函数时，我们将其传递给该函数。</p><p>下面，我们不仅要在 DLL 的远程进程中分配内存，我们还要包括用于 shellcode（64字节就足够了）和一定的数据空间：</p><div class="highlight"><pre><code class="language-text">DWORD nBufferSize = dwLength // size of the DLL
    + nUserdataLen
    + 64; // shellcode buffer

// alloc memory (RWX) in the host process for the image...
lpRemoteLibraryBuffer = VirtualAllocEx(hProcess, NULL, nBufferSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
if (!lpRemoteLibraryBuffer)
    break;
printf(&#34;Allocated memory address in remote process: 0x%p\n&#34;, lpRemoteLibraryBuffer);

// write the image into the host process...
if (!WriteProcessMemory(hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, NULL))
    break;

ULONG_PTR uiReflectiveLoaderAddr = (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset;

// write our userdata blob into the host process
ULONG_PTR userdataAddr = (ULONG_PTR)lpRemoteLibraryBuffer + dwLength;
if (!WriteProcessMemory(hProcess, (LPVOID)userdataAddr, lpUserdata, nUserdataLen, NULL))
    break;

ULONG_PTR uiShellcodeAddr = userdataAddr + nUserdataLen;</code></pre></div><p>Shellcode 将有两个目标：</p><ol><li>使用我们的附加参数调用反射型加载器函数</li><li>ExitThread() 进行适当的清理，以便我们可以从调用过程中获取线程的退出代码。</li></ol><p>首先，我们获得的内存地址 ExitThread，该内存地址对于每个进程都应该相同（因为大多数（几乎所有）进程都加载了 kernel32.dll）。</p><div class="highlight"><pre><code class="language-text">HMODULE kernel32 = LoadLibraryA(&#34;kernel32.dll&#34;); 
FARPROC exitthread = GetProcAddress(kernel32, &#34;ExitThread&#34;);</code></pre></div><p>接下来，我们将引导程序 Shellcode 写入缓冲区，然后将其写入分配的远程进程内存空间。shellcode 的 x86 版本很简单，因为我们只需要在调用反射加载程序之前以相反的顺序（按照__stdcall 调用约定）将参数推入堆栈即可，x64 shellcode 更为复杂，因为调用约定要求使用寄存器来传递参数。</p><p>最后，我们将 shellcode 写入远程进程，并创建一个使用 shellcode 地址作为入口点的远程线程：</p><div class="highlight"><pre><code class="language-text">// finally, write our shellcode into the host process
if (!WriteProcessMemory(hProcess, (LPVOID)uiShellcodeAddr, bootstrap, i, NULL))
    break;

// Make sure our changes are written right away
FlushInstructionCache(hProcess, lpRemoteLibraryBuffer, nBufferSize);

// create a remote thread in the host process to call the ReflectiveLoader!
hThread = CreateRemoteThread(hProcess, NULL, 1024 * 1024, (LPTHREAD_START_ROUTINE)uiShellcodeAddr, lpParameter, (DWORD)NULL, &amp;dwThreadId);</code></pre></div><p>反射型加载器功能本身与 Fewer 的原始版本相比没有太大变化，除了传递给它的附加参数以及随后在 DLL 中调用选择的导出的部分外。加载 DLL 之后，它将调用 DllMain（理想情况下为null），然后调用我们的导出。</p><p>下面就介绍今天的主角：</p><h2>sRDI✨（Shellcode反射DLL注入）</h2><p>它可以基于 Shellcode 实现反射型 DLL 注入，并且能够将 DLL 转换为独立的 Shellcode。</p><p>项目地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/monoxgas/sRDI" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/monoxgas/sRD</span><span class="invisible">I</span><span class="ellipsis"></span></a></p><p>如果我们不想接触磁盘，则需要某种注入技术。可以写一个反射型加载的 DLL，但是反射性 DLL 注入会留下可以检测到的内存伪像。</p><p>而 sRDI 可以把一个普通的 DLL 文件转换为一段不依赖任何位置的 Shellcode。</p><p>相对于标准 RDI，使用 sRDI 的一些优点：</p><ul><li>你可以转换任何 DLL为无位置依赖的 shellcode，并且可以使用标准的 shellcode 注入技术来使用它。</li><li>你的 DLL 中不需要写任何反射加载器代码，因为反射加载器是在 DLL 外部的 shellcode 中实现的。</li><li>合理使用权限，没有大量的 RWX 权限数据。</li><li>还可以根据选项，抹掉 PE 头特征。 </li></ul><h2>组成简介🎨</h2><p>sRDI 的所有功能基于以下两个组件：</p><ol><li>一个C语言项目，可将 PE Loader 编译为 Shellcode</li><li>转换代码负责将 DLL、RDI 和用户数据进行绑定</li></ol><p>由以下元素组成：</p><ul><li><b>ShellcodeRDI：</b>编译 DLL 加载器的 Shellcode</li><li><b>NativeLoader：</b>需要时，将 DLL 转换为 shellcode，然后注入内存</li><li><b>DotNetLoader：</b>NativeLoader 的 C＃ 实现</li><li><b>Python \ ConvertToShellcode.py：</b>将 DLL 转换为 shellcode</li><li><b>Python \ EncodeBlobs.py：</b>对已编译的 sRDI 进行编码，进行静态嵌入</li><li><b>PowerShell \ ConvertTo-Shellcode.ps1：</b>将 DLL 转换为 shellcode</li><li><b>FunctionTest：</b>导入 sRDI 的 C 函数，进行调试测试</li><li><b>TestDLL：</b>示例DLL，包括两个导出函数，用于后续的加载和调用</li></ul><blockquote><b>DLL 不需要使用 RDI 进行编译，但是该技术具有交叉兼容性。</b></blockquote><h2><b>优势💎</b></h2><p><b>＃1 – 隐秘的持久性</b></p><ul><li>使用服务器端 Python 代码（sRDI）将 RAT 转换为 shellcode</li><li>将 shellcode 写入注册表</li><li>设置计划的任务以执行基本的加载程序 DLL</li><li>加载程序读取 shellcode 并注入（少于20行C代码）</li></ul><p><b>优点：</b> RAT 或加载器都不需要了解 RDI 或使用 RDI 进行编译。装载机可以保持小巧而简单，避免警告。</p><p><b>#2 – 侧面加载</b></p><ul><li>让你的 RAT 在内存中运行</li><li>编写 DLL 以执行额外的功能</li><li>将 DLL 转换为 shellcode（使用 sRDI）并本地注入</li><li>使用 GetProcAddressR 查找导出的函数</li><li>执行 X 次附加功能，而无需重新加载 DLL</li></ul><p><b>优点： </b>使您的初始工具更轻巧，并根据需要添加功能。加载一次 DLL 并像使用其他任何 DLL 一样使用它。</p><p><b>＃3 – 依赖关系</b></p><ul><li>从磁盘读取现有的合法 API DLL</li><li>将 DLL 转换为 shellcode（使用 sRDI）并将其加载到内存中</li><li>使用 GetProcAddress 查找所需的功能</li></ul><p><b>优点： </b>避免使用监视工具来检测 LoadLibrary 调用。访问 API 函数而不会泄漏信息。（WinInet，PSApi，TlHelp32，GdiPlus）</p><h2>使用✔</h2><h3>使用 python 将 DLL 转换为 shellcode</h3><div class="highlight"><pre><code class="language-python"><span class="kn">from</span> <span class="nn">ShellcodeRDI</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">dll</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&#34;TestDLL_x86.dll&#34;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">shellcode</span> <span class="o">=</span> <span class="n">ConvertToShellcode</span><span class="p">(</span><span class="n">dll</span><span class="p">)</span></code></pre></div><h3>使用 C＃ 加载程序将 DLL 加载到内存中</h3><div class="highlight"><pre><code class="language-csharp"><span class="n">DotNetLoader</span><span class="p">.</span><span class="n">exe</span> <span class="n">TestDLL_x64</span><span class="p">.</span><span class="n">dll</span>
</code></pre></div><h3>使用 python 脚本转换 DLL 并使用本机 EXE 加载</h3><div class="highlight"><pre><code class="language-python"><span class="n">python</span> <span class="n">ConvertToShellcode</span><span class="o">.</span><span class="n">py</span> <span class="n">TestDLL_x64</span><span class="o">.</span><span class="n">dll</span>
<span class="n">NativeLoader</span><span class="o">.</span><span class="n">exe</span> <span class="n">TestDLL_x64</span><span class="o">.</span><span class="nb">bin</span></code></pre></div><h3>使用 powershell 转换 DLL 并使用 Invoke-Shellcode 加载</h3><div class="highlight"><pre><code class="language-text">Import-Module .\Invoke-Shellcode.ps1
Import-Module .\ConvertTo-Shellcode.ps1
Invoke-Shellcode -Shellcode (ConvertTo-Shellcode -File TestDLL_x64.dll)</code></pre></div><h2>搭建🔨</h2><p>sRDI 是使用Visual Studio 2015（v140）和 Windows SDK 8.1 构建的。python 脚本是使用 Python 3 编写的。</p><p>Python和Powershell脚本位于：</p><ul><li>Python\ConvertToShellcode.py</li><li>PowerShell\ConvertTo-Shellcode.ps1</li></ul><p>构建项目后，其他二进制文件将位于：</p><ul><li>bin\NativeLoader.exe</li><li>bin\DotNetLoader.exe</li><li>bin\TestDLL_&lt;arch&gt;.dll</li><li>bin\ShellcodeRDI_&lt;arch&gt;.bin </li></ul><h2>测试test⌛</h2><p>让我们编译一个简单的 x86 DLL，执行弹出 2 个记事本进程：</p><figure data-size="small"><noscript><img src="https://pic2.zhimg.com/v2-241f58bad8b2b3d68da48e35e921a461_b.jpg" data-caption="" data-size="small" data-rawwidth="815" data-rawheight="418" class="origin_image zh-lightbox-thumb" width="815" data-original="https://pic2.zhimg.com/v2-241f58bad8b2b3d68da48e35e921a461_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-241f58bad8b2b3d68da48e35e921a461_b.jpg" data-caption="" data-size="small" data-rawwidth="815" data-rawheight="418" class="origin_image zh-lightbox-thumb lazy" width="815" data-original="https://pic2.zhimg.com/v2-241f58bad8b2b3d68da48e35e921a461_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-241f58bad8b2b3d68da48e35e921a461_b.jpg"/></figure><p>将 DLL 转换为 shellcode。我们将得到一个以十进制值表示的 shellcode 字节数组：</p><div class="highlight"><pre><code class="language-text">$sc = ConvertTo-Shellcode \\VBOXSVR\Experiments\messagebox\messagebox\Debug\messagebox.dll</code></pre></div><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-1b2ddb8ced35677c712b90731ace424f_b.jpg" data-caption="" data-size="normal" data-rawwidth="513" data-rawheight="337" class="origin_image zh-lightbox-thumb" width="513" data-original="https://pic4.zhimg.com/v2-1b2ddb8ced35677c712b90731ace424f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-1b2ddb8ced35677c712b90731ace424f_b.jpg" data-caption="" data-size="normal" data-rawwidth="513" data-rawheight="337" class="origin_image zh-lightbox-thumb lazy" width="513" data-original="https://pic4.zhimg.com/v2-1b2ddb8ced35677c712b90731ace424f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-1b2ddb8ced35677c712b90731ace424f_b.jpg"/></figure><p>让我们将它们转换为十六进制：</p><div class="highlight"><pre><code class="language-text">$sc2 = $sc | % { write-output ([System.String]::Format(&#39;{0:X2}&#39;, $_)) }</code></pre></div><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-40e368ce9bbaf297bc8386c25c63744a_b.jpg" data-caption="" data-size="normal" data-rawwidth="500" data-rawheight="177" class="origin_image zh-lightbox-thumb" width="500" data-original="https://pic3.zhimg.com/v2-40e368ce9bbaf297bc8386c25c63744a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-40e368ce9bbaf297bc8386c25c63744a_b.jpg" data-caption="" data-size="normal" data-rawwidth="500" data-rawheight="177" class="origin_image zh-lightbox-thumb lazy" width="500" data-original="https://pic3.zhimg.com/v2-40e368ce9bbaf297bc8386c25c63744a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-40e368ce9bbaf297bc8386c25c63744a_b.jpg"/></figure><p>将它们全部加入并打印到文本文件：</p><div class="highlight"><pre><code class="language-text">$sc2 -join &#34;&#34; &gt; shell.txt</code></pre></div><figure data-size="small"><noscript><img src="https://pic4.zhimg.com/v2-3050e89a67a0d5d63e16f19667d6afbb_b.jpg" data-caption="" data-size="small" data-rawwidth="677" data-rawheight="278" class="origin_image zh-lightbox-thumb" width="677" data-original="https://pic4.zhimg.com/v2-3050e89a67a0d5d63e16f19667d6afbb_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-3050e89a67a0d5d63e16f19667d6afbb_b.jpg" data-caption="" data-size="small" data-rawwidth="677" data-rawheight="278" class="origin_image zh-lightbox-thumb lazy" width="677" data-original="https://pic4.zhimg.com/v2-3050e89a67a0d5d63e16f19667d6afbb_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-3050e89a67a0d5d63e16f19667d6afbb_b.jpg"/></figure><p>使用我们之前获得的 shellcode 创建一个新的二进制文件：</p><figure data-size="small"><noscript><img src="https://pic2.zhimg.com/v2-8cdcf1f560d9bfadf905f1a3aa1c762d_b.jpg" data-caption="" data-size="small" data-rawwidth="761" data-rawheight="516" class="origin_image zh-lightbox-thumb" width="761" data-original="https://pic2.zhimg.com/v2-8cdcf1f560d9bfadf905f1a3aa1c762d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-8cdcf1f560d9bfadf905f1a3aa1c762d_b.jpg" data-caption="" data-size="small" data-rawwidth="761" data-rawheight="516" class="origin_image zh-lightbox-thumb lazy" width="761" data-original="https://pic2.zhimg.com/v2-8cdcf1f560d9bfadf905f1a3aa1c762d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-8cdcf1f560d9bfadf905f1a3aa1c762d_b.jpg"/></figure><p>为了加载和执行 shellcode，我们将把它作为资源放入二进制文件中。从 PE 资源加载和执行 Shellcode：</p><figure data-size="small"><noscript><img src="https://pic1.zhimg.com/v2-4320f81578d859a2394e1803b464b44c_b.jpg" data-caption="" data-size="small" data-rawwidth="638" data-rawheight="475" class="origin_image zh-lightbox-thumb" width="638" data-original="https://pic1.zhimg.com/v2-4320f81578d859a2394e1803b464b44c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-4320f81578d859a2394e1803b464b44c_b.jpg" data-caption="" data-size="small" data-rawwidth="638" data-rawheight="475" class="origin_image zh-lightbox-thumb lazy" width="638" data-original="https://pic1.zhimg.com/v2-4320f81578d859a2394e1803b464b44c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-4320f81578d859a2394e1803b464b44c_b.jpg"/></figure><p>编译并运行二进制文件。如果 shellcode 成功运行，我们应该会看到两个 notepad.exe 进程弹出窗口：</p><figure data-size="small"><noscript><img src="https://pic1.zhimg.com/v2-625ddec3e4e94820bd640cc5c1c39b6c_b.jpg" data-caption="" data-size="small" data-rawwidth="1462" data-rawheight="904" data-thumbnail="https://pic1.zhimg.com/v2-625ddec3e4e94820bd640cc5c1c39b6c_b.jpg" class="origin_image zh-lightbox-thumb" width="1462" data-original="https://pic1.zhimg.com/v2-625ddec3e4e94820bd640cc5c1c39b6c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-625ddec3e4e94820bd640cc5c1c39b6c_b.jpg" data-caption="" data-size="small" data-rawwidth="1462" data-rawheight="904" data-thumbnail="https://pic1.zhimg.com/v2-625ddec3e4e94820bd640cc5c1c39b6c_b.jpg" class="origin_image zh-lightbox-thumb lazy" width="1462" data-original="https://pic1.zhimg.com/v2-625ddec3e4e94820bd640cc5c1c39b6c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-625ddec3e4e94820bd640cc5c1c39b6c_b.jpg"/></figure><p>有关 <b>sRDI</b> 的内容就简单介绍到这里。更多有关 CTF 的内容请前往 <a href="https://link.zhihu.com/?target=https%3A//twosecurity.cn/%3Fquery_ref%3DqGLdXm" class=" wrap external" target="_blank" rel="nofollow noreferrer">二向箔安全</a> 进行学习，最近推出了一系列免费的网络安全技能包，有关CTF、渗透测试、网络攻防、黑客技巧尽在其中，学它涨姿势💯。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-bacc5586a9947727c6c17bbaff0c6df1_b.jpg" data-caption="" data-size="normal" data-rawwidth="720" data-rawheight="403" class="origin_image zh-lightbox-thumb" width="720" data-original="https://pic2.zhimg.com/v2-bacc5586a9947727c6c17bbaff0c6df1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-bacc5586a9947727c6c17bbaff0c6df1_b.jpg" data-caption="" data-size="normal" data-rawwidth="720" data-rawheight="403" class="origin_image zh-lightbox-thumb lazy" width="720" data-original="https://pic2.zhimg.com/v2-bacc5586a9947727c6c17bbaff0c6df1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-bacc5586a9947727c6c17bbaff0c6df1_b.jpg"/></figure>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
