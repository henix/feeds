<div class="title-image"><img src="https://pic1.zhimg.com/v2-c7c53b1f62a29bdfce1d67370007048c_b.jpg" alt=""></div><p>这本书的写作风格非常的有特色, 非常适合初学者. 作者以实现List为线索, 带着你一边写错误的代码(就像你可能会写出来的一样), 一边看报错信息找错, 然后再教你报错里的一些基本概念的意思, 最后跟你一起把错误的代码改对, 整个过程就像身边有个亲密的好朋友在手把手地教你一样, 陪着你试错, 在你受阻时却又秒变Rust聚聚跳出来给你耐心解释各种基本概念,  这么好的书, 边读边感动得我泪流满面 !</p><p>而我们市面上见到的大部分书是怎么写的呢?  作者整理自己的知识体系, 把各种知识分门别类, 按照难度和依赖关系进行拓扑排序, 然后组织章节目录, 并且尽力排除各种错误, 以期给到读者一个完美正确的版本.   我只能说, 这样的书适合用作随时查阅的手册, 却不适合入门学习. </p><p>其实回想一下, 我们学习任何东西都是这么一个过程, 它并非是像大部分书里所写的一样, 一蹴而就地就得到了一个正确的结果, 而是不断地尝试, 不断出错, 然后在排错的过程中去学习新知识, 解决之前的问题, 解决完老问题之后就去尝试新东西, 如此循环.  而这本书真实地还原了这样一个初学者的学习过程.  转念一想, 也许我们学习每个东西的过程, 如果把它写下来, 也都会是篇幅不小的书吧 :) </p><p><br/>下面是每一节内容的概括, 列出了所出现的重要名词, 便于查找: </p><ul><li>一开始讲的内存布局(data layout), 还顺带把空指针优化 (null-pointer optimization) 也讲了:  <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/first-layout.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/first-layout.html</span><span class="ellipsis"></span></a> </li><li>然后讲了一些rust的基本语法知识, 包括 impl, namespacing operator, implicit return 和 explicit return: <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/first-new.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/first-new.html</span><span class="ellipsis"></span></a> </li><li>讲所有权 (ownership) 的概念, 以及相关的 move, mutable reference, shared reference 等概念: <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/first-ownership.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/first-ownership.html</span><span class="ellipsis"></span></a> </li><li>实现 Push, 讲到了 men::replace 的用法: <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/first-push.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/first-push.html</span><span class="ellipsis"></span></a> </li><li>介绍 Option 及 pattern match, 顺便提了 unimplemented 宏, Unconditional panic 和 Diverging function 的概念: <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/first-pop.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/first-pop.html</span><span class="ellipsis"></span></a> </li><li>讲测试, 包括测试函数和测试模块标记:  <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/first-test.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/first-test.html</span><span class="ellipsis"></span></a> </li><li>介绍 Drop, 并解释为什么 drop 的默认实现不是尾递归的:  <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/first-drop.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/first-drop.html</span><span class="ellipsis"></span></a> </li><li>介绍 Option 的 take 和 map,  以及 closure  : <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/second-option.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/second-option.html</span><span class="ellipsis"></span></a> </li><li>介绍范型 (generic, 参数化多态) : <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/second-generic.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/second-generic.html</span><span class="ellipsis"></span></a> </li><li>介绍 Option 的 as_ref 和 as_mut , 解决 map 要所有权的问题,  解释了闭包捕获参数时指定 &amp;mut 的语义 : <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/second-peek.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/second-peek.html</span><span class="ellipsis"></span></a> </li><li>介绍了 into_iter 的实现 和  associated type,  <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/second-into-iter.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/second-into-iter.html</span><span class="ellipsis"></span></a> </li><li>介绍 iter 的实现, 及 生命周期范型参数 (lifetime), 还介绍了 生命周期省略 (lifetime elision), 自动解引用 (deref coercion) 以及通过 turbofish 手动标注部分类型,  <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/second-iter.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/second-iter.html</span><span class="ellipsis"></span></a> </li><li>介绍 iter_mut 的实现, <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/second-iter-mut.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/second-iter-mut.html</span><span class="ellipsis"></span></a> </li><li>开始实现不可变列表, <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/third.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/third.html</span><span class="ellipsis"></span></a> </li><li>介绍数据共享的内存布局, Rc, <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/third-layout.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/third-layout.html</span><span class="ellipsis"></span></a> </li><li>实现不可变列表的 append, tail, iter,  <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/third-basics.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/third-basics.html</span><span class="ellipsis"></span></a> </li><li>实现不可变列表的 drop, 用到了 Rc::try_unwrap, <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/third-drop.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/third-drop.html</span><span class="ellipsis"></span></a> </li><li>介绍Rc的线程不安全并引入线程安全的Arc, 介绍 Send, Sync 这两个和线程安全相关的 marker trait, 介绍 内部可变性 (interior mutability) 和 外部可变性 (inherited mutability, AKA external mutability) 的区别, 并说明 Rc 和 Arc 是内部可变的 (虽然从用户角度不可变, 但它们内部维护了一个可变的引用计数器): <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/third-arc.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/third-arc.html</span><span class="ellipsis"></span></a> </li><li>介绍 RefCell, borrow 和 borrow_mut, 动机是实现自动gc, 以及双端队列, <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/fourth-layout.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">rust-unofficial.github.io</span><span class="invisible">/too-many-lists/fourth-layout.html</span><span class="ellipsis"></span></a> </li><li>(未完待续, 今天暂时就读这么多了..) </li></ul><p class="ztext-empty-paragraph"><br/></p><p>原书地址: <a href="https://link.zhihu.com/?target=https%3A//rust-unofficial.github.io/too-many-lists/index.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Learning Rust With Entirely Too Many Linked Lists</a></p>