<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>TiDB 的后花园</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sat, 16 Nov 2019 05:46:43 +0800</lastBuildDate>
<item>
<title>Unified Thread Pool | Hackathon 2019 优秀项目介绍</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-11-14-91839290.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/91839290&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f1358d96099d3f1268614a0d2c3f13_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：夏锐航&lt;/p&gt;&lt;blockquote&gt;本文由逊馁队的成员夏锐航同学主笔，介绍 Unified Thread Pool 项目的设计与实现过程。该项目实现了在 TiKV 中使用一个统一的自适应线程池处理读请求，能够显著提升性能，并可预测性地限制大查询对小请求的干扰，最终在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247490046%26idx%3D1%26sn%3D962bb8aa4619c3815fcc561ed96331d7%26chksm%3Deb163e94dc61b7826b7e73a057f4c9823261c1a79005104dd41dbd6ef4276c01bd6e41a69d14%26scene%3D21%26token%3D1896003006%26lang%3Dzh_CN%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Hackathon 2019&lt;/a&gt; 中斩获一等奖。&lt;/blockquote&gt;&lt;p&gt;距离 TiDB Hackathon 落幕已经过去了半个多月，回忆这次比赛、获奖的经历，依然让我感到非常兴奋。我目前是华南理工大学大三的学生，我和正在 PingCAP 实习的学长奕霖一起组队参加了这次 TiDB Hackathon，比赛的主题为 “Improve”，即提升 TiDB 及相关项目的性能、易用性等。我们项目设计的切入点是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;TiKV 现有的线程池在大小查询混合场景下的表现不太优秀。&lt;/li&gt;&lt;li&gt;需要针对不同的环境、场景配置线程池数量，使用和学习成本较高。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;于是我和奕霖尝试为 TiKV 重新实现一个线程池来解决这个问题，以达到 Improve 整体表现的效果。除了优化读请求的线程池外，我们计划将这个线程池来代替 TiKV 中其他线程池，最后就产生了我们本次的参赛作品 Unified Thread Pool。&lt;/p&gt;&lt;h2&gt;项目设计&lt;/h2&gt;&lt;p&gt;在 TiKV 现行的线程池方案中有 Coprocessor、Storage 和 Scheduler 三套线程池。这些线程池原本是设计来分隔不同的任务，减少它们之间的相互影响。这种方式简单粗暴，缺点也很明显，如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;由于多个线程池共存，每个线程池都被限制至无法使用系统的全部资源。&lt;/li&gt;&lt;li&gt;每套任务中又对应二至三个不同优先级的线程池，但是从实际效果来讲这个隔离也没能很好的发挥用处。&lt;/li&gt;&lt;li&gt;在目前的 TiKV 中需要对每个线程池单独配置，如 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/configuration/tikv-server/configuration-file/%23scheduler-worker-pool-size&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Scheduler&lt;/a&gt;、&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/configuration/tikv-server/configuration-file/%23readpoolstorage&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Storage&lt;/a&gt;、&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/configuration/tikv-server/configuration-file/%23readpoolcoprocessor&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Coprocessor&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们的 Unified Thread Pool 是一个在用户态模拟多级反馈队列调度的线程池，能较好的解决上述现行线程池方案的几个缺点。两者具体的对比如下表所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-354e87e1e944aa0101d4cfd130e788d3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1370&quot; data-rawheight=&quot;322&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1370&quot; data-original=&quot;https://pic4.zhimg.com/v2-354e87e1e944aa0101d4cfd130e788d3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-354e87e1e944aa0101d4cfd130e788d3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1370&quot; data-rawheight=&quot;322&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1370&quot; data-original=&quot;https://pic4.zhimg.com/v2-354e87e1e944aa0101d4cfd130e788d3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-354e87e1e944aa0101d4cfd130e788d3_b.jpg&quot;/&gt;&lt;figcaption&gt;表 1 与现行线程池的对比&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Unified Thread Pool 的调度方案参考自多级反馈队列算法，在 Unified Thread Pool 中一共有三个队列，worker 每次以不同的数量从不同的队列里面拿任务执行来表示优先级。不同于 OS 场景下的调度是以每个任务为单位，在这里一个 TiDB query 可能因为跨越多个 Region 而产生多个 TiKV task，如图 1 所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4fd38ec39a809f4c3b280050c81b328c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;341&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-4fd38ec39a809f4c3b280050c81b328c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4fd38ec39a809f4c3b280050c81b328c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;341&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-4fd38ec39a809f4c3b280050c81b328c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4fd38ec39a809f4c3b280050c81b328c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 TiDB query 与 TiKV task 的关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因此在这里我们需要以 TiDB 的 query 为单位进行调度。为了实现这一点我们让 TiDB 在发送 query 的时候带上一个 token 来作为标识，在线程池内我们也以 token（query）为整体来调整优先级。&lt;/p&gt;&lt;p&gt;另一点很重要的改动是，现在 TiKV 中可能会出现一些大的 Coprocessor 请求，这些请求按 batch 执行，一个请求可能包含数百个 batches，执行一次就需要秒级的时间，使得对它们的调度无法进行。关于 Coprocessor 向量化执行的内容 PingCAP 后续也会有相关文章进行介绍。因此我们使用 Rust 最新的 async/await 协程机制，在 Coprocessor batches 之间手动埋点移交执行权，如下图所示，一个原本需要约一秒钟，包含约 500 个 batch 的任务在现在将会变为许多个时间约为一毫秒的小任务，在每个小任务之间会主动移交执行权。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5e0071204ccf173cc89ea25a73ba9373_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;750&quot; data-rawheight=&quot;440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;750&quot; data-original=&quot;https://pic4.zhimg.com/v2-5e0071204ccf173cc89ea25a73ba9373_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5e0071204ccf173cc89ea25a73ba9373_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;750&quot; data-rawheight=&quot;440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;750&quot; data-original=&quot;https://pic4.zhimg.com/v2-5e0071204ccf173cc89ea25a73ba9373_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-5e0071204ccf173cc89ea25a73ba9373_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2 将请求分成多次执行&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;至此，Unified Thread Pool 已经基本能够通过动态调节队列的参数来实现资源对大小任务的分配，并且需要设置的参数非常简单，仅有一个表示当出现大小任务混杂的情形时小任务应占的计算资源的百分数。通过测试我们看到这个的分配的效果比较精确，如下图所示。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ceb9722c9e51c41bf985f30f486e3f05_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-ceb9722c9e51c41bf985f30f486e3f05_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ceb9722c9e51c41bf985f30f486e3f05_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-ceb9722c9e51c41bf985f30f486e3f05_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ceb9722c9e51c41bf985f30f486e3f05_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3 Configurable&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;比赛过程&lt;/h2&gt;&lt;h3&gt;Hacking Time&lt;/h3&gt;&lt;p&gt;在 10 月 26 日上午拿到 UCloud 提供的机器（8C16G）后，我们开始部署 TiDB 集群便于测试。第一次部署方案是 3TiDB + 3TiKV，但是当集群运行起来之后我们发现当请求压来时瓶颈似乎在 TiDB 上，于是我们将 TiKV 集群 down 掉一台，情况虽然有所好转但还是无法将 TiKV 跑到满负荷。一番挣扎无果后我们将整个集群铲掉重新部署，第二次按照 4TiDB + 1TiKV + 1Tester 部署完之后终于让瓶颈出现在 TiKV 上。&lt;/p&gt;&lt;p&gt;详细的测试方案是使用 Tester 机器向四台 TiDB 发送请求然后检测延时和 QPS，sysbench 测试数据 32 张表，每张 10,000,000 条数据，总计容量约 80G。我们模拟了大小两种规格的请求，小请求是使用 sysbench 的 &lt;code&gt;point_selec t&lt;/code&gt; 和 &lt;code&gt;read_only&lt;/code&gt;，大请求则是使用四个 clients 不断地 &lt;code&gt;SELECT COUNT(*) FROM ..&lt;/code&gt; 来扫表。下图是我们在上述测试环境中对 Unified Thread Pool 与 TiKV master 版本所做的对比，可以看到在单纯的小请求情况下吞吐量提高了 20%~50%。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9e07f0aec2061bf4dde1b0677cedad8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;675&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9e07f0aec2061bf4dde1b0677cedad8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9e07f0aec2061bf4dde1b0677cedad8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;675&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9e07f0aec2061bf4dde1b0677cedad8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d9e07f0aec2061bf4dde1b0677cedad8_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4 fully utilize&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;睁眼吃喝闭眼睡&lt;/h3&gt;&lt;p&gt;众所周知 Hackathon 不变的主题就是吃吃喝喝，这一次也一样。PingCAP 为选手们提供了丰富的三餐，配上广州 office 的装潢简直像在度假。午餐有超多口味可以选，到了晚上一会议桌的虾蟹的确是太有视觉冲击力。除了正餐之外，还有不限量供应的零食咖啡快乐水，实在是太幸福了。&lt;/p&gt;&lt;p&gt;在比赛开始之前就有一件非常好奇的事情，就是据说现场晚上有三张床垫，不知道会出现怎样难上加难的场景。结果真的到了犯困的时候才发现原来其他人是根本不睡的……&lt;/p&gt;&lt;p&gt;晚上两点左右感觉刚跑完的测试效果还行，就找了间放了床的小会议室准备做梦。可是充气床垫的气已经漏完了，在茶水间里面翻到充气装置之后打算给它重启，但是插头插上之后气泵的声音在深夜里面真是大得不行，不知道之前工作人员是怎样悄无声息地把三个床垫给充起来的。为了防止噪音扰民，我们把床垫卷到大楼下一层（洗手间旁边）的小房间里面充气，期间还引来了两位像是保安的叔叔来看看发生了什么。接下来和奕霖两个人扛着两米的床垫走过会议室走过茶水间走过工位，走进小卧室的那一段路，实在是令人印象非常深刻。&lt;/p&gt;&lt;p&gt;这栋楼的空调效果真是非常强劲，虽然不是第一次在贵司被冷到，但是这一回来的时候依旧没有带外套。即使睡觉之前已经把空调关掉了，还是和带了外套但没拿出来的奕霖在床上缩成了两团。&lt;/p&gt;&lt;h2&gt;写在 Hackathon 之后&lt;/h2&gt;&lt;p&gt;比赛最后 Demo Time 的时候看别人的项目都好优秀，看得有点想提前跑路了，还好不是我上去做 presentation，能夺魁事实上挺让我感到意外的，现在 Hackathon 虽然已经结束了，但还想继续完善这个作品。现在它虽然能提升最大吞吐量，但是在延时方面的表现还能更进一步。在比赛时我们的线程池是基于比较简单的 juliex 来设计的，后续计划参考一些比如 tokio 之类的成熟的线程池来进行优化，希望能够将它完善合进 master。大家可以在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/tidb-performance-challenge/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 性能挑战赛&lt;/a&gt; 中继续一起鼓捣这个项目，该项目对应的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/issues/5765&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;最后感谢奕霖老师这么强还愿意带我玩，感谢 PingCAP 让我蹭吃蹭喝的辛苦付出 :D&lt;/p&gt;&lt;blockquote&gt;附：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//v.qq.com/x/page/s30152xwbyj.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;逊馁队 Demo Show 视频（0:00 - 10:35）&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;原文阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/unified-thread-pool/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Unified Thread Pool | Hackathon 2019 优秀项目介绍 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-11-14-91839290</guid>
<pubDate>Thu, 14 Nov 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>TiDB-Wasm 原理与实现 | Hackathon 优秀项目介绍</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-11-13-91563672.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/91563672&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f1358d96099d3f1268614a0d2c3f13_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：Ti-Cool&lt;/p&gt;&lt;blockquote&gt;上周我们推送了《&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-in-the-browser-running-a-golang-database-on-wasm/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;让数据库运行在浏览器里？TiDB + WebAssembly 告诉你答案&lt;/a&gt;》，向大家展示了 TiDB-Wasm 的魅力：TiDB-Wasm 项目是 TiDB Hackathon 2019 中诞生的二等奖项目，实现了将 TiDB 编译成 Wasm 运行在浏览器里，让用户无需安装就可以使用 TiDB。&lt;br/&gt;本文由 Ti-Cool 队成员主笔，为大家详细介绍 TiDB-Wasm 设计与实现细节。&lt;/blockquote&gt;&lt;p&gt;10 月 27 日，为期两天的 Hackathon 落下帷幕，我们用一枚二等奖为此次上海之行画上了圆满的句号，不枉我们风尘仆仆跑去异地参赛（强烈期待明年杭州能作为赛场，主办方也该鼓励鼓励杭州当地的小伙伴呀 :D ）。&lt;/p&gt;&lt;p&gt;我们几个 PingCAP 的小伙伴找到了 Tony 同学一起组队，组队之后找了一个周末进行了“秘密会晤”——Hackathon kick off。想了 N 个 idea，包括使用 unikernel 技术将 TiDB 直接跑在裸机上，或者将网络协议栈做到用户态以提升 TiDB 集群性能，亦或是使用异步 io 技术提升 TiKV 的读写能力，这些都被一一否决，原因是这些 idea 不是和 Tony 的工作内容相关，就是和我们 PingCAP 小伙伴的日常工作相关，做这些相当于我们在 Hackathon 加了两天班，这一点都不酷。本着「与工作无关」的标准，我们想了一个 idea：把 TiDB 编译成 Wasm 运行在浏览器里，让用户无需安装就可以使用 TiDB。我们一致认为这很酷，于是给队伍命名为 Ti-Cool（太酷了）。&lt;/p&gt;&lt;h2&gt;WebAssembly 简介&lt;/h2&gt;&lt;p&gt;这里插入一些 WebAssembly 的背景知识，让大家对这个技术有个大致的了解。&lt;/p&gt;&lt;p&gt;WebAssembly 的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//webassembly.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;官方介绍&lt;/a&gt; 是这样的：WebAssembly（缩写为 Wasm）是一种为基于堆栈的虚拟机设计的指令格式。它被设计为 C/C++/Rust 等高级编程语言的可移植目标，可在 web 上部署客户端和服务端应用程序。&lt;/p&gt;&lt;p&gt;从上面一段话我们可以得出几个信息：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Wasm 是一种可执行的指令格式。&lt;/li&gt;&lt;li&gt;C/C++/Rust 等高级语言写的程序可以编译成 Wasm。&lt;/li&gt;&lt;li&gt;Wasm 可以在 web（浏览器）环境中运行。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;可执行指令格式&lt;/h3&gt;&lt;p&gt;看到上面的三个信息我们可能又有疑问：什么是指令格式？&lt;/p&gt;&lt;p&gt;我们常见的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Executable_and_Linkable_Format&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ELF 文件&lt;/a&gt; 就是 Unix 系统上最常用的二进制指令格式，它被 loader 解析识别，加载进内存执行。同理，Wasm 也是被某种实现了 Wasm 的 runtime 识别，加载进内存执行，目前常见的实现了 Wasm runtime 的工具有各种主流浏览器，nodejs，以及一个专门为 Wasm 设计的通用实现：Wasmer，甚至还有人给 Linux 内核提 feature 将 Wasm runtime 集成在内核中，这样用户写的程序可以很方便的跑在内核态。&lt;/p&gt;&lt;p&gt;各种主流浏览器对 WebAssembly 的支持程度：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-01d2e33e71576ff7f3e4252095dba57f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;712&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-01d2e33e71576ff7f3e4252095dba57f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-01d2e33e71576ff7f3e4252095dba57f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;712&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-01d2e33e71576ff7f3e4252095dba57f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-01d2e33e71576ff7f3e4252095dba57f_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 主流浏览器对 WebAssembly 的支持程度&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;从高级语言到 Wasm &lt;/h3&gt;&lt;p&gt;有了上面的背景就不难理解高级语言是如何编译成 Wasm 的，看一下高级语言的编译流程：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3b59bb6f19d91ed984c0639f109bd4c3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;195&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-3b59bb6f19d91ed984c0639f109bd4c3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3b59bb6f19d91ed984c0639f109bd4c3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;195&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-3b59bb6f19d91ed984c0639f109bd4c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3b59bb6f19d91ed984c0639f109bd4c3_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2 高级语言编译流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们知道高级编程语言的特性之一就是可移植性，例如 C/C++ 既可以编译成 x86 机器可运行的格式，也可以编译到 ARM 上面跑，而我们的 Wasm 运行时和 ARM，x86_32 其实是同类东西，可以认为它是一台虚拟的机器，支持执行某种字节码，这一点其实和 Java 非常像，实际上 C/C++ 也可以编译到 JVM 上运行（参考：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/4221605/compiling-c-for-the-jvm&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;compiling-c-for-the-jvm&lt;/a&gt;）。&lt;/p&gt;&lt;h3&gt;各种 runtime 以及 WASI&lt;/h3&gt;&lt;p&gt;再啰嗦一下各种环境中运行 Wasm 的事，上面说了 Wasm 是设计为可以在 web 中运行的程序，其实 Wasm 最初设计是为了弥补 js 执行效率的问题，但是发展到后面发现，这玩意儿当虚拟机来移植各种程序也是很赞的，于是有了 nodejs 环境，Wasmer 环境，甚至还有内核环境。&lt;/p&gt;&lt;p&gt;这么多环境就有一个问题了：各个环境支持的接口不一致。比如 nodejs 支持读写文件，但浏览器不支持，这挑战了 Wasm 的可移植性，于是 WASI (WebAssembly System Interface) 应运而生，它定义了一套底层接口规范，只要编译器和 Wasm 运行环境都支持这套规范，那么编译器生成的 Wasm 就可以在各种环境中无缝移植。如果用现有的概念来类比，Wasm runtime 相当于一台虚拟的机器，Wasm 就是这台机器的可执行程序，而 WASI 是运行在这台机器上的系统，它为 Wasm 提供底层接口（如文件操作，socket 等）。&lt;/p&gt;&lt;p&gt;Example or  Hello World？&lt;/p&gt;&lt;p&gt;程序员对 Hello World 有天生的好感，为了更好的说明 Wasm 和 WASI 是啥，我们这里用一个 Wasm 的 Hello World 来介绍（例程来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//talks.godoc.org/github.com/chai2010/awesome-go-zh/chai2010/chai2010-golang-wasm.slide%2327&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;chai2010-golang-wasm.slide#27&lt;/a&gt;）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(module
    ;; type iov struct { iov_base, iov_len int32 }
    ;; func fd_write(id *iov, iovs_len int32, nwritten *int32) (written int32)
    (import &amp;#34;wasi_unstable&amp;#34; &amp;#34;fd_write&amp;#34; (func $fd_write (param i32 i32 i32 i32) (result i32)))

    (memory 1)(export &amp;#34;memory&amp;#34; (memory 0))

    ;; The first 8 bytes are reserved for the iov array, starting with address 8
    (data (i32.const 8) &amp;#34;hello world\n&amp;#34;)

    ;; _start is similar to main function, will be executed automatically
    (func $main (export &amp;#34;_start&amp;#34;)
        (i32.store (i32.const 0) (i32.const 8))  ;; iov.iov_base - The string address is 8
        (i32.store (i32.const 4) (i32.const 12)) ;; iov.iov_len  - String length

        (call $fd_write
            (i32.const 1)  ;; 1 is stdout
            (i32.const 0)  ;; *iovs - The first 8 bytes are reserved for the iov array
            (i32.const 1)  ;; len(iovs) - Only 1 string
            (i32.const 20) ;; nwritten - Pointer, inside is the length of the data to be written
        )
        drop ;; Ignore return value
    )
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体指令的解释可以参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pengowray.github.io/wasm-ops/html/wasm-opcodes.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;这里的 test.wat 是 Wasm 的文本表示，wat 之于 Wasm 的关系类似于汇编和 ELF 的关系。&lt;/p&gt;&lt;p&gt;然后我们把 wat 编译为 Wasm 并且使用 Wasmer（一个通用的 Wasm 运行时实现）运行：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6bcb924ca994346dae73ceda6dd29c4f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;487&quot; data-rawheight=&quot;91&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;487&quot; data-original=&quot;https://pic4.zhimg.com/v2-6bcb924ca994346dae73ceda6dd29c4f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6bcb924ca994346dae73ceda6dd29c4f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;487&quot; data-rawheight=&quot;91&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;487&quot; data-original=&quot;https://pic4.zhimg.com/v2-6bcb924ca994346dae73ceda6dd29c4f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6bcb924ca994346dae73ceda6dd29c4f_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3 Hello World&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;改造工作&lt;/h2&gt;&lt;p&gt;恐惧来自未知，有了背景知识动起手来才无所畏惧，现在可以开启 TiDB 的浏览器之旅。&lt;/p&gt;&lt;h3&gt;浏览器安全限制&lt;/h3&gt;&lt;p&gt;我们知道，浏览器本质是一个沙盒，是不会让内部的程序做一些危险的事情的，比如监听端口，读写文件。而 TiDB 的使用场景实际是用户启动一个客户端通过 MySQL 协议连接到 TiDB，这要求 TiDB 必须监听某个端口。&lt;/p&gt;&lt;p&gt;&lt;b&gt;考虑片刻之后，我们认为即便克服了浏览器沙盒这个障碍，真让用户用 MySQL 客户端去连浏览器也并不是一个优雅的事情，我们希望的是用户在页面上可以有一个开箱即用的 MySQL 终端，它已经连接好了 TiDB。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;于是我们第一件事是给 TiDB 集成一个终端，让它启动后直接弹出这个终端接受用户输入 SQL。所以我们需要在 TiDB 的代码中找到一个工具，它的输入是一串 SQL，输出是 SQL 的执行结果，写一个这样的东西对于我们几个没接触过 TiDB 代码的人来说还是有些难度，于是我们想到了一个捷径：TiDB 的测试代码中肯定会有输入 SQL 然后检查输出的测试。那么把这种测试搬过来改一改不就是我们想要的东西嘛？然后我们翻了翻 TiDB 的测试代码，发现了大量的这样的用法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;result = tk.MustQuery(&amp;#34;select count(*) from t group by d order by c&amp;#34;)
result.Check(testkit.Rows(&amp;#34;3&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;2&amp;#34;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以我们只需要看看这个 &lt;code&gt;tk&lt;/code&gt; 是个什么东西，借来用一下就行了。这是 &lt;code&gt;tk&lt;/code&gt; 的主要函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Exec executes a sql statement.
func (tk *TestKit) Exec(sql string, args ...interface{}) (sqlexec.RecordSet, error) {
    var err error
    if tk.Se == nil {
        tk.Se, err = session.CreateSession4Test(tk.store)
        tk.c.Assert(err, check.IsNil)
        id := atomic.AddUint64(&amp;amp;connectionID, 1)
        tk.Se.SetConnectionID(id)
    }
    ctx := context.Background()
    if len(args) == 0 {
        var rss []sqlexec.RecordSet
        rss, err = tk.Se.Execute(ctx, sql)
        if err == nil &amp;amp;&amp;amp; len(rss) &amp;gt; 0 {
            return rss[0], nil
        }
        return nil, errors.Trace(err)
    }
    stmtID, _, _, err := tk.Se.PrepareStmt(sql)
    if err != nil {
        return nil, errors.Trace(err)
    }
    params := make([]types.Datum, len(args))
    for i := 0; i &amp;lt; len(params); i++ {
        params[i] = types.NewDatum(args[i])
    }
    rs, err := tk.Se.ExecutePreparedStmt(ctx, stmtID, params)
    if err != nil {
        return nil, errors.Trace(err)
    }
    err = tk.Se.DropPreparedStmt(stmtID)
    if err != nil {
        return nil, errors.Trace(err)
    }
    return rs, nil
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;剩下的事情就非常简单了，写一个 Read-Eval-Print-Loop (REPL)  读取用户输入，将输入交给上面的 Exec，再将 Exec 的输出格式化到标准输出，然后循环继续读取用户输入。&lt;/p&gt;&lt;h3&gt;编译问题&lt;/h3&gt;&lt;p&gt;&lt;b&gt;集成一个终端只是迈出了第一步，我们现在需要验证一个非常关键的问题：TiDB 能不能编译到 Wasm，虽然 TiDB 是 Golang 写的，但是中间引用的第三方库没准哪个写了平台相关的代码就没法直接编译了&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们先按照 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/golang/go/wiki/WebAssembly%23getting-started&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Golang 官方文档&lt;/a&gt; 编译：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8d8afa3b0292b47b2464dd05012151e7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;931&quot; data-rawheight=&quot;179&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;931&quot; data-original=&quot;https://pic4.zhimg.com/v2-8d8afa3b0292b47b2464dd05012151e7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8d8afa3b0292b47b2464dd05012151e7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;931&quot; data-rawheight=&quot;179&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;931&quot; data-original=&quot;https://pic4.zhimg.com/v2-8d8afa3b0292b47b2464dd05012151e7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8d8afa3b0292b47b2464dd05012151e7_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4 按照 Golang 官方文档编译（1/2）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;果然出师不利，查看 goleveldb 的代码发现，storage 包下面的代码针对不同平台有各自的实现，唯独没有 Wasm/js 的：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-233579f3644d7f6fe84b5a9f7372e7a3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;229&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-233579f3644d7f6fe84b5a9f7372e7a3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-233579f3644d7f6fe84b5a9f7372e7a3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;229&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-233579f3644d7f6fe84b5a9f7372e7a3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-233579f3644d7f6fe84b5a9f7372e7a3_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5 按照 Golang 官方文档编译（2/2）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;所以在 Wasm/js 环境下编译找不到一些函数。所以这里的方案就是添加一个 &lt;code&gt;file_storage_js.go&lt;/code&gt;，然后给这些函数一个 unimplemented 的实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;package storage

import (
	&amp;#34;os&amp;#34;
	&amp;#34;syscall&amp;#34;
)

func newFileLock(path string, readOnly bool) (fl fileLock, err error) {
	return nil, syscall.ENOTSUP
}

func setFileLock(f *os.File, readOnly, lock bool) error {
	return syscall.ENOTSUP
}

func rename(oldpath, newpath string) error {
	return syscall.ENOTSUP
}

func isErrInvalid(err error) bool {
	return false
}

func syncDir(name string) error {
	return syscall.ENOTSUP
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后再次编译：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-31d4ec0f360aea32700c9b4db086bacc_b.png&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;143&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-31d4ec0f360aea32700c9b4db086bacc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-31d4ec0f360aea32700c9b4db086bacc_b.png&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;143&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-31d4ec0f360aea32700c9b4db086bacc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-31d4ec0f360aea32700c9b4db086bacc_b.png&quot;/&gt;&lt;figcaption&gt;图 6 再次编译的结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;emm… 编译的时候没有函数可以说这个函数没有 Wasm/js 对应的版本，没有 body 是个什么情况？好在我们有代码可以看，到 &lt;code&gt;arith_decl.go&lt;/code&gt; 所在的目录看一下就知道怎么回事了：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-47e492f0072a80d3827f945bf8ce0bf2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;306&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-47e492f0072a80d3827f945bf8ce0bf2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-47e492f0072a80d3827f945bf8ce0bf2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;306&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-47e492f0072a80d3827f945bf8ce0bf2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-47e492f0072a80d3827f945bf8ce0bf2_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7 查看目录&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;然后 &lt;code&gt;arith_decl.go&lt;/code&gt; 的内容是一些列的函数声明，但是具体的实现放到了上面的各个平台相关的汇编文件中了。&lt;/p&gt;&lt;p&gt;看起来还是和刚刚一样的情况，我们只需要为 Wasm 实现一套这些函数就可以了。但这里有个问题是，这是一个代码不受我们控制的第三方库，并且 TiDB 不直接依赖这个库，而是依赖了一个叫 &lt;code&gt;mathutil&lt;/code&gt; 的库，然后 &lt;code&gt;mathutil&lt;/code&gt; 依赖这个 &lt;code&gt;bigfft&lt;/code&gt;。悲催的是，这个 &lt;code&gt;mathutil&lt;/code&gt; 的代码也不受我们控制，因此很直观的想到了两种方案：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;给这两个库的作者提 PR，让他们支持 Wasm。&lt;/li&gt;&lt;li&gt;我们将这两个库 clone 过来改掉，然后把 TiDB 依赖改到我们 clone 过来的库上。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;方案一的问题很明显，整个周期较长，等作者接受 PR 了我们的 Hackathon 都凉凉了（而且还不一定会接受）；方案二的问题也不小，这会导致我们和上游脱钩。那么有没有第三种方案呢，即在编译 Wasm 的时候不依赖这两个库，在编译正常的二进制文件的时候又用这两个库？经过搜索发现，我们很多代码都用到了 &lt;code&gt;mathutil&lt;/code&gt;，但是基本上只用了几个函数：&lt;code&gt;MinUint64&lt;/code&gt;，&lt;code&gt;MaxUint64&lt;/code&gt;，&lt;code&gt;MinInt32&lt;/code&gt;，&lt;code&gt;MaxInt32&lt;/code&gt; 等等，我们想到的方案是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;新建一个 &lt;code&gt;mathutil&lt;/code&gt; 目录，在这个目录里建立 &lt;code&gt;mathutil_linux.go&lt;/code&gt; 和 &lt;code&gt;mathutil_js.go&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;在 &lt;code&gt;mathutil_linux.go&lt;/code&gt; 中 reexport 第三方包的几个函数。&lt;/li&gt;&lt;li&gt;在 &lt;code&gt;mathutil_js.go&lt;/code&gt; 中自己实现这几个函数，不依赖第三方包。&lt;/li&gt;&lt;li&gt;将所有对第三方的依赖改到 &lt;code&gt;mathutil&lt;/code&gt; 目录上。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这样，&lt;code&gt;mathutil&lt;/code&gt; 目录对外提供了原来 &lt;code&gt;mathutil&lt;/code&gt; 包的函数，同时整个项目只有 &lt;code&gt;mathutil&lt;/code&gt; 目录引入了这个不兼容 Wasm 的第三方包，并且只在 &lt;code&gt;mathutil_linux.go&lt;/code&gt; 中引入（&lt;code&gt;mathutil_js.go&lt;/code&gt; 是自己实现的），因此编译 Wasm 的时候就不会再用到 &lt;code&gt;mathutil&lt;/code&gt; 这个包。&lt;/p&gt;&lt;p&gt;再次编译，成功了！&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4a01c0041a64b01434647b456e581fe4_b.png&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;114&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-4a01c0041a64b01434647b456e581fe4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4a01c0041a64b01434647b456e581fe4_b.png&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;114&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-4a01c0041a64b01434647b456e581fe4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4a01c0041a64b01434647b456e581fe4_b.png&quot;/&gt;&lt;figcaption&gt;图 8 编译成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;兼容性问题&lt;/h3&gt;&lt;p&gt;编译出 main.Wasm 按照 Golang 的 Wasm 文档跑一下，由于目前是直接通过 os.Stdin 读用户输入的 SQL，通过 os.Stdout 输出结果，所以理论上页面上会是空白的（我们还没有操作 dom），但是由于 TiDB 的日志会打向 os.Stdout，所以在浏览器的控制台上应该能看到 TiDB 正常启动的日志才对。然而很遗憾看到的是异常栈：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c8099d27bb0441dc7c2ba7d4420398df_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;287&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-c8099d27bb0441dc7c2ba7d4420398df_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c8099d27bb0441dc7c2ba7d4420398df_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;287&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-c8099d27bb0441dc7c2ba7d4420398df_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-c8099d27bb0441dc7c2ba7d4420398df_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9 异常栈&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;可以看到这个错是运行时没实现 os.stat 操作，这是因为目前的 Golang 没有很好的支持 WASI，它仅在 &lt;code&gt;wasm_exec.js&lt;/code&gt; 中 mock 了一个 &lt;code&gt;fs&lt;/code&gt;:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;global.fs = {
        writeSync(fd, buf) {
                ...
        },
        write(fd, buf, offset, length, position, callback) {
                ...
        },
        open(path, flags, mode, callback) {
                ...
        },
        ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而且这个 mock 的 &lt;code&gt;fs&lt;/code&gt; 并没有实现 &lt;code&gt;stat&lt;/code&gt;, &lt;code&gt;lstat&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;, &lt;code&gt;mkdir&lt;/code&gt; 之类的调用，那么解决方案就是我们在启动之前在全局的 &lt;code&gt;fs&lt;/code&gt; 对象上 mock 一下这几个函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function unimplemented(callback) {
    const err = new Error(&amp;#34;not implemented&amp;#34;);
    err.code = &amp;#34;ENOSYS&amp;#34;;
    callback(err);
}
function unimplemented1(_1, callback) { unimplemented(callback); }
function unimplemented2(_1, _2, callback) { unimplemented(callback); }

fs.stat = unimplemented1;
fs.lstat = unimplemented1;
fs.unlink = unimplemented1;
fs.rmdir = unimplemented1;
fs.mkdir = unimplemented2;
go.run(result.instance);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后再刷新页面，在控制台上出现了久违的日志：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f00a297031deaa064d8ea5877981867a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;418&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-f00a297031deaa064d8ea5877981867a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f00a297031deaa064d8ea5877981867a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;418&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-f00a297031deaa064d8ea5877981867a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-f00a297031deaa064d8ea5877981867a_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10 日志信息&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;到目前为止就已经解决了 TiDB 编译到 Wasm 的所有技术问题，剩下的工作就是找一个合适的能运行在浏览器里的 SQL 终端替换掉前面写的终端，和 TiDB 对接上就能让用户在页面上输入 SQL 并运行起来了。&lt;/p&gt;&lt;h3&gt;用户接口&lt;/h3&gt;&lt;p&gt;通过上面的工作，我们现在有了一个 Exec 函数，它接受 SQL 字符串，输出 SQL 执行结果，并且它可以在浏览器里运行，我们还需要一个浏览器版本 SQL 终端和这个函数交互，两种方案：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 Golang 直接操作 dom 来实现这个终端。&lt;/li&gt;&lt;li&gt;在 Golang 中把 Exec 暴露到全局，然后找一个现成的 js 版本的终端和这个全局的 Exec 对接。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对于前端小白的我们来说，第二种方式成本最低，我们很快找到了 jquery.console.js 这个库，它只需要传入一个 SQL 处理的 callback 即可运行，而我们的 Exec 简直就是为这个 callback 量身打造的。&lt;/p&gt;&lt;p&gt;因此我们第一步工作就是把 Exec 挂到浏览器的 window 上（暴露到全局给 js 调用）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;js.Global().Set(&amp;#34;executeSQL&amp;#34;, js.FuncOf(func(this js.Value, args []js.Value) interface{} {
    go func() {
	    // Simplified code
	    sql := args[0].String()
	    args[1].Invoke(k.Exec(sql))
    }()
    return nil
}))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样就能在浏览器的控制台运行 SQL 了：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b62d23bae548c4c621d453578b5c60dd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;333&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-b62d23bae548c4c621d453578b5c60dd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b62d23bae548c4c621d453578b5c60dd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;333&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-b62d23bae548c4c621d453578b5c60dd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b62d23bae548c4c621d453578b5c60dd_b.jpg&quot;/&gt;&lt;figcaption&gt;图 11 在浏览器控制台运行 SQL&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;然后将用 jquery.console.js 搭建一个 SQL 终端，再将 executeSQL 作为 callback 传入，大功告成：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0c65deaa8ca33079a52a2f3e55b63023_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;406&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-0c65deaa8ca33079a52a2f3e55b63023_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0c65deaa8ca33079a52a2f3e55b63023_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;406&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-0c65deaa8ca33079a52a2f3e55b63023_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0c65deaa8ca33079a52a2f3e55b63023_b.jpg&quot;/&gt;&lt;figcaption&gt;图 12 搭建 SQL 终端&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;现在算是有一个能运行的版本了。&lt;/p&gt;&lt;h3&gt;本地文件访问&lt;/h3&gt;&lt;p&gt;还有一点点小麻烦要解决，那就是 TiDB 的 load stats 和 load data 功能。load data 语法和功能详解可以参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/sql/statements/load-data/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 官方文档&lt;/a&gt;，其功能简单的说就是用户指定一个文件路径，然后客户端将这个文件内容传给 TiDB，TiDB 将其加载到指定的表里。我们的问题在于，浏览器中是不能读取用户电脑上的文件的，于是我们只好在用户执行这个语句的时候打开浏览器的文件上传窗口，让用户主动选择一个这样的文件传给 TiDB：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;js.Global().Get(&amp;#34;upload&amp;#34;).Invoke(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
    go func() {
        fileContent := args[0].String()
        _, e := doSomething(fileContent)
        c &amp;lt;- e
    }()
    return nil
}), js.FuncOf(func(this js.Value, args []js.Value) interface{} {
    go func() {
        c &amp;lt;- errors.New(args[0].String())
    }()
    return nil
}))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;load stats 的实现也是同理。&lt;/p&gt;&lt;p&gt;&lt;b&gt;此外，我们还使用同样的原理 “自作主张” 加入了一个新的指令：source，用户执行这个命令可以上传一个 SQL 文件，然后我们会执行这个文件里的语句。我们认为这个功能的主要使用场景是：用户初次接触 TiDB 时，想验证其对 MySQL 的兼容性，但是一条一条输入 SQL 效率太低了，于是可以将所有用户业务中用到的 SQL 组织到一个 SQL 文件中（使用脚本或其他自动化工具），然后在页面上执行 source 导入这个文件，验证结果。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以一个 test.sql 文件为例，展示下 source 命令的效果，test.sql 文件内容如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;CREATE DATABASE IF NOT EXISTS samp_db;

USE samp_db;

CREATE TABLE IF NOT EXISTS person (
      number INT(11),
      name VARCHAR(255),
      birthday DATE
);

CREATE INDEX person_num ON person (number);

INSERT INTO person VALUES(&amp;#34;1&amp;#34;,&amp;#34;tom&amp;#34;,&amp;#34;20170912&amp;#34;);

UPDATE person SET birthday=&amp;#39;20171010&amp;#39; WHERE name=&amp;#39;tom&amp;#39;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;source 命令执行之后弹出文件选择框：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a6f1998b31d343294a27433da256f08d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;412&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a6f1998b31d343294a27433da256f08d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a6f1998b31d343294a27433da256f08d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;412&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a6f1998b31d343294a27433da256f08d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a6f1998b31d343294a27433da256f08d_b.jpg&quot;/&gt;&lt;figcaption&gt;图 13 source 命令执行（1/2）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;选中 SQL 文件上传后自动执行，可以对数据库进行相应的修改：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dccd5b202f1dc8ea31e76b3a693b253c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;937&quot; data-rawheight=&quot;406&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;937&quot; data-original=&quot;https://pic1.zhimg.com/v2-dccd5b202f1dc8ea31e76b3a693b253c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dccd5b202f1dc8ea31e76b3a693b253c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;937&quot; data-rawheight=&quot;406&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;937&quot; data-original=&quot;https://pic1.zhimg.com/v2-dccd5b202f1dc8ea31e76b3a693b253c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dccd5b202f1dc8ea31e76b3a693b253c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 14 source 命令执行（2/2）&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;总结与展望&lt;/h2&gt;&lt;p&gt;总的来说，这次 Hackathon 为了移植 TiDB 我们主要解决了几个问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;浏览器中无法监听端口，我们给 TiDB 嵌入了一个 SQL 终端。&lt;/li&gt;&lt;li&gt;goleveldb 对 Wasm 的兼容问题。&lt;/li&gt;&lt;li&gt;bigfft 的 Wasm 兼容问题。&lt;/li&gt;&lt;li&gt;Golang 自身对 WASI 支持不完善导致的 fs 相关函数缺失。&lt;/li&gt;&lt;li&gt;TiDB 对本地文件加载转换为浏览器上传文件方式加载。&lt;/li&gt;&lt;li&gt;支持 source 命令批量执行 SQL。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;目前而言我们已经将这个项目作为 TiDB Playground (&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//play.pingcap.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;play.pingcap.com/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;) 和 TiDB Tour (&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tour.pingcap.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;tour.pingcap.com/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;) 开放给用户使用。由于它不需要用户安装配置就能让用户在阅读文档的同时进行尝试，很大程度上降低了用户学习使用 TiDB 的成本，社区有小伙伴已经基于这些自己做数据库教程了，譬如：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/imiskolee/tidb-wasm-markdown&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;imiskolee/tidb-wasm-markdown&lt;/a&gt;（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/0Vo4apK4VdBfOs0-KyWXZA&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;相关介绍文章&lt;/a&gt;）。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-87223b57c3becda6170a7b2751fcf8a0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;397&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-87223b57c3becda6170a7b2751fcf8a0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-87223b57c3becda6170a7b2751fcf8a0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;397&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-87223b57c3becda6170a7b2751fcf8a0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-87223b57c3becda6170a7b2751fcf8a0_b.jpg&quot;/&gt;&lt;figcaption&gt;图 15 TiDB Playground&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;由于 Hackathon 时间比较紧张，其实很多想做的东西还没实现，比如：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 indexedDB 让数据持久化：需要针对 indexedDB 实现一套 Storage 的 interface。&lt;/li&gt;&lt;li&gt;使用 P2P 技术（如 webrtc）对其他浏览器提供服务：未来必定会有越来越多的应用迁移到 Wasm，而很多应用是需要数据库的，TiDB-Wasm 恰好可以扮演这样的角色。&lt;/li&gt;&lt;li&gt;给 TiDB 的 Wasm 二进制文件瘦身：目前编译出来的二进制文件有将近 80M，对浏览器不太友好，同时运行时占用内存也比较多。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;欢迎更多感兴趣的社区小伙伴们加入进来，一起在这个项目上愉快的玩耍（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/projects/27&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;github.com/pingcap/tidb/projects/27&lt;/a&gt;），也可以通过 &lt;a href=&quot;mailto:info@pingcap.com&quot;&gt;info@pingcap.com&lt;/a&gt; 联系我们。&lt;/p&gt;&lt;p&gt;&lt;b&gt;阅读原文：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-wasm-introduction/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB-Wasm 原理与实现 | Hackathon 优秀项目介绍 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-11-13-91563672</guid>
<pubDate>Wed, 13 Nov 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何玩转 TiDB 性能挑战赛？本文教你 30 分钟快速上手拿积分！</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-11-12-91391418.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/91391418&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-885ef147a4c39132ee5bdeccbcb41d07_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：wish&lt;/p&gt;&lt;p&gt;上周我们正式宣布了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/tidb-performance-challenge/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 性能挑战赛&lt;/a&gt;。在赛季内，通过向 TiDB、TiKV、PD 贡献代码完成指定类别任务的方式，你可以获得相应的积分，最终你可以使用积分兑换礼品或奖金。在性能挑战赛中，你首先需要完成几道 Easy 的题目，积累一定量积分后，才能开始挑战 Medium / Hard 难度的题目。&lt;/p&gt;&lt;p&gt;活动发布后，大家向我们反馈 TiKV 任务的资料比较少，上手难度比较高。因此本文以 TiKV 性能挑战赛 Easy 级别任务 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/issues/5751&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PCP: Migrate functions from TiDB&lt;/a&gt; 为例，教大家如何快速又正确地完成这个任务，从而玩转“TiDB 性能挑战赛”。这个任务中每项完成后均可以获得 50 分，是积累分数从而挑战更高难度任务的好机会。既能改进 TiKV 为性能提升添砖加瓦、又能参与比赛得到积分，还能成为 Contributor，感兴趣的小伙伴们一起来“打怪”吧！&lt;/p&gt;&lt;h2&gt;背景知识&lt;/h2&gt;&lt;p&gt;TiKV Coprocessor（协处理）模块为 TiDB 提供了在存储引擎侧直接进行部分 SQL 计算的功能，支持按表达式进行过滤、聚合等，这样不仅利用起了 TiKV 机器的 CPU 资源，还能显著减少网络传输及相应的 RPC 开销，显著提升性能。大家可以阅读 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tikv-source-code-reading-14/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《TiKV 源码解析系列文章（十四）Coprocessor 概览》&lt;/a&gt;一文进一步了解 Coprocessor 模块。&lt;/p&gt;&lt;p&gt;表达式计算是 Coprocessor 非常重要的一个功能，例如用户输入了这样的 SQL：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SELECT * FROM t WHERE  sqrt(col_area) &amp;gt; 10;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;TiKV Coprocessor 使用表达式 &lt;code&gt;sqrt(col_area) &amp;gt; 10&lt;/code&gt; 对每一行进行求值，并根据结果对数据进行过滤，最后将过滤后的结果返回给 TiDB。为了能计算这个表达式，TiKV 必须实现与 TiDB 行为一致的 &lt;code&gt;Sqrt&lt;/code&gt; 函数，当然 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符也要提供对应的实现，这些统称为内置函数（built-in function）。&lt;/p&gt;&lt;p&gt;TiDB 和 MySQL 有非常多的内置函数，但 TiKV 目前只实现了一部分，只有当用户输入的表达式完全被 TiKV 支持并已经进行充分测试时，对应的表达式才会被下推到 Coprocessor 执行，否则 TiDB 只能从 TiKV 捞完整数据上来，达不到加速目的。&lt;/p&gt;&lt;p&gt;另外，TiKV 从 3.0 版本开始就包含两套 Coprocessor 执行框架，一套是老的框架，基于火山模型（推荐阅读 paper： &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//paperhub.s3.amazonaws.com/dace52a42c07f7f8348b08dc2b186061.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Volcano - An Extensible and Parallel Query Evaluation System&lt;/a&gt;）实现，另一套是 3.0 的新框架，基于向量化模型（推荐阅读 paper：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cidrdb.org/cidr2005/papers/P19.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MonetDB/X100: Hyper-Pipelining Query Execution&lt;/a&gt;）实现。火山模型中每个算子和函数都按行一个一个计算，向量化模型中则按列批量计算。由于在向量化模型中一个批次进行的处理操作是一样的，因此它可以规避条件分支，且能更好地利用流水线与缓存，从而具有更高的计算效率，差距可达 10 倍以上。&lt;/p&gt;&lt;p&gt;既然两个模型中函数处理的数据单位是不一样的，它们自然也有不一样的函数签名及实现，因此还有一大批内置函数虽然在 TiKV 侧已经实现了，但只有火山模型的实现，而没有向量化模型的实现。这类函数虽然 TiDB 已下推计算，但 TiKV 会回退到使用火山模型而不是向量化模型，无法达成最优计算效率。&lt;/p&gt;&lt;p&gt;综上，TiDB 内置函数在 TiKV 侧有几种实现状态：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;完全没有实现，如 &lt;code&gt;FromDays&lt;/code&gt; 函数。&lt;/li&gt;&lt;li&gt;已有火山模型的实现，没有向量化模型的实现，如 &lt;code&gt;BitLength&lt;/code&gt; 函数。&lt;/li&gt;&lt;li&gt;火山模型和向量化都已实现，如 &lt;code&gt;LTReal&lt;/code&gt; 函数。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/issues/5751&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PCP: Migrate functions from TiDB&lt;/a&gt; 这个任务就是希望大家能帮助我们在 TiKV 侧实现更多 TiDB 所支持的内置函数，并支持向量化计算。这个 issue 中 Non-Vectorize 打钩意味着函数已有火山模型的实现，Vectorized 打钩意味着函数已有向量化模型的实现。因此你可以：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;选择一个完全没有实现的函数，如 &lt;code&gt;FromDays&lt;/code&gt;，从 TiDB 侧迁移它的代码到 TiKV 并实现在火山模型（Non-Vectorize）上，提个 PR +50 积分，再迁移到向量化模型（Vectorize）上，从而再提个 PR +50 积分。&lt;/li&gt;&lt;li&gt;或选择一个已有火山模型但没有向量化实现的函数，如 &lt;code&gt;BitLength&lt;/code&gt; 函数，为它适配向量化模型（Vectorize）接口，提个 PR +50 积分。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;实现一个完全没有在 TiKV 侧实现的内置函数一般来说具有更高难度，因此能获得更高回报！&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;如何从 TiDB 迁移内置函数在火山模型上实现&lt;/h2&gt;&lt;p&gt;这部分在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/30mins-become-contributor-of-tikv&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《三十分钟成为 Contributor | 为 TiKV 添加 built-in 函数》&lt;/a&gt; 中有所介绍，大家可以照着这个教程来，这里就不再赘述。&lt;/p&gt;&lt;blockquote&gt;注：由于 Coprocessor 框架实现的是 Fallback 机制，不允许函数只有向量化实现而没有火山模型实现。因此，若一个内置函数完全没有在 TiKV 侧实现，请先将它在火山模型上进行实现，再迁移至向量化模型。&lt;/blockquote&gt;&lt;h2&gt;如何为函数适配向量化模型接口&lt;/h2&gt;&lt;p&gt;&lt;b&gt;以下本文的重点！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果一个内置函数在 TiKV 中已经有了火山模型的实现，但没有向量化模型的实现，则可以迁移它。以 LogicalXor 内置函数为例，它之前并没有向量化的实现（当然现在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/pull/5826&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;有了&lt;/a&gt;）。可以遵循以下步骤：&lt;/p&gt;&lt;h3&gt;1. 找到火山模型的实现&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;components/tidb_query/src/expr/scalar_function.rs&lt;/code&gt; 中搜索 &lt;code&gt;LogicalXor&lt;/code&gt;，可以发现这个函数的实现位于 &lt;code&gt;logical_xor&lt;/code&gt; 函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;LogicalXor =&amp;gt; logical_xor,&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来搜索 &lt;code&gt;fn logical_xor&lt;/code&gt; 就可以定位到函数具体内容，位于 &lt;code&gt;builtin_op.rs&lt;/code&gt;（PS：不同内置函数会在不同文件中，不要照搬）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pub fn logical_xor(&amp;amp;self, ctx: &amp;amp;mut EvalContext, row: &amp;amp;[Datum]) -&amp;gt; Result&amp;lt;Option&amp;lt;i64&amp;gt;&amp;gt; {
    let arg0 = try_opt!(self.children[0].eval_int(ctx, row));
    let arg1 = try_opt!(self.children[1].eval_int(ctx, row));
    Ok(Some(((arg0 == 0) ^ (arg1 == 0)) as i64))
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;2. 翻译为向量化实现&lt;/h3&gt;&lt;p&gt;阅读理解上面的代码，可知 &lt;code&gt;LogicalXor&lt;/code&gt; 是一个二元内置函数。其中，第一个参数 &lt;code&gt;children[0]&lt;/code&gt; 和第二个参数 &lt;code&gt;children[1]&lt;/code&gt; 都是通过 &lt;code&gt;eval_int&lt;/code&gt; 方式访问的，因此 &lt;code&gt;LogicalXor&lt;/code&gt; 接受的两个参数都是 int 类型。最后，这个函数返回值是 &lt;code&gt;Result&amp;lt;Option&amp;lt;i64&amp;gt;&amp;gt;&lt;/code&gt; 代表它计算结果也是 int 类型。可以由这些信息翻译为以下向量化计算代码，实现在 &lt;code&gt;components/tidb_query/src/rpn_expr/impl_op.rs&lt;/code&gt; 文件中：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#[rpn_fn]
#[inline]
pub fn logical_xor(arg0: &amp;amp;Option&amp;lt;Int&amp;gt;, arg1: &amp;amp;Option&amp;lt;Int&amp;gt;) -&amp;gt; Result&amp;lt;Option&amp;lt;Int&amp;gt;&amp;gt; {
    // TODO
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;注：&lt;code&gt;Int&lt;/code&gt; 是 &lt;code&gt;i64&lt;/code&gt; 的 Type Alias。你既可以写 &lt;code&gt;Int&lt;/code&gt; 也可以写 &lt;code&gt;i64&lt;/code&gt;，不过更推荐 &lt;code&gt;Int&lt;/code&gt; 一些。你可以从&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/blob/d019ccecefc260ff760a53b7b8742fb84ffca9b5/components/tidb_query/src/codec/data_type/mod.rs%23L10&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;找到所有的 Type Alias。&lt;code&gt;eval_xxx&lt;/code&gt; 函数与类型的对应关系如下表所示。&lt;/blockquote&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-be61bb25a568bd491dac8ad2b37f8884_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;988&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;988&quot; data-original=&quot;https://pic1.zhimg.com/v2-be61bb25a568bd491dac8ad2b37f8884_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-be61bb25a568bd491dac8ad2b37f8884_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;988&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;988&quot; data-original=&quot;https://pic1.zhimg.com/v2-be61bb25a568bd491dac8ad2b37f8884_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-be61bb25a568bd491dac8ad2b37f8884_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;换句话说就是：向量化版本的 &lt;code&gt;logical_xor&lt;/code&gt; 是一个接受两个参数且两个参数都是 Int 类型的函数，返回 Int，是不是非常直观呢？另外我们使用 &lt;code&gt;None&lt;/code&gt; 来代表 SQL 中的 &lt;code&gt;NULL&lt;/code&gt; 值，因此函数参数及返回值都是 &lt;code&gt;Option&amp;lt;Int&amp;gt;&lt;/code&gt; 类型。&lt;/p&gt;&lt;p&gt;最后照搬原来的内部实现（注意处理好 &lt;code&gt;None&lt;/code&gt; / &lt;code&gt;Some&lt;/code&gt; 的情况），这个函数就算完成了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#[rpn_fn]
#[inline]
pub fn logical_xor(arg0: &amp;amp;Option&amp;lt;Int&amp;gt;, arg1: &amp;amp;Option&amp;lt;Int&amp;gt;) -&amp;gt; Result&amp;lt;Option&amp;lt;Int&amp;gt;&amp;gt; {
    Ok(match (arg0, arg1) {
        (Some(arg0), Some(arg1)) =&amp;gt; Some(((*arg0 == 0) ^ (*arg1 == 0)) as i64),
        _ =&amp;gt; None,
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可能会问，不是说好了向量化计算是批量计算的吗，为什么向量化计算版本的代码没有接受数组，而只是接受单个值呢？原因在于 TiKV 向量化计算框架会自动基于你的这个基本实现，在编译期生成向量化计算版本，伪代码类似于这样：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;fn logical_xor_vector_scalar(arg0: []Int, arg1: Int) -&amp;gt; []Int {
  let r = vec![];
  for i in 0..n {
    r.push( logical_xor(arg0[i], arg1) );
  }
  return r;
}
 
fn logical_xor_scalar_vector(arg0: Int, arg1: []Int) -&amp;gt; []Int {
  let r = vec![];
  for i in 0..n {
    r.push( logical_xor(arg0, arg1[i]) );
  }
  return r;
}
 
fn logical_xor_vector_vector(arg0: []Int, arg1: []Int) -&amp;gt; []Int {
  let r = vec![];
  for i in 0..n {
    r.push( logical_xor(arg0[i], arg1[i]) );
  }
  return r;
}
 
fn logical_xor_scalar_scalar(arg0: Int, arg1: Int) -&amp;gt; []Int {
  let r = vec![];
  for i in 0..n {
    r.push( logical_xor(arg0, arg1) );
  }
  return r;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你只需要关注内置函数本身的逻辑实现，其他的全部自动搞定！这些所有的奥秘都隐藏在了 &lt;code&gt;#[rpn_fn]&lt;/code&gt; 过程宏中。&lt;/p&gt;&lt;p&gt;当然，上面的伪代码只是便于你进行理解。这个过程宏的实际实现并不是像上面这样粗暴地组装代码。它巧妙地利用了 Rust 的泛型机制，让编译器去生成不同个数参数情况下的最优实现。这里有点偏题就不继续展开细说了，我们后续的源码阅读文章对这个机制会有进一步分析，感兴趣的同学可以阅读代码自行学习。&lt;/p&gt;&lt;h3&gt;3. 增加函数入口&lt;/h3&gt;&lt;p&gt;目前只是提供了向量化版本的函数实现，但还需要告诉向量化计算框架，在遇到 LogicalXor 这个内置函数的时候，使用上向量化版本 &lt;code&gt;logical_xor&lt;/code&gt; 的实现。这一步很简单，修改 &lt;code&gt;components/tidb_query/src/rpn_expr/mod.rs&lt;/code&gt; 文件中的 &lt;code&gt;map_expr_node_to_rpn_func&lt;/code&gt; 函数，增加一个对应关系即可：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;ScalarFuncSig::LogicalXor =&amp;gt; logical_xor_fn_meta(),&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意，此处要为函数名加上 &lt;code&gt;_fn_meta&lt;/code&gt; 后缀，从而用上 &lt;code&gt;#[rpn_fn]&lt;/code&gt; 过程宏自动生成的向量化版本函数实现。不要问为什么，问就是约定 :D&lt;/p&gt;&lt;h3&gt;4. 撰写单元测试&lt;/h3&gt;&lt;p&gt;搜索 &lt;code&gt;ScalarFuncSig::LogicalXor&lt;/code&gt; 可以找到火山模型下的该函数单元测试：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#[test]
fn test_logic_op() {
    let tests = vec![
        ...
        (
            ScalarFuncSig::LogicalXor,
            Datum::I64(1),
            Datum::I64(1),
            Some(0),
        ),
        (
            ScalarFuncSig::LogicalXor,
            Datum::I64(1),
            Datum::I64(0),
            Some(1),
        ),
        (
            ScalarFuncSig::LogicalXor,
            Datum::I64(0),
            Datum::I64(0),
            Some(0),
        ),
        (
            ScalarFuncSig::LogicalXor,
            Datum::I64(2),
            Datum::I64(-1),
            Some(0),
        ),
        (ScalarFuncSig::LogicalXor, Datum::I64(0), Datum::Null, None),
        (ScalarFuncSig::LogicalXor, Datum::Null, Datum::I64(1), None),
    ];
    let mut ctx = EvalContext::default();
    for (op, lhs, rhs, exp) in tests {
        let arg1 = datum_expr(lhs);
        let arg2 = datum_expr(rhs);
        ……
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个测试覆盖挺完备的，因此可以直接拿样例来复用，作为向量化版本的单元测试。向量化版本单元测试中不再使用 Datum 等结构，而是可以直接用最原始的基础数据结构 &lt;code&gt;Option&amp;lt;Int&amp;gt;&lt;/code&gt;，配上 &lt;code&gt;RpnFnScalarEvaluator&lt;/code&gt; 进行执行，代码如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#[test]
fn test_logical_xor() {
    let test_cases = vec![
        (Some(1), Some(1), Some(0)),
        (Some(1), Some(0), Some(1)),
        (Some(0), Some(0), Some(0)),
        (Some(2), Some(-1), Some(0)),
        (Some(0), None, None),
        (None, Some(1), None),
    ];
    for (arg0, arg1, expect_output) in test_cases {
        let output = RpnFnScalarEvaluator::new()
            .push_param(arg0)
            .push_param(arg1)
            .evaluate(ScalarFuncSig::LogicalXor)
            .unwrap();
        assert_eq!(output, expect_output);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果原来火山模型实现的单元测试不完备，那么请在你的向量化实现中的单元测试中补充更多测试样例，尽可能覆盖所有分支条件。你也可以从 TiDB 的实现中迁移测试样例。注意，测试的目标是要检测实现是否符合预期，预期的是 TiKV 实现与 TiDB 实现能输出一样的结果，因此 TiDB 的输出是标准输出，不能由你自己来决定这个函数的标准输出。&lt;/p&gt;&lt;p&gt;不过，有些情况下 TiDB 的输出可能与 MySQL 不一致，你可以选择与 TiDB 行为保持一致，也可以选择与 MySQL 行为保持一致，但都需要在 TiDB 中开 issue 汇报这个行为不一致情况。&lt;/p&gt;&lt;h3&gt;5. 运行测试&lt;/h3&gt;&lt;p&gt;至此，这个函数已经可以工作起来了，可以运行单元测试看一下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;make dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者干脆只跑刚才写的这个测试：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;EXTRA_CARGO_ARGS=&amp;#34;test_logical_xor&amp;#34; make dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;测试通过就可以提 PR 了。注意要在 PR 的开头写上&lt;/b&gt; &lt;b&gt;&lt;code&gt;PCP #5751&lt;/code&gt;&lt;/b&gt; &lt;b&gt;指明这个 PR 对应的性能挑战赛题目，不然合了是得不到积分的。另外我们鼓励每个 PR 都专注于做一件事情，所以请尽量不要在同一个 PR 内迁移或实现多个内置函数，否则只能得到一次 50 积分。&lt;/b&gt;&lt;/p&gt;&lt;h3&gt;6. 运行下推测试&lt;/h3&gt;&lt;p&gt;众所周知，手工编写的测试样例往往会遗漏一些考虑欠缺的边缘情况，并且可能由于犯了一些错误，测试的预期输出实际与 TiDB 不一致。为了能覆盖这些边缘情况，进一步确保 TiKV 中的内置函数实现与 TiDB 的实现一致，我们有一批使用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/MariaDB/randgen&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;randgen&lt;/a&gt; 自动生成的下推测试，位于 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/copr-test&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/tikv/copr-te&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。不管你是在 TiKV 中引入一个新的函数实现，还是迁移一个现有实现，都需要确保能跑过这个测试。流程如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;需要确保你新实现的函数在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/copr-test&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;copr-test&lt;/a&gt; 项目的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/copr-test/blob/master/push-down-test/functions.txt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;push-down-test/functions.txt&lt;/a&gt; 文件中，如果没有的话需要往 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/copr-test&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;copr-test&lt;/a&gt; 项目提 PR 将函数加入测试列表中。你需要将 SQL 里的函数名追加在文件中，或者可以参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/copr-test/blob/master/push-down-test/all_functions_reference.txt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;all_functions_reference.txt&lt;/a&gt; 文件，这个文件里列出了所有可以写的函数名，从中挑出你的那个函数名，加入 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/copr-test/blob/master/push-down-test/functions.txt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;push-down-test/functions.txt&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;假设 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/copr-test&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;copr-test&lt;/a&gt; 中提的 PR 是 #10，则在你之前提的 TiKV PR 中回复 &lt;code&gt;@sre-bot /run-integration-copr-test copr-test=pr/10&lt;/code&gt; 运行下推测试。如果你的函数之前已经在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/copr-test/blob/master/push-down-test/functions.txt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;push-down-test/functions.txt&lt;/a&gt; 列表中了，可以直接回复 &lt;code&gt;@sre-bot /run-integration-copr-test&lt;/code&gt; 运行下推测试。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当然，我们更推荐你能直接往 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/copr-test&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;copr-test&lt;/a&gt; 中添加人工编写的测试，更准确地覆盖边缘情况，具体方式参见 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/copr-test&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;copr-test&lt;/a&gt; 的 README。&lt;/p&gt;&lt;h3&gt;7. 在 TiDB 中增添签名映射&lt;/h3&gt;&lt;p&gt;如果上一步 copr-test 的测试挂了，一般来说有两种情况，一种情况是内置函数的实现有问题，被 copr-test 测了出来，另一种情况是你新实现的内置函数在 TiDB 侧还未建立函数签名与下推枚举签名 &lt;code&gt;ScalarFuncSig&lt;/code&gt; 之间的映射关系。后者会在测试中产生 “unspecified PbCode” 错误，非常容易辨别。如果出现了这种情况，大家可以参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12864&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/pingcap/tidb&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/pull/12864&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt; 的做法，为 TiDB 提 PR 增添相应内置函数的 PbCode 映射。添加完毕之后，可以在 TiKV PR 中回复 &lt;code&gt;@sre-bot /run-integration-copr-test copr-test=pr/X tidb=pr/Y&lt;/code&gt;（其中 &lt;code&gt;X&lt;/code&gt; 是你提的 copr-test PR 号，&lt;code&gt;Y&lt;/code&gt; 是你提的 TiDB PR 号）进行联合测试。&lt;/p&gt;&lt;h2&gt;完成！&lt;/h2&gt;&lt;p&gt;至此，你新实现的内置函数有了单元测试，也有了与 TiDB 的集成下推测试，是一个合格的 PR 了，可以接受我们的 review。在 merge 后，你就能拿到相应的积分，积分可以在赛季结束后兑换 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/tidb-performance-challenge/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 限量周边礼品&lt;/a&gt;！&lt;/p&gt;&lt;p&gt;最后欢迎大家加入 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//join.slack.com/t/tidbcommunity/shared_invite/enQtNzc0MzI4ODExMDc4LWYwYmIzMjZkYzJiNDUxMmZlN2FiMGJkZjAyMzQ5NGU0NGY0NzI3NTYwMjAyNGQ1N2I2ZjAxNzc1OGUwYWM0NzE&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Community Slack Workspace&lt;/a&gt; 和 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//tikv.org/chat&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;tikv-wg Slack Workspace&lt;/a&gt;，参赛过程中遇到任何问题都可以直接通过 &lt;b&gt;#performance-challenge-program&lt;/b&gt; channel 与我们取得联系。&lt;/p&gt;&lt;p&gt;&lt;b&gt;原文阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/how-to-join-in-the-tidb-performance-challenge-program/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;如何玩转 TiDB 性能挑战赛？本文教你 30 分钟快速上手拿积分！ | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-11-12-91391418</guid>
<pubDate>Tue, 12 Nov 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>TiDB 最佳实践系列（五）Java 数据库应用开发指南</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-11-06-90525429.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90525429&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-963a693752e240685f86cb85e076e2ab_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：Su Li, Zhang Ming&lt;/p&gt;&lt;p&gt;Java 是当前非常流行的开发语言，很多 TiDB 用户的业务层都是使用 Java 开发的，本文将从 Java 数据库交互组件开发的角度出发，介绍各组件的推荐配置和推荐使用方式，希望能帮助 Java 开发者在使用 TiDB 时能更好的发挥数据库性能。&lt;/p&gt;&lt;h2&gt;Java 应用中的数据库相关组件&lt;/h2&gt;&lt;p&gt;通常 Java 应用中和数据库相关的常用组件有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;网络协议：客户端通过标准 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/internals/en/client-server-protocol.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MySQL 协议&lt;/a&gt; 和 TiDB 进行网络交互。&lt;/li&gt;&lt;li&gt;JDBC API 及实现：Java 应用通常使用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/8/docs/technotes/guides/jdbc/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDBC (Java Database Connectivity)&lt;/a&gt; 来访问数据库。JDBC 定义了访问数据库 API，而 JDBC 实现完成标准 API 到 MySQL 协议的转换，常见的 JDBC 实现是 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/mysql/mysql-connector-j&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MySQL Connector/J&lt;/a&gt;，此外有些用户可能使用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mariadb.com/kb/en/library/about-mariadb-connector-j/%23about-mariadb-connectorj&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MariaDB Connector/J&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;数据库连接池：为了避免每次创建连接，通常应用会选择使用数据库连接池来复用连接，JDBC &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/8/docs/api/javax/sql/DataSource.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DataSource&lt;/a&gt; 定义了连接池 API，开发者可根据实际需求选择使用某种开源连接池实现。&lt;/li&gt;&lt;li&gt;数据访问框架：应用通常选择通过数据访问框架（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.mybatis.org/mybatis-3/zh/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MyBatis&lt;/a&gt;、&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//hibernate.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hibernate&lt;/a&gt;）的封装来进一步简化和管理数据库访问操作。&lt;/li&gt;&lt;li&gt;业务实现：业务逻辑控制着何时发送和发送什么指令到数据库，其中有些业务会使用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spring Transaction&lt;/a&gt; 切面来控制管理事务的开始和提交逻辑。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9e6abd61cf53fa3c09732030accb541a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;590&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;800&quot; data-original=&quot;https://pic3.zhimg.com/v2-9e6abd61cf53fa3c09732030accb541a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9e6abd61cf53fa3c09732030accb541a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;590&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;800&quot; data-original=&quot;https://pic3.zhimg.com/v2-9e6abd61cf53fa3c09732030accb541a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9e6abd61cf53fa3c09732030accb541a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如上图所示，应用可能使用 Spring Transaction 来管理控制事务非手工启停，通过类似 MyBatis 的数据访问框架管理生成和执行 SQL，通过连接池获取已池化的长连接，最后通过 JDBC 接口调用实现通过 MySQL 协议和 TiDB 完成交互。&lt;/p&gt;&lt;p&gt;接下来将分别介绍使用各个组件时可能需要关注的问题。&lt;/p&gt;&lt;h2&gt;JDBC&lt;/h2&gt;&lt;p&gt;Java 应用尽管可以选择在不同的框架中封装，但在最底层一般会通过调用 JDBC 来与数据库服务器进行交互。对于 JDBC，需要关注的主要有：API 的选择和 API Implementer 的参数配置。&lt;/p&gt;&lt;h3&gt;1. JDBC API&lt;/h3&gt;&lt;p&gt;对于基本的 JDBC API 使用可以参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/jdbc/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JDBC 官方教程&lt;/a&gt;，本文主要强调几个比较重要的 API 选择。&lt;/p&gt;&lt;h3&gt;1.1 使用 Prepare API&lt;/h3&gt;&lt;p&gt;对于 OLTP 场景，程序发送给数据库的 SQL 语句在去除参数变化后都是可穷举的某几类，因此建议使用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;预处理语句 (Prepared Statements)&lt;/a&gt; 代替普通的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/jdbc/basics/processingsqlstatements.html%23executing_queries&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;文本执行&lt;/a&gt;，并复用 Prepared Statements 来直接执行，从而避免 TiDB 重复解析的开销。&lt;/p&gt;&lt;p&gt;目前多数上层框架都会调用 Prepare API 进行 SQL 执行，如果直接使用 JDBC API 进行开发，注意选择使用 Prepare API。&lt;/p&gt;&lt;p&gt;另外需要注意 MySQL Connector/J 实现中默认只会做客户端的语句预处理，会将 &lt;code&gt;?&lt;/code&gt; 在客户端替换后以文本形式发送到客户端，所以除了要使用 Prepare API，还需要在 JDBC 连接参数中配置 &lt;code&gt;useServerPrepStmts = true&lt;/code&gt;，才能在 TiDB 服务器端进行语句预处理（下面参数配置章节有详细介绍）。&lt;/p&gt;&lt;h3&gt;1.2 使用 Batch 批量插入更新&lt;/h3&gt;&lt;p&gt;对于批量插入更新，如果插入记录较多，可以选择使用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.tutorialspoint.com/jdbc/jdbc-batch-processing&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;addBatch/executeBatch API&lt;/a&gt;。通过 &lt;code&gt;addBatch&lt;/code&gt; 的方式将多条 SQL 的插入更新记录先缓存在客户端，然后在 &lt;code&gt;executeBatch&lt;/code&gt; 时一起发送到数据库服务器。&lt;/p&gt;&lt;blockquote&gt;注意：&lt;br/&gt;对于 MySQL Connector/J 实现，默认 Batch 只是将多次 &lt;code&gt;addBatch&lt;/code&gt; 的 SQL 发送时机延迟到调用 &lt;code&gt;executeBatch&lt;/code&gt; 的时候，但实际网络发送还是会一条条的发送，通常不会降低与数据库服务器的网络交互次数。&lt;br/&gt;如果希望 Batch 网络发送批量插入，需要在 JDBC 连接参数中配置 &lt;code&gt;rewriteBatchedStatements=true&lt;/code&gt;（下面参数配置章节有详细介绍）。&lt;/blockquote&gt;&lt;h3&gt;1.3 使用 StreamingResult 流式获取执行结果&lt;/h3&gt;&lt;p&gt;一般情况下，为提升执行效率，JDBC 会默认提前获取查询结果并将其保存在客户端内存中。但在查询返回超大结果集的场景中，客户端会希望数据库服务器减少向客户端一次返回的记录数，等客户端在有限内存处理完一部分后再去向服务器要下一批。&lt;/p&gt;&lt;p&gt;在 JDBC 中通常有以下两种处理方式：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;设置 &lt;code&gt;&lt;a href=&quot;&amp;lt;/code&amp;gt;htt&amp;lt;code&amp;gt;ps://dev.mysql.co&amp;lt;/code&amp;gt;m/doc/connector-j/5.1/en/connector-j-reference-implementation-notes.html#ResultSet&quot;&gt;FetchSize 为 Integer.MIN_VALUE&lt;/a&gt; 让客户端不缓存，客户端通过 &lt;code&gt;StreamingResult&lt;/code&gt; 的方式从网络连接上流式读取执行结果。&lt;/code&gt;&lt;/li&gt;&lt;li&gt;使用 Cursor Fetch 首先需 href=&amp;#34;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//makejavafaster.blogspot.com/2015/06/jdbc-fetch-size-performance.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;makejavafaster.blogspot.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/2015/06/jdbc-fetch-size-performance.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&amp;#34;&amp;gt;设置 FetchSize 为正整数且在 JDBC URL 中配置 &lt;code&gt;useCursorFetch=true&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;TiDB 中同时支持两种方式，但更推荐使用第一种将 &lt;code&gt;FetchSize&lt;/code&gt; 设置为 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 的方式，比第二种功能实现更简单且执行效率更高。&lt;/p&gt;&lt;h3&gt;2. MySQL JDBC 参数&lt;/h3&gt;&lt;p&gt;JDBC 实现通常通过 JDBC URL 参数的形式来提供实现相关的配置。这里以 MySQL 官方的 Connector/J 来介绍 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;参数配置&lt;/a&gt;（如果使用的是 MariaDB，可以参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mariadb.com/kb/en/library/about-mariadb-connector-j/%23optional-url-parameters&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MariaDB 的类似配置&lt;/a&gt;）。因为配置项较多，这里主要关注几个可能影响到性能的参数。&lt;/p&gt;&lt;h3&gt;2.1 Prepare 相关参数&lt;/h3&gt;&lt;h3&gt;useServerPrepStmts&lt;/h3&gt;&lt;p&gt;默认情况下，&lt;code&gt;useServerPrepStmts&lt;/code&gt; 为 false，即尽管使用了 Prepare API，也只会在客户端做 “prepare”。因此为了避免服务器重复解析的开销，如果同一条 SQL 语句需要多次使用 Prepare API，则建议设置该选项为 true。&lt;/p&gt;&lt;p&gt;在 TiDB 监控中可以通过 &lt;code&gt;Query Summary &amp;gt; QPS By Instance&lt;/code&gt; 查看请求命令类型，如果请求中 &lt;code&gt;COM_QUERY&lt;/code&gt; 被 &lt;code&gt;COM_STMT_EXECUTE&lt;/code&gt; 或 &lt;code&gt;COM_STMT_PREPARE&lt;/code&gt; 代替即生效。&lt;/p&gt;&lt;h3&gt;cachePrepStmts&lt;/h3&gt;&lt;p&gt;虽然 &lt;code&gt;useServerPrepStmts=true&lt;/code&gt; 能让服务端执行 prepare 语句，但默认情况下客户端每次执行完后会 close prepared 的语句，并不会复用，这样 prepare 效率甚至不如文本执行。所以建议开启 &lt;code&gt;useServerPrepStmts=true&lt;/code&gt; 后同时配置 &lt;code&gt;cachePrepStmts=true&lt;/code&gt;，这会让客户端缓存 prepare 语句。&lt;/p&gt;&lt;p&gt;在 TiDB 监控中可以通过 &lt;code&gt;Query Summary &amp;gt; QPS By Instance&lt;/code&gt; 查看请求命令类型，如果类似下图，请求中 &lt;code&gt;COM_STMT_EXECUTE&lt;/code&gt; 数目远远多于 &lt;code&gt;COM_STMT_PREPARE&lt;/code&gt; 即生效。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-27df3394ba2c38eded9ba8f698842625_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;296&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;800&quot; data-original=&quot;https://pic2.zhimg.com/v2-27df3394ba2c38eded9ba8f698842625_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-27df3394ba2c38eded9ba8f698842625_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;296&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;800&quot; data-original=&quot;https://pic2.zhimg.com/v2-27df3394ba2c38eded9ba8f698842625_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-27df3394ba2c38eded9ba8f698842625_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另外，通过 &lt;code&gt;useConfigs=maxPerformance&lt;/code&gt; 配置会同时配置多个参数，其中也包括 &lt;code&gt;cachePrepStmts=true&lt;/code&gt;。&lt;/p&gt;&lt;h3&gt;prepStmtCacheSqlLimit&lt;/h3&gt;&lt;p&gt;在配置 &lt;code&gt;cachePrepStmts&lt;/code&gt; 后还需要注意 &lt;code&gt;prepStmtCacheSqlLimit&lt;/code&gt; 配置（默认为 256），该配置控制客户端缓存 prepare 语句的最大长度，超过该长度将不会被缓存。&lt;/p&gt;&lt;p&gt;在一些场景 SQL 的长度可能超过该配置，导致 prepared SQL 不能复用，建议根据应用 SQL 长度情况决定是否需要调大该值。&lt;/p&gt;&lt;p&gt;在 TiDB 监控中通过 &lt;code&gt;Query Summary &amp;gt; QPS by Instance&lt;/code&gt; 查看请求命令类型，如果已经配置了 &lt;code&gt;cachePrepStmts=true&lt;/code&gt;，但 &lt;code&gt;COM_STMT_PREPARE&lt;/code&gt; 还是和 &lt;code&gt;COM_STMT_EXECUTE&lt;/code&gt; 基本相等且有 &lt;code&gt;COM_STMT_CLOSE&lt;/code&gt;，需要检查这个配置项是否设置得太小。&lt;/p&gt;&lt;h3&gt;prepStmtCacheSize&lt;/h3&gt;&lt;p&gt;&lt;code&gt;prepStmtCacheSize&lt;/code&gt; 控制缓存的 prepare 语句数目（默认为 25），如果应用需要 prepare 的 SQL 种类很多且希望复用 prepare 语句，可以调大该值。&lt;/p&gt;&lt;p&gt;和上一条类似，在监控中通过 &lt;code&gt;Query Summary &amp;gt; QPS by Instance&lt;/code&gt; 查看请求中 &lt;code&gt;COM_STMT_EXECUTE&lt;/code&gt; 数目是否远远多于 &lt;code&gt;COM_STMT_PREPARE&lt;/code&gt; 来确认是否正常。&lt;/p&gt;&lt;h3&gt;2.2 Batch 相关参数&lt;/h3&gt;&lt;p&gt;在进行 batch 写入处理时推荐配置 &lt;code&gt;rewriteBatchedStatements=true&lt;/code&gt;，在已经使用 &lt;code&gt;addBatch&lt;/code&gt; 或 &lt;code&gt;executeBatch&lt;/code&gt; 后默认 JDBC 还是会一条条 SQL 发送，例如：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pstmt = prepare(“insert into t (a) values(?)”);
pstmt.setInt(1, 10);
pstmt.addBatch();
pstmt.setInt(1, 11);
pstmt.addBatch();
pstmt.setInt(1, 12);
pstmt.executeBatch();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然使用了 batch 但发送到 TiDB 语句还是单独的多条 insert：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;insert into t(a) values(10);
insert into t(a) values(11);
insert into t(a) values(12);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果设置 &lt;code&gt;rewriteBatchedStatements=true&lt;/code&gt;，发送到 TiDB 的 SQL 将是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;insert into t(a) values(10),(11),(12);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意的是，insert 语句的改写，只能将多个 values 后的值拼接成一整条 SQL，insert 语句如果有其他差异将无法被改写。 例如：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;insert into t (a) values (10) on duplicate key update a = 10;
insert into t (a) values (11) on duplicate key update a = 11;
insert into t (a) values (12) on duplicate key update a = 12;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将无法被改写成一条语句。该例子中，如果将 SQL 改写成如下形式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;insert into t (a) values (10) on duplicate key update a = values(a);
insert into t (a) values (11) on duplicate key update a = values(a);
insert into t (a) values (12) on duplicate key update a = values(a);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即可满足改写条件，最终被改写成：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;insert into t (a) values (10), (11), (12) on duplicate key update a = values(a);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;批量更新时如果有 3 处或 3 处以上更新，则 SQL 语句会改写为 multiple-queries 的形式并发送，这样可以有效减少客户端到服务器的请求开销，但副作用是会产生较大的 SQL 语句，例如这样：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;update t set a = 10 where id = 1; update t set a = 11 where id = 2; update t set a = 12 where id = 3;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外因为一个 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//bugs.mysql.com/bug.php%3Fid%3D96623&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;客户端 bug&lt;/a&gt;，不建议在批量 insert 以外的场景设置 &lt;code&gt;rewriteBatchedStatements=true&lt;/code&gt;。&lt;/p&gt;&lt;h3&gt;2.3 执行前检查参数&lt;/h3&gt;&lt;p&gt;通过监控可能会发现，虽然业务只向集群进行 insert 操作，却看到有很多多余的 select 语句。通常这是因为 JDBC 发送了一些查询设置类的 SQL 语句（例如 s&lt;code&gt;elect @@session.transaction_read_only&lt;/code&gt;）。这些 SQL 对 TiDB 无用，推荐配置 &lt;code&gt;useConfigs=maxPerformance&lt;/code&gt; 来避免额外开销。&lt;/p&gt;&lt;p&gt;&lt;code&gt;useConfigs=maxPerformance&lt;/code&gt; 会包含一组配置：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;cacheServerConfiguration=true
useLocalSessionState=true
elideSetAutoCommits=true
alwaysSendSetIsolation=false
enableQueryTimeouts=false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;配置后查看监控可以看到多余语句减少。&lt;/p&gt;&lt;h2&gt;连接池&lt;/h2&gt;&lt;p&gt;TiDB (MySQL) 连接建立是比较昂贵的操作（至少对于 OLTP），除了建立 TCP 连接外还需要进行连接鉴权操作，所以客户端通常会把 TiDB (MySQL) 连接保存到连接池中进行复用。&lt;/p&gt;&lt;p&gt;Java 的连接池实现很多（比如，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/brettwooldridge/HikariCP&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HikariCP&lt;/a&gt;, &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;tomcat-jdbc&lt;/a&gt;, &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/alibaba/druid&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;durid&lt;/a&gt;, &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.mchange.com/projects/c3p0/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;c3p0&lt;/a&gt;, &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//commons.apache.org/proper/commons-dbcp/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;dbcp&lt;/a&gt;），TiDB 不会限定使用的连接池，应用可以根据业务特点自行选择连接池实现。&lt;/p&gt;&lt;h3&gt;1. 连接数配置&lt;/h3&gt;&lt;p&gt;比较常见的是应用需要根据自身情况配置合适的连接池大小，以 HikariCP 为例：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;：连接池最大连接数，配置过大会导致 TiDB 消耗资源维护无用连接，配置过小则会导致应用获取连接变慢，所以需根据应用自身特点配置合适的值，可参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这篇文章&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;&lt;code&gt;minimumIdle&lt;/code&gt;：连接池最大空闲连接数，主要用于在应用空闲时存留一些连接以应对突发请求，同样是需要根据业务情况进行配置。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;应用在使用连接池时需要注意连接使用完成后归还连接，推荐应用使用对应的连接池相关监控（如 &lt;code&gt;metricRegistry&lt;/code&gt;），通过监控能及时定位连接池问题。&lt;/p&gt;&lt;h3&gt;2. 探活配置&lt;/h3&gt;&lt;p&gt;连接池维护到 TiDB 的长连接，TiDB 默认不会主动关闭客户端连接（除非报错），但一般客户端到 TiDB 之间还会有 LVS 或 HAProxy 之类的网络代理，它们通常会在连接空闲一定时间后主动清理连接。除了注意代理的 idle 配置外，连接池还需要进行保活或探测连接。&lt;/p&gt;&lt;p&gt;如果常在 Java 应用中看到以下错误：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;The last packet sent successfully to the server was 3600000 milliseconds ago. The driver has not received any packets from the server. com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 &lt;code&gt;n milliseconds ago&lt;/code&gt; 中的 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;0&lt;/code&gt; 或很小的值，则通常是执行的 SQL 导致 TiDB 异常退出引起的报错，推荐查看 TiDB stderr 日志；如果 &lt;code&gt;n&lt;/code&gt; 是一个非常大的值（比如这里的 3600000），很可能是因为这个连接空闲太久然后被中间 proxy 关闭了，通常解决方式除了调大 proxy 的 idle 配置，还可以让连接池：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每次使用连接前检查连接是否可用。&lt;/li&gt;&lt;li&gt;使用单独线程定期检查连接是否可用。&lt;/li&gt;&lt;li&gt;定期发送 test query 保活连接。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不同的连接池实现可能会支持其中一种或多种方式，可以查看所使用的连接池文档来寻找对应配置。&lt;/p&gt;&lt;h2&gt;数据访问框架&lt;/h2&gt;&lt;p&gt;业务应用通常会使用某种数据访问框架来简化数据库的访问。&lt;/p&gt;&lt;h3&gt;1. MyBatis&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.mybatis.org/mybatis-3/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MyBatis&lt;/a&gt; 是目前比较流行的 Java 数据访问框架，主要用于管理 SQL 并完成结果集和 Java 对象的来回映射工作。MyBatis 和 TiDB 兼容性很好，从历史 issue 可以看出 MyBatis 很少出现问题。这里主要关注如下几个配置。&lt;/p&gt;&lt;h3&gt;1.1 Mapper 参数&lt;/h3&gt;&lt;p&gt;MyBatis 的 Mapper 中支持两种参数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;select 1 from t where id = #{param1}&lt;/code&gt; 会作为 prepare 语句转换为 &lt;code&gt;select 1 from t where id = ?&lt;/code&gt; 进行 prepare， 并使用实际参数来复用执行，通过配合前面的 Prepare 连接参数能获得最佳性能。&lt;/li&gt;&lt;li&gt;&lt;code&gt;select 1 from t where id = ${param2}&lt;/code&gt; 会做文本替换为 &lt;code&gt;select 1 from t where id = 1&lt;/code&gt; 执行，如果这条语句被 prepare 成了不同参数，可能会导致 TiDB 缓存大量的 prepare 语句，并且这种方式执行 SQL 有注入安全风险。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;1.2 动态 SQL Batch&lt;/h3&gt;&lt;p&gt;要支持将多条 insert 语句自动重写为 &lt;code&gt;insert ... values(...), (...), ...&lt;/code&gt; 的形式，除了前面所说的在 JDBC 配置 &lt;code&gt;rewriteBatchedStatements=true&lt;/code&gt; 外，MyBatis 还可以使用动态 SQL 的 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.mybatis.org/mybatis-3/dynamic-sql.html%23foreach&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;foreach 语法&lt;/a&gt; 来半自动生成 batch insert。比如下面的 mapper:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;insert id=&amp;#34;insertTestBatch&amp;#34; parameterType=&amp;#34;java.util.List&amp;#34; fetchSize=&amp;#34;1&amp;#34;&amp;gt;
  insert into test
   (id, v1, v2)
  values
  &amp;lt;foreach item=&amp;#34;item&amp;#34; index=&amp;#34;index&amp;#34; collection=&amp;#34;list&amp;#34; separator=&amp;#34;,&amp;#34;&amp;gt;
  (
   #{item.id}, #{item.v1}, #{item.v2}
  )
  &amp;lt;/foreach&amp;gt;
  on duplicate key update v2 = v1 + values(v1)
&amp;lt;/insert&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;会生成一个 &lt;code&gt;insert on duplicate key update&lt;/code&gt; 语句，values 后面的 &lt;code&gt;(?, ?, ?)&lt;/code&gt; 数目是根据传入的 list 个数决定，最终效果和使用 &lt;code&gt;rewriteBatchStatements=true&lt;/code&gt; 类似，可以有效减少客户端和 TiDB 的网络交互次数，同样需要注意 prepare 后超过 &lt;code&gt;prepStmtCacheSqlLimit&lt;/code&gt; 限制导致不缓存 prepare 语句的问题。&lt;/p&gt;&lt;h3&gt;1.3 Streaming 结果&lt;/h3&gt;&lt;p&gt;前面介绍了在 JDBC 中如何使用流式读取结果，除了 JDBC 相应的配置外，在 MyBatis 中如果希望读取超大结果集合也需要注意：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;可以通过在 mapper 配置中对单独一条 SQL 设置 &lt;code&gt;fetchSize&lt;/code&gt;（见上一段代码段），效果等同于调用 JDBC setFetchSize。&lt;/li&gt;&lt;li&gt;可以使用带 ResultHandler 的查询接口来避免一次获取整个结果集。&lt;/li&gt;&lt;li&gt;可以使用 Cursor 类来进行流式读取。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于使用 xml 配置映射，可以通过在映射 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 部分配置 &lt;code&gt;fetchSize=&amp;#34;-2147483648&amp;#34;&lt;/code&gt;(&lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;) 来流式读取结果。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;select id=&amp;#34;getAll&amp;#34; resultMap=&amp;#34;postResultMap&amp;#34; fetchSize=&amp;#34;-2147483648&amp;#34;&amp;gt;
  select * from post;
&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而使用代码配置映射，则可以使用 &lt;code&gt;@Options(fetchSize = Integer.MIN_VALUE)&lt;/code&gt; 并返回 Cursor 从而让 SQL 结果能被流式读取。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Select(&amp;#34;select * from post&amp;#34;)
@Options(fetchSize = Integer.MIN_VALUE)
Cursor&amp;lt;Post&amp;gt; queryAllPost();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;2. ExecutorType&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;openSession&lt;/code&gt; 的时候可以选择 &lt;code&gt;ExecutorType&lt;/code&gt;，MyBatis 支持三种 executor：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Simple&lt;/code&gt;：每次执行都会向 JDBC 进行 prepare 语句的调用（如果 JDBC 配置有开启 &lt;code&gt;cachePrepStmts&lt;/code&gt;，重复的 prepare 语句会复用）。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Reuse&lt;/code&gt;：在 executor 中缓存 prepare 语句，这样不用 JDBC 的 &lt;code&gt;cachePrepStmts&lt;/code&gt; 也能减少重复 prepare 语句的调用。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Batch&lt;/code&gt;：每次更新只有在 &lt;code&gt;addBatch&lt;/code&gt; 到 query 或 commit 时才会调用 &lt;code&gt;executeBatch&lt;/code&gt; 执行，如果 JDBC 层开启了 &lt;code&gt;rewriteBatchStatements&lt;/code&gt;，则会尝试改写，没有开启则会一条条发送。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通常默认值是 &lt;code&gt;Simple&lt;/code&gt;，需要在调用 &lt;code&gt;openSession&lt;/code&gt; 时改变 &lt;code&gt;ExecutorType&lt;/code&gt;。如果是 Batch 执行，会遇到事务中前面的 update 或 insert 都非常快，而在读数据或 commit 事务时比较慢的情况，这实际上是正常的，在排查慢 SQL 时需要注意。&lt;/p&gt;&lt;h2&gt;Spring Transaction&lt;/h2&gt;&lt;p&gt;在应用代码中业务可能会通过使用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spring Transaction&lt;/a&gt; 和 AOP 切面的方式来启停事务。&lt;/p&gt;&lt;p&gt;通过在方法定义上添加 &lt;code&gt;@Transactional&lt;/code&gt; 注解标记方法，AOP 将会在方法前开启事务，方法返回结果前 commit 事务。如果遇到类似业务，可以通过查找代码 &lt;code&gt;@Transactional&lt;/code&gt; 来确定事务的开启和关闭时机。需要特别注意有内嵌的情况，如果发生内嵌，Spring 会根据 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Propagation&lt;/a&gt; 配置使用不同的行为，因为 TiDB 未支持 savepoint，所以不支持嵌套事务。&lt;/p&gt;&lt;h2&gt;排查工具&lt;/h2&gt;&lt;p&gt;在 Java 应用发生问题并且不知道业务逻辑情况下，使用 JVM 强大的排查工具会比较有用。这里简单介绍几个常用工具：&lt;/p&gt;&lt;h3&gt;1. jstack&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;jstack&lt;/a&gt; 对应于 Go 中的 &lt;code&gt;pprof/goroutine&lt;/code&gt;，可以比较方便地排查进程卡死的问题。&lt;/p&gt;&lt;p&gt;通过执行 jstack pid，即可输出目标进程中所有线程的线程 id 和堆栈信息。输出中默认只有 Java 堆栈，如果希望同时输出 JVM 中的 C++ 堆栈，需要加 &lt;code&gt;-m&lt;/code&gt; 选项。&lt;/p&gt;&lt;p&gt;通过多次 jstack 可以方便地发现卡死问题（比如：都通过 &lt;code&gt;Mybatis BatchExecutor flush&lt;/code&gt; 调用 update）或死锁问题（比如：测试程序都在抢占应用中某把锁导致没发送 SQL）&lt;/p&gt;&lt;p&gt;另外，&lt;code&gt;top -p $PID -H&lt;/code&gt; 或者 Java swiss knife 都是常用的查看线程 ID 的方法。通过 &lt;code&gt;printf &amp;#34;%x\n&amp;#34; pid&lt;/code&gt; 把线程 ID 转换成 16 进制，然后去 jstack 输出结果中找对应线程的栈信息，可以定位“某个线程占用 CPU 比较高，不知道它在执行什么”的问题。&lt;/p&gt;&lt;h3&gt;2. jmap &amp;amp; mat&lt;/h3&gt;&lt;p&gt;和 Go 中的 &lt;code&gt;pprof/heap&lt;/code&gt; 不同，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;jmap&lt;/a&gt; 会将整个进程的内存快照 dump 下来（go 是分配器的采样），然后可以通过另一个工具 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.eclipse.org/mat/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;mat&lt;/a&gt; 做分析。&lt;/p&gt;&lt;p&gt;通过 mat 可以看到进程中所有对象的关联信息和属性，还可以观察线程运行的状态。比如：我们可以通过 mat 找到当前应用中有多少 MySQL 连接对象，每个连接对象的地址和状态信息是什么。&lt;/p&gt;&lt;p&gt;需要注意 mat 默认只会处理 reachable objects，如果要排查 young gc 问题可以在 mat 配置中设置查看 unreachable objects。另外对于调查 young gc 问题（或者大量生命周期较短的对象）的内存分配，用 Java Flight Recorder 比较方便。&lt;/p&gt;&lt;h3&gt;3. trace&lt;/h3&gt;&lt;p&gt;线上应用通常无法修改代码，又希望在 Java 中做动态插桩来定位问题，推荐使用 btrace 或 arthas trace。它们可以在不重启进程的情况下动态插入 trace 代码。&lt;/p&gt;&lt;h3&gt;4. 火焰图&lt;/h3&gt;&lt;p&gt;Java 应用中获取火焰图较繁琐，可参阅 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//psy-lob-saw.blogspot.com/2017/02/flamegraphs-intro-fire-for-everyone.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Java Flame Graphs Introduction: Fire For Everyone!&lt;/a&gt; 来手动获取。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;本文从常用 Java 数据库交互组件的角度，阐述了开发 Java 应用程序使用 TiDB 的常见问题与解决办法。TiDB 是高度兼容 MySQL 协议的数据库，基于 MySQL 开发的 Java 应用的最佳实践也多适用于 TiDB。如果大家在使用上遇到了任何问题，可以在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//asktug.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;asktug.com&lt;/a&gt; 提问，也欢迎更多小伙伴和我们一起分享讨论 Java 应用使用 TiDB 的实践技巧。&lt;/p&gt;&lt;p&gt;&lt;b&gt;原文阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/best-practice-java/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 最佳实践系列（五）Java 数据库应用开发指南 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;b&gt;更多 TiDB 最佳实践：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/%23%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Blog-cns | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-11-06-90525429</guid>
<pubDate>Wed, 06 Nov 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>让数据库运行在浏览器里？TiDB + WebAssembly 告诉你答案</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-11-05-90220611.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90220611&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7d68fa08c72276205787fcd7d331c30c_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;一直以来都有个梦想：&lt;/p&gt;&lt;p&gt;希望有一个数据库能够弹性扩展（分布式）到成百上千节点的规模，易于学习和理解，可以运行在私有云、公有云、Multi-Cloud、Kubernetes，也能够跑在嵌入式设备（比如树莓派）上，更酷的是也能够直接运行在浏览器里，而且不需要任何浏览器扩展（Extension），变成「口袋数据库」，就像那部电影《蚁人》。&lt;/p&gt;&lt;p&gt;&lt;b&gt;今天，这一切都变成了现实：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB&lt;/a&gt;&lt;/b&gt; &lt;b&gt;可以直接运行在浏览器本地。打开浏览器，你可以直接创建数据库，对数据进行增删改查。关掉浏览器，一切都消失了，干净绿色环保——&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先在笔记本浏览器打开 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//play.pingcap.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;play.pingcap.com&lt;/a&gt;（这里用的是 MacOS 上面的 Chrome，不确定其它浏览器是否正常），可能需要几秒来加载页面，然后就能看到熟悉的 Shell 了。现在来试试几个 SQL 语句吧！由于 TiDB 基本兼容 MySQL 协议和语法，因此我们可以用熟悉的 MySQL 风格操作，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-34e6c30d1e69efb02f60f061123ae7b9_b.gif&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1102&quot; data-rawheight=&quot;857&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-34e6c30d1e69efb02f60f061123ae7b9_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1102&quot; data-original=&quot;https://pic2.zhimg.com/v2-34e6c30d1e69efb02f60f061123ae7b9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-34e6c30d1e69efb02f60f061123ae7b9_b.gif&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1102&quot; data-rawheight=&quot;857&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-34e6c30d1e69efb02f60f061123ae7b9_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1102&quot; data-original=&quot;https://pic2.zhimg.com/v2-34e6c30d1e69efb02f60f061123ae7b9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-34e6c30d1e69efb02f60f061123ae7b9_b.gif&quot;/&gt;&lt;figcaption&gt;图 1 在浏览器上运行 TiDB&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;是不是很酷？无痛体验 SQL 的时代到了。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;更酷的是，这一切都运行在浏览器本地，删库再也不用跑路了 😈&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有了这些，那么是时候给在线学习 SQL 教程的网站加点功能了，比如在文字教程时，同步运行 SQL 语句。这里有个简单的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tour.pingcap.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;演示&lt;/a&gt;：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-67c0e240e9fcadbf1659fd1ec71de08c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1999&quot; data-rawheight=&quot;775&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1999&quot; data-original=&quot;https://pic1.zhimg.com/v2-67c0e240e9fcadbf1659fd1ec71de08c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-67c0e240e9fcadbf1659fd1ec71de08c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1999&quot; data-rawheight=&quot;775&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1999&quot; data-original=&quot;https://pic1.zhimg.com/v2-67c0e240e9fcadbf1659fd1ec71de08c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-67c0e240e9fcadbf1659fd1ec71de08c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2 SQL 教程网站演示&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;那么在浏览器里面运行数据库还有哪些好处呢？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;还记得你安装配置数据库的痛苦吗？从此以后，每个人随时随地都可以拥有一个数据库，再也没有痛苦的安装过程，再也不用痛苦的配置参数，随时享受写 SQL 的快感。也许我们不再需要 indexdb 了，SQL 是更高级的 API，TiDB 使得「一次编写、到处运行」变成了现实。&lt;/p&gt;&lt;p&gt;当然，你一定很好奇这一切是怎么实现的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先要感谢 Go team 让 Go 语言支持了 WebAssembly（Wasm），这是近期最让我兴奋的特性之一，它让在浏览器里运行 Go 语言编写的应用程序成为了现实；&lt;/li&gt;&lt;li&gt;然后感谢 PingCAP 的开源分布式数据库 TiDB。我们把 TiDB 编译成 Wasm，在浏览器里直接运行生成的 Wasm 文件，这就使得在浏览器里运行一个数据库成为了现实。如果没有记错，TiDB 好像是 Go 语言编写的第一个可以在浏览器里面运行的 SQL 数据库；&lt;/li&gt;&lt;li&gt;特别感谢参加 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/presentations/blob/master/hackathon-2019/hackathon-2019-projects.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Hackathon 2019&lt;/a&gt; 的选手和大家各种有趣的想法，尤其感谢 Ti-cool 团队，在他们的努力下这一切变成了现实，该项目获得了 Hackathon 二等奖，现场评委团老师们也感到眼前一亮，对它的快速落地充满了期待！​&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;“TiDB-Wasm 极大降低了用户体验 TiDB 能力和初步验证 SQL 兼容性的门槛，使用体验就像 golang playground 一样流畅，Wasm 的出现也为 TiDB 文档中心的建设提出了新的思路，也许不久的将来，TiDB 用户可以像 golang 一样，在阅读文档的同时，就能够在页面上尝试实际操作的体验。我们也期待 Wasm 能够持续发展，实现 TiKV 的沙箱化运行，提供更贴近真实运行场景的 playground，甚至在自动化运维管理方向上贡献更新奇思路。”&lt;br/&gt;——李凯（美团 | 数据库团队负责人）&lt;br/&gt;“刚看到这个项目的时候真的眼前一亮，这是一个非常酷的创意，而且真的对 DBA 运维管理 TiDB 有非常大的帮助，个人强烈希望这个项目能尽快落地支持！&lt;br/&gt;目前我们公司使用 TiDB 时，有很大一部分是由现在业务改造接入，但是面临的一个很重要的问题是 应用原来都是基于 MySQL 开发，虽然 TiDB 在 SQL 语法兼容上做了很多的工作，但是仍然未能 100% 覆盖，所以业务切换前我们都必须要进行 SQL 语法兼容性测试及数据准确性校验。由于 TiDB 的部署都是在线上服务器，基于数据安全，我们的生产和办公网环境是隔离的，要实现上面的需求，目前我们有如下几种方式：a) 研发同学自己写脚本连接查看；b)DBA 登录集群协助验证；c)开发专用查询平台支持。目前这这几种方式都不够安全且效率低下。随着我们维护的 TiDB 集群越来越多，DBA 的对这种低效工作不堪其烦，急需相关工具支持，而 TiDB-Wasm 无疑会解决这种问题，所以希望官方能够重视这个项目，并尽快落地实现。”&lt;br/&gt;——于伯伟（58集团 | 数据库高级经理）&lt;br/&gt;“Wasm 是一个神奇的技术，也许诞生初期的目的只是为了解决 js 运行速度以及其他语言如何操作 html 的问题，但现在大家在用这种技术广泛尝试各种可能。TiDB-Wasm 就是一个很好的尝试，不仅大幅度降低了新人使用 TiDB 的难度、也给文档展示提供了神奇的操作环境、还能大幅度降低应用开发者本机调试环境的构建难度。相信这个思路能给其他服务端的软件一个很好的启发。”&lt;br/&gt;——李道兵（京东云 | 高级总监）&lt;br/&gt;“很多用户希望初步了解 TiDB 但是苦于找不到简单即用的线下环境，这导致他们还未入门就已经放弃。TiDB-Wasm 有望彻底解决这个问题。基于 TiDB-Wasm，用户可以方便的开启 session 来探索 TiDB 的特性和功能，调试 TiDB 的行为，以及对比 TiDB 与 MySQL 等数据库在 SQL 语法、加锁行为、事务隔离等级等细节上的差异，从而帮助用户更深入的理解 TiDB。对官方而言，甚至可以把路由、计算、存储层的扩容缩容、迁移等最佳实践集成到该平台并可视化该过程，从而给用户更真实、直观的感受。这将是一款令人激动的产品，它将促进 TiDB 社区更加繁荣，也将让所有 TiDB 用户受益！”&lt;br/&gt;——赵应钢（美团点评 | 分布式数据库平台开发和运维负责人，研究员）&lt;br/&gt;“TiDB-Wasm 这个项目成功地将 TiDB 移植到了 Wasm，证明了 TiDB 编译到 Wasm 的可行性，同时也反映了 WebAssembly 已走向成熟，相信后面会有更多项目移植到浏览器里运行。目前项目还处于 demo 阶段，后续如果将项目继续落地，在上面添加更多功能，比如使用 indexedDB 让数据持久化，比如使用 webrtc 之类的技术让不同浏览器中的 TiDB 可以进行 P2P 通讯，实现分布式浏览器数据库，我非常期待这些实现。”&lt;br/&gt;——侯圣文（贝壳找房 | 数据技术总监）&lt;br/&gt;“TiDB-Wasm 让我看到了 TiDB 的更多可能性。Wasm 本身是一个很有野心和想象力的技术，极大的扩展了前端的能力，可能大家都玩过类似 go playgound, rust playground 这类 web 的可交互体验平台，TiDB-Wasm 更进一步让用户甚至在离线环境下就能直接体验，可谓最极致的易用。从实用角度上来看，除了能成为一个浏览器中的 REPL 供配合文档快速体验和实验之外，TiDB-Wasm 甚至未来还可以作为 js 的 localStorage API 的很好的补充，为 js 生态提供一个 SQLite 之外的高性能本地数据库……当然，在体验上仍然有很多可以优化的地方，例如给 binary 瘦身，加入集群模式支持等。总体来说这是一个很好玩的项目。”&lt;br/&gt;——黄东旭（PingCAP | 联合创始人兼 CTO）&lt;br/&gt;“这个项目可以说集新颖性和实用性于一身，用一种很巧妙的方式，将数据库这样硬核的基础架构和炫酷的前端领域搭上关系，接下来二者就可以碰撞出各种火花。最直接的用法是大大降低用户体验 TiDB 的成本，只需要一个浏览器页面和等待下载 Binary 的时间，完全不需要安装部署，就可以体验 TiDB 基本的功能，无论是嵌入到文档中快速运行实例还是作为 Playgroud 网站让用户自由发挥，都非常合适。再扩展想一下，TiDB 可以看作 MySQL 的替代品，那么很多 MySQL 的教学网站也可以用这个 Wasm 来提升教学体验。当然，Demo 中演示的 SQL 教学只是最基本的玩法，有了这个东西，我们可以说：恭喜前端圈有了一个 JS 版本的 MySQL。相信前端的同学能把它玩出花来。一句话总结：这绝对是一个叫好又叫座的项目。”&lt;br/&gt;——申砾（PingCAP | Engineering VP）&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;接下来我们可以试试更多有趣的想法：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;让更多的在线 SQL 教程都可以直接运行。&lt;/li&gt;&lt;li&gt;让 TiDB 运行在 Go Playground 上，或许需要 Go team 的帮助。&lt;/li&gt;&lt;li&gt;支持持久化数据库，我们已经有了云计算、边缘计算，为什么不能有浏览器计算呢？&lt;/li&gt;&lt;li&gt;……&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;还有好多想法我们将在接下来的文章里介绍。如果你有新的、有趣的想法，欢迎 &lt;a href=&quot;mailto:info@pingcap.com&quot;&gt;联系我们&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;下一篇文章将由 Ti-cool 团队成员介绍整个项目的实现原理和后续改进工作，敬请期待！如果你已经等不及了，可以在这里直接看&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/13069&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;源码实现&lt;/a&gt;，祝大家玩得开心！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;原文阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-in-the-browser-running-a-golang-database-on-wasm/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;浏览器上可以运行数据库吗？TiDB + WebAssembly 告诉你答案 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-11-05-90220611</guid>
<pubDate>Tue, 05 Nov 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>无挑战，不 Geek！TiDB 性能挑战赛等你来战</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-11-05-90168854.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90168854&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-17a41d3e444d858568145b12bed95061_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;如果说，人类进化动力源于挑战：&lt;/p&gt;&lt;p&gt;想突破速度，于是从太空飞行追逐到量子世界；&lt;/p&gt;&lt;p&gt;想追求稳定，于是在万变之中，求不变之道；&lt;/p&gt;&lt;p&gt;想打破繁复，于是用 1 台智能手机集成 N 种必需品，大道至简……&lt;/p&gt;&lt;p&gt;那么，&lt;b&gt;挑战充满不确定性的未来，就是 TiDB 这款开源产品的不断进化的内在基因&lt;/b&gt;——如何做到更好的性能、更强的稳定性、更惊人的易用性？这也是 Geek 聚集的 TiDB 社区不断前进的指引。&lt;/p&gt;&lt;p&gt;无挑战，不 Geek。相信在上周举办 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.%3C/u%3Eweixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247490046%26idx%3D1%26sn%3D962bb8aa4619c3815fcc561ed96331d7%26chksm%3Deb163e94dc61b7826b7e73a057f4c9823261c1a79005104dd41dbd6ef4276c01bd6e41a69d14%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Hackathon 2019 &lt;/a&gt;上，大家已经在短短两天里领略了 TiDB 社区伙伴们的 Geek 精神，促成了很多优秀项目的诞生。&lt;b&gt;为了进一步激发社区的创造性，我们将开启 TiDB Challenge Program&lt;/b&gt;，这是一场从 Easy 到 Hard 的升级“打怪”竞赛，第一赛季将持续 3 个月，比赛过程中获得积分还可以兑换丰厚的礼品。万事俱备，就等各位来战！&lt;/u&gt;&lt;/p&gt;&lt;p&gt;TiDB Challenge Program 由 PingCAP 发起，旨在激发社区创造性，使选手可以通过完成一系列的任务提升 TiDB 产品的稳定性、性能和易用性。&lt;b&gt;第一赛季主题为 Performance Improvement&lt;/b&gt;，将于 2019 年 11 月 4 日正式开启，赛事持续 3 个月。选手可选择个人或团队名义参赛完成任务并获得相应积分。积分可在赛季结束后进行奖项兑换。&lt;/p&gt;&lt;p&gt;欢迎大家加入&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//join.slack.com/t/tidbcommunity/shared_invite/enQtNzc0MzI4ODExMDc4LWYwYmIzMjZkYzJiNDUxMmZlN2FiMGJkZjAyMzQ5NGU0NGY0NzI3NTYwMjAyNGQ1N2I2ZjAxNzc1OGUwYWM0NzE&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Community Slack Workspace&lt;/a&gt;和&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//tikv.org/chat&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;tikv-wg Slack Workspace&lt;/a&gt;，参赛过程中遇到任何问题都可以直接通过&lt;b&gt;#performance-challenge-program&lt;/b&gt;channel 与我们取得联系。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Highlights&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;从 Easy 到 Hard&lt;/b&gt;&lt;/p&gt;&lt;p&gt;本次大赛项目采用分级制度，充分照顾入门选手的「Easy」模式降低了参赛门槛，让 TiDB 小白也能快速上手。每个项目对应一定的积分，当选手累计到一定积分后可解锁「Medium」与「Hard」模式，犹如升级打怪般攻克重重障碍，成就感爆棚！&lt;/p&gt;&lt;p&gt;&lt;b&gt;大咖导师&lt;/b&gt;&lt;/p&gt;&lt;p&gt;针对「Medium」和「Hard」 类型的任务，我们设有专门的导师。参赛者可通过 Slack Channel 就代码实现过程中遇到的问题进行沟通，保证选手的参赛体验。&lt;/p&gt;&lt;p&gt;&lt;b&gt;丰厚奖品&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们为大家准备了丰富的奖品，使用完赛项目的积分即可兑换&lt;b&gt;（数量有限，先到先得哦）&lt;/b&gt;～&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f7e5f8f91a98fd943abdbf5b8523acf_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f7e5f8f91a98fd943abdbf5b8523acf_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f7e5f8f91a98fd943abdbf5b8523acf_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;606&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f7e5f8f91a98fd943abdbf5b8523acf_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1f7e5f8f91a98fd943abdbf5b8523acf_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;参赛细则&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;赛前准备&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/join&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Join GitHub&lt;/a&gt; 完成 GitHub 账号的创建。&lt;/li&gt;&lt;li&gt;参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//git-scm.com/book/en/v2/Getting-Started-Installing-Git&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Installing Git&lt;/a&gt; 在本地环境中安装 Git。&lt;/li&gt;&lt;li&gt;通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//help.github.com/en/github/getting-started-with-github/set-up-git&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Set up Git&lt;/a&gt; 配置 Git 访问 GitHub。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;报名&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;报名方式： &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tidb-perf-challenge/pcp/issues/new%3Ftemplate%3Dperformance-challenge-program.md%26title%3DPCP%253A%2BSign%2BUp&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;发起 Issue&lt;/a&gt; 至 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tidb-perf-challenge/pcp&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;tidb-perf-challege/pcp&lt;/a&gt; repo&lt;/li&gt;&lt;li&gt;格式要求：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;标题：PCP/Sign Up&lt;/li&gt;&lt;li&gt;内容：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;个人参赛：请对你自己进行简要介绍，并留下可以与你取得联系的邮箱地址。&lt;/li&gt;&lt;li&gt;团队参赛：请对你的团队进行简要介绍，写明团队名称，每个团队成员的 GitHub ID，并留下可以与你们取得联系的邮箱地址。可参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tidb-perf-challenge/pcp/blob/master/.github/ISSUE_TEMPLATE/performance-challenge-program.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;示例&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;注意事项：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;以团队形式参赛，每队成员最多三人。&lt;/li&gt;&lt;li&gt;有 PingCAP 内部员工参与的队伍，将作为打星队伍，不参与积分总排名，所获积分仍具有兑换权益&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;参赛流程&lt;/h2&gt;&lt;p&gt;TiDB Performance Challenge Program 全流程包括：查看任务-&amp;gt;领取任务-&amp;gt;实现任务-&amp;gt;提交任务-&amp;gt;评估任务-&amp;gt;获得积分-&amp;gt;积分兑换，其中“获得积分”之前的步骤都将在 GitHub 上实现。&lt;/p&gt;&lt;h3&gt;第一步：查看 / 提出 Issue&lt;/h3&gt;&lt;p&gt;当前开放的 Issue 列表可分别在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/projects/26&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB-Performance Challenge Program Project&lt;/a&gt;、&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/projects/20&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiKV-Performance Challenge Program Project&lt;/a&gt;、&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/pd/projects/2&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PD-Performance Challenge Program Project&lt;/a&gt; 中的 TODO Columns 查看。&lt;/p&gt;&lt;p&gt;其中 TODO Columns 按照题目难易程度划分了 3 列，分别是：TODO/Easy、TODO/Medium、TODO/Hard。每一个 Issue 还设置了一些标签，为方便大家理解，现将 TiDB Performance Challenge 相关标签所代表含义做如下说明：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;“difficulty/easy”、“difficulty/medium”、“difficulty/hard”：Issue 难度级别。&lt;/li&gt;&lt;li&gt;“Component/XX”：Issue 所涉及的模块。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除了当前开放的 Issue，如果你有其他关于 &lt;b&gt;Performance Improvement&lt;/b&gt; 的想法想要实现，可通过发起 Issue 的方式提出 Proposal。发起 Issue 之前请确保你已经了解了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/community/blob/master/CONTRIBUTING.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Contribution Guide&lt;/a&gt; 和 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/community/blob/master/CODE_OF_CONDUCT.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Contributor Covenant Code of Conduct&lt;/a&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;TiDB 相关 Proposal 可通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/issues/new%3Flabels%3Dtype%252Fenhancement%26template%3Dfeature-request.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Issue 发起通道&lt;/a&gt; 提交至 TiDB Repo；&lt;/li&gt;&lt;li&gt;TiKV 相关 Proposal 可通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/issues/new%3Ftemplate%3Dfeature-request.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiKV Issue 发起通道&lt;/a&gt; 提交至 TiKV Repo；&lt;/li&gt;&lt;li&gt;PD 相关 Proposal 可通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/pd/issues/new%3Flabels%3Dtype%252Fenhancement%26template%3Dfeature-request.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PD Issue 发起通道&lt;/a&gt; 提交至 PD Repo。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;格式要求：Issue 标题前需添加“&lt;b&gt;REQ-PCP&lt;/b&gt;”标记，例如：REQ-PCP: Further extract tidb_query into different workspaces。&lt;/p&gt;&lt;h3&gt;第二步：领取任务&lt;/h3&gt;&lt;p&gt;如果你决定认领某一个 Issue，请先在这个 Issue 中回复 &lt;b&gt;“/pick-up-challenge”&lt;/b&gt;， 后台将自动判断你所拥有的积分是否具备挑战此 Issue 的资格，积分满足要求即可开始挑战，积分不满足要求，需按照系统提示获得满足挑战要求的积分。&lt;/p&gt;&lt;p&gt;&lt;b&gt;需要特别提醒的是：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每个参赛主体（含个人及团队）参与 TiDB 性能挑战赛的&lt;b&gt;初始积分为 0&lt;/b&gt;，需要先完成 “Easy” 的 Issue 将积分积累至 400 分以上（含 400 分），才有资格挑战难度为“Medium”和“Hard”的题目。&lt;/li&gt;&lt;li&gt;每个参赛主体一次只能领取一个任务。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;第三步：实现代码&lt;/h3&gt;&lt;p&gt;在实现代码的过程中如果遇到问题，可以通过 &lt;b&gt;#performance-challenge-program&lt;/b&gt; channel 与我们进行探讨，Issue 指定的 Mentor 会尽可能在 24h 内予以回复。不过，在提出问题之前一定要确保你已经仔细阅读过题目内容并且已经完成了参考资料的学习哦～&lt;/p&gt;&lt;h3&gt;第四步：提交代码&lt;/h3&gt;&lt;p&gt;如果你觉得你的方案已经达到了题目的要求，可在相关 Repo（例如 tidb）的 master 分支上实现你的方案，并将代码以 GitHub Pull Request（简称 PR）的形式提交到相应的 GitHub Repo 上。当 PR 提交后，可在 PR 的评论中 at 该题目的 Mentor 进行代码评审，Mentor 会尽可能在方案提交后的 48h 内完成评估。&lt;/p&gt;&lt;p&gt;注：提交的 PR 需要满足 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/community/blob/master/commit-message-pr-style.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Commit Message and Pull Request Style&lt;/a&gt; 中定义的规范。&lt;/p&gt;&lt;p&gt;提交方式：代码完成后，参赛者需提交 GitHub Pull Request(PR) 到相应 Repo，如何提交 PR 可参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/community/blob/master/contributors/workflow.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub Workflow&lt;/a&gt;，这里也有一些 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/community/blob/master/contributors/command-help.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SRE-BOT Command Help&lt;/a&gt; 供大家参考。&lt;/p&gt;&lt;p&gt;格式要求：PR 的第一行需要指定任务 Issue 的编号，再写每个 repo 要求的格式，示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;PCP #12345
 
&amp;lt;!-- The following description --&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;第五步：代码评估及积分授予&lt;/h3&gt;&lt;p&gt;评估规则：PR Reviewer 会对 PR 进行代码格式、代码功能和性能的 Review，获得 2 个以上 Reviewer 认可（即在 PR 中评论 “LGTM”）的 PR 将会被 merge 到对应 repo 的主干。&lt;/p&gt;&lt;p&gt;如果你的 PR 被 Merge 到主干，那么就意味着该题目被你挑战成功，你将获得该题目对应的积分；其他参赛选手将失去对该题目的挑战资格，已经提交的 PR 也会被 Close。&lt;/p&gt;&lt;p&gt;否则，你需要继续和 PR 的 Reviewer 探讨实现方案和细节，合理的接受或者拒绝 Reviewer 对 PR 的评审建议。&lt;/p&gt;&lt;h3&gt;第六步：积分兑换&lt;/h3&gt;&lt;p&gt;积分获得情况将会在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/tidb-performance-challenge/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 性能挑战赛官方网站&lt;/a&gt; 呈现。所获积分可兑换礼品或奖金，礼品包括但不限于：TiDB 限量版帽衫、The North Face 定制电脑双肩包等。&lt;/p&gt;&lt;p&gt;兑换时间：&lt;b&gt;每个赛季结束后至下一赛季结束前&lt;/b&gt;可进行积分兑换，下一个赛季结束时，前一赛季的可兑换积分将直接清零，不可再进行社区礼品兑换。&lt;/p&gt;&lt;p&gt;兑换方式：本赛季结束后填写礼品兑换表（届时将开放填写权限）。&lt;/p&gt;&lt;h2&gt;学习资料&lt;/h2&gt;&lt;p&gt;这里有 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/presentations/blob/master/hackathon-2019/reference-document-of-hackathon-2019.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 精选技术讲解文章&lt;/a&gt;，帮助大家轻松掌握 TiDB 各核心组件的原理及功能；还有 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//university.pingcap.com/%3Fdiliater%3D6YvzZjyL97Z5c4G09GRzLQ%3D%3D&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PingCAP University&lt;/a&gt; 在线视频课程，帮助大家快速熟悉 TiDB 原理、架构及最佳实践，点击以上链接即可轻松获取。&lt;/p&gt;&lt;p&gt;这将是一次集体智慧的碰撞，我们期待着与社区小伙伴一起创造无限可能！&lt;/p&gt;&lt;p&gt;更多详情：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/tidb-performance-challenge/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt; | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-11-05-90168854</guid>
<pubDate>Tue, 05 Nov 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>TiKV 源码解析系列文章（十四）Coprocessor 概览</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-10-31-89518391.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/89518391&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-20f8a3ce333d33a342041949f11ab72d_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：Shirly&lt;/p&gt;&lt;p&gt;本文将简要介绍 TiKV Coprocessor 的基本原理，面向想要了解 TiKV 数据读取执行过程的同学，同时也面向想对该模块贡献代码的同学。阅读本文前，建议读者对 TiDB 整体架构有所了解，先阅读三篇文章了解 TiDB 技术内幕：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-internal-1/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;说存储&lt;/a&gt;、&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-internal-2/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;说计算&lt;/a&gt;、&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-internal-3/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;谈调度&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;什么是 Coprocessor&lt;/h2&gt;&lt;p&gt;熟悉 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/overview/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 整体框架&lt;/a&gt; 的同学可能记得，TiDB 是无状态的，数据存储在 TiKV 层。当 TiDB 在收到一个来自客户端的查询请求时，会向 TiKV 获取具体的数据信息。那么一个读请求最朴素的处理过程如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aa3dee0694dd1c0d14dc9e380e154ec2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;516&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-aa3dee0694dd1c0d14dc9e380e154ec2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aa3dee0694dd1c0d14dc9e380e154ec2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;516&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-aa3dee0694dd1c0d14dc9e380e154ec2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-aa3dee0694dd1c0d14dc9e380e154ec2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先需要肯定的是这种方式固然能解决问题，但是性能如何呢？我们来一起分析一下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;TiKV  将所有数据返回，网络开销太大。&lt;/li&gt;&lt;li&gt;TiDB 需要计算所有数据，CPU 消耗很大，相对的，TiKV 却并没有什么计算，很闲。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;看到以上问题后，聪明如你，可能很容易就想到，能不能让 TiKV 把自己负责的那部分数据做一次计算，再返回给 TiDB 呢？&lt;/p&gt;&lt;p&gt;有何不可呢？&lt;/p&gt;&lt;p&gt;TiKV 读取数据并计算的模块，我们定义为 Coprocessor，该概念灵感来自于 HBase，目前在 TiDB 中的实现类似于 HBase 中的 Coprocessor 的 Endpoint 部分，也可类比 MySQL 存储过程。&lt;/p&gt;&lt;p&gt;有了 Coprocessor 后，从宏观看一个读请求是如何下发到 TiKV 的呢？以下面的请求为例：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5182af7a6ac373f61670d3a75f74fbad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;704&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-5182af7a6ac373f61670d3a75f74fbad_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5182af7a6ac373f61670d3a75f74fbad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;704&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-5182af7a6ac373f61670d3a75f74fbad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5182af7a6ac373f61670d3a75f74fbad_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如图，以上查询语句在 TiDB 中处理如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;TiDB 收到查询语句，对语句进行分析，计算出物理执行计划，组织称 TiKV 的 Coprocessor 请求。&lt;/li&gt;&lt;li&gt;TiDB 将该 Coprocessor 请求根据数据的分布，分发到所有相关的 TiKV 上。&lt;/li&gt;&lt;li&gt;TiKV 在收到该 Coprocessor 请求后，根据请求算子对数据进行过滤聚合，然后返回给 TiDB。&lt;/li&gt;&lt;li&gt;TiDB 在收到所有数据的返回结果后，进行二次聚合，并将最终结果计算出来，返回给客户端。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;主要功能及处理概览&lt;/h2&gt;&lt;p&gt;TiKV Coprocessor 处理的读请求目前主要分类三种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;DAG：执行物理算子，为 SQL 计算出中间结果，从而减少 TiDB 的计算和网络开销。这个是绝大多数场景下 Coprocessor 执行的任务。&lt;/li&gt;&lt;li&gt;Analyze：分析表数据，统计、采样表数据信息，持久化后被 TiDB 的优化器采用。&lt;/li&gt;&lt;li&gt;CheckSum：对表数据进行校验，用于导入数据后一致性校验。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么 TiKV 在收到 Coprocessor 请求后，何时区分这三种请求的呢？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0b450b6d1c6e8acbc44cd91a5d38e934_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;441&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-0b450b6d1c6e8acbc44cd91a5d38e934_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0b450b6d1c6e8acbc44cd91a5d38e934_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;441&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-0b450b6d1c6e8acbc44cd91a5d38e934_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-0b450b6d1c6e8acbc44cd91a5d38e934_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;请求到了 TiKV 层，处理过程如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;由 gRPC server 接收并将请求分发给 Coprocessor Endpoint 进行处理。&lt;/li&gt;&lt;li&gt;Endpoint 在收到请求后，根据请求的优先级，将请求分发给对应的线程池。&lt;/li&gt;&lt;li&gt;所有请求会先异步从存储层获取 snapshot，然后开始真正的处理阶段。&lt;/li&gt;&lt;li&gt;根据请求的不同类型，构造不同的 Handler 进行数据的处理。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;目前 Coprocessor 支持的三种接口中，后面两种接口相对比较简单，而 DAG 是里面最复杂也是最常用的，所以本文后续将重点介绍 DAG 类请求。&lt;/p&gt;&lt;h2&gt;DAG Request 概览&lt;/h2&gt;&lt;p&gt;DAG 顾名思义，是由一系列算子组成的有向无环图，算子在代码中称为 Executors。&lt;/p&gt;&lt;p&gt;目前 DAG 请求主要实现了两种计算模型：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;火山模型：每个算子按行按需吐出，3.0 之后开始弃用。&lt;/li&gt;&lt;li&gt;向量化计算模型：每个算子批量化处理数据，3.0 之后开始推广。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在目前的 TiKV master 上，处于火山模型向向量化模型的过度阶段，因而两种计算模型同时存在。TiKV 收到请求时，会优先检测是否可走向量化模型，若部分功能在向量化模型中没有实现，则走旧的计算模型，具体处理逻辑流程如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e8396857c846de7980df121bb3b1f9c8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;474&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-e8396857c846de7980df121bb3b1f9c8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e8396857c846de7980df121bb3b1f9c8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;474&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-e8396857c846de7980df121bb3b1f9c8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e8396857c846de7980df121bb3b1f9c8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;相关代码在：&lt;code&gt;src/coprocessor/dag/mod.rs&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;因为火山模型已在被弃用中，所以下文我们只讲向量化计算模型。&lt;/p&gt;&lt;h2&gt;算子概览&lt;/h2&gt;&lt;p&gt;在向量化计算模型中，所有算子都实现了 &lt;code&gt;BatchExecutor&lt;/code&gt;接口，其主要定义了一个 &lt;code&gt;get_batch&lt;/code&gt; 的函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pub trait BatchExecutor: Send {
   fn next_batch(&amp;amp;mut self, scan_rows: usize) -&amp;gt; BatchExecuteResult;
}

pub struct BatchExecuteResult {
   pub physical_columns: LazyBatchColumnVec,
   pub logical_rows: Vec&amp;lt;usize&amp;gt;,
   pub is_drained: Result&amp;lt;bool, Error&amp;gt;,
   ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参数说明：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;next_batch&lt;/code&gt; 中 &lt;code&gt;scan_rows&lt;/code&gt; 由上层控制，由于扫的数据过多会慢，因此该数字从 32 倍增到 1024。&lt;/li&gt;&lt;li&gt;返回值 &lt;code&gt;BatchExecuteResult&lt;/code&gt; 中，由于返回了一批空数据不代表所有数据都处理完毕了，例如可能只是全被过滤，因而使用单独字段表示所有数据处理完毕。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;目前 TiKV 支持的算子主要有以下几类。&lt;/p&gt;&lt;h3&gt;TableScan&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;定义：根据指定主键范围扫表数据，并过滤出一部分列返回。它只会作为最底层算子出现，从底层 KV 获取数据。&lt;/li&gt;&lt;li&gt;源码路径：&lt;code&gt;components/tidb_query/src/batch/executors/table_scan_executor.rs&lt;/code&gt;&lt;/li&gt;&lt;li&gt;案例：&lt;code&gt;select col from t&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;IndexScan&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;定义：根据指定索引返回扫索引数据，并过滤出一部分索引列返回。它只会作为最底层算子出现，从底层 KV 获取数据。&lt;/li&gt;&lt;li&gt;源码路径：&lt;code&gt;components/tidb_query/src/batch/executors/index_scan_executor.rs&lt;/code&gt;&lt;/li&gt;&lt;li&gt;案例：&lt;code&gt;select index from t&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Selection&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;定义：对底层算子的结果按照过滤条件进行过滤，其中这些条件由多个表达式组成。&lt;/li&gt;&lt;li&gt;源码路径：&lt;code&gt;components/tidb_query/src/batch/executors/selection_executor.rs&lt;/code&gt;&lt;/li&gt;&lt;li&gt;案例：&lt;code&gt;select col from t where a+b=10&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9537e60316ef13101e74f7c99b008f0c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;177&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-9537e60316ef13101e74f7c99b008f0c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9537e60316ef13101e74f7c99b008f0c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;177&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-9537e60316ef13101e74f7c99b008f0c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9537e60316ef13101e74f7c99b008f0c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;Limit&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;定义：从底层算子吐出的数据中，限定返回若干行。&lt;/li&gt;&lt;li&gt;源码路径：&lt;code&gt;components/tidb_query/src/batch/executors/limit_executor.rs&lt;/code&gt;&lt;/li&gt;&lt;li&gt;案例：&lt;code&gt;select col from t limit 10&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a86af3a75066450b0f1f2ffd99d742cd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;241&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a86af3a75066450b0f1f2ffd99d742cd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a86af3a75066450b0f1f2ffd99d742cd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;241&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a86af3a75066450b0f1f2ffd99d742cd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a86af3a75066450b0f1f2ffd99d742cd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;TopN&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;定义：按照给定表达式进行排序后，取出前若干行数据。&lt;/li&gt;&lt;li&gt;源码路径：&lt;code&gt;components/tidb_query/src/batch/executors/top_n_executor.rs&lt;/code&gt;&lt;/li&gt;&lt;li&gt;案例：&lt;code&gt;select col from t order by a+1 limit 10&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f81a619595326369d12d9259d1773b01_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;172&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-f81a619595326369d12d9259d1773b01_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f81a619595326369d12d9259d1773b01_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;172&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-f81a619595326369d12d9259d1773b01_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f81a619595326369d12d9259d1773b01_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;Aggregation&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;定义：按照给定表达式进行分组、聚合。&lt;/li&gt;&lt;li&gt;源码路径：&lt;code&gt;components/tidb_query/src/batch/executors/*_aggr_executor.rs&lt;/code&gt;&lt;/li&gt;&lt;li&gt;案例： &lt;code&gt;select count(1) from t group by score + 1&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8669a7a532d4dae1e3ace722d3eb5a5c_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;133&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-8669a7a532d4dae1e3ace722d3eb5a5c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8669a7a532d4dae1e3ace722d3eb5a5c_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;133&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-8669a7a532d4dae1e3ace722d3eb5a5c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8669a7a532d4dae1e3ace722d3eb5a5c_b.png&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;混合使用各个算子&lt;/h3&gt;&lt;p&gt;综上，各个算子之间可以按照以下方式任意组合，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5c5b39a2ad24c059413f961ef11470dd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;905&quot; data-rawheight=&quot;524&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;905&quot; data-original=&quot;https://pic2.zhimg.com/v2-5c5b39a2ad24c059413f961ef11470dd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5c5b39a2ad24c059413f961ef11470dd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;905&quot; data-rawheight=&quot;524&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;905&quot; data-original=&quot;https://pic2.zhimg.com/v2-5c5b39a2ad24c059413f961ef11470dd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5c5b39a2ad24c059413f961ef11470dd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;案例：&lt;code&gt;select count(1) from t where age&amp;gt;10&lt;/code&gt; &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5b2a0a955e0c4051716a04f1118c7559_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;124&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-5b2a0a955e0c4051716a04f1118c7559_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5b2a0a955e0c4051716a04f1118c7559_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;124&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-5b2a0a955e0c4051716a04f1118c7559_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5b2a0a955e0c4051716a04f1118c7559_b.png&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;由于篇幅原因，本文只是讲了一些 Coprocessor 的概要，读者对此有个概念即可。后续我们将推出该模块相关的更多更深的源码细节分析，欢迎大家继续阅读并给出建设性的改进意见。&lt;/p&gt;&lt;p&gt;原文阅读：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tikv-source-code-reading-14/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiKV 源码解析系列文章（十四）Coprocessor 概览 | PingCAP&lt;/a&gt;&lt;p&gt;更多 TiKV 源码阅读：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/%23TiKV-%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E6%259E%2590&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Blog-cns | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-10-31-89518391</guid>
<pubDate>Thu, 31 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>据说今年黑客马拉松项目又多又猛？| TiDB Hackathon 回顾</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-10-31-89438349.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/89438349&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a1bf6fcf4f4d3255605d213ca373195b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;TiDB Hackathon 2019  在 10 月 27 日完美收官！北京、上海、广州三地共 &lt;b&gt;39 支队伍&lt;/b&gt;参赛，两天一夜的 Hacking Time，大家围绕着&lt;b&gt;「Improve」&lt;/b&gt;主题，为 TiDB 性能、易用性、稳定性、功能等各方面做出提升，最终 6 支队伍瓜分了一、二、三等奖的 15 万元现金奖励，另有 4 支队伍分获最佳贡献奖、最佳创意奖、最具潜力奖和 CTO 特别奖。&lt;br/&gt;&lt;b&gt;话说，本届 Hackathon 不管是从比赛的形式、规模，还是完赛项目的质量，相比去年可以说是颠覆性的提升。&lt;/b&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;项目超猛，Demo Show 超长&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;今年总共 39 支队伍参赛，几乎较去年翻倍。从质量来看，&lt;b&gt;优秀项目又多又猛&lt;/b&gt;，奖项角逐非常激烈，三地联动直播的 Demo Show 从下午 14:30 持续到 21:30（没看错，7 个小时），但是大家越看越兴奋——兴奋程度堪比看到编译完没有报错和 Warning 的电脑屏幕放几张（评委 Ed Huang&amp;#34;激动盗摄&amp;#34;的）PPT 大家随意感受一下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5a3d6e2b5f8e127ae04c64623c027efe_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic3.zhimg.com/v2-5a3d6e2b5f8e127ae04c64623c027efe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5a3d6e2b5f8e127ae04c64623c027efe_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic3.zhimg.com/v2-5a3d6e2b5f8e127ae04c64623c027efe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5a3d6e2b5f8e127ae04c64623c027efe_b.jpg&quot;/&gt;&lt;figcaption&gt;「Improve」不是说着玩儿的&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;经过紧张评选，评委团最终共评出了一、二、三等奖和最佳创意、最佳贡献、最佳潜力奖。由于奖项角逐太激烈，有很多优秀项目遗憾落选，我司 CTO 黄东旭现场临时增设了“CTO 特别奖” ，以下是全部获奖名单：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0428c4452cfad85a8e6a2288bc65ee45_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;834&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-0428c4452cfad85a8e6a2288bc65ee45_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0428c4452cfad85a8e6a2288bc65ee45_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;834&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-0428c4452cfad85a8e6a2288bc65ee45_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0428c4452cfad85a8e6a2288bc65ee45_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;再次恭喜各位获奖选手～🎉 &lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d55aec35ff71271514d24cc3889e39f5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1439&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-d55aec35ff71271514d24cc3889e39f5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d55aec35ff71271514d24cc3889e39f5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1439&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-d55aec35ff71271514d24cc3889e39f5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-d55aec35ff71271514d24cc3889e39f5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-80e31cd113b25356ab37cca5e3b3fcb8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;810&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-80e31cd113b25356ab37cca5e3b3fcb8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-80e31cd113b25356ab37cca5e3b3fcb8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;810&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-80e31cd113b25356ab37cca5e3b3fcb8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-80e31cd113b25356ab37cca5e3b3fcb8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这些项目深深刺激了大家的神经，小伙伴们看完 Demo Show 都开始了激烈的讨论、摩拳擦掌开始推动项目落地，而本届 Hackathon 导师、我司首席架构师唐刘老师，“开心到飞起”，火速写了一篇的点评文章（以下为节选内容）——&lt;/p&gt;&lt;p&gt;&lt;b&gt;一等奖项目：Unified Thread Pool&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个项目主要解决 TiKV 两个问题：1）线程池太多，频繁线程切换导致性能问题；2）大查询影响小查询问题。一开始我并不知道奕霖同学要挑战这个项目，看到的时候真的很震惊，毕竟之前我们内部尝试过几次，但都无疾而终。主要面临的困难是同一个线程池如何调度大小查询，包括大查询不能影响小查询，同时小查询的性能又要足够好。&lt;/p&gt;&lt;p&gt;奕霖同学参考 Linux 的 Schedule 算法，以及 Rust juliex 库，跟他同学一起完成了 Unified Thread Pool 的原型，实际的测试效果让我非常震惊，不光是纯 point select 性能有大量提升，在有大查询的情况下面，QPS 也能保持稳定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;二等奖项目：tidb-wasm&lt;/b&gt;&lt;/p&gt;&lt;p&gt;不得不说，这个是一个大杀器，它通过 wasm 技术，让 TiDB 能跑在浏览器上面，这个就很有意思了，我们可以很方便的做一个 TiDB Playground 出来，放到 PingCAP University（PU）这边，或者可以官网上嵌入，让用户直接尝试使用。这对于让用户快速的感受 TiDB 非常重要，可以说极大降低了用户了解 TiDB 的门槛，我个人非常期望这个项目能够落地。&lt;/p&gt;&lt;p&gt;&lt;b&gt;二等奖项目：TiDB 跨数据中心的解决方案&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个项目主要是解决跨 DC 情况下面 TiDB 的 latency 问题，主要从 Raft 层面来解决的。两个核心的思想：&lt;/p&gt;&lt;p&gt;1. Follower replication - 引入 raft sub-group 概念，将一些节点按照 DC 等属性进行分组，每个组里面有一个 delegate 节点，leader 只会跟这个 delegate 节点交互，由这个 delegate 节点将数据转发给这个 group 里面的其他节点。&lt;/p&gt;&lt;p&gt;2. 对于异地 follower read，并发的发送获取 TSO 以及 ReadIndex 的请求，减少一次 RTT。&lt;/p&gt;&lt;p&gt;这个项目我个人在开赛之前非常看好，后面果然拿了第二名的好成绩。&lt;/p&gt;&lt;p&gt;&lt;i&gt;……此处省略八千字长文点评，以上点评仅代表首架个人观点。&lt;/i&gt;&lt;/p&gt;&lt;blockquote&gt;总之这次完赛的项目质量都非常高，除了获奖项目之外，还有一些很有意义、实用性很强同时极具想象力的项目，我们非常希望这些项目都能在社区的维护下完善成熟～&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;评委老师好严肃，好认真&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;第二天大家吃完最后的午餐，就进入紧张的 Demo Show 环节了。评委团从项目的实用性/易用性/性能（40%）、完成度（30%）、创新性（20%）、展示度（10%），四个方面进行打分。由于项目一个比一个精彩，竞争非常激烈，评委老师们也卯足了劲，聚精会神地看每个细节，甚至用笔认真记下每个项目的优缺点。在选手演示结束后，评委老师们也随机提问，当然也不乏对项目完善方向的建议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-30bb33226f8a1f265083a39b366cbfd0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-30bb33226f8a1f265083a39b366cbfd0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-30bb33226f8a1f265083a39b366cbfd0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-30bb33226f8a1f265083a39b366cbfd0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-30bb33226f8a1f265083a39b366cbfd0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;尤其感谢美团数据库团队负责人&lt;b&gt;李凯&lt;/b&gt;，58 集团数据库高级经理&lt;b&gt;于伯伟&lt;/b&gt;，京东云高级总监&lt;b&gt;李道兵&lt;/b&gt;，美团点评分布式数据库平台开发和运维负责人、研究员&lt;b&gt;赵应钢&lt;/b&gt;，贝壳找房数据技术总监&lt;b&gt;侯圣文&lt;/b&gt;，五位老师认真负责的评审。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;分布式赛事保障&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然硬核的黑客马拉松少不了吃吃喝喝啦，为了保障北上广三地分布式赛事顺利，TiDB Robot 的分身们都拼了。希望所有参赛选手回忆起 2019 年参加过最好吃的马拉松，脑袋里会冒出 TiDB Robot 在会议室给大家摆自助大餐、小龙虾、披萨、啤酒的样子，毕竟 Robot 每顿都要在群里叉腰大喊：吃早饭啦，吃午饭啦，吃晚饭啦，趁热吃！还有夜宵零食随便吃！（都给我吃！）&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5594157428b4ae6372ca09622d86e135_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-5594157428b4ae6372ca09622d86e135_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5594157428b4ae6372ca09622d86e135_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-5594157428b4ae6372ca09622d86e135_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5594157428b4ae6372ca09622d86e135_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;不过最令 Robot 感到惊悚的事情莫过于，第二天早上看到一位同学头朝下，窝在沙发里，2 小时一动不动。Robot 心里咯噔了一下，静静观察了这位同学的呼吸起伏……（此处就不配图了）&lt;b&gt;大家都是通宵型选手，嗨起来其实都不用睡的……&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ffc7b4a0aa877407af75bc3b0935099a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic3.zhimg.com/v2-ffc7b4a0aa877407af75bc3b0935099a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ffc7b4a0aa877407af75bc3b0935099a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic3.zhimg.com/v2-ffc7b4a0aa877407af75bc3b0935099a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ffc7b4a0aa877407af75bc3b0935099a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;完赛项目合集，有你感兴趣的吗？&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-16758e456675d2cf9ac696384dce5411_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;2328&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-16758e456675d2cf9ac696384dce5411_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-16758e456675d2cf9ac696384dce5411_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;2328&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-16758e456675d2cf9ac696384dce5411_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-16758e456675d2cf9ac696384dce5411_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;以上是最后参与 Demo Show 的 37 个项目，不知有没有大家特别感兴趣的呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;为了社区小伙伴们都能参与进来，一起推动这些优秀项目的落地，我们将邀请部分参赛选手撰文，为大家深入介绍他们的项目设计思路、实现过程以及未来工作方向，敬请期待！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;* 完整项目介绍 &amp;amp; Repo 地址：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/presentations/blob/master/hackathon-2019/hackathon-2019-projects.md&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/pingcap/pres&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;entations/blob/master/hackathon-2019/hackathon-2019-projects.md&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;最后，&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;感谢 UCloud 提供云计算基础设施支持，&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;感谢志愿者们的奉献！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们明年见～&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-08e50ecbec49e3daaab0e04e1ad6eabc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-08e50ecbec49e3daaab0e04e1ad6eabc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-08e50ecbec49e3daaab0e04e1ad6eabc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-08e50ecbec49e3daaab0e04e1ad6eabc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-08e50ecbec49e3daaab0e04e1ad6eabc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-10-31-89438349</guid>
<pubDate>Thu, 31 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>高效编排有状态应用——TiDB 的云原生实践与思考</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-10-29-89037305.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/89037305&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5a5103695217f561e4e3f24d2152e650_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/012515fbeab1b0b61084100a805ecaa0&quot; data-hash=&quot;012515fbeab1b0b61084100a805ecaa0&quot; data-hovercard=&quot;p$b$012515fbeab1b0b61084100a805ecaa0&quot;&gt;@吴叶磊&lt;/a&gt; &lt;/p&gt;&lt;h2&gt;导语&lt;/h2&gt;&lt;p&gt;云原生时代以降，无状态应用以其天生的可替换性率先成为各类编排系统的宠儿。以 Kubernetes 为代表的编排系统能够充分利用云上的可编程基础设施，实现无状态应用的弹性伸缩与自动故障转移。这种基础能力的下沉无疑是对应用开发者生产力的又一次解放。 然而，在轻松地交付无状态应用时，我们应当注意到，状态本身并没有消失，而是按照各类最佳实践下推到了底层的数据库、对象存储等有状态应用上。那么，“负重前行”的有状态应用是否能充分利云与 Kubernetes 的潜力，复制无状态应用的成功呢？&lt;/p&gt;&lt;p&gt;或许你已经知道，Operator 模式已经成为社区在 Kubernetes 上编排有状态应用的最佳实践，脚手架项目 KubeBuilder 和 operator-sdk 也已经愈发成熟，而对磁盘 IO 有严苛要求的数据库等应用所必须的 Local PV（本地持久卷）也已经在 1.14 中 GA。这些积木似乎已经足够搭建出有状态应用在平稳运行在 Kubernetes 之上这一和谐景象。然而，书面上的最佳实践与生产环境之间还有无数工程细节造就的鸿沟，要在 Kubernetes 上可靠地运行有状态应用仍需要相当多的努力。下面我将以 TiDB 与 Kubernetes 的“爱恨情仇”为例，总结有状态应用走向云原生的工程最佳实践。&lt;/p&gt;&lt;h2&gt;TiDB 简介&lt;/h2&gt;&lt;p&gt;首先让我们先熟悉熟悉研究对象。TiDB 是一个分布式的关系型数据库，它采用了存储和计算分离的架构，并且分层十分清晰：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8f4eda9feef3eadca9c611672edf88b3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-8f4eda9feef3eadca9c611672edf88b3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8f4eda9feef3eadca9c611672edf88b3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-8f4eda9feef3eadca9c611672edf88b3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8f4eda9feef3eadca9c611672edf88b3_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 TiDB 架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;其中 TiDB 是 SQL 计算层，TiDB 进程接收 SQL 请求，计算查询计划，再根据查询计划去查询存储层完成查询。&lt;/p&gt;&lt;p&gt;存储层就是图中的 TiKV，TiKV 会将数据拆分为一个个小的数据块，比如一张 1000000 行的表，在 TiKV 中就有可能被拆分为 200 个 5000 行的数据块。这些数据块在 TiKV 中叫做 Region，而为了确保可用性， 每个 Region 都对应一个 Raft Group，通过 Raft Log 复制实现每个 Region 至少有三副本。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5dd409c6382dfa04bf2d726cb9745bf2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5dd409c6382dfa04bf2d726cb9745bf2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5dd409c6382dfa04bf2d726cb9745bf2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5dd409c6382dfa04bf2d726cb9745bf2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5dd409c6382dfa04bf2d726cb9745bf2_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2 TiKV Region 分布&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;而 PD 则是集群的大脑，它接收 TiKV 进程上报的存储信息，并计算出整个集群中的 Region 分布。借由此，TiDB 便能通过 PD 获知该如何访问某块数据。更重要的是，PD 还会基于集群 Region 分布与负载情况进行数据调度。比如，将过大的 Region 拆分为两个小 Region，避免 Region 大小由于写入而无限扩张；将部分 Leader 或数据副本从负载较高的 TiKV 实例迁移到负载较低的 TiKV 实例上，以最大化集群性能。这引出了一个很有趣的事实，也就是 TiKV 虽然是存储层，但它可以非常简单地进行水平伸缩。这有点意思对吧？在传统的存储中，假如我们通过分片打散数据，那么加减节点数往往需要重新分片或手工迁移大量的数据。而在 TiKV 中，以 Region 为抽象的数据块迁移能够在 PD 的调度下完全自动化地进行，而对于运维而言，只管加机器就行了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;了解有状态应用本身的架构与特性是进行编排的前提，比如通过前面的介绍我们就可以归纳出，TiDB 是无状态的，PD 和 TiKV 是有状态的，它们三者均能独立进行水平伸缩。我们也能看到，TiDB 本身的设计就是云原生的——它的容错能力和水平伸缩能力能够充分发挥云基础设施提供的弹性，既然如此，云原生“操作系统” Kubernetes 不正是云原生数据库 TiDB 的最佳载体吗？TiDB Operator 应运而生。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;TiDB Operator 简介&lt;/h2&gt;&lt;p&gt;Operator 大家都很熟悉了，目前几乎每个开源的存储项目都有自己的 Operator，比如鼻祖 etcd-operator 以及后来的 prometheus-operator、postgres-operator。Operator 的灵感很简单，Kubernetes 自身就用 Deployment、DaemonSet 等 API 对象来记录用户的意图，并通过 control loop 控制集群状态向目标状态收敛，那么我们当然也可以定义自己的 API 对象，记录自身领域中的特定意图，并通过自定义的 control loop 完成状态收敛。&lt;/p&gt;&lt;p&gt;在 Kubernetes 中，添加自定义 API 对象的最简单方式就是 CustomResourceDefinition（CRD），而添加自定义 control loop 的最简单方式则是部署一个自定义控制器。自定义控制器 + CRD 就是 Operator。具体到 TiDB 上，用户可以向 Kubernetes 提交一个 TidbCluster 对象来描述 TiDB 集群定义，假设我们这里描述说“集群有 3 个 PD 节点、3 个 TiDB 节点和 3 个 TiKV 节点”，这是我们的意图。 而 TiDB Operator 中的自定义控制器则会进行一系列的 Kubernetes 集群操作，比如分别创建 3 个 TiKV、TiDB、PD Pod，来让真实的集群符合我们的意图。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-39a45f3e0a57456a64ab8da808bc99be_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-39a45f3e0a57456a64ab8da808bc99be_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-39a45f3e0a57456a64ab8da808bc99be_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-39a45f3e0a57456a64ab8da808bc99be_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-39a45f3e0a57456a64ab8da808bc99be_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3 TiDB Operator&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;TiDB Operator 的意义在于让 TiDB 能够无缝运行在 Kubernetes 上，而 Kubernetes 又为我们抽象了基础设施。因此，TiDB Operator 也是 TiDB 多种产品形态的内核。对于希望直接使用 TiDB Operator 的用户， TiDB Operator 能做到在既有 Kubernetes 集群或公有云上开箱即用；而对于不希望有太大运维负载，又需求一套完整的分布式数据库解决方案的用户，我们则提供了打包 Kubernetes 的 on-premise 部署解决方案，用户可以直接通过方案中打包的 GUI 操作 TiDB 集群，也能通过 OpenAPI 将集群管理能力接入到自己现有的 PaaS 平台中；另外，对于完全不想运维数据库，只希望购买 SQL 计算与存储能力的用户，我们则基于 TiDB Operator 提供托管的 TiDB 服务，也即 DBaaS（Database as a Service）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe4b8106d8ad8b64fc6f59f2653b8345_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-fe4b8106d8ad8b64fc6f59f2653b8345_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe4b8106d8ad8b64fc6f59f2653b8345_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-fe4b8106d8ad8b64fc6f59f2653b8345_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-fe4b8106d8ad8b64fc6f59f2653b8345_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4 TiDB Operator 的多种上层产品形态&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;多样的产品形态对作为内核的 TiDB Operator 提出了更高的要求与挑战——事实上，由于数据资产的宝贵性和引入状态后带来的复杂性，有状态应用的可靠性要求与运维复杂度往往远高于无状态应用，这从 TiDB Operator 所面临的挑战中就可见一斑。&lt;/p&gt;&lt;h2&gt;挑战&lt;/h2&gt;&lt;p&gt;描绘架构总是让人觉得美好，而生产中的实际挑战则将我们拖回现实。&lt;/p&gt;&lt;p&gt;&lt;b&gt;TiDB Operator 的最大挑战就是数据库的场景极其严苛，大量用户的期盼都是我的数据库能够“永不停机”，对于数据不一致或丢失更是零容忍&lt;/b&gt;。很多时候大家对于数据库等有状态应用的可用性要求甚至是高于承载线上服务的 Kubernetes 集群的，至少线上集群宕机还能补救，而数据一旦出问题，往往意味着巨大的损失和补救成本，甚至有可能“回天乏术”。这本身也会在很大程度上影响大家把有状态应用推上 Kubernetes 的信心。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二个挑战是编排分布式系统这件事情本身的复杂性&lt;/b&gt;。Kubernetes 主导的 level driven 状态收敛模式虽然很好地解决了命令式编排在一致性、事务性上的种种问题，但它本身的心智模型是更为抽象的，我们需要考虑每一种可能的状态并针对性地设计收敛策略，而最后的实际状态收敛路径是随着环境而变化的，我们很难对整个过程进行准确的预测和验证。假如我们不能有效地控制编排层面的复杂度，最后的结果就是没有人能拍胸脯保证 TiDB Operator 能够满足上面提到的严苛挑战，那么走向生产也就无从谈起了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三个挑战是存储&lt;/b&gt;。数据库对于磁盘和网络的 IO 性能相当敏感，而在 Kubernetes 上，最主流的各类网络存储很难满足 TiDB 对磁盘 IO 性能的要求。假如我们使用本地存储，则不得不面对本地存储的易失性问题——磁盘故障或节点故障都会导致某块存储不可用，而这两种故障在分布式系统中是家常便饭。&lt;/p&gt;&lt;p&gt;&lt;b&gt;最后的问题是，尽管 Kubernetes 成功抽象了基础设施的计算能力与存储能力，但在实际场景的成本优化上考虑得很少&lt;/b&gt;。对于公有云、私有云、裸金属等不同的基础设施环境，TiDB Operator 需要更高级、特化的调度策略来做成本优化。大家也知道，成本优化是没有尽头的，并且往往伴随着一些牺牲，怎么找到优化过程中边际收益最大化的点，同样也是非常有意思的问题之一。&lt;/p&gt;&lt;p&gt;其中，场景严苛可以作为一个前提条件，而针对性的成本优化则不够有普适性。我们接下来就从编排和存储两块入手，从实际例子来看 TiDB 与 TiDB Operator 如何解决这些问题，并推广到一般的有状态应用上。&lt;/p&gt;&lt;h2&gt;控制器——剪不断，理还乱&lt;/h2&gt;&lt;p&gt;TiDB Operator 需要驱动集群向期望状态收敛，而最简单的驱动方式就是创建一组 Pod 来组成 TiDB 集群。通过直接操作 Pod，我们可以自由地控制所有编排细节。举例来说，我们可以：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通过替换 Pod 中容器的 image 字段完成原地升级。&lt;/li&gt;&lt;li&gt;自由决定一组 Pod 的升级顺序。&lt;/li&gt;&lt;li&gt;自由下线任意 Pod。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;事实上我们也确实采用过完全操作 Pod 的方案，但是当真正推进该方案时我们才发现，这种完全“自己造轮子”的方案不仅开发复杂，而且验证成本非常高。试想，为什么大家对 Kubernetes 的接受度越来越高， 即使是传统上较为保守的公司现在也敢于拥抱 Kuberentes？除了 Kubernetes 本身项目素质过硬之外，更重要的是有整个社区为它背书。我们知道 Kubernetes 已经在各种场景下经受过大量的生产环境考验，这种信心是各类测试手段都没法给到我们的。回到 TiDB Operator 上，选择直接操作 Pod 就意味着我们抛弃了社区在 StatefulSet、Deployment 等对象中沉淀的编排经验，随之带来的巨大验证成本大大影响了整个项目的开发效率。&lt;/p&gt;&lt;p&gt;因此，在目前的 TiDB Operator 项目中，大家可以看到控制器的主要操作对象是 StatefulSet。StatefulSet 能够满足有状态应用的大部分通用编排需求。当然，StatefulSet 为了做到通用化，做了很多不必要的假设，比如高序号的 Pod 是隐式依赖低序号 Pod 的，这会给我们带来一些额外的限制，比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;无法指定 Pod 进行下线缩容。&lt;/li&gt;&lt;li&gt;滚动更新顺序固定。&lt;/li&gt;&lt;li&gt;滚动更新需要后驱 Pod 全部 Ready。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;StatefulSet 和 Pod 的抉择，最终是灵活性和可靠性的权衡，而在 TiDB 面临的严苛场景下，我们只有先做到可靠，才能做开发、敢做开发。最后的选择自然就呼之欲出——StatefulSet。当然，这里并不是说，使用基于高级对象进行编排的方案要比基于 Pod 进行编排的方案更好，只是说我们在当时认为选择 StatefulSet 是一个更好的权衡。当然这个故事还没有结束，当我们基于 StatefulSet 把第一版 TiDB Operator 做稳定后，我们正在接下来的版本中开发一个新的对象来水平替换 StatefulSet，这个对象可以使用社区积累的 StatefulSet 测试用例进行验证，同时又可以解除上面提到的额外限制，给我们提供更好的灵活性。 假如你也在考虑从零开始搭建一个 Operator，或许也可以参考“先基于成熟的原生对象快速迭代，在验证了价值后再增强或替换原生对象来解决高级需求”这条落地路径。&lt;/p&gt;&lt;p&gt;接下来的问题是控制器如何协调基础设施层的状态与应用层的状态。举个例子，在滚动升级 TiKV 时，每次重启 TiKV 实例前，都要先驱逐该实例上的所有 Region Leader；而在缩容 TiKV 时，则要先在 PD 中将待缩容的 TiKV 下线，等待待缩容的 TiKV 实例上的 Region 全部迁移走，PD 认为 TiKV 下线完成时，再真正执行缩容操作调整 Pod 个数。这些都是在编排中协调应用层状态的例子，我们可以怎么做自动化呢？&lt;/p&gt;&lt;p&gt;大家也注意到了，上面的例子都和 Pod 下线挂钩，因此一个简单的方案就通过 container lifecycle hook，在 preStop 时执行一个脚本进行协调。这个方案碰到的第一个问题是缺乏全局信息，脚本中无法区分当前是在滚动升级还是缩容。当然，这可以通过在脚本中查询 apiserver 来绕过。更大的问题是 preStop hook 存在 grace period，kubelet 最多等待 .spec.terminationGracePeriodSeconds 这么长的时间，就会强制删除 Pod。对于 TiDB 的场景而言，我们更希望在自动的下线逻辑失败时进行等待并报警，通知运维人员介入，以便于最小化影响，因此基于 container hook 来做是不可接受的。&lt;/p&gt;&lt;p&gt;第二种方案是在控制循环中来协调应用层的状态。比如，我们可以通过 partition 字段来控制 StatefulSet 升级进度，并在升级前确保 leader 迁移完毕，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-803d2ddb2796b89e538432f4398c1611_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-803d2ddb2796b89e538432f4398c1611_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-803d2ddb2796b89e538432f4398c1611_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-803d2ddb2796b89e538432f4398c1611_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-803d2ddb2796b89e538432f4398c1611_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5 在控制循环中协调状态&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在伪代码中，每次我们因为要将所有 Pod 收敛到新版本而进入这段控制逻辑时，都会先检查下一个要待升级的 TiKV 实例上 leader 是否迁移完毕，直到迁移完毕才会继续往下走，调整 partition 参数，开始升级对应的 TiKV 实例。缩容也是类似的逻辑。但你可能已经意识到，缩容和滚动更新两个操作是有可能同时出现在状态收敛的过程中的，也就是同时修改 replicas 和 image 字段。这时候由于控制器需要区分缩容与滚动更新，诸如此类的边界条件会让控制器越来越复杂。&lt;/p&gt;&lt;p&gt;第三种方案是使用 Kubernetes 的 Admission Webhook 将一部分协调逻辑从控制器中拆出来，放到更纯粹的切面当中。针对这个例子，我们可以拦截 Pod 的 Delete 请求和针对上层对象的 Update 请求，检查缩容或滚动升级的前置条件，假如不满足，则拒绝请求并触发指令进行协调，比如驱逐 leader，假如满足，那么就放行请求。控制循环会不断下发指令直到状态收敛，因此 webhook 就相应地会不断进行检查直到条件满足，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fc1a229e38e2de39b8cf4a4c99c3cc42_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-fc1a229e38e2de39b8cf4a4c99c3cc42_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fc1a229e38e2de39b8cf4a4c99c3cc42_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-fc1a229e38e2de39b8cf4a4c99c3cc42_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-fc1a229e38e2de39b8cf4a4c99c3cc42_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6 在 Webhook 中协调状态&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这种方案的好处是我们把逻辑拆分到了一个与控制器垂直的单元中，从而可以更容易地编写业务代码和单元测试。当然，这个方案也有缺点，一是引入了新的错误模式，处理 webhook 的 server 假如宕机，会造成集群功能降级；二是该方案适用面并不广，只能用于状态协调与特定的 Kubernetes API 操作强相关的场景。在实际的代码实践中，我们会按照具体场景选择方案二或方案三，大家也可以到项目中一探究竟。&lt;/p&gt;&lt;p&gt;&lt;b&gt;上面的两个例子都是关于如何控制编排逻辑复杂度的，关于 Operator 的各类科普文中都会用一句“在自定义控制器中编写领域特定的运维知识”将这一部分轻描淡写地一笔带过，而我们的实践告诉我们，真正编写生产级 的自定义控制器充满挑战与抉择。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;Local PV —— 想说爱你不容易&lt;/h2&gt;&lt;p&gt;接下来是存储的问题。我们不妨看看 Kubernetes 为我们提供了哪些存储方案：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-943080c31fad592402b61e8dc462f044_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-943080c31fad592402b61e8dc462f044_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-943080c31fad592402b61e8dc462f044_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-943080c31fad592402b61e8dc462f044_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-943080c31fad592402b61e8dc462f044_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7 存储方案&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;其中，本地临时存储中的数据会随着 Pod 被删除而清空，因此不适用于持久存储。&lt;/p&gt;&lt;p&gt;远程存储则面临两个问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通常来说，远程存储的性能较差，这尤其体现在 IOPS 不够稳定上，因此对于磁盘性能有严格要求的有状态应用，大多数远程存储是不适用的。&lt;/li&gt;&lt;li&gt;通常来说，远程存储本身会做三副本，因此单位成本较高，这对于在存储层已经实现三副本的 TiDB 来说是不必要的成本开销。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，最适用于 TiDB 的是本地持久存储。这其中，hostPath 的生命周期又不被 Kubernetes 管理，需要付出额外的维护成本，最终的选项就只剩下了 Local PV。&lt;/p&gt;&lt;p&gt;Local PV 并非免费的午餐，所有的文档都会告诉我们 Local PV 有以下限制：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据易失（相比于远程存储的三副本）。&lt;/li&gt;&lt;li&gt;节点故障会影响数据访问。&lt;/li&gt;&lt;li&gt;难以垂直扩展容量（相当一部分远程存储可以直接调整 volume 大小）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些问题同样也是在传统的虚拟机运维场景下的痛点，因此 TiDB 本身设计就充分考虑了这些问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;本地存储的易失性要求应用自身实现数据冗余。&lt;/li&gt;&lt;ul&gt;&lt;li&gt;TiDB 的存储层 TiKV 默认就为每个 Region 维护至少三副本。&lt;/li&gt;&lt;li&gt;当副本缺失时，TiKV 能自动补齐副本数。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;节点故障会影响本地存储的数据访问。&lt;/li&gt;&lt;ul&gt;&lt;li&gt;节点故障后，相关 Region 会重新进行 leader 选举，将读写自动迁移到健康节点上。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;本地存储的容量难以垂直扩展。&lt;/li&gt;&lt;ul&gt;&lt;li&gt;TiKV 的自动数据切分与调度能够实现水平伸缩。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;存储层的这些关键特性是 TiDB 高效使用 Local PV 的前提条件，也是 TiDB 水平伸缩的关键所在。当然，在发生节点故障或磁盘故障时，由于旧 Pod 无法正常运行，我们需要自定义控制器帮助我们进行恢复，及时补齐实例数，确保有足够的健康实例来提供整个集群所需的存储空间、计算能力与 IO 能力。这也就是自动故障转移。&lt;/p&gt;&lt;p&gt;我们先看一看为什么 TiDB 的存储层不能像无状态应用或者使用远程存储的 Pod 那样自动进行故障转移。假设下图中的节点发生了故障，由于 TiKV-1 绑定了节点上的 PV，只能运行在该节点上，因此 在节点恢复前，TiKV-1 将一直处于 Pending 状态：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b90337525fa64a1e08842cb95db8ac62_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-b90337525fa64a1e08842cb95db8ac62_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b90337525fa64a1e08842cb95db8ac62_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-b90337525fa64a1e08842cb95db8ac62_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b90337525fa64a1e08842cb95db8ac62_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8 节点故障&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;此时，假如我们能够确认 Node 已经宕机并且短期无法恢复，那么就可以删除 Node 对象（比如 NodeController 在公有上会查询公有云的 API 来删除已经释放的 Node）。此时，控制器通过 Node 对象不存在这一事实理解了 Node 已经无法恢复，就可以直接删除 pvc-1 来解绑 PV，并强制删除 TiKV-1，最终让 TiKV-1 调度到其它节点上。当然，我们同时也要做应用层状态的协调，也就是先在 PD 中下线 TiKV-1，再将新的 TiKV-1 作为一个新成员加入集群，此时，PD 就会通知 TiKV-1 创建 Region 副本来补齐集群中的 Region 副本数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4def23bf88b88c266c411f25dedcbf3e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-4def23bf88b88c266c411f25dedcbf3e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4def23bf88b88c266c411f25dedcbf3e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-4def23bf88b88c266c411f25dedcbf3e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4def23bf88b88c266c411f25dedcbf3e_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9 能够确定节点状态时的故障转移&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当然，更多的情况下，我们是无法在自定义控制器中确定节点状态的，此时就很难针对性地进行原地恢复，因此我们通过向集群中添加新 Pod 来进行故障转移：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a618bf0bde89d5f1a8862aeaf56e3f9a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-a618bf0bde89d5f1a8862aeaf56e3f9a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a618bf0bde89d5f1a8862aeaf56e3f9a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-a618bf0bde89d5f1a8862aeaf56e3f9a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-a618bf0bde89d5f1a8862aeaf56e3f9a_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10 无法确定节点状态时的故障转移&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;上面讲的是 TiDB 特有的故障转移策略，但其实可以类推到大部分的有状态应用上。比如对于 MySQL 的 slave，我们同样可以通过新增 slave 来做 failover，而在 failover 时，我们同样也要做应用层的一些事情， 比如说去 S3 上拉一个全量备份，再通过 binlog 把增量数据补上，当 lag 达到可接受的程度之后开始对外提供读服务。因此大家就可以发现，对于有状态应用的 failover 策略是共通的，也都需要应用本身支持某种 failover 形式。比如对于 MySQL 的 master，我们只能通过 M-M 模式做一定程度上的 failover，而且还会损失数据一致性。这当然不是 Kubernetes 或云原生本身有什么问题，而是说 Kubernetes 只是改变了应用的运维模式，但并不能影响应用本身的架构特性。假如应用本身的设计就不是云原生的，那只能从应用本身去解决。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;通过 TiDB Operator 的实践，我们有以下几条总结：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Operator 本身的复杂度不可忽视。&lt;/li&gt;&lt;li&gt;Local PV 能满足高 IO 性能需求，代价则是编排上额外的复杂度。&lt;/li&gt;&lt;li&gt;应用本身必须迈向云原生（meets kubernetes part way）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后，言语的描述总是不如代码本身来得简洁有力，TiDB Operator 是一个完全开源的项目，眼见为实，大家可以尽情到 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-operator&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;项目仓库&lt;/a&gt; 中拍砖，也欢迎大家加入社区一起玩起来，期待你的 issue 和 PR！&lt;/p&gt;&lt;p&gt;假如你对于文章有任何问题或建议，或是想直接加入 PingCAP 鼓捣相关项目，欢迎通过我的邮箱 wuyelei@pingcap.com 联系我。&lt;/p&gt;&lt;blockquote&gt;本文为吴叶磊在 2019 QCon 全球软件开发大会（上海）上的专题演讲实录，Slides &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/presentations/blob/master/conference/%25E5%2590%25B4%25E5%258F%25B6%25E7%25A3%258A-QCon-2019-%25E9%25AB%2598%25E6%2595%2588%25E7%25BC%2596%25E6%258E%2592%25E6%259C%2589%25E7%258A%25B6%25E6%2580%2581%25E5%25BA%2594%25E7%2594%25A8-TiDB%25E7%259A%2584%25E4%25BA%2591%25E5%258E%259F%25E7%2594%259F%25E5%25AE%259E%25E8%25B7%25B5%25E4%25B8%258E%25E6%2580%259D%25E8%2580%2583.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;下载地址&lt;/a&gt;。&lt;/blockquote&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-10-29-89037305</guid>
<pubDate>Tue, 29 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>网易互娱的数据库选型和 TiDB 应用实践</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-10-27-87945199.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/87945199&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c2edf92e205ae540dc9e1f3bce5a97_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;作者介绍：李文杰，网易互娱计费组，高级数据库管理工程师，TiDB User Group Ambassador。&lt;/blockquote&gt;&lt;h2&gt;一、业务架构简介&lt;/h2&gt;&lt;p&gt;计费组是为网易互娱产品提供统一登录和支付高效解决方案的公共支持部门，对内是互娱的各个游戏工作室，对外是国内外数百个渠道。由于业务场景的特殊性，我们为各个游戏产品部署了不同的应用服务，其中大产品环境独立，小产品集中部署。&lt;/p&gt;&lt;p&gt;随着部门业务量的激增，单机 MySQL 在容量、性能、扩展性等方面都遇到了瓶颈，我们开始对其他数据库产品进行调研选型。本文将详细介绍网易互娱计费组针对自己场景的数据库选型对比方案，以及使用 TiDB 后解决的问题，并分享了使用 TiDB 过程中集群管理、监控和数据迁移等方面的最佳实践，以供大家参考和交流。&lt;/p&gt;&lt;h3&gt;1.1 MySQL 使用架构&lt;/h3&gt;&lt;p&gt;网易互娱计费组线上 MySQL 的基本使用架构，如下图所示，其中箭头方向表示数据或请求的指向：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e701bf359f428776beadb051bd789a73_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-e701bf359f428776beadb051bd789a73_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e701bf359f428776beadb051bd789a73_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-e701bf359f428776beadb051bd789a73_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e701bf359f428776beadb051bd789a73_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 网易互娱计费组线上 MySQL 使用架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;线上应用 Application 通过 Keepalive + 多机部署，流量经过负载均衡，可以有效保障应用服务的高可用；&lt;/li&gt;&lt;li&gt;数据库层架构是 Keepalive + 主从结构，利用半同步复制特性可以有效解决延迟和数据一致性的问题；&lt;/li&gt;&lt;li&gt;Application 通过 VIP 访问后端数据库，在数据库主节点宕机后通过 VIP 飘移到从节点，保证服务正常对外提供；&lt;/li&gt;&lt;li&gt;通过 Slave 节点进行数据备份和线上数据采集，经过全量和增量同步方式导出数据到数据中心，然后进行在线和离线计算任务；&lt;/li&gt;&lt;li&gt;类似这样的架构组合线上大概有 50+ 套，涉及服务器 200~400 台，日均新增数据 TB 级。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;1.2 MySQL 使用的现状与问题&lt;/h3&gt;&lt;p&gt;随着业务的发展，部门内各应用服务产生的数据量也在快速增长。业务落地数据量不断激增，导致单机 MySQL 不可避免地会出现性能瓶颈。主要体现在以下几个方面：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;容量&lt;/li&gt;&lt;ul&gt;&lt;li&gt;单机 MySQL 实例存储空间有限，想要维持现有架构就得删除和轮转旧数据，达到释放空间的目的；&lt;/li&gt;&lt;li&gt;网易互娱某些场景单表容量达到 700GB 以上，订单数据需永久保存，同时也需要保持在线实时查询，按照之前的存储设计会出现明显的瓶颈。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;性能&lt;/li&gt;&lt;ul&gt;&lt;li&gt;最大单表 15 亿行，行数过大，导致读写性能受到影响。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;扩展性&lt;/li&gt;&lt;ul&gt;&lt;li&gt;MySQL 无法在线灵活扩展，无法解决存储瓶颈。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;SQL 复杂&lt;/li&gt;&lt;ul&gt;&lt;li&gt;大表轮转后出现多个分表，联合查询时需要 join 多个分表，SQL 非常复杂并难以维护；&lt;/li&gt;&lt;li&gt;单机 MySQL 缺乏大规模数据分析的能力。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;数据壁垒&lt;/li&gt;&lt;ul&gt;&lt;li&gt;不同产品的数据库独立部署；&lt;/li&gt;&lt;li&gt;数据不互通，导致数据相关隔离，形成数据壁垒；&lt;/li&gt;&lt;li&gt;当进行跨产品计算时，需要维护多个异构数据源，访问方式复杂。数据分散在不同的数据孤岛上会增加数据分析难度，不利于共性价值的挖掘。如下图：&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-19112c8c75fc02890d7d5fb7c83d082f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-19112c8c75fc02890d7d5fb7c83d082f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-19112c8c75fc02890d7d5fb7c83d082f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-19112c8c75fc02890d7d5fb7c83d082f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-19112c8c75fc02890d7d5fb7c83d082f_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2 现状之数据孤岛&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;二、数据库选型&lt;/h2&gt;&lt;h3&gt;2.1 调研目标&lt;/h3&gt;&lt;p&gt;针对目前存储架构存在的问题，有需要使用其他存储方案的可能。考虑到目前的业务与 MySQL 高度耦合，对数据库选型的主要要求有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;必须兼容 MySQL 协议；&lt;/li&gt;&lt;li&gt;支持事务，保证任务以事务为维度来执行或遇错回滚；&lt;/li&gt;&lt;li&gt;支持索引，尤其是二级索引；&lt;/li&gt;&lt;li&gt;扩展性，支持灵活在线扩展能力，包括性能扩展和容量扩展。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其他要求：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;稳定性和可靠性；&lt;/li&gt;&lt;li&gt;备份和恢复；&lt;/li&gt;&lt;li&gt;容灾等。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;2.2 可选方案&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4e2c5d05280b41a4559bf6e8e882e5d3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1072&quot; data-rawheight=&quot;458&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1072&quot; data-original=&quot;https://pic4.zhimg.com/v2-4e2c5d05280b41a4559bf6e8e882e5d3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4e2c5d05280b41a4559bf6e8e882e5d3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1072&quot; data-rawheight=&quot;458&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1072&quot; data-original=&quot;https://pic4.zhimg.com/v2-4e2c5d05280b41a4559bf6e8e882e5d3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4e2c5d05280b41a4559bf6e8e882e5d3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;2.3 测试&lt;/h3&gt;&lt;h3&gt;2.3.1 基于 MySQL 的解决方案&lt;/h3&gt;&lt;p&gt;一开始仍然是倾向使用基于 MySQL 的解决方案，比如 MySQL InnoDB Cluster 或 MySQL + 中间件的方案。&lt;/p&gt;&lt;p&gt;我们测试了 MySQL 集群 5.7.25 版本对比 8.0.12 版本，在 128 并发写各 1000 万行的 10 个表，比较单节点、3 节点和 5 节点下的情况，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e043a4e85967a6d57373fab5b129d034_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;462&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-e043a4e85967a6d57373fab5b129d034_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e043a4e85967a6d57373fab5b129d034_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;462&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-e043a4e85967a6d57373fab5b129d034_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e043a4e85967a6d57373fab5b129d034_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3 对比结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在测试中发现，使用 MySQL InnoDB 集群的方案写性能比单机 MySQL 差约 30%，其他的读写测试结果也不甚满意。之后陆续测试 MySQL InnoDB Cluster 或 MySQL + 中间件的方案，不是测试结果性能不达要求，就是需要修改大量代码。&lt;/p&gt;&lt;p&gt;因此我们得出了基于 MySQL InnoDB Cluster 或 MySQL + 中间件的方案的不满足我们的业务场景的结论。总结来说，我们不使用 MySQL 分库分表、中间件或 MySQL 集群，原因主要是以下两点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;方案过于复杂&lt;/li&gt;&lt;li&gt;需要改业务代码&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;仔细分析来看，其实基于 MySQL InnoDB Cluster 或 MySQL + 中间件的方案，本质上是 MySQL 主从结构的延伸，并非真正的分布式拓展，像是以打“补丁”的方式来实现横向扩展，很多功能特性自然也难以让人满意。&lt;/b&gt;&lt;/p&gt;&lt;h3&gt;2.3.2 CockroachDB VS TiDB&lt;/h3&gt;&lt;p&gt;在开源的分布式 NewSQL 领域，知名的有 TiDB 和 CockroachDB（简称 CRDB），二者都是基于 Google Spanner 论文的开源实现。我们对这两种数据库的功能和性能做了大量的调研和测试。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;TiDB 天然兼容 MySQL 协议，而 CRDB 兼容 PostgreSQL ；&lt;/li&gt;&lt;li&gt;如果业务以 MySQL 为主，那 TiDB 可能是比较好的选择；如果是 PostgreSQL，那CRDB 可能是优先的选择。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;测试方面，我们也进行了全面地对比和测试。这里说其中一个测试案例：10 台机器 5 存储节点，160 并发访问单表 2 亿行，我们于 2018 年 7 月，对 CRDB-v2.1.0 版本和 TiDB-v2.0.5 版本进行了读写测试（CRDB 和 TiDB 集群均使用默认配置，未进行调优）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;集群拓扑&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b87fcc3484e0ed11b7415194bacca766_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;464&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-b87fcc3484e0ed11b7415194bacca766_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b87fcc3484e0ed11b7415194bacca766_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;464&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-b87fcc3484e0ed11b7415194bacca766_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b87fcc3484e0ed11b7415194bacca766_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4 CockroachDB 测试集群搭建&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2df8880a5aadd7b661237be784bd12c0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;531&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-2df8880a5aadd7b661237be784bd12c0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2df8880a5aadd7b661237be784bd12c0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;531&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-2df8880a5aadd7b661237be784bd12c0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2df8880a5aadd7b661237be784bd12c0_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5 TiDB 测试集群搭建&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;测试语句&lt;/b&gt;&lt;/p&gt;&lt;p&gt;范围查询：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SELECT c FROM sbtest%u WHERE id BETWEEN ? AND ?
SELECT SUM(k) FROM sbtest%u WHERE id BETWEEN ? AND ?
SELECT c FROM sbtest WHERE id BETWEEN ? AND ? ORDER BY c
SELECT DISTINCT c FROM sbtest%u WHERE id BETWEEN ? AND ? ORDER BY c&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;随机 IN 查询：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SELECT id, k, c, pad FROM sbtest1 WHERE k IN (?)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;随机范围查询：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SELECT count(k) FROM sbtest1 WHERE k BETWEEN ? AND ? OR k BETWEEN ? AND ?&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;更新索引列：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;UPDATE sbtest%u SET k=k+1 WHERE id=?&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;更新非索引列：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;UPDATE sbtest%u SET c=? WHERE id=?&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;读写混合：范围查询 + 更删改混合&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中一个重要的测试结果如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bcc6cccccdc3e119d41a5e053187f2b7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;466&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-bcc6cccccdc3e119d41a5e053187f2b7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bcc6cccccdc3e119d41a5e053187f2b7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;466&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-bcc6cccccdc3e119d41a5e053187f2b7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bcc6cccccdc3e119d41a5e053187f2b7_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6 测试结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;结论：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;CRDB 和 TiDB 在性能表现上不相上下；&lt;br/&gt;注：上面是 2018 年 7 月的基于 TiDB 2.0.5 版本的测试结果，现在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/releases/3.0-ga/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 已发布 3.0 GA 版本，在性能上有了质的提升&lt;/a&gt;，我们在近期进行了补充测试，大多数场景下 3.0 版本较 2.1 版本有数倍的性能提升，最新的测试结果图如下：&lt;br/&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-126246b456e76b94f40b965841eebc36_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;452&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-126246b456e76b94f40b965841eebc36_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-126246b456e76b94f40b965841eebc36_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;452&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-126246b456e76b94f40b965841eebc36_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-126246b456e76b94f40b965841eebc36_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7 TiDB 2.1.15 vs 3.0.3：OLTP 峰值比较&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d6716918375f8a4f1142a803e01dbc0c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;306&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d6716918375f8a4f1142a803e01dbc0c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d6716918375f8a4f1142a803e01dbc0c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;306&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d6716918375f8a4f1142a803e01dbc0c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d6716918375f8a4f1142a803e01dbc0c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8 TiDB 2.1.15 vs 3.0.3：TPC-C&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;2. CRDB 兼容 PostgreSQL，如果需要迁移则需要转协议，需 MySQL → PostgreSQL  → CRDB。迁移过程复杂，成本高；&lt;/p&gt;&lt;p&gt;3. TiDB 兼容 MySQL，代码修改量不多，迁移成本低。&lt;/p&gt;&lt;h3&gt;2.3.3 最终选型&lt;/h3&gt;&lt;p&gt;综合对比结果如下表：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7f97b461d169b0fd1ca972e1f527e5b7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;970&quot; data-rawheight=&quot;452&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;970&quot; data-original=&quot;https://pic4.zhimg.com/v2-7f97b461d169b0fd1ca972e1f527e5b7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7f97b461d169b0fd1ca972e1f527e5b7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;970&quot; data-rawheight=&quot;452&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;970&quot; data-original=&quot;https://pic4.zhimg.com/v2-7f97b461d169b0fd1ca972e1f527e5b7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-7f97b461d169b0fd1ca972e1f527e5b7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;经过谨慎的考量，我们选择了 TiDB。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-feae600e94813ac3a015f6b923bbeaa1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;497&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-feae600e94813ac3a015f6b923bbeaa1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-feae600e94813ac3a015f6b923bbeaa1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;497&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-feae600e94813ac3a015f6b923bbeaa1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-feae600e94813ac3a015f6b923bbeaa1_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9 选择 TiDB 的重要理由&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;三、TiDB 在网易互娱计费组的使用&lt;/h2&gt;&lt;h3&gt;3.1 TiDB 使用架构&lt;/h3&gt;&lt;p&gt;网易互娱使用 TiDB 的架构设计如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8f6d6f5043b3a90ea15ca410117e07c7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;479&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-8f6d6f5043b3a90ea15ca410117e07c7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8f6d6f5043b3a90ea15ca410117e07c7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;479&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-8f6d6f5043b3a90ea15ca410117e07c7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8f6d6f5043b3a90ea15ca410117e07c7_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10 基于 TiDB 的架构设计&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;整个集群分为 TiDB、TiKV 和 PD 3 个模块分层部署；&lt;/li&gt;&lt;li&gt;使用 Nginx 作为前端负载均衡。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;3.2 TiDB 解决了哪些需求&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4bb5735becad11940999f16df0597ad0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1282&quot; data-rawheight=&quot;456&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1282&quot; data-original=&quot;https://pic1.zhimg.com/v2-4bb5735becad11940999f16df0597ad0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4bb5735becad11940999f16df0597ad0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1282&quot; data-rawheight=&quot;456&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1282&quot; data-original=&quot;https://pic1.zhimg.com/v2-4bb5735becad11940999f16df0597ad0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4bb5735becad11940999f16df0597ad0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;3.3 TiDB 使用现状&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;业务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;TiDB 作为线上 MySQL 数据镜像，负责线上数据的收集和集中管理，形成数据湖泊；&lt;/li&gt;&lt;li&gt;应用于数据平台服务，包括报表、监控、运营、用户画像、大数据计算等场景；&lt;/li&gt;&lt;li&gt;HTAP：OLTP + OLAP。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;集群&lt;/li&gt;&lt;ul&gt;&lt;li&gt;测试集群：v2.1.15，用于功能测试、特性尝鲜；&lt;/li&gt;&lt;li&gt;线上集群：v2.1.15，80% 离线大数据计算任务 + 20% 线上业务。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;规模&lt;/li&gt;&lt;ul&gt;&lt;li&gt;41 台服务器，88 个实例节点，38 个 Syncer 实时同步流（将升级为 DM）；&lt;/li&gt;&lt;li&gt;存储：20TB/总 50TB，230 万个 Region；&lt;/li&gt;&lt;li&gt;QPS 均值 4k/s，高峰期万级 QPS，读写比约 1:5；&lt;/li&gt;&lt;li&gt;延迟时间：80% 在 8ms 以内，95% 在 125ms 以下，99.9% 在 500ms 以下。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2&gt;四、最佳实践分享&lt;/h2&gt;&lt;h3&gt;4.1 集群管理&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Ansible（推荐）&lt;/li&gt;&lt;ul&gt;&lt;li&gt;一键部署；&lt;/li&gt;&lt;li&gt;弹性伸缩，可在线灵活扩缩容；&lt;/li&gt;&lt;li&gt;升级，单节点轮转平滑升级；&lt;/li&gt;&lt;li&gt;集群启停和下线；&lt;/li&gt;&lt;li&gt;Prometheus 监控。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;Docker&lt;/li&gt;&lt;li&gt;K8s&lt;/li&gt;&lt;ul&gt;&lt;li&gt;使用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-operator&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Operator&lt;/a&gt; 可以在私有云和公有云上一键管理。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3&gt;4.2 运维实践&lt;/h3&gt;&lt;h3&gt;4.2.1 Prometheus 监控&lt;/h3&gt;&lt;p&gt;官方集成了 Prometheus + Grafana 的实时监控平台，从集群的各个方面进行了完善的监控，包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;服务器基础资源的监控：内存、CPU、存储空间、IO 等；&lt;/li&gt;&lt;li&gt;集群组件的监控：TiDB、PD、TiKV 等；&lt;/li&gt;&lt;li&gt;数据监控：实时同步流、上下游数据一致性检验等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;PD 监控示意图如下，集群管理员可以很方便地掌握集群的最新状态，包括集群的空间 Region 等所有情况。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a54da195fdd0a5e3c085dda6c351793_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a54da195fdd0a5e3c085dda6c351793_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a54da195fdd0a5e3c085dda6c351793_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a54da195fdd0a5e3c085dda6c351793_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8a54da195fdd0a5e3c085dda6c351793_b.jpg&quot;/&gt;&lt;figcaption&gt;图 11 最佳运维实践：Prometheus 实时监控&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果集群运行过程出错，在监控面板上很容易就发现，下图是使用过程中的一个案例：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-21ad70df0265e812b94011451e9cc4fe_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;191&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-21ad70df0265e812b94011451e9cc4fe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-21ad70df0265e812b94011451e9cc4fe_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;191&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-21ad70df0265e812b94011451e9cc4fe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-21ad70df0265e812b94011451e9cc4fe_b.jpg&quot;/&gt;&lt;figcaption&gt;图 12 最佳运维实践案例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;应用访问 TiDB 写入数据时发现特别慢，读请求正常。排查后，根据 TiKV 面板发现 Raft Store CPU 这项指标异常。深入了解原因是因为数据库副本复制是单线程操作，目前已经到了集群的瓶颈。解决办法有以下两点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Region 数量过多，Raft Store 还要处理 heartbeat message。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;解决方法：删除过期数据。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Raft Store 单线程处理速度跟不上集群写入速度。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;解决方法：从 2.1.5 升级到 2.1.15，开启自动 Region Merge 功能。&lt;/p&gt;&lt;h3&gt;4.2.2 部分运维问题及解决方案&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-645d348684315ec58be5a3569c76122e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1422&quot; data-rawheight=&quot;1314&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1422&quot; data-original=&quot;https://pic3.zhimg.com/v2-645d348684315ec58be5a3569c76122e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-645d348684315ec58be5a3569c76122e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1422&quot; data-rawheight=&quot;1314&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1422&quot; data-original=&quot;https://pic3.zhimg.com/v2-645d348684315ec58be5a3569c76122e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-645d348684315ec58be5a3569c76122e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;4.3 全网数据库遍历&lt;/h3&gt;&lt;p&gt;以前部分业务遍历全网数据库获取所需数据，需要维护多个源，而且是异构源，非常复杂和繁琐。使用 TiDB 很好地解决了这个问题，只需要访问一个源就可以获取到所有想要的数据。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-64e0713ff4ee564dec1b643c539dbfc2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;412&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-64e0713ff4ee564dec1b643c539dbfc2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-64e0713ff4ee564dec1b643c539dbfc2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;412&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-64e0713ff4ee564dec1b643c539dbfc2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-64e0713ff4ee564dec1b643c539dbfc2_b.jpg&quot;/&gt;&lt;figcaption&gt;图 13 全网数据库遍历&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;4.4 数据迁移&lt;/h3&gt;&lt;h3&gt;4.4.1 MySQL 到 TiDB&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-84ca591d0ad68ce644f3a2816018b44c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-84ca591d0ad68ce644f3a2816018b44c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-84ca591d0ad68ce644f3a2816018b44c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-84ca591d0ad68ce644f3a2816018b44c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-84ca591d0ad68ce644f3a2816018b44c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 14 数据从 MySQL 迁移到 TiDB&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;MySQL 数据库迁移到 TiDB 分为两个部分：全量和增量。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;全量&lt;/li&gt;&lt;ul&gt;&lt;li&gt;使用工具 （Mydumper 或 MySQL Dump 等）从 MySQL 导出数据，并且记录当前数据的 binlog 位置；&lt;/li&gt;&lt;li&gt;使用工具（Loader 或 Lightning 等）将数据导入到 TiDB 集群；&lt;/li&gt;&lt;li&gt;可以用作数据的备份和恢复操作。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;增量&lt;/li&gt;&lt;ul&gt;&lt;li&gt;TiDB 伪装成为上游 MySQL 的一个 Slave，通过工具（Syncer 或 DM）实时同步 binlog 到 TiDB 集群；&lt;/li&gt;&lt;li&gt;通常情况上游一旦有数据更新，下游就会实时同步过来。同步速度受网络和数据量大小的影响。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3&gt;4.4.2 数据迁出 TiDB&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-de4230f3e89b1b8fd0b59cb618fd1329_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-de4230f3e89b1b8fd0b59cb618fd1329_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-de4230f3e89b1b8fd0b59cb618fd1329_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-de4230f3e89b1b8fd0b59cb618fd1329_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-de4230f3e89b1b8fd0b59cb618fd1329_b.jpg&quot;/&gt;&lt;figcaption&gt;图 15 数据迁出 TiDB&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果数据需要反向导入或同步，可以利用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-ecosystem-tools-1/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Binlog&lt;/a&gt; 工具将 TiDB 集群的 binlog 同步到 MySQL。TiDB Binlog 支持以下功能场景：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;数据同步&lt;/b&gt;：同步 TiDB 集群数据到其他数据库；&lt;/li&gt;&lt;li&gt;&lt;b&gt;实时备份和恢复&lt;/b&gt;：备份 TiDB 集群数据，同时可以用于 TiDB 集群故障时恢复。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;导入的方式：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;全量：TiDB 兼容 MySQL 协议，在 MySQL 容量足够大的情况下，也可用工具将数据从 TiDB 导出后再导入 MySQL。&lt;/li&gt;&lt;li&gt;增量：打开 TiDB 的 binlog 开关，部署 binlog 收集组件（Pump+Drainer），可以将 binlog 数据同步到下游存储架构（MySQL、TiDB、Kafka、S3 等）。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;4.5 优雅地「去分库分表」&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-27d611443fcb9818371be07e692cfb61_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-27d611443fcb9818371be07e692cfb61_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-27d611443fcb9818371be07e692cfb61_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-27d611443fcb9818371be07e692cfb61_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-27d611443fcb9818371be07e692cfb61_b.jpg&quot;/&gt;&lt;figcaption&gt;图 16 去分库分表举例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;举例：一个超级大表按天分表，现在打算查询某个账号一年间的信息。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;上游 MySQL&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SELECT xx FROM HFeeall join HFee20190101 join ... join ...join ... join HFee20190917 WHERE xx;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要连接 N 个 join 条件，查询需要等待较长时间。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;下游 TiDB&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SELECT xx  FROM SuperHfeeall WHERE xx ;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用此方案，最大单表 700+GB，13+ 亿行，索引查询秒返回。&lt;/p&gt;&lt;h3&gt;4.6  业务迁移&lt;/h3&gt;&lt;p&gt;&lt;b&gt;目标&lt;/b&gt;：利用 TiDB 的水平扩展特性，解决容量瓶颈和系统吞吐量瓶颈。&lt;/p&gt;&lt;p&gt;&lt;b&gt;迁移原则&lt;/b&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据完整和准确：数据很重要，保证数据不错、不丢；&lt;/li&gt;&lt;li&gt;迁移平滑和迅速：服务敏感度高，停服时间要短；&lt;/li&gt;&lt;li&gt;可回滚：遇到问题可随时切回到 MySQL。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;1）数据同步&lt;/b&gt;&lt;/p&gt;&lt;p&gt;使用 DM 或者 Syncer 将上游 MySQL 的数据同步到 TiDB 集群。同步流搭建后注意需要检查上下游数据一致性。&lt;/p&gt;&lt;p&gt;观察一段时间，同步无误后，可以根据业务需要迁移部分读流量到 TiDB 集群。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-55e50472d089594c5b5be928e744d5ae_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;831&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;899&quot; data-original=&quot;https://pic3.zhimg.com/v2-55e50472d089594c5b5be928e744d5ae_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-55e50472d089594c5b5be928e744d5ae_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;831&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;899&quot; data-original=&quot;https://pic3.zhimg.com/v2-55e50472d089594c5b5be928e744d5ae_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-55e50472d089594c5b5be928e744d5ae_b.jpg&quot;/&gt;&lt;figcaption&gt;图 17 业务迁移之数据同步&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;2）读写验证&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这一阶段是验证应用访问 MySQL 和访问 TiDB 可以得到相同的结果，验证业务访问的准确性问题。&lt;/p&gt;&lt;p&gt;停止数据同步，使用流量复制工具将线上流量完全拷贝出来，同时读写 MySQL 和 TiDB。将两边的访问结果进行对比，核查 TiDB 是否可靠和可信。根据需要，这个阶段可以测试较长时间。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2e337efcdd9782d068cde17c8728c3fd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;772&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-2e337efcdd9782d068cde17c8728c3fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2e337efcdd9782d068cde17c8728c3fd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;772&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-2e337efcdd9782d068cde17c8728c3fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2e337efcdd9782d068cde17c8728c3fd_b.jpg&quot;/&gt;&lt;figcaption&gt;图 18 业务迁移之读写验证&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;3）灰度切换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;将步骤 2 的双写停止，即关双写，同时拉起上游的 DM 同步。&lt;/p&gt;&lt;p&gt;把访问部分非核心业务的库表写操作迁移到 TiDB，打开 TiDB 的 Binlog 开关对线上 MySQL 进行反向同步。这个操作，保证只写 MySQL 的数据同步到 TiDB ，只写 TiDB 的数据也可以反向同步到 MySQL，保证出了问题，随时可以回滚。当业务长时间访问正常，可以增加切换流量，进行灰度切换。建议观察一段时间，至少一个月。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b3ab62e04da1be6385b531bb98cb039d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;854&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-b3ab62e04da1be6385b531bb98cb039d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b3ab62e04da1be6385b531bb98cb039d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;854&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-b3ab62e04da1be6385b531bb98cb039d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b3ab62e04da1be6385b531bb98cb039d_b.jpg&quot;/&gt;&lt;figcaption&gt;图 19 业务迁移之灰度切换&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;4）迁移完成&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当流量完全迁移完成，保持 TiDB 反同步到 MySQL 过程，继续观察一段时间，确认无误后，断开反向同步，100% 迁移完成。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8194bf59c99fbcf65acd3617bbf620b7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;877&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-8194bf59c99fbcf65acd3617bbf620b7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8194bf59c99fbcf65acd3617bbf620b7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;877&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-8194bf59c99fbcf65acd3617bbf620b7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8194bf59c99fbcf65acd3617bbf620b7_b.jpg&quot;/&gt;&lt;figcaption&gt;图 20 完成迁移&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;五、总结与展望&lt;/h2&gt;&lt;p&gt;TiDB 兼容 MySQL 协议，支持 TP/AP 事务且扩展性好，能很好地解决网易互娱计费组业务大容量、高可用等问题。目前我们的业务在不断深入和扩大规模使用 TiDB，因为看好它，所以这里提出一些使用中的问题以帮助原厂持续打磨产品：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;集群数据备份：希望提供集群更高效地备份和恢复 SST 文件的方式；&lt;/li&gt;&lt;li&gt;事务限制：希望可以放宽大事务的限制，现在仍需要人工切分大事务，比较复杂；&lt;/li&gt;&lt;li&gt;同步：希望 DM 支持上下游表结构不一致的同步；&lt;/li&gt;&lt;li&gt;数据热点问题：建议加强自动检测和清除热点功能；&lt;/li&gt;&lt;li&gt;客户端重试：目前客户端代码需要封装重试逻辑，对用户不友好，希望可以改进。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后，根据网易互娱计费组已有的使用情况，我们计划继续加大、加深 TiDB 的使用场景，丰富业务类型和使用规模，期待 TiDB 给我们的业务带来更多便利。&lt;/p&gt;&lt;p&gt;&lt;b&gt;阅读原文：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/cases-cn/user-case-wangyihuyu/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;网易互娱的数据库选型和 TiDB 应用实践 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;b&gt;更多精彩案例：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/cases-cn/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;案例 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-10-27-87945199</guid>
<pubDate>Sun, 27 Oct 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
