<div class="title-image"><img src="https://pic2.zhimg.com/v2-68150af88543996b0b4300954b876c35_b.jpg" alt=""></div><p>本文的作者为：长亭Litch1，一个给phith0n师傅递茶的小弟</p><p>对于不出网的反序列化回显，有比较经典的利用Linux文件描述符的方法：</p><a href="https://link.zhihu.com/?target=https%3A//xz.aliyun.com/t/7307" data-draft-node="block" data-draft-type="link-card" data-image="https://pic1.zhimg.com/v2-d8f863a2f6b6a92529dd70c95f275280_ipico.jpg" data-image-width="1188" data-image-height="1160" class=" wrap external" target="_blank" rel="nofollow noreferrer">linux下java反序列化通杀回显方法的低配版实现 - 先知社区</a><p>文章思路比较巧妙，但有一些局限性，对比起来感觉response直接写回显会比较方便，但是在通用性上也存在痛点：</p><ul><li><i>很多框架对于Serlvet进行了封装，不同框架实现不同，同一框架的不同版本实现也可能不同，因此我们无法利用一种简单通用的方法去获取当前请求的response。</i></li></ul><p>针对这一点，前几天在先知社区看到了<i>@kingkk师傅</i>的</p><a href="https://link.zhihu.com/?target=https%3A//xz.aliyun.com/t/7348" data-draft-node="block" data-draft-type="link-card" class=" wrap external" target="_blank" rel="nofollow noreferrer">Tomcat中一种半通用回显方法</a><p>学习了一下，师傅的思路很巧妙：通过反射修改控制变量，来改变Tomcat处理请求时的流程，使得Tomcat处理请求时便将request,response存入ThreadLocal中，最后在反序列化的时候便可以利用ThreadLocal来取出response。师傅的寻找过程主要是从Tomcat处理请求的调用栈中寻找有机会的代码流程。我在学习完师傅的文章之后也试着跟着调用栈寻找了一下，看是否有别的方法，但是发现这种方法比较掣肘于Tomcat处理请求时现有的流程，没有更好的发现。于是尝试换一种思路，不再寻求改变代码流程，而是找找有没有Tomcat全局存储的request或response。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-062ff158e41d6336c5bb6b13c7c3e594_b.jpg" data-caption="" data-size="normal" data-rawwidth="255" data-rawheight="255" class="content_image" width="255"/></noscript><img src="https://pic1.zhimg.com/v2-062ff158e41d6336c5bb6b13c7c3e594_b.jpg" data-caption="" data-size="normal" data-rawwidth="255" data-rawheight="255" class="content_image lazy" width="255" data-actualsrc="https://pic1.zhimg.com/v2-062ff158e41d6336c5bb6b13c7c3e594_b.jpg"/></figure><p>个人感觉要忽略框架来寻找request，response的关键点是寻找当前运行代码的上下文环境与Tomcat运行上下文环境之间的联系。比如<i>@kingkk师傅</i>所用的ThreadLocal就是这样的联系。</p><h2>寻找</h2><p>我们先看看Tomcat中哪个类会存储Request以及Response。</p><p>起一个SpringBoot调试一下看看，在调用链中发现继承Http11Processor的AbstractProcessor中有Request以及Response的Field，而且这两个Field都是final类型的，也就是说其在赋值之后，对于对象的引用是不会改变的，那么我们只要能够获取到这个Http11Processor就肯定可以拿到Request和Response。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-085cb9936ddd875fa6323f497cd56000_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="203" class="origin_image zh-lightbox-thumb" width="560" data-original="https://pic1.zhimg.com/v2-085cb9936ddd875fa6323f497cd56000_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-085cb9936ddd875fa6323f497cd56000_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="203" class="origin_image zh-lightbox-thumb lazy" width="560" data-original="https://pic1.zhimg.com/v2-085cb9936ddd875fa6323f497cd56000_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-085cb9936ddd875fa6323f497cd56000_b.jpg"/></figure><p>这时候已经有了request，response，接下来往前寻找有没有哪里存储了这个Processor？或者是哪里对于Processor的Request等信息进行了存储？可以发现在之前的调用链中的AbstractProtocol的内部类ConnectionHandler中在处理的时候就将当前的Processor的信息存储在了global中。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-d1e380e4f719f22ebe12d52dc2a1417f_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="253" class="origin_image zh-lightbox-thumb" width="560" data-original="https://pic4.zhimg.com/v2-d1e380e4f719f22ebe12d52dc2a1417f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-d1e380e4f719f22ebe12d52dc2a1417f_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="253" class="origin_image zh-lightbox-thumb lazy" width="560" data-original="https://pic4.zhimg.com/v2-d1e380e4f719f22ebe12d52dc2a1417f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-d1e380e4f719f22ebe12d52dc2a1417f_b.jpg"/></figure><p>其中这个RequestGroupInfo类型的核心就是一个存储所有RequestInfo的List</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-31c231edc161e4f191fa51ecb4f2ba02_b.png" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="44" class="origin_image zh-lightbox-thumb" width="560" data-original="https://pic3.zhimg.com/v2-31c231edc161e4f191fa51ecb4f2ba02_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-31c231edc161e4f191fa51ecb4f2ba02_b.png" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="44" class="origin_image zh-lightbox-thumb lazy" width="560" data-original="https://pic3.zhimg.com/v2-31c231edc161e4f191fa51ecb4f2ba02_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-31c231edc161e4f191fa51ecb4f2ba02_b.png"/></figure><p>那么到现在已经有了<i> AbstractProtocol$ConnectoinHandler-------&gt;global--------&gt;RequestInfo-------&gt;Request--------&gt;Response</i></p><p>再往后看调用栈，现在要寻找有没有地方有存储AbstractProtocol(继承AbstractProtocol的类)。</p><p>在CoyoteAdapter的service方法中，我们发现CoyoteAdapter的connector这个Field有很多关于Request的操作。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-22cd087c7e4987dc434cf41a24dc32b0_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="218" class="origin_image zh-lightbox-thumb" width="560" data-original="https://pic1.zhimg.com/v2-22cd087c7e4987dc434cf41a24dc32b0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-22cd087c7e4987dc434cf41a24dc32b0_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="218" class="origin_image zh-lightbox-thumb lazy" width="560" data-original="https://pic1.zhimg.com/v2-22cd087c7e4987dc434cf41a24dc32b0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-22cd087c7e4987dc434cf41a24dc32b0_b.jpg"/></figure><p>这个类中就有与AbstractProtocol有关的字段：protocolHandler ，这个field的类型为ProtocolHandler,可以看一下继承了ProtocolHandler的类，其中与HTTP11有关的也都继承了AbstractProtocol</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-1cb9b9d549379e16225502603e3f99b0_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="117" class="origin_image zh-lightbox-thumb" width="560" data-original="https://pic1.zhimg.com/v2-1cb9b9d549379e16225502603e3f99b0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-1cb9b9d549379e16225502603e3f99b0_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="117" class="origin_image zh-lightbox-thumb lazy" width="560" data-original="https://pic1.zhimg.com/v2-1cb9b9d549379e16225502603e3f99b0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-1cb9b9d549379e16225502603e3f99b0_b.jpg"/></figure><p>处理请求的部分我们就寻找完了，为<i>Connector-----&gt;AbstractProtocol$ConnectoinHandler-------&gt;global--------&gt;RequestInfo-------&gt;Request--------&gt;Response</i></p><p>而在Tomcat启动过程中有这样的方法，可以看到会将Connector放入Service中</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-09ad1b53ff817f2596492eb20e94fb29_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="192" class="origin_image zh-lightbox-thumb" width="560" data-original="https://pic2.zhimg.com/v2-09ad1b53ff817f2596492eb20e94fb29_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-09ad1b53ff817f2596492eb20e94fb29_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="192" class="origin_image zh-lightbox-thumb lazy" width="560" data-original="https://pic2.zhimg.com/v2-09ad1b53ff817f2596492eb20e94fb29_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-09ad1b53ff817f2596492eb20e94fb29_b.jpg"/></figure><p>这里的Service为StandardService，所以串起来就是：<i>StandardService---&gt;Connector---&gt;AbstractProtocol$ConnectoinHandler---&gt;RequestGroupInfo(global)---&gt;RequestInfo-------&gt;Request--------&gt;Response</i></p><h2>关键</h2><p><b>Tomcat的类加载机制并不是传统的双亲委派机制，因为传统的双亲委派机制并不适用于多个Web App的情况。</b></p><p>假设WebApp A依赖了common-collection 3.1，而WebApp B依赖了common-collection 3.2 这样在加载的时候由于全限定名相同，不能同时加载，所以必须对各个webapp进行隔离，如果使用双亲委派机制，那么在加载一个类的时候会先去他的父加载器加载，这样就无法实现隔离，tomcat隔离的实现方式是每个WebApp用一个独有的ClassLoader实例来优先处理加载，并不会传递给父加载器。这个定制的ClassLoader就是WebappClassLoader。</p><p>那么如何破坏Java原有的类加载机制呢？如果上层的ClassLoader需要调用下层的ClassLoader怎么办呢？就需要使用Thread Context ClassLoader，线程上下文类加载器。Thread类中有getContextClassLoader()和setContextClassLoader(ClassLoader cl)方法用来获取和设置上下文类加载器，如果没有setContextClassLoader(ClassLoader cl)方法通过设置类加载器，那么线程将继承父线程的上下文类加载器，如果在应用程序的全局范围内都没有设置的话，那么这个上下文类加载器默认就是应用程序类加载器。对于Tomcat来说ContextClassLoader被设置为WebAppClassLoader（在一些框架中可能是继承了public abstract WebappClassLoaderBase的其他Loader)。</p><p><b>说了那么多，其实WebappClassLoaderBase就是我们寻找的Thread和Tomcat 运行上下文的联系之一</b>。</p><p>我们debug看看Thread.currentThread.getContextClassLoader()里面都有啥东西，这里只要稍微搜寻一下就会发现有很多Tomcat有关的运行信息。我们只要寻找我们上文提到的需要的Service就可以了。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-62bcc23ff847e04dc91ad8f8fd053e53_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="196" class="origin_image zh-lightbox-thumb" width="560" data-original="https://pic4.zhimg.com/v2-62bcc23ff847e04dc91ad8f8fd053e53_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-62bcc23ff847e04dc91ad8f8fd053e53_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="196" class="origin_image zh-lightbox-thumb lazy" width="560" data-original="https://pic4.zhimg.com/v2-62bcc23ff847e04dc91ad8f8fd053e53_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-62bcc23ff847e04dc91ad8f8fd053e53_b.jpg"/></figure><p>最后的路径：</p><p><i>WebappClassLoaderBase ---&gt; ApplicationContext(getResources().getContext()) ---&gt; StandardService---&gt;Connector---&gt;AbstractProtocol$ConnectoinHandler---&gt;RequestGroupInfo(global)---&gt;RequestInfo-------&gt;Request--------&gt;Response</i></p><p>核心代码在修改完的ysoserial的util/Gardgets.java中。</p><h2>加入ysoserial</h2><p>我对ysoserial不是很熟，直接仿造<i>@kingkk师傅</i>把自己写的利用createTemplatesImpl加了进去。</p><p>新添加的链：</p><p>• CommonsBeanutils1TomcatHeader（用于解除tomcat对于request header的大小限制）</p><p>• CommonsBeanutils1TomcatEcho2</p><p>• CommonsCollections2TomcatEcho2</p><p>• CommonsCollections3TomcatEcho2</p><p>• CommonsCollections4TomcatEcho2</p><p>用法:</p><p>//为了区别出与普通request，需要在打的时候在request header加上<i> tomcat: tomcat</i><br/><i>java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1TomcatEcho2 yourCommand</i></p><p>github地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/buptchk/ysoserial/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/buptchk/ysos</span><span class="invisible">erial/</span><span class="ellipsis"></span></a></p><p><b>测试SpringBoot（内置Tomcat8.0.30)：</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-df3dca72e402846c9f16c7f3f7c944b0_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="174" class="origin_image zh-lightbox-thumb" width="560" data-original="https://pic1.zhimg.com/v2-df3dca72e402846c9f16c7f3f7c944b0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-df3dca72e402846c9f16c7f3f7c944b0_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="174" class="origin_image zh-lightbox-thumb lazy" width="560" data-original="https://pic1.zhimg.com/v2-df3dca72e402846c9f16c7f3f7c944b0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-df3dca72e402846c9f16c7f3f7c944b0_b.jpg"/></figure><p><b>测试普通的JSP(Tomcat 9.0.7)：</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-f88549d7c50fd97419ec81f59c6e7cb0_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="174" class="origin_image zh-lightbox-thumb" width="560" data-original="https://pic1.zhimg.com/v2-f88549d7c50fd97419ec81f59c6e7cb0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-f88549d7c50fd97419ec81f59c6e7cb0_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="174" class="origin_image zh-lightbox-thumb lazy" width="560" data-original="https://pic1.zhimg.com/v2-f88549d7c50fd97419ec81f59c6e7cb0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-f88549d7c50fd97419ec81f59c6e7cb0_b.jpg"/></figure><p><b>测试shiro(vulhub中的环境)：</b></p><p>测试shiro的时候，发现一个问题，生成的payload太长了 ，已经超过了Tomcat默认的max header的大小，经过一再缩减也没有成功，于是考虑通过改变Tomcat max header的大小解除限制，思路是改变org.apache.coyote.http11.AbstractHttp11Protocol的maxHeaderSize的大小，这个值会影响新的Request的inputBuffer时的对于header的限制，但是由于request的inputbuffer会复用，所以我们在修改完maxHeaderSize之后，需要多个连接同时访问，让tomcat新建request的inputbuffer，这时候的buffer的大小限制就会使用我们修改过后的值。</p><p>具体的攻击流程：</p><ul><li><i>//生成改变max header的较短payload，并发送过去</i></li><li><i>java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1TomcatHeader yourSize</i></li><li><i>//生成较长的回显payload，使用多个线程同时发送，注意控制发送payload的数量，一般来说在连接少的情况下发送10个之内就可以成功</i></li><li><i>java -jarysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1TomcatEcho2 yourCommand</i></li></ul><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-ae0101a9cb92199ff2168c3cc84d7673_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="525" class="origin_image zh-lightbox-thumb" width="560" data-original="https://pic4.zhimg.com/v2-ae0101a9cb92199ff2168c3cc84d7673_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-ae0101a9cb92199ff2168c3cc84d7673_b.jpg" data-caption="" data-size="normal" data-rawwidth="560" data-rawheight="525" class="origin_image zh-lightbox-thumb lazy" width="560" data-original="https://pic4.zhimg.com/v2-ae0101a9cb92199ff2168c3cc84d7673_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-ae0101a9cb92199ff2168c3cc84d7673_b.jpg"/></figure><h2>最后</h2><p>从<i>@kingkk师傅</i>的文章中学到了很多，也因此在加入ysoserial的时候少踩了不少坑。</p><p>Thread.currentThread.getContextClassLoader()最终获取到request的办法应该不止一种，但有的可能有版本问题。</p><p>同时这个方法也有一些局限性，已知的局限性：</p><ul><li><b>由于是从很多连接中筛出自己当前的那一条，连接较多时，可能有性能问题,并且对于shiro拓展header的问题，在连接特别多的情况下可能不适用(猜测有可能不会再新建inputBuffer，还没有进行测试。</b></li><li><b>我自己测试的Tomcat版本较少，由于涉及到较多的Tomcat内部类，所以Tomcat实现改变的话就会有问题(我其实原来是用的另一种写法，但后来发现有版本问题)。</b></li></ul><h2>最后的最后</h2><p><i>@threedr3am师傅</i>刚发了一篇</p><a href="https://link.zhihu.com/?target=https%3A//xz.aliyun.com/t/7388" data-draft-node="block" data-draft-type="link-card" data-image="https://pic4.zhimg.com/v2-4d23566df50aa80078786b259ecb1823_180x120.jpg" data-image-width="2770" data-image-height="1112" class=" wrap external" target="_blank" rel="nofollow noreferrer">基于tomcat的内存 Webshell 无文件攻击技术 - 先知社区</a><p>思路也很赞，感觉也可以基于Thread.currentThread.getContextClassLoader()来动态注册Filter，有兴趣的师傅可以试一下哈。</p><p>本人水平有限，如果师傅发现文章中的疏漏，欢迎指出来可以一起探讨~</p>