<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TiDB 源码阅读系列文章（十）Chunk 和执行框架简介</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/38095421">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-23b3db33eab46a4f9f2fa39360197f04_r.jpg" alt=""></div><blockquote>作者：@张建</blockquote><h2><b>什么是 Chunk</b></h2><p>TiDB 2.0 中，我们引入了一个叫 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L32">Chunk</a> 的数据结构用来在内存中存储内部数据，用于减小内存分配开销、降低内存占用以及实现内存使用量统计/控制，其特点如下：</p><ul><li>只读</li><li>不支持随机写</li><li>只支持追加写</li><li>列存，同一列的数据连续的在内存中存放</li></ul><p>Chunk 本质上是 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L320">Column</a> 的集合，它负责连续的在内存中存储同一列的数据，接下来我们看看 Column 的实现。<br><br><b>1. Column</b></p><p>Column 的实现参考了 Apache Arrow，Column 的代码在 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L320">这里</a>。根据所存储的数据类型，我们有两种 Column：</p><ul><li>定长 Column：存储定长类型的数据，比如 <code class="inline">Double</code>、<code class="inline">Bigint</code>、<code class="inline">Decimal</code> 等</li><li>变长 Column：存储变长类型的数据，比如 <code class="inline">Char</code>、<code class="inline">Varchar</code> 等</li></ul><p>哪些数据类型用定长 Column，哪些数据类型用变长 Column 可以看函数 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L90">addColumnByFieldType</a> 。</p><p>Column 里面的字段非常多，这里先简单介绍一下：</p><ul><li>length </li></ul><p>用来表示这个 Column 有多少行数据。</p><ul><li>nullCount</li></ul><p>用来表示这个 Column 中有多少 <code class="inline">NULL</code> 数据。</p><ul><li>nullBitmap</li></ul><p>用来存储这个 Column 中每个元素是否是 <code class="inline">NULL</code>，需要特殊注意的是我们使用 0 表示 <code class="inline">NULL</code>，1 表示非 <code class="inline">NULL</code>，和 Apache Arrow 一样。</p><ul><li>data</li></ul><p>存储具体的数据，不管定长还是变长的 Column，所有的数据都存储在这个 byte slice 中。</p><ul><li>offsets</li></ul><p>给变长的 Column 使用，存储每个数据在 data 这个 slice 中的偏移量。</p><ul><li>elemBuf</li></ul><p>给定长的 Column 使用，当需要读或者写一个数据的时候，使用它来辅助 encode 和 decode。</p><p><br></p><p><b>1.1  追加一个定长的非 NULL 值</b></p><p>追加一个元素需要根据具体的数据类型调用具体的 append 方法，比如： <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L378">appendInt64</a>、<a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L404">appendString</a> 等。<br>一个定长类型的 Column 可以用如下图表示:</p><img src="https://pic1.zhimg.com/v2-0f164200b3563b7433656d3fcd1c5174_r.jpg" data-caption="" data-size="normal" data-rawwidth="634" data-rawheight="156" data-watermark="watermark" data-original-src="v2-0f164200b3563b7433656d3fcd1c5174" data-watermark-src="v2-0a1ce58f54f86188b4976e81cbdb241d" data-private-watermark-src=""><p><br>我们以 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L378">appendInt64</a> 为例来看看如何追加一个定长类型的数据：</p><ul><li>使用 <code class="inline">unsafe.Pointer</code> 把要 append 的数据先复制到 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L326">elemBuf</a> 中；</li><li>将 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L326">elemBuf</a> 中的数据 append 到 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L325">data</a> 中；</li><li>往 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L323">nullBitmap</a> 中 append 一个 1。</li></ul><p>上面第 1 步在 <code class="inline">appendInt64</code> 这个函数中完成，第 2、3 步在 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L372">finishAppendFixed</a> 这个函数中完成。其他定长类型元素的追加操作非常相似，感兴趣的同学可以接着看看 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L388">appendFloat32</a>、<a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L414">appendTime</a> 等函数。</p><p><br></p><p><b>1.2  追加一个变长的非 NULL 值</b></p><p>而一个变长的 Column 可以用下图表示：</p><img src="https://pic1.zhimg.com/v2-c01c278418cd2f8f15f2953bd3ef5a76_r.jpg" data-caption="" data-size="normal" data-rawwidth="941" data-rawheight="196" data-watermark="watermark" data-original-src="v2-c01c278418cd2f8f15f2953bd3ef5a76" data-watermark-src="v2-18a8be583d750b82fb3b7956c619f0df" data-private-watermark-src=""><p><br>我们以 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L404">appendString</a> 为例来看看如何追加一个变长类型的数据：</p><ul><li>把数据先 append 到 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L325">data</a> 中；</li><li>往 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L323">nullBitmap</a> 中 append 一个 1；</li><li>往 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L324">offsets</a> 中 append 当前 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L325">data</a> 的 size 作为下一个元素在 data 中的起始点。</li></ul><p>上面第 1 步在 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L404">appendString</a> 这个函数中完成，第 2、3 步在 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L398">finishAppendVar</a> 这个函数中完成。其他边长类型元素的追加操作也是非常相似，感兴趣的同学可以接着看看 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L409">appendBytes</a>、<a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L449">appendJSON</a> 等函数。</p><p><b>1.3  追加一个 NULL 值</b></p><p>我们使用 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L362">appendNull</a> 函数来向一个 Column 中追加一个 <code class="inline">NULL</code> 值：</p><ul><li>往 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L323">nullBitmap</a> 中 append 一个 0；</li><li>如果是定长 Column，需要往 data 中 append 一个 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L326">elemBuf</a> 长度的数据，用来占位；</li><li>如果是变长 Column，不用往 data中 append 数据，而是往 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L324">offsets</a> 中 append 当前 data 的 size 作为下一个元素在 data 中的起始点。</li></ul><p><b>2. Row</b></p><img src="https://pic2.zhimg.com/v2-e955b29d2d3f711028fb35eacb4da90a_r.jpg" data-caption="" data-size="normal" data-rawwidth="301" data-rawheight="347" data-watermark="watermark" data-original-src="v2-e955b29d2d3f711028fb35eacb4da90a" data-watermark-src="v2-b3e0dacdc44654138402f51bc6dc3367" data-private-watermark-src=""><p><br>如上图所示，Chunk 中的 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L456">Row</a> 是一个逻辑上的概念：Row 中的数据存储在 Chunk 的各个 Column 中，同一个 Row 中的数据在内存中没有连续存储在一起，我们在获取一个 Row 对象的时候也不需要进行数据拷贝。提供 Row 的概念是因为算子运行过程中，大多数情况都是以 Row 为单位访问和操作数据，比如聚合，排序等。 </p><p>Row 提供了获取 Chunk 中数据的方法，比如 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L472">GetInt64</a>、<a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L496">GetString</a>、<a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L563">GetMyDecimal</a> 等，前面介绍了往 Column 中 append 数据的方法，获取数据的方法可以由 append 数据的方法反推，代码也比较简单，这里就不再详细介绍了。</p><p><br><b>3. 使用</b></p><p>目前 Chunk 这个包只对外暴露了 Chunk, Row 等接口，而没有暴露 Column，所以，写数据调用的是在 Chunk 上实现的对 Column 具体函数的 warpper，比如 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L230">AppendInt64</a>；读数据调用的是在 Row 上实现的 Getxxx 函数，比如 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L472">GetInt64</a>。</p><h2><b>执行框架简介</b></h2><p><b>1. 老执行框架简介</b></p><p>在重构前，TiDB 1.0 中使用的执行框架会不断调用 Child 的 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/executor.go#L191">Next</a> 函数获取一个由 Datum 组成的 Row（和刚才介绍的 Chunk Row 是两个数据结构），这种执行方式的特点是：每次函数调用只返回一行数据，且不管是什么类型的数据都用 Datum 这个结构体来封装。<br></p><img src="https://pic1.zhimg.com/v2-1271c308a21b086e23c50728d83eafc5_r.jpg" data-caption="" data-size="normal" data-rawwidth="192" data-rawheight="380" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p><br>这种方法的优点是简单、易用。缺点是：</p><ul><li>如果处理的数据量多，那么框架上的函数调用开销将会非常大；</li><li>Datum 占用的无效内存太大，内存浪费比较多（存一个 8 字节的整数需要 56 字节）；</li><li>Datum 没有重用，golang 的 gc 压力大；</li><li>每个 Operator 一次只输出一行数据，要进行更加缓存友好的计算、更充分的利用 CPU 的 pipeline 非常困难；</li><li>Datum 中的 interface 类型的数据，统计它的内存使用量比较困难。</li></ul><p><b>2. 新执行框架简介</b></p><p>在重构后，TiDB 2.0 中使用的执行框架会不断调用 Child 的 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/executor.go#L198">NextChunk</a> 函数，获取一个 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L32">Chunk</a> 的数据。</p><img src="https://pic1.zhimg.com/v2-f9ade9cdfe393088d0841f55fd8a02f2_r.jpg" data-caption="" data-size="normal" data-rawwidth="192" data-rawheight="380" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p><br>这种执行方式的特点是：</p><ul><li>每次函数调用返回一批数据，数据量由一个叫 <code class="inline">tidb_max_chunk_size</code> 的 session 变量来控制，默认是 1024 行。因为 TiDB 是一个混合 TP 和 AP 的数据库，对于 AP 类型的查询来说，因为计算的数据量大，1024 没啥问题，但是对于 TP 请求来说，计算的数据量可能比较少，直接在一开始就分配 1024 行的内存并不是最佳的实践（ <a href="https://github.com/pingcap/tidb/issues/6489">这里</a> 有个 github issue 讨论这个问题，欢迎感兴趣的同学来讨论和解决）。</li><li>Child 把它产出的数据写入到 Parent 传下来的 <a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L32">Chunk</a> 中。</li></ul><p>这种执行方式的好处是：</p><ul><li>减少了框架上的函数调用开销。比如同样输出 1024 行结果，现在的函数调用次数将会是以前的 1/1024。</li><li>内存使用更加高效。Chunk 中的数据组织非常紧凑，存一个 8 字节的整数几乎就只需要 8 字节，没有其他额外的内存开销了。</li><li>减轻了 golang 的 gc 压力。Chunk 占用的内存可以不断地重复利用，不用频繁的申请新内存，从而减轻了 golang 的 gc 压力。</li><li>查询的执行过程更加缓存友好。如我们之前所说，Chunk 按列来组织数据，在计算的过程中我们也尽量按列来计算，这样既能让一列的数据尽量长时间的待在 Cache 中，减轻 Cache Miss 率，也能充分利用起 CPU 的 pipeline。这一块在后续的源码分析文章中会有详细介绍，这里就不再展开了。</li><li>内存监控和控制更加方便。Chunk 中没有使用任何 interface，我们能很方便的直接获取一个 Chunk 当前所占用的内存的大小，具体可以看这个函数：<a href="https://github.com/pingcap/tidb/blob/source-code/util/chunk/chunk.go#L63">MemoryUsage</a>。关于 TiDB 内存控制，我们也会在后续文章中详细介绍，这里也不再展开了。</li></ul><p><b>3.  新旧执行框架性能对比</b></p><p>采用了新的执行框架后，OLAP 类型语句的执行速度、内存使用效率都有极大提升，从 <a href="https://github.com/pingcap/docs-cn/blob/master/benchmark/tpch.md">TPC-H 对比结果</a> 看，性能有数量级的提升。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
