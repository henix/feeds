<div class="title-image"><img src="https://pic4.zhimg.com/v2-14cbccbc6a4bbb99662a0894ee226b0a_b.jpg" alt=""></div><p>作者： <a class="member_mention" href="https://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06" data-hash="6f8ffd80705c262c2ee3fa4d9b3f8f06" data-hovercard="p$b$6f8ffd80705c262c2ee3fa4d9b3f8f06">@周佩雨</a> ，就职于长亭科技</p><p>JavaScript是一门非常灵活的语言，我感觉在某些方面可能比PHP更加灵活。所以，除了传统的SQL注入、代码执行等注入型漏洞外，也会有一些独有的安全问题，比如今天要说这个prototype污染。</p><h2><a href="https://link.zhihu.com/?target=https%3A//www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html%230x01-prototype__proto__" class=" wrap external" target="_blank" rel="nofollow noreferrer">0x01 prototype和__proto__分别是什么？</a></h2><p>JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义：</p><p>function Foo() { this.bar = 1 } new Foo() </p><p><code>Foo</code>函数的内容，就是<code>Foo</code>类的构造函数，而<code>this.bar</code>就是<code>Foo</code>类的一个属性。</p><blockquote>为了简化编写JavaScript代码，ECMAScript 6后增加了<code>class</code>语法，但<code>class</code>其实只是一个语法糖。</blockquote><p>一个类必然有一些方法，类似属性<code>this.bar</code>，我们也可以将方法定义在构造函数内部：</p><p>function Foo() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new Foo()).show() </p><p>但这样写有一个问题，就是每当我们新建一个Foo对象时，<code>this.show = function...</code>就会执行一次，这个<code>show</code>方法实际上是绑定在对象上的，而不是绑定在“类”中。</p><p>我希望在创建类的时候只创建一次<code>show</code>方法，这时候就则需要使用原型（prototype）了：</p><p>function Foo() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let foo = new Foo() foo.show() </p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-592e9ec1083e88ef2c5c5cebbece337e_b.jpg" data-caption="" data-size="normal" data-rawwidth="554" data-rawheight="325" class="origin_image zh-lightbox-thumb" width="554" data-original="https://pic3.zhimg.com/v2-592e9ec1083e88ef2c5c5cebbece337e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-592e9ec1083e88ef2c5c5cebbece337e_b.jpg" data-caption="" data-size="normal" data-rawwidth="554" data-rawheight="325" class="origin_image zh-lightbox-thumb lazy" width="554" data-original="https://pic3.zhimg.com/v2-592e9ec1083e88ef2c5c5cebbece337e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-592e9ec1083e88ef2c5c5cebbece337e_b.jpg"/></figure><p>我们可以认为原型<code>prototype</code>是类<code>Foo</code>的一个属性，而所有用<code>Foo</code>类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的<code>foo</code>对象，其天生就具有<code>foo.show()</code>方法。</p><p>我们可以通过<code>Foo.prototype</code>来访问<code>Foo</code>类的原型，但<code>Foo</code>实例化出来的对象，是不能通过prototype访问原型的。这时候，就该<code>__proto__</code>登场了。</p><p>一个Foo类实例化出来的foo对象，可以通过<code>foo.__proto__</code>属性来访问Foo类的原型，也就是说：</p><p>foo.__proto__ == Foo.prototype </p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-fd63de1cae36e310c2dee9a314a1cfd3_b.jpg" data-caption="" data-size="normal" data-rawwidth="340" data-rawheight="103" class="content_image" width="340"/></noscript><img src="https://pic4.zhimg.com/v2-fd63de1cae36e310c2dee9a314a1cfd3_b.jpg" data-caption="" data-size="normal" data-rawwidth="340" data-rawheight="103" class="content_image lazy" width="340" data-actualsrc="https://pic4.zhimg.com/v2-fd63de1cae36e310c2dee9a314a1cfd3_b.jpg"/></figure><p>所以，总结一下：</p><ol><li><code>prototype</code>是一个类的属性，所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法</li><li>一个对象的<code>__proto__</code>属性，指向这个对象所在的类的<code>prototype</code>属性</li></ol><h2><b><a href="https://link.zhihu.com/?target=https%3A//www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html%230x02-javascript" class=" wrap external" target="_blank" rel="nofollow noreferrer">0x02 JavaScript原型链继承</a></b></h2><p>所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法，这个特性被用来实现JavaScript中的继承机制。</p><p>比如：</p><p>function Father() { this.first_name = &#39;Donald&#39; this.last_name = &#39;Trump&#39; } function Son() { this.first_name = &#39;Melania&#39; } Son.prototype = new Father() let son = new Son() console.log(`Name: ${son.first_name} ${son.last_name}`) </p><p>Son类继承了Father类的<code>last_name</code>属性，最后输出的是<code>Name: Melania Trump</code>。</p><p>总结一下，对于对象son，在调用<code>son.last_name</code>的时候，实际上JavaScript引擎会进行如下操作：</p><ol><li>在对象son中寻找last_name</li><li>如果找不到，则在<code>son.__proto__</code>中寻找last_name</li><li>如果仍然找不到，则继续在<code>son.__proto__.__proto__</code>中寻找last_name</li><li>依次寻找，直到找到<code>null</code>结束。比如，<code>Object.prototype</code>的<code>__proto__</code>就是<code>null</code> </li></ol><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-5260663ac7b25022e596d9746c3f5454_b.jpg" data-caption="" data-size="normal" data-rawwidth="650" data-rawheight="296" class="origin_image zh-lightbox-thumb" width="650" data-original="https://pic1.zhimg.com/v2-5260663ac7b25022e596d9746c3f5454_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-5260663ac7b25022e596d9746c3f5454_b.jpg" data-caption="" data-size="normal" data-rawwidth="650" data-rawheight="296" class="origin_image zh-lightbox-thumb lazy" width="650" data-original="https://pic1.zhimg.com/v2-5260663ac7b25022e596d9746c3f5454_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-5260663ac7b25022e596d9746c3f5454_b.jpg"/></figure><p>JavaScript的这个查找的机制，被运用在面向对象的继承中，被称作prototype继承链。</p><p>以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可：</p><ol><li>每个构造函数(constructor)都有一个原型对象(prototype)</li><li>对象的<code>__proto__</code>属性，指向类的原型对象<code>prototype</code></li><li>JavaScript使用prototype链实现继承机制</li></ol><h2><b><a href="https://link.zhihu.com/?target=https%3A//www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html%230x03" class=" wrap external" target="_blank" rel="nofollow noreferrer">0x03 原型链污染是什么</a></b></h2><p>第一章中说到，<code>foo.__proto__</code>指向的是<code>Foo</code>类的<code>prototype</code>。那么，如果我们修改了<code>foo.__proto__</code>中的值，是不是就可以修改Foo类呢？</p><p>做个简单的实验：</p><p>// foo是一个简单的JavaScript对象 let foo = {bar: 1} // foo.bar 此时为1 console.log(foo.bar) // 修改foo的原型（即Object） foo.__proto__.bar = 2 // 由于查找顺序的原因，foo.bar仍然是1 console.log(foo.bar) // 此时再用Object创建一个空的zoo对象 let zoo = {} // 查看zoo.bar console.log(zoo.bar) </p><p>最后，虽然zoo是一个<b>空</b>对象<code>{}</code>，但<code>zoo.bar</code>的结果居然是2：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-e72846c5e6d590c392d2a1d01893e942_b.jpg" data-caption="" data-size="normal" data-rawwidth="537" data-rawheight="440" class="origin_image zh-lightbox-thumb" width="537" data-original="https://pic3.zhimg.com/v2-e72846c5e6d590c392d2a1d01893e942_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-e72846c5e6d590c392d2a1d01893e942_b.jpg" data-caption="" data-size="normal" data-rawwidth="537" data-rawheight="440" class="origin_image zh-lightbox-thumb lazy" width="537" data-original="https://pic3.zhimg.com/v2-e72846c5e6d590c392d2a1d01893e942_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-e72846c5e6d590c392d2a1d01893e942_b.jpg"/></figure><p>原因也显而易见：因为前面我们修改了foo的原型<code>foo.__proto__.bar = 2</code>，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。</p><p>后来，我们又用Object类创建了一个zoo对象<code>let zoo = {}</code>，zoo对象自然也有一个bar属性了。</p><p>那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是<b>原型链污染</b>。</p><h2><b><a href="https://link.zhihu.com/?target=https%3A//www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html%230x04" class=" wrap external" target="_blank" rel="nofollow noreferrer">0x04 哪些情况下原型链会被污染？</a></b></h2><p>在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？</p><p>我们思考一下，哪些情况下我们可以设置<code>__proto__</code>的值呢？其实找找能够控制数组（对象）的“键名”的操作即可：</p><ul><li>对象merge</li><li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li></ul><p>以对象merge为例，我们想象一个简单的merge函数：</p><p>function merge(target, source) { for (let key in source) { if (key in source &amp;&amp; key in target) { merge(target[key], source[key]) } else { target[key] = source[key] } } } </p><p>在合并的过程中，存在赋值的操作<code>target[key] = source[key]</code>，那么，这个key如果是<code>__proto__</code>，是不是就可以原型链污染呢？</p><p>我们用如下代码实验一下：</p><p>let o1 = {} let o2 = {a: 1, &#34;__proto__&#34;: {b: 2}} merge(o1, o2) console.log(o1.a, o1.b) o3 = {} console.log(o3.b) </p><p>结果是，合并虽然成功了，但原型链没有被污染：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-0bfd885d1307e17fadfa6912b8c481c0_b.jpg" data-caption="" data-size="normal" data-rawwidth="624" data-rawheight="500" class="origin_image zh-lightbox-thumb" width="624" data-original="https://pic1.zhimg.com/v2-0bfd885d1307e17fadfa6912b8c481c0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-0bfd885d1307e17fadfa6912b8c481c0_b.jpg" data-caption="" data-size="normal" data-rawwidth="624" data-rawheight="500" class="origin_image zh-lightbox-thumb lazy" width="624" data-original="https://pic1.zhimg.com/v2-0bfd885d1307e17fadfa6912b8c481c0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-0bfd885d1307e17fadfa6912b8c481c0_b.jpg"/></figure><p>这是因为，我们用JavaScript创建o2的过程（<code>let o2 = {a: 1, &#34;__proto__&#34;: {b: 2}}</code>）中，<code>__proto__</code>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是<code>[a, b]</code>，<code>__proto__</code>并不是一个key，自然也不会修改Object的原型。</p><p>那么，如何让<code>__proto__</code>被认为是一个键名呢？</p><p>我们将代码改成如下：</p><p>let o1 = {} let o2 = JSON.parse(&#39;{&#34;a&#34;: 1, &#34;__proto__&#34;: {&#34;b&#34;: 2}}&#39;) merge(o1, o2) console.log(o1.a, o1.b) o3 = {} console.log(o3.b) </p><p>可见，新建的o3对象，也存在b属性，说明Object已经被污染：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-a51b1f8cd603e76d62ce9036765f971b_b.jpg" data-caption="" data-size="normal" data-rawwidth="650" data-rawheight="430" class="origin_image zh-lightbox-thumb" width="650" data-original="https://pic4.zhimg.com/v2-a51b1f8cd603e76d62ce9036765f971b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-a51b1f8cd603e76d62ce9036765f971b_b.jpg" data-caption="" data-size="normal" data-rawwidth="650" data-rawheight="430" class="origin_image zh-lightbox-thumb lazy" width="650" data-original="https://pic4.zhimg.com/v2-a51b1f8cd603e76d62ce9036765f971b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-a51b1f8cd603e76d62ce9036765f971b_b.jpg"/></figure><p>这是因为，JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p><p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。</p><h2><b><a href="https://link.zhihu.com/?target=https%3A//www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html%230x05-code-breaking-2018-thejs" class=" wrap external" target="_blank" rel="nofollow noreferrer">0x05 Code-Breaking 2018 Thejs 分析</a></b></h2><p>我在Code-Breaking 2018中出了一道原型链污染的CTF题目，为了更加贴合真实环境，我没有刻意加太多自己的代码，后端主要代码如下（完整代码可参考<a href="https://link.zhihu.com/?target=https%3A//github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a>）：</p><p>// ... const lodash = require(&#39;lodash&#39;) // ... app.engine(&#39;ejs&#39;, function (filePath, options, callback) { // define the template engine fs.readFile(filePath, (err, content) =&gt; { if (err) return callback(new Error(err)) let compiled = lodash.template(content) let rendered = compiled({...options}) return callback(null, rendered) }) }) //... app.all(&#39;/&#39;, (req, res) =&gt; { let data = req.session.data || {language: [], category: []} if (req.method == &#39;POST&#39;) { data = lodash.merge(data, req.body) req.session.data = data } res.render(&#39;index&#39;, { language: data.language, category: data.category }) }) </p><p>lodash是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具：</p><ol><li><code>lodash.template</code> 一个简单的模板引擎</li><li><code>lodash.merge</code> 函数或对象的合并</li></ol><p>其实整个应用逻辑很简单，用户提交的信息，用merge方法合并到session里，多次提交，session里最终保存你提交的所有信息。</p><p>而这里的<code>lodash.merge</code>操作实际上就存在原型链污染漏洞。</p><p>在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的<code>lodash.template</code>中。我们看到<code>lodash.template</code>的代码：<a href="https://link.zhihu.com/?target=https%3A//github.com/lodash/lodash/blob/4.17.4-npm/template.js%23L165" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/lodash/lodas</span><span class="invisible">h/blob/4.17.4-npm/template.js#L165</span><span class="ellipsis"></span></a></p><p>// Use a sourceURL for easier debugging. var sourceURL = &#39;sourceURL&#39; in options ? &#39;//# sourceURL=&#39; + options.sourceURL + &#39;\n&#39; : &#39;&#39;; // ... var result = attempt(function() { return Function(importsKeys, sourceURL + &#39;return &#39; + source) .apply(undefined, importsValues); }); </p><p>options是一个对象，sourceURL取到了其<code>options.sourceURL</code>属性。这个属性原本是没有赋值的，默认取空字符串。</p><p>但因为原型链污染，我们可以给所有Object对象中都插入一个<code>sourceURL</code>属性。最后，这个<code>sourceURL</code>被拼接进<code>new Function</code>的第二个参数中，造成任意代码执行漏洞。</p><p>我将带有<code>__ptoto__</code>的Payload以json的形式发送给后端，因为express框架支持根据Content-Type来解析请求Body，这里给我们注入原型提供了很大方便：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-42c5b8d5250c459c70997fc136f61760_b.jpg" data-caption="" data-size="normal" data-rawwidth="650" data-rawheight="122" class="origin_image zh-lightbox-thumb" width="650" data-original="https://pic1.zhimg.com/v2-42c5b8d5250c459c70997fc136f61760_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-42c5b8d5250c459c70997fc136f61760_b.jpg" data-caption="" data-size="normal" data-rawwidth="650" data-rawheight="122" class="origin_image zh-lightbox-thumb lazy" width="650" data-original="https://pic1.zhimg.com/v2-42c5b8d5250c459c70997fc136f61760_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-42c5b8d5250c459c70997fc136f61760_b.jpg"/></figure><p>可见，我们代码执行成功，返回了id命令的结果。</p><p>整个案例我觉得是一个非常经典的原型链污染漏洞教程，代码不多，逻辑不复杂，没有刻意创造漏洞，真正触发漏洞的代码在库中。</p><p>我一直觉得，出题不要刻意创造漏洞，而是找找你的知识点是否能在真实环境下找到应用。</p><h2><b><a href="https://link.zhihu.com/?target=https%3A//www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html%23_1" class=" wrap external" target="_blank" rel="nofollow noreferrer">相关文章</a></b></h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/HoLyVieR/pro</span><span class="invisible">totype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf</span><span class="ellipsis"></span></a></li><li><a href="https://link.zhihu.com/?target=https%3A//xz.aliyun.com/t/2802" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">xz.aliyun.com/t/2802</span><span class="invisible"></span></a></li><li><a href="https://link.zhihu.com/?target=https%3A//xz.aliyun.com/t/2735" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">xz.aliyun.com/t/2735</span><span class="invisible"></span></a></li></ul>