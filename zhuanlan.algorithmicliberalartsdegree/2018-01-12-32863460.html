<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>震惊！有向图中的k割之王！背后的秘密居然是这样的！</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/32863460">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-c6d5b6998a4787b66f0f5296bb0dc304_r.jpg" alt=""></div><p></p><p>让 <equation>G=(V,E)</equation> 为一个无向图, 一个集合 <equation>F\subseteq E</equation> 叫做k-cut(k割), 如果删除这个边的集合, 则新的图里至少有k个连通分量. 2-cut就是图上的割. 割在各种优化问题中都会出现, 比如计算视觉里的图像分割.</p><p>我们的目的是找到minimum k-cut. 就是边数最小的k-cut. (或者最小权值的k-cut, 一样的方法), 而边数最小的k割我们称之为<b>k割之王</b>. </p><p>难以置信的是, 无向图上的minimum k-cut竟然是可以在多项式时间内解决的! 有兴趣知道已知算法的话可以看<a href="http://chaoxu3.web.engr.illinois.edu/paper/hypergraph_k_cut.pdf">最近的一篇文章里的introduction</a>.</p><p><br></p><p>当然, k-cut还有其他的不同的但是在无向图上等价的定义. 比如, 一个边的集合F叫做k-cut, 如果</p><ol><li><equation>G-F</equation> 里存在 <equation>k</equation> 个顶点T, 使得对于任意 <equation>v\in T</equation> ,  <equation>v</equation> 最多能达到<equation>T</equation>中的一个顶点.</li><li><equation>G-F</equation> 里存在 <equation>k</equation> 个顶点T, 使得对于任意 <equation>v\in V</equation> ,  <equation>v</equation> 最多能达到<equation>T</equation>中的一个顶点.</li></ol><p>这两个定义里的区别只有一个字符,  <equation>T</equation> 被换成了 <equation>V</equation> . 这两个定义在无向图里是一模一样的. 但是在<b>有向图</b>中就不同了. </p><p>我们发现如果使用第一个定义的话, 在有向图里, 我们仍未知道2-cut是否是可以多项式时间内解决. 谁能做出来将获得我贡献的$100美元.</p><p>但是如果用第二个定义, 却可以证明对于任意常数k, k-cut可以多项式时间内解决. </p><p>文章以下都用第二个定义.</p><p>正式的说明一下问题. </p><blockquote><b>有向图上的最小k割问题</b><br><b>输入:</b> 一个有向图 <equation>G=(V,E)</equation><br><b>输出:</b>  最小的<equation>F\subseteq E</equation> , 使得 <equation>G-F</equation> 里存在 <equation>k</equation> 个顶点 <equation>T</equation> , 使得对于任意 <equation>v\in V</equation> ,  <equation>v</equation> 最多能达到<equation>T</equation>中的一个顶点. </blockquote><p>这个看起来实际上是非常像NP-hard的问题, 但神奇的是竟然可以多项式时间内解决. 注意这里k是常数, 如果k也属于输入则是NP-hard的.</p><blockquote><b>定义:</b> 对于一个有向图G, 一个顶点集合的 <equation>S</equation> 的值是 <equation>f(S)</equation> , 定义为有多少条边的头在 <equation>S</equation> 里, 尾在 <equation>V\setminus S </equation> 里.</blockquote><p><br></p><blockquote><b>定理1:</b> <equation>G</equation> 里存在 <equation>k</equation> 个顶点 <equation>T</equation> , 使得对于任意 <equation>v\in V</equation> ,  <equation>v</equation> 最多只能达到<equation>T</equation>中的一个顶点. 有且仅有存在k个互不相交的 <equation>V</equation> 的非空子集, <equation>V_1,...,V_k</equation> , 使得对于任意 <equation>i</equation> , <equation>V_i</equation> 的值为0</blockquote><p>k个不相交的非空集合叫做k-subpartition. 这说明了只要我们能找到k个k-subpartition  <equation>V_1,...,V_k</equation> , 使得 <equation>\sum_{i} f(V_i)</equation> 最小即可. 那么我们现在要解决的问题就是找最优的k-subpartition, 也就是让里面的集合的值的和最小的k-subpartition.</p><blockquote><b>定义:</b> 一个集合S叫做实心的, 如果对于任意 <equation>\emptyset\subsetneq S'\subsetneq S</equation>, <equation>f(S) &lt; f(S')</equation> .</blockquote><p>很明显, 存在一个最优的k-subpartition, 使得里面的每一个集合都是实心的. 整个算法<b>背后</b>最重要的<b>秘密</b>是下面的这个定理. </p><blockquote><b>定理2:</b> 存在一颗树 <equation>T</equation> , 使得对于任意实心集合 <equation>U</equation> ,  <equation>T[U]</equation> 是一颗树. 并且给定有向图G, 这棵树可以多项式时间内找到. [1]</blockquote><p>因为存在一个全是实心的最优解. 我们可以假设这个最优解为 <equation>S_1,\ldots,S_k</equation> . 则我们知道存在 <equation>T </equation> 的k-1个边, 使得删掉之后得到k个连通分量 <equation>U_1,\ldots,U_k</equation> . 并且 <equation>S_i\subseteq U_i</equation> . 所以我们可以尝试所有的 <equation>k-1</equation> 个边. 最后, 有了下面的定理, 就能在给了 <equation>U_i</equation> 的情况下找到 <equation>S_i</equation> .</p><blockquote><b>定理3:</b> 给定G和一个顶点子集U, 则可以在多项式时间找到一个包含在U里的最小值的实心集合.</blockquote><p>放在一起就多项式时间了.</p><p>定理1和3都很容易证明, 定理2比较难, 还是看paper比较好.</p><p><br></p><p>P.S.</p><p>今年不少人觉得SODA的文章质量下降了不少啊.</p><p>我现在所知的信息感觉Mathematical Programming似乎是很容易发的journal啊.</p><p><br></p><p>[1] <a href="http://www.sciencedirect.com/science/article/pii/S0167637704001002">An algorithm for source location in directed graphs</a> </p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
