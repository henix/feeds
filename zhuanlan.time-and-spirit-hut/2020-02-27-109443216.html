<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Rust 视界 | async-std 团队发布 Async Http 套件</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/109443216">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-aca027d5229c0601b1b98a260241338d_b.jpg" alt=""></div><blockquote>本文首发于公众号「混沌学社」，搜索<b>ChaosSchool</b>可订阅。</blockquote><p><b>本文是对Yoshua Wuyts 博客文章的摘录，以及一些私人观点。</b></p><p><b>原文地址：</b><a href="https://link.zhihu.com/?target=https%3A//blog.yoshuawuyts.com/async-http/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">blog.yoshuawuyts.com/as</span><span class="invisible">ync-http/</span><span class="ellipsis"></span></a>。</p><hr/><p><b>Async HTTP</b></p><p>async-std 团队的主要开发者yoshuawuyts，联合「 协议实验室」 和 「微软」的另外两人，共同发布了 async http 套件。</p><p>主要分为三个库：</p><p>1. <b>async-h1</b> ：流式的HTTP/1.1客户端和服务器协议实现</p><p>2. <b>http-types</b>  ：从http服务器（Tide）和客户端框架（Surf）中提取的可重用http类型，是为了共享抽象，减少维护多套代码。</p><p>3. <b>async-native-tls</b>  ：流式TLS客户端和服务器实现，同时支持async-std和tokio。</p><h2><b>项目看点</b></h2><p><b>看点一：  流式设计。</b>像处理「水流」一样来处理数据流。</p><p><b>1. 基于 chunked 来实现了流式传输。</b></p><div class="highlight"><pre><code class="language-text">Transfer-Encoding: chunked</code></pre></div><p><b>2. 得益于 Rust 的流处理模型。</b><br/></p><p><b>在同步Rust中，核心流抽象是迭代器（Iterator）</b>。它提供了一种按顺序 出让（yield）每一项（item），并阻塞了它们。通过将迭代器传递到其他迭代器的构造器（constructors）中来完成组合，从而使我们能够在不费吹灰之力的情况下就将所有内容都组合在一起。</p><p><b>在异步Rust中，核心流抽象是流（Stream）</b>。它的行为与 Iterator 非常相似，但是它不会阻塞每个 item 的 出让（yield），而是允许其他任务在等待时运行。</p><p>另外，异步Rust 具有 AsyncRead 和 AsyncWrite 形式的同步读写。这些trait 的目的是表示未解析的字节，通常直接来自IO层（例如来自套接字或文件）。</p><p>Rust流具有其他语言的一些最佳特性。例如：通过利用Rust的 trait 系统，它们避免了 Node.js 的 Duplex 流中出现的继承问题。但是它们还实现了<b>背压</b>（back pressure，意思是在数据传输过程中有一大堆数据在缓存之后积压着）和<b>延迟迭代</b>（lazy iteration），从而提高了效率。最重要的是，Rust流允许使用相同的类型进行异步迭代。</p><p>参考：</p><p>1. <a href="https://link.zhihu.com/?target=https%3A//blog.yoshuawuyts.com/rust-streams/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">blog.yoshuawuyts.com/ru</span><span class="invisible">st-streams/</span><span class="ellipsis"></span></a> </p><p>2. <a href="https://link.zhihu.com/?target=https%3A//nodejs.org/api/stream.html%23stream_class_stream_duplex" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">nodejs.org/api/stream.h</span><span class="invisible">tml#stream_class_stream_duplex</span><span class="ellipsis"></span></a> </p><p class="ztext-empty-paragraph"><br/></p><p><b>看点二：</b> <b>AsRef/AsMut 模式应用于多个类型转换（http-types），来自于web-sys中的实践。</b></p><p>在 web-sys 中，可以通过 .as_ref 方法来获取任何一个 父 class 的引用</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-3c218172e6cbac1477d229c84cb57349_b.jpg" data-caption="" data-size="normal" data-rawwidth="481" data-rawheight="279" class="origin_image zh-lightbox-thumb" width="481" data-original="https://pic2.zhimg.com/v2-3c218172e6cbac1477d229c84cb57349_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-3c218172e6cbac1477d229c84cb57349_b.jpg" data-caption="" data-size="normal" data-rawwidth="481" data-rawheight="279" class="origin_image zh-lightbox-thumb lazy" width="481" data-original="https://pic2.zhimg.com/v2-3c218172e6cbac1477d229c84cb57349_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-3c218172e6cbac1477d229c84cb57349_b.jpg"/></figure><p>而在 async-h1 中，对于所有的Request也实现了AsRef&lt;Url&gt;, AsRef&lt;Headers&gt;。这种 「AsRef 模式」让我们可以实现「近似于OOP那样的」继承关系。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-446d7bbb155d6445c036c9472a66ee36_b.jpg" data-caption="" data-size="normal" data-rawwidth="457" data-rawheight="423" class="origin_image zh-lightbox-thumb" width="457" data-original="https://pic3.zhimg.com/v2-446d7bbb155d6445c036c9472a66ee36_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-446d7bbb155d6445c036c9472a66ee36_b.jpg" data-caption="" data-size="normal" data-rawwidth="457" data-rawheight="423" class="origin_image zh-lightbox-thumb lazy" width="457" data-original="https://pic3.zhimg.com/v2-446d7bbb155d6445c036c9472a66ee36_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-446d7bbb155d6445c036c9472a66ee36_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p><b>看点三：</b> <b>专门权衡开发体验和性能的API设计。</b></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-261d070ceaddc9bb261ac5a2090cc9be_b.jpg" data-caption="" data-size="normal" data-rawwidth="802" data-rawheight="873" class="origin_image zh-lightbox-thumb" width="802" data-original="https://pic3.zhimg.com/v2-261d070ceaddc9bb261ac5a2090cc9be_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-261d070ceaddc9bb261ac5a2090cc9be_b.jpg" data-caption="" data-size="normal" data-rawwidth="802" data-rawheight="873" class="origin_image zh-lightbox-thumb lazy" width="802" data-original="https://pic3.zhimg.com/v2-261d070ceaddc9bb261ac5a2090cc9be_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-261d070ceaddc9bb261ac5a2090cc9be_b.jpg"/></figure><p><b>看点四：</b> <b>将 HTTP 状态码和错误类型相关联</b>。<br/></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-00c373eb181cecac2054cb86893930dd_b.jpg" data-caption="" data-size="normal" data-rawwidth="608" data-rawheight="333" class="origin_image zh-lightbox-thumb" width="608" data-original="https://pic2.zhimg.com/v2-00c373eb181cecac2054cb86893930dd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-00c373eb181cecac2054cb86893930dd_b.jpg" data-caption="" data-size="normal" data-rawwidth="608" data-rawheight="333" class="origin_image zh-lightbox-thumb lazy" width="608" data-original="https://pic2.zhimg.com/v2-00c373eb181cecac2054cb86893930dd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-00c373eb181cecac2054cb86893930dd_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><h2><b>对于「分裂生态」言论的回应</b></h2><p>介于Rust社区有人一直在说「async-std vs tokio」导致生态分裂的言论，该文章里也有回应：</p><ul><li><b>在公共领域分享发现并不是分裂行为</b></li><li><b>async-std团队只是在尝试和改进新的解决方案</b></li><li><b>然而，用 “ 我们vs他们 ” 的言辞煽动争议才是「分裂社区」</b></li><li><b>感谢 hyperium/http 团队的贡献，async-h1使用了优秀的httparse库。和他们走上不同的道路，async-std有足够的理由，就算有竞争，也是健康的竞争。</b></li></ul><p>（个人观点：只是多种解决方案而已，不代表分裂，因为它们还是共同秉持着 Rust 的理念和原则。async-std 和 tokio 都是不错的代表。）<br/></p><h2><b>下一步动作</b></h2><p>1. 讨论 async-h2 中。</p><p>2. 等待 tide 发布 1.0 。tide 是一个基于 async-std 的异步 Web 开发框架，目前tide 已经 0.6 版本了。</p><p>&lt;全文完&gt;</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
