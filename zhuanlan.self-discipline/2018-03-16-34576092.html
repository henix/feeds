<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>递归函数（八）：偏序结构</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34576092">原文</a></p>
<h2><b>回顾</b></h2><p>上一篇我们介绍了不动点算子和Y组合子，以及Y组合子的具体表现形式，<br>这一篇我们根据不动点算子的性质来证明<code class="inline">fact</code>函数就是<code class="inline">g</code>函数的不动点。<br>随后，我们回归到了数学中，讨论集合上的一种偏序结构，<br>这为下文完全偏序集，以及完全偏序集上连续函数的不动点定理做好准备。</p><h2><b>不动点算子的性质</b></h2><img src="https://pic2.zhimg.com/v2-5aa0f01d21740986634a9e6bf34c3d48_r.jpg" data-caption="" data-size="normal" data-rawwidth="259" data-rawheight="246"><p>上文我们介绍了不动点算子<code class="inline">fix</code>，<br>它可以用来求取任意函数的不动点。</p><code lang="haskell">fix :: (a -&gt; a) -&gt; a
fix f = let x = f x in x</code><p>并且我们说以下函数的不动点为<code class="inline">fact = fix g</code>，</p><code lang="haskell">g :: (Int -&gt; Int) -&gt; Int -&gt; Int
g f n = case n of
  1 -&gt; 1
  _ -&gt; n * f (n-1)</code><p>但是上文中，我们只是对它们的计算结果进行比对，<br>并没有对它进行<b>证明</b>。</p><p>考虑到<code class="inline">fix</code>的性质，<code class="inline">fix g = g (fix g)</code>，<br>（因为<code class="inline">fix g</code>是<code class="inline">g</code>的不动点，令<code class="inline">h = fix g</code>，上式为<code class="inline">h = g h</code> <br>我们可以使用<b>数学归纳法</b>，证明对于任意的自然数 <equation>n</equation> ，<code class="inline">fact n = fix g n</code>。</p><p>我们先证<b>初始条件</b>，</p><code lang="haskell">fix g 1 
= g (fix g) 1 
= case 1 of 
    1 -&gt; 1
    _ -&gt; ...
= 1
= fact 1</code><p>然后再证<b>递推条件</b>，假设<code class="inline">fact k = fix g k</code>，<br>我们要推出<code class="inline">fact (k+1) = fix g (k+1)</code>，其中， <equation>k &gt; 0</equation> 。</p><code lang="haskell">fix g (k+1)
= g (fix g) (k+1)
= case (k+1) of 
    1 -&gt; 1
    _ -&gt; (k+1) * (fix g) k
= (k+1) * (fix g) k
= (k+1) * fact k
= fact (k+1)</code><p>因此，对于任意的自然数 <equation>n</equation> ，<code class="inline">fact n = fix g n</code>。<br>即，<code class="inline">fact = fix g</code>。</p><h2><b>不动点算子的有限展开</b></h2><img src="https://pic1.zhimg.com/v2-2982ac05515d431e35d327be6238dfa6_r.jpg" data-caption="" data-size="normal" data-rawwidth="332" data-rawheight="116"><p>根据上一节<code class="inline">fact = fix g</code>的证明，我们看到，<br>每一步递推，我们都使用了不动点算子<code class="inline">fix</code>的性质<code class="inline">fix g = g (fix g)</code>，<br>但是对于一个具有有限存储空间的机器来说，递推的步骤不可能是无限的。</p><p>为了界定最多使用多少次递推，我们定义， <equation>fix^{[n+1]}\ g = g\ (fix^{[n]} g)</equation> ，<br>并且认为 <equation>fix^{[0]}\ g</equation> 对于任意的 <equation>n</equation> 无定义，<br> <equation>fix^{[1]}\ g\ 1 = 1</equation> ，而 <equation>fix^{[1]}\ g\ n</equation> 在 <equation>n &gt; 1</equation> 时没有定义，<br> <equation>fix^{[2]}\ g\ 1 = 1</equation> ， <equation>fix^{[2]}\ g\ 2 = 2</equation> ，而 <equation>fix^{[2]}\ g\ n</equation> 在 <equation>n &gt; 2</equation> 时没有定义。</p><p>因此， <equation>fix^{[n]}\ g</equation> 是一个<b>部分函数</b>，且，<br> <equation>fix^{[n+1]}\ g</equation> 所表示的函数，总是比 <equation>fix^{[n]}\ g</equation> 的计算能力更强一些，离<code class="inline">fact</code>更近一些。<br>当 <equation>n\rightarrow \infty</equation> 时， <equation>fix^{[\infty ]}\ g</equation> 就是阶乘函数<code class="inline">fact</code>。</p><p>即， <equation>\lbrace fix^{[n]} g|\ n\geqslant 0 \rbrace</equation> 的<b>最小上界</b>，就是<code class="inline">g</code>的不动点。<br>那么，什么样的<code class="inline">g</code>才能保证这个集合具有最小上界呢？<br><a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E7%90%86%E8%AE%BA">序理论</a>指出，<b>完全偏序集上的序保持自映射具有最小不动点</b>。</p><p>为此，我们需要先认识什么是偏序集，什么是连续函数。<br>使用完全偏序集上的连续函数解释程序中函数的方式，称为<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E7%90%86%E8%AE%BA">域论模型</a>。</p><h2><b>偏序集与哈斯图</b></h2><img src="https://pic3.zhimg.com/v2-ca7cf8adbf29c978933a475f247bebde_r.jpg" data-caption="" data-size="normal" data-rawwidth="292" data-rawheight="222"><p>在第三篇中，我们讨论过<a href="https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">偏序关系</a>，<br>一个<b>偏序集</b> <equation>(D,\leqslant )</equation> 是一个集合 <equation>D</equation> ，并且在这个集合上定义了一个<b>偏序关系</b> <equation>\leqslant</equation> 。</p><p>设 <equation>A</equation> 为实数集的一个非空子集，我们定义 <equation>A</equation> 上的偏序关系为 <equation>\leqslant</equation> ，<br> <equation>x\leqslant y</equation> 当且仅当 <equation>x</equation> 是小或等于 <equation>y</equation> 的实数，则 <equation>(A,\leqslant )</equation> 是一个偏序集。</p><p>偏序集反映了集合上的一种偏序结构，它比我们想象中的更为常见，<br>例如，一个集合 <equation>A</equation> ，对于任意两个元素 <equation>x,y\in A</equation> ，我们定义 <equation>x\leqslant y</equation> 当且仅当 <equation>x=y</equation> ，<br>那么 <equation>(A,\leqslant )</equation> 是一个偏序集。</p><p>因此，如果某个集合构成了一个偏序集，这完全取决于我们怎样定义偏序关系。</p><p>设 <equation>(D,\leqslant )</equation> 是一个偏序集，<br>对于任意的 <equation>x,y\in D</equation> ，如果总是有 <equation>x\leqslant y</equation> 或者 <equation>y\leqslant x</equation> 成立，<br>则称 <equation>x</equation> 和 <equation>y</equation> 是<b>可比的</b>。</p><p><equation>x\leqslant y</equation> ，且 <equation>x\neq y</equation> ，则记为 <equation>x&lt;y</equation> 。<br>如果 <equation>x</equation> 和 <equation>y</equation> 是可比的，且 <equation>x&lt;y</equation> ，如果不存在 <equation>z\in D</equation> ，使得 <equation>x&lt;z&lt;y</equation> ，<br>则称 <equation>y</equation><b> 覆盖 </b><equation>x</equation> 。</p><p>根据可比性和覆盖性，我们就可以将偏序关系用<b>无向图</b>表示出来了，<br>其中，顶点表示元素，边表示覆盖关系，并且省去图中每个顶点处的环，<br> <equation>y</equation> 覆盖 <equation>x</equation> 就将代表 <equation>y</equation> 的顶点放在代表 <equation>x</equation> 的顶点之上，并在 <equation>x</equation> 和 <equation>y</equation> 之间连线，<br>如果 <equation>x&lt;y</equation> ，但是 <equation>y</equation> 不覆盖 <equation>x</equation> ，就省掉 <equation>x</equation> 与 <equation>y</equation> 之间的连线。</p><p>这样用来表示有限偏序集的无向图，称为<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E6%96%AF%E5%9C%96">哈斯图</a>。</p><p>例如，易证<b>整除关系</b>是整数集上的一种偏序关系，<br>我们可以画出偏序集 <equation>\lbrace 1,2,3,4,5,6,9,10,15 \rbrace</equation> 对应的哈斯图，如下，</p><img src="https://pic4.zhimg.com/v2-dafdb936b22c79c6840bae5bbbb84fc6_r.jpg" data-caption="" data-size="normal" data-rawwidth="220" data-rawheight="173"><h2><b>全序集与拟序集</b></h2><img src="https://pic1.zhimg.com/v2-a27366c2bff2c9c470d571693f760ed4_r.jpg" data-caption="" data-size="normal" data-rawwidth="530" data-rawheight="200"><p>设 <equation>(D,\leqslant )</equation> 是一个偏序集，如果对于任意 <equation>x,y\in D</equation> ， <equation>x</equation> 和 <equation>y</equation> 都可比，<br>则称 <equation>\leqslant</equation> 为 <equation>D</equation> 上的<b>全序关系</b>，此时称 <equation>(D,\leqslant )</equation> 为<b>全序集</b>。</p><p>可见，实数集以及实数集上的小于等于关系 <equation>\leqslant</equation> ，构成了一个全序集。<br>哈斯图为从下至上的“一条线”，是全序集的充要条件。</p><p>设 <equation>R</equation> 是非空集合 <equation>A</equation> 上的，反自反的和传递的二元关系，<br>则称 <equation>R</equation> 为 <equation>A</equation> 上的<b>拟序关系</b>，常将拟序关系记为 <equation>&lt;</equation> ，并称 <equation>(A,&lt;)</equation> 为<b>拟序集</b>。<br>拟序关系自然具有反对称性。<br>（其中，反自反关系，指的是不存在 <equation>x\in A</equation> ，使得 <equation>x&lt;x</equation> 。</p><p>拟序关系与偏序关系的哈斯图在画法上完全相同，<br>只是拟序关系的哈斯图的各顶点都没有环。</p><p>设 <equation>(A,&lt;)</equation> 是一个拟序集，如果对于任意的 <equation>x,y\in A</equation> ，<br> <equation>x&lt;y</equation> ， <equation>x=y</equation> ， <equation>y&lt;x</equation> 三式有且仅有一式成立，则称 <equation>&lt;</equation> 具有<b>三歧性</b>，<br>这样的拟序关系 <equation>&lt;</equation> ，称为<b>拟全序关系</b>，这样的拟序集 <equation>(A,&lt;)</equation> ，称为<b>拟全序集</b>。<br>拟全序集的哈斯图也是“一条线”。</p><h2><b>最小元与上确界</b></h2><img src="https://pic3.zhimg.com/v2-3fa180632f5a71452ddd338e9867be18_r.jpg" data-caption="" data-size="normal" data-rawwidth="270" data-rawheight="187"><p>对于偏序集 <equation>(D,\leqslant )</equation> ，以及它的一个子集 <equation>S\subseteq D</equation> ，<br>如果存在 <equation>y\in S</equation> ，且对于任意的 <equation>x\in S</equation> ，有 <equation>y\leqslant x</equation> ，则称 <equation>y</equation> 为 <equation>S</equation> 的<b>最小元</b>。<br>（相似的我们可以定义最大元</p><p>如果存在 <equation>y\in S</equation> ，对于任意的 <equation>x\in S</equation> ，<br>如果 <equation>x\leqslant y</equation> 那么就有 <equation>x=y</equation> ，则称 <equation>y</equation> 为 <equation>S</equation> 的<b>极小元</b>。<br>（相似的我们可以定义极大元</p><p>如果 <equation>S</equation> 是有穷集，则 <equation>S</equation> 的极小元一定存在，并且可能有多个，<br>但是最小元却不一定存在。</p><p>上文中，我们画出了偏序集 <equation>A=\lbrace 1,2,3,4,5,6,9,10,15 \rbrace</equation> 对应的哈斯图，</p><img src="https://pic3.zhimg.com/v2-086295e163bc5eaff1567167b64beca3_r.jpg" data-caption="" data-size="normal" data-rawwidth="220" data-rawheight="173"><p>我们取 <equation>B_1=\lbrace 1,2,3 \rbrace</equation> ， <equation>B_2=\lbrace 3,5,15 \rbrace</equation> ， <equation>B_3=A</equation> ，<br>则 <equation>1</equation> 是 <equation>B_1</equation> 的最小元，也是极小元， <equation>2,3</equation> 是 <equation>B_1</equation> 的极大元，但 <equation>B_1</equation> 没有最大元。<br> <equation>3,5</equation> 是 <equation>B_2</equation> 的极小元，但 <equation>B_2</equation> 没有最小元， <equation>15</equation> 是 <equation>B_2</equation> 的最大元，也是极大元。<br> <equation>1</equation> 是 <equation>B_3</equation> 的最小元，也是极小元， <equation>4,6,9,10,15</equation> 是 <equation>B_3</equation> 的极大元，但是 <equation>B_3</equation> 没有最大元。</p><p>对于偏序集 <equation>(D,\leqslant )</equation> ，以及它的一个子集 <equation>S\subseteq D</equation> ，<br>如果存在 <equation>y\in D</equation> ，（注意，不一定是 <equation>y\in S</equation> <br>使得对于任意的 <equation>x\in S</equation> ， <equation>x\leqslant y</equation> ，则称 <equation>y</equation> 为 <equation>S</equation> 的<b>上界</b>，<br>如果 <equation>S</equation> 的所有上界存在最小元，则称它为 <equation>S</equation> <b>最小上界</b>，或<b>上确界</b>。<br>（相似的可以定义下确界</p><p><equation>S</equation> 的上界和下界不一定存在，即使存在，上确界和下确界也不一定存在。</p><p>设 <equation>(A,&lt;)</equation> 是一个拟全序集，如果对于 <equation>A</equation> 中的任何非空子集 <equation>S</equation> 都有最小元，<br>则称 <equation>&lt;</equation> 是一个<b>良序关系</b>， <equation>(A,&lt;)</equation> 是一个<b>良序集</b>。</p><p>例如，自然数集以及自然数集上的小于关系，构成了一个良序集 <equation>(N,&lt;)</equation> ，<br>但是，整数集以及整数集上的小于关系，并不构成良序集，而仅仅是一个拟全序集。</p><h2><b>总结</b></h2><p>本文从一个证明出发，我们了解了不动点算子的工作原理，<br>然后引出了一些数学概念，序关系在不动点算子理论中占有很重要的地位，<br>所以，这里给出了详细的介绍，下文我们开始讨论最小不动点定理。</p><hr><h2><b>参考</b></h2><p><a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E7%90%86%E8%AE%BA">序理论</a> <br><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E7%90%86%E8%AE%BA">域论模型</a> <br><a href="https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">偏序关系</a> <br><a href="https://book.douban.com/subject/1230394/">离散数学教程</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
