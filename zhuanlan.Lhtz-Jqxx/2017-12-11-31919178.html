<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Jupyter Notebooks里的TensorFlow图可视化</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/31919178">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-82d31011dd29735daa95ede1addf8550_r.jpg" alt=""></div><h2><b>前言</b></h2><p><i><b>前提：</b>假设你熟悉Python，TensorFlow和Jupyter notebooks。 我们的目标只是可视化计算图。</i></p><p>TensorFlow操作形成计算图。 而对于简单的例子，你可能可以查看代码，并立即看到发生了什么，较大的计算图可能不那么明显。 可视化图表可以帮助诊断计算本身的问题，也可以帮助了解TensorFlow中的某些操作是如何工作的以及事情如何组合在一起的。</p><p>让我们来看几种不同的可视化TensorFlow图形的例子，最重要的是，如何以一种非常简单和有效的方式来实现。</p><p>首先，让我们创建一个简单的TensorFlow图。 常规操作（如使用tf.placeholder）会在所谓的默认图形中创建一个节点。 我们可以通过tf.get_default_graph（）访问它，但是我们也可以临时更改它。 在下面的示例中，我们将创建一个tf.Graph对象的新实例，并创建一个添加两个变量的例子。</p><p><b>c=a+b</b></p><img src="https://pic2.zhimg.com/v2-3520c99e2016556da6fb075a1ae54229_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="132"><p>变量g现在包含操作c = a + b的计算图的定义。 我们可以使用g.as_graph_def（）方法获取表达式的图形的文本表示。 虽然这主要用于通过tf.import_graph_def进行序列化和随后的反序列化，但我们将使用它来创建一个 GraphViz DOT graph。</p><p>让我们来看看GraphDef的简单表达。 首先，我们查看图中所有节点的名称。</p><img src="https://pic3.zhimg.com/v2-094b1b66d584b06f0784f76844f8cd42_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="52"><p>结果有三个节点。 一个是每一个变量，另一个用于添加操作。 占位符变量节点有一个名称，因为我们在调用tf.placeholder时明确命名它们。 如果我们省略了name关键字参数，TensorFlow将简单地生成一个名称，就像在add操作中一样。</p><p>接下来，我们可以看看图中的边。 每个GraphDef节点都有一个输入字段，指定具有边缘的节点。 让我们来看看：</p><img src="https://pic2.zhimg.com/v2-35077a5c49a4f30924a0d86d3301869a_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="56"><p>我们可以看到，有两个边，每个变量一个。 我们可以直接将其直接提供给GraphViz。</p><p><br></p><h2><b>构建 GraphViz DOTgraph</b></h2><p>GraphViz是一个非常受欢迎的库，用于绘制图形，树形和其他图形数据结构。 我们将使用Python GraphViz软件包，它提供了一个很好的界面。 我们可以通过安装graphviz直接安装在Jupyter notebooks中。</p><p>图形定义本身将非常简单，我们将从TensorFlow本身的一个类似的代码（在graph_to_dot.py中）获得灵感，该代码生成给定GraphDef的DOTgraph文件格式。 不过，它只能作为命令行脚本使用，因此我们不能直接从我们的代码中调用它。 这就是为什么我们想自己来实现它，但不要担心，它只会是几行代码。</p><img src="https://pic3.zhimg.com/v2-9dbdda28e2e639559b33ce3d0bc8da17_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="396"><p>现在让我们将它打包成一个函数，并尝试在更复杂的表达式上使用它。</p><img src="https://pic1.zhimg.com/v2-e08ef4c7e740ebce466f36f9a49cc0d8_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="162"><p>我们将建立另一个图，计算公式为π* r2的圆的面积。</p><img src="https://pic4.zhimg.com/v2-66d7c7f2a3317f556dabf0a3e7d4c577_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="362"><h2><b>使用本地TensorBoard实例可视化图形信</b></h2><p>GraphViz对于可视化小图很适用，神经网络可以增长到相当大的大小。 TensorBoard允许我们轻松地将的方程组分成有效范围，然后在结果图中将其视觉分离。 但是在这样做之前，让我们尝试用TensorBoard来显示我们之前的图形。</p><p>我们需要做的就是使用tf.summary.FileWriter来保存它，它使用一个目录和一个图形，并以TensorBoard可以读取的格式对图形进行序列化。 该目录可以是任何你想要的，只需确保您使用tensorboard --logdir = DIR命令（DIR是您为FileWriter指定的目录）指向同一目录。</p><img src="https://pic3.zhimg.com/v2-e28452a258de52bbddc03592d2b71d31_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="48"><p>接下来，打开控制台并执行FileWriter命令在同一目录下，然后运行tensorboard --logdir = logs。 这将启动一个TensorBoard的实例，你可以访问http:// localhost:6006。 然后运行到图形部分，你应该会看到一个如下图所示的图形。 请注意，你也可以点击图形中的节点进一步检查。</p><img src="https://pic4.zhimg.com/v2-d12156bbd6d94938a559c6a20c978c13_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="361"><p>幸运的是，TensorFlow允许我们将操作连在一起，称为 scope。 但首先，让我们来看一个更复杂的例子，而不使用 scope。 我们将创建一个非常简单的前馈神经网络，具有三层（各自权重W1，W2，W3，偏置b1，b2，b3）。</p><img src="https://pic4.zhimg.com/v2-bfb018ba9753fc6e13b971061dc8adde_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="321"><img src="https://pic1.zhimg.com/v2-af7a2285d72c42a800c33712732ba707_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="441"><p>我们可以通过使用上述的tf.name_scope函数来改善这一点。 让我们重写前馈网络代码，将每个层分成自己的scope。</p><img src="https://pic1.zhimg.com/v2-f5ee9301710c02a8a3d6e8b03838cf8c_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="362"><p>以下是结果图形，展示了整个网络的紧凑视图（左）以及展开其中一个节点时的外观（右）。</p><img src="https://pic2.zhimg.com/v2-aa6afa1f4dc10476f96fc1909d57ce98_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="582"><h2><b>使用云托管的TensorBoard实例来做rendering</b></h2><p>我们将使用从this StackOverflow answer中获取的DeepDream notebook的修改的片段。 它基本上需要tf.GraphDef，将其发送到云端，并将生成的可视化文件的&lt;iframe&gt;嵌入到Jupyter notebooks。</p><p>这是它的整体片段。 所有你需要做的是调用show_graph（），它将处理所有内容，如下面的例子，如上图g所示。 这种方法明显的优点是你不需要运行TensorBoard来可视化数据，但你也需要访问互联网。</p><img src="https://pic1.zhimg.com/v2-bfd7744cb6c201b8ba34e94d33d397c3_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="624"><img src="https://pic3.zhimg.com/v2-52ef31e93977d5e0a82cfd6de26cb1fb_r.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="613"><p><br></p><img src="https://pic3.zhimg.com/v2-a283cc2b67804cefe5c2b7a6d86dfc21_r.jpg" data-caption="" data-size="normal" data-rawwidth="1141" data-rawheight="697"><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
