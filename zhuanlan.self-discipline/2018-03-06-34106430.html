<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Emacs之魂（六）：宏与元编程</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34106430">原文</a></p>
<p></p><img src="https://pic1.zhimg.com/v2-fd7960006a1daada2752c71e1443af9b_r.jpg" data-caption="" data-size="normal" data-rawwidth="500" data-rawheight="359"><h2><b>数据和代码</b></h2><p>如果说Lisp语言有一个特性最能使人津津乐道的话，我想应该是它的宏系统（macro system）了吧，<br>在Lisp语言中，程序和代码的表现形式（textual representation）几乎一致，造就了它无与伦比的<a href="https://zh.wikipedia.org/zh-hans/%E5%85%83%E7%BC%96%E7%A8%8B">元编程</a>能力。<br>这种对称性，使得Lisp语言可以像处理数据一样优雅的处理代码本身。</p><p>并且和其他语言不同的是，Lisp的宏系统，并不是简单的文本操作，<br>而是建立在语法对象（syntax object）基础之上。</p><p>前文提到过，我们直接写<code class="inline">(foo bar bar)</code>表示函数调用或者宏调用（macro call），<br>加引用<code class="inline">'(foo bar bar)</code>表示列表字面量，<br>直接写<code class="inline">x</code>表示变量或者函数，加引用<code class="inline">'x</code>表示符号（symbol）。</p><p>如果我们把列表字面量和符号看做数据，把变量和函数调用看做程序，<br>那么数据和程序的表现形式（textual representation）几乎是相同的，只差一个引用。<br>所以，如果一个函数能够处理数据（列表/变量），那么它也一定能够处理被引用的程序，<br>同理，如果一个函数能够返回一段数据（列表/变量），那么去掉引用之后（使用<code class="inline">eval</code>），<br>也可以看做它是返回了一段程序。</p><p>例如，</p><code lang="emacs">(defun inc (var)
    (list 'setq var (list '1+ var)))

(inc 'x)    ; (setq x (1+ x))</code><p>我们定义了一个<code class="inline">inc</code>函数，它接受<code class="inline">var</code>作为参数，返回了一个列表。<br>即，<code class="inline">(inc 'x)</code>的求值结果为<code class="inline">(setq x (1+ x))</code>，<br>其中，<code class="inline">(setq x (1+ x))</code>是一个列表。</p><p>我们可以通过<code class="inline">eval</code>直接把返回的列表当做程序来执行，</p><code lang="emacs">(defvar x 0)
(eval (inc 'x))

x    ; 1</code><p><code class="inline">x</code>的值被修改了，变成了<code class="inline">1</code>。</p><h2><b>定义一个宏</b></h2><img src="https://pic4.zhimg.com/v2-6de75035cb3b4e965c0c3f7b43e6945f_r.jpg" data-caption="" data-size="normal" data-rawwidth="460" data-rawheight="332"><p>我们只需要将上文的<code class="inline">inc</code>稍作修改，就可以把它转换成一个宏（macro），<br>我们只需要将<code class="inline">defun</code>改成<code class="inline">defmacro</code>即可，</p><code lang="emacs">(defmacro inc (var)
    (list 'setq var (list '1+ var)))</code><p>现在<code class="inline">inc</code>就是一个宏（macro）了，它的使用方式和函数非常相似，</p><code lang="emacs">(defvar x 0)
(inc x)

x    ; 1</code><p>我们看到，这里直接使用了<code class="inline">(inc x)</code>，而不是<code class="inline">(inc 'x)</code>，<br>并且，<code class="inline">(inc x)</code>的作用和直接写程序<code class="inline">(setq x (1+ x))</code>是一样的。</p><p><code class="inline">(inc x)</code>我们称之为宏调用（macro call），<br>而<code class="inline">(setq x (1+ x))</code>我们称之为宏展开（macro expansion）后的程序。</p><p>编译器或者解释器会采用不同的策略进行宏展开，<br>一般而言，编译器会在求值程序之前，将代码中所有的宏（macro）进行展开，<br>即，将所有的宏调用<code class="inline">(inc x)</code>，替换成它返回的那段程序<code class="inline">(setq x (1+ x))</code>，<br>直到代码中不再包含宏（macro）为止，然后再进行编译。</p><p>一个简单的解释器实现，可能会一边执行程序一边进行宏展开操作，<br>它会在运行时，通过判断符号（symbol）的类型，来决定进行函数调用还是宏调用。<br>这样可能会有助于理解宏的递归展开问题。</p><p>一个宏展开式中，可能还会包含其它的宏，也可能还会包含另一个宏的定义。<br>（以后的文章中，我们会介绍）</p><p>因此，在宏定义中，进行的具有副作用（side effect）的操作，<br>其执行时机并不是在运行时，而是在宏展开阶段，<br>而如果宏实参中包含了带有副作用的操作，那么它可能被展开到源代码中的多个位置，<br>从而被执行多次。</p><h2><b>语法对象</b></h2><img src="https://pic2.zhimg.com/v2-8765cb13799e6bf78ab751733ee1e632_r.jpg" data-caption="" data-size="normal" data-rawwidth="378" data-rawheight="319"><p>在Emacs Lisp中，宏变量<code class="inline">inc</code>实际上是一个转换函数，<br>它将<code class="inline">var</code>转换成了<code class="inline">(list 'setq var (list '1+ var))</code>，即把符号（symbol）转换成了一个列表对象。</p><p>宏变量的值与函数一样会保存在符号（symbol）<code class="inline">inc</code>的function cell中，<br>因此，一个符号（symbol）不可能既表示一个函数又表示一个宏（macro）。</p><p>当Lisp解释器遇到一个符号（symbol）的时候，<br>会判断它到底是一个变量，一个函数还是一个宏（macro）。</p><code lang="emacs">(defun add1 (x)
    (+ x 1))

(defvar a 1)
(add1 a)</code><p>如果是一个函数，且当前进行的是函数调用<code class="inline">(add1 a)</code>，<br>那么就会先求值它的实参，<code class="inline">a</code>求值为<code class="inline">1</code>，<br>再将<code class="inline">add1</code>的形参<code class="inline">x</code>绑定为实参的值<code class="inline">1</code>，再求值函数体，<br>即，求值<code class="inline">(+ x 1)</code>，结果为<code class="inline">2</code>。</p><code lang="emacs">(defmacro inc (var)
    (list 'setq var (list '1+ var)))

(defvar x 0)
(inc x)
x    ; 1</code><p>如果是一个宏（macro），且当前进行的是宏调用<code class="inline">(inc x)</code>，<br>那么它并不会像函数那样先求值函数体，而是直接将宏形参绑定为宏调用的实参值。<br>即，<code class="inline">var</code>绑定为符号（symbol）<code class="inline">x</code>。</p><p>值得注意的是，宏调用的实参，是一个符号（symbol），它是一个Lisp对象，而不是一个字符串，<br>宏（macro）所返回的结果，也是一个Lisp对象。</p><p>更明确的说，宏（macro）是一个针对<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-13.html#node_sec_12.2">语法对象</a>（syntax object）的变换函数，<br>它对读取器获得的语法对象（syntax object）进行变换。<br>在某些Lisp方言，例如<a href="http://www.r6rs.org/final/html/r6rs/r6rs.html">Scheme</a>，这些语法对象（syntax object）包含了上下文信息，使用它们可以编写出强大而灵活的宏（macro）。</p><img src="https://pic4.zhimg.com/v2-7e780bf315c359f9ec78a6f3ab75ff69_r.jpg" data-caption="" data-size="normal" data-rawwidth="748" data-rawheight="449"><p>这里容易引起混乱的是，在Emacs Lisp中，直接使用了符号和列表表示了语法对象，<br>而实际上语法对象是一个数据结构，在其内部包含了符号和列表的信息。<br>这样做的好处是，在宏展开阶段宏（macro）接受和返回的都是语法对象，<br>而在运行时阶段，处理的都是运行时对象了。<br>（例如：<a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-13.html#node_sec_12.6">syntax-&gt;datum和datum-&gt;syntax</a>）</p><p>通过以下程序我们可以验证，<code class="inline">var</code>确实是一个符号（symbol）。</p><code lang="emacs">(defmacro inc (var)
    (message "%s" (symbolp var))    ; t
    (list 'setq var (list '1+ var)))</code><p>我们之前十分小心的区分了标识符，符号（symbol）和变量，<br>是为了在类似这样的场景中保持清醒。</p><p>标识符经过Lisp读取器，在Lisp内部会变成一个符号（symbol），它是一个语法对象，<br>然后Lisp会对所有的宏（macro）进行展开，将这些语法对象绑定到宏形参上，对语法对象进行变换。<br>最后，求值器在运行时会求值这些符号（symbol），得到一个变量值或者函数值。</p><p>因此，编写宏（macro）可以看作是对编译器或者解释器进行编程，<br>Lisp允许用户在表达式被求值之前对它进行一些变换。</p><h2><b>总结</b></h2><p>本文初步介绍了Lisp的宏系统，展示了宏调用与函数调用之间的异同，<br>我们发现Lisp的宏系统是建立在语法对象（syntax object）基础之上的，而不是简单的进行文本替换。<br>此外，由于Emacs Lisp的宏（macro）不是卫生的（hygienic），所以会和Common Lisp一样出现变量捕获问题。<br>下文我们开始介绍一些Lisp宏的常见陷阱和用法。</p><hr><h2><b>参考</b></h2><p><a href="https://www.gnu.org/software/emacs/manual/elisp.html">GNU Emacs Lisp Reference Manual</a> <br><a href="http://www.scheme.com/csug8/">Chez Scheme Version 8 User's Guide</a> <br><a href="ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html">An Introduction to Scheme and its Implementation</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
