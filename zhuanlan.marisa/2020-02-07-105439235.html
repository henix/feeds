<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>NuPRL 中的证明--从一到CTT</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/105439235">原文</a></p>
<p>本文假设读者已经装了 NuPRL5 的 VM/要到了帳號并照著 <a href="https://link.zhihu.com/?target=http%3A//nuprl.org/html/02cucs-NuprlManual-02overview.pdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">nuprl.org/html/02cucs-N</span><span class="invisible">uprlManual-02overview.pdf</span><span class="ellipsis"></span></a> 做基操。</p><p>这是向略懂 dependent type 的人的 NuPRL 教程，介紹这一最神/传奇的定理证明器。你不需要会 Haskell，但是至少要能理解 untyped lambda calculus，最好会点 OCaml/SML，最理想是 LCF ML，因为这是 NuPRL 的 Tactic 语言，而且它沒正式的 language report。Lisp 麻，会用 Emacs 程度就可以了，在 NuPRL 里几本用不上。</p><p>这文章只能向有 Agda/Coq/HOL/PVS/Metamath 经验的介绍下 NuPRL 了，因为完全 normie 的话像我一样出见 NuPRL 怕是不太可能有过了。</p><h2><b>Equality in CTT </b></h2><p>我们先来看 equivalence。不好意思让你们失望了，NuPRL 里沒有 ADT。所以 NuPRL 的 <img src="https://www.zhihu.com/equation?tex=a+%3D+b+%5Cin+T" alt="a = b \in T" eeimg="1"/>  是个 primitive，如果 a 和 b 不等就是个空集，相等则有唯一成员 <img src="https://www.zhihu.com/equation?tex=%2A" alt="*" eeimg="1"/> ，相当于 unit type。</p><p>值得一提的是，在 Agda 用的 ITT 中，一个 value 只能和自己相等，但在 CTT，因为有 quotient type 的概念，你还可以定义一个类型使两个不同的 value 相等。</p><p>given equality relation <img src="https://www.zhihu.com/equation?tex=E" alt="E" eeimg="1"/> on type <img src="https://www.zhihu.com/equation?tex=T" alt="T" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=a+%3D+b+%5Cin+T%2F%5C%21%2FE+%5Ciff+a+E+b" alt="a = b \in T/\!/E \iff a E b" eeimg="1"/> </p><h2>Number, Subset type(refinement type/subtype by comprehension)</h2><p>连 Equality 都 primitive 了，NuPRL 的 Integer 也是 primitive 的。所以就不要想 Peano number 了。</p><p>自然数的定义直接上 refinement type。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7BN%7D+%3D%3D+%5C%7Bi%3A%5Cmathbb%7BZ%7D%5C+%7C%5C+0%5Cleq+i%5C%7D" alt="\mathbb{N} == \{i:\mathbb{Z}\ |\ 0\leq i\}" eeimg="1"/> </p><h2>Unit, then to Binary</h2><p>equality 已經成了 primitive，別的就不用都重新定义了。</p><p><img src="https://www.zhihu.com/equation?tex=a+%5Cin+T+%3D%3D+a+%3D+a%5Cin+T" alt="a \in T == a = a\in T" eeimg="1"/> </p><p>Unit 也就这么定义了</p><p><img src="https://www.zhihu.com/equation?tex=Unit+%3D%3D+0+%5Cin+%5Cmathbb%7BZ%7D" alt="Unit == 0 \in \mathbb{Z}" eeimg="1"/> </p><p>Boolean:</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7BB%7D+%3D%3D+Unit+%2B+Unit" alt="\mathbb{B} == Unit + Unit" eeimg="1"/> </p><p>是不是发现了什么？</p><p>沒错，NuPRL 沒有用来 pattern match 的 data constructor。毕竟是用 tactic 做证明的啉，case split 有 tactic，要 pattern match 又沒用。</p><h2>结语(划掉)</h2><p>不好意思，我们还没做证明。那現在就可以来一个了</p><p><img src="https://www.zhihu.com/equation?tex=%2A%3E%5C%21%3E+0+%3D+0+%5Cin+%5Cmathbb%7BZ%7D%5C+%7Bby%7D%5C+%5Ctexttt%7BAuto%7D" alt="*&gt;\!&gt; 0 = 0 \in \mathbb{Z}\ {by}\ \texttt{Auto}" eeimg="1"/> </p><p>好，证完了。反正用 Auto Tactic 就对了。</p><h2>Subtyping</h2><p>你们好多人说 Subtyping 难，然而在 NuPRL 里 subtyping 如吃飯喝水一样自然。首先看看这句定义</p><blockquote>A is a subtype of B, written A ≤ B, if a value of type A can be supplied wherever a value of type B is demanded.</blockquote><p>然后把这给忘了吧，因为 CTT 的 subtyping 是这么定义的</p><blockquote>A is a subtype of B ( <img src="https://www.zhihu.com/equation?tex=A+%5Csqsubseteq+B" alt="A \sqsubseteq B" eeimg="1"/> ) iff <img src="https://www.zhihu.com/equation?tex=a+%3D+a%27+%5Cin+A+%5Cimplies+a%3Da%27+%5Cin+B" alt="a = a&#39; \in A \implies a=a&#39; \in B" eeimg="1"/> </blockquote><p>这是一个外延性定义。</p><p>自然地</p><p><img src="https://www.zhihu.com/equation?tex=%5C%7Bx%3AA%5C+%7C%5C+P%28x%29+%5C%7D+%5Csqsubseteq+A" alt="\{x:A\ |\ P(x) \} \sqsubseteq A" eeimg="1"/> </p><h2>Void, Top, Intersection over a family</h2><p><img src="https://www.zhihu.com/equation?tex=+u%3Dv+%5Cin+%5Cbigcap%5Climits_%7Bx%3AA%7D%7BB%28x%29%7D+%5Ciff+%5Cforall+x+%5Cin+A.+u%3Dv+%5Cin+B%28x%29" alt=" u=v \in \bigcap\limits_{x:A}{B(x)} \iff \forall x \in A. u=v \in B(x)" eeimg="1"/> </p><p>注意不要和 intersection type 搞混了，虽然它们是有关系。</p><p>Void 就是 Empty type。它是个 primitive。当然，并不代表你不能用 <img src="https://www.zhihu.com/equation?tex=%5C%7Bx%3A%5Cmathbb%7BZ%7D%5C+%7C%5C+x%3Cx+%5C%7D" alt="\{x:\mathbb{Z}\ |\ x&lt;x \}" eeimg="1"/> 这样的 type 表示它。自然地， <img src="https://www.zhihu.com/equation?tex=Void+%5Csqsubseteq+A" alt="Void \sqsubseteq A" eeimg="1"/> </p><p>在一个有 subtyping 的 type theory 里，Top 可不能和 Unit 混在一起了 (说的就是你，Agda！)</p><p>Intersection over a family 中 A 为 empty 时，B(x) 的 B 就是 a functions from Empty to some type 了，因为从 empty 可以 derive anything，所以这样就是 Top, where <img src="https://www.zhihu.com/equation?tex=A+++%5Csqsubseteq+Top" alt="A   \sqsubseteq Top" eeimg="1"/> 了。当然 Agda 用 <img src="https://www.zhihu.com/equation?tex=%5Ctop" alt="\top" eeimg="1"/> 表示 Unit 不是沒有道理的，因为 <img src="https://www.zhihu.com/equation?tex=A%5E0+%5Ccong+1" alt="A^0 \cong 1" eeimg="1"/> (即从 empty 到所有类型的 function 只有一个)嚒。</p><p><img src="https://www.zhihu.com/equation?tex=A%28given%5C+B%29%3D%5Cbigcap%5Climits_%7Bx%3AA%7D%7BB%28x%29%7D" alt="A(given\ B)=\bigcap\limits_{x:A}{B(x)}" eeimg="1"/> if x is free in B.</p><p>这叫做 Guarded Type，作用放之后讲。不过現在我们可以用 <img src="https://www.zhihu.com/equation?tex=Void%28given%5C+Void%29" alt="Void(given\ Void)" eeimg="1"/> 来定义 Top。</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
