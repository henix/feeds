<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>当然我在扯淡</title>
<link>https://henix.github.io/feeds/yinwang/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Wed, 21 Aug 2019 11:27:51 +0800</lastBuildDate>
<item>
<title>关于微内核的对话</title>
<link>https://henix.github.io/feeds/yinwang/2019-08-19-microkernel.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/08/19/microkernel&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;关于微内核的对话&lt;/h2&gt;
            &lt;p&gt;不知怎么的，最近“微内核 vs 宏内核”又成了热门话题。这场争论从 1992 年开始……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.yinwang.org/images/minix-flamewar.jpg&quot; width=&quot;56%&quot;&gt;&lt;/p&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;说老实话，我很久没有关心操作系统了，因为通常所谓的“操作系统”，在我心里不过是一个 C 语言的运行时系统（run-time system），就像 JVM 是 Java 的运行时系统一样。由于 C 语言的设计缺陷，这些系统引入了各种无需有的概念（进程，线程，虚拟内存……），以及它们带来的复杂性和开销。&lt;/p&gt;

&lt;p&gt;微内核与宏内核之争当然也包括在内。在我看来这些都是无需有的概念和争论。&lt;/p&gt;

&lt;p&gt;在我的理念里，一个操作系统本应该是&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/04/14/os-design&quot;&gt;这个样子&lt;/a&gt;。简单得很，根本不存在那么多问题。我可以利用这些思想来看透现有操作系统的绝大部分思想，管它是微内核还是宏内核。我可以把现有的操作系统看成是这个系统的“退化版”。&lt;/p&gt;

&lt;p&gt;操作系统是一个死知识横行的领域。很多人发现操作系统课难学，难理解。里面有些内容，比如各种同步机制，很多人上完课毕了业，工作很多年以后都还弄不明白是怎么回事，它们为什么在那里。类似的东西包括虚拟内存，进程与线程的区别，等等。&lt;/p&gt;

&lt;p&gt;经过了很多的经验和思考，加上其他领域给我的启发，我终于明白了。原来很多这些概念都是无须有的，死掉的知识。&lt;/p&gt;

&lt;p&gt;操作系统课程里面的概念经常是这样形成的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;很久以前，有人为了解决了一个特定的问题，提出了一个概念（比如 semaphore）。这个概念本来只有一个用途，就是解决他遇到的那个特定的问题。&lt;/li&gt;
  &lt;li&gt;因为这人太有名，这概念就被写进了教科书里。有时候连他当时的具体实现细节都给写进去了。比如 semaphore 的两个操作被叫做 P 和 V，连这两个名字都给作为“典故”写进去了。&lt;/li&gt;
  &lt;li&gt;教授们照本宣科，吹毛求疵，要你用这概念解决很多其它问题。很多根本就是人为造出来的变态问题，现实中遇不到的，或者是一些不该用这个概念解决的问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就是为什么操作系统课学起来那么难——很多都是没道理的难。&lt;/p&gt;

&lt;p&gt;再加上 Unix 系统里面一堆设计恶劣，无法有效组合使用的工具软件，操作系统就在学生心中产生了永久性的威慑力。死记硬背，喜欢折腾，喜欢发现奇技淫巧的人，在这个领域里茁壮成长。逐渐的，他们产生了莫名的自信。他们并不理解里面的很多概念是怎么来的，只是记住了它们。他们写的代码也很难看懂。然后他们开始从心理上打压那些记不住这些概念，看不懂他们代码的人。&lt;/p&gt;

&lt;p&gt;久而久之，这些人就成为了大家所崇拜的“神”。&lt;/p&gt;

&lt;p&gt;跟有些人聊操作系统是件闹心的事，因为我往往会抛弃一些术语和概念，从零开始讨论。我试图从“计算本质”的出发点来理解这类事物，理解它们的起因，发展，现状和可能的改进。我所关心的往往是“这个事物应该是什么样子”，“它还可以是什么（也许更好的）样子”，而不只是“它现在是什么样子”。不明白我的这一特性，又自恃懂点东西的人，往往会误以为我连基本的术语都不明白。于是天就这样被他们聊死了。&lt;/p&gt;

&lt;p&gt;幸运的是我有几个聊得来的朋友，他们不会那么教条主义。于是今天我跟一个朋友在微信上聊起了“微内核 vs 宏内核”这件事。其实这个问题在我脑子里已经比较清楚了，可是通过这些对话，我学到了新的东西。这些东西是我们在对话之前可能都没有完全理解的，也许很多其他人也没理解。所以我觉得可以把这些有价值的对话记录下来。&lt;/p&gt;

&lt;p&gt;我不想从头解释这个事，因为你可以从网络上找到“微内核”和“宏内核”的设计原理。我想展示在这里的只是我们的对话，里面有对也有错，翻来覆去的思想斗争。对话是一个很有意思的东西，我觉得比平铺直叙的文章还要有效一些。&lt;/p&gt;

&lt;h3 id=&quot;对话&quot;&gt;对话&lt;/h3&gt;

&lt;p&gt;好了，现在开始。对话人物“IAN”是我，“LD”是我的一个朋友。&lt;/p&gt;

&lt;p&gt;（8 月 19 日，开始）&lt;/p&gt;

&lt;p&gt;IAN：好多年没折腾 OS，现在再折腾应该有新的发现。这篇 &lt;a href=&quot;https://pdfs.semanticscholar.org/983f/f3bf3adf07c9679f4a4e49cd5a8db2e68c5a.pdf&quot;&gt;paper&lt;/a&gt; 说 Minix 3 比 Linux 要慢 510%。&lt;/p&gt;

&lt;p&gt;IAN：通常的定义，说微内核只需要 send 和 receive 两个系统调用。你不觉得有问题吗？其实函数调用的本质就是 send（参数）和 receive（返回值），但只有这两个系统调用，这种做法是过度的复用（multiplex）。&lt;/p&gt;

&lt;p&gt;LD：是。&lt;/p&gt;

&lt;p&gt;LD：一个外设产生了中断，中断管理进程接收到到中断，发一个消息给相应的设备驱动进程，这个进程处理中断请求，如果设备驱动有 bug，挂了，也不会干扰 OS。这就是微内核逻辑。&lt;/p&gt;

&lt;p&gt;（下载 Minix 3 源代码看了一会儿。上网搜索关于微内核的资料……）&lt;/p&gt;

&lt;p&gt;IAN：微内核似乎一直没解决性能问题。后面的 L4, QNX… 把 sever 隔离在不同的地址空间似乎是个最大的问题。&lt;/p&gt;

&lt;p&gt;LD：导致通讯成本特别大。本来传递个地址就可以的事。现在要整个复制过去。&lt;/p&gt;

&lt;p&gt;IAN：地址空间不应该分开。或者也许可以在 MMU 上面做文章，传递时把那片内存给 map 过去。这样上下文切换又是一个开销…… 函数调用被搞的这么麻烦，微内核似乎确实是不行。对了，微内核服务调用时会产生进程切换吗？&lt;/p&gt;

&lt;p&gt;LD：会，按照微内核的定义，每一个基本单元都是一个进程。&lt;/p&gt;

&lt;p&gt;IAN：完蛋了。&lt;/p&gt;

&lt;p&gt;LD：内存管理是一个进程，IO 管理是一个进程，每个设备驱动是一个进程，中断管理是一个进程。&lt;/p&gt;

&lt;p&gt;IAN：进程切换的开销……&lt;/p&gt;

&lt;p&gt;LD：为了降低进程间通信开销，所以定义了 L4。我也不太懂这个有啥用。&lt;/p&gt;

&lt;p&gt;IAN：改善的是通信开销，但仍然有进程切换开销。我刚看了一下 L4，它是从寄存器传值，但是进程切换会把寄存器都放到内存吧。&lt;/p&gt;

&lt;p&gt;LD：对呀，所以 L4 意义似乎不大。&lt;/p&gt;

&lt;p&gt;LD：带“微”的除了微软和微信，没一个成功的。&lt;/p&gt;

&lt;p&gt;LD：最近流行的所谓微服务。&lt;/p&gt;

&lt;p&gt;IAN：驱动的 bug 应该有其他办法。&lt;/p&gt;

&lt;p&gt;LD：现在的 OS 的问题，就是内核微小的错误，都是让整个系统挂掉。这和我们写软件应该用多进程还是多线程，同样的问题。&lt;/p&gt;

&lt;p&gt;IAN：应该从硬件底层彻底抛弃现在的进程切换方式。保存的上下文太多。&lt;/p&gt;

&lt;p&gt;LD：现在 OS 不是分成 user 和 kernel 保护级别么。 我觉得再增加一个两个保护级别，专门针对设备驱动程序似乎是更好的选择。&lt;/p&gt;

&lt;p&gt;IAN：我以前设想一个办法可以完全不需要保护级别，而且不需要虚拟内存。&lt;/p&gt;

&lt;p&gt;LD：怎么办？ 编译器静态分析搞定？Rust？&lt;/p&gt;

&lt;p&gt;IAN：完全使用实地址，但是代码无法访问对象外面的内存。&lt;/p&gt;

&lt;p&gt;LD：靠编译器保证？&lt;/p&gt;

&lt;p&gt;IAN：不需要多先进的编译器。语言里面没有指针这东西就行，这样你没法访问不是给你的对象。嗯，需要抛弃 C 语言……&lt;/p&gt;

&lt;p&gt;LD：Rust！&lt;/p&gt;

&lt;p&gt;IAN：用不着 Rust，哈哈。其实 JVM 早就是那样了。只不过通常不认为 JVM 是一个操作系统，但操作系统完全可以做成那样。&lt;/p&gt;

&lt;p&gt;LD：所谓对象，就是每次地址访问，除了地址还有一个 size？ 超过 size 不允许？还是编译器确保一定不会超过 size？&lt;/p&gt;

&lt;p&gt;IAN：你在 Java 或者其它高级语言比如 Python… 都没法访问对象外面的内存啊。只有 C 可以，因为 C 有指针，可以随便指到哪。&lt;/p&gt;

&lt;p&gt;LD：是的。C 这种方式，就是天天在没有护栏的桥上走来走去。除了越界访问，还有一个问题，就是多个 task 同时改一块内存。&lt;/p&gt;

&lt;p&gt;IAN：然后为了防止越界，有了“进程”，“虚拟地址”这种概念。&lt;/p&gt;

&lt;p&gt;LD：虚拟地址，还是为了用虚拟内存。&lt;/p&gt;

&lt;p&gt;IAN：虚拟地址，虚拟内存就是为了隔离。每个进程都以为地址从0开始，然后本来很容易的函数调用被隔离开了。如果改变了这个，微内核就真的可以很快了。实际上内核就不存在了…… 哦，还是有。就只剩下调度器，内存管理。IPC 没了，被函数调用所取代。&lt;/p&gt;

&lt;p&gt;LD：换个思路。其实 OS 最容易出问题的是硬件驱动，所以尽量让硬件标准化，别每个硬件都搞一套自己的驱动。让一套驱动支持多种硬件，问题就解决了。比如 usb 驱动。完全可以做到一类硬件都用一个设备驱动。&lt;/p&gt;

&lt;p&gt;IAN：我还是觉得驱动程序 bug 其实可以不导致当机。用内核线程行不行？共享地址空间，但是异步执行。&lt;/p&gt;

&lt;p&gt;LD：Linux 似乎就是这样。tasklet，可以被调度的。&lt;/p&gt;

&lt;p&gt;IAN：所以驱动程序要是当掉，可以不死对吗？我回去查一下。&lt;/p&gt;

&lt;p&gt;LD：看啥错误了。不小心修改了其它模块的内存就完蛋了。其它错误最多硬件本身不能用了。&lt;/p&gt;

&lt;p&gt;IAN：所以就是为什么你说再多一个保护级别。&lt;/p&gt;

&lt;p&gt;LD：嗯，别碰了内核关键的代码。但是驱动之间还是可以互相干扰的。&lt;/p&gt;

&lt;p&gt;IAN：是个不错的折中方案。所以微内核解决了一个不是那么关键的问题。&lt;/p&gt;

&lt;p&gt;LD：是的。这个问题不重要。哦，对了，Windows 是微内核的。好像从 2000 开始。&lt;/p&gt;

&lt;p&gt;IAN：只是号称吧。Mac OS X 不是号称 Mach 微内核加 BSD 吗？&lt;/p&gt;

&lt;p&gt;LD：对。MacOS 也是微内核。&lt;/p&gt;

&lt;p&gt;IAN：那他们怎么解决的性能问题呢？&lt;/p&gt;

&lt;p&gt;LD：不知道。Windows 蓝屏可不少，显然没做到完全隔离。至于 Mac，不清楚为啥那么稳定。&lt;/p&gt;

&lt;p&gt;IAN：根据我们之前的讨论，Mac 微内核可能是假的。Mac 稳定是因为它的 driver 就没几个吧，硬件都是固定选好的。&lt;/p&gt;

&lt;p&gt;LD：嗯，也是稳定的主要原因。&lt;/p&gt;

&lt;p&gt;IAN：这个英明了…… 而且看来微内核在集群方面也没什么用处。&lt;/p&gt;

&lt;p&gt;LD：集群，每个计算机是一个 node。挂了也不怕。&lt;/p&gt;

&lt;p&gt;（8 月 20 日继续讨论）&lt;/p&gt;

&lt;p&gt;IAN：我发现这个 &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.361.4009&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;paper&lt;/a&gt;……&lt;/p&gt;

&lt;p&gt;IAN：这东西叫 L4Linux，就是 Linux 跑在 L4 微内核上。比起纯 Linux，开销只有 5%&lt;/p&gt;

&lt;p&gt;IAN：代码在这里：http://os.inf.tu-dresden.de/L4/LinuxOnL4&lt;/p&gt;

&lt;p&gt;IAN：L4 的做法是 1) 小参数用寄存器传递，不切换某些寄存器。2) 大型参数把内存映射到接收进程，跟我之前设想的一样。这样避免了拷贝。然后采用了“direct process switch”，“lazy scheduling”降低了调度开销。现代处理器的 tagged TLB 之类也大大降低了进程切换开销。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.yinwang.org/images/direct-message-copy.jpg&quot; width=&quot;56%&quot;&gt;&lt;/p&gt;

&lt;p&gt;IAN：上图是 direct message copy。先把接收进程的目的地址映射到发送进程的地址空间，然后发送进程往里拷贝。所以其实仍然有一次拷贝，并不像我理想的 OS 那样直接就能传递对象引用，完全不用拷贝。Pass-by-value vs pass-by-reference。但这比起 Linux 似乎开销是一样的。&lt;/p&gt;

&lt;p&gt;LD：微内核好处真的很大么？&lt;/p&gt;

&lt;p&gt;IAN：好处就是微内核的好处，隔离。可能看各人需求了。一个 99.99% 可靠的系统和一个 99.999999% 可靠的系统的差别？&lt;/p&gt;

&lt;p&gt;IAN：不过似乎高可靠需求都去用 vxworks 之类的了&lt;/p&gt;

&lt;p&gt;（上网查询 vxworks……）&lt;/p&gt;

&lt;p&gt;IAN：原来 vxworks 也是微内核。&lt;/p&gt;

&lt;p&gt;IAN：5% 的开销还可以接受…… 进程切换开销貌似没有提，用的地址映射方法。&lt;/p&gt;

&lt;p&gt;LD：cross address space&lt;/p&gt;

&lt;p&gt;IAN：刚买了个 tplink 路由器，里面跑的 vxworks。&lt;/p&gt;

&lt;p&gt;LD：tplink 不是 Linux？&lt;/p&gt;

&lt;p&gt;IAN：新的 tplink AC1900，改成了 vxworks。Airport Extreme 也是 vxworks。&lt;/p&gt;

&lt;p&gt;LD：why？&lt;/p&gt;

&lt;p&gt;IAN：实时，可靠性高吧。&lt;/p&gt;

&lt;p&gt;LD：可靠性应该是最高的之一。卫星、武器都用。&lt;/p&gt;

&lt;p&gt;IAN：波音 787 也用这个。各种火星车。&lt;/p&gt;

&lt;p&gt;IAN：还有个 &lt;a href=&quot;https://www.ghs.com/products/safety_critical/integrity-do-178b.html&quot;&gt;GreenHills Integrity DO-178B&lt;/a&gt; 实时操作系统。F35 用的。&lt;/p&gt;

&lt;p&gt;IAN：Much of the F-35’s software is written in C and C++ because of programmer availability; Ada83 code also is reused from the F-22. The Integrity DO-178B real-time operating system (RTOS) from Green Hills Software runs on COTS Freescale PowerPC processors.&lt;/p&gt;

&lt;p&gt;IAN：Freescale PowerPC…&lt;/p&gt;

&lt;p&gt;LD：我们的一个 mcu 就是 freescale 的 powerpc&lt;/p&gt;

&lt;p&gt;LD：有个叫“rtems”的 os，我一直很关注。&lt;/p&gt;

&lt;p&gt;IAN：摘自 Integrity DO-178B RTOS：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Safe and secure by design
- RTOS designed for use in reliable, mission critical, 
safety critical and secure (MILS &amp;amp; MLS) applications
- Based on modern microkernel RTOS design
- Fast, deterministic behavior with absolute minimum interrupt latencies
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;IAN：Integrity 也是微内核。看来微内核是可靠一些，属于在 C 语言框架下的一个不错的折中方案。&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;（如果你有什么不同意见，欢迎联系我。如果觉得有帮助，可以考虑&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付费&lt;/a&gt;）&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-08-19-microkernel</guid>
<pubDate>Mon, 19 Aug 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>中国人的信任危机</title>
<link>https://henix.github.io/feeds/yinwang/2019-08-17-trust.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/08/17/trust&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;中国人的信任危机&lt;/h2&gt;
            &lt;p&gt;最近有些人找到我，问我为什么很久没写文章了，我没有回答他们。一方面是因为我没有必要回答任何问题，另一方面我不想当面告诉这些人——我不信任他们。回国两年以来，我对国人的信任值已经降低到了人生中的最低水平。我发现几乎所有人都是在演戏，极少有人是他们自己，人心已经被贪婪和愚昧所毒害。&lt;/p&gt;

&lt;p&gt;在这种情况下，我已经没有动力跟不熟悉的人“分享”什么了。我以为网络上的人才有这么差，可是回国之后，我发现现实中的人们跟网络上的差别不大。毕竟很多国人大部分时间都生活在网上，没有其它乐趣，成天刷微博，刷知乎，谈论各种名人丑闻，看什么信什么，使得他们的内心变得阴暗。&lt;/p&gt;

&lt;p&gt;回国之前我写过一篇文章『对中国人的信心』，有些朋友看了都在笑我，说你回去就知道了。老实说吧，那篇文章不是真心的，那是我为数不多的 PR 文。我不想自己给大家一种“总是在批判什么”的形象，所以虚情假意了一番。其实我从来就没对“中国人”有什么信心。&lt;/p&gt;

&lt;p&gt;我是一个没有民族情结的人。在我的心里根本就没有“中国人”，“美国人”，“英国人”这样的概念。每一个人都是他们自己的个体，我从来不一概而论。但每个国家在每个时期的主流文化还是有一些特征的。所以虽然我下面要提到对“中国人”的一些感受，你也许是个例外。&lt;/p&gt;

&lt;p&gt;这段时间各种各样的“硅谷精英”回到国内，乘着国内的“AI 热”，“区块链热”，打着各种大牌，扯着各种旗子，到处宣讲和忽悠。他们不希望有人听见我的声音，因为我一眼就能看穿他们的把戏。各种小编写手，拿我的事各种歪曲：“那个被微软全球封杀的人，销声匿迹了。”&lt;/p&gt;

&lt;p&gt;我并没有被微软“全球封杀”，我也没有消失，我比以前任何时候都要强大。我很清楚像我这样的水平的人，应该有什么样的地位，应该对社会起什么样的作用。因为我的良知，对自己的怀疑，我放弃了太多。我太客气了，眼睁睁看着一些名不副实的人占据重要的位置，打压有真才实学的人。这让我遗憾。&lt;/p&gt;

&lt;p&gt;我没想到我所热爱的领域会沦落到今天这种地步。IT 业界的风气真的很差，差到让人恶心。程序员本应是受人尊重的职业，今天却沦落到“996”的地步。野心家们创造了 996 的“文化”，对有才能的人各种压榨和打压。人们受不了了，终于搞了个 996.ICU，结果创造“996”的人站出来，把这种违法压榨的行为叫做“奋斗”，说你不奋斗怎么能成功！很多人还觉得他说得有道理，就是要奋斗啊！这些人就像闰土一样，麻木了。&lt;/p&gt;

&lt;p&gt;这让我想起一个笑话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;新年过后，老板开着一辆崭新的兰博基尼来上班。一进门满脸笑容对我说：“由于你在过去一年的杰出努力，今年我给自己买了一辆兰博基尼。如果你明年继续这么努力…… 我明年再给自己买一辆兰博基尼！”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你越是“奋斗”，越是 996，某些其它人就越是富有。我不管他 996 有什么效果，996 的公司发展如何，这种行为把法制和规矩搞坏了，造成极其恶劣的社会风气。当不正常的现象成为了常态，它的受害者反倒为它辩护，这就非常危险了。这叫做“斯德哥尔摩综合征”。&lt;/p&gt;

&lt;p&gt;不过说回来，996 也许不是一个人发明的。996 加班文化的出现，似乎是民族心理特征所产生的。如果同事里面有些人很拼，还拉其他人一起，虽然公司没有规定 996，某些人自然会变成 996。所以我觉得，我们的文化应该有一个改变，不能太拼了。&lt;/p&gt;

&lt;p&gt;中国人真的是很拼的民族。以前苦惯了拼惯了，忽然有一天不需要那么拼了，仍然继续拼命，不拼不习惯。大部分中国人推崇“苦干”，而忽视了“巧干”。方法不对，事倍功半，就只好加班来弥补。&lt;/p&gt;

&lt;p&gt;中国人虽然好像有钱了，可是人们的幸福指数很低，被恐惧驱使着生活。每个人的脑子里都是“房子”，“车子”，“小孩的教育”……  等到老了身体出问题了，就满脑子都是“养生”。&lt;/p&gt;

&lt;p&gt;每个家庭都怕小孩子“输在起跑线上”，从小就灌输“奋斗”的心理。从小就要“好好学习”，将来才会找到好工作，才有出息。进个大厂，让爸妈有面子，更好找媳妇。这下好了，你好好学习，艰苦奋斗，进入名校，最后你就如愿地做上 996 的工作，继续你的奋斗。那些说你应该奋斗人的人，都躺在家里数钱玩。&lt;/p&gt;

&lt;p&gt;中国就是这样一个“恐惧驱动”的社会，人们的心里没有爱，没有相互关心，没有高贵的品质，只有生存，恐惧，面子，身份，地位…… 攀比的风气盛行。&lt;/p&gt;

&lt;p&gt;“输在起跑线上”的恐惧，让中国父母的脑子里充满了“学区房”，“排名”，“升学率”之类的概念，却没有人真的理解“教育”到底是什么。他们没有明白，小孩子的教育最重要的不是所谓“知识”。他们不理解小学，中学学到的那些东西是多么的肤浅，各种奇技淫巧而已。上了大学那些东西基本上全部要被抛弃，从头来一遍。&lt;/p&gt;

&lt;p&gt;不理解教育是什么的人，会很愿意掏钱让小孩上各种补习班，这就富了一大帮赚智商税的。扯着各种牌子，哈佛，牛津。给公司起个洋名字，请个老外傀儡 CEO 把自己包装成“国际公司”，自称研究过儿童心理学，创造了多么人性化的教学法。不知情的父母们花着几万几万的价钱，把孩子送到这些地方度过他们的童年。&lt;/p&gt;

&lt;p&gt;为了孩子的教育，中国的父母吵了多少架，妻子跟婆婆翻了多少脸。每一个中国女人都对孩子的教育战战兢兢，惶惶不可终日。很多家庭一旦有了孩子，就全家围着孩子转，夫妻的感情基本上就不存在了。当然，过一阵丈夫可能就出轨了，各种乌七八糟狗血的事情。中国似乎很少有感情和心理正常的家庭。&lt;/p&gt;

&lt;p&gt;有了这样的“优厚待遇”，孩子就感觉幸福了吗？从小被逼着学习没时间玩，长大了给人打工，努力挣钱娶老婆，生出来的孩子长大一点又被逼着学习…… 如此生命的轮回，就跟牲口差不多了。女孩子的择偶条件，必然有一项就是“房子”。有人说中国的房价都是丈母娘给炒上去的，这话有点道理。可是房价贵是贵，你花了很多钱，真的能买到质量好的房子吗？&lt;/p&gt;

&lt;p&gt;绝大部分没在国外住过的人都不明白“合理质量”的住宅是什么样的，所以房产公司可以瞎忽悠，以次充好。普通的居民住宅一般住个几年就会破的不成样子，物业不但不提供好的服务，还会为了赚钱干出各种黑心缺德事。为了“维权”，几乎每个小区都有自发成立的“业主委员会”。花了那么多钱，背了几十年的债，闹一辈子的心。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.yinwang.org/images/broken-glass.jpg&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;

&lt;p&gt;比如上图，就是我父母住的成都某小区楼门口的顶棚。玻璃顶棚碎成这样了，业主们闹了两年还不修。你能想象这种心情吗，自己的父母每天从这摇摇欲坠的玻璃下面走过！楼里的三部电梯坏了两部，闹了几个月修了其中一部，还有一部一直不修。物业为了赚外快，还做出其它一系列损害业主利益的事情。业主们拉了一个群，经常跟打仗似的在里面谈论这些事情。&lt;/p&gt;

&lt;p&gt;你也许觉得这是一个特别不好的小区才会这样，可惜旁边的几个小区我看过了，样子都差不多，根本没有品质可言。这就是成都的市中心。我看过一个朋友买的成都高新区的新房子，屋里装修崭新的，一进电梯就像进了贫民窟，地下车库也是破败不堪。难以想象他每天一路走过那样的破地方，钻进一辆豪华的奥迪车…… 这些都是中国最知名的房地产开发商的作品！你买的时候它们还没建好，谁知道搬进去就是这个样子？&lt;/p&gt;

&lt;p&gt;有钱一点的，花很多钱买个“豪宅小区”的房子甚至“别墅”，难道就会好些吗？差不多的。一开头看似金碧辉煌，跟欧洲宫殿似的，过了没多久天花板就裂了，楼下大堂的墙皮就掉了，台阶裂了里面长了草，车库地砖破了没人修，整个小区旧的不像样，蒙了一层灰。可是人家仍然被叫做“豪宅”啊。我看过上海的很多“豪宅小区”，根本就只是做个样子而已。&lt;/p&gt;

&lt;p&gt;比如下图，就是上海黄浦江边某著名“豪宅小区”的大楼门口……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.yinwang.org/images/shanghai-residence.jpg&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;

&lt;p&gt;这就是中国土豪们的“体面”生活。花了很多钱，却买不来真正的品质。美国的建筑质量显然好很多，很普通的房子都比上海最贵的一些“豪宅”要好。为什么呢？因为别人有良知，有规范，有法制。从小就听人说“有些东西是钱买不来的”，现在有了钱，你们体会到了吧？&lt;/p&gt;

&lt;p&gt;中国有那么多暴富的互联网企业，可是连符合基本规范的房子都造不出来。我曾经应邀参观国内一个特别有钱的互联网公司，心想这么有钱的公司，办公楼应该建的很好吧。结果呢，那些楼不知道是哪个村里的工头造的。里面破破烂烂不说，卫生间连擦手纸和干手机都没有。&lt;/p&gt;

&lt;p&gt;国产电视剧都喜欢渲染“霸道总裁”，西装革履的高富帅，住在高大上的精品房子里，让人误以为中国有这样的地方。大家都被骗了，因为你花很多钱也找不到这样的地方。电视剧都是挑了最好的角落拍，拍了再 P 一下。你可以想象摄影机没拍到的地方是什么样子。&lt;/p&gt;

&lt;p&gt;花了很多钱却买不来基本的品质，这就是中国的现状。所以中国人看起来很“有钱”，实际上却很穷。许多被中国人瞧不起的地方，“经济不行了”的地方，房子建的都比中国质量高，市政设施都比中国的干净。只有用心，用良心，才能建设好的生活，可是中国人都只想收获，不想付出。收了别人的钱，却总是偷工减料，不想提供相应的品质。大家都这样，你说生活怎么好得起来？&lt;/p&gt;

&lt;p&gt;生活环境如此，中国人不用心改造现实的环境，却热衷于“虚拟产业”。中国的互联网产业，人工智能，显然是非常受重视的。没有其它国家的人有这么热衷于人工智能和高科技，成天各种浮夸，布道，洗脑。AI 是有用的，但并不是像中国人吹嘘的那样，似乎是唯一可以做的事情，革命性的产业。AI 有它可以做的事情，也有很多它做不到的，可惜中国大佬们全都在浮夸 AI 的能力，每每上台必然说得天花乱坠，跟科幻电影似的。&lt;/p&gt;

&lt;p&gt;作为一个“深度学习工程师”，成天研究和折腾深度学习框架，这些我都看在眼里，记在心里，一直没好说出来。这些布道 AI 的大佬们，到底有没有碰过代码，有没有训练过模型，知不知道深度学习到底是什么……&lt;/p&gt;

&lt;p&gt;这让我想起当年的“大跃进”，大家都叫着要“超英赶美”，大炼钢铁，却连饭都吃不饱。美国人发明了机器学习，深度学习，可是为什么美国人没有像中国人这么“全民 AI”呢？因为别人知道还有很多重要的事情可以做。我坐等你们超英赶美瞎忙乎，我们自己实实在在把房子造好，把街道建好，把衣服造好，把生活弄舒服…… 发展 AI 能改善这些吗？中国人的衣服，鞋子，日用品…… 几乎样样靠进口。&lt;/p&gt;

&lt;p&gt;国内 IT 界组织个演讲，必然把人的名字前面冠以各种头衔：国外某大公司高管，某名校博士  xxx…… 结果呢，尽在鼓吹一些不可能做到的事情，睁着眼睛说瞎话。看得多了你就发现，中国的每一个公众人物，人生导师，都是被金钱操纵的木偶。他们说的并不是他们想的，不是他们相信的。每一个都是在演一出戏，演技如此之差，人们居然看不出来。&lt;/p&gt;

&lt;p&gt;把公司，学校，甚至各种奖放在人的名字前面，好像别人的价值依附于这些一样，是不尊重人的表现。国外组织个演讲，海报上都是人的名字在前，后面最多加一个“Ph.D”，“F.R.S”这样的高级头衔。没有人会刻意声明自己的公司和职位，甚至把这些摆在自己名字前面。这些都显示出品位的低级。&lt;/p&gt;

&lt;p&gt;十多年前在清华的时候，水木清华 BBS 宣传“图灵奖得主xx”来演讲。当时我回复他们说，请不要把“图灵奖”放在别人名字前面好不好？我为什么这样说呢，因为我尊重这个人，我觉得把“图灵奖得主”放在别人名字前面，是不尊重人的做法。&lt;/p&gt;

&lt;p&gt;十多年了，中国的这种文化一点没有变，反而愈演愈烈。什么低级的“头衔”都一股脑往人的名字前面放。这样的风气降低了各种会议的品位，这就是为什么两年以来我从来没有在任何会议上做过演讲。有挺多人邀请我，可是我一看到他们的宣传材料，就觉得太低级，根本不适合我出面。&lt;/p&gt;

&lt;p&gt;没有其它国家的人如此的在乎“名”，在乎标签，以至于大部分中国人出国读书不是为了真才实学，而只是为了贴金，挂个品牌。中国海归们喜欢炫耀自己是从国外哪个学校来的，在哪个知名公司待过，每一次遇到这种人我都打心眼里瞧不起他们。&lt;/p&gt;

&lt;p&gt;可是中国的土豪公司就是看重这些。很多国内公司招的高管，不是因为他们有深刻的见解，能够引导大家走向正确的方向，而是为了能利用他们的“名牌”为自己造势。所以他们必然要找一个叫得响名字的国外公司，他做过一个大家听说过的项目。至于这个项目到底质量如何，他在里面到底起了多大作用，甚至是帮倒忙，他们不管。然后这些人进去就各种瞎指挥，高高在上，打压其他人。&lt;/p&gt;

&lt;p&gt;我回国以来不断有中国公司找我，很可惜绝大部分都是看重我的“名”，而对我的实力，我的见解和人品不关心。开头热情洋溢的，后来发现我不愿意出头露面布道，不能把我名字打在网站上，不能利用我的名气，后来就不联系了。所以后来这样的公司找我，都懒得理了。&lt;/p&gt;

&lt;p&gt;中国的各位牛人大佬，却可以不知羞耻地用自己的“名”换来“利”，被贪欲驱使而到处站台宣讲和鼓吹。我真为他们可惜，毁掉了自己的一世英名。我早就看透了许多的中国业界公众人物，几乎没有任何一个值得我尊敬的。但这一次 AI 和区块链热潮到来，真是把他们的本质暴露的淋漓尽致。原来的科学家，工程师，摇身一变成为了传销布道者。&lt;/p&gt;

&lt;p&gt;鼓吹 AI 和区块链的小媒体也像雨后春笋一样发展起来。标题必须以“重磅！……”开头，内容是语不惊人誓不休，满篇兴奋浮夸的语气。把小打小闹的改进说成是划时代的突破，尽其危言耸听之能事。字里行间充满了“大牛”，“大神”，“神童”之类的词汇。每每在朋友圈看到有人转发这种文章，我都会对转发者的水准产生怀疑。&lt;/p&gt;

&lt;p&gt;现在创业一个常见做法，就是把最热门的词汇都放在一起，或者往上面靠。比如有好些公司号称同时用了“深度学习”和“区块链”，而他们的业务跟其中一项毫不沾边。甚至有的公司业务跟这两者完全没有关系，但公司拿了投资人的钱，折腾几年也不出成果，乘着这个东风也想来捞一把，所以也号称用了深度学习和区块链，甚至开始“发币”。&lt;/p&gt;

&lt;p&gt;说到区块链…… 我有一个朋友很喜欢研究区块链，是真心喜欢这技术，我看的区块链技术书都是他推荐的。这家伙回国来加入过好多区块链项目，跟我说过的就有六七个之多。每次开头都很兴奋，说这次这个应该可以成，我觉得他们是很严肃地想做这个事！结果每次过了没两个月又对我说，妈呀，这帮人写了白皮书，拉了上亿的投资，一年没有写过一行代码，现在等着我一个人去帮他们实现！&lt;/p&gt;

&lt;p&gt;看到他这么迷茫，我也好心帮他看过几个项目，这就是为什么我之前写过关于区块链智能合约的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/02/22/smart-contract&quot;&gt;文章&lt;/a&gt;。其实那篇文章针对的是一个他给我看的新项目，项目是由美国数一数二的牛校的教授出面发起的。白皮书说要用“深度学习”来训练得到形式验证所需要的“前条件”和“后条件”。&lt;/p&gt;

&lt;p&gt;我一眼就知道是忽悠，“深度学习+区块链+智能合约”，真是会蹭风口。朋友跟我说他们想融 2 亿美元。怎么也没想到美国名校的大教授居然也会下水干这种勾当。这教授也是华人，就像大部分的区块链骗子项目一样，都是中国人发起的。白皮书的作者，包括几个美国大学教授，全都是中国人。&lt;/p&gt;

&lt;p&gt;很多年前我还曾经见过其中一位教授，当时感觉还挺有实力，值得尊敬一个人。可是那天看到他的名字上了白皮书，头像放在网站上，他在我心目中的形象彻底毁掉了。&lt;/p&gt;

&lt;p&gt;还曾经有英国某牛校的博士后找我合作区块链的事，拉着他导师来站台剪裁照相。这么正经的专业，却满口油嘴滑舌的，说了半天冠冕堂皇伟大的口号，终究还是说出了最终的目的：想要“发币”。&lt;/p&gt;

&lt;p&gt;我为这些人感到耻辱，我为我们的民族感到耻辱。这么多的中国人明目张胆干这样的事情，为了钱出卖自己的灵魂，我们还有脸面对世界上的其他民族吗？中国人在世界上是什么样的形象？知道某些国外媒体怎么评价中国吗：“现在的中国，钱就是上帝！”&lt;/p&gt;

&lt;p&gt;所以很多人说现在 AI 是大骗，区块链是小骗。有人说币圈彻底的揭示了人性最丑恶的一面。我觉得说得挺对。&lt;/p&gt;

&lt;p&gt;这些见得多了也就困了，感觉特别无聊。被利益的肥肉引来的大量苍蝇，已经充斥了人们的视线。靠谱的人，那些能把机器学习和区块链用在该用的地方的人，比例就越来越小。&lt;/p&gt;

&lt;p&gt;中国人已经迷失了自己的文化，我越来越看不明白我们是在走向文明还是愚昧。中国需要一个巨大的改变。这个改变需要从停止这些浮躁的风气，认识到我们的错误和不足开始。&lt;/p&gt;

&lt;p&gt;（声明一下：本文不代表本人所在公司的立场，其中描述的事情也跟本人所在公司无关。其实我身边有不少踏实又有见解的人，我只是感觉国内业界总体乌烟瘴气，欠骂。）&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-08-17-trust</guid>
<pubDate>Sat, 17 Aug 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>关于人的素质</title>
<link>https://henix.github.io/feeds/yinwang/2019-07-31-human-quality.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/07/31/human-quality&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;也说人的素质&lt;/h2&gt;
            &lt;p&gt;最近上海开始搞垃圾分类，有些人就开始把“能否准确分类垃圾”跟“素质”这个词挂钩，从道德高度鄙视那些不认真分类垃圾，或者不按规定投放垃圾的人。有些小区门口每周都要张榜，公开表扬和批评各楼层的垃圾分类情况。某些人很是有种给人发小红花的快感。&lt;/p&gt;

&lt;p&gt;且不说上海的垃圾分类方法和执行方式是否合理（比如湿垃圾破袋扔之类的奇葩做法）…… 这些战战兢兢指手画脚，使我想起一些关于“素质”一词的事情来……&lt;/p&gt;

&lt;p&gt;很多中国人喜欢提“素质”这个词，总觉得自己是素质高尚的，喜欢指责别人素质低。然而真的如此吗？实际上，我发现爱提“素质”这个词的人，在心理上都是有一定问题的。&lt;/p&gt;

&lt;p&gt;在这些人心里，素质只是一个口号，一个标牌，一个可以把自己放到别人之上，获得优越感的心理手段。总觉得自己高人一等，说别人素质低，好像自己素质就无可挑剔，是圣人。&lt;/p&gt;

&lt;p&gt;我排队，所以我素质高，所以我可以鄙视其他人。别人只是走到前面看了看，就觉得别人要插队…… 喂喂喂，你干嘛？到后面排队去！什么素质…… 小区公告说可回收垃圾要自己拿到挺远地方扔，你把可回收垃圾洗的干干净净码的整整齐齐，但你觉得搬运可回收物应该是垃圾处理人员的本职工作，你就像以往一样放在垃圾桶旁边，所以你素质低，不讲公德，你就是村炮，我就高你一等！&lt;/p&gt;

&lt;p&gt;这其实体现了他们内心对待其他人的不平等，或者叫做“歧视”。喜欢歧视其他人的人往往也有另外一种性质，叫做“势利”。满口“素质”的人往往是势利的。他们自以为是圣人，而其实呢，他们缺少最重要的一种品质——平等对待和尊重他人。&lt;/p&gt;

&lt;p&gt;还有另外一些人，他们因为恐惧而做出显示“高素质”的举动。这些人很在意别人的眼光，生怕在外人眼里素质不高了，所以事事谨小慎微。这种人在早期是因为被前一种人鄙视，所以因为恐惧而显示“高素质”。久而久之，他们也开始鄙视其他人，总喜欢说别人素质低。这也许就是所谓“斯德哥尔摩综合征”。&lt;/p&gt;

&lt;p&gt;可惜的是，以上这些人都没有明白真正的素质是什么。他们避免某种行为，是因为他们怕别人觉得自己“素质低”，所以不再高人一等，或者怕被人看不起。他们的行为是出于恐惧或者其它卑劣的心态，而不是因为从内心尊重其他人。&lt;/p&gt;

&lt;p&gt;有位古人说得好，“己所不欲，勿施于人”。能够从内心尊重他人，体会到某种行为对他人造成的影响，从而自动调整自己的行为，这就叫做“共情”，compassion。从这种美好的感情出发，调整自己的行为，而不引以为豪。一旦有了共情，良好的行为将成为自动的，而不需要调动恐惧，或者高人一等的心理。&lt;/p&gt;

&lt;p&gt;没有这种共情感觉的人，就只能按照条条款款规矩办事。书上说这个是“素质低”的表现，所以我不这样，但是从来没理解为什么。如果你理解了，就会发现你不用记住这些规矩了。因为你能切身体会到这些行为所造成的烦恼，所以你就能像对待自己一样去照顾其他人的感受。&lt;/p&gt;

&lt;p&gt;一旦你从内心体会到这些，你就不会再提“素质”这个词了。你的行为不再是为了显得自己素质高，高人一等，而是自动的，发自内心的。你也会发现有些所谓“素质高”的做法其实是多此一举，承担不必要的责任。然后你就学会了灵活行事，让自己和其他人的生活都更加美好。不是名义上的“美好”，而是实质意义上的。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-07-31-human-quality</guid>
<pubDate>Wed, 31 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>再谈“P vs NP”问题</title>
<link>https://henix.github.io/feeds/yinwang/2019-07-21-pnp2.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/07/21/pnp2&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;再谈“P vs NP”问题&lt;/h2&gt;
            &lt;p&gt;好几年前曾经写过一篇文章表达对计算机科学里著名的 “&lt;a href=&quot;https://en.wikipedia.org/wiki/P_versus_NP_problem&quot;&gt;P vs NP&lt;/a&gt;” 问题的看法。当时正值我人生中第 N 次研究那些东西，由于看透了却不在乎，所以写得特别简略。没想到有人看到后，还以为我没仔细学过复杂度理论，说我信口开河。我一般懒得谈论这种太理论的问题，身边也很少有人关心，所以后来干脆把文章撤了。不是我说的有什么不对，而是我懒得跟人争论。&lt;/p&gt;

&lt;p&gt;没想到最近又遇到有人抓住我删掉的文章，乘机拿出来贬损我，尽其羞辱之能力。说王垠你太自以为是了，你知不知道“P vs NP”要是解决了，世界将有天翻地覆的变化，多少的计算难题会被解决，机器学习都没必要了，非对称加密全都被破解…… 跟上课似的头头是道滔滔不绝，几乎把他本科算法课本上的内容给我背了一遍，以为别人不知道一样，却没有显示出任何他自己的思想。&lt;/p&gt;

&lt;p&gt;呃，我真是服了某些人背书冒术语的能力，难怪能做国内某大厂的 P10（注：不是我的在职公司）。鉴于很多人对此类问题的一知半解，反倒嘲笑别人不懂，牛逼轰轰打压其他人，我决定事后把这个问题再详细讲一下，免得以后还要为它费口舌。&lt;/p&gt;

&lt;p&gt;对于初学者这篇文章有点门槛，需要学习一些东西。“&lt;a href=&quot;https://en.wikipedia.org/wiki/P_versus_NP_problem&quot;&gt;P vs NP&lt;/a&gt;” 问题属于计算理论（Theory of Computation）的一部分——复杂度理论。计算理论不止包括复杂度理论（Complexity），还包括可计算性（Computability），也就是“停机问题”一类的内容。&lt;/p&gt;

&lt;p&gt;国内大学的计算机教学一般在算法课上对复杂度理论有初级的讲授，但很少人能够真的理解。如果你没有系统的学习过复杂度理论，我建议你研读一下计算理论的专著（而不是普通的算法教材），比如 Michael Sipser 的『&lt;a href=&quot;https://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X&quot;&gt;Introduction to the Theory of Computation&lt;/a&gt;』。&lt;/p&gt;

&lt;p&gt;我当年在 Indiana 做研究生计算理论课助教的时候，可算是把这书给看透了…… 被逼的。其中“可计算性理论”在我将来的 PL 研究中起了比较大的启发作用，而复杂度理论的用处一般。我觉得 Sipser 的书写的不够清晰透彻，但很多学校拿它做教材，好像也没有其它特别好的替代品。&lt;/p&gt;

&lt;p&gt;计算理论如此晦涩难懂，我认为图灵机是祸首。如果你能理解 lambda calculus，将会大大简化理解计算理论的过程。如果你想用更深刻更容易的方法理解计算理论，可以参考&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/10/18/turing&quot;&gt;这篇文章&lt;/a&gt;的“Lambda 演算与计算理论”一节，里面会提到另一本参考书。从这篇文章你也可以看出来，我丝毫不崇拜图灵。&lt;/p&gt;

&lt;h3 id=&quot;p-vs-np-真的重要吗&quot;&gt;“P vs NP” 真的重要吗？&lt;/h3&gt;

&lt;p&gt;“P vs NP” 这个问题有它的理论价值，它是有趣的问题，里面的有些思路有启发意义，值得花些时间来了解。但计算机科学界长久以来都严重夸大它的重要性，把一个很普通的问题捧上了天，吹得神乎其神。&lt;/p&gt;

&lt;p&gt;再加上图灵机模型在计算理论界的广泛使用，使得这门学问显得异常艰深。很多人看到图灵机就晕了，在课程上蒙混过关，考试完了就全忘了，根本无法理解里面的实质内容。正是因为很多人的不明觉厉，使得“P vs NP”登上了它在 CS 界的宝座。&lt;/p&gt;

&lt;p&gt;很多人做了一辈子计算机工作，做了很多巧妙的设计构架，写了许许多多的代码，解决了很多性能难题。提到“P vs NP”，虽然一辈子都没用上这个理论，仍然顶礼膜拜。由此可见“不明觉厉”对于人们心理的威力。&lt;/p&gt;

&lt;p&gt;很多人认为“P vs NP”是计算机科学最重要的问题。Clay 数学研究所甚至悬赏一百万美元解决这个问题，把它叫做数学界的 7 个千年难题之一，跟黎曼猜想并列其中。&lt;/p&gt;

&lt;p&gt;好几次有人声称解决了“P vs NP”，上了新闻，闹得舆论沸沸扬扬，小编们吹得好像世界要天翻地覆了一样，把他们追捧为天才苦行僧，后来却又发现他们的结果是错的……&lt;/p&gt;

&lt;p&gt;如果你真的理解了“P vs NP”的内涵，就会发现这一切都是闹剧。这个问题即使得到解决，也不能给世界带来很大变化。解决这个问题对于现实的计算，作用是微乎其微的。不管 P 是否等价于 NP，我们遇到的计算问题的难度不会因此有重大改变。&lt;/p&gt;

&lt;p&gt;甚至有些数学家认为“P vs NP” 根本没有资格跟黎曼猜想一起并列于“千禧年问题”。我倒是希望有人真的解决了它，这样我们就可以切实的看到这有什么意义。&lt;/p&gt;

&lt;p&gt;“P vs NP” 也许不是愚蠢的问题，但计算机科学界几十年以来夸大它的重要性的做法，是非常愚蠢的，让整个领域蒙羞。&lt;/p&gt;

&lt;p&gt;真正重要的数学问题被解决，应该对现实世界具有强大的作用。这种作用可以是“潜在的”，它的应用可以发生在很久以后的将来，但这必须能够被预见到。数学家们把这叫做“applicable result”（注意不叫 applied 或者 practical）。否则这个数学问题就只能被叫做“有理论价值”，“有趣”，而不能叫做“重要”。即使所谓“纯数学”，也应该有可以预见的效果。&lt;/p&gt;

&lt;p&gt;很多数学家都明白黎曼猜想（Riemann hypothesis）的重要性。大数学家希尔伯特说过：“如果我沉睡了三千年醒过来，我的第一句话会是‘黎曼猜想被解决了吗？’” 假设希尔伯特还在世，他会对解决“P vs NP”有同样的渴望吗？我觉得不会。实际上，很多数学家都觉得“P vs NP”的重要性根本没法和黎曼猜想相提并论，因为我们预见不到它会产生任何重要的效果。&lt;/p&gt;

&lt;h3 id=&quot;什么是多项式时间&quot;&gt;什么是多项式时间？&lt;/h3&gt;

&lt;p&gt;很多人提到“P vs NP”就会跟你吹嘘，P 如果等于 NP，世界将有天翻地覆的变化。许许多多我们以前没法办到的事情，都将成为现实。非对称加密技术会被破解，生物化学将得到飞跃，机器学习将不再有必要……&lt;/p&gt;

&lt;p&gt;这些人都忽略了一个重要的问题：什么是多项式时间。盲目的把“多项式”等同于“容易”和“高效”，导致了对 “P vs NP” 重要性的严重夸大。&lt;/p&gt;

&lt;p&gt;n&lt;sup&gt;100&lt;/sup&gt; 是不是多项式？是的。n&lt;sup&gt;1000000&lt;/sup&gt; 也是多项式。n&lt;sup&gt;100&lt;sup&gt;100&lt;/sup&gt;&lt;/sup&gt; 也是多项式，n&lt;sup&gt;100&lt;sup&gt;100&lt;sup&gt;100 &lt;/sup&gt;&lt;/sup&gt;&lt;/sup&gt;也是多项式…… 实际上，只要 n 的指数是常数，它就是一个多项式，而 n 的指数可以是任意大的常数！n 的指数可以是任意大的常数！n 的指数可以是任意大的常数！重要的事情说三遍。&lt;/p&gt;

&lt;p&gt;时间复杂度 n&lt;sup&gt;100&lt;sup&gt;100&lt;sup&gt;100 &lt;/sup&gt;&lt;/sup&gt;&lt;/sup&gt; 的算法，能用吗？所以即使 P=NP，你需要的计算时间仍然可以是宇宙毁灭 N 次，其中 N 是任意的常数。&lt;/p&gt;

&lt;p&gt;说到这里，又会有人跟我说你不懂，当 n 趋近于无穷的时候，非多项式总会在某个时候超越多项式，所以当 n “足够大”的时候，多项式时间的算法总是会更好。很可惜，“无穷”对于现实的问题是没有意义的。任何被叫做“重要”的问题，都应该在合理的时间内得到结果。&lt;/p&gt;

&lt;p&gt;我们关心的要点不应该是“足够大”，而是“具体要多大”。精确的量化，找到实际可以用的区间，这才是合格的科学家该有的思路。计算机科学里，大 O 表示法泛滥成灾，只看最高次幂，忽略系数和常数项，也是常见的误区。我也曾经沉迷于如何把 O(n&lt;sup&gt;3&lt;/sup&gt;) 的算法降低到 O(n&lt;sup&gt;2.9&lt;/sup&gt;)，现在回头才发现当年是多么的幼稚。&lt;/p&gt;

&lt;p&gt;“多项式时间”这个概念太宽泛太笼统。以如此笼统的概念为基础的理论，不可能对现实的计算问题产生意义。我们关心的不应该仅仅是“是否多项式”，而是“具体是什么样的多项式”。6n&lt;sup&gt;20&lt;/sup&gt; + 26n&lt;sup&gt;7&lt;/sup&gt; + 200，1000n&lt;sup&gt;3&lt;/sup&gt; + 8n&lt;sup&gt;2&lt;/sup&gt; + 9，…… 每一个多项式的曲线都是很不一样的，在各个区间它们的差别也是不一样的。多项式的幂，系数，常数项，它们的不同都会产生重大的差异。&lt;/p&gt;

&lt;p&gt;这就是为什么“P=NP”没有很大意义，因为 P 本身太笼统，其内部的差异可以是天壤之别。与其试图笼统的证明 P 等价于 NP，还不如为具体的问题想出实质意义上高效的算法，精确到幂，系数，常数项。&lt;/p&gt;

&lt;h3 id=&quot;pnp-有意义吗&quot;&gt;P!=NP 有意义吗？&lt;/h3&gt;

&lt;p&gt;“P vs NP”问题有两种可能性：P=NP（等价），或者 P!=NP（不等价）。以上我说明了 P=NP 的意义不大，那么要是 P!=NP 呢？&lt;/p&gt;

&lt;p&gt;很多人会跟你说，要是一个问题是 NP-Hard，然后又有 P!=NP，那么我们就知道这个问题没有多项式时间的算法存在，就避免了为多项式时间算法浪费时间了。这不也有一些价值吗？&lt;/p&gt;

&lt;p&gt;我并没有否认 P!=NP 是有那么一点价值：在某些时候它也许避免了浪费时间。但这种价值比较小，而且它具有误导性。&lt;/p&gt;

&lt;p&gt;一个常见的 NP-Hard 问题是 SAT。如果  P!=NP，那么大家就应该放弃为它找到高效的算法吗？如果大家都这样想，那么现在的各种高效的 SAT solver 就不存在了。实际上，利用随机算法，我们在大多数时候都能比较快的解决 SAT 问题。&lt;/p&gt;

&lt;p&gt;问题在于，“P vs NP”关心的只是“最坏情况”，而最坏情况也许非常罕见。有些问题大部分实际的情况都可以高效的解决，只有少数变态的情况会出现非常高的复杂度。为了这少数情况放弃大多数，这就是“P vs NP”的误导。&lt;/p&gt;

&lt;p&gt;如果因为 P!=NP，你认为 NP-Hard 的问题就没有高效的算法，那你也许会误以为你可以利用这些“难题”来做非对称加密。然而 NP-Hard 并不等于没法快速解决，所以要是你因此被误导，也许会设计出有漏洞的加密算法。&lt;/p&gt;

&lt;p&gt;即使 P!=NP，我们仍然不能放弃寻找重要的 NP-Hard 问题的高效算法，所以确切的证明 P!=NP 的价值也不是那么重要了。其实你只要知道 P=NP “大概不可能”，就已经能起到“节省时间”的目的了。你没必要证明它。&lt;/p&gt;

&lt;h3 id=&quot;什么是-np&quot;&gt;什么是 NP？&lt;/h3&gt;

&lt;p&gt;这一节我来讲讲“P vs NP”里的“NP”到底是什么。内容比较深，看不懂的人可以跳过。&lt;/p&gt;

&lt;p&gt;很多人都没搞明白 NP 是什么就开始夸夸其谈“P vs NP”的价值。 经常出现的错误，是把 NP 等同于“指数时间”。实际上 NP 代表的是“Nondeterministic Polynomial time”，也就是“非确定性图灵机”（nondeterministic Turing machine）能在多项式时间解决的那些问题。&lt;/p&gt;

&lt;p&gt;什么是“非确定性图灵机”？如果你把课本上那堆图灵机的定义看明白看透了，然后又理解了程序语言理论，你会发现所谓“非确定性图灵机”可以被很简单的解释。&lt;/p&gt;

&lt;p&gt;你可以把我们通常用到的程序看作是“确定性图灵机”（deterministic Turing machine）。它们遇到条件分支，在同一个时刻只能走其中一条路，不能两边同时探索。&lt;/p&gt;

&lt;p&gt;那么“非确定性图灵机”呢？你可以把“非确定性图灵机”想象成一个具有“超能力”的计算机，它遇到分支语句的时候，可以同时执行 True 和 False 两个分支。它能够同时遍历任意多的程序分支，这是一台具有超能力的机器！&lt;/p&gt;

&lt;p&gt;所以“P vs NP”的含义大概就是这样：请问那些需要非确定性图灵机（超能力计算机）在多项式时间才能解决的问题，能够用确定性图灵机（普通计算机）在多项式时间解决吗？&lt;/p&gt;

&lt;p&gt;现在问题来了，具有如此超能力的机器存在吗？答案当然是“No！” 就算是量子计算机做成功了，也不可能具有这样的计算能力。没有人知道如何造出非确定性图灵机，人们没有任何头绪它如何能够存在。&lt;/p&gt;

&lt;p&gt;所以 “P vs NP” 这个 问题的定义，是基于一个完全假想的机器——非确定性图灵机。既然是假象的机器，为什么一定要是“非确定图灵机”呢？为什么不可以是其它具有超能力的东西？&lt;/p&gt;

&lt;p&gt;仔细想想吧，“非确定性图灵机”对于现实的意义，就跟 Hogwarts 魔法学校和哈利波特对于现实的意义一样。我们为什么不研究“P vs HP”呢，其中 H 代表 Harry Potter。HP 定义为：哈利波特能够在多项式时间解决的问题。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“P vs NP”问题：请问那些需要非确定性图灵机（超能力计算机）在多项式时间才能解决的问题，能够用确定性图灵机（普通计算机）在多项式时间解决吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;“P vs HP”问题：请问那些需要哈利波特在多项式时间才能解决的问题，能够用确定性图灵机（普通计算机）在多项式时间解决吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我不是开玩笑，仔细回味一下 “P vs NP” 和 “P vs HP” 的相似性吧。也许你会跟我一样意识到 NP 这个概念本身就是虚无的。我不明白“一个不存在的机器能在多项式时间解决的问题”，这样的说法有何意义，基于它的理论又有什么科学价值。&lt;/p&gt;

&lt;p&gt;非确定性图灵机存在的意义，也许只是因为它可以被证明等价于其它一些常见的问题，比如 SAT。计算理论书籍一般在证明 SAT 与 非确定性图灵机等价性之后，就完全抛掉了非确定性图灵机，之后的等价性证明都是通过 SAT 来进行。&lt;/p&gt;

&lt;p&gt;我觉得 NP 这个概念其实是在故弄玄虚。我们完全可以从 SAT 本身出发去发展这个理论，而不需要设想一个具有超能力的机器。我们可以有一个问题叫做“P vs SAT”，而不出现 NP 这个概念。&lt;/p&gt;

&lt;p&gt;（有点扯远了）&lt;/p&gt;

&lt;h3 id=&quot;其它质疑-p-vs-np-价值的人&quot;&gt;其它质疑 P vs NP 价值的人&lt;/h3&gt;

&lt;p&gt;有人认为我质疑 P vs NP 的价值是一知半解信口开河，然而我并不是第一个质疑它的人。很多人对 P vs NP 都有类似的疑惑，但因为这个问题的地位如此之高，没人敢站出来。只要你开口，一群人就会居高临下指责你基础课程没学好，说你眼界太窄…… 再加上那一堆纷繁复杂基于图灵机的证明，让你有苦说不出。&lt;/p&gt;

&lt;p&gt;由于这个原因，我从来没敢公开表达我的观点，直到我发现 Doron Zeilberger 的这篇&lt;a href=&quot;http://sites.math.rutgers.edu/~zeilberg/Opinion98.html&quot;&gt;文章&lt;/a&gt;。Zeilberger 是个数学家，Rutgers 大学的数学系教授。在那之前他开了个玩笑，戏称自己证明了 P=NP，还写了篇像模像样的论文。在文章里他告诫大家：不要爱上你的模型（Don’t Fall In Love With Your Model）。他这句话说到了我心里。&lt;/p&gt;

&lt;p&gt;你还能在网络上找到其它人对“P vs NP”的质疑，比如这篇来自于一位专门研究计算理论的学者：&lt;/p&gt;

&lt;p&gt;​    &lt;a href=&quot;https://rjlipton.wordpress.com/2009/07/03/is-pnp-an-ill-posed-problem&quot;&gt;Is P=NP an Ill Posed Problem?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我觉得他讲的也很在理。正是在这些人的鼓舞之下，我随手写出了之前对“P vs NP” 的质疑。只言片语里面，融入了我多年的深入学习，研究和思考。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;看这篇文章很累吧？我写着也累。对于我来说这一切都已经那么明了，真的不想费口舌。但是既然之前已经说出来了，为了避免误解，我仍然决定把这些东西写下来摆在这里。如果你暂时看不懂可以先放在一边，等到了需要深入研究计算理论，想得头痛的时候再来看。你也许会感谢我。&lt;/p&gt;

&lt;p&gt;我希望严谨的计算机科学工作者能够理解我在说什么，反思一下对“P vs NP”的理解。计算机专业的学生应该理解“P vs NP”理论，但不必沉迷其中。这并不是一个值得付出毕生精力去解决的问题。计算机科学里面还有其它许多有趣而重要的问题需要你们去探索。如果你觉得计算机科学都不过瘾，你可以去证明黎曼猜想啊 :)&lt;/p&gt;

&lt;p&gt;当然所有这些都是我的个人观点，我没有强求任何人接受它们。强迫别人接受自己的观点是不可以的，但想阻止别人表达对此类问题的质疑，也是不可以的，因为我们生活在自由的世界。&lt;/p&gt;

&lt;p&gt;没人想抢走你们的玩具，但不要忘了，它只是玩具。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-07-21-pnp2</guid>
<pubDate>Sun, 21 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>再谈“P vs NP”问题</title>
<link>https://henix.github.io/feeds/yinwang/2019-07-16-pnp2.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/07/16/pnp2&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;&lt;![CDATA[
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        ]]&gt;&lt;/script&gt;
&lt;div class=&quot;inner&quot;&gt;&amp;#13;
            &lt;h2&gt;再谈“P vs NP”问题&lt;/h2&gt;&amp;#13;
            &lt;p&gt;曾经写过一篇文章，表达对计算机科学里著名的 “&lt;a href=&quot;https://en.wikipedia.org/wiki/P_versus_NP_problem&quot;&gt;P vs NP&lt;/a&gt;” 问题的看法。当时正在研究那些东西，由于看透了却不在乎，所以写得特别简略。没想到有人看到那篇文章后，还误以为我没仔细学过复杂度理论，认为我是武断的信口开河。我一般懒得谈论这种太理论的问题，身边很少有人关心，所以后来干脆把文章撤了。&lt;/p&gt;

&lt;p&gt;没想到最近又遇到有人抓住我删掉的文章，跟我辩论这事。跟上课似的头头是道滔滔不绝，几乎把他本科算法课本上的内容给我背了一遍，却没有显示出任何他自己的思想。所以我决定事后把这个问题再详细讲一下，免得以后还要为它费口舌。&lt;/p&gt;

&lt;p&gt;计算理论（Theory of Computation）我系统的学过很多遍了，理解得比绝大部分人都要透彻，我看破了这里面的很多事情。计算理论的书籍和文献，几乎全都基于图灵机模型。而研究编程语言和逻辑的学者，很多都不认同图灵的理论。他们从图灵的导师（&lt;a href=&quot;https://en.wikipedia.org/wiki/Alonzo_Church&quot;&gt;Alonzo Church&lt;/a&gt;）和他的师兄们（比如 &lt;a href=&quot;https://en.wikipedia.org/wiki/Stephen_Cole_Kleene&quot;&gt;Stephen Kleene&lt;/a&gt;）那里学东西。这些人的理论往往比图灵的要清晰简单，并且具有同等的建模价值。&lt;/p&gt;

&lt;p&gt;受到这些人的启发，摸透了图灵机，lambda calculus，combinatory logic，…… 经过周密的思考，我才对 P vs NP 的重要性提出了质疑。这是我多年积累的看法，感觉自然到了不需要辩论的地步，却没想到说出来之后遭到如此的抗议。&lt;/p&gt;

&lt;p&gt;起初为此苦恼，但逐渐的我理解了，这是深刻的见解表达出来的时候必须面对的现实。我应该对人们的不理解感到同情，而不是懊恼。很多人对 P vs NP 的理解停留于本科算法课学到的内容。他们不知道 lambda calculus 是什么，没有切实的理解图灵机与 lambda calculus 的等价性，不能像我一样从更清晰的角度看看待计算理论问题。&lt;/p&gt;

&lt;p&gt;如果你没有系统的学习过复杂度理论，我建议你仔细研读一下经典的计算理论教材，比如 Michael Sipser 的『&lt;a href=&quot;https://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X&quot;&gt;Introduction to the Theory of Computation&lt;/a&gt;』。我觉得 Sipser 的书写的不够清晰透彻，但很多学校拿它做教材，好像也没有更好的替代品，所以将就着看吧。&lt;/p&gt;

&lt;h3 id=&quot;p-vs-np-真的是重要问题&quot;&gt;“P vs NP” 真的是重要问题？&lt;/h3&gt;

&lt;p&gt;“P vs NP” 这个问题有它的理论价值，它是有趣的问题，值得花些时间来了解。但计算机科学界长久以来都在严重夸大它的重要性，把一个很普通的问题捧上了天，吹得神乎其神。&lt;/p&gt;

&lt;p&gt;很多人认为“P vs NP”是计算机科学最重要的问题。Clay 数学研究所甚至悬赏一百万美元解决这个问题，把它叫做数学界的 7 个千年难题之一，跟黎曼猜想并列其中。&lt;/p&gt;

&lt;p&gt;好几次有人声称解决了“P vs NP”，上了新闻，闹得舆论沸沸扬扬，小编们吹得好像世界要天翻地覆了一样，把他们追捧为天才苦行僧，后来却又发现他们的结果是错的……&lt;/p&gt;

&lt;p&gt;如果你真的理解了“P vs NP”的内涵，就会发现这一切都是闹剧。这个问题即使得到解决，也不能给世界带来很大变化。实际上，解决这个问题对于现实的计算，作用是微乎其微的。不管 P 是否等价于 NP，我们遇到的计算问题的难度不会因此有任何改变。&lt;/p&gt;

&lt;p&gt;在我看来，“P vs NP” 根本没有资格跟黎曼猜想一起并列于“千禧年问题”。我倒是希望有人真的解决了它，这样我们就可以切实的看到这有什么意义。&lt;/p&gt;

&lt;p&gt;“P vs NP” 不是愚蠢的问题，但计算机科学界夸大它的重要性的做法，是非常愚蠢的。&lt;/p&gt;

&lt;h3 id=&quot;什么是多项式时间&quot;&gt;什么是多项式时间？&lt;/h3&gt;

&lt;p&gt;真正重要的数学问题被解决，应该对现实世界具有强大的作用。这种作用可以是“潜在的”，它的应用可以发生在很久以后的将来，但这必须能够被预见到。数学家们把这叫做“applicable result”。否则这个数学问题就只能被叫做“有理论价值”，“有趣”，而不能叫做“重要”。即使所谓“纯数学”，也应该有可以预见的效果。&lt;/p&gt;

&lt;p&gt;很多数学家都明白黎曼猜想（Riemann hypothesis）的重要性。大数学家希尔伯特说过：“如果我沉睡了三千年醒过来，我的第一句话会是‘黎曼猜想被解决了吗？’” 如果希尔伯特还在世，他会对解决“P vs NP”有同样的渴望吗？我觉得不会。实际上，很多数学家都觉得“P vs NP”的重要性根本没法和黎曼猜想相提并论，因为我们预见不到它会产生任何重要的效果。&lt;/p&gt;

&lt;p&gt;很多人提到“P vs NP”总是跟你吹嘘，P 如果等于 NP，世界将有天翻地覆的变化：许许多多我们以前没法办到的事情，都将成为现实。非对称加密技术会被破解，生物化学将得到飞跃……&lt;/p&gt;

&lt;p&gt;这些人都忽略了一个重要的问题：什么是多项式时间。盲目的把“多项式”等同于“容易”和“高效”，导致了对 “P vs NP” 重要性的严重夸大。&lt;/p&gt;

&lt;p&gt;n^100 是不是多项式？是的。n^(100^100) 也是多项式。时间复杂度为 n^(100^100) 的算法，能用吗？所以即使 P=NP，你需要的计算时间仍然可以是直到宇宙毁灭。&lt;/p&gt;

&lt;p&gt;说到这里，又会有人跟我说你不懂，当 n 趋近于无穷的时候，非多项式总会在某个时候超越多项式，所以当 n “足够大”的时候，多项式时间的算法总是会更好。很可惜，“无穷”对于现实的问题是没有意义的。任何被叫做“重要”的问题，都应该在合理的时间内得到结果。&lt;/p&gt;

&lt;p&gt;我们关心的要点不应该是“足够大”，而是“具体要多大”。精确的量化，找到实际可以用的区间，这才是一个合格的科学家应该具有的思路。计算机科学里，大 O 表示法泛滥成灾，只看最高次幂，忽略系数和常数项，也是常见的误区。我也曾经沉迷于如何把 O(n^3) 的算法降低到 O(n^2.9)，现在回头才发现当年是多么的幼稚。&lt;/p&gt;

&lt;p&gt;“多项式时间”这个概念太宽泛太笼统。以如此笼统的概念为基础的理论，不可能对现实的计算问题产生意义。我们关心的不应该仅仅是“是否多项式”，而是“具体是什么样的多项式”。多项式的幂，系数，常数项，它们的不同都会产生重大的差异。&lt;/p&gt;

&lt;p&gt;这就是为什么“P vs NP”没有很大意义，因为 P 本身太笼统，其内部的差异可以是天壤之别。研究“P vs NP”就像研究“男人 vs 大猪蹄子”一样笼统而不严谨。与其试图笼统的证明 P 是否等价于 NP，还不如为具体的问题想出高效的算法。&lt;/p&gt;

&lt;h3 id=&quot;其它质疑-p-vs-np-价值的人&quot;&gt;其它质疑 P vs NP 价值的人&lt;/h3&gt;

&lt;p&gt;很多人认为我质疑 P vs NP 的价值是狂妄和信口开河，然而我并不是第一个质疑它的人。很多人对 P vs NP 都有类似的疑惑，但因为这个问题的地位如此之高，没人敢站出来。只要你开口，一群人就会居高临下指责你基础课程没学好，说你眼界太窄…… 再加上那一堆纷繁复杂基于图灵机的证明，让你有苦说不出。&lt;/p&gt;

&lt;p&gt;由于这个原因，我从来没敢公开表达我的观点，直到我发现 Doron Zeilberger 的这篇&lt;a href=&quot;http://sites.math.rutgers.edu/~zeilberg/Opinion98.html&quot;&gt;文章&lt;/a&gt;。Zeilberger 是个数学家，Rutgers 大学的数学系教授。在那之前他开了个玩笑，戏称自己证明了 P=NP，还写了篇像模像样的论文。在文章里他告诫大家：不要爱上你的模型（Don’t Fall In Love With Your Model）。他这句话说到了我心里。&lt;/p&gt;

&lt;p&gt;你还能在网络上找到其它学者对“P vs NP”的质疑，比如这篇来自于一位专业研究计算理论的学者：&lt;/p&gt;

&lt;p&gt;​    &lt;a href=&quot;https://rjlipton.wordpress.com/2009/07/03/is-pnp-an-ill-posed-problem&quot;&gt;Is P=NP an Ill Posed Problem?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我觉得他讲的也很在理。正是在这些人的鼓舞之下，我冒着砖头写出了之前对 P vs NP 的质疑。只言片语里面，融入了我多年的深入学习，研究和思考。&lt;/p&gt;

&lt;p&gt;我希望理性的计算机科学工作者能够理解我在说什么，反思一下对 P vs NP 的理解。我希望计算机专业的学生能够理解 P vs NP 理论，但不要沉迷其中。这并不是一个值得付出毕生精力去解决的问题。&lt;/p&gt;

&lt;p&gt;当然所有这些都是我个人的观点，我没有强求任何人接受它们。没人想抢走你们的玩具，但不要忘了，它只是玩具。&lt;/p&gt;

&amp;#13;
        &lt;/div&gt;
</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-07-16-pnp2</guid>
<pubDate>Tue, 16 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>学习的智慧</title>
<link>https://henix.github.io/feeds/yinwang/2019-07-12-learning-philosophy.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/07/12/learning-philosophy&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;学习的智慧&lt;/h2&gt;
            &lt;p&gt;有些人很爱学习，兢兢业业的把书一个字一个字从头看到尾，还拿笔把重点画上。好不容易学完一本书，结果完全不知道自己学到了什么。&lt;/p&gt;

&lt;p&gt;另外一些人聪明一点，他们的嘴里总是冒出一连串高深莫测的术语，滔滔不绝听得我头都冒汗。等遇到实际问题的时候，你就发现他们虽然口若悬河，做事动作快，加班加点，却总是走错方向。&lt;/p&gt;

&lt;p&gt;而垠神呢，更奇葩。跟垠神合作的人，常会发现他问一些很傻的“初学者”问题，简直让人不屑。遇到术语名词总是丈二和尚张冠李戴，好像不知道那些是什么。人们很惊奇的发现，垠神居然什么都不会！&lt;/p&gt;

&lt;p&gt;每次到了需要作出关键决策的时候，听大家正儿八经滔滔不绝之后，垠神慢条斯理不经意的抖出一句话：“那不就是 xx 吗？那样那样弄一下，不就可以了？” 你起初不信他，跟他争论，说这样不能满足我们的宏伟目标。他又轻描淡写跟你说一些，然后回头玩他的去了。因为垠神平时好像什么都不会，所以他的话被你当耳边风，你坚信自己是对的。&lt;/p&gt;

&lt;p&gt;几个月之后，经过实现 N 种方案，各种惨痛教训之后，你发现自己最后选择了垠神最初指出的方向。如果你开头就试图理解他在说什么，你可能几天就完工了。&lt;/p&gt;

&lt;p&gt;在 Indiana 的时候垠神经常享受的一件事情，就是静静看着同学们用各种术语装逼，眼睁睁看着他们误入歧途，重蹈自己几年前犯过的错误。甚至有些人弄了一两年都没发现走错了。不是垠神自私啊，而是很多人根本没有在意过他的看法。如果你如此的坚信自己是对的，垠神是懒得主动告诉你他在同一地点同一路线失败的经历的 ;)&lt;/p&gt;

&lt;h3 id=&quot;死知识活知识&quot;&gt;死知识，活知识&lt;/h3&gt;

&lt;p&gt;很多人坚信“知识就是力量”，可是他们不知道，知识和知识是不一样的。&lt;/p&gt;

&lt;p&gt;大部分人从学校，从书籍，从文献学知识，结果学到一堆“死知识”。要检验知识是不是死的，很简单。如果你遇到前所未见的问题，却不能把这些知识运用出来解决问题，那么这些知识就很可能是死的。&lt;/p&gt;

&lt;p&gt;死知识来源于其他人。追根溯源之后，你会发现这知识最初的创造者经过了成百上千的错误。这就像爱迪生发明灯泡，经过了几千次失败的实验。知识的创造者把最后的成功记录在文献里发表，然后你去读它。你以为得到了最宝贵的财富，然而最宝贵的财富却是看不见的。作者从那成百上千的失败中得到的经验教训，才是最宝贵的。而从来没有人把失败写下来发表。&lt;/p&gt;

&lt;p&gt;没有这些失败的经验，你就少了所谓“思路”，那你是不大可能从一个知识发展出新的知识的。就像你读了别人的重要 paper，你是不大可能由此发展出重大想法的。你的 paper 会比别人低一个档次，往往只能修修补补，弄出一个小点的想法。而原来的作者以及他的学生们，却可以很容易的变出新的花样，因为他们知道这些路是怎么走过来的，知道许许多多没有写下来的东西。“失败是成功之母”，在我脑子里就是这个意思。&lt;/p&gt;

&lt;p&gt;垠神从很早的时候就知道了这个道理，所以他很多时候不看书，不看 paper。或者只看个开头，知道问题是什么。他看到一个问题，喜欢自己想出解决方案。他不是每次都成功，实际上他为此经历了许许多多的失败。运气好的时候，他得到跟已有成果一样的结果。运气再好一点的时候，他得到更好的结果。但他关心的不只是成功，中间的许多失败对他也是价值重大的。&lt;/p&gt;

&lt;p&gt;然后他会去找有经验的人讨论，这些人也许很厉害，早就做过深入的研究。也许是初学者，刚刚接触到同样的问题。但很奇特的是，不管跟什么样的人交流，垠神几乎总是能得到启发。即使这个人什么都不懂，现教给他也一样。通过向不懂的人解释这个问题，他经常意外的发现问题的答案。&lt;/p&gt;

&lt;p&gt;为死知识引以为豪的人往往满口的术语，对“初级问题”不屑一顾。懂得活知识的人，却知道每一个初级甚至傻问题的价值。世界上最重大的发现，往往产生于对非常基础的问题的思考，比如“时间是什么？” 如果你觉得理所当然每个人都该知道这个问题的答案，只有白痴才会问出这种问题，那你就失去了很多产生活知识的机会。这就是为什么垠神经常问一些基础问题，因为他想知道它们背后还隐藏着什么他不知道的内涵。&lt;/p&gt;

&lt;p&gt;这就是垠神获取活知识的秘密。活知识必须靠自己创造出来，要经过许许多多的失败。如果没有经过失败，是不可能得到活知识的。&lt;/p&gt;

&lt;p&gt;由于活知识是自己创造的，其中包含的概念，垠神是不知道它们在文献中的术语的——垠神平时都懒得看文献。这就是为什么很多人跟垠神交流，发现他连基本的术语都不知道是什么。经过进一步交流，你也许会发现虽然垠神不知道一个东西的名字，他却知道这个东西是什么——以他自己的理解方式 ;)&lt;/p&gt;

&lt;h3 id=&quot;知识的来源&quot;&gt;知识的来源&lt;/h3&gt;

&lt;p&gt;所以呢，知识的来源最好是自己的头脑，但也不尽然。有些东西成本太高，比如一些医学，生物学，物理的东西，没条件做实验就没法得到，所以还是得先获取现成的死知识。&lt;/p&gt;

&lt;p&gt;有些人说到“学习”，总是喜欢认认真真上课，抄笔记，看书。有些人喜欢勾书，把书上整整齐齐画满了横杠。兢兢业业不辞辛苦，最后却发现没学会什么。&lt;/p&gt;

&lt;p&gt;为什么会这样呢？首先因为他们没有理智的选择知识的来源。他们没有意识到，对于同一个问题有很多不同的书，不同的作者对于问题的见解深度是不一样的。如果你拿着一本书从头看到尾，而不参考其他人的，往往会误入歧途。你手上的书的作者，也许自己没看很透这个问题，只是他发表的早，占了先机，所以这书成了学校指定的，大家推崇的“经典教材”。&lt;/p&gt;

&lt;p&gt;在学校的时候，我不止一次的发现经典教材很难懂。经过不懈的努力，让自己的思维爬到一定高度之后我才发现，原来这经典教材作者很多地方没有看透彻。写书的时候他也把一些可有可无的内容写进去，引经据典的罗列出各种 paper，却忽视了最重要的思想和直觉。看这种书，你当然头痛了。&lt;/p&gt;

&lt;p&gt;我为什么能突破这道壁垒呢？第一是因为我自己动手创造了知识，第二是因为我从其他人那里学到了东西。我喜欢在网上搜索对应一个主题的内容，往往能发现一些名不见经传的人的作品，反而比著名的大牛来的深刻。当然网上内容鱼龙混杂，你也不要死钻进去出不来了。&lt;/p&gt;

&lt;p&gt;看书的时候不要老想从头看到尾。如果一个主题你看得头大，最好的办法是放下这书，去寻找对同一主题的更简单的解释。这些东西可以来源于网络，也可以来自其它书籍，也可以来自身边的人。同时保留多个这样的资源，你就可以对任何主题采用同样的“广度优先”搜索，获得深入理解的机会就会增加。&lt;/p&gt;

&lt;p&gt;都说书籍是人类的朋友，我却发现看书是很闷的事情，我很不喜欢看技术方面的书。我最喜欢的是直接跟人学东西。找到懂一点的人，跟他聊。别管他懂多少，懂多深，我发现真人几乎总是比书好。至少，你聊天的时候不会打瞌睡 ;) 而且很多时候他没告诉你答案，但通过聊天，你自己把它给想出来了。&lt;/p&gt;

&lt;p&gt;参加学术会议的时候，我会事先把会议的 paper 浏览一下，然后发现根本看不进去。带着好奇心来到会议，听了演讲还是不懂。接下来我使出绝招…… 等演讲者下台之后的休息时间，我会走到他面前说：“你好，我比较笨看不懂你的 paper。请问你能在三句话之内把里面的要点概括一下吗？” 接下来奇迹发生了，作者说出了他从未发表的直觉，仔仔细细教会了我，甚至跟我成了朋友。当然对于这样的人，我也会告诉他一些我知道的东西作为回报。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-07-12-learning-philosophy</guid>
<pubDate>Fri, 12 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>机器学习与逻辑编程</title>
<link>https://henix.github.io/feeds/yinwang/2019-01-30-machine-learning.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/01/30/machine-learning&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;机器学习与逻辑编程&lt;/h2&gt;
            &lt;p&gt;（声明：本文内容纯属个人的技术兴趣，与本人在职公司的立场无关）&lt;/p&gt;

&lt;p&gt;你可能没有想到，机器学习（machine learning）和逻辑编程（logic programming）有着一种美妙的关系，在我眼里她们就像一对亲姐妹。&lt;/p&gt;

&lt;p&gt;很多人都了解机器学习，可是很少有人理解逻辑编程。在这篇短文里，我试图告诉你逻辑编程是什么，以及它与机器学习的相似之处。&lt;/p&gt;

&lt;h3 id=&quot;逻辑编程是什么&quot;&gt;逻辑编程是什么&lt;/h3&gt;

&lt;p&gt;说到逻辑编程（logic programming），人们不禁想到 Prolog 之类晦涩的逻辑式编程语言。很多人上本科的时候被迫学过 Prolog，但从来不知道它有何意义。毕业之后再听到 logic programming 这个词，就只剩下敬畏和茫然，或者觉得是没用的老古董。&lt;/p&gt;

&lt;p&gt;其实逻辑编程是很美的东西，并不过时。它的有些思想已经悄悄被应用到了最先进的编程语言之中。逻辑编程的原理可以被很轻松的解释清楚，而不需要理解 Prolog。&lt;/p&gt;

&lt;p&gt;最近研究机器学习，我发现逻辑编程与机器学习之间有着有趣而隐秘的关系。我希望这可以调动起你的胃口来。&lt;/p&gt;

&lt;p&gt;要理解逻辑编程是什么，你只需要看一个很简单的例子：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有一个未知数 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;，我们不知道它是多少，但我们知道：&lt;/p&gt;

  &lt;p&gt;​     X + 2 = 5&lt;/p&gt;

  &lt;p&gt;请问 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 是几？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上求解 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 的问题就是一个逻辑程序。像 Prolog 这样的逻辑语言系统，会给你结果：&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 等于 3。可是这个问题却不能用其它几乎所有编程语言来表达（C, C++, Python, Java, Go, Scala, Haskell, Rust, Swift…）。原因在于，使用普通的编程语言，你不能把“未知数”当成一个值来进行演算。&lt;/p&gt;

&lt;p&gt;在我们的例子里面，&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 的值是未知数，所以当普通语言看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;X + 2&lt;/code&gt; 这样的表达式，它就无法运行。它会报错：使用未初始化的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;。也就是说，你必须先知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 的值，你才能说 &lt;code class=&quot;highlighter-rouge&quot;&gt;X + 2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但在像 Prolog 这样的逻辑式语言里面，“未知数”是可以被作为一个正常的值来进行计算的。它们可以被传递到其它函数里，可以被放进数据结构，可以进行复杂的逻辑组合操作，就像你在操作一个普通的数字或者字符串一样。&lt;/p&gt;

&lt;p&gt;逻辑式程序中一般会有一个（或者多个）“目标”（goal）。目标一般是一个判断表达式，也就是说它的值是布尔类型（boolean）。这里我们的例子里只有一个目标，就是“X + 2 = 5”。也就是说，我们想要 X 加上 2 等于 5。&lt;/p&gt;

&lt;p&gt;当逻辑式语言看到了目标，就把目标记下来。最后程序员开始提问：&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 是几？这时候，逻辑语言的运行系统开始进行“反向计算”，找到未知数的值，使得目标的值为“真”（true）。在我们的例子里，系统会告诉你：&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 等于 3。&lt;/p&gt;

&lt;p&gt;为什么叫做“反向计算”呢？因为&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我们先声明了未知变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;，&lt;/li&gt;
  &lt;li&gt;然后我们提出目标 &lt;code class=&quot;highlighter-rouge&quot;&gt;X + 2 = 5&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于复杂一点的程序，1 和 2 之间可能还有其它的代码。我们最后的问题，却是问最开头声明的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 等于几，所以系统从最后面的目标 &lt;code class=&quot;highlighter-rouge&quot;&gt;X + 2 = 5&lt;/code&gt; 出发，“反向”推导出 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 的值。&lt;/p&gt;

&lt;p&gt;这就是为什么研究逻辑式编程的人把这种操作叫做“反向计算”。你可能注意到了，我们的代码里面只写了加法（&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;）操作，而系统实质上为我们做了减法：5 - 2 得到  3。&lt;/p&gt;

&lt;p&gt;如果你想深入理解逻辑式编程，我建议你看看 Dan Friedman 的书『&lt;a href=&quot;https://mitpress.mit.edu/books/reasoned-schemer&quot;&gt;The Reasoned Schemer&lt;/a&gt;』。但目前你了解到的这些，应该足以读完这篇文章。&lt;/p&gt;

&lt;h3 id=&quot;机器学习与逻辑编程的相似点&quot;&gt;机器学习与逻辑编程的相似点&lt;/h3&gt;

&lt;p&gt;你可能已经明白了逻辑编程是什么。下面我们来看看它跟机器学习有什么关系。&lt;/p&gt;

&lt;p&gt;首先我们看到逻辑编程有“目标”（goal），比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;X + 2 = 5&lt;/code&gt;。在机器学习中有一个对应的东西，那就是误差函数（loss function）。只不过逻辑编程的 goal 是个等式，而机器学习的 loss function 是个函数。&lt;/p&gt;

&lt;p&gt;逻辑编程系统会为你选择未知数的值，从而精确地“满足”这个 goal。而机器学习的目标呢，是要为你选择未知数的值，最小化这个 loss function，使得误差最小。看到相似之处了吗？所以，机器学习可以被看成是“在连续空间中的近似的逻辑编程”，而逻辑编程可以被看成是“在离散空间中的精确的机器学习”。&lt;/p&gt;

&lt;p&gt;逻辑编程有“反向计算”，机器学习有“反向传递”(back propagation)，而它们的工作方式，有着惊人的相似之处。只不过机器学习因为是连续空间的，所以需要使用微积分的原理，而不只是简单的逻辑组合。&lt;/p&gt;

&lt;p&gt;实际上逻辑编程必须先进行正向计算，构造出含有未知数的结构，然后进行所谓“resolution“，求出未知数的值。而机器学习也类似，你必须进行一遍正向计算（forward pass），然后才能进行 back propagation，求出导数，并且更新“weight”的值。&lt;/p&gt;

&lt;p&gt;逻辑编程的“未知数”（比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;），对应了机器学习的 weight。实际上，机器学习的 weight 本质就是“未知数”。你需要得到它们的值，使得 loss function 最小，但一开头你不知道它们是什么，所以你给它们一些随机的初始值，让系统开始正向计算。机器学习的 weight 和逻辑编程的未知数如此的相似，它们可以被作为普通的值，与输入进行计算操作（Conv 等操作），直至你遇到 goal 或者 loss function，然后你掉头回去调整未知数的值……&lt;/p&gt;

&lt;h3 id=&quot;机器学习框架是程序语言&quot;&gt;机器学习框架是程序语言&lt;/h3&gt;

&lt;p&gt;所以呢，你现在明白了我为什么对机器学习感兴趣了吧。我看到了它与编程语言的优雅知识之间的联系，看到了它是对于“计算”概念的一种扩展。机器学习把“计算”和“微积分”有趣地融合在了一起。&lt;/p&gt;

&lt;p&gt;实际上，你可以把机器学习的各种框架（framework）看成是新的编程语言，它们的工作原理类似于 Prolog 语言的运行时系统。如果要起一个名字，你也许可以把它们叫做“可求导编程语言”（differentiable programming language）。&lt;/p&gt;

&lt;p&gt;写 framework 的工作，实质上是设计编程语言或者解释器，编译器。而有些 framework 所谓的“计算图”，实质就是编译器中的 data-flow graph 或者 control-flow graph 一类的东西。&lt;/p&gt;

&lt;p&gt;目前这些语言还处于初级阶段，表达力比较弱，有各种不完善的地方。由于机器学习解决的是连续的数值问题，机器学习的“模型”一般要很简单才行，否则很可能出现学习不收敛的情况。所以我还不知道编程语言的很多概念能否顺利的迁移到机器学习上面。&lt;/p&gt;

&lt;p&gt;但目前看来有一些很明显的对应关系和发展趋势：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Feed-forward 网络，比如 CNN 一类的，对应了编程语言中最简单的表达式，或者叫“纯函数”。其中没有递归，也没有副作用。它只能处理图像一类具有固定长度的数据。&lt;/li&gt;
  &lt;li&gt;RNN 对应的是程序语言里含有递归（循环）的函数。由于递归函数对应的是“递归数据结构”，这就是为什么 RNN 可以处理文本一类没有固定长度的“链表”数据。&lt;/li&gt;
  &lt;li&gt;Neural Turing Machine 及其后续的研究 &lt;a href=&quot;https://deepmind.com/blog/differentiable-neural-computers/&quot;&gt;Differentiable Neural Computer&lt;/a&gt;，试图把更广阔的编程概念引入到机器学习里面，实现任意复杂的数据结构和计算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于数值计算特有的误差问题和机器学习带来的巨大计算量，我不知道这个趋势最终可以发展到什么地步。但编程语言和机器学习的这个联系，是优雅而让人回味的。&lt;/p&gt;

&lt;p&gt;（如果你觉得这篇文章有启发，可以点击这里&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付费&lt;/a&gt;）&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-01-30-machine-learning</guid>
<pubDate>Wed, 30 Jan 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>解谜英语语法（1）</title>
<link>https://henix.github.io/feeds/yinwang/2018-11-24-grammar-chapter1.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/11/24/grammar-chapter1&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;解谜英语语法（1）&lt;/h2&gt;
            &lt;h3 id=&quot;第一章初识句子&quot;&gt;第一章：初识句子&lt;/h3&gt;

&lt;p&gt;直到几百年前，各个不同大陆上的人还从来没见过面，可是他们的语言里却不约而同出现了同样的结构：句子。这难道不是很奇妙的事情吗？这说明句子的出现似乎是一种自然规律。&lt;/p&gt;

&lt;h3 id=&quot;句子的核心地位&quot;&gt;句子的核心地位&lt;/h3&gt;

&lt;p&gt;句子是人类语言最核心的构造。为什么呢？因为人和人说话终究是为了一个目的：描述一件事。&lt;/p&gt;

&lt;p&gt;这件事也许只有一个字：吃！&lt;/p&gt;

&lt;p&gt;也许可以很长：昨天晚上在上海某路边餐厅吃的&lt;strong&gt;鹅肝&lt;/strong&gt;，&lt;strong&gt;是&lt;/strong&gt;我吃遍全世界&lt;strong&gt;最好的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一个句子表达的就是一件事，或者叫做一个“事件”。人与人交流，无非就是讲述一个个的事件。&lt;/p&gt;

&lt;h3 id=&quot;你需要的能力&quot;&gt;你需要的能力&lt;/h3&gt;

&lt;p&gt;所以要掌握一种语言，你只要掌握句子就行了。有了句子就有了一切。&lt;/p&gt;

&lt;p&gt;掌握句子包括两件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;能够迅速地造出正确的句子，准确地表达自己的意思。&lt;/li&gt;
  &lt;li&gt;能够迅速地理解别人的句子，准确地接收别人的意思。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两件事，一个是“发送”，一个是“接收”。因为语言是沟通（或者叫“通讯”）的工具，所以它就只包含这两件事。&lt;/p&gt;

&lt;h3 id=&quot;句子的本质&quot;&gt;句子的本质&lt;/h3&gt;

&lt;p&gt;假设我们是原始人，还没有语言。我想告诉同伴“我吃苹果”这件事，该怎么表达呢？没有语言，那我可以先画个图嘛：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/i-eat-apple.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;到后来，部落里的人聪明了一点，发明了“符号”这种东西。他们给事物起了简单的符号名字，不再需要画图了，所以我们有了 I, apple 这样的词用来指代事物。有了 eat 这样的词，用来代表动作。所以画面变成这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/i-eat-apple-symbol.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;后来干脆连框也不画了。直接写出这些符号来：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I eat apples.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么，你觉得“我吃苹果”这个事，里面最关键的部分是什么呢？是“我”，“苹果”，还是“吃”呢？&lt;/p&gt;

&lt;p&gt;稍微想一下，你也许会发现，关键在于“吃”这个动作。因为那是我和苹果之间发生的&lt;strong&gt;事件&lt;/strong&gt;。这句话是说“吃”这件事，而“我”或者“苹果”，只是“吃”的一部分。&lt;/p&gt;

&lt;p&gt;用 eat 这个词，你不但可以表达“我吃苹果”，还可以表达“他吃面条”，“猫吃老鼠”之类的很多事情。于是，聪明一点的人就把 eat 这个词提取出来，做成一个“模板”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/eat-verb.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个模板就是所谓“动词”。eat 这个动词给你留下两个空，填进去之后，左边的东西吃右边的。&lt;/p&gt;

&lt;h3 id=&quot;动词是句子的核心&quot;&gt;动词是句子的核心&lt;/h3&gt;

&lt;p&gt;就像我说的，句子是语言的核心，而动词就是句子的核心。动词是事件的关键，比如 eat。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A eat B.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以选择空格里的 A 或者 B 是什么。但不管怎么换，事情仍然是“吃”。为了描述方便，我们把 A 和 B 这两个空格叫做&lt;strong&gt;参数&lt;/strong&gt;（parameter）。&lt;/p&gt;

&lt;p&gt;这跟数学函数的参数（f(x) 里面那个 x）类似，也跟程序函数的参数类似。用数学或者程序的方式来表示这个句子，就是这样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;eat(A, B)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中 A 和 B，是动作 eat 的参数。我只是打个比方帮助你理解，当然我们不会这样写英语。如果你完全不懂数学或者编程，可以忽略这个比方。&lt;/p&gt;

&lt;p&gt;动词决定了它的参数在什么位置，它们可以是什么种类的成分。比如 eat，它的两个参数只能是某种“物”。你不能放另一个动词（比如 walk）进去，也不能放 red 这样的形容词进去。这种动词对参数的约束，我们把它叫做“参数类型”。&lt;/p&gt;

&lt;p&gt;你可能发现了，一个句子除了动词，就只剩下动词的参数了。动词对它的参数具有决定性的作用，动词就是句子的核心。准确理解一个动词“想要什么参数”，什么样的构造可以出现在那个参数位置，就是造出正确句子的关键。&lt;/p&gt;

&lt;p&gt;使用不同的动词可以造出不同的句子。所以要理解语法，你在初期应该把大部分精力放在各种各样的动词身上，而不是花几个月时间去背名词和形容词。我并不是说名词和形容词不重要，只是它们并不是核心或者骨架。&lt;/p&gt;

&lt;p&gt;没有人会怪你不认识某种恐龙的名字，但如果你不能理解“I am not used to eating garbage food.” 是什么意思，那你可能就有麻烦了。&lt;/p&gt;

&lt;h3 id=&quot;如何造出正确的句子&quot;&gt;如何造出正确的句子&lt;/h3&gt;

&lt;p&gt;我已经提到，对于人的语言能力，“造句”能力占了一半。很多人不知道复杂的长句是怎么造出来的，所以他们也很难看懂别人写的长句。&lt;/p&gt;

&lt;p&gt;我并不是说一味追求长句是好事，正好相反。如果你能用短句表达出你的意思，就最好不要用长句。虽说如此，拥有造长句的“能力”是很重要的。这就像拥有制造核武器的能力是重要的，虽然我们可能永远不会用到核武器。&lt;/p&gt;

&lt;p&gt;当然，制造长句不可能有核武器那种难度。造长句其实挺容易。你只需要先造出一个正确的短句，然后按照规则，一步步往上面添加成分，或者把其中某一部分“扩大”，就可以逐渐“生成”一个长句。&lt;/p&gt;

&lt;p&gt;这就像造一个房子，你首先打稳地基，用钢板造一个架子，然后往上面添砖加瓦。你可以自由地选择你想要的窗户的样式，瓦片的颜色，墙壁的材质，浴缸的形状…… 好像有点抽象了，我举个例子吧。&lt;/p&gt;

&lt;p&gt;首先，我造一个最简单的句子。最简单的句子是什么呢？我们已经知道动词是句子的核心，有些动词自己就可以是一个句子。所以我们的第一个句子就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;eat.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它适用于这样的场景：你在碗里放上狗粮，然后对狗儿说：“吃。” 当然，你体会到了，这句话缺乏一些爱意，或者你只是早上起来还比较迷糊，不想多说一个字，但它至少是一个正确的句子。&lt;/p&gt;

&lt;p&gt;接下来，我们知道 eat 可以加上两个参数，所以我就给它两个参数：I, apples。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;I&lt;/strong&gt; eat &lt;strong&gt;apples&lt;/strong&gt;. （我吃苹果）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个句子适用于这样的场景：别人问我：“你一般吃什么水果呢？” 我说：“我吃苹果。”&lt;/p&gt;

&lt;p&gt;有点单调，所以我再加点东西上去。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I eat &lt;strong&gt;Fuji apples&lt;/strong&gt;. （我吃富士苹果）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Fuji 被我加在了 apples 前面，它给 apples 增加了一个“修饰”或者“限定”。它只能是富士苹果，而不是其它种类的苹果。&lt;/p&gt;

&lt;p&gt;但我并不总是吃富士苹果，我有时不吃苹果。我想表达我只是“有时”吃富士苹果，所以句子又被我扩充了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Sometimes&lt;/strong&gt; I eat Fuji apples. （我有时吃富士苹果）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你觉得这个 sometimes 是在修饰（限制）句子的哪个部分呢？它在修饰“我”，“苹果”，还是“吃”？实际上，它是在限制“吃”这个动作发生的频率，所以它跟 eat 的关系紧密一些，也就是说它是在修饰 eat，而不是 I 或者 apples。&lt;/p&gt;

&lt;p&gt;以此类推，我们可以把它发展得很长：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sometimes &lt;strong&gt;I&lt;/strong&gt; &lt;strong&gt;eat&lt;/strong&gt; fresh Fuji &lt;strong&gt;apples&lt;/strong&gt; bought from a local grocery store.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我有时候吃从一个本地杂货店买来的新鲜富士苹果。注意，虽然这句子挺长，但它的“骨架”仍然是 I eat apples.&lt;/p&gt;

&lt;p&gt;我已经演示了，一个长句是怎么“生成”的。先造一个短句，然后往上面添砖加瓦，是写出长句的关键。正确的短句，按照规则加上一些成分，就成为正确的长句。这样你的语法就会一直是正确的。&lt;/p&gt;

&lt;p&gt;当然，扩展句子的时候，你不能随意往上加东西，它们必须满足一定的规则才能正确的衔接。比如，你只能把 Fuji 放在 apple 前面，而不是后面。这就像造房子的时候，你不能在该放窗户的地方放一道门，你不能用错配件和胶水。所谓语法，很多时候就是在告诉你这些部件要怎么样才能接的上。&lt;/p&gt;

&lt;p&gt;在后面的章节，我们会逐渐接触到这些细节的规则。&lt;/p&gt;

&lt;h3 id=&quot;如何理解长句&quot;&gt;如何理解长句&lt;/h3&gt;

&lt;p&gt;人与人交流的另一个部分就是“接收”。如果书上有很长一句话，你要怎么才能理解它呢？许多人看到长句就头痛，不知道该怎么办。这是因为他们不明白长句都是从短句扩展出来的，所以产生了恐惧感。&lt;/p&gt;

&lt;p&gt;其实理解长句的方法，都隐含在了上一节介绍的造出长句的方法里面。造句的时候我们先勾画出一个框架，然后往里面填修饰的东西。理解的时候如果有困难，我们可以用类似的办法。我们首先分析出句子的主干，把它理解了，然后再往上面添加其它的成分，逐步理解到整个句子的含义。&lt;/p&gt;

&lt;p&gt;比如之前的那个例子：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sometimes &lt;strong&gt;I eat&lt;/strong&gt; fresh Fuji &lt;strong&gt;apples&lt;/strong&gt; bought from a local grocery store.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你需要“反向思考”，分析出句子的主干是短句“I eat apples”。如果你觉得一下子找不到主干，那么你可以试试挨个的找到“修饰成分”，把它们逐个删掉，最后留下来的就是主干了。&lt;/p&gt;

&lt;p&gt;注意，主干“I eat apples” 本身就是一个语法正确的句子，它满足所有的语法规则。于是你理解了它在说“我吃苹果”。然后你逐渐加上细节，知道是什么样的苹果，从哪里买来的，什么时候吃。&lt;/p&gt;

&lt;p&gt;漏掉或者误解了细节，你可能会误解一部分意思，但抓住了主干，你就不会完全不理解这个句子在说什么。&lt;/p&gt;

&lt;p&gt;再次强调，每一个复杂的长句，里面都藏着一个非常短的，语法正确的短句。理解长句的关键，就在于找到这个短句。&lt;/p&gt;

&lt;p&gt;如何获得识别修饰成分，找到主干短句的能力，也在于你对具体的语法规则的理解。这些我们在稍后的章节介绍。&lt;/p&gt;

&lt;h3 id=&quot;如何培养真正的能力&quot;&gt;如何培养真正的能力&lt;/h3&gt;

&lt;p&gt;这一章我只是介绍了你需要的两种能力，可是如何培养这两种能力呢？其实它们两者是相辅相成的。造句的能力可以帮助你理解别人的句子，而阅读别人的句子，分析其结构，可以帮助你获得造出类似句子的能力。&lt;/p&gt;

&lt;p&gt;所以我给你开的处方是这样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;练习造句。每学一个动词，要用它造出多个句子来。这样你就获得对它的灵活运用的能力。&lt;/li&gt;
  &lt;li&gt;分析句子。看到一个复杂的句子，觉得理解有难度，你就把它抄下来。按照我介绍的“造句方法”，把它分解成主干和修饰成分。不久，你就会发现你的理解能力和造句能力都提高了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要注意的是，分析句子的时候，没有必要去纠结一个成分“叫什么”，对应什么术语。比如它是表语还是宾语，还是宾补…… 这没有意义。&lt;/p&gt;

&lt;p&gt;你可以理解任何英语句子，你可以成为很好的记者或者作家，却仍然不知道什么叫做“宾补”。你只需要造句的能力和理解句子的能力，而你不需要术语就能做到这两点。&lt;/p&gt;

&lt;p&gt;最后可能有人问，你这是提高实际的英语能力，可是我需要应付的是标准化的考试。这样做能行吗？当然行，而且你做语法题的速度会非常快。没有考试题目会要求你“找出句子里的宾补成分来”。实际上，题目里不可能出现“宾补”这个词。他们只会在那个成分的位置留一个空，让你选择合适的内容填进去。也就是说，你不需要知道那个位置叫“宾补”，就能做对题。&lt;/p&gt;

&lt;p&gt;实际上，做题的时候，你的头脑里根本不应该出现“宾补”这样的术语。具有了真正的英语能力，做语法选择题的时候，你会一眼就选对正确的答案，却说不出这道题在考你哪方面的能力。是时态呢，还是某种句子成分？我不知道，因为那毫无意义，关键是我做对了题目！我就是感觉其它答案都不“顺口”，我根本不会写那样的句子，而正确的选项一眼看起来就是“通的”。&lt;/p&gt;

&lt;p&gt;所以不管是实际的交流还是做题，死抠语法术语都没有什么意义。你去问问每一个英国人，美国人，他们是怎么做对语法题的，你会得到同样的答案。这本书就是要帮助你得到这种母语级别的能力，而不是一些纸上谈兵的术语。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-11-24-grammar-chapter1</guid>
<pubDate>Sat, 24 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>解谜英语语法</title>
<link>https://henix.github.io/feeds/yinwang/2018-11-23-grammar.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/11/23/grammar&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;王垠英语语法（前言）&lt;/h2&gt;
            &lt;h3 id=&quot;封二&quot;&gt;封二&lt;/h3&gt;

&lt;div style=&quot;text-align: right&quot;&gt;—献给 Daisy&lt;/div&gt;

&lt;h3 id=&quot;起因&quot;&gt;起因&lt;/h3&gt;

&lt;p&gt;这是一本独特的语法书。它的作者既不是专业英语教师，也不是语言学家，而是一个程序语言研究者。&lt;/p&gt;

&lt;p&gt;师从世界顶尖的程序语言专家，他钻研过世界上最美最强大的程序语言，他洞察过艰深古怪的逻辑学。现在，他认为程序语言和逻辑是已攻克的目标，山下的风景。&lt;/p&gt;

&lt;p&gt;对程序语言和逻辑的深刻理解，不但让他成为了更好的程序员，而且加深了他对自然语言（特别是英语）的理解。许多年来，他一直利用自己独到的方式来理解和使用英语。英语在他的头脑里有着跟常人很不一样的画面。对他而言，英语语法是如此的简单，琢磨起来趣味盎然。&lt;/p&gt;

&lt;p&gt;可是回国之后，他发现身边的朋友仍然在为语法的枯燥繁复而头痛，所以他萌生了写这样一本书的念头。他想把自己的英语如此流畅的秘密告诉世人，帮助那些正在为学习语法而痛苦挣扎的人们。&lt;/p&gt;

&lt;h3 id=&quot;语法书为什么枯燥难懂&quot;&gt;语法书为什么枯燥难懂&lt;/h3&gt;

&lt;p&gt;在我看来，普通语法书难懂的原因很简单：世代相传的照本宣科。语法书往往是包罗万象，“系统”地列出各种概念：名词，代词，动词，形容词，副词，句子成分，各种从句…… 洋洋洒洒上千页纸。不仅中国人写的语法书是这样，外国人写的语法书也这样。&lt;/p&gt;

&lt;p&gt;只见树木不见森林。这样的书缺乏“活知识”，到用的时候就想不起来，只能作为字典，需要的时候来查。所以很多人学了这些大部头语法书，照样写不出像样的句子来。时间充裕的写作都没法写好，面对外国人的时候进行快速的对话，就更加困难。&lt;/p&gt;

&lt;p&gt;看普通的语法书，学生被各种术语淹没：及物动词，不及物动词，表语，宾语补足语…… 想学会这些术语，却发现头脑在不断地碰壁。&lt;/p&gt;

&lt;p&gt;这就好像几百年前，人们认为地是一个平面，而天是一个穹顶，于是他们无法解释自己观察到的很多现象。过了好久才有人意识到问题的根源：地球是圆的。&lt;/p&gt;

&lt;p&gt;从现代程序语言理论的角度看来，英语语法里的很多术语和概念，其实是子虚乌有的，或者非常不准确的，就像当年的“地平说”一样。这些概念来源于早期语言学家对于人类语言能力的不成熟理解。可惜，很多古老的概念被英语老师们一代传一代，成为了必修的教条。&lt;/p&gt;

&lt;p&gt;这些术语都是祖辈传下来的东西，普通英语老师也不知道它们是怎么产生的。如果离开了这些术语，他们就不知道如何讲述语法，于是只好照原样传下去。所以他们也就没办法接触到本质，不可能把事情变得简单。&lt;/p&gt;

&lt;p&gt;科学的发展史告诉我们，正确的理论往往是最简单的，有毛病的理论才会复杂不堪。从程序语言和逻辑学的观点看来，传统语言学留下的这些概念，很多都是有问题的。这就是为什么学语法那么复杂，那么头痛，那么枯燥。&lt;/p&gt;

&lt;h3 id=&quot;本书的方法&quot;&gt;本书的方法&lt;/h3&gt;

&lt;p&gt;跟几乎所有的语法书不同，这本书不只是传授给你现成的知识，它引导你从人本源的交流需求出发，从无到有把语法“重新发明”出来。如果只是把知识传授给你，你就成为知识的奴隶。但如果你自己发明了知识，你就成为了知识的主宰。所以“重新发明”会贯穿这本书的主线。&lt;/p&gt;

&lt;p&gt;要想重新发明语法，我们当然不能继续沿用现有的语法术语，否则我们就只有步前人的后尘。但如果碰巧遇到可以借用的，真正有用的术语，我们还是继续使用它们。&lt;/p&gt;

&lt;p&gt;因为这个原因，请不要对本书的“术语准确性”吹毛求疵。因为就像物理学家费曼的父亲告诉他的，最重要的不是一个东西“叫什么”，而是它“是什么”。&lt;/p&gt;

&lt;p&gt;这本书就是要告诉你语法是什么。你会成为语法的主人。&lt;/p&gt;

&lt;p&gt;另外，因为这本书不会试图做一本包罗万象的字典，所以你不能指望在里面找到所有你需要的内容。这本书会包含“精华”和“通用”的思想，还有一些常见的例子，但某些具体的情况，比如某个特定动词的用法，你可能还需要看看字典。&lt;/p&gt;

&lt;p&gt;本书的作用是，它让你翻开字典就能找到你需要的东西，并且理解如何使用它。一般的语法书自己就是字典，可惜很少有人能够理解和运用。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-11-23-grammar</guid>
<pubDate>Fri, 23 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>更新一下</title>
<link>https://henix.github.io/feeds/yinwang/2018-10-14-update.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/10/14/update&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;更新一下&lt;/h2&gt;
            &lt;p&gt;我好像正好半年没有写东西了。哦不，我其实写了一些。仔细看我的书的人可能发现，那第一章其实悄悄更新了很多次。但我意识到了问题，我似乎没有动力完成这本书。嗯，我似乎是一个以半途而废著称的人。我从来不觉得必须从头到尾做完什么，除非我一直认为那是正确的方向。&lt;/p&gt;

&lt;p&gt;首先的问题是，写作这本书起初并没有良好的动机。我的意思是，当初想写这本书是出于对现状的“不满”，或者说是：恨。相对于爱，恨不是一个好的动机。&lt;/p&gt;

&lt;p&gt;我的老师 Dan Friedman 写了那么多本“小人书”，每一本都精辟而深刻，专注于一个他当时热爱的主题：函数式编程，逻辑式编程，自动定理证明……&lt;/p&gt;

&lt;p&gt;跟他相比，我自愧不如，因为我的动机不是出于爱。心中的恨，让我很像 Anakin Skywalker。不管恨是如何产生的，如果任其发展，它将把我变成 Darth Vader。我不想成为 Darth Vader。&lt;/p&gt;

&lt;p&gt;动机错了，也就导致了写作这本书的各种困难：设定的目标太高太远，太过注重“精华”，太早的解释过于深刻的原理，语言也啰嗦不流畅，充满了带刺或者负面的字眼…… 我开始担心看了我的书的人会变成什么样子。&lt;/p&gt;

&lt;p&gt;我意识到理解一件事和教会别人这件事，是完全不同的难度。如果我不理解人的心理，我就不会成为一个好的老师。如果我的心灵不够清澈，我就写不出纯美的作品。&lt;/p&gt;

&lt;p&gt;更要命的是，我的生活里有各种似乎更加有趣而有益的事情。所以每次想要写书，马上就会有有趣的事情来打断我……&lt;/p&gt;

&lt;p&gt;因此，写书这个事就被我一拖再拖。我想先研究一下人的心理，我想成为更好的人。只有当我成为一个很好的人，看我的书的人才会成为更好的人。&lt;/p&gt;

&lt;p&gt;但我还不够好。&lt;/p&gt;

&lt;p&gt;*  *  *&lt;/p&gt;

&lt;p&gt;过去的几年我都太关心“教”别人什么东西，以老师自居。可是我最近发现，我最爱的事情其实是从别人那里“学”东西。我喜欢跟人聊天讨论，大大的多过自己看书。经常能体会到“听君一席话，胜读十年书”的道理。&lt;/p&gt;

&lt;p&gt;总之，这半年我就是在学各种新东西。从专家那里学，也从很普通的人那里学。从小说里，电影里，音乐里学。学技术，也学人文。学习和领悟让我快乐。比起把自己封闭在自己的领域和圈子里，写一本旨在“改变现状”的书，学习让我更加快乐。我有了新的朋友和同事，我这才感觉我不再是孤军奋战，感觉新的生活开始了。&lt;/p&gt;

&lt;p&gt;如果只是想教会别人东西，我仍然是原来的我。而从别人那里学东西，我就成为“升级版”的我。学习让我有了朋友，朋友让我心里充满了爱，只有爱才是我前进的动力。&lt;/p&gt;

&lt;p&gt;*  *  *&lt;/p&gt;

&lt;p&gt;过去的王垠，心中充满了批判，然而世界上有远比批判有效而有益的事情。批判难以达到改进世界的效果，我的价值不可能通过批判而得到实现，而且它会让我失去潜在的朋友。价值的实现只能通过把我的技能，通过友好而快乐的途径作用到现实世界，让世界变得更好。不好的方面应该被忘记，而不是花大力气去批判它们。&lt;/p&gt;

&lt;p&gt;过去的王垠，以“天才”自居，天天谈论技术，各种评判；而现在的王垠，更加重视友谊和人性，比较少评判事物。比起冰冷的技术，真心的朋友更加能让我快乐。我希望有更多的朋友，更少的敌人。&lt;/p&gt;

&lt;p&gt;有个朋友引用一句林徽因的诗来赞美我：“你是爱，是暖，是希望，你是人间的四月天。” 目前感觉言过其实，不过我会努力达到这个境界，嗯。&lt;/p&gt;

&lt;p&gt;除了技术，世界上还有那么多有趣而重要的东西：艺术，文学，音乐，美食…… 它们也越来越多的走进我的生活，让我成为一个更加丰富的人。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/les-miserables.jpg&quot; width=&quot;600&quot;&gt;&lt;/p&gt;

&lt;p&gt;我要感谢我的朋友们。真的朋友就像一面镜子，从你们我认识到了自己的问题，拓展了自己的视野。我会不断改进自己。&lt;/p&gt;

&lt;p&gt;我不想再做一个不接地气的神，我的心里对自己的能力没有 pride。我不再是“垠神”，也不要叫我“大神”了。与其让人们崇拜我，畏惧我，恭维我，我更愿意让他们发自内心地喜欢我。我欢迎各种形式的互相学习和交流合作。&lt;/p&gt;

&lt;p&gt;虽然不再继续写那本书，我肯定会写技术方面的博文，而且更新会比书频繁很多。写书让我犯困，几个月写不出来一章，还不如写点短的文章分享一下。所以不用为书遗憾，因为专注于一个主题的短文是更加有效而有价值的东西。&lt;/p&gt;

&lt;p&gt;上海是一个神奇的城市。这里有很多我喜欢的故事，是一个人杰地灵的地方。自从民国年代，许许多多的传奇故事发生在上海。我希望我在上海也有美好的故事。&lt;/p&gt;

&lt;p&gt;最后再次感谢大家的支持。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-10-14-update</guid>
<pubDate>Sun, 14 Oct 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
