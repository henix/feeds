<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Milo的编程</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sat, 16 Feb 2019 08:40:24 +0800</lastBuildDate>
<item>
<title>常在我心</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2019-02-13-56640030.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56640030&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b845dab3b9ef95ab4a4ffe5a4750e96f_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1079126838621544448&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;常在我心&quot; data-poster=&quot;https://pic2.zhimg.com/v2-b7e6879086e9544c5ef5d32f077ec05a.jpg&quot; data-lens-id=&quot;1079126838621544448&quot;&gt;              &lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-b7e6879086e9544c5ef5d32f077ec05a.jpg&quot;&gt;              &lt;span class=&quot;content&quot;&gt;                &lt;span class=&quot;title&quot;&gt;常在我心&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;                &lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1079126838621544448&lt;/span&gt;              &lt;/span&gt;            &lt;/a&gt;            &lt;p&gt;这是一个用 HTML/JS 实现的光滑粒子流体动力学（smoothed particle hydrodynamics, SPH） [1][2][3] 实时 Demo，它使用 HTML5 Canvas 渲染。&lt;/p&gt;&lt;p&gt;改变文字的方法是，打开 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//miloyip.com/misc/sv2019.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;miloyip.com/misc/sv2019&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;，然后在 URL 里输入（当然&lt;code&gt;&quot;知乎&quot;&lt;/code&gt;可改做其他文字）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;javascript:b64EncodeUnicode(&quot;知乎&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;便会显示一个编码后的文本：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;55+l5LmO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;把这个文本加在 URL 的问号后面：&lt;/p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//miloyip.com/misc/sv2019.html%3F55%2Bl5LmO&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;miloyip.com/misc/sv2019&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;.html?55+l5LmO&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;便可以看到封面的效果。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CHuge%7B%5Ccolor%7Bpink%7D%7B%5Ctextit%7BHappy+St+Valentine%27s+Day+2019%21%7D%7D%7D&quot; alt=&quot;\Huge{\color{pink}{\textit{Happy St Valentine&#39;s Day 2019!}}}&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;h2&gt;相关回答／文章&lt;/h2&gt;&lt;a href=&quot;https://www.zhihu.com/question/20187195/answer/146381413&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-f8a781f3032b886ce16bc6e6726740e1_ipico.jpg&quot; data-image-width=&quot;756&quot; data-image-height=&quot;645&quot; class=&quot;internal&quot;&gt;如何用 C 语言画「心形」？&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30123802&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-58972af6a18081c088c298f494ef4f08_ipico.jpg&quot; data-image-width=&quot;513&quot; data-image-height=&quot;513&quot; class=&quot;internal&quot;&gt;Milo Yip：完美恋爱迷宫&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31901449&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-fd045c136f75263c865390c69518016a_ipico.jpg&quot; data-image-width=&quot;1024&quot; data-image-height=&quot;1024&quot; class=&quot;internal&quot;&gt;Milo Yip：用C语言画光（七）：比尔-朗伯定律&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/31482830/answer/318497552&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-2941287c52be96de6898ec279decb881_ipico.jpg&quot; data-image-width=&quot;1286&quot; data-image-height=&quot;1290&quot; class=&quot;internal&quot;&gt;如何用计算几何模型画一束玫瑰花？&lt;/a&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] Müller, Matthias, David Charypar, and Markus Gross. &quot;Particle-based fluid simulation for interactive applications.&quot;&lt;i&gt;Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation&lt;/i&gt;. Eurographics Association, 2003.&lt;/p&gt;&lt;p&gt;[2] Bridson, Robert.&lt;i&gt;Fluid simulation for computer graphics&lt;/i&gt;. AK Peters/CRC Press, 2015.&lt;/p&gt;&lt;p&gt;[3] Kim, Doyub.&lt;i&gt;Fluid Engine Development&lt;/i&gt;. AK Peters/CRC Press, 2017.&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2019-02-13-56640030</guid>
<pubDate>Wed, 13 Feb 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>腾讯香农编码器，尽享高清视频体验</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-11-19-50351685.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50351685&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e4f37e174d1ddaab435feae983354b99_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;      这里给大家推荐一款高清视频编码利器——腾讯自主研发的香农编码器（&lt;a href=&quot;https://shannon-lab.qq.com/&quot;&gt;Tencent Shannon Encoder&lt;/a&gt;，简称T265）。在莫斯科国立大学主办的2018世界视频编码器大赛（MSU codec comparison）中，香农编码器从众多编码器中脱颖而出，继在客观指标取得优异成绩后，经过主办方严格的人眼主观测试，取得人眼主观质量评测的冠军：&lt;/p&gt;&lt;a href=&quot;http://www.compression.ru/video/codec_comparison/hevc_2018/#subjective_report&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-abe98f4240a1cc40c89eba20b0b97f1f&quot; data-image-width=&quot;300&quot; data-image-height=&quot;150&quot; data-image-size=&quot;180x120&quot;&gt;HEVC Video Codecs Comparison 2018&lt;/a&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-47bc5baf13fb26c090e45800af0d5276_r.jpg&quot; data-caption=&quot;图1 MSU发布的腾讯香农编码器的性能测试结果&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1981&quot; data-rawheight=&quot;1825&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-47bc5baf13fb26c090e45800af0d5276&quot; data-watermark-src=&quot;v2-81a023252af7f5ea01e2440f5dff8543&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;       衡量一个编码器的优劣是一件非常复杂的事情，涉及编码质量，速度和质量平衡以及码控平稳度等多个指标，受多种因素影响。下面结合大赛的测评报告，对香农编码器做三点评述。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;注重SSIM与PSNR的均衡&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       在MSU的编码质量测评中，使用了SSIM 和PSNR两种客观指标，其中SSIM指标侧重于衡量编码视频图像和原视频图像之间的结构相似性，而PSNR指标侧重于衡量编码视频图像相对原视频图像的保真度。为了保证编码视频图像的主观质量，一般需要保证SSIM和PSNR两者间的均衡，避免导致意外的主观质量问题。如图2所示，中间和右边的图像虽然PSNR一样，但右边图像有严重块效应，主观质量很差，这里SSIM指标比PSNR指标更好地反映了主观质量；而如图3所示，中间和右边图像SSIM一样，但右边图像有像素块像素值完全反转的严重失真，主观质量差得多，这里PSNR指标比SSIM指标更好地反映了主观质量。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-29a51a9507c710d2f247dd51349d4b46_r.jpg&quot; data-caption=&quot;图2 编码PSNR相同，SSIM不同的情况&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1224&quot; data-rawheight=&quot;508&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-29a51a9507c710d2f247dd51349d4b46&quot; data-watermark-src=&quot;v2-087fa81e798672e649ff95a2df3358dd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d4560722f32536e4b965efc5745bdd9_r.jpg&quot; data-caption=&quot;图3 编码SSIM相同，PSNR不同的情况&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;442&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5d4560722f32536e4b965efc5745bdd9&quot; data-watermark-src=&quot;v2-ac05bb1186b6566c819912458a76dc8b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;       腾讯香农编码器在优化过程中综合考虑了PSNR和SSIM模型的特点，在算法设计实现中采取了两者比较均衡的策略，给用户带来较好的主观视觉体验。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-01168dc1038b4aff2856a944c7cc27f8_r.jpg&quot; data-caption=&quot;图4 香农编码器PSNR和SSIM排名&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1064&quot; data-rawheight=&quot;239&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-01168dc1038b4aff2856a944c7cc27f8&quot; data-watermark-src=&quot;v2-681fe1d4f18b36846d35390013bb9f27&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;侧重中低码率的互联网应用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       在MSU的测评中所有测试序列的编码码率段都主要集中在1~12Mbps，甚至更高码率上，而互联网视频应用中编码码率段基本集中在1~6Mbps之间。腾讯香农编码器作为一款主要服务于互联网视频应用的编码器，在优化时也更关注于1~6Mbps中低码率段，由MSU测评的数据可以得到如下中低码率段的排名和全码率段的排名对比，香农编码器在中低码率段更有优势。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dff397db45dc83ac6dbaf1be938e4f2e_r.jpg&quot; data-caption=&quot;图5 Playground序列全码率段RD曲线&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1886&quot; data-rawheight=&quot;774&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-dff397db45dc83ac6dbaf1be938e4f2e&quot; data-watermark-src=&quot;v2-0a7fcda5e9e48ebc3fced768539b38c1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ddb872587456c9fd8e61dcd7f39864ff_r.jpg&quot; data-caption=&quot;图6 中低码率段部分编码器排名&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;531&quot; data-rawheight=&quot;215&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ddb872587456c9fd8e61dcd7f39864ff&quot; data-watermark-src=&quot;v2-2f53376173d8e27820bc6eec49b01f74&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;编码鲁棒性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       MSU根据时间复杂度和空间复杂度选择了迥异的测试序列，这些测试序列基本涵盖了各种场景，用来测试编码器对各种场景的编码适应能力。香农编码器通过更合理的码率分配策略，将码控精度控制在5%以内的同时，还额外节省了超过6%的带宽。其编码的鲁棒性表现也还不错，如下图所示，对于典型测试序列Sea Sunrise，当许多编码器的RD曲线都出现异常的时候，香农编码器的RD曲线不但正常，压缩性能也超过竞品。测试序列的难例挖掘是编码器研发不断迭代过程中的一个难点，香农编码器在编码鲁棒性上还有可提升的空间。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6ff9807d0518e4504dc8bce3b2738a65_r.jpg&quot; data-caption=&quot;图7 Sea Sunrise RD曲线&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;415&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6ff9807d0518e4504dc8bce3b2738a65&quot; data-watermark-src=&quot;v2-e0e6a39811e0a47590915cf38dc470ba&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;总结和展望&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       腾讯香农编码器在MSU视频编码比赛中经受了检验，无论客观指标，还是主观指标，成绩都非常突出，未来我们在技术上还会持续演进，带来更清晰流畅的视频体验。&lt;/p&gt;</description>
<author>程曦铭</author>
<guid isPermaLink="false">2018-11-19-50351685</guid>
<pubDate>Mon, 19 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>自然而然</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-10-14-46698082.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46698082&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
    unsigned i, j, k = 0, n = 1e8;
    for (i = 0; i &amp;lt; n; i++)
        for (j = 0; j &amp;lt; RAND_MAX; j += rand())
            k++;
    printf(&quot;%f\n&quot;, (double)k / n);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;console&quot;&gt;$ gcc -O3 a.c &amp;amp;&amp;amp; ./a.out
2.718219&lt;/code&gt;&lt;p&gt;&lt;a href=&quot;http://mathworld.wolfram.com/UniformSumDistribution.html&quot;&gt;Uniform Sum Distribution&lt;/a&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-10-14-46698082</guid>
<pubDate>Sun, 14 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用C语言实现井字棋（上）</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-07-25-39581573.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39581573&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c43e48d68c4d756e3a1a016f910f1382_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.zhihu.com/question/284523599/answer/438445079&quot;&gt;Milo Yip：用C++编写游戏容易吗？有什么开源的小游戏吗？能分享一下吗？&lt;/a&gt; 这个答案中，我提到学习游戏编程可从回合制游戏开始，例如井字棋。&lt;/p&gt;&lt;p&gt;考虑到一些&lt;b&gt;初学者&lt;/b&gt;的学习需求，我就写一个井字棋的教程吧。上篇实现二人游戏，下篇加上「人工智能」后约有 100 行 C 语言代码。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 游戏状态的表示&lt;/h2&gt;&lt;p&gt;首先，我认为表示方法（representation）是编程中应最先要考虑的事情。对于回合制游戏，我们需要存储一个回合中的游戏状态（game state）。&lt;/p&gt;&lt;p&gt;以下用一个结构体表示井字棋一个回合中的状态，并加入函数作初始化：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct {
    int board[3][3];    // -1 = empty, 0 = O, 1 = X
    int turn;           // O first
} state;

void init(state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; j++)
        for (i = 0; i &amp;lt; 3; i++)
            s-&amp;gt;board[j][i] = -1;
    s-&amp;gt;turn = 0;
}&lt;/code&gt;&lt;p&gt;以上用二维数组存储棋盘（board）是其中一种表示方式，另一种方式则是记录每个回合下棋子的位置。我们采用前者是因为它较容易实现胜负判定。有些回合制游戏可能使用冗余的表示方式，以方便实现各种规则。&lt;/p&gt;&lt;p&gt;而使用结构体而不是直接用全局变量，可带来一些优点，例如增强可读性及内聚性。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 显示游戏状态&lt;/h2&gt;&lt;p&gt;编写游戏时，我们通常希望先显示游戏状态，之后才加入其他规则，因为这样可以方便测试。&lt;/p&gt;&lt;p&gt;我希望用这样的文本显示游戏状态，当空置时写上位置编号（1-9），以方便玩家输入下棋位置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt; 1 | 2 | 3 
---+---+---
 4 | 5 | 6 
---+---+---
 7 | 8 | 9 &lt;/code&gt;&lt;p&gt;简单直白地编写代码的话：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void display(const state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; j++) {
        for (i = 0; i &amp;lt; 3; i++) {
            switch (s-&amp;gt;board[j][i]) {
                case -1: printf(&quot; %d &quot;, j * 3 + i + 1); break;
                case  0: printf(&quot; O &quot;); break;
                case  1: printf(&quot; X &quot;); break;
            }
            if (i &amp;lt; 2)
                printf(&quot;|&quot;);
            else
                printf(&quot;\n&quot;);
        }
        if (j &amp;lt; 2)
            printf(&quot;---+---+---\n&quot;);
        else
            printf(&quot;\n&quot;);
    }
}&lt;/code&gt;&lt;p&gt;由于 &lt;code class=&quot;inline&quot;&gt;display()&lt;/code&gt; 只读而不改变游戏状态，所以其参数类型为 &lt;code class=&quot;inline&quot;&gt;const state*&lt;/code&gt;。 &lt;/p&gt;&lt;p&gt;我们稍压缩一下代码：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void display(const state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; printf(++j &amp;lt; 3 ? &quot;---+---+---\n&quot; : &quot;\n&quot;))
        for (i = 0; i &amp;lt; 3; putchar(&quot;||\n&quot;[i++]))
            printf(&quot; %c &quot;, s-&amp;gt;board[j][i] == -1 ? &#39;1&#39; + j * 3 + i : &quot;OX&quot;[s-&amp;gt;board[j][i]]);
}&lt;/code&gt;&lt;p&gt;我们可以加入 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 函数去显示初始化的状态：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
} &lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe0.c&quot;&gt;tictactoe0.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 实现下棋&lt;/h2&gt;&lt;p&gt;然后，我们加入第一个游戏规则，就是下棋：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int move(state* s, int i, int j) {
    if (s-&amp;gt;board[j][i] != -1)
        return 0;
    s-&amp;gt;board[j][i] = s-&amp;gt;turn++ % 2;
    return 1;
}&lt;/code&gt;&lt;p&gt;函数内做了一个合法性判断，如果该位置已有棋子，则返回 0 表示失败。成功的话，在偶数回合填入 0，表示 O；奇数回合填入 1，表示 X；然后都把回合加一。&lt;/p&gt;&lt;p&gt;更改 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 简单测试： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    move(&amp;amp;s, 1, 1);
    display(&amp;amp;s);
    move(&amp;amp;s, 0, 1);
    display(&amp;amp;s);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-416ea35bcab6968eb0f15953cac392c5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;162&quot; data-rawheight=&quot;504&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe1.c&quot;&gt;tictactoe1.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;4. 处理输入&lt;/h2&gt;&lt;p&gt;在每一回合中，提示当前玩家（O 或 X），并让玩家输入一个下棋位置（1-9），如果位置不合法，则重新输入：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void human(state* s) {
    char c;
    do {
        printf(&quot;%c: &quot;, &quot;OX&quot;[s-&amp;gt;turn % 2]);
        c = getchar();
        while (getchar() != &#39;\n&#39;);
        printf(&quot;\n&quot;);
    } while (c &amp;lt; &#39;1&#39; || c &amp;gt; &#39;9&#39; || !move(s, (c - &#39;1&#39;) % 3, (c - &#39;1&#39;) / 3));
}&lt;/code&gt;&lt;p&gt;在标准输入中，要到回车键才能处理输入，所以这里我们读了第一个输入字符后，就忽略其他字符直到读到换行符。我们把表示位置的字符转换成二维数组索引。&lt;/p&gt;&lt;p&gt;然后，就可以修改 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 实现二人下棋的流程： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    while (s.turn &amp;lt; 9) {
        human(&amp;amp;s);
        display(&amp;amp;s);
    } 
}&lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe2.c&quot;&gt;tictactoe2.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;5. 胜负判定&lt;/h2&gt;&lt;p&gt;众所周知，井字棋的胜利条件，是有三个棋子在横线、直线或斜线连成一线。我们实现一个 &lt;code class=&quot;inline&quot;&gt;evaluate()&lt;/code&gt; 函数去评估棋局的状态，如果 O 胜出则返回 1，X 胜出则返回 -1，不分胜负则返回 0：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define CHECK(j1, i1, j2, i2, j3, i3) \
    if (s-&amp;gt;board[j1][i1] != -1 &amp;amp;&amp;amp; s-&amp;gt;board[j1][i1] == s-&amp;gt;board[j2][i2] &amp;amp;&amp;amp; s-&amp;gt;board[j1][i1] == s-&amp;gt;board[j3][i3]) \
        return s-&amp;gt;board[j1][i1] == 0 ? 1 : -1;

int evaluate(const state* s) {
    int i;
    for (i = 0; i &amp;lt; 3; i++) {
        CHECK(i, 0, i, 1, i, 2);    // horizontal
        CHECK(0, i, 1, i, 2, i);    // vertical
    }
    CHECK(0, 0, 1, 1, 2, 2);        // diagonal
    CHECK(0, 2, 1, 1, 2, 0);        // diagonal
    return 0;
}&lt;/code&gt;&lt;p&gt;上面的代码使用了一个宏 &lt;code class=&quot;inline&quot;&gt;CHECK()&lt;/code&gt; 去检测三个位置是否都为相同的棋子，如是则直接返回胜方。&lt;/p&gt;&lt;p&gt;最后，我们在 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 中，待每次下棋及显示状态后， 判定是否出现胜方，如果到达第 9 个回合（回合从 0 开始），则判定是平局（draw）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    while (s.turn &amp;lt; 9) {
        human(&amp;amp;s);
        display(&amp;amp;s);
        switch (evaluate(&amp;amp;s)) {
            case  1: printf(&quot;O win\n&quot;); return 0;
            case -1: printf(&quot;X win\n&quot;); return 0;
        }
    } 
    printf(&quot;Draw\n&quot;);
}&lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe3.c&quot;&gt;tictactoe3.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;6. 总结&lt;/h2&gt;&lt;p&gt;本篇实现了二人井字棋，它是一个简单的回合制游戏。我们先选择了游戏的状态表示方式（&lt;code class=&quot;inline&quot;&gt;state&lt;/code&gt;结构体及&lt;code class=&quot;inline&quot;&gt;init()&lt;/code&gt;函数），然后把状态以文本形式显示（&lt;code class=&quot;inline&quot;&gt;display()&lt;/code&gt;函数），加入每回合下棋规则（&lt;code class=&quot;inline&quot;&gt;move()&lt;/code&gt;函数），以及人类玩家的输入处理（&lt;code class=&quot;inline&quot;&gt;human()&lt;/code&gt;函数），并作胜负判定（&lt;code class=&quot;inline&quot;&gt;evaluate()&lt;/code&gt;函数），最后在&lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt;里则实现了按回合的循环及输出胜负结果。&lt;/p&gt;&lt;p&gt;虽然这个游戏本身以及 60 行的示例代码都很简单，但这个框架可以用于实现其他（更复杂的）回合制游戏。实时游戏（如动作游戏）的主要区别，其实也只在于把输入部分做成非阻塞的函数，而该循环则称为游戏循环（game loop）。&lt;/p&gt;&lt;p&gt;下篇将加入不败的「人工智能」。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-07-25-39581573</guid>
<pubDate>Wed, 25 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用C语言画希尔伯特曲线</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-06-20-38276467.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38276467&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d34f3e5d10cf51d8af90f99b49bdcf03_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B8%8C%E7%88%BE%E4%BC%AF%E7%89%B9%E6%9B%B2%E7%B7%9A&quot;&gt;希尔伯特曲线&lt;/a&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_curve&quot;&gt;Hilbert curve&lt;/a&gt;）是一种空间填充曲线（space filling curve）的分形图案，由德国数学家 &lt;a href=&quot;https://en.wikipedia.org/wiki/David_Hilbert&quot;&gt;David Hilbert&lt;/a&gt;（1862-1943）发现 [1]。简单来说，空间填充曲线就是可以用「一笔画」的方式填充整个二维、三维或更高维的空间。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d7c0d2f1d9b096b85e79f50e8569082f_r.jpg&quot; data-caption=&quot;[1] 中的插图，展示第1、2、3阶的希尔伯特曲线&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;612&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d7c0d2f1d9b096b85e79f50e8569082f&quot; data-watermark-src=&quot;v2-6aee5a02d11ac9d243a38a809e655eae&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;本文描述用 C 语言绘画这种曲线的方法和技巧。&lt;/p&gt;&lt;p&gt;（题图是一个三维的希尔伯特曲线雕塑，来自 &lt;a href=&quot;http://mathbun.com/&quot;&gt;http://mathbun.com/&lt;/a&gt;）&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 递归、坐标变换&lt;/h2&gt;&lt;p&gt;最初，我在 [2] 找到一种基于矢量的绘画方法。它的原理是，一阶的希尔伯特曲线是一个「⊓」的形状，我们可以生成四个顶点，把顶点连接起来。而第二阶则是用第一阶的四个顶点位置，加上旋转和缩小，去画4 个「⊓」形状。只要把最后生成的顶点连接起来，就可以生成整个曲线：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7833b4f3a74fe531aa941a95f9822920_r.jpg&quot; data-caption=&quot;左图是一阶，起点在左下角。右图黑线部分是4个「⊓」形状，它们的中心为左图的顶点位置，加上旋转 -90、0、0、90度、以及缩小为一半。最后把所有顶点连起来，增加了灰线部分。&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;397&quot; data-rawheight=&quot;182&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7833b4f3a74fe531aa941a95f9822920&quot; data-watermark-src=&quot;v2-a802e01794c71709cd1f2128de4b9241&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们用一个影像缓冲去绘画这些垂直、水平线，最后用 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/26525083&quot;&gt;极简的 PNG 编码函数 svpng()&lt;/a&gt;  来存储。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &quot;svpng.inc&quot;
#define S 512

unsigned char img[S * S * 3];
float px = 0.0f, py = 0.0f;

void setpixel(int x, int y) { /* ... */}
void lineto(float tx, float ty) {/* ... */}

void hilbert(float x, float y, float xi, float xj, float yi, float yj, int n) {
    if (n) {
        hilbert(x,                   y,                    yi / 2,  yj / 2,  xi / 2,  xj / 2, n - 1);
        hilbert(x + xi / 2,          y + xj / 2,           xi / 2,  xj / 2,  yi / 2,  yj / 2, n - 1);
        hilbert(x + xi / 2 + yi / 2, y + xj / 2 + yj / 2,  xi / 2,  xj / 2,  yi / 2,  yj / 2, n - 1);
        hilbert(x + xi / 2 + yi,     y + xj / 2 + yj,     -yi / 2, -yj / 2, -xi / 2, -xj / 2, n - 1);
    }
    else
        lineto(x + (xi + yi) / 2, y + (xj + yj) / 2);
}

int main() {
    hilbert(0.0f, 0.0f, 0.0f, S, S, 0.0f, 4);
    svpng(fopen(&quot;hilbert.png&quot;, &quot;wb&quot;), S, S,img, 0);
}&lt;/code&gt;&lt;p&gt;4阶的结果（为方便起见，起点位于左上角）：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-41985853acabc9b888e3c4d28051e63f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-41985853acabc9b888e3c4d28051e63f&quot; data-watermark-src=&quot;v2-07d283a9aeeb319dbbbcf5ea05f91046&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;注：&lt;code class=&quot;inline&quot;&gt;setpixel()&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;lineto()&lt;/code&gt;较锁碎，不在此展示，完整代码位于&lt;a href=&quot;https://github.com/miloyip/misc/blob/master/hilbert/hilbert.c&quot;&gt;https://github.com/miloyip/misc/blob/master/hilbert/hilbert.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 方向编码&lt;/h2&gt;&lt;p&gt;第一个方法要计算每个顶点的位置，计算量较大。另一种绘画希尔伯特曲线的方式，是考虑它的 L-system：&lt;/p&gt;&lt;blockquote&gt;变数: L, R&lt;br&gt;常数: F, +, -&lt;br&gt;公理: L&lt;br&gt;规则:&lt;br&gt;L → − R F + L F L + F R −&lt;br&gt;R → − L F + R F R + F L −&lt;br&gt;F ： 向前&lt;br&gt;- ： 右转90°&lt;br&gt;+ ： 左转90°&lt;/blockquote&gt;&lt;p&gt;我们可以看到，两条规则其实是对称的，我们只需要把在迭归时，从 L 变成 R时把旋转方向反转。我参考了[3]的代码实现，但每次向前移动只绘画两个像素，当中&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;为笔的当前像素位置，参数&lt;code class=&quot;inline&quot;&gt;d&lt;/code&gt;为当前方向，&lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt;记录旋转：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &quot;svpng.inc&quot;
#include &amp;lt;stdlib.h&amp;gt;

unsigned char* img, *p;
const int n = 4, s = (2 &amp;lt;&amp;lt; n) - 1;

void step(int d) {
    int a[] = { 3, s * 3, -3, s * -3 }, i;
    for (i = 0; i &amp;lt; 2; i++, p += a[d &amp;amp; 3])
        p[0] = p[1] = p[2] = 255;
}

void hilbert(int d, int r, int n) {
    if (n--) {
        hilbert(d + r, -r, n); step(d + r);
        hilbert(d,      r, n); step(d    );
        hilbert(d,      r, n); step(d - r);
        hilbert(d - r, -r, n);
    }
}

int main() {
    p = img = calloc(s * s, 3);
    hilbert(0, 1, n);
    p[0] = p[1] = p[2] = 255;
    svpng(fopen(&quot;hilbert2.png&quot;, &quot;wb&quot;), s, s, img, 0);
    free(img);
}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b39f241a8582cf0669bfb3a0af68cf1c_r.jpg&quot; data-caption=&quot;放大 16 倍后的4阶结果&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;496&quot; data-rawheight=&quot;496&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b39f241a8582cf0669bfb3a0af68cf1c&quot; data-watermark-src=&quot;v2-5f1180c240c8f3460c447eb1b0e68d50&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这种实现方式较简单，也能用最少的影像尺寸存储结果。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 简单文本&lt;/h2&gt;&lt;p&gt;既然可以用较小的画布尺寸，我们直接把每个像素变换成&lt;code class=&quot;inline&quot;&gt;**&lt;/code&gt; 两个字符：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

char* img, *p;
const int n = 4, s = (2 &amp;lt;&amp;lt; n) - 1, a[] = { 2, s * 2, -2, -s * 2 };

void step(int d) {
    int i;
    for (i = 0; i &amp;lt; 2; i++, p += a[d &amp;amp; 3])
        p[0] = p[1] = &#39;*&#39;;
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    memset(p = img = malloc(s * s * 2), &#39; &#39;, s * s * 2);
    hilbert(0, 1, n);
    p[0] = p[1] = &#39;*&#39;;
    for (p = img; p &amp;lt; img + s * s * 2; p += s * 2)
        printf(&quot;%.*s\n&quot;, s * 2, p);
    free(img);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bab9624e85060beacb77194ae95ec8f8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;890&quot; data-rawheight=&quot;898&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bab9624e85060beacb77194ae95ec8f8&quot; data-watermark-src=&quot;v2-2b008e151d8579c2b45fddf22dcb3081&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;h2&gt;4. ASCII 字符美化&lt;/h2&gt;&lt;p&gt;上面的输出有点丑。我在 [4] 里找到一种美化方法，可通过方向的改变来决定用什么字符，该映射为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┌&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt; _&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┐&lt;/code&gt; →  &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;└&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;|_&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┘&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;| &lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;│&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;| &lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;─&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;__&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9f1bf3371387712e2ce38bf9536636b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;186&quot; data-rawheight=&quot;106&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我通过记录上一次的方向，与当前要步进的方向，去做这个映射。例如之前是向下的（&lt;code class=&quot;inline&quot;&gt;l=3&lt;/code&gt;）当前要向右（&lt;code class=&quot;inline&quot;&gt;d=0&lt;/code&gt;），即&lt;code class=&quot;inline&quot;&gt;└&lt;/code&gt; 的情况，便在笔的位置写进&lt;code class=&quot;inline&quot;&gt;|_&lt;/code&gt;这两个字符。针对 &lt;equation&gt;4\times4=16&lt;/equation&gt; 种组合，我用字符串表示：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

char* img, *p;
const int n = 4 , s = 1 &amp;lt;&amp;lt; n, a[] = { 2, s * 2, -2, -s * 2 };
int l = 3;

void step(int d) {
    d &amp;amp;= 3;
    p[0] = &quot;_  ||||   _|   |&quot;[l * 4 + d];
    p[1] = &quot;_   _    ____   &quot;[l * 4 + d];
    p += a[d];
    l = d;
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    p = img = malloc(s * s * 2);
    hilbert(0, 1, n);
    p[0] = p[1] = &#39; &#39;;
    for (p = img; p &amp;lt; img + s * s * 2; p += s * 2)
        printf(&quot;%.*s\n&quot;, s * 2, p);
    free(img);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f6d81fe1327e9a92219de371b4cca505_r.jpg&quot; data-caption=&quot;4阶&quot; data-size=&quot;small&quot; data-rawwidth=&quot;768&quot; data-rawheight=&quot;478&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f6d81fe1327e9a92219de371b4cca505&quot; data-watermark-src=&quot;v2-6f64734912d4820a49f0e40933b5835c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0f01b2e77086e678da2860a55fcba3b7_r.jpg&quot; data-caption=&quot;6阶&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1290&quot; data-rawheight=&quot;1308&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0f01b2e77086e678da2860a55fcba3b7&quot; data-watermark-src=&quot;v2-10deb3eb183f553e27a6da9f87a629de&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;h2&gt;5. 无内存分配&lt;/h2&gt;&lt;p&gt;为了尽一步简化，我希望能去掉画步的内存分配。方法是把逻辑改为，从上至下左至右打印字符，每画两个字符我们都遍历整个曲线，若曲线的位置和当前打印位置相同，才把那两个字符打印出来。这样会增加大量运算，但可以减少代码量。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

const int n = 4, s = 1 &amp;lt;&amp;lt; n, a[] = { 1, s, -1, -s };
int l = 3, p, q;

void step(int d) {
    d &amp;amp;= 3;
    if (p == q)
        printf(&quot;%.2s&quot;, &amp;amp;&quot;__    | |_| |      ___|_ _    | &quot;[l * 8 + d * 2]);
    p += a[l = d];
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    for (; q &amp;lt; s * s; q++, p = 0) {
        hilbert(0, 1, n);
        if (q % s == s - 1)
            putchar(&#39;\n&#39;);
    }
}&lt;/code&gt;&lt;h2&gt;6. 代码压缩&lt;/h2&gt;&lt;p&gt;最后，我把上面的代码压缩成 256 个字符：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;const n=4,s=1&amp;lt;&amp;lt;n,a[]={1,s,-1,-s};
l=3,p,q;
t(d){d&amp;amp;=3;p-q||printf(&quot;%.2s&quot;,&amp;amp;&quot;__    | |_| |      ___|_ _    | &quot;[l*8+d*2]);p+=a[l=d];}
h(d,r,n){n--&amp;amp;&amp;amp;(h(d+r,-r,n),t(d+r),h(d,r,n),t(d),h(d,r,n),t(d-r),h(d-r,-r,n));}
main(){for(;p=0,q&amp;lt;s*s;++q%s||putchar(10))h(0,1,n);}&lt;/code&gt;&lt;a href=&quot;https://tio.run/##VY7RaoQwEEV/RYSVxMwU3e1DIeZLREIwuC6k2Zik7IP665vGdvvQCwNz7syFO@JolL2mNN5tiIUV7xBE23UWVD@ItYUA2AKGnRtxAQcLj0TTVVfiwh0u2@b8zcaJlKe3cyihKqUssrZik3mKH0kpN1m8/LI39QfT9Xmg3DGheiP0wPeZaPBg6WoRq4pkZB7wcCAeO4W/j4P/E/5e8RWgfP9UN0voOt094U40sHShDpyx5RRy4684zsqTtqF0Jg20OcP3lJ7jZNQ1JHx8Aw&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Try It Online&lt;/a&gt;&lt;p&gt;本文所有代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/tree/master/hilbert&quot;&gt;https://github.com/miloyip/misc/tree/master/hilbert&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;相关文章&lt;/h2&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24688522&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b082e4583bfbf99f53a075d4510a2f25&quot; data-image-width=&quot;1439&quot; data-image-height=&quot;1080&quot; data-image-size=&quot;180x120&quot;&gt;Milo Yip：用 C 语言画科赫雪花&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23692828&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b5818ef7694bbb3236a1bdc7e9a8b572&quot; data-image-width=&quot;1620&quot; data-image-height=&quot;1080&quot; data-image-size=&quot;180x120&quot;&gt;Milo Yip：如何用 C 语言画这个图&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/27015321/answer/35028446&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;b92e467997b0f799cfb7f085dc06833a&quot; data-image-width=&quot;1018&quot; data-image-height=&quot;884&quot; data-image-size=&quot;ipico&quot;&gt;如何用 C 语言画一个“圣诞树”？&lt;/a&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] D. Hilbert, &lt;a href=&quot;http://www.digizeitschriften.de/dms/img/?PPN=PPN235181684_0038&amp;amp;DMDID=dmdlog40&quot;&gt;Über die stetige Abbildung einer Linie auf ein Flächenstück&lt;/a&gt;, Mathematische Annalen 38 (1891), 459–460.&lt;/p&gt;&lt;p&gt;[2] &lt;a href=&quot;http://www.soc.napier.ac.uk/~andrew/hilbert.html&quot;&gt;http://www.soc.napier.ac.uk/~andrew/hilbert.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[3] &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35358486&quot;&gt;形形色色的空间填充曲线 和 L-System&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[4] &lt;a href=&quot;https://codegolf.stackexchange.com/questions/104392/ascii-hilbert-curve&quot;&gt;ASCII Hilbert Curve&lt;/a&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-06-20-38276467</guid>
<pubDate>Wed, 20 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>波兰表示法与表达式树</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-06-13-38013510.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38013510&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e53026a0f73a4bcaba68b7aa7ae0619f_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;昨晚撰写答案《&lt;a href=&quot;https://www.zhihu.com/question/280630276/answer/415398747&quot;&gt;Milo Yip：怎么用 C 语言画出二叉树的图形？&lt;/a&gt;》，以 ASCII 字符打印任意深度的满二叉树（full binary tree）。评论中问及如何打印非满二叉树。我记起，整个满二叉树可存储在单个一维数组。那么，可以先把非满二叉树的节点写到一维数组，然后修改打印程序，如果数组中存有该序号的节点，才打印该节点及其指向父节点的连线，否则打印空白占位字符。&lt;/p&gt;&lt;p&gt;我的回评或过于简短，不够清晰，因此我想用实际代码解释。然而，怎样建一个非满二叉树？我想到可以写一个简单的表达式解析器，支持加减乘除，不支持负数操作数。程序也能打印出其表达式树。&lt;/p&gt;&lt;p&gt;最简单的表达式语法，莫过于&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95&quot;&gt;波兰表示法&lt;/a&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;Polish notation&lt;/a&gt;）。波兰表示法又称为前缀表示法，即运算符写在前面。波兰表示法的特点是不需要括号。例如，表达式(&lt;code class=&quot;inline&quot;&gt;1 + 2) * (3 - 4)&lt;/code&gt; 的波表示法是 &lt;code class=&quot;inline&quot;&gt;* + 1 2 - 3 4&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;（题图 &lt;a href=&quot;https://unsplash.com/photos/4xEfxMShEUM&quot;&gt;photo by Elliott Engelmann&lt;/a&gt;）&lt;/p&gt;&lt;hr&gt;&lt;p&gt;首先设计解析后的数据结构，表达式树的节点可能是运算符或操作数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef enum { NUM, ADD, SUB, MUL, DIV } Type;

typedef struct NodeTag {
    union {
        double number;
        struct NodeTag *children[2];
    } u;
    Type type;
} Node;&lt;/code&gt;&lt;p&gt;因为一个节点不会同时为运算符或操作数，采用 &lt;code class=&quot;inline&quot;&gt;union&lt;/code&gt;可能节省一点内存。&lt;/p&gt;&lt;p&gt;波兰表示法的解释器非常简单，可通过递归实现，不需要额外的数据结构：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Node* parse(char** s) {
    while (isspace(**s))
        (*s)++;    
    if (**s == &#39;\0&#39;)
        return NULL;
    else {
        Node* n = (Node*)calloc(1, sizeof(Node));
        if (isdigit(**s)) {
            n-&amp;gt;type = NUM;
            n-&amp;gt;u.number = strtod(*s, s);
        }
        else {
            int i;
            switch (**s) {
                case  &#39;+&#39;: n-&amp;gt;type = ADD; break;
                case  &#39;-&#39;: n-&amp;gt;type = SUB; break;
                case  &#39;*&#39;: n-&amp;gt;type = MUL; break;
                case  &#39;/&#39;: n-&amp;gt;type = DIV; break;
                default: release(n); return NULL;
            }
            (*s)++;
            for (i = 0; i &amp;lt; 2; i++)
                if ((n-&amp;gt;u.children[i] = parse(s)) == NULL) {
                    release(n);
                    return NULL;
                }
        }
        return n;
    }
}&lt;/code&gt;&lt;p&gt;每次有内存分配，都匹对释放，也是递归：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void release(Node* n) {
    int i;
    if (n-&amp;gt;type != NUM)
        for (i = 0; i &amp;lt; 2; i++)
            if (n-&amp;gt;u.children[i])
                release(n-&amp;gt;u.children[i]);
    free(n);
}&lt;/code&gt;&lt;p&gt;然后我们可以打印中缀表示法：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define OPERATOR_CHAR(n) (&quot;+-*/&quot;[n-&amp;gt;type - ADD])

void printInfix(const Node *n) {
    if (n-&amp;gt;type == NUM)
        printf(&quot;%lg&quot;, n-&amp;gt;u.number);
    else {
        putchar(&#39;(&#39;);
        printInfix(n-&amp;gt;u.children[0]);
        printf(&quot; %c &quot;, OPERATOR_CHAR(n));
        printInfix(n-&amp;gt;u.children[1]);
        putchar(&#39;)&#39;);
    }
}&lt;/code&gt;&lt;p&gt;以及对表达式树求值：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;double eval(const Node* n) {
    switch (n-&amp;gt;type) {
        case ADD: return eval(n-&amp;gt;u.children[0]) + eval(n-&amp;gt;u.children[1]);
        case SUB: return eval(n-&amp;gt;u.children[0]) - eval(n-&amp;gt;u.children[1]);
        case MUL: return eval(n-&amp;gt;u.children[0]) * eval(n-&amp;gt;u.children[1]);
        case DIV: return eval(n-&amp;gt;u.children[0]) / eval(n-&amp;gt;u.children[1]);
        case NUM: return n-&amp;gt;u.number;
    }
}&lt;/code&gt;&lt;p&gt;编写&lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt;： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main(int argc, char** argv) {
    if (argc != 2)
        return printf(&quot;Help: pntree \&quot;+ * 1 2 3\&quot;&quot;);
    else {
        char** p = &amp;amp;argv[1];
        Node* root = parse(p);
        if (root) {
            printInfix(root);
            printf(&quot; = %lg\n&quot;, eval(root));
            release(root);
        }
        else
            return printf(&quot;Invalid input\n&quot;);
    }
}&lt;/code&gt;&lt;p&gt;测试：&lt;/p&gt;&lt;code lang=&quot;console&quot;&gt;$ ./pntree &quot;* + 1 2 - 3 4&quot;
((1 + 2) * (3 - 4)) = -3&lt;/code&gt;&lt;hr&gt;&lt;p&gt;接下来，我们要修改之前的满二叉树打印程序。和之前的需求不一样，树的深度是随输入改变的，所以需先求出最大高度（深度）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int maxDepth(const Node* n) {
    if (n-&amp;gt;type == NUM)
        return 1;
    else {
        int maximum = 0, i, d;
        for (i = 0; i &amp;lt; 2; i++)
            if (maximum &amp;lt; (d = maxDepth(n-&amp;gt;u.children[i])))
                maximum = d;
        return maximum + 1;
    }
}&lt;/code&gt;&lt;p&gt;接着是分配一个 &lt;equation&gt;2^d-1&lt;/equation&gt; 大小的数组，把序号映射至节点：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void fillMap(Node** map, Node* n, int index) {
    int i;
    map[index] = n;
    if (n-&amp;gt;type != NUM)
        for (i = 0; i &amp;lt; 2; i++)
            fillMap(map, n-&amp;gt;u.children[i], index * 2 + i + 1);
}

void printTree(Node* n) {
    int depth = maxDepth(n), i, j, index;
    Node** map = (Node**)calloc((1 &amp;lt;&amp;lt; depth) - 1, sizeof(Node*));
    fillMap(map, n, 0);
    // ...
    free(map);
}&lt;/code&gt;&lt;p&gt;这里和原答案一样，使用广度优先遍历去打印节点。先忽略连线的部分：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void putchars(char c, int n) {
    while (n--)
        putchar(c);
}

int printNode(Node* n, int w) {
    if (n-&amp;gt;type == NUM)
        return printf(&quot;%*lg&quot;, w, n-&amp;gt;u.number);
    else
        return printf(&quot;%*c&quot;, w, &quot;+-*/&quot;[n-&amp;gt;type - ADD]);
}

void printTree(Node* n) {
    int depth = maxDepth(n), i, j, index;
    Node** map = (Node**)calloc((1 &amp;lt;&amp;lt; depth) - 1, sizeof(Node*));
    fillMap(map, n, 0);
    for (j = 0, index = 0; j &amp;lt; depth; j++) {
        int w = 1 &amp;lt;&amp;lt; (depth - j + 1);
        // Curve to parent ...
        // Node content
        for (i = 0; i &amp;lt; 1 &amp;lt;&amp;lt; j; i++, index++)
            if (map[index])
                putchars(&#39; &#39;, w * 2 - printNode(map[index], w));
            else
                putchars(&#39; &#39;, w * 2);
        putchar(&#39;\n&#39;);
    }
    free(map);
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;putchars(c, n)&lt;/code&gt;连续打印 n 个相同字符。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;printNode(n, w)&lt;/code&gt; 打印节点的内容（运算符或操作数），打印寛度为&lt;code class=&quot;inline&quot;&gt;w&lt;/code&gt;个字符，返回实际打印字符数目。&lt;/p&gt;&lt;p&gt;在 &lt;code class=&quot;inline&quot;&gt;printTree(n)&lt;/code&gt;中，采用之前相同的两层循环，在内循环里递增序号&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt;，并获取当前节点&lt;code class=&quot;inline&quot;&gt;map[index]&lt;/code&gt;。若该序号没有节点，则打印空白字符。 &lt;/p&gt;&lt;p&gt;最终结果：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-327cf535e573aca9c44c62564fc3f19e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1710&quot; data-rawheight=&quot;446&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-327cf535e573aca9c44c62564fc3f19e&quot; data-watermark-src=&quot;v2-cd05f5e7509ba8ea3ed3824ddbf85739&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;本文简单示范如何实现波兰表示法的计算器，并打印其非满二叉表达式树。此方法需要 &lt;equation&gt;O(2^d)&lt;/equation&gt; 的时间和空间复杂度。如实际节点数量远低于 &lt;equation&gt;2^d&lt;/equation&gt; ，可考虑用哈希表存储该映射表，但时间复杂度始终无法降低。另一简单优化方法，是用二维数组存储字符输出，那就只需绘画表达式树含有的节点。&lt;/p&gt;&lt;p&gt;完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/pntree/pntree.c&quot;&gt;pntree.c&lt;/a&gt;。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-06-13-38013510</guid>
<pubDate>Wed, 13 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从零开始的 JSON 库教程（八）：访问与其他功能</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-06-04-37618664.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37618664&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-58d55d45d37aa51b9ba19f3e3cec0b22_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文是&lt;a href=&quot;https://zhuanlan.zhihu.com/json-tutorial&quot;&gt;《从零开始的 JSON 库教程》&lt;/a&gt;的第八个单元。代码位于 &lt;a href=&quot;https://github.com/miloyip/json-tutorial/blob/master/tutorial08&quot;&gt;json-tutorial/tutorial08&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;（题图Photo by &lt;a href=&quot;https://unsplash.com/photos/9Q_pLLP_jmA?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Rob Lambert&lt;/a&gt;）&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 对象键值查询&lt;/h2&gt;&lt;p&gt;我们在第六个单元实现了 JSON 对象的数据结构，它仅为一个 &lt;code class=&quot;inline&quot;&gt;lept_value&lt;/code&gt; 的数组：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;struct lept_value {
    union {
        struct { lept_member* m; size_t size; }o;
        /* ... */
    }u;
    lept_type type;
};

struct lept_member {
    char* k; size_t klen;   /* member key string, key string length */
    lept_value v;           /* member value */
};&lt;/code&gt;&lt;p&gt;为了做相应的解析测试，我们实现了最基本的查询功能：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;size_t lept_get_object_size(const lept_value* v);
const char* lept_get_object_key(const lept_value* v, size_t index);
size_t lept_get_object_key_length(const lept_value* v, size_t index);
lept_value* lept_get_object_value(lept_value* v, size_t index);&lt;/code&gt;&lt;p&gt;在实际使用时，我们许多时候需要查询一个键值是否存在，如存在，要获得其相应的值。我们可以提供一个函数，简单地用线性搜寻实现这个查询功能（时间复杂度 &lt;equation&gt;\mathrm{O}(n)&lt;/equation&gt; ）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define LEPT_KEY_NOT_EXIST ((size_t)-1)

size_t lept_find_object_index(const lept_value* v, const char* key, size_t klen) {
    size_t i;
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_OBJECT &amp;amp;&amp;amp; key != NULL);
    for (i = 0; i &amp;lt; v-&amp;gt;u.o.size; i++)
        if (v-&amp;gt;u.o.m[i].klen == klen &amp;amp;&amp;amp; memcmp(v-&amp;gt;u.o.m[i].k, key, klen) == 0)
            return i;
    return LEPT_KEY_NOT_EXIST;
}}&lt;/code&gt;&lt;p&gt;若对象内没有所需的键，此函数返回 &lt;code class=&quot;inline&quot;&gt;LEPT_KEY_NOT_EXIST&lt;/code&gt;。使用时：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value o;
size_t index;
lept_init(&amp;amp;o);
lept_parse(&amp;amp;o, &quot;{\&quot;name\&quot;:\&quot;Milo\&quot;, \&quot;gender\&quot;:\&quot;M\&quot;}&quot;);
index = lept_find_object_index(&amp;amp;o, &quot;name&quot;, 4);
if (index != LEPT_KEY_NOT_EXIST) {
    lept_value* v = lept_get_object_value(&amp;amp;o, index);
    printf(&quot;%s\n&quot;, lept_get_string(v));
}
lept_free(&amp;amp;o);&lt;/code&gt;&lt;p&gt;由于一般也是希望获取键对应的值，而不需要索引，我们再加入一个辅助函数，返回类型改为 &lt;code class=&quot;inline&quot;&gt;lept_value*&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value* lept_find_object_value(lept_value* v, const char* key, size_t klen) {
    size_t index = lept_find_object_index(v, key, klen);
    return index != LEPT_KEY_NOT_EXIST ? &amp;amp;v-&amp;gt;u.o.m[index].v : NULL;
}&lt;/code&gt;&lt;p&gt;上述例子便可简化为：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value o, *v;
/* ... */
if ((v = lept_find_object_value(&amp;amp;o, &quot;name&quot;, 4)) != NULL)
    printf(&quot;%s\n&quot;, lept_get_string(v));&lt;/code&gt;&lt;hr&gt;&lt;h2&gt;2. 相等比较&lt;/h2&gt;&lt;p&gt;在实现数组和对象的修改之前，为了测试结果的正确性，我们先实现 &lt;code class=&quot;inline&quot;&gt;lept_value&lt;/code&gt; 的&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E9%97%9C%E4%BF%82%E9%81%8B%E7%AE%97%E5%AD%90&quot;&gt;相等比较&lt;/a&gt;（equality comparison）。首先，两个值的类型必须相同，对于 true、false、null 这三种类型，比较类型后便完成比较。而对于数字和字符串，需进一步检查是否相等：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int lept_is_equal(const lept_value* lhs, const lept_value* rhs) {
    assert(lhs != NULL &amp;amp;&amp;amp; rhs != NULL);
    if (lhs-&amp;gt;type != rhs-&amp;gt;type)
        return 0;
    switch (lhs-&amp;gt;type) {
        case LEPT_STRING:
            return lhs-&amp;gt;u.s.len == rhs-&amp;gt;u.s.len &amp;amp;&amp;amp; 
                memcmp(lhs-&amp;gt;u.s.s, rhs-&amp;gt;u.s.s, lhs-&amp;gt;u.s.len) == 0;
        case LEPT_NUMBER:
            return lhs-&amp;gt;u.n == rhs-&amp;gt;u.n;
        /* ... */
        default:
            return 1;
    }
}&lt;/code&gt;&lt;p&gt;由于值可能复合类型（数组和对象），也就是一个树形结构。当我们要比较两个树是否相等，可通过递归实现。例如，对于数组，我们先比较元素数目是否相等，然后递归检查对应的元素是否相等：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int lept_is_equal(const lept_value* lhs, const lept_value* rhs) {
    size_t i;
    /* ... */
    switch (lhs-&amp;gt;type) {
        /* ... */
        case LEPT_ARRAY:
            if (lhs-&amp;gt;u.a.size != rhs-&amp;gt;u.a.size)
                return 0;
            for (i = 0; i &amp;lt; lhs-&amp;gt;u.a.size; i++)
                if (!lept_is_equal(&amp;amp;lhs-&amp;gt;u.a.e[i], &amp;amp;rhs-&amp;gt;u.a.e[i]))
                    return 0;
            return 1;
        /* ... */
    }
}&lt;/code&gt;&lt;p&gt;而对象与数组的不同之处，在于概念上对象的键值对是无序的。例如，&lt;code class=&quot;inline&quot;&gt;{&quot;a&quot;:1,&quot;b&quot;:2}&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;{&quot;b&quot;:2,&quot;a&quot;:1}&lt;/code&gt; 虽然键值的次序不同，但这两个 JSON 对象是相等的。我们可以简单地利用 &lt;code class=&quot;inline&quot;&gt;lept_find_object_index()&lt;/code&gt; 去找出对应的值，然后递归作比较。这部分留给读者作为练习。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 复制、移动与交换&lt;/h2&gt;&lt;p&gt;本单元的重点，在于修改数组和对象的内容。我们将会实现一些接口做修改的操作，例如，为对象设置一个键值，我们可能会这么设计：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_set_object_value(lept_value* v, const char* key, size_t klen, const lept_value* value);

void f() {
    lept_value v, s;
    lept_init(&amp;amp;v);
    lept_parse(&amp;amp;v, &quot;{}&quot;);
    lept_init(&amp;amp;s);
    lept_set_string(&amp;amp;s, &quot;Hello&quot;, 5);
    lept_set_object_keyvalue(&amp;amp;v, &quot;s&quot;, &amp;amp;s); /* {&quot;s&quot;:&quot;Hello&quot;} */
    lept_free(&amp;amp;v)
    lept_free(&amp;amp;s);  /* 第二次释放！*/
}&lt;/code&gt;&lt;p&gt;凡涉及赋值，都可能会引起资源拥有权（resource ownership）的问题。值 &lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt; 并不能以指针方式简单地写入对象 &lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;，因为这样便会有两个地方都拥有 &lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;，会做成重复释放的 bug。我们有两个选择：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 中，把参数 &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_copying#Deep_copy&quot;&gt;深度复制&lt;/a&gt;（deep copy）一个值，即把整个树复制一份，写入其新增的键值对中。&lt;/li&gt;&lt;li&gt;在 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 中，把参数 &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; 拥有权转移至新增的键值对，再把 &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; 设置成 null 值。这就是所谓的移动语意（move semantics）。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;深度复制是一个常用功能，使用者也可能会用到，例如把一个 JSON 复制一个版本出来修改，保持原来的不变。所以，我们实现一个公开的深度复制函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_copy(lept_value* dst, const lept_value* src) {
    size_t i;
    assert(src != NULL &amp;amp;&amp;amp; dst != NULL &amp;amp;&amp;amp; src != dst);
    switch (src-&amp;gt;type) {
        case LEPT_STRING:
            lept_set_string(dst, src-&amp;gt;u.s.s, src-&amp;gt;u.s.len);
            break;
        case LEPT_ARRAY:
            /* \todo */
            break;
        case LEPT_OBJECT:
            /* \todo */
            break;
        default:
            lept_free(dst);
            memcpy(dst, src, sizeof(lept_value));
            break;
    }
}&lt;/code&gt;&lt;p&gt;C++11 加入了右值引用的功能，可以从语言层面区分复制和移动语意。而在 C 语言中，我们也可以通过实现不同版本的接口（不同名字的函数），实现这两种语意。但为了令接口更简单和正交（orthgonal），我们修改了 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 的设计，让它返回新增键值对的值指针，所以我们可以用 &lt;code class=&quot;inline&quot;&gt;lept_copy()&lt;/code&gt; 去复制赋值，也可以简单地改变新增的键值：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;/* 返回新增键值对的指针 */
lept_value* lept_set_object_value(lept_value* v, const char* key, size_t klen);

void f() {
    lept_value v;
    lept_init(&amp;amp;v);
    lept_parse(&amp;amp;v, &quot;{}&quot;);
    lept_set_string(lept_set_object_value(&amp;amp;v, &quot;s&quot;), &quot;Hello&quot;, 5);
    /* {&quot;s&quot;:&quot;Hello&quot;} */
    lept_copy(
        lept_add_object_keyvalue(&amp;amp;v, &quot;t&quot;),
        lept_get_object_keyvalue(&amp;amp;v, &quot;s&quot;, 1));
    /* {&quot;s&quot;:&quot;Hello&quot;,&quot;t&quot;:&quot;Hello&quot;} */
    lept_free(&amp;amp;v);
}
&lt;/code&gt;&lt;p&gt;我们还提供了 &lt;code class=&quot;inline&quot;&gt;lept_move()&lt;/code&gt;，它的实现也非常简单：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_move(lept_value* dst, lept_value* src) {
    assert(dst != NULL &amp;amp;&amp;amp; src != NULL &amp;amp;&amp;amp; src != dst);
    lept_free(dst);
    memcpy(dst, src, sizeof(lept_value));
    lept_init(src);
}&lt;/code&gt;&lt;p&gt;类似地，我们也实现了一个交换值的接口：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_swap(lept_value* lhs, lept_value* rhs) {
    assert(lhs != NULL &amp;amp;&amp;amp; rhs != NULL);
    if (lhs != rhs) {
        lept_value temp;
        memcpy(&amp;amp;temp, lhs, sizeof(lept_value));
        memcpy(lhs,   rhs, sizeof(lept_value));
        memcpy(rhs, &amp;amp;temp, sizeof(lept_value));
    }
}&lt;/code&gt;&lt;p&gt;当我们要修改对象或数组里的值时，我们可以利用这 3 个函数。例如：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;const char* json = &quot;{\&quot;a\&quot;:[1,2],\&quot;b\&quot;:3}&quot;;
char *out;
lept_value v;
lept_init(&amp;amp;v);
lept_parse(&amp;amp;v, json);
lept_copy(
    lept_find_object_value(&amp;amp;v, &quot;b&quot;, 1),
    lept_find_object_value(&amp;amp;v, &quot;a&quot;, 1));
printf(&quot;%s\n&quot;, out = lept_stringify(&amp;amp;v, NULL)); /* {&quot;a&quot;:[1,2],&quot;b&quot;:[1,2]} */
free(out);

lept_parse(&amp;amp;v, json);
lept_move(
    lept_find_object_value(&amp;amp;v, &quot;b&quot;, 1),
    lept_find_object_value(&amp;amp;v, &quot;a&quot;, 1));
printf(&quot;%s\n&quot;, out = lept_stringify(&amp;amp;v, NULL)); /* {&quot;a&quot;:null,&quot;b&quot;:[1,2]} */
free(out);

lept_parse(&amp;amp;v, json);
lept_swap(
    lept_find_object_value(&amp;amp;v, &quot;b&quot;, 1),
    lept_find_object_value(&amp;amp;v, &quot;a&quot;, 1));
printf(&quot;%s\n&quot;, out = lept_stringify(&amp;amp;v, NULL)); /* {&quot;a&quot;:3,&quot;b&quot;:[1,2]} */
free(out);

lept_free(&amp;amp;v);&lt;/code&gt;&lt;p&gt;在使用时，可尽量避免 &lt;code class=&quot;inline&quot;&gt;lept_copy()&lt;/code&gt;，而改用 &lt;code class=&quot;inline&quot;&gt;lept_move()&lt;/code&gt; 或 &lt;code class=&quot;inline&quot;&gt;lept_swap()&lt;/code&gt;，因为后者不需要分配内存。当中 &lt;code class=&quot;inline&quot;&gt;lept_swap()&lt;/code&gt; 更是无须做释放的工作，令它达到 &lt;equation&gt;\mathrm{O}(1)&lt;/equation&gt; 时间复杂度，其性能与值的内容无关。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;4. 动态数组&lt;/h2&gt;&lt;p&gt;在此单元之前的实现里，每个数组的元素数目在解析后是固定不变的，其数据结构是：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;struct lept_value {
    union {
        /* ... */
        struct { lept_value* e; size_t size; }a; /* array:  elements, element count*/
        /* ... */
    }u;
    lept_type type;
};&lt;/code&gt;&lt;p&gt;用这种数据结构增删元素时，我们需要重新分配一个数组，把适当的旧数据拷贝过去。但这种做法是非常低效的。例如我们想要从一个空的数组加入 &lt;equation&gt;n&lt;/equation&gt; 个元素，便要做 &lt;equation&gt;n(n - 1)/2&lt;/equation&gt; 次元素复制，即 &lt;equation&gt;\mathrm{O}(n^2)&lt;/equation&gt; 的时间复杂度。&lt;/p&gt;&lt;p&gt;其中一个改进方法，是使用动态数组（&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_array&quot;&gt;dynamic array&lt;/a&gt;，或称可增长数组／growable array）的数据结构。C++ STL 标准库中最常用的 &lt;code class=&quot;inline&quot;&gt;std::vector&lt;/code&gt; 也是使用这种数据结构的容器。&lt;/p&gt;&lt;p&gt;改动也很简单，只需要在数组中加入容量 &lt;code class=&quot;inline&quot;&gt;capacity&lt;/code&gt; 字段，表示当前已分配的元素数目，而 &lt;code class=&quot;inline&quot;&gt;size&lt;/code&gt; 则表示现时的有效元素数目：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;        /* ... */
        struct { lept_value* e; size_t size, capacity; }a; /* array:  elements, element count, capacity */
        /* ... */&lt;/code&gt;&lt;p&gt;我们终于提供设置数组的函数，而且它可提供初始的容量：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_set_array(lept_value* v, size_t capacity) {
    assert(v != NULL);
    lept_free(v);
    v-&amp;gt;type = LEPT_ARRAY;
    v-&amp;gt;u.a.size = 0;
    v-&amp;gt;u.a.capacity = capacity;
    v-&amp;gt;u.a.e = capacity &amp;gt; 0 ? (lept_value*)malloc(capacity * sizeof(lept_value)) : NULL;
}&lt;/code&gt;&lt;p&gt;我们需要稍修改 &lt;code class=&quot;inline&quot;&gt;lept_parse_array()&lt;/code&gt;，调用 &lt;code class=&quot;inline&quot;&gt;lept_set_array()&lt;/code&gt; 去设置类型和分配空间。&lt;/p&gt;&lt;p&gt;另外，类似于 &lt;code class=&quot;inline&quot;&gt;lept_get_array_size()&lt;/code&gt;，也加入获取当前容量的函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;size_t lept_get_array_capacity(const lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    return v-&amp;gt;u.a.capacity;
}&lt;/code&gt;&lt;p&gt;如果当前的容量不足，我们需要扩大容量，标准库的 &lt;code class=&quot;inline&quot;&gt;realloc()&lt;/code&gt; 可以分配新的内存并把旧的数据拷背过去：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_reserve_array(lept_value* v, size_t capacity) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    if (v-&amp;gt;u.a.capacity &amp;lt; capacity) {
        v-&amp;gt;u.a.capacity = capacity;
        v-&amp;gt;u.a.e = (lept_value*)realloc(v-&amp;gt;u.a.e, capacity * sizeof(lept_value));
    }
}&lt;/code&gt;&lt;p&gt;当数组不需要再修改，可以使用以下的函数，把容量缩小至刚好能放置现有元素：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_shrink_array(lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    if (v-&amp;gt;u.a.capacity &amp;gt; v-&amp;gt;u.a.size) {
        v-&amp;gt;u.a.capacity = v-&amp;gt;u.a.size;
        v-&amp;gt;u.a.e = (lept_value*)realloc(v-&amp;gt;u.a.e, v-&amp;gt;u.a.capacity * sizeof(lept_value));
    }
}&lt;/code&gt;&lt;p&gt;我们不逐一检视每个数组修改函数，仅介绍一下两个例子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value* lept_pushback_array_element(lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    if (v-&amp;gt;u.a.size == v-&amp;gt;u.a.capacity)
        lept_reserve_array(v, v-&amp;gt;u.a.capacity == 0 ? 1 : v-&amp;gt;u.a.capacity * 2);
    lept_init(&amp;amp;v-&amp;gt;u.a.e[v-&amp;gt;u.a.size]);
    return &amp;amp;v-&amp;gt;u.a.e[v-&amp;gt;u.a.size++];
}

void lept_popback_array_element(lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY &amp;amp;&amp;amp; v-&amp;gt;u.a.size &amp;gt; 0);
    lept_free(&amp;amp;v-&amp;gt;u.a.e[--v-&amp;gt;u.a.size]);
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;lept_pushback_array_element()&lt;/code&gt; 在数组末端压入一个元素，返回新的元素指针。如果现有的容量不足，就需要调用 &lt;code class=&quot;inline&quot;&gt;lept_reserve_array()&lt;/code&gt; 扩容。我们现在用了一个最简单的扩容公式：若容量为 0，则分配 1 个元素；其他情况倍增容量。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;lept_popback_array_element()&lt;/code&gt; 则做相反的工作，记得删去的元素需要调用 &lt;code class=&quot;inline&quot;&gt;lept_free()&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;下面这 3 个函数留给读者练习：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;lept_insert_array_element()&lt;/code&gt; 在 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 位置插入一个元素；&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;lept_erase_array_element()&lt;/code&gt; 删去在 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 位置开始共 &lt;code class=&quot;inline&quot;&gt;count&lt;/code&gt; 个元素（不改容量）；&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;lept_clear_array()&lt;/code&gt; 清除所有元素（不改容量）。&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;c&quot;&gt;lept_value* lept_insert_array_element(lept_value* v, size_t index);
void lept_erase_array_element(lept_value* v, size_t index, size_t count);
void lept_clear_array(lept_value* v);&lt;/code&gt;&lt;hr&gt;&lt;h2&gt;5. 动态对象&lt;/h2&gt;&lt;p&gt;动态对象也是采用上述相同的结构，所以直接留给读者修改结构体，并实现以下函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_set_object(lept_value* v, size_t capacity);
size_t lept_get_object_capacity(const lept_value* v);
void lept_reserve_object(lept_value* v, size_t capacity);
void lept_shrink_object(lept_value* v);
void lept_clear_object(lept_value* v);
lept_value* lept_set_object_value(lept_value* v, const char* key, size_t klen);
void lept_remove_object_value(lept_value* v, size_t index);&lt;/code&gt;&lt;p&gt;注意 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 会先搜寻是否存在现有的键，若存在则直接返回该值的指针，不存在时才新增。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;6. 总结与练习&lt;/h2&gt;&lt;p&gt;本单元主要加入了数组和对象的访问、修改方法。当中的赋值又引申了三种赋值的方式（复制、移动、交换）。这些问题是各种编程语言中都需要考虑的事情，为了减少深度复制的成本，有些程序库或运行时还会采用&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD&quot;&gt;写入时复制&lt;/a&gt;（copy-on-write, COW）。而浅复制（shallow copy）则需要 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0&quot;&gt;引用计数&lt;/a&gt;（reference count）或 &lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)&quot;&gt;垃圾回收&lt;/a&gt;（garbage collection, GC）等技术。&lt;/p&gt;&lt;p&gt;另外，我们实现了以动态数组的数据结构，能较高效地对数组和对象进行增删操作。至此，我们已经完成本教程的所有核心功能。做完下面的练习后，我们还会作简单讲解，然后将迎来本教程的最后一个单元。&lt;/p&gt;&lt;p&gt;本单元练习内容：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;完成 &lt;code class=&quot;inline&quot;&gt;lept_is_equal()&lt;/code&gt; 里的对象比较部分。不需要考虑对象内有重复键的情况。&lt;/li&gt;&lt;li&gt;打开 &lt;code class=&quot;inline&quot;&gt;test_array_access()&lt;/code&gt; 里的 &lt;code class=&quot;inline&quot;&gt;#if 0&lt;/code&gt;，实现 &lt;code class=&quot;inline&quot;&gt;lept_insert_array_element()&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;lept_erase_array_element()&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;lept_clear_array()&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;打开 &lt;code class=&quot;inline&quot;&gt;test_object_access()&lt;/code&gt; 里的 &lt;code class=&quot;inline&quot;&gt;#if 0&lt;/code&gt;，参考动态数组，实现第 5 部分列出的所有函数。&lt;/li&gt;&lt;li&gt;完成 &lt;code class=&quot;inline&quot;&gt;lept_copy()&lt;/code&gt; 里的数组和对象的复制部分。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 &lt;a href=&quot;https://github.com/miloyip/json-tutorial/issues&quot;&gt;issue&lt;/a&gt; 中提出，让所有人一起讨论。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-06-04-37618664</guid>
<pubDate>Mon, 04 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何用 C 语言画小猪佩奇</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-05-19-37031514.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37031514&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ff5a359eb78ce2a1da7ee035376ed610_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;我们曾在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30745861&quot;&gt;用 C 语言画光（一）：基础&lt;/a&gt;》中，使用到带符号距离场（signed distance field, SDF）表示圆形：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\phi_\text{circle}(\mathbf{x})=\| \mathbf{x} - \mathbf{c}\| - r\tag{1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;沿用这个方法表示形状，但这次我们想利用 ASCII 字符&lt;code class=&quot;inline&quot;&gt;|/=\&lt;/code&gt;画出形状的外框，并填充内部，类似这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   =====
 //.....\\
||.......||
 \\.....//
   =====&lt;/code&gt;&lt;p&gt;SDF 的梯度（gradient）代表 SDF 变化最大的方向，可用这个方向去决定用哪一个字符。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-86ad876b201bb9bf1309cc1c3a0822a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1340&quot; data-rawheight=&quot;830&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-86ad876b201bb9bf1309cc1c3a0822a0&quot; data-watermark-src=&quot;v2-ee44f61ebefd2f643693ff57d1bd8eee&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们通过&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%88%86&quot;&gt;差分&lt;/a&gt;求 SDF 的梯度近似值，然后用 &lt;code class=&quot;inline&quot;&gt;atan2()&lt;/code&gt; 求出梯度的角度：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} \theta &amp;amp;= \mathrm{atan2} \left(\frac{\partial \phi(\mathbf{x})}{\partial y}, \frac{\partial \phi(\mathbf{x})}{\partial x} \right) \tag{2}\\ &amp;amp;\approx \mathrm{atan2} \left(\phi(x,y+\Delta) - \phi(x,y-\Delta), \phi(x+\Delta,y) - \phi(x-\Delta,y)\right) \tag{3}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;用 C 语言简单实现，在 &lt;equation&gt;[-1, 1]\times[-1,1]&lt;/equation&gt; 画布中画一个半径 0.8 并带有 0.1 寛度外框的圆形：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;math.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#define T double

T f(T x, T y) {
    return sqrt(x * x + y * y) - 0.8f;
}

char outline(T x, T y) {
    T delta = 0.001;
    if (fabs(f(x, y)) &amp;lt; 0.05) {
        T dx = f(x + delta, y) - f(x - delta, y);
        T dy = f(x, y + delta) - f(x, y - delta);
        return &quot;|/=\\|/=\\|&quot;[(int)((atan2(dy, dx) / 6.2831853072 + 0.5) * 8 + 0.5)];
    }
    else if (f(x, y) &amp;lt; 0)
        return &#39;.&#39;;
    else
        return &#39; &#39;;
}

int main() {
    for (T y = -1; y &amp;lt; 1; y += 0.05, putchar(&#39;\n&#39;))
        for (T x = -1; x &amp;lt; 1; x += 0.025)
            putchar(outline(x, y));
}&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2389220aa8dc0f9658208817d02d8bc0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;856&quot; data-rawheight=&quot;798&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2389220aa8dc0f9658208817d02d8bc0&quot; data-watermark-src=&quot;v2-3d7249bd69aad46ffd4e1fc3bdeff6b0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;然后，我们就可以画多个圆形，把它们适当地旋转和缩放，用&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30748318&quot;&gt;构造实体几何&lt;/a&gt;比它们组合起来，那么用19行代码就可以画出小猪佩奇了：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;// ASCII Peppa Pig by Milo Yip
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#define T double
T c(T x,T y,T r){return sqrt(x*x+y*y)-r;}
T u(T x,T y,T t){return x*cos(t)+y*sin(t);}
T v(T x,T y,T t){return y*cos(t)-x*sin(t);}
T fa(T x,T y){return fmin(c(x,y,0.5),c(x*0.47+0.15,y+0.25,0.3));}
T no(T x,T y){return c(x*1.2+0.97,y+0.25,0.2);}
T nh(T x,T y){return fmin(c(x+0.9,y+0.25,0.03),c(x+0.75,y+0.25,0.03));}
T ea(T x,T y){return fmin(c(x*1.7+0.3,y+0.7,0.15),c(u(x,y,0.25)*1.7,v(x,y,0.25)+0.65,0.15));}
T ey(T x,T y){return fmin(c(x+0.4,y+0.35,0.1),c(x+0.15,y+0.35,0.1));}
T pu(T x,T y){return fmin(c(x+0.38,y+0.33,0.03),c(x+0.13,y+0.33,0.03));}
T fr(T x,T y){return c(x*1.1-0.3,y+0.1,0.15);}
T mo(T x,T y){return fmax(c(x+0.15,y-0.05,0.2),-c(x+0.15,y,0.25));}
T o(T x,T y,T(*f)(T,T),T i){T r=f(x,y);return fabs(r)&amp;lt;0.02?(atan2(f(x,y+1e-3)-r,f(x+1e-3,y)-r)+0.3)*1.273+6.5:r&amp;lt;0?i:0;}
T s(T x,T y,T(*f)(T,T),T i){return f(x,y)&amp;lt;0?i:0;}
T f(T x,T y){return o(x,y,no,1)?fmax(o(x,y,no,1),s(x,y,nh,12)):fmax(o(x,y,fa,1),fmax(o(x,y,ey,11),fmax(o(x,y,ea,1),fmax(o(x,y,mo,1),fmax(s(x,y,fr,13),s(x,y,pu,12))))));}
int main(int a,char**b){for(T y=-1,s=a&amp;gt;1?strtod(b[1],0):1;y&amp;lt;0.6;y+=0.05/s,putchar(&#39;\n&#39;))for(T x=-1;x&amp;lt;0.6;x+=0.025/s)putchar(&quot; .|/=\\|/=\\| @!&quot;[(int)f(u(x,y,0.3),v(x,y,0.3))]);}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-31638f949e3a92e6f0bbf345bfb94f6e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;660&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-31638f949e3a92e6f0bbf345bfb94f6e&quot; data-watermark-src=&quot;v2-64070d0e4c7b0c8040f6527a47ff0bfb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;2倍：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-64060e12365c0667d3c69d8cf87ca2aa_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1334&quot; data-rawheight=&quot;1306&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-64060e12365c0667d3c69d8cf87ca2aa&quot; data-watermark-src=&quot;v2-27d5d9e7d76ea331f803f0ef42fc7fa6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;4 倍：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-76b9b97233b9a35332a8a44c7828474d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1070&quot; data-rawheight=&quot;1044&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-76b9b97233b9a35332a8a44c7828474d&quot; data-watermark-src=&quot;v2-b784a78e92973aa49f5a45c5eadf883b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;8 倍：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c7087e6e76862c7379dee7a68856a2a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2184&quot; data-rawheight=&quot;1800&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c7087e6e76862c7379dee7a68856a2a0&quot; data-watermark-src=&quot;v2-8d18514a07ad93aad74ba25fa52ae9ee&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;blockquote&gt;今天也是精致的猪猪女孩～&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-05-19-37031514</guid>
<pubDate>Sat, 19 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Milo的知乎2017</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-01-01-32521954.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32521954&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-81c07ee78170e087a12805873c62e3e2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;2017年为了改善自己的身体状况，在知乎&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25493253&quot;&gt;休息&lt;/a&gt;了一段时间，所以今年投入创作的时间减少了。另外，本年有幸获得知乎盐 Club 荣誉会员（获 3568 票）。&lt;/p&gt;&lt;p&gt;按2018元旦的累积数字和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24664465&quot;&gt;去年&lt;/a&gt;对比，得到以下数据，括号内的为累积总数（自 2011 年）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;回答了 277 个问题（1474）&lt;/li&gt;&lt;li&gt;发布了 19 篇文章（51）&lt;/li&gt;&lt;li&gt;发布了 41 个想法（41）&lt;/li&gt;&lt;li&gt;获 68919 个赞同（197509）&lt;/li&gt;&lt;li&gt;获 6233 个感谢（28570）&lt;/li&gt;&lt;li&gt;获 43949 次收藏（131802）&lt;/li&gt;&lt;li&gt;获 43979 人关注（125095）&lt;/li&gt;&lt;li&gt;获 436.47 元（2309.33）&lt;/li&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f763464f917228f0387bf4ea4c526d21_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;742&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-558b4db991dc6aab99df5536b1d881b6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;742&quot;&gt;&lt;p&gt;感谢各位支持，2018 年继续努力（填坑）。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-01-01-32521954</guid>
<pubDate>Mon, 01 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>《写生机器人》制作经验分享（上）</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-12-26-32084037.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32084037&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2227224aab303f50deea51da1e4ff436_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;我在《&lt;a href=&quot;https://www.zhihu.com/question/263477736/answer/269707887&quot; class=&quot;internal&quot;&gt;对编程感兴趣的程序员是否都对电路、单片机也怀有浓厚的兴趣？ &lt;/a&gt;》展示了前两年制作的一个写生机器人，不少网友表示感兴趣，故撰本文回顾制作历程及感悟。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 起源&lt;/h2&gt;&lt;p&gt;在 2014 年，当时我已经开发&lt;b&gt;软件&lt;/b&gt;算有二十多年（第一个主导的商业游戏项目《王子传奇》在1995年台湾发行）。然而，除了懂得一些简单的、中学物理课学到的电子知识，从来没接触过&lt;b&gt;硬件&lt;/b&gt;开发。和读计算机相关专业的朋友不一样，我本科读的是认知科学（cognitive science，在香港大学属社会科学院），完全没有硬件方面的课。&lt;/p&gt;&lt;p&gt;因此，那个时候想学习一下硬件开发，扩阔视野。&lt;/p&gt;&lt;p&gt;最初，我在网上买了一套一百多块的 Arduino 入门套装，按着 [1] 的例子学习，如控制 LED／7段 LED、处理按钮／电位器输入、控制电机／舵机等。有赖 Arduino 团队的努力，开发环境和 API 都十分简单易用，熟悉 C/C++的程序员可轻松入门。&lt;/p&gt;&lt;p&gt;但经验告诉我，&lt;/p&gt;&lt;blockquote&gt;要提升一门技术的水平，最好是从做一个项目中学习。&lt;/blockquote&gt;&lt;p&gt;当时，我工作的部门（腾讯／IEG 互动娱乐事业群／研发部）正宣传举办第一届的《Intel杯创新大赛》，让IEG 同事创作作品，范围包括智能硬件、VR／AR 等，每年举办两次。我便鼓起勇气参加了。那么，做什么好呢？&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 构思&lt;/h2&gt;&lt;p&gt;我先考虑自己懂什么，以及想做些什么。&lt;/p&gt;&lt;p&gt;最后的构思源于以下的经历：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;本科专业是&lt;b&gt;认知科学&lt;/b&gt;，研究信息如何在大脑中形成及转录过程的跨领域学科；&lt;/li&gt;&lt;li&gt;对计算机图形学比较了解，有幸成为知乎计算机图形学的优秀回答者；&lt;/li&gt;&lt;li&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23725230&quot; class=&quot;internal&quot;&gt;程序员可以学画画吗？ &lt;/a&gt;》提及我在业余学过基本&lt;b&gt;素描&lt;/b&gt;和&lt;b&gt;油画&lt;/b&gt;；&lt;/li&gt;&lt;li&gt;我想做一些&lt;b&gt;会动&lt;/b&gt;的东西，因为以前做的软件，即使有动画及互动内容，都是困于屏幕之中。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我曾在 YouTube 看过一个绘画机器人的艺术项目 [2]，我觉得和我上述的经历吻合，引发了一些思考。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img data-rawheight=&quot;350&quot; src=&quot;https://pic1.zhimg.com/v2-081992f24b7efbe42c1fffb82dc8339c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;700&quot; data-original=&quot;https://pic1.zhimg.com/v2-081992f24b7efbe42c1fffb82dc8339c_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img data-rawheight=&quot;350&quot; src=&quot;https://pic1.zhimg.com/v2-081992f24b7efbe42c1fffb82dc8339c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;700&quot; data-original=&quot;https://pic1.zhimg.com/v2-081992f24b7efbe42c1fffb82dc8339c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-081992f24b7efbe42c1fffb82dc8339c_b.jpg&quot;&gt;&lt;figcaption&gt;Portrait drawing by Paul the robot [2]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我以前学画的时候，也会想一些问题，也和老师讨论过。&lt;/p&gt;&lt;p&gt;绘画是越写实越好么？不是。要写实的话，摄影更写实。绘画和摄影有相似的地方，但不能互相取代。&lt;/p&gt;&lt;p&gt;绘画（以下主要指写生）和摄影的主要区别是什么？画家在构图后，还可以选择要表达的重点。另外，写生是一个较长期的渐进过程，从整体粗略至局部细致，过程中不断观察比对画作和对象。这和摄影通常一次曝光（通常是几十分之一秒），然后显影很不一样。&lt;/p&gt;&lt;p&gt;也因此，同一对象、同一灯光、同一构图下，即使不同的摄影师也几乎得到相同的作品。而画家则会因当时对对象的不同观察和想法、不同的手法表现，得出独一无二的作品。这也许存在争议，纯粹是个人的一个想法。&lt;/p&gt;&lt;p&gt;我当时想到，如果要做一个机器人模仿人类进行写生，要怎么做才可以重现出这种区别，创作出独一无二的作品，而不只是用相机拍下然后打印？我想到 3 点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;模仿人的&lt;b&gt;多关节肢体&lt;/b&gt;，使用真实绘画素材（如铅笔、走珠笔、绘图笔、秀丽笔、油漆笔），而非用打印机。虽然用 XY plotter 也可用上绘画素材，但完全不像人的手。&lt;/li&gt;&lt;li&gt;模仿人的&lt;b&gt;视觉系统&lt;/b&gt;，可以持续观察写生对象及当前的画作，进行对比。&lt;/li&gt;&lt;li&gt;模仿人的&lt;b&gt;渐进写生过程&lt;/b&gt;，而非完全的机械式输入处理输出。而且，对象可能会随时间改变（如人像、风景），作品可包含这些时间的变化。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我没怎么想商业价值，觉得这个机器人更像是一个互动的装置艺术。我希望每张作品都是独一无二的艺术品。&lt;/p&gt;&lt;p&gt;记得以前读认知科学时，要评估一些认知能力模型是否好，其中一个方法是用计算机去模拟出来，看看能否模仿生物的那些能力。所以从研究的角度来说，这个项目也许涉及艺术风格的模仿及研究。&lt;/p&gt;&lt;p&gt;不过，我并没有把上述的所有构思都实现。基于时间和能力所限，只是做一个非常简化的版本。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 设计&lt;/h2&gt;&lt;p&gt;如果只做算法部分，或可购买现成的机器臂，或是组装现成的套件。但我没学过机械设计，希望借这个项目尝试一下。&lt;/p&gt;&lt;p&gt;当时常见到的玩具机器人和机器臂，一般都使用舵机（摇控模型的直流伺服电机／RC servo）作为致动器（actuator），而 [1] 的机器臂也是用这种构造。这种机器臂构造简单，控制也容易（用 PWM 信号控制目标角度），但缺点也是很明显的，角度不够精确，也难以控制转动的速度，画出来的作品抖动明显。&lt;/p&gt;&lt;p&gt;我从 [3] 学习到一些致动器原理及传动系统，似乎步进电机（stepper motor）是更好的选择，可以用一个脉冲控制电机旋转一个很小的角度。那么我可以用编程的方法，精准地控制旋转速度。&lt;/p&gt;&lt;p&gt;我没有读机器臂相关的书，只是从需求去设计：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;画在 A3 大小的纸张。一般的玩具机器臂没有这么大的移动范围。&lt;/li&gt;&lt;li&gt;容易制作。因为没有技术、设备。&lt;/li&gt;&lt;li&gt;成本比较低。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我想，最简单需要一个水平二维移动的手，再加上一个垂直移动的持笔装置。二维移动需要至少两个自由度（degree of freedom, DOF），加上垂直移动共 3 个 DOF。那么，需要模拟上臂、下臂和手三部分。&lt;/p&gt;&lt;p&gt;构造上，最简单的是把电机放到关节上，但步进电机一般比舵机重，而机器臂也要足够长，会不会太重？太重有两个问题：上臂的关节要承受因重力而生的大力矩，底座要很重才能平衡。&lt;/p&gt;&lt;p&gt;因此，我想到的方案是把电机都放在底座，通过带子传动。后来知道这些构件称为同步轮（synchornized wheel）和同步带（synchronized belt）。我想到这个设计还有 4 个好处：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;手臂不用放置电机，使手臂轻很多，旋转两个关节所需的力矩变小。&lt;/li&gt;&lt;li&gt;上臂的关节不用直接使用步进电机的输出轴，而可以用上更粗、更坚固的轴，令系统更强健。&lt;/li&gt;&lt;li&gt;系统中最重的部件（步进电机）位于底座，而且可放在手臂的另一端，令重心接近第一关节，更稳定。&lt;/li&gt;&lt;li&gt;采用不同大小的同步轮，可作进一步减速，提升精确性。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;要做设计，首先要知道有什么零件可以使用。我在网上找寻合适的零件，包括电机、传动和结构上的。我发现最平宜的结构是用板材配合立柱，用螺丝紧固。&lt;/p&gt;&lt;p&gt;然后绘画各部分的草图：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img data-rawheight=&quot;957&quot; src=&quot;https://pic2.zhimg.com/v2-ae3cb7ce87c60d0fb7bff6cd891ef455_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1481&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1481&quot; data-original=&quot;https://pic2.zhimg.com/v2-ae3cb7ce87c60d0fb7bff6cd891ef455_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img data-rawheight=&quot;957&quot; src=&quot;https://pic2.zhimg.com/v2-ae3cb7ce87c60d0fb7bff6cd891ef455_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1481&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1481&quot; data-original=&quot;https://pic2.zhimg.com/v2-ae3cb7ce87c60d0fb7bff6cd891ef455_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ae3cb7ce87c60d0fb7bff6cd891ef455_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;我最不了解的是各种轴承（bearing），没想到会这样复杂，不确定是否需要这么多轴承。设计时要匹配各种轴承的尺寸，我通过不断搜寻轴承目录，试各种尺寸的组合，才得出设计方案。同步轮也有同样问题，设计都是要配合现成能买到的规格。&lt;/p&gt;&lt;p&gt;另外，垂直移动的持笔装置也是设计的难点。我看到一些持笔装置是用舵机的，感觉不能很精确控制高度，而且持笔不够稳固。如果要用秀丽笔控制高度来画不同粗细，最好还是精确一点。最后我的方案是用直线轴承，轴承中放置铝管，铝管中固定笔枝，再配合小型的直线步进电机。直线步进电机常见于光驱，控制激光的轨道位置，可以非常精确。因为笔支不重，细小的直线步进电机已经足够，而且它的控制也和其他步进电机一样简单。&lt;/p&gt;&lt;p&gt;我没学过机械制图，只有 3dsMax、SketchUp的使用经验。我找了一下流行的相关设计软件，最后下载了 SolidWorks 的试用版本来学习。 SolidWorks 确实是十分容易使用，我花了两周左右（如没记错）的工余时间便学习并画出以下的设计图和渲染圖：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img data-rawheight=&quot;842&quot; src=&quot;https://pic3.zhimg.com/v2-6c7a05acb0fb621319f1d8a36835b4ba_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1191&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1191&quot; data-original=&quot;https://pic3.zhimg.com/v2-6c7a05acb0fb621319f1d8a36835b4ba_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img data-rawheight=&quot;842&quot; src=&quot;https://pic3.zhimg.com/v2-6c7a05acb0fb621319f1d8a36835b4ba_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1191&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1191&quot; data-original=&quot;https://pic3.zhimg.com/v2-6c7a05acb0fb621319f1d8a36835b4ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6c7a05acb0fb621319f1d8a36835b4ba_b.jpg&quot;&gt;&lt;/figure&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img data-rawheight=&quot;511&quot; src=&quot;https://pic4.zhimg.com/v2-27040ae6596d492ea5a1b1a8cc3ff41f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;960&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;960&quot; data-original=&quot;https://pic4.zhimg.com/v2-27040ae6596d492ea5a1b1a8cc3ff41f_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img data-rawheight=&quot;511&quot; src=&quot;https://pic4.zhimg.com/v2-27040ae6596d492ea5a1b1a8cc3ff41f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;960&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;960&quot; data-original=&quot;https://pic4.zhimg.com/v2-27040ae6596d492ea5a1b1a8cc3ff41f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-27040ae6596d492ea5a1b1a8cc3ff41f_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;不过，我还是不太了解 SolidWorks 的约束系统，第一次画图应该有很多问题。而设计时，很多数值（例如光轴要多粗的、板材要多厚的、电机要多大力矩的）我也没有深究，应该都是高于实际的要求。我并没有做力学方面的模拟，做了的话应该可以再降低成本。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;4. 机器臂制作&lt;/h2&gt;&lt;p&gt;我在网上找公司按图切割铝合金板，并购买所有的部件。制作中还需要一些工序，所以后来也购买了电钻床和夹钳等工具。&lt;/p&gt;&lt;p&gt;如同模型一样，组装这个机器臂是很好玩的环节。在设计时，我并没有很在意组装次序，所以组装时发现确实是有点难度，试过错放漏放部件，要拆掉重来。&lt;/p&gt;&lt;p&gt;持笔的铝管需要固定笔枝，我采用的是在管铝上攻丝，这样也方便更换笔枝。第一次手工攻丝还是觉得有点难度，记得做了两枝铝管才成功。&lt;/p&gt;&lt;p&gt;主要部分完成组装后，就接上电机控制器和 Arduino 去测试。非常成功地旋转了！但是⋯⋯同步带不够紧！&lt;/p&gt;&lt;p&gt;当初设计时，我参考了一个网站，按同步带类型／长度、同步轮半径去计算轴距的长度。然而，没想到最后还是有点松。看了一些其他用同步带的设计，原来都要加一个可调的滑轮去控制松紧！没辨法之下，我要拆开部件钻孔，买立柱和轴承作为滑轮。&lt;/p&gt;&lt;p&gt;而且！我设计时没考虑到怎样检测手臂复位！我买的是没有角度回馈的步进电机，在开始时需要把手臂转到一个初始角度做复位。我唯有临时加上了两个微动开关去检测手臂是否到达初始角度。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img data-rawheight=&quot;529&quot; src=&quot;https://pic2.zhimg.com/v2-043ccd20bdd3e9b64544e6b00974de21_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;919&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;919&quot; data-original=&quot;https://pic2.zhimg.com/v2-043ccd20bdd3e9b64544e6b00974de21_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img data-rawheight=&quot;529&quot; src=&quot;https://pic2.zhimg.com/v2-043ccd20bdd3e9b64544e6b00974de21_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;919&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;919&quot; data-original=&quot;https://pic2.zhimg.com/v2-043ccd20bdd3e9b64544e6b00974de21_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-043ccd20bdd3e9b64544e6b00974de21_b.jpg&quot;&gt;&lt;figcaption&gt;红圈中的是后来加入的滑轮，黄圈中的是后来加入的微动开关&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这两个失误说明，经验还是很重要的。不过，第一次做这方面的设计，能正常地动起来，我已经很满足了。而且整个手臂很坚固，旋转也很顺滑细致，单凭想像力去做的设计还算不错吧。&lt;/p&gt;&lt;p&gt;经过简单测试（用固定频率旋转两个轴），设置步进电机驱动器使用16 微步进（micro stepping）模式没什么问题，能实现两个关节 旋转，最高 末端精度（距离底座半径越大精度越低）。这样已经足够了，编程随便画些东西！&lt;/p&gt;&lt;p&gt;很久以后我发图出来，才有网友说这不是&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/SCARA&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SCARA&lt;/a&gt;嘛。啊？我真不知道。如果有导师指导应该会好很多，不过胡猜瞎试也是另一种乐趣。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img data-rawheight=&quot;900&quot; src=&quot;https://pic3.zhimg.com/v2-cbd5c076959cc92f741cd552df2e364e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1188&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1188&quot; data-original=&quot;https://pic3.zhimg.com/v2-cbd5c076959cc92f741cd552df2e364e_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img data-rawheight=&quot;900&quot; src=&quot;https://pic3.zhimg.com/v2-cbd5c076959cc92f741cd552df2e364e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1188&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1188&quot; data-original=&quot;https://pic3.zhimg.com/v2-cbd5c076959cc92f741cd552df2e364e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-cbd5c076959cc92f741cd552df2e364e_b.jpg&quot;&gt;&lt;figcaption&gt;三菱的SCARA机器臂&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr&gt;&lt;h2&gt;5. 绘画直线算法&lt;/h2&gt;&lt;p&gt;除了画点以外，最简单的图形应该是直线。我比较熟悉在光栅图像里画线的方法，最近也写过一篇《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30553006&quot; class=&quot;internal&quot;&gt;用 C 语言画直线&lt;/a&gt;》。然而，Bresenham 画线算法源于控制 XY plotter，不能用在旋转关节。&lt;/p&gt;&lt;p&gt;设计机械臂硬件的时候，我也没有仔细去想怎样编程，心想：「应该没什么问题吧，到时再想。」&lt;/p&gt;&lt;p&gt;我不但没学过机械设计，也没学过控制。在图形学中学过逆向运动学（inverse kinematics），可以把目标的世界坐标转换成关节的角度。但似乎不行，我不知道世界坐标中应该步进多长的距离，两个旋转角度又怎样用多个单步、什么频率？&lt;/p&gt;&lt;p&gt;这次我也没有直接去找相关专著找答案。我觉得这应该不会是十分困难的问题，我尝试自行想个算法解决。&lt;/p&gt;&lt;p&gt;分析一下，先不考虑频率，我们每个离散步只能有 8 种输出：每个轴顺时针步进／逆时针步进／待机，但不会两个轴同时待机， &lt;img src=&quot;https://www.zhihu.com/equation?tex=3%5E2-1%3D+8&quot; alt=&quot;3^2-1= 8&quot; eeimg=&quot;1&quot;&gt;  。那么，我们可以分别对 8 种输出，计算出旋转后的末端世界坐标。然后，找出向直线方向移动（不应回头）而又最接近直线的一种输出！&lt;/p&gt;&lt;p&gt;我实验用这个算法，画各种角度的直线、正方形，效果也不错！ ⋯⋯但是有点抖。&lt;/p&gt;&lt;p&gt;这是因为，每次移动的距离是不一样的，但我都只是简单地延迟相同的间隔，所以直线上的移动速度并不平均。这并不难解决，只要按该步的欧氏距离及目标速度，就能计算出该步的延迟时间。实验也成功显示这样会减少抖动。&lt;/p&gt;&lt;p&gt;还有一个问题，就是开始和结束的时候的抖动。这是因为我们开始时从静止突然加速到目标速度，结束时则相反。解决方法是引入线性加速度，让笔从慢至快、快至慢地移动。以下实际上是第二届比赛前录制的视频，但能演示画直线的动作：&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.zhihu.com/video/928749126110298112&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic4.zhimg.com/80/v2-d6990bd74059cc4e09d585c492cb2377_b.jpg&quot; data-lens-id=&quot;928749126110298112&quot;&gt;              &lt;img class=&quot;thumbnail&quot; src=&quot;https://pic4.zhimg.com/80/v2-d6990bd74059cc4e09d585c492cb2377_b.jpg&quot;&gt;              &lt;span class=&quot;content&quot;&gt;                &lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;                &lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/928749126110298112&lt;/span&gt;              &lt;/span&gt;            &lt;/a&gt;            &lt;hr&gt;&lt;h2&gt;6. 第一届Intel杯创新大赛&lt;/h2&gt;&lt;p&gt;因为当时已接近第一届的比赛日子，我决定这一届只提交机器臂的部分。我继续写了个简单的 SVG 解析器，把 Bezier 曲线分割成线段绘画。下面是画一幅 SVG 的过程片段：&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.zhihu.com/video/928757235193114624&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic4.zhimg.com/80/v2-8c617f47adaa140b990c8a0388f24157_b.jpg&quot; data-lens-id=&quot;928757235193114624&quot;&gt;              &lt;img class=&quot;thumbnail&quot; src=&quot;https://pic4.zhimg.com/80/v2-8c617f47adaa140b990c8a0388f24157_b.jpg&quot;&gt;              &lt;span class=&quot;content&quot;&gt;                &lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;                &lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/928757235193114624&lt;/span&gt;              &lt;/span&gt;            &lt;/a&gt;            &lt;p&gt;最后做 presentation、演讲、即场演示，赢得第一届Intel杯创新大赛一等奖！&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img data-rawheight=&quot;744&quot; src=&quot;https://pic4.zhimg.com/v2-db8105ef03e5673b895b2a5c504efc67_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1062&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1062&quot; data-original=&quot;https://pic4.zhimg.com/v2-db8105ef03e5673b895b2a5c504efc67_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img data-rawheight=&quot;744&quot; src=&quot;https://pic4.zhimg.com/v2-db8105ef03e5673b895b2a5c504efc67_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1062&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1062&quot; data-original=&quot;https://pic4.zhimg.com/v2-db8105ef03e5673b895b2a5c504efc67_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-db8105ef03e5673b895b2a5c504efc67_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;从最初构想至第一届创新大赛比赛日大约历时一年，但实际上有很多个月都没有搞，估计大约花了三个月左右的工余时间。由于工具和硬件都在公司，而我晚上又坐班车回家，所以除了设计阶段在家里进行，其他都是用午饭时间搞的。&lt;/p&gt;&lt;p&gt;此阶段的制作成本（不包括工具）一览：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Blr%7D+%E9%83%A8%E4%BB%B6+%26+%5Ctext%7BRMB%7D%5C%5C+%5Chline+%5Ctext%7B7075%E9%93%9D%E5%90%88%E9%87%913mm%E6%9D%BF%E6%9D%90%E5%8F%8A%E5%88%87%E5%89%B2%7D+%26+217%5C%5C+%E9%93%9D%E5%90%88%E9%87%91%E6%94%AF%E6%9F%B1%E5%8F%8A%E7%B4%A7%E5%9B%BA%E4%BB%B6+%26+100%5C%5C+42%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%5Ctimes+2%E3%80%81%E5%85%89%E9%A9%B1%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E5%8F%8A%E9%A9%B1%E5%8A%A8+%26+170%5C%5C+%E5%90%8C%E6%AD%A5%E8%BD%AE%E5%8F%8A%E5%90%8C%E6%AD%A5%E5%B8%A6+%26+160%5C%5C+%E9%93%AC%E9%95%80%E8%BD%B4%E5%85%89%E8%BD%B4%E5%8F%8A%E8%BD%B4%E6%89%BF+%26+30%5C%5C+%5Ctext%7BArduino+Mega%7D+%26+34%5C%5C+%5Chline+%E5%90%88%E8%AE%A1+%26+711%5C%5C+%5Cend%7Barray%7D%5C%5C&quot; alt=&quot;\begin{array}{lr} 部件 &amp;amp; \text{RMB}\\ \hline \text{7075铝合金3mm板材及切割} &amp;amp; 217\\ 铝合金支柱及紧固件 &amp;amp; 100\\ 42步进电机\times 2、光驱步进电机及驱动 &amp;amp; 170\\ 同步轮及同步带 &amp;amp; 160\\ 铬镀轴光轴及轴承 &amp;amp; 30\\ \text{Arduino Mega} &amp;amp; 34\\ \hline 合计 &amp;amp; 711\\ \end{array}\\&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;下篇讲述继续参加第二届创新大赛，加入 Intel RealSense 和实现素描算法，以及对这个项目的感悟。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] McRoberts, Michael, Brad Levy, and Cliff Wootton. &lt;i&gt;Beginning Arduino&lt;/i&gt;. New York.: Apress, 2010.《Arduino从基础到实践》，杨继志、郭敬译，电子工业出版社，2013。（已有中文版第二版）&lt;/p&gt;&lt;p&gt;[2] Tresset, Patrick, and Frederic Fol Leymarie. &quot;Portrait drawing by Paul the robot.&quot; Computers &amp;amp; Graphics 37.5 (2013): 348-363.&lt;/p&gt;&lt;p&gt;[3] Roberts, Dustyn. &lt;i&gt;Making Things Move DIY Mechanisms for Inventors, Hobbyists, and Artists&lt;/i&gt;. McGraw Hill Professional, 2010. 《Maker机械电子创意实现与项目制作》，郭洪红译， 科学出版社，2013。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-12-26-32084037</guid>
<pubDate>Tue, 26 Dec 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
