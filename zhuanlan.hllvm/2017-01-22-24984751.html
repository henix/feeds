<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>最快的JS编译器: BuckleScript</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/24984751">原文</a></p>
昨天Hacker News 上在讨论<a href="https://github.com/bloomberg/bucklescript/" data-editable="true" data-title="BuckleScript">BuckleScript</a>, 因为博客在墙外 所以我把它贴过来。<a href="https://github.com/bloomberg/bucklescript/" data-editable="true" data-title="BuckleScript">BuckleScript</a> 上已经在一些公司生产线上好几个月了 昨天Facebook的朋友告诉我他们 messenger.com 使用BuckleScript一个季度了， 唯一的一个线上bug 还是因为自己定义JS类型接口的时候把int32 和 float 弄混了， 他们也会马上发布最新的React 到Reason &amp; BuckleScript 的绑定. 值得一提的是Facebook Reason组里面两个核心成员一个是ReactJS和React Native 的发明者，另一个核心成员是一个加拿大华裔，希望下一波web技术潮流能够有华人来引领 : )<p>源地址在这里 <a href="http://yawar.blogspot.fr/2017/01/bucklescript-significant-new-ocaml-to.html" data-editable="true" data-title="yawar.blogspot.fr 的页面">http://yawar.blogspot.fr/2017/01/bucklescript-significant-new-ocaml-to.html</a><br>Hacker News 上的讨论 <a href="https://news.ycombinator.com/item?id=13448769" data-editable="true" data-title="BuckleScript: write JavaScript faster, safer and smaller">BuckleScript: write JavaScript faster, safer and smaller</a></p><h3><a href="http://yawar.blogspot.fr/2017/01/bucklescript-significant-new-ocaml-to.html" data-editable="true" data-title="BuckleScript: a significant new OCaml to JavaScript compiler">BuckleScript: a significant new OCaml to JavaScript compiler</a></h3><p>RECENTLY I've been paying attention to the <a href="https://bloomberg.github.io/bucklescript/" data-editable="true" data-title="BuckleScript">BuckleScript</a> compiler from OCaml to JavaScript (ES5, to be exact). I'm seeing some significant advances that it brings to the state of the art, and thought I would share.</p><p>A little background: I use Scala.js at work, and it is rock-solid. Once you're set up with a project, you are pretty much good to go. Bindings to significant JS libraries are high-quality; I use some of the biggest names in JS frontend dev libraries today, and all in a nice Scala-style object-functional layer.</p><p>That aside, I still periodically look around the ecosystem and try to evaluate the latest developments. I've been hearing about BuckleScript for a while, but only recently decided to try it out for a side project after trying and failing to understand how this works in JavaScript.</p><p>So, without further ceremony, let me present my findings.</p><p>BuckleScript's compiler is <b><em>insanely</em> fast</b>, because Bob Zhang (the project lead) has taken to heart the OCaml obsession with performance and routinely tries to optimise away millisecond-level delays. Once you get a taste of that speed (entire project compiled faster than you can blink), you'll find it difficult to go back to something slower. It's like getting to use git after you've used svn all your life.</p><p>It compiles to idiomatic, <i><b>readable ES5,</b></i> with nice indentation, (almost) no name mangling, and a one-to-one mapping from OCaml modules to ES modules (whichever kind you prefer: Require, AMD, Google).</p><p>It targets and integrates with the existing npm ecosystem; it doesn't try to introduce yet another package manager. It makes writing bindings (types) for existing JS libraries reasonably easy, and the documentation (the <a href="http://bloomberg.github.io/bucklescript/Manual.html" data-editable="true" data-title="manual">manual</a>especially) is fantastic at guiding you through that.</p><p>OCaml is a bit of an odd duck syntax-wise, even among the functional programming languages. There are nuances to get used to. But once you get used to them, it is a pleasure to program in. And if you just can't get used to them, you can always try out Facebook's <a href="http://facebook.github.io/reason/" data-editable="true" data-title="Reason">Reason</a>, which is an alternative, JavaScript-lookalike syntax for OCaml.</p><p>This focus on integration and ease of reuse of the JavaScript ecosystem means it's feasible to leverage the npm package collection in your pure OCaml project. You can deploy a backend server which performs core functions as a statically compiled, native binary (i.e. not nodejs); deploy ES5 nodejs services which take advantage of specialised npm packages for MSSQL querying, or SOAP clients, or what have you; and you can deploy ES5 in your frontend webapp scripts, all written in pure OCaml.</p><p>So, why OCaml specifically? After all, there are plenty of nice languages out there.</p><p>As it turns out, that OCaml obsession with speed <em>and</em> type-safety together serve it well here. It's a pragmatic, simple, and matter-of-fact language, and its runtime model maps very well to the JavaScript runtime model, while also preserving important compile-time safety guarantees.</p><p>I should emphasise that it's <em>pragmatic</em>: you're not forced to deal with the added mental load of monads and other type system rabbit holes--but they're all available if you need them! Personally, I feel that laziness, purity, and monads have driven away more people than they've attracted. I think that OCaml gets the balance right. Others obviously feel differently. But in concrete terms, BuckleScript is a significant contribution that shouldn't be missed.</p><br><p>If you've developed in a compiled language for any length of time and like type-safety guarantees, after trying BuckleScript you'll be asking yourself how much time you've wasted over the years waiting for your compiler to finish so you can continue your edit-compile cycle. Maybe it's best not to think too much about that.</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
