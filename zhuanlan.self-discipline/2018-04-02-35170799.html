<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>语言背后的代数学（六）：Henkin模型</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/35170799">原文</a></p>
<p></p><img src="https://pic3.zhimg.com/v2-0d34436db4471d65a5d0bd535cc42880_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="698" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><h2><b>回顾</b></h2><p>为了解释简单类型化演算 <equation>\lambda^\to</equation> 中项，我们介绍了<b><equation>\Sigma</equation> 代数</b>，<br>用 <equation>\Sigma</equation> 代数中的载体 <equation>A^\sigma</equation> 来解释基本类型 <equation>\sigma</equation> ，<br>用载体上的函数集 <equation>A^{\sigma\to\tau}=\{f|f:A^\sigma\to A^\tau\}</equation> 来解释类型为 <equation>\sigma\to\tau</equation> 的所有函数。</p><p>但只是做这些对应关系，还是不够的，<br>我们还得证明，这样的解释是“足够多的”，<br>以保证每一个合法 <equation>\lambda^\to</equation> 项的解释，都在这个 <equation>\Sigma</equation> 代数中。</p><p>尤其是使用集合上的函数，来解释具有不动点的 <equation>\lambda</equation> 项时，<br> <equation>A^{\sigma\to\tau}</equation> 的条件应当适当放宽一些，它不一定恰好是函数集 <equation>\{f|f:A^\sigma\to A^\tau\}</equation> 。<br>为此我们需要更抽象的，从语义角度定义函数是如何作用到它的参数上的。</p><h2><b>1. 作用结构</b></h2><img src="https://pic4.zhimg.com/v2-11930d7968530bedf2390866ed737269_r.jpg" data-caption="" data-size="normal" data-rawwidth="454" data-rawheight="388" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>从形式系统的角度来看， <equation>\lambda</equation> 项的“应用”，是推导规则的一部分，<br>包括<b>类型推导规则</b>， <equation>\frac{\Gamma\vdash t_1:T_1\to T_2~~~~\Gamma\vdash t_2:T_1}{\Gamma\vdash t_1~t_2:T_2}</equation> ，<br>还包括<b>求值规则</b>， <equation>(\lambda x:T.t)~v\to [x\mapsto v]t</equation> 。</p><p>项的“应用”，我们可以定义为 <equation>\Sigma</equation> 代数上的一个<b>作用结构</b>（applicative structure）。</p><p>假设 <equation>\lambda x:\sigma.t</equation> 是一个类型为 <equation>\sigma\to\tau</equation> 的 <equation>\lambda</equation> 项，我们可以把它“应用于”类型为 <equation>\sigma</equation> 的项 <equation>v:\sigma</equation> ，<br>我们有， <equation>(\lambda x:\sigma.t)~v=([x\mapsto v]t):\tau</equation> 。</p><p>因此， <equation>\Sigma</equation> 代数上的一个<b>作用结构</b> <equation>App^{\sigma,\tau}</equation> ，指的是这样的一个映射，<br> <equation>App^{\sigma,\tau}:A^{\sigma\to\tau}\to A^\sigma \to A^\tau</equation> ，<br>它将集合 <equation>A^{\sigma\to\tau}</equation> 中的一个函数，以及集合 <equation>A^\sigma</equation> 中的一个元素，映射成集合 <equation>A^\tau</equation> 中的一个元素。</p><p>一个有效的作用结构，必须具有<b>外延性条件</b>（extensional），即， <equation>\forall f,g\in A^\sigma\to\tau</equation> ，<br>如果对于任意的 <equation>d\in A^\sigma</equation> ，都有 <equation>App~f~d=App~g~d</equation> ，则必有 <equation>f=g</equation> 。</p><p>它指出集合 <equation>A^\sigma\to\tau</equation> 的两个函数，如果在 <equation>App^{\sigma,\tau}</equation> 下的作用效果相同，<br>那么它们必须是同一个函数。</p><h2><b>2. 项的唯一解释</b></h2><img src="https://pic4.zhimg.com/v2-d0f343b4404ef2e4264a3d3a3da18d1b_r.jpg" data-caption="" data-size="normal" data-rawwidth="175" data-rawheight="220" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>有了满足外延性条件的作用结构之后，<br>我们就可以归纳的定义出<b>含义函数</b>（meaning function） <equation>\mathscr{A}[\![\cdot]\!]</equation> 了，</p><p>（1） <equation>\mathscr{A}[\![\varnothing\vdash c:\sigma]\!]\eta=Const(c)</equation> <br>（2） <equation>\mathscr{A}[\![x:\sigma\vdash x:\sigma]\!]\eta=\eta(x)</equation> <br>（3） <equation>\mathscr{A}[\![\Gamma,x:\sigma\vdash M:\tau]\!]\eta=\mathscr{A}[\![\Gamma\vdash M:\tau]\!]\eta</equation> <br>（4） <equation>\mathscr{A}[\![\Gamma\vdash MN:\tau]\!]\eta=App^{\sigma,\tau}~\mathscr{A}[\![\Gamma\vdash M:\sigma\to\tau]\!]\eta~\mathscr{A}[\![\Gamma\vdash N:\sigma]\!]\eta</equation> <br>（5） <equation>\mathscr{A}[\![\Gamma\vdash\lambda x:\sigma.M:\sigma\to\tau]\!]\eta=</equation> ，存在唯一的 <equation>f\in A^{\sigma\to\tau}</equation> ，使得，<br> <equation>\forall d\in A^\sigma</equation> ， <equation>App~f~d=\mathscr{A}[\![\Gamma,x:\sigma\vdash M:\tau]\!]\eta[x\mapsto d]</equation> </p><p>其中， <equation>\eta</equation> 是满足指派 <equation>\Gamma</equation> 的环境，<br> <equation>Const</equation> 是一个映射，将项常量映射到所有 <equation>A^\sigma</equation> 并集的元素上，<br>使得，如果 <equation>c:\sigma</equation> ，则 <equation>Const(c)\in A^\sigma</equation> 。</p><p>由于以上几个等式覆盖了所有的 <equation>\lambda</equation> 项，因此这样定义的含义函数是<b>完全的</b>。<br>并且由于它为每一个 <equation>\lambda</equation> 项都指定了确定的语义，因此它给出的解释方式也是唯一的。<br>它称为<b>Henkin模型</b>。</p><p>Henkin模型是<b>可靠的</b>，设 <equation>\mathscr{A}</equation> 是 <equation>\lambda^\to</equation> 的任意Henkin模型，<br> <equation>\Gamma\vdash M:\sigma</equation> 是可证的， <equation>\eta</equation> 是一个满足指派 <equation>\Gamma</equation> 的环境，<br>则 <equation>\mathscr{A}[\![\Gamma\vdash M:\sigma]\!]\eta\in A^\sigma</equation> 。</p><p>即，如果一个类型断言是可证的，则它在语义上也成立。<br>（关于完全性的讨论，略）</p><h2><b>3. 例子</b></h2><img src="https://pic1.zhimg.com/v2-eb39ffc5f85a13ee05646af900013807_r.jpg" data-caption="" data-size="normal" data-rawwidth="283" data-rawheight="178" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>我们可以对具有单一类型 <equation>nat</equation> 的 <equation>\lambda</equation> 演算，定义它的Henkin模型，<br>令 <equation>A^{nat}</equation> 为自然数集， <equation>A^{\sigma\to\tau}</equation> 为所有从 <equation>A^\sigma</equation> 到 <equation>A^\tau</equation> 的函数集合，<br>这称为<b>自然数上的完全集合论函数体系</b>，<br>（full set-theoretic function hierarchy over the natural number）。</p><p>我们通过 <equation>App~f~x=f(x)</equation> ，把函数 <equation>f\in A^{\sigma\to\tau}</equation> ，作用到参数 <equation>x\in A^\sigma</equation> 上。<br>下面我们得出 <equation>\lambda x:nat\to nat.\lambda y:nat.xy</equation> 的语义。</p><p>由于该项是封闭项，选择什么样的环境 <equation>\eta</equation> 都是无关紧要的。<br>根据上文“含义函数” <equation>\mathscr{A}[\![\cdot]\!]</equation> 的归纳定义，我们有，<br> <equation>\mathscr{A}[\![\varnothing\vdash\lambda x:nat\to nat.\lambda y:nat.xy]\!]\eta=</equation> ，唯一的 <equation>f\in A^{(nat\to nat)\to nat\to nat}</equation> ，使得，<br> <equation>\forall h\in A^{nat\to nat}</equation> ， <equation>App~f~h=\mathscr{A}[\![x:nat\to nat\vdash\lambda y:nat.xy]\!]\eta[x\mapsto h]</equation> 。</p><p>然后我们再来看下，<br> <equation>\mathscr{A}[\![x:nat\to nat\vdash\lambda y:nat.xy]\!]\eta[x\mapsto h]=</equation> ，唯一的 <equation>g\in A^{nat\to nat}</equation> ，使得，<br> <equation>\forall n\in A^{nat}</equation> ， <equation>App~g~n=[\![x:nat\to nat,y:nat\vdash xy]\!]\eta[x\mapsto h][y\mapsto n]</equation> ，<br>即，唯一的 <equation>g\in A^{nat\to nat}</equation> ，使得， <equation>\forall n\in A^{nat}</equation> ， <equation>App~g~n=App~h~n</equation> 。<br>那么这个唯一的 <equation>g\in A^{nat\to nat}</equation> ，实际上就是 <equation>h</equation> 了。</p><p>其中， <equation>App~g~n=App~h~n</equation> 是因为，<equation>App~g~n=[\![x:nat\to nat,y:nat\vdash xy]\!]\eta[x\mapsto h][y\mapsto n]</equation> <equation>=[\![h:nat\to nat,n:nat\vdash hn]\!]\eta</equation> <equation>=App~h~n</equation> </p><p>综合以上两个步骤，<br> <equation>\mathscr{A}[\![\varnothing\vdash\lambda x:nat\to nat.\lambda y:nat.xy]\!]\eta=</equation> ，唯一的 <equation>f\in A^{(nat\to nat)\to nat\to nat}</equation> ，使得，<br> <equation>\forall h\in A^{nat\to nat}</equation> ， <equation>App~f~h=h</equation> 。<br>因此， <equation>f\in A^{(nat\to nat)\to nat\to nat}</equation> 的语义是一个恒等函数。</p><p>我们从语义上证明了以下等式，<br> <equation>\varnothing\vdash\lambda x:nat\to nat.\lambda y:nat.xy=\lambda x:nat\to nat.x</equation> 。</p><h2><b>4. 环境模型条件和组合模型条件</b></h2><img src="https://pic3.zhimg.com/v2-b7a586ae709a511ff52009eee3e0bf71_r.jpg" data-caption="" data-size="normal" data-rawwidth="520" data-rawheight="424" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>以上定义的作用结构 <equation>App^{\sigma,\tau}</equation> 称为满足<b>环境模型条件</b>（enviroment model condition），<br>依赖了环境 <equation>\eta</equation> 这一附加概念。<br>它使得每一个合法的 <equation>\lambda</equation> 项，都有模型中一个唯一确定的数学对象与之对应。</p><p>由于 <equation>\lambda</equation> 项有 <equation>\lambda</equation> “抽象”和 <equation>\lambda</equation> “应用”双重复杂性，所以，建立一个合理的解释也比较麻烦。<br>在《<a href="https://zhuanlan.zhihu.com/p/34699469">你好，类型</a>》系列文章中，<br>我们介绍过组合子逻辑，我们知道可以将任意的 <equation>\lambda</equation> 项转换成对应的 <equation>CL</equation> 项，反之亦然。</p><p>因此，如果存在模型可以解释所有的 <equation>CL</equation> 项，那么使用它也就可以解释所有 <equation>\lambda</equation> 项了。<br> <equation>CL</equation> 项比 <equation>\lambda</equation> 项更为简洁，它不包含 <equation>\lambda</equation> “抽象”，只包含 <equation>K</equation> 和 <equation>S</equation> 这两个组合子。</p><p>类似于 <equation>\lambda</equation> 项的“应用”，对于 <equation>K</equation> 和 <equation>S</equation> 的“组合”，我们同样可以定义 <equation>\Sigma</equation> 代数上的一个<b>作用结构</b>。</p><p>给定 <equation>\Sigma</equation> 代数，对任意类型 <equation>\rho,\sigma,\tau</equation> ，如果存在元素<br> <equation>K_{\sigma,\tau}\in A^{\sigma\to(\tau\to\sigma)}</equation> ， <equation>S_{\rho,\sigma,\tau}\in A^{(\rho\to\sigma\to\tau)\to(\rho\to\sigma)\to\rho\tau}</equation> ，<br>满足下列对合适类型 <equation>x,y,z</equation> 的等式条件， <equation>K_{\sigma,\tau}xy=x</equation> ， <equation>S_{\rho,\sigma,\tau}xyz=(xz)(yz)</equation> ，<br>我们就称，该作用结构满足<b>组合模型条件</b>（combinatory model condition）。</p><p>由于所有 <equation>CL</equation> 项都可以表示成 <equation>K</equation> 和 <equation>S</equation> 的“组合”，<br>因此，满足组合模型条件的作用结构，可以唯一解释所有 <equation>CL</equation> 项。</p><p>可以证明，一个满足外延性条件的作用结构，<br>如果它满足环境模型条件，当且仅当它也同样满足组合模型条件。</p><h2><b>总结</b></h2><p>本文介绍了Henkin模型作用结构所满足的条件，<b>环境模型条件</b>和<b>组合模型条件</b>，<br>它们是等价的，有了它们我们才能给出 <equation>\lambda</equation> 项的<b>可靠</b>解释，<br>即，任何合法的 <equation>\lambda</equation> 项都有唯一解释，且在语法上可证的 <equation>\lambda</equation> 项，在语义上也成立。</p><p>下文我们开始学习范畴论，为理解笛卡尔闭范畴打好基础。</p><hr><h2><b>参考</b></h2><p><a href="https://zhuanlan.zhihu.com/p/34699469">你好，类型（三）：Combinatory logic</a><br><a href="https://book.douban.com/subject/1944729/">程序设计语言理论基础</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
