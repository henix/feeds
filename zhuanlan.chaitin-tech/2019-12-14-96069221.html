<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>如何绕过JSC最新缓解措施并逃逸Safari沙箱</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/96069221">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-b9eec9b5bff18bab36a19ac491a71b20_b.jpg" alt=""></div><p>本文讨论了一种绕过JavaScriptCore(JSC)最新的StructureID随机化的技术实践，并阐述了通过WebKit IPC逃逸Safari沙箱的具体利用技术。作为以上技术的载体，我们将整个过程呈现在了Real World CTF 2019 决赛当中 (<a href="https://link.zhihu.com/?target=https%3A//realworldctf.com" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">realworldctf.com</span><span class="invisible"></span></a>), 期待能为Safari/WebKit浏览器的安全研究添砖加瓦。 </p><p>本文内容与 <a class="member_mention" href="https://www.zhihu.com/people/8e54c6f265d1887503798285c3f993a7" data-hash="8e54c6f265d1887503798285c3f993a7" data-hovercard="p$b$8e54c6f265d1887503798285c3f993a7">@许文</a> 共同创作。感谢<a href="https://link.zhihu.com/?target=https%3A//www.cc.gatech.edu/~mxu80/" class=" wrap external" target="_blank" rel="nofollow noreferrer">徐萌</a>为本文的改善提出的建议。感谢 <a class="member_mention" href="https://www.zhihu.com/people/372a9eeb0267cf732f5b73265f3dc307" data-hash="372a9eeb0267cf732f5b73265f3dc307" data-hovercard="p$b$372a9eeb0267cf732f5b73265f3dc307">@shiki7</a> 与我一起把这个题成功呈现到Real World CTF中。</p><h2>攻击JavaScriptCore</h2><p>在本次比赛当中，我们刻意在最新版本JavaScriptCore中引入了一个runtime漏洞。通过引入未预期的JIT优化副作用，我们可以成功利用这个漏洞。</p><h2>对FastStructureCache的分析</h2><p>我们为RegExp相关的structure创建了一个分配缓存，名字叫做FastStructureCache。其完整内容可以从<a href="https://link.zhihu.com/?target=https%3A//gist.githubusercontent.com/HQ1995/96d8922f915bc44ca794611344324a8f/raw/41d80298dc276d22d1efcc2b63a4ccf93266ed68/patch.diff" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a>找到。</p><p>下面是对这个漏洞关键部分做的一些注解。</p><div class="highlight"><pre><code class="language-cpp"><span class="k">class</span><span class="err"> </span><span class="nc">FastStructureCache</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">JSNonFinalObject</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">Base</span> <span class="o">=</span> <span class="n">JSNonFinalObject</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">Structure</span><span class="o">**</span> <span class="n">fastCacheStructure</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">uint64_t</span> <span class="n">fastCacheSizeMax</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">uint64_t</span> <span class="n">fastCacheSizeUsed</span><span class="p">;</span>

    <span class="k">static</span> <span class="n">Structure</span><span class="o">*</span> <span class="nf">createStructureFastPath</span><span class="p">(</span><span class="n">VM</span><span class="o">&amp;</span> <span class="n">vm</span><span class="p">,</span> 
        <span class="n">SGlobalObject</span><span class="o">*</span> <span class="n">globalObject</span><span class="p">,</span> <span class="n">JSValue</span> <span class="n">prototype</span><span class="p">,</span> 
        <span class="k">const</span> <span class="n">TypeInfo</span><span class="o">&amp;</span> <span class="n">typeInfo</span><span class="p">,</span> <span class="k">const</span> <span class="n">ClassInfo</span><span class="o">*</span> <span class="n">classInfo</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fastCacheStructure</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fastCacheStructure</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Structure</span><span class="o">*</span><span class="p">[</span><span class="n">fastCacheSizeMax</span><span class="p">];</span>
            <span class="n">uint64_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">fastCacheSizeMax</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// * [1]
</span><span class="c1"></span>                <span class="c1">// Later, we will set the correct globalObject and prototype
</span><span class="c1"></span>                <span class="n">fastCacheStructure</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">::</span><span class="n">create</span><span class="p">(</span>
                    <span class="n">vm</span><span class="p">,</span> <span class="n">globalObject</span><span class="p">,</span> <span class="n">prototype</span><span class="p">,</span> <span class="n">typeInfo</span><span class="p">,</span> <span class="n">classInfo</span><span class="p">);</span>
                <span class="n">idx</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fastCacheSizeUsed</span> <span class="o">&lt;</span> <span class="n">fastCacheSizeMax</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Structure</span><span class="o">*</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">fastCacheStructure</span><span class="p">[</span><span class="n">fastCacheSizeUsed</span><span class="p">];</span>
            <span class="c1">// * [2]
</span><span class="c1"></span>            <span class="c1">// set the correct global object and prototype
</span><span class="c1"></span>            <span class="n">return_value</span><span class="o">-&gt;</span><span class="n">setPrototypeWithoutTransition</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">prototype</span><span class="p">);</span>
            <span class="n">return_value</span><span class="o">-&gt;</span><span class="n">setGlobalObject</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">globalObject</span><span class="p">);</span>
            <span class="n">fastCacheSizeUsed</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">Structure</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">globalObject</span><span class="p">,</span> <span class="n">prototype</span><span class="p">,</span> <span class="n">typeInfo</span><span class="p">,</span> <span class="n">classInfo</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="n">FastStructureCache</span><span class="p">(</span><span class="n">VM</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Structure</span><span class="o">*</span> <span class="n">structure</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div><p>在 [1] 处，我们创建了缓存。尽管现在它里面的prototype都是不正确的，但是我们在后面真正要使用它们的时候会在 [2] 处设置对应的正确prototype。这至少引入了两个bug。首先，type info和 class info是永远不会变的，所以后期使用这些structure的对象的时候这些信息全都是错误的。不过我们并没有去研究过这个bug是不是可以利用的或者怎么利用。然后，图1 比较了<a href="https://link.zhihu.com/?target=https%3A//github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/runtime/StructureInlines.h%23L39" class=" wrap external" target="_blank" rel="nofollow noreferrer">Structure::create</a>中的常规过程和FastStructureCache的区别，显然，FastStructureCache没有用didBecomePrototype()这个函数去标记这个对象已经成了prototype。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-49d9b493879883da9dad2a8b7f8964fc_b.jpg" data-size="normal" data-rawwidth="847" data-rawheight="980" class="origin_image zh-lightbox-thumb" width="847" data-original="https://pic1.zhimg.com/v2-49d9b493879883da9dad2a8b7f8964fc_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-49d9b493879883da9dad2a8b7f8964fc_b.jpg" data-size="normal" data-rawwidth="847" data-rawheight="980" class="origin_image zh-lightbox-thumb lazy" width="847" data-original="https://pic1.zhimg.com/v2-49d9b493879883da9dad2a8b7f8964fc_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-49d9b493879883da9dad2a8b7f8964fc_b.jpg"/><figcaption>图1. 错误的创建structure的过程</figcaption></figure><h2>基本漏洞利用原语构建</h2><p>根据lokihardt的<a href="https://link.zhihu.com/?target=https%3A//bugs.chromium.org/p/project-zero/issues/detail%3Fid%3D1649" class=" wrap external" target="_blank" rel="nofollow noreferrer">一些注解</a>，我们可以得知JSC根本就不允许Proxy对象出现在Native数组的原型链当中。但是，有了这个bug我们便可以打破这个JSC的assumption并做一些有趣的事情。</p><p>图2 阐述了其中因由，假设已经有一个RegExp对象出现在了一个Native数组的原型链中。当我们试图把一个Proxy对象设置在这个RegExp的原型链当中，不会触发任何的转换来把这个数组转换为swithToSlowPutArrayStorage类型的数组。这样来说，我们便可以照葫芦画瓢的利用lokihardt已经讲过的技巧来使用HasIndexedProperty这个IR来向JSC引入非预期的副作用。并造成类型混淆。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-1a80005a6e6e89e73e619dc6e6a9e622_b.jpg" data-size="normal" data-rawwidth="1101" data-rawheight="806" class="origin_image zh-lightbox-thumb" width="1101" data-original="https://pic3.zhimg.com/v2-1a80005a6e6e89e73e619dc6e6a9e622_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-1a80005a6e6e89e73e619dc6e6a9e622_b.jpg" data-size="normal" data-rawwidth="1101" data-rawheight="806" class="origin_image zh-lightbox-thumb lazy" width="1101" data-original="https://pic3.zhimg.com/v2-1a80005a6e6e89e73e619dc6e6a9e622_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-1a80005a6e6e89e73e619dc6e6a9e622_b.jpg"/><figcaption>图2. JSC在为对象设置Prototype时候的检查</figcaption></figure><p>我们给出了addrOf和fakeObj的原语的<a href="https://link.zhihu.com/?target=https%3A//gist.githubusercontent.com/HQ1995/96d8922f915bc44ca794611344324a8f/raw/049e280021d72b390df923bbda59216af0996fa2/poc.js" class=" wrap external" target="_blank" rel="nofollow noreferrer">POC</a>,它的执行效果如下:</p><div class="highlight"><pre><code class="language-bash">➜  ./jsc pwn.js
0x00007fa42ebdc240
<span class="o">[</span><span class="m">1</span><span class="o">]</span>    <span class="m">27955</span> segmentation fault  ./jsc pwn.js</code></pre></div><h2>泄露StructureID</h2><p>起初当我们在Mojave上开发<a href="https://link.zhihu.com/?target=https%3A//twitter.com/insu_yun_en/status/1153742447115153413%3Fs%3D20" class=" wrap external" target="_blank" rel="nofollow noreferrer">full-chain利用</a>之际，structureID的7-bit entropy已经被引入Webkit master。为了利用该漏洞，在那时我们便成功找到了一种基于JIT编译器的通用绕过方法。</p><p>无独有偶，BlackHat EU 上的一个<a href="https://link.zhihu.com/?target=https%3A//i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">talk</a>也公开了一种基于runtime function的方法来泄露structureID的方法。这些方法都是基于一个简单有效的事实: JSC里面并不是所有的内建函数，机制都依赖正确的structureID。</p><p>图3阐述了利用Function.prototype.toString.call()来泄露structureID的过程。我们需要伪造三个对象，其中包括一个没有正确structureID的伪造函数对象。如此一来，我们不仅能泄露structureID的entropy，还可以泄露一个butterfly指针。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-bcfd602672681079f086bc3de1722656_b.jpg" data-size="normal" data-rawwidth="609" data-rawheight="647" class="origin_image zh-lightbox-thumb" width="609" data-original="https://pic3.zhimg.com/v2-bcfd602672681079f086bc3de1722656_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-bcfd602672681079f086bc3de1722656_b.jpg" data-size="normal" data-rawwidth="609" data-rawheight="647" class="origin_image zh-lightbox-thumb lazy" width="609" data-original="https://pic3.zhimg.com/v2-bcfd602672681079f086bc3de1722656_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-bcfd602672681079f086bc3de1722656_b.jpg"/><figcaption>图3. 泄露StructureID。(蓝色代表伪造的对象，绿色代表正常的对象)</figcaption></figure><p>我们给出了一个泄露structureID的<a href="https://link.zhihu.com/?target=https%3A//gist.githubusercontent.com/HQ1995/96d8922f915bc44ca794611344324a8f/raw/41d80298dc276d22d1efcc2b63a4ccf93266ed68/leakid.js" class=" wrap external" target="_blank" rel="nofollow noreferrer">代码实现</a>,执行效果如下:</p><div class="highlight"><pre><code class="language-text">➜  ./jsc pwn.js
Structure ID: 8230700009a5e</code></pre></div><h2>绕过JSC 隔离堆并执行任意代码</h2><p>大家经常使用的绕过隔离堆的方法有两个，<a href="https://link.zhihu.com/?target=https%3A//github.com/LinusHenze/WebKit-RegEx-Exploit/blob/master/pwn.js%23L176" class=" wrap external" target="_blank" rel="nofollow noreferrer">WASM’s Memory buffer</a>或者是<a href="https://link.zhihu.com/?target=https%3A//github.com/niklasb/sploits/blob/master/safari/regexp-uxss.html%23L128" class=" wrap external" target="_blank" rel="nofollow noreferrer">Object’s butterfly</a>。因为gigacage没有对它们做隔离。因为我们在泄露structureID还可以顺便泄露butterfly指针，向图4描绘的这样，用第二种方法在butterfly上伪造一个对象来实现任意地址读写可以少写很多代码。</p><p>从任意地址读写到代码执行，我们使用了覆盖JIT代码内存的陈词滥调。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-831be9cdbf273890308dd046123ac91d_b.jpg" data-size="normal" data-rawwidth="795" data-rawheight="280" class="origin_image zh-lightbox-thumb" width="795" data-original="https://pic2.zhimg.com/v2-831be9cdbf273890308dd046123ac91d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-831be9cdbf273890308dd046123ac91d_b.jpg" data-size="normal" data-rawwidth="795" data-rawheight="280" class="origin_image zh-lightbox-thumb lazy" width="795" data-original="https://pic2.zhimg.com/v2-831be9cdbf273890308dd046123ac91d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-831be9cdbf273890308dd046123ac91d_b.jpg"/><figcaption>图4. 通过在butterfly上面伪造一个对象来绕过gigacage隔离堆。</figcaption></figure><h2>攻击WebKit IPC进程并逃逸沙箱</h2><p>由于现代浏览器广泛使用了多进程模型以及沙箱墨香，Broker进程IPC便成为了最有力的沙箱逃逸攻击面之一。Chrome Windows在最近的一次成功沙箱逃逸便是利用了Broker IPC的内存破坏。</p><p>如图5中阐述，WebKit的Broker IPC server由多个消息代理组合而成，可以双向通信，同步或者异步通信。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-13f61e2d9d4d9690b930cc1c255ed723_b.jpg" data-size="normal" data-rawwidth="541" data-rawheight="373" class="origin_image zh-lightbox-thumb" width="541" data-original="https://pic4.zhimg.com/v2-13f61e2d9d4d9690b930cc1c255ed723_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-13f61e2d9d4d9690b930cc1c255ed723_b.jpg" data-size="normal" data-rawwidth="541" data-rawheight="373" class="origin_image zh-lightbox-thumb lazy" width="541" data-original="https://pic4.zhimg.com/v2-13f61e2d9d4d9690b930cc1c255ed723_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-13f61e2d9d4d9690b930cc1c255ed723_b.jpg"/><figcaption>图5. 渲染进程与其他进程的交互。</figcaption></figure><h2>一个UI进程中的Use-After-Free漏洞的故事</h2><p>通过回滚AAPL的一个<a href="https://link.zhihu.com/?target=https%3A//gist.github.com/HQ1995/96d8922f915bc44ca794611344324a8f/raw/3b605cbb50324ad5f45a651ad9fe93145c03a412/sandbox.diff" class=" wrap external" target="_blank" rel="nofollow noreferrer">patch</a>，我们在Webkit IPC进程中引入了一个bug。我们删掉了VideoFullScreenMessageProxy::setHasVideo中对contextID的检查。这样一来选手们在触发漏洞的时候就可以轻松点。不停的触发这一条消息就能触发漏洞。</p><p>如图6中描述，这些消息Proxy都是通过WTF::HashMap来建议contextID和一些对象之间的映射。因为WTF::HashMap中，0这个index实际上是表示这个位置是空的。但是我们把这个ID的检查删掉了。这样就可以给它发ID为0的消息，造成存入和查找的逻辑不一致。想办法多存一点来触发哈希表的rehash，这个过程会有UAF的情况出现。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-705fe50daf15727bb62c0e354fee8005_b.jpg" data-size="normal" data-rawwidth="1273" data-rawheight="310" class="origin_image zh-lightbox-thumb" width="1273" data-original="https://pic2.zhimg.com/v2-705fe50daf15727bb62c0e354fee8005_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-705fe50daf15727bb62c0e354fee8005_b.jpg" data-size="normal" data-rawwidth="1273" data-rawheight="310" class="origin_image zh-lightbox-thumb lazy" width="1273" data-original="https://pic2.zhimg.com/v2-705fe50daf15727bb62c0e354fee8005_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-705fe50daf15727bb62c0e354fee8005_b.jpg"/><figcaption>图 6. 危险的裸指针</figcaption></figure><p>由于指向PlaybackSessionModel的这个指针是裸指针，因此在触发rehash时它将变为悬空指针。 一旦VideoFullscreenInterfaceMac对象被解构，则将触发UAF。</p><p>通过向UI进程发送以下消息可以触发UAF。</p><div class="highlight"><pre><code class="language-text">send(Messages::VideoFullscreenManagerProxy::SetHasVideo(2, true));
send(Messages::VideoFullscreenManagerProxy::SetHasVideo(-3, true));
send(Messages::VideoFullscreenManagerProxy::SetHasVideo(255, true));
send(Messages::VideoFullscreenManagerProxy::SetHasVideo(7, true));
send(Messages::VideoFullscreenManagerProxy::SetHasVideo(4095, true));
send(Messages::VideoFullscreenManagerProxy::SetHasVideo(0, true));
send(Messages::VideoFullscreenManagerProxy::SetHasVideo(18, true));
send(Messages::VideoFullscreenManagerProxy::SetHasVideo(800, true));</code></pre></div><h2>稳定的在UI进程中实现堆喷射</h2><p>当考虑如何在CPP编写的软件中利用UAF漏洞的时候，我们一般要考虑伪造的虚表往哪里放，伪造的虚表地址如何才能知道。因为macOS的堆比较弱，所以我们用堆喷来实现。</p><p>虽然通常都是找一个消息发多次的方式来实现堆喷，但是我们在这里直接用了web进程和UI进程之间的共享内存来实现。如此一来，只需要发一条消息。</p><p>伪代码如下:</p><div class="highlight"><pre><code class="language-text">WebProcess::singleton().parentProcessConnection()-&gt;sendSync(
    Messages::WebPasteboardProxy::
        SetPasteboardBufferForType(&#34;name&#34;, &#34;type&#34;, handle, 0x10000000), 
    Messages::WebPasteboardProxy::
        SetPasteboardBufferForType::Reply(newChangeCount), 0);</code></pre></div><h2>靠谱儿的重新填充被释放的内存</h2><p>WebAuthenticatorCoordinatorProxy这部分有一个函数带有一个Vector&lt;uint8_t&gt;参数，既是Byte粒度的控制，又没有杂质，简直是填充任何对象的万灵药！</p><div class="highlight"><pre><code class="language-text">void WebAuthenticatorCoordinatorProxy::makeCredential(FrameIdentifier frameId, 
    SecurityOriginData&amp;&amp; origin, 
    Vector&lt;uint8_t&gt;&amp;&amp; hash, 
    PublicKeyCredentialCreationOptions&amp;&amp; options, 
    RequestCompletionHandler&amp;&amp; handler) {
    handleRequest({ WTFMove(hash), 
        WTFMove(options), 
        makeWeakPtr(m_webPageProxy), 
        WebAuthenticationPanelResult::Unavailable, 
        nullptr, 
        GlobalFrameIdentifier 
        { 
            m_webPageProxy.webPageID(), 
            frameId 
        }, 
        WTFMove(origin) 
        }, 
        WTFMove(handler));
}</code></pre></div><p>伪代码如下:</p><div class="highlight"><pre><code class="language-text">sendWithAsyncReply(Messages::WebAuthenticatorCoordinatorProxy::MakeCredential(
        m_mainFrame-&gt;frameID(), 
        SecurityOriginData(&#34;http&#34;, &#34;hqzhao.me&#34;, 8080), hash, options), 
        callback
);</code></pre></div><h2>老生常谈: 劫持虚表并在沙箱外执行任意代码</h2><p>图7描绘了整个沙箱逃逸的过程，一如既往的劫持虚标，一如既往的栈迁移，一如既往的调用setcontext的gadget。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-a994e440f09f15f99a36d066f4d7c808_b.jpg" data-size="normal" data-rawwidth="1518" data-rawheight="839" class="origin_image zh-lightbox-thumb" width="1518" data-original="https://pic1.zhimg.com/v2-a994e440f09f15f99a36d066f4d7c808_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-a994e440f09f15f99a36d066f4d7c808_b.jpg" data-size="normal" data-rawwidth="1518" data-rawheight="839" class="origin_image zh-lightbox-thumb lazy" width="1518" data-original="https://pic1.zhimg.com/v2-a994e440f09f15f99a36d066f4d7c808_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-a994e440f09f15f99a36d066f4d7c808_b.jpg"/><figcaption>图7。 从UAF到沙箱逃逸</figcaption></figure><h2>班主任评语</h2><p>以上在macOS上的利用确实冗长，枯燥又乏味。虽然整个心路历程不算那么的容易，但是如今Safari和WebKit的漏洞利用技术的前沿和重心应该还是在iOS上。不说iOS的JIT上辈子就不能修改了，也不说iOS的随机化强多了，也不说iOS13的沙箱配置文件连BSD syscall都开始禁了，光是自从iPhone有了PAC以来，还没有公开技术来讨论在任意地址读写后如何在content中执行代码。不管是用户态还是内核态，大家A12平台以后的exploit除了逻辑漏洞，基本都是在靠着漏洞品相和环境特性在做Data-Only相关的attack。如文章中说的这些陈词滥调，应该会慢慢从主流软件中绝迹。</p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
