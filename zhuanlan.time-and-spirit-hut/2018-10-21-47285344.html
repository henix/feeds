<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>「Rust每日新闻」本周精选 • 第十六期</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/47285344">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-10c6913d0bc44f08fed6d57e31af7e30_r.jpg" alt=""></div><blockquote>前言：<br><br>从2018年开始，我每天会花1个小时关注Rust社区动态，并且在<a href="http://rust.cc/">Rust.CC论坛</a>、<a href="https://t.me/rust_daily_news">tg channel</a>、<a href="https://steemit.com/@blackanger">Steemit</a>、<a href="https://github.com/RustStudy/rust_daily_news">GitHub</a>、<a href="https://www.yuque.com/chaosbot/rustnews">语雀订阅</a>都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。<br><br>2018-10-21</blockquote><h2><b>通告两则</b></h2><p><b>「Rust每日新闻」调查问卷</b></p><p>「Rust每日新闻」持续更新也快一年了，现在想做个小调查，了解下读者群，为了在年底出一份「每日新闻」年度报告做准备。同时也为了将来可以更好地给大家提供内容。 大家有空填写一下，不涉及隐私。</p><p>昨天的金数据问卷调查满额了，今天用腾讯问卷新做了一份，已经填过的朋友，无需再填了。没填过的朋友，抽空用新的问卷调查填写一下。看大家的调查结果，也挺有意思，等问卷结束了，把统计结果分享给大家。</p><p><a href="https://wj.qq.com/s/2801182/f890">问卷地址</a></p><p><b>「声明」</b></p><p>今天一天遇到两起评论，一条是带着阴阳怪气评论每周精选，一条是直接说我「标题党」，这让我有点不舒服。当然，我愿意相信对方也许并无恶意，只是用词不当。不过我也觉得有必要再次说明几点：</p><ol><li>「每日新闻」只是满足我自己每天的阅读需求，顺便总结出来分享给大家。</li><li>每日新闻里的内容，不要当作是翻译来看待。并非翻译，只是我看完以后做了梳理和总结。</li><li>人非圣贤，孰能无错？ 所以新闻的内容有错是很正常的。看见我对内容有错误的理解，欢迎指出问题，我很乐意改正，因为「每日新闻」的存在，也有一部分原因是因为我也要学习。</li><li>你可以觉得我的水平很水，发的内容不值得你看，可以选择不交流不关注。但如果要评论或交流，还请携带善意。</li><li>并非我敏感，只是觉得给大家说清楚比较好。</li><li>有人可能认为我是宣扬Rust调门很高。但其实，我每日新闻基本都在Rust群发放，而且对原文也基本没有故意的篡改或添加私货（要加私货也是对原文中涉及的相关内容进行补充）。 不喜勿看。</li></ol><p>特此说明</p><hr><h2><b>官方新闻</b></h2><p><b>「官方」crates.io的2018年10月15日事件始末</b></p><p>在2018年10月15日，crates.io遭到了一次「伪装官方」的攻击事件。</p><p>事件起始：</p><ul><li>有人伪造了一个用户名cratesio，然后以常用的简短的名字上传一些crate，里面除了Cargo.toml和README之外什么都没有。</li><li>并且指示crates.io用户，如果想要这些名字，<a href="http://xn--crates-o05j327c.io/">就去crates.io</a> issues列表发issues。</li><li>此用户上传crate的速度引发了GitHub的限制，导致所有软件的上传和下载速度减慢。</li></ul><p>官方应对：</p><ul><li>封禁该用户IP</li><li>删除该用户上传的所有crate，将cratesio用户的页面定向为404</li><li>该用户被举报到GitHub，封禁处理</li></ul><p>事件从开始到结束，一共经历了五小时。</p><p>官方未来的措施：</p><ul><li>考虑到单个的正常用户不可能一次性上传很多crate，所以将会限制上传crate的数量和速率</li><li>猜测该用户攻击行为的动机，很可能是因为之前crates.io上面的包名的「抢注」政策不满意。所以官方将在未来几周内讨论确定该政策的解决措施。</li><li>无论动机如何，官方团队都不欢迎这种攻击行为，如果对政策不满意，可以提交RFC或给help@crates.io发邮件。避免使用这种恶意攻击行为。</li><li>通过这次事件，官方团队也意识到应该多和社区进行沟通，并且会为社区的沟通制定更多的通道。</li></ul><p><a href="https://blog.rust-lang.org/2018/10/19/Update-on-crates.io-incident.html"> Read More </a> </p><p><b>「Web框架」Tide中的路由和提取：首个草图</b></p><p>该文由aaron编写，描述了Tide中路由和提取的设计，结合了Rocket、Actix和Gotham等框架的创意。</p><p>路由：从HTTP请求映射到endpoint，即，用于处理请求的一段代码。 提取： endpoint如何在HTTP请求中提取数据。</p><p>这文章只是一个草图。</p><p>通过一个simple app来展示这种设计：</p><code lang="rust">#[derive(Serialize, Deserialize)]
struct Message {
    contents: String,
    author: Option&lt;String&gt;,
    // etc...
}

/// A handle to an in-memory list of messages
#[derive(Clone)]
struct Database { /* ... */ }

impl Database {
    /// Create a handle to an empty database
    fn new() -&gt; Database;

    /// Add a new message, returning its ID
    fn insert(&amp;mut self, msg: Message) -&gt; u64;

    /// Attempt to look up a message by ID
    fn get(&amp;mut self, id: u64) -&gt; Option&lt;Message&gt;;

    /// Attempt to edit a message; returns `false`
    /// if `id` is not found.
    fn set(&amp;mut self, id: u64, msg: Message) -&gt; bool;
}</code><p>上面代码代替App的复杂的后端，可以看作是这个简单app的内存数据库层</p><p>接下来构建一个简单Web API：</p><code lang="rust">fn main() {
    // The endpoints will receive a handle to the app state, i.e. a `Database` instance
    let mut app = App::new(Database::new());

    app.at("/message").post(new_message);
    app.at("/message/{}").get(get_message);
    app.at("/message/{}").put(set_message);

    app.serve();
}</code><p>具体的endpoint实现：</p><code lang="text">async fn new_message(mut db: AppState&lt;Database&gt;, msg: Json&lt;Message&gt;) -&gt; Display&lt;usize&gt; {    
    db.insert(msg.0)
}</code><p>该函数签名等价于：</p><code lang="text">fn new_message(mut db: AppState&lt;Database&gt;, msg: Json&lt;Message&gt;)
    -&gt; impl Future&lt;Output = Display(usize)&gt;</code><p>其中每个参数都实现Extractor trait。</p><p>Extractor trait中说明了如何从请求中提取数据。对于new_message，现在使用两个提取器：一个用于获取应用程序状态（数据库）的句柄，另一个用于提取主体（作为json编码的消息）。</p><p>在函数体内，可以直接使用参数。提取器包装器类型实现了Deref和DerefMut。在需要所有权时可以使用.0来提取内部对象：</p><code lang="text">db.insert(msg.0)</code><p>最后将返回插入消息的标识符，Display(u64) 。Display类型是一个装饰器，用于将给定值序列化为vanilla HTTP 200，并通过Display trait来生成格式化的http body。</p><code lang="text">impl&lt;T: fmt::Display&gt; IntoResponse for Display&lt;T&gt; { ... }</code><p>更多示例看原文。</p><p>设计目标：</p><ul><li>清晰地了解API和代码如何映射，将通过对路由和提取的分离和限制路由表达能力来做到这一点。</li><li>将提取和respond序列更加符合人体工程学。通过利用trait来实现这一点。</li><li>避免在核心中使用宏和代码生成。</li><li>为中间件和配置提供一个干净的机制，让API非常适合可扩展和自定义</li></ul><p>路由：</p><ul><li>通过「table of contents」分离路由，可以方便查看整个应用程序的结构</li><li>路由没有「fallback」机制，不能有两个相同的路由。</li><li>仅通过URL和HTTP方法选择endpoint</li></ul><p>路由的语法：</p><code lang="rust">"/users/{}"
"/users/{}/help"
"/users/new"
"/users/new/help"</code><p>路由只允许两条路由重叠，其中一条要比另一条更具体。</p><p>路由和资源是相匹配的：</p><code lang="rust">impl&lt;AppData&gt; Resource&lt;AppData&gt; {
    pub fn get&lt;T&gt;(&amp;mut self, endpoint: impl Endpoint&lt;AppData, T&gt;) -&gt; &amp;mut Config;
    pub fn put&lt;T&gt;(&amp;mut self, endpoint: impl Endpoint&lt;AppData, T&gt;) -&gt; &amp;mut Config;
    pub fn post&lt;T&gt;(&amp;mut self, endpoint: impl Endpoint&lt;AppData, T&gt;) -&gt; &amp;mut Config;
    pub fn delete&lt;T&gt;(&amp;mut self, endpoint: impl Endpoint&lt;AppData, T&gt;) -&gt; &amp;mut Config;

    pub fn nest(&amp;mut self, impl FnOnce(&amp;mut Router));

    pub fn config(&amp;mut self) -&gt; &amp;mut Config;
}</code><p>（ 有种Restful的风格）</p><p>其中AppData是路由核心类型之一，核心类型包括：</p><code lang="rust">/// An application, which houses application state and other top-level concerns.
pub struct App&lt;AppData&gt; { .. }

/// Configures routing within an application. Routers can be nested.
pub struct Router&lt;AppData&gt; { .. }

/// Configures the responses for an application for a particular URL match.
pub struct Resource&lt;AppData&gt; { .. }

/// Embeds a typemap for providing hierarchical configuration of extractors, middleware, and more.
pub struct Config { .. }</code><p>路由终止于Endpoints</p><code lang="text">pub trait Endpoint&lt;AppData, Kind&gt; {
    type Fut: Future&lt;Output = Response&gt; + Send + 'static;
    fn call(&amp;self, state: AppData, req: Request, config: &amp;Config) -&gt; Self::Fut;
}</code><p>对于框架的使用者来说endpoint，是任意一个异步函数，其中每个参数都实现了Extractor，返回类型实现IntoResponse。这点和Rocket框架相似，但没有使用宏来实现。</p><p>提取器 Extraction</p><code lang="text">pub trait Extractor&lt;AppData&gt;: Sized {
    type Error: IntoResponse;
    type Fut: Future&lt;Output = Result&lt;Self, Self::Error&gt;&gt; + Send + 'static;
    fn extract(state: AppData, config: &amp;Config, req: &amp;mut Request) -&gt; Self::Fut;
}</code><p>这更像actix-web，以下所有类型都实现了Extractor：</p><code lang="text">pub struct Json&lt;T&gt;(pub T);
pub struct AppState&lt;T&gt;(pub T);
pub struct Path&lt;T&gt;(pub T);
pub struct Glob&lt;T&gt;(pub T);
pub struct Query&lt;T&gt;(pub T);</code><p>最终endpoint必须返回能转换为Response的数据：</p><code lang="text">pub trait IntoResponse: Sized {
    type Body: BufStream + Send + 'static;
    fn into_response(self) -&gt; http::Response&lt;Self::Body&gt;;
}</code><p>下一篇文章将阐述中间件和配置API的设计</p><p><a href="https://rust-lang-nursery.github.io/wg-net/2018/10/16/tide-routing.html">Read</a></p><hr><h2><b>社区新闻</b></h2><p><b>「社区」Rust成为GitHub上增长最快的第五种编程语言</b></p><p>增长最快的语言：</p><ul><li>Kotlin</li><li>HCL</li><li>TypeScript</li><li>PowerShell</li><li>Rust</li></ul><p><a href="https://octoverse.github.com/projects">Read More</a></p><p><b>「研究项目」「系列文章」shifgrethor：Rust实现的垃圾收集库</b></p><p>Rust官方核心人员withoutboats开发了一个内存安全的垃圾收集库。它只是一个研究项目，并不能实际使用。</p><p>当然也可以用于学习目的，了解Rust的语言能力如何用于编码安全API中的复杂内存管理要求。</p><p>从长远来看，shifgrethor很可能会成为可用的高性能的垃圾回收器。当然，该项目不太可能成为Rust项目的常用功能。也就是说，请不要理解为「Rust要加GC了」。</p><p>shifgrethor的存在，只是为了要寻找一个实用的场景，用户可以使用GC来处理复杂的内存管理。比如涉及共享所有权的时候，可以使用动态的方式来管理内存。</p><p>shifgrethor是一个精准的跟踪GC</p><ul><li>允许循环引用。不同于引用计数，这种GC不会导致内存泄漏。</li><li>精准的GC。它可以确切地知道哪些数据是活跃的，哪些不是。</li></ul><p>Shifgrethor允许完全自由引用</p><ul><li>可以解引用GC指针，可正常获得堆中的对象</li><li>GC堆中的对象可以持有不在GC堆中对象的借用/引用，即使它们在栈上</li><li>GC堆中的对象可以拥有栈中的对象。</li><li>可以讲GC指针从栈上移动到堆上。</li></ul><p>GC是一种共享所有权，因此还需要内部可变性。</p><p><a href="https://github.com/withoutboats/shifgrethor">shifgrethor</a></p><p>博文 <a href="https://boats.gitlab.io/blog/post/shifgrethor-i/">Read</a></p><p><b>「社区」新包 pin-cell</b></p><p>官方核心开发人员withoutboats开发了新的crate，pin-cell，类似于RefCell，但PinCell是针对pinned可变引用的内部可变类型。</p><p>为什么PinCell很有用？</p><p>从一个object到此object内部包含object的操作叫做「projection」，比如从结构体到其包含的字段，从Vec到其中的元素。Rust中可以按值、按引用、按可变引用来进行projection。</p><p>讲pinned引用转换为某些类型的操作叫做「pin projection」，当前讲pinned引入到RefCell是不安全的，所以必须用PinCell来安全处理「projection」。</p><p><a href="https://boats.gitlab.io/blog/post/pin-cell/">Read</a></p><p><b>Rust文档化建议</b></p><p>作者对Rust文档化（在你编写自己的crate时）给出了一些建议：</p><ul><li>README 一定要写，不管多小的crate</li><li>CONTRIBUTION要列出来，以便别人贡献</li><li>提出一个preRFC，提出增加features文档化配置的功能，这个感觉还是挺有意义的</li></ul><p><a href="https://phaazon.net/blog/rust-features-documentation">原文</a></p><p><b>Amethyst游戏引擎的最新进展</b></p><p>开发团队：</p><ul><li>组建核心团队，负责整体管理和方向。</li><li>引入新的贡献者团队，这些团队专注于引擎的特定领域，并授权写入权限。</li><li>引入活跃策略。如果团队中有人在6个月内处于非活跃状态，将会被自动剔除团队。</li><li>现在有四名活跃的成员。</li></ul><p>引擎核心：</p><ul><li>基于UDP协议的net-dev正在取得进展，它会独立于引擎之外，但会被用于引擎中的高级API。这意外着你可以独立使用net-dev库。</li><li>3D渲染器正在完全重写，为了支持现代的渲染技术（Vulkan/Metal/DirectX12后端、VR等），正在招募相关经验的贡献者</li><li>正在设计和原型化支持高级部署体系结构的新的资源管道，有助于集成专业级的工作流到引擎中。（使用构建时和部署时配置来节省运行时的计算负担），并减少开发人员和艺术家的资源管理负担。希望通过引擎实现高度可扩展的开发流程，即使在大型商业游戏上也是如此。</li><li>实验性的Amethyst editor 发布，用于创建游戏原型</li><li>下一步将推出0.9版本，该版本将助力于2D游戏开发人员</li></ul><p><a href="https://www.amethyst.rs/blog/dev-news-10-2018/">原文</a></p><p><b>const fn编译时SUBLEQ解释器</b></p><p>作者通过实现一个SUBLEQ解释器来测试const fn最近稳定的最小化子集mini-const-fn的可能性。</p><p>SUBLEQ是一种单指令集计算机，由其唯一指令SUbtract和Branch（如果小于或等于0的分支）组成。</p><p>指令 subleq a, b, c 将会执行 <code class="inline">mem[b] = mem[b] - mem[a]; if mem[b] &lt;= 0 { goto c; }</code>，也就是，减并且小于等于0跳转，并且该指令是图灵完备的。其中a、b、c都是地址，<code class="inline">mem[b] = mem[b] - mem[a];</code>求减法，后面的分支进行控制挑战，可以实现通用的计算。</p><p>wiki： <a href="https://en.wikipedia.org/wiki/One_instruction_set_computer">https://en.wikipedia.org/wiki/One_instruction_set_computer</a></p><p>当前Rust稳定的const-fn最小子集，包含的内容比较少，比如，包括算术运算符，结构/元组/数组创建和访问。 不允许任何种类的控制流构造，如if，match，while，for或loop。</p><p>在实现过程中得到如下事实：</p><ul><li>const fn中仅仅允许使用生命周期和Sized作为泛型限定，比如还不能指定<code class="inline">T: Copy</code></li><li>函数指针在const fn中是 unstable状态</li><li>const fn目前还不支持let绑定和重新分配可变变量</li><li>循环可以通过递归调用const fn来实现</li></ul><code lang="rust">const fn count(i: i32) -&gt; i32 {
    count(i+1)
}</code><p>比如实现无限的计数循环，但不能指定分支条件。最终的解决方案是，手动展开循环。</p><p>结论：</p><p>const fn的最小子集是否图灵完备？</p><p>答案是：</p><ul><li>是的。因为可以用它实现图灵完备的SUBLEQ</li><li>不是。 只能执行有限数量的迭代。</li><li>也许。找到一种方式可以从循环或递归中提前中止（即使找到了中止的方法，仍然只有96次迭代的最大值，因为const fn求值器不允许超过96个栈帧）</li></ul><p>一个有趣的事实</p><p>subleq函数可以看做一个不动点迭代器（Fixed Point iterator）。</p><p><a href="https://www.reddit.com/r/rust/comments/9o6vzo/constfn_compiletime_subleq_interpreter/">原文</a></p><p><b>「实验项目」rails/rails_fast_attributes： 使用Rust提升Rails性能</b></p><p>刚在Ruby Summit China大会上讲完《Ruby的好朋友-Rust》，今天就看到了这个</p><p>是Diesel作者用Helix来帮助提升ActiveRecord的属性映射性能 ​​​​</p><p>Helix是Cargo作者带头实现的方便用Rust扩展Ruby的库</p><p><a href="https://github.com/rails/rails_fast_attributes">rails/rails_fast_attributes</a></p><p><b>使用WebAssembly加速Markdown渲染</b></p><p>SpiderOak公司的博文，SpiderOak是一个云端备份工具。该公司出了一个产品叫 Semaphor，它是可协作的加密群组IM软件。起因是因为SpiderOak团队需要一个安全的群组消息传递和文件共享解决方案，而没有电子邮件或现成协作工具带来的风险。 使用私有区块链加密开发。</p><p>在Semaphor中发送的每条消息，都是Markdown文档，所以渲染性能对它们来说很重要。所以他们一直在寻找加速渲染性能的方法。最终他们想到一个方案，就是将WebAssembly集成到React组件中，取代react函数，所以他们提出了<a href="https://github.com/SpiderOak/react-wasm-bridge">react-wasm-bridge</a> 实验组件。它将props传递给Rust WebAssembly模块，并提供构建React渲染树的接口。</p><p>Rust是个很自然的选择，因为Rust工具链很完善，比如有wasm-bindgen这样的工具。他们对Markdown渲染器的要求是：</p><ul><li>安全，解析用户的输入需要安全</li><li>快速， 呈现消息展示是Semaphor中最频繁的操作</li></ul><p>Rust+wasm方案改进后</p><p>安全性：</p><p>当前他们的Markdown渲染器用的是<a href="https://github.com/markdown-it/markdown-it">markdown-it</a>，它与react一起工作并不安全，因为包含有HTML字符串，对目前的解决方案并不满意。因此新的解决方案必须没有HTML字符串，而是直接创建元素。因此通过Rust来构建React 元素树，并且wasm环境还是一个天然的沙箱，对于攻击者来说并没有那么有用。</p><p>性能：</p><p>刚开始的实现方案性能并没有多少提升，后来针对它们的产品场景，将React中循环渲染构建dom的逻辑，转移到了Rust中，从而提升了性能。因为对于它们的产品来说，只需要渲染一次即可，im中的消息是不可变的，所以不需要重新渲染。</p><p>最终的测试结果：</p><code lang="text">BROWSER  MARKDOWN-IT   WASM
—————————————————------------
Firefox    162ms       175ms
Chrome     197ms       84ms</code><p><a href="https://github.com/SpiderOak/react-markdown-wasm">react-markdown-wasm</a></p><p><a href="https://engineering.spideroak.com/2018/08/29/using-webassembly-to-speed-up-message-rendering/">原文</a></p><p><b>继续讨论Rust中的2D图形</b></p><p>这是「我想要一个2D图形Crate 」文章相关的后续讨论贴，该文作者总结了此次讨论中的几个具体的主题。</p><p><a href="https://nical.github.io/posts/rust-2d-graphics-01.html">原文</a></p><hr><h2><b>学习资源</b></h2><p><b>免费书籍推荐：CODE ARTISTRY BOOK</b></p><p>副标题：A Practical Guide To Rust 卷1</p><p><a href="https://thedarkula.gitlab.io/code-artistry/book/">官网</a></p><p><a href="https://thedarkula.gitlab.io/code-artistry/book/VolumeI.pdf">PDF</a></p><p><b>通过WebAssembly在Cloudless上玩Serverless Rust</b></p><p><a href="https://blog.cloudflare.com/cloudflare-workers-as-a-serverless-rust-platform/">Read</a></p><p><b>基于 AWS Lambda 和 WebAssembly实现Serverless Rust</b></p><p>这篇文章介绍了 ：</p><ol><li>介绍如何使用WebAssembly创建Serverless功能。</li><li>演示完全用Rust编写的AWS Lambda函数。</li></ol><p><a href="https://blog.scottlogic.com/2018/10/18/serverless-rust.html">Read More</a></p><p><b>Rust与编程三定律</b></p><p>本文作者模仿阿西莫夫机器人三定律自创的叫信息学三定律（Three Laws of Informatics）</p><p>（感觉叫编程三定律好多了）</p><ul><li>程序必须正确（Programs must be correct.）</li><li>程序必须可维护，但不能违反第一条定律（Programs must be maintainable, except where it would conflict with the First Law.）</li><li>程序必须高效，但不能违反前两条定律（Programs must be efficient, except where it would conflict with the First or Second Law.）</li></ul><p>（好像有点道理）</p><p>本文很长，作者比较了众多语言，从编程语言发展历史，阐述了编程三定律背后的意义。从这个角度来看，Rust应该是目前唯一遵循此三定律的语言。</p><p><a href="https://medium.com/@schemouil/rust-and-the-three-laws-of-informatics-4324062b322b">Read</a></p><p><b>「系列文章」Gfx-hal指南Part 2：顶点缓冲区（Vertex buffers）</b></p><p><a href="https://falseidolfactory.com/2018/10/09/gfx-hal-part-2-vertex-buffers.html">Read</a></p><p><b>打通wasm &lt;=&gt; Fressian &lt;=&gt; cljs</b></p><p>通过Fressian，连通 Rust、wasm和cljs</p><p>Fressian是Clojure使用的数据格式， Fress是clojure.js实现的Fressian和wasm无缝转换的工具</p><p>现在用Rust实现serde-fressian，通过serde_fressian::wasm 模块与fress.wasm命名空间进行交互，这样就实现了使用Rust编写的wasm模块，直接为cljs使用。</p><p><a href="https://pkpkpk.github.io/wasm%E2%A5%AAfressian%E2%A5%ADcljs.html">Read More</a></p><p><b>「小工具」Rust+WASM制作的浏览器扩展</b></p><p>用于在docs.rs上生成railroad语法图</p><p>该插件是用 Rust库macro_railroad （[之前新闻介绍链接] (<a href="https://t.me/rust_daily_news/954">https://t.me/rust_daily_news/954</a>)），和wasm共同制作的</p><p><a href="https://github.com/lukaslueg/macro_railroad_ext">macro_railroad_ext</a> 源码</p><p><a href="https://www.reddit.com/r/rust/comments/9pnk1w/show_reddit_a_browserextension_to_generate/"> Read More</a></p><p><b>「Rust Workshop」调试Rust分享的幻灯片</b></p><p>内容包括：</p><ul><li>高效使用println!</li><li>利用断言</li><li>利用日志（log），以及介绍Log的生态系统</li><li>回溯和恐慌</li><li>LLDB &amp; GDB，推荐了很多LLDB/GDB的命令行debug技巧</li><li>record &amp; replay debug</li></ul><p>其中log生态系统介绍的crate：</p><ul><li>log</li><li>env_logger ，使用该库的时候，要理解RUST_LOG 环境变量</li><li>stderrlog</li><li>flexi_logger</li><li>android_logger</li></ul><p>关于回溯：</p><p>推荐了backtrace 包，可以按需定制生成回溯</p><p>记录和重放Debug：</p><p>推荐了工具<a href="https://rr-project.org/">rr</a>，只支持Linux环境</p><p>相关代码：<a href="https://github.com/jdm/debugging-workshop">debugging-workshop</a></p><p><a href="https://www.joshmatthews.net/debugging-workshop/#1">Slides</a></p><hr><h2><b>项目</b></h2><p><b>ToDo MVC 的WASM版本</b></p><p>使用了wasm-bindgen</p><p><a href="https://github.com/jonathanKingston/todomvc-wasm">原文</a></p><p><b>ToDoMVC的命令行版本</b></p><p><a href="https://medium.com/@devashishdxt/building-a-command-line-todo-app-in-rust-a89bb7af91c3">原文</a></p><h2><b>「Rust练手小项目」</b></h2><ul><li>统计git commit中的「咒骂」词语: <a href="https://github.com/sondr3/git-anger-management">git-anger-management</a></li><li>Rust语法糖集合，该库提供了作者编写的一些语法扩展，方便使用的宏: <a href="https://github.com/harryfei/sugar-rs">sugar-rs</a></li></ul><h2><b>广告黑洞Pi-hole 开源了Rust实现的Restful API</b></h2><p>基于Rocket实现</p><p>pi-hole可以阻止超过100,000个广告服务域</p><p><a href="https://pi-hole.net/">官网</a></p><p><a href="https://pi-hole.net/2018/10/15/announcing-our-restful-api-contributions-welcome/">原文</a></p><p><b>「视频」Bay Rust Meetup上排名前100的crate介绍</b></p><p>该视频介绍了Rust生态系统中前100个crate</p><p>文字总结：<a href="http://thume.ca/crates/">http://thume.ca/crates/</a></p><p><a href="https://watch.cloudflarestream.com/6cc794b568e4b4b19153355e247ff6dd">Read</a></p><p><b>「社区项目」用Rust实现的Avatar头像生成工具</b></p><p><a href="https://github.com/sonmezonur/initials.rs">initials.rs</a></p><hr><h2><b>工具与库</b></h2><p><b>「社区」Rust SGX SDK v1.0.4发布</b></p><p>Rust SGX SDK由百度X-Lab维护，是为英特尔SGX enclaves开发安全可信计算应用程序的便捷框架。</p><p>在此版本中，添加了对最新英特尔SGX SDK 2.3.1的支持，并且（世界上首次）启用了基于SGX远程证明的内存安全Enclave-Enclave / Untrusted-to-Enclave TLS通信。</p><p><a href="https://medium.com/baiduxlab/rust-sgx-sdk-v1-0-4-released-9c7d9056a888">Read</a></p><p><b>「新语言」Rust实现的高效编程语言Formality</b></p><p>可用于写智能合约</p><p>特性：</p><ul><li>具有形式证明，可用于定理证明，Readme里还有一个证明<code class="inline">a + b == b + a</code>的示例</li><li>无GC</li><li>兼容EVM ，可以运行以太坊合约</li><li>兼容GPU，可以编译为OpenCL/CUDA</li><li>简单，2k行代码实现</li></ul><p>看上去目前还未完善，还有很多工作要做</p><p><a href="https://github.com/MaiaVictor/formality">formality</a></p><p><b>K8s的Rust客户端</b></p><p><a href="https://github.com/ynqa/kubernetes-rust">kubernetes-rust</a></p><h2><b>Welle： ApacheBench的Rust实现</b></h2><p><a href="https://github.com/rylev/welle">welle</a></p><p><b>「工具」envy： 新的配置工具</b></p><p>envy是基于serde实现的环境配置工具。它通过序列化/反序列化的手段，可以将外部环境的参数转为Rust中的类型。</p><p>看上去非常方便使用</p><p><a href="https://medium.com/@softprops/configuration-envy-a09584386705">Read</a></p><p><a href="https://github.com/softprops/envy">envy</a></p><p><b>「工具」ruplacer：查找并替换源文件中的文本</b></p><p><a href="https://dmerej.info/blog/post/ruplacer/">Read</a></p><p><a href="https://github.com/SuperTanker/ruplacer">ruplacer</a></p><p><b>libdiffuzz：面向安全的Memory Sanitizer替代品</b></p><p>可用于检测未初始化内存的使用。</p><p>之前在「我如何在流行的crate里发现漏洞」中介绍过的检测未初始化内存的工具，被作者用Rust重写了。</p><p>之前新闻的链接 <a href="https://t.me/rust_daily_news/1308">Read More</a></p><p><a href="https://github.com/Shnatsel/libdiffuzz">libdiffuzz</a></p><p><b>「社区」Inkwell：安全暴露LLVM的包装器</b></p><p>Inkwell旨在通过安全地包装llvm-sys来帮助你编写自己的编程语言</p><p><a href="https://github.com/TheDan64/inkwell">Inkwell</a></p><p><b>「crate介绍」 很多派生宏 derive_more 0.13.0  发布</b></p><p>derive_more 是一个提供了很多derive宏的第三方包。</p><p>在新版本中新增了自动派生Display的功能</p><p><a href="https://jeltef.github.io/derive_more/derive_more/display.html">Readme</a></p><p><a href="https://github.com/JelteF/derive_more">derive_more</a></p><p><b>「小工具」快速在命令终端访问你喜欢的网站</b></p><p>群友 Hisriver 写的一个小工具，他在去年写了一个浏览器插件「付费」Anyshortcut（<a href="https://anyshortcut.com/%EF%BC%89%EF%BC%8C%E4%BB%8A%E5%B9%B4%E7%94%A8Rust%E6%8A%8A%E8%BF%99%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD%E6%90%AC%E5%88%B0%E4%BA%86%E7%BB%88%E7%AB%AF%E4%B8%8A%EF%BC%8C%E7%BB%88%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%9A%82%E4%B8%8D%E6%94%B6%E8%B4%B9%E3%80%82">https://anyshortcut.com/），今年用Rust把这个浏览器插件的功能搬到了终端上，终端功能暂不收费。</a></p><p>感兴趣的可以关注和使用</p><p><a href="https://www.reddit.com/r/rust/comments/9ptvwq/show_reddit_a_rust_cli_tool_to_help_you_launch/">Read More </a></p><p>源码 <a href="https://github.com/anyshortcut/anyshortcut-cli">anyshortcut-cli</a></p><hr><h2><b>招聘</b></h2><p><b>「Job」医疗初创项目招聘Rust工程师 「旧金山/全职/非远程/薪酬/股权」</b></p><p>致力于改善医疗软件，拯救医生。 技术栈：Rust/node/react</p><p>也包括特定领域机器学习和细粒度的应用安全挑战</p><p><a href="https://www.reddit.com/r/rust/comments/9ohzyd/jobs_commure_healthcare_software_startup_hiring/">原文</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
