<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TypeScript Type-Level Programming</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/54182787">原文</a></p>
<p>TypeScript 有着足够强大（？）的类型系统，我们可以用它做类型层面的编程。首先来看如何在类型层面表达编程的几个要素：数据（广义地指可供编写者操作的所有实体）、操作变换数据的原语和控制流（广义，包括命令式的<code>loop</code>以及所谓函数式的<code>recursion</code>等）。</p><h2><b>数据及其基本变换</b></h2><p>TypeScript 中有 N 个原生类型：来自 JS 的 number, boolean, string, null, undefined, ...，以及 TS 中独特的 literal type（string, number, boolean literal 如 'foo', 1, true 可作为类型，其值域只包含<i>自己</i>，即 let a: 1 这个变量中只能存放 1 ），<b>这些类型都可以在类型编程中作为基本数据对象</b>，供我们操作。在此之上，我们可以借助 TS 的类型系统构造两种复合对象：“list” 和 “dict”。</p><p>我们把 TS 中所有的 object types （如 <code>{ a: number, b: string}</code>）定义为 dict。除了这种“literal dict”之外，可以用 TS 中的 Mapped Types 从一个 dict 得到另一个 dict：</p><div class="highlight"><pre><code class="language-ts"><span></span><span class="p">{[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">:</span> <span class="cm">/* do sth. to K or T[K] */</span><span class="p">}</span>
</code></pre></div><p><b>Mapped Types 可以看作对原 dict 的 "values"作 map 变换（保留 keys 不变）得到的一个新的 dict</b>。</p><p>我们把 TS 中的 Union Type 定义为 list。要得到一个 list，除了最简单的“literal union type”之外，还有如下几种构造方式：</p><div class="highlight"><pre><code class="language-ts"><span></span><span class="nx">type</span> <span class="nx">T</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">b</span>: <span class="kt">string</span> <span class="p">}</span>
<span class="nx">keyof</span> <span class="nx">T</span>  <span class="c1">// 'a' | 'b'，类比 dict.keys()</span>
<span class="nx">T</span><span class="p">[</span><span class="nx">keyof</span> <span class="nx">T</span><span class="p">]</span>  <span class="c1">// number | string，对一个 dict 进行“lookup with unioned key”得到 Union Type，类比 dict.values()</span>
</code></pre></div><p>结合 Mapped Types 和 Lookup Types，我们可以得到一个普适的对 list 进行 map的方法：</p><div class="highlight"><pre><code class="language-ts"><span></span><span class="p">{[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">KS</span><span class="p">]</span><span class="o">:</span> <span class="cm">/* do sth. to K */</span><span class="p">}[</span><span class="nx">KS</span><span class="p">]</span>
</code></pre></div><p>KS 是任意的一个 list，这样我们就能得到一个对 KS 的每个元素做变换后的 list。问题是，怎么对每个元素做变换呢？</p><h2><b>控制流</b></h2><p>最显而易见的是 Conditional Types，它可以用来实现分支结构。如：</p><div class="highlight"><pre><code class="language-ts"><span></span><span class="kd">let</span> <span class="nx">v</span><span class="o">:</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span> <span class="kr">extends</span> <span class="nb">Function</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span>
</code></pre></div><p>上面 v 的<i>类型</i>是 <code>true</code>。</p><p>注意这里引入了<code>extends</code>用于判断子类型关系，可以作为谓词判断某一陈述的真假。</p><p>结合 conditional typing 与 <code>never</code>的特性（<code>never</code>是关于<code>|</code>运算的幺元，即<code>a | never</code>等于<code>a</code>），我们可以对 list 做 filter 操作：</p><div class="highlight"><pre><code class="language-ts"><span></span><span class="nx">type</span> <span class="nx">T</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">b</span>: <span class="kt">string</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nx">numbers</span><span class="o">:</span> <span class="p">{[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span> <span class="kr">extends</span> <span class="kt">number</span> <span class="o">?</span> <span class="nx">T</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span> <span class="o">:</span> <span class="nx">never</span><span class="p">}[</span><span class="nx">keyof</span> <span class="nx">T</span><span class="p">]</span>  <span class="c1">// numbers: { a: number | never } 即 { a: number }</span>
</code></pre></div><p>在此基础上应用 lookup 即可实现对 dict 的 filter 操作。</p><p>如果说判断子类型关系相当于<code>&lt;=</code>（I mean, in type lattice），那么我们还希望它能够判断<code>=</code>的关系。由<code>a ≤ b /\ b ≤ a  =&gt;  a = b</code>我们可知，只要能判断<code>&lt;=</code>并能够进行逻辑与运算，就能判断相等关系。可惜的是 TS 并没有在这种“type condition”中为我们提供“与”逻辑，所以我们用嵌套的条件判断来表示“与逻辑”：</p><div class="highlight"><pre><code class="language-ts"><span></span><span class="nx">type</span> <span class="nx">Func</span> <span class="o">=</span> <span class="nb">Function</span>
<span class="kd">let</span> <span class="nx">v</span>: <span class="kt">Function</span> <span class="kr">extends</span> <span class="nx">Func</span> <span class="o">?</span> <span class="p">(</span><span class="nx">Func</span> <span class="kr">extends</span> <span class="nb">Function</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="p">)</span> <span class="o">:</span> <span class="kc">false</span>  <span class="c1">// v7: true</span>
</code></pre></div><p>“非”、“或”逻辑同理，只需调整层次结构和分支顺序，我们就能实现任意的布尔逻辑了。</p><p>上面的这个判断相等的 pattern 很好用，我们可以把它放进一个函数……等等，函数？</p><p><b>Generic Type Declaration！</b></p><p>把上面的这种分支逻辑，放进一个带有类型参数的类型声明（别名）里，即可作为一个 type-level function，在需要时使用：</p><div class="highlight"><pre><code class="language-ts"><span></span><span class="nx">type</span> <span class="nx">Equal</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="nx">U</span> <span class="o">?</span> <span class="p">(</span><span class="nx">U</span> <span class="kr">extends</span> <span class="nx">T</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="p">)</span> <span class="o">:</span> <span class="kc">false</span>
<span class="kd">let</span> <span class="nx">v</span>: <span class="kt">Equal</span><span class="o">&lt;</span><span class="nx">Func</span><span class="p">,</span> <span class="nb">Function</span><span class="o">&gt;</span>  <span class="c1">// v: true</span>
</code></pre></div><p>有了函数，很自然地想到递归。不过目前 TypeScript 只支持 recursive mapped types，也就是说我们的“递归函数”只能返回 dict。作为一个有点牵强的例子，想象这样一个情景：有一种 object type T，它的 field 要么也是 T 类型的 object，要么是 <code>Promise&lt;U&gt;</code>；我们有一个函数将这种 object 里所有的 <code>Promise</code> 变成其结果（等待所有 <code>Promise</code> resolve ，记录结果并替换），那么如何描述这个函数的类型？</p><div class="highlight"><pre><code class="language-ts"><span></span><span class="nx">type</span> <span class="nx">Unwrapped</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nx">infer</span> <span class="nx">U</span><span class="o">&gt;</span> <span class="o">?</span> <span class="nx">U</span> : <span class="kt">Unwrapped</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="nx">type</span> <span class="nx">Unwrap</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">wrapped</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Unwrapped</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>
</code></pre></div><p>这里我们的 <code>Unwrapped</code>除了使用类型参数之外还使用了条件类型里的<code>infer</code>语法来引入新的 local binding，算是某种意义上的“<b>模式匹配</b>”。在普通的编程语言里，我们对 ADT 的值作模式匹配；而在我们的 type-level programming 里，我们对有着“代数类型类型”的类型作模式匹配。ADT 有 data constructor，它们其实就是普通的函数；而我们的“ATT”当然也对应地有 type constructor，比如 <code>Promise</code>就是一个把<code>T</code>这个类型变换成<code>Promise&lt;T&gt;</code>这个类型的“类型函数”。在我们的类型世界中，“代数类型类型”是除了 primitives 和 list, dict 之外构造数据的第三种方法。</p><p>我们可以尝试用这个代数类型来实现经典的自然数：</p><div class="highlight"><pre><code class="language-ts"><span></span><span class="nx">type</span> <span class="nx">Zero</span> <span class="o">=</span> <span class="k">void</span>
<span class="nx">type</span> <span class="nx">Succ</span><span class="o">&lt;</span><span class="nx">N</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">pred</span>: <span class="kt">N</span> <span class="p">}</span>
<span class="nx">type</span> <span class="nx">Nat</span><span class="o">&lt;</span><span class="nx">N</span> <span class="o">=</span> <span class="nx">Zero</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">Zero</span> <span class="o">|</span> <span class="nx">Succ</span><span class="o">&lt;</span><span class="nx">N</span><span class="o">&gt;</span>
<span class="nx">type</span> <span class="nx">One</span> <span class="o">=</span> <span class="nx">Succ</span><span class="o">&lt;</span><span class="nx">Zero</span><span class="o">&gt;</span>
<span class="nx">type</span> <span class="nx">Two</span> <span class="o">=</span> <span class="nx">Succ</span><span class="o">&lt;</span><span class="nx">One</span><span class="o">&gt;</span>
<span class="err">​</span>
<span class="nx">type</span> <span class="nx">IsNat</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="nx">Nat</span><span class="o">&lt;</span><span class="nx">infer</span> <span class="nx">N</span><span class="o">&gt;</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span>
<span class="nx">type</span> <span class="nx">ZeroIsNat</span> <span class="o">=</span> <span class="nx">IsNat</span><span class="o">&lt;</span><span class="nx">Zero</span><span class="o">&gt;</span> <span class="c1">// true</span>
<span class="nx">type</span> <span class="nx">OneIsNat</span> <span class="o">=</span> <span class="nx">IsNat</span><span class="o">&lt;</span><span class="nx">One</span><span class="o">&gt;</span>  <span class="c1">// true</span>
<span class="nx">type</span> <span class="nx">NumberIsNat</span> <span class="o">=</span> <span class="nx">IsNat</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span>  <span class="c1">// false</span>
<span class="nx">type</span> <span class="nx">IsNatIsNat</span> <span class="o">=</span> <span class="nx">IsNat</span><span class="o">&lt;</span><span class="nx">IsNat</span><span class="o">&gt;</span>  <span class="c1">// error! IsNat cannot be used like this!</span>
</code></pre></div><p><code>Succ</code> 并不一定要有上述代码所示的结构，只是因为 TS 采用的是 structural typing，所以我们只要保证不同等级的 <code>Succ</code> 有不同的结构即可。用 pattern match 我们可以构造一个谓词函数，用来判断一个类型是否属于我们定义的代数类型。</p><p>有意思的是最后一句，我们将 <code>IsNat</code> 传给 <code>IsNat</code>，期望的答案是 <code>false</code>，即 <code>IsNat</code> 作为一个函数，不属于代数类型 <code>Nat</code>；而 TypeScript 编译器告诉我们</p><p><code>Generic type 'IsNat' requires 1 type argument(s).</code> </p><p>这就是我们常说的，“函数不是一等公民”。</p><p><i>- THE END -</i></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
