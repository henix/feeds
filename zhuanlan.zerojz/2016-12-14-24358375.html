<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[4068] 闲谈世上最难的逻辑问题</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/24358375">原文</a></p>
首先声明这并不是一片朋友圈文章，标题中的“世上最难”不是我说的，是wikipedia说的（见<a href="https://en.wikipedia.org/wiki/The_Hardest_Logic_Puzzle_Ever" class="" data-editable="true" data-title="The Hardest Logic Puzzle Ever">The Hardest Logic Puzzle Ever</a>）。<p>故事的开始是苦逼的博士狗们一起赶作业，然后<a href="https://www.zhihu.com/people/75a2edc58ed3e8fd89df5ecf7f8f872d" data-hash="75a2edc58ed3e8fd89df5ecf7f8f872d" class="member_mention" data-editable="true" data-title="@尘锐案" data-hovercard="p$b$75a2edc58ed3e8fd89df5ecf7f8f872d">@尘锐案</a> 突然就把这个东西搬了出来，然后大家瞬间两眼放光，纷纷抛弃了作业……当然主要的讨论都是<a href="https://www.zhihu.com/people/055e67cff14ec9b20cceccf5649052e3" data-hash="055e67cff14ec9b20cceccf5649052e3" class="member_mention" data-title="@Y. Huang" data-editable="true" data-hovercard="p$b$055e67cff14ec9b20cceccf5649052e3">@Y. Huang</a> 和<a href="https://www.zhihu.com/people/75a2edc58ed3e8fd89df5ecf7f8f872d" data-hash="75a2edc58ed3e8fd89df5ecf7f8f872d" class="member_mention" data-editable="true" data-title="@尘锐案" data-hovercard="p$b$75a2edc58ed3e8fd89df5ecf7f8f872d">@尘锐案</a> 进行的，我只是听懂并且理解了他们的做法，不过实在是很有意思，所以记录一下：</p><h2>1.问题</h2><p>问题的是这样的：世上存在三个神，分别是True，False和Random。其中</p><ul><li>T神只说真话</li><li>F神只说假话</li><li>R神每次在听完问题后，抛一枚硬币来决定说真话还是说假话</li></ul><p>它们现在就在你面前，但是你不知道哪个神是哪个神。你有三次机会来试探，每次机会你可以说出一个Statement，并找其中一位神来给出判断（true/false）。 神总是能听懂你的语言，并给出按照它设定的回答，但是它会用自己的语言来回答，它会回答X或Y。你知道其中一个代表true，另一个代表false，但是并不知道哪个代表哪个。</p><p>问题来了：你能在用完三次机会后，判断出三位神各自的身份吗？</p><br><p>下面是答案👇</p><p>下面是答案👇<br></p><p>下面是答案👇<br></p><p>下面是答案👇<br></p><p>下面是答案👇<br></p><p>下面是答案👇<br></p><p>下面是答案👇</p><p><b><u>先仔细考虑之后，再看答案！</u></b></p><p>下面是答案👇<br></p><p>下面是答案👇<br></p><p>下面是答案👇<br></p><p>下面是答案👇<br></p><p>下面是答案👇</p><p>下面是答案👇</p><h2>2.答案</h2><p>答案是：可以。</p><br><p>甚至我们可以做到更强：每次都可以随机问一个神（In particular，可以做到每次都问同一个神，或者依次问完所有神）<br></p><p>事实上，我们有如下定理</p><p>定理：对于任意一个Statement <equation>Q</equation>，存在一个Statement<equation>P(Q)</equation>，使得任意一位神对<equation>P(Q)</equation>给出的判断，在我们自己给定的翻译下，都是对<equation>Q</equation>正确的判断。</p><p>而这个<equation>P(Q)</equation>的存在性，是我们反推出来的。当时的情况是：<a href="https://www.zhihu.com/people/055e67cff14ec9b20cceccf5649052e3" data-hash="055e67cff14ec9b20cceccf5649052e3" class="member_mention" data-title="@Y. Huang" data-editable="true" data-hovercard="p$b$055e67cff14ec9b20cceccf5649052e3">@Y. Huang</a>不知道从哪里知道了有这个定理，于是我(ta)们(yi)一(ge)起(ren)把这个<equation>P(Q)</equation>推导了出来。</p><p>事实上，考虑如下的一个图：<equation>Q\rightarrow P(Q)\rightarrow^{\text{God}} \{X,Y\}\rightarrow^I \{T,F\}</equation>。这里，God箭头表示神给出了判断，<equation>I</equation>是我们自己对神的语言的解释，我们希望最后这个复合函数给出了<equation>Q</equation>的判断，也就是说，我们希望如下的复合是一个恒等映射</p><equation>\{T,F\}\rightarrow^P \{T,F\}\rightarrow^{\text{God}} \{X,Y\}\rightarrow^I \{T,F\}</equation><p>所以我们有<equation>I\circ \text{God }\circ P =\text{id}</equation>，我们对God函数唯一知道的事情是：它是一个双射。也就是说，它一定会把<equation>T</equation>(true)映射到<equation>X,Y</equation>中的一个，然后把<equation>F</equation>(false)映射到另一个。所以我们可以写下如下等式：<equation>P=\text{God}^{-1}\circ I^{-1}</equation></p><p>我们好像几乎做完了（因为找到了<equation>P</equation>的表达式），但是又好像什么都没做（<equation>\text{God}^{-1}</equation>是个什么鬼！）</p><p>我们作如下观察：</p><ol><li><equation>I</equation>是我们<b>自己选择</b>的解释，所以我们可以给出自己的规定，比如：<equation>I(X)=F,I(Y)=T</equation>。也就是说，God说X，我们就认为它说False；God说Y，我们就认为它说True。<br></li><li>假如<equation>I\circ \text{God }\circ P </equation>把<equation>T</equation>映射到<equation>T</equation>，那么它已经是个恒等映射了。因为每一步都是双射，而一共只有两个元素，只要一个元素对，另一个元素就一定是正确的。</li></ol><p>所以我们只需要<equation>\text{God}\circ P(T)=I^{-1}(T)=Y</equation>，下面是睁大眼睛的时刻：</p><p>假如<equation>P(T)</equation>是true statement， 也即<equation>P(T)=T</equation>，我们有如下等价</p><equation>P(T)\Leftrightarrow P(T)=T \Leftrightarrow \text{God}(P(T))=\text{God}(T) \Leftrightarrow Y=\text{God}(T)</equation><br><p>所以！<equation>P(T)</equation>这个statement就是在说<equation>\text{God}(T)=Y</equation>，翻译一下就是：你对“truth”的判断是<equation>Y</equation>。</p><p>我们来考虑一下真值表，假设神的语言是<equation>X</equation>代表true，<equation>Y</equation>代表false</p><ul><li>假如是True神，那么对它来说： truth的判断是<equation>X</equation>。所以我们的statement是假的，从而它要说<equation>Y</equation>。经过我们的解释函数<equation>I</equation>，我们得到了回答<equation>T</equation>。<br></li></ul><br><li>假如是False神，那么对它来说：truth的判断是<equation>Y</equation>。所以我们的statement是真的，从而它要说<equation>Y</equation>。经过我们的解释函数<equation>I</equation>，我们得到了回答<equation>T</equation>。</li><p>现在我们可以把<equation>T</equation>换成我们想要的任何statement <equation>Q</equation>了。</p><p>比如，<equation>Q=</equation>你是True神</p><p>延续上面的语言设定（<equation>X</equation> for ture，<equation>Y</equation> for false），那么我们问神的statement是：你对“你是True神”的判断是<equation>Y</equation>，然后</p><ul><li>假如是True神，那么<equation>Q=T</equation>，根据我们上面的分析，我们可以得到<equation>T</equation>的回答，注意这个<equation>T</equation>是针对<equation>Q</equation>的判断，所以我们知道这个神就是True神</li><li>假如是False神，那么<equation>Q=F</equation>，所以它对<equation>Q</equation>的判断是<equation>X</equation>。再看我们的statement，发现我们的statement也是假的，所以它要说反话，从而给出<equation>X</equation>的回答，而我们的翻译（<b>注意这里是<equation>I</equation>函数而不是上面的语言设定</b>）说<equation>X</equation>代表false，所以这个不是True神</li><li>假如是Random神，那么<equation>Q=F</equation>。假如它选择说假话，那么和False神一样的推到给出它的回答是<equation>X</equation>；假如它选择说真话，那么它对<equation>Q</equation>的判断是<equation>Y</equation>，从而我们的statement是对的，所以它会说<equation>X</equation>。但是解释函数告诉我们，这意味着<equation>Q</equation>是假的，所以这个也不是True神！</li></ul><p>我们看到，只有True神会给出true的回答，其余都是false，所以接下来我们只要一个个问就行了。</p><br><p>Remark：我们可以看到，我们的提问方式保证了不仅仅可以无视问的是哪位神（因为总是可以得到正确的回答），而且不依赖神的语言！即使说神互相之间的语言也可以是不一样的，比如True神对true说<equation>X</equation>，Random神对false说<equation>X</equation>，而我们可能两个神都会问到，甚至用同一个解释函数<equation>I</equation>去解释它们的回答，我们仍然可以得到正确的答案！</p><br><p>Generalized Problem：上述问题中，Random神是在回答问题前，选择接受True神或者False神的设定，再作回答。可以看到我们的答案完全可以忽略Random神，因为当它抛完硬币后，它就被归到True神或者False神的情况里。所以呢，Random神很不高心，现在它要秀一下存在感：它决定通过抛硬币来决定它的回答（而不是回答方式）！</p><p>也就是说，每次Random神给出的判断完全就是抛硬币的结果，而和你问什么完全没有关系。它完全不给出任何信息量。现在还是三次机会问三个神，请问：你还可以找到一个方法区分这三位神吗？</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
