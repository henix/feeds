<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Some Problems Of URLs</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/30958554">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-7afd5fa7e6e4b41cc8b2a80c41f08ad7_r.jpg" alt=""></div><h2><b>背景</b> </h2><p>统一资源定位符（<a href="https://tools.ietf.org/html/rfc1738">URL</a>）是一种数据结构和相关的序列化格式，其目的是唯一的定位互联网（或其他网络）上的资源。（另请参阅<a href="https://tools.ietf.org/html/rfc3986">统一资源标识符</a>）。这是一个宏大的目标，但 URL 已经或多或少的被证明是易于操作和使用的，真令人感叹！全局命名空间使应用程序变得强大，也使它们之间的交互成为可能。 </p><p>但是，URL 在可用性、安全性和经济性方面仍存在一些问题。大多数人都希望全局命名空间能够不断完善。接下来我将全面的谈谈关于 URL 的问题，后面会探讨一些技术细节，你也可以直接跳到后面部分。 </p><h2><b>命名的重要性 </b></h2><p>URL 的可用性是非常差的，不仅在于其复杂的结构，还在于它模糊、不易阅读（<a href="https://noncombatant.org/2017/11/07/problems-of-urls/#syntaxyness">syntaxy</a>）的表现形式。复杂的结构有时并不是必需的。 </p><p>URL 的可用性比较差，这对于像 URL 和 DNS 这样的分布式命名方案的倡导者来说是一种缺陷。人们有时候会提出使用一种集中化的命名方案来减少混乱，从而增强 URL 的可用性和安全性。他们确实提出了一种观点，我们就此来探讨一下。 </p><p>例如，我同事<a href="https://medium.com/@owencm/rethinking-url-bars-as-primary-browser-ui-e2118339d2c0">欧文▪坎贝尔-摩尔（Owen Campbell-Moore）认为</a> <a href="https://medium.com/@owencm/rethinking-url-bars-as-primary-browser-ui-e2118339d2c0">URL</a> <a href="https://medium.com/@owencm/rethinking-url-bars-as-primary-browser-ui-e2118339d2c0">带来的问题很难避免</a>，并且希望搜索引擎提供一种信任机制，在对人们有意义的名字和源或 URL 之间做一种映射。 </p><p>然而，这需要搜索引擎或其它集中命名机构是值得信任的，做到这一点却很困难： </p><img src="https://pic3.zhimg.com/v2-d1348dedd11af6e4f541fbde8919bd79_r.jpg" data-caption="“这是可怕的雷区”—— Cristian Vat on Twitter " data-rawwidth="552" data-rawheight="459"><p>同样，谷歌搜索 [<a href="https://www.google.com/search?q=download+chrome">下载</a> <a href="https://www.google.com/search?q=download+chrome">Chrom</a>e ] 的结果虽然大多数是正确合法的，但是在搜索结果的第一页仍然存在一些虚假的东西（至少在我写作的时候和我所能记得的情况）。事实上，我们常常反复遇到这么一个问题，就是最顶端的搜索结果往往是不准确的。谷歌的搜索引擎不能准确的找到谷歌的浏览器，从某种意义上说，谷歌似乎并没有把它放在可信范围之内。哎…… </p><p>或许机器学习可以有效的识别这种恶搞，比如通过比较名字和图标的相似度且从人的视角来审视它们的准确性。这将加快发现潜在恶搞信息的过程，提高集中命名机构的可信度，但是我们仍然依赖于权威。 </p><p>显然，在这篇的大部分内容中，我都赞同欧文关于 URL 缺陷的观点，但我却不认同采用集中命名机构的做法，也不应该转向另一种解决方案。 </p><p>我认为欧文提出的问题可以通过探讨下面这问题来解决： </p><p>“源并不是用户友好的” </p><p>我完全同意 URL 可用性差这一点，但我认为源（<a href="https://tools.ietf.org/search/rfc6454">scheme, host, port tuple</a>）可以变得更加具有可用性，如果成功的解决了这个技术问题，这将缓解集中命名机构的压力。 </p><p><b>增强源的可用性 </b></p><p>我们可以通过改变 URL 地址栏的以下几个方面来增强源的可用性： </p><ol><li>仅显示主机名。没有端口和协议，必要情况下也可以考虑只展示有效的 TLD（top level domain,顶级域名）+1 标签，即 eTLD+1。事实上这将被证明是必要的和有用的。 </li><li>只为非安全的协议显示安全标识符，比如 Chrome 的 “Not Secure” 标签。 </li><li>不为安全的协议显示安全标识符。 </li><li>继续弃用和移除不安全的协议。理想情况下，随着 HTTPS-ify （HTTPS 认证 ）的持续发展，人们以后能看见的协议恐怕就只有 HTTPS 这一个了。 </li></ol><p>Safari 浏览器已经完成了上述大部分工作，尽管有一点我认为是错误的：对于一些有扩展验证的站点（EV，Extended Validation ），它显示了 EV 的名字而不是前面所说的 eTLD+1。这也让 goat-worms（山羊蠕虫）变得有机可乘（<a href="https://noncombatant.org/2017/02/15/decoding-chromes-https-ux/#what-about-extended-validation-certificates">相关的文章</a>）。但是通过 Safari 浏览器的尝试也能瞥见 URL 命名方式的美好未来。桌面文件也大胆的采用这种方式，在你点击关注地址栏之前仅仅显示主机名。 </p><img src="https://pic2.zhimg.com/v2-8b57135dd2b6aad503f5d9b4950d021c_r.jpg" data-caption="很棒，不是吗？ " data-rawwidth="648" data-rawheight="135"><p>事实上，eTLD+1、主机名和复制粘贴部分内容是大多数人采用的方式。为了提高 URL的可用性和安全性，应用程序和平台的开发者只需要按照以下流程来工作： </p><p>（在做了上面提的一些方面后或多或少仍有一些问题。）</p><p>1、异常的主机名仍然令人困惑。       </p><p>        1、我认为困惑本身对人们来说是有用的，具有良好形态的主机名，     像“facebook.com”、“baidu.com”就创建了一个好的品牌。主机名在广告和大众文化中是很普及的。</p><p>       2、异常的主机名本身就是易于区分的，比如，“facebook.com”和“facebook.com.wumpgarble.phishing.blog”，特别是当使用eTLD+1时，“phishing.blog”显然不是“facebook.com”。 </p><p>      3、正如baidu.com和mixi.jp，它们甚至可以跨越语言和字符集屏障使用，尽管有IDN（Internationalized domain name，<a href="https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E5%8C%96%E5%9F%9F%E5%90%8D#cite_note-1">国际化域名</a>）可以提供帮助。 </p><p>2、人们需要分享链接，开发人员也需要读、写和修改它们。 </p><p>     1、我想我们可以通过在地址栏获得焦点时使整个URL可见和可编辑来处理这个问题。</p><p>3、同形异意词攻击仍然存在 </p><p>    1、集中命名机构也有这个问题 </p><p>    2、应对这个机制的方法可以在集中式或分散式的命名方案中起到作用。 </p><h2><b>问题 </b></h2><p>URL 几乎变成了用户界面的组件：人们期望可以编辑 URL，复制粘贴它们，（至少部分地）解析它们以提取出相关的安全信息，有时也会修改它们，所有这些甚至可以在一个小小的手机屏幕上完成。 </p><p>事实证明这并不是太好，因为为了实现这些目标，URL 必须相当复杂，即使在最简单的情况下对象序列化和反序列化也难以实现。最后的问题就是人们很难在实际应用中使用 URL。 </p><p><b>URLs 的复杂性 </b></p><p>尽管 <a href="https://cs.chromium.org/chromium/src/url/gurl.h?sq=package:chromium&amp;dr=CSs&amp;l=472">Chrome</a> <a href="https://cs.chromium.org/chromium/src/url/gurl.h?sq=package:chromium&amp;dr=CSs&amp;l=472">使用的实现方法更加复杂</a>（另请参阅 <a href="https://cs.chromium.org/chromium/src/url/third_party/mozilla/url_parse.h?sq=package:chromium&amp;dr=CSs&amp;l=77">url::Parsed</a>），我们可以想象，URL 的结构实际上不需要太复杂，比如： </p><code lang="java">class URL { 
 string scheme 
 string username 
 string password 
 string host 
 string port 
 string path 
 string query 
 string ref    // Also called "fragment". 
} </code><p>有点太简单了。首先，TCP 和UDP 端口号是 16 位无符号整型，并不是随意的字符串。其次，主机可以是 IPV4 的地址也可以是 IPV6 的地址或者其他网络类型的地址。还可以是 DNS主机名、NETBIOS 主机名（Network Basic Input/Output System，网络基本输入输出系统）或某个其他域中的名字。即使仅仅考虑 DNS 和 NETBIOS 主机名，简单的字符串也不能完全涵盖我们所需要的信息。 </p><ol><li>DNS 是分级的（最多有127级），一个名称由一个或多个标签组成，每个标签包含 1 到63 个八位字节数，名称的内部总长度最多可达到 255 个八位字节数的长度。（<a href="https://en.wikipedia.org/wiki/Domain_Name_System#Domain_name_syntax">维基百科</a>） </li><li><a href="https://en.wikipedia.org/wiki/NetBIOS#Name_service">维基百科说</a>，“NetBIOS 名称的长度是 16 个八位字节数的长度，根据具体的实现而有所不同。通常，第 16 个八位字节称为 NetBIOS 后缀，指定资源的类型，可以用来告诉其他应用程序系统提供什么类型的服务”。 这留下了一些问题，但我们不会在此深究。 </li></ol><p>所以，现在让我们的表示方法复杂一点： </p><code lang="java">abstract class NetworkAddress { ... } 
class IPv4NetworkAddress extends NetworkAddress { ... } 
class IPv6NetAddress extends NetworkAddress { ... } 
abstract class HostName { ... } 
class DNSName extends HostName { ... } 
class NetBIOSName extends HostName { ... } 
class HostIdentifier { 
 enum Type { 
   Address, 
   Name 
 } 
 union { 
 NetworkAddress address 
 HostName name 
 } 
} 
class URL { 
 string scheme 
 string username 
 string password 
 HostIdentifier host 
 uint16_t port 
 string path 
 string query 
 string ref  // Also called "fragment". 
} </code><p>我们更加严格的限定了端口，并且 HostIdentifier 是两个抽象类 NetworkAddress 和 HostName 的总和类型。反过来说，抽象类型被实例化为具体的地址和名称，我们已经给出了一些例子。 </p><p>虽然真实的实现细节是很复杂的，但是让我们来进一步假设这个 string 类型是一系列的 Unicode 字符。 </p><p>每个这些假设的类至少有一个序列化函数和至少一个反序列化函数或者是构造函数。即使是IPV4 这样的 4 字节数据结构也能清楚的表示。一个使用了 BSD 套接字函数 inet_aton （反序列化）和 inet_ntoa（序列化）的<a href="https://noncombatant.org/2017/11/07/problems-of-urls/ipv4-parser.c">简单程序</a>能够产生下面相同的效果： </p><code lang="text">Serialized       Deserialized  Reserialized    
222.173.190.239  0xDEADBEEF    222.173.190.239 
0xDEADBEEF       0xDEADBEEF    222.173.190.239 
033653337357     0xDEADBEEF    222.173.190.239 
222.11386607     0xDEADBEEF    222.173.190.239 
222.173.48879    0xDEADBEEF    222.173.190.239 
127.0.0.1        0x7F000001    127.0.0.1       
0x7F000001       0x7F000001    127.0.0.1       
127.1            0x7F000001    127.0.0.1       
127.0.1          0x7F000001    127.0.0.1 </code><p>Chrome 会将 <a href="http://151.101.193.67/">http://0x9765C143</a> 转换为 <a href="http://151.101.193.67/">http://151.101.193.67/</a>，并定位到这个网址去；然而Firefox 会直接定位到 <a href="http://151.101.193.67/">http://0x9765C143</a> 这个地址中去，并不会再地址栏将其先转换为点分十进制。 </p><p><a href="https://en.wikipedia.org/wiki/IPv6_address#Representation">正如维基百科中说的那样</a>，IPV6 地址有自己的表示形式。值得一提的是为了避免冒号分隔的十六进制 IPV6 地址和同样是冒号分隔的端口号产生混乱，IPV6 的地址必须要被包括在一对方括号中：  </p><code lang="text">https://[2001:db8:85a3:8d3:1319:8a2e:370:7348]:443/foo/bar/noodles         
        +---------------IPv6 address --------+  ^          
                                                |              
                                                port  </code><p><b>语法 </b></p><p>每种语言都有很多的语法元字符，尤其是当一些语法元字符根据上下文的不同而产生多种意义时，我就称这种语言具有 “syntaxy” 特性。如果你尝试编写一个 URL 解析器，你会发现它必须要能区分多种情况，（冒号）: 到底是协议 :// 的一部分，还是一个十六进制的分隔符，或者是端口号的分隔符。同样，/ 也至少有两重意思。 </p><p>或许是在不知不觉中，人们需要在大脑中建立相同的状态机制来解析 URL，否则就会陷入困境。除此之外，URL 协议并不是真正的单词，/ 看起来也像是 \，等等这样的情况，人们对URL 这种语言的理解是模糊的，它这并不是一种人们能够轻易掌握的语言。 </p><h2><b>要达到的目标 </b></h2><p>对于 URL 可用性问题的解决方案至少有以下几点属性： </p><ol><li>明确的语法 </li><li>明确划分源的安全 </li><li>书写不能过于繁琐 </li><li>易于阅读（低合成度） </li><li>减少组件以避免混淆并且降低 URL 语法的复杂性 </li></ol><h2><b>缓解措施 </b></h2><p>不能从更根本上思考 URL 就无法真正解决它带来的问题。URL 非常普及，而结构就是它们存在的问题：组成成分过于冗杂。 </p><p>或许我们只能在一定程度上减轻这个问题，或许头脑风暴、集思广益一番会有更多有趣的收获。 </p><p><b>弃用和移除 URL 中的字段 </b></p><p>首先，我们可以把 URL 中不需要的部分或加剧我们研究问题的部分去掉。<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=661005">Chromium issue 661005</a> 有一个很好的例子： </p><p>重现步骤： </p><p>1、  定位到 <a href="https://www.google.com:443+q%3Delon@tesla.com/">https://www.google.com:443+q=elon@tesla.com</a></p><p>2、  由此产生的页面应该是：<a href="https://www.tesla.com/">https://www.tesla.com</a> </p><p>预期的行为是什么？</p><p>警告用户他们将发送登录凭证：</p><p>       -  用户名：“<a href="http://www.google.com/">www.google.com</a>”</p><p>       -   密码：“443+q=elon” </p><p>更严重的是，混在 URL 中的 username 和 password 字段使主机名变得难以区分，并且增加了钓鱼攻击的风险。比如，人们或许会认为 <a href="mailto:https://paypal@phishing.com">https://paypal@phishing.com</a>  是指向 Paypal 这个网站，但是实际上它是指向 phishing.com 的。</p><p><a href="https://support.microsoft.com/en-us/help/834489/internet-explorer-does-not-support-user-names-and-passwords-in-web-sit">Internet Exploer</a> <a href="https://support.microsoft.com/en-us/help/834489/internet-explorer-does-not-support-user-names-and-passwords-in-web-sit">在很久之前就放弃了对嵌入在</a> <a href="https://support.microsoft.com/en-us/help/834489/internet-explorer-does-not-support-user-names-and-passwords-in-web-sit">URL</a> <a href="https://support.microsoft.com/en-us/help/834489/internet-explorer-does-not-support-user-names-and-passwords-in-web-sit">中证书的支持</a>，明智的是，Edge 并没有恢复此支持。Firefox 支持嵌套的证书，但是会对此提出警告。 </p><img src="https://pic3.zhimg.com/v2-12516de41ec5f15425e50d1d7c980a19_r.jpg" data-caption="Firefox会对访问嵌入证书的URL发出警告。" data-rawwidth="671" data-rawheight="261"><p>Chrome 不支持在子资源中使用嵌套证书的 URL，但是<a href="https://xkcd.com/1172/">不可避免</a>的，这会<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=779116">妨碍别人的使用</a>。那么我们似乎可以通过允许他们在子资源的 URL 中尽可能少的使用案例，（像 Firefox）会警告人们当向顶级域名跳转的时候。但如果我们认为问题不仅在于证书嵌套，还在于增加了问题的复杂性、降低了可靠性，也降低了 URL 解析器的一致性，那么证明这个方法并没有解决整个问题。</p><p>由于 IE 和 Edge 浏览器不支持嵌套凭证，在数十年前它们就已经失去了成为可靠的网络平台的特点。为什么 Chrome 和 Firefox 继续放纵这种可能引发钓鱼攻击的行为呢？</p><p>其他语言，比如JSON 面临着严重的可靠性和不一致性的问题，我认为 web 是一个具有前瞻性的平台，它应逐渐去除这些模糊的接口。<a href="https://github.com/brave/browser-laptop/issues/10825">这儿</a>有个与浏览器解析器不一致的问题。  </p><p><b>消除和弃用不规则的主机地址表现形式 </b></p><p>没有任何理由相信用户输入的十六进制、八进制或其他奇怪形式的 IP 地址。它们或许会被用于攻击以掩盖某些东西（尽管点分四组的表示形式足以掩盖主机名的本质）。<a href="https://blogs.msdn.microsoft.com/ieinternals/2014/03/06/browser-arcana-ip-literals-in-urls/">Internet Explore曾经授权（内联网区域）</a> <a href="https://blogs.msdn.microsoft.com/ieinternals/2014/03/06/browser-arcana-ip-literals-in-urls/">URL</a> <a href="https://blogs.msdn.microsoft.com/ieinternals/2014/03/06/browser-arcana-ip-literals-in-urls/">可以在主机名中不使用点号</a>，包括模糊形式的 URL。除了用于攻击，我敢说没有人会使用这些形式的地址。读到这里的读者多少都是对技术有一定了解的，也会惊讶这些奇怪的表现形式的存在。让我们先把这些历史遗留问题抛在一边。  </p><h2><b>大胆的设想 </b></h2><p>这些都是缓解问题的好方法，但是我猜可能已经太迟了。 </p><p><b>同一方向的分层名称</b> </p><p>DNS 主机名和文件名都是 URL 中两种命名方式，也都是采用分层命名，然而走的却是两个相反的方向！ </p><p>在 DNS 域名 <a href="http://www.example.com/">www.example.com</a> 中，com 是 example 的父级域名，example 是 www 的父级域名，域名从左到右依次是子域名到父域名，我称这为<a href="https://en.wikipedia.org/wiki/Endianness">小端命名</a>方式。 </p><p>在路径 /noodles/doodles/poodles.php 中，noodles 是doodles 的父路径，poodles.php 是doodles 下的文件，从左到右依次为从父到子，称这种方式为大端命名方式。 </p><code lang="text">https://www.example.com/noodles/doodles/poodles.php       
        --------------- +++++++++++++++++++++++++++       
          little-endian   big-endian  </code><p>这已经令人十分迷惑了，但是考虑到国际化域名（<a href="https://en.wikipedia.org/wiki/Internationalized_domain_name">IDN</a>）和其他 Unicode  编码方式的 URL 组件时，问题会更加复杂。使问题变得更加棘手的原因是：一些语言从右向左阅读（RTL），如阿拉伯语或希伯来语，而不是像英语一样从左到右（LTR）。进一步考虑，URL可能会同时包含 LTR 和 RTL 组件。（实际上，所有采用 RTL 主机名方式的 URL 都至少有一个 LTR 组件：开头的 https 协议或其他协议） </p><p><a href="https://twitter.com/typhoonfilsy/status/927701344185491456">typhoonfilsy</a> 提供了一个不错的例子： </p><img src="https://pic2.zhimg.com/v2-6a0216152e91733533362082bd4c50f4_r.jpg" data-caption="在主机名和路径中都包含阿拉伯语和英语的URL。" data-rawwidth="399" data-rawheight="42"><p>现在我们有大端和小端命名的两个名字，每个都包含 LTR 和 RTL 的组件。如果命名空间的层次划分都往一个方向，这将是十分有用的，至少会减少一个方向上的困扰。 </p><code lang="text">https://com.example.www/noodles/doodles/poodles.php       
       +++++++++++++++ +++++++++++++++++++++++++++       
         big-endian      big-endian  </code><p>在 RTL 语言中，这样做会更容易混淆： </p><code lang="text">php.seldoop/seldood/seldoon/www.elpmaxe.moc：// HTTPS
+++++++++++++++++++++++++++ ++++++++++++++++  
big-endian                       big-endian
    RTL                          RTL            LTR  </code><p>然而，随着新的顶级域名的扩展（TLDs）,降低了使 DNS 成为大端命名的可能性。比如，blog.google 和 google.blog 都是合法的 DNS 域名（只有前者是目前已经注册并为网站提供实时的服务，另一个与顶级域名扩展有关的问题是提高了欺骗的机会）。交换域名的字节序会使问题更加困惑，至少对于这些形态的例子。 </p><p><b>简化语法 </b></p><p>我们可以假想一种新的 URL 语法，它拥有更少的模糊的语法元字符。这只是一种设想并不是严格的实验，这里假设用逗号来分隔 URL 的组件，用斜杠来分割命名中的不同位置： </p><code lang="text">https,com/example/www,,noodles/doodles/poodles.php 
https,com/example/www,443,noodles/doodles/poodles.php 
https,com/example/www,,noodles/doodles/poodles.php,q=cute%20puppies 
https,com/example/www,,noodles/doodles/poodles.php,q=cute%20puppies,table-of-contents </code><p>与往常一样，在给定组件中使用的元字符必须要进行转义，在查询字符串里逗号被转义为 %2c： </p><code lang="text">https,com/example/www,,noodles/doodles/poodles.php,q=cute%2C%20puppies </code><p>如果用 ,,（两个逗号）表示协议默认的端口使你迷惑的话，我们可以这样： </p><code lang="text">https/443,com/example/www,noodles/doodles/poodles.php 
https/8443,com/example/www,noodles/doodles/poodles.php </code><p>我们也可以考虑给每个 URL 组件加上自己的标签，而不仅仅是依赖它们的顺序。这样会去除默认或可选组件的空占位符。这种形式写起来或许困难但读起来却很容易。 </p><code lang="text">scheme:https,port:443,host:com/example/org 
scheme:https,port:443,host:com/example/org,path:a/b/c 
scheme:https,host:com/example/org,path:a/b/c 
host:com/example/org,path:a/b/c,scheme:https </code><p>现在就要考虑过滤逗号、反斜线和冒号等符号了。 </p><p>现在你该明白了，使用别的不同的语法也是可能的解决方案。 </p><p>到此足矣。 </p><p>感谢 Eric Lawrence 和 Yan Zhu 提供的一些问题实例，并感谢 Emily Stark-Dunn 和Owen Campbell-Moore 阅读早期稿件并提供有益的想法。 </p><p>有问题可以<a href="mailto:chris@noncombatant.org">联系我</a>。</p><p><br></p><p>原文：<a href="https://noncombatant.org/2017/11/07/problems-of-urls/#NamesArePower">Some Problems Of URLs</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
