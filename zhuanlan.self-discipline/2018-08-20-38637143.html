<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>设计模式奏鸣曲（三）：系统边界处的异常处理</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/38637143">原文</a></p>
<p></p><img src="https://pic1.zhimg.com/v2-d600018a0749b2de5d93d09e8fbb9820_r.jpg" data-caption="" data-size="normal" data-rawwidth="1000" data-rawheight="618" data-watermark="watermark" data-original-src="v2-d600018a0749b2de5d93d09e8fbb9820" data-watermark-src="v2-677cd7735b5ff22fa55fe7a23fccb1b4" data-private-watermark-src=""><h2><b>1. 异常流程</b></h2><p>在确定产品功能的时候，人们提到更多的是，该产品应该怎样表现，<br>而实际上，产品所涉及的<b>异常流程</b>是否清晰，<br>才是提高功能<b>可靠性</b>的关键。</p><p>考虑如下一个简单的功能，<br>点击页面中的按钮，发起一个ajax请求，后端读取数据库返回相应的查询结果。</p><p>我们可以把它划分为三个环节，<br>（1）前端发起ajax请求给后端<br>（2）后端接受到请求，调用数据库查询服务<br>（3）查询数据库，返回相应的查询结果</p><img src="https://pic2.zhimg.com/v2-0dba081d3818be3c05c898c6c0ffde6b_r.jpg" data-caption="" data-size="normal" data-rawwidth="532" data-rawheight="298" data-watermark="watermark" data-original-src="v2-0dba081d3818be3c05c898c6c0ffde6b" data-watermark-src="v2-d4d83f73441032ac76d2e55c0371f3ae" data-private-watermark-src=""><blockquote>线性系统的可靠性是每个系统组件的可靠性的乘积。<br>——《<a href="https://book.douban.com/subject/2580604/">持续集成</a>》</blockquote><p>因此，假设以上每个环节的可靠性是 90%，那么整个系统的可靠性，则将只有 72.9%。<br>如果整个系统包含 100 个环节呢？可靠性就只剩下 0.0027% 了！！</p><p>因此，如果在系统层面承诺具有高可靠性，就得在每个环节上下足功夫。</p><h2><b>2. 异常在所难免</b></h2><p>在计算机科学中，<a href="https://zh.wikipedia.org/wiki/%E5%81%A5%E5%A3%AE%E6%80%A7_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">健壮性</a>（robustness）指的是，<br>一个计算机系统在执行过程中处理错误，<br>以及算法在遭遇输入、运算等异常时继续正常运行的能力。</p><p>要想提高代码的健壮性，我认为首先应该改变我们对<b>错误</b>的认知习惯。</p><img src="https://pic1.zhimg.com/v2-edd86dc28bf4ad2327ffb179cf87f64c_r.jpg" data-caption="" data-size="normal" data-rawwidth="266" data-rawheight="190" data-watermark="watermark" data-original-src="v2-edd86dc28bf4ad2327ffb179cf87f64c" data-watermark-src="v2-d35d5a5473a60465a46d2dfe062a4be4" data-private-watermark-src=""><p>我们应该认为，<b>异常是在所难免的</b>，<br>而剩下的问题是，都有哪些异常，以及如何处理它们。</p><p>有一个类似相同的论断，来自于《<a href="https://book.douban.com/subject/25870212/">Reactive Design Patterns</a>》</p><blockquote>The question therefore is not if a failure occurs but only when or how often.</blockquote><p>我们在这个基础上考虑问题。</p><h2><b>3. 如何提供可靠的服务</b></h2><p>人们通常认为，提供可靠的服务，就是不发生错误，<br>我认为这是不太恰当的。</p><p>因为作为底层服务，在出现某些错误的情况下，我们实在<b>不应该替用户拿主意</b>。</p><img src="https://pic4.zhimg.com/v2-ce3fe0307eccf6022192d76879438c2f_r.jpg" data-caption="" data-size="normal" data-rawwidth="398" data-rawheight="336" data-watermark="watermark" data-original-src="v2-ce3fe0307eccf6022192d76879438c2f" data-watermark-src="v2-768cfbb820bd085aacd83176053344fe" data-private-watermark-src=""><p>因此重要的事情，不是吞掉异常让服务看起来可靠，<br>而是，考虑用何种方式<b>将错误呈现给用户</b>，<br>这需要我们站在用户的角度考虑问题。</p><p>当考虑了异常之后，接口所传递的<b>知识</b>就在无形中被扩充了，<br>接口实际上包含了在不同情况下（正常/异常），应该返回什么结果。</p><p><b>3.1 反模式：出错消息</b></p><img src="https://pic3.zhimg.com/v2-ff7064264d096b248174873956be7e9a_r.jpg" data-caption="" data-size="normal" data-rawwidth="312" data-rawheight="180" data-watermark="watermark" data-original-src="v2-ff7064264d096b248174873956be7e9a" data-watermark-src="v2-e6cb499b47e73cec15180a5949233b45" data-private-watermark-src=""><p>返回一段出错消息，是一种最常见的不为用户考虑的<b>反模式</b>，<br>因为用户不得不解析这段消息来确定究竟发生了什么错误。</p><p>这种情况用户一般也不会解析它，<br>而反馈给更上层的用户也是不合理的，<br>因此，这种消息最多保留到了日志中，或者干脆被直接忽略了。</p><p>为了让消息无歧义，更好的办法是返回错误的类型（或者是错误的统一编码），<br>它们会作为接口文档的一部分提供给用户，<br>并由用户决定处理方式。</p><p><b>3.2 反模式：不一致</b></p><p>比无法区分错误类型更好一点，但是同样有问题的报错方式就是，不一致的展示错误，<br>某些接口通过抛异常来报错，<br>另外一些接口统一捕获了异常，通过一个错误标志位来报错。</p><p>无疑这在某种程度上加大了用户代码的复杂度，<br>而且对于用户来说，他们也无法区分一个异常到底是接口的编写者<b>已知的</b>还是<b>未知的</b>。<br>用户无法确认一个使用错误标志位来报错的接口，会不会抛异常。</p><img src="https://pic2.zhimg.com/v2-7d410b501259a7a65cca7f05596e06d1_r.jpg" data-caption="" data-size="normal" data-rawwidth="556" data-rawheight="360" data-watermark="watermark" data-original-src="v2-7d410b501259a7a65cca7f05596e06d1" data-watermark-src="v2-a5842e78663dc6e23640fa350b4c82cb" data-private-watermark-src=""><p>人们的确痛恨不一致性，但是却没有找到问题的症结所在，<br>让接口表现一致，是一种经常被推进，但实际上是一种过于理想化的解决方案。<br>在这一点上，我认为问题的症结在于<b>知识没有被明确的传达给用户</b>。</p><p>例如，如果我们在某个地方明确表明，“通过错误标志位来报错的接口一定不会抛异常”，<br>那么即使某些接口采用了不一致的报错方式，<br>我们仍然可以从容的处理了。</p><p>因此，不一致并没有问题，有问题的是<b>歧义性</b>。</p><h2><b>4. 传递知识</b></h2><p>经过上文的例证，我们看到接口所传递的<b>知识</b>比接口所提供的功能一样重要。<br>为了提供健壮的接口，那就得从一开始告诉用户，<b>不能这样使用</b>。</p><img src="https://pic1.zhimg.com/v2-0126a04bc769b6a379379e962c2b063f_r.jpg" data-caption="" data-size="normal" data-rawwidth="272" data-rawheight="250" data-watermark="watermark" data-original-src="v2-0126a04bc769b6a379379e962c2b063f" data-watermark-src="v2-fcb2da2149c749768939de19ee5a53d7" data-private-watermark-src=""><p>当然，寄希望于用户不会这样使用是没作用的。<br><a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E8%8F%B2%E5%AE%9A%E7%90%86">墨菲定律</a>表明，<b>凡是可能出错的事，迟早会出错。</b></p><p>因此，除了上文讨论如何提供功能之外，<br>我们还要对<b>用户</b>，以及我们的<b>依赖方</b>进行管理。</p><p><b>4.1 用户管理</b></p><p>至少应该在某个地方明确表明，接口总共包含了哪些使用方式，<br>每一种使用方式，<b>预期</b>会得到怎样的结果，<br>越<b>明确</b>越好。</p><img src="https://pic3.zhimg.com/v2-583e0a29c0e41c609df57a67dd1994b8_r.jpg" data-caption="" data-size="normal" data-rawwidth="259" data-rawheight="194" data-watermark="watermark" data-original-src="v2-583e0a29c0e41c609df57a67dd1994b8" data-watermark-src="v2-933434153738de01eb3182538caac765" data-private-watermark-src=""><p>什么时候会出现异常，接口会以什么形式反馈出来。<br>例如，如果用户传入的参数不符合业务逻辑上的约束，接口会怎样表现，<br>接口在调用它的依赖方时出现了错误，应该如何处理。</p><p>这些都应该<b>明确</b>的向用户表明，<br>而不是，让用户<b>假定</b>接口应当采用何种处理方式。</p><p><b>4.2 依赖管理</b></p><img src="https://pic4.zhimg.com/v2-f3ab1a772f7f3cffc307449d87260e89_r.jpg" data-caption="" data-size="normal" data-rawwidth="270" data-rawheight="270" data-watermark="watermark" data-original-src="v2-f3ab1a772f7f3cffc307449d87260e89" data-watermark-src="v2-daed46542c2d1b83a5539361c05e9aee" data-private-watermark-src=""><p>我们要知道有哪些依赖，然后再仔细挖掘被依赖方所隐藏的信息，<br>被依赖方所采用的报错方式，可能并不是我们所期望的，<br>这其实并没有问题，问题是我们要有能力<b>区分</b>它们。</p><p>上文我们也看到了，很多项目都在“<b>让依赖方进行修改</b>”方面做出了无谓的努力，<br>这可能意味着我们在依赖管理方面做的还不够友好。</p><p>实际上，我们并不需要一个“<b>规范</b>的”接口，<br>但是我们需要一个具有“<b>明确</b>含义”的接口。</p><h2><b>结语</b></h2><p>我们来感受一下异常作为一种<b>知识</b>，是如何通过接口来传递的，<br>它如同接口的正常返回值一样。</p><p>可靠性的关键可能不在于表面上它不会出现错误，<br>而是在于，每一种可能出现的错误，都被<b>恰当的责任人</b>进行了处理。</p><img src="https://pic2.zhimg.com/v2-ac5e0852a1bd3b669456d6a591021824_r.jpg" data-caption="" data-size="normal" data-rawwidth="432" data-rawheight="288" data-watermark="watermark" data-original-src="v2-ac5e0852a1bd3b669456d6a591021824" data-watermark-src="v2-fb1e08e6f9e4d71a3303c0f617553d88" data-private-watermark-src=""><p>当我们调用一个接口，它并没有抛异常，而是返回了一个<code class="inline">Null</code>，<br>而且在多种不同的情况下，它都返回<code class="inline">Null</code>，<br>这种接口简直是<b>可笑的</b>。</p><p>我们不得不联系接口的设计者，请他帮忙看看，到底发生了什么事情。<br>这真是一种极大的资源浪费。</p><p>这只是不良接口的一种表现形式而已，<br>所以重要的还是对异常流程，以及异常中所隐藏的<b>知识</b>有所察觉。</p><blockquote>梁惠王曰：“寡人之于国也，尽心焉耳矣。河内凶，则移其民于河东，移其粟于河内。河东凶亦然。察邻国之政，无如寡人之用心者。邻国之民不加少，寡人之民不加多，何也？”<br>孟子对曰：“王好战，请以战喻。填然鼓之，兵刃既接，弃甲曳兵而走，或百步而后止，或五十步而后止。以五十步笑百步，则何如？”<br>曰：“不可。直不百步耳，是亦走也。”<br>曰：“王如知此，则无望民之多于邻国也。“</blockquote>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
