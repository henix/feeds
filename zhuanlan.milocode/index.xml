<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Milo的编程</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Tue, 18 Feb 2020 08:54:24 +0800</lastBuildDate>
<item>
<title>愿你平安</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2020-02-14-106789452.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/106789452&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ce2f5d0e6d924c136652ebff629bf624_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;近年的情人节，我写过不同的程序：&lt;/p&gt;&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; href=&quot;https://www.zhihu.com/question/31482830/answer/318497552&quot; data-image=&quot;https://pic2.zhimg.com/v2-2941287c52be96de6898ec279decb881_ipico.jpg&quot; data-image-width=&quot;1286&quot; data-image-height=&quot;1290&quot; class=&quot;internal&quot;&gt;如何用计算几何模型画一束玫瑰花？&lt;/a&gt;&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; href=&quot;https://zhuanlan.zhihu.com/p/56640030&quot; data-image=&quot;https://pic4.zhimg.com/v2-b845dab3b9ef95ab4a4ffe5a4750e96f_ipico.jpg&quot; data-image-width=&quot;1120&quot; data-image-height=&quot;1054&quot; class=&quot;internal&quot;&gt;Milo Yip：常在我心&lt;/a&gt;&lt;p&gt;但在 2020 年的今天，我想到了挪亚方舟的故事（《创世记》8:6-11）：&lt;/p&gt;&lt;blockquote&gt;过了四十天，挪亚开了方舟的窗户，放出一只乌鸦去；那乌鸦飞来飞去，直到地上的水都干了。他又放出一只鸽子去，要看看水从地上退了没有。但遍地上都是水，鸽子找不着落脚之地，就回到方舟挪亚那里，挪亚伸手把鸽子接进方舟来。他又等了七天，再把鸽子从方舟放出去。到了晚上，鸽子回到他那里，嘴里叼着一个新拧下来的&lt;b&gt;橄榄叶子&lt;/b&gt;，挪亚就知道地上的水退了。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%25A9%2584%25E6%25AC%2596%25E6%259E%259D&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;橄榄枝&lt;/a&gt;（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Olive_branch&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;olive branch&lt;/a&gt;）在西方文化里代表和平、平安、灾难的消退。&lt;/p&gt;&lt;p&gt;所以我这次用 HTML5 canvas，简单地以橄榄枝拼成一个心形。&lt;/p&gt;&lt;p&gt;我只希望，我们和我们关心的人能平安渡过这次灾难。&lt;/p&gt;&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; href=&quot;https://link.zhihu.com/?target=http%3A//miloyip.github.io/misc/sv2020/sv2020.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;miloyip.github.io/misc/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;sv2020/sv2020.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;你可以把链接转发给你关心的人，移动端都应该可以打开。&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1211452907620601856&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;&quot; data-name=&quot;&quot; data-poster=&quot;https://pic2.zhimg.com/v2-cd40d96582db291292a1d028608fad95.jpg&quot; data-lens-id=&quot;1211452907620601856&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-cd40d96582db291292a1d028608fad95.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1211452907620601856&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2020-02-14-106789452</guid>
<pubDate>Fri, 14 Feb 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>使用 Graphviz 绘画 UML 图</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2019-10-29-88835583.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/88835583&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5cb521bd5213630b8a492bd6601cbc8c_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;简介&lt;/h2&gt;&lt;blockquote&gt;本文为开放文档，可在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/miloyip/graphvizuml&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub&lt;/a&gt; 提交 issue／PR。本文的 PDF 版本可在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//miloyip.github.io/graphvizuml/graphvizuml.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;在此下载&lt;/a&gt;。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.graphviz.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Graphviz&lt;/a&gt; 是 AT&amp;amp;T 实验室开发的一个开源软件，它以一种文本语言去描述图（graph），然后自动排布节点和边去生成图片。它已有近 30 年历史。&lt;/p&gt;&lt;p&gt;UML（unified modeling language，统一建模语言）是一种常用的面向对象设计的方法。其中最常用的是类图（class diagram），用于表示类的构成以及类之间的关系。&lt;/p&gt;&lt;p&gt;利用 Graphviz 去生成 UML 类图有几个好处：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;用文本表示图，容易更新，容易做版本管理。&lt;/li&gt;&lt;li&gt;能自动排布节点位置，在大型复杂的图特别方便。&lt;/li&gt;&lt;li&gt;统一文档风格。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;实际上，文档生成工具&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.doxygen.nl/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Doxygen&lt;/a&gt; 也是采用 Graphviz 生成类图的。不过，我们在软件设计中，经常以类图表示系统中某个部分，并且按需展示某些重点，而不是简单地全部列出，所以还是需要手工去描述我们想要画什么，表示我们的软件设计。&lt;/p&gt;&lt;h2&gt;使用 Graphviz dot&lt;/h2&gt;&lt;p&gt;首先，下载 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.graphviz.org/download/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Graphviz&lt;/a&gt; 安装包。macOS 用户可以 &lt;code&gt;brew install graphviz&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;建立一个测试源文件 &lt;code&gt;hello.dot&lt;/code&gt;（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/DOT%25E8%25AF%25AD%25E8%25A8%2580&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DOT语言&lt;/a&gt;为 Graphviz 的图形描述语言）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    Hello -&amp;gt; World
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在命令行执行：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;dot -Tpng hello.dot -o hello.png&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就能生成：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fcb1bc1215556c437adc1e3670992f4c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;483&quot; class=&quot;content_image&quot; width=&quot;300&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fcb1bc1215556c437adc1e3670992f4c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;483&quot; class=&quot;content_image lazy&quot; width=&quot;300&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fcb1bc1215556c437adc1e3670992f4c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;作为程序员，我们可以用常用的 GNU make 去做这个生成，以下的 makefile 也展示生成 PDF 矢量格式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;DOTFILES = $(basename $(wildcard *.dot))

all: \
    $(addsuffix .png, $(DOTFILES)) \
    $(addsuffix .pdf, $(DOTFILES))

%.png: %.dot
    dot $&amp;lt; -Tpng -o $@

%.pdf: %.dot
    dot $&amp;lt; -Tpdf -o $@&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;类图&lt;/h2&gt;&lt;p&gt;UML 类图（class diagram）是最常见的图，用于表示系统的静态结构。UML 中类是以矩形表示。我们可以在 dot 文件中预设节点的形状，并且设置一些如字体等属性：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Foo
    Bar
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9d812d8ee9b39146f1c92a52a53a14ae_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;179&quot; data-rawheight=&quot;59&quot; class=&quot;content_image&quot; width=&quot;179&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9d812d8ee9b39146f1c92a52a53a14ae_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;179&quot; data-rawheight=&quot;59&quot; class=&quot;content_image lazy&quot; width=&quot;179&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9d812d8ee9b39146f1c92a52a53a14ae_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;稍后我们再谈如何加入类的成员。&lt;/p&gt;&lt;h2&gt;继承&lt;/h2&gt;&lt;p&gt;继承（inheritance）是类之间很重要的关系，在 UML 中又称其为泛化（generalization）关系，以空心箭头表示派生类指向基类。在 DOT 语言中，可以设置边的箭头形状，不过要注意，通常我们会把基类放在上面，因此我通常会这样设置：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Animal, Mammal, Reptile, Dog, Cat, Snake

    /* inheritance */
    {
        edge [arrowtail=onormal, dir=back]

        Animal -&amp;gt; { Mammal, Reptile }
        Mammal -&amp;gt; { Dog, Cat}
        Reptile -&amp;gt; Snake
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-16bb86422b5d32af6cbb21d290cd9b44_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;275&quot; data-rawheight=&quot;251&quot; class=&quot;content_image&quot; width=&quot;275&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-16bb86422b5d32af6cbb21d290cd9b44_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;275&quot; data-rawheight=&quot;251&quot; class=&quot;content_image lazy&quot; width=&quot;275&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-16bb86422b5d32af6cbb21d290cd9b44_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;关联&lt;/h2&gt;&lt;p&gt;UML 中的关联（association）描述两个类的关系，以类之间的实线表示。例如人和杂志的关系是订阅：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Person, Magazine

    /* Association */
    {
        edge [dir=none]
        Person -&amp;gt; Magazine [label=&amp;#34; subscribe&amp;#34;]
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4062e2958ca79dad0565bcb936aae067_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;111&quot; data-rawheight=&quot;168&quot; class=&quot;content_image&quot; width=&quot;111&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4062e2958ca79dad0565bcb936aae067_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;111&quot; data-rawheight=&quot;168&quot; class=&quot;content_image lazy&quot; width=&quot;111&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4062e2958ca79dad0565bcb936aae067_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们经常会表示关联之间的多重性（multiplicity），例如 &lt;code&gt;Person&lt;/code&gt; 类的实例最多可订阅 5 本杂志，而每本杂志可被任意数目的人订阅：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]
    edge [fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Person, Magazine

    /* Association with multiplicity */
    {
        edge [dir=none]
        Person -&amp;gt; Magazine [label=&amp;#34; subscribe&amp;#34;, headlabel=&amp;#34;0..10&amp;#34;, taillabel=&amp;#34;* &amp;#34;]
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8d7106016f7b32fde83cc5c44ee2ad25_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;111&quot; data-rawheight=&quot;168&quot; class=&quot;content_image&quot; width=&quot;111&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8d7106016f7b32fde83cc5c44ee2ad25_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;111&quot; data-rawheight=&quot;168&quot; class=&quot;content_image lazy&quot; width=&quot;111&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8d7106016f7b32fde83cc5c44ee2ad25_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;注意，上面的例子在 &lt;code&gt;label&lt;/code&gt;、&lt;code&gt;headlabel&lt;/code&gt;、&lt;code&gt;taillabel&lt;/code&gt; 加入空格避免它们太贴近连线（这不完美）。&lt;/p&gt;&lt;p&gt;关联可以是单向或双向的，以线形箭头表示，无箭头也表示双向关联。以下展示单向关联，面试官知道他对应的候选人，但候选人不知道面试官：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]
    edge [fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Interviewer, Candidate

    /* Unidirection association */
    {
        Interviewer -&amp;gt; Candidate [arrowhead=vee]
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2ad362c65be547450d5f196f4876d235_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;97&quot; data-rawheight=&quot;155&quot; class=&quot;content_image&quot; width=&quot;97&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2ad362c65be547450d5f196f4876d235_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;97&quot; data-rawheight=&quot;155&quot; class=&quot;content_image lazy&quot; width=&quot;97&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2ad362c65be547450d5f196f4876d235_b.png&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;聚合&lt;/h2&gt;&lt;p&gt;聚合（aggregation）是一种特殊的关系，是一种弱的包含关系，包含方以空心菱形表示。例如，一个部门含有一些员工：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]
    edge [fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Department, Employeee

    /* Aggregation */
    {
        edge [dir=back, arrowtail=odiamond, headlabel=&amp;#34;* &amp;#34;]
        Department -&amp;gt; Employeee
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4e54aa100bf23b7e16256e599ba27ed4_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;102&quot; data-rawheight=&quot;155&quot; class=&quot;content_image&quot; width=&quot;102&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4e54aa100bf23b7e16256e599ba27ed4_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;102&quot; data-rawheight=&quot;155&quot; class=&quot;content_image lazy&quot; width=&quot;102&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4e54aa100bf23b7e16256e599ba27ed4_b.png&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;组成&lt;/h2&gt;&lt;p&gt;组成（composition）是更强的包含关系，说明一个类的实例是另一个类的组成部分，它们有一致的生命周期，组成方以实心菱形表示。例如，一家公司由多个部门组成，若果公司结业，部门也不存在了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]
    edge [fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Company, Department, Employeee

    /* Composition */
    {
        edge [dir=back, arrowtail=diamond, headlabel=&amp;#34;* &amp;#34;]
        Company -&amp;gt; Department        
    }

    /* Aggregation */
    {
        edge [dir=back, arrowtail=odiamond, headlabel=&amp;#34;* &amp;#34;]
        Department -&amp;gt; Employeee
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d730758e13a7d6dbfd19de88a197c6c9_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;102&quot; data-rawheight=&quot;251&quot; class=&quot;content_image&quot; width=&quot;102&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d730758e13a7d6dbfd19de88a197c6c9_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;102&quot; data-rawheight=&quot;251&quot; class=&quot;content_image lazy&quot; width=&quot;102&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-d730758e13a7d6dbfd19de88a197c6c9_b.png&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;依赖&lt;/h2&gt;&lt;p&gt;依赖（depedency）关系说明一个类会使用到另一个类，例如表示以一个类作为成员方法的参数或返回值。UML 中采用线形箭头和虚线表示。以下的例子表示工厂创建产品，常见于各种工厂模式，工厂不拥有产品。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]
    edge [fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Factory, Product

    /* Dependency */
    {
        edge [arrowhead=vee, style=dashed]
        Factory -&amp;gt; Product [label=&amp;#34; &amp;lt;&amp;lt;create&amp;gt;&amp;gt;&amp;#34;]
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ab9e69eb721e09640efea6402a5711c2_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;119&quot; data-rawheight=&quot;168&quot; class=&quot;content_image&quot; width=&quot;119&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ab9e69eb721e09640efea6402a5711c2_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;119&quot; data-rawheight=&quot;168&quot; class=&quot;content_image lazy&quot; width=&quot;119&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ab9e69eb721e09640efea6402a5711c2_b.png&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;类成员&lt;/h2&gt;&lt;p&gt;类除了名字，也可以展示其成员。成员包括属性（attribute）和方法（method）。&lt;/p&gt;&lt;p&gt;每个成员的可见性（visibility）以一个前置符号表示：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 公有（public）&lt;/li&gt;&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 私有（private）&lt;/li&gt;&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 保护（protected）&lt;/li&gt;&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 包（package）&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果成员为静态（static）的，则加下划线。&lt;/p&gt;&lt;p&gt;属性的格式为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;visibility&amp;gt; &amp;lt;attribute name&amp;gt; : &amp;lt;type&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;方法的格式为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;visibility&amp;gt; &amp;lt;method name&amp;gt; (&amp;lt;param1 name&amp;gt; : &amp;lt;param1 type&amp;gt;, ...) : &amp;lt;return type&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Graphviz 可使用 record shape 或 HTML table 来分隔类名字、属性和方法，例如以下的 C++ 类：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Deposite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetAmount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用 record shape 的话可写作：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=record, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Account [label=&amp;#34;{
Account
|
# balance : int\l
- owner : string\l
|
+ Deposite(amount : int)\l
+ Withdraw(amount : int)\l
+ GetBalance() : int\l
}&amp;#34;]

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6ebcda7e08e3b541b84a14b5d169d874_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;178&quot; data-rawheight=&quot;124&quot; class=&quot;content_image&quot; width=&quot;178&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6ebcda7e08e3b541b84a14b5d169d874_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;178&quot; data-rawheight=&quot;124&quot; class=&quot;content_image lazy&quot; width=&quot;178&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6ebcda7e08e3b541b84a14b5d169d874_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当中，&lt;code&gt;\l&lt;/code&gt; 是代表该行向左对齐并换行。&lt;/p&gt;&lt;p&gt;如需更多控制，则可使用 HTML table，但就会更冗长：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=plaintext, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Account [label=&amp;lt;
&amp;lt;table border=&amp;#34;0&amp;#34; cellborder=&amp;#34;1&amp;#34; cellspacing=&amp;#34;0&amp;#34;&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td align=&amp;#34;left&amp;#34; balign=&amp;#34;left&amp;#34;&amp;gt;
# balance : int&amp;lt;br/&amp;gt;
- owner : string&amp;lt;br/&amp;gt;
&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Account&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td align=&amp;#34;left&amp;#34; balign=&amp;#34;left&amp;#34;&amp;gt;
+ Deposite(amount : int)&amp;lt;br/&amp;gt;
+ Withdraw(amount : int)&amp;lt;br/&amp;gt;
+ GetBalance() : int&amp;lt;br/&amp;gt;
&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;gt;]

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 HTML table 可加入 &lt;code&gt;&amp;lt;U&amp;gt;&amp;lt;/U&amp;gt;&lt;/code&gt;（下划线）、&lt;code&gt;&amp;lt;I&amp;gt;&amp;lt;/I&amp;gt;&lt;/code&gt; （斜体）等字体控制，但只在一些渲染器中有效。如需表示静态或抽像，可利用 stereotype &lt;code&gt;&amp;lt;&amp;lt;abstract&amp;gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&amp;lt;static&amp;gt;&amp;gt;&lt;/code&gt; 等说明。&lt;/p&gt;&lt;p&gt;再重申一次，类图不必要展示所有细节，可按想表达的意思仅加入部分成员，每个方法也可忽略一些参数细节。&lt;/p&gt;&lt;h2&gt;包&lt;/h2&gt;&lt;p&gt;在比较大的系统里，类通常会用包（package）的方式来组织。Graphviz 不能简单还完 UML 包的图形，但可以使用 subgraph cluster 功能去近似地表示类属于那个包。&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    graph [fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5,
        labeljust=left] 
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]
    edge [fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    subgraph clusterView {
        label=&amp;#34;View&amp;#34;
        AccountView, CustomerView
    }

    subgraph clusterModel {
        label=&amp;#34;Model&amp;#34;
        Account, Customer
    }

    /* Unidirecitonal association */
    {
        edge [arrowhead=vee]
        AccountView -&amp;gt; Account
        CustomerView -&amp;gt; Customer
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9dee260a95e0ed2be812a9c1d4805a3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;283&quot; data-rawheight=&quot;229&quot; class=&quot;content_image&quot; width=&quot;283&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9dee260a95e0ed2be812a9c1d4805a3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;283&quot; data-rawheight=&quot;229&quot; class=&quot;content_image lazy&quot; width=&quot;283&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e9dee260a95e0ed2be812a9c1d4805a3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;注意，&lt;code&gt;subgraph&lt;/code&gt; 的名字必须以 &lt;code&gt;cluster&lt;/code&gt; 为前缀。&lt;/p&gt;&lt;h2&gt;排布技巧&lt;/h2&gt;&lt;p&gt;自动排布故然很方便，但有时候我们想做出一些修改。例如，dot 描述的是有向图，从来源节点指向目标节点时，目标节点就会成为下一级，预设设置下，节点会垂直排列，如以下例子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    Canvas, Shape, Rectangle, Circle

    /* Inheritance */
    {
        edge [arrowtail=onormal, dir=back]
        Shape -&amp;gt; { Rectangle, Circle }
    }

    /* Composition */
    {
        edge [dir=back, arrowtail=diamond, headlabel=&amp;#34;* &amp;#34;]        
        Canvas -&amp;gt; Shape
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e8529cc90f0c84b40175be2db4c3a70a_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;189&quot; data-rawheight=&quot;251&quot; class=&quot;content_image&quot; width=&quot;189&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e8529cc90f0c84b40175be2db4c3a70a_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;189&quot; data-rawheight=&quot;251&quot; class=&quot;content_image lazy&quot; width=&quot;189&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e8529cc90f0c84b40175be2db4c3a70a_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;但有时候我们想作一些改动，例如继承沿用这种方式，但关联时则以水平。我们可以使用 &lt;code&gt;rank=same&lt;/code&gt; 去设置一组节点为同一级，节点之间的距离可整体设置 &lt;code&gt;nodesep&lt;/code&gt; 属性：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    graph [nodesep=1]
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    {
        rank=same
        Canvas, Shape
    }

    Rectangle, Circle

    /* inheritance */
    {
        edge [arrowtail=onormal, dir=back]
        Shape -&amp;gt; { Rectangle, Circle }
    }

    /* composition */
    {
        edge [dir=back, arrowtail=diamond, headlabel=&amp;#34;* &amp;#34;]
        Canvas -&amp;gt; Shape
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be7d43b8b14763b62f01219a8652df76_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;337&quot; data-rawheight=&quot;155&quot; class=&quot;content_image&quot; width=&quot;337&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be7d43b8b14763b62f01219a8652df76_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;337&quot; data-rawheight=&quot;155&quot; class=&quot;content_image lazy&quot; width=&quot;337&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-be7d43b8b14763b62f01219a8652df76_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;颜色&lt;/h2&gt;&lt;p&gt;UML 图也不一定是黑白的。做软件设计时可以加入颜色去加入一些意思，例如不同包的类可设置为不同颜色。挑选颜色是一个头痛的问题，可以采用 Graphviz 的配色方案（color scheme）功能。例如用 &lt;code&gt;colorscheme=spectral7&lt;/code&gt; 设置 7 个光谱色配色方案，然后我们可以用 &lt;code&gt;fillcolor=1&lt;/code&gt; 至 &lt;code&gt;7&lt;/code&gt; 去填充节点形状：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;digraph {
    graph [fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5, labeljust=left] 
    node [shape=box, fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5,
        style=filled, colorscheme=spectral7]
    edge [fontname=&amp;#34;Inconsolata, Consolas&amp;#34;, fontsize=10, penwidth=0.5]

    subgraph clusterView {
        label=&amp;#34;View&amp;#34;
        node [fillcolor=4]
        AccountView, CustomerView
    }

    subgraph clusterModel {
        label=&amp;#34;Model&amp;#34;
        node [fillcolor=6]
        Account, Customer
    }

    /* Unidirecitonal association */
    {
        edge [arrowhead=vee]
        AccountView -&amp;gt; Account
        CustomerView -&amp;gt; Customer
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3115b3b5765c4250ef799a6873213f51_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;283&quot; data-rawheight=&quot;229&quot; class=&quot;content_image&quot; width=&quot;283&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3115b3b5765c4250ef799a6873213f51_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;283&quot; data-rawheight=&quot;229&quot; class=&quot;content_image lazy&quot; width=&quot;283&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3115b3b5765c4250ef799a6873213f51_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;状态图&lt;/h2&gt;&lt;p&gt;T.B.W.&lt;/p&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;Koutsofios, Eleftherios, and Stephen C. North. &lt;a href=&quot;https://zhuanlan.zhihu.com/(https://graphviz.gitlab.io/_pages/pdf/dotguide.pdf)&quot; class=&quot;internal&quot;&gt;&amp;#34;Drawing graphs with dot.&amp;#34;&lt;/a&gt; (1996).&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//graphviz.gitlab.io/_pages/doc/info/attrs.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Node, Edge and Graph Attributes&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//graphviz.gitlab.io/_pages/doc/info/shapes.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Node Shapes&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//graphviz.gitlab.io/_pages/doc/info/arrows.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Arrow Shapes&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2019-10-29-88835583</guid>
<pubDate>Tue, 29 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>近况、出版、道合</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2019-09-26-83349497.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83349497&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-970c00caee727b54c828400d5b218404_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;过去一个月忙著做IEG各级游戏客户端的通道评审、实习生评审、校园招聘，还去了一周大阪团建，今天我所在的部门（魔方工作室群）终于完成了到新建大楼的搬迁，终于整顿下来，想写一点东西。&lt;/p&gt;&lt;p&gt;首先，《&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/34778851/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;腾讯游戏开发精粹&lt;/a&gt;》出版了！一年多前，我发起这个项目，希望同事能有一个对外分享技术的途径。这个项目从成立编委会、规划、招稿、摘要评审、编辑、排版、管理层审核、出版，经历了不少困难，最终能看到实体的出版物，有种金石为开的感觉。第一次做这样的工作，有很多不足之处，期待大家的反馈。如果顺利，希望能继续有第二册，在内容范围、形式上也可以再作创新，例如考虑对业界学界公开招稿，这方面也期待有读者提供意见。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf2ce3cdcda9fd91c32f1633bac014ce_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;591&quot; data-rawheight=&quot;783&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;591&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf2ce3cdcda9fd91c32f1633bac014ce_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf2ce3cdcda9fd91c32f1633bac014ce_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;591&quot; data-rawheight=&quot;783&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;591&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf2ce3cdcda9fd91c32f1633bac014ce_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bf2ce3cdcda9fd91c32f1633bac014ce_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个出版相关的「喜讯」是，《游戏引擎架构》&lt;b&gt;第二版&lt;/b&gt;终于完成编辑排版，快将出版。两周前写的译序，简直就是一篇忏悔录，先睹为快：&lt;/p&gt;&lt;blockquote&gt;不知不觉，本书原版第1版已出版十年。十年前 iPhone 3GS 面世，《愤怒的小鸟》在同年上架 Apple Store。随着智能手机的渗透率不断增长，全球范围内移动游戏极速超越PC和游戏机，成为最多用户及最高收入的游戏平台。我开始翻译本书时，正任职于麻辣马开发PC／游戏机平台游戏，之后幸运地在2011年前加入腾讯，从事游戏引擎技术的研发工作，也亲历了这个浪潮。&lt;br/&gt;2013年国内《天天爱消除》和《天天酷跑》这两款2D手游成为行业爆款，而我在当年第1版译序中写下〝还可预料，现时单机／游戏机的一些较高级的架构及技术，将在不远的未来着陆移动终端平台。〞那个时候，不少人认为手机只适合这些消闲游戏，也许不需要前沿技术。然而，随后各种游戏类型陆续爆发，MOBA的王者属《王者荣耀》，ACT有《火影忍者》，FPS有《穿越火线》以至本年的《和平精英》。我追索这十多年的游戏硬件发展，虽然移动平台的性能和顶级游戏机有稳定十年的差距，但至少在架构和技术上，移动平台的游戏已逐渐贴近前沿。&lt;br/&gt;在端游时代，游戏项目的技术选型多姿多采，有选择自研引擎的（如《天涯明月刀》的QuickSilver引擎），也有选择各种商业和开源的游戏引擎。但在2013-17年期间，除了网易继续自研引擎，国内大部分手游项目都选择了 Unity。Unity引擎具有非常友好的工具及编程环境，它采用的 C# 语言也减轻了开发者的负担，令游戏团队能非常高效地生产。但与此同时，它的黑盒性质也极大地影响了这一代游戏程序员。这个情况在我做公司内部晋级评审时深有感受：以往一些工作可能需要深入了解技术原理，并寻找最适合项目的最优方案，然后把技术从无到有去实现出来，过程中对人员的技术成长很有帮助；而面对黑盒，很多时候是通过猜想个中的实现，再尝试以打补丁方式去解决问题，更少机会完整地实现一些技术，对于较底层的开发能力更易缺失。但当手游竞争越趋激烈，游戏开发周期从三个月上升至三年，开发团队的技术能力也变得越重要。2015年 Unreal 提供源代码给所有人，并且大力增强移动平台的支持，开始成为手游项目的另一可行选项。如果仅考虑对开发人员的成长，我会建议尽量使用具源代码的工具，并多了解它内部如何运作，在适当时候作出修改。期待我们能继续提升技术水平，并发挥创新能力，进一步提升游戏的品质。&lt;br/&gt;在第1版译本出版以来，我收到大量读者反馈，一些错漏之处也在每次印刷中修正。不时有朋友告诉我，他们因为读这本译作而对游戏引擎技术产生兴趣，最后还加入到这个行业之中，身为译者也感到欣慰。2014 年我在美国三藩市游戏开发大会遇到原作者 Jason Gregory，也是令人兴奋的时刻。但对于一直期待第2版的朋友，面对以年为单位的等待，本人实在难辞其咎。虽然百词莫辩，也必须作出点交代。除了繁忙的工作，在数年里我花了不少工余时间在知乎上回答问题及写技术文章，学习并实践多方面的兴趣，也在近不惑之年才开始注重身体健康而去系统锻鍊。由于个人的能力及时间有限，我也希望能和其他人合作去推动知识分享，例如刚出版的《腾讯游戏开发精粹》便是我通过腾讯游戏学院发起的项目，而另一本和同事合译作品《基于物理的建模与动画（暂名）》希望也能尽快与大家见面。&lt;br/&gt;由于有些读者已读过第1版，所以我特意在新增的章节标题中加入剑标符，以方便挑选阅读。最后，期望这本书能引发你对游戏技术的兴趣，在未来可以玩到你的游戏作品。&lt;/blockquote&gt;&lt;p&gt;回想到我来腾讯 IEG 也有 8 年了，前 4 年在研发部，而后 4 年在魔方。2015年我觉得和一线开发有点距离，想重新投入产品的相关技术研发。我选择了魔方，主要是考虑到他之前的产品以页游为主，在技术上的积累较少，我可能可以帮助他提升技术水平。刚进去的时候，我们的引擎组是一个项目中的小组，只有几人。&lt;/p&gt;&lt;p&gt;2015年上线了魔方第一款3D的射击手游《独立防线》，这是一个商业上不成功的项目，但累积了3D的制作经验和FPS团队。而翌年魔方上线了爆款动作手游《火影忍者》，这个 IP 项目的商业成功，令工作室群有更多空间去投入更大型的研发项目。我们引擎组的工作也逐部扩展至多个项目的引擎技术支持，性能优化，技术攻关，各式各样。这个研发阶段非常漫长，再加上政策的影响，魔方今年才继《火影忍者》后有至少 4 款新游戏上线，包括《妖精的尾巴》、《王牌战士》、《一人之下》、《战歌竞技场》。&lt;/p&gt;&lt;p&gt;我的小组在这4年中，除了参与这些项目的技术攻关及性能优化，也主导一些技术要求更高的预研项目。同时，我们也有机会尝试研发一些创新的游戏引擎技术。引擎组也变成了引擎中心，人数从几个人涨到了 25 人。曾经可以为每个成员亲手做生日蛋糕，现在也变得不太可能了。&lt;/p&gt;&lt;p&gt;我觉得魔方还是需要一直蜕变，除了令自己和同事成长，也需要有新血，才能做更多有趣的事情。相对于攻关技术难题，招聘是令我更烦恼的任务。由于游戏业务的持续增长，公司内外的人才竞争都很厉害。&lt;/p&gt;&lt;p&gt;如果你已从事游戏业界一段日子，对游戏技术有追求，希望来和我共事，可以直接联系我。我们现在招一些比较专门的社招职位：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075140203122688&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-UE4客户端开发工程师（UE4 Client-side Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1151807055762296832&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏AI系统开发Leader（Game AI System Leader）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1151809644675469312&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏AI系统开发工程师（Game AI System Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075140727410688&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏引擎开发工程师（Game Engine Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075140417032192&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏图形开发工程师（Game Graphics Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075140580610048&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏物理开发工程师（Game Physics Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075140928737280&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏工具开发工程师（Game Tool Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/jobdesc.html%3FpostId%3D1177075141037789184&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏客户端开发运营工程师（Game Client-side DevOps Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075141167812608&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-程序化生成技术美术（Procedural Content Generation Technical Artist）&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;另外，如果你是2020/21年毕业、对游戏开发有热情的本硕博学生，也可把 CV &lt;a href=&quot;mailto:miloyip@tencent.com&quot;&gt;电邮给我&lt;/a&gt;。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2019-09-26-83349497</guid>
<pubDate>Thu, 26 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>重画了儿子的作品</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2019-03-23-60126751.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60126751&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-22b7dcc730b3bb3bc038f8f40fd13924_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;前几天在《&lt;a href=&quot;https://www.zhihu.com/question/315712281/answer/626294464&quot; class=&quot;internal&quot;&gt;为什么图形学人才这么少？&lt;/a&gt;》的回答中，引用了儿子2017年9月用 Scratch 画的一幅作品，当时还猜不到他是怎么画的。后来评论中 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0c708d923f8fb00142e1f25cdd4951d9&quot; data-hash=&quot;0c708d923f8fb00142e1f25cdd4951d9&quot; data-hovercard=&quot;p$b$0c708d923f8fb00142e1f25cdd4951d9&quot;&gt;@王赟 Maigo&lt;/a&gt; 试出了可用&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28x%2C+y%29+%3D+%7Cx%7C%5E3%2B%7Cy%7C%5E3%5Ctag%7B1%7D&quot; alt=&quot;f(x, y) = |x|^3+|y|^3\tag{1}&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;再通过取模并用色相（hue）显示，便可获得类似的图。&lt;/p&gt;&lt;p&gt;然后我搜到 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.scratch-wiki.info/wiki/Pen_Color_%28value%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Scratch 的 hue 范围&lt;/a&gt; 是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B0%2C+200%5D&quot; alt=&quot;[0, 200]&quot; eeimg=&quot;1&quot;&gt; ，所以应该是简单地取模 200 的结果。那么就用 C 语言实现一下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&quot;svpng.inc&quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#define W 800&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define H 800&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fabs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; 
                              &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fabs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;360&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// hsv2rgb with s = v = 1&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;svpng&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;luasplot.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;得到接近的结果：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-13d684a0f03362862299d725aaeba48e_b.jpg&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;800&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;800&quot; data-original=&quot;https://pic3.zhimg.com/v2-13d684a0f03362862299d725aaeba48e_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-13d684a0f03362862299d725aaeba48e_b.jpg&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;800&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;800&quot; data-original=&quot;https://pic3.zhimg.com/v2-13d684a0f03362862299d725aaeba48e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-13d684a0f03362862299d725aaeba48e_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;实际上 (1) 是 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Norm_%28mathematics%29%23p-norm&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;p-norm&lt;/a&gt; 去除了开 p 次方的版本，形状也是相似的。我在《&lt;a href=&quot;https://www.zhihu.com/question/39088212/answer/476010539&quot; class=&quot;internal&quot;&gt;如何用C语言画一个蘑菇？&lt;/a&gt;》介绍过 p-norm，却没联想到。&lt;/p&gt;&lt;p&gt;设 p = 4 可得这个效果：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ea8bb06525e2d63bed4c774dbff7924c_b.jpg&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;800&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;800&quot; data-original=&quot;https://pic1.zhimg.com/v2-ea8bb06525e2d63bed4c774dbff7924c_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ea8bb06525e2d63bed4c774dbff7924c_b.jpg&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;800&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;800&quot; data-original=&quot;https://pic1.zhimg.com/v2-ea8bb06525e2d63bed4c774dbff7924c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ea8bb06525e2d63bed4c774dbff7924c_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;计算机图形学有趣么？&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2019-03-23-60126751</guid>
<pubDate>Sat, 23 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>常在我心</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2019-02-13-56640030.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56640030&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b845dab3b9ef95ab4a4ffe5a4750e96f_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1079126838621544448&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;常在我心&quot; data-poster=&quot;https://pic2.zhimg.com/v2-b7e6879086e9544c5ef5d32f077ec05a.jpg&quot; data-lens-id=&quot;1079126838621544448&quot;&gt;              &lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-b7e6879086e9544c5ef5d32f077ec05a.jpg&quot;&gt;              &lt;span class=&quot;content&quot;&gt;                &lt;span class=&quot;title&quot;&gt;常在我心&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;                &lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1079126838621544448&lt;/span&gt;              &lt;/span&gt;            &lt;/a&gt;            &lt;p&gt;这是一个用 HTML/JS 实现的光滑粒子流体动力学（smoothed particle hydrodynamics, SPH） [1][2][3] 实时 Demo，它使用 HTML5 Canvas 渲染。&lt;/p&gt;&lt;p&gt;改变文字的方法是，打开 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//miloyip.com/misc/sv2019.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;miloyip.com/misc/sv2019&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;，然后在 URL 里输入（当然&lt;code&gt;&quot;知乎&quot;&lt;/code&gt;可改做其他文字）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;javascript:b64EncodeUnicode(&quot;知乎&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;便会显示一个编码后的文本：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;55+l5LmO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;把这个文本加在 URL 的问号后面：&lt;/p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//miloyip.com/misc/sv2019.html%3F55%2Bl5LmO&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;miloyip.com/misc/sv2019&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;.html?55+l5LmO&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;便可以看到封面的效果。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CHuge%7B%5Ccolor%7Bpink%7D%7B%5Ctextit%7BHappy+St+Valentine%27s+Day+2019%21%7D%7D%7D&quot; alt=&quot;\Huge{\color{pink}{\textit{Happy St Valentine&#39;s Day 2019!}}}&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;h2&gt;相关回答／文章&lt;/h2&gt;&lt;a href=&quot;https://www.zhihu.com/question/20187195/answer/146381413&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-f8a781f3032b886ce16bc6e6726740e1_ipico.jpg&quot; data-image-width=&quot;756&quot; data-image-height=&quot;645&quot; class=&quot;internal&quot;&gt;如何用 C 语言画「心形」？&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30123802&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-58972af6a18081c088c298f494ef4f08_ipico.jpg&quot; data-image-width=&quot;513&quot; data-image-height=&quot;513&quot; class=&quot;internal&quot;&gt;Milo Yip：完美恋爱迷宫&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31901449&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-fd045c136f75263c865390c69518016a_ipico.jpg&quot; data-image-width=&quot;1024&quot; data-image-height=&quot;1024&quot; class=&quot;internal&quot;&gt;Milo Yip：用C语言画光（七）：比尔-朗伯定律&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/31482830/answer/318497552&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-2941287c52be96de6898ec279decb881_ipico.jpg&quot; data-image-width=&quot;1286&quot; data-image-height=&quot;1290&quot; class=&quot;internal&quot;&gt;如何用计算几何模型画一束玫瑰花？&lt;/a&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] Müller, Matthias, David Charypar, and Markus Gross. &quot;Particle-based fluid simulation for interactive applications.&quot;&lt;i&gt;Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation&lt;/i&gt;. Eurographics Association, 2003.&lt;/p&gt;&lt;p&gt;[2] Bridson, Robert.&lt;i&gt;Fluid simulation for computer graphics&lt;/i&gt;. AK Peters/CRC Press, 2015.&lt;/p&gt;&lt;p&gt;[3] Kim, Doyub.&lt;i&gt;Fluid Engine Development&lt;/i&gt;. AK Peters/CRC Press, 2017.&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2019-02-13-56640030</guid>
<pubDate>Wed, 13 Feb 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>腾讯香农编码器，尽享高清视频体验</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-11-20-50351685.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50351685&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e4f37e174d1ddaab435feae983354b99_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;      这里给大家推荐一款高清视频编码利器——腾讯自主研发的香农编码器（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//shannon-lab.qq.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tencent Shannon Encoder&lt;/a&gt;，简称T265）。在莫斯科国立大学主办的2018世界视频编码器大赛（MSU codec comparison）中，香农编码器从众多编码器中脱颖而出，继在客观指标取得优异成绩后，经过主办方严格的人眼主观测试，取得人眼主观质量评测的冠军：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.compression.ru/video/codec_comparison/hevc_2018/%23subjective_report&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-abe98f4240a1cc40c89eba20b0b97f1f_180x120.jpg&quot; data-image-width=&quot;300&quot; data-image-height=&quot;150&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HEVC Video Codecs Comparison 2018&lt;/a&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-81a023252af7f5ea01e2440f5dff8543_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1981&quot; data-rawheight=&quot;1825&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1981&quot; data-original=&quot;https://pic4.zhimg.com/v2-81a023252af7f5ea01e2440f5dff8543_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-81a023252af7f5ea01e2440f5dff8543_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1981&quot; data-rawheight=&quot;1825&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1981&quot; data-original=&quot;https://pic4.zhimg.com/v2-81a023252af7f5ea01e2440f5dff8543_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-81a023252af7f5ea01e2440f5dff8543_b.jpg&quot;/&gt;&lt;figcaption&gt;图1 MSU发布的腾讯香农编码器的性能测试结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;       衡量一个编码器的优劣是一件非常复杂的事情，涉及编码质量，速度和质量平衡以及码控平稳度等多个指标，受多种因素影响。下面结合大赛的测评报告，对香农编码器做三点评述。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;注重SSIM与PSNR的均衡&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       在MSU的编码质量测评中，使用了SSIM 和PSNR两种客观指标，其中SSIM指标侧重于衡量编码视频图像和原视频图像之间的结构相似性，而PSNR指标侧重于衡量编码视频图像相对原视频图像的保真度。为了保证编码视频图像的主观质量，一般需要保证SSIM和PSNR两者间的均衡，避免导致意外的主观质量问题。如图2所示，中间和右边的图像虽然PSNR一样，但右边图像有严重块效应，主观质量很差，这里SSIM指标比PSNR指标更好地反映了主观质量；而如图3所示，中间和右边图像SSIM一样，但右边图像有像素块像素值完全反转的严重失真，主观质量差得多，这里PSNR指标比SSIM指标更好地反映了主观质量。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-087fa81e798672e649ff95a2df3358dd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1224&quot; data-rawheight=&quot;508&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1224&quot; data-original=&quot;https://pic2.zhimg.com/v2-087fa81e798672e649ff95a2df3358dd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-087fa81e798672e649ff95a2df3358dd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1224&quot; data-rawheight=&quot;508&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1224&quot; data-original=&quot;https://pic2.zhimg.com/v2-087fa81e798672e649ff95a2df3358dd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-087fa81e798672e649ff95a2df3358dd_b.jpg&quot;/&gt;&lt;figcaption&gt;图2 编码PSNR相同，SSIM不同的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ac05bb1186b6566c819912458a76dc8b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;442&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1238&quot; data-original=&quot;https://pic4.zhimg.com/v2-ac05bb1186b6566c819912458a76dc8b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ac05bb1186b6566c819912458a76dc8b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;442&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1238&quot; data-original=&quot;https://pic4.zhimg.com/v2-ac05bb1186b6566c819912458a76dc8b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ac05bb1186b6566c819912458a76dc8b_b.jpg&quot;/&gt;&lt;figcaption&gt;图3 编码SSIM相同，PSNR不同的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;       腾讯香农编码器在优化过程中综合考虑了PSNR和SSIM模型的特点，在算法设计实现中采取了两者比较均衡的策略，给用户带来较好的主观视觉体验。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-681fe1d4f18b36846d35390013bb9f27_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1064&quot; data-rawheight=&quot;239&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1064&quot; data-original=&quot;https://pic4.zhimg.com/v2-681fe1d4f18b36846d35390013bb9f27_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-681fe1d4f18b36846d35390013bb9f27_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1064&quot; data-rawheight=&quot;239&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1064&quot; data-original=&quot;https://pic4.zhimg.com/v2-681fe1d4f18b36846d35390013bb9f27_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-681fe1d4f18b36846d35390013bb9f27_b.jpg&quot;/&gt;&lt;figcaption&gt;图4 香农编码器PSNR和SSIM排名&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;侧重中低码率的互联网应用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       在MSU的测评中所有测试序列的编码码率段都主要集中在1~12Mbps，甚至更高码率上，而互联网视频应用中编码码率段基本集中在1~6Mbps之间。腾讯香农编码器作为一款主要服务于互联网视频应用的编码器，在优化时也更关注于1~6Mbps中低码率段，由MSU测评的数据可以得到如下中低码率段的排名和全码率段的排名对比，香农编码器在中低码率段更有优势。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0a7fcda5e9e48ebc3fced768539b38c1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1886&quot; data-rawheight=&quot;774&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1886&quot; data-original=&quot;https://pic2.zhimg.com/v2-0a7fcda5e9e48ebc3fced768539b38c1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0a7fcda5e9e48ebc3fced768539b38c1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1886&quot; data-rawheight=&quot;774&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1886&quot; data-original=&quot;https://pic2.zhimg.com/v2-0a7fcda5e9e48ebc3fced768539b38c1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0a7fcda5e9e48ebc3fced768539b38c1_b.jpg&quot;/&gt;&lt;figcaption&gt;图5 Playground序列全码率段RD曲线&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2f53376173d8e27820bc6eec49b01f74_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;531&quot; data-rawheight=&quot;215&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;531&quot; data-original=&quot;https://pic1.zhimg.com/v2-2f53376173d8e27820bc6eec49b01f74_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2f53376173d8e27820bc6eec49b01f74_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;531&quot; data-rawheight=&quot;215&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;531&quot; data-original=&quot;https://pic1.zhimg.com/v2-2f53376173d8e27820bc6eec49b01f74_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2f53376173d8e27820bc6eec49b01f74_b.jpg&quot;/&gt;&lt;figcaption&gt;图6 中低码率段部分编码器排名&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;编码鲁棒性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       MSU根据时间复杂度和空间复杂度选择了迥异的测试序列，这些测试序列基本涵盖了各种场景，用来测试编码器对各种场景的编码适应能力。香农编码器通过更合理的码率分配策略，将码控精度控制在5%以内的同时，还额外节省了超过6%的带宽。其编码的鲁棒性表现也还不错，如下图所示，对于典型测试序列Sea Sunrise，当许多编码器的RD曲线都出现异常的时候，香农编码器的RD曲线不但正常，压缩性能也超过竞品。测试序列的难例挖掘是编码器研发不断迭代过程中的一个难点，香农编码器在编码鲁棒性上还有可提升的空间。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e0e6a39811e0a47590915cf38dc470ba_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;984&quot; data-original=&quot;https://pic3.zhimg.com/v2-e0e6a39811e0a47590915cf38dc470ba_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e0e6a39811e0a47590915cf38dc470ba_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;984&quot; data-original=&quot;https://pic3.zhimg.com/v2-e0e6a39811e0a47590915cf38dc470ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e0e6a39811e0a47590915cf38dc470ba_b.jpg&quot;/&gt;&lt;figcaption&gt;图7 Sea Sunrise RD曲线&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;总结和展望&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       腾讯香农编码器在MSU视频编码比赛中经受了检验，无论客观指标，还是主观指标，成绩都非常突出，未来我们在技术上还会持续演进，带来更清晰流畅的视频体验。&lt;/p&gt;</description>
<author>程曦铭</author>
<guid isPermaLink="false">2018-11-20-50351685</guid>
<pubDate>Tue, 20 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>腾讯香农编码器，尽享高清视频体验</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-11-19-50351685.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50351685&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e4f37e174d1ddaab435feae983354b99_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;      这里给大家推荐一款高清视频编码利器——腾讯自主研发的香农编码器（&lt;a href=&quot;https://shannon-lab.qq.com/&quot;&gt;Tencent Shannon Encoder&lt;/a&gt;，简称T265）。在莫斯科国立大学主办的2018世界视频编码器大赛（MSU codec comparison）中，香农编码器从众多编码器中脱颖而出，继在客观指标取得优异成绩后，经过主办方严格的人眼主观测试，取得人眼主观质量评测的冠军：&lt;/p&gt;&lt;a href=&quot;http://www.compression.ru/video/codec_comparison/hevc_2018/#subjective_report&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-abe98f4240a1cc40c89eba20b0b97f1f&quot; data-image-width=&quot;300&quot; data-image-height=&quot;150&quot; data-image-size=&quot;180x120&quot;&gt;HEVC Video Codecs Comparison 2018&lt;/a&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-47bc5baf13fb26c090e45800af0d5276_r.jpg&quot; data-caption=&quot;图1 MSU发布的腾讯香农编码器的性能测试结果&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1981&quot; data-rawheight=&quot;1825&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-47bc5baf13fb26c090e45800af0d5276&quot; data-watermark-src=&quot;v2-81a023252af7f5ea01e2440f5dff8543&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;       衡量一个编码器的优劣是一件非常复杂的事情，涉及编码质量，速度和质量平衡以及码控平稳度等多个指标，受多种因素影响。下面结合大赛的测评报告，对香农编码器做三点评述。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;注重SSIM与PSNR的均衡&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       在MSU的编码质量测评中，使用了SSIM 和PSNR两种客观指标，其中SSIM指标侧重于衡量编码视频图像和原视频图像之间的结构相似性，而PSNR指标侧重于衡量编码视频图像相对原视频图像的保真度。为了保证编码视频图像的主观质量，一般需要保证SSIM和PSNR两者间的均衡，避免导致意外的主观质量问题。如图2所示，中间和右边的图像虽然PSNR一样，但右边图像有严重块效应，主观质量很差，这里SSIM指标比PSNR指标更好地反映了主观质量；而如图3所示，中间和右边图像SSIM一样，但右边图像有像素块像素值完全反转的严重失真，主观质量差得多，这里PSNR指标比SSIM指标更好地反映了主观质量。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-29a51a9507c710d2f247dd51349d4b46_r.jpg&quot; data-caption=&quot;图2 编码PSNR相同，SSIM不同的情况&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1224&quot; data-rawheight=&quot;508&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-29a51a9507c710d2f247dd51349d4b46&quot; data-watermark-src=&quot;v2-087fa81e798672e649ff95a2df3358dd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d4560722f32536e4b965efc5745bdd9_r.jpg&quot; data-caption=&quot;图3 编码SSIM相同，PSNR不同的情况&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;442&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5d4560722f32536e4b965efc5745bdd9&quot; data-watermark-src=&quot;v2-ac05bb1186b6566c819912458a76dc8b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;       腾讯香农编码器在优化过程中综合考虑了PSNR和SSIM模型的特点，在算法设计实现中采取了两者比较均衡的策略，给用户带来较好的主观视觉体验。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-01168dc1038b4aff2856a944c7cc27f8_r.jpg&quot; data-caption=&quot;图4 香农编码器PSNR和SSIM排名&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1064&quot; data-rawheight=&quot;239&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-01168dc1038b4aff2856a944c7cc27f8&quot; data-watermark-src=&quot;v2-681fe1d4f18b36846d35390013bb9f27&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;侧重中低码率的互联网应用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       在MSU的测评中所有测试序列的编码码率段都主要集中在1~12Mbps，甚至更高码率上，而互联网视频应用中编码码率段基本集中在1~6Mbps之间。腾讯香农编码器作为一款主要服务于互联网视频应用的编码器，在优化时也更关注于1~6Mbps中低码率段，由MSU测评的数据可以得到如下中低码率段的排名和全码率段的排名对比，香农编码器在中低码率段更有优势。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dff397db45dc83ac6dbaf1be938e4f2e_r.jpg&quot; data-caption=&quot;图5 Playground序列全码率段RD曲线&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1886&quot; data-rawheight=&quot;774&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-dff397db45dc83ac6dbaf1be938e4f2e&quot; data-watermark-src=&quot;v2-0a7fcda5e9e48ebc3fced768539b38c1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ddb872587456c9fd8e61dcd7f39864ff_r.jpg&quot; data-caption=&quot;图6 中低码率段部分编码器排名&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;531&quot; data-rawheight=&quot;215&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ddb872587456c9fd8e61dcd7f39864ff&quot; data-watermark-src=&quot;v2-2f53376173d8e27820bc6eec49b01f74&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;编码鲁棒性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       MSU根据时间复杂度和空间复杂度选择了迥异的测试序列，这些测试序列基本涵盖了各种场景，用来测试编码器对各种场景的编码适应能力。香农编码器通过更合理的码率分配策略，将码控精度控制在5%以内的同时，还额外节省了超过6%的带宽。其编码的鲁棒性表现也还不错，如下图所示，对于典型测试序列Sea Sunrise，当许多编码器的RD曲线都出现异常的时候，香农编码器的RD曲线不但正常，压缩性能也超过竞品。测试序列的难例挖掘是编码器研发不断迭代过程中的一个难点，香农编码器在编码鲁棒性上还有可提升的空间。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6ff9807d0518e4504dc8bce3b2738a65_r.jpg&quot; data-caption=&quot;图7 Sea Sunrise RD曲线&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;415&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6ff9807d0518e4504dc8bce3b2738a65&quot; data-watermark-src=&quot;v2-e0e6a39811e0a47590915cf38dc470ba&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;总结和展望&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       腾讯香农编码器在MSU视频编码比赛中经受了检验，无论客观指标，还是主观指标，成绩都非常突出，未来我们在技术上还会持续演进，带来更清晰流畅的视频体验。&lt;/p&gt;</description>
<author>程曦铭</author>
<guid isPermaLink="false">2018-11-19-50351685</guid>
<pubDate>Mon, 19 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>自然而然</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-10-14-46698082.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46698082&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
    unsigned i, j, k = 0, n = 1e8;
    for (i = 0; i &amp;lt; n; i++)
        for (j = 0; j &amp;lt; RAND_MAX; j += rand())
            k++;
    printf(&quot;%f\n&quot;, (double)k / n);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;console&quot;&gt;$ gcc -O3 a.c &amp;amp;&amp;amp; ./a.out
2.718219&lt;/code&gt;&lt;p&gt;&lt;a href=&quot;http://mathworld.wolfram.com/UniformSumDistribution.html&quot;&gt;Uniform Sum Distribution&lt;/a&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-10-14-46698082</guid>
<pubDate>Sun, 14 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用C语言实现井字棋（上）</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-07-25-39581573.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39581573&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c43e48d68c4d756e3a1a016f910f1382_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.zhihu.com/question/284523599/answer/438445079&quot;&gt;Milo Yip：用C++编写游戏容易吗？有什么开源的小游戏吗？能分享一下吗？&lt;/a&gt; 这个答案中，我提到学习游戏编程可从回合制游戏开始，例如井字棋。&lt;/p&gt;&lt;p&gt;考虑到一些&lt;b&gt;初学者&lt;/b&gt;的学习需求，我就写一个井字棋的教程吧。上篇实现二人游戏，下篇加上「人工智能」后约有 100 行 C 语言代码。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 游戏状态的表示&lt;/h2&gt;&lt;p&gt;首先，我认为表示方法（representation）是编程中应最先要考虑的事情。对于回合制游戏，我们需要存储一个回合中的游戏状态（game state）。&lt;/p&gt;&lt;p&gt;以下用一个结构体表示井字棋一个回合中的状态，并加入函数作初始化：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct {
    int board[3][3];    // -1 = empty, 0 = O, 1 = X
    int turn;           // O first
} state;

void init(state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; j++)
        for (i = 0; i &amp;lt; 3; i++)
            s-&amp;gt;board[j][i] = -1;
    s-&amp;gt;turn = 0;
}&lt;/code&gt;&lt;p&gt;以上用二维数组存储棋盘（board）是其中一种表示方式，另一种方式则是记录每个回合下棋子的位置。我们采用前者是因为它较容易实现胜负判定。有些回合制游戏可能使用冗余的表示方式，以方便实现各种规则。&lt;/p&gt;&lt;p&gt;而使用结构体而不是直接用全局变量，可带来一些优点，例如增强可读性及内聚性。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 显示游戏状态&lt;/h2&gt;&lt;p&gt;编写游戏时，我们通常希望先显示游戏状态，之后才加入其他规则，因为这样可以方便测试。&lt;/p&gt;&lt;p&gt;我希望用这样的文本显示游戏状态，当空置时写上位置编号（1-9），以方便玩家输入下棋位置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt; 1 | 2 | 3 
---+---+---
 4 | 5 | 6 
---+---+---
 7 | 8 | 9 &lt;/code&gt;&lt;p&gt;简单直白地编写代码的话：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void display(const state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; j++) {
        for (i = 0; i &amp;lt; 3; i++) {
            switch (s-&amp;gt;board[j][i]) {
                case -1: printf(&quot; %d &quot;, j * 3 + i + 1); break;
                case  0: printf(&quot; O &quot;); break;
                case  1: printf(&quot; X &quot;); break;
            }
            if (i &amp;lt; 2)
                printf(&quot;|&quot;);
            else
                printf(&quot;\n&quot;);
        }
        if (j &amp;lt; 2)
            printf(&quot;---+---+---\n&quot;);
        else
            printf(&quot;\n&quot;);
    }
}&lt;/code&gt;&lt;p&gt;由于 &lt;code class=&quot;inline&quot;&gt;display()&lt;/code&gt; 只读而不改变游戏状态，所以其参数类型为 &lt;code class=&quot;inline&quot;&gt;const state*&lt;/code&gt;。 &lt;/p&gt;&lt;p&gt;我们稍压缩一下代码：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void display(const state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; printf(++j &amp;lt; 3 ? &quot;---+---+---\n&quot; : &quot;\n&quot;))
        for (i = 0; i &amp;lt; 3; putchar(&quot;||\n&quot;[i++]))
            printf(&quot; %c &quot;, s-&amp;gt;board[j][i] == -1 ? &#39;1&#39; + j * 3 + i : &quot;OX&quot;[s-&amp;gt;board[j][i]]);
}&lt;/code&gt;&lt;p&gt;我们可以加入 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 函数去显示初始化的状态：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
} &lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe0.c&quot;&gt;tictactoe0.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 实现下棋&lt;/h2&gt;&lt;p&gt;然后，我们加入第一个游戏规则，就是下棋：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int move(state* s, int i, int j) {
    if (s-&amp;gt;board[j][i] != -1)
        return 0;
    s-&amp;gt;board[j][i] = s-&amp;gt;turn++ % 2;
    return 1;
}&lt;/code&gt;&lt;p&gt;函数内做了一个合法性判断，如果该位置已有棋子，则返回 0 表示失败。成功的话，在偶数回合填入 0，表示 O；奇数回合填入 1，表示 X；然后都把回合加一。&lt;/p&gt;&lt;p&gt;更改 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 简单测试： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    move(&amp;amp;s, 1, 1);
    display(&amp;amp;s);
    move(&amp;amp;s, 0, 1);
    display(&amp;amp;s);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-416ea35bcab6968eb0f15953cac392c5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;162&quot; data-rawheight=&quot;504&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe1.c&quot;&gt;tictactoe1.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;4. 处理输入&lt;/h2&gt;&lt;p&gt;在每一回合中，提示当前玩家（O 或 X），并让玩家输入一个下棋位置（1-9），如果位置不合法，则重新输入：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void human(state* s) {
    char c;
    do {
        printf(&quot;%c: &quot;, &quot;OX&quot;[s-&amp;gt;turn % 2]);
        c = getchar();
        while (getchar() != &#39;\n&#39;);
        printf(&quot;\n&quot;);
    } while (c &amp;lt; &#39;1&#39; || c &amp;gt; &#39;9&#39; || !move(s, (c - &#39;1&#39;) % 3, (c - &#39;1&#39;) / 3));
}&lt;/code&gt;&lt;p&gt;在标准输入中，要到回车键才能处理输入，所以这里我们读了第一个输入字符后，就忽略其他字符直到读到换行符。我们把表示位置的字符转换成二维数组索引。&lt;/p&gt;&lt;p&gt;然后，就可以修改 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 实现二人下棋的流程： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    while (s.turn &amp;lt; 9) {
        human(&amp;amp;s);
        display(&amp;amp;s);
    } 
}&lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe2.c&quot;&gt;tictactoe2.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;5. 胜负判定&lt;/h2&gt;&lt;p&gt;众所周知，井字棋的胜利条件，是有三个棋子在横线、直线或斜线连成一线。我们实现一个 &lt;code class=&quot;inline&quot;&gt;evaluate()&lt;/code&gt; 函数去评估棋局的状态，如果 O 胜出则返回 1，X 胜出则返回 -1，不分胜负则返回 0：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define CHECK(j1, i1, j2, i2, j3, i3) \
    if (s-&amp;gt;board[j1][i1] != -1 &amp;amp;&amp;amp; s-&amp;gt;board[j1][i1] == s-&amp;gt;board[j2][i2] &amp;amp;&amp;amp; s-&amp;gt;board[j1][i1] == s-&amp;gt;board[j3][i3]) \
        return s-&amp;gt;board[j1][i1] == 0 ? 1 : -1;

int evaluate(const state* s) {
    int i;
    for (i = 0; i &amp;lt; 3; i++) {
        CHECK(i, 0, i, 1, i, 2);    // horizontal
        CHECK(0, i, 1, i, 2, i);    // vertical
    }
    CHECK(0, 0, 1, 1, 2, 2);        // diagonal
    CHECK(0, 2, 1, 1, 2, 0);        // diagonal
    return 0;
}&lt;/code&gt;&lt;p&gt;上面的代码使用了一个宏 &lt;code class=&quot;inline&quot;&gt;CHECK()&lt;/code&gt; 去检测三个位置是否都为相同的棋子，如是则直接返回胜方。&lt;/p&gt;&lt;p&gt;最后，我们在 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 中，待每次下棋及显示状态后， 判定是否出现胜方，如果到达第 9 个回合（回合从 0 开始），则判定是平局（draw）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    while (s.turn &amp;lt; 9) {
        human(&amp;amp;s);
        display(&amp;amp;s);
        switch (evaluate(&amp;amp;s)) {
            case  1: printf(&quot;O win\n&quot;); return 0;
            case -1: printf(&quot;X win\n&quot;); return 0;
        }
    } 
    printf(&quot;Draw\n&quot;);
}&lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe3.c&quot;&gt;tictactoe3.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;6. 总结&lt;/h2&gt;&lt;p&gt;本篇实现了二人井字棋，它是一个简单的回合制游戏。我们先选择了游戏的状态表示方式（&lt;code class=&quot;inline&quot;&gt;state&lt;/code&gt;结构体及&lt;code class=&quot;inline&quot;&gt;init()&lt;/code&gt;函数），然后把状态以文本形式显示（&lt;code class=&quot;inline&quot;&gt;display()&lt;/code&gt;函数），加入每回合下棋规则（&lt;code class=&quot;inline&quot;&gt;move()&lt;/code&gt;函数），以及人类玩家的输入处理（&lt;code class=&quot;inline&quot;&gt;human()&lt;/code&gt;函数），并作胜负判定（&lt;code class=&quot;inline&quot;&gt;evaluate()&lt;/code&gt;函数），最后在&lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt;里则实现了按回合的循环及输出胜负结果。&lt;/p&gt;&lt;p&gt;虽然这个游戏本身以及 60 行的示例代码都很简单，但这个框架可以用于实现其他（更复杂的）回合制游戏。实时游戏（如动作游戏）的主要区别，其实也只在于把输入部分做成非阻塞的函数，而该循环则称为游戏循环（game loop）。&lt;/p&gt;&lt;p&gt;下篇将加入不败的「人工智能」。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-07-25-39581573</guid>
<pubDate>Wed, 25 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用C语言画希尔伯特曲线</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-06-20-38276467.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38276467&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d34f3e5d10cf51d8af90f99b49bdcf03_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B8%8C%E7%88%BE%E4%BC%AF%E7%89%B9%E6%9B%B2%E7%B7%9A&quot;&gt;希尔伯特曲线&lt;/a&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_curve&quot;&gt;Hilbert curve&lt;/a&gt;）是一种空间填充曲线（space filling curve）的分形图案，由德国数学家 &lt;a href=&quot;https://en.wikipedia.org/wiki/David_Hilbert&quot;&gt;David Hilbert&lt;/a&gt;（1862-1943）发现 [1]。简单来说，空间填充曲线就是可以用「一笔画」的方式填充整个二维、三维或更高维的空间。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d7c0d2f1d9b096b85e79f50e8569082f_r.jpg&quot; data-caption=&quot;[1] 中的插图，展示第1、2、3阶的希尔伯特曲线&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;612&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d7c0d2f1d9b096b85e79f50e8569082f&quot; data-watermark-src=&quot;v2-6aee5a02d11ac9d243a38a809e655eae&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;本文描述用 C 语言绘画这种曲线的方法和技巧。&lt;/p&gt;&lt;p&gt;（题图是一个三维的希尔伯特曲线雕塑，来自 &lt;a href=&quot;http://mathbun.com/&quot;&gt;http://mathbun.com/&lt;/a&gt;）&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 递归、坐标变换&lt;/h2&gt;&lt;p&gt;最初，我在 [2] 找到一种基于矢量的绘画方法。它的原理是，一阶的希尔伯特曲线是一个「⊓」的形状，我们可以生成四个顶点，把顶点连接起来。而第二阶则是用第一阶的四个顶点位置，加上旋转和缩小，去画4 个「⊓」形状。只要把最后生成的顶点连接起来，就可以生成整个曲线：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7833b4f3a74fe531aa941a95f9822920_r.jpg&quot; data-caption=&quot;左图是一阶，起点在左下角。右图黑线部分是4个「⊓」形状，它们的中心为左图的顶点位置，加上旋转 -90、0、0、90度、以及缩小为一半。最后把所有顶点连起来，增加了灰线部分。&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;397&quot; data-rawheight=&quot;182&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7833b4f3a74fe531aa941a95f9822920&quot; data-watermark-src=&quot;v2-a802e01794c71709cd1f2128de4b9241&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们用一个影像缓冲去绘画这些垂直、水平线，最后用 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/26525083&quot;&gt;极简的 PNG 编码函数 svpng()&lt;/a&gt;  来存储。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &quot;svpng.inc&quot;
#define S 512

unsigned char img[S * S * 3];
float px = 0.0f, py = 0.0f;

void setpixel(int x, int y) { /* ... */}
void lineto(float tx, float ty) {/* ... */}

void hilbert(float x, float y, float xi, float xj, float yi, float yj, int n) {
    if (n) {
        hilbert(x,                   y,                    yi / 2,  yj / 2,  xi / 2,  xj / 2, n - 1);
        hilbert(x + xi / 2,          y + xj / 2,           xi / 2,  xj / 2,  yi / 2,  yj / 2, n - 1);
        hilbert(x + xi / 2 + yi / 2, y + xj / 2 + yj / 2,  xi / 2,  xj / 2,  yi / 2,  yj / 2, n - 1);
        hilbert(x + xi / 2 + yi,     y + xj / 2 + yj,     -yi / 2, -yj / 2, -xi / 2, -xj / 2, n - 1);
    }
    else
        lineto(x + (xi + yi) / 2, y + (xj + yj) / 2);
}

int main() {
    hilbert(0.0f, 0.0f, 0.0f, S, S, 0.0f, 4);
    svpng(fopen(&quot;hilbert.png&quot;, &quot;wb&quot;), S, S,img, 0);
}&lt;/code&gt;&lt;p&gt;4阶的结果（为方便起见，起点位于左上角）：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-41985853acabc9b888e3c4d28051e63f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-41985853acabc9b888e3c4d28051e63f&quot; data-watermark-src=&quot;v2-07d283a9aeeb319dbbbcf5ea05f91046&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;注：&lt;code class=&quot;inline&quot;&gt;setpixel()&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;lineto()&lt;/code&gt;较锁碎，不在此展示，完整代码位于&lt;a href=&quot;https://github.com/miloyip/misc/blob/master/hilbert/hilbert.c&quot;&gt;https://github.com/miloyip/misc/blob/master/hilbert/hilbert.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 方向编码&lt;/h2&gt;&lt;p&gt;第一个方法要计算每个顶点的位置，计算量较大。另一种绘画希尔伯特曲线的方式，是考虑它的 L-system：&lt;/p&gt;&lt;blockquote&gt;变数: L, R&lt;br&gt;常数: F, +, -&lt;br&gt;公理: L&lt;br&gt;规则:&lt;br&gt;L → − R F + L F L + F R −&lt;br&gt;R → − L F + R F R + F L −&lt;br&gt;F ： 向前&lt;br&gt;- ： 右转90°&lt;br&gt;+ ： 左转90°&lt;/blockquote&gt;&lt;p&gt;我们可以看到，两条规则其实是对称的，我们只需要把在迭归时，从 L 变成 R时把旋转方向反转。我参考了[3]的代码实现，但每次向前移动只绘画两个像素，当中&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;为笔的当前像素位置，参数&lt;code class=&quot;inline&quot;&gt;d&lt;/code&gt;为当前方向，&lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt;记录旋转：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &quot;svpng.inc&quot;
#include &amp;lt;stdlib.h&amp;gt;

unsigned char* img, *p;
const int n = 4, s = (2 &amp;lt;&amp;lt; n) - 1;

void step(int d) {
    int a[] = { 3, s * 3, -3, s * -3 }, i;
    for (i = 0; i &amp;lt; 2; i++, p += a[d &amp;amp; 3])
        p[0] = p[1] = p[2] = 255;
}

void hilbert(int d, int r, int n) {
    if (n--) {
        hilbert(d + r, -r, n); step(d + r);
        hilbert(d,      r, n); step(d    );
        hilbert(d,      r, n); step(d - r);
        hilbert(d - r, -r, n);
    }
}

int main() {
    p = img = calloc(s * s, 3);
    hilbert(0, 1, n);
    p[0] = p[1] = p[2] = 255;
    svpng(fopen(&quot;hilbert2.png&quot;, &quot;wb&quot;), s, s, img, 0);
    free(img);
}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b39f241a8582cf0669bfb3a0af68cf1c_r.jpg&quot; data-caption=&quot;放大 16 倍后的4阶结果&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;496&quot; data-rawheight=&quot;496&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b39f241a8582cf0669bfb3a0af68cf1c&quot; data-watermark-src=&quot;v2-5f1180c240c8f3460c447eb1b0e68d50&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这种实现方式较简单，也能用最少的影像尺寸存储结果。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 简单文本&lt;/h2&gt;&lt;p&gt;既然可以用较小的画布尺寸，我们直接把每个像素变换成&lt;code class=&quot;inline&quot;&gt;**&lt;/code&gt; 两个字符：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

char* img, *p;
const int n = 4, s = (2 &amp;lt;&amp;lt; n) - 1, a[] = { 2, s * 2, -2, -s * 2 };

void step(int d) {
    int i;
    for (i = 0; i &amp;lt; 2; i++, p += a[d &amp;amp; 3])
        p[0] = p[1] = &#39;*&#39;;
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    memset(p = img = malloc(s * s * 2), &#39; &#39;, s * s * 2);
    hilbert(0, 1, n);
    p[0] = p[1] = &#39;*&#39;;
    for (p = img; p &amp;lt; img + s * s * 2; p += s * 2)
        printf(&quot;%.*s\n&quot;, s * 2, p);
    free(img);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bab9624e85060beacb77194ae95ec8f8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;890&quot; data-rawheight=&quot;898&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bab9624e85060beacb77194ae95ec8f8&quot; data-watermark-src=&quot;v2-2b008e151d8579c2b45fddf22dcb3081&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;h2&gt;4. ASCII 字符美化&lt;/h2&gt;&lt;p&gt;上面的输出有点丑。我在 [4] 里找到一种美化方法，可通过方向的改变来决定用什么字符，该映射为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┌&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt; _&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┐&lt;/code&gt; →  &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;└&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;|_&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┘&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;| &lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;│&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;| &lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;─&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;__&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9f1bf3371387712e2ce38bf9536636b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;186&quot; data-rawheight=&quot;106&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我通过记录上一次的方向，与当前要步进的方向，去做这个映射。例如之前是向下的（&lt;code class=&quot;inline&quot;&gt;l=3&lt;/code&gt;）当前要向右（&lt;code class=&quot;inline&quot;&gt;d=0&lt;/code&gt;），即&lt;code class=&quot;inline&quot;&gt;└&lt;/code&gt; 的情况，便在笔的位置写进&lt;code class=&quot;inline&quot;&gt;|_&lt;/code&gt;这两个字符。针对 &lt;equation&gt;4\times4=16&lt;/equation&gt; 种组合，我用字符串表示：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

char* img, *p;
const int n = 4 , s = 1 &amp;lt;&amp;lt; n, a[] = { 2, s * 2, -2, -s * 2 };
int l = 3;

void step(int d) {
    d &amp;amp;= 3;
    p[0] = &quot;_  ||||   _|   |&quot;[l * 4 + d];
    p[1] = &quot;_   _    ____   &quot;[l * 4 + d];
    p += a[d];
    l = d;
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    p = img = malloc(s * s * 2);
    hilbert(0, 1, n);
    p[0] = p[1] = &#39; &#39;;
    for (p = img; p &amp;lt; img + s * s * 2; p += s * 2)
        printf(&quot;%.*s\n&quot;, s * 2, p);
    free(img);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f6d81fe1327e9a92219de371b4cca505_r.jpg&quot; data-caption=&quot;4阶&quot; data-size=&quot;small&quot; data-rawwidth=&quot;768&quot; data-rawheight=&quot;478&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f6d81fe1327e9a92219de371b4cca505&quot; data-watermark-src=&quot;v2-6f64734912d4820a49f0e40933b5835c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0f01b2e77086e678da2860a55fcba3b7_r.jpg&quot; data-caption=&quot;6阶&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1290&quot; data-rawheight=&quot;1308&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0f01b2e77086e678da2860a55fcba3b7&quot; data-watermark-src=&quot;v2-10deb3eb183f553e27a6da9f87a629de&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;h2&gt;5. 无内存分配&lt;/h2&gt;&lt;p&gt;为了尽一步简化，我希望能去掉画步的内存分配。方法是把逻辑改为，从上至下左至右打印字符，每画两个字符我们都遍历整个曲线，若曲线的位置和当前打印位置相同，才把那两个字符打印出来。这样会增加大量运算，但可以减少代码量。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

const int n = 4, s = 1 &amp;lt;&amp;lt; n, a[] = { 1, s, -1, -s };
int l = 3, p, q;

void step(int d) {
    d &amp;amp;= 3;
    if (p == q)
        printf(&quot;%.2s&quot;, &amp;amp;&quot;__    | |_| |      ___|_ _    | &quot;[l * 8 + d * 2]);
    p += a[l = d];
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    for (; q &amp;lt; s * s; q++, p = 0) {
        hilbert(0, 1, n);
        if (q % s == s - 1)
            putchar(&#39;\n&#39;);
    }
}&lt;/code&gt;&lt;h2&gt;6. 代码压缩&lt;/h2&gt;&lt;p&gt;最后，我把上面的代码压缩成 256 个字符：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;const n=4,s=1&amp;lt;&amp;lt;n,a[]={1,s,-1,-s};
l=3,p,q;
t(d){d&amp;amp;=3;p-q||printf(&quot;%.2s&quot;,&amp;amp;&quot;__    | |_| |      ___|_ _    | &quot;[l*8+d*2]);p+=a[l=d];}
h(d,r,n){n--&amp;amp;&amp;amp;(h(d+r,-r,n),t(d+r),h(d,r,n),t(d),h(d,r,n),t(d-r),h(d-r,-r,n));}
main(){for(;p=0,q&amp;lt;s*s;++q%s||putchar(10))h(0,1,n);}&lt;/code&gt;&lt;a href=&quot;https://tio.run/##VY7RaoQwEEV/RYSVxMwU3e1DIeZLREIwuC6k2Zik7IP665vGdvvQCwNz7syFO@JolL2mNN5tiIUV7xBE23UWVD@ItYUA2AKGnRtxAQcLj0TTVVfiwh0u2@b8zcaJlKe3cyihKqUssrZik3mKH0kpN1m8/LI39QfT9Xmg3DGheiP0wPeZaPBg6WoRq4pkZB7wcCAeO4W/j4P/E/5e8RWgfP9UN0voOt094U40sHShDpyx5RRy4684zsqTtqF0Jg20OcP3lJ7jZNQ1JHx8Aw&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Try It Online&lt;/a&gt;&lt;p&gt;本文所有代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/tree/master/hilbert&quot;&gt;https://github.com/miloyip/misc/tree/master/hilbert&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;相关文章&lt;/h2&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24688522&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b082e4583bfbf99f53a075d4510a2f25&quot; data-image-width=&quot;1439&quot; data-image-height=&quot;1080&quot; data-image-size=&quot;180x120&quot;&gt;Milo Yip：用 C 语言画科赫雪花&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23692828&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b5818ef7694bbb3236a1bdc7e9a8b572&quot; data-image-width=&quot;1620&quot; data-image-height=&quot;1080&quot; data-image-size=&quot;180x120&quot;&gt;Milo Yip：如何用 C 语言画这个图&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/27015321/answer/35028446&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;b92e467997b0f799cfb7f085dc06833a&quot; data-image-width=&quot;1018&quot; data-image-height=&quot;884&quot; data-image-size=&quot;ipico&quot;&gt;如何用 C 语言画一个“圣诞树”？&lt;/a&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] D. Hilbert, &lt;a href=&quot;http://www.digizeitschriften.de/dms/img/?PPN=PPN235181684_0038&amp;amp;DMDID=dmdlog40&quot;&gt;Über die stetige Abbildung einer Linie auf ein Flächenstück&lt;/a&gt;, Mathematische Annalen 38 (1891), 459–460.&lt;/p&gt;&lt;p&gt;[2] &lt;a href=&quot;http://www.soc.napier.ac.uk/~andrew/hilbert.html&quot;&gt;http://www.soc.napier.ac.uk/~andrew/hilbert.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[3] &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35358486&quot;&gt;形形色色的空间填充曲线 和 L-System&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[4] &lt;a href=&quot;https://codegolf.stackexchange.com/questions/104392/ascii-hilbert-curve&quot;&gt;ASCII Hilbert Curve&lt;/a&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-06-20-38276467</guid>
<pubDate>Wed, 20 Jun 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
