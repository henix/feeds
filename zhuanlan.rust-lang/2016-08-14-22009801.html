<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>万变不离其宗</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/22009801">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/ee91688a1f2d5a9fd2c66dd56511a557_r.jpg" alt=""></div><p>在前面的文章中，我们已经讨论了Rust在内存管理方面的语法。本文将主要探讨一下Rust实现无性能损失的“内存安全”的原理。</p><p>Rust语言的核心特点是，在没有放弃对内存的直接控制力的情况下，实现了内存安全。所谓对内存的直接控制能力，在前文已经有所展示：可以自行决定内存布局，包括在栈上分配内存，还是在堆上分配内存；支持指针类型；可以对一个变量实施取地址操作；有确定性的内存释放；等等。</p><p>另一方面，从安全性的角度来说，我们可以看到，Rust有所有权概念，有借用指针，有生命周期分析等这套东西。初学者在刚开始碰到这些概念的时候，往往会觉得无所适从。太麻烦，太复杂了。随便写个小程序都编译不通过，学习曲线非常陡峭。那么，Rust设计者究竟是怎么考虑的这个问题，要设计这样复杂的规则？Rust语言的这一系列安全规则，背后的指导思想究竟是什么呢？</p><p>关于这个问题，<b>强烈建议 </b>各位读者观看一下 Nicholas Matsakis (Rust核心设计者之一)的一个演讲视频： </p><p><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/" class="">https://air.mozilla.org/guaranteeing-memory-safety-in-rust/</a></p><p>Nicholas Matsakis 对 Rust 的设计做出了巨大的贡献，他也特别擅长于把复杂的东西深入浅出地讲解出来。这段视频非常清晰直观的解释了“内存安全”背后的设计思路。</p><p>总的来说，Rust的设计者们在一系列的“内存不安全”的问题中观察到了这样的一个结论：</p><blockquote><p>Danger arises from  <strong>Aliasing + Mutation</strong></p></blockquote><p>首先我们介绍一下这两个概念 Alias 和 Mutation：</p><ul><li>Alias</li></ul><p>意思是“别名”。如果一个变量可以通过多种 Path 来访问，那它们就可以互相看做alias。Alias 意味着“共享”，我们可以通过多个入口访问同一块内存。</p><ul><li>Mutation</li></ul><p>意思是“改变”。如果我们通过某个变量修改了一块内存，就是发生了mutation。Mutation 意味着拥有“修改”权限，我们可以写入数据。</p><p>Rust保证内存安全的一个重要原则就是，如果能保证 alias 和 mutation 不同时出现，那么代码就一定是安全的。</p><p>在本文中，我将此规则总结为：共享不可变，可变不共享。</p><h2>编译错误示例</h2><p>Rust 的编译错误列表 <a href="https://doc.rust-lang.org/error-index.html">https://doc.rust-lang.org/error-index.html</a> 中，从 E0499 到 E0509，所有的这些编译错误，其实都在讲同一件事情。它们主要关心的是共享和可变之间的关系。“共享不可变，可变不共享”是所有这些编译错误遵循的同样的法则。</p><p>下面我们通过几个简单的示例来直观的感受一下，这个规则究竟是什么意思。</p><p>示例一：</p><code lang="text">fn main() {
    let i = 0;
    let p1 = &amp; i;
    let p2 = &amp; i;
    println!("{} {} {}", i, p1, p2);
}
</code><p>以上这段代码是可以编译通过的。其中变量绑定 i p1 p2 指向的是同一个变量，但是它们都只有只读的权限，所以它们存在“共享”，不存在“可变”。因此它一定是安全的。</p><p>示例二：</p><p>我们让变量绑定 i 是可变的，然后在存在 p1 的情况下，通过 i 修改变量的值：</p><code lang="text">fn main() {
    let mut i = 0;
    let p1 = &amp; i;
    i = 1;
}
</code><p>编译可见，出现了错误，错误信息为：</p><code lang="text">error: cannot assign to `i` because it is borrowed [E0506]
</code><p>这个错误可以这么理解：在存在只读借用的情况下，变量绑定 i 和 p1 已经互为 alias，它们之间存在“共享”，因此必须避免“可变”。这段代码违反了“共享不可变”的原则。</p><p>示例三：</p><p>如果我们把上例中的借用，改为可变借用的话，其实是可以通过它修改原先的变量的值的，以下代码可以编译通过：</p><code lang="text">fn main() {
    let mut i = 0;
    let p1 = &amp;mut i;
    *p1 = 1;
}
</code><p>那我们是不是说，它违反了“共享不可变”的原则呢？其实不是。因为这段代码中不存在“共享”。在可变借用存在的时候，编译器认为原先的变量绑定 i 已经被冻结(frozen)，不可通过 i 读写变量。此时有且仅有 p1 这一个入口可以读写变量。证明如下：</p><code lang="text">fn main() {
    let mut i = 0;
    let p1 = &amp;mut i;
    *p1 = 1;
    let x = i; // 通过i读变量
}
</code><p>在存在 p1 的情况下，我们再通过 i 做读操作，是错误的：</p><code lang="text">error: cannot use `i` because it was mutably borrowed [E0503]
</code><p>同理，如果我们改成这样，一样会出错：</p><code lang="text">fn main() {
    let mut i = 0;
    let p1 = &amp;mut i;
    i = 1; // 通过i写变量
}
</code><p>在 p1 存在的情况下，不可通过 i 写变量。如果这种情况可以被允许，那就会出现多个入口可以同时访问同一块内存，且都具有写权限，这就违反了Rust的“共享不可变，可变不共享”的原则。错误信息为：</p><code lang="text">error: cannot assign to `i` because it is borrowed [E0506]
</code><p>示例四：</p><p>同时创建两个可变借用的情况：</p><code lang="text">fn main() {
    let mut i = 0;
    let p1 = &amp;mut i;
    let p2 = &amp;mut i;
}
</code><p>编译错误信息为：</p><code lang="text">error: cannot borrow `i` as mutable more than once at a time [E0499]
</code><p>因为 p1 p2 都是可变借用，它们都指向了同一个变量，而且都有修改权限，这是Rust所不可允许的情况，因此这段代码无法编译通过。</p><p>正因为这样的原因，&amp;mut 型借用也经常被称为“独占指针”，&amp; 型借用也经常被称为“共享指针”。</p><h2>内存不安全示例：修改枚举</h2><p>Rust设计的这个原则，究竟有没有必要呢，它又是如何在实际代码中起到“内存安全”检查作用的呢？</p><p>第一个示例，我们用 enum 来说明。假如说，我们有一个枚举类型：</p><code lang="text">enum StringOrInt {
    Str(String),
    Int(i64),
}
</code><p>它有两个元素，分别可以携带String类型的信息以及i64类型的信息。假如说，我们有一个引用指向了它的内部数据，同时再修改这个变量，大家猜想会发生什么情况？这样做可能会出内存安全问题，因为我们有机会用一个String类型的指针指向了i64类型的数据，或者用一个i64类型的指针，指向了String类型的数据。完整示例如下：</p><code lang="text">use std::fmt::Debug;

#[derive(Debug)]
enum StringOrInt {
    Str(String),
    Int(i64),
}

fn main() {
  use StringOrInt::{Str, Int};
  let mut x = Str("Hello world".to_string());

  if let Str(ref insides) = x {
    x = Int(1);
    println!("inside is {}, x says: {:?}", insides, x);
  }
}
</code><p>这段代码中，我们用if let语法，创建了一个指向内部String的指针，然后在此指针的生命周期内，再把x内部数据变成i64类型。这是典型的内存不安全的场景。</p><p>幸运的是，这段代码编译不通过，错误信息为：</p><code lang="text">error: cannot assign to `x` because it is borrowed [E0506]
</code><p>这个例子，给了我们一个直观的感受，为什么Rust需要“可变性和共享性不能同时存在”的规则。保证当前只有一个访问入口，这是保证安全的可靠做法。</p><h2>内存不安全示例：迭代器失效</h2><p>如果在遍历一个数据结构的过程中，修改这个数据结构，会导致迭代器失效。比如说，在C++里面，我们可能写出这样的代码：</p><code lang="text">#include &lt;vector&gt;

using namespace std;
int main() {
  vector&lt;int&gt; v(10,10);

  for (vector&lt;int&gt;::iterator i = v.begin(); i != v.end(); i++) {
    if (*i % 2 == 0) { // when arbitrary condition satisfied
      v.clear();
    }
  }
  return 0;
}
</code><p>编译，执行，发现程序崩溃了。原因就在于，我们在迭代过程中，数组v直接被清空了，而迭代器并不知道这个信息，它还在继续进行迭代，于是出现了“野指针”现象，此时迭代器实际上指向了已经被释放的内存。迭代器失效这样的问题在C++中是“未定义行为”，也就是说可能发生什么后果都是未知的。这是一种典型的内存不安全行为。</p><p>然而，在Rust里面，这样的代码是不允许编译通过的：</p><code lang="text">fn main() {
  let mut arr = vec!["ABC", "DEF", "GHI"];
  for item in &amp;arr {
    arr.clear();
  }
}
</code><p>为什么Rust可以避免这个问题呢？因为Rust里面的for循环实质上是生成了一个迭代器，它一直持有一个指向容器的引用，当迭代器的生命周期内，任何对容器的修改都是无法编译通过的。类似这样：</p><code lang="text">{  //以下是伪代码
  // 在iter变量的生命周期内，它都持有一个指向arr的引用
  let iter&lt;'a&gt; = into_iter(&amp;'a arr);   
  loop  {
      match iter.next() {
// 如果需要使用 arr 的 &amp;mut 指针，则会发生冲突
// &amp;mut arr 和 &amp;arr 不能同时存在，它违反了Rust内存安全的原则
          Some(i) =&gt; { arr.clear(); }  
          None =&gt; break ,
      }
  }
}
</code><p>在整个 for 循环的范围内，这个迭代器的生命周期都一直存在。而它持有一个指向容器的引用，&amp;型或者&amp;mut型，根据情况而定。迭代器的 api 设计是，可以修改当前指向的元素，没办法修改容器本身的。当你想在这里对容器进行修改的时候，必然需要产生一个新的针对容器的&amp;mut型引用，（clear方法的签名是Vec::clear(&amp;mut self)，调用clear必然产生对原vec的&amp;mut型引用）。这是与Rust的“alias+mutation”规则相冲突的，所以编译不通过。</p><p>“问渠哪得清如许，为有源头活水来”。为什么在Rust中永远不会出现迭代器失效这样的错误？因为通过“mutation + alias”规则，就可以完全杜绝这样的现象，这个规则是Rust内存安全的根，是解决内存安全问题的灵魂。Rust不是针对各式各样的场景，case by case的方式来解决内存安全问题。而是通过一种统一的机制，高屋建瓴地解决了这一类问题，快刀斩乱麻，直击要害。</p><p>面对类似迭代器失效这一类的，指针指向非法地址的内存安全问题，在许多语言中都无法做到静态检查出来。比如在Java中，出现这样的问题的时候，编译器是没法检查出来的，在执行阶段，程序会抛出一个异常Exception in thread "main" java.util.ConcurrentModificationException。因为我们在for循环内部，对容器本身做了修改，java容器探测到了这种修改，然后就阻止了逻辑的继续执行，抛出了异常。java的这个设计相比C++要好很多，因为即便出现了迭代器失效，最多引发异常，而并不会有野指针这样的“内存安全”的问题，因为迭代器没有机会访问已经被释放的非法内存。然而抛出异常并非是一个完美的设计，只是不得已而为之罢了。因为异常本来的设计目的是为了处理外部环境难以预计的错误的，而现在的这个错误，实际上是程序的逻辑错误，即便抛了异常，外部逻辑捕获了这个异常，也没什么好办法处理。唯一合理的修复方案是，发现这样的异常之后，回过头来修复代码错误。这样的问题如果能在编译阶段就能得到发现和解决，才是最合适的解决方案。在遍历容器的时候同时对容器做修改，可能出现在多线程场景，也可能出现在单线程场景。</p><p>类似这样的问题依靠GC也没办法处理。GC只关心内存的分配和释放，对于变量的读写权限是不关心的。GC在此处发挥不了什么作用。</p><p>而Rust依靠我们前面强调的“alias+mutation”规则就可以很好地解决该问题。这个思路的核心就是，如果存在多个只读的引用，是允许的；如果存在可写的引用，那么就一定不能同时存在其它的只读或者可写的引用。大家看到这个逻辑，是不是马上可以联想到多线程环境下的 ReadWriteLocker ? 其实也确实如此，Rust检查内存安全的核心逻辑，可以理解为一个在编译阶段执行的读写锁。多个读同时存在是可以的，存在一个写的时候，其它的读写都不能同时存在。</p><p>大家还记不记得，Rust设计者总结的Rust有三大特点：一是快，二是内存安全，三是免除数据竞争。由上面的分析可见，Rust所说的“免除数据竞争”，实际上和“内存安全”是一码事情。“免除数据竞争”可以看做是多线程环境下的“内存安全”。单线程环境下的“内存安全”靠的是编译阶段的类似读写锁的机制，与多线程环境下其它语言常用的读写锁机制并无巨大区别。也正因为Rust编译器在设计上打下的良好基础，“内存安全”才能轻松地扩展到多线程环境下的“免除数据竞争”。这俩概念其实只有一箭之隔。所以我们可以看到Java将此异常命名为“Concurrent”的真实含义。这里的“Concurrent”并不是单指多线程并发。</p><h2>内存不安全示例：悬空指针</h2><p>我们再使用一个例子，来继续说明一下为什么Rust的“mutation+alias”规则是有必要的。我们这次通过制造一个悬空指针的例子来解释。以下为一段不靠谱C++代码，它创建了一个动态数组，然后使用了一个指针，指向了动态数组的内部元素，然后我们向动态数组中添加内容，然后我们发现，原先的指针“悬空”了，它指向了一个非法的地址：</p><code lang="text">// 仅仅为了示例而已，不代表推荐的C++编码风格
#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;
int main() {
  vector&lt;int&gt; v(100, 5);

  // 指针指向内部第一个元素
  int * p0 = &amp;v[0];
  cout &lt;&lt; *p0 &lt;&lt; endl;
  // 为了确保v发生扩容，多插入一些数据。
  for (int i = 0; i&lt;100; i++) {
    v.push_back(10);
  }
  // 打印p0的内容
  cout &lt;&lt; *p0 &lt;&lt; endl;
  return 0;
}
</code><p>编译通过，执行结果为：</p><code lang="text">5
-72140872
</code><p>熟悉STL的朋友肯定知道这里究竟发生了什么。动态数组是自行管理内存空间的，在往动态数组内部添加元素的时候，如果超过了当前的最大容量，这个动态数组会申请一块更大的连续内存空间，将原先的元素移动过去，释放掉原先的内存空间，然后继续往后面添加元素。</p><p>我们的指针一开始是指向动态数组的第一个元素的，但是当往动态数组内部添加多个元素之后，原先的那块内存已经不够用了，动态数组在这个过程中已经将原先的内存空间释放，并申请了新的内存空间。于是，原本应该指向数组第一个元素的指针从一个合法的指针，变成了指向已回收内存区域的悬空指针，它现在指向的数据是与原先的意图不同的。而这种情况正是属于Rust希望解决的“内存安全”问题。</p><p>我们来看看用Rust写会发生什么。同样的，使用动态数组类型，使用一个指针指向它的第一个元素，然后在原先的动态数组中插入数据：</p><code lang="text">fn main() {
  let mut arr : Vec&lt;i32&gt; = vec![1,2,3,4,5];
  let p : &amp;i32 = &amp;arr[0];
  for i in 1..100 {
    arr.push(i);
  }
}
</code><p>编译不通过，错误信息为：</p><code lang="text">error: cannot borrow `arr` as mutable because it is also borrowed as immutable
</code><p>我们可以看到，“mutation+alias”规则再次起了作用。在存在一个不可变引用的情况下，我们不能修改原先变量的值。写Rust代码的时候，会经常有这样的感觉，Rust编译器极其严格，甚至有点到了不近人情的地步。但是大部分时候，却又发现，它指出来的问题的确是对我们有益的。对它越熟练，越觉得它是一个好帮手。</p><h2>总结</h2><p>Rust在内存安全方面的设计方案的核心思想是， <strong>共享不可变，可变不共享</strong>。</p><p>在可变性控制方面，如果说，C语言和函数式编程语言分属一个天平的两端，那么Rust就处于这个天平的中央。C语言的思想是，尽量不对程序员做限制，尽量接近机器底层，什么类型安全，什么可变性，什么共享性，都是由程序员自由掌控的，语言本身不提供太多的限制和规定。安全与否，完全取决于程序员。而函数式编程的思想是，尽量使用不可变绑定，在可变性上有严格限制，在共享性方面没有限制。函数式编程特别强调无副作用的函数，以及不可变类型，以此来达到提高安全性的目的。</p><p>而Rust则是选择了折中的方案，允许可变性，允许共享性，只要这两者不是同时出现。共享不可变，可变不共享，这是Rust中保证内存安全和线程安全的法宝。而我们可以看到，Rust的这个设计并不是首鼠两端，和稀泥式的中庸之道。而是经过了仔细的观察总结、严谨的设计之后的产物。</p><p>其一，相比于函数式设计方式，它并没有本质上牺牲安全性，Rust和Haskell具有同一等级的安全性（Rust设计组原话）。函数式编程强调的“不可变”特性，极大提升了安全性的同时，也极大提高了学习门槛。而 Rust 在“不可变”要求上的理性妥协，实现了在不损失安全性的同时，一定程度上降低了学习成本。从 C/C++ 背景转为使用 Rust 无需做太大的思维转变。相比于函数式的设计方式，它的入门门槛更低。虽然对于习惯了无拘无束自由挥洒的 C/C++ 编程语言的朋友来说，还是有诸多不习惯，但毕竟比 Haskell 这种要容易。</p><p>其二，Rust 针对传统 C/C++ 做了大幅改进，设计了一系列静态检查规则，来防止一些潜在的bug。“共享不可变，可变不共享”就是其中一项重要的原则。在传统的 C/C++ 中，所有的指针都是同一个类型。从功能性上来说，这么设计是非常强大的，但它缺少的恰恰是一定程度的取舍，以提高安全性。相对来说，Rust 对程序员的限制更多，有所为，有所不为。鼓励用户使用的功能，应当越容易越优雅越好；避免用户滥用的功能，应当越困难越复杂越好。二者不可偏废。</p><p>其三，Rust 的这套内存安全体系，不需要依赖 GC。虽然现在 GC 的性能越来越好，但是没有 GC 在某些场景下依然是很重要的。没有 GC、编译型语言的特点，是 Rust 执行性能的潜力保证。这是为什么Rust设计组有底气说 Rust 的运行性能与 C 语言处于同一档次的原因。当然目前的 Rust 还很年轻，许多优化还没有实现，但这不要紧，单从技术层面上看，还有许多优化在可行性上是没问题的，唯一需要的是时间和工作量，还有不少潜力可以挖。另外，没有 GC 就可以使得它只依赖一个非常轻量级的薄薄的 runtime。理论上来说，它可以用于许多嵌入式平台上，甚至可以在无操作系统的裸机上执行，使用Rust编写操作系统也是完全可行的。这就使得Rust拥有与C/C++相似的系统级编程特性，大幅扩展了 Rust 的应用场景。</p><p>其四，Rust 的核心思想 “共享不可变，可变不共享”，具有极好的一致性和扩展性。它不仅仅可以解决内存安全的问题，还是解决线程安全的基础。在后文中我们可以看到，所谓的线程安全，实质就是内存安全在多线程情况下的自然延伸。反过来，我们也可以把 Rust 的内存安全解决方案视为传统的线程安全机制 Read Write Locker 的编译阶段执行的版本。大家应该都能联想到，在多线程环境下，数据竞争问题是怎么出现的。如果多个线程对同一个共享变量都是只读的，它是安全的；如果有一个线程对共享变量写操作，那它就必须是独占的，不可有其它线程继续读写。否则，就会出现数据竞争。在后面的文章中，我们还会发现，Rust 里面的许多线程安全的类型，与一些非线程安全的类型，具有非常有趣的迷之对称性。</p><p>由此我们可以看出，Rust的这套设计方案的的确确是有创新性的，它走出来了一条前无古人的道路。Rust在其它方面的功能，都不能称作是原创设计，都是从其它编程语言前辈中学过来的。唯独安全性方面的设计，是独一无二的。只要我们保证了“共享不可变，可变不共享”，我们就可以保证内存安全。那么它这套设计方案，究竟能不能被大众所接受呢，我们拭目以待。</p><p>本文同步发布在微信公众号：<b>Rust编程</b>，欢迎关注。</p><br>​
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
