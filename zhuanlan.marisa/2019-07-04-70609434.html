<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>从单位半群到单子</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/70609434">原文</a></p>
<p>接触函数式编程的人越来越多了，学习Haskell的人也多了起来。很多人在逐渐深入学习的过程中，都不可避免的会遇到一个Haskell等函数式编程中一个常用的重要概念---单子（monad）。</p><p>单子是什么呢？这是一个困扰很多人的问题。很多时候貌似搞懂了，可回过头来仔细一想，又不明白了，总是觉得有那么一层不清晰的东西蒙在上面。本文试图从单位半群（monoid）开始一步一步的揭开这层不清晰的东西，带领大家看到真正的单子（monad）的样子。</p><p><b>读者提醒：对已经会在实际编程中熟练的使用单子，但对深究单子的数学意义和范畴论不感兴趣的朋友，可以不用继续往下阅读了。以下内容对在编程实践中更好的使用单子帮助不大，不过对理解函数式编程理论中的概念和Haskell中的一些高深的代码会有一个更好的基础。</b></p><p><b>约定：下面统一用中文的单子表示monad，单位半群表示monoid。</b></p><p>我们常常听到，单子就是一个自函子范畴上的单位半群。既然单子就是一个单位半群，那我们就从单位半群开始，看看单子究竟是什么。</p><p><b>集合上的单位半群</b></p><p>单位半群我们已经很熟悉了，当集合 S 上存在一个闭合的二元运算 *: S <img src="https://www.zhihu.com/equation?tex=%5Ctimes" alt="\times" eeimg="1"/> S -&gt; S， 和一个单位元 e。对集合 S 中的任意元素 a、b、c，满足如下的性质，我们就说这个集合是一个单位半群。</p><div class="highlight"><pre><code class="language-text">              e * a = a                        --- 左单位元定律
              a * e = a                        --- 右单位元定律
        (a * b) * c = a * (b * c)              --- 结合律</code></pre></div><p>下面是单位半群的元素和运算的示意图</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-99279827afe5fb268fdaf8f229a3cd8c_b.jpg" data-size="normal" data-rawwidth="576" data-rawheight="849" class="origin_image zh-lightbox-thumb" width="576" data-original="https://pic1.zhimg.com/v2-99279827afe5fb268fdaf8f229a3cd8c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-99279827afe5fb268fdaf8f229a3cd8c_b.jpg" data-size="normal" data-rawwidth="576" data-rawheight="849" class="origin_image zh-lightbox-thumb lazy" width="576" data-original="https://pic1.zhimg.com/v2-99279827afe5fb268fdaf8f229a3cd8c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-99279827afe5fb268fdaf8f229a3cd8c_b.jpg"/><figcaption>单位半群的二元运算</figcaption></figure><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-f495365ad25c880961accd48c138668a_b.jpg" data-size="normal" data-rawwidth="605" data-rawheight="833" class="origin_image zh-lightbox-thumb" width="605" data-original="https://pic3.zhimg.com/v2-f495365ad25c880961accd48c138668a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-f495365ad25c880961accd48c138668a_b.jpg" data-size="normal" data-rawwidth="605" data-rawheight="833" class="origin_image zh-lightbox-thumb lazy" width="605" data-original="https://pic3.zhimg.com/v2-f495365ad25c880961accd48c138668a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-f495365ad25c880961accd48c138668a_b.jpg"/><figcaption>左单位元定律</figcaption></figure><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-53781b4360ec7eef10064a737a66fc66_b.jpg" data-size="normal" data-rawwidth="571" data-rawheight="819" class="origin_image zh-lightbox-thumb" width="571" data-original="https://pic3.zhimg.com/v2-53781b4360ec7eef10064a737a66fc66_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-53781b4360ec7eef10064a737a66fc66_b.jpg" data-size="normal" data-rawwidth="571" data-rawheight="819" class="origin_image zh-lightbox-thumb lazy" width="571" data-original="https://pic3.zhimg.com/v2-53781b4360ec7eef10064a737a66fc66_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-53781b4360ec7eef10064a737a66fc66_b.jpg"/><figcaption>右单位元定律</figcaption></figure><p>（还有结合律的图等我家小学生期末考试后再补上吧）</p><p>在Haskell中可以用类型类Monoid来表示：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">class</span> <span class="kt">Monoid</span> <span class="nf">m</span> <span class="kr">where</span>
    <span class="nf">mempty</span>   <span class="ow">::</span> <span class="nf">m</span>                       <span class="o">--^</span> <span class="err">这就是单位元</span> <span class="nf">e</span>
    <span class="nf">mappend</span> <span class="ow">::</span> <span class="nf">m</span> <span class="ow">-&gt;</span> <span class="nf">m</span> <span class="ow">-&gt;</span> <span class="nf">m</span>              <span class="o">--^</span> <span class="err">这就是二元运算</span> <span class="o">*</span>

<span class="o">--^</span> <span class="nf">mempty和mappend需要由程序员来保证满足如下的单位半群定律</span>
<span class="c1">--   mempty `mappend` a = a            --^ 左单位元定律</span>
<span class="c1">--   a `mappend` mempty = a            --^ 右单位元定律</span>
<span class="c1">--  (a `mappend` b) `mappend` c = a `mappend` (b `mappend` c)   --^ 结合律</span></code></pre></div><p>我们先来看一个常用的64位无符号整数组成的集合，我们知道这个集合有单位元0，其二元运算是加法 +，对任意的64位无符号整数a、b、c，有如下的性质：</p><div class="highlight"><pre><code class="language-text">               0 + a = a                        --- 左单位元定律
               a + 0 = a                        --- 右单位元定律
         (a + b) + c = a + (b + c)              --- 加法的结合律</code></pre></div><p>于是我们可以说这个64位无符号整数组成的集合是一个单位半群，有如下的单位半群实例。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Word64</span> <span class="kr">where</span>
    <span class="nf">mempty</span>  <span class="ow">=</span> <span class="mi">0</span>               <span class="o">--^</span> <span class="err">单位元是</span><span class="mi">0</span>
    <span class="nf">mappend</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>             <span class="o">--^</span> <span class="err">二元运算是加法</span></code></pre></div><p>我们再来看一个更简单的布尔集合，这个集合只有True和False两个元素。</p><figure data-size="small"><noscript><img src="https://pic2.zhimg.com/v2-102255d0fe81362ca940eea257c8e885_b.jpg" data-caption="" data-size="small" data-rawwidth="702" data-rawheight="489" class="origin_image zh-lightbox-thumb" width="702" data-original="https://pic2.zhimg.com/v2-102255d0fe81362ca940eea257c8e885_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-102255d0fe81362ca940eea257c8e885_b.jpg" data-caption="" data-size="small" data-rawwidth="702" data-rawheight="489" class="origin_image zh-lightbox-thumb lazy" width="702" data-original="https://pic2.zhimg.com/v2-102255d0fe81362ca940eea257c8e885_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-102255d0fe81362ca940eea257c8e885_b.jpg"/></figure><p>  （等我家小学生期末考试后换个好看的图）</p><p>当二元运算是与操作 &amp;&amp; 时，单位元是True，得到了一个单位半群。有如下的性质：</p><div class="highlight"><pre><code class="language-text">               True &amp;&amp; a = a                        --- 左单位元定律
               a &amp;&amp; True = a                        --- 右单位元定律
           (a &amp;&amp; b) &amp;&amp; c = a &amp;&amp; (b &amp;&amp; c)            --- 与操作的结合律</code></pre></div><p>在Haskell中，用All来表示这个单位半群。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">All</span> <span class="ow">=</span> <span class="kt">All</span> <span class="p">{</span> <span class="nf">getAll</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">All</span> <span class="kr">where</span>
    <span class="nf">mempty</span>  <span class="ow">=</span> <span class="kt">True</span>
    <span class="nf">mappend</span> <span class="ow">=</span> <span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span></code></pre></div><p>当二元运算是或操作 || 时，单位元是False，也得到了一个单位半群。有如下的性质：</p><div class="highlight"><pre><code class="language-text">              False || a = a                        --- 左单位元定律
              a || False = a                        --- 右单位元定律
           (a || b) || c = a || (b || c)            --- 或操作的结合律</code></pre></div><p>在Haskell中，用Any来表示这个单位半群。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">Any</span> <span class="ow">=</span> <span class="kt">Any</span> <span class="p">{</span> <span class="nf">getAny</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Any</span> <span class="kr">where</span>
    <span class="nf">mempty</span>  <span class="ow">=</span> <span class="kt">False</span>
    <span class="nf">mappend</span> <span class="ow">=</span> <span class="p">(</span><span class="o">||</span><span class="p">)</span></code></pre></div><p>其他的单位半群实例就不一一举例了，有兴趣的可以看看Haskell的Data.Monoid中的例子。</p><p><b>自态射上的单位半群</b></p><p>我们现在来看另一种形式的单位半群。给定一个范畴 C，我们假定这个范畴的两个对象 a 和 b 之间的所有态射组成了一个集合，叫Hom-set，简记为 C(a, b)。这个集合中的每一个元素都是 a 和 b 之间的态射。</p><p>当这个范畴 C 只有一个对象 a 时，对象 a 和 a 之间的态射是 a 上的自态射，a 上的所有自态射同样也组成了一个集合。根据范畴的定义，这个自态射的集合存在一个二元运算 <img src="https://www.zhihu.com/equation?tex=%5Ccdot" alt="\cdot" eeimg="1"/> ，即态射的组合运算，两个态射的组合 g <img src="https://www.zhihu.com/equation?tex=%5Ccdot" alt="\cdot" eeimg="1"/> f 依然是一个态射，还存在一个单位元即态射 id。满足如下性质：</p><div class="highlight"><pre><code class="language-text">               id . f = f                        --- 左单位元定律
               f . id = f                        --- 右单位元定律
          (h . g) . f = h . (g . f)              --- 态射组合的结合律</code></pre></div><p>于是一个对象上的自态射的集合 C(a, a) 就是一个单位半群。</p><figure data-size="small"><noscript><img src="https://pic4.zhimg.com/v2-3de56554fc653ac69e372c0c32d2b6e7_b.jpg" data-size="small" data-rawwidth="699" data-rawheight="599" class="origin_image zh-lightbox-thumb" width="699" data-original="https://pic4.zhimg.com/v2-3de56554fc653ac69e372c0c32d2b6e7_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-3de56554fc653ac69e372c0c32d2b6e7_b.jpg" data-size="small" data-rawwidth="699" data-rawheight="599" class="origin_image zh-lightbox-thumb lazy" width="699" data-original="https://pic4.zhimg.com/v2-3de56554fc653ac69e372c0c32d2b6e7_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-3de56554fc653ac69e372c0c32d2b6e7_b.jpg"/><figcaption>自态射单位半群示意图</figcaption></figure><p>在Haskell中用Endo a类型来表示这个单位半群。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">Endo</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Endo</span> <span class="p">{</span> <span class="nf">appEndo</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="p">}</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Endo</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="nf">mempty</span>  <span class="ow">=</span> <span class="nf">id</span>
    <span class="nf">mappend</span> <span class="ow">=</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span></code></pre></div><p>可以将多个Endo a类型的函数放到一个列表里，这样我们就可以把多个简单的步骤组合成一个复杂的步骤，这个可以定义一个foldEndo 函数来完成。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">foldEndo</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Endo</span> <span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Endo</span> <span class="nf">a</span>
<span class="nf">foldEndo</span> <span class="ow">=</span> <span class="nf">foldr</span> <span class="nf">mappend</span> <span class="nf">mempty</span></code></pre></div><p>下面是将几个自态射组合成一个自态射的应用例子，给定一个数，输出一个数。</p><div class="highlight"><pre><code class="language-haskell"><span class="o">&gt;</span> <span class="p">(</span><span class="nf">appEndo</span> <span class="o">.</span> <span class="nf">foldEndo</span> <span class="o">.</span> <span class="nf">map</span> <span class="kt">Endo</span> <span class="o">$</span> <span class="p">[(</span><span class="o">+</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span> <span class="p">(`</span><span class="nf">mod</span><span class="p">`</span> <span class="mi">7</span><span class="p">)])</span> <span class="mi">88</span>
<span class="mi">19</span></code></pre></div><p><b>幺半范畴和丰化范畴</b></p><p>范畴的对象之间的所有态射可以组成一个集合，具有这个性质的范畴叫局部小范畴。但还有很多范畴不具有这个性质。那我们怎么来表示一般范畴的对象之间的所有态射呢？</p><p>我们可以用另一个范畴上的对象来表示范畴 C 上的对象之间的所有态射，称为Hom-object，同样简记为 C(a, b)，这个范畴叫范畴 V。</p><figure data-size="small"><noscript><img src="https://pic2.zhimg.com/v2-c5face0db44d0b89175f6619693cd3d9_b.jpg" data-size="small" data-rawwidth="713" data-rawheight="523" class="origin_image zh-lightbox-thumb" width="713" data-original="https://pic2.zhimg.com/v2-c5face0db44d0b89175f6619693cd3d9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-c5face0db44d0b89175f6619693cd3d9_b.jpg" data-size="small" data-rawwidth="713" data-rawheight="523" class="origin_image zh-lightbox-thumb lazy" width="713" data-original="https://pic2.zhimg.com/v2-c5face0db44d0b89175f6619693cd3d9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-c5face0db44d0b89175f6619693cd3d9_b.jpg"/><figcaption>范畴 C 和 范畴 V</figcaption></figure><p>如果范畴 V 上存在张量积 ⊗ : V <img src="https://www.zhihu.com/equation?tex=%5Ctimes" alt="\times" eeimg="1"/> V -&gt; V ，同时还具有这个张量积运算的单位元 i ，满足左右单位元定律，使得有自然变换 λ: i ⊗ C(a, b) ≃ C(a, b)，和  ρ: C(a, b) ⊗ i ≃ C(a, b)。而且如果张量积运算满足结合律，即有自然变换 α: (C(c, d) ⊗ C(b, c)) ⊗ C(a,b) ≃ C(c, d) ⊗ (C(b, c) ⊗ C(a,b))。这些自然变换满足如下的同归图，为了简化图，使用a、b、c、d 来表示范畴 V 上的对象：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-7db2771fbca4dc4a077cc08e96f92829_b.jpg" data-size="normal" data-rawwidth="1235" data-rawheight="574" class="origin_image zh-lightbox-thumb" width="1235" data-original="https://pic2.zhimg.com/v2-7db2771fbca4dc4a077cc08e96f92829_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-7db2771fbca4dc4a077cc08e96f92829_b.jpg" data-size="normal" data-rawwidth="1235" data-rawheight="574" class="origin_image zh-lightbox-thumb lazy" width="1235" data-original="https://pic2.zhimg.com/v2-7db2771fbca4dc4a077cc08e96f92829_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-7db2771fbca4dc4a077cc08e96f92829_b.jpg"/><figcaption>幺半范畴的张量积运算的结合一致性</figcaption></figure><p class="ztext-empty-paragraph"><br/></p><figure data-size="small"><noscript><img src="https://pic3.zhimg.com/v2-b1191157c54f989587e46a673c6ab79e_b.jpg" data-size="small" data-rawwidth="685" data-rawheight="286" class="origin_image zh-lightbox-thumb" width="685" data-original="https://pic3.zhimg.com/v2-b1191157c54f989587e46a673c6ab79e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-b1191157c54f989587e46a673c6ab79e_b.jpg" data-size="small" data-rawwidth="685" data-rawheight="286" class="origin_image zh-lightbox-thumb lazy" width="685" data-original="https://pic3.zhimg.com/v2-b1191157c54f989587e46a673c6ab79e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-b1191157c54f989587e46a673c6ab79e_b.jpg"/><figcaption>幺半范畴的单位元的左右结合一致性</figcaption></figure><p>则我们得到了幺半范畴（Monoidal Category）。可以有如下的Haskell的类型类的实例。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">instance</span> <span class="kt">Monoidal</span> <span class="p">(</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="p">(,)</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kt">Id</span> <span class="p">(</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="p">(,)</span> <span class="ow">=</span> <span class="nb">()</span>
    <span class="nf">idl</span> <span class="ow">=</span> <span class="nf">snd</span>
    <span class="nf">idr</span> <span class="ow">=</span> <span class="nf">fst</span>
    <span class="nf">coidl</span> <span class="nf">a</span> <span class="ow">=</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="nf">a</span><span class="p">)</span>
    <span class="nf">coidr</span> <span class="nf">a</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span><span class="nb">()</span><span class="p">)</span>
    <span class="nf">assoc</span> <span class="p">((</span><span class="nf">a</span><span class="p">,</span> <span class="nf">b</span><span class="p">),</span> <span class="nf">c</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span> <span class="p">(</span><span class="nf">b</span><span class="p">,</span> <span class="nf">c</span><span class="p">))</span>
    <span class="nf">coassoc</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span> <span class="p">(</span><span class="nf">b</span><span class="p">,</span> <span class="nf">c</span><span class="p">))</span> <span class="ow">=</span> <span class="p">((</span><span class="nf">a</span><span class="p">,</span> <span class="nf">b</span><span class="p">),</span> <span class="nf">c</span><span class="p">)</span>

<span class="o">--^</span> <span class="nf">idl</span><span class="p">,</span> <span class="nf">idr和assoc是自然同构</span>
<span class="nf">idr</span> <span class="o">.</span> <span class="nf">coidr</span> <span class="ow">=</span> <span class="nf">id</span>
<span class="nf">idl</span> <span class="o">.</span> <span class="nf">coidl</span> <span class="ow">=</span> <span class="nf">id</span>
<span class="nf">coidl</span> <span class="o">.</span> <span class="nf">idl</span> <span class="ow">=</span> <span class="nf">id</span>
<span class="nf">coidr</span> <span class="o">.</span> <span class="nf">idr</span> <span class="ow">=</span> <span class="nf">id</span>
<span class="nf">assoc</span> <span class="o">.</span> <span class="nf">coassoc</span> <span class="ow">=</span> <span class="nf">id</span>
<span class="nf">coassoc</span> <span class="o">.</span> <span class="nf">assoc</span> <span class="ow">=</span> <span class="nf">id</span>

<span class="o">--^</span> <span class="nf">idl</span><span class="p">,</span> <span class="nf">idr和assoc满足如下的幺半范畴的张量积运算的单位元定律和结合律</span>
<span class="c1">-- first 和 second是Arrow的函数</span>
<span class="nf">first</span> <span class="nf">idr</span> <span class="ow">=</span> <span class="nf">second</span> <span class="nf">idl</span> <span class="o">.</span> <span class="nf">assoc</span>
<span class="nf">second</span> <span class="nf">idl</span> <span class="ow">=</span> <span class="nf">first</span> <span class="nf">idr</span> <span class="o">.</span> <span class="nf">coassoc</span>

<span class="nf">assoc</span> <span class="o">.</span> <span class="nf">assoc</span> <span class="ow">=</span> <span class="nf">second</span> <span class="nf">assoc</span> <span class="o">.</span> <span class="nf">assoc</span> <span class="o">.</span> <span class="nf">first</span> <span class="nf">assoc</span></code></pre></div><p>因为一般范畴上的对象内部是不可见的，我们不能象集合那样从内部选一个元素来作为单位元。但我们可以用一个态射来表示Hom-object上的单位元，即如果可以在范畴 V 上找到态射 <img src="https://www.zhihu.com/equation?tex=j_a" alt="j_a" eeimg="1"/>: i -&gt; C(a, a)，满足如下的同归图，那我们就可以把态射 <img src="https://www.zhihu.com/equation?tex=j_a" alt="j_a" eeimg="1"/>: i -&gt; C(a, a) 作为 C(a, a)上的单位元。</p><figure data-size="small"><noscript><img src="https://pic1.zhimg.com/v2-eacfe0da18de6507f437c0222f00c068_b.jpg" data-caption="" data-size="small" data-rawwidth="696" data-rawheight="301" class="origin_image zh-lightbox-thumb" width="696" data-original="https://pic1.zhimg.com/v2-eacfe0da18de6507f437c0222f00c068_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-eacfe0da18de6507f437c0222f00c068_b.jpg" data-caption="" data-size="small" data-rawwidth="696" data-rawheight="301" class="origin_image zh-lightbox-thumb lazy" width="696" data-original="https://pic1.zhimg.com/v2-eacfe0da18de6507f437c0222f00c068_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-eacfe0da18de6507f437c0222f00c068_b.jpg"/></figure><figure data-size="small"><noscript><img src="https://pic2.zhimg.com/v2-fe8f9a3eb7f1f2ceb019ca8e6a6ece41_b.jpg" data-caption="" data-size="small" data-rawwidth="625" data-rawheight="275" class="origin_image zh-lightbox-thumb" width="625" data-original="https://pic2.zhimg.com/v2-fe8f9a3eb7f1f2ceb019ca8e6a6ece41_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-fe8f9a3eb7f1f2ceb019ca8e6a6ece41_b.jpg" data-caption="" data-size="small" data-rawwidth="625" data-rawheight="275" class="origin_image zh-lightbox-thumb lazy" width="625" data-original="https://pic2.zhimg.com/v2-fe8f9a3eb7f1f2ceb019ca8e6a6ece41_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-fe8f9a3eb7f1f2ceb019ca8e6a6ece41_b.jpg"/></figure><p>如果范畴 C 上的态射的组合可以表示为范畴 V 上的组合运算 <img src="https://www.zhihu.com/equation?tex=%5Ccirc+" alt="\circ " eeimg="1"/> :  C(b, c) ⊗  C(a, b) -&gt; C(a, c)，将两个Hom-object组合成一个Hom-object，且满足如下的同归图。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-8fe02222feb02fb8c6cdb9c61164b9c3_b.jpg" data-caption="" data-size="normal" data-rawwidth="1241" data-rawheight="351" class="origin_image zh-lightbox-thumb" width="1241" data-original="https://pic4.zhimg.com/v2-8fe02222feb02fb8c6cdb9c61164b9c3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-8fe02222feb02fb8c6cdb9c61164b9c3_b.jpg" data-caption="" data-size="normal" data-rawwidth="1241" data-rawheight="351" class="origin_image zh-lightbox-thumb lazy" width="1241" data-original="https://pic4.zhimg.com/v2-8fe02222feb02fb8c6cdb9c61164b9c3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-8fe02222feb02fb8c6cdb9c61164b9c3_b.jpg"/></figure><p>则我们得到了幺半范畴 V 上的丰化范畴（Enriched Category）。</p><figure data-size="small"><noscript><img src="https://pic1.zhimg.com/v2-c9991cd4919f13938497b068547b1f74_b.jpg" data-caption="" data-size="small" data-rawwidth="713" data-rawheight="603" class="origin_image zh-lightbox-thumb" width="713" data-original="https://pic1.zhimg.com/v2-c9991cd4919f13938497b068547b1f74_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-c9991cd4919f13938497b068547b1f74_b.jpg" data-caption="" data-size="small" data-rawwidth="713" data-rawheight="603" class="origin_image zh-lightbox-thumb lazy" width="713" data-original="https://pic1.zhimg.com/v2-c9991cd4919f13938497b068547b1f74_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-c9991cd4919f13938497b068547b1f74_b.jpg"/></figure><p>如果幺半范畴 V 的张量积运算是可交换的，即有自然变换 γ : C(b, c) ⊗  C(a, b) ≃ C(a, b) ⊗  C(b, c)，则幺半范畴 V 是对称幺半范畴。</p><p>另外如果幺半范畴 V 中的所有对象 A 都存在如下的自然同构，此时存在一对伴随函子 <img src="https://www.zhihu.com/equation?tex=-+%5Cotimes+A+%5C+%5Cdashv+%5C+-%5EA" alt="- \otimes A \ \dashv \ -^A" eeimg="1"/> ，则幺半范畴 V 是闭范畴。其中<img src="https://www.zhihu.com/equation?tex=B%5EA" alt="B^A" eeimg="1"/>是这个闭范畴中的一个对象，称为指数对象。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cphi%3A+V%28X+%5Cotimes+A%2C+B%29+%5Csimeq+V%28X%2C+B%5EA%29+%3A+%5Cpsi" alt="\phi: V(X \otimes A, B) \simeq V(X, B^A) : \psi" eeimg="1"/> </p><p>当幺半范畴 V 既是对称范畴又是闭范畴时，称之为对称闭幺半范畴。可以证明，对称闭幺半范畴 V 是其自身上的丰化范畴。</p><p>Haskell 中的 Hask 范畴就是一个幺半范畴，其张量积是Haskell的元组 (,)，单位对象是Unit，也即 ()。其结合律由 (a, (b, c)) ≃ ((a, b), c) 表示，左单位元定律由 ((), a) ≃ a 表示，右单位元定律由 (a, ()) ≃ a 表示。Hask 范畴也是一个对称幺半范畴，其交换律由 (a, b) ≃ (b, a) 表示。</p><p>Hask 范畴的指数对象 <img src="https://www.zhihu.com/equation?tex=B%5EA" alt="B^A" eeimg="1"/> 就是函数类型 A -&gt; B，且对任意对象 A，都存在指数化函子 <img src="https://www.zhihu.com/equation?tex=-%5EA" alt="-^A" eeimg="1"/>  ，因此是一个对称闭幺半范畴。</p><p>于是我们得到Hask 范畴是其自身上的丰化范畴，单位元态射 <img src="https://www.zhihu.com/equation?tex=j_a" alt="j_a" eeimg="1"/> 是 () -&gt; a，组合运算 <img src="https://www.zhihu.com/equation?tex=%5Ccirc+" alt="\circ " eeimg="1"/> 是 <img src="https://www.zhihu.com/equation?tex=%5Ccdot" alt="\cdot" eeimg="1"/> : (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)。</p><p><b>幺半范畴上的单位半群</b></p><p>接下来，我们开始在幺半范畴 V 上构造一个单位半群。首先，我们来看只有一个对象 a 的范畴 C，其对象上的态射都是自态射。我们可以找到其对应的幺半范畴 V 。</p><p>这个幺半范畴 V 的对象表示了范畴 C 的自态射的Hom-object，简记为 C(a, a)。同样的，有张量积 ⊗ : V <img src="https://www.zhihu.com/equation?tex=%5Ctimes" alt="\times" eeimg="1"/> V -&gt; V ，这个张量积运算有单位元 i ，即有自然变换 λ: i ⊗ C(a, a) ≃ C(a, a)，和  ρ: C(a, a) ⊗ i ≃ C(a, a)。而且张量积运算满足结合律，即有自然变换 α: (C(a, a) ⊗ C(a, a)) ⊗ C(a,a) ≃ C(a, a) ⊗ (C(a, a) ⊗ C(a,a))。这些自然变换满足上面的结合律一致性和单位元左右结合一致性的同归图。</p><figure data-size="small"><noscript><img src="https://pic2.zhimg.com/v2-cd08f9c668f7eab48327b9c07f0d5e25_b.jpg" data-size="small" data-rawwidth="653" data-rawheight="1062" class="origin_image zh-lightbox-thumb" width="653" data-original="https://pic2.zhimg.com/v2-cd08f9c668f7eab48327b9c07f0d5e25_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-cd08f9c668f7eab48327b9c07f0d5e25_b.jpg" data-size="small" data-rawwidth="653" data-rawheight="1062" class="origin_image zh-lightbox-thumb lazy" width="653" data-original="https://pic2.zhimg.com/v2-cd08f9c668f7eab48327b9c07f0d5e25_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-cd08f9c668f7eab48327b9c07f0d5e25_b.jpg"/><figcaption>自态射的Enriched V</figcaption></figure><p>类似的，我们可以证明这个幺半范畴 V 是对称闭幺半范畴，因此是其自身的丰化范畴。这个丰化范畴的单位元是态射 e: i -&gt; C(a, a)，二元运算是态射mu: C(a, a) ⊗  C(a, a) -&gt; C(a, a)。满足如下的左右单位元定律：</p><div class="highlight"><pre><code class="language-text">         mu . e ⊗ id ≃ λ
         mu . id ⊗ e ≃ ρ</code></pre></div><p>和结合律：</p><div class="highlight"><pre><code class="language-text">    mu . mu ⊗ id ≃ mu . id ⊗ mu</code></pre></div><p>于是我们就在幺半范畴 V 上构造出了一个单位半群，这个单位半群的单位元是态射 e，二元运算是 mu 。</p><p><b>自函子范畴上的单位半群</b></p><p>对象是范畴的范畴我们称之为 <b>Cat</b> 范畴，这个范畴的对象之间的态射是函子，例如范畴 C 到范畴 D 的函子记为 F: C -&gt; D。函子之间的态射称为自然变换，例如有自然变换 α : F -&gt; G 。</p><figure data-size="small"><noscript><img src="https://pic4.zhimg.com/v2-e5e1249e7e59bf5b793439428fb1dd3f_b.jpg" data-size="small" data-rawwidth="658" data-rawheight="526" class="origin_image zh-lightbox-thumb" width="658" data-original="https://pic4.zhimg.com/v2-e5e1249e7e59bf5b793439428fb1dd3f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-e5e1249e7e59bf5b793439428fb1dd3f_b.jpg" data-size="small" data-rawwidth="658" data-rawheight="526" class="origin_image zh-lightbox-thumb lazy" width="658" data-original="https://pic4.zhimg.com/v2-e5e1249e7e59bf5b793439428fb1dd3f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-e5e1249e7e59bf5b793439428fb1dd3f_b.jpg"/><figcaption>Cat 范畴和函子，自然变换</figcaption></figure><p>现在我们来看只有一个对象的 <b>Cat</b> 范畴，其对象是范畴 C，态射是范畴 C 上的自态射，也就是自函子。所有在范畴 C 上的自函子构成了一个自函子范畴，这个范畴的对象是范畴 C 上的自函子，态射是自函子之间的自然变换。</p><p>如果把函子的组合运算 ◦，看成是一个张量运算，两个同样的自函子的张量积也记为 M (M a)。于是有得到一系列的自函子Id，M ◦ M ，M ◦ M ◦ M ，· · · ，则这些自函子构成的自函子范畴也是一个幺半范畴，这个幺半范畴的单位对象是自函子 Id 。这个幺半范畴同时也是其自身上的丰化范畴。</p><figure data-size="small"><noscript><img src="https://pic4.zhimg.com/v2-63a0e0473f4f017e519992a718f9603f_b.jpg" data-size="small" data-rawwidth="750" data-rawheight="680" class="origin_image zh-lightbox-thumb" width="750" data-original="https://pic4.zhimg.com/v2-63a0e0473f4f017e519992a718f9603f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-63a0e0473f4f017e519992a718f9603f_b.jpg" data-size="small" data-rawwidth="750" data-rawheight="680" class="origin_image zh-lightbox-thumb lazy" width="750" data-original="https://pic4.zhimg.com/v2-63a0e0473f4f017e519992a718f9603f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-63a0e0473f4f017e519992a718f9603f_b.jpg"/><figcaption>自函子范畴是其自身的丰化范畴</figcaption></figure><p>于是同样的，我们在这个自函子范畴上得到一个单位半群，其单位元是自然变换 e: Id -&gt; M，二元运算是自然变换 mu: M ◦ M  -&gt; M，这就是单子。满足如下的同归图。 </p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-edf4585b043c1ab5d5371c5596a8d0d0_b.jpg" data-size="normal" data-rawwidth="565" data-rawheight="264" class="origin_image zh-lightbox-thumb" width="565" data-original="https://pic1.zhimg.com/v2-edf4585b043c1ab5d5371c5596a8d0d0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-edf4585b043c1ab5d5371c5596a8d0d0_b.jpg" data-size="normal" data-rawwidth="565" data-rawheight="264" class="origin_image zh-lightbox-thumb lazy" width="565" data-original="https://pic1.zhimg.com/v2-edf4585b043c1ab5d5371c5596a8d0d0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-edf4585b043c1ab5d5371c5596a8d0d0_b.jpg"/><figcaption>单子的左右单位元定律</figcaption></figure><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-2e7725f5f7632285ee065d73db038711_b.jpg" data-size="normal" data-rawwidth="687" data-rawheight="486" class="origin_image zh-lightbox-thumb" width="687" data-original="https://pic2.zhimg.com/v2-2e7725f5f7632285ee065d73db038711_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-2e7725f5f7632285ee065d73db038711_b.jpg" data-size="normal" data-rawwidth="687" data-rawheight="486" class="origin_image zh-lightbox-thumb lazy" width="687" data-original="https://pic2.zhimg.com/v2-2e7725f5f7632285ee065d73db038711_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-2e7725f5f7632285ee065d73db038711_b.jpg"/><figcaption>单子的结合律定律</figcaption></figure><p>在Haskell中，单子就是一个类型构造子 M，这个类型构造子接受一个类型参数 a，构造出一个更复杂的类型 M a。同时这个类型构造子具有如下两个函数，也是两个自然变换：</p><p>其中一个自然变换eta: Id -&gt; M，也记为eta: a -&gt; M a，可以将类型 a 的值提升为更复杂的类型 M a 的值。</p><p>另一个自然变换 mu: M ◦ M  -&gt; M，也记为mu: M (M a) -&gt; M a，当我们两次应用类型构造子 M 时，会得到两层的更复杂的类型 M (M a)。自然变换 mu 可以将这个两层的更复杂的类型 M (M a) 的值，拍扁为稍简单的只有一层的类型 M a 的值。</p><p>自然变换eta 和自然变换mu满足单位半群也即单子的左右单位元定律和结合律定律。</p><p>单子的左右单位元定律</p><div class="highlight"><pre><code class="language-text">               mu . eta ◦ id ≃ id
               mu . id ◦ eta ≃ id</code></pre></div><p>单子的结合律定律</p><div class="highlight"><pre><code class="language-text">            mu . mu ◦ id ≃ mu . id ◦ mu</code></pre></div><p>在数学的范畴论中，用符号 <img src="https://www.zhihu.com/equation?tex=%5Ceta" alt="\eta" eeimg="1"/> 来表示 eta, 用符号 <img src="https://www.zhihu.com/equation?tex=%5Cmu" alt="\mu" eeimg="1"/> 来表示 mu。而eta ◦ id 表示为 <img src="https://www.zhihu.com/equation?tex=%5Ceta+M" alt="\eta M" eeimg="1"/>，id ◦ eta则表示为 <img src="https://www.zhihu.com/equation?tex=M+%5Ceta" alt="M \eta" eeimg="1"/>，相应的mu ◦ id 表示为 <img src="https://www.zhihu.com/equation?tex=%5Cmu+M" alt="\mu M" eeimg="1"/>，id ◦ mu 则表示为 <img src="https://www.zhihu.com/equation?tex=M+%5Cmu" alt="M \mu" eeimg="1"/>。于是我们有常见的范畴论描述的单子的左右单位元定律：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmu+%5Ccdot+%5Ceta+M+%5Csimeq+%5Cmu+%5Ccdot+M+%5Ceta" alt="\mu \cdot \eta M \simeq \mu \cdot M \eta" eeimg="1"/> </p><p>和结合律定律：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmu+%5Ccdot+%5Cmu+M+%5Csimeq+%5Cmu+%5Ccdot+M+%5Cmu" alt="\mu \cdot \mu M \simeq \mu \cdot M \mu" eeimg="1"/> </p><p>于是，我们就得到了数学上的精确描述的Haskell单子 M。在单子 M 构造的自函子范畴中，存在一个单位半群，使得无论我们应用这个单子 M 在类型 a 上多少次（0次或多次），我们都可以将其看成是只应用了一次单子 M 在类型 a 上。我想这就是为何叫 M 是单子的原因吧。自然变换 eta 和 mu 满足的单位元定律和结合律则保证了单子 M 的自相似性。</p><p>在Haskell中，有如下的monad类型类来表示单子。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">class</span> <span class="kt">Monad</span> <span class="nf">m</span> <span class="kr">where</span>
    <span class="nf">return</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">m</span> <span class="nf">a</span>
    <span class="nf">join</span> <span class="ow">::</span> <span class="nf">m</span> <span class="p">(</span><span class="nf">m</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">m</span> <span class="nf">a</span>

<span class="o">--^</span> <span class="nf">return和join需要由程序员来保证满足如下的单子定律</span>
<span class="c1">--   join . return      = id               --^ 左单位元定律</span>
<span class="c1">--   join . fmap return = id               --^ 右单位元定律</span>
<span class="c1">--   join . join  =  join . fmap join      --^ 结合律</span></code></pre></div><p>一个简单的单子的例子是Maybe，这是一个很常用的类型构造子，Maybe a表示要么什么都没有，要么正好有类型 a 的一个值。在C++中是Optional模板类，在Rust中是Option。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Maybe</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Nothing</span>
             <span class="o">|</span> <span class="kt">Just</span> <span class="nf">a</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="nf">return</span> <span class="ow">=</span> <span class="kt">Just</span>
    <span class="nf">join</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
    <span class="nf">join</span> <span class="p">(</span><span class="kt">Just</span> <span class="nf">maybe</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">maybe</span></code></pre></div><p>可以很容易证明上面的Maybe单子满足单子的单位元定律和结合律。</p><p>另一个常用的单子是列表，也就是Haskell中的类型构造子 [ ]，[a] 表示要么没有元素，要么有一个元素，要么有二个元素，要么有三个元素，· · · 。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">[]</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">[]</span>
          <span class="o">|</span> <span class="nf">a</span> <span class="kt">:</span> <span class="kt">[]</span> <span class="nf">a</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="nf">return</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">:</span> <span class="kt">[]</span><span class="p">)</span>
    <span class="nf">join</span>   <span class="ow">=</span> <span class="nf">concat</span></code></pre></div><p>同样可以证明列表单子 [ ] 满足单子的单位元定律和结合律。</p><p><b>结语</b></p><p>这篇文章主要给大家讲了单子为什么是一个单位半群，这个单位半群的基底也即自函子的幺半范畴是怎么样的。特别是讲明白了为什么单子这个单位半群的单位元是一个自然变换eta: I -&gt; M，这是很多人理解单子的一个大的障碍。</p><p>最后，我们再总结一下：</p><p><b>单子就是一个自函子 M 加上单位半群的两个自然变换 eta 和 mu，这两个自然变换满足单子的左右单位元定律和结合律。</b></p><p>限于篇幅，很多地方讲的不够详细，有兴趣的可以看下面的参考链接。</p><p><b>参考链接：</b></p><a href="https://link.zhihu.com/?target=https%3A//bartoszmilewski.com/2018/05/16/free-monoidal-functors-categorically/" data-draft-node="block" data-draft-type="link-card" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">bartoszmilewski.com/201</span><span class="invisible">8/05/16/free-monoidal-functors-categorically/</span><span class="ellipsis"></span></a><a href="https://link.zhihu.com/?target=https%3A//bartoszmilewski.com/%3Fs%3Denriched%2Bcategory" data-draft-node="block" data-draft-type="link-card" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">bartoszmilewski.com/?</span><span class="invisible">s=enriched+category</span><span class="ellipsis"></span></a><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
