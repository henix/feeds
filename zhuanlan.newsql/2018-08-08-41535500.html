<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TiDB 源码阅读（十五） Sort Merge Join</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/41535500">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-e445e0a331d683cab8f11fda36478022_r.jpg" alt=""></div><p>作者： <a class="member_mention" href="http://www.zhihu.com/people/5202d0b6a9c623e0674ff36891c8ab52" data-hash="5202d0b6a9c623e0674ff36891c8ab52" data-hovercard="p$b$5202d0b6a9c623e0674ff36891c8ab52">@姚维</a> </p><h2><b>什么是 Sort Merge Join</b></h2><p>在开始阅读源码之前, 我们来看看什么是 Sort Merge Join (SMJ)，定义可以看 <a href="https://en.wikipedia.org/wiki/Sort-merge_join">wikipedia</a>。简单说来就是将 Join 的两个表，首先根据连接属性进行排序，然后进行一次扫描归并, 进而就可以得出最后的结果。这个算法最大的消耗在于对内外表数据进行排序，而当连接列为索引列时，我们可以利用索引的有序性避免排序带来的消耗, 所以通常在查询优化器中，连接列为索引列的情况下可以考虑选择使用 SMJ。</p><h2><b>TiDB Sort Merge Join 实现</b></h2><p><b>执行过程</b></p><p>TiDB 的实现代码在 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/merge_join.go">tidb/executor/merge_join.go</a> 中 <code class="inline">MergeJoinExec.NextChunk</code> 是这个算子的入口。下面以 <code class="inline">SELECT * FROM A JOIN B ON A.a = B.a</code> 为例，对 SMJ 执行过程进行简述，假设此时外表为 A，内表为 B，join-keys 为 a，A，B 表的 a 列上都有索引：</p><p>1.顺序读取外表 A 直到 join-keys 中出现另外的值，把相同 keys 的行放入数组 a1，同样的规则读取内表 B，把相同 keys 的行放入数组 a2。如果外表数据或者内表数据读取结束，退出。</p><p>2. 从 a1 中读取当前第一行数据，设为 v1。从 a2 中读取当前第一行数据，设为 v2。</p><p>3. 根据 join-keys 比较 v1，v2，结果分为几种情况：</p><ul><ul><li>cmpResult &gt; 0, 表示 v1 大于 v2，把当前 a2 的数据丢弃，从内表读取下一批数据，读取方法同 1。重复 2。</li><li>cmpResult &lt; 0, 表示 v1 小于 v2，说明外表的 v1 没有内表的值与之相同，把外表数据输出给 resultGenerator（不同的连接类型会有不同的结果输出，例如外连接会把不匹配的外表数据输出）。</li><li>cmpResult == 0, 表示 v1 等于 v2。那么遍历 a1 里面的数据，跟 a2 的数据，输出给 resultGenerator 作一次连接。</li></ul></ul><p>4. 回到步骤 1。</p><p>下面的图展示了 SMJ 的过程：</p><p><br></p><img src="https://pic1.zhimg.com/v2-b72f20067fcc79e607e567fbc8711bad_r.jpg" data-caption="" data-size="normal" data-rawwidth="941" data-rawheight="942" data-watermark="watermark" data-original-src="v2-b72f20067fcc79e607e567fbc8711bad" data-watermark-src="v2-08f69ef7725298bf5d409e0fc691037f" data-private-watermark-src=""><p><br></p><p><b>读取内表 / 外表数据</b></p><p>我们分别通过 <code class="inline">fetchNextInnerRows</code> 或者 <code class="inline">fetchNextOuterRows</code> 读取内表和外表的数据。这两个函数实现的功能类似，这里只详述函数 <code class="inline">fetchNextInnerRows</code> 的实现。</p><p><code class="inline">MergeSortExec</code> 算子读取数据，是通过迭代器 <code class="inline">readerIterator</code> 完成，<code class="inline">readerIterator</code> 可以顺序读取数据。<code class="inline">MergeSortExec</code> 算子维护两个 readerIterator：<code class="inline">outerIter</code> 和 <code class="inline">innerIter</code>，它们在 <code class="inline">buildMergeJoin</code> 函数中被构造。</p><p>真正读取数据的操作是在 <code class="inline">readerIterator.nextSelectedRow</code> 中完成, 这里会通过 <code class="inline">ri.reader.NextChunk</code> 每次读取一个 Chunk 的数据，关于 Chunk 的相关内容，可以查看我们之前的文章 <a href="https://pingcap.com/blog-cn/tidb-source-code-reading-10/">TiDB 源码阅读系列文章（十）Chunk 和执行框架简介</a> 。</p><p>这里值得注意的是，我们通过 <code class="inline">expression.VectorizedFilter</code> 对外表数据进行过滤，返回一个 curSelected 布尔数组，用于外表的每一行数据是否是满足 filter 过滤条件。以 <code class="inline">select * from t1 left outer join t2 on t1.a=100;</code> 为例, 这里的 filter 是 <code class="inline">t1.a=100</code>, 对于没有通过这个过滤条件的行，我们通过 <code class="inline">ri.joinResultGenerator.emitToChunk</code> 函数发送给 resultGenerator, 这个 resultGenerator 是一个 interface，具体是否输出这行数据，会由 join 的类型决定，比如外连接则会输出，内连接则会忽略。具体关于 resultGenerator, 可以参考之前的文章：<a href="https://pingcap.com/blog-cn/tidb-source-code-reading-9/">TiDB 源码阅读系列文章（九）Hash Join</a></p><p><code class="inline">rowsWithSameKey</code> 通过 <code class="inline">nextSelectedRow</code> 不断读取下一行数据，并通过对每行数据的 join-keys 进行判断是不是属于同一个 join-keys，如果是，会把相同 join-keys 的行分别放入到 <code class="inline">innerChunkRows</code> 和 <code class="inline">outerIter4Row</code> 数组中。然后对其分别建立迭代器 innerIter4Row 和 outerIter4Row。在 SMJ 中的执行过程中，会利用这两个迭代器来获取数据进行真正的比较得出 join result。</p><p><br></p><p><b>Merge-Join</b></p><p>实现 Merge-Join 逻辑的代码在函数 <code class="inline">MergeJoinExec.joinToChunk</code>, 对内外表迭代器的当前数据根据各自的 join-keys 作对比，有如下几个结果：</p><ul><li>cmpResult &gt; 0，代表外表当前数据大于内表数据，那么通过 <code class="inline">fetchNextInnerRows</code> 直接读取下一个内表数据，然后重新比较即可。</li><li>cmpResult &lt; 0，代表外表当前数据小于内表数据，这个时候就分几种情况了，如果是外连接，那么需要输出外表数据 + NULL，如果是内连接，那么这个外表数据就被忽略，对于这个不同逻辑的处理，统一由 <code class="inline">e.resultGenerator</code> 来控制，我们只需要把外表数据通过 <code class="inline">e.resultGenerator.emitToChunk</code> 调用它即可。然后通过 <code class="inline">fetchNextOuterRows</code> 读取下一个外表数据，重新比较。</li><li>cmpResult == 0，代表外表当前数据等于内表当前数据，这个时候就把外表数据跟内表当前数据做一次连接，通过 <code class="inline">e.resultGenerator.emitToChunk</code> 生成结果。之后外表跟内表分别获取下一个数据，重新开始比较。</li></ul><p>重复上面的过程，直到外表或者内表数据被遍历完，退出 Merge-Join 的过程。</p><p><br></p><p><b>更多</b></p><p>我们上面的分析代码基于 <a href="https://github.com/pingcap/tidb/tree/source-code">Source-code</a> 分支，可能大家已经发现了一些问题，比如我们会一次性读取内外表的 Join group（相同的 key）。这里如果相同的 key 比较多，是有内存 OOM 的风险的。针对这个问题，我们在最新的 master 分支做了几个事情来优化：</p><ol><li>外表其实不需要把相同的 keys 一次性都读取上来， 它只需要按次迭代外表数据，再跟内表逐一对比作连接即可。这里至少可以减少外表发生 OOM 的问题，可以大大减少 OOM 的概率。</li><li>对于内表，我们对 OOM 也不是没有办法，我们用 <code class="inline">memory.Tracker</code> 这个内存追踪器来记录当前内表已经使用的中间结果的内存大小，如果它超过我们设置的阈值，我们会采取输出日志或者终止 SQL 继续运行的方法来规避 OOM 的发生。关于 <code class="inline">memory.Tracker</code> 我们不在此展开，可以留意我们后续的源码分析文章。</li></ol><p>后续我们还会在 Merge-Join 方面做一些优化， 比如我们可以做多路归并，中间结果存外存等等，敬请期待。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
