<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>TiDB 的后花园</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Thu, 23 May 2019 05:11:32 +0800</lastBuildDate>
<item>
<title>TiKV 成功晋级 CNCF 孵化项目</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-05-22-66600821.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66600821&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bbfdd6ba9aeff9ad58299478524f0608_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;今天，CNCF（Cloud Native Computing Foundation，云原生计算基金会）技术监督委员会（TOC）宣布已经投票决议通过，正式将  TiKV 从沙箱项目晋级至孵化项目。&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;TiKV 是一个开源的分布式事务 Key-Value 数据库，支持跨行 ACID 事务，同时实现了自动水平伸缩、数据强一致性、跨数据中心高可用和云原生等重要特性，最初由 PingCAP 团队在 2016 年作为 TiDB 的底层存储引擎设计并开发，于 2018 年 8 月被 CNCF 宣布接纳为 CNCF 沙箱云原生项目。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d7112596433c749a70b627712caaec9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-d7112596433c749a70b627712caaec9d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d7112596433c749a70b627712caaec9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-d7112596433c749a70b627712caaec9d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-d7112596433c749a70b627712caaec9d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;对于 TiKV 的此次晋级，CNCF 首席技术及运营官 Chris Aniszczyk 表示：“社区需要更多支持一致性和可伸缩性的云原生存储选项，TiKV 填补了这个空缺，而不依赖于任何分布式文件系统。自从加入 CNCF 以来，我们看到该项目在中国和国外都取得了令人瞩目的增长。随着它进入孵化阶段，我们很高兴看到该项目持续增长，期待新的贡献者继续添加更多新功能。”&lt;/p&gt;&lt;p&gt;TiKV 最初的设计便采用云原生架构，并很好地融入了现有的 CNCF 生态系统：使用 Prometheus 进行集群监控，使用 gRPC 进行通信，可以部署在 Kubernetes 上，采用 Operator 简化安装、升级和维护。&lt;/p&gt;&lt;p&gt;作为一个基础组件，TiKV 可作为构建其它系统的基石。除了作为分布式 HTAP 数据库 TiDB 的存储引擎，还有更多的存储系统构建于 TiKV 之上，包括三个 Redis-on-TiKV 项目：Tidis、Titan 以及 Titea ，和一个 Prometheus-metrics-in-TiKV 项目：TiPrometheus。TiKV 的生态影响力正在持续扩大。&lt;/p&gt;&lt;p&gt;2018 年 12 月， TiKV 发布了 2.1 GA 版本。目前，TiKV 汇集了来自三星、摩拜、知乎、饿了么、腾讯云、一点资讯，以及 UCloud 的贡献。并已被银行、金融科技、保险、拼车、游戏等多个行业的领先企业应用在实际生产环境中，比如小米、北京银行、知乎、Shopee、BookMyShow 等。&lt;/p&gt;&lt;p&gt;&lt;b&gt;TiKV 的主要特点&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;跨数据中心高可用&lt;/b&gt;&lt;br/&gt;使用 Raft 和 PD（Placement Driver）来支持跨数据中心高可用。&lt;/li&gt;&lt;li&gt;&lt;b&gt;水平扩展&lt;/b&gt;&lt;br/&gt;通过 PD 和精心设计的 Raft 协议，TiKV 在水平扩展性方面的表现出色，可以轻松扩展到 200+TB 的数据。&lt;/li&gt;&lt;li&gt;&lt;b&gt;一致的分布式事务&lt;/b&gt;&lt;br/&gt;与 Google Spanner 类似，TiKV 支持外部一致的分布式事务。&lt;/li&gt;&lt;li&gt;&lt;b&gt;协处理器（Coprocessor）支持&lt;/b&gt;&lt;br/&gt;与 HBase 类似，TiKV 实现了支持分布式计算的协处理器框架，用于支持计算下推操作。&lt;/li&gt;&lt;li&gt;&lt;b&gt;与 TiDB 无缝衔接&lt;/b&gt;&lt;br/&gt;TiKV 和 TiDB 强强联合，构建了一个具有高水平可伸缩性、支持一致性事务、具备传统关系型数据库和 NoSQL 最佳特性的、优雅的数据库解决方案。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;TiKV 大事记&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;247 contributors&lt;/li&gt;&lt;li&gt;5,120 GitHub stars&lt;/li&gt;&lt;li&gt;54 releases&lt;/li&gt;&lt;li&gt;3,654 commits&lt;/li&gt;&lt;li&gt;743 forks&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;CNCF 的其他孵化项目还包括：gRPC, rkt, CNI, Jaeger, Notary, TUF, Vitess, NATS, Linkerd, Helm, Rook, Harbor, etcd, Open Policy Agent 和 CRI-O。晋级为 CNCF 孵化项目之后，TiKV 将与其他项目一道，成为与其技术利益一致的、中立的基金会的一部分，享有 Linux 基金会为其提供的治理、市场和社区推广等权益。&lt;/p&gt;&lt;p&gt;每个 CNCF 项目都有一个相关的成熟度级别：沙箱、孵化或毕业阶段。有关每个级别的技术资格的更多信息，请参阅 CNCF 毕业标准  v1.1 版本。&lt;/p&gt;&lt;p&gt;TiKV 项目信息:&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-7171758dc75db70e5d19d005d27e7ae2_ipico.jpg&quot; data-image-width=&quot;284&quot; data-image-height=&quot;284&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;tikv/tikv&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-05-22-66600821</guid>
<pubDate>Wed, 22 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Tedis：基于 TiKV 构建的 NoSQL 数据库</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-05-21-66525803.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66525803&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b07eb3ad8f25813a803f1f9db4b66082_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;作者介绍&lt;/b&gt;&lt;br/&gt;&lt;b&gt;陈东明&lt;/b&gt;，饿了么北京技术中心架构组负责人，负责饿了么的产品线架构设计以及饿了么基础架构研发工作。曾任百度架构师，负责百度即时通讯产品的架构设计。具有丰富的大规模系统构 建和基础架构的研发经验，善于复杂业务需求下的大并发、分布式系统设计和持续优化。个人微信公众号 dongming_cdm。&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;Tedis&lt;/b&gt; （&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/eleme/tedis&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/eleme/tedis&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;）&lt;b&gt;是基于开源 TiKV 的兼容 Redis 协议的强一致性的 NoSQL 数据库开源项目。&lt;/b&gt;本文介绍一下 Tedis 开源项目的架构设计和特性，以及架构背后的一些思考（包括为何选择 TiKV 和 Redis 协议）。&lt;/p&gt;&lt;p&gt;先来讨论为什么基于 TiKV 构建我们自己的 NoSQL 数据库。&lt;/p&gt;&lt;p&gt;首先简述一下 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tikv&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiKV&lt;/a&gt;&lt;/u&gt;[1]，TiKV 是 TiDB 的一个子项目，TiDB 是一个分布式的关系型数据库 [2]，TiKV 是 TiDB 的存储层。TiKV 本身是可独立于 TiDB 的单独项目。它是一个强一致、可水平扩展的、高可用的分布式 Key-Value 存储系统。&lt;/p&gt;&lt;p&gt;&lt;b&gt;选择 TiKV 的第一个原因是 TiKV 是一个强一致的系统。&lt;/b&gt;在我的另外一篇文章中（发表在 InfoQ, 参看 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/rhzs0KI2G%2AY2r9PMdeNv&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;infoq.cn/article/rhzs0K&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;I2G*Y2r9PMdeNv&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;），我阐述了一个观点：NoSQL 数据库应该具有一致性，并且通过多副本技术达到实际的高可用，也就是说 NoSQL 数据库应该是一个“实际上的 CA” （effectively CA）系统。但是在这篇文章中我并没有明确说明 NoSQL 该具有的一致性是哪种一致性。&lt;b&gt;实际上，我所说的一致性其实就是一种强一致性&lt;/b&gt; [3]，&lt;b&gt;或者更准确的说是线性一致性&lt;/b&gt; [4]。TiKV 正是具有这种线性一致性。TiKV 中的每个数据都会保存 3 个副本，在只有一个副本的节点宕机或者出现网络分区的情况下，另外 2 个副本仍然能够对外提供服务。理论上来讲，同时出现 2 个以上副本同时坏掉的可能性很小，也就是理论上可以达到非常高的可用性。通过 TiKV 滚动升级等运维辅助，如果在实际的生产中，有良好的运维，可以达到实际上非常高的可用性。也就是称为一个“实际上的 CA”（effectively CA）系统。&lt;/p&gt;&lt;p&gt;TiKV 通过 Raft [5] 协议实现了线性一致性和高可用 2 个特性。Raft 是一种分布式共识协议，通过 Raft 协议，数据可以被认为是原子的写入到 3 个副本上。共识协议的一个特点就是要写入大多数，才会认为写入成功，3 个副本的大多数就是 2 个，也就是在只有一个副本宕机或者网络分区的情况下，仍然可以成功写入，并且提供读服务。&lt;/p&gt;&lt;p&gt;&lt;b&gt;选择 TiKV 的第二个原因是 TiKV 的架构可扩展和生态。&lt;/b&gt;在 TiDB 中 TiKV 是独立的一层，形成了一个很好的可扩展架构，实际上可以在 TiKV 上扩展出很多不同的数据库出来。TiDB 层本身就是这种架构上的一个扩展。这种架构类似于 Google 公司的第一代的 Spanner 系统 [6]，Spanner 系统本身也是一个强一致性的、高可用的分布式 Key-Value 系统。在 Spanner 的基础之上，Google 构建了 F1 系统 [7]，实现了 SQL 协议。2017 年，Google 升级了 Spanner 到第二代 [8]，让 Spanner 本身就具有了 SQL 能力。虽然一代 Spanner+F1 是这样的架构，但它仍然是一种非常优秀的架构。我们的 Tedis 项目，也是构建在这一可扩展架构上的一个项目，依托于 TiKV 提供的底层能力，向上构建了不同于 SQL 协议的 Redis 协议。&lt;b&gt;我相信 TiKV 的这种可扩展架构，未来可以成为一种生态，还可以在上面“⻓出”其他的类型的数据库，比如说 Mango 协议、图协议。这些数据库都具有与底层 TiKV 相同的线性一致性和高可用性，区别只在于对外的接口协议不同。&lt;/b&gt;目前这种生态已初⻅端倪，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/distributedio/titan&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Titan&lt;/a&gt; 这个开源项目，与我们的 Tedis 项目非常类似，他们的开源步伐先于我们，目前做的也非常不错。我相信，我们肯定不是这个生态中的最后一个。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-17b7f1ebb11c6dacef4841f983df5cc4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;650&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;864&quot; data-original=&quot;https://pic1.zhimg.com/v2-17b7f1ebb11c6dacef4841f983df5cc4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-17b7f1ebb11c6dacef4841f983df5cc4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;650&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;864&quot; data-original=&quot;https://pic1.zhimg.com/v2-17b7f1ebb11c6dacef4841f983df5cc4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-17b7f1ebb11c6dacef4841f983df5cc4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总之基于 TiKV，Tedis 实现了以下的技术特性：&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 大数据量，可以存储至少数十 TB 级别的数据。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 高性能，在满足高 QPS 的同时，保证比较低的延时。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 高可靠，数据被可靠的持久化存储，少量机器的损坏不会导致数据的丢失。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4. 高可用，作为在线服务的底层依赖存储，要有非常完善的高可用性能力，外卖服务不同于电子商务，对实时性要求非常高，对系统的可用性的要求则是更高的。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;5. 易运维，可以在不停服的基础上进行数据迁移和集群扩容。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;接下来，我们讨论第二个问题，为什么选择 Redis 协议。&lt;/p&gt;&lt;p&gt;SQL 语言与其背后的关系模型，从 1970s 发明以来，一直在应用开发领域占据这统治地位，虽然在 CAP 定理的推动下 [4]，在 NoSQL 运动中，出现很多 NoSQL 系统，就如我前面阐述的一样，一致性不应该是 NoSQL 出现的理由，去 SQL 和关系模型才是 NoSQL 出现的动力。但我并不认为 NoSQL 会代替 SQL。虽然 NoSQL 出现的时候，原本表达的意思是&lt;b&gt;“NO SQL&lt;/b&gt;（没有 SQL）&lt;b&gt;”&lt;/b&gt;，但是我觉得另外一种对 NoSQL 的解释更合适，也就是&lt;b&gt;“N&lt;/b&gt;ot &lt;b&gt;O&lt;/b&gt;nly &lt;b&gt;SQL&lt;/b&gt;（不仅仅有 SQL）&lt;b&gt;”&lt;/b&gt;。NoSQL 不是 SQL 的替代品，应该是 SQL 的有力补充。在 NoSQL 运动中，涌现出来的非常优秀的 NoSQL 系统大多都有自己的独有的接口协议，比如 Redis、MongoDB、Cassandra、图数据库等等。他们都有各自非常适用的使用场景，比如 MongoDB 贴近面向对象，图数据库适合节点的图关系运算。而 Redis 贴近开发者数据结构思维，相信每个开发者都是从数组、hash 表、队列这样的数据结构中成⻓起来的。&lt;/p&gt;&lt;p&gt;另外，Redis 本身是一个非常优秀的产品，它的普及程度非常高，特别是在互联网行业。在每个互联网公司，Redis 都已经成为工程师开发工具箱中，必备的工具之一。Redis 已经是开发者除 SQL 之外，第二熟悉的产品了。&lt;/p&gt;&lt;p&gt;但是，选择 Redis 协议，也给我带来一些实际的困扰，我们有些使用者最初接触 Tedis 时，总是拿我们和 Redis 相比。但是，虽然我们采用的是 Redis 接口，但是 &lt;b&gt;Tedis 本身并不对标 Redis 这个产品。Redis 是非常优秀的缓存。虽然 Redis 也可以开启持久化功能，由于 Redis 本身架构设计，开启持久化的 Redis 仍然不能达到“实际上的 CA”（effectively CA），和 100% 的持久性（durability）。这是 Redis 和 Tedis 的一个很大的区别，Tedis 是一个数据库，不是一个缓存。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;讨论完上面的 2 个架构思考，我们来看一下 Tedis 的架构设计。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c1b41d4a5c931a65a14c6004f275a235_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;941&quot; data-rawheight=&quot;581&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;941&quot; data-original=&quot;https://pic2.zhimg.com/v2-c1b41d4a5c931a65a14c6004f275a235_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c1b41d4a5c931a65a14c6004f275a235_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;941&quot; data-rawheight=&quot;581&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;941&quot; data-original=&quot;https://pic2.zhimg.com/v2-c1b41d4a5c931a65a14c6004f275a235_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c1b41d4a5c931a65a14c6004f275a235_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在 Tedis 中，我们封装了一个 TiKV 的 SDK，对 Redis 的协议进行了解析，并且将 Redis 协议转成对 TiKV 的调用。&lt;/p&gt;&lt;p&gt;目前 Tedis 仍然有很多要完善的地方，但是我们会尽快完善如下的事项，在我们的开源日程表中:&lt;/p&gt;&lt;p&gt;1. Redis 命令的补全&lt;/p&gt;&lt;p&gt;2. 压缩和限流等一些扩展功能&lt;/p&gt;&lt;p&gt;3. Cassandra 协议的支持&lt;/p&gt;&lt;h2&gt;&lt;b&gt;写在最后&lt;/b&gt; &lt;/h2&gt;&lt;p&gt;作为存储系统，不应该让使用者在一致性、可用性这些技术特性上做过多的选择，使用者应该更多的考虑哪种接口更适合自己的应用场景，自己更熟练使用哪种接口，能用哪种接口更快的进行功能开发。&lt;/p&gt;&lt;p&gt;由于篇幅所限，本文中关于强一致性、线性一致性、Redis、Raft、Spanner 的很多技术细节的阐述未能详尽，拟另行成文讨论。&lt;/p&gt;&lt;p&gt;参考资料：&lt;/p&gt;&lt;p&gt;1. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tikv&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/pingcap/tikv&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/TiDB&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/pingcap/TiDB&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;3. Eventually Consistent - Revisited，Werner Vogels, 2008， &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.allthingsdistributed.com/2008/12/event&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;allthingsdistributed.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/2008/12/event&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt; ually_consistent .html&lt;/p&gt;&lt;p&gt;4. Linearizability: A Correctness Condition for Concurrent Objects，Maurice P. Herlihy and Jeannette M. Wing，1990&lt;/p&gt;&lt;p&gt;5. In Search of an Understandable Consensus Algorithm, Diego Ongaro and John Ousterhout, 2014&lt;/p&gt;&lt;p&gt;6. Spanner: Google’s Globally-Distributed Database, James C. Corbett, Jeffrey Dean et al., 2012&lt;/p&gt;&lt;p&gt;7. F1: A Distributed SQL Database That Scales, Jeff Shute et al., 2013 8.Spanner: Becoming a SQL System, David F. Bacon et al., 2017&lt;/p&gt;&lt;p&gt;&lt;b&gt;Tedis 项目&lt;/b&gt;：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/eleme/tedis&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-ab251cb43154626043bebc0fb470f9b6_ipico.jpg&quot; data-image-width=&quot;400&quot; data-image-height=&quot;400&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;eleme/tedis&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-05-21-66525803</guid>
<pubDate>Tue, 21 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>TiKV 源码解析系列文章（七）gRPC Server 的初始化和启动流程</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-05-16-66007323.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66007323&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6141529219ad29fa36dc4db5d8bb2624_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：屈鹏&lt;/p&gt;&lt;p&gt;本篇 TiKV 源码解析将为大家介绍 TiKV 的另一周边组件—— &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/grpc-rs/pulls&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;grpc-rs&lt;/a&gt;。grpc-rs 是 PingCAP 实现的一个 gRPC 的 Rust 绑定，其 Server/Client 端的代码框架都基于 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.rs/futures/0.1.26/futures/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Future&lt;/a&gt;，事件驱动的 EventLoop 被隐藏在了库的内部，所以非常易于使用。本文将以一个简单的 gRPC 服务作为例子，展示 grpc-rs 会生成的服务端代码框架和需要服务的实现者填写的内容，然后会深入介绍服务器在启动时如何将后台的事件循环与这个框架挂钩，并在后台线程中运行实现者的代码。&lt;/p&gt;&lt;h2&gt;基本的代码生成及服务端 API&lt;/h2&gt;&lt;p&gt;gRPC 使用 protobuf 定义一个服务，之后调用相关的代码生成工具就可以生成服务端、客户端的代码框架了，这个过程可以参考我们的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/grpc-rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;官方文档&lt;/a&gt;。客户端可以直接调用这些生成的代码，向服务端发送请求并接收响应，而服务端则需要服务的实现者自己来定制对请求的处理逻辑，生成响应并发回给客户端。举一个例子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#[derive(Clone)]
struct MyHelloService {}
impl Hello for MyHelloService {
    // trait 中的函数签名由 grpc-rs 生成，内部实现需要用户自己填写
    fn hello(&amp;amp;mut self, ctx: RpcContext, req: HelloRequest, sink: UnarySink&amp;lt;HelloResponse&amp;gt;) {
        let mut resp = HelloResponse::new();
        resp.set_to(req.get_from());
        ctx.spawn(
            sink.success(resp)
                .map(|_| println!(&amp;#34;send hello response back success&amp;#34;))
                .map_err(|e| println!(&amp;#34;send hello response back fail: {}&amp;#34;, e))
        );
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们定义了一个名为 &lt;code&gt;Hello&lt;/code&gt; 的服务，里面只有一个名为 &lt;code&gt;hello&lt;/code&gt; 的 RPC。grpc-rs 会为服务生成一个 trait，里面的方法就是这个服务包含的所有 RPC。在这个例子中唯一的 RPC 中，我们从 &lt;code&gt;HelloRequest&lt;/code&gt; 中拿到客户端的名字，然后再将这个名字放到 &lt;code&gt;HelloResponse&lt;/code&gt; 中发回去，非常简单，只是展示一下函数签名中各个参数的用法。&lt;/p&gt;&lt;p&gt;然后，我们需要考虑的是如何把这个服务运行起来，监听一个端口，真正能够响应客户端的请求呢？下面的代码片段展示了如何运行这个服务：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;fn main() {
    // 创建一个 Environment，里面包含一个 Completion Queue
    let env = Arc::new(EnvBuilder::new().cq_count(4).build());
    let channel_args = ChannelBuilder::new(env.clone()).build_args();
    let my_service = MyHelloWorldService::new();
    let mut server = ServerBuilder::new(env.clone())
        // 使用 MyHelloWorldService 作为服务端的实现，注册到 gRPC server 中
        .register_service(create_hello(my_service))
        .bind(&amp;#34;0.0.0.0&amp;#34;, 44444)
        .channel_args(channel_args)
        .build()
        .unwrap();
    server.start();
    thread::park();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上代码展示了 grpc-rs 的足够简洁的 API 接口，各行代码的意义如其注释所示。&lt;/p&gt;&lt;h2&gt;Server 的创建和启动&lt;/h2&gt;&lt;p&gt;下面我们来看一下这个 gRPC server 是如何接收客户端的请求，并路由到我们实现的服务端代码中进行后续的处理的。&lt;/p&gt;&lt;p&gt;第一步我们初始化一个 Environment，并设置 Completion Queue（完成队列）的个数为 4 个。完成队列是 gRPC 的一个核心概念，grpc-rs 为每一个完成队列创建一个线程，并在线程中运行一个事件循环，类似于 Linux 网络编程中不断地调用 &lt;code&gt;epoll_wait&lt;/code&gt; 来获取事件，进行处理：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// event loop
fn poll_queue(cq: Arc&amp;lt;CompletionQueueHandle&amp;gt;) {
    let id = thread::current().id();
    let cq = CompletionQueue::new(cq, id);
    loop {
        let e = cq.next();
        match e.event_type {
            EventType::QueueShutdown =&amp;gt; break,
            EventType::QueueTimeout =&amp;gt; continue,
            EventType::OpComplete =&amp;gt; {}
        }
        let tag: Box&amp;lt;CallTag&amp;gt; = unsafe { Box::from_raw(e.tag as _) };
        tag.resolve(&amp;amp;cq, e.success != 0);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;事件被封装在 Tag 中。我们暂时忽略对事件的具体处理逻辑，目前我们只需要知道，当这个 Environment 被创建好之后，这些后台线程便开始运行了。那么剩下的任务就是监听一个端口，将网络上的事件路由到这几个事件循环中。这个过程在 Server 的 &lt;code&gt;start&lt;/code&gt; 方法中：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;/// Start the server.
pub fn start(&amp;amp;mut self) {
    unsafe {
        grpc_sys::grpc_server_start(self.core.server);
        for cq in self.env.completion_queues() {
            let registry = self
                .handlers
                .iter()
                .map(|(k, v)| (k.to_owned(), v.box_clone()))
                .collect();
            let rc = RequestCallContext {
                server: self.core.clone(),
                registry: Arc::new(UnsafeCell::new(registry)),
            };
            for _ in 0..self.core.slots_per_cq {
                request_call(rc.clone(), cq);
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先调用 &lt;code&gt;grpc_server_start&lt;/code&gt; 来启动这个 Server，然后对每一个完成队列，复制一份 handler 字典。这个字典的 key 是一个字符串，而 value 是一个函数指针，指向对这个类型的请求的处理函数——其实就是前面所述的服务的具体实现逻辑。key 的构造方式其实就是 &lt;code&gt;/&amp;lt;ServiceName&amp;gt;/&amp;lt;RpcName&amp;gt;&lt;/code&gt;，实际上就是 HTTP/2 中头部字段中的 path 的值。我们知道 gRPC 是基于 HTTP/2 的，关于 gRPC 的请求、响应是如何装进 HTTP/2 的帧中的，更多的细节可以参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;官方文档&lt;/a&gt;，这里就不赘述了。&lt;/p&gt;&lt;p&gt;接着我们创建一个 &lt;code&gt;RequestCallContext&lt;/code&gt;，然后对每个完成队列调用几次 &lt;code&gt;request_call&lt;/code&gt;。这个函数会往完成队列中注册若干个 Call，相当于用 &lt;code&gt;epoll_ctl&lt;/code&gt; 往一个 &lt;code&gt;epoll fd&lt;/code&gt; 中注册一些事件的关注。Call 是 gRPC 在进行远程过程调用时的基本单元，每一个 RPC 在建立的时候都会从完成队列里取出一个 Call 对象，后者会在这个 RPC 结束时被回收。因此，在 &lt;code&gt;start&lt;/code&gt;函数中每一个完成队列上注册的 Call 个数决定了这个完成队列上可以并发地处理多少个 RPC，在 grpc-rs 中默认的值是 1024 个。&lt;/p&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;以上代码基本都在 grpc-rs 仓库中的 &lt;code&gt;src/server.rs&lt;/code&gt; 文件中。在 &lt;code&gt;start&lt;/code&gt; 函数返回之后，服务端的初始化及启动过程便结束了。现在，可以快速地用几句话回顾一下：首先创建一个 Environment，内部会为每一个完成队列启动一个线程；接着创建 Server 对象，绑定端口，并将一个或多个服务注册到这个 Server 上；最后调用 Server 的 &lt;code&gt;start&lt;/code&gt; 方法，将服务的具体实现关联到若干个 Call 上，并塞进所有的完成队列中。在这之后，网络上新来的 RPC 请求便可以在后台的事件循环中被取出，并根据具体实现的字典分别执行了。最后，不要忘记 &lt;code&gt;start&lt;/code&gt; 是一个非阻塞的方法，调用它的主线程在之后可以继续执行别的逻辑或者挂起。&lt;/p&gt;&lt;p&gt;本篇源码解析就到这里，下篇关于 grpc-rs 的文章我们会进一步介绍一个 Call 或者 RPC 的生命周期，以及每一阶段在 Server 端的完成队列中对应哪一种事件、会被如何处理，这一部分是 grpc-rs 的核心代码，敬请期待！&lt;/p&gt;&lt;p&gt;&lt;b&gt;原文阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tikv-source-code-reading-7/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiKV 源码解析系列文章（七）gRPC Server 的初始化和启动流程&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-05-16-66007323</guid>
<pubDate>Thu, 16 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Golang Failpoint 的设计与实现</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-05-16-64340817.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64340817&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bafeeae88945a35b3a137c3013b39afc_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：龙恒&lt;/p&gt;&lt;p&gt;对于一个大型复杂的系统来说，通常包含多个模块或多个组件构成，模拟各个子系统的故障是测试中必不可少的环节，并且这些故障模拟必须做到无侵入地集成到自动化测试系统中，通过在自动化测试中自动激活这些故障点来模拟故障，并观测最终结果是否符合预期结果来判断系统的正确性和稳定性。如果在一个分布式系统中需要专门请一位同事来插拔网线来模拟网络异常，一个存储系统中需要通过破坏硬盘来模拟磁盘损坏，昂贵的测试成本会让测试成为一场灾难，并且难以模拟一些需要精细化控制的的测试。所以我们需要一些自动化的方式来进行确定性的故障测试。&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/failpoint&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Failpoint 项目&lt;/a&gt;&lt;/b&gt; &lt;b&gt;就是为此而生，它是 FreeBSD&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.freebsd.org/cgi/man.cgi%3Fquery%3Dfail&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;failpoints&lt;/a&gt;&lt;/b&gt; &lt;b&gt;的 Golang 实现，允许在代码中注入错误或异常行为， 并由环境变量或代码动态激活来触发这些异常行为。Failpoint 能用于各种复杂系统中模拟错误处理来提高系统的容错性、正确性和稳定性，比如：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;微服务中某个服务出现随机延迟、某个服务不可用。&lt;/li&gt;&lt;li&gt;存储系统磁盘 I/O 延迟增加、I/O 吞吐量过低、落盘时间长。&lt;/li&gt;&lt;li&gt;调度系统中出现热点，某个调度指令失败。&lt;/li&gt;&lt;li&gt;充值系统中模拟第三方重复请求充值成功回调接口。&lt;/li&gt;&lt;li&gt;游戏开发中模拟玩家网络不稳定、掉帧、延迟过大等，以及各种异常输入（外挂请求）情况下系统是否正确工作。&lt;/li&gt;&lt;li&gt;……&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;为什么要重复造轮子？&lt;/h2&gt;&lt;p&gt;etcd 团队在 2016 年开发了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/etcd-io/gofail/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;gofail&lt;/a&gt; 极大地简化了错误注入，为 Golang 生态做出了巨大贡献。我们在 2018 年已经引入了 gofail 进行错误注入测试，但是我们在使用中发现了一些功能性以及便利性的问题，所以我们决定造一个更好的「轮子」。&lt;/p&gt;&lt;h3&gt;如何使用 gofail&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;使用注释在程序中注入一个 failpoint：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// gofail: var FailIfImportedChunk int
// if merger, ok := scp.merger.(*ChunkCheckpointMerger); ok &amp;amp;&amp;amp; merger.Checksum.SumKVS() &amp;gt;= uint64(FailIfImportedChunk) {
// rc.checkpointsWg.Done()
// rc.checkpointsWg.Wait()
// panic(&amp;#34;forcing failure due to FailIfImportedChunk&amp;#34;)
// }
// goto RETURN1
    
// gofail: RETURN1:
    
// gofail: var FailIfStatusBecomes int
// if merger, ok := scp.merger.(*StatusCheckpointMerger); ok &amp;amp;&amp;amp; merger.EngineID &amp;gt;= 0 &amp;amp;&amp;amp; int(merger.Status) == FailIfStatusBecomes {
// rc.checkpointsWg.Done()
// rc.checkpointsWg.Wait()
// panic(&amp;#34;forcing failure due to FailIfStatusBecomes&amp;#34;)
// }
// goto RETURN2
    
// gofail: RETURN2:&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;gofail enable&lt;/code&gt; 命令将注释转换为代码：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;if vFailIfImportedChunk, __fpErr := __fp_FailIfImportedChunk.Acquire(); __fpErr == nil { defer __fp_FailIfImportedChunk.Release(); FailIfImportedChunk, __fpTypeOK := vFailIfImportedChunk.(int); if !__fpTypeOK { goto __badTypeFailIfImportedChunk} 
    if merger, ok := scp.merger.(*ChunkCheckpointMerger); ok &amp;amp;&amp;amp; merger.Checksum.SumKVS() &amp;gt;= uint64(FailIfImportedChunk) {
        rc.checkpointsWg.Done()
        rc.checkpointsWg.Wait()
        panic(&amp;#34;forcing failure due to FailIfImportedChunk&amp;#34;)
    }
    goto RETURN1; __badTypeFailIfImportedChunk: __fp_FailIfImportedChunk.BadType(vFailIfImportedChunk, &amp;#34;int&amp;#34;); };
    
/* gofail-label */ RETURN1:
    
if vFailIfStatusBecomes, __fpErr := __fp_FailIfStatusBecomes.Acquire(); __fpErr == nil { defer __fp_FailIfStatusBecomes.Release(); FailIfStatusBecomes, __fpTypeOK := vFailIfStatusBecomes.(int); if !__fpTypeOK { goto __badTypeFailIfStatusBecomes} 
    if merger, ok := scp.merger.(*StatusCheckpointMerger); ok &amp;amp;&amp;amp; merger.EngineID &amp;gt;= 0 &amp;amp;&amp;amp; int(merger.Status) == FailIfStatusBecomes {
        rc.checkpointsWg.Done()
        rc.checkpointsWg.Wait()
        panic(&amp;#34;forcing failure due to FailIfStatusBecomes&amp;#34;)
    }
    goto RETURN2; __badTypeFailIfStatusBecomes: __fp_FailIfStatusBecomes.BadType(vFailIfStatusBecomes, &amp;#34;int&amp;#34;); };
    
/* gofail-label */ RETURN2:&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;gofail 使用中遇到的问题&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;使用注释的方式在代码中注入 failpoint，代码容易出错，并且没有编译器检测。&lt;/li&gt;&lt;li&gt;只能全局生效，大型项目为了缩短自动化测试的时间会引入并行测试，不同并行任务之间会存在干扰。&lt;/li&gt;&lt;li&gt;需要写一些 hack 代码来避免一些不必要的错误日志，比如如上代码，必须要写 &lt;code&gt;// goto RETURN2&lt;/code&gt; 和 &lt;code&gt;// gofail: RETURN2:&lt;/code&gt;，并且中间必须添加一个空行，至于原因可以看 generated code 逻辑。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;我们要设计一个什么样子的 failpoint？&lt;/h2&gt;&lt;h3&gt;理想的 failpoint 实现应该是什么样子？&lt;/h3&gt;&lt;p&gt;理想中的 failpoint 应该是使用代码定义并且对业务逻辑无侵入，如果在一个支持宏的语言中 (比如 Rust)，我们可以定义一个 &lt;code&gt;fail_point&lt;/code&gt; 宏来定义 failpoint：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;fail_point!(&amp;#34;transport_on_send_store&amp;#34;, |sid| if let Some(sid) = sid {
    let sid: u64 = sid.parse().unwrap();
    if sid == store_id {
        self.raft_client.wl().addrs.remove(&amp;amp;store_id);
    }
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是我们遇到了一些问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Golang 并不支持 macro 语言特性。&lt;/li&gt;&lt;li&gt;Golang 不支持编译器插件。&lt;/li&gt;&lt;li&gt;Golang tags 也不能提供一个比较优雅的实现 (&lt;code&gt;go build --tag=&amp;#34;enable-failpoint-a&amp;#34;&lt;/code&gt;)。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Failpoint 设计准则&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;使用 Golang 代码定义 failpoint，而不是注释或其他形式。&lt;/li&gt;&lt;li&gt;Failpoint 代码不应该有任何额外开销：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;不能影响正常功能逻辑，不能对功能代码有任何侵入。&lt;/li&gt;&lt;li&gt;注入 failpoint 代码之后不能导致性能回退。&lt;/li&gt;&lt;li&gt;Failpoint 代码最终不能出现在最终发行的二进制文件中。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;Failpoint 代码必须是易读、易写并且能引入编译器检测。&lt;/li&gt;&lt;li&gt;最终生成的代码必须具有可读性。&lt;/li&gt;&lt;li&gt;生成代码中，功能逻辑代码的行号不能发生变化（便于调试）。&lt;/li&gt;&lt;li&gt;支持并行测试，可以通过 &lt;code&gt;context.Context&lt;/code&gt; 控制一个某个具体的 failpoint 是否激活。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Golang 如何实现一个类似 failpoint 宏？&lt;/h3&gt;&lt;p&gt;宏的本质是什么？如果追本溯源，发现其实可以通过 AST 重写在 Golang 中实现满足以上条件的 failpoint，原理如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e5020c7090df7d820cbe00563fddd42d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2260&quot; data-rawheight=&quot;1478&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2260&quot; data-original=&quot;https://pic2.zhimg.com/v2-e5020c7090df7d820cbe00563fddd42d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e5020c7090df7d820cbe00563fddd42d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2260&quot; data-rawheight=&quot;1478&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2260&quot; data-original=&quot;https://pic2.zhimg.com/v2-e5020c7090df7d820cbe00563fddd42d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e5020c7090df7d820cbe00563fddd42d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;对于任何一个 Golang 代码的源文件，可以通过解析出这个文件的语法树，遍历整个语法树，找出所有 failpoint 注入点，然后对语法树重写，转换成想要的逻辑。&lt;/p&gt;&lt;h2&gt;相关概念&lt;/h2&gt;&lt;h3&gt;Failpoint&lt;/h3&gt;&lt;p&gt;Failpoint 是一个代码片段，并且仅在对应的 failpoint name 激活的情况下才会执行，如果通过 &lt;code&gt;failpoint.Disable(&amp;#34;failpoint-name-for-demo&amp;#34;)&lt;/code&gt; 禁用后，那么对应的的 failpoint 永远不会触发。所有 failpoint 代码片段不会编译到最终的二进制文件中，比如我们模拟文件系统权限控制：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func saveTo(path string) error {
    failpoint.Inject(&amp;#34;mock-permission-deny&amp;#34;, func() error {
         // It&amp;#39;s OK to access outer scope variable
         return fmt.Errorf(&amp;#34;mock permission deny: %s&amp;#34;, path)
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Marker 函数&lt;/h3&gt;&lt;p&gt;AST 重写阶段标记需要被重写的部分，主要有以下功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;提示 Rewriter 重写为一个相等的 IF 语句。&lt;/li&gt;&lt;ul&gt;&lt;li&gt;标记函数的参数是重写过程中需要用到的参数。&lt;/li&gt;&lt;li&gt;标记函数是一个空函数，编译过程会被 inline，进一步被消除。&lt;/li&gt;&lt;li&gt;标记函数中注入的 failpoint 是一个闭包，如果闭包访问外部作用域变量，闭包语法允许捕获外部作用域变量，则不会出现编译错误，同时转换后的的代码是一个 IF 语句，IF 语句访问外部作用域变量不会产生任何问题，所以闭包捕获只是为了语法合法，最终不会有任何额外开销。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;简单、易读、易写。&lt;/li&gt;&lt;li&gt;引入编译器检测，如果 Marker 函数的参数不正确，程序不能通过编译的，进而保证转换后的代码正确性。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;目前支持的 Marker 函数列表：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;func Inject(fpname string&lt;/code&gt;, &lt;code&gt;fpblock func(val Value)) {}&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;func InjectContext(fpname string&lt;/code&gt;, &lt;code&gt;ctx context.Context&lt;/code&gt;, &lt;code&gt;fpblock func(val Value)) {}&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;func Break(label ...string) {}&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;func Goto(label string) {}&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;func Continue(label ...string) {}&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;func Return(results ...interface{}) {}&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;func Fallthrough() {}&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;func Return(results ...interface{}) {}&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;func Label(label string) {}&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;如何在你的程序中使用 failpoint 进行注入？&lt;/h2&gt;&lt;p&gt;&lt;b&gt;最简单的方式是使用&lt;/b&gt; &lt;b&gt;&lt;code&gt;failpoint.Inject&lt;/code&gt;&lt;/b&gt; &lt;b&gt;在调用的地方注入一个 failpoint，最终&lt;/b&gt; &lt;b&gt;&lt;code&gt;failpoint.Inject&lt;/code&gt;&lt;/b&gt; &lt;b&gt;调用会重写为一个 IF 语句，其中&lt;/b&gt; &lt;b&gt;&lt;code&gt;mock-io-error&lt;/code&gt;&lt;/b&gt; &lt;b&gt;用来判断是否触发，&lt;code&gt;failpoint-closure&lt;/code&gt;&lt;/b&gt; &lt;b&gt;中的逻辑会在触发后执行。&lt;/b&gt; 比如我们在一个读取文件的函数中注入一个 I/O 错误：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;failpoint.Inject(&amp;#34;mock-io-error&amp;#34;, func(val failpoint.Value) error {
    return fmt.Errorf(&amp;#34;mock error: %v&amp;#34;, val.(string))
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最终转换后的代码如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;if ok, val := failpoint.Eval(_curpkg_(&amp;#34;mock-io-error&amp;#34;)); ok {
    return fmt.Errorf(&amp;#34;mock error: %v&amp;#34;, val.(string))
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过 &lt;code&gt;failpoint.Enable(&amp;#34;mock-io-error&amp;#34;, &amp;#34;return(&amp;#34;disk error&amp;#34;)&amp;#34;)&lt;/code&gt; 激活程序中的 failpoint，如果需要给 &lt;code&gt;failpoint.Value&lt;/code&gt; 赋一个自定义的值，则需要传入一个 failpoint expression，比如这里 &lt;code&gt;return(&amp;#34;disk error&amp;#34;)&lt;/code&gt;，更多语法可以参考 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.freebsd.org/cgi/man.cgi%3Fquery%3Dfail&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;failpoint 语法&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;闭包可以为&lt;/b&gt; &lt;b&gt;&lt;code&gt;nil&lt;/code&gt;，比如&lt;/b&gt; &lt;b&gt;&lt;code&gt;failpoint.Enable(&amp;#34;mock-delay&amp;#34;, &amp;#34;sleep(1000)&amp;#34;)&lt;/code&gt;，目的是在注入点休眠一秒，不需要执行额外的逻辑。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;failpoint.Inject(&amp;#34;mock-delay&amp;#34;, nil)
failpoint.Inject(&amp;#34;mock-delay&amp;#34;, func(){})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最终会产生以下代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;failpoint.Eval(_curpkg_(&amp;#34;mock-delay&amp;#34;))
failpoint.Eval(_curpkg_(&amp;#34;mock-delay&amp;#34;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;如果我们只想在 failpoint 中执行一个 panic，不需要接收&lt;/b&gt; &lt;b&gt;&lt;code&gt;failpoint.Value&lt;/code&gt;，则我们可以在闭包的参数中忽略这个值。&lt;/b&gt;例如：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;failpoint.Inject(&amp;#34;mock-panic&amp;#34;, func(_ failpoint.Value) error {
    panic(&amp;#34;mock panic&amp;#34;)
})
// OR
failpoint.Inject(&amp;#34;mock-panic&amp;#34;, func() error {
    panic(&amp;#34;mock panic&amp;#34;)
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最佳实践是以下这样：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;failpoint.Enable(&amp;#34;mock-panic&amp;#34;, &amp;#34;panic&amp;#34;)
failpoint.Inject(&amp;#34;mock-panic&amp;#34;, nil)
// GENERATED CODE
failpoint.Eval(_curpkg_(&amp;#34;mock-panic&amp;#34;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;为了可以在并行测试中防止不同的测试任务之间的干扰，可以在&lt;/b&gt; &lt;b&gt;&lt;code&gt;context.Context&lt;/code&gt;&lt;/b&gt; &lt;b&gt;中包含一个回调函数，用于精细化控制 failpoint 的激活与关闭&lt;/b&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;failpoint.InjectContext(ctx, &amp;#34;failpoint-name&amp;#34;, func(val failpoint.Value) {
    fmt.Println(&amp;#34;unit-test&amp;#34;, val)
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;转换后的代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;if ok, val := failpoint.EvalContext(ctx, _curpkg_(&amp;#34;failpoint-name&amp;#34;)); ok {
    fmt.Println(&amp;#34;unit-test&amp;#34;, val)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;使用&lt;/b&gt; &lt;b&gt;&lt;code&gt;failpoint.WithHook&lt;/code&gt;&lt;/b&gt; &lt;b&gt;的示例&lt;/b&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (s *dmlSuite) TestCRUDParallel() {
    sctx := failpoint.WithHook(context.Backgroud(), func(ctx context.Context, fpname string) bool {
        return ctx.Value(fpname) != nil // Determine by ctx key
    })
    insertFailpoints = map[string]struct{} {
        &amp;#34;insert-record-fp&amp;#34;: {},
        &amp;#34;insert-index-fp&amp;#34;: {},
        &amp;#34;on-duplicate-fp&amp;#34;: {},
    }
    ictx := failpoint.WithHook(context.Backgroud(), func(ctx context.Context, fpname string) bool {
        _, found := insertFailpoints[fpname] // Only enables some failpoints.
        return found
    })
    deleteFailpoints = map[string]struct{} {
        &amp;#34;tikv-is-busy-fp&amp;#34;: {},
        &amp;#34;fetch-tso-timeout&amp;#34;: {},
    }
    dctx := failpoint.WithHook(context.Backgroud(), func(ctx context.Context, fpname string) bool {
        _, found := deleteFailpoints[fpname] // Only disables failpoints. 
        return !found
    })
    // other DML parallel test cases.
    s.RunParallel(buildSelectTests(sctx))
    s.RunParallel(buildInsertTests(ictx))
    s.RunParallel(buildDeleteTests(dctx))
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;如果我们在循环中使用 failpoint，可能我们会使用到其他的 Marker 函数&lt;/b&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;failpoint.Label(&amp;#34;outer&amp;#34;)
for i := 0; i &amp;lt; 100; i++ {
    inner:
        for j := 0; j &amp;lt; 1000; j++ {
            switch rand.Intn(j) + i {
            case j / 5:
                failpoint.Break()
            case j / 7:
                failpoint.Continue(&amp;#34;outer&amp;#34;)
            case j / 9:
                failpoint.Fallthrough()
            case j / 10:
                failpoint.Goto(&amp;#34;outer&amp;#34;)
            default:
                failpoint.Inject(&amp;#34;failpoint-name&amp;#34;, func(val failpoint.Value) {
                    fmt.Println(&amp;#34;unit-test&amp;#34;, val.(int))
                    if val == j/11 {
                        failpoint.Break(&amp;#34;inner&amp;#34;)
                    } else {
                        failpoint.Goto(&amp;#34;outer&amp;#34;)
                    }
                })
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上代码最终会重写为如下代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;outer:
    for i := 0; i &amp;lt; 100; i++ {
    inner:
        for j := 0; j &amp;lt; 1000; j++ {
            switch rand.Intn(j) + i {
            case j / 5:
                break
            case j / 7:
                continue outer
            case j / 9:
                fallthrough
            case j / 10:
                goto outer
            default:
                if ok, val := failpoint.Eval(_curpkg_(&amp;#34;failpoint-name&amp;#34;)); ok {
                    fmt.Println(&amp;#34;unit-test&amp;#34;, val.(int))
                    if val == j/11 {
                        break inner
                    } else {
                        goto outer
                    }
                }
            }
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;为什么会有&lt;/b&gt; &lt;b&gt;&lt;code&gt;label&lt;/code&gt;、&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;&lt;/b&gt; &lt;b&gt;和&lt;/b&gt; &lt;b&gt;&lt;code&gt;fallthrough&lt;/code&gt;&lt;/b&gt; &lt;b&gt;相关 Marker 函数? 为什么不直接使用关键字？&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Golang 中如果某个变量或则标签未使用，是不能通过编译的。&lt;br/&gt;&lt;i&gt;Copy&lt;/i&gt;label1: // compiler error: unused label1  failpoint.Inject(&amp;#34;failpoint-name&amp;#34;, func(val failpoint.Value) {         if val.(int) == 1000 {             goto label1 // illegal to use goto here         }         fmt.Println(&amp;#34;unit-test&amp;#34;, val)     })&lt;/li&gt;&lt;li&gt;&lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 只能在循环上下文中使用，在闭包中使用。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;一些复杂的注入示例&lt;/h3&gt;&lt;p&gt;&lt;b&gt;示例一：在 IF 语句的&lt;/b&gt; &lt;b&gt;&lt;code&gt;INITIAL&lt;/code&gt;&lt;/b&gt; &lt;b&gt;和&lt;/b&gt; &lt;b&gt;&lt;code&gt;CONDITIONAL&lt;/code&gt;&lt;/b&gt; &lt;b&gt;中注入 failpoint&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;if a, b := func() {
    failpoint.Inject(&amp;#34;failpoint-name&amp;#34;, func(val failpoint.Value) {
        fmt.Println(&amp;#34;unit-test&amp;#34;, val)
    })
}, func() int { return rand.Intn(200) }(); b &amp;gt; func() int {
    failpoint.Inject(&amp;#34;failpoint-name&amp;#34;, func(val failpoint.Value) int {
        return val.(int)
    })
    return rand.Intn(3000)
}() &amp;amp;&amp;amp; b &amp;lt; func() int {
    failpoint.Inject(&amp;#34;failpoint-name-2&amp;#34;, func(val failpoint.Value) {
        return rand.Intn(val.(int))
    })
    return rand.Intn(6000)
}() {
    a()
    failpoint.Inject(&amp;#34;failpoint-name-3&amp;#34;, func(val failpoint.Value) {
        fmt.Println(&amp;#34;unit-test&amp;#34;, val)
    })
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码最终会被重写为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;if a, b := func() {
    if ok, val := failpoint.Eval(_curpkg_(&amp;#34;failpoint-name&amp;#34;)); ok {
        fmt.Println(&amp;#34;unit-test&amp;#34;, val)
    }
}, func() int { return rand.Intn(200) }(); b &amp;gt; func() int {
    if ok, val := failpoint.Eval(_curpkg_(&amp;#34;failpoint-name&amp;#34;)); ok {
        return val.(int)
    }
    return rand.Intn(3000)
}() &amp;amp;&amp;amp; b &amp;lt; func() int {
    if ok, val := failpoint.Eval(_curpkg_(&amp;#34;failpoint-name-2&amp;#34;)); ok {
        return rand.Intn(val.(int))
    }
    return rand.Intn(6000)
}() {
    a()
    if ok, val := failpoint.Eval(_curpkg_(&amp;#34;failpoint-name-3&amp;#34;)); ok {
        fmt.Println(&amp;#34;unit-test&amp;#34;, val)
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;示例二：在&lt;/b&gt; &lt;b&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/b&gt; &lt;b&gt;语句的 CASE 中注入 failpoint 来动态控制某个 case 是否被阻塞&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (s *StoreService) ExecuteStoreTask() {
    select {
    case &amp;lt;-func() chan *StoreTask {
        failpoint.Inject(&amp;#34;priority-fp&amp;#34;, func(_ failpoint.Value) {
            return make(chan *StoreTask)
        })
        return s.priorityHighCh
    }():
        fmt.Println(&amp;#34;execute high priority task&amp;#34;)

    case &amp;lt;- s.priorityNormalCh:
        fmt.Println(&amp;#34;execute normal priority task&amp;#34;)

    case &amp;lt;- s.priorityLowCh:
        fmt.Println(&amp;#34;execute normal low task&amp;#34;)
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码最终会被重写为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (s *StoreService) ExecuteStoreTask() {
    select {
    case &amp;lt;-func() chan *StoreTask {
        if ok, _ := failpoint.Eval(_curpkg_(&amp;#34;priority-fp&amp;#34;)); ok {
            return make(chan *StoreTask)
        })
        return s.priorityHighCh
    }():
        fmt.Println(&amp;#34;execute high priority task&amp;#34;)

    case &amp;lt;- s.priorityNormalCh:
        fmt.Println(&amp;#34;execute normal priority task&amp;#34;)

    case &amp;lt;- s.priorityLowCh:
        fmt.Println(&amp;#34;execute normal low task&amp;#34;)
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;示例三：动态注入 SWITCH CASE&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;switch opType := operator.Type(); {
case opType == &amp;#34;balance-leader&amp;#34;:
    fmt.Println(&amp;#34;create balance leader steps&amp;#34;)

case opType == &amp;#34;balance-region&amp;#34;:
    fmt.Println(&amp;#34;create balance region steps&amp;#34;)

case opType == &amp;#34;scatter-region&amp;#34;:
    fmt.Println(&amp;#34;create scatter region steps&amp;#34;)

case func() bool {
    failpoint.Inject(&amp;#34;dynamic-op-type&amp;#34;, func(val failpoint.Value) bool {
        return strings.Contains(val.(string), opType)
    })
    return false
}():
    fmt.Println(&amp;#34;do something&amp;#34;)

default:
    panic(&amp;#34;unsupported operator type&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上代码最终会重写为如下代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;switch opType := operator.Type(); {
case opType == &amp;#34;balance-leader&amp;#34;:
    fmt.Println(&amp;#34;create balance leader steps&amp;#34;)

case opType == &amp;#34;balance-region&amp;#34;:
    fmt.Println(&amp;#34;create balance region steps&amp;#34;)

case opType == &amp;#34;scatter-region&amp;#34;:
    fmt.Println(&amp;#34;create scatter region steps&amp;#34;)

case func() bool {
    if ok, val := failpoint.Eval(_curpkg_(&amp;#34;dynamic-op-type&amp;#34;)); ok {
        return strings.Contains(val.(string), opType)
    }
    return false
}():
    fmt.Println(&amp;#34;do something&amp;#34;)

default:
    panic(&amp;#34;unsupported operator type&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除了上面的例子之外，还可以写的更加复杂的情况：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;由 &lt;code&gt;INITIAL&lt;/code&gt; 语句、&lt;code&gt;CONDITIONAL&lt;/code&gt; 表达式，以及 &lt;code&gt;POST&lt;/code&gt; 语句组成的循环&lt;/li&gt;&lt;li&gt;&lt;code&gt;FOR RANGE&lt;/code&gt; 语句&lt;/li&gt;&lt;li&gt;&lt;code&gt;SWITCH INITIAL&lt;/code&gt; 语句&lt;/li&gt;&lt;li&gt;Slice 的构造和索引&lt;/li&gt;&lt;li&gt;结构体动态初始化&lt;/li&gt;&lt;li&gt;……&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;实际上，任何你可以调用函数的地方都可以注入 failpoint，所以请发挥你的想象力。&lt;/p&gt;&lt;h2&gt;Failpoint 命名最佳实践&lt;/h2&gt;&lt;p&gt;上面生成的代码中会自动添加一个 &lt;code&gt;_curpkg_&lt;/code&gt; 调用在 &lt;code&gt;failpoint-name&lt;/code&gt; 上，是因为名字是全局的，为了避免命名冲突，所以会在最终的名字中包含包名，&lt;code&gt;_curpkg_&lt;/code&gt; 相当一个宏，在运行的时候自动使用包名进行展开。你并不需要在自己的应用程序中实现 &lt;code&gt;_curpkg_&lt;/code&gt;，它在执行 &lt;code&gt;failpoint-ctl enable&lt;/code&gt; 命令的时候自动生成以及自动添加，并在执行 &lt;code&gt;failpoint-ctl disable&lt;/code&gt; 命令的时候被删除。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;package ddl // ddl’s parent package is `github.com/pingcap/tidb`

func demo() {
	// _curpkg_(&amp;#34;the-original-failpoint-name&amp;#34;) will be expanded as `github.com/pingcap/tidb/ddl/the-original-failpoint-name`
	if ok, val := failpoint.Eval(_curpkg_(&amp;#34;the-original-failpoint-name&amp;#34;)); ok {...}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为同一个包下面的所有 failpoint 都在同一个命名空间，所以需要小心命名来避免命名冲突，这里有一些推荐的规则来改善这种情况：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;保证名字在包内是唯一的。&lt;/li&gt;&lt;li&gt;使用一个自解释的名字。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以通过环境变量来激活 failpoint：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;GO_FAILPOINTS=&amp;#34;github.com/pingcap/tidb/ddl/renameTableErr=return(100);github.com/pingcap/tidb/planner/core/illegalPushDown=return(true);github.com/pingcap/pd/server/schedulers/balanceLeaderFailed=return(true)&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;致谢&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;感谢 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/etcd-io/gofail&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;gofail&lt;/a&gt; 提供最初实现，给我们提供了灵感，让我们能站在巨人的肩膀上对 failpoint 进行迭代。&lt;/li&gt;&lt;li&gt;感谢 FreeBSD 定义&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.freebsd.org/cgi/man.cgi%3Fquery%3Dfail&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;语法规范&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后，欢迎大家和我们交流讨论，一起完善 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/failpoint&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Failpoint 项目&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;原文阅读：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.pingcap.com/blog-cn/golang-failpoint/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Golang Failpoint 的设计与实现&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-05-16-64340817</guid>
<pubDate>Thu, 16 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>银行交易系统 TiDB 在线缩容迁移</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-05-15-65878590.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65878590&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e5610024df07e75583d513f6a7d6d59d_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：Dan&lt;/p&gt;&lt;p&gt;本文转载自公众号「白噪声OG」。&lt;/p&gt;&lt;p&gt;经历了上礼拜漫长的上线周期，终于有时间总结一下期间发生的故事。TiDB 是一款非常优秀的国产分布式 NewSQL 数据库，因其支持水平扩展性、强一致性、高可用性，从 18 年 3 月起已在国内银行的账务、支付类核心系统得到应用。&lt;/p&gt;&lt;p&gt;临近年中，银行重要系统的建设进入投产冲刺阶段，本次上线又有多个系统对接 TiDB，为了优化集群资源分配，引发了这次分享的主题——&lt;b&gt;线上系统 TiKV 的缩容、region 的迁移&lt;/b&gt;，本文主要针对本次 TiKV 的缩容、迁移过程进行梳理总结。&lt;/p&gt;&lt;p&gt;&lt;b&gt;TiDB 数据库的扩容已在官方文档进行了详细的说明&lt;/b&gt;（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/op-guide/horizontal-scale/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;pingcap.com/docs-cn/op-&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;guide/horizontal-scale/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;）&lt;b&gt;并被各路大咖广泛提及，但缩容迁移并在银行交易系统上的实践却少有分享，这也是本文的目的之一。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;进入主题，先交代下环境，服务器集群采用 NVMe+SSD 的存储方案构建了 16 个 TiKV 实例，作为重要的核心支付类系统，两地三中心五副本不可少，每个 TiKV 上 8K+ 个 region。&lt;b&gt;整个迁移过程历时 5 个小时，过程中没有停止系统对外服务，很是顺滑平稳。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-076f34fdabe840a09b7ac9765cae57e6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;529&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic3.zhimg.com/v2-076f34fdabe840a09b7ac9765cae57e6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-076f34fdabe840a09b7ac9765cae57e6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;529&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic3.zhimg.com/v2-076f34fdabe840a09b7ac9765cae57e6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-076f34fdabe840a09b7ac9765cae57e6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;接下来还是看一下迁移的过程：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;（一）&lt;/b&gt;TiKV 采用 Raft 一致性算法保证副本强一致性，迁移过程本质上是扩容的逆过程，确定下线的 TiKV 打上 label 后，将 region 搬移到最终保留下来的 TiKV 上。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-463994044be8e73c8161a5eb9e6d57a8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;676&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-463994044be8e73c8161a5eb9e6d57a8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-463994044be8e73c8161a5eb9e6d57a8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;676&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-463994044be8e73c8161a5eb9e6d57a8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-463994044be8e73c8161a5eb9e6d57a8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;（二）&lt;/b&gt;接下来聚焦 region 1 的 Raft Group，对其副本进行搬移，实际上所有 region 的数据是一样的，只是在保留的 TiKV 内进行 region 数据的复制，新产生的副本由于数据不完整，作为 Raft Group 中的 learner。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a85bc5542754c7f96751820cc9a59018_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;373&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-a85bc5542754c7f96751820cc9a59018_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a85bc5542754c7f96751820cc9a59018_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;373&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-a85bc5542754c7f96751820cc9a59018_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a85bc5542754c7f96751820cc9a59018_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;（三）&lt;/b&gt;Learner 创建后，PD 会在这样的一个 Raft Group（5 个全副本 region + 2 个 learner）中发起选举：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;选举会增加 label 限制，确保 leader 最终在保留的 TiKV 中产生；&lt;/li&gt;&lt;li&gt;由于 learner 没有投票权，选举实际还是个 5 副本选主，多数派 (N+1)/2 仍为 3。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8434cd530afeadd794ff536310abad65_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;474&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-8434cd530afeadd794ff536310abad65_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8434cd530afeadd794ff536310abad65_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;474&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-8434cd530afeadd794ff536310abad65_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8434cd530afeadd794ff536310abad65_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;（四）&lt;/b&gt;这样新的 leader 选出来了，当两个新副本数据追平后，将删除下线 TiKV 中的 region。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e551cc40b3c2dec6e6be3002913b8a29_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;747&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-e551cc40b3c2dec6e6be3002913b8a29_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e551cc40b3c2dec6e6be3002913b8a29_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;747&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-e551cc40b3c2dec6e6be3002913b8a29_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e551cc40b3c2dec6e6be3002913b8a29_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;（五）&lt;/b&gt;这样一个新的 5 副本 Raft Group 我们就获得了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c0194bd790246f323b7a3062f450a8da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;406&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic3.zhimg.com/v2-c0194bd790246f323b7a3062f450a8da_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c0194bd790246f323b7a3062f450a8da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;406&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic3.zhimg.com/v2-c0194bd790246f323b7a3062f450a8da_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c0194bd790246f323b7a3062f450a8da_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里再说几点：&lt;/p&gt;&lt;p&gt;1. 磁盘 IO 对迁移的效率影响还是很大的，测试环境使用普通的 SAS 盘，在更高并发的条件下，耗时长了很多。&lt;/p&gt;&lt;p&gt;2.（二）、（三）、（四）的过程并非原子化操作，当然 learner 的数据本身也不具备一致性，但对 raft 的改造最终要保证一致性，与 PingCAP 的开发同学确认后，这些会在之后加入。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 我认为最有意思，也最有意义的一点，learner 的引入是本次迁移过程中非常巧妙的设计，解决了数据不一致副本在选举过程中的尴尬地位，而 learner 也是 Multi-Raft 协议中的重要角色，HTAP 引擎 TiFlash&amp;amp;TiSpark 也以此引入列存副本，非常期待&lt;/b&gt; &lt;b&gt;TiDB 3.0。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;PS：本次上线的重头戏 Cloud TiDB 在平稳运行后，希望有机会进行总结分享。TiDB 自上线后实现了多次重要变更操作，均未暂停系统对外服务，从一只开发狗的角度看 TiDB 在金融级 NewSQL 数据库的方向上的确投入了很多。&lt;/p&gt;&lt;p&gt;最后，感谢 PingCAP Gin 同学和研发大神们的支持，感谢运维爸爸们直到凌晨 4 点的奋斗。&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-05-15-65878590</guid>
<pubDate>Wed, 15 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>RustCon Asia 实录 | Distributed Actor System in Rust</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-05-14-65610580.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65610580&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0cf9cf7793a40ec22bc5c53c74bbae26_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;作者介绍：&lt;/b&gt;&lt;br/&gt;&lt;b&gt;Zimon Dai&lt;/b&gt;，阿里云城市大脑 Rust 开发工程师。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-320fadb788cb6ec43c3ae720fbbbd8dc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-320fadb788cb6ec43c3ae720fbbbd8dc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-320fadb788cb6ec43c3ae720fbbbd8dc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-320fadb788cb6ec43c3ae720fbbbd8dc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-320fadb788cb6ec43c3ae720fbbbd8dc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;本文根据 Zimon 在&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247488419%26idx%3D1%26sn%3D4299a08995a036dbec895998f5a4447f%26chksm%3Deb1634c9dc61bddfb153937966ce4da297fd12bb0710b9472441479bc14f8f1d6b7ed40ba7e8%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;首届 RustCon Asia 大会&lt;/a&gt;&lt;/u&gt;上的演讲整理。&lt;/p&gt;&lt;p&gt;大家好，我今天分享的是我们团队在做的 &lt;b&gt;Distributed Actor System&lt;/b&gt;。首先我想说一下这个 Talk 「不是」关于哪些内容的，因为很多人看到这个标题的时候可能会有一些误解。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cdca908c4939a68c26bee5118611c155_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-cdca908c4939a68c26bee5118611c155_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cdca908c4939a68c26bee5118611c155_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-cdca908c4939a68c26bee5118611c155_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-cdca908c4939a68c26bee5118611c155_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第一点，我们不会详细讲一个完整的 Actor System 是怎么实现的，因为 Actor System 有一个很完善的标准，比如说像 Java 的 Akka， Rust 的 Actix 这些都是很成熟的库，在这里讲没有特别大的意义。第二，我们也不会去跟别的流行的 Rust 的 Actor System 做比较和竞争。可能很多人做 Rust 开发的一个原因是 Rust 写的服务器在 Techpower 的 benchmark 上排在很前面，比如微软开发的 Actix，我们觉得 Actix 确实写的很好，而我们也没有必要自己搞一套 Actix。第三，我们不会介绍具体的功能，因为这个库现在并没有开源，但这也是我们今年的计划。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这个 Talk 主要会讲下面几个方向（如图 2），就是我们在做一个 Actor System 或者大家在用 Actor System 类似想法去实现一个东西的时候，会遇到的一些常见的问题。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d0d19a57ffdb9b4efa82fba05e9860f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d0d19a57ffdb9b4efa82fba05e9860f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d0d19a57ffdb9b4efa82fba05e9860f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d0d19a57ffdb9b4efa82fba05e9860f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d0d19a57ffdb9b4efa82fba05e9860f4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先我会讲一讲 Compilation-stable 的 TypeId 和 Proc macros，然后分享一个目前还没有 Stable 的 Rust Feature，叫做 Specialization， 最后我们会介绍怎么做一个基于 Tick 的 Actor System，如果你是做游戏开发或者有前端背景的话会比较了解 Tick 这个概念，比如做游戏的话，有 frame rate，你要做 60 帧，每帧大概就是 16 毫秒，大概这样是一个 Tick；前端的每一个 Interval 有一个固定的时长，比如说 5 毫秒，这就是一个 Tick。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. The TypeId Problem&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c52e8a343ad2d33d80252c4bd5652252_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;518&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-c52e8a343ad2d33d80252c4bd5652252_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c52e8a343ad2d33d80252c4bd5652252_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;518&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-c52e8a343ad2d33d80252c4bd5652252_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c52e8a343ad2d33d80252c4bd5652252_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先讲一下 TypeId。如图 3 ，比如说我们现在已经有了两个Actor，它们可能是在分布式系统里面的不同的节点上，要进行网络传输。这个时候你能想到一个很简单的方式：Actor A 通过机器的 Broker A 发了一个消息，这个消息通过网络请求到达了另一个 Broker B，通过这个 Broker B，把这个 Buffer 变成一个 Message 给了目标 Actor B，这是一个常见的网络通信。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a242e266ea3d45a007ba44a9f0950db1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a242e266ea3d45a007ba44a9f0950db1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a242e266ea3d45a007ba44a9f0950db1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a242e266ea3d45a007ba44a9f0950db1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a242e266ea3d45a007ba44a9f0950db1_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;但是这里面会有一个问题，比如，我们要进行网络通讯的时候，我们实际上是把他编译成了一个没有信息的 Buffer，就是一个 Vec&amp;lt;u8&amp;gt;，Message 本身是有 Type 的（因为Rust 是强类型的语言，Rust 中所有东西都是有类型的）。怎么把这个信息抹掉，然后当到了目标 Actor 的时候，再把这个类型恢复回来？这是我们今天要讲 TypeId 的问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.1 常见的解决办法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有一个很常见的解决方法，就是给每一个 message 的消息头里加上这个 message 的类型描述，大家可以看下图是一段我写的伪代码：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1c13a19577ab49dd0e77a411ffcd70f0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;495&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-1c13a19577ab49dd0e77a411ffcd70f0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1c13a19577ab49dd0e77a411ffcd70f0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;495&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-1c13a19577ab49dd0e77a411ffcd70f0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-1c13a19577ab49dd0e77a411ffcd70f0_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;最重要的就是第一个 field，叫做 type_uid，这个 Message 里 payload 具体是什么类型。如果我们给 Actor System 里每一个消息类型都赋予一个独特的 TypeId，那么就可以根据  TypeId 猜出来这个 Message 的 payload 具体是什么东西。第二个  field 就是 receiver，其实就是一个目标的 address。 第三个是一个 Buffer，是通过 serialization 的 Buffer。&lt;/p&gt;&lt;p&gt;现在我们把这个问题聚焦到一个更小的具体问题上：我们怎么给每个消息类型赋予一个独特的 TypeId？刚好 Rust 有一个东西可以做这个事情—— &lt;b&gt;std::any::Any&lt;/b&gt;（图 6）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2d8a6d926e6f830ffb4c76cf142ff7a1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;468&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-2d8a6d926e6f830ffb4c76cf142ff7a1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2d8a6d926e6f830ffb4c76cf142ff7a1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;468&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-2d8a6d926e6f830ffb4c76cf142ff7a1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2d8a6d926e6f830ffb4c76cf142ff7a1_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Rust 里面所有的类型都实现了 Any 这个 Trait， 它有一个核心方法，叫做 get _type_id，这个方法刚刚在上周 stable。对任何一个类型调用这个方法的话，就能得到一个独特的 TypeId，它里面是一个 64 位的整数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;有了 TypeId 之后，大家可以想一下对 TypeId 会有什么样的要求？下图中我列举了一些最重要的事情&lt;/b&gt;：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-09ea748d3ab3c87905f1a0249e11411d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-09ea748d3ab3c87905f1a0249e11411d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-09ea748d3ab3c87905f1a0249e11411d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-09ea748d3ab3c87905f1a0249e11411d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-09ea748d3ab3c87905f1a0249e11411d_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先，这个 TypeId 要对所有的节点都是一致的。比如你有一个消息类型， TypeId 是 1，但在另一个节点里面 1 这个整数可能表示的是另一个消息类型，如果按照新的消息类型去解码这个消息的话，会出现解码错误。所以我们希望这个 TypeId 是在整个 Network 里面都是稳定的。这就导致我们并不可以使用 std 提供的 TypeId。因为很不幸的是 std 的 TypeId 是跟编译的流程绑定的，在你每次编译时都会生成新的 TypeId，也就是说如果整个网络里部署的软件正好是来自两次不同的 Rust 编译的话，TypeId 就会有 mismatch。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这样就会导致一个问题：即便是更新了一个小小的组件，也可能要重新编译整个网络，这是很夸张的。&lt;/b&gt;所以我们现在是利用 Proc Macro 来获得一个稳定的 TypeId 从而解决这个问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.2 Proc Macro&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实这也是社区里面一个很长久的问题，大概从 2015 年左右就有人开始问，特别是很多做游戏编程的人，因为游戏里 identity 都需要固定的 TypeId。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-35b2e4b80df4ef7b1cb8757c910d0861_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-35b2e4b80df4ef7b1cb8757c910d0861_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-35b2e4b80df4ef7b1cb8757c910d0861_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-35b2e4b80df4ef7b1cb8757c910d0861_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-35b2e4b80df4ef7b1cb8757c910d0861_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这个问题怎么解决呢？很简单，用一个很粗暴的方式：如果我们能够知道每一个消息名字 name，就可以给每一个 name 分一个固定的整数 id，然后把这个组合存到一个文件里，每次编译的时候都去读这个文件，这样就可以保证每次生成的代码里面是固定的写入一个整数，这样 TypeId 就是固定的。&lt;/p&gt;&lt;p&gt;我们怎么做到在编译的时候去读一个文件呢？其实现在几乎是唯一的方法，就是去用 Proc Macro 来做这事。我们看一下这边我们定义了（图 9）一个自己的 TypeId 的类型：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e428644e8f1c9ac284a9630612cc2666_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;474&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-e428644e8f1c9ac284a9630612cc2666_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e428644e8f1c9ac284a9630612cc2666_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;474&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-e428644e8f1c9ac284a9630612cc2666_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e428644e8f1c9ac284a9630612cc2666_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;UniqueTypeId 这个 Trait 只有一个方法，就是获取 Type-uid，相当于 std 的 Any； struct TypeId 内部只有一个 field，一个整数 t， TypeId 就相当于 std 的 TypeId。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5f641831c3a75467df528bf8469cde06_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5f641831c3a75467df528bf8469cde06_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5f641831c3a75467df528bf8469cde06_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5f641831c3a75467df528bf8469cde06_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5f641831c3a75467df528bf8469cde06_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;图 10 上半部分有一个 Message 叫做 StartTaskRequest，这是我们要使用的消息。然后我们在上面写一个 customer derive。图 10 下半部分就是我们真正去实现它的时候写的 Proc Macro，大家可以看到，我们是用的 quote，里面是真正去实现前面我们讲的 UniqueTypeId 的这个 Trait。然后里面这个 type_uid 方法他返回的 TypeId，实际上是固定写死的。这个 t 的值是 #id，#id 可以在 customer derive 写的过程中从文件中固定读出来的一个变量。&lt;/p&gt;&lt;p&gt;通过这种方法，我们就可以固定的生成代码，每次就写好这个 Type，就是这个 integer，很多的 customer derive 可能只是为了简化代码，但是固定 TypeId 是不用 Proc macro 和 Customer derive 绝对做不到的事情。&lt;/p&gt;&lt;p&gt;然后我们只需要在本地指定一个固定的文件，比如 .toml （图 10 右下角），让里面每一个 message 类型都有一个固定的 TypeId，就可以解决这个问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-423ce1d823dec1513fa9e2e6f17ad5a7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-423ce1d823dec1513fa9e2e6f17ad5a7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-423ce1d823dec1513fa9e2e6f17ad5a7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-423ce1d823dec1513fa9e2e6f17ad5a7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-423ce1d823dec1513fa9e2e6f17ad5a7_b.jpg&quot;/&gt;&lt;figcaption&gt;图 11&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;获得固定的 TypeId 之后，就可以用来擦除 Rust 中的类型。可以通过 serde 或者 Proto Buffer 来做。把 TypeId 序列化成一个 Buffer，再把 Buffer 反序列化成一个具体的 Type。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5fbcf190fdd0dbfd059b7ee2b9ebd8cd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;514&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-5fbcf190fdd0dbfd059b7ee2b9ebd8cd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5fbcf190fdd0dbfd059b7ee2b9ebd8cd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;514&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-5fbcf190fdd0dbfd059b7ee2b9ebd8cd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5fbcf190fdd0dbfd059b7ee2b9ebd8cd_b.jpg&quot;/&gt;&lt;figcaption&gt;图 12&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;前面讲了一种方法，根据 Buffer header 的 signature 猜 Type 类型。这个方法整体感觉很像 Java 的 Reflection，就是动态判断一个 Buffer 的具体类型。具体判断可能写这样的代码依次判断这个 message 的 TypeId 是什么（如图 12），比如先判断它是否是 PayloadA 的 TypeId，如果不是的话再判断是否是 PayloadB 的 TypeId……一直往下写，但是你这样也会写很多很多代码，而且需要根据所有的类型去匹配。怎么解决这个问题呢？我们还是要用 Proc Macro 来做这个事情。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1ce467a0ab85751c613a0b299e58c149_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-1ce467a0ab85751c613a0b299e58c149_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1ce467a0ab85751c613a0b299e58c149_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-1ce467a0ab85751c613a0b299e58c149_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-1ce467a0ab85751c613a0b299e58c149_b.jpg&quot;/&gt;&lt;figcaption&gt;图 13&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如图 13，我们在 Actor 里定义一个 message 叫做 handle_message，它内部其实是一个 Macro，这个 Macro 会根据你在写这个 Actor 时注册的所有的消息类型把这些 if else 的判断不停的重复写完。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d411ae4befac5026fef0c98c8518e8d0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d411ae4befac5026fef0c98c8518e8d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d411ae4befac5026fef0c98c8518e8d0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d411ae4befac5026fef0c98c8518e8d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d411ae4befac5026fef0c98c8518e8d0_b.jpg&quot;/&gt;&lt;figcaption&gt;图 14&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;最后我们会得到一个非常简单的 Actor 的架构（如图 14）。我们这里比如说写一个 Sample Actor，首先你需要  customer derive Actor，它会帮你实现 Actor 这个 Trait。接下来要申明接收哪几种消息，#[Message(PayloadA, PayloadB)] 表示 SampleActor 接收的是 PayloadA 和 PayloadB，然后在实现 Actor 这个 Trait 时，customer derive 就会把 if else 类型匹配全部写完全，然后只需要实现一个 Handler 的类把消息处理的方法再写一下。这样下来整个程序架构会非常清晰。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6e81f6df6861a7252647192ea3a11c87_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-6e81f6df6861a7252647192ea3a11c87_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6e81f6df6861a7252647192ea3a11c87_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-6e81f6df6861a7252647192ea3a11c87_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6e81f6df6861a7252647192ea3a11c87_b.jpg&quot;/&gt;&lt;figcaption&gt;图 15&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;总的来说，通过 Proc Macro 我们可以得到一个非常干净的、有 self-explaining 的 Actor Design，同时还可以把 Actor 的声明和具体的消息处理的过程完全分割开，最重要的是我们可以把不安全的 type casting 全部都藏在背后，给用户一个安全的接口。而且这个运行损耗会非常低，因为是在做 integer comparison。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. Specialization&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;第二个议题是介绍一下 Specialization，这是 Rust 的一个还没有进入 Stable 的 Feature，很多人可能还不太了解，它是 Trait 方向上的一个重要的 Feature。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d89e9e5e64532ccbef870fabc7598eec_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d89e9e5e64532ccbef870fabc7598eec_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d89e9e5e64532ccbef870fabc7598eec_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d89e9e5e64532ccbef870fabc7598eec_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d89e9e5e64532ccbef870fabc7598eec_b.jpg&quot;/&gt;&lt;figcaption&gt;图 16&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;图 16 中有一个特殊的问题。如果某个消息是有多种编码模式，比如 Serde 有一个很流行的编码叫 bincode（把一个 struct 编码成一个 Buffer），当然也有很多人也会用 Proto-buffer，那么如果 Message 是来自不同的编码模式，要怎么用同样的一种 API 去解码不同的消息呢？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-558292e774f0251eb1374e0bee15b0a6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-558292e774f0251eb1374e0bee15b0a6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-558292e774f0251eb1374e0bee15b0a6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-558292e774f0251eb1374e0bee15b0a6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-558292e774f0251eb1374e0bee15b0a6_b.jpg&quot;/&gt;&lt;figcaption&gt;图 17&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;这里需要用到一个很新的 RFC#1212 叫做 Specialization，它主要是提供两个功能：第一个是它可以让 Trait 的功能实现互相覆盖，第二个是它允许 Trait 有一个默认的实现。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-034d142fe34f47718cbb9eafc163679e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-034d142fe34f47718cbb9eafc163679e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-034d142fe34f47718cbb9eafc163679e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-034d142fe34f47718cbb9eafc163679e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-034d142fe34f47718cbb9eafc163679e_b.jpg&quot;/&gt;&lt;figcaption&gt;图 18&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;比如说我们先定义了一个 Payload（如图 18），这个 Payload 必须支持 Serde 的 Serialization 和 Deserialization， Payload 的方法也是常规的方法，Serialize 和 Deserialize。最重要的是默认的情况下，如果一个消息只支持 Serde  的编码解码，那我们就调用 bincode。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9db16323b7fdc07d5dc14864bb6d689a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-9db16323b7fdc07d5dc14864bb6d689a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9db16323b7fdc07d5dc14864bb6d689a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-9db16323b7fdc07d5dc14864bb6d689a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9db16323b7fdc07d5dc14864bb6d689a_b.jpg&quot;/&gt;&lt;figcaption&gt;图 19&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这样我们就可以写一个实现（图 19），前面加一个 Default，加了 Default 之后，如果一个 struct 有这几个 Trait 的支持，那他就会调用 Default。如果多了一个 Trait 的话，就会用多出来的 Trait 的那个新方法。这样大家就可以不断的去通过限制更多的范围来支持更多 Codec。&lt;/p&gt;&lt;p&gt;Specialization 这个 feature，现在只有 nightly 上有，然后只需要开一个 #![feature(specialization)] 就可以用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. Tick-based actor system&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ff1059e1a93ac52ab13849d3b5b7345b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-ff1059e1a93ac52ab13849d3b5b7345b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ff1059e1a93ac52ab13849d3b5b7345b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-ff1059e1a93ac52ab13849d3b5b7345b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ff1059e1a93ac52ab13849d3b5b7345b_b.jpg&quot;/&gt;&lt;figcaption&gt;图 20&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;下面来介绍一下 Tick-based actor system，就是我们怎么在一个基于 Tokio 的 actor system 上面实现Tick，大家都知道  Tokio  是异步的架构，但是我们想做成基于 Tick 的。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Tick 有哪些好处呢？首先 Tick 这个概念会用在很多的地方，然后包括比如说游戏设计、Dataflow、Stream computation（流式计算），还有 JavaScript 的 API，也有点 Tick 的 感觉。如果整个逻辑是基于 Tick 的话，会让逻辑和等待机制变得更加简单，同时也可以做 event hook。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-74e9422c2e5be704f335a5e94b0902a3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-74e9422c2e5be704f335a5e94b0902a3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-74e9422c2e5be704f335a5e94b0902a3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-74e9422c2e5be704f335a5e94b0902a3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-74e9422c2e5be704f335a5e94b0902a3_b.jpg&quot;/&gt;&lt;figcaption&gt;图 21&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;具体做法其实很简单。我们可以设计一个新的 struct，比如图 21 中的 WaitForOnce，首先声明一个 deadline，意思是在多少个 Tick 之内我必须得收到一个消息，然后可以提交这个消息的 signature。我们在使用 Tokio  来进行 Network IO 时就可以生成一个 stream，把 stream 每次输出时 Tick 加 1，我们就只需要维护一个 concurrent 的 SkipMap，然后把每一个 Tick 的 waits 全部注册进来。当到达这个 Tick 时，如果该 Tick 所有的 waits 都已经覆盖到了，那你就可以 release 这个 feature，解决掉。&lt;/p&gt;&lt;p&gt;另外，通过 Tick 也可以去做一些 actor system 这个 spec 里面没有的东西。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-41c4e4618b682fd419c6b57694f07358_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-41c4e4618b682fd419c6b57694f07358_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-41c4e4618b682fd419c6b57694f07358_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-41c4e4618b682fd419c6b57694f07358_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-41c4e4618b682fd419c6b57694f07358_b.jpg&quot;/&gt;&lt;figcaption&gt;图 22&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;比如在图 22 中列举的，第一点 actor system 很少会允许等待别的 actor，但是基于 Tick 的架构是可以做的，比如设置 deadline 等于 1，表示在下一个 Tick 执行之前，必须得收到这个消息，实际上就实现了一种 actor 之间互相依赖消息的设置。第二个，我们还可以做 pre-fetch，比如现在要去抓取一些资源做预存，不会立刻用这个资源，这样当我真正使用这些资源的时候他可以很快得到，那么可以设置一个比较“遥远”但是没有那么“遥远”的 deadline，比如设置 1000 个 tick 之后，必须拿到一个什么东西，实际上这个消息的 fetch 会有比较大的时间容错。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 总结&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1b961b639bc037aa2528d0830cbcba70_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-1b961b639bc037aa2528d0830cbcba70_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1b961b639bc037aa2528d0830cbcba70_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-1b961b639bc037aa2528d0830cbcba70_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-1b961b639bc037aa2528d0830cbcba70_b.jpg&quot;/&gt;&lt;figcaption&gt;图 23&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;最后总结一下我们的 Distributed Actor System 的一些特性，首先它是基于 Tick 的，并且可以通过 Specialization 支持多种不同的 codecs，然后我们可以通过 TypeId 实现类似 reflection 的效果。最后我们计划在 2019 年左右的时候开源这个 actor system。其实我们有很多系统和线上的业务都是基于 Rust 的，我们也会逐渐的公开这些东西，希望能够在从今年开始跟社区有更多的互动，有更多的东西可以和大家交流。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;RustCon Asia&lt;/b&gt;&lt;br/&gt;2019 年 4 月 23 日，由秘猿科技和 PingCAP 主办的&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247488419%26idx%3D1%26sn%3D4299a08995a036dbec895998f5a4447f%26chksm%3Deb1634c9dc61bddfb153937966ce4da297fd12bb0710b9472441479bc14f8f1d6b7ed40ba7e8%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;首届 RustCon Asia 在北京圆满落幕&lt;/a&gt;&lt;/u&gt;，300 余位来自中国、美国、加拿大、德国、俄罗斯、印度、澳大利亚等国家和地区的 Rust 爱好者参加了本次大会。作为 Rust 亚洲社区首次「大型网友面基 Party」，本届大会召集了 20 余位海内外顶尖 Rust 开发者讲师，为大家带来一天半节奏紧凑的分享和两天 Workshop 实操辅导，内容包括 Rust 在分布式数据存储、安全领域、搜索引擎、嵌入式 IoT、图像处理等等跨行业、跨领域的应用实践。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;大会 Talk 视频合集：&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/playlist%3Flist%3DPL85XCvVPmGQjPvweRqkBgnh_HKE5MBB8x&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/playlist?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;list=PL85XCvVPmGQjPvweRqkBgnh_HKE5MBB8x&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-05-14-65610580</guid>
<pubDate>Tue, 14 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>RustCon Asia 实录 | Distributed Actor System in Rust</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-05-13-65610580.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65610580&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0cf9cf7793a40ec22bc5c53c74bbae26_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;作者介绍：&lt;/b&gt;&lt;br/&gt;&lt;b&gt;Zimon Dai&lt;/b&gt;，阿里云城市大脑 Rust 开发工程师。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-320fadb788cb6ec43c3ae720fbbbd8dc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-320fadb788cb6ec43c3ae720fbbbd8dc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-320fadb788cb6ec43c3ae720fbbbd8dc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-320fadb788cb6ec43c3ae720fbbbd8dc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-320fadb788cb6ec43c3ae720fbbbd8dc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;本文根据 Zimon 在&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247488419%26idx%3D1%26sn%3D4299a08995a036dbec895998f5a4447f%26chksm%3Deb1634c9dc61bddfb153937966ce4da297fd12bb0710b9472441479bc14f8f1d6b7ed40ba7e8%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;首届 RustCon Asia 大会&lt;/a&gt;&lt;/u&gt;上的演讲整理。&lt;/p&gt;&lt;p&gt;大家好，我今天分享的是我们团队在做的 &lt;b&gt;Distributed Actor System&lt;/b&gt;。首先我想说一下这个 Talk 「不是」关于哪些内容的，因为很多人看到这个标题的时候可能会有一些误解。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cdca908c4939a68c26bee5118611c155_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-cdca908c4939a68c26bee5118611c155_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cdca908c4939a68c26bee5118611c155_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-cdca908c4939a68c26bee5118611c155_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-cdca908c4939a68c26bee5118611c155_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第一点，我们不会详细讲一个完整的 Actor System 是怎么实现的，因为 Actor System 有一个很完善的标准，比如说像 Java 的 Akka， Rust 的 Actix 这些都是很成熟的库，在这里讲没有特别大的意义。第二，我们也不会去跟别的流行的 Rust 的 Actor System 做比较和竞争。可能很多人做 Rust 开发的一个原因是 Rust 写的服务器在 Techpower 的 benchmark 上排在很前面，比如微软开发的 Actix，我们觉得 Actix 确实写的很好，而我们也没有必要自己搞一套 Actix。第三，我们不会介绍具体的功能，因为这个库现在并没有开源，但这也是我们今年的计划。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这个 Talk 主要会讲下面几个方向（如图 2），就是我们在做一个 Actor System 或者大家在用 Actor System 类似想法去实现一个东西的时候，会遇到的一些常见的问题。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d0d19a57ffdb9b4efa82fba05e9860f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d0d19a57ffdb9b4efa82fba05e9860f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d0d19a57ffdb9b4efa82fba05e9860f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d0d19a57ffdb9b4efa82fba05e9860f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d0d19a57ffdb9b4efa82fba05e9860f4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先我会讲一讲 Compilation-stable 的 TypeId 和 Proc macros，然后分享一个目前还没有 Stable 的 Rust Feature，叫做 Specialization， 最后我们会介绍怎么做一个基于 Tick 的 Actor System，如果你是做游戏开发或者有前端背景的话会比较了解 Tick 这个概念，比如做游戏的话，有 frame rate，你要做 60 帧，每帧大概就是 16 毫秒，大概这样是一个 Tick；前端的每一个 Interval 有一个固定的时长，比如说 5 毫秒，这就是一个 Tick。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. The TypeId Problem&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c52e8a343ad2d33d80252c4bd5652252_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;518&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-c52e8a343ad2d33d80252c4bd5652252_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c52e8a343ad2d33d80252c4bd5652252_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;518&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-c52e8a343ad2d33d80252c4bd5652252_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c52e8a343ad2d33d80252c4bd5652252_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先讲一下 TypeId。如图 3 ，比如说我们现在已经有了两个Actor，它们可能是在分布式系统里面的不同的节点上，要进行网络传输。这个时候你能想到一个很简单的方式：Actor A 通过机器的 Broker A 发了一个消息，这个消息通过网络请求到达了另一个 Broker B，通过这个 Broker B，把这个 Buffer 变成一个 Message 给了目标 Actor B，这是一个常见的网络通信。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a242e266ea3d45a007ba44a9f0950db1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a242e266ea3d45a007ba44a9f0950db1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a242e266ea3d45a007ba44a9f0950db1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a242e266ea3d45a007ba44a9f0950db1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a242e266ea3d45a007ba44a9f0950db1_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;但是这里面会有一个问题，比如，我们要进行网络通讯的时候，我们实际上是把他编译成了一个没有信息的 Buffer，就是一个 Vec&amp;lt;u8&amp;gt;，Message 本身是有 Type 的（因为Rust 是强类型的语言，Rust 中所有东西都是有类型的）。怎么把这个信息抹掉，然后当到了目标 Actor 的时候，再把这个类型恢复回来？这是我们今天要讲 TypeId 的问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.1 常见的解决办法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有一个很常见的解决方法，就是给每一个 message 的消息头里加上这个 message 的类型描述，大家可以看下图是一段我写的伪代码：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1c13a19577ab49dd0e77a411ffcd70f0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;495&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-1c13a19577ab49dd0e77a411ffcd70f0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1c13a19577ab49dd0e77a411ffcd70f0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;495&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-1c13a19577ab49dd0e77a411ffcd70f0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-1c13a19577ab49dd0e77a411ffcd70f0_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;最重要的就是第一个 field，叫做 type_uid，这个 Message 里 payload 具体是什么类型。如果我们给 Actor System 里每一个消息类型都赋予一个独特的 TypeId，那么就可以根据  TypeId 猜出来这个 Message 的 payload 具体是什么东西。第二个  field 就是 receiver，其实就是一个目标的 address。 第三个是一个 Buffer，是通过 serialization 的 Buffer。&lt;/p&gt;&lt;p&gt;现在我们把这个问题聚焦到一个更小的具体问题上：我们怎么给每个消息类型赋予一个独特的 TypeId？刚好 Rust 有一个东西可以做这个事情—— &lt;b&gt;std::any::Any&lt;/b&gt;（图 6）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2d8a6d926e6f830ffb4c76cf142ff7a1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;468&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-2d8a6d926e6f830ffb4c76cf142ff7a1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2d8a6d926e6f830ffb4c76cf142ff7a1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;468&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-2d8a6d926e6f830ffb4c76cf142ff7a1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2d8a6d926e6f830ffb4c76cf142ff7a1_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Rust 里面所有的类型都实现了 Any 这个 Trait， 它有一个核心方法，叫做 get _type_id，这个方法刚刚在上周 stable。对任何一个类型调用这个方法的话，就能得到一个独特的 TypeId，它里面是一个 64 位的整数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;有了 TypeId 之后，大家可以想一下对 TypeId 会有什么样的要求？下图中我列举了一些最重要的事情&lt;/b&gt;：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-09ea748d3ab3c87905f1a0249e11411d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-09ea748d3ab3c87905f1a0249e11411d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-09ea748d3ab3c87905f1a0249e11411d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-09ea748d3ab3c87905f1a0249e11411d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-09ea748d3ab3c87905f1a0249e11411d_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先，这个 TypeId 要对所有的节点都是一致的。比如你有一个消息类型， TypeId 是 1，但在另一个节点里面 1 这个整数可能表示的是另一个消息类型，如果按照新的消息类型去解码这个消息的话，会出现解码错误。所以我们希望这个 TypeId 是在整个 Network 里面都是稳定的。这就导致我们并不可以使用 std 提供的 TypeId。因为很不幸的是 std 的 TypeId 是跟编译的流程绑定的，在你每次编译时都会生成新的 TypeId，也就是说如果整个网络里部署的软件正好是来自两次不同的 Rust 编译的话，TypeId 就会有 mismatch。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这样就会导致一个问题：即便是更新了一个小小的组件，也可能要重新编译整个网络，这是很夸张的。&lt;/b&gt;所以我们现在是利用 Proc Macro 来获得一个稳定的 TypeId 从而解决这个问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.2 Proc Macro&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实这也是社区里面一个很长久的问题，大概从 2015 年左右就有人开始问，特别是很多做游戏编程的人，因为游戏里 identity 都需要固定的 TypeId。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-35b2e4b80df4ef7b1cb8757c910d0861_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-35b2e4b80df4ef7b1cb8757c910d0861_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-35b2e4b80df4ef7b1cb8757c910d0861_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-35b2e4b80df4ef7b1cb8757c910d0861_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-35b2e4b80df4ef7b1cb8757c910d0861_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这个问题怎么解决呢？很简单，用一个很粗暴的方式：如果我们能够知道每一个消息名字 name，就可以给每一个 name 分一个固定的整数 id，然后把这个组合存到一个文件里，每次编译的时候都去读这个文件，这样就可以保证每次生成的代码里面是固定的写入一个整数，这样 TypeId 就是固定的。&lt;/p&gt;&lt;p&gt;我们怎么做到在编译的时候去读一个文件呢？其实现在几乎是唯一的方法，就是去用 Proc Macro 来做这事。我们看一下这边我们定义了（图 9）一个自己的 TypeId 的类型：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e428644e8f1c9ac284a9630612cc2666_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;474&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-e428644e8f1c9ac284a9630612cc2666_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e428644e8f1c9ac284a9630612cc2666_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;474&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-e428644e8f1c9ac284a9630612cc2666_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e428644e8f1c9ac284a9630612cc2666_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;UniqueTypeId 这个 Trait 只有一个方法，就是获取 Type-uid，相当于 std 的 Any； struct TypeId 内部只有一个 field，一个整数 t， TypeId 就相当于 std 的 TypeId。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5f641831c3a75467df528bf8469cde06_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5f641831c3a75467df528bf8469cde06_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5f641831c3a75467df528bf8469cde06_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5f641831c3a75467df528bf8469cde06_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5f641831c3a75467df528bf8469cde06_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;图 10 上半部分有一个 Message 叫做 StartTaskRequest，这是我们要使用的消息。然后我们在上面写一个 customer derive。图 10 下半部分就是我们真正去实现它的时候写的 Proc Macro，大家可以看到，我们是用的 quote，里面是真正去实现前面我们讲的 UniqueTypeId 的这个 Trait。然后里面这个 type_uid 方法他返回的 TypeId，实际上是固定写死的。这个 t 的值是 #id，#id 可以在 customer derive 写的过程中从文件中固定读出来的一个变量。&lt;/p&gt;&lt;p&gt;通过这种方法，我们就可以固定的生成代码，每次就写好这个 Type，就是这个 integer，很多的 customer derive 可能只是为了简化代码，但是固定 TypeId 是不用 Proc macro 和 Customer derive 绝对做不到的事情。&lt;/p&gt;&lt;p&gt;然后我们只需要在本地指定一个固定的文件，比如 .toml （图 10 右下角），让里面每一个 message 类型都有一个固定的 TypeId，就可以解决这个问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-423ce1d823dec1513fa9e2e6f17ad5a7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-423ce1d823dec1513fa9e2e6f17ad5a7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-423ce1d823dec1513fa9e2e6f17ad5a7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-423ce1d823dec1513fa9e2e6f17ad5a7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-423ce1d823dec1513fa9e2e6f17ad5a7_b.jpg&quot;/&gt;&lt;figcaption&gt;图 11&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;获得固定的 TypeId 之后，就可以用来擦除 Rust 中的类型。可以通过 serde 或者 Proto Buffer 来做。把 TypeId 序列化成一个 Buffer，再把 Buffer 反序列化成一个具体的 Type。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5fbcf190fdd0dbfd059b7ee2b9ebd8cd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;514&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-5fbcf190fdd0dbfd059b7ee2b9ebd8cd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5fbcf190fdd0dbfd059b7ee2b9ebd8cd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;514&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-5fbcf190fdd0dbfd059b7ee2b9ebd8cd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5fbcf190fdd0dbfd059b7ee2b9ebd8cd_b.jpg&quot;/&gt;&lt;figcaption&gt;图 12&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;前面讲了一种方法，根据 Buffer header 的 signature 猜 Type 类型。这个方法整体感觉很像 Java 的 Reflection，就是动态判断一个 Buffer 的具体类型。具体判断可能写这样的代码依次判断这个 message 的 TypeId 是什么（如图 12），比如先判断它是否是 PayloadA 的 TypeId，如果不是的话再判断是否是 PayloadB 的 TypeId……一直往下写，但是你这样也会写很多很多代码，而且需要根据所有的类型去匹配。怎么解决这个问题呢？我们还是要用 Proc Macro 来做这个事情。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1ce467a0ab85751c613a0b299e58c149_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-1ce467a0ab85751c613a0b299e58c149_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1ce467a0ab85751c613a0b299e58c149_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-1ce467a0ab85751c613a0b299e58c149_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-1ce467a0ab85751c613a0b299e58c149_b.jpg&quot;/&gt;&lt;figcaption&gt;图 13&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如图 13，我们在 Actor 里定义一个 message 叫做 handle_message，它内部其实是一个 Macro，这个 Macro 会根据你在写这个 Actor 时注册的所有的消息类型把这些 if else 的判断不停的重复写完。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d411ae4befac5026fef0c98c8518e8d0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d411ae4befac5026fef0c98c8518e8d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d411ae4befac5026fef0c98c8518e8d0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d411ae4befac5026fef0c98c8518e8d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d411ae4befac5026fef0c98c8518e8d0_b.jpg&quot;/&gt;&lt;figcaption&gt;图 14&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;最后我们会得到一个非常简单的 Actor 的架构（如图 14）。我们这里比如说写一个 Sample Actor，首先你需要  customer derive Actor，它会帮你实现 Actor 这个 Trait。接下来要申明接收哪几种消息，#[Message(PayloadA, PayloadB)] 表示 SampleActor 接收的是 PayloadA 和 PayloadB，然后在实现 Actor 这个 Trait 时，customer derive 就会把 if else 类型匹配全部写完全，然后只需要实现一个 Handler 的类把消息处理的方法再写一下。这样下来整个程序架构会非常清晰。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6e81f6df6861a7252647192ea3a11c87_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-6e81f6df6861a7252647192ea3a11c87_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6e81f6df6861a7252647192ea3a11c87_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-6e81f6df6861a7252647192ea3a11c87_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6e81f6df6861a7252647192ea3a11c87_b.jpg&quot;/&gt;&lt;figcaption&gt;图 15&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;总的来说，通过 Proc Macro 我们可以得到一个非常干净的、有 self-explaining 的 Actor Design，同时还可以把 Actor 的声明和具体的消息处理的过程完全分割开，最重要的是我们可以把不安全的 type casting 全部都藏在背后，给用户一个安全的接口。而且这个运行损耗会非常低，因为是在做 integer comparison。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. Specialization&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;第二个议题是介绍一下 Specialization，这是 Rust 的一个还没有进入 Stable 的 Feature，很多人可能还不太了解，它是 Trait 方向上的一个重要的 Feature。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d89e9e5e64532ccbef870fabc7598eec_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d89e9e5e64532ccbef870fabc7598eec_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d89e9e5e64532ccbef870fabc7598eec_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-d89e9e5e64532ccbef870fabc7598eec_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d89e9e5e64532ccbef870fabc7598eec_b.jpg&quot;/&gt;&lt;figcaption&gt;图 16&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;图 16 中有一个特殊的问题。如果某个消息是有多种编码模式，比如 Serde 有一个很流行的编码叫 bincode（把一个 struct 编码成一个 Buffer），当然也有很多人也会用 Proto-buffer，那么如果 Message 是来自不同的编码模式，要怎么用同样的一种 API 去解码不同的消息呢？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-558292e774f0251eb1374e0bee15b0a6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-558292e774f0251eb1374e0bee15b0a6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-558292e774f0251eb1374e0bee15b0a6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-558292e774f0251eb1374e0bee15b0a6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-558292e774f0251eb1374e0bee15b0a6_b.jpg&quot;/&gt;&lt;figcaption&gt;图 17&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;这里需要用到一个很新的 RFC#1212 叫做 Specialization，它主要是提供两个功能：第一个是它可以让 Trait 的功能实现互相覆盖，第二个是它允许 Trait 有一个默认的实现。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-034d142fe34f47718cbb9eafc163679e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-034d142fe34f47718cbb9eafc163679e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-034d142fe34f47718cbb9eafc163679e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-034d142fe34f47718cbb9eafc163679e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-034d142fe34f47718cbb9eafc163679e_b.jpg&quot;/&gt;&lt;figcaption&gt;图 18&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;比如说我们先定义了一个 Payload（如图 18），这个 Payload 必须支持 Serde 的 Serialization 和 Deserialization， Payload 的方法也是常规的方法，Serialize 和 Deserialize。最重要的是默认的情况下，如果一个消息只支持 Serde  的编码解码，那我们就调用 bincode。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9db16323b7fdc07d5dc14864bb6d689a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-9db16323b7fdc07d5dc14864bb6d689a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9db16323b7fdc07d5dc14864bb6d689a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-9db16323b7fdc07d5dc14864bb6d689a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9db16323b7fdc07d5dc14864bb6d689a_b.jpg&quot;/&gt;&lt;figcaption&gt;图 19&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这样我们就可以写一个实现（图 19），前面加一个 Default，加了 Default 之后，如果一个 struct 有这几个 Trait 的支持，那他就会调用 Default。如果多了一个 Trait 的话，就会用多出来的 Trait 的那个新方法。这样大家就可以不断的去通过限制更多的范围来支持更多 Codec。&lt;/p&gt;&lt;p&gt;Specialization 这个 feature，现在只有 nightly 上有，然后只需要开一个 #![feature(specialization)] 就可以用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. Tick-based actor system&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ff1059e1a93ac52ab13849d3b5b7345b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-ff1059e1a93ac52ab13849d3b5b7345b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ff1059e1a93ac52ab13849d3b5b7345b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-ff1059e1a93ac52ab13849d3b5b7345b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ff1059e1a93ac52ab13849d3b5b7345b_b.jpg&quot;/&gt;&lt;figcaption&gt;图 20&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;下面来介绍一下 Tick-based actor system，就是我们怎么在一个基于 Tokio 的 actor system 上面实现Tick，大家都知道  Tokio  是异步的架构，但是我们想做成基于 Tick 的。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Tick 有哪些好处呢？首先 Tick 这个概念会用在很多的地方，然后包括比如说游戏设计、Dataflow、Stream computation（流式计算），还有 JavaScript 的 API，也有点 Tick 的 感觉。如果整个逻辑是基于 Tick 的话，会让逻辑和等待机制变得更加简单，同时也可以做 event hook。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-74e9422c2e5be704f335a5e94b0902a3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-74e9422c2e5be704f335a5e94b0902a3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-74e9422c2e5be704f335a5e94b0902a3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-74e9422c2e5be704f335a5e94b0902a3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-74e9422c2e5be704f335a5e94b0902a3_b.jpg&quot;/&gt;&lt;figcaption&gt;图 21&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;具体做法其实很简单。我们可以设计一个新的 struct，比如图 21 中的 WaitForOnce，首先声明一个 deadline，意思是在多少个 Tick 之内我必须得收到一个消息，然后可以提交这个消息的 signature。我们在使用 Tokio  来进行 Network IO 时就可以生成一个 stream，把 stream 每次输出时 Tick 加 1，我们就只需要维护一个 concurrent 的 SkipMap，然后把每一个 Tick 的 waits 全部注册进来。当到达这个 Tick 时，如果该 Tick 所有的 waits 都已经覆盖到了，那你就可以 release 这个 feature，解决掉。&lt;/p&gt;&lt;p&gt;另外，通过 Tick 也可以去做一些 actor system 这个 spec 里面没有的东西。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-41c4e4618b682fd419c6b57694f07358_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-41c4e4618b682fd419c6b57694f07358_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-41c4e4618b682fd419c6b57694f07358_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-41c4e4618b682fd419c6b57694f07358_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-41c4e4618b682fd419c6b57694f07358_b.jpg&quot;/&gt;&lt;figcaption&gt;图 22&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;比如在图 22 中列举的，第一点 actor system 很少会允许等待别的 actor，但是基于 Tick 的架构是可以做的，比如设置 deadline 等于 1，表示在下一个 Tick 执行之前，必须得收到这个消息，实际上就实现了一种 actor 之间互相依赖消息的设置。第二个，我们还可以做 pre-fetch，比如现在要去抓取一些资源做预存，不会立刻用这个资源，这样当我真正使用这些资源的时候他可以很快得到，那么可以设置一个比较“遥远”但是没有那么“遥远”的 deadline，比如设置 1000 个 tick 之后，必须拿到一个什么东西，实际上这个消息的 fetch 会有比较大的时间容错。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 总结&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1b961b639bc037aa2528d0830cbcba70_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-1b961b639bc037aa2528d0830cbcba70_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1b961b639bc037aa2528d0830cbcba70_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;527&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-1b961b639bc037aa2528d0830cbcba70_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-1b961b639bc037aa2528d0830cbcba70_b.jpg&quot;/&gt;&lt;figcaption&gt;图 23&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;最后总结一下我们的 Distributed Actor System 的一些特性，首先它是基于 Tick 的，并且可以通过 Specialization 支持多种不同的 codecs，然后我们可以通过 TypeId 实现类似 reflection 的效果。最后我们计划在 2019 年左右的时候开源这个 actor system。其实我们有很多系统和线上的业务都是基于 Rust 的，我们也会逐渐的公开这些东西，希望能够在从今年开始跟社区有更多的互动，有更多的东西可以和大家交流。&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;大会 Talk 视频合集：&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/playlist%3Flist%3DPL85XCvVPmGQjPvweRqkBgnh_HKE5MBB8x&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/playlist?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;list=PL85XCvVPmGQjPvweRqkBgnh_HKE5MBB8x&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-05-13-65610580</guid>
<pubDate>Mon, 13 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>What’s New in TiDB 3.0.0-rc.1</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-05-13-65543904.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65543904&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-213ca7fb3c6f74d37e387aeecfa9721f_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：段兵&lt;/p&gt;&lt;p&gt;2019 年 5 月 10 日，TiDB 3.0.0-rc.1 版本正式推出，该版本对系统稳定性，性能，安全性，易用性等做了较多的改进，接下来逐一介绍。&lt;/p&gt;&lt;h2&gt;提升系统稳定性&lt;/h2&gt;&lt;p&gt;众所周知，数据库的查询计划的稳定性至关重要，此版本采用多种优化手段促进查询计划的稳定性得到进一步提升，如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;新增 Fast Analyze 功能，使 TiDB 收集统计信息的速度有了数量级的提升，对集群资源的消耗和生产业务的影响比普通 Analyze 方式更小。&lt;/li&gt;&lt;li&gt;新增 Incremental Analyze 功能，对于值单调增的索引能够更加方便和快速地更新其统计信息。&lt;/li&gt;&lt;li&gt;在 CM-Sketch 中新增 TopN 的统计信息，缓解因为 CM-Sketch 哈希冲突导致估算偏大的问题，使代价估算更加准确。&lt;/li&gt;&lt;li&gt;优化 Cost Model，利用和 RowID 列之间的相关性更加精准的估算谓词的选择率，使得索引选择更加稳定和准确。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;提升系统性能&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;TableScan,IndexScan,Limit&lt;/code&gt; 算子，进一步提升 SQL 执行性能。&lt;/li&gt;&lt;li&gt;TiKV 采用&lt;code&gt;Iterator Key Bound Option&lt;/code&gt;存储结构减少内存分配及拷贝，RocksDB 的 Column Families 共享 block cache 提升 cache命中率等手段大幅提升性能。&lt;/li&gt;&lt;li&gt;TiDB Lightning encode SQL 性能提升 50%，将数据源内容解析成 TiDB 的 types.Datum，减少 encode 过程中多余的解析工作，使得性能得到较大的提升。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;增强系统安全性&lt;/h2&gt;&lt;p&gt;RBAC（Role-Based Access Control）基于角色的权限访问控制是商业系统中最常见的权限管理技术之一，通过 RBAC 思想可以构建最简单”用户-角色-权限“的访问权限控制模型。RBAC 中用户与角色关联，权限与角色关联，角色与权限之间一般是多对多的关系统，用户通过成为什么样的角色获取该角色所拥有的权限，达到简化权限管理的目的，通过此版本的迭代 RBAC 功能开发完成，欢迎试用。&lt;/p&gt;&lt;h2&gt;提升产品易用性&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;新增 SQL 方式查询慢查询，丰富 TiDB 慢查询日志内容，如：Coprocessor 任务数，平均/最长/90% 执行/等待时间，执行/等待时间最长的 TiKV 地址，简化慢查询定位工作，提升产品易用性。&lt;/li&gt;&lt;li&gt;新增系统配置项合法性检查，优化系统监控项等，提升产品易用性。&lt;/li&gt;&lt;li&gt;支持对 &lt;code&gt;TableReader&lt;/code&gt;、&lt;code&gt;IndexReader&lt;/code&gt; 和 &lt;code&gt;IndexLookupReader&lt;/code&gt; 算子进行内存追踪控制，对 Query 内存使用统计更加精确，可以更好地检测、处理对内存消耗较大的语句。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;社区贡献&lt;/h2&gt;&lt;p&gt;V3.0.0-rc.1 版本的开发过程中，开源社区贡献者给予了我们极大的支持，例如美团的同学负责开发的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/projects/19&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SQL Plan Management&lt;/a&gt; 特性对于提升产品的易用性有很大的帮助，一点资讯的陈付同学与其他同学一起对 TiKV 线程池进行了重构，提高了性能并降低了延迟，掌门科技的聂殿辉 同学实现 TiKV 大量 UDF 函数帮忙 TiKV 完善 Coprocessor 功能，就不再一一列举。在此对各位贡献者表示由衷的感谢。接下来我们会开展更多的专项开发活动以及一系列面向社区的培训课程，希望能对大家了解如何做分布式数据库有帮助。&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-05-13-65543904</guid>
<pubDate>Mon, 13 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>TiDB 3.0.0-rc.1 Release Notes</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-05-13-65541594.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65541594&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ff33e08b8e612a29db91d36dee8a125f_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;2019 年 5 月 10 日，TiDB 发布 3.0.0-rc.1 版本，对应的 TiDB Ansible 版本为 3.0.0-rc.1。相比 3.0.0 Beta.1 版本，该版本对系统稳定性、易用性、功能、优化器、统计信息以及执行引擎做了很多改进。&lt;/p&gt;&lt;h2&gt;TiDB&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;SQL 优化器&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;利用列之间的顺序相关性提升代价估算准确度，并提供启发式参数 &lt;code&gt;tidb_opt_correlation_exp_factor&lt;/code&gt; 用于控制在相关性无法被直接用于估算的场景下对索引扫描的偏好程度。&lt;/li&gt;&lt;li&gt;当过滤条件中包含相关列时，在抽取复合索引的访问条件时尽可能多地匹配索引的前缀列。&lt;/li&gt;&lt;li&gt;用动态规划决定连接的执行顺序，当参与连接的表数量不多于 &lt;code&gt;tidb_opt_join_reorder_threshold&lt;/code&gt;时启用。&lt;/li&gt;&lt;li&gt;在构造 Index Join 的的内表中，以复合索引作为访问条件时，尽可能多地匹配索引的前缀列。&lt;/li&gt;&lt;li&gt;提升对单列索引上值为 NULL 的行数估算准确度。&lt;/li&gt;&lt;li&gt;在逻辑优化阶段消除聚合函数时特殊处理 &lt;code&gt;GROUP_CONCAT&lt;/code&gt; ，防止产生错误的执行结果。&lt;/li&gt;&lt;li&gt;当过滤条件为常量时，正确地将它下推到连接算子的子节点上。&lt;/li&gt;&lt;li&gt;在逻辑优化阶段列剪裁时特殊处理一些函数，例如 &lt;code&gt;RAND()&lt;/code&gt; ，防止产生和 MySQL 不兼容的执行结果。&lt;/li&gt;&lt;li&gt;支持 &lt;code&gt;FAST ANALYZE&lt;/code&gt;，通过&lt;code&gt;tidb_enable_fast_analyze&lt;/code&gt; 变量控制。该特性通过用对 Region 进行采样取代扫描整个 region 的方式加速统计信息收集。&lt;/li&gt;&lt;li&gt;支持 &lt;code&gt;SQL PLAN MANAGEMENT&lt;/code&gt;。该特性通过对 SQL 进行执行计划绑定，以确保执行稳定性。该特性目前处于测试阶段，仅支持对 SELECT 语句使用绑定的执行计划，不建议在生产场景中直接使用。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;执行引擎&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;支持对 &lt;code&gt;TableReader&lt;/code&gt;、&lt;code&gt;IndexReader&lt;/code&gt; 和 &lt;code&gt;IndexLookupReader&lt;/code&gt; 算子进行内存追踪控制。&lt;/li&gt;&lt;li&gt;在慢日志中展示更多 COPROCESSOR 端执行任务相关细节。如 COPROCESSOR 任务数，平均/最长/90% 执行/等待时间，执行/等待时间最长的 TiKV 地址等。&lt;/li&gt;&lt;li&gt;支持 PREPARE 不含占位符的 DDL 语句。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;Server&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;TiDB 启动时，只允许 DDL owner 执行 bootstrap &lt;/li&gt;&lt;li&gt;新增 &lt;code&gt;tidb_skip_isolation_level_check&lt;/code&gt; 变量控制检查隔离级别设置为 SERIALIZABLE 时不报错 &lt;/li&gt;&lt;li&gt;在慢日志中，将隐式提交的时间与 SQL 执行时间融合在一起 &lt;/li&gt;&lt;li&gt;RBAC 权限管理&lt;/li&gt;&lt;ul&gt;&lt;li&gt;支持 &lt;code&gt;SHOW GRANT&lt;/code&gt; &lt;/li&gt;&lt;li&gt;支持 &lt;code&gt;SET DEFAULT ROLE&lt;/code&gt; &lt;/li&gt;&lt;li&gt;支持 &lt;code&gt;GRANT ROLE&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;li&gt;修正了插件退出时导致 TiDB 退出的问题 &lt;/li&gt;&lt;li&gt;修正只读语句被错误地放到事务历史中的问题 &lt;/li&gt;&lt;li&gt;kill 语句可以更快的结束 SQL 的执行，并快速释放资源 &lt;/li&gt;&lt;li&gt;增加启动选项 &lt;code&gt;config-check&lt;/code&gt; 来检查配置文件的合法性 &lt;/li&gt;&lt;li&gt;修正非严格模式下对于写入 NULL 字段的合法性检查 &lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;DDL&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;为 CREATE TABLE 添加了 pre_split_regions 选项，该选项可以在建表时预先分配 Table Region，避免建表后大量写入造成的写热点 &lt;/li&gt;&lt;li&gt;优化了部分 DDL 语句的执行性能 &lt;/li&gt;&lt;li&gt;FULLTEXT KEY 新增不支持全文索引的 warning &lt;/li&gt;&lt;li&gt;修正了旧版本 TiDB 中，UTF8 和 UTF8MB4 编码的兼容性问题 &lt;/li&gt;&lt;li&gt;修正了一个表的 shard_row_id_bits 的潜在 BUG &lt;/li&gt;&lt;li&gt;修正了 ALTER TABLE Charset 后，Column Charset 不会跟随变化的 BUG &lt;/li&gt;&lt;li&gt;修正了使用 BINARY/BIT 作为 Column Default Value 时，SHOW COLUMN 可能出错的 BUG &lt;/li&gt;&lt;li&gt;修正了 SHOW FULL COLUMNS 语句中，CHARSET / COLLATION 显示的兼容性问题 &lt;/li&gt;&lt;li&gt;现在 SHOW COLLATIONS 语句只会列出 TiDB 所实际支持的 COLLATIONS &lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2&gt;PD&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;升级 ETCD 版本 &lt;/li&gt;&lt;ul&gt;&lt;li&gt;统一 etcd 的日志格式与 pd server 一致&lt;/li&gt;&lt;li&gt;修复 prevote 可能无法选出 Leader 的问题&lt;/li&gt;&lt;li&gt;快速 drop 掉会失败的 propose 和 read 请求，减少阻塞后面的请求时间&lt;/li&gt;&lt;li&gt;修复 Lease 的死锁问题&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;修复 store 读热点的 keys 统计不正确问题 &lt;/li&gt;&lt;li&gt;支持从单一 PD 节点强制重建 PD 集群 &lt;/li&gt;&lt;li&gt;修复 Scatter Region 产生无效 Operator Step 的问题 &lt;/li&gt;&lt;li&gt;修复 Region Merge Operator 超时时间过短的问题 &lt;/li&gt;&lt;li&gt;热点调度使用高优先级 &lt;/li&gt;&lt;li&gt;添加 PD server 端处理 TSO 请求的耗时 Metrics &lt;/li&gt;&lt;li&gt;添加相对应的 Store ID 和 Address 到 store 相关的 Metrics &lt;/li&gt;&lt;li&gt;支持 GetOperator 服务 &lt;/li&gt;&lt;li&gt;修复 Heartbeat stream 下发送 error 找不到 store 的问题 &lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;TiKV&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Engine&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;修复读流量统计不准确问题 &lt;/li&gt;&lt;li&gt;修复 prefix extractor panic 的问题 &lt;/li&gt;&lt;li&gt;优化内存管理，减少 &lt;code&gt;Iterator Key Bound Option&lt;/code&gt; 的内存分配和拷贝 &lt;/li&gt;&lt;li&gt;修复 Merge Region 时未考虑 Learner log gap 造成的 panic 问题&lt;/li&gt;&lt;li&gt;支持不同的 &lt;code&gt;column families&lt;/code&gt; 共享 &lt;code&gt;block cache&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;Server&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;减少 &lt;code&gt;batch commands&lt;/code&gt; 的上下文切换开销&lt;/li&gt;&lt;li&gt;检查 seek iterator status 的合法性 &lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;RaftStore&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;可配置化 &lt;code&gt;properties index distance&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;Coprocessor&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;新增 batch index scan executor &lt;/li&gt;&lt;li&gt;新增向量化 evaluation 框架 &lt;/li&gt;&lt;li&gt;新增 batch 执行器统计框架 &lt;/li&gt;&lt;li&gt;构建 RPN expression 时检查 max column 以防止 evaluation 阶段 column offset 越界的问题 &lt;/li&gt;&lt;li&gt;实现 &lt;code&gt;BatchLimitExecutor&lt;/code&gt; &lt;/li&gt;&lt;li&gt;ReadPool 使用 &lt;code&gt;tokio-threadpool&lt;/code&gt; 替换原本的 &lt;code&gt;futures-cpupool&lt;/code&gt;，减少 context switch &lt;/li&gt;&lt;li&gt;新增 batch 聚合框架 &lt;/li&gt;&lt;li&gt;新增 &lt;code&gt;BatchSelectionExecutor&lt;/code&gt; &lt;/li&gt;&lt;li&gt;实现 batch aggression function &lt;code&gt;AVG&lt;/code&gt; &lt;/li&gt;&lt;li&gt;实现 RPN function &lt;code&gt;LogicalAnd&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;Misc&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;支持选用 tcmalloc 为内存分配器 &lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2&gt;Tools&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;TiDB-Binlog&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;修复 unsigned int 类型的主键列的 binlog 数据为负数，造成同步出错中断的问题 &lt;/li&gt;&lt;li&gt;删除下游是 pb 时的压缩选项，修改下游名字 pb 成 file &lt;/li&gt;&lt;li&gt;Pump 新增 storage.sync-log 配置项，支持 Pump 本地存储异步刷盘 &lt;/li&gt;&lt;li&gt;Pump 和 Drainer 之间通讯支持流量压缩 &lt;/li&gt;&lt;li&gt;Drainer 新增 syncer.sql-mode 配置项，支持使用不同 sql-mode 解析 DDL query &lt;/li&gt;&lt;li&gt;Drainer 新增 syncer.ignore-table 配置项，支持过滤不需要同步的表 &lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;Lightning&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;使用 row id 或者列的默认值填充 dump 文件中缺少的 column 数据 &lt;/li&gt;&lt;li&gt;Importer 修复部分 SST 导入失败依然返回导入成功的 bug &lt;/li&gt;&lt;li&gt;Importer 支持 upload SST 到 TiKV 限速 &lt;/li&gt;&lt;li&gt;Lightning 优化导入表的顺序，按照表的数据大小顺序进行导入，减少导入过程中大表执行 checksum 和 Analyze 对集群的影响，并且提高 Checksum 和 Analyze 的成功率 &lt;/li&gt;&lt;li&gt;提升 Lightning encode SQL 性能，性能提升 50%，直接解析数据源文件内容成 TiDB 的 types.Datum，省去 KV encoder 的多余解析工作 &lt;/li&gt;&lt;li&gt;日志格式改为 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/rfcs/blob/master/text/2018-12-19-unified-log-format.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Unified Log Format&lt;/a&gt; &lt;/li&gt;&lt;li&gt;新增一些命令行选项，即使缺少配置文件也能使用。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;数据同步对比工具 (sync-diff-inspector)&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;支持 checkpoint，记录校验状态，重启后从上次进度继续校验 &lt;/li&gt;&lt;li&gt;增加配置项 only-use-checksum，只通过计算 checksum 来检查数据是否一致 &lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2&gt;TiDB-Ansible&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;TiKV 监控变更以及更新 Ansible、Grafana、Prometheus 版本 &lt;/li&gt;&lt;ul&gt;&lt;li&gt;summary 监控适用于用户查看集群状态&lt;/li&gt;&lt;li&gt;trouble_shooting 监控适用于 DBA 排查问题&lt;/li&gt;&lt;li&gt;details 监控适用于开发分析问题&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;修复下载 Kafka 版本 Binlog 失败的 BUG &lt;/li&gt;&lt;li&gt;修改操作系统版本限制，仅支持 CentOS 7.0 及以上，Red Hat 7.0 及以上版本的操作系统 &lt;/li&gt;&lt;li&gt;滚动升级时的版本检测改为多并发 &lt;/li&gt;&lt;li&gt;更新 README 中文档链接&lt;/li&gt;&lt;li&gt;移除重复的 TiKV 监控项，新增 trouble shooting 监控项 &lt;/li&gt;&lt;li&gt;优化 &lt;code&gt;table-regions.py&lt;/code&gt; 脚本，按表显示 leader 分布 &lt;/li&gt;&lt;li&gt;更新 drainer 配置文件 &lt;/li&gt;&lt;li&gt;优化 TiDB 监控，新增以 SQL 类别显示延迟的监控项 &lt;/li&gt;&lt;li&gt;更新 Lightning 配置文件，新增 tidb_lightning_ctl 脚本 &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-05-13-65541594</guid>
<pubDate>Mon, 13 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>DM 源码阅读系列文章（五）Binlog replication 实现</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-05-08-65085586.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65085586&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1531d15e86959451981ee9de49ea9d03_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：lan&lt;/p&gt;&lt;p&gt;本文为 DM 源码阅读系列文章的第五篇。&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/dm-source-code-reading-4/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;上篇文章&lt;/a&gt; 介绍了 dump 和 load 两个数据同步处理单元的设计实现，对核心 interface 实现、数据导入并发模型、数据导入暂停或中断的恢复进行了分析。&lt;b&gt;本篇文章将详细地介绍 DM 核心处理单元 Binlog replication，内容包含 binlog 读取、过滤、路由、转换，以及执行等逻辑。&lt;/b&gt;文内涉及到 shard merge 相关逻辑功能，如 column mapping、shard DDL 同步处理，会在 shard merge 篇单独详细讲解，这里就不赘述了。&lt;/p&gt;&lt;h2&gt;Binlog replication 处理流程&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-db9946ecad5943830d35e583f7e35ad8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;456&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-db9946ecad5943830d35e583f7e35ad8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-db9946ecad5943830d35e583f7e35ad8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;456&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-db9946ecad5943830d35e583f7e35ad8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-db9946ecad5943830d35e583f7e35ad8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从上图可以大致了解到 Binlog replication 的逻辑处理流程，对应的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L886&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;逻辑入口代码&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;1.从 relay log 或者 MySQL/MariaDB 读取 binlog events。&lt;/p&gt;&lt;p&gt;2.对 binlog events 进行处理转换（transformation），这里可以做三类操作：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-af6497ca0030d448c6dbdb05989e0f3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1342&quot; data-rawheight=&quot;372&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1342&quot; data-original=&quot;https://pic4.zhimg.com/v2-af6497ca0030d448c6dbdb05989e0f3f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-af6497ca0030d448c6dbdb05989e0f3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1342&quot; data-rawheight=&quot;372&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1342&quot; data-original=&quot;https://pic4.zhimg.com/v2-af6497ca0030d448c6dbdb05989e0f3f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-af6497ca0030d448c6dbdb05989e0f3f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;3.executor 对 job 进行冲突检测，然后根据固定规则分发给对应的 worker 执行。&lt;/p&gt;&lt;p&gt;4.定期保存 binlog position/gtid 到 checkpoint。&lt;/p&gt;&lt;h2&gt;Binlog 读取&lt;/h2&gt;&lt;p&gt;Binlog replication 支持两种方式读取 binlog events:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1032&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;从远程的 MySQL/MariaDB&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1036&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;从 DM-worker 的本地 relay log&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;两种方式都提供了同样的读取方法，处理核心都是 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/siddontang/go-mysql&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;go-mysql&lt;/a&gt;。该库主要提供了两个功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;注册为 MySQL/MariaDB 的 slave server ，从 MySQL/MariaDB 顺序读取 raw binlog events。&lt;/li&gt;&lt;li&gt;解析 raw binlog events。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更多的处理细节会在下篇关于 relay log 的文章中进行介绍，迫不及待的小伙伴可以先翻阅一下相关代码实现。&lt;/p&gt;&lt;h2&gt;Binlog 转换&lt;/h2&gt;&lt;p&gt;处理程序拿到解析好的 binlog event 后，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1133&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;根据 binlog 的类型来对 binlog 进行分类处理&lt;/a&gt;。Binlog replication 主要关心以下类型的 binlog event ：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-44d8ec0e2fa7164c445f58cd966d81b1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1784&quot; data-rawheight=&quot;508&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1784&quot; data-original=&quot;https://pic2.zhimg.com/v2-44d8ec0e2fa7164c445f58cd966d81b1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-44d8ec0e2fa7164c445f58cd966d81b1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1784&quot; data-rawheight=&quot;508&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1784&quot; data-original=&quot;https://pic2.zhimg.com/v2-44d8ec0e2fa7164c445f58cd966d81b1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-44d8ec0e2fa7164c445f58cd966d81b1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Binlog replication 数据处理单元会对每一类 binlog event 进行以下的处理步骤，具体实现的处理顺序可能略有差异，以代码实现为准。&lt;/p&gt;&lt;h3&gt;过滤&lt;/h3&gt;&lt;p&gt;Binlog replication 会从两个维度对 binlog event 来进行过滤：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;根据 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L119&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;同步库/表黑白名单&lt;/a&gt;，过滤掉对应库/表的所有 binlog event。&lt;/li&gt;&lt;li&gt;根据 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L117&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;binlog event 过滤规则&lt;/a&gt;，过滤掉对应库/表指定的 binlog event。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;u&gt;&lt;code&gt;&lt;a href=&quot;&amp;lt;/code&amp;gt;https://github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/filter.go#L147&quot;&gt;row event过滤处理&lt;/a&gt; &lt;/code&gt;&lt;/u&gt;和&lt;u&gt;&lt;code&gt;&lt;a href=&quot;ht&amp;lt;/code&amp;gt;tps://github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/filter.go#L96&quot;&gt;query event过滤处理&lt;/a&gt; &lt;/code&gt;&lt;/u&gt;的实现在逻辑上面存在一些差异：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;row event&lt;/code&gt; 包含 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1167&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;库名和表名&lt;/a&gt; 信息；&lt;code&gt;query event&lt;/code&gt; 需要通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/parser&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;tidb parser&lt;/a&gt; &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1365&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;解析 event 里面包含的 query statement 来获取需要的库名，表名以及其他信息&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;tidb parser 不是完全 100% 兼容 MySQL 语法，当遇到 parser 不支持的 query statement 时候，解析就会报错，从而无法获取到对应的库名和表名信息。Binlog replication 提供了一些 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/filter.go%23L32&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;内置的不支持的 query statement 正则表达式&lt;/a&gt;，配合 href=&amp;#34;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/filter.go%23L123&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/pingcap/dm/b&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;lob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/filter.go#L123&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&amp;#34;&amp;gt;使用 [schema-pattern: *, table-pattern: *]的 binlog event 过滤规则，来跳过 parser 不支持的 query statement。&lt;/li&gt;&lt;li&gt;&lt;code&gt;query event&lt;/code&gt; 里面也会包含 statement format binlog event，此时 Binlog replication 就可以利用 parser 解析出来具体的 statement 类型，对不支持的 statement format binlog event 作出相应的处理： &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/ddl.go%23L117&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;对于需要同步的表，进行报错处理&lt;/a&gt;；&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/ddl.go%23L108&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;不需要同步的表，忽略继续同步&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;路由&lt;/h3&gt;&lt;p&gt;binlog 过滤完成之后，对于需要同步的表就会根据过滤步骤获得的库名和表名，通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L116&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;路由规则&lt;/a&gt; &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1960&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;转换得到需要同步到的目标库名和表名&lt;/a&gt;，在接下来的转换步骤来使用目标库名和表名来转换出正确的 DML 和 DDL statement。&lt;/p&gt;&lt;h3&gt;转换&lt;/h3&gt;&lt;p&gt;&lt;code&gt;row event&lt;/code&gt; 转换处理和 &lt;code&gt;query event&lt;/code&gt; 转换处理的实现存在一些差异，这里分开来讲述。&lt;/p&gt;&lt;p&gt;&lt;code&gt;row event&lt;/code&gt; 转换处理通过三个转换函数生成对应的 statements：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1261&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;generate insert sqls&lt;/a&gt;&lt;/code&gt; ：将 &lt;code&gt;write rows event&lt;/code&gt; 转换为 &lt;code&gt;replace into statements&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1294&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;generate update sqls&lt;/a&gt;&lt;/code&gt;：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;safe mode = true&lt;/code&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/dml.go%23L193&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;将 update rows event 转换为 delete + replace statements&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;&lt;code&gt;safe mode = false&lt;/code&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/dml.go%23L231&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;将 update row event 转换为 update statements&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1327&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;generate delete sqls&lt;/a&gt;&lt;/code&gt;：将 delete rows event 转换为 delete statements。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;query event&lt;/code&gt; 转换处理：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;因为 TiDB 目前不支持一条 DDL 语句包含多个 DDL 操作，query event 转换处理会首先尝试将 &lt;b&gt;包含多个 DDL 变更操作的单条 DDL 语句&lt;/b&gt; 拆分成 &lt;b&gt;只包含一个 DDL 操作的多条 DDL 语句&lt;/b&gt;（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1411&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;具体代码实现&lt;/a&gt;）。&lt;/li&gt;&lt;li&gt;使用 parser 将 DDL statement 对应的 ast 结构里面的库名和表名替换成对应的目标库名和表名（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1442&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;具体代码实现&lt;/a&gt;）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过转换处理之后，将不同的 binlog event 包装成不同的 job 发送到 executor 执行：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1353&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;row event -&amp;gt; insert/update/delete job&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1529&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;query event -&amp;gt; ddl job&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1702&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;xid event -&amp;gt; xid job&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Job 执行&lt;/h2&gt;&lt;h3&gt;冲突检测&lt;/h3&gt;&lt;p&gt;binlog 顺序同步模型要求按照 binlog 顺序一个一个来同步 binlog event，这样的顺序同步势必不能满足高 QPS 低同步延迟的同步需求，并且不是所有的 binlog 涉及到的操作都存在冲突。Binlog replication 采用冲突检测机制，鉴别出来需要顺序执行的 jobs，在确保这些 jobs 的顺序执行的基础上，最大程度地保持其他 job 的并发执行来满足性能方面的要求。&lt;/p&gt;&lt;p&gt;冲突检测流程如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;遇到 DDL job，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L642&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;等待前面已经分发出来的所有 DML jobs 执行完成后&lt;/a&gt;，然后单独执行该 DDL job，执行完成之后保存 checkpoint 信息。&lt;/li&gt;&lt;li&gt;遇到 DML job，会 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1712&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;先检测并且尝试解决冲突&lt;/a&gt;。如果检测到冲突（即存在两个 executor  的 worker 的 jobs 都需要与当前的 job 保持顺序执行），&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1730&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;会发送一个 flush job 来等待已经分发的所有 DML jobs 执行完成&lt;/a&gt;，然后再将  job 分发到对应的 worker，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L1735&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;并且记录该分发信息到内存&lt;/a&gt;。在没有冲突的情况下，如果不需要与已经分发出去的 job 保持顺序的话，发送 job 到任意 worker 上；如果需要保持顺序的话，那么根据内存储存的历史分发信息，发送 job 到对应的 worker 上。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;冲突检测实现比较简单，根据转换步骤获得每条 statement 对应的 &lt;code&gt;primary/unique key&lt;/code&gt; 信息，来进行交集检测，如果存在交集那么认定是需要顺序的执行两条 statement，请参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/causality.go&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;具体实现代码&lt;/a&gt;。&lt;/p&gt;&lt;h3&gt;执行&lt;/h3&gt;&lt;p&gt;job 分发到对应的 worker 后，worker 根据一定的规则来批量执行这些 job，如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L804&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;遇到 DDL 立即执行&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L861&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;遇到 flush&lt;/a&gt; 或者积累的 job 数量超过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/dm/config/task.go%23L183&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;配置的 batch 数量&lt;/a&gt; 立即执行。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L871&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;没有新的 job 分发进来，清空当前已经积累的 jobs 或者 sleep 10 ms&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;根据上面三个规则可以很快地将已经分发的 jobs 应用到下游 TiDB。&lt;/p&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;本篇文章详细地介绍 DM 核心处理单元 Binlog replication，内容包含 binlog 读取、过滤、路由、转换，以及执行等逻辑。下一篇我们会对 relay log 数据处理单元的设计进行详细的讲解。&lt;/p&gt;&lt;p&gt;&lt;i&gt;更多阅读：&lt;/i&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.pingcap.com/blog-cn/%23DM-%25E6%25BA%2590%25E7%25A0%2581%25E9%2598%2585%25E8%25AF%25BB&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;博客&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-05-08-65085586</guid>
<pubDate>Wed, 08 May 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
