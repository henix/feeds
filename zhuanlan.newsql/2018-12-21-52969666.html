<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TiDB 源码阅读系列文章（二十二）Hash Aggregation</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/52969666">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-2e665a8d2aeb4f9ccf89d305b5638fe8_r.jpg" alt=""></div><h2><b>聚合算法执行原理</b></h2><p>在 SQL 中，聚合操作对一组值执行计算，并返回单个值。TiDB 实现了 2 种聚合算法：Hash Aggregation 和 Stream Aggregation。</p><p>我们首先以 <code class="inline">AVG</code> 函数为例（案例参考 <a href="https://stackoverflow.com/questions/1471147/how-do-aggregates-group-by-work-on-sql-server/1471167#1471167">Stack Overflow</a>），简述这两种算法的执行原理。</p><p>假设表 <code class="inline">t</code> 如下：</p><img src="https://pic2.zhimg.com/v2-b2dd18d0611f1126eefb231f6ee49292_r.jpg" data-caption="" data-size="normal" data-rawwidth="1232" data-rawheight="504" data-watermark="watermark" data-original-src="v2-b2dd18d0611f1126eefb231f6ee49292" data-watermark-src="v2-8db01296a4397381f572bfd5a329c488" data-private-watermark-src=""><p>SQL:<code class="inline">select avg(b) from t group by a</code>, 要求将表<code class="inline">t</code>的数据按照<code class="inline">a</code>的值分组，对每一组的<code class="inline">b</code>值计算平均值。不管 Hash 还是 Stream 聚合，在<code class="inline">AVG</code>函数的计算过程中，我们都需要维护 2 个中间结果变量<code class="inline">sum</code>和<code class="inline">count</code>。Hash 和 Stream 聚合算法的执行原理如下。</p><ul><li><b>Hash Aggregate 的执行原理</b></li></ul><p>在 Hash Aggregate 的计算过程中，我们需要维护一个 Hash 表，Hash 表的键为聚合计算的 <code class="inline">Group-By</code> 列，值为聚合函数的中间结果 <code class="inline">sum</code> 和 <code class="inline">count</code>。在本例中，键为 <code class="inline">列 a</code> 的值，值为 <code class="inline">sum(b)</code> 和 <code class="inline">count(b)</code>。</p><p>计算过程中，只需要根据每行输入数据计算出键，在 Hash 表中找到对应值进行更新即可。对本例的执行过程模拟如下。</p><img src="https://pic2.zhimg.com/v2-4c0e089d8cb104047a03624a62c0aa40_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="508" data-watermark="watermark" data-original-src="v2-4c0e089d8cb104047a03624a62c0aa40" data-watermark-src="v2-a811115327639d12cea5c777a01121dc" data-private-watermark-src=""><p>输入数据输入完后，扫描 Hash 表并计算，便可以得到最终结果：</p><img src="https://pic3.zhimg.com/v2-26730a2dd30e86d15333c71ed9f077a2_r.jpg" data-caption="" data-size="normal" data-rawwidth="1238" data-rawheight="230" data-watermark="watermark" data-original-src="v2-26730a2dd30e86d15333c71ed9f077a2" data-watermark-src="v2-99647b66dfb1d3e931cb250e08325d72" data-private-watermark-src=""><ul><li><b>Stream Aggregation 的执行原理</b></li></ul><p>Stream Aggregate 的计算需要保证输入数据<b>按照</b> <b><code class="inline">Group-By</code></b> <b>列有序</b>。在计算过程中，每当读到一个新的 Group 的值或所有数据输入完成时，便对前一个 Group 的聚合最终结果进行计算。</p><p>对于本例，我们首先对输入数据按照 <code class="inline">a</code> 列进行排序。排序后，本例执行过程模拟如下。</p><img src="https://pic4.zhimg.com/v2-6a3a1877235777488a3eeb310f583388_r.jpg" data-caption="" data-size="normal" data-rawwidth="1592" data-rawheight="658" data-watermark="watermark" data-original-src="v2-6a3a1877235777488a3eeb310f583388" data-watermark-src="v2-ce83f2fe1e9f559028fd5c0552a46552" data-private-watermark-src=""><p>因为 Stream Aggregate 的输入数据需要保证同一个 Group 的数据连续输入，所以 Stream Aggregate 处理完一个 Group 的数据后可以立刻向上返回结果，不用像 Hash Aggregate 一样需要处理完所有数据后才能正确的对外返回结果。当上层算子只需要计算部分结果时，比如 Limit，当获取到需要的行数后，可以提前中断 Stream Aggregate 后续的无用计算。</p><p>当 <code class="inline">Group-By</code> 列上存在索引时，由索引读入数据可以保证输入数据按照 <code class="inline">Group-By</code> 列有序，此时同一个 Group 的数据连续输入 Stream Aggregate 算子，可以避免额外的排序操作。</p><h2><b>TiDB 聚合函数的计算模式</b></h2><p>由于分布式计算的需要，TiDB 对于聚合函数的计算阶段进行划分，相应定义了 5 种计算模式：CompleteMode，FinalMode，Partial1Mode，Partial2Mode，DedupMode。不同的计算模式下，所处理的输入值和输出值会有所差异，如下表所示：</p><img src="https://pic1.zhimg.com/v2-a47f00865b6947802ad23614be6612f5_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="826" data-watermark="watermark" data-original-src="v2-a47f00865b6947802ad23614be6612f5" data-watermark-src="v2-e0330d54b46bfda4ffe89a871977b0b6" data-private-watermark-src=""><p>以上文提到的 <code class="inline">select avg(b) from t group by a</code> 为例，通过对计算阶段进行划分，可以有多种不同的计算模式的组合，如：</p><ul><li>CompleteMode</li></ul><p>此时 <code class="inline">AVG</code> 函数的整个计算过程只有一个阶段，如图所示：</p><img src="https://pic1.zhimg.com/v2-567c7fc043936b972b03a13e10b11da3_r.jpg" data-caption="" data-size="normal" data-rawwidth="470" data-rawheight="493" data-watermark="watermark" data-original-src="v2-567c7fc043936b972b03a13e10b11da3" data-watermark-src="v2-18d7246583684dfce6c22c1769a8f4e7" data-private-watermark-src=""><ul><li>Partial1Mode –&gt; FinalMode</li></ul><p>此时我们将 <code class="inline">AVG</code> 函数的计算过程拆成两个阶段进行，如图所示：<br></p><img src="https://pic3.zhimg.com/v2-df34ce6dfe2919f80ebd4aa950f2480c_r.jpg" data-caption="" data-size="normal" data-rawwidth="556" data-rawheight="637" data-watermark="watermark" data-original-src="v2-df34ce6dfe2919f80ebd4aa950f2480c" data-watermark-src="v2-638ea8080df76ae1255c6e340518b5ce" data-private-watermark-src=""><p>除了上面的两个例子外，还可能有如下的几种计算方式：</p><ol><li>聚合被下推到 TiKV 上进行计算（Partial1Mode），并返回经过预聚合的中间结果。为了充分利用 TiDB server 所在机器的 CPU 和内存资源，加快 TiDB 层的聚合计算，TiDB 层的聚合函数计算可以这样进行：Partial2Mode –&gt; FinalMode。</li><li>当聚合函数需要对参数进行去重，也就是包含 <code class="inline">DISTINCT</code> 属性，且聚合算子因为一些原因不能下推到 TiKV 时，TiDB 层的聚合函数计算可以这样进行：DedupMode –&gt; Partial1Mode –&gt; FinalMode。</li></ol><p>聚合函数分为几个阶段执行， 每个阶段对应的模式是什么，是否要下推到 TiKV，使用 Hash 还是 Stream 聚合算子等都由优化器根据数据分布、估算的计算代价等来决定。</p><h2><b>TiDB 并行 Hash Aggregation 的实现</b></h2><ul><li><b>如何构建 Hash Aggregation 执行器</b></li></ul><ol><li><a href="https://github.com/pingcap/tidb/tree/v2.1.0/planner/core/logical_plan_builder.go#L95">构建逻辑执行计划</a> 时，会调用 <a href="https://github.com/pingcap/tidb/blob/v2.1.0/expression/aggregation/descriptor.go#L49">NewAggFuncDesc</a> 将聚合函数的元信息封装为一个 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/expression/aggregation/descriptor.go#L35-L46">AggFuncDesc</a>。 其中 <code class="inline">AggFuncDesc.RetTp</code> 由 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/expression/aggregation/descriptor.go#L146-L163">AggFuncDesc.typeInfer</a> 根据聚合函数类型及参数类型推导而来；<code class="inline">AggFuncDesc.Mode</code> 统一初始化为 CompleteMode。</li><li><a href="https://github.com/pingcap/tidb/tree/v2.1.0/planner/core/task.go#L487">构建物理执行计划</a>时，<code class="inline">PhysicalHashAgg</code> 和 <code class="inline">PhysicalStreamAgg</code> 的 <code class="inline">attach2Task</code> 方法会根据当前 <code class="inline">task</code> 的类型尝试进行下推聚合计算，如果 <code class="inline">task</code> 类型满足下推的基本要求，比如 <code class="inline">copTask</code>，接着会调用 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/planner/core/task.go#L380">newPartialAggregate</a> 尝试将聚合算子拆成 TiKV 上执行的 Partial 算子和 TiDB 上执行的 <code class="inline">Final</code> 算子，其中 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/expression/aggregation/agg_to_pb.go#L25">AggFuncToPBExpr</a> 函数用来判断某个聚合函数是否可以下推。若聚合函数可以下推，则会在 TiKV 中进行预聚合并返回中间结果，因此需要将 TiDB 层执行的 <code class="inline">Final</code> 聚合算子的 <code class="inline">AggFuncDesc.Mode</code> <a href="https://github.com/pingcap/tidb/tree/v2.1.0/planner/core/task.go#L427">修改为 FinalMode</a>，并将其 <code class="inline">AggFuncDesc.Args</code> <a href="https://github.com/pingcap/tidb/tree/v2.1.0/planner/core/task.go#L403-L426">修改为 TiKV 预聚合后返回的中间结果</a>，TiKV 层的 Partial 聚合算子的 <code class="inline">AggFuncDesc</code> 也需要作出对应的修改，这里不再详述。若聚合函数不可以下推，则 <code class="inline">AggFuncDesc.Mode</code> 保持不变。</li><li><a href="https://github.com/pingcap/tidb/blob/v2.1.0/executor/builder.go#L999">构建 HashAgg 执行器</a>时，首先检查当前 <code class="inline">HashAgg</code> 算子<a href="https://github.com/pingcap/tidb/blob/v2.1.0/executor/builder.go#L1037-L1047">是否可以并行执行</a>。目前当且仅当两种情况下 <code class="inline">HashAgg</code> 不可以并行执行：</li></ol><ul><li>存在某个聚合函数参数为 DISTINCT 时。TiDB 暂未实现对 DedupMode 的支持，因此对于含有 <code class="inline">DISTINCT</code> 的情况目前仅能单线程执行。</li><li>系统变量 <code class="inline"><a href="https://github.com/pingcap/docs-cn/blob/master/sql/tidb-specific.md#tidb_hashagg_partial_concurrency">tidb_hashagg_partial_concurrency</a></code> 和 <code class="inline"><a href="https://github.com/pingcap/docs-cn/blob/master/sql/tidb-specific.md#tidb_hashagg_final_concurrency">tidb_hashagg_final_concurrency</a></code> 被同时设置为 1 时。这两个系统变量分别用来控制 Hash Aggregation 并行计算时候，TiDB 层聚合计算 partial 和 final 阶段 worker 的并发数。当它们都被设置为 1 时，选择单线程执行。</li></ul><p>若<code class="inline">HashAgg</code>算子可以并行执行，使用<a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/builder.go#L1062">AggFuncDesc.Split</a>根据<code class="inline">AggFuncDesc.Mode</code>将 TiDB 层的聚合算子的计算拆分为 partial 和 final 两个阶段，并分别生成对应的<code class="inline">AggFuncDesc</code>，设为<code class="inline">partialAggDesc</code>和<code class="inline">finalAggDesc</code>。若<code class="inline">AggFuncDesc.Mode == CompleteMode</code>，则将 TiDB 层的计算阶段拆分为<code class="inline">Partial1Mode --&gt; FinalMode</code>；若<code class="inline">AggFuncDesc.Mode == FinalMode</code>，则将 TiDB 层的计算阶段拆分为<code class="inline">Partial2Mode --&gt; FinalMode</code>。进一步的，我们可以根据<code class="inline">partialAggDesc</code>和<code class="inline">finalAggDesc</code>分别<a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/builder.go#L1063-L1066">构造出对应的执行函数</a>。</p><ul><li><b>并行 Hash Aggregation 执行过程详述</b></li></ul><p>TiDB 的并行 Hash Aggregation 算子执行过程中的主要线程有：Main Thead，Data Fetcher，Partial Worker，和 Final Worker：</p><ul><li>Main Thread 一个：</li><ul><li>启动 Input Reader，Partial Workers 及 Final Workers</li><li>等待 Final Worker 的执行结果并返回</li></ul><li>Data Fetcher 一个：</li><ul><li>按 batch 读取子节点数据并分发给 Partial Worker</li></ul><li>Partial Worker 多个：</li><ul><li>读取 Data Fetcher 发送来的数据，并做预聚合</li><li>将预聚合结果根据 Group 值 shuffle 给对应的 Final Worker</li></ul><li>Final Worker 多个：</li><ul><li>读取 PartialWorker 发送来的数据，计算最终结果，发送给 Main Thread</li></ul></ul><p>Hash Aggregation 的执行阶段可分为如下图所示的 5 步：</p><img src="https://pic1.zhimg.com/v2-070c20ca9c7b3e1d03ede09d95d20259_r.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="347" data-watermark="watermark" data-original-src="v2-070c20ca9c7b3e1d03ede09d95d20259" data-watermark-src="v2-65f2027935adc477a4bed0fa5f275d34" data-private-watermark-src=""><ol><li><b>启动 Data Fetcher，Partial Workers 及 Final Workers。</b></li></ol><p>这部分工作由 <a href="https://github.com/pingcap/tidb/tree/v2.1.0">prepare4Parallel</a> 函数完成。该函数会启动一个 Data Fetcher，<a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L589-L591">多个 Partial Worker</a> 以及 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L596-L598">多个 Final Worker</a>。Partial Worker 和 Final Worker 的数量可以分别通过 <code class="inline">tidb_hashgg_partial_concurrency</code> 和 <code class="inline">tidb_hashagg_final_concurrency</code> 系统变量进行控制，这两个系统变量的默认值都为 4。</p><p><b>2.DataFetcher 读取子节点的数据并分发给 Partial Workers。</b></p><p>这部分工作由 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L535">fetchChildData</a> 函数完成。</p><p><b>3.Partial Workers 预聚合计算，及根据 Group Key shuffle 给对应的 Final Workers。</b></p><p>这部分工作由 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L326">HashAggPartialWorker.run</a> 函数完成。该函数调用 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L351">updatePartialResult</a> 函数对 DataFetcher 发来数据执行 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L358-L363">预聚合计算</a>，并将预聚合结果存储到 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L63">partialResultMap</a> 中。其中 <code class="inline">partialResultMap</code> 的 key 为根据 <code class="inline">Group-By</code> 的值 encode 的结果，value 为 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggfuncs/aggfuncs.go#L89">PartialResult</a> 类型的数组，数组中的每个元素表示该下标处的聚合函数在对应 Group 中的预聚合结果。<a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L370">shuffleIntermData</a> 函数完成根据 Group 值 shuffle 给对应的 Final Worker。</p><p><b>4.Final Worker 计算最终结果，发送给 Main Thread。</b></p><p>这部分工作由 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L505">HashAggFinalWorker.run</a> 函数完成。该函数调用 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L434">consumeIntermData</a> 函数 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/aggregate.go#L443">接收 PartialWorkers 发送来的预聚合结果</a>，进而 <a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L459">合并</a> 得到最终结果。<a href="https://github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go#L459">getFinalResult</a> 函数完成发送最终结果给 Main Thread。</p><p><b>5.Main Thread 接收最终结果并返回。</b></p><h2><b>TiDB 并行 Hash Aggregation 的性能提升</b></h2><p>此处以 <a href="https://github.com/pingcap/tidb-bench/blob/master/tpch/queries/17.sql">TPC-H query-17</a> 为例，测试并行 Hash Aggregation 相较于单线程计算时的性能提升。引入并行 Hash Aggregation 前，它的计算瓶颈在 <code class="inline">HashAgg_35</code>。</p><p>该查询执行计划如下：</p><img src="https://pic2.zhimg.com/v2-8967db518d31d2316d040b20a6620605_r.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="941" data-watermark="watermark" data-original-src="v2-8967db518d31d2316d040b20a6620605" data-watermark-src="v2-f47abed183d2edbddd6fda0d8ce6098c" data-private-watermark-src=""><p>在 TiDB 中，使用 <a href="https://github.com/pingcap/docs-cn/blob/master/sql/understanding-the-query-execution-plan.md#explain-analyze-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F">EXPLAIN ANALYZE</a> 可以获取 SQL 的执行统计信息。因篇幅原因此处仅贴出 TPC-H query-17 部分算子的 EXPLAIN ANALYZE 结果。</p><p><code class="inline">HashAgg</code> 单线程计算时：</p><img src="https://pic4.zhimg.com/v2-db9b78ba3e21565d4e7d5088e639af8f_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="113" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>查询总执行时间 23 分 24 秒，其中 <code class="inline">HashAgg</code> 执行时间约 17 分 9 秒。</p><p><code class="inline">HashAgg</code> 并行计算时（此时 TiDB 层 Partial 和 Final 阶段的 worker 数量都设置为 16）：</p><img src="https://pic3.zhimg.com/v2-8be3186bc4261d00467ac4dc110e5b0b_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="113" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>总查询时间 8 分 37 秒，其中 <code class="inline">HashAgg</code> 执行时间约 1 分 4 秒。</p><p>并行计算时，Hash Aggregation 的计算速度提升约 16 倍。</p><p><br></p><p><i><b>更多 TiDB 源码阅读系列文章：</b></i><br></p><a href="http://link.zhihu.com/?target=https%3A//www.pingcap.com/blog-cn/%23%25E6%25BA%2590%25E7%25A0%2581%25E9%2598%2585%25E8%25AF%25BB" data-draft-node="block" data-draft-type="link-card" data-image="v2-60ab5bd867c2434d70c957a02a2169e1" data-image-width="1200" data-image-height="1200" data-image-size="ipico">博客</a><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
