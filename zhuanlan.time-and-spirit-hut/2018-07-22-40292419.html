<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>「Rust每日新闻」本周精选  •  第三期</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/40292419">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-10c6913d0bc44f08fed6d57e31af7e30_r.jpg" alt=""></div><blockquote>前言：<br>从2018年开始，我每天会花1个小时关注Rust社区动态，并且在<a href="https://link.zhihu.com/?target=http%3A//rust.cc">http://rust.cc</a>论坛、<a href="https://link.zhihu.com/?target=https%3A//t.me/rust_daily_news">tg channel</a>、GitHub都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。今天突然想到，在这个知乎专栏里，每周精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。</blockquote><h2><b>官方新闻：</b></h2><p><b>Clippy已经成为了Rustup的组件</b></p><p>使用起来更方便：</p><ul><li>rustup update</li><li>rustup component add clippy-preview</li><li>cargo clippy</li></ul><p><a href="https://internals.rust-lang.org/t/clippy-is-available-as-a-rustup-component/7967">📎 clippy is available as a rustup component</a></p><p><b>proc_macro稳定化分支PR已被合并</b></p><p>预计随着Rust stable 1.29版发布</p><p><a href="https://github.com/rust-lang/rust/pull/52081">rustc: Stabilize the `proc_macro` feature by alexcrichton · Pull Request #52081 · rust-lang/rust</a></p><p><b>Rust 2018 Edition 稳定化预览 2</b></p><p>Rust 1.29 将对应Edition preview 2版本，2018-08-02发布</p><p>预期NLL和新的模块系统变更能在 1.29中可用。</p><p><a href="https://internals.rust-lang.org/t/possible-stabilizations-for-2018-edition-preview-2/7983">Possible stabilizations for 2018 Edition Preview 2</a></p><p><b>Rust 1.27.2发布</b></p><p>修复了几个bug</p><p><a href="https://blog.rust-lang.org/2018/07/20/Rust-1.27.2.html">The Rust Programming Language Blog</a></p><p><b>Futures 0.3-alpha.1 发布</b></p><p>同时 async/await 已经使用了futures0.3 实现</p><p><a href="https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/19/futures-0.3.0-alpha.1.html">Futures 0.3.0-alpha.1</a></p><h2><b>官方博文：</b></h2><p><b>关于CTFE和类型系统的思考</b></p><p>CTFE（Compile-Time Function Evaluation），是指编译时函数求值，直白地说，是编译期执行代码。比如，知道了数组的大小如何在编译期计算其内存布局。</p><p>从Rust1.26以来Rust引进了CTFE，因此引发了一系列CTFE期间应该允许哪些操作的探讨。这篇文章是从类型系统角度对这些讨论的看法。</p><p>CTFE仅用于const的值或者是数组长度</p><code lang="rust">fn demo() {
  const X: u32 = 3 + 4; // CTFE
  let x: u32 = 4 + 3; // no CTFE 
}</code><p>CTFE需要考虑的问题（要点总结）：</p><ul><li> const安全，并非所有操作都可以在CTFE上下文使用 ，所以需要考虑以下问题</li></ul><p>        - CTFE必须是确定的，也就是说，不能存在歧义，否则会计算错误。</p><p>        - const fn 之所以存在，是为了满足在CTFE上下文中调用指定的函数。const fn 关键字可以让编译期识别，以便和普通的fn区分。</p><ul><li>const类型系统和健壮性</li></ul><p>       - const类型系统不允许CTFE调用非const函数</p><p>       - CTFE不能支持指针，因为在编译期需要合法有效的值，指针无法保证</p><ul><li> CTFE的正确性</li></ul><p>       - Rust中CTFE是由miri来执行的，miri是一个mir解释器，已经集成到了rustc中</p><p>       -  miri执行const上下文的代码，并且目前，拒绝原始指针的所有操作。但是未来还会计划修改miri来让它执行更多的操作。</p><p>      - CTFE的正确性是指编译期求值和运行时的表现完全一致。但是目前CTFE对于浮点数的计算比较困难。</p><ul><li>CTFE与Unsafe（假如扩展miri来支持unsafe，需要允许哪些操作？）</li></ul><p>      -  CTFE目前已经实现了以确定的方式支持内存分配</p><p>      -  允许引入 const-unsafe来操作原生指针，也就是说，把const上下文也分为safe和unsafe两个区域</p><ul><li>静态提升（Static Promotion）</li></ul><p>      -  比如，`fn make_a_3() -&gt; &amp;'static i32 { &amp;3 }` 返回值 包含的&amp;3会被提升为一个静态值，从而编译通过。</p><p>     - 应该只允许遵循const-well-type的值进行静态提升，比如`&amp;3`可以提升，而`*const T`不行</p><p>    - 要保证CTFE的正确性</p><p>看来，CTFE还有很长一段路要走啊，想利用miri来检测unsafe中的UB比我想象中困难</p><p><a href="https://www.ralfj.de/blog/2018/07/19/const.html">https://www.ralfj.de/blog/2018/07/19/const.html</a></p><p><br></p><p><b>官方：如何帮助测试Rust 2018 edition</b></p><p>文章包括：</p><ul><li>如何使用Rust 2018 edition</li><li>如何报告问题</li><li>测试哪些内容</li><li>使用Rustfix排除现有的crate</li><li>使用新的features，比如新的模块系统</li></ul><p><a href="https://www.ncameron.org/blog/how-to-help-test-the-2018-edition/">https://www.ncameron.org/blog/how-to-help-test-the-2018-edition/</a></p><p><b>嵌入式工作组报告 7</b></p><ul><li>建立WG twitter ：<a href="https://twitter.com/rustembedded">https://twitter.com/rustembedded</a></li><li>MUSL的libm（用于sin，cos等数学函数）移植工作开始，32个函数已经移植了26个。有望被归到Rust core中</li><li>针对thumbv6m和msp430目标的Atomic *{load，store} API可用</li><li>有两个多轴（Multirotor）飞控项目用上了Rust，基于 stm32f3 ，分别是[TrustFlight](<a href="https://github.com/korken89/trustflight_firmware">korken89/trustflight_firmware</a>)和[BetaFPV F3](<a href="https://betafpv.com/products/beta75-bnf-tiny-whoop-quadcopter">Beta75 BNF Micro Whoop Quadcopter</a>)</li><li>有两个项目致力于让树莓派上使用Rust更容易：[RustBerry](<a href="https://gitlab.com/AGausmann/rustberry">Adam Gausmann / rustberry</a>)和[rust_gpiozero](<a href="https://github.com/rahul-thakoor/rust_gpiozero">rahul-thakoor/rust_gpiozero</a>)</li><li>基于embedded-hal的嵌入式生态系统中又多了很多库</li></ul><p><a href="https://internals.rust-lang.org/t/the-embedded-working-group-newsletter-7/7959">https://internals.rust-lang.org/t/the-embedded-working-group-newsletter-7/7959</a></p><p><b>Podcast：Steve Klabnik 访谈： Rust与并发</b></p><p><a href="https://soundcloud.com/podcastcode/bonus-episode-steve-klabnik-on-concurrency-and-rust">https://soundcloud.com/podcastcode/bonus-episode-steve-klabnik-on-concurrency-and-rust</a></p><p><b>你好Content-O-Tron</b></p><p>Content-O-Tron是官方内容团队负责的一个社区计划</p><p>该计划准备寻找那些使用Rust并且经常写博客的人，帮助推动编写Rust相关博客和帮助传播、解决问题</p><p><a href="http://blog.community.rs/content-team/2018/07/16/hello-content-o-tron.html">The Rust Community Blog</a></p><h2><b>社区：博文与库</b></h2><p><b>呼吁：对流行crate中unsafe代码进行审计</b></p><p>捅出actix-web unsafe问题那哥们又发贴了，现在actix-web中的unsafe带来的不安全问题已经差不多修复了。但是有很多crate中还在用unsafe，使用unsafe本身很正常，但是想让unsafe中不产生UB，是严重依赖于开发者自身的水平和认知。所以，审核还是必须的。但最好是使用safe rust，以及如果不是必须要用到unsafe，那么可以强制使用#![forbid(unsafe_code)]属性禁用unsafe。</p><p>该作者分享了自己审核crate的一些方法：</p><p>- 主要是利用模糊测试（fuzzing）整体检查crate</p><p>- 检查它们是否出现内存错误</p><p>- 尝试使用safe代码替换unsafe而不影响性能</p><p>模糊测试相关工具：</p><p>- cargo-fuzz， <a href="https://github.com/rust-fuzz/cargo-fuzz">rust-fuzz/cargo-fuzz</a></p><p>- targets， <a href="https://github.com/rust-fuzz/targets">rust-fuzz/targets</a></p><p>模糊测试是发现错误的一种简单方式，但也不能保证百分百发现错误</p><p>作者考察了一些库，发现社区不太关心DoS拒绝服务安全漏洞，他在3个crate中找到相关漏洞，他提交了但是3周过去了都没有人去修复。</p><p><a href="https://www.reddit.com/r/rust/comments/8zpp5f/auditing_popular_crates_how_a_oneline_unsafe_has/">r/rust - Auditing popular crates: how a one-line unsafe has nearly ruined everything</a></p><p><b>dalek 0.7 vs  ring  0.13</b></p><p>dalek再次成为签名和验证最快的</p><p><a href="https://github.com/tendermint/signatory/commit/322118dc11ad160d7277224d141f8ce134226469">README.md: Update ed25519 benchmarks · tendermint/signatory@322118d</a></p><p>另外介绍下 signatory 库抽象了一层数字签名的统一接口，支持dalek、ring等作为底层加密库provider</p><p><a href="https://github.com/tendermint/signatory">tendermint/signatory</a></p><p><b>Artifact 2.0 发布</b></p><p>完全用Rust+wasm重写了整个项目</p><p>Artifact是一个简单，可链接和可跟踪的设计文档工具</p><p>文章里记录了他为什么要用Rust重写该项目</p><p><a href="https://vitiral.github.io/2018/07/16/artifact-2.0-rust-full-stack-web-and-cli-application.html">Artifact 2.0 Rust Full Stack Web And Cli Application</a></p><p><a href="https://github.com/vitiral/artifact">vitiral/artifact</a></p><p><b>PingCAP的raft库发布了0.3.1</b></p><p><a href="https://crates.io/crates/raft">https://crates.io/crates/raft</a></p><p><b>Ropey0.8版本发布</b></p><p>Ropey是一个utf8 文本缓冲区库，旨在成为文本编辑器的后备文本缓冲区</p><p>特色：性能好，内存开销底，Unicode安全</p><p><a href="https://github.com/cessen/ropey">cessen/ropey</a></p><p><b>安全高性能的av1编码器</b></p><p>AV1是下一代开放视频编码标准</p><p><a href="https://github.com/xiph/rav1e">xiph/rav1e</a></p><p><b>使用actix-web实现bind9 web API</b></p><p><a href="https://www.reddit.com/r/rust/comments/8z4yui/bind9_web_api_using_actixweb/">r/rust - BIND9 web API using actix-web</a></p><p><b>Rust实现的elias-fano编码</b></p><p>Elias-Fano(PEF)编码是基于分区的倒排索引压缩算法</p><p><a href="https://github.com/tomarrell/rust-elias-fano">tomarrell/rust-elias-fano</a></p><p><b>wayland-rs采用纯Rust实现</b></p><p>wayland-rs 是Wayland协议的Rust实现，弃用了之前的C绑定</p><p>Wayland是一个协议定义了如何与内核通讯、如何与Client通讯等，Linux桌面X Client/X server的替代者</p><p><a href="https://smithay.github.io/wayland-rs-v-0-21.html">Wayland-rs 0.21: Pure rust implementation</a></p><p><b>Handlebars-rust 发布1.0</b></p><p>Handlebars-rust 是一个模板库，1.0中改进了渲染大数据集的性能</p><p><a href="https://www.reddit.com/r/rust/comments/8zu1am/handlebarsrust_just_hit_10/">Handlebars-rust just hit 1.0 • r/rust</a></p><p><b>「嵌入式」让Rust和CC1101无线电模块一起玩耍</b></p><p><a href="https://dsvensson.github.io/posts/2018-07-13-Electrosmog-trapping-with-CC1101.html#article">https://dsvensson.github.io/posts/2018-07-13-Electrosmog-trapping-with-CC1101.html#article</a></p><p><b>为什么你应该经常练习防御性编程？</b></p><p>Rust只能保证所有权可以控制范围内的安全。作者举了一个逻辑错误的示例来说明这一点。</p><p>建议：</p><ul><li>写代码的时候要预估错误</li><li>识别事务中最基本的工作单元（比如某个任务的具体步骤、缩略图中的单个缩略图、下载器中的单个文件等），并为其定义可能产生的意外错误</li></ul><p><a href="http://blog.ssokolow.com/archives/2018/07/17/why-you-should-always-practice-defensive-programming/">http://blog.ssokolow.com/archives/2018/07/17/why-you-should-always-practice-defensive-programming/</a></p><p><b>使用Docker和K8s部署Rust</b></p><p><a href="https://www.fpcomplete.com/blog/2018/07/deploying-rust-with-docker-and-kubernetes">Deploying Rust with Docker and Kubernetes</a></p><p><b>《面向程序员的类型论》的学习笔记（Rust实现）</b></p><p>这笔记写的漂亮（虽然现在还没有啥内容），利用了Rust文档注释支持markdown这一点。可以关注一下，希望不要烂尾</p><p><a href="https://docs.rs/ctrs/1.0.1/ctrs/">ctrs - Rust</a></p><p><b>Ripgrep开启多行搜索功能</b></p><p><a href="https://www.reddit.com/r/rust/comments/905y36/multiline_search_is_coming_to_ripgrep/">r/rust - Multi-line search is coming to ripgrep</a></p><p><b>对Rust crate依赖的理论化研究</b></p><p>这个仓库里包含了一篇论文，研究了依赖的兼容性</p><p><a href="https://github.com/teiesti/compdep">teiesti/compdep</a></p><p><b>Arch： 使用rust和webassembly为3w个Led彩灯制作动画</b></p><p>Lin Clark在jsconf上面的演讲视频</p><p><a href="https://hacks.mozilla.org/2018/07/the-arch-using-rust-webassembly-to-animate-30k-colored-led-lights/">The Arch: Using Rust &amp; WebAssembly to animate 30k colored LED lights – Mozilla Hacks - the Web developer blog</a></p><p><b>Rust实现的区块链 exonum发布0.9</b></p><p><a href="https://github.com/exonum/exonum/blob/master/CHANGELOG.md">exonum/exonum</a></p><p><b>Rust实现的js打包神器</b></p><p>&gt; cargo install pax</p><p>&gt; pax index.js bundle.js</p><p><a href="https://pax.js.org/">The fastest JavaScript bundler in the galaxy</a></p><p><b>glitchcat让你超容易创建CLI 应用</b></p><p><a href="https://blog.kuviman.com/2018/07/20/glitchcat.html">https://blog.kuviman.com/2018/07/20/glitchcat.html</a></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
