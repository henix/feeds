<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Ad Infinitum!</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/32045442">原文</a></p>
<p>最近读了一篇paper，Duplication and Partial Evaluation，讲的是一门很。。奇怪的语言，</p><p>这门语言，可以大致想象是有无数个interpreter，一个stack着一个，interpret下一个，在最下，则是被解释的用户输入的代码。</p><p>你可以更改各种built in function，或者打印出来。比如说，你可以更改第1层（第0层为用户代码，第n+1层解释第n层代码）的apply，输入值print一次，输出值print一次，这样就实现了简陋debugger了。又或者对第二层解释器这样做，运行代码的时候就知道内部执行了啥</p><p>实现方法自然不能靠构造无限个interpreter，所以要先上laziness，按需增加，然后任何时刻，都有一个被解释的解释器去解释当下代码，然后有个被编译的解释器解释前一个解释器，这样就只有两轮。但是，这样，如果你更改n+2的代码，不会由n+1暴露到n层（换句话说n层看不出有啥区别），因为n层的时候，n+1层是被预编译的解释器执行，只有在n+1层看的到。这样，就顶多是两个编译器的开销。</p><p>‘顶多’，双重编译很疼，于是用了下Partial Evaluation，手动优化成一个编译器。</p><p>什么鬼啊这是。</p><p>可以在<a href="http://io.livecode.ch/learn/readevalprintlove/black">The reflective language Black</a>试试看。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
