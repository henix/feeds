<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>柯里化的前生今世（十一）：Pure and Lazy</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34200898">原文</a></p>
<h2><b>语言的作用</b></h2><p>语言的作用是为了交流想法，描述概念，<br>当前使用了什么语言，取决于我们有什么样的需要。</p><p>为了理解词法作用域，闭包，和continuation，<br>前文中，我们借助了Racket。</p><p>现在，为了理解代数数据类型（<a href="https://wiki.haskell.org/Algebraic_data_type">algebraic data type</a>），多态（<a href="https://wiki.haskell.org/Polymorphism">polymorphism</a>），参数化类型（parameterized type），类型类（<a href="https://en.wikipedia.org/wiki/Type_class">type class</a>），我们要学习Haskell了。</p><p>编程也是如此，它是关于思想的，<br>编程语言只是描述这种思想的工具罢了。</p><img src="https://pic1.zhimg.com/v2-a5010841720f3d42440b581d31ba2c31_r.jpg" data-caption="" data-size="normal" data-rawwidth="645" data-rawheight="309"><h2><b>非严格语义（non-strict semantics）</b></h2><p>在Haskell规范中，并没有要求使用惰性求值策略（<a href="https://en.wikipedia.org/wiki/Evaluation_strategy">evaluation strategy</a>），<br>只是规定它是一种非严格的语言（non-strict language），<br>具体的求值策略取决于实现。</p><p>那么，什么才能叫做non-strict呢？<br>non-strict与lazy有什么关系呢？<br>还要从数学上函数的严格性（strictness）说起。</p><p>程序中的function与数学函数之间的关系，<br>是指称语义中的内容。（指称语义是形式语义的一种，它将每一段代码，与一个数学对象相对应，用来研究程序的含义。</p><p>在数学上，如果一个函数对定义域中的某些参数，没有定义值，<br>就称为该函数为部分函数（<a href="https://en.wikipedia.org/wiki/Partial_function">partial function</a>）。</p><img src="https://pic3.zhimg.com/v2-28a0a72e4322c186996a60889cd3f0b0_r.jpg" data-caption="" data-size="normal" data-rawwidth="200" data-rawheight="200"><p>程序中的function，对应着数学上的部分函数。</p><p>此外，程序中某一类型的全体值，也不能简单的对应于数学上的集合，<br>例如，程序中的全体整数类型的值，并不对应于整数集，<br>因为返回整型值的function，取某些参数时，程序可能不会终止。</p><p>为了给这样的function和返回值找到指称，<br>我们给每个集合增加一个新的值：<code class="inline">⊥</code>，读作bottom。</p><code lang="text">f(⊥) = ⊥</code><p>一个数学函数，如果参数是<code class="inline">⊥</code>，那么结果就一定是<code class="inline">⊥</code>，<br>这样的函数称为严格函数（<a href="https://en.wikipedia.org/wiki/Strict_function">strict function</a>）。</p><p>反之，如果参数包含<code class="inline">⊥</code>，但是结果不一定是<code class="inline">⊥</code>，<br>这样的函数就称为非严格函数（non-strict function）。</p><p>如果程序语言中function的指称语义是非严格函数，<br>那么这样的语言，就称为非严格的语言（non-strict language）。</p><p><b>注：</b><br>严格性是指称语义中的概念，而求值是操作语义中的概念。<br>并且指称语义对于操作语义具有可靠性（soundness），<br>即，如果一个表达式根据操作语义求值为另一个，那么，它们必定具有相同的指称。</p><p>因此，对于non-strict language，求值策略可能并不唯一，<br>对Haskell来说，GHC是最流行的编译器，<br>它使用了惰性求值（<a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>）。</p><p>在没有歧义的情况下，人们常用lazy暗指non-strict，<br>lazy更直观更有利于沟通。</p><h2><b>引用透明性</b></h2><blockquote>An expression is said to be referentially transparent if it can be replaced with its corresponding value without changing the program's behavior.</blockquote><p>即，引用透明性（<a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>）指的是，<br>程序中的表达式总是可以用它的值来代替。</p><p>而程序中的纯函数（<a href="https://en.wikipedia.org/wiki/Pure_function">pure function</a>），指的是，<br>（1）这个函数对相同参数总是输出相同结果<br>（2）这个函数没有副作用（side effect）<br>因此，纯函数具有引用透明性。</p><p>此外，语言采用了惰性求值，意味着表达式的求值方式是按需确定的，<br>所以，依靠副作用来得到计算结果就不可行了，<br>我们不知道计算在什么时候发生。</p><p>因此，一旦语言拥抱了惰性求值，就不得不保证引用透明性，<br>反之则不一定，具有引用透明性的语言，可能不必是惰性求值的。</p><p>至于，纯函数是不是解决问题的最佳方式，目前尚无定论，<br>但至少它是为了追求优雅性，对通常编程方式的一种挑战。</p><h2><b>历史上的纯函数式惰性语言</b></h2><p>在20世纪70年代末，Gerry Sussman和Guy Steele发明了Scheme，它是Lisp的一个方言，与lambda演算很相似，并支持了词法作用域。<br>几乎同时，Robin Milner为了进行自动定理证明发明了ML，其中使用了多态类型系统。<br>但是<a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>和<a href="https://en.wikipedia.org/wiki/ML_(programming_language)">ML</a>都是基于严格语义的语言（strict language）。</p><p>到了80年代，人们燃起了对非严格语义的（non-strict），或者说是按需求值的（call-by-need）函数式语言的研究热情。<br>这方面的研究理所当然的吸引了很多人，首先，函数式语言简单而优雅，其次，惰性（lazy）与引用透明性有关，并且还可以处理无穷长的数据结构（infinite data structure）。<br>在80年代中期，很多研究者都想设计实现一个纯函数式的（pure）惰性语言，Miranda和Lazy ML是其中的两个例子。</p><p>1987年波特兰FPCA'87会议之后，与会者想发明一种尚未命名的新语言，<br>其实一开始，人们想从一门现有的语言开始，逐渐发展迭代，比如说，使用当时最成熟的<a href="https://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a>。<br>Miranda是David Turner的公司Research Software Limited开发的一门语言，它是惰性求值的，包含代数数据类型，使用了<a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner类型系统</a>，从1985年起用于商业中。Miranda有很好用户接口，对实现的支持良好，还有大量的教材。</p><p>可是，与David Turner沟通后，他拒绝了这件事。<br>我们想要一门用于研究语言特性的语言，因此我们决定任何人都可以扩展和修改语言本身，重新实现或者发行。但是David Turner想维持一份语言规范，让语言具有最好的可移植性，他不想让Miranda出现各种不同的方言。</p><p>于是，Haskell的故事就这样开始了。</p><img src="https://pic2.zhimg.com/v2-10ddadd8d83fa7a05cb29739a4d98378_r.jpg" data-caption="" data-size="normal" data-rawwidth="700" data-rawheight="353"><hr><h2><b>参考</b></h2><p><a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf">A History of Haskell</a> <br><a href="https://wiki.haskell.org/Non-strict_semantics">Non-strict semantics</a> <br><a href="http://www.vex.net/~trebla/haskell/lazy.xhtml">Lazy Evaluation of Haskell</a> <br><a href="https://book.douban.com/subject/1761918/">Foundations for Programming Languages</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
