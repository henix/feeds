<p></p><figure><noscript><img src="https://pic2.zhimg.com/v2-23bc477b007ec02c513c469fdf4f7a35_b.jpg" data-caption="" data-size="normal" data-rawwidth="700" data-rawheight="409" class="origin_image zh-lightbox-thumb" width="700" data-original="https://pic2.zhimg.com/v2-23bc477b007ec02c513c469fdf4f7a35_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-23bc477b007ec02c513c469fdf4f7a35_b.jpg" data-caption="" data-size="normal" data-rawwidth="700" data-rawheight="409" class="origin_image zh-lightbox-thumb lazy" width="700" data-original="https://pic2.zhimg.com/v2-23bc477b007ec02c513c469fdf4f7a35_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-23bc477b007ec02c513c469fdf4f7a35_b.jpg"></figure><h2><b>1. 一致性</b></h2><p><a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%25E7%259B%25B4%25E8%25A7%2589%25E4%25B8%25BB%25E4%25B9%2589%25E9%2580%25BB%25E8%25BE%2591" class=" wrap external" target="_blank" rel="nofollow noreferrer">直觉主义逻辑</a>不承认经典逻辑中的<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%25E6%258E%2592%25E4%25B8%25AD%25E5%25BE%258B" class=" wrap external" target="_blank" rel="nofollow noreferrer">排中律</a>——对于任意命题P，或者P真，或者¬P为真。<br>但是和经典逻辑一样，接受<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%2597%25A0%25E7%259F%259B%25E7%259B%25BE%25E5%25BE%258B" class=" wrap external" target="_blank" rel="nofollow noreferrer">无矛盾律</a>——任何命题P，P和¬P不能同时为真。</p><figure><noscript><img src="https://pic3.zhimg.com/v2-5166b84a7f111863cd32d2d20d9a0b22_b.jpg" data-caption="" data-size="normal" data-rawwidth="330" data-rawheight="328" class="content_image" width="330"></noscript><img src="https://pic3.zhimg.com/v2-5166b84a7f111863cd32d2d20d9a0b22_b.jpg" data-caption="" data-size="normal" data-rawwidth="330" data-rawheight="328" class="content_image lazy" width="330" data-actualsrc="https://pic3.zhimg.com/v2-5166b84a7f111863cd32d2d20d9a0b22_b.jpg"></figure><p>无矛盾的逻辑系统，称为<b>一致的</b>，或者协调的。<br>一个有用的逻辑系统不能包含矛盾。</p><h2><b>2. 完备性</b></h2><p>上文关于一致性的讨论中，我们并没有区分逻辑公式的<b>证明</b>和<b>语义</b>，<br>所谓<b>证明</b>，就是一串符号推导序列，从一些合法的公式经过一步或多步，推导出另一些合法的公式。</p><p>而公式的<b>语义</b>则是人为选择的，人们倾向于为公式选择<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%258F%25AF%25E9%259D%25A0%25E6%2580%25A7%25E5%25AE%259A%25E7%2590%2586" class=" wrap external" target="_blank" rel="nofollow noreferrer">可靠的</a>语义，<br>即，所有可证的公式，在语义上都为真。</p><figure><noscript><img src="https://pic4.zhimg.com/v2-e72e4360c7cf2b132e164c78586abd63_b.jpg" data-caption="" data-size="normal" data-rawwidth="361" data-rawheight="283" class="content_image" width="361"></noscript><img src="https://pic4.zhimg.com/v2-e72e4360c7cf2b132e164c78586abd63_b.jpg" data-caption="" data-size="normal" data-rawwidth="361" data-rawheight="283" class="content_image lazy" width="361" data-actualsrc="https://pic4.zhimg.com/v2-e72e4360c7cf2b132e164c78586abd63_b.jpg"></figure><p>但是可靠性并不意味着<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25AE%258C%25E5%25A4%2587%25E6%2580%25A7" class=" wrap external" target="_blank" rel="nofollow noreferrer">完备性</a>，<br>即，所有语义上为真的命题，并不一定总是可证的。</p><h2><b>3. 第一第二不完备性定理</b></h2><p>人们在研究逻辑系统的时候，对<b>一致性</b>和<b>完备性</b>有着很强烈的追求，<br>谁都希望自己发明的逻辑系统中没有矛盾，而且所有为真的命题都可证。</p><p>但是1931年，<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25BA%2593%25E5%25B0%2594%25E7%2589%25B9%25C2%25B7%25E5%2593%25A5%25E5%25BE%25B7%25E5%25B0%2594" class=" wrap external" target="_blank" rel="nofollow noreferrer">哥德尔</a>发现了两个定理，粉碎了这个幻想，</p><blockquote>任何相容的形式系统，只要蕴涵皮亚诺算术公理，就可以在其中构造在体系中不能被证明的真命题，因此通过推演不能得到所有真命题（即体系是不完备的）。<br>—— <a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%25E5%2593%25A5%25E5%25BE%25B7%25E5%25B0%2594%25E4%25B8%258D%25E5%25AE%258C%25E5%25A4%2587%25E5%25AE%259A%25E7%2590%2586" class=" wrap external" target="_blank" rel="nofollow noreferrer">哥德尔第一不完备性定理</a></blockquote><p>哥德尔定理，给出了符号推导方法的局限性，<br>如果要求系统无矛盾，那么某些事实可能是<b>不可证</b>的。</p><figure><noscript><img src="https://pic4.zhimg.com/v2-56f5fc0763a97cb114b3ec0f4b66ed13_b.jpg" data-caption="" data-size="normal" data-rawwidth="518" data-rawheight="353" class="origin_image zh-lightbox-thumb" width="518" data-original="https://pic4.zhimg.com/v2-56f5fc0763a97cb114b3ec0f4b66ed13_r.jpg"></noscript><img src="https://pic4.zhimg.com/v2-56f5fc0763a97cb114b3ec0f4b66ed13_b.jpg" data-caption="" data-size="normal" data-rawwidth="518" data-rawheight="353" class="origin_image zh-lightbox-thumb lazy" width="518" data-original="https://pic4.zhimg.com/v2-56f5fc0763a97cb114b3ec0f4b66ed13_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-56f5fc0763a97cb114b3ec0f4b66ed13_b.jpg"></figure><p>此外，<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%25E5%2593%25A5%25E5%25BE%25B7%25E5%25B0%2594%25E4%25B8%258D%25E5%25AE%258C%25E5%25A4%2587%25E5%25AE%259A%25E7%2590%2586" class=" wrap external" target="_blank" rel="nofollow noreferrer">哥德尔第二不完备性定理</a>指出，</p><blockquote>任何逻辑自洽的形式系统，只要蕴涵皮亚诺算术公理，它就不能用于证明它本身的相容性。</blockquote><p>好吧，连自身的一致性，也不能在系统之内证明了。</p><blockquote>所以，在软件开发过程中，检查一个软件系统是否符合设计要求，所使用的方法就是对它进行测试，在这个软件系统之外进行证明。</blockquote><h2><b>4. 排除错误</b></h2><p>在使用编程语言的时候，我们都或多或少的接触过<b>类型</b>这个概念。<br>类型系统的一个重要作用就是，通过<b>类型检查</b>排除可能会发生的错误。</p><p>和逻辑系统一样，如果类型系统保证所有<b>良类型</b>的程序都<b>按预期</b>正常表现，<br>我们就说它是<b>可靠的</b>，<br>这是一个很好的性质，<b>如果A成立，则B成立</b>，建立了<b>符号</b>和<b>行为</b>之间的联系。</p><figure><noscript><img src="https://pic1.zhimg.com/v2-dfc743dfa2a01282e4b5f3ffacdba948_b.jpg" data-caption="" data-size="normal" data-rawwidth="284" data-rawheight="90" class="content_image" width="284"></noscript><img src="https://pic1.zhimg.com/v2-dfc743dfa2a01282e4b5f3ffacdba948_b.jpg" data-caption="" data-size="normal" data-rawwidth="284" data-rawheight="90" class="content_image lazy" width="284" data-actualsrc="https://pic1.zhimg.com/v2-dfc743dfa2a01282e4b5f3ffacdba948_b.jpg"></figure><p>不幸的是，程序即使经过了类型检查，<br>也保证不了那些<b>不在预期范围之内</b>的特性，<br>即，<b>如果A成立，则C是否成立，我们是不确定的。</b></p><figure><noscript><img src="https://pic1.zhimg.com/v2-2225c9f3d0cead3e951c6c5dffd65078_b.jpg" data-caption="" data-size="normal" data-rawwidth="260" data-rawheight="100" class="content_image" width="260"></noscript><img src="https://pic1.zhimg.com/v2-2225c9f3d0cead3e951c6c5dffd65078_b.jpg" data-caption="" data-size="normal" data-rawwidth="260" data-rawheight="100" class="content_image lazy" width="260" data-actualsrc="https://pic1.zhimg.com/v2-2225c9f3d0cead3e951c6c5dffd65078_b.jpg"></figure><p>例如，对除法表达式进行简单的类型检查，能保证除法操作数的类型合法，<br>但无法避免除<code>0</code>错误，<br>这可能需要更强大的类型系统才行。</p><p>另一方面，上面提到良类型的程序，预期会表现正常。<br>但是，类型不合法的程序，却<b>未必</b>会出错。<br><b>如果A不成立，那么B是否成立也是不确定的。</b></p><figure><noscript><img src="https://pic2.zhimg.com/v2-de916fd575c22e18a201d6df9256cf5d_b.jpg" data-caption="" data-size="normal" data-rawwidth="302" data-rawheight="102" class="content_image" width="302"></noscript><img src="https://pic2.zhimg.com/v2-de916fd575c22e18a201d6df9256cf5d_b.jpg" data-caption="" data-size="normal" data-rawwidth="302" data-rawheight="102" class="content_image lazy" width="302" data-actualsrc="https://pic2.zhimg.com/v2-de916fd575c22e18a201d6df9256cf5d_b.jpg"></figure><p>这两件事和<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%2581%259C%25E6%259C%25BA%25E9%2597%25AE%25E9%25A2%2598" class=" wrap external" target="_blank" rel="nofollow noreferrer">停机问题</a>是一脉相承的，<br>对于图灵完备的编程语言来说，要想判定一段程序的所有运行时特征，唯一的办法<b>运行它</b>，仅依赖静态检查是行不通的。</p><blockquote>不存在通用的过程，来判断一段程序是否停机。</blockquote><h2><b>5. Believe the type</b></h2><p>那么我们还要相信类型吗？<br><b>要相信。</b></p><figure><noscript><img src="https://pic1.zhimg.com/v2-9f2137b50469a4455a8cf4a323e8f904_b.png" data-caption="" data-size="normal" data-rawwidth="180" data-rawheight="127" class="content_image" width="180"></noscript><img src="https://pic1.zhimg.com/v2-9f2137b50469a4455a8cf4a323e8f904_b.png" data-caption="" data-size="normal" data-rawwidth="180" data-rawheight="127" class="content_image lazy" width="180" data-actualsrc="https://pic1.zhimg.com/v2-9f2137b50469a4455a8cf4a323e8f904_b.png"></figure><p>我们要相信类型系统，可以帮我们排除那些<b>已被证明的</b>错误。<br>相信类型系统，能指导我们设计出<b>一致的</b>软件。</p><blockquote>Show me your type, and I'll show you your language.</blockquote><p>然而，类型信息却不等同于文档，它只能提供一些辅助信息，<br>它不是用来<b>传递知识</b>的，真是如有雷同，实属巧合，<br>这恰恰反映了在知识传递方面，所做的工作还不够。</p><h2><b>结语</b></h2><p>本文从逻辑系统出发，介绍了人们经常提及的一些特性，<br>包括一致性，完备性，可靠性，进而还介绍了哥德尔不完备性定理。</p><p><b>类型检查</b>可看做是一种逻辑推导，<br>它可以排除某些<b>已知的</b>错误，但也不是万能的。</p><p>要想写出高质量的代码，除了在设计方面多花一些心思之外，<br>更好的办法就是对它进行<b>测试</b>，不论是静态检查还是运行时检查，<br>不论是自动化的单元测试，还是<b>人工测试</b>。</p><p>完全依赖<b>设计</b>和<b>检查</b>是行不通的，有时候唯一可以发现错误的方法就是<b>运行</b>它。</p><hr><h2><b>参考</b></h2><p><a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/1513387/" class=" wrap external" target="_blank" rel="nofollow noreferrer">计算机科学中的现代逻辑学</a><br><a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/1230394/" class=" wrap external" target="_blank" rel="nofollow noreferrer">离散数学教程</a><br><a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/2364517/" class=" wrap external" target="_blank" rel="nofollow noreferrer">数理逻辑</a><br><a href="http://link.zhihu.com/?target=http%3A//homepage.divms.uiowa.edu/%7Etinelli/classes/185/Fall06/notes/cardelli-95.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">Type Systems</a><br><a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/27004230/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Type-driven Development with Idris</a></p><p><a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%25E7%259B%25B4%25E8%25A7%2589%25E4%25B8%25BB%25E4%25B9%2589%25E9%2580%25BB%25E8%25BE%2591" class=" wrap external" target="_blank" rel="nofollow noreferrer">直觉主义逻辑</a><br><a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%25E6%258E%2592%25E4%25B8%25AD%25E5%25BE%258B" class=" wrap external" target="_blank" rel="nofollow noreferrer">排中律</a><br><a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%2597%25A0%25E7%259F%259B%25E7%259B%25BE%25E5%25BE%258B" class=" wrap external" target="_blank" rel="nofollow noreferrer">无矛盾律</a><br><a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%258F%25AF%25E9%259D%25A0%25E6%2580%25A7%25E5%25AE%259A%25E7%2590%2586" class=" wrap external" target="_blank" rel="nofollow noreferrer">可靠性</a><br><a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25AE%258C%25E5%25A4%2587%25E6%2580%25A7" class=" wrap external" target="_blank" rel="nofollow noreferrer">完备性</a><br><a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%25E5%2593%25A5%25E5%25BE%25B7%25E5%25B0%2594%25E4%25B8%258D%25E5%25AE%258C%25E5%25A4%2587%25E5%25AE%259A%25E7%2590%2586" class=" wrap external" target="_blank" rel="nofollow noreferrer">哥德尔不完备性定理</a><br><a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%2581%259C%25E6%259C%25BA%25E9%2597%25AE%25E9%25A2%2598" class=" wrap external" target="_blank" rel="nofollow noreferrer">停机问题</a><br></p><hr><p>下一篇：<a href="https://zhuanlan.zhihu.com/p/40453858" class="internal">设计模式奏鸣曲（九）：软件设计者的自身修养</a></p>