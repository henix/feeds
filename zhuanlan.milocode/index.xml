<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Milo的编程</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sun, 29 Sep 2019 20:47:48 +0800</lastBuildDate>
<item>
<title>近况、出版、道合</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2019-09-26-83349497.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83349497&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-970c00caee727b54c828400d5b218404_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;过去一个月忙著做IEG各级游戏客户端的通道评审、实习生评审、校园招聘，还去了一周大阪团建，今天我所在的部门（魔方工作室群）终于完成了到新建大楼的搬迁，终于整顿下来，想写一点东西。&lt;/p&gt;&lt;p&gt;首先，《&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/34778851/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;腾讯游戏开发精粹&lt;/a&gt;》出版了！一年多前，我发起这个项目，希望同事能有一个对外分享技术的途径。这个项目从成立编委会、规划、招稿、摘要评审、编辑、排版、管理层审核、出版，经历了不少困难，最终能看到实体的出版物，有种金石为开的感觉。第一次做这样的工作，有很多不足之处，期待大家的反馈。如果顺利，希望能继续有第二册，在内容范围、形式上也可以再作创新，例如考虑对业界学界公开招稿，这方面也期待有读者提供意见。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf2ce3cdcda9fd91c32f1633bac014ce_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;591&quot; data-rawheight=&quot;783&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;591&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf2ce3cdcda9fd91c32f1633bac014ce_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf2ce3cdcda9fd91c32f1633bac014ce_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;591&quot; data-rawheight=&quot;783&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;591&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf2ce3cdcda9fd91c32f1633bac014ce_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bf2ce3cdcda9fd91c32f1633bac014ce_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个出版相关的「喜讯」是，《游戏引擎架构》&lt;b&gt;第二版&lt;/b&gt;终于完成编辑排版，快将出版。两周前写的译序，简直就是一篇忏悔录，先睹为快：&lt;/p&gt;&lt;blockquote&gt;不知不觉，本书原版第1版已出版十年。十年前 iPhone 3GS 面世，《愤怒的小鸟》在同年上架 Apple Store。随着智能手机的渗透率不断增长，全球范围内移动游戏极速超越PC和游戏机，成为最多用户及最高收入的游戏平台。我开始翻译本书时，正任职于麻辣马开发PC／游戏机平台游戏，之后幸运地在2011年前加入腾讯，从事游戏引擎技术的研发工作，也亲历了这个浪潮。&lt;br/&gt;2013年国内《天天爱消除》和《天天酷跑》这两款2D手游成为行业爆款，而我在当年第1版译序中写下〝还可预料，现时单机／游戏机的一些较高级的架构及技术，将在不远的未来着陆移动终端平台。〞那个时候，不少人认为手机只适合这些消闲游戏，也许不需要前沿技术。然而，随后各种游戏类型陆续爆发，MOBA的王者属《王者荣耀》，ACT有《火影忍者》，FPS有《穿越火线》以至本年的《和平精英》。我追索这十多年的游戏硬件发展，虽然移动平台的性能和顶级游戏机有稳定十年的差距，但至少在架构和技术上，移动平台的游戏已逐渐贴近前沿。&lt;br/&gt;在端游时代，游戏项目的技术选型多姿多采，有选择自研引擎的（如《天涯明月刀》的QuickSilver引擎），也有选择各种商业和开源的游戏引擎。但在2013-17年期间，除了网易继续自研引擎，国内大部分手游项目都选择了 Unity。Unity引擎具有非常友好的工具及编程环境，它采用的 C# 语言也减轻了开发者的负担，令游戏团队能非常高效地生产。但与此同时，它的黑盒性质也极大地影响了这一代游戏程序员。这个情况在我做公司内部晋级评审时深有感受：以往一些工作可能需要深入了解技术原理，并寻找最适合项目的最优方案，然后把技术从无到有去实现出来，过程中对人员的技术成长很有帮助；而面对黑盒，很多时候是通过猜想个中的实现，再尝试以打补丁方式去解决问题，更少机会完整地实现一些技术，对于较底层的开发能力更易缺失。但当手游竞争越趋激烈，游戏开发周期从三个月上升至三年，开发团队的技术能力也变得越重要。2015年 Unreal 提供源代码给所有人，并且大力增强移动平台的支持，开始成为手游项目的另一可行选项。如果仅考虑对开发人员的成长，我会建议尽量使用具源代码的工具，并多了解它内部如何运作，在适当时候作出修改。期待我们能继续提升技术水平，并发挥创新能力，进一步提升游戏的品质。&lt;br/&gt;在第1版译本出版以来，我收到大量读者反馈，一些错漏之处也在每次印刷中修正。不时有朋友告诉我，他们因为读这本译作而对游戏引擎技术产生兴趣，最后还加入到这个行业之中，身为译者也感到欣慰。2014 年我在美国三藩市游戏开发大会遇到原作者 Jason Gregory，也是令人兴奋的时刻。但对于一直期待第2版的朋友，面对以年为单位的等待，本人实在难辞其咎。虽然百词莫辩，也必须作出点交代。除了繁忙的工作，在数年里我花了不少工余时间在知乎上回答问题及写技术文章，学习并实践多方面的兴趣，也在近不惑之年才开始注重身体健康而去系统锻鍊。由于个人的能力及时间有限，我也希望能和其他人合作去推动知识分享，例如刚出版的《腾讯游戏开发精粹》便是我通过腾讯游戏学院发起的项目，而另一本和同事合译作品《基于物理的建模与动画（暂名）》希望也能尽快与大家见面。&lt;br/&gt;由于有些读者已读过第1版，所以我特意在新增的章节标题中加入剑标符，以方便挑选阅读。最后，期望这本书能引发你对游戏技术的兴趣，在未来可以玩到你的游戏作品。&lt;/blockquote&gt;&lt;p&gt;回想到我来腾讯 IEG 也有 8 年了，前 4 年在研发部，而后 4 年在魔方。2015年我觉得和一线开发有点距离，想重新投入产品的相关技术研发。我选择了魔方，主要是考虑到他之前的产品以页游为主，在技术上的积累较少，我可能可以帮助他提升技术水平。刚进去的时候，我们的引擎组是一个项目中的小组，只有几人。&lt;/p&gt;&lt;p&gt;2015年上线了魔方第一款3D的射击手游《独立防线》，这是一个商业上不成功的项目，但累积了3D的制作经验和FPS团队。而翌年魔方上线了爆款动作手游《火影忍者》，这个 IP 项目的商业成功，令工作室群有更多空间去投入更大型的研发项目。我们引擎组的工作也逐部扩展至多个项目的引擎技术支持，性能优化，技术攻关，各式各样。这个研发阶段非常漫长，再加上政策的影响，魔方今年才继《火影忍者》后有至少 4 款新游戏上线，包括《妖精的尾巴》、《王牌战士》、《一人之下》、《战歌竞技场》。&lt;/p&gt;&lt;p&gt;我的小组在这4年中，除了参与这些项目的技术攻关及性能优化，也主导一些技术要求更高的预研项目。同时，我们也有机会尝试研发一些创新的游戏引擎技术。引擎组也变成了引擎中心，人数从几个人涨到了 25 人。曾经可以为每个成员亲手做生日蛋糕，现在也变得不太可能了。&lt;/p&gt;&lt;p&gt;我觉得魔方还是需要一直蜕变，除了令自己和同事成长，也需要有新血，才能做更多有趣的事情。相对于攻关技术难题，招聘是令我更烦恼的任务。由于游戏业务的持续增长，公司内外的人才竞争都很厉害。&lt;/p&gt;&lt;p&gt;如果你已从事游戏业界一段日子，对游戏技术有追求，希望来和我共事，可以直接联系我。我们现在招一些比较专门的社招职位：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075140203122688&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-UE4客户端开发工程师（UE4 Client-side Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1151807055762296832&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏AI系统开发Leader（Game AI System Leader）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1151809644675469312&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏AI系统开发工程师（Game AI System Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075140727410688&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏引擎开发工程师（Game Engine Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075140417032192&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏图形开发工程师（Game Graphics Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075140580610048&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏物理开发工程师（Game Physics Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075140928737280&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏工具开发工程师（Game Tool Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/jobdesc.html%3FpostId%3D1177075141037789184&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-游戏客户端开发运营工程师（Game Client-side DevOps Engineer）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//careers.tencent.com/zh-cn/jobdesc.html%3FpostId%3D1177075141167812608&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;28937-程序化生成技术美术（Procedural Content Generation Technical Artist）&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;另外，如果你是2020/21年毕业、对游戏开发有热情的本硕博学生，也可把 CV &lt;a href=&quot;mailto:miloyip@tencent.com&quot;&gt;电邮给我&lt;/a&gt;。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2019-09-26-83349497</guid>
<pubDate>Thu, 26 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>重画了儿子的作品</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2019-03-23-60126751.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60126751&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-22b7dcc730b3bb3bc038f8f40fd13924_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;前几天在《&lt;a href=&quot;https://www.zhihu.com/question/315712281/answer/626294464&quot; class=&quot;internal&quot;&gt;为什么图形学人才这么少？&lt;/a&gt;》的回答中，引用了儿子2017年9月用 Scratch 画的一幅作品，当时还猜不到他是怎么画的。后来评论中 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0c708d923f8fb00142e1f25cdd4951d9&quot; data-hash=&quot;0c708d923f8fb00142e1f25cdd4951d9&quot; data-hovercard=&quot;p$b$0c708d923f8fb00142e1f25cdd4951d9&quot;&gt;@王赟 Maigo&lt;/a&gt; 试出了可用&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28x%2C+y%29+%3D+%7Cx%7C%5E3%2B%7Cy%7C%5E3%5Ctag%7B1%7D&quot; alt=&quot;f(x, y) = |x|^3+|y|^3\tag{1}&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;再通过取模并用色相（hue）显示，便可获得类似的图。&lt;/p&gt;&lt;p&gt;然后我搜到 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.scratch-wiki.info/wiki/Pen_Color_%28value%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Scratch 的 hue 范围&lt;/a&gt; 是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B0%2C+200%5D&quot; alt=&quot;[0, 200]&quot; eeimg=&quot;1&quot;&gt; ，所以应该是简单地取模 200 的结果。那么就用 C 语言实现一下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&quot;svpng.inc&quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#define W 800&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define H 800&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fabs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; 
                              &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fabs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;360&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// hsv2rgb with s = v = 1&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;svpng&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;luasplot.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;得到接近的结果：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-13d684a0f03362862299d725aaeba48e_b.jpg&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;800&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;800&quot; data-original=&quot;https://pic3.zhimg.com/v2-13d684a0f03362862299d725aaeba48e_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-13d684a0f03362862299d725aaeba48e_b.jpg&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;800&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;800&quot; data-original=&quot;https://pic3.zhimg.com/v2-13d684a0f03362862299d725aaeba48e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-13d684a0f03362862299d725aaeba48e_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;实际上 (1) 是 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Norm_%28mathematics%29%23p-norm&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;p-norm&lt;/a&gt; 去除了开 p 次方的版本，形状也是相似的。我在《&lt;a href=&quot;https://www.zhihu.com/question/39088212/answer/476010539&quot; class=&quot;internal&quot;&gt;如何用C语言画一个蘑菇？&lt;/a&gt;》介绍过 p-norm，却没联想到。&lt;/p&gt;&lt;p&gt;设 p = 4 可得这个效果：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ea8bb06525e2d63bed4c774dbff7924c_b.jpg&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;800&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;800&quot; data-original=&quot;https://pic1.zhimg.com/v2-ea8bb06525e2d63bed4c774dbff7924c_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ea8bb06525e2d63bed4c774dbff7924c_b.jpg&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;800&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;800&quot; data-original=&quot;https://pic1.zhimg.com/v2-ea8bb06525e2d63bed4c774dbff7924c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ea8bb06525e2d63bed4c774dbff7924c_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;计算机图形学有趣么？&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2019-03-23-60126751</guid>
<pubDate>Sat, 23 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>常在我心</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2019-02-13-56640030.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56640030&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b845dab3b9ef95ab4a4ffe5a4750e96f_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1079126838621544448&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;常在我心&quot; data-poster=&quot;https://pic2.zhimg.com/v2-b7e6879086e9544c5ef5d32f077ec05a.jpg&quot; data-lens-id=&quot;1079126838621544448&quot;&gt;              &lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-b7e6879086e9544c5ef5d32f077ec05a.jpg&quot;&gt;              &lt;span class=&quot;content&quot;&gt;                &lt;span class=&quot;title&quot;&gt;常在我心&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;                &lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1079126838621544448&lt;/span&gt;              &lt;/span&gt;            &lt;/a&gt;            &lt;p&gt;这是一个用 HTML/JS 实现的光滑粒子流体动力学（smoothed particle hydrodynamics, SPH） [1][2][3] 实时 Demo，它使用 HTML5 Canvas 渲染。&lt;/p&gt;&lt;p&gt;改变文字的方法是，打开 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//miloyip.com/misc/sv2019.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;miloyip.com/misc/sv2019&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;，然后在 URL 里输入（当然&lt;code&gt;&quot;知乎&quot;&lt;/code&gt;可改做其他文字）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;javascript:b64EncodeUnicode(&quot;知乎&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;便会显示一个编码后的文本：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;55+l5LmO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;把这个文本加在 URL 的问号后面：&lt;/p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//miloyip.com/misc/sv2019.html%3F55%2Bl5LmO&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;miloyip.com/misc/sv2019&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;.html?55+l5LmO&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;便可以看到封面的效果。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CHuge%7B%5Ccolor%7Bpink%7D%7B%5Ctextit%7BHappy+St+Valentine%27s+Day+2019%21%7D%7D%7D&quot; alt=&quot;\Huge{\color{pink}{\textit{Happy St Valentine&#39;s Day 2019!}}}&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;h2&gt;相关回答／文章&lt;/h2&gt;&lt;a href=&quot;https://www.zhihu.com/question/20187195/answer/146381413&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-f8a781f3032b886ce16bc6e6726740e1_ipico.jpg&quot; data-image-width=&quot;756&quot; data-image-height=&quot;645&quot; class=&quot;internal&quot;&gt;如何用 C 语言画「心形」？&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30123802&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-58972af6a18081c088c298f494ef4f08_ipico.jpg&quot; data-image-width=&quot;513&quot; data-image-height=&quot;513&quot; class=&quot;internal&quot;&gt;Milo Yip：完美恋爱迷宫&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31901449&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-fd045c136f75263c865390c69518016a_ipico.jpg&quot; data-image-width=&quot;1024&quot; data-image-height=&quot;1024&quot; class=&quot;internal&quot;&gt;Milo Yip：用C语言画光（七）：比尔-朗伯定律&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/31482830/answer/318497552&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-2941287c52be96de6898ec279decb881_ipico.jpg&quot; data-image-width=&quot;1286&quot; data-image-height=&quot;1290&quot; class=&quot;internal&quot;&gt;如何用计算几何模型画一束玫瑰花？&lt;/a&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] Müller, Matthias, David Charypar, and Markus Gross. &quot;Particle-based fluid simulation for interactive applications.&quot;&lt;i&gt;Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation&lt;/i&gt;. Eurographics Association, 2003.&lt;/p&gt;&lt;p&gt;[2] Bridson, Robert.&lt;i&gt;Fluid simulation for computer graphics&lt;/i&gt;. AK Peters/CRC Press, 2015.&lt;/p&gt;&lt;p&gt;[3] Kim, Doyub.&lt;i&gt;Fluid Engine Development&lt;/i&gt;. AK Peters/CRC Press, 2017.&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2019-02-13-56640030</guid>
<pubDate>Wed, 13 Feb 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>腾讯香农编码器，尽享高清视频体验</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-11-20-50351685.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50351685&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e4f37e174d1ddaab435feae983354b99_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;      这里给大家推荐一款高清视频编码利器——腾讯自主研发的香农编码器（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//shannon-lab.qq.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tencent Shannon Encoder&lt;/a&gt;，简称T265）。在莫斯科国立大学主办的2018世界视频编码器大赛（MSU codec comparison）中，香农编码器从众多编码器中脱颖而出，继在客观指标取得优异成绩后，经过主办方严格的人眼主观测试，取得人眼主观质量评测的冠军：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.compression.ru/video/codec_comparison/hevc_2018/%23subjective_report&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-abe98f4240a1cc40c89eba20b0b97f1f_180x120.jpg&quot; data-image-width=&quot;300&quot; data-image-height=&quot;150&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HEVC Video Codecs Comparison 2018&lt;/a&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-81a023252af7f5ea01e2440f5dff8543_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1981&quot; data-rawheight=&quot;1825&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1981&quot; data-original=&quot;https://pic4.zhimg.com/v2-81a023252af7f5ea01e2440f5dff8543_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-81a023252af7f5ea01e2440f5dff8543_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1981&quot; data-rawheight=&quot;1825&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1981&quot; data-original=&quot;https://pic4.zhimg.com/v2-81a023252af7f5ea01e2440f5dff8543_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-81a023252af7f5ea01e2440f5dff8543_b.jpg&quot;/&gt;&lt;figcaption&gt;图1 MSU发布的腾讯香农编码器的性能测试结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;       衡量一个编码器的优劣是一件非常复杂的事情，涉及编码质量，速度和质量平衡以及码控平稳度等多个指标，受多种因素影响。下面结合大赛的测评报告，对香农编码器做三点评述。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;注重SSIM与PSNR的均衡&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       在MSU的编码质量测评中，使用了SSIM 和PSNR两种客观指标，其中SSIM指标侧重于衡量编码视频图像和原视频图像之间的结构相似性，而PSNR指标侧重于衡量编码视频图像相对原视频图像的保真度。为了保证编码视频图像的主观质量，一般需要保证SSIM和PSNR两者间的均衡，避免导致意外的主观质量问题。如图2所示，中间和右边的图像虽然PSNR一样，但右边图像有严重块效应，主观质量很差，这里SSIM指标比PSNR指标更好地反映了主观质量；而如图3所示，中间和右边图像SSIM一样，但右边图像有像素块像素值完全反转的严重失真，主观质量差得多，这里PSNR指标比SSIM指标更好地反映了主观质量。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-087fa81e798672e649ff95a2df3358dd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1224&quot; data-rawheight=&quot;508&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1224&quot; data-original=&quot;https://pic2.zhimg.com/v2-087fa81e798672e649ff95a2df3358dd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-087fa81e798672e649ff95a2df3358dd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1224&quot; data-rawheight=&quot;508&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1224&quot; data-original=&quot;https://pic2.zhimg.com/v2-087fa81e798672e649ff95a2df3358dd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-087fa81e798672e649ff95a2df3358dd_b.jpg&quot;/&gt;&lt;figcaption&gt;图2 编码PSNR相同，SSIM不同的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ac05bb1186b6566c819912458a76dc8b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;442&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1238&quot; data-original=&quot;https://pic4.zhimg.com/v2-ac05bb1186b6566c819912458a76dc8b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ac05bb1186b6566c819912458a76dc8b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;442&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1238&quot; data-original=&quot;https://pic4.zhimg.com/v2-ac05bb1186b6566c819912458a76dc8b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ac05bb1186b6566c819912458a76dc8b_b.jpg&quot;/&gt;&lt;figcaption&gt;图3 编码SSIM相同，PSNR不同的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;       腾讯香农编码器在优化过程中综合考虑了PSNR和SSIM模型的特点，在算法设计实现中采取了两者比较均衡的策略，给用户带来较好的主观视觉体验。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-681fe1d4f18b36846d35390013bb9f27_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1064&quot; data-rawheight=&quot;239&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1064&quot; data-original=&quot;https://pic4.zhimg.com/v2-681fe1d4f18b36846d35390013bb9f27_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-681fe1d4f18b36846d35390013bb9f27_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1064&quot; data-rawheight=&quot;239&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1064&quot; data-original=&quot;https://pic4.zhimg.com/v2-681fe1d4f18b36846d35390013bb9f27_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-681fe1d4f18b36846d35390013bb9f27_b.jpg&quot;/&gt;&lt;figcaption&gt;图4 香农编码器PSNR和SSIM排名&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;侧重中低码率的互联网应用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       在MSU的测评中所有测试序列的编码码率段都主要集中在1~12Mbps，甚至更高码率上，而互联网视频应用中编码码率段基本集中在1~6Mbps之间。腾讯香农编码器作为一款主要服务于互联网视频应用的编码器，在优化时也更关注于1~6Mbps中低码率段，由MSU测评的数据可以得到如下中低码率段的排名和全码率段的排名对比，香农编码器在中低码率段更有优势。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0a7fcda5e9e48ebc3fced768539b38c1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1886&quot; data-rawheight=&quot;774&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1886&quot; data-original=&quot;https://pic2.zhimg.com/v2-0a7fcda5e9e48ebc3fced768539b38c1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0a7fcda5e9e48ebc3fced768539b38c1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1886&quot; data-rawheight=&quot;774&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1886&quot; data-original=&quot;https://pic2.zhimg.com/v2-0a7fcda5e9e48ebc3fced768539b38c1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0a7fcda5e9e48ebc3fced768539b38c1_b.jpg&quot;/&gt;&lt;figcaption&gt;图5 Playground序列全码率段RD曲线&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2f53376173d8e27820bc6eec49b01f74_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;531&quot; data-rawheight=&quot;215&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;531&quot; data-original=&quot;https://pic1.zhimg.com/v2-2f53376173d8e27820bc6eec49b01f74_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2f53376173d8e27820bc6eec49b01f74_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;531&quot; data-rawheight=&quot;215&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;531&quot; data-original=&quot;https://pic1.zhimg.com/v2-2f53376173d8e27820bc6eec49b01f74_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2f53376173d8e27820bc6eec49b01f74_b.jpg&quot;/&gt;&lt;figcaption&gt;图6 中低码率段部分编码器排名&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;编码鲁棒性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       MSU根据时间复杂度和空间复杂度选择了迥异的测试序列，这些测试序列基本涵盖了各种场景，用来测试编码器对各种场景的编码适应能力。香农编码器通过更合理的码率分配策略，将码控精度控制在5%以内的同时，还额外节省了超过6%的带宽。其编码的鲁棒性表现也还不错，如下图所示，对于典型测试序列Sea Sunrise，当许多编码器的RD曲线都出现异常的时候，香农编码器的RD曲线不但正常，压缩性能也超过竞品。测试序列的难例挖掘是编码器研发不断迭代过程中的一个难点，香农编码器在编码鲁棒性上还有可提升的空间。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e0e6a39811e0a47590915cf38dc470ba_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;984&quot; data-original=&quot;https://pic3.zhimg.com/v2-e0e6a39811e0a47590915cf38dc470ba_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e0e6a39811e0a47590915cf38dc470ba_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;984&quot; data-original=&quot;https://pic3.zhimg.com/v2-e0e6a39811e0a47590915cf38dc470ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e0e6a39811e0a47590915cf38dc470ba_b.jpg&quot;/&gt;&lt;figcaption&gt;图7 Sea Sunrise RD曲线&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;总结和展望&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       腾讯香农编码器在MSU视频编码比赛中经受了检验，无论客观指标，还是主观指标，成绩都非常突出，未来我们在技术上还会持续演进，带来更清晰流畅的视频体验。&lt;/p&gt;</description>
<author>程曦铭</author>
<guid isPermaLink="false">2018-11-20-50351685</guid>
<pubDate>Tue, 20 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>腾讯香农编码器，尽享高清视频体验</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-11-19-50351685.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50351685&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e4f37e174d1ddaab435feae983354b99_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;      这里给大家推荐一款高清视频编码利器——腾讯自主研发的香农编码器（&lt;a href=&quot;https://shannon-lab.qq.com/&quot;&gt;Tencent Shannon Encoder&lt;/a&gt;，简称T265）。在莫斯科国立大学主办的2018世界视频编码器大赛（MSU codec comparison）中，香农编码器从众多编码器中脱颖而出，继在客观指标取得优异成绩后，经过主办方严格的人眼主观测试，取得人眼主观质量评测的冠军：&lt;/p&gt;&lt;a href=&quot;http://www.compression.ru/video/codec_comparison/hevc_2018/#subjective_report&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-abe98f4240a1cc40c89eba20b0b97f1f&quot; data-image-width=&quot;300&quot; data-image-height=&quot;150&quot; data-image-size=&quot;180x120&quot;&gt;HEVC Video Codecs Comparison 2018&lt;/a&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-47bc5baf13fb26c090e45800af0d5276_r.jpg&quot; data-caption=&quot;图1 MSU发布的腾讯香农编码器的性能测试结果&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1981&quot; data-rawheight=&quot;1825&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-47bc5baf13fb26c090e45800af0d5276&quot; data-watermark-src=&quot;v2-81a023252af7f5ea01e2440f5dff8543&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;       衡量一个编码器的优劣是一件非常复杂的事情，涉及编码质量，速度和质量平衡以及码控平稳度等多个指标，受多种因素影响。下面结合大赛的测评报告，对香农编码器做三点评述。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;注重SSIM与PSNR的均衡&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       在MSU的编码质量测评中，使用了SSIM 和PSNR两种客观指标，其中SSIM指标侧重于衡量编码视频图像和原视频图像之间的结构相似性，而PSNR指标侧重于衡量编码视频图像相对原视频图像的保真度。为了保证编码视频图像的主观质量，一般需要保证SSIM和PSNR两者间的均衡，避免导致意外的主观质量问题。如图2所示，中间和右边的图像虽然PSNR一样，但右边图像有严重块效应，主观质量很差，这里SSIM指标比PSNR指标更好地反映了主观质量；而如图3所示，中间和右边图像SSIM一样，但右边图像有像素块像素值完全反转的严重失真，主观质量差得多，这里PSNR指标比SSIM指标更好地反映了主观质量。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-29a51a9507c710d2f247dd51349d4b46_r.jpg&quot; data-caption=&quot;图2 编码PSNR相同，SSIM不同的情况&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1224&quot; data-rawheight=&quot;508&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-29a51a9507c710d2f247dd51349d4b46&quot; data-watermark-src=&quot;v2-087fa81e798672e649ff95a2df3358dd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d4560722f32536e4b965efc5745bdd9_r.jpg&quot; data-caption=&quot;图3 编码SSIM相同，PSNR不同的情况&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;442&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5d4560722f32536e4b965efc5745bdd9&quot; data-watermark-src=&quot;v2-ac05bb1186b6566c819912458a76dc8b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;       腾讯香农编码器在优化过程中综合考虑了PSNR和SSIM模型的特点，在算法设计实现中采取了两者比较均衡的策略，给用户带来较好的主观视觉体验。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-01168dc1038b4aff2856a944c7cc27f8_r.jpg&quot; data-caption=&quot;图4 香农编码器PSNR和SSIM排名&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1064&quot; data-rawheight=&quot;239&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-01168dc1038b4aff2856a944c7cc27f8&quot; data-watermark-src=&quot;v2-681fe1d4f18b36846d35390013bb9f27&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;侧重中低码率的互联网应用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       在MSU的测评中所有测试序列的编码码率段都主要集中在1~12Mbps，甚至更高码率上，而互联网视频应用中编码码率段基本集中在1~6Mbps之间。腾讯香农编码器作为一款主要服务于互联网视频应用的编码器，在优化时也更关注于1~6Mbps中低码率段，由MSU测评的数据可以得到如下中低码率段的排名和全码率段的排名对比，香农编码器在中低码率段更有优势。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dff397db45dc83ac6dbaf1be938e4f2e_r.jpg&quot; data-caption=&quot;图5 Playground序列全码率段RD曲线&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1886&quot; data-rawheight=&quot;774&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-dff397db45dc83ac6dbaf1be938e4f2e&quot; data-watermark-src=&quot;v2-0a7fcda5e9e48ebc3fced768539b38c1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ddb872587456c9fd8e61dcd7f39864ff_r.jpg&quot; data-caption=&quot;图6 中低码率段部分编码器排名&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;531&quot; data-rawheight=&quot;215&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ddb872587456c9fd8e61dcd7f39864ff&quot; data-watermark-src=&quot;v2-2f53376173d8e27820bc6eec49b01f74&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;编码鲁棒性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       MSU根据时间复杂度和空间复杂度选择了迥异的测试序列，这些测试序列基本涵盖了各种场景，用来测试编码器对各种场景的编码适应能力。香农编码器通过更合理的码率分配策略，将码控精度控制在5%以内的同时，还额外节省了超过6%的带宽。其编码的鲁棒性表现也还不错，如下图所示，对于典型测试序列Sea Sunrise，当许多编码器的RD曲线都出现异常的时候，香农编码器的RD曲线不但正常，压缩性能也超过竞品。测试序列的难例挖掘是编码器研发不断迭代过程中的一个难点，香农编码器在编码鲁棒性上还有可提升的空间。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6ff9807d0518e4504dc8bce3b2738a65_r.jpg&quot; data-caption=&quot;图7 Sea Sunrise RD曲线&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;415&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6ff9807d0518e4504dc8bce3b2738a65&quot; data-watermark-src=&quot;v2-e0e6a39811e0a47590915cf38dc470ba&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;总结和展望&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;       腾讯香农编码器在MSU视频编码比赛中经受了检验，无论客观指标，还是主观指标，成绩都非常突出，未来我们在技术上还会持续演进，带来更清晰流畅的视频体验。&lt;/p&gt;</description>
<author>程曦铭</author>
<guid isPermaLink="false">2018-11-19-50351685</guid>
<pubDate>Mon, 19 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>自然而然</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-10-14-46698082.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46698082&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
    unsigned i, j, k = 0, n = 1e8;
    for (i = 0; i &amp;lt; n; i++)
        for (j = 0; j &amp;lt; RAND_MAX; j += rand())
            k++;
    printf(&quot;%f\n&quot;, (double)k / n);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;console&quot;&gt;$ gcc -O3 a.c &amp;amp;&amp;amp; ./a.out
2.718219&lt;/code&gt;&lt;p&gt;&lt;a href=&quot;http://mathworld.wolfram.com/UniformSumDistribution.html&quot;&gt;Uniform Sum Distribution&lt;/a&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-10-14-46698082</guid>
<pubDate>Sun, 14 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用C语言实现井字棋（上）</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-07-25-39581573.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39581573&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c43e48d68c4d756e3a1a016f910f1382_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.zhihu.com/question/284523599/answer/438445079&quot;&gt;Milo Yip：用C++编写游戏容易吗？有什么开源的小游戏吗？能分享一下吗？&lt;/a&gt; 这个答案中，我提到学习游戏编程可从回合制游戏开始，例如井字棋。&lt;/p&gt;&lt;p&gt;考虑到一些&lt;b&gt;初学者&lt;/b&gt;的学习需求，我就写一个井字棋的教程吧。上篇实现二人游戏，下篇加上「人工智能」后约有 100 行 C 语言代码。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 游戏状态的表示&lt;/h2&gt;&lt;p&gt;首先，我认为表示方法（representation）是编程中应最先要考虑的事情。对于回合制游戏，我们需要存储一个回合中的游戏状态（game state）。&lt;/p&gt;&lt;p&gt;以下用一个结构体表示井字棋一个回合中的状态，并加入函数作初始化：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct {
    int board[3][3];    // -1 = empty, 0 = O, 1 = X
    int turn;           // O first
} state;

void init(state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; j++)
        for (i = 0; i &amp;lt; 3; i++)
            s-&amp;gt;board[j][i] = -1;
    s-&amp;gt;turn = 0;
}&lt;/code&gt;&lt;p&gt;以上用二维数组存储棋盘（board）是其中一种表示方式，另一种方式则是记录每个回合下棋子的位置。我们采用前者是因为它较容易实现胜负判定。有些回合制游戏可能使用冗余的表示方式，以方便实现各种规则。&lt;/p&gt;&lt;p&gt;而使用结构体而不是直接用全局变量，可带来一些优点，例如增强可读性及内聚性。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 显示游戏状态&lt;/h2&gt;&lt;p&gt;编写游戏时，我们通常希望先显示游戏状态，之后才加入其他规则，因为这样可以方便测试。&lt;/p&gt;&lt;p&gt;我希望用这样的文本显示游戏状态，当空置时写上位置编号（1-9），以方便玩家输入下棋位置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt; 1 | 2 | 3 
---+---+---
 4 | 5 | 6 
---+---+---
 7 | 8 | 9 &lt;/code&gt;&lt;p&gt;简单直白地编写代码的话：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void display(const state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; j++) {
        for (i = 0; i &amp;lt; 3; i++) {
            switch (s-&amp;gt;board[j][i]) {
                case -1: printf(&quot; %d &quot;, j * 3 + i + 1); break;
                case  0: printf(&quot; O &quot;); break;
                case  1: printf(&quot; X &quot;); break;
            }
            if (i &amp;lt; 2)
                printf(&quot;|&quot;);
            else
                printf(&quot;\n&quot;);
        }
        if (j &amp;lt; 2)
            printf(&quot;---+---+---\n&quot;);
        else
            printf(&quot;\n&quot;);
    }
}&lt;/code&gt;&lt;p&gt;由于 &lt;code class=&quot;inline&quot;&gt;display()&lt;/code&gt; 只读而不改变游戏状态，所以其参数类型为 &lt;code class=&quot;inline&quot;&gt;const state*&lt;/code&gt;。 &lt;/p&gt;&lt;p&gt;我们稍压缩一下代码：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void display(const state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; printf(++j &amp;lt; 3 ? &quot;---+---+---\n&quot; : &quot;\n&quot;))
        for (i = 0; i &amp;lt; 3; putchar(&quot;||\n&quot;[i++]))
            printf(&quot; %c &quot;, s-&amp;gt;board[j][i] == -1 ? &#39;1&#39; + j * 3 + i : &quot;OX&quot;[s-&amp;gt;board[j][i]]);
}&lt;/code&gt;&lt;p&gt;我们可以加入 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 函数去显示初始化的状态：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
} &lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe0.c&quot;&gt;tictactoe0.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 实现下棋&lt;/h2&gt;&lt;p&gt;然后，我们加入第一个游戏规则，就是下棋：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int move(state* s, int i, int j) {
    if (s-&amp;gt;board[j][i] != -1)
        return 0;
    s-&amp;gt;board[j][i] = s-&amp;gt;turn++ % 2;
    return 1;
}&lt;/code&gt;&lt;p&gt;函数内做了一个合法性判断，如果该位置已有棋子，则返回 0 表示失败。成功的话，在偶数回合填入 0，表示 O；奇数回合填入 1，表示 X；然后都把回合加一。&lt;/p&gt;&lt;p&gt;更改 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 简单测试： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    move(&amp;amp;s, 1, 1);
    display(&amp;amp;s);
    move(&amp;amp;s, 0, 1);
    display(&amp;amp;s);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-416ea35bcab6968eb0f15953cac392c5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;162&quot; data-rawheight=&quot;504&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe1.c&quot;&gt;tictactoe1.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;4. 处理输入&lt;/h2&gt;&lt;p&gt;在每一回合中，提示当前玩家（O 或 X），并让玩家输入一个下棋位置（1-9），如果位置不合法，则重新输入：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void human(state* s) {
    char c;
    do {
        printf(&quot;%c: &quot;, &quot;OX&quot;[s-&amp;gt;turn % 2]);
        c = getchar();
        while (getchar() != &#39;\n&#39;);
        printf(&quot;\n&quot;);
    } while (c &amp;lt; &#39;1&#39; || c &amp;gt; &#39;9&#39; || !move(s, (c - &#39;1&#39;) % 3, (c - &#39;1&#39;) / 3));
}&lt;/code&gt;&lt;p&gt;在标准输入中，要到回车键才能处理输入，所以这里我们读了第一个输入字符后，就忽略其他字符直到读到换行符。我们把表示位置的字符转换成二维数组索引。&lt;/p&gt;&lt;p&gt;然后，就可以修改 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 实现二人下棋的流程： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    while (s.turn &amp;lt; 9) {
        human(&amp;amp;s);
        display(&amp;amp;s);
    } 
}&lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe2.c&quot;&gt;tictactoe2.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;5. 胜负判定&lt;/h2&gt;&lt;p&gt;众所周知，井字棋的胜利条件，是有三个棋子在横线、直线或斜线连成一线。我们实现一个 &lt;code class=&quot;inline&quot;&gt;evaluate()&lt;/code&gt; 函数去评估棋局的状态，如果 O 胜出则返回 1，X 胜出则返回 -1，不分胜负则返回 0：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define CHECK(j1, i1, j2, i2, j3, i3) \
    if (s-&amp;gt;board[j1][i1] != -1 &amp;amp;&amp;amp; s-&amp;gt;board[j1][i1] == s-&amp;gt;board[j2][i2] &amp;amp;&amp;amp; s-&amp;gt;board[j1][i1] == s-&amp;gt;board[j3][i3]) \
        return s-&amp;gt;board[j1][i1] == 0 ? 1 : -1;

int evaluate(const state* s) {
    int i;
    for (i = 0; i &amp;lt; 3; i++) {
        CHECK(i, 0, i, 1, i, 2);    // horizontal
        CHECK(0, i, 1, i, 2, i);    // vertical
    }
    CHECK(0, 0, 1, 1, 2, 2);        // diagonal
    CHECK(0, 2, 1, 1, 2, 0);        // diagonal
    return 0;
}&lt;/code&gt;&lt;p&gt;上面的代码使用了一个宏 &lt;code class=&quot;inline&quot;&gt;CHECK()&lt;/code&gt; 去检测三个位置是否都为相同的棋子，如是则直接返回胜方。&lt;/p&gt;&lt;p&gt;最后，我们在 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 中，待每次下棋及显示状态后， 判定是否出现胜方，如果到达第 9 个回合（回合从 0 开始），则判定是平局（draw）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    while (s.turn &amp;lt; 9) {
        human(&amp;amp;s);
        display(&amp;amp;s);
        switch (evaluate(&amp;amp;s)) {
            case  1: printf(&quot;O win\n&quot;); return 0;
            case -1: printf(&quot;X win\n&quot;); return 0;
        }
    } 
    printf(&quot;Draw\n&quot;);
}&lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe3.c&quot;&gt;tictactoe3.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;6. 总结&lt;/h2&gt;&lt;p&gt;本篇实现了二人井字棋，它是一个简单的回合制游戏。我们先选择了游戏的状态表示方式（&lt;code class=&quot;inline&quot;&gt;state&lt;/code&gt;结构体及&lt;code class=&quot;inline&quot;&gt;init()&lt;/code&gt;函数），然后把状态以文本形式显示（&lt;code class=&quot;inline&quot;&gt;display()&lt;/code&gt;函数），加入每回合下棋规则（&lt;code class=&quot;inline&quot;&gt;move()&lt;/code&gt;函数），以及人类玩家的输入处理（&lt;code class=&quot;inline&quot;&gt;human()&lt;/code&gt;函数），并作胜负判定（&lt;code class=&quot;inline&quot;&gt;evaluate()&lt;/code&gt;函数），最后在&lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt;里则实现了按回合的循环及输出胜负结果。&lt;/p&gt;&lt;p&gt;虽然这个游戏本身以及 60 行的示例代码都很简单，但这个框架可以用于实现其他（更复杂的）回合制游戏。实时游戏（如动作游戏）的主要区别，其实也只在于把输入部分做成非阻塞的函数，而该循环则称为游戏循环（game loop）。&lt;/p&gt;&lt;p&gt;下篇将加入不败的「人工智能」。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-07-25-39581573</guid>
<pubDate>Wed, 25 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用C语言画希尔伯特曲线</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-06-20-38276467.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38276467&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d34f3e5d10cf51d8af90f99b49bdcf03_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B8%8C%E7%88%BE%E4%BC%AF%E7%89%B9%E6%9B%B2%E7%B7%9A&quot;&gt;希尔伯特曲线&lt;/a&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_curve&quot;&gt;Hilbert curve&lt;/a&gt;）是一种空间填充曲线（space filling curve）的分形图案，由德国数学家 &lt;a href=&quot;https://en.wikipedia.org/wiki/David_Hilbert&quot;&gt;David Hilbert&lt;/a&gt;（1862-1943）发现 [1]。简单来说，空间填充曲线就是可以用「一笔画」的方式填充整个二维、三维或更高维的空间。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d7c0d2f1d9b096b85e79f50e8569082f_r.jpg&quot; data-caption=&quot;[1] 中的插图，展示第1、2、3阶的希尔伯特曲线&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;612&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d7c0d2f1d9b096b85e79f50e8569082f&quot; data-watermark-src=&quot;v2-6aee5a02d11ac9d243a38a809e655eae&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;本文描述用 C 语言绘画这种曲线的方法和技巧。&lt;/p&gt;&lt;p&gt;（题图是一个三维的希尔伯特曲线雕塑，来自 &lt;a href=&quot;http://mathbun.com/&quot;&gt;http://mathbun.com/&lt;/a&gt;）&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 递归、坐标变换&lt;/h2&gt;&lt;p&gt;最初，我在 [2] 找到一种基于矢量的绘画方法。它的原理是，一阶的希尔伯特曲线是一个「⊓」的形状，我们可以生成四个顶点，把顶点连接起来。而第二阶则是用第一阶的四个顶点位置，加上旋转和缩小，去画4 个「⊓」形状。只要把最后生成的顶点连接起来，就可以生成整个曲线：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7833b4f3a74fe531aa941a95f9822920_r.jpg&quot; data-caption=&quot;左图是一阶，起点在左下角。右图黑线部分是4个「⊓」形状，它们的中心为左图的顶点位置，加上旋转 -90、0、0、90度、以及缩小为一半。最后把所有顶点连起来，增加了灰线部分。&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;397&quot; data-rawheight=&quot;182&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7833b4f3a74fe531aa941a95f9822920&quot; data-watermark-src=&quot;v2-a802e01794c71709cd1f2128de4b9241&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们用一个影像缓冲去绘画这些垂直、水平线，最后用 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/26525083&quot;&gt;极简的 PNG 编码函数 svpng()&lt;/a&gt;  来存储。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &quot;svpng.inc&quot;
#define S 512

unsigned char img[S * S * 3];
float px = 0.0f, py = 0.0f;

void setpixel(int x, int y) { /* ... */}
void lineto(float tx, float ty) {/* ... */}

void hilbert(float x, float y, float xi, float xj, float yi, float yj, int n) {
    if (n) {
        hilbert(x,                   y,                    yi / 2,  yj / 2,  xi / 2,  xj / 2, n - 1);
        hilbert(x + xi / 2,          y + xj / 2,           xi / 2,  xj / 2,  yi / 2,  yj / 2, n - 1);
        hilbert(x + xi / 2 + yi / 2, y + xj / 2 + yj / 2,  xi / 2,  xj / 2,  yi / 2,  yj / 2, n - 1);
        hilbert(x + xi / 2 + yi,     y + xj / 2 + yj,     -yi / 2, -yj / 2, -xi / 2, -xj / 2, n - 1);
    }
    else
        lineto(x + (xi + yi) / 2, y + (xj + yj) / 2);
}

int main() {
    hilbert(0.0f, 0.0f, 0.0f, S, S, 0.0f, 4);
    svpng(fopen(&quot;hilbert.png&quot;, &quot;wb&quot;), S, S,img, 0);
}&lt;/code&gt;&lt;p&gt;4阶的结果（为方便起见，起点位于左上角）：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-41985853acabc9b888e3c4d28051e63f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-41985853acabc9b888e3c4d28051e63f&quot; data-watermark-src=&quot;v2-07d283a9aeeb319dbbbcf5ea05f91046&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;注：&lt;code class=&quot;inline&quot;&gt;setpixel()&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;lineto()&lt;/code&gt;较锁碎，不在此展示，完整代码位于&lt;a href=&quot;https://github.com/miloyip/misc/blob/master/hilbert/hilbert.c&quot;&gt;https://github.com/miloyip/misc/blob/master/hilbert/hilbert.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 方向编码&lt;/h2&gt;&lt;p&gt;第一个方法要计算每个顶点的位置，计算量较大。另一种绘画希尔伯特曲线的方式，是考虑它的 L-system：&lt;/p&gt;&lt;blockquote&gt;变数: L, R&lt;br&gt;常数: F, +, -&lt;br&gt;公理: L&lt;br&gt;规则:&lt;br&gt;L → − R F + L F L + F R −&lt;br&gt;R → − L F + R F R + F L −&lt;br&gt;F ： 向前&lt;br&gt;- ： 右转90°&lt;br&gt;+ ： 左转90°&lt;/blockquote&gt;&lt;p&gt;我们可以看到，两条规则其实是对称的，我们只需要把在迭归时，从 L 变成 R时把旋转方向反转。我参考了[3]的代码实现，但每次向前移动只绘画两个像素，当中&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;为笔的当前像素位置，参数&lt;code class=&quot;inline&quot;&gt;d&lt;/code&gt;为当前方向，&lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt;记录旋转：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &quot;svpng.inc&quot;
#include &amp;lt;stdlib.h&amp;gt;

unsigned char* img, *p;
const int n = 4, s = (2 &amp;lt;&amp;lt; n) - 1;

void step(int d) {
    int a[] = { 3, s * 3, -3, s * -3 }, i;
    for (i = 0; i &amp;lt; 2; i++, p += a[d &amp;amp; 3])
        p[0] = p[1] = p[2] = 255;
}

void hilbert(int d, int r, int n) {
    if (n--) {
        hilbert(d + r, -r, n); step(d + r);
        hilbert(d,      r, n); step(d    );
        hilbert(d,      r, n); step(d - r);
        hilbert(d - r, -r, n);
    }
}

int main() {
    p = img = calloc(s * s, 3);
    hilbert(0, 1, n);
    p[0] = p[1] = p[2] = 255;
    svpng(fopen(&quot;hilbert2.png&quot;, &quot;wb&quot;), s, s, img, 0);
    free(img);
}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b39f241a8582cf0669bfb3a0af68cf1c_r.jpg&quot; data-caption=&quot;放大 16 倍后的4阶结果&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;496&quot; data-rawheight=&quot;496&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b39f241a8582cf0669bfb3a0af68cf1c&quot; data-watermark-src=&quot;v2-5f1180c240c8f3460c447eb1b0e68d50&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这种实现方式较简单，也能用最少的影像尺寸存储结果。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 简单文本&lt;/h2&gt;&lt;p&gt;既然可以用较小的画布尺寸，我们直接把每个像素变换成&lt;code class=&quot;inline&quot;&gt;**&lt;/code&gt; 两个字符：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

char* img, *p;
const int n = 4, s = (2 &amp;lt;&amp;lt; n) - 1, a[] = { 2, s * 2, -2, -s * 2 };

void step(int d) {
    int i;
    for (i = 0; i &amp;lt; 2; i++, p += a[d &amp;amp; 3])
        p[0] = p[1] = &#39;*&#39;;
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    memset(p = img = malloc(s * s * 2), &#39; &#39;, s * s * 2);
    hilbert(0, 1, n);
    p[0] = p[1] = &#39;*&#39;;
    for (p = img; p &amp;lt; img + s * s * 2; p += s * 2)
        printf(&quot;%.*s\n&quot;, s * 2, p);
    free(img);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bab9624e85060beacb77194ae95ec8f8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;890&quot; data-rawheight=&quot;898&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bab9624e85060beacb77194ae95ec8f8&quot; data-watermark-src=&quot;v2-2b008e151d8579c2b45fddf22dcb3081&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;h2&gt;4. ASCII 字符美化&lt;/h2&gt;&lt;p&gt;上面的输出有点丑。我在 [4] 里找到一种美化方法，可通过方向的改变来决定用什么字符，该映射为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┌&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt; _&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┐&lt;/code&gt; →  &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;└&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;|_&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┘&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;| &lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;│&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;| &lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;─&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;__&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9f1bf3371387712e2ce38bf9536636b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;186&quot; data-rawheight=&quot;106&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我通过记录上一次的方向，与当前要步进的方向，去做这个映射。例如之前是向下的（&lt;code class=&quot;inline&quot;&gt;l=3&lt;/code&gt;）当前要向右（&lt;code class=&quot;inline&quot;&gt;d=0&lt;/code&gt;），即&lt;code class=&quot;inline&quot;&gt;└&lt;/code&gt; 的情况，便在笔的位置写进&lt;code class=&quot;inline&quot;&gt;|_&lt;/code&gt;这两个字符。针对 &lt;equation&gt;4\times4=16&lt;/equation&gt; 种组合，我用字符串表示：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

char* img, *p;
const int n = 4 , s = 1 &amp;lt;&amp;lt; n, a[] = { 2, s * 2, -2, -s * 2 };
int l = 3;

void step(int d) {
    d &amp;amp;= 3;
    p[0] = &quot;_  ||||   _|   |&quot;[l * 4 + d];
    p[1] = &quot;_   _    ____   &quot;[l * 4 + d];
    p += a[d];
    l = d;
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    p = img = malloc(s * s * 2);
    hilbert(0, 1, n);
    p[0] = p[1] = &#39; &#39;;
    for (p = img; p &amp;lt; img + s * s * 2; p += s * 2)
        printf(&quot;%.*s\n&quot;, s * 2, p);
    free(img);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f6d81fe1327e9a92219de371b4cca505_r.jpg&quot; data-caption=&quot;4阶&quot; data-size=&quot;small&quot; data-rawwidth=&quot;768&quot; data-rawheight=&quot;478&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f6d81fe1327e9a92219de371b4cca505&quot; data-watermark-src=&quot;v2-6f64734912d4820a49f0e40933b5835c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0f01b2e77086e678da2860a55fcba3b7_r.jpg&quot; data-caption=&quot;6阶&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1290&quot; data-rawheight=&quot;1308&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0f01b2e77086e678da2860a55fcba3b7&quot; data-watermark-src=&quot;v2-10deb3eb183f553e27a6da9f87a629de&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;h2&gt;5. 无内存分配&lt;/h2&gt;&lt;p&gt;为了尽一步简化，我希望能去掉画步的内存分配。方法是把逻辑改为，从上至下左至右打印字符，每画两个字符我们都遍历整个曲线，若曲线的位置和当前打印位置相同，才把那两个字符打印出来。这样会增加大量运算，但可以减少代码量。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

const int n = 4, s = 1 &amp;lt;&amp;lt; n, a[] = { 1, s, -1, -s };
int l = 3, p, q;

void step(int d) {
    d &amp;amp;= 3;
    if (p == q)
        printf(&quot;%.2s&quot;, &amp;amp;&quot;__    | |_| |      ___|_ _    | &quot;[l * 8 + d * 2]);
    p += a[l = d];
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    for (; q &amp;lt; s * s; q++, p = 0) {
        hilbert(0, 1, n);
        if (q % s == s - 1)
            putchar(&#39;\n&#39;);
    }
}&lt;/code&gt;&lt;h2&gt;6. 代码压缩&lt;/h2&gt;&lt;p&gt;最后，我把上面的代码压缩成 256 个字符：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;const n=4,s=1&amp;lt;&amp;lt;n,a[]={1,s,-1,-s};
l=3,p,q;
t(d){d&amp;amp;=3;p-q||printf(&quot;%.2s&quot;,&amp;amp;&quot;__    | |_| |      ___|_ _    | &quot;[l*8+d*2]);p+=a[l=d];}
h(d,r,n){n--&amp;amp;&amp;amp;(h(d+r,-r,n),t(d+r),h(d,r,n),t(d),h(d,r,n),t(d-r),h(d-r,-r,n));}
main(){for(;p=0,q&amp;lt;s*s;++q%s||putchar(10))h(0,1,n);}&lt;/code&gt;&lt;a href=&quot;https://tio.run/##VY7RaoQwEEV/RYSVxMwU3e1DIeZLREIwuC6k2Zik7IP665vGdvvQCwNz7syFO@JolL2mNN5tiIUV7xBE23UWVD@ItYUA2AKGnRtxAQcLj0TTVVfiwh0u2@b8zcaJlKe3cyihKqUssrZik3mKH0kpN1m8/LI39QfT9Xmg3DGheiP0wPeZaPBg6WoRq4pkZB7wcCAeO4W/j4P/E/5e8RWgfP9UN0voOt094U40sHShDpyx5RRy4684zsqTtqF0Jg20OcP3lJ7jZNQ1JHx8Aw&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Try It Online&lt;/a&gt;&lt;p&gt;本文所有代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/tree/master/hilbert&quot;&gt;https://github.com/miloyip/misc/tree/master/hilbert&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;相关文章&lt;/h2&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24688522&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b082e4583bfbf99f53a075d4510a2f25&quot; data-image-width=&quot;1439&quot; data-image-height=&quot;1080&quot; data-image-size=&quot;180x120&quot;&gt;Milo Yip：用 C 语言画科赫雪花&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23692828&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b5818ef7694bbb3236a1bdc7e9a8b572&quot; data-image-width=&quot;1620&quot; data-image-height=&quot;1080&quot; data-image-size=&quot;180x120&quot;&gt;Milo Yip：如何用 C 语言画这个图&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/27015321/answer/35028446&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;b92e467997b0f799cfb7f085dc06833a&quot; data-image-width=&quot;1018&quot; data-image-height=&quot;884&quot; data-image-size=&quot;ipico&quot;&gt;如何用 C 语言画一个“圣诞树”？&lt;/a&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] D. Hilbert, &lt;a href=&quot;http://www.digizeitschriften.de/dms/img/?PPN=PPN235181684_0038&amp;amp;DMDID=dmdlog40&quot;&gt;Über die stetige Abbildung einer Linie auf ein Flächenstück&lt;/a&gt;, Mathematische Annalen 38 (1891), 459–460.&lt;/p&gt;&lt;p&gt;[2] &lt;a href=&quot;http://www.soc.napier.ac.uk/~andrew/hilbert.html&quot;&gt;http://www.soc.napier.ac.uk/~andrew/hilbert.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[3] &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35358486&quot;&gt;形形色色的空间填充曲线 和 L-System&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[4] &lt;a href=&quot;https://codegolf.stackexchange.com/questions/104392/ascii-hilbert-curve&quot;&gt;ASCII Hilbert Curve&lt;/a&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-06-20-38276467</guid>
<pubDate>Wed, 20 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>波兰表示法与表达式树</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-06-13-38013510.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38013510&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e53026a0f73a4bcaba68b7aa7ae0619f_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;昨晚撰写答案《&lt;a href=&quot;https://www.zhihu.com/question/280630276/answer/415398747&quot;&gt;Milo Yip：怎么用 C 语言画出二叉树的图形？&lt;/a&gt;》，以 ASCII 字符打印任意深度的满二叉树（full binary tree）。评论中问及如何打印非满二叉树。我记起，整个满二叉树可存储在单个一维数组。那么，可以先把非满二叉树的节点写到一维数组，然后修改打印程序，如果数组中存有该序号的节点，才打印该节点及其指向父节点的连线，否则打印空白占位字符。&lt;/p&gt;&lt;p&gt;我的回评或过于简短，不够清晰，因此我想用实际代码解释。然而，怎样建一个非满二叉树？我想到可以写一个简单的表达式解析器，支持加减乘除，不支持负数操作数。程序也能打印出其表达式树。&lt;/p&gt;&lt;p&gt;最简单的表达式语法，莫过于&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95&quot;&gt;波兰表示法&lt;/a&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;Polish notation&lt;/a&gt;）。波兰表示法又称为前缀表示法，即运算符写在前面。波兰表示法的特点是不需要括号。例如，表达式(&lt;code class=&quot;inline&quot;&gt;1 + 2) * (3 - 4)&lt;/code&gt; 的波表示法是 &lt;code class=&quot;inline&quot;&gt;* + 1 2 - 3 4&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;（题图 &lt;a href=&quot;https://unsplash.com/photos/4xEfxMShEUM&quot;&gt;photo by Elliott Engelmann&lt;/a&gt;）&lt;/p&gt;&lt;hr&gt;&lt;p&gt;首先设计解析后的数据结构，表达式树的节点可能是运算符或操作数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef enum { NUM, ADD, SUB, MUL, DIV } Type;

typedef struct NodeTag {
    union {
        double number;
        struct NodeTag *children[2];
    } u;
    Type type;
} Node;&lt;/code&gt;&lt;p&gt;因为一个节点不会同时为运算符或操作数，采用 &lt;code class=&quot;inline&quot;&gt;union&lt;/code&gt;可能节省一点内存。&lt;/p&gt;&lt;p&gt;波兰表示法的解释器非常简单，可通过递归实现，不需要额外的数据结构：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Node* parse(char** s) {
    while (isspace(**s))
        (*s)++;    
    if (**s == &#39;\0&#39;)
        return NULL;
    else {
        Node* n = (Node*)calloc(1, sizeof(Node));
        if (isdigit(**s)) {
            n-&amp;gt;type = NUM;
            n-&amp;gt;u.number = strtod(*s, s);
        }
        else {
            int i;
            switch (**s) {
                case  &#39;+&#39;: n-&amp;gt;type = ADD; break;
                case  &#39;-&#39;: n-&amp;gt;type = SUB; break;
                case  &#39;*&#39;: n-&amp;gt;type = MUL; break;
                case  &#39;/&#39;: n-&amp;gt;type = DIV; break;
                default: release(n); return NULL;
            }
            (*s)++;
            for (i = 0; i &amp;lt; 2; i++)
                if ((n-&amp;gt;u.children[i] = parse(s)) == NULL) {
                    release(n);
                    return NULL;
                }
        }
        return n;
    }
}&lt;/code&gt;&lt;p&gt;每次有内存分配，都匹对释放，也是递归：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void release(Node* n) {
    int i;
    if (n-&amp;gt;type != NUM)
        for (i = 0; i &amp;lt; 2; i++)
            if (n-&amp;gt;u.children[i])
                release(n-&amp;gt;u.children[i]);
    free(n);
}&lt;/code&gt;&lt;p&gt;然后我们可以打印中缀表示法：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define OPERATOR_CHAR(n) (&quot;+-*/&quot;[n-&amp;gt;type - ADD])

void printInfix(const Node *n) {
    if (n-&amp;gt;type == NUM)
        printf(&quot;%lg&quot;, n-&amp;gt;u.number);
    else {
        putchar(&#39;(&#39;);
        printInfix(n-&amp;gt;u.children[0]);
        printf(&quot; %c &quot;, OPERATOR_CHAR(n));
        printInfix(n-&amp;gt;u.children[1]);
        putchar(&#39;)&#39;);
    }
}&lt;/code&gt;&lt;p&gt;以及对表达式树求值：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;double eval(const Node* n) {
    switch (n-&amp;gt;type) {
        case ADD: return eval(n-&amp;gt;u.children[0]) + eval(n-&amp;gt;u.children[1]);
        case SUB: return eval(n-&amp;gt;u.children[0]) - eval(n-&amp;gt;u.children[1]);
        case MUL: return eval(n-&amp;gt;u.children[0]) * eval(n-&amp;gt;u.children[1]);
        case DIV: return eval(n-&amp;gt;u.children[0]) / eval(n-&amp;gt;u.children[1]);
        case NUM: return n-&amp;gt;u.number;
    }
}&lt;/code&gt;&lt;p&gt;编写&lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt;： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main(int argc, char** argv) {
    if (argc != 2)
        return printf(&quot;Help: pntree \&quot;+ * 1 2 3\&quot;&quot;);
    else {
        char** p = &amp;amp;argv[1];
        Node* root = parse(p);
        if (root) {
            printInfix(root);
            printf(&quot; = %lg\n&quot;, eval(root));
            release(root);
        }
        else
            return printf(&quot;Invalid input\n&quot;);
    }
}&lt;/code&gt;&lt;p&gt;测试：&lt;/p&gt;&lt;code lang=&quot;console&quot;&gt;$ ./pntree &quot;* + 1 2 - 3 4&quot;
((1 + 2) * (3 - 4)) = -3&lt;/code&gt;&lt;hr&gt;&lt;p&gt;接下来，我们要修改之前的满二叉树打印程序。和之前的需求不一样，树的深度是随输入改变的，所以需先求出最大高度（深度）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int maxDepth(const Node* n) {
    if (n-&amp;gt;type == NUM)
        return 1;
    else {
        int maximum = 0, i, d;
        for (i = 0; i &amp;lt; 2; i++)
            if (maximum &amp;lt; (d = maxDepth(n-&amp;gt;u.children[i])))
                maximum = d;
        return maximum + 1;
    }
}&lt;/code&gt;&lt;p&gt;接着是分配一个 &lt;equation&gt;2^d-1&lt;/equation&gt; 大小的数组，把序号映射至节点：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void fillMap(Node** map, Node* n, int index) {
    int i;
    map[index] = n;
    if (n-&amp;gt;type != NUM)
        for (i = 0; i &amp;lt; 2; i++)
            fillMap(map, n-&amp;gt;u.children[i], index * 2 + i + 1);
}

void printTree(Node* n) {
    int depth = maxDepth(n), i, j, index;
    Node** map = (Node**)calloc((1 &amp;lt;&amp;lt; depth) - 1, sizeof(Node*));
    fillMap(map, n, 0);
    // ...
    free(map);
}&lt;/code&gt;&lt;p&gt;这里和原答案一样，使用广度优先遍历去打印节点。先忽略连线的部分：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void putchars(char c, int n) {
    while (n--)
        putchar(c);
}

int printNode(Node* n, int w) {
    if (n-&amp;gt;type == NUM)
        return printf(&quot;%*lg&quot;, w, n-&amp;gt;u.number);
    else
        return printf(&quot;%*c&quot;, w, &quot;+-*/&quot;[n-&amp;gt;type - ADD]);
}

void printTree(Node* n) {
    int depth = maxDepth(n), i, j, index;
    Node** map = (Node**)calloc((1 &amp;lt;&amp;lt; depth) - 1, sizeof(Node*));
    fillMap(map, n, 0);
    for (j = 0, index = 0; j &amp;lt; depth; j++) {
        int w = 1 &amp;lt;&amp;lt; (depth - j + 1);
        // Curve to parent ...
        // Node content
        for (i = 0; i &amp;lt; 1 &amp;lt;&amp;lt; j; i++, index++)
            if (map[index])
                putchars(&#39; &#39;, w * 2 - printNode(map[index], w));
            else
                putchars(&#39; &#39;, w * 2);
        putchar(&#39;\n&#39;);
    }
    free(map);
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;putchars(c, n)&lt;/code&gt;连续打印 n 个相同字符。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;printNode(n, w)&lt;/code&gt; 打印节点的内容（运算符或操作数），打印寛度为&lt;code class=&quot;inline&quot;&gt;w&lt;/code&gt;个字符，返回实际打印字符数目。&lt;/p&gt;&lt;p&gt;在 &lt;code class=&quot;inline&quot;&gt;printTree(n)&lt;/code&gt;中，采用之前相同的两层循环，在内循环里递增序号&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt;，并获取当前节点&lt;code class=&quot;inline&quot;&gt;map[index]&lt;/code&gt;。若该序号没有节点，则打印空白字符。 &lt;/p&gt;&lt;p&gt;最终结果：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-327cf535e573aca9c44c62564fc3f19e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1710&quot; data-rawheight=&quot;446&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-327cf535e573aca9c44c62564fc3f19e&quot; data-watermark-src=&quot;v2-cd05f5e7509ba8ea3ed3824ddbf85739&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;本文简单示范如何实现波兰表示法的计算器，并打印其非满二叉表达式树。此方法需要 &lt;equation&gt;O(2^d)&lt;/equation&gt; 的时间和空间复杂度。如实际节点数量远低于 &lt;equation&gt;2^d&lt;/equation&gt; ，可考虑用哈希表存储该映射表，但时间复杂度始终无法降低。另一简单优化方法，是用二维数组存储字符输出，那就只需绘画表达式树含有的节点。&lt;/p&gt;&lt;p&gt;完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/pntree/pntree.c&quot;&gt;pntree.c&lt;/a&gt;。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-06-13-38013510</guid>
<pubDate>Wed, 13 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从零开始的 JSON 库教程（八）：访问与其他功能</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-06-04-37618664.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37618664&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-58d55d45d37aa51b9ba19f3e3cec0b22_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文是&lt;a href=&quot;https://zhuanlan.zhihu.com/json-tutorial&quot;&gt;《从零开始的 JSON 库教程》&lt;/a&gt;的第八个单元。代码位于 &lt;a href=&quot;https://github.com/miloyip/json-tutorial/blob/master/tutorial08&quot;&gt;json-tutorial/tutorial08&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;（题图Photo by &lt;a href=&quot;https://unsplash.com/photos/9Q_pLLP_jmA?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Rob Lambert&lt;/a&gt;）&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 对象键值查询&lt;/h2&gt;&lt;p&gt;我们在第六个单元实现了 JSON 对象的数据结构，它仅为一个 &lt;code class=&quot;inline&quot;&gt;lept_value&lt;/code&gt; 的数组：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;struct lept_value {
    union {
        struct { lept_member* m; size_t size; }o;
        /* ... */
    }u;
    lept_type type;
};

struct lept_member {
    char* k; size_t klen;   /* member key string, key string length */
    lept_value v;           /* member value */
};&lt;/code&gt;&lt;p&gt;为了做相应的解析测试，我们实现了最基本的查询功能：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;size_t lept_get_object_size(const lept_value* v);
const char* lept_get_object_key(const lept_value* v, size_t index);
size_t lept_get_object_key_length(const lept_value* v, size_t index);
lept_value* lept_get_object_value(lept_value* v, size_t index);&lt;/code&gt;&lt;p&gt;在实际使用时，我们许多时候需要查询一个键值是否存在，如存在，要获得其相应的值。我们可以提供一个函数，简单地用线性搜寻实现这个查询功能（时间复杂度 &lt;equation&gt;\mathrm{O}(n)&lt;/equation&gt; ）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define LEPT_KEY_NOT_EXIST ((size_t)-1)

size_t lept_find_object_index(const lept_value* v, const char* key, size_t klen) {
    size_t i;
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_OBJECT &amp;amp;&amp;amp; key != NULL);
    for (i = 0; i &amp;lt; v-&amp;gt;u.o.size; i++)
        if (v-&amp;gt;u.o.m[i].klen == klen &amp;amp;&amp;amp; memcmp(v-&amp;gt;u.o.m[i].k, key, klen) == 0)
            return i;
    return LEPT_KEY_NOT_EXIST;
}}&lt;/code&gt;&lt;p&gt;若对象内没有所需的键，此函数返回 &lt;code class=&quot;inline&quot;&gt;LEPT_KEY_NOT_EXIST&lt;/code&gt;。使用时：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value o;
size_t index;
lept_init(&amp;amp;o);
lept_parse(&amp;amp;o, &quot;{\&quot;name\&quot;:\&quot;Milo\&quot;, \&quot;gender\&quot;:\&quot;M\&quot;}&quot;);
index = lept_find_object_index(&amp;amp;o, &quot;name&quot;, 4);
if (index != LEPT_KEY_NOT_EXIST) {
    lept_value* v = lept_get_object_value(&amp;amp;o, index);
    printf(&quot;%s\n&quot;, lept_get_string(v));
}
lept_free(&amp;amp;o);&lt;/code&gt;&lt;p&gt;由于一般也是希望获取键对应的值，而不需要索引，我们再加入一个辅助函数，返回类型改为 &lt;code class=&quot;inline&quot;&gt;lept_value*&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value* lept_find_object_value(lept_value* v, const char* key, size_t klen) {
    size_t index = lept_find_object_index(v, key, klen);
    return index != LEPT_KEY_NOT_EXIST ? &amp;amp;v-&amp;gt;u.o.m[index].v : NULL;
}&lt;/code&gt;&lt;p&gt;上述例子便可简化为：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value o, *v;
/* ... */
if ((v = lept_find_object_value(&amp;amp;o, &quot;name&quot;, 4)) != NULL)
    printf(&quot;%s\n&quot;, lept_get_string(v));&lt;/code&gt;&lt;hr&gt;&lt;h2&gt;2. 相等比较&lt;/h2&gt;&lt;p&gt;在实现数组和对象的修改之前，为了测试结果的正确性，我们先实现 &lt;code class=&quot;inline&quot;&gt;lept_value&lt;/code&gt; 的&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E9%97%9C%E4%BF%82%E9%81%8B%E7%AE%97%E5%AD%90&quot;&gt;相等比较&lt;/a&gt;（equality comparison）。首先，两个值的类型必须相同，对于 true、false、null 这三种类型，比较类型后便完成比较。而对于数字和字符串，需进一步检查是否相等：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int lept_is_equal(const lept_value* lhs, const lept_value* rhs) {
    assert(lhs != NULL &amp;amp;&amp;amp; rhs != NULL);
    if (lhs-&amp;gt;type != rhs-&amp;gt;type)
        return 0;
    switch (lhs-&amp;gt;type) {
        case LEPT_STRING:
            return lhs-&amp;gt;u.s.len == rhs-&amp;gt;u.s.len &amp;amp;&amp;amp; 
                memcmp(lhs-&amp;gt;u.s.s, rhs-&amp;gt;u.s.s, lhs-&amp;gt;u.s.len) == 0;
        case LEPT_NUMBER:
            return lhs-&amp;gt;u.n == rhs-&amp;gt;u.n;
        /* ... */
        default:
            return 1;
    }
}&lt;/code&gt;&lt;p&gt;由于值可能复合类型（数组和对象），也就是一个树形结构。当我们要比较两个树是否相等，可通过递归实现。例如，对于数组，我们先比较元素数目是否相等，然后递归检查对应的元素是否相等：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int lept_is_equal(const lept_value* lhs, const lept_value* rhs) {
    size_t i;
    /* ... */
    switch (lhs-&amp;gt;type) {
        /* ... */
        case LEPT_ARRAY:
            if (lhs-&amp;gt;u.a.size != rhs-&amp;gt;u.a.size)
                return 0;
            for (i = 0; i &amp;lt; lhs-&amp;gt;u.a.size; i++)
                if (!lept_is_equal(&amp;amp;lhs-&amp;gt;u.a.e[i], &amp;amp;rhs-&amp;gt;u.a.e[i]))
                    return 0;
            return 1;
        /* ... */
    }
}&lt;/code&gt;&lt;p&gt;而对象与数组的不同之处，在于概念上对象的键值对是无序的。例如，&lt;code class=&quot;inline&quot;&gt;{&quot;a&quot;:1,&quot;b&quot;:2}&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;{&quot;b&quot;:2,&quot;a&quot;:1}&lt;/code&gt; 虽然键值的次序不同，但这两个 JSON 对象是相等的。我们可以简单地利用 &lt;code class=&quot;inline&quot;&gt;lept_find_object_index()&lt;/code&gt; 去找出对应的值，然后递归作比较。这部分留给读者作为练习。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 复制、移动与交换&lt;/h2&gt;&lt;p&gt;本单元的重点，在于修改数组和对象的内容。我们将会实现一些接口做修改的操作，例如，为对象设置一个键值，我们可能会这么设计：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_set_object_value(lept_value* v, const char* key, size_t klen, const lept_value* value);

void f() {
    lept_value v, s;
    lept_init(&amp;amp;v);
    lept_parse(&amp;amp;v, &quot;{}&quot;);
    lept_init(&amp;amp;s);
    lept_set_string(&amp;amp;s, &quot;Hello&quot;, 5);
    lept_set_object_keyvalue(&amp;amp;v, &quot;s&quot;, &amp;amp;s); /* {&quot;s&quot;:&quot;Hello&quot;} */
    lept_free(&amp;amp;v)
    lept_free(&amp;amp;s);  /* 第二次释放！*/
}&lt;/code&gt;&lt;p&gt;凡涉及赋值，都可能会引起资源拥有权（resource ownership）的问题。值 &lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt; 并不能以指针方式简单地写入对象 &lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;，因为这样便会有两个地方都拥有 &lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;，会做成重复释放的 bug。我们有两个选择：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 中，把参数 &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_copying#Deep_copy&quot;&gt;深度复制&lt;/a&gt;（deep copy）一个值，即把整个树复制一份，写入其新增的键值对中。&lt;/li&gt;&lt;li&gt;在 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 中，把参数 &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; 拥有权转移至新增的键值对，再把 &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; 设置成 null 值。这就是所谓的移动语意（move semantics）。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;深度复制是一个常用功能，使用者也可能会用到，例如把一个 JSON 复制一个版本出来修改，保持原来的不变。所以，我们实现一个公开的深度复制函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_copy(lept_value* dst, const lept_value* src) {
    size_t i;
    assert(src != NULL &amp;amp;&amp;amp; dst != NULL &amp;amp;&amp;amp; src != dst);
    switch (src-&amp;gt;type) {
        case LEPT_STRING:
            lept_set_string(dst, src-&amp;gt;u.s.s, src-&amp;gt;u.s.len);
            break;
        case LEPT_ARRAY:
            /* \todo */
            break;
        case LEPT_OBJECT:
            /* \todo */
            break;
        default:
            lept_free(dst);
            memcpy(dst, src, sizeof(lept_value));
            break;
    }
}&lt;/code&gt;&lt;p&gt;C++11 加入了右值引用的功能，可以从语言层面区分复制和移动语意。而在 C 语言中，我们也可以通过实现不同版本的接口（不同名字的函数），实现这两种语意。但为了令接口更简单和正交（orthgonal），我们修改了 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 的设计，让它返回新增键值对的值指针，所以我们可以用 &lt;code class=&quot;inline&quot;&gt;lept_copy()&lt;/code&gt; 去复制赋值，也可以简单地改变新增的键值：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;/* 返回新增键值对的指针 */
lept_value* lept_set_object_value(lept_value* v, const char* key, size_t klen);

void f() {
    lept_value v;
    lept_init(&amp;amp;v);
    lept_parse(&amp;amp;v, &quot;{}&quot;);
    lept_set_string(lept_set_object_value(&amp;amp;v, &quot;s&quot;), &quot;Hello&quot;, 5);
    /* {&quot;s&quot;:&quot;Hello&quot;} */
    lept_copy(
        lept_add_object_keyvalue(&amp;amp;v, &quot;t&quot;),
        lept_get_object_keyvalue(&amp;amp;v, &quot;s&quot;, 1));
    /* {&quot;s&quot;:&quot;Hello&quot;,&quot;t&quot;:&quot;Hello&quot;} */
    lept_free(&amp;amp;v);
}
&lt;/code&gt;&lt;p&gt;我们还提供了 &lt;code class=&quot;inline&quot;&gt;lept_move()&lt;/code&gt;，它的实现也非常简单：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_move(lept_value* dst, lept_value* src) {
    assert(dst != NULL &amp;amp;&amp;amp; src != NULL &amp;amp;&amp;amp; src != dst);
    lept_free(dst);
    memcpy(dst, src, sizeof(lept_value));
    lept_init(src);
}&lt;/code&gt;&lt;p&gt;类似地，我们也实现了一个交换值的接口：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_swap(lept_value* lhs, lept_value* rhs) {
    assert(lhs != NULL &amp;amp;&amp;amp; rhs != NULL);
    if (lhs != rhs) {
        lept_value temp;
        memcpy(&amp;amp;temp, lhs, sizeof(lept_value));
        memcpy(lhs,   rhs, sizeof(lept_value));
        memcpy(rhs, &amp;amp;temp, sizeof(lept_value));
    }
}&lt;/code&gt;&lt;p&gt;当我们要修改对象或数组里的值时，我们可以利用这 3 个函数。例如：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;const char* json = &quot;{\&quot;a\&quot;:[1,2],\&quot;b\&quot;:3}&quot;;
char *out;
lept_value v;
lept_init(&amp;amp;v);
lept_parse(&amp;amp;v, json);
lept_copy(
    lept_find_object_value(&amp;amp;v, &quot;b&quot;, 1),
    lept_find_object_value(&amp;amp;v, &quot;a&quot;, 1));
printf(&quot;%s\n&quot;, out = lept_stringify(&amp;amp;v, NULL)); /* {&quot;a&quot;:[1,2],&quot;b&quot;:[1,2]} */
free(out);

lept_parse(&amp;amp;v, json);
lept_move(
    lept_find_object_value(&amp;amp;v, &quot;b&quot;, 1),
    lept_find_object_value(&amp;amp;v, &quot;a&quot;, 1));
printf(&quot;%s\n&quot;, out = lept_stringify(&amp;amp;v, NULL)); /* {&quot;a&quot;:null,&quot;b&quot;:[1,2]} */
free(out);

lept_parse(&amp;amp;v, json);
lept_swap(
    lept_find_object_value(&amp;amp;v, &quot;b&quot;, 1),
    lept_find_object_value(&amp;amp;v, &quot;a&quot;, 1));
printf(&quot;%s\n&quot;, out = lept_stringify(&amp;amp;v, NULL)); /* {&quot;a&quot;:3,&quot;b&quot;:[1,2]} */
free(out);

lept_free(&amp;amp;v);&lt;/code&gt;&lt;p&gt;在使用时，可尽量避免 &lt;code class=&quot;inline&quot;&gt;lept_copy()&lt;/code&gt;，而改用 &lt;code class=&quot;inline&quot;&gt;lept_move()&lt;/code&gt; 或 &lt;code class=&quot;inline&quot;&gt;lept_swap()&lt;/code&gt;，因为后者不需要分配内存。当中 &lt;code class=&quot;inline&quot;&gt;lept_swap()&lt;/code&gt; 更是无须做释放的工作，令它达到 &lt;equation&gt;\mathrm{O}(1)&lt;/equation&gt; 时间复杂度，其性能与值的内容无关。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;4. 动态数组&lt;/h2&gt;&lt;p&gt;在此单元之前的实现里，每个数组的元素数目在解析后是固定不变的，其数据结构是：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;struct lept_value {
    union {
        /* ... */
        struct { lept_value* e; size_t size; }a; /* array:  elements, element count*/
        /* ... */
    }u;
    lept_type type;
};&lt;/code&gt;&lt;p&gt;用这种数据结构增删元素时，我们需要重新分配一个数组，把适当的旧数据拷贝过去。但这种做法是非常低效的。例如我们想要从一个空的数组加入 &lt;equation&gt;n&lt;/equation&gt; 个元素，便要做 &lt;equation&gt;n(n - 1)/2&lt;/equation&gt; 次元素复制，即 &lt;equation&gt;\mathrm{O}(n^2)&lt;/equation&gt; 的时间复杂度。&lt;/p&gt;&lt;p&gt;其中一个改进方法，是使用动态数组（&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_array&quot;&gt;dynamic array&lt;/a&gt;，或称可增长数组／growable array）的数据结构。C++ STL 标准库中最常用的 &lt;code class=&quot;inline&quot;&gt;std::vector&lt;/code&gt; 也是使用这种数据结构的容器。&lt;/p&gt;&lt;p&gt;改动也很简单，只需要在数组中加入容量 &lt;code class=&quot;inline&quot;&gt;capacity&lt;/code&gt; 字段，表示当前已分配的元素数目，而 &lt;code class=&quot;inline&quot;&gt;size&lt;/code&gt; 则表示现时的有效元素数目：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;        /* ... */
        struct { lept_value* e; size_t size, capacity; }a; /* array:  elements, element count, capacity */
        /* ... */&lt;/code&gt;&lt;p&gt;我们终于提供设置数组的函数，而且它可提供初始的容量：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_set_array(lept_value* v, size_t capacity) {
    assert(v != NULL);
    lept_free(v);
    v-&amp;gt;type = LEPT_ARRAY;
    v-&amp;gt;u.a.size = 0;
    v-&amp;gt;u.a.capacity = capacity;
    v-&amp;gt;u.a.e = capacity &amp;gt; 0 ? (lept_value*)malloc(capacity * sizeof(lept_value)) : NULL;
}&lt;/code&gt;&lt;p&gt;我们需要稍修改 &lt;code class=&quot;inline&quot;&gt;lept_parse_array()&lt;/code&gt;，调用 &lt;code class=&quot;inline&quot;&gt;lept_set_array()&lt;/code&gt; 去设置类型和分配空间。&lt;/p&gt;&lt;p&gt;另外，类似于 &lt;code class=&quot;inline&quot;&gt;lept_get_array_size()&lt;/code&gt;，也加入获取当前容量的函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;size_t lept_get_array_capacity(const lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    return v-&amp;gt;u.a.capacity;
}&lt;/code&gt;&lt;p&gt;如果当前的容量不足，我们需要扩大容量，标准库的 &lt;code class=&quot;inline&quot;&gt;realloc()&lt;/code&gt; 可以分配新的内存并把旧的数据拷背过去：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_reserve_array(lept_value* v, size_t capacity) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    if (v-&amp;gt;u.a.capacity &amp;lt; capacity) {
        v-&amp;gt;u.a.capacity = capacity;
        v-&amp;gt;u.a.e = (lept_value*)realloc(v-&amp;gt;u.a.e, capacity * sizeof(lept_value));
    }
}&lt;/code&gt;&lt;p&gt;当数组不需要再修改，可以使用以下的函数，把容量缩小至刚好能放置现有元素：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_shrink_array(lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    if (v-&amp;gt;u.a.capacity &amp;gt; v-&amp;gt;u.a.size) {
        v-&amp;gt;u.a.capacity = v-&amp;gt;u.a.size;
        v-&amp;gt;u.a.e = (lept_value*)realloc(v-&amp;gt;u.a.e, v-&amp;gt;u.a.capacity * sizeof(lept_value));
    }
}&lt;/code&gt;&lt;p&gt;我们不逐一检视每个数组修改函数，仅介绍一下两个例子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value* lept_pushback_array_element(lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    if (v-&amp;gt;u.a.size == v-&amp;gt;u.a.capacity)
        lept_reserve_array(v, v-&amp;gt;u.a.capacity == 0 ? 1 : v-&amp;gt;u.a.capacity * 2);
    lept_init(&amp;amp;v-&amp;gt;u.a.e[v-&amp;gt;u.a.size]);
    return &amp;amp;v-&amp;gt;u.a.e[v-&amp;gt;u.a.size++];
}

void lept_popback_array_element(lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY &amp;amp;&amp;amp; v-&amp;gt;u.a.size &amp;gt; 0);
    lept_free(&amp;amp;v-&amp;gt;u.a.e[--v-&amp;gt;u.a.size]);
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;lept_pushback_array_element()&lt;/code&gt; 在数组末端压入一个元素，返回新的元素指针。如果现有的容量不足，就需要调用 &lt;code class=&quot;inline&quot;&gt;lept_reserve_array()&lt;/code&gt; 扩容。我们现在用了一个最简单的扩容公式：若容量为 0，则分配 1 个元素；其他情况倍增容量。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;lept_popback_array_element()&lt;/code&gt; 则做相反的工作，记得删去的元素需要调用 &lt;code class=&quot;inline&quot;&gt;lept_free()&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;下面这 3 个函数留给读者练习：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;lept_insert_array_element()&lt;/code&gt; 在 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 位置插入一个元素；&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;lept_erase_array_element()&lt;/code&gt; 删去在 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 位置开始共 &lt;code class=&quot;inline&quot;&gt;count&lt;/code&gt; 个元素（不改容量）；&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;lept_clear_array()&lt;/code&gt; 清除所有元素（不改容量）。&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;c&quot;&gt;lept_value* lept_insert_array_element(lept_value* v, size_t index);
void lept_erase_array_element(lept_value* v, size_t index, size_t count);
void lept_clear_array(lept_value* v);&lt;/code&gt;&lt;hr&gt;&lt;h2&gt;5. 动态对象&lt;/h2&gt;&lt;p&gt;动态对象也是采用上述相同的结构，所以直接留给读者修改结构体，并实现以下函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_set_object(lept_value* v, size_t capacity);
size_t lept_get_object_capacity(const lept_value* v);
void lept_reserve_object(lept_value* v, size_t capacity);
void lept_shrink_object(lept_value* v);
void lept_clear_object(lept_value* v);
lept_value* lept_set_object_value(lept_value* v, const char* key, size_t klen);
void lept_remove_object_value(lept_value* v, size_t index);&lt;/code&gt;&lt;p&gt;注意 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 会先搜寻是否存在现有的键，若存在则直接返回该值的指针，不存在时才新增。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;6. 总结与练习&lt;/h2&gt;&lt;p&gt;本单元主要加入了数组和对象的访问、修改方法。当中的赋值又引申了三种赋值的方式（复制、移动、交换）。这些问题是各种编程语言中都需要考虑的事情，为了减少深度复制的成本，有些程序库或运行时还会采用&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD&quot;&gt;写入时复制&lt;/a&gt;（copy-on-write, COW）。而浅复制（shallow copy）则需要 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0&quot;&gt;引用计数&lt;/a&gt;（reference count）或 &lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)&quot;&gt;垃圾回收&lt;/a&gt;（garbage collection, GC）等技术。&lt;/p&gt;&lt;p&gt;另外，我们实现了以动态数组的数据结构，能较高效地对数组和对象进行增删操作。至此，我们已经完成本教程的所有核心功能。做完下面的练习后，我们还会作简单讲解，然后将迎来本教程的最后一个单元。&lt;/p&gt;&lt;p&gt;本单元练习内容：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;完成 &lt;code class=&quot;inline&quot;&gt;lept_is_equal()&lt;/code&gt; 里的对象比较部分。不需要考虑对象内有重复键的情况。&lt;/li&gt;&lt;li&gt;打开 &lt;code class=&quot;inline&quot;&gt;test_array_access()&lt;/code&gt; 里的 &lt;code class=&quot;inline&quot;&gt;#if 0&lt;/code&gt;，实现 &lt;code class=&quot;inline&quot;&gt;lept_insert_array_element()&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;lept_erase_array_element()&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;lept_clear_array()&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;打开 &lt;code class=&quot;inline&quot;&gt;test_object_access()&lt;/code&gt; 里的 &lt;code class=&quot;inline&quot;&gt;#if 0&lt;/code&gt;，参考动态数组，实现第 5 部分列出的所有函数。&lt;/li&gt;&lt;li&gt;完成 &lt;code class=&quot;inline&quot;&gt;lept_copy()&lt;/code&gt; 里的数组和对象的复制部分。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 &lt;a href=&quot;https://github.com/miloyip/json-tutorial/issues&quot;&gt;issue&lt;/a&gt; 中提出，让所有人一起讨论。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-06-04-37618664</guid>
<pubDate>Mon, 04 Jun 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
