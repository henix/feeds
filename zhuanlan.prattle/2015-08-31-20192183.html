<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>这个周末，做了点小东西</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20192183">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/9cbe6e2ab891313dd778f79b966004d9_r.jpg" alt=""></div><p>昨晚临睡前，脑袋里突然蹦出一个想法，于是赶忙写了一些代码验证。这么一写便一发不可收拾，写兴奋导致一夜未眠，今早起来，拎了两罐红牛和一袋刚刚到货的九月份的soylent，感到公司开写。没想到，这一写就是一天。</p><br><p>这个项目起初的想法是如何在已有的网站前面做一层功能，防止恶意的爬虫爬整站的数据。如果是新做一个网站，方法还是不少，毕竟输出的内容自己可控；但若是考虑到对于已有的网站，不想因此改变网站的代码，所以还是有一些难度。</p><br><p>在今年大概三月份的时候，我写了篇文章介绍shapesecurity。这家公司做的是安全领域的一个有意思的点：antibot。它通过实时改变网页里面表单的信息，每次访问都得到不同的表单id/name，来混淆视听，让bot无法施展。</p><br><img src="https://pic3.zhimg.com/50a6e21f17ac8416c8ef486fee77d1e1_r.jpg" data-rawwidth="522" data-rawheight="125"><br><img src="https://pic1.zhimg.com/cd54f652fd416e6e3397d80131e9da0f_r.jpg" data-rawwidth="522" data-rawheight="125"><p>这两者背后的思想比较接近，除了要做一个http proxy来处理内容的修改（以及请求的重构）外，就是要让修改的html不影响css和js的执行。比如你把表单关于姓名的输入框的id修改成了 'i7Esx82xP'，那么，对应的css和js，如果有相应的代码处理这个id，那么，也需要一同修改。之前我曾经用elixir做了个简单的http proxy，能够修改html里任意部分，但css/js如何处理，一直没有好的思路，字符串替换有各种问题，而解析语法又把这件事的门槛一下大大提高了，所以后来就作罢；最近正好别的项目需要做个小parser，研究好些生成parser的工具，发现了html/css/js都有很不错的成型的parser，使得做语法解析这件事，我不必从BNF开始，而是直接跳到如何transform语法树（AST），最后再输出即可。</p><br><p>这些parser都是基于javascript的，所以这个项目我需要基于javascript。真巧手头另一个项目在尝试es6，于是整个项目我就拿es6撰写，并且严格遵循airbnb的javascript style guide（<a href="https://github.com/airbnb/javascript" data-editable="true" data-title="airbnb/javascript · GitHub">airbnb/javascript · GitHub</a>）。</p><br><p>为了让项目比较通用，我把代码划分成processor和rule。rule暴露给用户，用户可以决定在一棵语法树下，哪些节点他关心，至于如何遍历，则由processor完成。遍历的结果交给用户的rule里定义的transform函数，由该函数处理。为了让语法树一次遍历可以把所有定义的rule都处理完，还是颇费了些功夫，又动态生成了些middleware，在遍历树的过程中依次调用。</p><br><p>看一个完整的流程可能比较好理解。假设我们要把一个html文件里的所有css，不管是内联的还是外联的，统统生成一个css文件，并且在html的语法树里删除旧的css定义，放入新的；js也如法炮制。整个过程如下：</p><br><img src="https://pic2.zhimg.com/c491ca47b1944f38df99dfceef8e74f1_r.jpg" data-rawwidth="568" data-rawheight="240"><br><p>这段代码很简单，从文件读入一个html，使用两条rule，生成语法树，transform，然后再生成html。</p><br><p>我们看css rule的定义：</p><br><img src="https://pic2.zhimg.com/d6b96eb4414dc18d1843c1f10fce2024_r.jpg" data-rawwidth="729" data-rawheight="169"><br><p>里面有两组filter，第一组是找tag是link，属性包含 rel='stylesheet' 的。这是外联的css；第二组是找tag是style的，这个是内联的css。两组filter是或的关系。results存找到的结果，tranform是处理的函数，我们稍后再说。</p><br><p>当html文件内容被读入，语法数生成以后，我们根据rule来做transform：</p><br><img src="https://pic2.zhimg.com/3eed9a6b7c753154343fc672bc7fcebe_r.jpg" data-rawwidth="649" data-rawheight="230"><br><p>transform的代码很简单，对语法树应用rule。我们看findNode:</p><br><img src="https://pic4.zhimg.com/2c27bfb1ca0c36bf54315b9ccb9c094b_r.jpg" data-rawwidth="524" data-rawheight="320"><br><p>findNode首先根据rule里面的filter生成一个middleware数组。如果用户定义的filter超过一组，那么filter组和组的关系是或的关系，在一组filter内部，如果有多个函数，则是与的关系。这段代码用了ramda这个很好用的js下的函数式编程的库。感兴趣的同学可以试用。函数式编程可以让你的代码变得简洁清晰。根据rule的filter生成的middleware其实是一个判断：如果满足filter的条件，那么就把当前遍历到的节点插入到rule的results里。</p><br><p>生成好的middlewares会交给traverse里使用。当一棵树遍历完成后，再对rule的results用定义好的transform函数进行处理。</p><br><p>我们看traverse：</p><img src="https://pic4.zhimg.com/1adbde310902bfe5b2da60023b352d94_r.jpg" data-rawwidth="382" data-rawheight="171"><br><br><p>traverse很简单，遍历到的一棵子树，调用所有的middlewares处理，然后继续遍历下去。</p><br><p>我们再看rule下的transform究竟做了什么：</p><br><img src="https://pic1.zhimg.com/a8f8bd06af5483ca241e685d97953cb8_r.jpg" data-rawwidth="836" data-rawheight="633"><br><p>之前，css rule里的transform是这么定义的：</p><br><code lang="text">combineNodes('css', fileAdapter(name))</code><p>这里返回的接受items的匿名函数就是在findNode里调用的transform函数。这个函数把找到的节点里的css相关的信息找出来，然后处理。由于css外联的是一个文件（getUrl），内联的是一段文字（#text），我们要把这些内容都交给 concat 来处理，不好统一成一个接口。文件无论是从fs还是从http里读取，获取都是一个异步的过程，而内联的css本身内容就在那里，是个同步的过程。为了消弭两者的区别，这里我都使用了 Promise 来封装，只不过，内联css是个立刻就能 resolve 的 Promise。这样处理后，就可以把他们压在一个数组里，传给 concat 来处理了：</p><br><img src="https://pic1.zhimg.com/a104afb779e3ca8dada8f034962076aa_r.jpg" data-rawwidth="620" data-rawheight="169"><br><p>concat 很简单，处理所有 Promise，然后把读取的内容连接起来，写入文件。为了让整个框架更灵活，concat 可以有 fileConcat 和 redisConcat 等。用户也可以自定义。</p><br><p>主要的代码就这么些，如果想了解更多，可以fork/star这个项目：</p><br><p><a href="https://github.com/tyrchen/transformer" data-editable="true" data-title="tyrchen/transformer · GitHub">tyrchen/transformer · GitHub</a></p><br><p>项目自带一个example，可以在examples的目录下运行（请照着readme操作）。</p><br><p>末了，说几句es6。es6基本上已经势不可挡了，最新发布的很多js项目都开始用es6撰写了，es6的lambda函数（⇒）很好用，大大节省代码量。另外，let/const真的很赞。es5时代我都是写CoffeeScript，如今，我已经不是那么想CoffeeScript了。</p><br><p>如果您觉得这篇文章不错，请点赞。多谢！</p><br><p>欢迎订阅公众号『程序人生』（搜索微信号 programmer_life）。每篇文章都力求原汁原味，北京时间中午12点左右，美西时间下午8点左右与您相会。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
