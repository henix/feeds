<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>First Lens to Lenses</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/58868310">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-0ab22bd71bf809dd634a62d79be068b5_b.jpg" alt=""></div><h2>前言</h2><p>Haskell中有一个很强大的库，叫做Lens。</p><p>在Haskell中，只提供了「模式匹配」的语法来访问/修改数据结构。于是处理深层的数据就成为了老大难的问题。</p><p>比如在这样的数据结构里：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> 
    <span class="p">{</span> <span class="n">positionX</span> <span class="ow">::</span> <span class="kt">Double</span>
    <span class="p">,</span> <span class="n">positionY</span> <span class="ow">::</span> <span class="kt">Double</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Segment</span> <span class="ow">=</span> <span class="kt">Segment</span>
    <span class="p">{</span> <span class="n">segmentStart</span> <span class="ow">::</span> <span class="kt">Point</span>
    <span class="p">,</span> <span class="n">segmentEnd</span> <span class="ow">::</span> <span class="kt">Point</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="nf">p1</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="nf">p2</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="nf">l1</span> <span class="ow">=</span> <span class="kt">Segment</span> <span class="n">p1</span> <span class="n">p2</span>
</code></pre></div><p>我们要修改l1的第二个端点的横坐标：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">l1</span> <span class="p">{</span><span class="n">segmentEnd</span> <span class="ow">=</span> <span class="p">(</span><span class="n">segmentEnd</span> <span class="n">l1</span><span class="p">)</span> <span class="p">{</span><span class="n">positionX</span> <span class="ow">=</span> <span class="mi">10</span><span class="p">}}</span>
</code></pre></div><p>如果数据结构更加复杂的时候，代码就会变得更冗长。</p><p>这时候Lens库就出场了,刚刚那段代码等价于：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">l1</span> <span class="o">&amp;</span> <span class="n">endLens</span> <span class="o">.</span> <span class="n">xLens</span> <span class="o">.~</span> <span class="mi">10</span>
</code></pre></div><p>其中endLens . xLens就是一个透镜组，先访问end，再访问x，.~就是set。很composable有木有。</p><p>但是我们打开Hackage想要看看Lens究竟是啥的时候，第一眼就被lens的类型吓到了：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Lens</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">f</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span>
</code></pre></div><p>这是啥！？</p><p>当我们打开某乎，搜索关键字，想看看各路dalao的解释的时候，又被吓到了：</p><blockquote> 一个Lens不过就是Coalgebra for the CoState Comonad，这有什么难理解的。<br> </blockquote><p>这又是啥！？</p><p>不懂不懂！但这不妨碍我们自己去摸索……</p><h2>从零开始的getter和setter</h2><p>无论是深层还是浅层，lens做的都是get和set的操作。我们先把getter和setter抽象出来。</p><p>数据b到数据a的getter和setter应该具有如下类型：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">getter</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">setter</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</code></pre></div><p>我们同时需要getter和setter，于是将这两个函数合起来：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">newtype</span> <span class="kt">GS</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">GS</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div><p>如果现在有一个GS b a， 我就可以对b进行set或者get的操作了：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">set</span> <span class="ow">::</span> <span class="kt">GS</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">set</span> <span class="p">(</span><span class="kt">GS</span> <span class="n">gs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">flip</span> <span class="o">$</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">gs</span> 

<span class="nf">get</span> <span class="ow">::</span> <span class="kt">GS</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">get</span> <span class="p">(</span><span class="kt">GS</span> <span class="n">gs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">gs</span>
</code></pre></div><p>对于Point到Double类型，我们可以写下一些GS：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">xGS</span><span class="p">,</span> <span class="n">yGS</span> <span class="ow">::</span> <span class="kt">GS</span> <span class="kt">Point</span> <span class="kt">Double</span>
<span class="nf">xGS</span> <span class="ow">=</span> <span class="kt">GS</span> <span class="p">(</span><span class="nf">\</span><span class="n">p</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">p</span> <span class="p">{</span> <span class="n">positionX</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">},</span> <span class="n">positionX</span> <span class="n">p</span><span class="p">))</span>
<span class="nf">yGS</span> <span class="ow">=</span> <span class="kt">GS</span> <span class="p">(</span><span class="nf">\</span><span class="n">p</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">p</span> <span class="p">{</span> <span class="n">positionY</span> <span class="ow">=</span> <span class="n">y</span> <span class="p">},</span> <span class="n">positionY</span> <span class="n">p</span><span class="p">))</span>
</code></pre></div><p>我们可以像Lens一样，对Point进行get和set：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">get</span> <span class="n">xGS</span> <span class="n">p1</span> <span class="c1">-- = 1.0</span>
<span class="nf">set</span> <span class="n">yGS</span> <span class="mi">10</span> <span class="n">p2</span> <span class="c1">-- = Point 3.0 10.0</span>
</code></pre></div><p>Lens有一个很重要的性质就是可组合性，多个lens可以组合在一起。不知GS能不能做到呢，先写下类型：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="p">(</span><span class="o">&gt;.</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">GS</span> <span class="n">c</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">GS</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">GS</span> <span class="n">c</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&gt;.</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">_</span>
</code></pre></div><p>（此处省略填坑的步骤）我们可以写出组合GS的代码！</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">infixr</span> <span class="mi">9</span> <span class="o">&gt;.</span>
<span class="p">(</span><span class="o">&gt;.</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">GS</span> <span class="n">c</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">GS</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">GS</span> <span class="n">c</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&gt;.</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">GS</span> <span class="n">cbl</span><span class="p">)</span> <span class="p">(</span><span class="kt">GS</span> <span class="n">bal</span><span class="p">)</span> <span class="ow">=</span> 
    <span class="kt">GS</span> <span class="o">$</span> <span class="nf">\</span><span class="n">c</span> <span class="ow">-&gt;</span> 
        <span class="kr">let</span> <span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">cbl</span> <span class="n">c</span> <span class="kr">in</span>
            <span class="kr">let</span> <span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bal</span> <span class="n">b</span> <span class="kr">in</span> 
                <span class="p">(</span><span class="n">bc</span> <span class="o">.</span> <span class="n">ab</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>验证一下：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">get</span> <span class="p">(</span><span class="n">endGS</span> <span class="o">&gt;.</span> <span class="n">xGS</span><span class="p">)</span> <span class="n">l1</span> <span class="c1">-- get x of the end of l1 = 3</span>
<span class="nf">set</span> <span class="p">(</span><span class="n">endLens</span> <span class="o">&gt;.</span> <span class="n">xLens</span><span class="p">)</span> <span class="mi">10</span> <span class="n">l1</span> <span class="o">--...</span>
</code></pre></div><p>！好耶，我们的GS也是可以组合的！这就是我们的Lens！那么我们也给它一个Lens的名字吧！</p><p>附上：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">newtype</span> <span class="kt">MyLens</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MyLens</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

<span class="nf">set</span> <span class="ow">::</span> <span class="kt">MyLens</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">set</span> <span class="p">(</span><span class="kt">MyLens</span> <span class="n">lens</span><span class="p">)</span> <span class="ow">=</span> <span class="n">flip</span> <span class="o">$</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">lens</span> 

<span class="nf">view</span> <span class="ow">::</span> <span class="kt">MyLens</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">view</span> <span class="p">(</span><span class="kt">MyLens</span> <span class="n">lens</span><span class="p">)</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">lens</span>

<span class="nf">over</span> <span class="ow">::</span> <span class="kt">MyLens</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">over</span> <span class="n">lens</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">set</span> <span class="n">lens</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">view</span> <span class="n">lens</span> <span class="n">b</span><span class="p">))</span> <span class="n">b</span>

<span class="nf">compLens</span> <span class="ow">::</span> <span class="kt">MyLens</span> <span class="n">c</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">MyLens</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MyLens</span> <span class="n">c</span> <span class="n">a</span>
<span class="nf">compLens</span> <span class="p">(</span><span class="kt">MyLens</span> <span class="n">cbl</span><span class="p">)</span> <span class="p">(</span><span class="kt">MyLens</span> <span class="n">bal</span><span class="p">)</span> <span class="ow">=</span> 
    <span class="kt">MyLens</span> <span class="o">$</span> <span class="nf">\</span><span class="n">c</span> <span class="ow">-&gt;</span> 
        <span class="kr">let</span> <span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">cbl</span> <span class="n">c</span> <span class="kr">in</span>
            <span class="kr">let</span> <span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bal</span> <span class="n">b</span> <span class="kr">in</span> 
                <span class="p">(</span><span class="n">bc</span> <span class="o">.</span> <span class="n">ab</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> 

<span class="kr">infixr</span> <span class="mi">9</span> <span class="o">&gt;.</span>
<span class="p">(</span><span class="o">&gt;.</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">MyLens</span> <span class="n">c</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">MyLens</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MyLens</span> <span class="n">c</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&gt;.</span><span class="p">)</span> <span class="ow">=</span> <span class="n">compLens</span>

<span class="kr">infixl</span> <span class="mi">8</span> <span class="o">^.</span>
<span class="p">(</span><span class="o">^.</span><span class="p">)</span> <span class="ow">=</span> <span class="n">flip</span> <span class="n">view</span>

<span class="kr">infixr</span> <span class="mi">4</span> <span class="o">%~</span>
<span class="p">(</span><span class="o">%~</span><span class="p">)</span> <span class="ow">=</span> <span class="n">over</span>

<span class="kr">infixr</span> <span class="mi">4</span> <span class="o">.~</span>
<span class="p">(</span><span class="o">.~</span><span class="p">)</span> <span class="ow">=</span> <span class="n">set</span>

<span class="kr">infixl</span> <span class="mi">1</span> <span class="o">&amp;</span> 
<span class="nf">x</span> <span class="o">&amp;</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</code></pre></div><h2>大胆猜想 小心求证</h2><p>可是我们现在得到的是<code>b -&gt; (a -&gt; b, a)</code>和库里的<code>forall f. Functor f. (a -&gt; f b) -&gt; (s -&gt; f t)</code>八竿子打不着啊。难道它们冥冥之中有什么关系！？</p><p>我们看一个lens的一个简化版本</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Lens'</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Lens</span> <span class="n">b</span> <span class="n">b</span> <span class="n">a</span> <span class="n">a</span> <span class="c1">--forall f. Functor f. (a -&gt; f a) -&gt; (b -&gt; f b)</span>
</code></pre></div><p>调一下参数的位置就有<code>b -&gt; forall f. Functor f. (a -&gt; f a) -&gt; f b</code>，跟<code>b -&gt; (a -&gt; b, a)</code>进行比较，不同的是<code>forall f. Functor f =&gt; (a -&gt; f a) -&gt; f b</code>和<code>(a -&gt; b, a)</code>这两部分。</p><p>如果这两部分是等价的（isomorphism），不就可以得到MyLens和Lens'也等价了吗！？</p><p>于是大胆猜想：<b><code>forall f. Functor f =&gt; (a -&gt; f a) -&gt; f b</code>和<code>(a -&gt; b, a)</code>是等价的</b></p><p>然后小（shi）心（fen）论（cao）证（shuai），（省略填hole的n步），我们写出了：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">phi</span> <span class="ow">::</span><span class="p">(</span><span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">phi</span> <span class="n">lensPart</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">lensPart</span> <span class="n">afa</span> <span class="kr">in</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">snd</span> <span class="n">p</span><span class="p">,</span> <span class="n">fst</span> <span class="n">p</span><span class="p">)</span> 
    <span class="kr">where</span>
        <span class="n">afa</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- f = (a,)</span>
        <span class="n">afa</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">psi</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">psi</span> <span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="n">afa</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">ab</span> <span class="o">$</span> <span class="n">afa</span> <span class="n">a</span>
</code></pre></div><p>！好耶我们证明了MyLens和Lens'是等价的！</p><h2>泛化的版本</h2><p>但是，Lens库里提供的Lens是这样的：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Lens</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">f</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span>
</code></pre></div><p>这又是什么意思呢？现在先别管这个，我们继续来看我们自己造的Lens。</p><p>现在我们可以写出这样的代码：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">_1</span> <span class="ow">::</span> <span class="kt">MyLens</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span>
<span class="nf">_1</span> <span class="ow">=</span> <span class="kt">MyLens</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">a'</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a'</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">a</span><span class="p">))</span>

<span class="nf">_2</span> <span class="ow">::</span> <span class="kt">MyLens</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="n">b</span>
<span class="nf">_2</span> <span class="ow">=</span> <span class="kt">MyLens</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">b'</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b'</span><span class="p">),</span> <span class="n">b</span><span class="p">))</span>

<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_1</span> <span class="o">.~</span> <span class="mi">10</span> <span class="c1">-- = (10, 2)</span>
<span class="c1">--set _1 10 (1, 2)</span>

<span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="s">"Ho Ho Ho"</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_1</span> <span class="o">&gt;.</span> <span class="n">_2</span><span class="p">)</span> <span class="o">.~</span> <span class="s">"How bad could it be?"</span> 
<span class="c1">-- ((1, "How bad could it be?"), 2)</span>
</code></pre></div><p>但是我们暂时写不出：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_1</span> <span class="o">.~</span> <span class="sc">'1'</span> <span class="c1">--期望得到('1', 2)</span>
</code></pre></div><p>这样的代码，会报错：</p><p><code>? Could not deduce (Num Char) arising from the literal ‘1’       from the context: Num b         bound by the inferred type of it :: Num b =&gt; (Char, b)         at &lt;interactive&gt;:2:1-18</code></p><p>这是因为MyLens对getter和setter的抽象，限制了set进去的东西要和get到的东西具有同样的类型，并且set完之后的类型要和set之前一样：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">getter</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="c1">--             ^ here，这是get到的值的类型</span>
<span class="nf">setter</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="c1">--             ^ here，这是set进去的值的类型</span>
</code></pre></div><p>我们可以来消除这个限制，将getter和setter抽象为：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">getter</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="c1">-- 从s中get到a</span>
<span class="nf">setter</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="c1">--把s中的a set为b，s变为t</span>
</code></pre></div><p>于是MyLens可以重写为：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">newtype</span> <span class="kt">MyLens</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">MyLens</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
<span class="c1">-- getter :: s -&gt; a</span>
<span class="c1">-- setter :: s -&gt; b -&gt; t</span>
<span class="c1">-- set, view, over, (&gt;.)等的实现和之前完全一样!</span>
</code></pre></div><p>现在我们就可以写出：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_1</span> <span class="o">.~</span> <span class="sc">'1'</span> <span class="c1">-- ('1', 2)</span>
</code></pre></div><p>那么，问题来了，现在这个MyLens的版本是否是和库里的Lens等价呢？现在也给出一个证明（省略填hole过程）：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Lens</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Helper</span> <span class="n">a</span> <span class="n">b</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Helper</span> <span class="p">{</span> <span class="n">unHelper</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="nf">psi</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span>
<span class="nf">psi</span> <span class="p">(</span><span class="n">bt</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="n">afb</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">bt</span> <span class="o">$</span> <span class="n">afb</span> <span class="n">a</span>

<span class="nf">phi</span> <span class="ow">::</span><span class="p">(</span><span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">phi</span> <span class="n">lensPart</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">unHelper</span> <span class="o">$</span> <span class="n">lensPart</span> <span class="n">afb</span> <span class="kr">in</span> <span class="p">(</span><span class="n">snd</span> <span class="n">p</span><span class="p">,</span> <span class="n">fst</span> <span class="n">p</span><span class="p">)</span> 
    <span class="kr">where</span>
        <span class="n">afb</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Helper</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b</span> <span class="c1">-- f = (a, b -&gt; _)</span>
        <span class="n">afb</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Helper</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
</code></pre></div><h2>Further more?</h2><p>到这里，我们已经得到了一个属于自己的Lens。我们也会用它从一些数据结构中的字段，但是Lens远远不是只有这点威力。</p><p>首先，MyLens中的getter和setter其实是抽象的，<code>getter :: b -&gt; a</code>a并不一定指的是b中的字段，而就是一个普普通通的函数。比如我设写一个lens，从[a]中get到length，而set并不改变值：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">_length</span> <span class="ow">::</span> <span class="kt">MyLens</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kt">Int</span> <span class="n">b</span>
<span class="nf">_length</span> <span class="ow">=</span> <span class="kt">MyLens</span> <span class="o">$</span> <span class="nf">\</span><span class="n">as</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">const</span> <span class="n">as</span><span class="p">,</span> <span class="n">length</span> <span class="n">as</span><span class="p">)</span>
</code></pre></div><p>我们根据这个_length可以写出一些代码：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">view</span>  <span class="n">_length</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c1">-- 3</span>
<span class="nf">view</span> <span class="p">(</span><span class="n">_1</span> <span class="o">&gt;.</span> <span class="n">_length</span><span class="p">)</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s">"Tora!Tora!Tora!"</span><span class="p">)</span> <span class="c1">-- 3 </span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">_length</span> <span class="o">.~</span> <span class="s">"123"</span> <span class="c1">-- [1, 2, 3]</span>
</code></pre></div><p>至此，我们发现MyLens和库中的Lens并没有什么使用上的不同（毕竟是等价的）。而MyLens这么直观，为何库中Lens要采用这种形式呢？我现在是不知道的，但我仍然被库中的Lens所折服：</p><ul><li><code>(a -&gt; f b) -&gt; (s -&gt; f t)</code>形式优美，跟CPS变换有很深的联系。</li><li>通过取不同的函子，能达到不同层次的抽象，实现不同的行为。（而MyLens就做不了很多其它抽象了。比如说Lens库中的Traversal，不过这个其实是我自己写不出行为一致的代码，从而下的断言）</li></ul><p><br></p><p>下面开始解答前面的一些问题：</p><h2>Co-Algebra for Co-State Co-Monad?</h2><p>回到前文提到，ekmett大神说过：</p><blockquote> 一个Lens不过就是Coalgebra for the CoState Comonad，这有什么难理解的。<br> </blockquote><p>我们也验证一下这句abstract nonsense</p><ul><li>首先CoState Comonad就是Haskell中的Store</li></ul><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Store</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Store</span> <span class="p">(</span><span class="n">s</span><span class="ow">-&gt;</span><span class="n">a</span><span class="p">)</span> <span class="n">s</span>
</code></pre></div><p>也就是<code>(s-&gt;a, s)</code>。它是一个Comonad，自然也就是一个Endofunctor</p><ul><li>然后CoAlgebra for Endofunctor f就是一个a，和一个态射</li></ul><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">CoAlgebra</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div><ul><li>最后Coalgebra for the CoState Comonad就是</li></ul><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kt">CoAlgebra</span> <span class="p">(</span><span class="kt">Store</span> <span class="n">s</span><span class="p">)</span> <span class="n">a</span>   
<span class="c1">-- -&gt;   </span>
<span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Store</span> <span class="n">s</span> <span class="n">a</span>  
 <span class="c1">-- ~   a -&gt;(s-&gt;a, s)</span>
</code></pre></div><p>这玩意儿就是咱们定义的MyLens的初始版本。</p><p>哦！这句话原来是这个意思（我怎么还是啥都没学到）</p><h2>Yoneda lemma？</h2><p>Yoneda lemma说的是，对象A和函子F满足：</p><p><img src="https://www.zhihu.com/equation?tex=+Nat%28Hom%28A%2C%5C_%29%2C+F%29+%5Ccong+F%5C+A+" alt=" Nat(Hom(A,\_), F) \cong F\ A " eeimg="1"> </p><p>在Haskell中，在*范畴，可以具体写出：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Yoneda</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="c1">-- 与</span>
<span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="c1">-- 等价</span>
</code></pre></div><p>我们观察到<code>forall f. Functor f =&gt; (a -&gt; f a) -&gt; f b</code>和形式1是很像的，那有没有可能两种Lens的等价关系可以由Yoneda lemma导出呢？</p><p><br></p><p>直觉是对的，但是这里要绕点弯子：</p><p>首先Yoneda lemma是对所有的范畴都成立的，我们可以看一下在自函子范畴的形式是怎么样的（伪代码）：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="c1">-- eta :: (*-&gt;*)-&gt;*, 函子的函子</span>
<span class="kr">type</span> <span class="kt">Yoneda</span> <span class="n">eta</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> 
    <span class="n">forall</span> <span class="n">g</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">g</span> <span class="ow">=&gt;</span> 
        <span class="n">forall</span> <span class="n">t</span><span class="o">.</span> <span class="p">(</span><span class="n">f</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="n">t</span><span class="p">)</span> <span class="c1">--f到g的自然变换，也就是函子间的态射，Hom(f, _)</span>
        <span class="ow">-&gt;</span> <span class="n">eta</span> <span class="n">g</span>
<span class="c1">-- 与</span>
<span class="nf">eta</span> <span class="n">f</span>
<span class="c1">-- 等价</span>
</code></pre></div><p><br></p><p>现在给一个不严谨的证明：</p><p>将<code>eta g = g b</code>，<code>f t = (a, a-&gt;t)</code>代入在自函子范畴上的Yoneda lemma，得到</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">forall</span> <span class="n">g</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">g</span> <span class="ow">=&gt;</span> 
    <span class="n">forall</span> <span class="n">t</span><span class="o">.</span> <span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">t</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="n">t</span><span class="p">)</span> 
    <span class="ow">-&gt;</span> <span class="n">g</span> <span class="n">b</span>
<span class="c1">-- 与</span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span>
<span class="c1">-- 等价</span>
</code></pre></div><p>（很接近了！）</p><p>对形式1中<code>forall t. ((a, a-&gt;t) -&gt; g t)</code>进行curry化，得到<code>a -&gt; forall t. (a-&gt;t) -&gt; g t</code>。</p><p>对<code>forall t. (a-&gt;t) -&gt; g t</code>应用*范畴下的Yoneda lemma，替换成<code>g a</code>。</p><p>于是形式1等价于</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">forall</span> <span class="n">g</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">g</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="n">b</span>
</code></pre></div><p>于是就得到了：</p><p><code>forall g. Functor g =&gt; (a -&gt; g a) -&gt; f b</code>和<code>(a -&gt; b, a)</code>是等价的！</p><p>（目的达成！功德圆满！）</p><h2>后记</h2><p>终于能拿两三天来瞅瞅Lens库，着实被Lens库的优美所震撼！然后又按图索骥，自己鼓捣出上面这些东西，真的挺满足的。说是填hole，但其实都是在草稿纸上推的。。。然后灵光一闪填一个函子进去，然后就ok了。不过过程中我是想用idris来证明那些等价关系的，最后发现idris写出来的东西很冗长，于是就算了，毕竟也没用上dt。</p><p>然后就是我到现在对MyLens是否能实现Traversal的功能，我还是存疑的，望大佬解惑。写过这样一个函数：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">traverse'</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Traversable</span> <span class="n">f</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MyLens</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span>
<span class="nf">traverse'</span> <span class="ow">=</span> <span class="kt">MyLens</span> <span class="p">(</span><span class="nf">\</span><span class="n">fa</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">fa</span><span class="p">,</span> <span class="n">fold</span> <span class="n">fa</span><span class="p">))</span>
</code></pre></div><p>发现行为和traverse之于Lens不一致。（就不应该出现fold fa的）。。。就很困惑，直觉告诉我是写不出来的。又尝试将Helper a b实现了Applicative，再代入一个同构的map中，得到的行为也不一致555。</p><p>关于标题双关：</p><ul><li>Lens to Lenses就是从自己写的Lens再看库里的Lens</li><li>第一个Lens作动词，想表达focus的意思（生掰），就是关注Lens（及背后的一些东西）</li></ul><p>最后 望各路大神指正（溜了</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
