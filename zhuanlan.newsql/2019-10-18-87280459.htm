<div class="title-image"><img src="https://pic1.zhimg.com/v2-206d9738b5b3622f8c51640f2a38a2e6_b.jpg" alt=""></div><p>作者：黄东旭</p><blockquote>“TiDB，你已经是一个成熟的数据库了，该学会用自己的 SQL 查自己的状态了。”</blockquote><p>对于一个成熟的数据库来说，通过 SQL 来查询系统本身的状态再正常不过，对于 MySQL 来说 <code>INFOMATION_SCHEMA</code> 和 <code>PERFORMANCE_SCHEMA</code> 里面有大量的信息，基本上通过查询些信息，DBA 就能对整个系统的运行状态一目了然。最棒的是，查询的接口正是 SQL，不需要依赖其他的第三方工具，运用表达力强大的 SQL 甚至可以对这些信息进行二次加工或者过滤，另外接入第三方的运维监控工具也很自然，不需要引入新的依赖。</p><p>过去由于种种原因，TiDB 很多的内部状态信息是通过不同组件暴露 RESTFul API 来实现，这个方案也不是不好，但是随着 API 的增多，管理成本越来越高，举一个例子：在不参考文档的前提下，用户是很难记住那么多 RESTFul API 的路径的，只能通过将这些 API 封装成命令行工具来使用，但是如果这是一张系统表，只需要一句 <code>SHOW TABLES</code> 和几条 <code>SELECT</code> 就能够了。当然选择 RESTFul API 还有其他的原因，例如有些操作并不是只读的，是类似命令的形式，例如：手动 split region 这类操作，使用 RESTFul API 会更好，这两者其实并不矛盾，系统表当然是一个很好的补充，这是提升整体软件易用性的一个好例子。</p><p><b>今天正好有一些时间，花了几十分钟完整的走了一遍流程，给 TiDB 的</b> <b><code>INFORMATION_SCHEMA</code></b> <b>添加了一张名为</b> <b><code>TIDB_SERVERS_INFO</code></b> <b>的表，用来显示集群中所有活着的 tidb-server 的状态信息（基本和</b> <b><code>/info/all</code></b> <b>做的事情差不多），意在抛砖引玉，社区的小伙伴可以参照这篇博客添加新的有用的信息。</b></p><p>有这个想法后，我的直觉是去找 <code>information_schema</code> 的代码看看别的系统表是怎么实现的，照猫画虎就 OK 了（😁没毛病）。 TiDB 的代码组织还算比较直观，在 tidb repo 的根目录下直接看到了一个包叫 <code>infoschema</code>，感觉就是它，打开 <code>inforschema/table.go</code> 后确实应证了我的猜想，文件开头集中定义了很多字符串常量：</p><div class="highlight"><pre><code class="language-text">...
tableTiKVStoreStatus                	= &#34;TIKV_STORE_STATUS&#34;
tableAnalyzeStatus                  	= &#34;ANALYZE_STATUS&#34;
tableTiKVRegionStatus               	= &#34;TIKV_REGION_STATUS&#34;
tableTiKVRegionPeers                	= &#34;TIKV_REGION_PEERS&#34;
...</code></pre></div><p>这些常量正是 TiDB 的 <code>INFOMATION_SCHEMA</code> 中的表名，根据这些变量顺藤摸瓜可以找到同文件里面的 <code>tableNameToColumns</code> 这个 map，顾名思义应该是这个 map 通过表名映射到表结构定义，随便打开一个，果然如此：</p><div class="highlight"><pre><code class="language-text">var columnStatisticsCols = []columnInfo{
	{&#34;SCHEMA_NAME&#34;, mysql.TypeVarchar, 64, mysql.NotNullFlag, nil, nil}, 
	{&#34;TABLE_NAME&#34;, mysql.TypeVarchar, 64, mysql.NotNullFlag, nil, nil}, 
	{&#34;COLUMN_NAME&#34;, mysql.TypeVarchar, 64, mysql.NotNullFlag, nil, nil}, 
	{&#34;HISTOGRAM&#34;, mysql.TypeJSON, 51, 0, nil, nil}, 
}</code></pre></div><p>下一步需要如何填充数据返回给 TiDB 的 SQL Engine，我们注意到 <code>infoschemaTable</code> 这个类实现了 <code>table.Table interface</code>，很显然这个 interface 就是 TiDB 中对于 Table 获取数据/修改数据的接口，有关获取数据的方法是 <code>IterRecords</code>，我们只需要看到 <code>IterRecords</code> 中的实现就能知道这些系统表的数据是如何返回给 SQL Engine 的，果然在 <code>IterRecords</code> 里面有一个方法，<code>inforschemaTable.getRows()</code>，这个方法的定义中有一个巨大的 switch 语句，用于判断是在哪个系统表上，根据这个信息然后返回不同的数据：</p><div class="highlight"><pre><code class="language-text">...
switch it.meta.Name.O {
	case tableSchemata:
		fullRows = dataForSchemata(dbs)
	case tableTables:
		fullRows, err = dataForTables(ctx, dbs) 
	case tableTiDBIndexes: 
		fullRows, err = dataForIndexes(ctx, dbs) 
...
}</code></pre></div><p>Bingo! 感觉就是我们需要的东西。</p><p><b>现在步骤就很清楚了：</b></p><ol><li>在 <code>infoschema/tables.go</code> 中添加一个新的字符串常量 <code>tableTiDBServersInfo</code> 用于定义表名；</li><li>定义一个 <code>[]columnInfo：tableTiDBServersInfoCols</code>，用于定义这张系统表的结构；</li><li>在 <code>tableNameToColumns</code> 这个 map 中添加一个新的映射关系 <code>tableTiDBServersInfo =&gt; tableTiDBServersInfoCols</code>；</li><li>在 <code>infoschemaTable.getRows()</code> 方法中加入一个新的 <code>dataForTableTiDBServersInfo</code> 的 swtich case；</li><li>搞定。</li></ol><p>下一个目标是实现 <code>dataForTableTiDBServersInfo</code>，很显然，大致的思路是：</p><ol><li>找到这个集群的 PD，因为这些集群拓扑信息；</li><li>将这些信息封装成 <code>tableTiDBServersInfoCols</code> 中定义的形式，返回给 <code>getRows</code> 方法。</li></ol><p>通过传入的 ctx 对象，获取到 Store 的信息， <code>sessionctx.Context</code> 是 TiDB 中一个很重要的对象，也是 TiDB 贯穿整个 SQL 引擎的一个设计模式，这个 Context 中间存储在这个 session 生命周期中的一些重要信息，例如我们可以通过 <code>sessionctx.Context</code> 获取底层的 Storage 对象，拿到 Storage 对象后，能干的事情就很多了。</p><p>本着照猫画虎的原则，参考了一下 <code>dataForTiDBHotRegions</code> 的实现：</p><div class="highlight"><pre><code class="language-text">tikvStore, ok := ctx.GetStore().(tikv.Storage) </code></pre></div><p>因为我们的目标是获取 PD 对象，必然地，只有 TiKV 作为 backend 的时候才有 PD，所以这里的类型转换判断是必要的。</p><p>其实，通过 PD 获取集群信息这样的逻辑已经在 TiDB 中封装好了，我发现在 <code>domain/info.go</code> 中的这个方法正是我们想要的：</p><div class="highlight"><pre><code class="language-text">// GetAllServerInfo gets all servers static information from etcd. func (is *InfoSyncer) 
GetAllServerInfo(ctx context.Context) (map[string]*ServerInfo, error)</code></pre></div><p>实际上，TiDB 的 <code>/info/all</code> 这个 REST API 正是通过调用这个函数实现，我们只需要调用这个方法，将返回值封装好就完成了。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-5ecb9035e5753574aa3efa1f5119d097_b.jpg" data-caption="" data-size="normal" data-rawwidth="974" data-rawheight="275" class="origin_image zh-lightbox-thumb" width="974" data-original="https://pic4.zhimg.com/v2-5ecb9035e5753574aa3efa1f5119d097_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-5ecb9035e5753574aa3efa1f5119d097_b.jpg" data-caption="" data-size="normal" data-rawwidth="974" data-rawheight="275" class="origin_image zh-lightbox-thumb lazy" width="974" data-original="https://pic4.zhimg.com/v2-5ecb9035e5753574aa3efa1f5119d097_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-5ecb9035e5753574aa3efa1f5119d097_b.jpg"/></figure><p><b>自此，我们就完成了一个新的系统表的添加。在自己添加的新表上 SELECT 一下，是不是很有成就感 :) 欢迎大家在此基础上添加更多有用的信息。</b></p><p><b>阅读原文：</b></p><a href="https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/hands-on-build-a-new-system-table-for-tidb/" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg" data-image-width="1200" data-image-height="1200" class=" wrap external" target="_blank" rel="nofollow noreferrer">Hands-on! 如何给 TiDB 添加新系统表 | PingCAP</a><p></p>