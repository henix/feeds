<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>观察ChakraCore JIT生成的native code</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/23314157">原文</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/20792855" data-editable="true" data-title="前面">前面</a>介绍了ChakraCore的各个dump开关，可以用来查看编译的中间阶段的结果。这里介绍一下一个简单的JavaScript函数被编译成的native code像什么样子。</p><p>为了查看JIT code，一个办法是使用之前介绍的 -dump 开关查看encode阶段的结果（-dump:encoder）。另外ChakraCore支持一个选项是 -DebugBreak:FunctionNumber。FunctionNumber可以通过查看其它dump获得，比如 -dump:irbuilder，在JavaScript源文件没改变的话，即使是多次运行同一个函数的FunctionNumber也是不变的。-DebugBreak会导致encode阶段在函数入口插入一条断点指令（默默给encoder点个赞），比如x86和x64下的“int 3”，这样运行到该方法就会自然中断到调试器。</p><p>代查看的JavaScript源代码如下，要看的是其中 <b>access()</b> 的JIT code。 </p><code lang="js">// ch.exe -mic:1 -off:simplejit -DebugBreak:3
function Point(x, y) {
    this.x = x;
    this.y = y;
}

function access(pt) {
    return pt.x;
}

var pt = new Point(1, 2);
access(pt);
access(pt);</code><p>以x64为例，以下是JIT给上面 <b>access()</b> 生成native code的CFG（Control Flow Graph）, 因为比较大，分成2部分介绍。这个CFG是从WinDbg里面反汇编的代码生成的<a href="https://msdn.microsoft.com/en-us/library/dn966108.aspx" data-editable="true" data-title="DGML">DGML</a>，能在Visual Studio中直接查看。下图中每一个节点代表了一个basic block, 黑色实箭头是fallthough到下一个follower block, 红色的虚线箭头表示一个跳转（包括条件跳转和无条件跳转）。最上面的绿色节点代表函数入口而最下面的黄色节点是函数的退出block（含有 ret 指令）。</p><p><img src="https://pic3.zhimg.com/v2-aa2219e7fd629d34c5aed9a4a0c0d102_r.png" data-rawheight="840" data-rawwidth="1057">Control Flow Graph - part 1</p><img src="https://pic1.zhimg.com/v2-08ee1601080e718807bb1d83dd871031_r.png" data-rawheight="706" data-rawwidth="1696"><p>Control Flow graph - part 2 （注意顶上两条入边与part 1的底部相连）</p><ol><li>函数入口。1，2，3属于stack probe (对栈顶位置做一些基本检查，实现在 <a href="https://github.com/Microsoft/ChakraCore/blob/release/1.3/lib/Backend/amd64/LowererMDArch.cpp#L1630" data-editable="true" data-title="LowererMDArch::GeneratePrologueStackProbe">LowererMDArch::GeneratePrologueStackProbe</a> ）。检查StackLimit+FrameSize是否溢出，如溢出则跳至3做stack probe。</li><li>检查栈顶（RSP）有没有超出StackLimit，超过了则需进入3做stack probe。 <br></li><li>检查栈空间，如还有stack space则扩展StackLimit，否则抛出stack overflow（见<a href="https://github.com/Microsoft/ChakraCore/blob/master/lib/Runtime/Base/ThreadContext.cpp#L1700" data-editable="true" data-title="ThreadContext::ProbeStackNoDispose">ThreadContext::ProbeStackNoDispose</a>）。</li><li>把寄存器参数放进<a href="https://msdn.microsoft.com/en-us/library/ew5tede7.aspx" data-editable="true" data-title="home space">home space</a>，加载后面需要用到的常量，检查函数执行计数器（FunctionEntryPointInfo里面<a href="https://github.com/Microsoft/ChakraCore/blob/release/1.3/lib/Runtime/Base/FunctionBody.h#L988" data-editable="true" data-title="callsCount">callsCount</a>）是否超过255，没有则进入5将计数器加1。另外注意到打头的两条nop指令，是为了随机化JIT生成的native code。</li><li>把函数计数器加1。</li><li>检查传入参数个数。由于this引用被隐式传入，所以参数个数是实参个数+1。这里使用了AND指令是由于这里的参数个数存在了32-bit的低24-bit，高8位作为flag。</li><li>如果没有传入参数（除了this），则把undefined放入rcx寄存器。</li><li>把第一个参数放入rcx寄存器。</li><li>判断上面存入rcx的是否是对象指针。ChakraCore使用了float tagging，打上tag的值的第48-bit为0则其内容为指针，否则为其他值，如double, int。</li><li>已经判定第一个参数（RCX）位对象指针。ChakraCore里面对应JavaScript的Object对象的是DynamicObject，其偏移8的位置（如下图）存储了Js::Type对象的指针。这里的Type对象类似于v8的hidden class。在JIT编译的时候已经有profile信息。这里rax指向的类型对象的地址作为常量存在JIT生成的代码里就是从profile推导出来的。</li><li>判断当前的inline cache里面的类型是否匹配。第10步里检查的类型已经是常量，意味着传入任何其他类型的对象检查都会失败，如果直接退回（BailOut）interpreter，再重新JIT代价还是很大的。其实只要传入的参数的对象类型保持基本稳定，JIT生成的大部分代码还是有效，而不需要类型和最初JIT时profile里的类型一致。所以有了了inline cache（前面的常量也可以说是一种inline cache）。简单来看，它对应一个callsite，保存了访问的类型对象的地址和要访问的属性偏移，如果当前对象类型和inline cache里的一致的话，则使用inline cache里的偏移访问属性（进入第17步）。</li><li>从对象地址给定的偏移（0x10）获取属性，存入rbx。</li><li>JIT假定的类型和inline cache里面的类型都不匹配，调用<a href="https://github.com/Microsoft/ChakraCore/blob/master/lib/Runtime/Language/JavascriptOperators.cpp#L7180" data-editable="true" data-title="PatchGetValue">PatchGetValue</a>, 从本对象以及原型链里查找属性，根据查找的结果更新inline cache（PatchGetValue里面的Patch就是patch这个）。</li><li>把取得的属性从rbx复制到rax。</li><li>在第9步获取的不是对象指针的情况下（比如传入了一个数值而不是对象），bailout回interpreter执行，重新获取profile。</li><li>返回。</li><li>从inline cache里面获取属性偏移，取得属性值。</li></ol><p>以上就是一个最简单的方法JIT后的native code的简单描述，其中有些步骤还比较复杂 ，以后再专门展开。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
