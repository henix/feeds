<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>杨博的长长的答案</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Tue, 30 Jan 2018 23:40:09 +0800</lastBuildDate>
<item>
<title>JVM也是玄学</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2018-01-30-33445689.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;JVM也是玄学&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33445689&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前段时间， &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/7fa583366d87dfe45694c2057b98cb12&quot; data-hash=&quot;7fa583366d87dfe45694c2057b98cb12&quot; data-hovercard=&quot;p$b$7fa583366d87dfe45694c2057b98cb12&quot;&gt;@陈亮&lt;/a&gt; 发现一件怪事，&lt;a href=&quot;https://www.zhihu.com/question/58735131/answer/158460810&quot;&gt;java循环长度的相同、循环体代码相同的两次for循环的执行时间相差了100倍&lt;/a&gt;！&lt;/p&gt;&lt;p&gt;有些同学说这是因为GC或者cache missing。但我掐指一算，这些同学可能是错的。&lt;/p&gt;&lt;p&gt;因为，就算空跑这么多次循环也不止15毫秒。&lt;/p&gt;&lt;p&gt;考虑到15毫秒是Windows里计时器的最小间隔，跑出15毫秒只有一个可能：JVM的优化编译器发现整段循环都没有副作用，于是把整个循环全删了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不过回答装箱拆箱的同学可能沾点边，因为这段代码中，JVM决定是否能把整段循环删掉取决于它怎么分析Integer.valueOf。&lt;/p&gt;&lt;p&gt;在JVM不优化的情况下，每次内层循环会调用Integer.value 8000次，其中有读取7999次缓存，创建1次new Integer。如果JVM把valueOf和new Integer都内联，然后做了逃逸分析的话，new Integer是可以完全优化掉的。&lt;/p&gt;&lt;p&gt;虽然new Integer调用次数很少，但是JVM需要把new Integer内联之后才能分析出整段代码都没有副作用。所以我猜测new Integer是否被内联可能是影响性能的关键因素。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不幸的是，JVM的优化行为，对用户来说很难预测。&lt;/p&gt;&lt;p&gt;比如实际上new Integer的调用次数相当少。由于new Integer不是热点，JVM倾向于不内联new Integer那也不奇怪。&lt;/p&gt;&lt;p&gt;更难预测之处在于，在嵌套函数调用的情况下，JVM先内联里层还是先内联外层也会对优化结果产生影响。本文的例子倒还好说，如果涉及forEach之类的高阶函数调用时，会碰上monomorphic call的问题，虽然外层函数调用次数很少，但必须内联外层才能消除内层的虚函数调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;总而言之，这种代码属于JVM的阴暗角落，就好像C语言里的i+++++i一样恶心。对于应用开发者来说，如果不是特别在乎性能的场合，别碰。甚至说不定升级一下JVM，性能就自动变好了。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-01-30-33445689</guid>
<pubDate>Tue, 30 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>我爱“不可变编程”，但我更爱Binding.scala的Var</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2018-01-26-33314153.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;我爱“不可变编程”，但我更爱Binding.scala的Var&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33314153&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/ba3acd2a624b861556652d4454f11608&quot; data-hash=&quot;ba3acd2a624b861556652d4454f11608&quot; data-hovercard=&quot;p$b$ba3acd2a624b861556652d4454f11608&quot;&gt;@蠢毛毛&lt;/a&gt; 最近在Coursera上学习Scala的课程，在一次课程的作业中，有一个函数的实现在Instruction中特别指出使用while循环实现，然而之前的作业中是从未使用while循环的，同样的功能通常使用递归形式或者foreach、map等函数来实现，避开使用变量。&lt;br&gt;这时突然提出要用while循环来做，那就避免不了使用var变量了，然而这完全与函数式编程的理念相悖。于是有小伙伴提出了问题，最后的几张图是教员的回复，大概意思是说Scala中for“循环”会被展开成foreach的调用，中间会有成吨的性能损耗，而且foreach底层实现也是用while循环，干脆直接用while循环算了。。。&lt;br&gt;另外也有小伙伴表示，Scala对与简单for循环没有优化性能极差，是一个众所周知的问题，并甩出了一个ISSUE的链接。。。&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//issues.scala-lang.org/browse/SI-1338&quot;&gt;https://issues.scala-lang.org/browse/SI-1338&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;我推荐的风格是所以情况都不用while和局部变量var，可以用foldLeft和尾递归代替。&lt;/p&gt;&lt;p&gt;foldLeft性能差一点，适合性能不敏感的场合。尾递归性能和while差不多。&lt;/p&gt;&lt;p&gt;可读性上来讲，foldLeft和尾递归不比while差，但可能初学者需要一点时间适应一下。&lt;/p&gt;&lt;p&gt;从保证程序的正确性上讲，无论尾递归还是while都有可能写错，写成死循环，foldLeft却能保证循环的次数，不可能写成死循环。再者，var还有额外的风险，如果写错了的话，可能会不小心改错了值。&lt;/p&gt;&lt;p&gt;所以我推荐所有场合都不用while和局部变量var，一律用foldLeft和尾递归即可。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;我只强调“局部变量var”一律用foldLeft和尾递归代替，是因为类里面的var和可变数据结构更棘手些，不可一概而论。&lt;/p&gt;&lt;p&gt;棘手的原因有三点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;类里的var造成的潜在危害很大，可能在并发或者重入的情况下，导致很难解决的bug。&lt;/li&gt;&lt;li&gt;不容易完全消除类里的var，如果一定要消除，会导致代码变长、性能变差。&lt;/li&gt;&lt;li&gt;如果你本来就是为可变模型建模，用var最顺手。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以，类里的var是架构设计问题，而不只是编码问题。&lt;/p&gt;&lt;p&gt;举个例子，我在&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/Binding.scala&quot;&gt;Binding.scala&lt;/a&gt;中做了一个艰难的设计决策。我让Binding.scala的内部数据在初始构建数据绑定表达式时不可变，但在运行时可变。&lt;/p&gt;&lt;p&gt;我在&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/Binding.scala/blob/9.0.x/README-zh.md%23%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2591%25E5%25AE%259A%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%25E7%259A%2584%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F%25E7%25AE%25A1%25E7%2590%2586&quot;&gt;数据绑定表达式的生命周期管理&lt;/a&gt;一节写到：&lt;/p&gt;&lt;blockquote&gt;简而言之，Binding.scala 将函数分为两类：&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;用户定义的 @dom 方法，用于产生不带副作用的纯函数式的数据绑定表达式。&lt;/li&gt;&lt;li&gt;调用 dom.render 以及 Binding.watch 的函数，自动地管理所有副作用。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可能某些人会诟病Binding.scala的数据模型不够“purity”，因为运行起来会变。&lt;/p&gt;&lt;p&gt;但实际上用起来，这种混合做法却很顺畅。因为用户定义的数据绑定表达式只描述数据之间的关系，而不修改任何变量，所有的变量修改都由Binding.scala框架负责。那么，只要我写的框架没有bug，用户就很难自己写出bug。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-01-26-33314153</guid>
<pubDate>Fri, 26 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Scala起源</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2017-02-08-25138340.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Scala起源&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25138340&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Scala起源&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Martin Odersky访谈（第一部分）&lt;/p&gt;&lt;p&gt;by Bill Venners and Frank Sommers&lt;/p&gt;&lt;p&gt;译者：杨博&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://www.artima.com/scalazine/articles/origins_of_scala.html&quot;&gt;The Origins of Scala&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;摘要&lt;/b&gt;

Martin Odersky与Bill Venners谈论Scala编程语言如何创立的相关历史。&lt;/p&gt;&lt;p&gt;Scala，一门通用用途、面向对象、函数式的JVM语言，是瑞士洛桑联邦理工大学教授Martin Odersky的心血结晶。本访谈系列由多部分组成。本文是第一部分，Martin Odersky与Artima网站的Bill Venners谈论了Scala的历史。&lt;/p&gt;&lt;p&gt;&lt;b&gt;发现编译器的魅力&lt;/b&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: 我们从头开始谈谈吧。你最早是如何开始涉猎编程语言的呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 编译器和编程语言一直都是我最喜欢的主题。我第一次钻研编译器是在1980年。那时我还是个本科生，想编写一个自己的编译器。 当时我唯一能远程用上的电脑是Sinclair ZX 80。它上面有1KB内存。我差点就在上面开始尝试了。但幸好我很快就得到更强大的机器Osborne-1。这是世界上第一款“便携式”计算机，远看就像一台倾斜90度的缝纫机。 它的屏幕五英寸大，每行只能显示52个小小的字符。但它亦有惊人之处。内存多达56KB，软盘驱动器有两个，每个容量90KB。&lt;/p&gt;&lt;p&gt;那些日子，我花了一些时间与另一个叫做Peter Sollich的同学呆在一起。我们学了一门新语言Modula-2。我们觉得它既优雅又精致。 于是我们诞生出了一个新计划：我们要为8位计算机Z80编写Modula-2编译器。编写时有个小问题，Osborene附带的唯一语言是微软的Basic语言。Basic语言完全不合乎我们设想，它甚至不支持带参数的例程——除了全局变量就别无所有了。而当时其他编译器对我们穷学生来说太贵了。 因此，我们决定采用经典的自举（bootstrapping）技术。 Peter用Z80汇编语言写了第一个编译器，支持Pascal的小部分语言子集。接着，我们使用这个编译器来编译一个稍大的语言。以此类推，在几次迭代后，我们终于可以编译完整的Modula-2代码了。它可以生成解释型字节码，以及Z80二进制文件。 它生成的字节码，在当年所有系统中，文件最小；它生成的二进制文件，在8位计算机中，速度最快。在当时，算得上能力很强的系统了。&lt;/p&gt;&lt;p&gt;在我们快完成编译器之时，Borland公司推出了Turbo Pascal，还在考虑进入Modula-2市场。事实上，Borland公司决定购买我们的Modula-2的编译器、命名为Turbo Modula-2再卖到CP/M，此外他们还想开发IBM PC版。 我们愿意为他们开发IBM PC版，但他们告诉我们，他们另有计划。 不幸的是，他们开发IBM PC版所费时间远超预期。 产品发布已经是三四年后。实现团队已经从公司分拆，成为了我们所知的TopSpeed Modula-2。由于缺了IBM PC版，Borland公司从未为Turbo-Modula-2提供营销资源， 所以它一直没什么名气。&lt;/p&gt;&lt;p&gt;我们完成Modula-2编译器之际，Borland公司立时就邀请我和Peter加入。Peter去了他们公司。我差点也去了。但我的问题是，我还有一年课程要读，还有硕士项目要做。那时我差点没忍住辍学的诱惑。 最后，我决定坚持上大学。 在我硕士项目期间（关于增量解析），我发现我挺喜欢科研的。所以最后，我放弃加入Borland编写编译器，转而攻读博士学位。我的导师是Pascal和Modula-2的发明者，苏黎世联邦理工学院的Niklaus Wirth。&lt;/p&gt;&lt;p&gt;&lt;b&gt;改善Java的工作&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: Scala是怎么诞生的？有什么历史吗？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 在我快要离开苏黎世时，大约1988年至1989年，我越来越喜欢函数式编程了。所以我继续科研之路，并最终成为德国卡尔斯鲁厄大学教授。 我最初工作更偏向编程的理论方面，比如call-by-need lambda演算. 这项工作与Phil Wadler共同完成。当时他在格拉斯哥大学。 有一天，Phil告诉我，他的组里有个热血助理听说一门新的语言刚出来，仍处于Alpha阶段，名叫Java。 助理向Phil宣告：“瞧瞧我大Java，它有移植性，有字节码，能运行在Web上，还有垃圾收集。这东西可以完爆你。你打算怎么办呢？”Phil说：“呃，可能他说得有点道理。”&lt;/p&gt;&lt;p&gt;答案是，我和Phil Wadler决定从函数式编程中提取一些点子，移植到Java界。 我们的努力转化成为一门名叫Pizza的语言，其中具备函数式编程的三大特性：泛型、高阶函数和模式匹配。Pizza首次发布于1996年，即Java推出后一年。Pizza还算成功，因为它表明，JVM平台上可以实现函数式语言特性。&lt;/p&gt;&lt;p&gt;接着，Sun核心开发团队的Gilad Bracha和David Stoutamire联系了我们。他们说：“我们对你已经做的泛型什么的东西还真挺感兴趣。我们来做个新项目专注这个功能吧。”这个新项目就成了GJ（Generic Java）。 因此，我们在1997/1998年开发了GJ。6年后，GJ再加上当时我们还没做的额外功能，就成为了Java 5中的泛型。那个没做的额外功能就是Java泛型的通配符功能，后来由Gilad Bracha和奥胡斯大学的人独立开发。&lt;/p&gt;&lt;p&gt;虽然我们的泛型扩展被搁置了6年，但Sun对我为GJ写的编译器产生了强烈的兴趣。有证据表明，GJ比他们的第一个Java编译器更稳定，更易于维护。 因此，他们决定，在2000年发布的Java 1.3版及以后版本的中，都采用GJ编译器作为标准javac编译器。&lt;/p&gt;&lt;p&gt;&lt;b&gt;设计比Java更好的语言&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 此刻，在Pizza和GJ的经验中，我常常感到沮丧，因为Java是一门具有硬性约束的语言。因此，我做很多事情时都不能用我本来想用的方式，不能用我确信正确的方式来做。毕竟那时候我的工作重点是改善Java。所以，在那段时期过去以后，我决定，我该退一步了。我想从一张白纸开始，看看我能不能设计出比Java更好的东西。但同时我又知道我不能完全从头开始。 我必须利用上现有的基础设施，不然的话，光是无中生有的自举，没有任何库，工具之类的东西，根本就不现实。&lt;/p&gt;&lt;p&gt;所以我决定，即使我想设计不同于Java的语言，总归得连接到Java的基础设施——即JVM和Java库。 我的想法就是这样。 当时我正有个大好机会，因为当时我在洛桑联邦理工学院做教授，这让我有了独立研究的良好环境。我可以组成一个小团体的研究人员，可以专心工作，不会因外部的赞助人而耗光我所有的时间。&lt;/p&gt;&lt;p&gt;起初我们相当激进。 我们想创造的东西，基于一种非常优美的并发模型，叫做&lt;b&gt;join演算&lt;/b&gt;。我们创造了面向对象版的join演算，叫做Functional Nets，还创造了一门语言，叫做Funnel。过了一段时间，我们发现，Funnel语言的确非常纯粹，但却算不上很实用。 Funnel根植于非常小的内核。 人们认为理所当然应具备的功能（比如类、模式匹配）都必须要对内核编码才能提供。从学术角度看，这技术非常优雅。但实践中不大行得通。 初学者想要找出该怎么编码会相当困难，而专家却发现一次又一次重复编码又很无聊。&lt;/p&gt;&lt;p&gt;结果，我们决定再次重头做点事情，介于纯粹的学术语言Funnel，以及非常务实但受限重重的GJ之间。我们要创造的东西，将会既具有实用价值，又比Java中的先进。2002年时，我们开始开发这门新的语言。我们叫它Scala。首次公开发布于2003年。 2006年年初时有一次相对较大的重新设计。 此后它一直持续成长并逐渐稳定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;改善Java时所受的约束&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: 你说，你需要与Java向后兼容，你受到重重约束，因而多次让你感到沮丧。你能否具体举些例子说说，有哪些事，戴着镣铐跳舞时无法做到，而只保证二进制兼容但无视源代码兼容时就可以做到？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 设计泛型时，我遇到许多非常非常紧的约束。最紧的约束，最难应付的，就是被迫要完全向后兼容&lt;b&gt;无泛型Java&lt;/b&gt;。这个故事是这样的，Java1.2才刚刚加入集合库，Sun不想仅仅因为推出了泛型就另外新增一整套集合库。而不这么做，泛型就得以完全透明的方式实现。&lt;/p&gt;&lt;p&gt;这就是存在一些相当丑陋的东西的原因。 你不得不处处让无泛型类型和泛型类型一起工作，即所谓的&lt;b&gt;raw类型&lt;/b&gt;。而且你还不能改变数组的行为不然就会碰上unchecked警告。最重要的是，处理数组时无法按你想要的方式来做，比如创建具有类型参数T的数组，或者创建你还不知道元素类型的数组。反正你就是没办法做。后来我们在Scala中确实找到了办法，但前提条件是我们让Scala的数组不再支持协变和逆变。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: 你能否阐述一下Java的协变数组有些什么问题吗？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: Java发布初版时，Bill Joy、James Gosling以及Java团队的其他成员都觉得Java就该支持泛型，可惜他们没有时间好好设计。所以考虑到Java（至少初版）不支持泛型，他们觉得至少要让数组能支持协变。这就意味着，举例说吧，String数组就是Object数组的子类型。这么做的原因是，他们想要支持编写某种&lt;b&gt;泛型&lt;/b&gt;排序方法，接受一个Object数组参数，以及一个比较器（comparator）参数，而该方法可以把Object数组排序。然后，允许你把String数组传入其中。总而言之，这类设计算得上一般意义上的类型错乱了。这就是你在Java中会遇到数组修改异常的罪魁祸首。实际上，也正是它导致泛型数组无法正常实现以及数组在Java泛型中根本没法用的原因。你不能声明字符串列表的数组，压根就做不到。你必须用丑陋的raw类型，只能永无止尽地使用列表的数组。因此，它有点像原罪。 他们做得很快，觉得这只是权宜之计。它实际上把未来的每一次设计决定全都毁了。 因此，为了不再次陷入同样的陷阱，我们不得不另寻他路。现在我们宣布，不会与Java向上兼容，有些事情，我们想要做得不同。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2017-02-08-25138340</guid>
<pubDate>Wed, 08 Feb 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>内存溢出 ≠ 内存不足</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2017-01-17-24928828.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;内存溢出 ≠ 内存不足&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24928828&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很多人，比如&lt;a href=&quot;https://www.zhihu.com/people/6e20ed7f6a42010d62d63d09f54793c7&quot; data-hash=&quot;6e20ed7f6a42010d62d63d09f54793c7&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@赵北云&quot; data-hovercard=&quot;p$b$6e20ed7f6a42010d62d63d09f54793c7&quot;&gt;@赵北云&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/7a7768ec9018494013255730c34cfcd0&quot; data-hash=&quot;7a7768ec9018494013255730c34cfcd0&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@Kifile&quot; data-hovercard=&quot;p$b$7a7768ec9018494013255730c34cfcd0&quot;&gt;@Kifile&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/5818bea8dc799bce35ddb3c7af649e7a&quot; data-hash=&quot;5818bea8dc799bce35ddb3c7af649e7a&quot; class=&quot;member_mention&quot; data-title=&quot;@戴帽子的狗&quot; data-editable=&quot;true&quot; data-hovercard=&quot;p$b$5818bea8dc799bce35ddb3c7af649e7a&quot;&gt;@戴帽子的狗&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/8ff71e48d8431145e99f39f732c7fcc5&quot; data-hash=&quot;8ff71e48d8431145e99f39f732c7fcc5&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@武大郎&quot; data-hovercard=&quot;p$b$8ff71e48d8431145e99f39f732c7fcc5&quot;&gt;@武大郎&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/c17a2fa8908b8dfc9b80fc3170d4d13e&quot; data-hash=&quot;c17a2fa8908b8dfc9b80fc3170d4d13e&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@支浩宇&quot; data-hovercard=&quot;p$b$c17a2fa8908b8dfc9b80fc3170d4d13e&quot;&gt;@支浩宇&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/bdbb011fa8e73b808445ca48dafdfd31&quot; data-hash=&quot;bdbb011fa8e73b808445ca48dafdfd31&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@韩葆-逸松&quot; data-hovercard=&quot;p$b$bdbb011fa8e73b808445ca48dafdfd31&quot;&gt;@韩葆-逸松&lt;/a&gt;认为：&lt;/p&gt;&lt;blockquote&gt;内存溢出 = stackoverflow = 内存不足&lt;/blockquote&gt;&lt;p&gt;事实上，虽然stackoverflow可以看成是栈内存不足的一种体现。但内存溢出并不一定跟内存分配有什么关系，因为还有一种情况是缓冲区溢出。&lt;br&gt;&lt;/p&gt;&lt;p&gt;C/C++标准库有个strcpy，会一直复制内存，直到遇到\0。比如如果你用C++写了一个游戏服务器，其中读取客户端网络包的代码写成这样：&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;code lang=&quot;cpp&quot;&gt;const MAX_LENGTH = 16;
bool is_administrator = false;
char destination[MAX_LENGTH];

std::string source = read_string_from_client();
strcpy(destination, source.c_str());
&lt;/code&gt;&lt;br&gt;&lt;p&gt;那么如果黑客构造出的source长于16字节，那么就会修改到destination之外的内存。很多平台的栈变量是跟按地址顺序倒着分配的。所以destination溢出以后会修改先前定义的变量。比如黑客可以用这个办法把is_administrator修改成true。&lt;br&gt;这种情况就是缓冲区溢出攻击。&lt;/p&gt;假如黑客黑掉服务器之后，把你的服务端程序偷出来开私服。由于私服泛滥，游戏失败了。于是你的新游戏决定抛弃了C++，改用C99标准的C语言。这次你这样写：&lt;br&gt;&lt;code lang=&quot;c&quot;&gt;int length = read_int_from_client();
char buffer[length];
int data = read_int_from_client();
&lt;/code&gt;&lt;p&gt;这里会在栈上分配length字节的空间，然后再往栈顶放上一个data。当length很大时，会把data挤到栈空间之外。这种情况下，假如编译器生成的代码没有越界检查的话，那么黑客只要用客户端发送特定的length和data组合，就能够改写服务器的任意内存。黑客通常会修改服务器代码的机器码，比如注入一些jmp指令，让线程跳到黑客想执行的函数。&lt;/p&gt;那么这一次你又被“栈溢出”攻击黑掉了服务器。&lt;p&gt;从这两个例子可以看出，内存溢出就是内存越界。我们说内存溢出这个词是往往指的是栈溢出或缓冲区溢出。&lt;/p&gt;&lt;p&gt;无论栈溢出还是缓冲区溢出都是安全漏洞的温床。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2017-01-17-24928828</guid>
<pubDate>Tue, 17 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用全栈Scala架构开发的web游戏工具</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2017-01-01-24669379.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;用全栈Scala架构开发的web游戏工具&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24669379&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
有一个日本手机游戏叫做《碧蓝幻想》。大概长成这样：&lt;img src=&quot;https://pic2.zhimg.com/a86564a518b5f54efe29d320df2c2d78_r.jpg&quot; data-rawwidth=&quot;1037&quot; data-rawheight=&quot;1200&quot;&gt;&lt;br&gt;这个游戏和魔兽世界一样，也有所谓的副本，需要组队才能打得过。不幸的是，这个游戏没有组队系统，而是提供了“在微博上组队”的功能，点一下就会发一条类似这样的信息：&lt;img src=&quot;https://pic2.zhimg.com/2a356d020a73910a17d5fe48399ff40a_r.png&quot; data-rawwidth=&quot;861&quot; data-rawheight=&quot;937&quot;&gt;&lt;p&gt;要想组队的玩家，就得去微博上寻找队友，然后把参战ID复制到游戏里面。&lt;/p&gt;&lt;p&gt;那么，你想要组队，你就得在微博上搜索别人发的组队信息，看看Boss等级、三围、队伍配置是否匹配。这个过程非常麻烦，你需要点开一大堆微博，挨个筛选。&lt;/p&gt;有一个程序员（&lt;a href=&quot;https://twitter.com/walfieee&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;@walfieee&quot;&gt;@walfieee&lt;/a&gt;）不堪忍受懒惰的开发商，于是自己用&lt;a href=&quot;https://github.com/ThoughtWorksInc/Binding.scala&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;Binding.scala&quot;&gt;Binding.scala&lt;/a&gt;帮《碧蓝幻想》做了个&lt;a href=&quot;https://github.com/walfie/gbf-raidfinder&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;组队系统&quot;&gt;组队系统&lt;/a&gt;。&lt;br&gt;&lt;img src=&quot;https://pic2.zhimg.com/14bdc21cb604c84e79d96374583203ac_r.png&quot; data-rawwidth=&quot;1305&quot; data-rawheight=&quot;910&quot;&gt;&lt;p&gt;这样大家就可以解放双手，批量刷副本啦。&lt;/p&gt;&lt;br&gt;&lt;a href=&quot;https://twitter.com/walfieee&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;@walfieee&quot;&gt;@walfieee&lt;/a&gt;开发的组队系统是个完整的网站，包含了前后端代码。&lt;p&gt;项目已经开源到Github上（&lt;a href=&quot;https://github.com/walfie/gbf-raidfinder&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;walfie/gbf-raidfinder&quot;&gt;walfie/gbf-raidfinder&lt;/a&gt;），所有代码都是用Scala写的。后端使用Redis+Play，前端用MDL+Binding.scala，前后端通信使用WebSocket+protobuf。可以自动部署到heroku。&lt;/p&gt;&lt;p&gt;难能可贵的是，&lt;a href=&quot;https://twitter.com/walfieee&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;@walfieee&quot;&gt;@walfieee&lt;/a&gt;撰写了很好的开发文档（&lt;a href=&quot;https://github.com/walfie/gbf-raidfinder/blob/master/docs/project.md&quot; data-editable=&quot;true&quot; data-title=&quot;project.md&quot; class=&quot;&quot;&gt;project.md&lt;/a&gt;），让人可以根据文档快速搭建开发环境。&lt;/p&gt;&lt;p&gt;除了这个项目以外，&lt;a href=&quot;https://github.com/Algomancer/Full-Stack-Scala-Starter&quot; data-editable=&quot;true&quot; data-title=&quot;Full-Stack-Scala-Starter&quot; class=&quot;&quot;&gt;Full-Stack-Scala-Starter&lt;/a&gt;提供了全栈Scala的项目模板，也很不错。&lt;/p&gt;&lt;p&gt;我觉得这两个项目对于想要搭建全栈Scala架构的网站的人来说，都是很好的参考实现。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2017-01-01-24669379</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>你觉得Binding.scala吼不吼啊？</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2017-01-01-24669230.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;你觉得Binding.scala吼不吼啊？&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24669230&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ThoughtWorksInc/Binding.scala&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;github.com 的页面&quot;&gt;Binding.scala&lt;/a&gt;是Scala上的数据绑定框架，如果配合Scala.js，可以作为前端框架使用。本文收集了全球用户对Binding.scala的反馈。&lt;/p&gt;&lt;p&gt;Ólafur Páll Geirsson:&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;blockquote&gt;Hi，我只想对 &lt;br&gt;&lt;a class=&quot;&quot; href=&quot;https://www.zhihu.com/people/atry&quot; data-editable=&quot;true&quot; data-title=&quot;@杨博&quot;&gt;@杨博&lt;/a&gt;&lt;br&gt; 你说声谢谢，Binding.scala 真棒！我花了一会儿功夫让脑子绕清楚`.bind`的用法和时机。但一旦搞清楚了，前端（包括路由和其他很酷的功能）开发过程就变得非常直截了当。&lt;br&gt;TodoMVC对新手上手来说是个极好的例子。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D57bc5dd087f779f0691f0b2a&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57bc5dd087f779f0691f0b2a&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57bc5dd087f779f0691f0b2a&lt;/a&gt;&lt;/p&gt;Justin Maat:&lt;br&gt;&lt;blockquote&gt;Binding.scala感觉非常简单，不像其他库那么复杂&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D5720f1cb9b4160fa760a6470&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=5720f1cb9b4160fa760a6470&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=5720f1cb9b4160fa760a6470&lt;/a&gt;&lt;/p&gt;dafcok:&lt;br&gt;&lt;blockquote&gt;感觉Binding.scala精简至极。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/scala/comments/4dvsbn/announcing_bindingscala_a_reactive_web_framework/d1vui5n&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://www.reddit.com/r/scala/comments/4dvsbn/announcing_bindingscala_a_reactive_web_framework/d1vui5n&quot;&gt;https://www.reddit.com/r/scala/comments/4dvsbn/announcing_bindingscala_a_reactive_web_framework/d1vui5n&lt;/a&gt;&lt;/p&gt;Milad Khajavi:&lt;br&gt;&lt;blockquote&gt;感谢你，我发现Binding.scala和我见过的其他框架相比，Binding.scala非常简单。伟大的作品。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D581bf9952d4796175f4015ba&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=581bf9952d4796175f4015ba&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=581bf9952d4796175f4015ba&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;Binding.scala之简洁，远超其他数据绑定框架，还支持XML字面量。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/khajavi/status/819885381621518338&quot; data-editable=&quot;true&quot; data-title=&quot;twitter.com 的页面&quot; class=&quot;&quot;&gt;https://twitter.com/khajavi/status/819885381621518338&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;Philip Stutz:&lt;br&gt;&lt;blockquote&gt;嘿杨兄，Binding.scala真的很酷，是迄今为止web应用的客户端开发最最方便的方式。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D57bacaddbb6fad403cf53794&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57bacaddbb6fad403cf53794&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57bacaddbb6fad403cf53794&lt;/a&gt;&lt;/p&gt;Markus Herrmann:&lt;br&gt;&lt;blockquote&gt;真的很酷！Binding.scala——Scala数据绑定框架&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/datalabrat/status/765483174587670529&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/datalabrat/status/765483174587670529&quot;&gt;https://twitter.com/datalabrat/status/765483174587670529&lt;/a&gt;&lt;/p&gt;Rahel Lüthy:&lt;br&gt;&lt;blockquote&gt;Binding.scala——ThoughtWorks的reactive web框架，感觉极其简洁&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/netzwerg999/status/718751672974118912&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/netzwerg999/status/718751672974118912&quot;&gt;https://twitter.com/netzwerg999/status/718751672974118912&lt;/a&gt;&lt;/p&gt;Adam Hibble:&lt;br&gt;&lt;blockquote&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/thoughtworks&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;@thoughtworks&quot;&gt;@thoughtworks&lt;/a&gt; Binding.scala简单极了。&lt;/blockquote&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/Algomancer/status/783445081927720960&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/Algomancer/status/783445081927720960&quot;&gt;https://twitter.com/Algomancer/status/783445081927720960&lt;/a&gt;&lt;br&gt;&lt;blockquote&gt;我真的很喜欢用Binding.scala做些小巧、可重用、可隔离的组件。&lt;/blockquote&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/scala/comments/55whc1/a_really_simple_full_stack_scala_starter_with/d8g58bh&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://www.reddit.com/r/scala/comments/55whc1/a_really_simple_full_stack_scala_starter_with/d8g58bh&quot;&gt;https://www.reddit.com/r/scala/comments/55whc1/a_really_simple_full_stack_scala_starter_with/d8g58bh&lt;/a&gt;&lt;br&gt;Walfie:&lt;br&gt;&lt;blockquote&gt;在我使用Binding.scala至今，绝大多数时间 Binding.scala 都给了我丝般柔顺的体验。多亏有了Binding.scala&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/walfieee/status/778365304355291136&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/walfieee/status/778365304355291136&quot;&gt;https://twitter.com/walfieee/status/778365304355291136&lt;/a&gt;&lt;/p&gt;jfilali:&lt;br&gt;&lt;blockquote&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Atry&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;@Atry&quot;&gt;@Atry&lt;/a&gt; Binding.scala 看起来真伟大。恭喜。你的所作所为是真正的创新。以前，我评估了各种库的品质时、搭建了开发环境，包括scala-react、material-ui的包装库、material-ui的JavaScript依赖、diode、JavaScript打包、JavaScript依赖。现在，我怀疑所有这些工作还有什么价值。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D584d355628d755bf14ef4a3a&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=584d355628d755bf14ef4a3a&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=584d355628d755bf14ef4a3a&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;blockquote&gt;（……关于Binding.scala支持定制XML组件）让我能乐上一整天。实际上我已经把Binding.scala和flux/Model用在一起了。尽管底层是可变模型，一样能运转得很好。我遵守以下编码风格：利用容器连接存储和视觉组件，组件接受的参数都是Binding[Node]对象。我发现这种方式可伸缩性非常好。&lt;br&gt;目前我需要写几篇博客，但至今我体验到Binding.scala真的非常好。我的生产力大大提高。我以前写了个ReactJS项目花了两个月，react-scala-js项目花了一个月，而Binding.scala项目只用两周。&lt;br&gt;不久以后我会写一篇博客谈谈我的经验。&lt;/blockquote&gt;&lt;a href=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=5879bd26074f7be763cc550f&quot; data-editable=&quot;true&quot; data-title=&quot;gitter.im 的页面&quot; class=&quot;&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=5879bd26074f7be763cc550f&lt;/a&gt;&lt;br&gt;&lt;br&gt;Pedro Larroy:&lt;br&gt;&lt;blockquote&gt;Binding.scala是Scala的reactive web应用库，比ReactJS易用。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/plarroy/status/715955108928962561&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/plarroy/status/715955108928962561&quot;&gt;https://twitter.com/plarroy/status/715955108928962561&lt;/a&gt;&lt;/p&gt;chris-tek:&lt;br&gt;&lt;blockquote&gt;我以前学过ELM、Scala.js+diode，最近开始调研Scala.js+Binding.scala，构建纯粹完全响应式的GUI。&lt;br&gt;现在我已经有些阶段性成果，成功让GUI和后端（RabbitMQ + stomp，websocket协议）交换数据。不可思议，程序运行得非同寻常的棒。&lt;br&gt;Binding.scala那坨代码写得真好。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D57c69070ca24c06c638a5ff5&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57c69070ca24c06c638a5ff5&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57c69070ca24c06c638a5ff5&lt;/a&gt;&lt;/p&gt;Anthony Homan:&lt;br&gt;&lt;blockquote&gt;Binding.scala绝对是最卓越的！我承认我才刚刚开始接触Binding.scala，但即便如此，Binding.scala真真是我寻觅已久的那块拼板，让Scala.js真正值得投资。&lt;br&gt;我会继续试着把我现有的AngularJS（前端）/Scala（后端）应用，移植到全栈Scala上，用Scala.js和Binding.scala代替AngularJS。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//groups.google.com/d/msg/scala-js/xJsjE-zFeuk/gqIgTXi2AwAJ&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://groups.google.com/d/msg/scala-js/xJsjE-zFeuk/gqIgTXi2AwAJ&quot;&gt;https://groups.google.com/d/msg/scala-js/xJsjE-zFeuk/gqIgTXi2AwAJ&lt;/a&gt;&lt;/p&gt;Simone Scarduzio:&lt;br&gt;&lt;blockquote&gt;今天涨点知识：Binding.scala，用Scala代替ReactJS的明智选择&lt;br&gt;&lt;/blockquote&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/s_scarduzio/status/763501825484087300&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/s_scarduzio/status/763501825484087300&quot;&gt;https://twitter.com/s_scarduzio/status/763501825484087300&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;很惭愧，就做了一点微小的工作。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2017-01-01-24669230</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用sbt-best-practice为Scala库设置Travis CI上的持续集成和持续交付</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2016-09-08-22371242.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;用sbt-best-practice为Scala库设置Travis CI上的持续集成和持续交付&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22371242&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github上有很多 Scala 开源库。它们都有自动测试的功能。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如 README 页面上有个小图标（build passing）表示当前版本是否通过了测试。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/8e8fa025d59af31425ede63348dd370a_r.png&quot; data-rawwidth=&quot;2276&quot; data-rawheight=&quot;918&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;再如，每当有人提交 Pull Request 的时候，也会有个小勾勾报告这次修改能不能通过测试。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/916699913e7dbf3895d424feb3695d19_r.png&quot; data-rawwidth=&quot;2352&quot; data-rawheight=&quot;1404&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;还有，这些库还会发布到 Maven 中心仓库，我如果要在自己的项目使用它们的话，只要在自己的 sbt 配置中添加依赖就可以自动下载了。&lt;/p&gt;&lt;p&gt;这些自动测试和发布功能属于持续集成和持续交付，可以用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt; 和 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/sbt-best-practice&quot;&gt;sbt-best-practice&lt;/a&gt; 实现。&lt;/p&gt;&lt;p&gt;Travis CI 是个持续集成服务。一旦你的 Github 仓库启用了 Travis CI ，每当有人在仓库推送代码或者提交 Pull Request 时，就会触发 Travis CI 执行一段脚本。&lt;/p&gt;&lt;p&gt;对于 Scala 项目来说，一般用 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.scala-sbt.org/&quot;&gt;sbt&lt;/a&gt; 管理构建过程，所以我们会希望 Travis CI 被触发以后，执行测试和发布的 sbt 任务。这样就可以完成题主要求的所有功能了。&lt;/p&gt;&lt;p&gt;第一步：启用 Travis CI&lt;/p&gt;&lt;p&gt;Travis CI 的构建过程配置在 .travis.yml 文件中。Scala 库的 .travis.yml 应该写成这样：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;yaml&quot;&gt;# 告诉 Travis CI 应该用已经安装了 Scala 的系统镜像来执行本文件中配置的脚本
language: scala

# 应执行 sbt test 任务来进行自动测试
script:
  - sbt test

# 如果存在 deploy.sbt 文件，就执行 sbt &quot;release with-defaults&quot; 任务来进行自动发布
deploy:
  skip_cleanup: true
  provider: script
  script: sbt &quot;release with-defaults&quot;
  on:
    condition: -e ./deploy.sbt
    all_branches: true
&lt;/code&gt;&lt;p&gt;有了 .travis.yml，你还需要访问&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//travis-ci.org/profile&quot;&gt;你在 Travis CI 的 Profile 页面&lt;/a&gt;，为 Github 仓库启用 Travis CI。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/bec2d73be3f0489403b57835aebc7221_r.png&quot; data-rawwidth=&quot;684&quot; data-rawheight=&quot;384&quot;&gt;&lt;p&gt;然后，CI 会自动执行 sbt test 测试每次提交。此外，CI 还会检测 deploy.sbt 是否存在，如果存在，就执行 sbt &quot;release with-defaults&quot; 任务来进行自动发布。&lt;/p&gt;&lt;p&gt;第二步：添加 Sbt 插件&lt;/p&gt;&lt;p&gt;sbt test 和 sbt &quot;release with-defaults&quot; 两个任务由 Sbt 插件提供。编辑project/plugins.sbt ，启用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/sbt-best-practice&quot;&gt;sbt-best-practice&lt;/a&gt; 插件，这些任务就会自动配置好。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;addSbtPlugin(&quot;com.thoughtworks.sbt-best-practice&quot; % &quot;sbt-best-practice&quot; % &quot;latest.release&quot;)
&lt;/code&gt;&lt;p&gt;添加测试框架&lt;/p&gt;&lt;p&gt;对于自动测试，你还需要添加测试框架依赖并编写自己的测试用例。&lt;/p&gt;&lt;p&gt;在 Scala 社区，常用的测试框架有 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//junit.org/&quot;&gt;JUnit&lt;/a&gt; 、&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.scalatest.org/&quot;&gt;ScalaTest&lt;/a&gt;、&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//etorreborre.github.io/specs2/&quot;&gt;Specs2&lt;/a&gt; 和 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/lihaoyi/utest&quot;&gt;µTest&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;以 µTest 为例，编辑或创建 build.sbt:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;libraryDependencies += &quot;com.lihaoyi&quot; %% &quot;utest&quot; % &quot;0.4.3&quot; % &quot;test&quot;

testFrameworks += new TestFramework(&quot;utest.runner.Framework&quot;)
&lt;/code&gt;&lt;p&gt;这样一来，在 src/test/scala 编写的测试用例就会被 sbt test 所执行了。&lt;/p&gt;&lt;p&gt;第三步：提供自动发布时的项目信息开源许可证&lt;/p&gt;&lt;p&gt;要发布到 Maven 中心仓库的软件必须是开源软件。你需要准备一个 LICENSE 文件。比如我们常用的 Apache License 的内容可以在这里找到：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.apache.org/licenses/LICENSE-2.0&quot;&gt;https://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/p&gt;&lt;p&gt;组织名和项目名&lt;/p&gt;&lt;p&gt;当然，你还需要指定库的名称。 sbt 项目用组织名外加项目名的组合作为唯一标识。编辑或创建 build.sbt 设置如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;organizatio := &quot;com.thoughtworks.q&quot;

name := &quot;q&quot;
&lt;/code&gt;&lt;p&gt;版本号&lt;/p&gt;&lt;p&gt;版本号应该保存在 version.sbt 中：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;version in ThisBuild := &quot;1.0.0-SNAPSHOT&quot;
&lt;/code&gt;&lt;p&gt;第四步：设置自动发布时的密码、密钥等鉴权机制申请 Sonatype 帐号&lt;/p&gt;&lt;p&gt;Maven 中心仓库中的大部分软件都是从 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.sonatype.org/&quot;&gt;Sonatype&lt;/a&gt; 上同步过来的。所以，只要你把项目发布到 Sonatype ，就会自动发布到 Maven 中心仓库。&lt;/p&gt;&lt;p&gt;首先，你需要注册一个 Sonatype 帐号：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://issues.sonatype.org/secure/Signup!default.jspa&quot;&gt;https://issues.sonatype.org/secure/Signup!default.jspa&lt;/a&gt;&lt;/p&gt;&lt;p&gt;然后，填写表单，申请权限以发布项目到 Sonatype ：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;amp;pid=10134&quot;&gt;https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;amp;amp;pid=10134&lt;/a&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/b6194475835107f913616c38a663a583_r.png&quot; data-rawwidth=&quot;1072&quot; data-rawheight=&quot;1285&quot;&gt;&lt;p&gt;你可以参照我申请时的格式来填写：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//issues.sonatype.org/browse/OSSRH-22779&quot;&gt;https://issues.sonatype.org/browse/OSSRH-22779&lt;/a&gt;&lt;/p&gt;&lt;p&gt;生成和上传 PGP 密钥&lt;/p&gt;&lt;p&gt;发布到 Sonatype 的软件必须用 PGP 签名。所以你得生成一对 PGP 密钥。&lt;/p&gt;&lt;p&gt;你可以用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.gnupg.org/&quot;&gt;GnuPG&lt;/a&gt; 来生成密钥。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;gpg --gen-key
gpg --export --armor --output pubring.asc
gpg --export-secret-keys --armor --output secring.asc
&lt;/code&gt;&lt;p&gt;填写密钥所需的信息，其中一个步骤需要填写加密口令，直接按回车填写空口令即可。&lt;br&gt;当前目录就会出现私钥文件 secring.asc 和公钥文件 pubring.asc 。&lt;/p&gt;&lt;p&gt;接下来，你需要上传公钥。&lt;/p&gt;&lt;p&gt;访问 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pgp.mit.edu/&quot;&gt;MIT PGP Key Server&lt;/a&gt; ，把 pubring.asc 的内容粘贴到 “Enter ASCII-armored PGP key here:” 处，然后点击“Submit this key to the keyserver!”。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/481bd96062fd239e8a4b124a7a75ada0_r.png&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;1063&quot;&gt;&lt;p&gt;生成 Github Personal Access Token&lt;/p&gt;&lt;p&gt;在发布 Scala 库时， CI 会通过 sbt-best-practice 插件会自动给 Github 仓库中的版本设置一个版本 tag 。&lt;br&gt;所以需要为 CI 设置 Github 仓库的修改权限。这可以通过 Github Personal Access Token 实现。&lt;/p&gt;&lt;p&gt;访问 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/settings/tokens/new&quot;&gt;Sign in to GitHub · GitHub&lt;/a&gt; ，然后填写 Token description 并勾选public_repo 权限。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/f20404b12f59ccfefef28ef4dbe18262_r.png&quot; data-rawwidth=&quot;1151&quot; data-rawheight=&quot;1190&quot;&gt;&lt;p&gt;Github 会生成一段类似 74bf3a944382ec8e07625a6e55eb05a416ca585d 的 Personal Access Token 。请保存这段 Personal Access Token 供稍后使用。&lt;/p&gt;&lt;p&gt;创建一个 Secret Gist 保存所有密码和密钥&lt;/p&gt;&lt;p&gt;上述所有的这些密码和密钥都可以通过 Sbt 来设置。但是，我觉得你恐怕不会愿意把你的密码放在公共仓库中。&lt;/p&gt;&lt;p&gt;所以我建议你把密码和密钥放在只有自己才知道的 Secret Gist 中。然后把 Secret Gist 的 URL 设置在 Travis CI 的秘密环境变量中。那么， CI 运行 sbt 任务时，就可以读取环境变量访问 Secret Gist 获得所有这些密码和密钥。&lt;/p&gt;&lt;p&gt;访问 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gist.github.com/&quot;&gt;https://gist.github.com/&lt;/a&gt; ，点击“Add file”按钮，添加三个文件：&lt;/p&gt;&lt;p&gt;secret.sbt&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;// 此处应填写刚才生成的 Github Personal Access Token
githubCredential in Global := PersonalAccessToken(&quot;74bf3a944382ec8e07625a6e55eb05a416ca585d&quot;)

// 此处应填写你刚才注册 Sonatype 时使用的帐号和密码
credentials in Global += Credentials(&quot;Sonatype Nexus Repository Manager&quot;, &quot;oss.sonatype.org&quot;, &quot;你的 Sonatype 帐号&quot;, &quot;你的 Sonatype 密码&quot;)

val currentDirectory = file(sourcecode.File()).getParentFile

pgpSecretRing := currentDirectory / &quot;secring.asc&quot;

pgpPublicRing := currentDirectory / &quot;pubring.asc&quot;

pgpPassphrase := Some(Array.empty)
&lt;/code&gt;&lt;p&gt;secring.asc&lt;/p&gt;&lt;p&gt;请把 GnuPG 生成的 secring.asc 内容复制到此处。&lt;/p&gt;&lt;p&gt;pubring.asc&lt;/p&gt;&lt;p&gt;请把 GnuPG 生成的 pubring.asc 内容复制到此处。&lt;/p&gt;&lt;p&gt;最后点击“Create secret gist”按钮，生成这个 Secret Gist 。&lt;/p&gt;&lt;p&gt;请记下新生成的 Secret Gist 网址，类似 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gist.github.com/Atry/xxxxxxxxxxxxxxxxxxxx&quot;&gt;https://gist.github.com/Atry/xxxxxxxxxxxxxxxxxxxx&lt;/a&gt;&lt;/p&gt;&lt;p&gt;创建 Travis CI 的秘密环境变量&lt;/p&gt;&lt;p&gt;在你的 Travis CI 项目设置面板中添加 SECRET_GIST 环境变量，设为你刚生成的 Secret Gist 网址 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gist.github.com/Atry/xxxxxxxxxxxxxxxxxxxx&quot;&gt;https://gist.github.com/Atry/xxxxxxxxxxxxxxxxxxxx&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/7f572b7c22dc3a135ff2c3f443f6cf3a_r.png&quot; data-rawwidth=&quot;1072&quot; data-rawheight=&quot;843&quot;&gt;&lt;p&gt;创建 deploy.sbt 读取 SECRET_GIST 环境变量&lt;/p&gt;&lt;p&gt;deploy.sbt 包含了发布 Scala 库时的设置。我们启用 Travis 和 SonatypeRelease ，然后读取 SECRET_GIST 环境变量并加载 Secret Gist 中的 secret.sbt 文件&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;enablePlugins(Travis)

enablePlugins(SonatypeRelease)

lazy val secret = project settings(publishArtifact := false) configure { secret =&amp;gt;
  sys.env.get(&quot;SECRET_GIST&quot;) match {
    case Some(gitUri) =&amp;gt;
      secret.addSbtFilesFromGit(gitUri, file(&quot;secret.sbt&quot;))
    case None =&amp;gt;
      secret
  }
}
&lt;/code&gt;&lt;p&gt;日常使用注意事项&lt;/p&gt;&lt;p&gt;关于 deploy.sbt.disabled&lt;/p&gt;&lt;p&gt;把 .travis.yml 、 project/plugins.sbt 、 LICENSE 、 build.sbt 、 deploy.sbt 几个文件推送到 Git 仓库后， CI 会触发自动测试和自动发布。每次发布成功后，sbt-best-practice 会自动把 deploy.sbt 改名为 deploy.sbt.disabled ，因此，如果将来再有提交，就只会触发自动测试，而不会触发自动发布。如果你想发布下一个新版本，手动把deploy.sbt.disabled 改名为 deploy.sbt 就能触发 CI 执行自动发布流程了。&lt;/p&gt;&lt;p&gt;关于版本号&lt;/p&gt;&lt;p&gt;一旦触发发布，CI 会自动修改 version.sbt 中记录的版本号。比如你的仓库中原本版本号是 1.0.0-SNAPSHOT ，触发自动发布时， CI 会首先把版本号改为 1.0.0 然后标上 GIT tag，然后再把版本号改为 1.0.1-SNAPSHOT 。如果你希望下次发布的版本号是 1.5.0 ，那么你需要在触发下一次自动发布以前，手动把 version.sbt 中记录的版本号改为 1.5.0-SNAPSHOT 。&lt;/p&gt;&lt;p&gt;相关链接&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//scala-lang.org/&quot;&gt;Scala&lt;/a&gt; - 一门多范式的编程语言，也是本文的涉及的全部技术的基础。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/scala-project-template&quot;&gt;scala-project-template&lt;/a&gt; - Scala项目模板，类似本文描述的结构，但改用私有 Git 仓库来保存密码而非 Secret Gist，因此 deploy.sbt 内容稍有不同。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/Q.scala&quot;&gt;Q.scala&lt;/a&gt; - 完整设置了自动测试和发布的 Scala 库。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.scala-sbt.org/&quot;&gt;Sbt&lt;/a&gt; - Simple Build Tool, Scala 社区最为广泛实用的构建工具。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/sbt-best-practice&quot;&gt;sbt-best-practice&lt;/a&gt; - Sbt 插件，提供了本文提及的全部发布功能。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/lihaoyi/utest&quot;&gt;µTest&lt;/a&gt; - 一个简单好用的 Scala 测试框架。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt; - 为 Github 项目提供了持续集成服务。除了 Travis CI ，其他持续集成方案还有我司的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.go.cd/&quot;&gt;GoCD&lt;/a&gt; 、 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//jenkins.io/&quot;&gt;Jenkins&lt;/a&gt; 、 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.atlassian.com/software/bamboo&quot;&gt;Bamboo&lt;/a&gt; 等。相比这些方案，Travis CI 很精简，完全省略了 pipeline 的概念，我很喜欢。开源项目可以免费使用 Travis CI。我见过的开源项目中最常见的持续集成服务就是 Travis CI。&lt;/li&gt;&lt;/ul&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2016-09-08-22371242</guid>
<pubDate>Thu, 08 Sep 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>挟尸要价的法律性质</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2016-06-15-21360759.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;挟尸要价的法律性质&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21360759&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;https://pic3.zhimg.com/4c024103bba4c6b8babe60b0a1f1db91_r.png&quot; data-rawwidth=&quot;750&quot; data-rawheight=&quot;1334&quot;&gt;&lt;blockquote&gt;&lt;p&gt;  12月6日，攀枝花，两位小男孩在金沙江边玩耍时，发现一块石头上系着一根绳子，他们好奇地把绳子往岸边拉，发现绳子上竟拴着一具尸体。&lt;/p&gt;&lt;p&gt;  死者叫邓树超，25岁，攀枝花市仁和区人，在11月30日跳江自杀。为何他的尸体被拴在江中？据了解，邓树超跳江4天后，当地的几名渔民打捞起他的遗体，索要1.8万元捞尸费。因价格未谈妥，死者父亲邓钢明只能任由儿子的遗体在江中多漂了三天。12月6日，在支付渔民5400元后，邓钢明接走了儿子的尸体。&lt;/p&gt;&lt;p&gt;  小伙子跳江自杀 渔民捞起尸体&lt;/p&gt;&lt;p&gt;  “11月30日，这是我们见孩子的最后一面。”昨日，说起儿子的离去，邓钢明悲痛欲绝。他介绍，11月30日上午，儿子回到老家，说要6000块钱，“我们问他拿来做什么，他说出租车的一年租期要到了，还有两个月的租金没着落”。因为邓树超的父母都是农民，暂时拿不出钱来，希望缓两天把水果卖了再给钱。没要到钱，邓树超离家返城。&lt;/p&gt;&lt;p&gt;  邓钢明介绍，儿子是从车主罗某手中承包了出租车。12月2日，罗某打来电话称邓树超一直没有交接班。因为联系不到儿子，家人只好报警，最后找到了车，人却没有踪影。&lt;/p&gt;&lt;p&gt;  “警方说，11月30日14时50分许，有人报警称有一名男子在密地桥上跳江自尽。” 邓钢明说，当地警方调取了监控请他们辨认，跳江男子正是邓树超。12月3日下午，邓树超父母再次接到警方电话，说在雅砻江与金沙江交汇处，有渔民打捞到一具尸体，请他们过去。经辨认，正是儿子尸体。后经警方认定，排除他杀，邓树超系跳江自杀。&lt;/p&gt;&lt;p&gt;  邓钢明讲述，儿子性格内向，不怎么爱说话。&lt;/p&gt;&lt;p&gt;  渔民要价1.8万元 尸体多漂三天&lt;/p&gt;&lt;p&gt;  12月3日，邓钢明看见儿子的尸体，在江边失声痛哭。“当时，人都泡变形了，我们只想把娃儿接回家尽快安葬。”邓钢明介绍，当时他们想把儿子的尸体带走，但打捞的渔民说，“如果不给钱就不能抬走尸体。”当时打捞的渔民要价1.8万元，邓钢明说家里经济条件不好，拿不出这么多钱来。&lt;/p&gt;&lt;p&gt;  “他们（渔民）打捞确实付出了劳动，应该给点钱，没想到价格这么高。”邓钢明说，当时参与打捞的渔民一共有6人，他同意每人给200元的辛苦费，但被拒绝。“经过讨价还价，他们最后表示要8000元。”因为拿不够钱，邓钢明选择了任由儿子的遗体漂在江中，自己回家筹钱。&lt;/p&gt;&lt;p&gt;  12月6日，在攀枝花警方的协调下，死者家属支付渔民们4600元报酬和800元清洗、搬运费用后，将遗体拉到了殡仪馆。“因为价格没谈妥，儿子在江上多漂了3天。”邓钢明抹了抹眼泪说。&lt;/p&gt;&lt;p&gt;  渔民回应&lt;/p&gt;&lt;p&gt;  要的是“劳务费” 收费参照先例&lt;/p&gt;&lt;p&gt;  昨日上午，成都商报记者在江边见到了参与打捞的渔民之一侯师傅。“11月3日上午，我们收网时发现渔网很重，拉起来后才发现渔网缠住了一具尸体的脚。”侯师傅称，当时江水很急，他们六个渔民花了1个多小时才把遗体打捞起来。“前些年，经常能打捞到上游漂下来的遗体，并不奇怪。”打捞起尸体后，他们并没有报警，而是问了上下游熟悉的人，看是否有人失踪的消息。&lt;/p&gt;&lt;p&gt;  在转交遗体时，侯师傅等人提出需要邓树超的家人支付一定的打捞费用。为何开价1.8万元，侯师傅说，“这个价格并不高，这是参照前段时间雅砻江打捞遗体的费用要价1.8万元。”据现场一名渔民讲述，今年10月27日，在打捞到遗体上游几公里处的雅砻江流域发生一起塌方事件，当时打捞到两具遗体，一个收费是3万多元，一个是2.8万元。&lt;/p&gt;&lt;p&gt;  几名参与打捞尸体的渔民表示，因为怕遗体被水冲走，渔民们找来绳子，捆在了遗体的脚手上，并安排人看守，“从发现到打捞，再到寻找死者家人，我们付出了辛苦的劳动，收相应费用并不为过。”现场的渔民还表示，他们并未要对方必须拿出多少钱，只是觉得做了事情，该得到应有的回报。&lt;/p&gt;&lt;p&gt;  法律视线&lt;/p&gt;&lt;p&gt;  渔民捞尸 能不能索要报酬？&lt;/p&gt;&lt;p&gt;  西南财大民商法博士后沈冬军认为，渔民在未与家属达成一致意见的情况下，主动打捞尸体，构成民法上的无因管理行为。所谓无因管理，是指没有法定或者约定义务，基于保护他人的利益，主动管理他人事务或为他人提供服务的法律事实。在这个事件中，渔民在打捞起尸体后，有权索要必要的费用。这个必要费用是多少，可以根据市场因素来确定。&lt;/p&gt;&lt;p&gt;  川师法学教师蒋健也认为，打捞尸体的行为属于无因管理的帮助行为，渔民可以据此主张适当补偿。&lt;/p&gt;&lt;p&gt;  渔民能不能扣留尸体？&lt;/p&gt;&lt;p&gt;  沈冬军认为，无因管理法律关系中没有赋予管理人扣留物品的权利，更何况尸体是特殊物品。如果渔民擅自扣留尸体，甚至处理尸体，可能面临侵权责任。如果侮辱、破坏尸体，情节严重可涉嫌侮辱尸体犯罪。&lt;/p&gt;&lt;p&gt;  打捞费有无标准？&lt;/p&gt;&lt;p&gt;  四川谦亨律师事务所张天鸿律师认为，之所以发生这样的事件，原因可能在于没有明确的溺水救助和遗体打捞制度，及明确的溺水救助和遗体打捞劳务标准。对于遗体打捞劳务标准，应充分考虑打捞成本与打捞价格的对等性、合理性，但漫天要价应严厉打击。&lt;/p&gt;&lt;p&gt;  渔民是否涉嫌敲诈勒索？&lt;/p&gt;&lt;p&gt;  蒋健认为，扣尸索要1.8万元，不构成刑法上的敲诈勒索犯罪。敲诈勒索犯罪主观上需要明知他人不拿出财物，心理上会造成极大的恐惧、害怕或名誉极大受损。渔民扣尸是为了索要多一点的辛苦费，经过民警调解后，双方达成了支付5400元的协议，渔民的扣留行为并没有造成严重的后果和恶劣的社会影响，没有达到敲诈勒索犯罪的程度。&lt;/p&gt;&lt;br&gt;&lt;p&gt;  沈冬军也认为，不管是打捞还是扣留，渔民和死者家属间发生的都是民事法律关系，刑法作为最后的调整手段，不宜滥用到民事法律关系中。&lt;/p&gt;&lt;/blockquote&gt;挟尸要价可能构成敲诈勒索罪和侮辱尸体罪。&lt;br&gt;&lt;ul&gt;&lt;li&gt;你的手机掉在大街上。有人把你的手机捡走，然后以手机原价卖回给你。这叫不当得利。&lt;br&gt;&lt;/li&gt;&lt;li&gt;你的手机掉在大街上。有人把你的手机捡走，然后威胁要公布手机中的裸照，以手机十倍价格卖回给你。这叫敲诈勒索罪。&lt;/li&gt;&lt;li&gt;你的手机掉在大街上。有人帮你保管，等你回来再还给你，耽误了时间，你给他支付误工费。这叫公平原则。&lt;/li&gt;&lt;li&gt;你的手机掉在大街上。有人帮你保管，要求你先支付误工费才还你。你不付钱他就扣下你的手机。这叫侵占行为（但不构成侵占罪）。&lt;/li&gt;&lt;li&gt;你的手机掉在大街上。有人帮你保管，等你回来再还给你，耽误了时间，你没给他支付误工费。他起诉你，法院要你支付误工费。这叫责令受益人给予适当补偿。&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;把手机换成尸体，大街换成金沙江，道理一样。&lt;p&gt;原新闻中采访的律师说的，与法理不合。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2016-06-15-21360759</guid>
<pubDate>Wed, 15 Jun 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>做编程学历很重要么？</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2015-12-22-20436273.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;做编程学历很重要么？&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20436273&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
我2006年毕业，我虽然大学也是一本，但专业不对口，学的是法学。&lt;br&gt;&lt;br&gt;我在大学期间做过游戏外挂和一些别的小工具，就开发能力而论，比绝大多数应届毕业生都要强许多。2005年初我甚至用JavaScript做过一个只支持IE5.5的虚拟DOM框架，比ReactJS早了八年。&lt;br&gt;&lt;br&gt;然而，当年我找码农的工作，简历投出去大都石沉大海。我住在广州北郊龙洞的城中村，几个月都找不到工作，楼下饭店老板娘每天看着我的颓废样，说：“小伙子，要在厂里找个工作不难，想找个坐办公室的工作可没那么容易。”当年民工荒，老板娘可能觉得我不切实际，眼高手低吧。&lt;br&gt;&lt;br&gt;后来 &lt;a data-hash=&quot;8b1c293dd32f164a18ac0a432912d437&quot; href=&quot;https://www.zhihu.com/people/8b1c293dd32f164a18ac0a432912d437&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@黄希彤&quot;&gt;@黄希彤&lt;/a&gt; 内部推荐我去腾讯的qzone组，按社会招聘的标准面试，我过五关斩六将最后拿到offer。&lt;a data-hash=&quot;8b1c293dd32f164a18ac0a432912d437&quot; href=&quot;https://www.zhihu.com/people/8b1c293dd32f164a18ac0a432912d437&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@黄希彤&quot;&gt;@黄希彤&lt;/a&gt; 说我专业不对口问题不大，但要是没有毕业证，要通过腾讯的招聘流程就麻烦了。&lt;br&gt;&lt;br&gt;不幸的是，我有一个朋友，在天涯论坛叫做“菜霸”，是个骇客，媒体称他为农村失学少年（他另一个网名叫“朽木自雕”，你们体会一下）。当时菜霸把腾讯脱裤了。腾讯做背景调查时发现我有这样的骇客朋友，担心我是坏人，就把我的offer取消了。&lt;br&gt;&lt;br&gt;后来我连续去了几家不靠谱的公司，参加了一次不靠谱的创业，翻译了&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3581107/&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;Flex 3权威指南&quot;&gt;Flex 3权威指南&lt;/a&gt;，直到2008年底入职网易，职业生涯才算安定下来（有趣的是，我去了网易后，&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ac.net.blog.163.com/blog/&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;博客&quot;&gt;博客&lt;/a&gt;产量急剧下降）。我虽然不是科班出身，但我计算机基础比一般科班出身的都要牢靠，我在网易时被当时同事称为“语言律师”。&lt;br&gt;&lt;br&gt;我自己算了一下，如果我当年专业对口，搞搞ACM，考个GRE去美帝留学，毕业就去Google、Facebook或LinkedIn，职业生涯应该会比现在顺利一点。&lt;br&gt;&lt;br&gt;不过，如果你的要求只是入行成为一名码农，那么真心不难。何况你现在比我当年环境好太多了。&lt;br&gt;&lt;br&gt;虽然你现在找工作时，依然和我当年一样，简历会被直接筛走而进不了招聘流程，即使有内部推荐，也要走难度高于应届毕业生的社会招聘流程。不过，你可以在github上做开源项目，很多用人单位都很看重。不像我当时只有sourceforge可用，想要对知名项目做贡献，门槛很高。&lt;br&gt;&lt;br&gt;除此之外，你可以直接做freelancer（参见 &lt;a href=&quot;http://www.zhihu.com/question/22063667&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;想全职做国外的程序外包，例如freelancer，能分享下经验吗？ - 自由职业&quot;&gt;想全职做国外的程序外包，例如freelancer，能分享下经验吗？ - 自由职业&lt;/a&gt;）。有了案例后，找工作会容易许多。我今年初找工作的空窗期做过一个多月freelancer，挣了两千多美元，不久就有一家迪拜的公司想找我去全职工作。&lt;br&gt;&lt;br&gt;最后，你英语不好需要解决，因为所有主流技术的英文资料都要比其他语言全面得多，更不要说freelancer需要用英语和客户沟通。我上大学时英语补考好几次，到了毕业时英语四级都没过。但我在英文技术社区活跃了几年以后，现在我的技术英语读写能力不比我组里任何一个人差（然而我听力不好，吃喝玩乐的单词基本不认识）。你刚开始多查字典，多参与讨论，时间长了，技术单词认得多了，英文读写就会好起来。&lt;br&gt;&lt;br&gt;你还可以找出版社接活翻译技术书籍，又学英语又学技术还能挣点钱。你直接给&lt;a href=&quot;http://www.zhihu.com/people/liujiang&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;刘江&quot;&gt;刘江&lt;/a&gt;发私信要求试译就行。现在有&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//translate.google.com/toolkit&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;谷歌翻译工具套件&quot;&gt;谷歌翻译工具套件&lt;/a&gt;，比我当年翻译容易多了。</description>
<author>杨博</author>
<guid isPermaLink="false">2015-12-22-20436273</guid>
<pubDate>Tue, 22 Dec 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>不优雅的F#</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2015-11-15-20342142.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;不优雅的F#&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20342142&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
英文的Elegance通常固定翻译为“优雅”，并不是日常汉语中的优美典雅的意思，而是指内涵丰富而组成元素简单高效。&lt;br&gt;&lt;br&gt;以游戏设计为例：&lt;br&gt;&lt;ul&gt;&lt;li&gt;围棋规则很简单但变化很丰富，所以围棋规则很优雅。（元素简单内涵丰富）&lt;br&gt;&lt;/li&gt;&lt;li&gt;三国杀每一张武将都有截然不同的特殊技能，所以规则多，例外多，然而三国杀武将强弱分明，策略并不复杂，那么三国杀的游戏规则就很不优雅。（元素复杂内涵肤浅）&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;F#是OCaml的方言。我用过OCaml，没有用过F#，但看过F#的文档。&lt;br&gt;&lt;br&gt;F#虽然也算一门现代编程语言，但语言设计远远不如Scala优雅。F#的标准库和.NET标准库互相之间格格不入，F#的基于代数数据类型（ADT）的类型系统也和.net原生的类库风格格格不入。F#生态环境和Scala相比更是弱爆了。在工程实践中，无论面向对象编程还是函数式编程，Scala都有大量的框架和第三方库，更不要说Scala标准库本身就完爆F#标准库。&lt;br&gt;&lt;br&gt;我觉得微软当年在卖碟的鲍尔默领导下，对技术的理解有点走火入魔，设计的API臃肿不堪，死守向后兼容性不放。&lt;br&gt;所以微软设计的语言也是这个尿性，压根没动脑筋思考过怎么把函数式语言融入面向对象中，只是简单兼容OCaml语法，再额外增加一堆不相干的功能。相比之下Martin Odersky做过Pizza、Generic Java，很多年前就已经试过怎么在JVM中实现函数式编程，最终完成的Scala抛弃与Java的源代码兼容性，最终平滑的把函数式编程特性和面向对象融入在一起：参见&lt;a href=&quot;http://www.infoq.com/cn/articles/Scala-Design&quot; data-editable=&quot;true&quot; data-title=&quot;Scala的设计目标——Martin Odersky访谈（二）&quot; class=&quot;&quot;&gt;Scala的设计目标——Martin Odersky访谈（二）&lt;/a&gt;。&lt;br&gt;&lt;br&gt;Scala和F#的关系类似Lua和____（此处可填Python、JavaScript、Ruby）。Lua的语言核心极为精简，然而其他动态语言能做到的功能，Lua都能做到。尽管Lua对于语言特性非常吝啬，却早在十多年前就支持了coroutine，这很具有前瞻性。&lt;br&gt;Roberto Ierusalimschy写过一篇文章论述它是如何设计Lua的：&lt;a href=&quot;https://queue.acm.org/detail.cfm?id=1983083&quot; data-editable=&quot;true&quot; data-title=&quot;Passing a Language through the Eye of a Needle&quot; class=&quot;&quot;&gt;Passing a Language through the Eye of a Needle&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;http://www.zhihu.com/people/excited-vczh&quot; data-hash=&quot;0970f947b898ecc0ec035f9126dd4e08&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@vczh&quot;&gt;@vczh&lt;/a&gt; 说：&lt;blockquote&gt;Scala比F#更烂是因为Scala比C++更复杂，永远都学不会。&lt;/blockquote&gt;&lt;p&gt;我能理解&lt;a data-hash=&quot;0970f947b898ecc0ec035f9126dd4e08&quot; href=&quot;http://www.zhihu.com/people/0970f947b898ecc0ec035f9126dd4e08&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@vczh&quot;&gt;@vczh&lt;/a&gt; 作为微软员工，无法黑微软的痛楚，但我还是觉得 &lt;a data-hash=&quot;0970f947b898ecc0ec035f9126dd4e08&quot; href=&quot;http://www.zhihu.com/people/0970f947b898ecc0ec035f9126dd4e08&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@vczh&quot;&gt;@vczh&lt;/a&gt; 对“复杂”的理解稍显浅薄。&lt;br&gt;&lt;br&gt;我们看看Scala作者Martin Odersky写的&lt;a href=&quot;http://www.ac.net.blog.163.com/blog/static/13649056201232581654403/&quot; data-editable=&quot;true&quot; data-title=&quot;简单还是复杂？&quot; class=&quot;&quot;&gt;简单还是复杂？&lt;/a&gt;&lt;br&gt;我自己从头比了比上下文无关语法的数量，Scala相当紧凑，和Haskell或OCaml相当，比Java5稍少，比C#和C++少得多。 &lt;br&gt;由于F#是OCaml的超集，F#的语法比Scala复杂。F#功能并不比Scala强但语法比Scala复杂，暗示着F#中存在冗余语法或者不一致的语法，也就是，不优雅。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2015-11-15-20342142</guid>
<pubDate>Sun, 15 Nov 2015 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
