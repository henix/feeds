<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>命运之轮</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/35699422">原文</a></p>
<p>我最初学编程，应该也就是2010年左右的事情吧。</p><p>当时啥也不会，就会在C++吧水贴。</p><p>在那，听说过了有一个很厉害很潮流的东西，叫做C++11，有什么叫concept跟module的东西，好像挺厉害的样子。</p><p>当时，在clang上就可以用C++11了，只不过这两功能还没有，就有auto, lambda, constexpr 不知道有没有（记不清了），也很好了。</p><a href="https://www.zhihu.com/question/56943731" data-draft-node="block" data-draft-type="link-card">时间快进到现在，这两功能还是没加进去。</a><p>不过C++厨们可以稍稍放心，我今天不是来黑C++的。</p><p>这固然是C++的悲剧，不过也是所有语言的悲剧。</p><p><br></p><p>如果去看历史，去看看一个个语言的发展，我们会发现一个规律：</p><p><b>语言/语言家族的发展，是不停的扩大，直到无法支撑自身的重量而倒下为止。</b></p><p><br></p><p>让我们跳到1958。</p><p>ALGOL。</p><p>只要大家说计算机历史，就一定要说ALGOL。</p><p>因为这可以说是一切的开端。也是一门伟大的语言。</p><p>做Algol相关的work的图灵奖得主，足足有6个：John Backus，Alan Perlis，Peter Naur，John McCarthy，Edsger W. Dijkstra，Tony Hoare。还有无冕之王，Peter Landin跟John Reynold。</p><p>但是，为何这么成功的语言，却默默无名？因为错在了下一步。</p><p>在1960后，ALGOL推出了ALGOL 58，ALGOL 60，还有各种方言后，大家开始慢慢懂该怎么设计语言，实现编译器了。BNF，Recursion，Continuation，Stack，都慢慢被大家发明发现，慢慢熟悉。大家也开始发现了ALGOL 60没做好跟没有做的东西。</p><p>于是，1962起，大家开始发明一门新的，叫ALGOL X的语言，旨在把这些问题修好。从1962起讨论，一直到1965，变成一个draft。高兴的ALGOL厨把这叫做ALGOL W，并且等着用了。一切就差一些小修小补了。</p><p>就跟物理学大厦就剩下两朵乌云一样。</p><p>快进半年。另外一个ALGOL W的draft被奉上。情况不容乐观。</p><p>本来说好的三个月，跳票成了半年不说，draft变得更厚更长，问题反而越来越多。于是说在等三个月，我们再修修。</p><p>明明说三月，三月后又三月，三月后又三月，都快一年了。</p><p>拖了9个月后，在1968年尾，一个叫ALGOL W的，连设计者也不爱的怪兽产生了。</p><p>自此，ALGOL被命运之轮碾过。</p><p><br></p><p>故事的另一个主角，则知名得多。CPL。</p><p>这是1963，离悲剧还远得很，这时候大家都已自己是ALGOL方言为荣。</p><p>CPL就是一个ALGOL方言，旨在做更底层的ALGOL。</p><p>语言的设计也不算很复杂，唯一的问题就是不知道为啥，编译器死活写不出来。</p><p>于是，1967，有人在想，为何我们不把CPL简化点？这样就能做出编译器来了。</p><p>然后就出现了BCPL。同年，BCPL的编译器也被实现了。</p><p>两年后，为了把BCPL放上微型机，再次简化，出现了B。</p><p>同时间，B的一些问题被发现，效率也不够高，于是一个差不多的语言开始被设计，C。</p><p>而在C设计过程中，1970年，CPL的编译器终于面世。</p><p>命运之轮碾压过ALGOL，再碾压过CPL，碾压一次不够再碾压一次，BCPL，最后出了B，然后造就了C。最大赢家。</p><p>之后的，就是历史。</p><p><br></p><p>不过，这不是结束。也不是结束的开始。顶多是开始的结束。</p><p>还记得最开头的C++吗？没错，命运之轮怎么会放过C。</p><p>在C++后，为了简化，出现了JAVA，旨在消除C++的各种复杂性-比如不区分unsigned啊，自动管理内存啊，只有Class啊-只不过，到了最后，还是照样该变大变大。自动管理内存的确比手动简单，但是JVM确变成一个怪兽。就连unsigned这种小东西，<a href="https://www.zhihu.com/question/39596383/answer/82267124">也回到语言中了。</a>屠龙的勇士，必成恶龙。</p><p>另外一边，PERL崩溃之后诞生的Python也一样，，不知道怎么的，就加入了optional static typing。。。说好的only one way呢？Simplicity呢？</p><p><br></p><p>专门搞PL的人别偷笑，Scala就不说了，Haskell也一样，GHC无比复杂，连RecursiveDo都能水一篇<a href="https://pdfs.semanticscholar.org/20ab/57bf6d14d6a08a950b015d17af5f41b1b22b.pdf">170页的Paper</a>，有一个minimal core，也不能解决这问题。也别以为Macro能解决问题-R6RS总共有187页，其中，有90页是语言定义。被称为怪兽的ALGOL W也就265页，实在差不了多少。ALGOL 60呢？17页。ALGOL 58则只有15页。不过R7RS倒是还行，只有77页。当然，这是以丢掉向后兼容性为代价的。</p><p><br></p><p>有没有语言试图挑战这命运之轮？</p><p>有。Scheme，Python，都壮士断腕，丢掉了向后兼容性。自己不丢，别人就会给你丢。</p><p>Go也算是，Rob Pike活了60年，啥大风大浪没见过，尤其是Google的Build Server再也撑不起他们的C++，当然知道复杂度乃洪水猛兽-要不然为啥死撑不肯加generic。</p><p>不过这几个付出的代价不少-不是兼容性就是限制自己发展。对于语言设计者来说，这是个绕不开的问题。</p><p><br></p><p>回到最初。为什么C++的concept module老是跳票，总共跳了9年？</p><p>还记得ALGOL W有多少页吗？265。至于C++17，1600多。6个ALGOL W，100个ALGOL 58。能让人大呼卧槽的数字。Java标准700页，加上JVM，也有1300页。</p><p><br></p><p>于是隔几天，我跟朋友吃饭的时候提起，卧槽，现在的编程语言复杂度都变成鬼了，100个ALGOL。这么复杂，怎么设计怎么写编译器。</p><p>我那在nvidia实习的朋友听了，不以为然的说了声，哦。直到我过了半年，上了门计算机架构的课，才明白为什么他没有被震惊到。</p><p><br></p><p>其实PL的复杂度爆炸还算好的了。</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
