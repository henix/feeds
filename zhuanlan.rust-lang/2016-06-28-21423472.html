<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>基本数据类型</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/21423472">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/2d3a49c8aed879ac11aac9a2bb718896_r.png" alt=""></div><h1>基本数据类型</h1><h2>变量声明</h2><p>Rust的变量必须先声明后使用。对于局部变量，声明语法为:</p><code lang="text">let variable : i32 = 100;
</code><p>与传统的C/C++语言相比，Rust的变量声明语法不同。这样设计主要有这样几个方面的考虑：</p><br><p>1. 语法分析更容易</p><p>从语法分析的角度来说，Rust的变量声明语法比C/C++语言的简单，局部变量声明一定是以关键字 let开头，类型一定是跟在:的后面。</p><p>在C++里面，这样一个简单的结构 A B(C);，在语法分析的时候都会有多种可能性：</p><p>1) A 和 C 是类型，B 是函数声明；2) A 是类型，C 是变量，B 是变量初始化； 3) A 是变量，这是一个错误的语法。<br><br>当类型变得更复杂的时候，Rust的优势体现得更明显，比如大家分析一下这样的以下ff变量是什么类型</p><code lang="text">int (*ff( int ))( int, int );</code><p>    如果我们用Rust来写，则清晰得多：</p><code lang="text">  let ff : fn(isize,isize) -&gt; fn(isize);
</code><p>    更不用说C++经常碰到的语法歧义问题，比如：</p><code lang="text">  a&lt;b&gt; c;
</code><p>在语法解析阶段，这段代码的意思可能有两种：1) a 小于 b 大于 c，这是两个比较操作，虽然语义上有问题，bool 类型不能做比较； 2) a&lt;b&gt;是带模板参数的类型，c 是变量名。语法分析器必须参考当前环境下的其它信息才能决定它是符合哪种语法。</p><p>  Rust在语法设计方面，一直以LL(1)类型语法为目标。这意味着，写出Rust的语法分析器不是特别困难的事情，即便是用最简单的递归下降法也能很好完成任务。语法的简洁不仅能降低编译器的编写难度，其实还有多重好处。更重要的是，能让程序员学习成本更低，在做“人肉分析”的时候更轻松。另外，对于周边生态环境和工具的建设也有不小的促进作用。在这方面C++则是做了一个坏的典范，它的语法复杂度之高，使得能写出完整的C++语法分析器的人，可以说是寥寥无几，大幅度提高了C++周边工具开发的难度。</p><br><p>2. 方便引入类型推导功能</p><p>Rust的变量声明一个重要特点是，要声明的变量前置，对它的类型描述后置。这也是吸取了其它语言的教训后的结果。</p><p>因为在变量声明语句中，最重要的是变量本身，而类型其实是个附属的额外描述，并非必不可少的一部分。如果我们可以通过上下文环境由编译器自动分析出来这个变量的类型，那么这个类型描述完全可以省略不写。</p><p>在C++中，一开始是完全跟随C语言的设计，使用了类型前置的语法。但是在后期，加入越来越多的高级功能后，比如 lambda 和匿名类型，设计者发现许多情况下，必须使用编译器自动类型推导，于是迫不得已又引入了新的声明语法，这样导致了语言复杂度变得更高：</p><code lang="text">auto multiply = [](auto a, auto b) {return a*b;};
</code><p>在C#中也有同样的问题，在引入lambda和匿名类型功能后，不得不引入新的var关键字做为新的类型声明语法。</p><p>Rust在一开始的设计就考虑了类型自动推导功能，因此类型后置的语法更合适。</p><p>3.  let语句不光是局部变量声明语句，而且具有pattern destructure(模式解构)的功能。关于“模式解构”的内容在后面的文章会详细描述。</p><br><p>Rust中声明变量缺省是“只读”的，比如说如下程序：</p><code lang="text">fn main() {
   let x = 5;
   x = 10;
}
</code><p>会得到“re-assignment of immutable variable x”这样的编译错误。</p><p>如果我们需要让变量是可写的，那么需要使用mut关键字：</p><code lang="text">let mut x = 5; // mut x: i32
x = 10;
</code><p>此时，变量x才是可读写的。实际上，let语句就是引入了一个模式解构，我们不能把 let mut 视为一个组合，而应该将mut x视为一个组合。</p><p>mut x是一个“模式”，我们还可以用这种方式同时声明多个变量：</p><code lang="text">let (mut a, mut b) = (1, 2);
let Point { x: ref a, y: ref b} = p;
</code><p>所以，在Rust中，一般把声明的局部变量称为“变量绑定”，强调的是“绑定”的含义，与C/C++中的“赋值”语句有所区别。</p><h2>变量隐藏(Shadowing)</h2><p>Rust中允许在同一个代码块中声明同样名字的变量。如果这么做，那么后面声明的变量会将前面声明的变量“隐藏”起来。</p><code lang="text">fn main() {
    let x = "hello";
    println!("x is {}", x);
    let x = 5;
    println!("x is {}", x);
}
</code><p>这个程序是可以编译通过的。请注意第5行的代码，它不是x=5;，它前面有一个let关键字。</p><p>如果没有这个 let 关键字，这条语句就是对 x 的重新绑定（重新赋值）。</p><p>而有了这个 let 关键字，它在这里就是又声明了一个新的变量，只是它的名字恰巧与前面一个变量刚好相同而已。</p><p>但是这两个x代表的内存空间完全不同，它们的类型完全不同，它们实际上是不同的两个变量。从第5行开始，下面一直到这个代码块结束的范围，我们没有任何办法再去访问前一个x变量，因为它的名字已经被隐藏了。</p><p>变量隐藏在有些情况下非常有用，比如，我们对一个可变数组执行初始化，希望此时它是可读写的，但是初始化完成后，我们希望它是只读的。可以这么做：</p><code lang="text">// 注意：这段代码只是演示变量隐藏功能，并不是Vec类型的最佳初始化方法
fn main() {
    let mut v = Vec::new();  // v 必须是mut修饰，因为我们需要对它写入数据
    v.push(1);
    v.push(2);
    v.push(3);
    let v = v;  // 从这里往下，v成了只读变量，可读写变量v已经被隐藏，无法访问
    for i in &amp;v {
        println!("{}", i);
    }
}
</code><p>反过来，如果一个变量是不可变的，我们也可以通过变量隐藏创建一个新的同名变量是可变的。</p><code lang="text">fn main() {
    let v = Vec::new();
    let mut v = v;
    v.push(1);
    println!("{:?}", v);
}
</code><p>请注意，这个过程是符合“内存安全”的。关于“内存安全”的概念，一直是Rust关注的重点，我们将在后文详细讲述。</p><p>在上面这个示例中，我们需要理解的是，一个“不可变绑定”，它依然是一个“变量”。虽然我们没法通过这个“变量绑定”修改变量的值，但是我们重新使用可变绑定之后，还是有机会修改的。这么做并不会产生内存安全问题，因为我们对这块内存拥有完整的所有权，且此时没有任何其它引用指向这个变量，对这个变量的修改是完全合法的。</p><h2>类型推导</h2><p>Rust的类型推导功能是比较强大的。它不仅可以从变量声明的当前语句中获取信息进行推导，而且还能通过上下文信息，进行推导。</p><code lang="text">fn main() {
    // 没有明确标出变量的类型，但是通过字面量的后缀，
    // 编译器知道elem的类型为u8.
    let elem = 5u8;
    // 创建一个动态数组，数组内包含的是什么元素类型可以留着不写
    let mut vec = Vec::new();
    vec.push(elem);
    // 到后面调用了push函数，通过elem变量的类型，
    // 编译器可以推导出vec的实际类型是 Vec&lt;u8&gt;
    println!("{:?}", vec);

}
</code><p>我们甚至还可以只写一部分类型，剩下的部分让编译器去推导，比如下面的这个程序，我们只知道players变量是Vec动态数组类型，但是里面包含什么元素类型不清楚，可以在尖括号中用下划线来代替：</p><code lang="text">fn main() {
    let player_scores = [
        ("Jack", 20), ("Jane", 23), ("Jill", 18), ("John", 19),
    ];

    // players 是动态数组，内部成员的类型没有指定，交给编译器自动推导
    let players : Vec&lt;_&gt; = player_scores
        .iter()
        .map(|&amp;(player, _score)| {
            player
        })
        .collect();
    println!("{:?}", players);
}
</code><p>自动类型推导，和“动态类型系统”，是两码事。Rust依然是静态类型的，一个变量的类型必须在编译阶段确定，且无法更改，只是某些时候不需要在源码中显式写出来而已，这只是编译器给我们提供的一个辅助工具。</p><h2>基本类型</h2><p>下面我们来逐一介绍一下Rust的基本数据类型。</p><h3>bool</h3><p>布尔类型代表的是“是”和“否”的逻辑。它有两个值：true和false。一般用在逻辑表达式中，可以执行“与”、“或”、“非”等运算。</p><code lang="text">let x = true;
let y: bool = !x;
println!("{} {}", x, y);
</code><h3>字符</h3><p>字符类型由char表示。它可以描述任何一个符合unicode标准的字符值。在代码中，单个的字符字面量用单引号包围。</p><code lang="text">let love = '❤';
</code><p>字符类型字面量也可以使用转义符：</p><code lang="text">let c1 = '\n';       // 换行符
let c2 = '\x7f';     // 8 bit 字符变量
let c3 = '\u{7FFF}'; // Unicode字符
</code><p>因为char类型的设计目的是描述任意一个unicode字符，因此它占据的内存空间不是1个byte，而是4个byte。</p><p>对于ASCII字符其实只需占用一个字节的空间，因此Rust提供了单字节字符字面量来表示ASCII字符。我们可以使用一个字母 b 在字符或者字符串前面，代表这个字面量存储在 byte 数组中。示例如下：</p><code lang="text">let x :u8 = 1;
let y :u8 = b'A';
let s :&amp;[u8;5] = b"hello";
let r :&amp;[u8;14] = br#"hello \n world"#;
</code><h3>整数类型</h3><p>Rust有许多的数字类型，主要分为整数类型和浮点数类型。本节讲整数类型。各种整数类型之间的主要区分特征是：有符号/无符号，占据空间大小。</p><br><img src="https://pic4.zhimg.com/c17f62b1decf916d4a110c6a03c477b6_r.png" data-rawwidth="283" data-rawheight="269"><br><p>所谓有符号无符号，指的是如何理解内存空间中的bit表达的含义。如果一个变量是有符号类型，那么它的最高位的那一个bit就是“符号位”，表示该数为正值还是负值。如果一个变量是无符号类型，那么它的最高位和其它位一样，表示该数的大小。比如对于一个byte大小的数据来说，如果存的是无符号数，那么它的表达范围是0~255，如果存的是有符号数，那么它的表达范围是-128~127。</p><p>关于各个类型所占据的空间大小，在名字中就已经表现得很明确，无需多言。需要特别关注的是isize和usize类型，它们占据的空间是不定的，与指针占据的空间一致，与所在的平台相关，如果是32位系统上，则是32位大小；如果是64位系统上，则是64位大小。在C++中与它们相对应的类似类型是int_ptr和uint_ptr。</p><p>数字类型的字面量表示可以有许多方式：</p><code lang="text">let i1 : i32 = 32;     // 直接写10进制表示
let i2 : i32 = 0xFF;   // 以0x开头代表16进制表示
let i3 : i32 = 0o55;   // 以0o开头代表8进制表示。
let i4 : i32 = 0b1001; // 以0b开头代表2进制表示。
</code><p>在C/C++/javascript语言中以0开头的数字代表8进制坑过不少人，这个设计终于改了。</p><p>在所有的数字字面量中，可以在任意地方添加任意的下划线，方便阅读：</p><code lang="text">let i5 = 0x_1234_ABCD; //使用下划线分割数字，不影响语义，但是极大方便了阅读体验。
</code><p>字面量后面可以跟后缀，可代表该数字的具体类型，从而省略掉显示类型标记：</p><code lang="text">let i6 = 123usize; // i6变量是usize类型
let i7 = 0x_ff_u8; // i7变量是u8类型
let i8 = 32;       // 不写类型，使用其它上下文信息做类型推导
</code><p>在Rust中，我们可以为任何一个类型添加方法，整型也不例外。比如在标准库中，整数类型有一个方法是pow，它可以计算n次幂，于是我们可以这么使用：</p><code lang="text">let x = 9_i32;
println!("9 ^ 3 = {}", x.pow(3));
</code><p>同理，我们甚至可以不使用变量，而直接对整型字面量，这么调用函数：</p><code lang="text">println!("9 ^ 3 = {}", 9_i32.pow(3));
</code><p>我们可以看到这是非常方便的设计。</p><h3>浮点类型</h3><p>Rust提供了基于 IEEE 754-2008 标准的浮点类型。按占据空间大小区分，分别为f32和f64，其使用方法与整型差别不大。浮点数字面量表示方式有如下几种：</p><code lang="text">let f1 = 123.0f64;    // type f64
let f2 = 0.1f64;      // type f64
let f3 = 0.1f32;      // type f32
let f4 = 12E+99_f64;  // type f64
let f5 : f64 = 2.;    // type f64
</code><h3>类型转换as</h3><p>Rust是强类型编程语言，它对各个类型之间的转换控制得非常严格。即便是下面这样的程序，也会出现编译错误：</p><code lang="text">fn main() {
    let var1 : i8 = 41;
    let var2 : i16 = var1;
}
</code><p>编译结果为mismatched types! i8类型的变量竟然无法向i16类型的变量赋值！</p><p>Rust提供了一个关键字as，专门用于这样的类型转换：</p><code lang="text">fn main() {
    let var1 : i8 = 41;
    let var2 : i16 = var1 as i16;
}
</code><p>也就是说，Rust设计者遵循了这样的一条设计原则，显式比隐式好：</p><blockquote><p>Explicit is better than implicit. —The Zen of Python</p></blockquote><p>as关键字也不是随便可以用的，它只允许编译器认为合理的类型转换。任意类型转换是不允许的：</p><code lang="text">let a = "some string";
let b = a as u32;
</code><p>最基本的变量类型就先介绍到这里，下篇开讲复合数据类型。</p><p>本文同步发布在微信公众号：<b>Rust编程</b>。欢迎各位关注。</p><br>​
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
