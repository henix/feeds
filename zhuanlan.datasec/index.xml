<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>数据安全、隐私保护与密码学技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/</link>
<description>本专栏主要发布如下内容： 1. 国际黑帽子大会（… 本专栏主要发布如下内容： 1. 国际黑帽子大会（Black Hat），国际黑客大会（Def Con）上的演讲内容分析； 2. 密码学、网络安全相关的源代码分析； 3. 密码学、网络安全相关的知识介绍； 4. 业内可公开的安全架构思想； 5. 其他与信息安全相关的内容或转载文章； 欢迎投稿，欢迎指出任何错误~ 希望我们能够一起为普及、分享、研究信息安全相关理论和知识贡献自己的一份力量！</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 02 Jan 2020 09:06:10 +0800</lastBuildDate>
<item>
<title>2012年BIU密码学冬令营-01-格简介-第1部分</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2020-01-01-100556866.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/100556866&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e360959d44a6a8c3c10d1f05da43db49_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;新年新气象，欠的账也要还了… 2019年有知友私信给我，希望能把2012年BIU冬令营格密码学讲座（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cyber.biu.ac.il/event/the-2nd-biu-winter-school/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cyber.biu.ac.il/event/t&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;he-2nd-biu-winter-school/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;）的视频重新整理后发出。，这都到2020年了，终于有点时间重新整理这些视频了。在整理的过程中，我也发现了当时翻译中的很多错误，可能也代表自己对格密码学有了更进一步（虽然是很小的一步）的理解吧…&lt;/p&gt;&lt;p&gt;之前的视频由 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/dd331d75c50e28dd9e719ba2c6a0594a&quot; data-hash=&quot;dd331d75c50e28dd9e719ba2c6a0594a&quot; data-hovercard=&quot;p$b$dd331d75c50e28dd9e719ba2c6a0594a&quot;&gt;@Scalers&lt;/a&gt; 听译狂练小组的成员们一起来完成的，在此再次向他们表示感谢，相应参与人员的信息仍然保留在字幕中。此次字幕的整理工作得到了BIU冬令营组织者Benny Pinkas教授的大力支持，字幕文件和内容将会全部公开。最近，格密码学迎来了又一轮快速的发展，期望这一系列讲座能帮助密码学研究者们对格密码学有大致的了解。当然了，如果翻译中存在问题和错误，欢迎在评论区指正。我将一一修复错误，并随时更新视频。&lt;/p&gt;&lt;p&gt;2012年BIU冬令营格密码学讲座中，Learning With Errors假设的提出者Oded Regev打了个头炮，通过《Introduction to Lattice》的讲座为冬令营的参与者们介绍了格的基本概念和基本性质。由于这个讲座有两个多小时长，我们把此讲座分为三个部分分别上传。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;讲义链接：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cyber.biu.ac.il/wp-content/uploads/2017/01/slides-barilan1-2.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cyber.biu.ac.il/wp-cont&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ent/uploads/2017/01/slides-barilan1-2.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;视频链接：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.youtube.com/watch%3Fv%3D4ulHOV8iLls%26feature%3Dplcp&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=4ulHOV8iLls&amp;amp;feature=plcp&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av81642862/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av81&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;642862/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/Winter%2520School%2520on%2520Cryptography%25202012%2520-%2520Lattice-Based%2520Cryptography/01-Introduction%2520to%2520Lattices&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/Winter%20School%20on%20Cryptography%202012%20-%20Lattice-Based%20Cryptography/01-Introduction%20to%20Lattices&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1195763785770782720&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic3.zhimg.com/v2-47daab4796cabb07e6c02fcf64fc8632.jpg&quot; data-lens-id=&quot;1195763785770782720&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic3.zhimg.com/v2-47daab4796cabb07e6c02fcf64fc8632.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1195763785770782720&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-006ecba481ad4361e23ba21ad44bf0e5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-006ecba481ad4361e23ba21ad44bf0e5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-006ecba481ad4361e23ba21ad44bf0e5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-006ecba481ad4361e23ba21ad44bf0e5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-006ecba481ad4361e23ba21ad44bf0e5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;早上好，感谢主办方的邀请，感谢主办方为此次活动提供的大力支持。我估计随着讲座的进行，大家可能会更感谢演讲的老师们。总之非常感谢。&lt;/p&gt;&lt;p&gt;我们今天早上以什么为开场呢？我将从学术的角度为大家讲一讲这一领域的历史进程，有关格的简短介绍。后面大家可以看到，我们的讲座速度非常快，而且讲座的内容比较深入。所以，我认为第一个讲座应该是以“简介”为主题，希望大家都能够理解格是什么。如果有问题，大家随时可以打断我。好像很多朋友是从很远的地方过来听讲座的，有来自美国的，来自加拿大的，所以如果你觉得要睡着了，就告诉同桌把你叫起来。不过我会试着讲得有意思些，这样大家都不会睡着。但是从这些时区来的朋友们，让大家不睡着可能有点困难。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-298c7eb03e542335b7687c901222feff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic4.zhimg.com/v2-298c7eb03e542335b7687c901222feff_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-298c7eb03e542335b7687c901222feff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic4.zhimg.com/v2-298c7eb03e542335b7687c901222feff_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-298c7eb03e542335b7687c901222feff_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这个冬令营的主题是什么？主题是格和格在密码学中的应用。我们先来讲一讲格是什么。我想大家要首先了解的是格是什么？可能有些朋友根本没有听说过这个名词。这里有一个例子。这是在某个区域里有规律的图形，这就是格。这其实是卷心菜，不过表示的是同一个东西。它们都按照某种模式而规律排布，这种规律排布卷心菜的方式就是格，这个例子也一样，所以我们有两种表示方法了，卷心菜或者格。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e51fa99a179af2f44f3a37be8c60cc80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic1.zhimg.com/v2-e51fa99a179af2f44f3a37be8c60cc80_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e51fa99a179af2f44f3a37be8c60cc80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic1.zhimg.com/v2-e51fa99a179af2f44f3a37be8c60cc80_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e51fa99a179af2f44f3a37be8c60cc80_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这更像是格了。什么是格？格是高维空间中的点集。这是一个3维空间，且点的排布呈周期性规律。这是3维空间格的一个例子，但这实际上不能称之为格，因为这里点的数量并不是无穷多的，不过这个图能把格的意思表达出来。我这里不会详细讲解格的定义，我们会在讲座的第二个小时详细讲解，这里只是给大家一个概念。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-682254b3f7a96df843964d49b283c1bf_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic4.zhimg.com/v2-682254b3f7a96df843964d49b283c1bf_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-682254b3f7a96df843964d49b283c1bf_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic4.zhimg.com/v2-682254b3f7a96df843964d49b283c1bf_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-682254b3f7a96df843964d49b283c1bf_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;格可以形式化地定义为这样的形式，格是按照这种方式定义的点集。我们在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathbb%7BR%7D%5En&quot; alt=&quot;\mathbb{R}^n&quot; eeimg=&quot;1&quot;/&gt; 中选择 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个线性无关的向量，然后我们选取这些向量的全部整数组合而构成的点集。&lt;/p&gt;&lt;p&gt;幻灯片上是一个格的例子。我选择了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_1&quot; alt=&quot;v_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_2&quot; alt=&quot;v_2&quot; eeimg=&quot;1&quot;/&gt; ，这是两个向量，然后我选取它们的全部整数组合。举例来说，我们有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2v_2&quot; alt=&quot;2v_2&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_1%2Bv_2&quot; alt=&quot;v_1+v_2&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=2v_1&quot; alt=&quot;2v_1&quot; eeimg=&quot;1&quot;/&gt; 。我们也可以选择负数，比如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=-v_2&quot; alt=&quot;-v_2&quot; eeimg=&quot;1&quot;/&gt; ，这个点没在图里面。但实际上，点集会遍布整个空间，遍布所有方向。很显然， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%280%2C0%29&quot; alt=&quot;(0,0)&quot; eeimg=&quot;1&quot;/&gt; 这个0点永远包含在格点中。我想大家可以从图中对格有个直观感觉了，这些都是这两个向量的整数组合，所形成的点集有点像网格，我们把这称为格。&lt;/p&gt;&lt;p&gt;有些人会把这两个点称为基。点集 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_1%2Cv_2%2C%E2%80%A6%2Cv_n&quot; alt=&quot;v_1,v_2,…,v_n&quot; eeimg=&quot;1&quot;/&gt; 是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L&quot; alt=&quot;L&quot; eeimg=&quot;1&quot;/&gt; 的基。这个定义很像向量的线性生成空间，只不过我们这里只选取整数组合。我们通过这种方式得到了规律点集的形式化描述。在第一个小时我不会讲的特别深入。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-43fac4259918dd2f14a236c0dfba06eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic4.zhimg.com/v2-43fac4259918dd2f14a236c0dfba06eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-43fac4259918dd2f14a236c0dfba06eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic4.zhimg.com/v2-43fac4259918dd2f14a236c0dfba06eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-43fac4259918dd2f14a236c0dfba06eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们来讲一讲为什么格在密码学中有如此重要的地位。 举例来说，我们选择这两个向量，这样更形象些。我们选择这两个向量， &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_1&quot; alt=&quot;v_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_2&quot; alt=&quot;v_2&quot; eeimg=&quot;1&quot;/&gt; ，然后想一想这两个向量生成的格是什么。一眼看上去，你可能会觉得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_1%2Bv_2&quot; alt=&quot;v_1+v_2&quot; eeimg=&quot;1&quot;/&gt; 是一个特别长的向量，和原点离得很远，所生成格的形状可能很奇怪。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-eed89efda031087413d514c231918860_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic1.zhimg.com/v2-eed89efda031087413d514c231918860_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-eed89efda031087413d514c231918860_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic1.zhimg.com/v2-eed89efda031087413d514c231918860_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-eed89efda031087413d514c231918860_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;但实际上如果你仔细思考一下的话，就会发现这才是所生成的格。对比开始时想象的结果，你可能会觉得很惊奇，所生成的格点可以离原点这么近。但实际上向量是可以相减的，你可以计算 &lt;img src=&quot;https://www.zhihu.com/equation?tex=3v_2-4v_1&quot; alt=&quot;3v_2-4v_1&quot; eeimg=&quot;1&quot;/&gt; ，你就会得到这个和原点距离非常近的点，这就是格之所以如此有用的一个原因，因为即使基向量很长，格点和原点距离也可能非常近。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-05f0f096c96e65684d502844835969a0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic1.zhimg.com/v2-05f0f096c96e65684d502844835969a0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-05f0f096c96e65684d502844835969a0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic1.zhimg.com/v2-05f0f096c96e65684d502844835969a0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-05f0f096c96e65684d502844835969a0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我想给大家讲解的是，格的基向量并不是唯一的，这是格的另一个性质。 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_1%27&quot; alt=&quot;v_1&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_2%27&quot; alt=&quot;v_2&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 这两个向量也是同样一个格的基。这在密码学中有很重要的作用，大家在后面也能看到，我们可以试着用格基隐藏格原本的结构特性。我可以不给你 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_1%27&quot; alt=&quot;v_1&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_2%27+&quot; alt=&quot;v_2&amp;#39; &quot; eeimg=&quot;1&quot;/&gt; ，只给你 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_1&quot; alt=&quot;v_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v_2+&quot; alt=&quot;v_2 &quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-858c2f2309e9b0d99fd63b279a8c0a13_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic4.zhimg.com/v2-858c2f2309e9b0d99fd63b279a8c0a13_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-858c2f2309e9b0d99fd63b279a8c0a13_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic4.zhimg.com/v2-858c2f2309e9b0d99fd63b279a8c0a13_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-858c2f2309e9b0d99fd63b279a8c0a13_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;来看看格的历史。这里是研究格的数学家先驱们。照片上他们看起来好像很不开心，我也不知道为什么。最近数学家的照片看起来会开心些，可能是因为格理论有了些进展。&lt;/p&gt;&lt;p&gt;历史上，在19世纪早期，人们主要是从数论的角度、从数学角度研究格。人们关注格的数论方面性质，而不是格的应用。1801年高斯开始研究格，然后是Hermit、Minkowski。我认为Minkowski在格的研究方面做出了突出的贡献，甚至今天大家都可以学习到Minkowski的研究成果了，也就是Minkowski定理。他们当时关注的是不同的问题，并没有关注密码学应用，但这个定理直到现在都有重要的应用价值，所以Gauss、Hermite和Minkowski，他们是格领域主要的数学家们，我们今天会看到他们的一些成果。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c743342f25d5b270c1a3c36780d01ed8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic1.zhimg.com/v2-c743342f25d5b270c1a3c36780d01ed8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c743342f25d5b270c1a3c36780d01ed8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic1.zhimg.com/v2-c743342f25d5b270c1a3c36780d01ed8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c743342f25d5b270c1a3c36780d01ed8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;近期，在20世纪，我们会看到新一代的数学家们给出了新的研究成果。近期学者们提出了一个非常重要的研究成果，我认为每个人都应该学习这个成果，这个成果叫LLL算法、3L算法、或者叫L立方算法，是Lenstral、Lenstral和Louvasz提出的。&lt;/p&gt;&lt;p&gt;这是他们三个的照片。他们三个看起来开心点了。不知道大家看不看得出来，照片里好像挺冷的，但是他们还是挺开心。我也不知道他们谁是谁，但这确实是1982年的照片，照片中的三个人分别是两个Lenstras和Louvasz，他们在一起研究这个算法时拍摄的。&lt;/p&gt;&lt;p&gt;这个算法的结果非常令人惊异。如果你以前从来都不知道这个算法也没关系，明天每个人都会学习到这个算法。Vadim会为大家讲解这个算法。这个算法非常令人惊异。这个算法最开始用于寻找格中的近似最短向量，当然我们现在也会这么用，我们后面会看到近似最短向量是什么意思。本质上说，这个算法可以用来寻找离原点比较近的一个格向量。&lt;/p&gt;&lt;p&gt;但实际上，这个算法最初被用于在实数域分解多项式，以及在固定维度下解决整数规划问题，这是Lenstra在后面的论文中提出的。这个算法在整数分解问题上具有重要应用价值。什么叫在实数域分解多项式呢？就是把一个多项式分解为低阶的多项式，并且是在实数上进行分解。&lt;/p&gt;&lt;p&gt;另一个应用领域是下面这个，我们现在也可以在类似Maple的数学工具中做这样的运算。假设我们计算得到了一个数，经过了很长时间的计算，你最后得到了一个数：6.73205…你估计会觉得这可能是个很特殊的数，可能是某个数的平方根，或者是某个数的立方根。大家觉得呢？这个数是不是看起来挺熟悉的？实际上这是个非常简单的例子，大家可能知道结果是什么。这个数等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Csqrt%7B3%7D%2B5+&quot; alt=&quot;\sqrt{3}+5 &quot; eeimg=&quot;1&quot;/&gt; 。这是个非常简单的例子，我们可以使用LLL算法来实现这样的功能。实际上我们可以在任意数上做这样的操作。你只需要输入一个数，算法就会告诉你它可能是哪些数运算得来的。上周我就一直在做计算，并最后得到了一个非常复杂的数，但后来我发现这个数实际上等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Csqrt%7B5%7D%2B4+&quot; alt=&quot;\sqrt{5}+4 &quot; eeimg=&quot;1&quot;/&gt; ，结果挺让人开心的。这就是LLL算法的另一个重要应用。大家可能想知道这是怎么做到的，不过我们现在要看看其他的内容了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-86d433c493c9726c7017ef9810d90197_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic4.zhimg.com/v2-86d433c493c9726c7017ef9810d90197_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-86d433c493c9726c7017ef9810d90197_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic4.zhimg.com/v2-86d433c493c9726c7017ef9810d90197_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-86d433c493c9726c7017ef9810d90197_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;继续往下，这是一些历史知识。这是1982年的事情。最近，学者们意识到格在密码学中有重要的应用价值，这也是我们冬令营的主题。当开始讨论密码学时，大家时差综合症就要犯了，因为有点理论…&lt;/p&gt;&lt;p&gt;什么是密码学？密码学是一个很大的领域。我认为密码学对于电子商务很重要…密码学被用在生活中的方方面面，比如信用卡、护照、手机、互联网等等。密码学的重要程度不用我过多强调了吧？&lt;/p&gt;&lt;p&gt;绝大多数系统都是基于RSA密码学系统的。这是Rivest、Shamir、Adleman在1977年提出的，他们发明了这个密码学系统。我们一直还在使用这样的密码学系统。基于格的密码学系统从某方面讲，将成为密码学系统的另一种选择。我们将在接下来的4天时间里让大家了解到这一点。格密码学有成为另一种选择的潜力，也是一个好的备选方案，我们将在接下来的4天时间里为大家讲解这一观点，希望大家能认同这一观点。很显然，有很多理由支持我们转入基于格的密码学系统。这就是RSA密码学系统，我后面还会提到。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-54c17f89ac4ee9a1df78cf3b80531726_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic3.zhimg.com/v2-54c17f89ac4ee9a1df78cf3b80531726_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-54c17f89ac4ee9a1df78cf3b80531726_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic3.zhimg.com/v2-54c17f89ac4ee9a1df78cf3b80531726_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-54c17f89ac4ee9a1df78cf3b80531726_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果我没记错的话，密码学和格第一次牵手是在LLL算法提出没多久以后。人们想，我们现在有密码学算法了，也有LLL算法了，我们可以做一些很棒的事情，没准我们可以用LLL算法破解密码学方案，或者用于对密码学方案进行分析。实际上，即使现在，密码分析学也是LLL算法的一个重要应用领域。它可以作为一个密码分析学算法，用于破解密码学方案，给出方案应用方法的建议。举例来说，LLL算法可以破解基于背包问题的密码学系统。这是Lagarias和Odlyzko在1985年提出的。最近，LLL算法可以破解RSA的变种方案。Blömer做出了杰出的工作，还有Hastad和Coppersmith。如果你在特定的配置环境下使用RSA算法，则可证明应用LLL算法可以破解RSA。这是一个非常棒的研究成果。这个领域也有很多分支。我今天并不会过多讲解这方面的内容，估计在后面Vidim会讲解，这的确是一个很棒的成果。&lt;/p&gt;&lt;p&gt;在冬令营中我要讲解的内容更正能量一些，我们要讲解如何构造密码学方案，如何应用格来构造密码学方案。学者们在20世纪90年代中期意识到了这一点。1996年Ajtai首先进行了尝试，这个想法非常令人惊奇，是突破性的想法。这就是冬令营的主题，如何使用格代数结构，使用格计算问题构造密码学方案。如何构造公钥密码学方案，或者构造其他密码学函数，构造很多其它的密码学方案。这是1996年开创的领域，Ajtai首先进行了尝试。&lt;/p&gt;&lt;p&gt;为什么我们关心这个领域呢？为什么我们要用格来构造密码学方案呢？这是我在第一小时的简介中要为大家介绍的内容。事实证明，格密码学有很多整数分解或者离散对数等传统假设不具有的特性。&lt;/p&gt;&lt;p&gt;格的安全性更高。我们现在在考虑数学证明，但是首先我们要注意，我们不能证明所有的方案都是安全的，无法证明基于一系列NP问题构造的密码学方案就一定是安全的。但我们可以证明，这些密码学方案的安全性与其他一些问题是等价的，方案安全性与格的特定困难问题等价，而且我们相信这些困难问题确实很难。在后面几页幻灯片中我会讲到这一点。&lt;/p&gt;&lt;p&gt;另一个很棒的特性是，格密码学方案可以抵御量子计算机的攻击。现在可能绝大多数人已经知道，量子计算机可以解决整数分解问题，量子计算机可以解决离散对数问题，可以整数分解，量子计算机可以破解密码学方案。量子计算机还可以做很多其他的事情。我想说的是，其他可以抵御量子计算机攻击的候选算法中，格密码学可以排在很高的地位，可能可以排在最高的地位。这也是为什么我们要研究它的一个原因。我们现在还没有量子计算机，这仍然是未来才可能出现的东西，科学家们仍然在尝试构造量子计算机。但如果你想构造一个10年内安全的密码学方案，你应该需要开始担心量子计算机了。我们知道，我们可能在10至12年之内将得到量子计算机，所以我们需要担心这一点。对于我们现在发送的一些数据，我们至少需要在10年内保证加密的安全性，所以我们现在就应该开始担心量子计算机的诞生了。这很严峻，因为我们没有太多的备选密码学方案。如果你了解量子计算机的最新研究进展情况的话，你会知道我们没有太多的备选方案，但是我们又不得不依靠密码学来实现一些功能。我们需要使用密码学来在网上使用我们的信用卡，使用网上银行什么的，所以我们需要一些备选密码学方案。而格密码学是抵御量子计算机攻击的备选密码学方案。&lt;/p&gt;&lt;p&gt;我在后面会提到格密码学的另一个优点。在某些情况下，格密码学的运算速度比较快，并且格密码学可以提供更多的功能。这是近几年才提出的成果，我在后面几页幻灯片中会讲到。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0939b22c763e84fc6b1bdfcc8f965601_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-0939b22c763e84fc6b1bdfcc8f965601_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0939b22c763e84fc6b1bdfcc8f965601_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-0939b22c763e84fc6b1bdfcc8f965601_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0939b22c763e84fc6b1bdfcc8f965601_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们大致讲了讲为什么我们要研究格密码学。现在，我们尝试高屋建瓴地看看，如何使用格构造密码学方案。为什么格可以用来构造密码学方案？简单来说。假定我们有这样一个格、我们一般使用高维格，不是这种格。这是个2维格，我们一般使用更高维度的格，比如500维的格。基本思想是，如果我们随机选择一个格点，比如这个点，然后我进行扰乱，把点移动到这里。我选择了一个格点，把它往下移动了一些。现在，从计算角度很难得知这个点是否从这个格点移动来的，很难得知这个点是从哪个格点移动来的。在2维格中，这个问题看起来比较简单，但如果是500维格的话，我们可以沿着很多方向移动，向上、向下…在高维中我们可以有很多移动方向，这就是格问题困难度的来源。&lt;/p&gt;&lt;p&gt;实话实说，大家在后面的几个讲座中可能看不到这些困难问题，因为现在这些困难问题都被进一步封装，使得其可以更好地应用于密码学方案中，比如SIS问题、LWE问题。后面的几个讲座中大家可以学习到，实际构造时可能用不到这个问题，不过这是格密码学构造的基本思想。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-891307cf4f14c5b5b742cd74a70f2db9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-891307cf4f14c5b5b742cd74a70f2db9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-891307cf4f14c5b5b742cd74a70f2db9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-891307cf4f14c5b5b742cd74a70f2db9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-891307cf4f14c5b5b742cd74a70f2db9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们来更深入的讲一讲，格密码学有什么优点？我前面说到，第一个优点是可证明安全。现在，我们在构造密码学方案时一般会伴随一个特定的安全性证明。这个安全性证明指出，如果你能破解密码学方案，如果你能破解公钥加密的私钥，或者可以对单向函数求逆，即使破解的概率非常低，几乎可以忽略，也会发生很奇特的事情。如果能破解密码学方案，你也就可以解决格中的困难问题了。这非常好，这实际上告诉我们在构造密码学方案时，我们没有漏掉一些构造细节，我们没有留下安全缺口或者脆弱性漏洞。我们可以证明如果方案被破解了，就会发生奇特的事情，这非常好。在传统密码学中，我们不一定能得到安全性证明。有些时候我们能证明安全性，但是即使RSA系统，我们不知道是不是破解RSA一定意味着可以解决整数分解问题。有的密码学方案具备这样的特性，并不是所有的密码学方案都有这个特性。但在格密码学中，最近10年左右的方案构造都可以得到安全性证明。这就是第一个优点了。&lt;/p&gt;&lt;p&gt;格密码学与传统密码学的第二个对比点是，格密码学所得到的安全性更高。这一点我会在下一页幻灯片中详细讲解。这个优点非常好，叫做最糟糕困难安全性。这是格中所独有的优点，在其他代数结构中似乎都没有这个优点。这是个非常棒的优点，我会在下面两页幻灯片中详细讲解。这个优点的意思是，如果你可以破解密码学算法，那么你就可以解决最糟糕情况困难问题，你可以对任意格解决一个困难问题。在下一页幻灯片中我还会提到，传统密码学是没有这个特点的，传统密码学的安全性一般基于平均情况困难问题。下一页幻灯片中我会讲解这一特性的重要性。这是一个非常棒的优点，这也是为什么Ajtai在20世纪90年代中期的工作得到了这么广泛的关注。这是一个新的思想，是一个新的特性。这个特性很奇特。这个优点中可能包含一些我自己的主观判断，对我来说这是格密码学的一个优点。与整数分解相比，这是一个相对较新的困难问题。如果把数学家的工作考虑进来的话，这个困难问题已经有200年的历史了，但在计算机科学领域，这个困难问题只有30年的历史，是个新提出的困难问题。&lt;/p&gt;&lt;p&gt;另一个优点是格困难问题不能被量子算法解决。我们对这个困难问题很有信心，这确实是一个很困难的问题，我们可以基于它构造密码学方案。到现在为止，量子算法还不能解决这些困难问题。当然我不知道是不是一定不能解决，寻找解决格困难问题的量子算法是个很重要的公开问题。学者们已经寻找了15年，到现在为止还是没有能解决格困难问题。所以可能格问题确实很困难，可能即使在量子算法下，格问题仍然很困难。&lt;/p&gt;&lt;p&gt;我还要提到的一个优点是，如果使用基于整数分解的密码学系统，此类方案经常要进行乘法、指数运算，这类运算的计算开销对于笔记本来说并不大。但对于小型设备，比如智能卡，乘法和指数运算这类运算的计算开销就比较大了。对于格密码学来说，很棒的一个特性是，格密码学的计算开销很小，只是进行一系列加法运算。特别是最近几年，学者们提出了很多非常高效的格密码学方案。这实在是令人惊讶，不需要做太多运算，只是一系列加法运算就能实现密码学方案。所以即使从效率的角度考虑，格密码学也具有巨大的优势。&lt;/p&gt;&lt;p&gt;最后一个优点是我的同事Vadim、Chris和Craig发现的。我们可以用格实现其他令人惊讶的密码学功能，比如全同态加密。Craig会在周二和周三为大家讲解全同态加密。这是一个开创性的工作成果，我们可以用格实现传统密码学无法实现的全同态加密。此方案的设想是在20世纪90年代中期提出的，没人能想到这竟然可以实现，没人能想到我们可以利用格实现实现整数分解无法实现的一些密码学特性。以前学者们一直认为整数分解这类数论假设是最强的一类假设，但实际上格也可以实现很多功能。随着冬令营的进行，希望大家可以逐渐认同学习格密码学是很有价值的事情。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7941b17ed321da6c196094e4ce37139d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-7941b17ed321da6c196094e4ce37139d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7941b17ed321da6c196094e4ce37139d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-7941b17ed321da6c196094e4ce37139d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7941b17ed321da6c196094e4ce37139d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们来深入讲解一下这些特点。第一点是可证明安全性。正如我前面提到的，我们不能证明某些方案是绝对安全的，没人可以证明如果P等于NP，那么所有方案都可以被破解。那可证明安全又是什么呢？可证明安全将密码学构造与一些我们认为可信的结论联系在了一起。可证明安全是一种归约算法，它将密码学方案的安全性归约到一个困难问题上。这个困难问题不是一大早你拍脑袋想出来的，而是一个新的、已确定困难的问题。我们把一系列密码学函数归约到这类困难问题上，这就是安全证明。我们希望利用安全证明来讨论方案的安全性。我后面可能就会提到，在很多情况下，安全性证明很有用，它告诉我们应该如何使用一个密码学方案。我后面还会提到这一点，安全性证明会告诉我们不要做哪些蠢事，它告诉我们如果可以破解密码学方案，如果存在一个攻击者以某个小概率破解密码学方案，就会发生一些奇特的事情，也就是我们的困难问题不再困难了，整个假设都被破解了。不光是你构造的算法不再安全，所有依赖于这一困难问题的密码学构造都不安全了。这是个非常好的结论，我们总希望能得到这样的结论。我们并不是经常能得到这样的结论，但格密码学可以得到更强的安全性结论。&lt;/p&gt;&lt;p&gt;这是个非常好的特性，安全性证明会告诉我们所构造的方案没什么问题。如果你有一些疯狂的想法，想要去构造密码学方案，首先你需要得到安全性证明，能把所构造的方案与一个困难问题联系到一起，你就会知道你的想法是正确的。可能你忘记了加什么东西，因为不加或者不做某个运算，方案可能不安全，但是如果有安全证明的话，这种事情就不会发生。&lt;/p&gt;&lt;p&gt;我们在周二会看到一个例子，方案并没有安全性证明，人们认为这个方案是安全的。人们构造了一个密码学方案，很长一段时间人们都认为它没什么问题，但实际上这个方案并没有和某个已确定困难的问题联系到一起。随后人们发现这方案有问题。我们会在后面提到这样的例子。另一个很棒的地方是，我后面可能会提到，我估计Chris在今天他的讲座中也会提到，安全性证明可以告诉我们如何选择方案的参数。这也和下面的一个特性相关。你有了一个密码学方案，但里面涉及一些参数，比如某些特定的数要大于其他数。大多数情况下，你可能不知道如何选取这些参数。但如果有安全性证明的话，它就会告诉你，如果安全性证明能通过，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m%3En%5E2+&quot; alt=&quot;m&amp;gt;n^2 &quot; eeimg=&quot;1&quot;/&gt; ，所以你在使用方案的时候，会把 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选为大于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5E2&quot; alt=&quot;n^2&quot; eeimg=&quot;1&quot;/&gt; 的数，这样安全性证明才能过得去。&lt;/p&gt;&lt;p&gt;密码学历史中也发生过这样的事情，Chris可能也会提到。我们证明了一个方案是安全的，安全性证明告诉我们，一部分参数要大于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5E2+&quot; alt=&quot;n^2 &quot; eeimg=&quot;1&quot;/&gt; 。我们不知道为什么，但我们会说，用的时候就让这些参数大于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5E2&quot; alt=&quot;n^2&quot; eeimg=&quot;1&quot;/&gt; 吧。那个时候我们还不知道为什么。但是5年以后，学者们提出了另一个算法。这个算法指出，如果这些参数小于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5E2+&quot; alt=&quot;n^2 &quot; eeimg=&quot;1&quot;/&gt; ，我们可以在次指数时间内破解密码学方案。我估计Chris在今天他的讲座中也会提到这一点。大家可以看到安全性证明的威力了，它会告诉我们怎么做才是正确的，它会告诉我们是否走在了正确的道路上。&lt;/p&gt;&lt;p&gt;我来举个例子，来看看安全性证明大概是个什么样子。这也会涉及到下面一个优点，也就是最糟糕情况、平均情况困难性这个优点上。这是个很简单的例子，是一个基于模平方的单向函数，这只是给大家解释下基本思想。假设你希望构造这样一个单向函数，这个单向函数是将输入值求平方，输入值为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+&quot; alt=&quot;x &quot; eeimg=&quot;1&quot;/&gt; ，输出为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%5E2+&quot; alt=&quot;x^2 &quot; eeimg=&quot;1&quot;/&gt; ，我们就用它了。令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot; eeimg=&quot;1&quot;/&gt; 为两个大质数的乘积，我不知道如何选择参数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; ，后面几分钟我就会提到怎么选择参数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot; eeimg=&quot;1&quot;/&gt; 了。现在就选择某个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; ，这个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot; eeimg=&quot;1&quot;/&gt; 是两个大质数的乘积。现在考虑这个函数，求 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%5E2&quot; alt=&quot;x^2&quot; eeimg=&quot;1&quot;/&gt; 模 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;在习题中，我会让大家试着证明，如果想求这个函数的逆函数，也就是给定 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%5E2+&quot; alt=&quot;x^2 &quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; 是随机选取的，找到任意一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%27+&quot; alt=&quot;x&amp;#39; &quot; eeimg=&quot;1&quot;/&gt; ，使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%27%5E2%3Dx%5E2+&quot; alt=&quot;x&amp;#39;^2=x^2 &quot; eeimg=&quot;1&quot;/&gt; 。在习题中我们可以很容易证明，如果可以找到原像，你就可以分解整数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; 。这就是安全性证明的一个例子，它证明了如果你可以求逆函数，那么你就有更高的概率，可能有1%的概率，或者某个不能用代数式表示的概率下，你可以分解 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; 。如果你不知道如何证明，或者没见过这个单向函数，试着想一想，我们实际上就是在证明这个单向函数的安全性。我们现在有了安全性证明，这很好，它证明了这个单向函数的安全性与整数分解相关，这是个挺不错的单向函数。但是这引入了另一个问题，这个函数，这个安全性证明叫做平均情况困难证明，基于平均情况困难性。基于平均情况困难性的原因是，我们没告诉你怎么选择 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; 。你会问我如何选择 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; ，我会告诉你 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot; eeimg=&quot;1&quot;/&gt; 等于两个大质数的乘积，我们还需要知道其他一些限制条件吗？大质数本身是不是要满足一些性质？是不是有所谓好的质数和不好的质数？这好像不那么显然，可能没有什么直观的结论。这实际上是一个很严重的问题，一个大问题，这引发了下面的问题，也就是我们如何选择 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-195f7a2c1d8df019eef7856b8d9182a5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-195f7a2c1d8df019eef7856b8d9182a5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-195f7a2c1d8df019eef7856b8d9182a5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-195f7a2c1d8df019eef7856b8d9182a5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-195f7a2c1d8df019eef7856b8d9182a5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们在RSA下看看这个问题。你想用代码实现一个RSA，如何选择参数模 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot; eeimg=&quot;1&quot;/&gt; ？如果你上过这方面的课程，你会知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+N&quot; alt=&quot; N&quot; eeimg=&quot;1&quot;/&gt; 不能是个偶数，偶数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot; eeimg=&quot;1&quot;/&gt; 不是个好选择。所以你估计会选择两个大质数，然后把它们乘起来。教科书上一般就讲到这里，但有可能某些质数比其他质数好？大家觉得呢？你觉得什么质数算是个好质数？安全质数？还有什么答案吗？&lt;/p&gt;&lt;p&gt;这是个好问题，我们其实不知道这个问题的答案是什么。让我来告诉你历史上发生了什么事情。1978年，学者们开始研究整数分解算法了。那时候RSA出现了，人们意识到整数分解是一个重要问题，试着寻找整数分解算法。1978年，学者们发现存在一个高效的算法分解整数，前提是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p-1&quot; alt=&quot;p-1&quot; eeimg=&quot;1&quot;/&gt; 或者 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q-1&quot; alt=&quot;q-1&quot; eeimg=&quot;1&quot;/&gt; 的最大质因子要比较小。所以人们说，如果你让RSA抵御这类攻击的话，你需要选择 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p&quot; alt=&quot;p&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q+&quot; alt=&quot;q &quot; eeimg=&quot;1&quot;/&gt; ，使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p-1&quot; alt=&quot;p-1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q-1&quot; alt=&quot;q-1&quot; eeimg=&quot;1&quot;/&gt; 的最大质因子比较大，不能太小。于是在1978年，你在代码里面增加了一个检查机制，检查&lt;img src=&quot;https://www.zhihu.com/equation?tex=p&quot; alt=&quot;p&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q+&quot; alt=&quot;q &quot; eeimg=&quot;1&quot;/&gt;是不是满足条件。&lt;/p&gt;&lt;p&gt;接下来，1981年又出来另一篇论文，对于另一个特定情况又有了另一个算法， &lt;img src=&quot;https://www.zhihu.com/equation?tex=p%2B1&quot; alt=&quot;p+1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q%2B1&quot; alt=&quot;q+1&quot; eeimg=&quot;1&quot;/&gt; 需要有比较大的质因子。很好，你又增加了一行代码，保证&lt;img src=&quot;https://www.zhihu.com/equation?tex=p&quot; alt=&quot;p&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q+&quot; alt=&quot;q &quot; eeimg=&quot;1&quot;/&gt;也满足这样的条件。&lt;/p&gt;&lt;p&gt;又过了1年，又出来了一篇论文，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p-1&quot; alt=&quot;p-1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q-1&quot; alt=&quot;q-1&quot; eeimg=&quot;1&quot;/&gt; 的最大质因子是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p%27&quot; alt=&quot;p&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q%27+&quot; alt=&quot;q&amp;#39; &quot; eeimg=&quot;1&quot;/&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p%27-1&quot; alt=&quot;p&amp;#39;-1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q%27-1&quot; alt=&quot;q&amp;#39;-1&quot; eeimg=&quot;1&quot;/&gt; 也要有大的质因子。好的，你再检查下这个是否成立。&lt;/p&gt;&lt;p&gt;大家估计可以猜到接下来发生什么了吧？1984年，学者们发现如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p%2B1&quot; alt=&quot;p+1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q%2B1&quot; alt=&quot;q+1&quot; eeimg=&quot;1&quot;/&gt; 的最大质因子是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p%27&quot; alt=&quot;p&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q%27+&quot; alt=&quot;q&amp;#39; &quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p%27-1&quot; alt=&quot;p&amp;#39;-1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q%27-1&quot; alt=&quot;q&amp;#39;-1&quot; eeimg=&quot;1&quot;/&gt; 也需要有比较大的质因子。大家估计没听说过有这么个历程，原因是我们现在有了更高效的大整数分解算法。我们发现了数筛法，所以现在这4个要求已经没这么重要了，我们已经有了更高效的整数分解算法，对于所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N%3Dp%5Ccdot+q&quot; alt=&quot;N=p\cdot q&quot; eeimg=&quot;1&quot;/&gt; 的形式，上面这4个算法的效率和数筛法效率差不多。可能对于不同的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p%27&quot; alt=&quot;p&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q%27+&quot; alt=&quot;q&amp;#39; &quot; eeimg=&quot;1&quot;/&gt; ，整数分解的效率还是会有所不同，但是我想这不会意味着故事的结束。我不是一个数论专家，但我估计在接下来几年 学者们可能会提出更高效的算法。我相信我们要根据所提出的算法选择更为特殊的质数，这确实是一个问题。&lt;/p&gt;&lt;p&gt;为什么会有这样一个问题？问题出在安全性证明上面。安全证明称如果能破解RSA，并不意味着能分解所有的整数，只意味着能分解某个特定的整数，但不意味着能分解所有的整数，只能分解一个特定的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; ，不是所有的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; 。这就是所谓的平均情况困难性。所以如果你相信破解RSA或者破解其他基于整数分解问题的方案是困难的，你相信的是在平均情况下，整数分解是困难的。你需要相信的并不是所有整数分解都是困难的，只相信一部分整数分解是困难的。我们这里假设的是，可能有1%的数是容易分解的，这1%的RSA方案是可以破解的，但是在最糟糕情况下，整数分解还是困难的。所以可能我们对某些特定的数可以很快进行整数分解，但不是全部的数。这确实是一直困扰我们的一个问题。但格里面没有这样的问题，这是一个重要的核心优点，格困难问题是最糟糕情况困难问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe8a2f2b3ccd18255ed900abe919f0f5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-fe8a2f2b3ccd18255ed900abe919f0f5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe8a2f2b3ccd18255ed900abe919f0f5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-fe8a2f2b3ccd18255ed900abe919f0f5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-fe8a2f2b3ccd18255ed900abe919f0f5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们从密码学函数的角度再理解一下。如果你基于平均情况困难性进行安全性证明，你得到的是类似于这样的映射关系。你选择了这个参数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; ，右边你就得到了一个基于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot; eeimg=&quot;1&quot;/&gt; 的密码学函数。这有点像双射，有点像一对一映射。对于每个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; ，你都证明了存在一个相同的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot; eeimg=&quot;1&quot;/&gt; 所对应的密码学函数。如果密码学函数被破解了，你就能分解这个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; ，确实有点像一对一双射。如果你突然发现密码学方案被破解了，这就意味着1%的密码学方案也被破解了，你得到的只是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot; eeimg=&quot;1&quot;/&gt; 中1%的数可以被分解，不是能分解所有的数，只意味着能分解1%的数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cd023575d93ffe9142f02aa23246a519_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-cd023575d93ffe9142f02aa23246a519_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cd023575d93ffe9142f02aa23246a519_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic2.zhimg.com/v2-cd023575d93ffe9142f02aa23246a519_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-cd023575d93ffe9142f02aa23246a519_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;而在格中我们可以得到更好的结论，这就是所谓的最糟糕情况困难性。什么是最糟糕情况困难性？安全性归约，或者说安全证明更像是一个完全映射。在左边选择一个任意的格，把它映射到右边，它会映射到右边所有的密码学函数。这个映射关系非常令人惊讶。下一个讲座中 Vadim将为大家讲解这是如何做到的，很神奇。这就是最糟糕情况困难的主要思想。从某种程度上，你将任意一个格困难问题都映射到了密码学函数的整个空间里面。这非常令人惊奇，这也意味着，如果1%的密码学函数被破解了，则任意一个格问题实例都可以被解决。&lt;/p&gt;&lt;p&gt;从很多方面看，这都是一个很好的性质。首先，这使得安全性强度更高了，不光是安全性强度更高了，而且它也告诉我们，不需要担心如何选择参数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot; eeimg=&quot;1&quot;/&gt; 了，你不需要担心如何选择所涉及到的参数，只要按照某个分布选参数就可以了。安全证明会告诉你如何选取参数，你只要这么选就好了，不需要担心哪个是好的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; ，哪个是不好的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N+&quot; alt=&quot;N &quot; eeimg=&quot;1&quot;/&gt; ，安全性证明会告诉你如何正确选取参数的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-19a0edbeef9352596ec98b376587fc48_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2880&quot; data-original=&quot;https://pic1.zhimg.com/v2-19a0edbeef9352596ec98b376587fc48_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-19a0edbeef9352596ec98b376587fc48_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2880&quot; data-rawheight=&quot;1800&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2880&quot; data-original=&quot;https://pic1.zhimg.com/v2-19a0edbeef9352596ec98b376587fc48_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-19a0edbeef9352596ec98b376587fc48_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我这里要强调一下，这是格的简介讲座，这只是一个简单的介绍。在进入技术部分的讲解前，我们要再讲一讲历史。在最近15年中又发生了什么？正如我前面所说的，Ajtai和Ajtai-Dwork在1996年开创性地提出了格密码学。他们意识到我们可以做很多很棒的事情，我们可以使用格做很多很棒的事情。他们告诉我们如何实现单向函数，如何实现公钥密码学系统，但是他们只提出了一个概念指出这些是可以用格来实现的。他们也指出如何得到最糟糕情况安全性。但从性能方便考虑的话，他们构造的方案效率非常低。如果使用他们所提出的系统，密钥可能是GB级的，性能实在不太好，运算效率很低，很麻烦。我认为他们的构造更多地是从理论的角度考虑的。&lt;/p&gt;&lt;p&gt;但是，最近几年，格密码学有了翻天覆地的变化。现在我们已经得到了非常高效的格密码学方案，其效率甚至可以与RSA比拟。开始时方案看起来根本没法用，也没什么可扩展的能力，只能做公钥密码学系统，而且绝大多数公钥密码学系统的构造都很繁琐，仅获得选择明文安全性已经非常困难了，而且几乎没有任何可扩展性。随后Louis和Warick试着定义格密码学系统，延伸这个思想。最近几年，学者们集中研究格密码学的两个核心问题，这两个核心问题也是接下来两个讲座的主要内容。Vadim会讲到Short Integer Solution问题，Chris会讲到Learning With Errors问题。用这两个问题可以构造非常高效的密码学方案，非常高效的单向函数。而且这两个问题把格的一些内容抽象化了。当你设计格密码学系统的时候，你不需要去考虑最糟糕情况困难性的安全性证明，你只需要基于SIS、LWE这两个中间问题构造方案就可以了，有人已经帮你们把最困难的问题解决了，帮你们完成了最糟糕情况证明。你只需要选一个问题，用这个问题构造密码学系统就好了。当然这方面还有很多工作要做，但至少一部分工作已经完成了。这些将是后面两个讲座的主题。这就是近几年格密码学的研究主线。&lt;/p&gt;&lt;p&gt;同时，格密码学还有另一个研究主线。我想大家在周二的时候会学习到，Vadim会在周二的讲座中讲到，这个主线所构造的密码学方案非常高效。我不得不说，这类格密码学方案实在是太高效了，他们是基于特定格代数结构而构造的。这两个问题被称为Ring-LWE以及Ring-SIS。2002年Micciancio开创了这一领域。2006年Chris Peikert、Alon Rosen、Lyrubashevsky和Micciancio进行扩展，他们意识到如果不考虑一般格，只考虑循环格这种满足特定性质的格代数结构，就可以大幅度提高方案的效率，构造安全高效的密码学方案，而且所构造的密码学方案确实非常高效。我不会讲解太多这方面的内容，不过大家可以感受一下，密钥的长度是KB级的，而计算效率甚至可以和哈希函数的计算效率接近了。我想Vadim会在周二详细讲解这方面的内容。&lt;/p&gt;&lt;p&gt;这就是格的简介部分。在进入技术部分的讲解之前，大家准备好，很烧脑。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2020-01-01-100556866</guid>
<pubDate>Wed, 01 Jan 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>隐私毯子：置乱模型下的隐私放大效应和数值求和方法</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-11-24-93441185.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/93441185&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dc36d948fb147e7218dd778e9be5482b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;最近发现需要读的论文数量增加速度已经超过顶会召开的速度了。密码学技术、乃至数据安全技术的发展越来越快，不仅是理论深度的发展越发迅速，相应的应用论文也越来越多，追的是真累…这不，刚把CRYPTO 2019的两个论文简单了解了一下，CCS 2019又开完了。CCS 2019里面至少有5篇论文是我想去精读的，想粗读的论文更是多得没边。等CCS 2019相关视频放出后，我能把我觉得有兴趣的演讲视频听译出来，分享给知友们，共同学习、互相讨论嘛。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为知友们带来的视频是密码学顶级会议CRYPTO 2019上的演讲视频《The Privacy Blanket: Amplification and Summation in the Shuffle Model》。&lt;/p&gt;&lt;p&gt;隐私毯子（The Privacy Blanket）是差分隐私中的一个概念，通过弱化攻击者的模型，尝试应用本地差分隐私（Local Differential Privacy）的数据处理方式得到和中心化差分隐私（一般叫Differential Privacy in the Curator Model）准确性接近的效果。我个人认为这是一个很有研究价值的理论。隐私毯子也反映出了差分隐私的一个本质：增加噪声的目的就是为了涵盖临近数据集变化引发的结果变化，那只要本地模型引入了这样量级的噪声，是不是就意味着可以在本地模型获得和中心化模型相同的准确性呢？置乱模型（Shuffle Model）就是类似的思想：如果假定用户是匿名的，就可以降低本地模型中引入的噪声量，实现所谓的隐私放大效应（Privacy Amplification）。&lt;/p&gt;&lt;p&gt;相信置乱模型的提出会给差分隐私领域指出新的道路：通过弱化攻击者的模型，差分隐私的问询准确性可以进一步提高。期待后续顶级会议上新差分隐私模型的诞生。&lt;/p&gt;&lt;p&gt;《The Privacy Blanket: Amplification and Summation in the Shuffle Model》实际上有两个视频。一个视频是CRYPTO 2019上面的讲座，相对言简意赅一些。另一个视频是作者在西门子研究院的演讲视频，内容更长也更丰富。这次为知友们带来的是CRYPTO 2019上的版本。西门子研究院的版本正在听译中，敬请期待。&lt;/p&gt;&lt;p&gt;非常感谢文章和视频发出后 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/5052229236da8864427d3c5f379a222e&quot; data-hash=&quot;5052229236da8864427d3c5f379a222e&quot; data-hovercard=&quot;p$b$5052229236da8864427d3c5f379a222e&quot;&gt;@猫咪老师说不要啊&lt;/a&gt; 的指正，“Blanket”这个词的意思是“毯子”，不是“篮子”，之前的翻译有误。想了想，“毯子”确实也更形象一些，就像把某个人的隐私用毯子盖住一样。相关错误已经修改，视频已经重新压制并上传。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1903.02837.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;arxiv.org/pdf/1903.0283&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;7.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;视频链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DX7ndlY7NuEk%26t%3D436s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=X7ndlY7NuEk&amp;amp;t=436s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av76884048/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av76&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;884048/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/CRYPTO/CRYPTO%25202019/The%2520Privacy%2520Blanket%2520-%2520Amplification%2520and%2520Summation%2520in%2520the%2520Shuffle%2520model%2520of%2520differential%2520privacy&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/CRYPTO/CRYPTO%202019/The%20Privacy%20Blanket%20-%20Amplification%20and%20Summation%20in%20the%20Shuffle%20model%20of%20differential%20privacy&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1182033995126231040&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic4.zhimg.com/v2-4943de4442f23214347922e12048bd3f.jpg&quot; data-lens-id=&quot;1182033995126231040&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic4.zhimg.com/v2-4943de4442f23214347922e12048bd3f.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1182033995126231040&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c67f97d84ebc27e594188ddb667f0042_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-c67f97d84ebc27e594188ddb667f0042_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c67f97d84ebc27e594188ddb667f0042_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-c67f97d84ebc27e594188ddb667f0042_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c67f97d84ebc27e594188ddb667f0042_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我讲解的论文题目是：《隐私毯子：差分隐私置乱模型的隐私放大效应与求和方法》。在讲解我们的具体工作之前，我们需要首先介绍差分隐私和置乱模型。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-41ad7bbda5b3860bf3c1e2f65f887213_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-41ad7bbda5b3860bf3c1e2f65f887213_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-41ad7bbda5b3860bf3c1e2f65f887213_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-41ad7bbda5b3860bf3c1e2f65f887213_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-41ad7bbda5b3860bf3c1e2f65f887213_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在差分隐私中，我们有一个数据集，数据集中包含用户的数据。我们想对数据集进行数据分析。我们希望数据分析的输出结果不过多透露出数据集中某一个个体的数据。为了形式化描述这一点，想象我们有另一个不包含我，而是包含艾蒙信息的数据集。我们不希望攻击者能通过观察输出结果，知道是我、还是艾蒙包含在数据集中。也就是说，攻击者无法区分这两个数据集的输出结果。当然了，如果在可忽略的统计距离下定义统计安全性，则根据三角不等式，即使两个数据集中所有的数据都不相同，你也不能区分两个数据集的输出结果。这意味着输出结果无法告知你任何与数据相关的有用信息，这种隐私定义也就没什么意义了。因此，我们需要定义区分两个数据集输出结果的程度，不能让不可区分性过于严苛，而这个定义就是差分隐私。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bc1810db6a98a4f96e40f4aba85dc057_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-bc1810db6a98a4f96e40f4aba85dc057_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bc1810db6a98a4f96e40f4aba85dc057_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-bc1810db6a98a4f96e40f4aba85dc057_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bc1810db6a98a4f96e40f4aba85dc057_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;差分隐私的定义是什么呢？ 我们有数据集 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%27&quot; alt=&quot;x&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; ，两个数据集中只有一个数据项是不相同的。我们想讨论的是，数据分析过程给出某一输出结果的概率。大家可以把最后的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta&quot; alt=&quot;\delta&quot; eeimg=&quot;1&quot;/&gt; 看成是统计距离，即密码学安全常数定义下的小参数。如果认为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta%3D0+&quot; alt=&quot;\delta=0 &quot; eeimg=&quot;1&quot;/&gt; ，这个约束条件描述的是：数据集 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; 和观察数据集 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%27&quot; alt=&quot;x&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 下得到相同输出结果的似然比不超过 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e%5E%CE%B5&quot; alt=&quot;e^ε&quot; eeimg=&quot;1&quot;/&gt; 。换句话说，攻击者无法获得、或以非常高的置信率获得过多某个个体的信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-98024e6720f4e72bc6f37b9549df921c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-98024e6720f4e72bc6f37b9549df921c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-98024e6720f4e72bc6f37b9549df921c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-98024e6720f4e72bc6f37b9549df921c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-98024e6720f4e72bc6f37b9549df921c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何使用这一定义呢？最开始的时候，差分隐私是在可信模型下定义的。我们有一个可信第三方，所有人都将数据提供给这个可信第三方。可信第三方对数据进行统计，得到统计结果，并在结果上增加一些随机量，最后把结果发送给分析方，也就是发送给攻击者。我们希望分析方能从分析结果中得到一些有用的信息…数据的分析结果是可用的，但因为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BM%7D&quot; alt=&quot;\mathcal{M}&quot; eeimg=&quot;1&quot;/&gt; 满足差分隐私，分析结果不会过多透露个体信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3312b5060c08ba2d9e8cd31b059fc794_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-3312b5060c08ba2d9e8cd31b059fc794_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3312b5060c08ba2d9e8cd31b059fc794_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-3312b5060c08ba2d9e8cd31b059fc794_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3312b5060c08ba2d9e8cd31b059fc794_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;随后，人们又提出了差分隐私的本地模型。此模型下，我们不再拥有可信第三方了，每个个体都在本地对自己的数据进行随机化处理。每个个体都在自己的数据上执行本地随机算法 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathcal%7BR%7D&quot; alt=&quot;\mathcal{R}&quot; eeimg=&quot;1&quot;/&gt; ，发送给分析方的结果数据本身就已经满足差分隐私性了。很明显，这意味着个体无法告知分析方太多与自己数据相关的信息，每一个个体传输给分析方的信息量都是有限的。但如果收集到很多用户的信息，分析方仍然可以得到与群体相关的一些信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-08e637d10474dc89063568e776881f13_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-08e637d10474dc89063568e776881f13_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-08e637d10474dc89063568e776881f13_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-08e637d10474dc89063568e776881f13_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-08e637d10474dc89063568e776881f13_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里我们就需要进行权衡了。很明显，与可信模型相比，本地模型不存在过多的信任关系，但本地模型的数据分析输出结果可用性较低。在可信模型下，对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B0%2C1%5D&quot; alt=&quot;[0,1]&quot; eeimg=&quot;1&quot;/&gt; 下的实数值求和引入的随机量为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%281%29&quot; alt=&quot;O(1)&quot; eeimg=&quot;1&quot;/&gt; 。但在本地模型下，引入的随机量不可能低于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28%5Csqrt%7Bn%7D%29+&quot; alt=&quot;O(\sqrt{n}) &quot; eeimg=&quot;1&quot;/&gt; 。简单来说，这是因为每个各地都需要在输入中增加 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%281%29&quot; alt=&quot;O(1)&quot; eeimg=&quot;1&quot;/&gt; 的噪声，把这些噪声加在一起，噪声和的方差为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%29&quot; alt=&quot;O(n)&quot; eeimg=&quot;1&quot;/&gt; ，标准差为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28%5Csqrt%7Bn%7D%29&quot; alt=&quot;O(\sqrt{n})&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9cbe1051bc5d9b804e7c4354ed46425f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-9cbe1051bc5d9b804e7c4354ed46425f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9cbe1051bc5d9b804e7c4354ed46425f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-9cbe1051bc5d9b804e7c4354ed46425f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9cbe1051bc5d9b804e7c4354ed46425f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;置乱模型位于可信模型和本地模型之间。置乱模型的基本思想是，我们有一个可信第三方，但我们只相信这个可信第三方会诚实地置乱所有的输入。可信第三方会把所有的输入放到随机置换函数中，函数把输入随机置换位置后，可信第三方再将结果发送给分析方。&lt;/p&gt;&lt;p&gt;在实际中如何实现这一安全模型框架呢？我们不关注这个问题，在论文中我们也没有考虑这个问题。这里有一些实现的建议。可以通过MPC实现，可以让第三方直接实现，也可以用混合网络实现。如果可以构建匿名信道，则匿名信道天生就是实现随机置乱模型的一种方法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-620df04a8429f3eab6b346f1eb630d14_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-620df04a8429f3eab6b346f1eb630d14_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-620df04a8429f3eab6b346f1eb630d14_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-620df04a8429f3eab6b346f1eb630d14_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-620df04a8429f3eab6b346f1eb630d14_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们论文中的实际贡献是什么呢？到目前为止，我所介绍的都是其他学者的工作。我们考虑取值范围为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B0%2C1%5D&quot; alt=&quot;[0,1]&quot; eeimg=&quot;1&quot;/&gt; 的实数值求和问题。我们证明了，单消息置乱模型的可用性比本地模型更好，但单消息置乱模型的可用性不会比可信模型更好。我们还证明了一个新的置乱隐私放大效应。我们不是第一个证明置乱隐私放大效应的学者，但我们在特定的场景下，在之前结果的基础上证明出了新的结果。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0e3621df9c2955ff41b47efea2f19d00_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-0e3621df9c2955ff41b47efea2f19d00_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0e3621df9c2955ff41b47efea2f19d00_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-0e3621df9c2955ff41b47efea2f19d00_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-0e3621df9c2955ff41b47efea2f19d00_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;来看看 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个参与方下的求和问题。每个用户有一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B0%2C1%5D&quot; alt=&quot;[0,1]&quot; eeimg=&quot;1&quot;/&gt; 之间的实数，我们想计算所有实数的和。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3a906cd982027a1ae2c9c2fa7bc97087_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-3a906cd982027a1ae2c9c2fa7bc97087_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3a906cd982027a1ae2c9c2fa7bc97087_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-3a906cd982027a1ae2c9c2fa7bc97087_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3a906cd982027a1ae2c9c2fa7bc97087_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;与本地模型相比，Cheu等人之前的工作在置乱模型下对协议进行了些许优化，优化协议为单消息模型，但未能证明协议的噪声标准差已达到最优。然而，他们还证明出，如果每个用户可以上传 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28%5Csqrt%7Bn%7D%29&quot; alt=&quot;O(\sqrt{n})&quot; eeimg=&quot;1&quot;/&gt; 比特长的消息，或者说每个用户向置乱方发 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Csqrt%7Bn%7D&quot; alt=&quot;\sqrt{n}&quot; eeimg=&quot;1&quot;/&gt; 次消息，置乱方对消息进行置乱处理，则协议的噪声标准差和可信模型一样。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a2b80aae19727bf46ee8dc8992b8ff0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-a2b80aae19727bf46ee8dc8992b8ff0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a2b80aae19727bf46ee8dc8992b8ff0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-a2b80aae19727bf46ee8dc8992b8ff0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-a2b80aae19727bf46ee8dc8992b8ff0a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们考虑当用户只给置乱方发送一次消息时，协议究竟能优化到何种程度。在这种情况下，我们证明了，如果用户可以只发送一次 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clog%28n%29&quot; alt=&quot;\log(n)&quot; eeimg=&quot;1&quot;/&gt; 比特长的消息，则协议的噪声标准差可以达到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%5E%7B1%2F6%7D%29&quot; alt=&quot;O(n^{1/6})&quot; eeimg=&quot;1&quot;/&gt; ，即协议的噪声方差可以达到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%5E%7B1%2F3%7D%29&quot; alt=&quot;O(n^{1/3})&quot; eeimg=&quot;1&quot;/&gt; 。但这已经是最优结果了，我们不可能获得更小的噪声标准差了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-52b38eda7162131cf2bb3b86e9e7c7fe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-52b38eda7162131cf2bb3b86e9e7c7fe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-52b38eda7162131cf2bb3b86e9e7c7fe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-52b38eda7162131cf2bb3b86e9e7c7fe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-52b38eda7162131cf2bb3b86e9e7c7fe_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我接下来将为大家证明准确性上界。因为时间关系，我不会为大家证明准确性下界。但我会解释协议的工作原理，解释如何在单消息置乱模型下得到此种准确性结果。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-df80bfe2b8eaf250d1a08f103622d897_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-df80bfe2b8eaf250d1a08f103622d897_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-df80bfe2b8eaf250d1a08f103622d897_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-df80bfe2b8eaf250d1a08f103622d897_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-df80bfe2b8eaf250d1a08f103622d897_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是本地随机算法的执行过程。算法非常简单，此算法只需要做两件事情。&lt;/p&gt;&lt;p&gt;当获得真实输入后，我们将其转换为固定精度下的值。也就是说，我们在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 固定精度下对输入进行随机舍入处理。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a796bcf575e65f6f059bac5133251f95_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-a796bcf575e65f6f059bac5133251f95_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a796bcf575e65f6f059bac5133251f95_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-a796bcf575e65f6f059bac5133251f95_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a796bcf575e65f6f059bac5133251f95_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;随后，我们将执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 元随机答复协议。也就是说，每个用户随机抛掷一枚有偏的硬币。每个用户有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cgamma&quot; alt=&quot;\gamma&quot; eeimg=&quot;1&quot;/&gt; 的概率返回一个与输入独立、满足均匀随机分布的答复结果。每个用户有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1-%5Cgamma&quot; alt=&quot;1-\gamma&quot; eeimg=&quot;1&quot;/&gt; 的概率答复真实结果。&lt;/p&gt;&lt;p&gt;最后，分析方将调用deBias算法，使统计结果满足无偏性。这一步处理过程非常简单，只需要执行一次线性映射。这就是本地随机算法的执行过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-19499a0fec5cb3a8c719742f538119f5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-19499a0fec5cb3a8c719742f538119f5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-19499a0fec5cb3a8c719742f538119f5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-19499a0fec5cb3a8c719742f538119f5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-19499a0fec5cb3a8c719742f538119f5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为什么此算法可以实现我们给出的准确性要求呢？此算法包含两个噪声源。第一个噪声源是将输入随机舍入到固定精度时引入的噪声，此噪声的方差是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%2Fk%5E2%29+&quot; alt=&quot;O(n/k^2) &quot; eeimg=&quot;1&quot;/&gt; 。因为有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个参与方，所以有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%29&quot; alt=&quot;O(n)&quot; eeimg=&quot;1&quot;/&gt; 的噪声。而随机舍入又会引入方差为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%281%2Fk%5E2%29&quot; alt=&quot;O(1/k^2)&quot; eeimg=&quot;1&quot;/&gt; 的噪声。第二个噪声源是一部分用户会给出与输入完全独立、满足均匀随机分布的答复结果。一共有大约 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28%5Cgamma+n%29&quot; alt=&quot;O(\gamma n)&quot; eeimg=&quot;1&quot;/&gt; 用户会给出错误的答复，每个用户错误答复所引入的噪声量为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%281%29+&quot; alt=&quot;O(1) &quot; eeimg=&quot;1&quot;/&gt; 。因此这部分噪声源将引入方差为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28%5Cgamma+n%29&quot; alt=&quot;O(\gamma n)&quot; eeimg=&quot;1&quot;/&gt; 的噪声。&lt;/p&gt;&lt;p&gt;在接下来的几分钟我会为大家证明，我们需要将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cgamma&quot; alt=&quot;\gamma&quot; eeimg=&quot;1&quot;/&gt; 设置为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%2Fn&quot; alt=&quot;k/n&quot; eeimg=&quot;1&quot;/&gt; 乘以一个与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta&quot; alt=&quot;\delta&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon&quot; alt=&quot;\epsilon&quot; eeimg=&quot;1&quot;/&gt; 相关的函数。如果把系数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%2Fn&quot; alt=&quot;k/n&quot; eeimg=&quot;1&quot;/&gt; 带入到最上方的噪声量中，我们就会得到噪声方差为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%2Fk%5E2%29%2BO%28k%29&quot; alt=&quot;O(n/k^2)+O(k)&quot; eeimg=&quot;1&quot;/&gt; 。因此，我们希望 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 大致等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%5E%7B1%2F3%7D%29&quot; alt=&quot;O(n^{1/3})&quot; eeimg=&quot;1&quot;/&gt; 即可。如果令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%5E%7B1%2F3%7D%29&quot; alt=&quot;O(n^{1/3})&quot; eeimg=&quot;1&quot;/&gt; ，则噪声方差将变为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%5E%7B1%2F3%7D%29&quot; alt=&quot;O(n^{1/3})&quot; eeimg=&quot;1&quot;/&gt; 。因此，噪声标准差为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%5E%7B1%2F6%7D%29&quot; alt=&quot;O(n^{1/6})&quot; eeimg=&quot;1&quot;/&gt; 。这就是协议噪声标准差为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28n%5E%7B1%2F6%7D%29&quot; alt=&quot;O(n^{1/6})&quot; eeimg=&quot;1&quot;/&gt; 的原因。&lt;/p&gt;&lt;p&gt;为什么我们要让 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cgamma&quot; alt=&quot;\gamma&quot; eeimg=&quot;1&quot;/&gt; 等于这个值呢？为什么这么设置就够了呢？为了证明这一点，我们需要考察攻击者在此模型下可以得到哪些信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-102ee83e1d88b924ec5f4ea5921c9931_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-102ee83e1d88b924ec5f4ea5921c9931_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-102ee83e1d88b924ec5f4ea5921c9931_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-102ee83e1d88b924ec5f4ea5921c9931_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-102ee83e1d88b924ec5f4ea5921c9931_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是攻击者的视角。攻击者能得到信息可以等价为一张直方图。攻击者只能知道每一个输入值、或者说每一个原始值被上传了多少次。因此攻击者得到的是所有输入值的一张直方图。而攻击者知道，在得到这张直方图的过程中，有的用户在说谎，有的用户在说实话。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3b44fd9634c29d378c126eb4cfe820a7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-3b44fd9634c29d378c126eb4cfe820a7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3b44fd9634c29d378c126eb4cfe820a7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-3b44fd9634c29d378c126eb4cfe820a7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3b44fd9634c29d378c126eb4cfe820a7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们把给出随机答复的用户所形成的直方图看作绿色直方图，把给出真实答复的用户所形成的直方图看作红色直方图。攻击者明显不知道直方图中哪一部分是红色的、哪一部分是绿色的。但我们要告诉攻击者直方图中哪一部分是红色的、哪一部分是绿色的。我们要给攻击者一个礼物，告诉攻击者哪些用户给出的是真实答复。我们还假设攻击者知道除目标用户之外，所有用户的真实输入。这是差分隐私中的一个标准假设。我们希望攻击者在足够多的背景知识下，仍然无法得到某个个体的信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-18ef3feb37f294ff9189e2568392206e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-18ef3feb37f294ff9189e2568392206e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-18ef3feb37f294ff9189e2568392206e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-18ef3feb37f294ff9189e2568392206e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-18ef3feb37f294ff9189e2568392206e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有了这个礼物，攻击者可以从直方图中移除答复真实结果的用户。如果目标用户给出的是真实答复，留给攻击者的就是绿色的直方图加上他的数据项。如果目标用户在撒谎，他的答复就与真实数据相互独立，结果中不会泄露任何信息。因此，我们只需要担心当目标用户给出真实答复下的情况。&lt;/p&gt;&lt;p&gt;我们把绿色直方图称为隐私毯子。隐私毯子的基本思想是，目标用户的数据可以被其他用户的独立随机数据所覆盖。隐私毯子可以盖住目标用户的真实数据。攻击者需要有能力区分两种场景下的答复结果。他需要告诉我们，答复结果是额外增加一个0得到的，还是额外增加一个1得到的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b622ce1ffca40931aec411048a11e83c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-b622ce1ffca40931aec411048a11e83c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b622ce1ffca40931aec411048a11e83c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-b622ce1ffca40931aec411048a11e83c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b622ce1ffca40931aec411048a11e83c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们需要考察两个概率分布的似然比。正如我前面所提到的，差分隐私要求似然比不能大于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e%5E%CE%B5&quot; alt=&quot;e^ε&quot; eeimg=&quot;1&quot;/&gt; 。因此，我们只需要证明这两个直方图出现的似然比大于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e%5E%CE%B5&quot; alt=&quot;e^ε&quot; eeimg=&quot;1&quot;/&gt; 的概率最大为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta&quot; alt=&quot;\delta&quot; eeimg=&quot;1&quot;/&gt; 。为了证明这一点，我们需要计算似然比。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-25b9cab5692e34349801c556f65af43a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-25b9cab5692e34349801c556f65af43a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-25b9cab5692e34349801c556f65af43a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-25b9cab5692e34349801c556f65af43a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-25b9cab5692e34349801c556f65af43a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当你的答复是0时，似然比就等于0提交的个数除以1提交的个数。即似然比等于某个二项随机变量加1除以某个二项随机变量。我们要求两个随机变量的比值不大于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e%5E%CE%B5&quot; alt=&quot;e^ε&quot; eeimg=&quot;1&quot;/&gt; 。因为二项随机变量分布很集中于概率分布均值，因此只要均值足够大，两个随机变量的比值就不会大于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e%5E%CE%B5&quot; alt=&quot;e^ε&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;均值应该为多大呢？ 均值应该等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon&quot; alt=&quot;\epsilon&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta&quot; alt=&quot;\delta&quot; eeimg=&quot;1&quot;/&gt; 下的某个函数。如果想让均值等于某个常数，则可令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cgamma&quot; alt=&quot;\gamma&quot; eeimg=&quot;1&quot;/&gt; 等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%2Fn&quot; alt=&quot;k/n&quot; eeimg=&quot;1&quot;/&gt; 乘以某个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon&quot; alt=&quot;\epsilon&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta&quot; alt=&quot;\delta&quot; eeimg=&quot;1&quot;/&gt; 下的函数。如果你对差分隐私很熟悉，你可能就会对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=log%281%2F%5Cdelta%29%2F%5Cepsilon%5E2&quot; alt=&quot;log(1/\delta)/\epsilon^2&quot; eeimg=&quot;1&quot;/&gt; 这个参数很熟悉。这是在差分隐私中使用高斯机制时，所需要增加的噪声方差。这个结果应该并不令人惊讶，因为隐藏信息用的二项随机变量近似等于高斯随机变量。这就是为什么会出现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=log%281%2F%5Cdelta%29%2F%5Cepsilon%5E2&quot; alt=&quot;log(1/\delta)/\epsilon^2&quot; eeimg=&quot;1&quot;/&gt; 的原因。&lt;/p&gt;&lt;p&gt;这就是隐私性证明过程了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-88fcec9772205fe476a6993d2eac45a1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-88fcec9772205fe476a6993d2eac45a1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-88fcec9772205fe476a6993d2eac45a1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-88fcec9772205fe476a6993d2eac45a1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-88fcec9772205fe476a6993d2eac45a1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们再来看看隐私放大效应。我在前面已经证明我们可以用此协议实现实数求和。这里的问题是，我们是否可以把相应的结论扩展到其它统计函数上？Erlingsson等人最近证明出，如果你有一个满足一定条件的本地随机算法…假定本地模型下的差分隐私参数为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon_0&quot; alt=&quot;\epsilon_0&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon_0&quot; alt=&quot;\epsilon_0&quot; eeimg=&quot;1&quot;/&gt; 为一个常数，你就可以自动在置乱模型下满足差分隐私性，且对应的参数更优。你需要引入一个非0参数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta&quot; alt=&quot;\delta&quot; eeimg=&quot;1&quot;/&gt; ，但参数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon_0&quot; alt=&quot;\epsilon_0&quot; eeimg=&quot;1&quot;/&gt; 下会除以一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Csqrt%7Bn%7D&quot; alt=&quot;\sqrt{n}&quot; eeimg=&quot;1&quot;/&gt; 。也就是说，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 很大，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon&quot; alt=&quot;\epsilon&quot; eeimg=&quot;1&quot;/&gt; 会降低很多。&lt;/p&gt;&lt;p&gt;这是一个很有用的结论。虽然我们希望获得较好的隐私性保证，但在很多场景下，我们不希望太好的隐私性保证。我们希望的是合理隐私性保证和高可用性。&lt;/p&gt;&lt;p&gt;我们扩展了Erlingsson的结论，可以让本地模型下的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon_0&quot; alt=&quot;\epsilon_0&quot; eeimg=&quot;1&quot;/&gt; 设置得更大。大家可以观察右侧的等式。 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon&quot; alt=&quot;\epsilon&quot; eeimg=&quot;1&quot;/&gt; 的表达式中包含了一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e%5E%7B%5Cepsilon_0%7D&quot; alt=&quot;e^{\epsilon_0}&quot; eeimg=&quot;1&quot;/&gt; ，这个参数会随着 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon_0&quot; alt=&quot;\epsilon_0&quot; eeimg=&quot;1&quot;/&gt; 的增大而快速增大。这里的关键点是，你可以令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon_0&quot; alt=&quot;\epsilon_0&quot; eeimg=&quot;1&quot;/&gt; 等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28log%28n%29%29&quot; alt=&quot;O(log(n))&quot; eeimg=&quot;1&quot;/&gt; 但仍然能获得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon%3D1&quot; alt=&quot;\epsilon=1&quot; eeimg=&quot;1&quot;/&gt; 的差分隐私性保证。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b7fcb13156a98f9d44d6698e9077e319_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b7fcb13156a98f9d44d6698e9077e319_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b7fcb13156a98f9d44d6698e9077e319_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b7fcb13156a98f9d44d6698e9077e319_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b7fcb13156a98f9d44d6698e9077e319_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上，即使我们令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon_0%3D1%2F2&quot; alt=&quot;\epsilon_0=1/2&quot; eeimg=&quot;1&quot;/&gt; ，令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%CE%B4%3D10%5E%7B-6%7D&quot; alt=&quot;δ=10^{-6}&quot; eeimg=&quot;1&quot;/&gt; ，这个图也告诉我们，我们结果中的隐私放大效应常数要比Erlingsson等人的结果更好，这是因为我们的攻击方法比他们的攻击方法更加直接。&lt;/p&gt;&lt;p&gt;我必须要说明的是，从系统和应用层面看，他们的结论要比我们的结论更通用。他们的模型和我们的模型有所不同。因此，不能说我们得到了更强的结果。&lt;/p&gt;&lt;p&gt;你可能会问一个问题，如果我们应用置乱隐私放大效应，是不是意味着我们可以寻找一个可以在本地模型下实现差分隐私的本地随机算法，然后直接在这上面应用置乱隐私放大效应？可以说对，也可以说不对。如果在本地模型下应用我这里给大家介绍的置乱模型下的随机算法，则当随机算法的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cepsilon&quot; alt=&quot;\epsilon&quot; eeimg=&quot;1&quot;/&gt; 参数设置得很大，例如设置为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28log%28n%29%29&quot; alt=&quot;O(log(n))&quot; eeimg=&quot;1&quot;/&gt; 时，直接应用置乱隐私放大效应，就可以得到我前面给出的隐私放大效应结果了。然而，如果你随便选择了一个本地模型下的本地随机算法，例如随便一个输入范围是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B0%2C1%5D&quot; alt=&quot;[0,1]&quot; eeimg=&quot;1&quot;/&gt; 的随机算法，比如简单随机答复，或者直接在结果上增加Laplace噪声，则置乱隐私放大效应的结果并不会太理想。隐私放大效应的系数可能只能到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Csqrt%7Bn%7D&quot; alt=&quot;\sqrt{n}&quot; eeimg=&quot;1&quot;/&gt; ，甚至只能到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clog%28n%29&quot; alt=&quot;\log(n)&quot; eeimg=&quot;1&quot;/&gt; 。因此，你需要适当选择本地随机算法，使其在置乱模型下可以得到最优的准确性，而不是选择一个在本地模型下最优的本地随机算法，再直接应用置乱隐私放大效应。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-14ffade5fb5c3641a2926ca9470d1c94_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-14ffade5fb5c3641a2926ca9470d1c94_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-14ffade5fb5c3641a2926ca9470d1c94_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-14ffade5fb5c3641a2926ca9470d1c94_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-14ffade5fb5c3641a2926ca9470d1c94_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里还有另一个问题。我之前提到，我们的协议是在单消息模型下构建的，多消息模型下会得到什么结果呢？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-64cdc8b4f79f07a91e152b2981f0c03c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-64cdc8b4f79f07a91e152b2981f0c03c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-64cdc8b4f79f07a91e152b2981f0c03c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-64cdc8b4f79f07a91e152b2981f0c03c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-64cdc8b4f79f07a91e152b2981f0c03c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Chou等人证明，如果发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28%5Csqrt%7Bn%7D%29&quot; alt=&quot;O(\sqrt{n})&quot; eeimg=&quot;1&quot;/&gt; 个单比特消息，就可以进一步提高准确性。置乱模型下的准确性结果可以和可信模型几乎完全相同。在提交此论文后，我们最近在Arxiv上在线提交了一个笔记，答案是一样的，的确可以做得更好。那篇笔记并没有涉及太多新的研究成果。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d1e681a17ac7822d68e370ab4669f692_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-d1e681a17ac7822d68e370ab4669f692_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d1e681a17ac7822d68e370ab4669f692_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-d1e681a17ac7822d68e370ab4669f692_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d1e681a17ac7822d68e370ab4669f692_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们证明，可以让通信量降低到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28log%28n%29%29&quot; alt=&quot;O(log(n))&quot; eeimg=&quot;1&quot;/&gt;，但是每个消息的长度也为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28log%28n%29%29&quot; alt=&quot;O(log(n))&quot; eeimg=&quot;1&quot;/&gt; 即发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28log%28n%29%29&quot; alt=&quot;O(log(n))&quot; eeimg=&quot;1&quot;/&gt; 个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28log%28n%29%29&quot; alt=&quot;O(log(n))&quot; eeimg=&quot;1&quot;/&gt; 比特长的消息，而不是发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28%5Csqrt%7Bn%7D%29&quot; alt=&quot;O(\sqrt{n})&quot; eeimg=&quot;1&quot;/&gt; 个单比特长的消息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dd28656abdae85f6202417fe0a83caec_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-dd28656abdae85f6202417fe0a83caec_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dd28656abdae85f6202417fe0a83caec_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-dd28656abdae85f6202417fe0a83caec_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dd28656abdae85f6202417fe0a83caec_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如何做到的呢？协议的基本思想可以追溯到Ishai等人在2006年发表的论文。那篇论文称，如果你有一个匿名通信信道，你就可以在统计安全下实现安全求和功能。我们可以在输入上加入随机噪声，每个参与方都可以在输入上加入随机噪声。随后，应用Ishai等人的协议，通过发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28log%28n%29%29&quot; alt=&quot;O(log(n))&quot; eeimg=&quot;1&quot;/&gt; 个消息实现隐私求和。如果你可以接受发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28log%28n%29%29&quot; alt=&quot;O(log(n))&quot; eeimg=&quot;1&quot;/&gt; 次消息，你就可以得到与可信模型相同的准确性结果。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f721c5ff2a3c8b3186516949678ca1bd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-f721c5ff2a3c8b3186516949678ca1bd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f721c5ff2a3c8b3186516949678ca1bd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-f721c5ff2a3c8b3186516949678ca1bd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f721c5ff2a3c8b3186516949678ca1bd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;还剩下哪些公开问题呢？ 我前面讲到，发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28log%28n%29%29&quot; alt=&quot;O(log(n))&quot; eeimg=&quot;1&quot;/&gt; 个消息足以得到与可信模型相同的准确性结果，单消息模型做不到那么高的准确性。你可能会问，如果是双消息呢？三消息呢？ &lt;img src=&quot;https://www.zhihu.com/equation?tex=log%28log%28n%29%29&quot; alt=&quot;log(log(n))&quot; eeimg=&quot;1&quot;/&gt; 消息呢？我们正在考虑这个问题，但到目前为止我们还不确定结果是什么。&lt;/p&gt;&lt;p&gt;我们还应该考察除求和以外的其它统计方法。这个模型的基本思想是，只要我们有一个置乱、或者说匿名通信信道，我们就可以利用这个信道计算得到很多统计结果。只需要一次性实现这个匿名通信信道，我们就可以非常高效地计算很多不同的统计结果。只有当可以利用这个模型计算很多不同的统计结果时，我们才能说这个模型是有用的。因此，如果想说明这个模型是有用的，我们需要在此模型下构建其它统计计算方法。&lt;/p&gt;&lt;p&gt;我们还需要解释如何实现置乱模型。已经有相关的学者尝试在可信硬件下实现置乱模型了。在差分隐私置乱模型出现之前，就已经出现了相关的工作。原因是，直观上看，在查看数据之前先置乱数据应该可以提高隐私性。我们或许可以使用MPC、混合网络、或者通过其它方法实现置乱模型。我们需查看不同的实现方法，寻找最容易、最轻量级的实现方法来构建置乱模型。&lt;/p&gt;&lt;p&gt;另一个问题是，置乱模型包含了一个可信假设。在证明过程中，大家可能已经注意到，我假设每个用户都会严格遵循协议要求执行协议。我们不需要假设每个用户都严格按照要求执行协议，只要有一定比例的用户会按照要求执行协议，这个协议就能保证隐私性。但我们需要让足够多的用户按照要求执行协议，只要足够多的用户随机答复，攻击者就无法知道目标用户的回复结果是什么了。因此，这些用户的安全假设并非是半可信的，他们必须是可信的。这样我们才能得到足够大的隐私毯子，从而隐藏目标用户的回复结果。你可能会想到，或许基于MPC的置乱协议可以帮助验证噪声是否已经正确添加。噪声添加过程、或者随机答复过程也可以在MPC中进行，以保证噪声被正确添加，这样就可以让这些用户的安全假设从可信退化到半可信。如果上述问题都能实现，假设就都可以成立，整个系统就满足置乱模型了。如果我们能移除可信假设，协议会变得更好。不过，置乱模型可能也不是最优的，可能可以有更好、更容易实现的模型，可以支持更多的统计计算。因此，另一个问题是，是否还存在其它的模型，可以进一步优化统计计算的准确性？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-643e8ae804cd23f2f2bd9a332df977ed_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-643e8ae804cd23f2f2bd9a332df977ed_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-643e8ae804cd23f2f2bd9a332df977ed_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-643e8ae804cd23f2f2bd9a332df977ed_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-643e8ae804cd23f2f2bd9a332df977ed_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这就是我的讲座内容，谢谢大家。&lt;/p&gt;&lt;p&gt;主持人：感谢James的精彩讲座，大家有什么问题吗？&lt;/p&gt;&lt;p&gt;主持人：如果没有其它问题，那就让我们再次感谢James，以及感谢本分会场所有的演讲者。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-11-24-93441185</guid>
<pubDate>Sun, 24 Nov 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>高效批处理不经意伪随机数生成器及其在隐私集合求交中的应用</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-07-85422763.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/85422763&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6ee6f7a27953600edc94f1cc797f68fc_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;随着涉及领域的不断增多，想听译的视频、想读的论文也变得越来越多。不过，这也意味着各个知识点之间变得更松散了。还是要抽出时间批量阅读一些论文，学习一些技术。&lt;/p&gt;&lt;p&gt;格密码学的视频还在整理当中。回看这些视频，不由得惊叹：当时自己哪里来的那么多时间把视频都听译完的。还是那句话：积少成多，我也在重新整理之前发布过的演讲视频相关专栏文章。部分有缺陷的文章和视频也重新进行了整理和发布。感兴趣的知友们可以翻看一下我之前发布的文章，会有一些新的变化。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为知友们带来的视频是信息安全顶级会议CCS 2016上的演讲视频《Efficient Batched Oblivious PRF with Applications to Private Set Intersection》。隐私集合求交（Private Set Intersection，PSI）愈发得到了学术界和企业界的关注。&lt;/p&gt;&lt;p&gt;近期，各个顶级会议上也推出了一系列高效PSI的构造与实现。自从Pinkas等人在2015年将不经意传输（Oblivious Transfer，OT）引入到PSI以来，PSI的效率已经从百万集合分钟级执行效率降低到百万集合秒级执行效率。这是一个相当巨大的飞跃。随着人们对隐私保护的愈发关注，相信以PSI为代表的安全多方计算（Secure Multi-Party Computation，SMPC）技术，以及以Intel SGX为代表的可信执行环境（Trusted Execution Environment，TEE）技术会逐步从理论走向落地、从落地走向大规模落地。期待未来能出现里程碑级别的应用杀手锏。&lt;/p&gt;&lt;p&gt;CCS 2016上的这篇文章可以说是非常有代表性的PSI方案构造。方案综合使用了不经意传输、不经意传输扩展（Oblivious Transfer Extension，OTE）、Cuckoo哈希、不经意伪随机数生成器（Oblivious Pseudo-Random Generator），同时还引入了编码理论相关的知识，可以说是多种密码学技术和安全多方计算技术的集合体。对此领域感兴趣的知友们可以认真阅读论文和开源代码，相信会有很大的收获。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//eprint.iacr.org/2016/799.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2016/79&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;9.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;视频链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3Di0kGwz_52Wg%26t%3D394s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=i0kGwz_52Wg&amp;amp;t=394s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av70403972/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av70&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;403972/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/CCS/CCS%25202016&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/CCS/CCS%202016&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1164465814702125056&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic1.zhimg.com/v2-4e1b18cf2e0de9c258e6c1bff0610dc3.png&quot; data-lens-id=&quot;1164465814702125056&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic1.zhimg.com/v2-4e1b18cf2e0de9c258e6c1bff0610dc3.png&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1164465814702125056&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d859be1f0e2ebcb58f9918a7fa96b25_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d859be1f0e2ebcb58f9918a7fa96b25_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d859be1f0e2ebcb58f9918a7fa96b25_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d859be1f0e2ebcb58f9918a7fa96b25_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5d859be1f0e2ebcb58f9918a7fa96b25_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家好，感谢Stefan的介绍。我的名字是Ni，我是俄勒冈州立大学的博士研究生，很高兴能来到这里介绍我们的工作。我们的论文题目是：高效批处理不经意伪随机函数及其在隐私集合求交中的应用。此工作是由我和Kalashnikov、Kumaresan、以及Rosulek共同完成的。在论文中，我们提出了一个高效的隐私集合求交协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7eebe69afe5d0c3ff4d6471caf08b0c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-7eebe69afe5d0c3ff4d6471caf08b0c0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7eebe69afe5d0c3ff4d6471caf08b0c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-7eebe69afe5d0c3ff4d6471caf08b0c0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7eebe69afe5d0c3ff4d6471caf08b0c0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;隐私集合求交是密码学中一个非常有趣的问题。我们以一个简单的场景为例，来看看什么是隐私集合求交。例如，幻灯片上有两个参与方：Alice和Bob。每个参与方都有一个集合，这里分别是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Y&quot; alt=&quot;Y&quot; eeimg=&quot;1&quot;/&gt; 。他们想计算两个集合的交集，但不想泄露其它额外的信息。例如，Alice不能知道Bob集合中非交集的元素。Bob也是类似的，他不能知道Alice集合中非交集的元素。这就是隐私集合求交问题的定义。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d15212522ca8ec5c0aaa2d4fe298528_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d15212522ca8ec5c0aaa2d4fe298528_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d15212522ca8ec5c0aaa2d4fe298528_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d15212522ca8ec5c0aaa2d4fe298528_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9d15212522ca8ec5c0aaa2d4fe298528_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;隐私集合求交的应用场景非常广泛，我这里给出的例子是通讯录匹配场景。例如，Alice有一个手机，里面存储着Alice的通讯录，Alice想要使用Skype。另一边，Bob是一个Skype服务器，里面存储着客户数据。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ef5dc61cf3ade5c6c49a9ae4d0144f55_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-ef5dc61cf3ade5c6c49a9ae4d0144f55_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ef5dc61cf3ade5c6c49a9ae4d0144f55_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-ef5dc61cf3ade5c6c49a9ae4d0144f55_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ef5dc61cf3ade5c6c49a9ae4d0144f55_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，Alice希望知道她的哪些朋友使用Skype，她希望使用Skype与朋友们聊天。很明显，两方希望计算集合的交集。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-884fb36ab797ff0ddf8a0216ff469452_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-884fb36ab797ff0ddf8a0216ff469452_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-884fb36ab797ff0ddf8a0216ff469452_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-884fb36ab797ff0ddf8a0216ff469452_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-884fb36ab797ff0ddf8a0216ff469452_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，Alice不想泄露自己的通讯录，因为这是她的个人信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b35f802fdcada72044a5ba9394c6cb18_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-b35f802fdcada72044a5ba9394c6cb18_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b35f802fdcada72044a5ba9394c6cb18_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-b35f802fdcada72044a5ba9394c6cb18_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b35f802fdcada72044a5ba9394c6cb18_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Bob也面临类似的问题，他不能泄露自己的客户数据，因为这是客户的隐私。这个场景就需要使用隐私集合求交功能。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-132e3934fc9a4fd347de93151b4a3330_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-132e3934fc9a4fd347de93151b4a3330_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-132e3934fc9a4fd347de93151b4a3330_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-132e3934fc9a4fd347de93151b4a3330_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-132e3934fc9a4fd347de93151b4a3330_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当考虑隐私集合求交这个问题时，我们可能会提出下述解决方案。Alice拥有集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;/&gt; ，Bob拥有集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Y&quot; alt=&quot;Y&quot; eeimg=&quot;1&quot;/&gt; 。他们分别对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;/&gt; 中的元素求哈希，对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Y&quot; alt=&quot;Y&quot; eeimg=&quot;1&quot;/&gt; 中的元素求哈希。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-054d6359e8ed91c3cbfb8e1d7279cbe5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-054d6359e8ed91c3cbfb8e1d7279cbe5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-054d6359e8ed91c3cbfb8e1d7279cbe5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-054d6359e8ed91c3cbfb8e1d7279cbe5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-054d6359e8ed91c3cbfb8e1d7279cbe5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Bob随后将哈希值发送给Alice。Alice对比两个集合的哈希值，并输出哈希值相等的元素，即交集元素。&lt;/p&gt;&lt;p&gt;这个协议效率非常高，因为协议只涉及到哈希值的计算。协议涉及的通信量也很小。但不幸的是，这个方案是不安全的，因为这个方案会泄露Bob输入集合的隐私。为什么呢？如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;/&gt; 属于比较小的域，例如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;/&gt; 为电话号码，只包含大约10个数字，Alice直接计算上亿个电话号码的哈希值，并将结果与从Bob收到的结果对比。这样，Alice就可以知道Bob的输入了。这也是此协议被称为朴素哈希的根本原因。因此，这是一个不安全的PSI协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-16391b0398831c1e9a90ed605050a8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-16391b0398831c1e9a90ed605050a8c3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-16391b0398831c1e9a90ed605050a8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-16391b0398831c1e9a90ed605050a8c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-16391b0398831c1e9a90ed605050a8c3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为了解决这个问题，学者们提出了很多PSI协议。当前最先进的PSI协议由Pinkas、Schneider、Segev和Zohner在2015年提出。隐私集合求交场景下的特殊情况为隐私相等性检测，即两个参与方希望知道两个字符串是否相等。他们的PSI协议通过不经意传输扩展实现隐私相等检测。他们还提出了一个高效的哈希技术，可以将隐私相等检测高效转换为隐私集合求交。我们的核心技术贡献是提高隐私相等检测的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-aa5a1449ce3467a041d368acd50e9c49_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-aa5a1449ce3467a041d368acd50e9c49_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-aa5a1449ce3467a041d368acd50e9c49_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-aa5a1449ce3467a041d368acd50e9c49_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-aa5a1449ce3467a041d368acd50e9c49_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们来看看Pinkas、Schneider、Segev、Zohner提出的隐私相等检测协议。Alice拥有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; ，而Bob拥有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 。我们想知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%3Dy&quot; alt=&quot;x=y&quot; eeimg=&quot;1&quot;/&gt; 是否成立。幻灯片上给出了一个例子： &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%3D001&quot; alt=&quot;x=001&quot; eeimg=&quot;1&quot;/&gt; 、 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y%3D011&quot; alt=&quot;y=011&quot; eeimg=&quot;1&quot;/&gt; 。他们协议的核心思想是对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 进行逐比特对比。如何做到这一点呢？他们使用了一个安全的黑盒工具，此工具叫不经意传输。&lt;/p&gt;&lt;p&gt;Bob分别为0和1随机采样两个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 比特长的字符串。随后，Bob和Alice执行不经意传输协议，Alice的输入是她的第一个比特0。协议执行完毕后，Alice收到她第一个比特0所对应的字符串0。然而，Bob无法得知Alice在不经意传输中的输入是什么，此性质由不经意传输协议的定义所保证。他们继续对第二个比特、第三个比特执行此种操作。现在，Bob从OT协议中取得自己输入所对应的字符串。他的输入比特是011，因此他分别取得0、1、1所对应的三个字符串。他对几个字符串求异或，将结果发送给Alice。Alice也取得OT执行完毕后的结果，即0、0、1所对应的三个字符串。她对几个字符串求异或，并对比Bob发送过来的异或值。这样Alice就知道双方的输入是否相等了。这就是当前PSI协议的隐私相等检测过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7b339bebaaeb8e456baadc73602ef4e8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-7b339bebaaeb8e456baadc73602ef4e8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7b339bebaaeb8e456baadc73602ef4e8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-7b339bebaaeb8e456baadc73602ef4e8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7b339bebaaeb8e456baadc73602ef4e8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;协议执行过程中，双方逐比特对比 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; ，而协议的基本思想是将多个2选1-OT协议替换为一个N选1-OT协议。当前PSI协议使用了Kolesnikov和Kumaresan于2013年提出的OT扩展协议，这意味着每轮协议只能同时对比8比特长的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; ，我后面会讲解为什么会这样。因此，他们的PSI协议中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=N%3D2%5E8&quot; alt=&quot;N=2^8&quot; eeimg=&quot;1&quot;/&gt; 。这意味着他们协议的OT执行次数依赖于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 的比特长度。他们的协议还需要通过多个OT实现完整的隐私相等检测。&lt;/p&gt;&lt;p&gt;在我们的工作中，我们提出了一个OT扩展协议。此协议中的N可以任意大。在我们的协议中，N可以为无穷大。这样，我们只需要使用一次OT即可实现隐私相等检测过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-da5afbfee11f260056f6d6a2bd798d34_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-da5afbfee11f260056f6d6a2bd798d34_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-da5afbfee11f260056f6d6a2bd798d34_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-da5afbfee11f260056f6d6a2bd798d34_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-da5afbfee11f260056f6d6a2bd798d34_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是当前PSI协议的另一个观察结论。我们将此协议看成一个黑盒。如果Alice的输入是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; ，而Bob的输入是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; ，这里 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 包含右侧的6个数据块，在PSI协议执行完毕后，Alice收到字符串0、0、1的异或值，我们可以将此异或值看成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_k%28x%29&quot; alt=&quot;F_k(x)&quot; eeimg=&quot;1&quot;/&gt; 。这意味着协议执行完毕后，Alice只能知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; 所对应的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_k%28x%29&quot; alt=&quot;F_k(x)&quot; eeimg=&quot;1&quot;/&gt; 。而Bob已知全部的6个数据块，因此Bob可以对任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 计算得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_k%28y%29&quot; alt=&quot;F_k(y)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;这里一个非常重要的性质是，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%5Cneq+y&quot; alt=&quot;x\neq y&quot; eeimg=&quot;1&quot;/&gt; ，则对Alice来说 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_k%28y%29&quot; alt=&quot;F_k(y)&quot; eeimg=&quot;1&quot;/&gt; 看起来是个随机数。这么看来，此协议本质上就是一个不经意伪随机函数。不经意伪随机函数是Freedman、Ishai、Pinkas和Reingold在2005年提出的概念。进一步，如果Bob将异或值，也就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_k%28y%29&quot; alt=&quot;F_k(y)&quot; eeimg=&quot;1&quot;/&gt; 发送给Alice，则Alice可以简单地比较 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_k%28x%29&quot; alt=&quot;F_k(x)&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_k%28y%29&quot; alt=&quot;F_k(y)&quot; eeimg=&quot;1&quot;/&gt; ，得知这两个值是否相等。这就是隐私相等检测协议的原理。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f604659c9460d5a42b22b477ca4868f0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-f604659c9460d5a42b22b477ca4868f0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f604659c9460d5a42b22b477ca4868f0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-f604659c9460d5a42b22b477ca4868f0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f604659c9460d5a42b22b477ca4868f0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在接下来的讲座中，我会聚焦于OT扩展协议本身。我们将首先介绍原始的2选1-OT扩展协议，再介绍N选1-OT扩展协议，最后介绍我们构造出的∞选1-OT扩展协议。随后，我们会介绍∞选1-OT扩展协议和我们提出的OPRF实例之间的关系。这里的OPRF对原始OPRF的定义进行了弱化。我后面会详细讲解定义具体的弱化点。我们将我们的OPRF应用在PSI上，从而构造了一个半诚实安全的PSI协议，比当前PSI协议的执行效率高3倍。正如我前面所说，当前PSI协议中，OT的执行次数依赖于集合元素的比特长度。我们的协议移除了OT执行次数与集合元素比特长度的依赖关系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-74f435091213142ef238370b4b4c7129_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-74f435091213142ef238370b4b4c7129_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-74f435091213142ef238370b4b4c7129_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-74f435091213142ef238370b4b4c7129_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-74f435091213142ef238370b4b4c7129_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们先来简单介绍Beaver的OT扩展协议。OT扩展协议的基本思想是，可以用少量OT和对称密码学操作构造大量的OT实例。Beaver在数十年前首次提出了这个想法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d39be6b5cc59b272462618e7c2050d78_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d39be6b5cc59b272462618e7c2050d78_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d39be6b5cc59b272462618e7c2050d78_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d39be6b5cc59b272462618e7c2050d78_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d39be6b5cc59b272462618e7c2050d78_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我要向大家介绍一个非常著名、非常高效的OT扩展协议。此协议由Ishai、Kilian、Nissim和Petrank于2003年提出。此协议的基本思想是，在基础OT协议中，Alice选择一个随机的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 比特长字符串 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t%5E1&quot; alt=&quot;t^1&quot; eeimg=&quot;1&quot;/&gt; 。她计算得到另一个字符串 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t%5E1+%5Coplus+r&quot; alt=&quot;t^1 \oplus r&quot; eeimg=&quot;1&quot;/&gt; 。在另一端还有个参与方Bob，他有一个单比特字符串 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1&quot; alt=&quot;s_1&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-767f61c0422e3223efa47b2f65795166_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-767f61c0422e3223efa47b2f65795166_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-767f61c0422e3223efa47b2f65795166_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-767f61c0422e3223efa47b2f65795166_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-767f61c0422e3223efa47b2f65795166_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1%3D0&quot; alt=&quot;s_1=0&quot; eeimg=&quot;1&quot;/&gt; ，则Bob接收到第一列字符串 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t%5E1&quot; alt=&quot;t^1&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b8f3fe1bba21cc376f727cc893c36e08_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-b8f3fe1bba21cc376f727cc893c36e08_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b8f3fe1bba21cc376f727cc893c36e08_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-b8f3fe1bba21cc376f727cc893c36e08_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b8f3fe1bba21cc376f727cc893c36e08_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1%3D1&quot; alt=&quot;s_1=1&quot; eeimg=&quot;1&quot;/&gt; ，则Bob接收到第二列字符串 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t%5E1+%5Coplus+r&quot; alt=&quot;t^1 \oplus r&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6776a265b116ad4ed2e7c696e234619b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-6776a265b116ad4ed2e7c696e234619b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6776a265b116ad4ed2e7c696e234619b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-6776a265b116ad4ed2e7c696e234619b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6776a265b116ad4ed2e7c696e234619b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;也就是说，Bob可以根据自己的选择比特 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1&quot; alt=&quot;s_1&quot; eeimg=&quot;1&quot;/&gt; 接收到字符串 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_1&quot; alt=&quot;q_1&quot; eeimg=&quot;1&quot;/&gt; 。OT协议定义的功能就是这样的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3f2191d593ae7a7639cb11c59e58deb6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-3f2191d593ae7a7639cb11c59e58deb6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3f2191d593ae7a7639cb11c59e58deb6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-3f2191d593ae7a7639cb11c59e58deb6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3f2191d593ae7a7639cb11c59e58deb6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，他们重复上述过程 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 次，每次都使用相同的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。最后，Bob收到包含 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 列的矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q&quot; alt=&quot;q&quot; eeimg=&quot;1&quot;/&gt; ，每列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 的值都由比特 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_i&quot; alt=&quot;s_i&quot; eeimg=&quot;1&quot;/&gt; 所决定。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-55eb4b8a17103c94edf8b1e777d86877_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-55eb4b8a17103c94edf8b1e777d86877_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-55eb4b8a17103c94edf8b1e777d86877_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-55eb4b8a17103c94edf8b1e777d86877_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-55eb4b8a17103c94edf8b1e777d86877_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，他们使用轻量级的密码学技术伪随机数生成器将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 个OT扩展为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT。这里 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 要远远大于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 。 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 大约等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B20%7D&quot; alt=&quot;2^{20}&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c09b4049ee64d6c8916a61212c7bf594_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-c09b4049ee64d6c8916a61212c7bf594_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c09b4049ee64d6c8916a61212c7bf594_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-c09b4049ee64d6c8916a61212c7bf594_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c09b4049ee64d6c8916a61212c7bf594_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在整个协议执行过程中，Alice得到了矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T+%5Coplus+r&quot; alt=&quot;T \oplus r&quot; eeimg=&quot;1&quot;/&gt; 。我们将这组矩阵称为OT矩阵。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4cdcec2b521a63ca46614bf4e8b3314e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4cdcec2b521a63ca46614bf4e8b3314e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4cdcec2b521a63ca46614bf4e8b3314e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4cdcec2b521a63ca46614bf4e8b3314e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4cdcec2b521a63ca46614bf4e8b3314e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果我们从行的角度观察这个矩阵，并且令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 表示第一个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 行。如果令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 表示 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 个比特值，则第二个矩阵的第i行就等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，则此时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。左右两行下标相同，取值也相同。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4df3023230ea40b5a3827b57cf793e64_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-4df3023230ea40b5a3827b57cf793e64_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4df3023230ea40b5a3827b57cf793e64_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-4df3023230ea40b5a3827b57cf793e64_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4df3023230ea40b5a3827b57cf793e64_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，则第二个矩阵的第i行等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+1%5E%7B%5Ckappa%7D&quot; alt=&quot;t_i \oplus 1^{\kappa}&quot; eeimg=&quot;1&quot;/&gt; 。此时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+s&quot; alt=&quot;q_i=t_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f376b3de2a0c94b0ba4565134c7d4455_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-f376b3de2a0c94b0ba4565134c7d4455_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f376b3de2a0c94b0ba4565134c7d4455_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-f376b3de2a0c94b0ba4565134c7d4455_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f376b3de2a0c94b0ba4565134c7d4455_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;也就是说， &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 或者等于0，或者等于1，长度为1比特。而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+%28r_i%29%5E%7B%5Ckappa%7D+%5Codot+s&quot; alt=&quot;q_i=t_i \oplus (r_i)^{\kappa} \odot s&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0890b2bd355c044d64438181e3a231ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-0890b2bd355c044d64438181e3a231ad_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0890b2bd355c044d64438181e3a231ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-0890b2bd355c044d64438181e3a231ad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0890b2bd355c044d64438181e3a231ad_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我们把目标聚焦于OT矩阵本身。如果Alice的输入是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; ，Bob的输入是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;/&gt; ，则Alice已知 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，她可以计算 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 的哈希值。Bob收到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 后，可以计算 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 的哈希值，以及 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的哈希值。这里一个非常重要的性质是， &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i%3Dq_i&quot; alt=&quot;t_i=q_i&quot; eeimg=&quot;1&quot;/&gt; ，或者 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i%3Dq_i+%5Coplus+s&quot; alt=&quot;t_i=q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; ，具体等于什么取决于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 。也就是说， &lt;img src=&quot;https://www.zhihu.com/equation?tex=H%28q_i%29&quot; alt=&quot;H(q_i)&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H%28q_i+%5Coplus+s%29&quot; alt=&quot;H(q_i \oplus s)&quot; eeimg=&quot;1&quot;/&gt; 有且仅有一个值等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H%28t_i%29&quot; alt=&quot;H(t_i)&quot; eeimg=&quot;1&quot;/&gt; ，而另一个值对Alice来说看起来像随机数。换句话说，Bob有两个值，Alice只知道其中的一个值。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c26c26f69bdbb769c67e680e58f3a8a9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c26c26f69bdbb769c67e680e58f3a8a9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c26c26f69bdbb769c67e680e58f3a8a9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c26c26f69bdbb769c67e680e58f3a8a9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c26c26f69bdbb769c67e680e58f3a8a9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在2013年，Kolesnikov和Kumaresan指出，IKNP协议中包含重复编码。如果称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 是一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 个比特值重复编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 次的编码过程，我们再来研究一下IKNP协议。第二个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 行等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+C%28r_i%29&quot; alt=&quot;t_i \oplus C(r_i)&quot; eeimg=&quot;1&quot;/&gt; ，而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%3D+t_i+%5Coplus+C%28r_i%29+%5Codot+s&quot; alt=&quot;q_i = t_i \oplus C(r_i) \odot s&quot; eeimg=&quot;1&quot;/&gt; 。Bob计算的是幻灯片上这两个值的哈希值。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7db446c8d9fc0f3d191fa664d689ae74_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-7db446c8d9fc0f3d191fa664d689ae74_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7db446c8d9fc0f3d191fa664d689ae74_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-7db446c8d9fc0f3d191fa664d689ae74_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7db446c8d9fc0f3d191fa664d689ae74_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，如果把随机编码移除，将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 替换为纠错编码，则此协议可以支持长度最大为8比特的选择比特值 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 。这也是为什么当前PSI协议只能对比8比特长的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; 和8比特长的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 。举例来说，我们令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 的输入为3比特长，此时Bob需要根据幻灯片上的公式计算8个哈希值。我们得到了一个非常重要的性质： &lt;img src=&quot;https://www.zhihu.com/equation?tex=H%28q_i+%5Coplus+C%28r%27%29+%5Codot+s%29%3DH%28t_i+%5Coplus+%5BC%28r%27%29+%5Coplus+C%28r_i%29%5D+%5Codot+s%29&quot; alt=&quot;H(q_i \oplus C(r&amp;#39;) \odot s)=H(t_i \oplus [C(r&amp;#39;) \oplus C(r_i)] \odot s)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bfb7daf88c32482ceaebf1080d7e9715_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-bfb7daf88c32482ceaebf1080d7e9715_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bfb7daf88c32482ceaebf1080d7e9715_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-bfb7daf88c32482ceaebf1080d7e9715_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-bfb7daf88c32482ceaebf1080d7e9715_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我们观察等式中的绿色部分。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3Dr%27&quot; alt=&quot;r_i=r&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; ，则绿色部分等于0。绿色部分与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;/&gt; 逐比特与，计算结果还是0，这意味着我们得到的是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H%28t_i%29&quot; alt=&quot;H(t_i)&quot; eeimg=&quot;1&quot;/&gt; 。换句话说，Bob可以计算 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 个哈希值，而Alice只能得到其中一个哈希值，这也是为什么此协议被称为N选1-OT的原因。从安全角度看，他们的协议要求 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r%E2%80%99%29+%5Coplus+C%28r_i%29&quot; alt=&quot;C(r’) \oplus C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 的汉明重量要大于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 。我们翻到下一页幻灯片，讲解其中的原因。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2aca4dc5c286d56d16e63e606c325193_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-2aca4dc5c286d56d16e63e606c325193_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2aca4dc5c286d56d16e63e606c325193_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-2aca4dc5c286d56d16e63e606c325193_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2aca4dc5c286d56d16e63e606c325193_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Bob能得到什么？他计算得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H%28q_i+%5Coplus+C%28r%27%29+%5Codot+s%29&quot; alt=&quot;H(q_i \oplus C(r&amp;#39;) \odot s)&quot; eeimg=&quot;1&quot;/&gt; ，这个值等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H%28t_i+%5Coplus+%5BC%28r%27%29+%5Coplus+C%28r_i%29%5D+%5Codot+s%29&quot; alt=&quot;H(t_i \oplus [C(r&amp;#39;) \oplus C(r_i)] \odot s)&quot; eeimg=&quot;1&quot;/&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i+%5Cneq+r%27&quot; alt=&quot;r_i \neq r&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; ，则此表达式计算得到的值对Alice来说是个随机数。然而，如果Alice可以通过某种方式猜测 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r%27&quot; alt=&quot;r&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 的值，如果Alice知道了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r%27&quot; alt=&quot;r&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; ，她就知道了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，她也就知道了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; ，这实际上意味着Alice知道此表达式所有红色部分的取值，但不知道蓝色部分 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;/&gt; 的值。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 的最小汉明距离为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r%27%29+%5Coplus+C%28r_i%29&quot; alt=&quot;C(r&amp;#39;) \oplus C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 的汉明重量大于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 。这意味着，Alice必须正确猜测 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;/&gt; 中的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 个比特。这样一来，此协议就满足安全性要求了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8507f3e31a805db7e0aaa83c4bbc96fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-8507f3e31a805db7e0aaa83c4bbc96fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8507f3e31a805db7e0aaa83c4bbc96fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-8507f3e31a805db7e0aaa83c4bbc96fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8507f3e31a805db7e0aaa83c4bbc96fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;下面是我们的观察结论，我们发现，我们不需要使用编码算法。我们将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 替换为输出 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ckappa&quot; alt=&quot;\kappa&quot; eeimg=&quot;1&quot;/&gt; 比特长随机字符串的随机函数。这是一个非常小的技巧，但这个技巧让我们的协议变得非常厉害。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0b975f2d9fc113b5267b9d1d254b9dff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-0b975f2d9fc113b5267b9d1d254b9dff_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0b975f2d9fc113b5267b9d1d254b9dff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-0b975f2d9fc113b5267b9d1d254b9dff_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0b975f2d9fc113b5267b9d1d254b9dff_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果我们将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 替换为随机函数，则我们的协议可以支持任意长度的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 。也就是说，这里的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 可以为任意比特长。从Bob的角度看，他可以计算得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H%28q_i+%5Coplus+C%28r%27%29+%5Codot+s%29&quot; alt=&quot;H(q_i \oplus C(r&amp;#39;) \odot s)&quot; eeimg=&quot;1&quot;/&gt; 。这意味着从正确性角度看，我们所得到的协议与之前的协议功能完全相同。在我们的协议中，Bob可以计算任意哈希值，而Alice只能知道其中一个哈希值。这就是为什么我们称我们的协议是∞选1-OT扩展的原因。从安全性看，我们要计算 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 的最优输出比特长度，让此长度等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot; eeimg=&quot;1&quot;/&gt; ，从而得到安全性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ed050c10304c9da0c68701b7697c9e27_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-ed050c10304c9da0c68701b7697c9e27_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ed050c10304c9da0c68701b7697c9e27_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-ed050c10304c9da0c68701b7697c9e27_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ed050c10304c9da0c68701b7697c9e27_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从前面两页幻灯片中，我们可以得到幻灯片上的这一行结论。现在，我们将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 设置成了伪随机函数。从安全性角度看，我们只需让 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r%27%29+%5Coplus+C%28r_i%29&quot; alt=&quot;C(r&amp;#39;) \oplus C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 的最小汉明重量是可忽略函数即可。为此，我们让伪随机函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 的输出比特长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=3.5+%5Ckappa&quot; alt=&quot;3.5 \kappa&quot; eeimg=&quot;1&quot;/&gt; 。这就是为满足协议的安全性，我们需要设置的算法参数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c8235d584f5a1bb7dc818779425c65b7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-c8235d584f5a1bb7dc818779425c65b7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c8235d584f5a1bb7dc818779425c65b7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-c8235d584f5a1bb7dc818779425c65b7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-c8235d584f5a1bb7dc818779425c65b7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这也意味着我们需要把基础OT矩阵宽度扩展到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=3.5+%5Ckappa&quot; alt=&quot;3.5 \kappa&quot; eeimg=&quot;1&quot;/&gt; 比特。不过，我们没必要使用更多的基础OT来扩展OT矩阵宽度。我们使用了一个小技巧。应用伪随机数生成器将OT矩阵的高度扩展到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=3.5+%5Ckappa&quot; alt=&quot;3.5 \kappa&quot; eeimg=&quot;1&quot;/&gt; 比特。随后，我们对矩阵转置，得到宽度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=3.5+%5Ckappa&quot; alt=&quot;3.5 \kappa&quot; eeimg=&quot;1&quot;/&gt; 比特的基础OT矩阵。这样，我们的协议就满足了安全性要求。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597edb8e873b0e1e339b15ecb8333879_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-597edb8e873b0e1e339b15ecb8333879_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597edb8e873b0e1e339b15ecb8333879_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-597edb8e873b0e1e339b15ecb8333879_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-597edb8e873b0e1e339b15ecb8333879_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是协议的完整执行流程。再次强调，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i+%5Cneq+r%27&quot; alt=&quot;r_i \neq r&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%27%29&quot; alt=&quot;F_{s,q_i}(r&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; 看起来像是随机数。而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%29%3DH%28q_i+%5Coplus+C%28r%29+%5Codot+s%29&quot; alt=&quot;F_{s,q_i}(r)=H(q_i \oplus C(r) \odot s)&quot; eeimg=&quot;1&quot;/&gt; ，这就是不经意伪随机函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%29&quot; alt=&quot;F_{s,q_i}(r)&quot; eeimg=&quot;1&quot;/&gt; 的定义。OT矩阵的每一行都定义了一个OPRF实例，这也是为什么我们将我们的协议命名为批处理OPRF的原因。每一行对应的第二个密钥 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 均不相同，但第一个密钥 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;/&gt; 是相同的。因此，我们得到的是批处理密钥相关OPRF。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0d84c35c672f8a09508842e3063a5076_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-0d84c35c672f8a09508842e3063a5076_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0d84c35c672f8a09508842e3063a5076_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-0d84c35c672f8a09508842e3063a5076_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0d84c35c672f8a09508842e3063a5076_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这也是为什么我们将我们的协议最终命名为批处理密钥相关OPRF的原因。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9526fb17c645faf040543bda1c36f2bb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-9526fb17c645faf040543bda1c36f2bb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9526fb17c645faf040543bda1c36f2bb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-9526fb17c645faf040543bda1c36f2bb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9526fb17c645faf040543bda1c36f2bb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;很容易在PSI上应用此OPRF。Bob将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%27%29&quot; alt=&quot;F_{s,q_i}(r&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; 发送给Alice，Alice简单比较 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r_i%29&quot; alt=&quot;F_{s,q_i}(r_i)&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%27%29&quot; alt=&quot;F_{s,q_i}(r&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; ，并告知这两个值是否相等。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i+%5Cneq+r%27&quot; alt=&quot;r_i \neq r&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; ，则对Alice来说 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%27%29&quot; alt=&quot;F_{s,q_i}(r&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; 像是个随机数。这意味着Alice无法猜测得到有关r&amp;#39;的任何信息。这就是隐私相等检测协议的执行过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3855e24cab7a3f5b17f5fa0bb9d7760a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-3855e24cab7a3f5b17f5fa0bb9d7760a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3855e24cab7a3f5b17f5fa0bb9d7760a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-3855e24cab7a3f5b17f5fa0bb9d7760a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3855e24cab7a3f5b17f5fa0bb9d7760a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最终，我们协议的OT执行次数不依赖于输入比特长度 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%7Cr%27%7C&quot; alt=&quot;|r&amp;#39;|&quot; eeimg=&quot;1&quot;/&gt; 、也不依赖于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%7Cr_i%7C&quot; alt=&quot;|r_i|&quot; eeimg=&quot;1&quot;/&gt; 。我们的协议比当前PSI协议执行效率快3倍。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-74a76255ad0fef9d88385886a4de4d86_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-74a76255ad0fef9d88385886a4de4d86_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-74a76255ad0fef9d88385886a4de4d86_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-74a76255ad0fef9d88385886a4de4d86_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-74a76255ad0fef9d88385886a4de4d86_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;幻灯片上给出了半诚实PSI协议的执行效率对比。基于电路的PSI协议的意思是使用通用安全计算协议实现PSI，此类协议的执行效率较低。如果我们使用公钥密码学构造PSI协议，协议的通信效率很高，但计算效率较低。基于OT构造PSI的协议效率较高，计算复杂度和通信复杂度都比较低。我们也对比了最近提出的两个协议，我们的协议比当前PSI协议执行效率快3倍。X轴用10为底的对数进行了放缩。我们协议的执行效率进一步向朴素哈希算法的执行效率迈进。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4f12efab5ad98fe53ea5434844b90abd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-4f12efab5ad98fe53ea5434844b90abd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4f12efab5ad98fe53ea5434844b90abd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-4f12efab5ad98fe53ea5434844b90abd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4f12efab5ad98fe53ea5434844b90abd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;感谢大家的聆听。&lt;/p&gt;&lt;p&gt;主持人：感谢主讲人的演讲，我们还有一些提问的时间。&lt;/p&gt;&lt;p&gt;提问者：你好，有个地方我没有想明白。如果我们用盲签名等公钥密码学方案构建OPRF，则此类方案只需要一轮交互，但你提到公钥密码学方案的执行效率很低。&lt;/p&gt;&lt;p&gt;主讲人：你能再描述一遍问题吗？&lt;/p&gt;&lt;p&gt;提问者：应用OPRF实现PSI的最直接方法是，Alice要求Bob对双方的字符串签名。Bob对字符串签名，并将结果返回给Alice。Alice检查签名结果是否相等，只要签名结果是唯一的，这个协议就是正确的。当然这里还有很多限制条件，比如不能直接使用RSA。但是，这个方案效率很高，可以实现PSI。你前面提到，参与方A要对参与方B所有的字符串签名。&lt;/p&gt;&lt;p&gt;主讲人：是的。&lt;/p&gt;&lt;p&gt;提问者：参与方A同时要对它自己的字符串签名，随后取两组签名的交集。但你前面提到这个过程效率很低，因为…&lt;/p&gt;&lt;p&gt;主讲人：我明白了，感谢你提出的问题。我们的OPRF只需要使用少量的公钥密码学方案 但需要使用大量的对称密码学方案，这就是我们的协议要比公钥密码学方案的协议高效的原因。&lt;/p&gt;&lt;p&gt;提问者：因为你只需要执行128次公钥密码学操作吗？&lt;/p&gt;&lt;p&gt;主讲人：是的，我们只需要执行128次，你可以看这页幻灯片。这里的技巧在于，我们在OPRF协议中使用了OT扩展协议，这意味着我们只需要执行128次公钥密码学操作，或者说κ次公钥密码学操作。&lt;/p&gt;&lt;p&gt;提问者：明白了。&lt;/p&gt;&lt;p&gt;主讲人：是的，我们还使用了对称密码学。很显然，对称密码学的执行效率比公钥密码学高得多，所以… &lt;/p&gt;&lt;p&gt;提问者：明白了。&lt;/p&gt;&lt;p&gt;主讲人：好的。&lt;/p&gt;&lt;p&gt;提问者：谢谢，所以这个方案才能这样高效地完成计算，明白了。&lt;/p&gt;&lt;p&gt;主讲人：是的。&lt;/p&gt;&lt;p&gt;提问者：谢谢。&lt;/p&gt;&lt;p&gt;主持人：听众还有什么其它问题吗？没有其它问题了，我们再次感谢主讲人。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-07-85422763</guid>
<pubDate>Mon, 07 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>传输短秘密值的条件下提高OT扩展协议的效率</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-04-76647738.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/76647738&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7b01b1ba136277a4576b00ee4b38443b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;最近收到了一位知友的私信，询问能否把《Winter School on Cryptography 2012: Lattice-Based Cryptography》的一系列字幕也发布出来，供参考和学习。经过与 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b&quot; data-hash=&quot;60a93d8892402f3493146a4fd54c5f2b&quot; data-hovercard=&quot;p$b$60a93d8892402f3493146a4fd54c5f2b&quot;&gt;@i春秋学院&lt;/a&gt; 当时字幕负责人的讨论，由于相关字幕已经发布了很长时间，我已经可以将字幕发布出来供知友们学习了！因此，在接下来一段时间，我会集中整理《Winter School on Cryptography 2012: Lattice-Based Cryptography》的字幕，重新压制视频并放出。感谢 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b&quot; data-hash=&quot;60a93d8892402f3493146a4fd54c5f2b&quot; data-hovercard=&quot;p$b$60a93d8892402f3493146a4fd54c5f2b&quot;&gt;@i春秋学院&lt;/a&gt; 一直以来的支持！&lt;/p&gt;&lt;p&gt;虽然会集中整理之前的字幕，但是我也会不断听写新的视频，如果有任何顶级安全会议中数据安全相关讲座的听译需求，还请知友们私信我，或者直接在评论区留言。对于一些很大工作量的听译工作（如《Winter School on Cryptography 2015: Practical Secure Multi-Party Computation》这类），我也会持续坚持听译，到合适的时间再对外发布，敬请知友们耐心等待。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为知友们带来的视频是CRYPTO 2013论文《Improved OT Extension for Transferring Short Secrets》。OT Extension协议是安全多方计算中最重要、也是最核心的协议。熟悉OT的知友们可能知道，OT Extension中最核心的论文应该是CRYPTO 2003的《Extending Oblivious Transfer Efficiently》以及CCS 2013的《More Efficient Oblivious Transfer and Extensions for Faster Secure Computation》。不过我一直没有找到这两个讲座的视频，如果哪位知友知道视频链接，也可以在评论区告诉我。&lt;/p&gt;&lt;p&gt;《Improved OT Extension for Transferring Short Secrets》的重要程度相对这两篇论文来说没有那么高，但这篇论文是优化GMW协议的重要理论基础。如果想实现基于GMW协议的安全多方计算应用，这篇论文的阅读和实现也是必不可少的。CRYPTO 2013对应的演讲视频介绍了《Improved OT Extension for Transferring Short Secrets》的基本思想，观看视频后再去读论文会有更深入的理解。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//eprint.iacr.org/2013/491.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2013/49&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;1.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;视频链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DAgPZVecLuXs&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=AgPZVecLuXs&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av62237491/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av62&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;237491/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/CRYPTO%25202013/Improved%2520OT%2520Extension%2520for%2520Transferring%2520Short%2520Secrets&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/CRYPTO%202013/Improved%20OT%20Extension%20for%20Transferring%20Short%20Secrets&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1141506723897516032&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png&quot; data-lens-id=&quot;1141506723897516032&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1141506723897516032&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢主持人的介绍。此工作是我与来自贝尔实验室的Vladimir Kalashnikov所共同完成的。我们工作针对的目标是安全计算，这是密码学上一个非常典型、非常普遍的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当前有很多重要的研究进展，尝试让安全计算从理论走向实际。这些工作的目标不仅是要提高协议的渐进效率，还要提高协议的真实执行效率。还有一些工作的方向是具体协议的实现，解决系统层面的问题。&lt;/p&gt;&lt;p&gt;在过去的5年，无论是理论角度还是实际角度，此领域都诞生了极多的突破性成果。从理论角度，我们得到了很多惊人的结论。我们现在只需要引入常数级额外开销，即可完成安全计算或安全函数求值。另一个突破是全同态加密。对于多种类型的函数，我们甚至可以在最优通信复杂度下构建安全计算协议。还可以使用基于ORAM的安全计算协议，利用RAM计算模型的优势完成安全计算，这样我们就能在次线性时间复杂度下完成安全计算。在实践角度，针对姚氏协议和GMW协议，学者们提出了很多算法或实现层面的优化，也尝试混合使用姚氏协议和GMW协议。特别地，姚氏协议的实现结果令人印象深刻。现在，我们可以在637毫秒内执行完AES的乱码电路。&lt;/p&gt;&lt;p&gt;虽然在实现层面和理论层面我们都得到了令人惊讶的成果，但在右侧，效率最高的协议仍然是20世纪80年代提出的姚氏协议和GMW协议。之所以这样，有一个很直观的原因：理论成果虽然引入常数复杂度，但这个常数可能非常大。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际应用时，可能存在这样一个复杂度与效率的层级关系。FHE的复杂度目前、以后也总会比公钥密码学原语的复杂度高几个量级。公钥密码学原语的复杂度目前、以后也总会比对称密码学原语的复杂度高几个量级。对称密码学原语的复杂度目前、以后也总会比一次一密的复杂度高几个量级。本次演讲的主题是OT扩展，其出发点就是减小公钥操作和对称密码操作的效率鸿沟。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在第一部分演讲中，我会详细介绍OT扩展的研究出发点，并解释OT扩展面临的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;诸如密钥协商、不经意传输等公钥密码学原语一般都很难高效实现。公钥密码学原语天生要依赖于某类代数结构，因此也会遭受很多密码学攻击。因此，相应的参数需要设置得比较大。这导致公钥密码学的计算复杂度也相对较高。另一方面，我们更容易实现伪随机数生成器或哈希函数等对称密码学运算。学者们设计出了很多算法，相应的参数要比公钥密码学小得多，实际中也可以更容易、更轻量级地实现对称密码学运算。这个结论背后还有相应的理论支撑。理论上，无法通过黑盒方式应用对称密码学原语构造大多数公钥密码学原语。这意味着公钥密码学原语和对称密码学原语的性能差约为3至4个数量级。对于诸如AES等被广泛使用的特定对称密码学操作，Intel专门提供了对应的指令集，进一步提高了这类运算的执行效率。因此，我们无法通过对称密码学原语实现公钥密码学原语。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那接下来该怎么办？或许可以用少量公钥原语实例和大量对称密码学操作，生成大量公钥实例。这一技术称为“扩展原语”。我们已经知道，很容易扩展公钥加密体制，具体过程是用对称加密算法加密具体的明文，用公钥加密算法加密对称加密的密钥。这样一来，我们只需要执行一次公钥操作。这一技术在我们每天使用的加密过程中起到了非常重要的作用。我们可以很自然地把这个问题展开：是否可以扩展其它公钥密码学原语。如OT？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;回忆一下不经意传输要解决的问题。发送方有两个输入： &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_0&quot; alt=&quot;x_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1&quot; alt=&quot;x_1&quot; eeimg=&quot;1&quot;/&gt; 。接收方有一个输入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。协议执行完毕后，发送方无法得到任何信息，接收方可以得到与其选择比特关联的发送方输入。OT是SFE的基础构建模块。姚氏电路中应用不经意传输实现了乱码密钥的2选1过程。在GMW协议中，OT的用途更加广泛，每个AND门的求值过程都要使用一次OT协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们知道OT的执行开销非常大，我们无法通过对称密码学操作实现OT。但假设我们有一个可以传输短字符串的OT，通过使用标准的伪随机数生成器，我们能得到可以传输长字符串的OT。这一技术称为“OT长度扩展”。&lt;/p&gt;&lt;p&gt;还有一个更难解决的问题，称为“OT实例扩展”，简称“OT扩展”。幸运的是，我们知道OT扩展是可行的。我们只需要 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个公钥密码学操作，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个种子OT，再加上 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 次对称密码学操作。应用这 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 次公钥密码学操作，我们就可以执行任意多项式大小次的OT操作。这一技术大幅降低了公钥密码学运算次数，对SFE的实际应用起到了重要的作用。近期大多数SFE的实现都应用了OT扩展协议，从而提高协议的执行效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Beaver在1996年提出了第一个OT扩展协议。第一个高效的OT扩展协议由Ishai、Kilian、Nissim和Petrank给出。此协议也称为IKNP协议，对应的论文发表在CRYPTO 2003上。后续，学者们期望在恶意攻击场景下提高OT扩展协议的执行效率。学者们同时也在加深对OT扩展协议的理解，从而知道OT扩展协议的上限是什么。在本工作中，我们将在半可信场景下提高IKNP协议的效率。我们给出了协议的渐进优化方法和实际优化方法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在接下来的讲座中，我们会描述Ishai等人的OT扩展协议构造。实际上，我们将直接使用Ishai等人CRYPTO 2003的演讲幻灯片。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;IKNP第一个、也是最重要的步骤是将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT归约为传输 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 比特字符串的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT。这一步骤将引入额外的、线性数量级的对称密码学操作。下一步是长度扩展步骤，我们之前已经讲解过这一步骤了。这可以让我们把长字符串OT协议归约为短字符串OT协议。这一步骤进一步引入了线性数量级的对称密码学操作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在核心归约步骤中，我们让接收方选择一个随机的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5Ctimes+k&quot; alt=&quot;n\times k&quot; eeimg=&quot;1&quot;/&gt; 矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 。随后，发送方选择一个随机的行向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;/&gt; 。接下来，接收方和发送方执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT协议，但此OT协议中两个参与方的角色互换。在每个OT协议中，接收方要选择长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 的两列比特值。每对比特值中。第一列为矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 中的某一列，第二列为第一列比特值与选择向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 的异或结果。发送方实际上应用它随机选择的行向量在接收方的两列比特值中选择一列。&lt;/p&gt;&lt;p&gt;这样，发送方通过OT协议得到了一个矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; 。我们来看看矩阵 Q 满足何种性质。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D0&quot; alt=&quot;r_i=0&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，收到的每对比特值就不太一样了。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，在IKNP协议中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i%5Coplus+s&quot; alt=&quot;q_i=t_i\oplus s&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;注意到，在第一种情况下，接收方知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+&quot; alt=&quot;t_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; 。因此，在第一种情况下，接收方能得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。在第二种情况下， 接收方能得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s+&quot; alt=&quot;q_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; ，也就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 。这意味着我们或许可以使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 作为OT协议中的数据加密密钥。但需要注意的是，我们必须要破坏矩阵中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的相互关系。我们应用随机预言机 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H&quot; alt=&quot;H&quot; eeimg=&quot;1&quot;/&gt; 来破坏 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的相互关系。最后，接收方根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 选择得到它的输出，也就是应用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 进行解密。&lt;/p&gt;&lt;p&gt;IKNP协议非常简单、非常优雅、效率极高。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们考虑 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT协议所需要的通信开销。其中发送方输入的长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L&quot; alt=&quot;L&quot; eeimg=&quot;1&quot;/&gt; 。大家已经了解到，核心归约步骤就是对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_%7Bi%2C0%7D&quot; alt=&quot;x_{i,0}&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_%7Bi%2C1%7D&quot; alt=&quot;x_{i,1}&quot; eeimg=&quot;1&quot;/&gt; 加密，这需要发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nL&quot; alt=&quot;2nL&quot; eeimg=&quot;1&quot;/&gt; 比特的数据。在长度扩展步骤中，我们要应用一个PRG，这需要发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nk&quot; alt=&quot;2nk&quot; eeimg=&quot;1&quot;/&gt; 比特的数据。&lt;/p&gt;&lt;p&gt;在姚氏电路中，我们需要传输长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3Dk&quot; alt=&quot;L=k&quot; eeimg=&quot;1&quot;/&gt; 的密钥，因此核心归约步骤和长度扩展步骤中的通信开销相同。在GMW中，我们只需要传输 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3D1&quot; alt=&quot;L=1&quot; eeimg=&quot;1&quot;/&gt; 的信息。令人惊讶的是，这一场景下长度扩展步骤的通信开销远高于核心归约步骤的通信开销。这就是一个问题了，我们可能可以在这一场景下对通信开销进行优化。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在讲座的后半部分，我们会提出IKNP的通用框架。我们也会向大家展示如何提高IKNP的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们先来详细分析一下IKNP协议。可以看到，接收方要选择这个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5Ctimes+k&quot; alt=&quot;n\times k&quot; eeimg=&quot;1&quot;/&gt; 的随机矩阵。随后，接收方要生成另一个矩阵，这个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列为第一个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列异或选择向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。换句话说， &lt;img src=&quot;https://www.zhihu.com/equation?tex=U%3D+T+%5Coplus+R&quot; alt=&quot;U= T \oplus R&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 是所有列均相等的矩阵，每个列都为接收方的选择向量。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果我们从行的视角看，就会发现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 行为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; ，这意味着 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 的每一行都是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 的一种编码。在IKNP协议中， &lt;img src=&quot;https://www.zhihu.com/equation?tex=0&quot; alt=&quot;0&quot; eeimg=&quot;1&quot;/&gt; 被映射为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=0%5Ek&quot; alt=&quot;0^k&quot; eeimg=&quot;1&quot;/&gt; ，而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 被映射为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1%5Ek&quot; alt=&quot;1^k&quot; eeimg=&quot;1&quot;/&gt; 。因此，我们可以看到IKNP这一高效协议在底层执行了一次逐行重复编码。这自然引出了一个问题：我们是否可以使用更复杂的编码？毕竟，重复编码是一种最简单的编码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;假设我们使用编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; ，并且我们假定 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 属于一个很大的域，域为从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 。我们用编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 映射成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29+&quot; alt=&quot;C(r_i) &quot; eeimg=&quot;1&quot;/&gt; ，这是一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 比特长字符串。现在，接收方需要用选择比特 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 构建矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 。我们来看看，在这个理论框架下IKNP协议的执行过程。&lt;/p&gt;&lt;p&gt;第一步，接收方获得了矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 。随后，接收方用加法秘密分享方案将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 分享为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29%3D+T+%5Coplus+U&quot; alt=&quot;C(R)= T \oplus U&quot; eeimg=&quot;1&quot;/&gt; 。接下来，接收方和发送方角色互换，执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT协议。在第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 个OT中，接收方的输入是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t%5Ei&quot; alt=&quot;t^i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u%5Ei&quot; alt=&quot;u^i&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列。执行完OT协议后，发送方得到矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; 。在IKNP协议中，我们知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 或者等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，或者等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+&quot; alt=&quot;t_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; 。在这一理论框架中，我们可以知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+%28C%28r_i%29+%5Codot+s%29&quot; alt=&quot;q_i=t_i \oplus (C(r_i) \odot s)&quot; eeimg=&quot;1&quot;/&gt; ，结果不算太复杂。&lt;/p&gt;&lt;p&gt;我们可以验证一下，当C是重复编码时 此框架对应的协议就是IKNP协议。特别地，当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D0&quot; alt=&quot;r_i=0&quot; eeimg=&quot;1&quot;/&gt; 时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29&quot; alt=&quot;C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 是一个全 &lt;img src=&quot;https://www.zhihu.com/equation?tex=0&quot; alt=&quot;0&quot; eeimg=&quot;1&quot;/&gt; 向量，因此我们得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; 时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29&quot; alt=&quot;C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 是一个全 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 向量，此时我们可以得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+s&quot; alt=&quot;q_i=t_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。这样一来，我们得到了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 个密钥。后面的执行过程就完全一样了，密钥生成算法为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+%28C%28r%29+%5Codot+s%29&quot; alt=&quot;q_i \oplus (C(r) \odot s)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们仍然可以证明接收方只能知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 。因此接收方只能解密对应的密文，从而得到对应的输入。核心归约步骤在恶意发送方的攻击下是完美安全的。特别地，恶意发送方只能得到矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; ，这是编码的随机独立分享结果。核心归约步骤在半诚实接收方的攻击下是统计安全的。这是因为除了在加密过程中使用了随机预言机之外，核心归约步骤没有安全性损失。因此，整个协议的安全性损失为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 的取值范围，以及 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-d%7D&quot; alt=&quot;2^{-d}&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=d&quot; alt=&quot;d&quot; eeimg=&quot;1&quot;/&gt; 是线性编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 的最小距离。&lt;/p&gt;&lt;p&gt;注意到在此理论框架下，我们可以从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选取消息，因此从效果上看，我们可以实现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT，而不是2选1-OT。但在这种情况下，核心归约步骤的通信开销会从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nL&quot; alt=&quot;2nL&quot; eeimg=&quot;1&quot;/&gt; 提高到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=nmL&quot; alt=&quot;nmL&quot; eeimg=&quot;1&quot;/&gt; 。随后，我们将标准的2选1-OT转换为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%2F%5Clog%28m%29&quot; alt=&quot;n/\log(m)&quot; eeimg=&quot;1&quot;/&gt; 个字符串长度稍长的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT实例，这也允许我们将通信开销表示为与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 相关的函数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我们有了一个自由变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; ，用它来平衡核心归约步骤和长度扩展步骤的开销。具体来说，如果我们使用的是最小距离为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%2F2&quot; alt=&quot;k/2&quot; eeimg=&quot;1&quot;/&gt; 的Hadamard编码，在这种情况下，2选1-OT的通信开销可以降低2倍。在多方GMW协议中，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%3D256&quot; alt=&quot;k=256&quot; eeimg=&quot;1&quot;/&gt; ，则通信开销也可以降低2倍。&lt;/p&gt;&lt;p&gt;也可以进一步优化长度扩展步骤的通信开销，此开销的优化程度是算法层面的，而不是渐进层面的。结合Hadamard编码后，与未优化的IKNP协议相比，新协议的通信开销要降低3.5倍。Asharov等人也独立发现了这一优化点，他们的论文将发表在CCS 2013上。&lt;/p&gt;&lt;p&gt;与IKNP相比，我们从渐进层面降低了每一个OT的通信开销。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3D1&quot; alt=&quot;L=1&quot; eeimg=&quot;1&quot;/&gt; 时，IKNP需要通信 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28k%29&quot; alt=&quot;O(k)&quot; eeimg=&quot;1&quot;/&gt; 比特，而我们需要通信 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28k%2F%5Clog%28k%29%29&quot; alt=&quot;O(k/\log(k))&quot; eeimg=&quot;1&quot;/&gt; 比特。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总结一下，为了平衡公钥密码学原语和对称密码学原语的性能鸿沟，学者们提出了OT扩展协议，这一协议在安全函数求值的实例落地中产生了巨大的影响。在本次讲座中，我们提出了IKNP的编码理论框架。可以在随机预言模型下证明此框架的安全性。随机预言模型也可以换为特定类型哈希函数假设，即相关性健壮哈希函数，这沿用了IKNP中安全性所依赖的相关性健壮哈希函数假设。当使用复杂编码时，此框架提高了多方GMW中2选1-OT和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT的性能。&lt;/p&gt;&lt;p&gt;我想用GMW和姚氏电路的性能对比问题作为讲座的结尾。近期的安全多方计算研究主要关注恶意模型下姚氏电路的性能优化问题。在半可信安全模型下，学者们也提出了很多姚氏电路的优化方法。但近期的一些工作也表明，GMW协议也有很多算法层面的优化点。我们的工作适用于GMW协议。谢谢大家。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-04-76647738</guid>
<pubDate>Fri, 04 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>ObliVM：安全计算编程框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-04-73618400.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/73618400&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-83f24da35d88aef9a1bc7d522f42c2cf_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;使用新的方法撰写密码学会议视频分享文章后，虽然点赞和阅读量并没有提升很多，但是根据知友们的反馈，这样做确实可以大幅度提高阅读体验。更开心的是，向知乎反馈后，知乎的工程师们也是大力配合，现在终于支持上传长度不超过60分钟的视频了，撒花庆祝！接下来的视频分享文章中，我会同时在知乎和B站上传翻译视频。知友们可以根据自己的习惯选择在哪个地方观看。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2015年安全顶级会议Security and Privacy 2015的演讲视频《ObliVM：安全计算编程框架》，对应的论文是《ObliVM: A Programming Framework for Secure Computation》。&lt;/p&gt;&lt;p&gt;上一篇文章《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot; class=&quot;internal&quot;&gt;SoK：安全多方计算通用框架&lt;/a&gt;》的视频中，作者调研了9个开源的通用安全计算框架，而ObliVM就是其中的一个。我个人对于“把Alice和Bob作为编程语言的关键词”这一点仍然记忆犹新。这一次，我们就来详细了解一下ObliVM到底是什么。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文链接：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.umd.edu/~elaine/docs/oblivm.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cs.umd.edu/~elaine/docs&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/oblivm.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;视频链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DQ2QLRcj0Mio%26t%3D92s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=Q2QLRcj0Mio&amp;amp;t=92s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av59239482/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av59&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;239482/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202015/ObliVM%2520A%2520Programming%2520Framework%2520for%2520Secure%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202015/ObliVM%20A%20Programming%20Framework%20for%20Secure%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1134043543998984192&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;ObliVM：安全计算编程框架&quot; data-poster=&quot;https://pic2.zhimg.com/v2-f3c6c88bc65211e0a5428862604b6751.jpg&quot; data-lens-id=&quot;1134043543998984192&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-f3c6c88bc65211e0a5428862604b6751.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;ObliVM：安全计算编程框架&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1134043543998984192&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）大家好，我很高兴能在这里为大家介绍我们的工作：ObliVM，这是一个安全计算的编程框架。这是我和我的队友们一同完成的工作，队友有Xiao Wang，坐在那里的Kartik，还有Yan Huang，还有Elaine Shi。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;很高兴自己在前面的一个演讲中为大家充分介绍了什么是安全计算，或安全函数求值。我这里只需给出一个简短的介绍。例如，Sheldon和Amy希望互相确认自己是不是对方的另一半。他们都相信基因匹配的效果。因此，他们可以执行一个分析过程，看看他们是否匹配。一个很关键的安全问题是：他们不想把敏感的基因数据泄露给对方。我在前面已经讲过了，安全计算是这一问题的绝佳解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以把这个问题抽象成下述形式：给定两个参与方Alice和Bob，以及他们的秘密输入&lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt;，他们希望联合计算一个公开函数&lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28x%2Cy%29&quot; alt=&quot;f(x,y)&quot; eeimg=&quot;1&quot;/&gt;，得到函数的计算结果。同时，除了计算结果&lt;img src=&quot;https://www.zhihu.com/equation?tex=z&quot; alt=&quot;z&quot; eeimg=&quot;1&quot;/&gt;外，涉及两个秘密输入的计算过程不会向对方泄露任何其它信息。这就是安全计算的概念。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家已经知道，安全计算的解决方案有姚氏乱码电路，还有GMW协议。我们关注什么地方呢？我们的关注点是：如何让安全计算能在实际中得到应用？例如，一个开发者希望开发一个安全计算应用。他们肯定不想把函数写成电路的形式。他们想用C语言、Java语言、或者Python语言编写代码。因此，源程序和安全计算协议之间存在很大的鸿沟。这就是我们ObliVM框架要做的事情。我们的ObliVM是一个工具，可以将源代码转换成实际的安全计算协议。这是ObliVM的框架概览。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里面最主要的问题是什么？Kartik已经提到，主要问题是开发人员喜欢用Python等语言模型编写代码。幻灯片左侧是开发人员撰写的源程序。但实际上，大多数安全计算协议是在电路模型下实现的。因此，在高层语言程序和电路程序之间存在很大的鸿沟。我们的问题是，如何将左侧的代码转换为右侧的协议？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢Kartik的讲解，你已经提出了我们工作的出发点。这里的关键挑战是，如何能让动态内存访问过程不泄露信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是一个不太容易解决的挑战。我们的解决方案是：把RAM模型下的问题转换到不经意RAM模型中。不经意的意思是内存访问和指令追踪过程不依赖于秘密输入。这样一来，不经意程序就可以被进一步转换为电路了。我们可以看到，在转换链路中，后一部分相对比较简单，前一部分非常有挑战性。本次讲座主要关注前一部分，解释如何做到这一点。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有一个非常平凡，也不能说非常平凡的解决方案。这个方案于2013年首先提出，基本思想是使用不经意RAM。不经意RAM，又称ORAM，可以把任意程序编译成不经意程序。基于这一思想，我们去年提出了SCVAM框架。此框架可以仿真通用ORAM。可以证明，我们的渐进性能比所有之前的解决方案都要好。这一解决方案是通用的，也很容易实现。但问题在于，这个方案可能不是最高效的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在过去的几年间，我们观察到研究人员提出了很多定制化安全计算协议。这方面的工作有很多，我实在没办法在幻灯片上把所有相关工作都列出来。这些定制化安全计算协议都很高效，可以这么说，这些协议比我们去年的工作都高效。但问题在于，这些协议的设计成本很高。例如，我们与Nina Taft聊了聊，她是我们的合作方。我们私下针对CCS 2013上面发表的隐私矩阵分解算法进行了讨论。她告诉我们，她们组织了5位研究人员，花费了大约4个月的时间才完成了全部的实现。也就是说，整个过程花费了超过1.5年的研究时间。这里涉及到巨大的工作量。我们的问题是：我们能不能做得更好？我们能否构建一个通用框架，但仍然获得定制化协议的执行效率？这就是我们ObliVM的目标。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们希望非领域专家，例如非密码学家，可以用它实现一些安全计算协议，同时获得定制化协议的执行效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何做到这一点？关键思想是：在ObliVM内部，我们提供很多编程抽象接口。我在幻灯片上具体列举了一些，如不经意数据结构、MapReduce、循环合并等。我后面会介绍其中一个抽象接口。如果想了解更多的细节，请阅读我们的论文。我还想提及的是，Kartik刚刚讲解的GraphSC论文也是一个并行计算编程接口抽象。总之，我们提供了一些编程接口抽象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我这里想简单介绍一下编程接口抽象到底是什么。我们来看看分布式计算社区。我估计绝大多数人都听说过MapReduce，这是谷歌于2004年在OSDI会议上发表的论文。在这篇论文发表之前，并行计算、或者说分布式计算，是一个很困难的任务。但通过MapReduce，开发者只需要将计算过程编码在Mapper和Reducer框架中。开发者不需要关注分布式计算方法，MapReduce框架会实现整个分布式计算过程。因此，与之前的工作相比，使用MapReduce涉及的开发工作量会非常小。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们想用与之非常类似的方法解决这一问题。我们希望提供一些抽象接口，允许开发者将计算任务编码在抽象接口中，这样他们就不需要关注底层的密码学原语，但仍然获得相同的计算性能。这就是我们的目标，这就是我们的解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何对外提供这些编程接口抽象？我们希望实现一个新的语言支持体系。例如，我们想为我们的开发者实现一个新的编程语言。在开发这个语言时，我们脑海中有两个目标。第一个目标是：领域专家或密码学家可以很容易地应用此语言实现不同的编程接口。另一方面，对于非专家来说，他们可能不是特别了解密码学技术，他们可以很容易地使用这些编程语言抽象构建他们自己的应用程序。&lt;/p&gt;&lt;p&gt;结合脑海中的这两个目标，我们的解决方案是构建新的语言特性，支持之前系统未无法支持的功能。我这里列举了一些特性，请大家阅读论文，了解相应的技术细节。后续我们会在幻灯片给出的地址上开源我们的编译器，这样大家可以更好地了解编译器的实现细节。我认为这些特性都很不错。例如，我们可以使用随机类型、虚函数等，从源代码阶段，而不是从后端原语阶段，实现不经意RAM协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有了这些编程接口抽象，开发人员该怎么做呢？例如，我们希望实现一个稀疏图算法。我们已经有了编程接口抽象这样一个武器库了。假设我们想要实现稀疏Dijkstra最短距离算法，我们可以选取适当的不经意数据结构，这里要选择不经意堆。随后，我们使用循环合并抽象实现相应的算法。通过使用这些工具，我们实现了3个不同的稀疏图算法。&lt;/p&gt;&lt;p&gt;整个流程好像都走得通，但我们得到了一个超出期望的结果：我们实现的算法从理论角度也得到了突破，所有3个算法的渐进复杂度都比当前最优算法的渐进复杂度低。这个结论令我们感到十分惊讶。如果想了解算法的更多细节，请阅读我们的论文。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;开发人员具体该做些什么呢？我在几分钟之前已经向大家许诺过了，我会为大家介绍一个编程接口抽象：循环合并。这是非常细节的内容了。在安全计算中，实现秘密循环是非常有挑战性的工作，因为循环次数本身就会泄露信息。这里我们允许编程人员编写有上界循环次数限制的循环语句。例如，我们允许协议保护循环次数，但我们要求开发人员公开告知循环次数的上限。&lt;/p&gt;&lt;p&gt;这是一个嵌套循环代码。这里有趣的地方在于，第4行到第7行的内部循环中，循环次数上界m并不是外部循环中每次迭代的最大迭代次数上界，而是两层嵌套代码中，内部循环的总执行次数上界。这样我们可以避免重复的执行过程。例如，如果我们按照传统方法给出上界，则总迭代次数是n•m，但这样设置的总迭代次数是n+m。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们的编译器会分析这段代码，自动将此类形式的代码转换成右下的代码形式。这段代码看起来像是一个状态机，这样就不会为算法引入额外的复杂度了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;应用所有这些技术以后，我们能得到什么呢？我之前已经提到，实现矩阵分解算法涉及的人力开销大约为1年1.5个研究者。如果使用ObliVM呢？结果非常令人惊讶，只需要一天就够了。一个博士研究生只需要一天就可以实现全部功能。&lt;/p&gt;&lt;p&gt;你可能会想，实现结果是否高效？可能自动化的实现结果并不高效。事实上，我们的实现的算法效率要高10到20倍，因此实现结果甚至更高效了。这就是我们现在得到的优化结果。我相信ObliVM对于所有安全计算开发者来说都是一个福音。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们深入解析一下各个优化点所带来的性能提升情况。我们这里给出的是Dijkstra算法的实现结果。论文中给出了更多的实现结果。虽然我们这里只关注ObliVM的编程语言部分，但实际上ObliVM拥有一个经过深度优化的后端ObliVM-SC。此后端代码也开源了，大家可以访问我们的网站，获取源代码链接。&lt;/p&gt;&lt;p&gt;我们实现了一个当前最优的电路ORAM，此ORAM专门为安全计算进行优化。我们将我们的系统和之前在CCS 2012上公开的最佳结果进行了对比，电路ORAM本身可以为我们带来50倍的性能提升。编程语言和编译器可以为我们带来2500倍的性能提升。我们进一步对后后端的其它部分进行了深度优化，可以在我们的论文中找到相应的技术细节描述。这些深度优化可以为我们带来7倍的性能提升。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总体来说，我们获得了大约100,000倍的性能提升，这是很大的性能提升倍数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里给大家一个更直观的方案效率描述。2012年在同一篇论文中，他们在1GB数据集上执行了二分搜索算法。一次单独问询的计算时间大约为12小时。现在情况又怎么样呢？使用我们的ObliVM框架，每次问询的执行时间仅为7.3秒。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还将我们的SCVM框架与不安全的解决方案进行了效率对比。也就是说，我们直接在计算机上执行明文程序，从而对比效率。我们计算了效率损失量，效率损失量相对还是可以接受的。对于分布式GWAS，效率损失仅为130倍。我们可以期待，未来这一数字可能会进一步降低。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有很多合作方都与我们合作，ObliVM已经在多个场景下得到了应用。我们刚刚赢得了3月份举办的基因分析竞赛，这是大约2个月前举办的竞赛。未来，我们希望在ObliVM框架的基础上实现更多的密码学计算任务，如同态加密等。&lt;/p&gt;&lt;p&gt;非常感谢大家，这就是我讲座的全部内容了，接下来我可以回答一些问题。&lt;/p&gt;&lt;p&gt;提问者：在演讲开始阶段你给出了一个二分搜索的例子，开发人员应该怎么实现二分搜索？开发人员需要写什么代码？&lt;/p&gt;&lt;p&gt;主讲人：你指的是哪个例子？&lt;/p&gt;&lt;p&gt;提问者：在最开始的地方，你给出了一个二分搜索的例子，那时候你提到…&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;主讲人：这张图中左侧是开发人员实现循环合并时要编写的代码。你提到了二分搜索的例子，对吧？&lt;/p&gt;&lt;p&gt;提问者：是的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;主讲人：我觉得用二分搜索举例子会比较好。开发人员要做的事情是…我们回到那页幻灯片上。在这里。&lt;/p&gt;&lt;p&gt;提问者：就是这里。&lt;/p&gt;&lt;p&gt;主讲人：这就是开发人员需要编写的代码…我看看这个代码能不能编译通过…是的，可以用我们的ObliVM编译器编译这个程序。编译器会自主处理内存访问过程。&lt;/p&gt;&lt;p&gt;提问者：是的。&lt;/p&gt;&lt;p&gt;主讲人：是的，编译器会识别相应的模块，判断哪些部分要替换为ORAM，哪些部分不需要替换。&lt;/p&gt;&lt;p&gt;提问者：ObliVM是不是有一种潜在使用方法，就是让ObliVM输出C代码，而不是电路，这样我们就可以把任意一个程序输入给ObliVM，使得程序无法被旁路攻击？&lt;/p&gt;&lt;p&gt;主讲人：这是一个非常好的问题。一个非常有趣的事实是，我们的ObliVM编译器输出的是Java代码。&lt;/p&gt;&lt;p&gt;提问者：明白。&lt;/p&gt;&lt;p&gt;主讲人：随后，执行Java代码，会生成一个电路。所以我觉得你提的问题非常好。我认为未来一个很有趣的研究方向是，如何阻止ObliVM编译器遭到旁路攻击。&lt;/p&gt;&lt;p&gt;提问者：好的，谢谢。&lt;/p&gt;&lt;p&gt;主讲人：谢谢你。&lt;/p&gt;&lt;p&gt;主讲人：什么？你可以使用麦克风的。&lt;/p&gt;&lt;p&gt;合作者：我们的编译器没办法被旁路攻击。如果你直接编写类似这样的代码，编译的输出结果是通用ORAM程序。但你也可以调用我们提供的不经意数据结构。我们在不经意数据结构中实现了二分搜索树，如果直接调用不经意数据结构抽象接口，编译时间会减少log(n)倍。&lt;/p&gt;&lt;p&gt;提问者：明白。&lt;/p&gt;&lt;p&gt;合作者：很容易让编译器输出C代码，修改后端编译器即可。比较困难的点在于前端，如何编译得到一个高效的电路。&lt;/p&gt;&lt;p&gt;主持人：感谢Elaine的解释。&lt;/p&gt;&lt;p&gt;主讲人：是的，感谢Elaine。&lt;/p&gt;&lt;p&gt;主持人：再次感谢我们的演讲者。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-04-73618400</guid>
<pubDate>Fri, 04 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>SoK：安全多方计算通用框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-04-72119587.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b38297e2e605b6e0c3739b6eee4bb1e8_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;有段时间没有为知友们带来安全会议的演讲视频翻译了，主要原因是我发现这类文章阅读量并不是很高。业余时间我自己反思了一下，可能是因为知乎到底还是一个问答类社区，文字类型的描述可能更适合知友们快速感知到安全会议演讲视频的内容。为此，在接下来的安全演讲视频文章中，我做了如下几个改变：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;不在知乎上传视频，而是根据视频主讲人的幻灯片展示情况，将对应的演讲稿发出。&lt;/li&gt;&lt;li&gt;演讲视频还是会上传，不过会上传到B站这个专门播放视频的地方。这样，如果有翻译错误，或者有更好的建议，知友或者B站的朋友可以通过弹幕、评论的形式更快地反馈。&lt;/li&gt;&lt;li&gt;演讲视频的中文字幕、时间轴文件（ass格式）、相应的截图等，我会公开在我的GitHub下面，方便知友们下载。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;希望这种方式可以让知友们各取所需。&lt;b&gt;如果知友们还想了解哪些演讲视频，也可以通过知乎评论、GitHub、B站等方式给我留言。我会尽可能满足大家的要求。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2019年5月23日刚刚召开的安全顶级会议Security and Privacy 2019的一个演讲视频《SoK：安全多方计算通用框架》，对应的论文是《SoK: General Purpose Frameworks for Secure Multi-Party Computation》。&lt;/p&gt;&lt;p&gt;这里需要介绍一个背景知识：如果一篇论文的开头是“SoK”，则代表这篇论文是一篇综述论文。SoK的全称是“Systematization of Knowledge Papers&lt;b&gt;”&lt;/b&gt;，Security and Privacy的官方网站（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ieee-security.org/TC/SP2013/cfp.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;ieee-security.org/TC/SP&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;2013/cfp.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;）给出了一个很详尽的解释：&lt;/p&gt;&lt;blockquote&gt;Following the success of the previous years&amp;#39; conferences, we are also soliciting papers focused on systematization of knowledge (SoK). The goal of this call is to encourage work that evaluates, systematizes, and contextualizes existing knowledge. These papers can provide a high value to our community but may not be accepted because of a lack of novel research contributions. Suitable papers include survey papers that provide useful perspectives on major research areas, papers that support or challenge long-held beliefs with compelling evidence, or papers that provide an extensive and realistic evaluation of competing approaches to solving specific problems. Submissions are encouraged to analyze the current research landscape: identify areas that have enjoyed much research attention, point out open areas with unsolved challenges, and present a prioritization that can guide researchers to make progress on solving important challenges.&lt;b&gt;Submissions must be distinguished by a checkbox on the submission form. In addition, the paper title must have the prefix &amp;#34;SoK:&amp;#34;&lt;/b&gt;. They will be reviewed by the full PC and held to the same standards as traditional research papers, except instead of emphasizing novel research contributions the emphasis will be on value to the community. Accepted papers will be presented at the symposium and included in the proceedings.&lt;/blockquote&gt;&lt;p&gt;简单来说，SoK论文的目标是系统化、结构化地评估已有知识体系的论文。这类论文虽然工作量很大，但由于缺乏必要的创新性贡献，所以一般不会被会议所接收。但是，随着相应知识的不断提出和完善，这类论文会对他人进一步的研究带来非常大的帮助。所以，越来越多的会议开始接收SoK论文了。SoK论文的最大特点是：这类论文的题目必须以“SoK”开头。&lt;/p&gt;&lt;p&gt;《SoK: General Purpose Frameworks for Secure Multi-Party Computation》这篇论文非常详尽的分析了现有的安全多方计算通用框架，从各种维度评估了各个框架的优缺点，在不同场景下给出了使用建议。特别地，作者成功构建了所有的通用框架，并把构建环境打包在Docker中。我个人用了一下Docker，样例程序都可以跑通，作者也针对各个框架给出了进一步的文档和注释。这篇文章特别适合准备研究安全多方计算协议，或者准备在实际中使用安全多方计算的研究人员。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DI0bremwQ_ns%26t%3D40s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=I0bremwQ_ns&amp;amp;t=40s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av57765218&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av57&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;765218&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202019/SoK%2520General%2520Purpose%2520Frameworks%2520for%2520Secure%2520Multi-Party%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202019/SoK%20General%20Purpose%20Frameworks%20for%20Secure%20Multi-Party%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;p&gt;感谢知乎工程师们的辛勤工作，知乎现在可以上传60分钟的视频了。为了文章的完整性，我把视频也同步发布在知乎专栏上面。&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1134055356077580288&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic4.zhimg.com/v2-56be736bd7d245f4652fb021facd0c27.jpg&quot; data-lens-id=&quot;1134055356077580288&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic4.zhimg.com/v2-56be736bd7d245f4652fb021facd0c27.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1134055356077580288&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（主讲人）非常感谢主持人的介绍。我是Marcela Hastings。这是一篇SoK论文。我将讲解我们的调研结果。我们考察的工具是安全多方计算。这是一个密码学工具，允许互不信任的参与方根据自己的输入计算任意一个函数，计算过程不泄露除输出结果以外的任何信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;安全多方计算实际应用中最著名的实例是丹麦甜菜拍卖系统。在这个场景中，售卖方是丹麦种田菜的农民，而购买方只有一个，即丹麦唯一的一个甜菜加工公司。售卖方为甜菜出价，表示他们希望按照这个价格售卖甜菜，购买方希望得知市场出清价（即保证供求关系平衡的售卖价格）。但售卖方不希望泄露自己的具体出价。如果常年泄露出价，则其它人就会得知自己的甜菜种植能力和做生意的能力了。因此，他们使用安全多方计算协议，在不泄露售卖方出价的条件下计算市场出清价。&lt;/p&gt;&lt;p&gt;另一个例子是波士顿妇女劳动委员会与企业的合作项目。此项目研究员工性别是否会影响到其实际的工资。公司不希望、从法律角度也不能够对外泄露自己雇员的收入或金融类信息。但通过安全多方计算，他们可以在不给出具体数据的条件下计算相应的统计分析结果。&lt;/p&gt;&lt;p&gt;所有这些例子都告诉我们安全多方计算已经足够高效，可以在实际场景中得到应用了。然而，我们之前看到的所有实际应用实例中，项目方都需要组织一个密码学专家团队，针对特定用例实现专用MPC引擎。如果想让MPC得到更广泛的应用，我们需要让不懂密码学的外行也能使用这一工具。虽然二十世纪八十年代，密码学家就提出了MPC算法，但一直以来MPC协议的效率都很低，无法在实际中使用，直到2004年“公平参与”编译器的提出改变了这一现状。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;“公平参与”是第一个通用MPC框架，可以通过MPC执行任意函数的计算。在接下来的10年，这一框架掀起了学者们针对MPC协议性能优化的浪潮。直至现在，无论从算法角度还是从实现层面，MPC协议得到了巨大的优化。在过去十年间，学者们提出了很多端到端MPC框架。在本工作中，我们重点考察通用端到端MPC框架。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;端到端框架的架构如幻灯片所示。框架一般实现了两个阶段的功能：编译器、执行器。这是因为大多数MPC算法只支持有限的算子，如模质数下的加法和乘法。开发者很难应用这些有限的算子实现所需的计算函数。因此，我们重点考察包含一个编译器的框架。编译器的输入是用高级语言描述的函数。编译器会把函数编译成算法可执行的协议。接下来，执行器会具体执行编译好的协议。协议会在多个参与方上同时执行。每个参与方都以编译器的输出结果和自己的秘密值作为输入，计算得到函数输出结果。当然了，不同框架的架构各不相同，但是它们基本都是这样的结构。&lt;/p&gt;&lt;p&gt;在本综述中，我们想回答这样一些问题：目前都有哪些框架？谁在使用这些框架？这些框架是否可以实现实际的计算过程？这些框架是否可以支持所需函数的计算？这些框架是否可以在实际中使用？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为了回答这些问题，我们调查了9个端到端框架和2个电路编译器。我们记录了这些框架的不同特性，包括框架所实现的协议、框架所支持的数据类型和运算操作、以及其它一些实现的具体细节。我们通过多种可用性标准对这些协议进行评价。为了收集这些数据，我们在每个框架上实现3个样例程序。我们把每个框架的完整构建环境及其对应的样例程序都放在了开源的代码仓库中。结合这些框架的使用经验，我们为各个框架补充了相应的文档。构建代码仓库的总时间约为750人小时。此仓库是开源的。我们仍然在积极地维护这一仓库，非常希望大家能看看这个代码仓库。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我想简单介绍一下完成这些工作后我们所得到的一些结论。总的来说，几乎所有的框架做得都不错。各种框架在不同的安全模型下实现了不同的协议。根据具体用例的不同，框架也提供了一些协议和安全模型的选项。我们可以在几乎所有的框架上实现我们的样例程序。这意味着对于绝大多数场景来说，框架的高层语言具有较好的可表达性。总的来说，大多数框架都是开源的、可编译的、可用的。然而，我们发现了两个重要的改进方向。第一个方向是：框架的工程局限性较高。例如，框架的系统构建环境过于复杂。第二个方向是：框架的可用性较差。其根本原因主要在于框架缺失相应的文档。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在具体讲解这些问题之前，我想先从宏观层面介绍我们的发现。我们考察了9个框架。最下方是2个电路编译器。大家可以从表格中看到框架支持的参与方数量、支持的安全模型。我们有两种安全模型。在半诚实模型中，攻击者会正确执行协议，但是攻击者会尝试得到其它参与方的输入。在恶意模型中，攻击者不会遵从约定执行协议，以错误的协议执行结果中推断信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还对不同的协议进行了简单的分类，这里需要简单解释一下。第一类协议是乱码电路协议，最初由姚期智于二十世纪八十年代提出。自姚期智提出此协议以来，学者们持续不断地对协议进行改进。理论密码学家从不同角度对乱码电路进行了优化。从实际中我们发现，几乎所有的框架都实现了半诚实两方协议，一个参与方对电路加密后将结果发送给另一个参与方，另一个参与方根据输入对电路求值。在乱码电路中，需要把函数表示为布尔电路的形式。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二类协议包含很多不同的协议。我们称这类协议为基于电路的多方计算协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这些协议拥有两个共同的特性。第一个特性是，需要把函数表示为代数电路或者布尔电路的形式。第二个特性是，数据需要用线性秘密分享的形式表示。线性秘密分享意味着协议支持任意数量的参与方。参与方协同工作，依次对门电路求值，将秘密分享输入转换为秘密分享输出。然而，在基于电路的多方计算模型下，不同协议将输入转换为输出的方式不太相同，可以基于信息论安全模型下转换，也可以基于密码安全模型下转换。&lt;/p&gt;&lt;p&gt;我们认为这两类协议可以涵盖大多数框架的基础协议。在理论层面，大多数理论密码学家用非常有限的运算操作定义MPC协议，涉及的运算操作只包含模整数下的加法和乘法，或者逐比特与预算和异或运算。这两类运算操作都是图灵完备的，任何函数都可以用这两种运算操作表示。然而，在实际中我们需要为代数模型下的除法、比较等公共函数定义更优的子协议，这样我们就不用把所有函数都表示为基本运算操作，从而提高函数表达的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们发现有3个框架实现了特定的子协议。我们称这类协议为混合协议。在最下方，大家可以看到2个电路编译器。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当选择适当的框架时，人们需要着重考虑的是：高层语言对协议的抽象能力。不同框架都实现了协议的抽象。我们对这些高层语言展开了考察。我们测试的其中一个样例程序是内积运算。内积运算是指逐位计算乘积，再对各个结果求和。&lt;/p&gt;&lt;p&gt;Frigate是一个电路编译器，它的高层语言是非常传统的C语言风格抽象。大家可以看一下幻灯片上给出的内积运算代码实现。初始化结果变量，在向量上构建循环语句，循环中依次取出向量中的每一个元素，计算各个元素的乘积，最后对乘积求和。实现过程非常直观、通俗易懂。然而，如果你熟悉MPC，你可能会知道在线性秘密分享模型中，我们可以通过一轮交互并行处理所有的乘法运算。如果你希望得到优化后的协议，你可能就需要使用PICCO等框架了。&lt;/p&gt;&lt;p&gt;PICCO会对内积运算的乘法进行了并行优化，它们实现了一个针对内积运算的自定义算子。所以PICCO是一个混合协议框架。大家可以看到，可以用这个非常简单的自定义算子求两个任意长向量的内积结果。即使你不熟悉密码学，也可以很方便地直接使用自定义算子，你也不需要关注底层到底做了什么。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，如果你是一个密码学家，你想实现一个比内积更复杂的函数，你可能会希望对生成的电路做更深度的控制和修改。这种情况下，你可能会使用ABY这样的框架。ABY是一个端到端框架，在C语言上实现了一个函数库。大家可以看到，我们用一个share类管理秘密数据。我们随后放置一个乘法门，ABY会帮助我们实现乘法的并行优化。我们需要一个乘法门对整个向量逐位计算乘法。随后，我们把向量展开，对所有乘法运算结果求和。这可以给我们更大的自由，实现我们想实现的函数。但如果你对密码背景不熟悉，你可能就不想具备这些自定义的能力。这就是我们考察的前后端高层语言的范围。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们下一个想讨论的内容是这些框架的一些限制。正如我前面提到的，软件工程是这些框架中最主要的问题。大家一定要记住，大多数框架都是在学术研究场景下开发的。因此，这些框架在工程落地时会有很多的限制。在我讲解下面内容的过程中，大家要把这一点牢记于心。&lt;/p&gt;&lt;p&gt;最主要的痛点是构建系统。系统的整个构建过程非常复杂。你需要从源代码层面编译特定版本的OpenSSL库，这就要花费很长的时间，或者你需要建立一个自定义的证书认证机构，从而建立秘密通信信道。光编译每一个框架平均就要花费我们1-2周的时间。这个过程苦不堪言。但是大家很幸运，我们已经把编译好的环境放在了Docker仓库里，所以大家不需要再重复一遍此项工作了。&lt;/p&gt;&lt;p&gt;在系统构建之上，要使用这些软件框架项目，我们还需要很多的软件开发工作。正确实现密码学协议已经很困难了，但在这之上，开发者还需要实现很多支持系统，例如分布式通信、用安全语言实现与其它通信系统的交互。这方面的结论虽然比较细节，但仍然令人沮丧。例如，在ObliVM中，我们无法编写一个返回结果超过32比特的计算函数。我们可以通过进一步的代码开发来解决这个问题。由于框架都是在学术层面上开发的，框架在实现层面上都不太完美。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个比较严重的问题是可用性，尤其是文档比较匮乏。如幻灯片所示，我们定义了5类文档，一半框架都缺失了至少3类文档。我这里不详细介绍每一类文档的细节，而是想给大家展示几个例子，从而证明语言文档的缺失极大地影响框架的可用性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;语言文档指的是描述如何使用高层语言的文档。CBMC-GC是一个电路编译器，可以将代码编译成乱码电路。大多数人都熟悉C语言。假设我们要实现这样一个简单的程序：把两个数直接相乘。这个代码感觉上是正确的。然而，我们会得到一个编译错误：我们忘记返回一个值。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上，在CBMC-GC中，计算过程中的所有秘密输入的变量名都需要以input开头。这根本不算是一个问题，但是并没有文档说明这一点，我们有必要告诉大家。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个例子来自于ObliVM，这是一个将类Java语言作为高层语言的端到端框架。与前面相同，我们的程序是计算两个数的乘积，但我们碰上了解析错误。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;事实上，Alice和Bob是此高层语言中的保留关键词。因此，我们不能把这两个词作为变量名。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Wisteria是开发编程语言的人所撰写的端到端框架。此框架使用函数式语言来描述计算函数。此框架包含了一个详尽的语言指南，告诉大家如何使用函数式语言编写计算函数。然而，语言文档没有考虑到解析器的限制要求。开发者需要在代码中放置很多的括号，编译器才能编译通过。&lt;/p&gt;&lt;p&gt;EMP-toolkit是一个我们非常喜欢使用的框架。这是一个基于乱码电路的框架。然而，我们发现平均600行代码才会有1行注释，并且没有单独的代码解释文档。这些问题都会导致框架难以使用。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，有一些框架的文档工作做得很好，我真挚地感谢这些框架的作者。对于那些维护一个较大开源项目框架的开发者，我想给出两个重要的建议。&lt;/p&gt;&lt;p&gt;第一个建议是，即使针对不同方面的很简单的文档，也会大幅提高框架的可用性。不同类型的文档指的是，可能有一个文档解释框架的架构，另一个文档是带注释的样例程序，演示一些高层语言的特性。&lt;/p&gt;&lt;p&gt;第二个建议是在线资源，例如提供一个邮件列表或在GitHub上开启问题追踪。这是一个持续生成、持续更新框架文档的好方法。问题追踪就像一个在线问答平台，这样你就不用通过邮件重复回答相同的问题了。问题追踪也是用户之间相互交流的平台，他们可以互相回答遇到的问题。如果你不再想维护你的框架，用户仍然可以相互讨论，解答相应的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;即使有这些工程和可用性方面的问题，MPC框架的实现情况还是非常乐观的。我们可以在框架上实现很多样例程序。总体来说，实现过程还是很顺利的。社区也发现了框架可用性的问题。IARPA HECTOR项目正在赞助下一代MPC框架的实现。在赞助中，它们专门提出了可用性评价标准。&lt;/p&gt;&lt;p&gt;我们强烈建议后续的开发者们可以与编程语言研究者合作。大多数框架都是由密码学家实现的，因此前后端语言的设计可能不是很规范。编译器经验充分的开发人员介入，会对语言设计有更好的帮助。&lt;/p&gt;&lt;p&gt;插播一条广告，我们仍然在积极维护我们的代码仓库，我们随时准备接受新框架、已有框架的提交请求。如果你在维护其中一些框架，或者想在学术项目中使用这些框架，建议看看此代码仓库。&lt;/p&gt;&lt;p&gt;最后一条广告，我们在寻找MPC的落地项目，如果你是潜在合作方，如果你有一个有趣的项目，请稍后与我们联系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢。&lt;/p&gt;&lt;p&gt;（主持人）非常感谢。如果有问题的话，请用麦克风提问。&lt;/p&gt;&lt;p&gt;（提问者）你好，首先非常感谢你们所做的工作。社区迫切需要你们所做的工作，这个工作非常令人激动。我知道你们完成了这一概览性的工作。你们也得到了一些好的结论，一些不好的结论。但你们没有给出类似这样的结论：这是正确的框架，社区应该在这个框架的基础上继续构建，或者类似的结论。这样的结论可能会非常重要，因为如果没有这样的结论，最后的情况可能就是：哦不，这里有12个标准，我们要尝试构建一个标准，然后我们就得到了第13个标准。你能给出类似这样的结论吗？&lt;/p&gt;&lt;p&gt;（演讲人）当然可以。在论文中，我们明确给出了建议，推荐使用哪些框架。如果你在为某个特定场景寻求建议，我这里可以给出4个不同场景下的推荐。对于乱码电路框架来说，Obliv-C是一个不错的通用框架。如果你一些密码学专业知识，EMP-toolkit会更适合你。SCALE-MAMBA最适合多参与方场景，或者说这是一个混合协议框架。因此，这是最好的线性秘密分享协议框架。此框架的适用性很广泛，更新仍然很活跃。如果你有特定的安全需求，你可能会对Sharemind感兴趣，这是唯一一个付费开发者维护的框架，而且开发者是学术领域的研究人员。这就是我给出的推荐建议。&lt;/p&gt;&lt;p&gt;（主持人）谢谢，我绝对也会开发一个将Alice和Bob作为保留关键词的编程语言，这太酷了。再次感谢你的精彩演讲。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-04-72119587</guid>
<pubDate>Fri, 04 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>安全机器学习：可扩展隐私保护机器学习系统</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-04-54108699.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/54108699&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d93ddfcf2db7be0818d187a604cfada4_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;2019年10月04日更新：重新上传了视频，将讲解内容的幻灯片截图和每页幻灯片对应的演讲内容附在了文章中。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;引言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这次为各位知友带来的视频是Yupeng Zhang在2017年信息安全旗舰会议《Security &amp;amp; Privacy》上的论文演讲，论文的题目是《安全机器学习：可扩展隐私保护机器学习系统》（SecureML: A System for Scalable Privacy-Preserving Machine Learning）。&lt;/p&gt;&lt;p&gt;这篇论文是数据安全技术领域的一位好朋友向我推荐。他建议我仔细阅读论文，有相关想法就一起讨论。可惜的是，目前我的日常工作和前沿数据安全技术关系比较小，因此论文阅读的进度比较慢。在浏览了讲座视频后，我初步感觉应用安全多方计算（Secure Multi-Party Computation，SMPC）技术解决数据流转，特别是B2B场景下的数据流转，是未来一个非常重要、也是值得深挖的方向。因此，我先把视频听译并分享出来，希望有更多的知友了解到这个领域。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//eprint.iacr.org/2017/396&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cryptology ePrint Archive: Report 2017/396&lt;/a&gt;&lt;/li&gt;&lt;li&gt;视频链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DCQxwdqzlgWI&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SecureML: A System for Scalable Privacy-Preserving Machine Learning&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av57764994/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av57&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;764994/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/S%2520%2526%2520P/S%2520%2526%2520P%25202017/SecureML%2520-%2520A%2520system%2520for%2520scalable%2520Privacy-Preserving%2520Machine%2520Learning&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/S%20%26%20P/S%20%26%20P%202017/SecureML%20-%20A%20system%20for%20scalable%20Privacy-Preserving%20Machine%20Learning&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;解释论文工作更全面的PPT：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//legacydirs.umiacs.umd.edu/~zhangyp/presentations/SecureML.pptx&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;legacydirs.umiacs.umd.edu&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/~zhangyp/presentations/SecureML.pptx&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;背景知识：安全多方计算及其问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;安全多方计算要研究的问题是：在无可信第三方的情况下，多个参与方如何安全地计算一个约定函数的输出结果。以安全多方计算提出者姚期智院士的百万富翁问题为例：有两个百万富翁Alice和Bob，他们相对比一下互相之间谁的资产更多，但又不想向对方透露自己的资产数额。在这个场景下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;百万富翁Alice的输入为Alice的资产量A。&lt;/li&gt;&lt;li&gt;百万富翁Bob的输入为Bob的资产量B。&lt;/li&gt;&lt;li&gt;约定的函数为：如果A&amp;gt;B，返回1，如果A&amp;lt;B，返回-1，否则返回0。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在完成计算后，Alice（Bob）获得了约定函数的计算结果，但无法得知B（或者A）的具体值。&lt;/p&gt;&lt;p&gt;在当前互联网场景下，各个公司都拥有海量的数据，但是尚不能完成数据之间的安全流转。安全多方计算协议的应用很可能解决此类问题，各公司在不对外明确提供数据的条件下，与其它公司共同完成数据计算，从而得到更好的数据计算结果。&lt;/p&gt;&lt;p&gt;目前，密码学家已经提出了多个实现任意函数的安全多方计算协议。从理论上讲，给定任意一个函数，我们都可以构造一个安全多方计算协议。然而，目前提出的安全多方协议有如下几个尚未解决的问题：（1）实现比较复杂的计算任务时效率较低（如实现高次多项式求值）；（2）安全多方计算协议会引入比较大的通信开销。目前来看，通用优化方案寻找起来相对比较困难。但在特定的计算场景下，是否可以找到比较好的优化方案，是一个非常有意思的研究领域。&lt;/p&gt;&lt;p&gt;本论文就在特定计算场景下实现了安全多方计算的优化。针对线性回归、逻辑回归、神经网络训练问题，本论文给出了优化方案，并通过理论证明和实际验证说明了方案的可行性。&lt;/p&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1163514753825185792&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic3.zhimg.com/v2-ede09ee76003acc48921f38a200ae85e.jpg&quot; data-lens-id=&quot;1163514753825185792&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic3.zhimg.com/v2-ede09ee76003acc48921f38a200ae85e.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1163514753825185792&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4c98c7868fff134bb50c7f654527d938_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-4c98c7868fff134bb50c7f654527d938_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4c98c7868fff134bb50c7f654527d938_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-4c98c7868fff134bb50c7f654527d938_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4c98c7868fff134bb50c7f654527d938_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家好，我是Yupeng Zhang，来自马里兰大学。今天。我要讲解我们撰写的论文：《安全机器学习：一个可扩展隐私保护机器学习系统》。这个工作由我和来自VISA研究院的Payman共同完成。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6721477e54585b952b82531819340465_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-6721477e54585b952b82531819340465_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6721477e54585b952b82531819340465_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-6721477e54585b952b82531819340465_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-6721477e54585b952b82531819340465_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现今，机器学习已被用在各个领域中，且引发了各个领域的变革。例如，机器学习可以用于图像处理、语音识别、异常检测、甚至下围棋。机器学习之所以在实际中的应用效果如此之好，是因为我们使用了大量的数据来训练机器学习模型。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c16fee1577c6e9d6eed416a8bc824874_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c16fee1577c6e9d6eed416a8bc824874_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c16fee1577c6e9d6eed416a8bc824874_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c16fee1577c6e9d6eed416a8bc824874_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c16fee1577c6e9d6eed416a8bc824874_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;虽然机器学习引发了变革，此技术也引入了安全问题：我们应该如何保护数据的隐私性？这里需要澄清一点，这里所指的隐私性与前面讲座中的隐私性不太相同。这里我们考虑的是用于训练机器学习模型的数据，如何保证这些数据的隐私性。毕竟作为终端用户，我们不想向公司分享我们的数据，让它们可以运行机器学习算法。我们应该如何解决这个问题？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9cce75892926c59bca8ef71d5c7b97fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9cce75892926c59bca8ef71d5c7b97fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9cce75892926c59bca8ef71d5c7b97fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9cce75892926c59bca8ef71d5c7b97fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9cce75892926c59bca8ef71d5c7b97fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;隐私保护机器学习为这类安全问题提供了一个解决方案，它允许公司执行相同的机器学习算法，但不需要得知用户的实际数据。这样一来，用户仍然可以获得机器学习算法带来的益处，同时可以实现数据隐私保护、不将数据泄露给公司。隐私保护机器学习研究领域已经有了很多的前置学术成果，幻灯片上列举了其中一些论文。这是一个非常前沿，进展速度很快的研究领域。&lt;/p&gt;&lt;p&gt;在我们的论文中，我们聚焦于下述安全模型：双服务器模型。在这个模型中，我们假定两个服务器分别属于两个不同的公司。两个服务器不会实施共谋攻击。作为终端用户，我们首先将数据拆分成两个分享值，分别将分享值发送给两个服务器。这样，单一服务器无法得到原始数据任何信息，因为它只能得到其中一个分享值。随后，两个服务器互相交互，执行两方安全计算，生成机器学习模型。这一安全模型的优点在于，首先，此模型将多方安全计算过程归约为两方安全计算过程，以此大幅提高计算效率。其次，上传数据后，用户即可处于离线状态，模型训练过程中用户不需要与服务器交互。此模型也可以解决下述问题：两个公司想共同训练模型，但不想将数据分享给对方。很多前置学术成果都使用了这一安全模型。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3082c37176c3af3a720265eb8ef3f408_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-3082c37176c3af3a720265eb8ef3f408_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3082c37176c3af3a720265eb8ef3f408_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-3082c37176c3af3a720265eb8ef3f408_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3082c37176c3af3a720265eb8ef3f408_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;本篇论文的主要贡献是，在此安全模型下，我们提出新的协议，支持隐私保护线性回归、逻辑回归、神经网络。特别地，我们综合使用了秘密分享、预计算三元组代数运算、以及混淆电路技术。从实现角度看，我们的系统与前置工作相比，效率有了量级上的提升。我们的系统支持大数据集模型训练，可以支持百万量级的数据集，五千个特征。本次讲座，我们主要关注线性回归和逻辑回归。相关技术可以推广到神经网络模型训练中，大家可以阅读我们的论文，以了解更多的技术细节。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-41652e8cfd49e1d648fc31518e3dad28_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-41652e8cfd49e1d648fc31518e3dad28_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-41652e8cfd49e1d648fc31518e3dad28_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-41652e8cfd49e1d648fc31518e3dad28_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-41652e8cfd49e1d648fc31518e3dad28_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先，什么是线性回归？假设我们将数据点和与之相关的结果值画在图中，如幻灯片所示。线性回归要根据图中的点，尝试拟合出一条与点尽可能吻合的线。形式化地讲，输入是数据值对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 。这里 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 可以是一个向量，我们也称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 为特征值。 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 是一个单值，我们也称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 为标签值。输出的模型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+w&quot; alt=&quot;\vec w&quot; eeimg=&quot;1&quot;/&gt; 是一个系数向量，其维度大小与输入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 的维度大小相同。我们要求 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+w&quot; alt=&quot;\vec w&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 的内积结果应该与y值非常近似。实际上，模型定义了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 之间的线性关系。&lt;/p&gt;&lt;p&gt;为了训练模型，我们这里引入随机梯度下降算法，简称SGD算法。我们把这个问题看成一个最优化问题，尝试找到一个最佳模型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+w&quot; alt=&quot;\vec w&quot; eeimg=&quot;1&quot;/&gt; ，使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y%5E%2A&quot; alt=&quot;y^*&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 的距离取得最小值。算法首先将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+w&quot; alt=&quot;\vec w&quot; eeimg=&quot;1&quot;/&gt; 初始化到一个随机位置上。随后，算法从数据集中选取一个随机样本。算法根据当前模型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+w&quot; alt=&quot;\vec w&quot; eeimg=&quot;1&quot;/&gt; 计算预测值，并将结果与正确的标签值进行比较。比较结果将告诉算法，应该往哪个方向移动，以得到最优解。可以证明，如果重复上述步骤，最终模型会收敛到最优位置。这就是SGD算法。&lt;/p&gt;&lt;p&gt;对于线性回归这一特殊算法，更新函数可以用幻灯片上的公式表示。正如大家所看到的，更新公式非常简单，更新公式只涉及到乘法运算和减法运算。因此，一种很自然地实现隐私保护线性回归的方法是，将秘密分享与分享值代数运算直接应用到线性回归算法上，这应该可以解决隐私问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0bb0bd37729f445e18a3c10f08a94ed8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-0bb0bd37729f445e18a3c10f08a94ed8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0bb0bd37729f445e18a3c10f08a94ed8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-0bb0bd37729f445e18a3c10f08a94ed8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-0bb0bd37729f445e18a3c10f08a94ed8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;整个场景描述如下。用户首先将数据和标签值进行秘密分享。服务器随机初始化模型，同样对模型执行秘密分享。随后，我们直接应用预计算的三元组，一遍又一遍地在分享值上执行更新函数，这就能解决问题了。但这里有一个很大的问题，因为秘密分享和分享值代数运算只能在整数域上执行，例如在模质数下的整数域执行，但只有当参数带小数时，线性回归和SGD算法才能正确执行。我们如何在整数域上实现带小数的运算？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-61c24ce104b5bd979ebb4602ce96dda6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-61c24ce104b5bd979ebb4602ce96dda6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-61c24ce104b5bd979ebb4602ce96dda6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-61c24ce104b5bd979ebb4602ce96dda6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-61c24ce104b5bd979ebb4602ce96dda6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这就引出了我们的第一个贡献。我们给出了一种方法，可以在整数域上直接执行带小数乘法。具体思想如下。考虑存在两个幻灯片上所示的带小数点的数，我们知道这两个数对应的明文。随后，在不丧失计算精度的条件下将两个数相乘，我们可以得到结果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 的小数部分为原来的2倍。这里我们假定整数部分足够大，不会超过有限域的范围。如果不考虑小数点，小数部分的乘法运算和整数部分的乘法运算完全一致，这很不错。问题在于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 会变长，如此计算下去， &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 的长度会越来越长，最终超过整数域的范围，导致溢出。解决此问题的一种直观方法是进行截断，即直接扔掉 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 的小数点最后几位。这样一来， &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 的长度就和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 、 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;/&gt; 相同了。这一方法称为定点乘法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9ff86746686645d10ad92c790d729f54_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9ff86746686645d10ad92c790d729f54_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9ff86746686645d10ad92c790d729f54_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9ff86746686645d10ad92c790d729f54_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9ff86746686645d10ad92c790d729f54_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在论文中我们证明：可以在分享值上应用相同的截断技巧。具体来说，这里我们有两个服务器上分享的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;/&gt; ，也就是说，这两个数分别被一个大整数域上的大随机数所遮盖。随后，我们应用预计算三元组执行乘法操作，得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 的分享值，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_0&quot; alt=&quot;c_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1&quot; alt=&quot;c_1&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_0&quot; alt=&quot;c_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1&quot; alt=&quot;c_1&quot; eeimg=&quot;1&quot;/&gt; 中编码了全精度乘法计算结果。随后，两个服务器分别独立地对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_0&quot; alt=&quot;c_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1&quot; alt=&quot;c_1&quot; eeimg=&quot;1&quot;/&gt; 进行截断，此过程不引入任何通信开销。我们证明截断后，应用两个分享值仍然可以以很高的概率恢复出定点乘法的计算结果，只不过计算结果的最后一位小数上会增加一个非常小的误差值。这就是我们的技术方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2541e0fe3f6f1307a264c58853b10eec_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-2541e0fe3f6f1307a264c58853b10eec_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2541e0fe3f6f1307a264c58853b10eec_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-2541e0fe3f6f1307a264c58853b10eec_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2541e0fe3f6f1307a264c58853b10eec_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;回到协议层面上，应用此技术方案，每一次乘法运算中，我们都对结果分享值简单截断，这样就完成了整个隐私保护线性回归协议的实现。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b93bd666ce96e03cc107f6b766a8a143_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b93bd666ce96e03cc107f6b766a8a143_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b93bd666ce96e03cc107f6b766a8a143_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b93bd666ce96e03cc107f6b766a8a143_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b93bd666ce96e03cc107f6b766a8a143_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里向大家展示截断技术的应用效果。由于此技术只在计算结果的最后一个比特中引入了非常小的噪声，因此整个计算过程的执行时间几乎和在明文上应用小数执行整个计算过程的时间相同。具体来说，在各种不同的场景下，我们所提出的技术要比定点乘法混淆电路快4-8倍。线性回归部分就这些内容。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b1df5c578a2d6070d526a954c34ce7d1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-b1df5c578a2d6070d526a954c34ce7d1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b1df5c578a2d6070d526a954c34ce7d1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-b1df5c578a2d6070d526a954c34ce7d1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b1df5c578a2d6070d526a954c34ce7d1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;下一部分，逻辑回归。逻辑回归主要用在分类问题上，我们要尝试将数据分成两个类型。形式化地讲，逻辑回归中的数据值对和线性回归相同。但在逻辑回归中， &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 是一个比特值，取值为0或者1，分别表示两种分类结果。&lt;/p&gt;&lt;p&gt;逻辑回归和线性回归的区别是，我们要在内积结果上进一步执行一个额外的函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f&quot; alt=&quot;f&quot; eeimg=&quot;1&quot;/&gt; ，此函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f&quot; alt=&quot;f&quot; eeimg=&quot;1&quot;/&gt; 一般称为激活函数。逻辑回归中的激活函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f&quot; alt=&quot;f&quot; eeimg=&quot;1&quot;/&gt; 为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B1%2Be%5E%7B-u%7D%7D&quot; alt=&quot;\frac{1}{1+e^{-u}}&quot; eeimg=&quot;1&quot;/&gt; ，函数图像如幻灯片所示。&lt;/p&gt;&lt;p&gt;我们仍然可以使用SGD算法来训练模型。令人惊讶的是，逻辑回归的更新函数几乎与线性回归完全相同，唯一的区别是我们要在内积结果上额外调用一次激活函数f。更新函数的其它地方都与线性回归完全相同。这意味着如果我们可以通过安全多方计算的方式计算函数f，我们就可以把这个计算过程应用到原始线性回归协议中，即可实现逻辑回归。但事实证明，这会面临巨大的挑战，因为函数f涉及到精确到小数的自然对数求幂。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97be932c275c66b2c23331bf46004a4a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-97be932c275c66b2c23331bf46004a4a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97be932c275c66b2c23331bf46004a4a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-97be932c275c66b2c23331bf46004a4a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97be932c275c66b2c23331bf46004a4a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如何实现此计算过程？传统方法是应用所谓的多项式近似方式。幻灯片给出了10阶多项式近似激活函数f的图像。正如大家所看到的，近似图像与逻辑回归激活函数非常接近，但是通过安全计算方式实现近似函数的计算，会引入较大的计算开销，因为我们至少需要执行10次乘法计算，才能完成10阶近似多项式的计算过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-03cf6704ad1088671c35ad928a245f5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-03cf6704ad1088671c35ad928a245f5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-03cf6704ad1088671c35ad928a245f5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-03cf6704ad1088671c35ad928a245f5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-03cf6704ad1088671c35ad928a245f5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在我们的论文中，我们重点考虑，激活函数的作用究竟是什么？因为我们要解决的是分类问题，我们实际需要的是一个值域为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B0%2C1%5D&quot; alt=&quot;[0,1]&quot; eeimg=&quot;1&quot;/&gt; 的激活函数，并且此函数在0点附近应该大幅递增。那么，我们能不能用这样一个函数作为激活函数？我们证明，把此函数作为激活函数，所得模型的准确性和原始逻辑回归函数准确性相同。但更重要的是，我们可以应用混淆电路高效地通过安全多方计算方式实现此激活函数。此激活函数只涉及到减法运算和与0比大小，后者本质上是查看最高位比特值是否为0。&lt;/p&gt;&lt;p&gt;因此，这引出了我们论文的另一个贡献。我们提出了一个新的概念：适用于安全多方计算的激活函数。我们不再通过已有方法近似计算激活函数，我们后退一步，思考我们到底需要满足何种条件的激活函数。随后，我们尝试提出一个新的激活函数，其可以高效地通过多方安全计算的方式实现。回到协议中来，我前面也讲到，我们只需要执行和线性回归相同的协议。在计算内积结果后，我们转换到混淆电路上计算激活函数的结果，再切换回原始协议中。这就是隐私保护逻辑回归的完整协议了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-796f835b0d3c9b9650841246d01b3a1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-796f835b0d3c9b9650841246d01b3a1d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-796f835b0d3c9b9650841246d01b3a1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-796f835b0d3c9b9650841246d01b3a1d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-796f835b0d3c9b9650841246d01b3a1d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还在论文中引入了一些其它的优化方法，如向量化，即所有计算过程都可以用矩阵形式表示。这种方式可以大幅提高计算效率。进一步，这一技术可以推广到神经网络训练中。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cf0b00452707e7093ed008a3af8054fc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cf0b00452707e7093ed008a3af8054fc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cf0b00452707e7093ed008a3af8054fc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cf0b00452707e7093ed008a3af8054fc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cf0b00452707e7093ed008a3af8054fc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后，我给大家讲解我们的实验结果。我们在包含10万条数据、每条数据包含500个特征的数据集上进行了实验。我们的协议可以很自然地分为2个阶段。第一个阶段是与数据无关的离线阶段，此阶段要生成乘法三元组。第二个阶段是在线阶段，此阶段要训练算法。&lt;/p&gt;&lt;p&gt;在局域网环境下，网络带宽为1.2GB/s，网络时延为0.17ms。协议的离线阶段需要花费大约400秒。协议的在线阶段执行速度非常快，只需要花费1.4秒，只比明文数据训练慢2倍。&lt;/p&gt;&lt;p&gt;在广域网环境下，网络带宽为9MB/s，网络时延为72ms。离线阶段大约要花费9000秒，在线阶段要花费141秒。即使在广域网环境下，我们系统的执行效率也要比前置工作快54倍。&lt;/p&gt;&lt;p&gt;进一步，我们观察到离线阶段是我们系统的性能瓶颈。我们进一步提出了一个替代方案，在用户的帮助下生成乘法三元组。应用这一方案，我们可以大幅降低离线阶段的时间开销，稍稍提高在线阶段的时间开销。不过此方案会减弱系统的安全模型。如果应用此方案，我们需要进一步假设客户端不与任意一个服务器实施共谋攻击。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-87fb0a4865bf486be9a0ebc5c646d3ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-87fb0a4865bf486be9a0ebc5c646d3ad_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-87fb0a4865bf486be9a0ebc5c646d3ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-87fb0a4865bf486be9a0ebc5c646d3ad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-87fb0a4865bf486be9a0ebc5c646d3ad_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接下来是逻辑回归的实验结果。正如我前面所讲到的那样，我们协议的一大优势在于，与线性回归相比，逻辑回归不会额外使用更多的预计算乘法三元组。因此，逻辑回归离线阶段时间消耗与线性回归离线阶段的时间消耗相同。在线阶段，我们需要进一步执行一次混淆电路，并引入一次额外的信息交互，额外增加的时间消耗如幻灯片所示。总消耗时间与线性回归仍处在同一个量级。据我们所知，这是在此安全模型下第一个实现隐私保护逻辑回归的研究成果。此系统可以支持100万条数据集，每条数据集包含5000个特征。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3506e296911e54bcf75803779e2a594c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-3506e296911e54bcf75803779e2a594c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3506e296911e54bcf75803779e2a594c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-3506e296911e54bcf75803779e2a594c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3506e296911e54bcf75803779e2a594c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后是神经网络。我们实现了包含2个隐藏层，每层包含128个神经元的神经网络。这里我们直接给出端到端的性能测试结果。综合考虑了在线阶段和离线阶段，在局域网环境下，训练此神经网络的时间大约为25,000秒，训练所消耗的时间是明文训练所消耗时间的35倍。在广域网环境下，性能会变得更加糟糕。对于此量级的数据集，总训练时间约为200,000秒。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fd9a25e319b65dfca10473fb7e8f0113_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-fd9a25e319b65dfca10473fb7e8f0113_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fd9a25e319b65dfca10473fb7e8f0113_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-fd9a25e319b65dfca10473fb7e8f0113_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-fd9a25e319b65dfca10473fb7e8f0113_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后是总结。本文提出了一个新的协议，实现隐私保护线性回归、逻辑回归、神经网络。特别地，我们引入了一种新的方法，可以直接在整数域下实现带小数乘法。我们提出了一个容易通过安全多方计算方式实现的激活函数。我们引入了向量化优化方式。从实现角度看，我们系统的执行效率比前置工作高几个数量级，可以支持大数据集训练。这就是我讲座的全部内容了，谢谢大家。&lt;/p&gt;&lt;p&gt;主持人：台下有两个麦克风，听众可以用麦克风提问。&lt;/p&gt;&lt;p&gt;提问者：我来问个问题。在SGD算法下，你们给出了三个技术提高了安全多方计算场景下SGD算法的效率。你是否可以介绍一下，每个技术分别对算法提供了多大的优化量？&lt;/p&gt;&lt;p&gt;主讲人：我们在论文中给出了详细的基准测试结果。简单总结一下，与通用方案相比，每个独立的技术都将算法速度提高了10倍左右，但需要把这几个技术组合起来使用。例如，带小数乘法运算不能用在混淆电路上，你只能在分享值代数计算过程中应用带小数乘法计算的相关优化技术。把各技术综合起来，算法的总执行效率会提高好几个量级。&lt;/p&gt;&lt;p&gt;提问者：非常感谢。&lt;/p&gt;&lt;p&gt;提问者：你好，我是John Percival，来自罗切斯特大学。我有个很简单的问题。你们是通过仿真完成的广域网实验，还是在真实的广域网环境下完成的实验？&lt;/p&gt;&lt;p&gt;主讲人：我们在亚马逊的机器上实现了我们的方案。一台机器位于美国东海岸，一台机器位于美国西海岸。因此，这是个真实的实验，没有仿真过程。&lt;/p&gt;&lt;p&gt;提问者：好的，谢谢。&lt;/p&gt;&lt;p&gt;主讲人：好的。&lt;/p&gt;&lt;p&gt;主持人：我们再次对演讲者表示感谢。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-04-54108699</guid>
<pubDate>Fri, 04 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Ouroboros：可证明安全的权益证明协议</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-04-43005995.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43005995&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4b90b274ea0062a31690c5d092b90f1d_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;2019年10月04日更新：重新上传了视频，将讲解内容的幻灯片截图和每页幻灯片对应的演讲内容附在了文章中。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;演讲视频简介&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;今天给各位知友带来另外一个存货视频《Ourboros：可证明安全的权益证明协议》。替代工作量证明机制（Proof of Work，PoW）的权益证明机制（Proof of Stake，PoS）已经成为了区块链领域的一个重点研究方向。与PoW相比，PoS具有下述优势（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Proof of Stake FAQs&lt;/a&gt;）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不需要消耗大量的电力来保证区块链的安全性。&lt;/li&gt;&lt;li&gt;由于不需要大量电力消耗，参与方不需要得到更多的代币奖励即可参与到网络中。&lt;/li&gt;&lt;li&gt;权益证明的使用可以进一步在区块链中引入博弈论机制，从而形成市场经济体制。&lt;/li&gt;&lt;li&gt;降低系统中心化的风险。&lt;/li&gt;&lt;li&gt;有能力应用经济学惩罚措施使得51%的攻击代价变得更高。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;以太坊权益证明机制优势的原始英文描述如下，供参考：&lt;br/&gt;1. &lt;b&gt;No need to consume large quantities of electricity&lt;/b&gt; in order to secure a blockchain (e.g. it&amp;#39;s estimated that both Bitcoin and Ethereum burn over $1 million worth of electricity and hardware costs per day as part of their consensus mechanism).&lt;br/&gt;2. Because of the lack of high electricity consumption, there is &lt;b&gt;not as much need to issue as many new coins&lt;/b&gt; in order to motivate participants to keep participating in the network. It may theoretically even be possible to have &lt;i&gt;negative&lt;/i&gt; net issuance, where a portion of transaction fees is &amp;#34;burned&amp;#34; and so the supply goes down over time.&lt;br/&gt;3. Proof of stake opens the door to a wider array of techniques that use game-theoretic mechanism design in order to better &lt;b&gt;discourage centralized cartels&lt;/b&gt; from forming and, if they do form, from acting in ways that are harmful to the network (e.g. like &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;selfish mining&lt;/a&gt; in proof of work).&lt;br/&gt;4. &lt;b&gt;Reduced centralization risks&lt;/b&gt;, as economies of scale are much less of an issue. $10 million of coins will get you exactly 10 times higher returns than $1 million of coins, without any additional disproportionate gains because at the higher level you can afford better mass-production equipment, which is an advantage for Proof-of-Work.&lt;br/&gt;5. Ability to use economic penalties to &lt;b&gt;make various forms of 51% attacks vastly more expensive&lt;/b&gt;to carry out than proof of work - to paraphrase Vlad Zamfir, &amp;#34;it&amp;#39;s as though your ASIC farm burned down if you participated in a 51% attack&amp;#34;.&lt;/blockquote&gt;&lt;p&gt;PoS的这些优势使得著名区块链平台以太坊（Ethereum）都宣布要用PoS代替PoW，并且已经提出了两种替代方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;综合使用PoS和PoW的协议：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ethereum/research/blob/master/papers/casper-basics/casper_basics.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Casper the Friendly Finality Gadget&lt;/a&gt;，由Vitalik Buterin（以太坊创始人）和Virgil Griffith提出。&lt;/li&gt;&lt;li&gt;不应用PoW，完全的PoS协议：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ethereum/research/blob/master/papers/CasperTFG/CasperTFG.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Casper the Firendly GHOST: Correct by Construction&lt;/a&gt;，由Vlad Zamfir提出。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但是，如何构造一个可证明安全的PoS机制是区块链社区、也是学术界研究的一个重点方向。在密码学最顶级的会议CRYPTO 2017上，Aggelos Kiayias、Alexander Russell、Bernardo David、Roman Oliynykow给出了一个证明安全的PoS协议：Ouroboros。而本次带来的视频，就是论文作者之一Aggelos Kiayias在CRYPTO 2016会议上的论文演讲视频。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;相关信息&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文下载链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//eprint.iacr.org/2016/889.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2016/88&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;9.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DfBKCbhX-dXI%26t%3D983s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=fBKCbhX-dXI&amp;amp;t=983s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av70033085/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av70&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;033085/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;中文字幕视频&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;知乎已经支持长视频的上传，我们也就没有必要将一个视频拆分为两个了。视频经过了一轮校对，修改了几个错字。&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1163474128312201216&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic2.zhimg.com/v2-93a05431754cd2ef75de353fcbb8add1.jpg&quot; data-lens-id=&quot;1163474128312201216&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-93a05431754cd2ef75de353fcbb8add1.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1163474128312201216&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5e55c07180c8823e104c147d8e672711_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-5e55c07180c8823e104c147d8e672711_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5e55c07180c8823e104c147d8e672711_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-5e55c07180c8823e104c147d8e672711_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5e55c07180c8823e104c147d8e672711_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;感谢大家前来聆听本会场的最后一个讲座，这一天确实比较漫长。在本讲座中，我将向大家介绍Ouroboros，一个可证明安全的权益证明协议。这是我和Alexander Russell、Bernardo David和Roman Oliynykov的工作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c21f8755cf4bda8ac94c58c9e704740d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-c21f8755cf4bda8ac94c58c9e704740d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c21f8755cf4bda8ac94c58c9e704740d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-c21f8755cf4bda8ac94c58c9e704740d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c21f8755cf4bda8ac94c58c9e704740d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;既然大家来到本会场听讲座，应该已经了解我们想实现的账本目标了。我们的目标是构造一个协议，实现一个健壮的交易账本。这是由Juan Garay、我、以及Nikos Leonardos提出的目标，论文缩写为GKL，我们给出了形式化定义。这就是我们的目标，这也引出了其它一些后续工作。这些工作对模型进行了精炼，给出了更好的定义。一些工作也出现在本会场前面的讲座中。我们现在可以认为，我们最终得到了一个基于仿真的、可组合的目标定义。一旦有了设计目标，有了很明确的方向，我们就会问这样一个问题：我们是否知道实现这一目标的最佳方法？而本会场最后这个讲座的目标就是要回答这个问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-738b5f1ab18e932a09fd0de9d9b23740_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-738b5f1ab18e932a09fd0de9d9b23740_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-738b5f1ab18e932a09fd0de9d9b23740_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-738b5f1ab18e932a09fd0de9d9b23740_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-738b5f1ab18e932a09fd0de9d9b23740_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们知道，可以通过比特币等其它我所引用的前人工作所提到的技术来实现账本目标。但我们也知道，在现实生活中执行的协议效果告诉我们，目前实现的账本目标具有扩展性差、能源消耗多等缺点。我们是否可以用一种更高效的方法实现账本目标？至少到目前为止，我们有一个称为权益证明的思想。比特币社区早在2011年就提出了这个想法，这可能是一种设计高效账本记录方式的方法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e590a082723faaea39bf54f5631bda1c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-e590a082723faaea39bf54f5631bda1c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e590a082723faaea39bf54f5631bda1c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-e590a082723faaea39bf54f5631bda1c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e590a082723faaea39bf54f5631bda1c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;权益证明的基本思想和技术背景是什么呢？前面其它学者的讲座中也强调，可以认为比特币执行过程的核心目标是实现选举过程。下一个区块是通过选举来产生的。某个协议参与方，也就是矿工，会被选择上，有权利对链进行扩展。被选择上的概率正比于参与方计算哈希值的能力。同时，全网通过一定的规则来解决碰撞问题。一般使用最长链规则或最大难度链规则。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-850656bbb240318bef016ca7c8c2be08_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-850656bbb240318bef016ca7c8c2be08_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-850656bbb240318bef016ca7c8c2be08_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-850656bbb240318bef016ca7c8c2be08_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-850656bbb240318bef016ca7c8c2be08_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;权益证明背后也遵从类似的思想，但权益证明使用实体所拥有的权益来完成选取。个体拥有的权益同样体现在账本上。权益证明将个体的权益考虑其中，通过随机化过程选举出下一个扩展链的实体。从某种角度上看，这一过程的基本逻辑也反应出当前现实生活中协议的执行逻辑，因为在现实生活中，我们可以用资金来购买哈希计算能力，通过投入更多的资金 你可以提高在系统中被选择上的概率。但权益证明从某种程度上看舍弃了协议执行过程中物理层面的印记，直接使用区块链本身记录的权益作为实体选举过程的参考，用于对区块链进行扩展。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2367110a07c9df17a00943df65f086eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-2367110a07c9df17a00943df65f086eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2367110a07c9df17a00943df65f086eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-2367110a07c9df17a00943df65f086eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2367110a07c9df17a00943df65f086eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以按照我们感兴趣的两个维度，对所有的协议进行分类。图中y轴表示执行协议的性能或消耗的能量高低，越大表示性能越好，能量消耗越低。x轴表示协议支持的去中心化程度。当同时考虑这两个因素时，我们可以认为我们的目标是实现一个账本。一方面我们已经有了中心化的数据库，很容易知道此数据库位于图中的左上角。我们也有比特币，它位于图中的右下角，更去中心化，但能源消耗很大。还可以直接将其它业务场景下的协商协议引入账本。我们可以看到，这种账本与比特币相比更加中心化，并且效率比中心化数据库低。毕竟在中心化数据库中，单一节点失效会使得全节点失效。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3460399bbb5e0cc2e5d15591e664c44d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-3460399bbb5e0cc2e5d15591e664c44d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3460399bbb5e0cc2e5d15591e664c44d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-3460399bbb5e0cc2e5d15591e664c44d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3460399bbb5e0cc2e5d15591e664c44d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果我们可以设计出权益证明协议，至少我们认为其有希望位于图中的右上角，因为权益证明协议会比通过协商协议实现的账本更加去中心化，因为权益的分布情况会随时间的变化而变化。但同时，协议可以实现每一次心跳都生成一个区块。如果执行协议的参与方变得特别多，协议的执行结果也不会变得太过糟糕。如果能实现这样一个协议，我们就既可以做到去中心化，又可以做到协议高效执行。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e92e61dd072c56d972ad8f2183d64a6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-e92e61dd072c56d972ad8f2183d64a6d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e92e61dd072c56d972ad8f2183d64a6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-e92e61dd072c56d972ad8f2183d64a6d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e92e61dd072c56d972ad8f2183d64a6d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在最早期刚提出权益证明思想的时候，人们认为权益证明有可能达成上述目的。但很快，人们就意识到，设计权益证明协议会遇到很严重的挑战。第一个挑战是存在所谓的“粉碎攻击”，因为选举过程成为了一个可计算协议，并且选取过程也会反应在区块链上，与比特币工作量证明协议相比，攻击者可以绕过协议的理想执行过程。部分实体可能利用其计算能力使协议的执行结果发生偏斜，使结果对自己有利。所有基于权益证明的区块链协议都会面临粉碎攻击问题。另一个被广泛研究的权益证明协议攻击方法称为“无权益风险”攻击。这一攻击反应的事实是，权益拥有者没必要严格按照协议对指定的链进行扩展。权益拥有者可以尝试同时扩展多个链。最后，权益证明还面临一个循环的问题。从某种角度看，我们在区块链上执行一个协议，产生随机量。但与此同时，协议的安全性也就不得不依赖于区块链。因此，如果要证明协议的安全性，我们要绕开随机量生成与区块链安全性的约束关系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-973dca3199eca3da1a27eaaf5847d333_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-973dca3199eca3da1a27eaaf5847d333_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-973dca3199eca3da1a27eaaf5847d333_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-973dca3199eca3da1a27eaaf5847d333_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-973dca3199eca3da1a27eaaf5847d333_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这就是我们的境地。现在的问题是，是否可以只使用权益证明思想实现我们期望的账本目标？我们简单论述一下协议。假定全网是同步的，时间按轮数进行划分，每一轮称为一个时间槽。网络中的每一条消息都可以在全网扩散。在前面的两个讲座中，大家应该也看到过与之相同的网络模型。攻击者非常激进，这意味着攻击者掌握了很多攻击能力。他可以传递消息、篡改消息、在消息中注入自己想要的内容、重排列消息接收顺序，可以将一些消息只发送给部分参与方，可以拒绝将自己接收的消息发送给别人。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f9e2c0d12183127ae9dc77bab8dde043_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-f9e2c0d12183127ae9dc77bab8dde043_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f9e2c0d12183127ae9dc77bab8dde043_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-f9e2c0d12183127ae9dc77bab8dde043_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f9e2c0d12183127ae9dc77bab8dde043_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在这样的场景下，我们首先来看看我们协议的执行过程。这是协议执行的第一步。此时我们需要假设权益是静态的。我们拥有固定量级的权益拥有者。每一位权益拥有者的权益都在最开始时初始化好。每一位权益拥有者都拥有特定的权益量。权益量是预定义好的，权益拥有者的权益量写在创始区块中。创世区块还包含一个种子。可以认为这个种子是一个随机字符串。种子可以为每一个时间槽随机选择并指派一个所谓的领导者。这个领导者将负责在特定的时间槽内生成区块。对于每一个时间槽，只有一个实体负责生成区块。由于种子包含在创始区块中，因此系统已经确定好每一个时间槽所对应的领导者了。时间槽领导者的采样权重源于权益拥有者所拥有的权益分布。这意味着拥有的权益越多，权益拥有者越有可能被选为特定时间槽的领导者。除此之外，整个选举过程是独立随机的。现在，协议开始执行。所有权益拥有者拥有一个公钥和一个私钥，用于生成数字签名。现在，对于每一个时间槽，协议的执行过程都非常简单。每一个时间槽都指定了一个领导者，这个领导者将生成一个区块。但是，实际中实体并不会严格执行此协议。例如，某个时间槽领导者可能处于离线状态，他也可能被攻击者所控制，拒绝执行协议。此种情况下，整个协议仍然继续执行。参与方会根据最长链规则扩展前一个区块。协议非常简单，和比特币基本完全一致，但参与方不需要在解决困难问题了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0d0d6300fa7e7f7a31f2c1986bd5f70_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-c0d0d6300fa7e7f7a31f2c1986bd5f70_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0d0d6300fa7e7f7a31f2c1986bd5f70_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-c0d0d6300fa7e7f7a31f2c1986bd5f70_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c0d0d6300fa7e7f7a31f2c1986bd5f70_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;整个协议非常简单。但如何分析这个协议呢？幻灯片给出了我们对协议的安全性分析方法。我们需要了解的第一个重要目标是所谓的“特征字符串”。特征字符串的长度与系统执行过程涉及到的时间槽数量一致。当时间槽归属诚实实体，则对应字符为0。如果归属恶意实体，则对应字符为1。注意到参与方本身无法知道特征字符串的取值，但我们可以观察协议执行过程和攻击者的执行策略获取特征字符串的取值。假定幻灯片上给出的就是协议执行过程中生成的特征字符串，我们来看看协议是如何执行的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-04c5cb9a016f53e68fa3440409d26f39_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-04c5cb9a016f53e68fa3440409d26f39_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-04c5cb9a016f53e68fa3440409d26f39_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-04c5cb9a016f53e68fa3440409d26f39_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-04c5cb9a016f53e68fa3440409d26f39_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;根据协议执行过程，我们可以定义一个区块树，我们称之为“分叉”，可以通过特征字符串生成这一区块树。最开始的特征字符为0，对应的是创始区块。我们假定创始区块的参与方总是诚实的。现在，我们有了第一个时间槽。一个诚实的参与方生成了区块1。接下来，我们看到了一个关联了攻击者的时间槽。不失一般性，攻击者不一定非要在轮到他操作的一瞬间就采取行动。攻击者可以等待，当时间槽将要切换到诚实参与方操作的时候再采取行动。攻击者可以执行下述攻击行为：控制时间槽2的攻击者将产生一个区块，使得诚实参与方将在3的位置生成区块。现在，区块链将会分为两个分支。因此，这个诚实参与方将会沿着上面的分支进行扩展。我们称此现象为一个尖叉。整个攻击过程会导致区块链出现3个分支，而攻击者可以规划整个攻击方式，他可以强制沿着中间分支扩展区块链。我们来看看位置5所发生的事情。在这一时刻，攻击者控制了时间槽4，他在下方生成区块，并告知时间槽5关联的参与方。注意到此参与方会发现，包含创始区块在内，中间和下方两个分支的长度都为3。由于攻击者可以控制消息的发送顺序，他可以说服参与方在5的位置扩展区块链。攻击者随后通过类似的方法在6的位置扩展区块链。最后，攻击者说服参与方在9的位置生成新的区块。我们观察到的结果是，前面所描述的简单协议，其实际执行结果可能非常复杂。这是因为攻击者可以控制诚实参与方，使其对区块链上不同的位置进行扩展。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1e5349d537befcfb3a482f0f8d27406d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-1e5349d537befcfb3a482f0f8d27406d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1e5349d537befcfb3a482f0f8d27406d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-1e5349d537befcfb3a482f0f8d27406d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-1e5349d537befcfb3a482f0f8d27406d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这会出现什么问题呢？从工作量证明开始。我们已经广泛研究了共识机制。如何从共识机制角度考虑此协议？正如所见，我们面临的情况和工作量证明不太一样。首先，攻击者的攻击难度会大幅降低。与基于工作量证明的协议执行过程相比，攻击者更容易实施攻击。为什么？因为攻击者可以事先知道哪个权益拥有者将会被激活。攻击者可以在不付出任何代价的前提下，在相同的时间槽中创建多个不同的区块。这与比特币的执行机制不同。在比特币中，攻击者需要投入计算资源来扩展区块链，但现在情况不一样了。最后，攻击者可以等到快到诚实节点行动的时候再采取行动。当时间槽指向攻击者自己时，他完全可以先等待，不采取任何行动。他可以等到诚实节点激活的时候再采取行动。他可以根据情况采取最佳攻击策略。因此，攻击者不需要提前告知其想如何扩展区块链。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c9db570bec62ce361f85ae446dd3ba6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-c9db570bec62ce361f85ae446dd3ba6d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c9db570bec62ce361f85ae446dd3ba6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-c9db570bec62ce361f85ae446dd3ba6d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c9db570bec62ce361f85ae446dd3ba6d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们来观察一下特征字符串。幻灯片给出了两个特征字符串。在协议实际执行过程中，特征字符串的可能性有指数多个。攻击者更喜欢看到哪个特征字符串呢？大家可以看到，很明显攻击者不喜欢结果为000的特征字符串。攻击者无法对这种特征字符串对应的区块链实施任何攻击。区块按顺序组织，没有分叉。另一方面，看看这个特征字符串00110001。攻击者完全可以对这个特征字符串对应的区块链实施攻击，我们称其为可分叉的。攻击者如何实施攻击？大家可以看看，为何我们称此字符串是可分叉的呢？仔细看看当前区块链的状态。如果你是下一个被激活的诚实参与方，你该如何行动？我们来看看会发生什么。大家可以看到，攻击者有明确的自主权，决定产生分叉的时间上限和时间下限。这是因为上方分叉的长度为5，下方分叉的长度为4，但是攻击者控制着此时间槽。因此，当你作为诚实参与方生成区块时，你沿着哪个分叉进行扩展完全由攻击者决定。这种情况下，攻击者可以成功实施攻击。此特征字符串比较糟糕，我们称其为可分叉。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23d6071afc168e2ea32458bdb3081987_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-23d6071afc168e2ea32458bdb3081987_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23d6071afc168e2ea32458bdb3081987_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-23d6071afc168e2ea32458bdb3081987_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-23d6071afc168e2ea32458bdb3081987_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里的核心点在于，如果我们随机选择一个特征字符串，其可分叉的概率有多大？这就是安全性分析的核心点。为了明白这一点，我们需要引入两个很有帮助的参数，两个参数分别称为到达量和边缘量。我们首先要关注的是所谓的封闭分叉。封闭分叉指的是分叉的结尾区块与一个诚实参与方关联，区块树的叶子节点是一个诚实参与方。注意，我们不需要考虑结尾区块与攻击者关联的分叉，因为攻击者随时可以在适当的时间在与攻击者关联的分叉后方填充任意区块。对于一个封闭区块，我们可以定义两个很有用的参数。第一个参数是保留量，其表示攻击者可以在后方增加多少个区块。幻灯片上，上方分叉的保留量是3，因为后面有三个时间槽是属于攻击者的。例如，当诚实参与方在第3时间槽上激活时，攻击者可以保留3个区块，并增加到后方。同时，还可以定义另一个参数，称为间隔量，表示此分支成为主链所需的时间。&lt;/p&gt;&lt;p&gt;如果我们用保留量减去间隔量，我们就定义了所谓的到达量。这个量告诉我们，此分叉需要多长时间才能成为主链。在我们的概率分析中，到达量和边缘量是两个非常重要的参数。好消息是，组合这几个参数后我们可以知道，如果一个特征字符串是可分叉的，当且仅当存在一个封闭区块，此区块的边缘量为0，或者至少为0。而边缘量指的是我们取最长链的到达量，将最长链的到达量与第二长链的到达量进行对比，并且计算这两个链到达量的差，我们应用到达量和边缘量建立了概率分析模型。&lt;/p&gt;&lt;p&gt;我们会发现，当新的权益拥有者增加区块时，到达量和边缘量构成了随机游走过程。当特征字符为1时，表示此时间槽被攻击，此时到达量和边缘量都增加了1。另一方面，当特征字符为0时 到达量和边缘量都会降低。这一过程反应在幻灯片最下方的这行公式上。如果事实真的如此，则到达量和边缘量构成简单的随机游走过程，但实际的协议执行过程中，只有最下方情况到达量和边缘量都会降低。在处于最下方情况时，到达量和边缘量都会降低。但实际上，到达量不可能降低到小于0。如果到达量是0，则到达量保持为0，因为到达量描述了攻击者的攻击优势。这个迭代公式中非常有趣的一点是，如果边缘量为0，则到达量会降低，因为攻击者可以在牺牲到达量的条件下对边缘量进行补偿。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-994232fa10530a7b1bed4fc4b60fd047_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-994232fa10530a7b1bed4fc4b60fd047_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-994232fa10530a7b1bed4fc4b60fd047_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-994232fa10530a7b1bed4fc4b60fd047_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-994232fa10530a7b1bed4fc4b60fd047_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，如果我们应用这个迭代公式，并且将此迭代公式应用在时间槽领导者采样实验中，我们实际上会得到一个二维随机游走过程。这个二维随机游走过程实际上非常简单，到达量和边缘量会交替为正或者为负。因此，这两个变量会构成一个简单的随机游走过程。但当到达量为正时，边缘量会降低，直到固定为0。因此，这个二维随机游走过程体现出了边缘量和到达量之间的相互关系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6eebc838015b7790dbcd00d2bb5c9e42_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-6eebc838015b7790dbcd00d2bb5c9e42_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6eebc838015b7790dbcd00d2bb5c9e42_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-6eebc838015b7790dbcd00d2bb5c9e42_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6eebc838015b7790dbcd00d2bb5c9e42_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在我们要考虑的问题是，当在这个随机游走过程中随机取一个长特征字符串，则最终得到边的边缘量至少为0的概率是多少？我们可以证明，这一情况出现的概率非常小，等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-%5Csqrt%7Bn%7D%7D&quot; alt=&quot;2^{-\sqrt{n}}&quot; eeimg=&quot;1&quot;/&gt; 乘以一个常数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d05a464763088403b8595dd4244dff0f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-d05a464763088403b8595dd4244dff0f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d05a464763088403b8595dd4244dff0f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-d05a464763088403b8595dd4244dff0f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d05a464763088403b8595dd4244dff0f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;关键点在于，我们可以把二维空间划分为3个区域，分别称为热区、脆弱区、冷区。脆弱区指的是边缘量和到达量的取值都接近为0，这实际上就是初始化状态。我们还有冷区 此时边缘值为负，此种情况下区块链是安全的。我们还有热区，此时区块链是不安全的。我们可以证明，在游戏开始时我们的初始状态为脆弱状态。从脆弱状态转移到热状态的概率无限接近于0，为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-%5Csqrt%7Bn%7D%7D&quot; alt=&quot;2^{-\sqrt{n}}&quot; eeimg=&quot;1&quot;/&gt; 。但从脆弱状态转移到冷状态的概率为常数。核心观察结论在于，一旦转移到了冷状态，则区块链将永远为冷状态，也就是说，随机游走过程的位置已经远离脆弱区和热区，我们是安全的。由于转移到热区的概率是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-%5Csqrt%7Bn%7D%7D&quot; alt=&quot;2^{-\sqrt{n}}&quot; eeimg=&quot;1&quot;/&gt; ，而转移到冷区的概率是常数，我们要做的是把时间划分成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Csqrt%7Bn%7D&quot; alt=&quot;\sqrt{n}&quot; eeimg=&quot;1&quot;/&gt; 个区域，证明在任意一个处理过程中，区块链都会有很高的概率从脆弱状态转移到冷状态，这意味着我们是安全的。最后，这意味着获得一个可分叉特征字符串的概率也是可忽略的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0c512ba97b9c67d864d9d28e9f1b7563_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-0c512ba97b9c67d864d9d28e9f1b7563_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0c512ba97b9c67d864d9d28e9f1b7563_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-0c512ba97b9c67d864d9d28e9f1b7563_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0c512ba97b9c67d864d9d28e9f1b7563_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有了这样一个基础协议，我们可以进一步设计出权益动态变化下的协议。在权益动态变化的条件下，我们要做的是在特定数量的时间槽中执行基础协议。当然，我们要假定创始区块初始化了一个随机种子。现在，假定我们有一个神奇的锚点，当区块链生成到给定的锚点时，我们可以得到一个新的种子，从而重新根据权益拥有者的权益分布生成新的记账顺序。到达锚点后，锚点会给我们另一个种子，我们用这个种子重新分配记账顺序。我们需要利用区块链自身的特性来更新权益拥有者的记账概率分布，而新的记账概率分布由一系列交易执行过程后，各个参与方的新权益量所决定。也就是说，我们根据区块链的一部分记录结果，应用锚点重新生成种子，然后再用新的种子创建更新后的权益拥有者记账概率分布，协议继续执行下去。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-95f6ed294841d11c690d6ea8f6b2866d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-95f6ed294841d11c690d6ea8f6b2866d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-95f6ed294841d11c690d6ea8f6b2866d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-95f6ed294841d11c690d6ea8f6b2866d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-95f6ed294841d11c690d6ea8f6b2866d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当然了，在现实生活中我们没有这样一个可信锚点，这么解决这个问题呢？答案是利用G.O.D，即保证“产出交付的硬币投掷”。“保证产出交付的硬币投掷”，或称G.O.D硬币投掷，可以确保输出的随机性。其基本意思是，如果协议的大多数执行方都是诚实的，则保证输出结果是无偏随机种子。我们要做的是要执行一小段时间的基础协议，产生一部分区块片段，这样我们就可以执行G.O.D硬币投掷协议，从而为下一个纪元产出一个随机种子。整个协议执行过程需要应用一个称为公开可验证密钥协商协议的工具，而我们可以通过简单的密码学工具构建公开可验证密钥协商协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-00aeab008d141d5227b7c705ff35c14a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-00aeab008d141d5227b7c705ff35c14a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-00aeab008d141d5227b7c705ff35c14a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-00aeab008d141d5227b7c705ff35c14a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-00aeab008d141d5227b7c705ff35c14a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;应用上述提到的所有工具和协议，我们最终证明账本可以达到目标。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0a9bbd1a013db7acf7329d10ff2ac76f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-0a9bbd1a013db7acf7329d10ff2ac76f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0a9bbd1a013db7acf7329d10ff2ac76f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-0a9bbd1a013db7acf7329d10ff2ac76f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0a9bbd1a013db7acf7329d10ff2ac76f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;虽然我没有时间讲解整个证明的细节，但我们可以通过理论证明，假定攻击者具有一定程度的适应性攻击能力，则Ouroboros协议的公共前缀、链质量、链生长速度等的错误率都是k的可忽略函数，这意味着可以用Ouroboros实现一个健壮的交易账本。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bfc7079a178aa3081ddff3b7a5ede2bb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-bfc7079a178aa3081ddff3b7a5ede2bb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bfc7079a178aa3081ddff3b7a5ede2bb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-bfc7079a178aa3081ddff3b7a5ede2bb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bfc7079a178aa3081ddff3b7a5ede2bb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt; 我在本次讲座中没时间讲解论文的全部内容了，各位可以在论文中发现一些其它成果。除了上述协议之外，我们还设计出了一个基于权重的激励模型。我这里跳过这几页幻灯片，我们直接来看最后的结论吧。我们证明，在Ouroboros协议上执行所设计的激励奖励机制可达到近似纳什均衡，而且与比特币相比，我们的激励机制与协议是完全兼容的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8efe4930a987dd381deeed5fae753dbe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-8efe4930a987dd381deeed5fae753dbe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8efe4930a987dd381deeed5fae753dbe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-8efe4930a987dd381deeed5fae753dbe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-8efe4930a987dd381deeed5fae753dbe_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;进一步，我们设计实验测试了协议的性能，具体结论在这页幻灯片上。我们在亚马逊云上用40个节点运行了实验。我们实现了协议，并测试了协议的性能。大家可以看到，权益证明协议可以达到良好的性能。在这种简单的协议实现下，每秒确认的交易数量可以达到250个，大家可以把这个结果和每秒确认7、8、或者9个的比特币协议进行对比。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2382731de9641da1c019d84164fac2ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-2382731de9641da1c019d84164fac2ad_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2382731de9641da1c019d84164fac2ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-2382731de9641da1c019d84164fac2ad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2382731de9641da1c019d84164fac2ad_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;后续工作中，我们将解决本工作尚没有解决的问题。后续工作将解决半异步、或者部分同步网络，攻击者合谋条件下的协议设计问题。这个工作是我和Bernardo David、Peter Gazi和Alexander Russell一起完成的，大家可以在ePrint上读到此篇论文。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-39f33f7e35e9d8d44b59f30c840c745f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-39f33f7e35e9d8d44b59f30c840c745f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-39f33f7e35e9d8d44b59f30c840c745f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-39f33f7e35e9d8d44b59f30c840c745f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-39f33f7e35e9d8d44b59f30c840c745f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这些也是后续工作，大家在网上可以找到演讲视频。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d84722498c325ac5fca8d61d7e774f7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-5d84722498c325ac5fca8d61d7e774f7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d84722498c325ac5fca8d61d7e774f7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-5d84722498c325ac5fca8d61d7e774f7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-5d84722498c325ac5fca8d61d7e774f7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;讲座时间快到了，这些是相关工作，大家可以在ePrint版本或会议版本找到相关文献。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dc6001ef88678ec103a0e8c506db1f71_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-dc6001ef88678ec103a0e8c506db1f71_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dc6001ef88678ec103a0e8c506db1f71_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-dc6001ef88678ec103a0e8c506db1f71_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-dc6001ef88678ec103a0e8c506db1f71_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这就是幻灯片的最后一页了，感谢大家前来聆听讲座。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;一些思考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;从数学角度看，PoS协议是可以做到可证明安全的。但是，从非数学角度看，PoS是可证明安全的吗？其核心点在于我们如何定义权益？权益到底是什么？在没有公认锚点的情况下，权益的定义一旦有问题，整个区块链的机制似乎就不成立了。在此，我仅引入“橙皮书”对Nervos创始人Jan的采访。&lt;/p&gt;&lt;blockquote&gt;2018年08月27日更新：感谢匿名知友指出的问题，对Nervos创始人Jan的访谈不是由“区块链头条”采访的，是由“橙皮书”采访并原创的，原链接为：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/giniWFxxAFGT0fr2qbZc_Q&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;对话Nervos：中国最懂以太坊的人，却选择了一条和以太坊截然不同的道路&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;知友们可以结合Jan的观点和PoS本身、再结合自己所具有的区块链相关知识，得到自己的结论：&lt;/p&gt;&lt;blockquote&gt;橙皮书：为什么不看好 PoS ？&lt;br/&gt;&lt;br/&gt;Jan：我总觉得 PoS有点问题。因为共识是要创造信任，信任是不可能自己创造自己。你想象一条蛇在咬自己的尾巴。PoS用系统自己发布的资产作为押金，去保证这个系统的安全。它没有锚定任何的东西，是漂浮在空中的。我没有看到任何的信任是通过 PoS这样的方式创造出来的。我觉得信任的创造还是要锚定能量。美元锚定是美国的军事实力。如果哪天美国没有这种军事实力，那美元的价值我觉得要打很多问号。PoW是相当于用军队锚定，PoS 是用美元锚定美元。&lt;br/&gt;&lt;br/&gt;这个问题你会思考很久。因为你可能又会想，归根到底这两种方式，好像都是用资本去锚定，因为电力本质上也是一种资本。但再想想，这两种资本好像是不太一样的。PoW 是体系外的资本。所以，PoS 我总觉得有点问题。&lt;/blockquote&gt;&lt;p&gt;那么为什么以太坊还要引入PoS呢？我个人的观点是：PoS本身的权益是漂浮在空中的，但是&lt;b&gt;如果PoS权益之前已经被认定为是一个有价值的东西（以太坊中的Eth），用一个公认有价值的东西反过来做为权益，PoS似乎就不漂浮在空中了&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;但是，Eth有价值吗？这个问题，有点深奥… 欢迎知友在评论区讨论。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-04-43005995</guid>
<pubDate>Fri, 04 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>传输短秘密值的条件下提高OT扩展协议的效率</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-08-05-76647738.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/76647738&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7b01b1ba136277a4576b00ee4b38443b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;最近收到了一位知友的私信，询问能否把《Winter School on Cryptography 2012: Lattice-Based Cryptography》的一系列字幕也发布出来，供参考和学习。经过与 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b&quot; data-hash=&quot;60a93d8892402f3493146a4fd54c5f2b&quot; data-hovercard=&quot;p$b$60a93d8892402f3493146a4fd54c5f2b&quot;&gt;@i春秋学院&lt;/a&gt; 当时字幕负责人的讨论，由于相关字幕已经发布了很长时间，我已经可以将字幕发布出来供知友们学习了！因此，在接下来一段时间，我会集中整理《Winter School on Cryptography 2012: Lattice-Based Cryptography》的字幕，重新压制视频并放出。感谢 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b&quot; data-hash=&quot;60a93d8892402f3493146a4fd54c5f2b&quot; data-hovercard=&quot;p$b$60a93d8892402f3493146a4fd54c5f2b&quot;&gt;@i春秋学院&lt;/a&gt; 一直以来的支持！&lt;/p&gt;&lt;p&gt;虽然会集中整理之前的字幕，但是我也会不断听写新的视频，如果有任何顶级安全会议中数据安全相关讲座的听译需求，还请知友们私信我，或者直接在评论区留言。对于一些很大工作量的听译工作（如《Winter School on Cryptography 2015: Practical Secure Multi-Party Computation》这类），我也会持续坚持听译，到合适的时间再对外发布，敬请知友们耐心等待。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为知友们带来的视频是CRYPTO 2013论文《Improved OT Extension for Transferring Short Secrets》。OT Extension协议是安全多方计算中最重要、也是最核心的协议。熟悉OT的知友们可能知道，OT Extension中最核心的论文应该是CRYPTO 2003的《Extending Oblivious Transfer Efficiently》以及CCS 2013的《More Efficient Oblivious Transfer and Extensions for Faster Secure Computation》。不过我一直没有找到这两个讲座的视频，如果哪位知友知道视频链接，也可以在评论区告诉我。&lt;/p&gt;&lt;p&gt;《Improved OT Extension for Transferring Short Secrets》的重要程度相对这两篇论文来说没有那么高，但这篇论文是优化GMW协议的重要理论基础。如果想实现基于GMW协议的安全多方计算应用，这篇论文的阅读和实现也是必不可少的。CRYPTO 2013对应的演讲视频介绍了《Improved OT Extension for Transferring Short Secrets》的基本思想，观看视频后再去读论文会有更深入的理解。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DAgPZVecLuXs&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=AgPZVecLuXs&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av62237491/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av62&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;237491/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/CRYPTO%25202013/Improved%2520OT%2520Extension%2520for%2520Transferring%2520Short%2520Secrets&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/CRYPTO%202013/Improved%20OT%20Extension%20for%20Transferring%20Short%20Secrets&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1141506723897516032&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png&quot; data-lens-id=&quot;1141506723897516032&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1141506723897516032&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢主持人的介绍。此工作是我与来自贝尔实验室的Vladimir Kalashnikov所共同完成的。我们工作针对的目标是安全计算，这是密码学上一个非常典型、非常普遍的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当前有很多重要的研究进展，尝试让安全计算从理论走向实际。这些工作的目标不仅是要提高协议的渐进效率，还要提高协议的真实执行效率。还有一些工作的方向是具体协议的实现，解决系统层面的问题。&lt;/p&gt;&lt;p&gt;在过去的5年，无论是理论角度还是实际角度，此领域都诞生了极多的突破性成果。从理论角度，我们得到了很多惊人的结论。我们现在只需要引入常数级额外开销，即可完成安全计算或安全函数求值。另一个突破是全同态加密。对于多种类型的函数，我们甚至可以在最优通信复杂度下构建安全计算协议。还可以使用基于ORAM的安全计算协议，利用RAM计算模型的优势完成安全计算，这样我们就能在次线性时间复杂度下完成安全计算。在实践角度，针对姚氏协议和GMW协议，学者们提出了很多算法或实现层面的优化，也尝试混合使用姚氏协议和GMW协议。特别地，姚氏协议的实现结果令人印象深刻。现在，我们可以在637毫秒内执行完AES的乱码电路。&lt;/p&gt;&lt;p&gt;虽然在实现层面和理论层面我们都得到了令人惊讶的成果，但在右侧，效率最高的协议仍然是20世纪80年代提出的姚氏协议和GMW协议。之所以这样，有一个很直观的原因：理论成果虽然引入常数复杂度，但这个常数可能非常大。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际应用时，可能存在这样一个复杂度与效率的层级关系。FHE的复杂度目前、以后也总会比公钥密码学原语的复杂度高几个量级。公钥密码学原语的复杂度目前、以后也总会比对称密码学原语的复杂度高几个量级。对称密码学原语的复杂度目前、以后也总会比一次一密的复杂度高几个量级。本次演讲的主题是OT扩展，其出发点就是减小公钥操作和对称密码操作的效率鸿沟。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在第一部分演讲中，我会详细介绍OT扩展的研究出发点，并解释OT扩展面临的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;诸如密钥协商、不经意传输等公钥密码学原语一般都很难高效实现。公钥密码学原语天生要依赖于某类代数结构，因此也会遭受很多密码学攻击。因此，相应的参数需要设置得比较大。这导致公钥密码学的计算复杂度也相对较高。另一方面，我们更容易实现伪随机数生成器或哈希函数等对称密码学运算。学者们设计出了很多算法，相应的参数要比公钥密码学小得多，实际中也可以更容易、更轻量级地实现对称密码学运算。这个结论背后还有相应的理论支撑。理论上，无法通过黑盒方式应用对称密码学原语构造大多数公钥密码学原语。这意味着公钥密码学原语和对称密码学原语的性能差约为3至4个数量级。对于诸如AES等被广泛使用的特定对称密码学操作，Intel专门提供了对应的指令集，进一步提高了这类运算的执行效率。因此，我们无法通过对称密码学原语实现公钥密码学原语。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那接下来该怎么办？或许可以用少量公钥原语实例和大量对称密码学操作，生成大量公钥实例。这一技术称为“扩展原语”。我们已经知道，很容易扩展公钥加密体制，具体过程是用对称加密算法加密具体的明文，用公钥加密算法加密对称加密的密钥。这样一来，我们只需要执行一次公钥操作。这一技术在我们每天使用的加密过程中起到了非常重要的作用。我们可以很自然地把这个问题展开：是否可以扩展其它公钥密码学原语。如OT？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;回忆一下不经意传输要解决的问题。发送方有两个输入： &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_0&quot; alt=&quot;x_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1&quot; alt=&quot;x_1&quot; eeimg=&quot;1&quot;/&gt; 。接收方有一个输入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。协议执行完毕后，发送方无法得到任何信息，接收方可以得到与其选择比特关联的发送方输入。OT是SFE的基础构建模块。姚氏电路中应用不经意传输实现了乱码密钥的2选1过程。在GMW协议中，OT的用途更加广泛，每个AND门的求值过程都要使用一次OT协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们知道OT的执行开销非常大，我们无法通过对称密码学操作实现OT。但假设我们有一个可以传输短字符串的OT，通过使用标准的伪随机数生成器，我们能得到可以传输长字符串的OT。这一技术称为“OT长度扩展”。&lt;/p&gt;&lt;p&gt;还有一个更难解决的问题，称为“OT实例扩展”，简称“OT扩展”。幸运的是，我们知道OT扩展是可行的。我们只需要 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个公钥密码学操作，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个种子OT，再加上 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 次对称密码学操作。应用这 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 次公钥密码学操作，我们就可以执行任意多项式大小次的OT操作。这一技术大幅降低了公钥密码学运算次数，对SFE的实际应用起到了重要的作用。近期大多数SFE的实现都应用了OT扩展协议，从而提高协议的执行效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Beaver在1996年提出了第一个OT扩展协议。第一个高效的OT扩展协议由Ishai、Kilian、Nissim和Petrank给出。此协议也称为IKNP协议，对应的论文发表在CRYPTO 2003上。后续，学者们期望在恶意攻击场景下提高OT扩展协议的执行效率。学者们同时也在加深对OT扩展协议的理解，从而知道OT扩展协议的上限是什么。在本工作中，我们将在半可信场景下提高IKNP协议的效率。我们给出了协议的渐进优化方法和实际优化方法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在接下来的讲座中，我们会描述Ishai等人的OT扩展协议构造。实际上，我们将直接使用Ishai等人CRYPTO 2003的演讲幻灯片。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;IKNP第一个、也是最重要的步骤是将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT归约为传输 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 比特字符串的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT。这一步骤将引入额外的、线性数量级的对称密码学操作。下一步是长度扩展步骤，我们之前已经讲解过这一步骤了。这可以让我们把长字符串OT协议归约为短字符串OT协议。这一步骤进一步引入了线性数量级的对称密码学操作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在核心归约步骤中，我们让接收方选择一个随机的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5Ctimes+k&quot; alt=&quot;n\times k&quot; eeimg=&quot;1&quot;/&gt; 矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 。随后，发送方选择一个随机的行向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;/&gt; 。接下来，接收方和发送方执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT协议，但此OT协议中两个参与方的角色互换。在每个OT协议中，接收方要选择长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 的两列比特值。每对比特值中。第一列为矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 中的某一列，第二列为第一列比特值与选择向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 的异或结果。发送方实际上应用它随机选择的行向量在接收方的两列比特值中选择一列。&lt;/p&gt;&lt;p&gt;这样，发送方通过OT协议得到了一个矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; 。我们来看看矩阵 Q 满足何种性质。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D0&quot; alt=&quot;r_i=0&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，收到的每对比特值就不太一样了。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，在IKNP协议中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i%5Coplus+s&quot; alt=&quot;q_i=t_i\oplus s&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;注意到，在第一种情况下，接收方知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+&quot; alt=&quot;t_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; 。因此，在第一种情况下，接收方能得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。在第二种情况下， 接收方能得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s+&quot; alt=&quot;q_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; ，也就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 。这意味着我们或许可以使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 作为OT协议中的数据加密密钥。但需要注意的是，我们必须要破坏矩阵中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的相互关系。我们应用随机预言机 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H&quot; alt=&quot;H&quot; eeimg=&quot;1&quot;/&gt; 来破坏 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的相互关系。最后，接收方根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 选择得到它的输出，也就是应用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 进行解密。&lt;/p&gt;&lt;p&gt;IKNP协议非常简单、非常优雅、效率极高。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们考虑 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT协议所需要的通信开销。其中发送方输入的长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L&quot; alt=&quot;L&quot; eeimg=&quot;1&quot;/&gt; 。大家已经了解到，核心归约步骤就是对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_%7Bi%2C0%7D&quot; alt=&quot;x_{i,0}&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_%7Bi%2C1%7D&quot; alt=&quot;x_{i,1}&quot; eeimg=&quot;1&quot;/&gt; 加密，这需要发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nL&quot; alt=&quot;2nL&quot; eeimg=&quot;1&quot;/&gt; 比特的数据。在长度扩展步骤中，我们要应用一个PRG，这需要发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nk&quot; alt=&quot;2nk&quot; eeimg=&quot;1&quot;/&gt; 比特的数据。&lt;/p&gt;&lt;p&gt;在姚氏电路中，我们需要传输长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3Dk&quot; alt=&quot;L=k&quot; eeimg=&quot;1&quot;/&gt; 的密钥，因此核心归约步骤和长度扩展步骤中的通信开销相同。在GMW中，我们只需要传输 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3D1&quot; alt=&quot;L=1&quot; eeimg=&quot;1&quot;/&gt; 的信息。令人惊讶的是，这一场景下长度扩展步骤的通信开销远高于核心归约步骤的通信开销。这就是一个问题了，我们可能可以在这一场景下对通信开销进行优化。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在讲座的后半部分，我们会提出IKNP的通用框架。我们也会向大家展示如何提高IKNP的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们先来详细分析一下IKNP协议。可以看到，接收方要选择这个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5Ctimes+k&quot; alt=&quot;n\times k&quot; eeimg=&quot;1&quot;/&gt; 的随机矩阵。随后，接收方要生成另一个矩阵，这个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列为第一个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列异或选择向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。换句话说， &lt;img src=&quot;https://www.zhihu.com/equation?tex=U%3D+T+%5Coplus+R&quot; alt=&quot;U= T \oplus R&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 是所有列均相等的矩阵，每个列都为接收方的选择向量。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果我们从行的视角看，就会发现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 行为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; ，这意味着 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 的每一行都是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 的一种编码。在IKNP协议中， &lt;img src=&quot;https://www.zhihu.com/equation?tex=0&quot; alt=&quot;0&quot; eeimg=&quot;1&quot;/&gt; 被映射为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=0%5Ek&quot; alt=&quot;0^k&quot; eeimg=&quot;1&quot;/&gt; ，而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 被映射为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1%5Ek&quot; alt=&quot;1^k&quot; eeimg=&quot;1&quot;/&gt; 。因此，我们可以看到IKNP这一高效协议在底层执行了一次逐行重复编码。这自然引出了一个问题：我们是否可以使用更复杂的编码？毕竟，重复编码是一种最简单的编码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;假设我们使用编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; ，并且我们假定 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 属于一个很大的域，域为从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 。我们用编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 映射成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29+&quot; alt=&quot;C(r_i) &quot; eeimg=&quot;1&quot;/&gt; ，这是一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 比特长字符串。现在，接收方需要用选择比特 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 构建矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 。我们来看看，在这个理论框架下IKNP协议的执行过程。&lt;/p&gt;&lt;p&gt;第一步，接收方获得了矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 。随后，接收方用加法秘密分享方案将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 分享为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29%3D+T+%5Coplus+U&quot; alt=&quot;C(R)= T \oplus U&quot; eeimg=&quot;1&quot;/&gt; 。接下来，接收方和发送方角色互换，执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT协议。在第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 个OT中，接收方的输入是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t%5Ei&quot; alt=&quot;t^i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u%5Ei&quot; alt=&quot;u^i&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列。执行完OT协议后，发送方得到矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; 。在IKNP协议中，我们知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 或者等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，或者等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+&quot; alt=&quot;t_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; 。在这一理论框架中，我们可以知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+%28C%28r_i%29+%5Codot+s%29&quot; alt=&quot;q_i=t_i \oplus (C(r_i) \odot s)&quot; eeimg=&quot;1&quot;/&gt; ，结果不算太复杂。&lt;/p&gt;&lt;p&gt;我们可以验证一下，当C是重复编码时 此框架对应的协议就是IKNP协议。特别地，当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D0&quot; alt=&quot;r_i=0&quot; eeimg=&quot;1&quot;/&gt; 时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29&quot; alt=&quot;C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 是一个全 &lt;img src=&quot;https://www.zhihu.com/equation?tex=0&quot; alt=&quot;0&quot; eeimg=&quot;1&quot;/&gt; 向量，因此我们得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; 时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29&quot; alt=&quot;C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 是一个全 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 向量，此时我们可以得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+s&quot; alt=&quot;q_i=t_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。这样一来，我们得到了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 个密钥。后面的执行过程就完全一样了，密钥生成算法为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+%28C%28r%29+%5Codot+s%29&quot; alt=&quot;q_i \oplus (C(r) \odot s)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们仍然可以证明接收方只能知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 。因此接收方只能解密对应的密文，从而得到对应的输入。核心归约步骤在恶意发送方的攻击下是完美安全的。特别地，恶意发送方只能得到矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; ，这是编码的随机独立分享结果。核心归约步骤在半诚实接收方的攻击下是统计安全的。这是因为除了在加密过程中使用了随机预言机之外，核心归约步骤没有安全性损失。因此，整个协议的安全性损失为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 的取值范围，以及 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-d%7D&quot; alt=&quot;2^{-d}&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=d&quot; alt=&quot;d&quot; eeimg=&quot;1&quot;/&gt; 是线性编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 的最小距离。&lt;/p&gt;&lt;p&gt;注意到在此理论框架下，我们可以从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选取消息，因此从效果上看，我们可以实现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT，而不是2选1-OT。但在这种情况下，核心归约步骤的通信开销会从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nL&quot; alt=&quot;2nL&quot; eeimg=&quot;1&quot;/&gt; 提高到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=nmL&quot; alt=&quot;nmL&quot; eeimg=&quot;1&quot;/&gt; 。随后，我们将标准的2选1-OT转换为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%2F%5Clog%28m%29&quot; alt=&quot;n/\log(m)&quot; eeimg=&quot;1&quot;/&gt; 个字符串长度稍长的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT实例，这也允许我们将通信开销表示为与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 相关的函数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我们有了一个自由变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; ，用它来平衡核心归约步骤和长度扩展步骤的开销。具体来说，如果我们使用的是最小距离为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%2F2&quot; alt=&quot;k/2&quot; eeimg=&quot;1&quot;/&gt; 的Hadamard编码，在这种情况下，2选1-OT的通信开销可以降低2倍。在多方GMW协议中，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%3D256&quot; alt=&quot;k=256&quot; eeimg=&quot;1&quot;/&gt; ，则通信开销也可以降低2倍。&lt;/p&gt;&lt;p&gt;也可以进一步优化长度扩展步骤的通信开销，此开销的优化程度是算法层面的，而不是渐进层面的。结合Hadamard编码后，与未优化的IKNP协议相比，新协议的通信开销要降低3.5倍。Asharov等人也独立发现了这一优化点，他们的论文将发表在CCS 2013上。&lt;/p&gt;&lt;p&gt;与IKNP相比，我们从渐进层面降低了每一个OT的通信开销。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3D1&quot; alt=&quot;L=1&quot; eeimg=&quot;1&quot;/&gt; 时，IKNP需要通信 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28k%29&quot; alt=&quot;O(k)&quot; eeimg=&quot;1&quot;/&gt; 比特，而我们需要通信 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28k%2F%5Clog%28k%29%29&quot; alt=&quot;O(k/\log(k))&quot; eeimg=&quot;1&quot;/&gt; 比特。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总结一下，为了平衡公钥密码学原语和对称密码学原语的性能鸿沟，学者们提出了OT扩展协议，这一协议在安全函数求值的实例落地中产生了巨大的影响。在本次讲座中，我们提出了IKNP的编码理论框架。可以在随机预言模型下证明此框架的安全性。随机预言模型也可以换为特定类型哈希函数假设，即相关性健壮哈希函数，这沿用了IKNP中安全性所依赖的相关性健壮哈希函数假设。当使用复杂编码时，此框架提高了多方GMW中2选1-OT和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT的性能。&lt;/p&gt;&lt;p&gt;我想用GMW和姚氏电路的性能对比问题作为讲座的结尾。近期的安全多方计算研究主要关注恶意模型下姚氏电路的性能优化问题。在半可信安全模型下，学者们也提出了很多姚氏电路的优化方法。但近期的一些工作也表明，GMW协议也有很多算法层面的优化点。我们的工作适用于GMW协议。谢谢大家。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-08-05-76647738</guid>
<pubDate>Mon, 05 Aug 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>ObliVM：安全计算编程框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-07-15-73618400.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/73618400&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-83f24da35d88aef9a1bc7d522f42c2cf_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;使用新的方法撰写密码学会议视频分享文章后，虽然点赞和阅读量并没有提升很多，但是根据知友们的反馈，这样做确实可以大幅度提高阅读体验。更开心的是，向知乎反馈后，知乎的工程师们也是大力配合，现在终于支持上传长度不超过60分钟的视频了，撒花庆祝！接下来的视频分享文章中，我会同时在知乎和B站上传翻译视频。知友们可以根据自己的习惯选择在哪个地方观看。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2015年安全顶级会议Security and Privacy 2015的演讲视频《ObliVM：安全计算编程框架》，对应的论文是《ObliVM: A Programming Framework for Secure Computation》。&lt;/p&gt;&lt;p&gt;上一篇文章《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot; class=&quot;internal&quot;&gt;SoK：安全多方计算通用框架&lt;/a&gt;》的视频中，作者调研了9个开源的通用安全计算框架，而ObliVM就是其中的一个。我个人对于“把Alice和Bob作为编程语言的关键词”这一点仍然记忆犹新。这一次，我们就来详细了解一下ObliVM到底是什么。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DQ2QLRcj0Mio%26t%3D92s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=Q2QLRcj0Mio&amp;amp;t=92s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av59239482/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av59&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;239482/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202015/ObliVM%2520A%2520Programming%2520Framework%2520for%2520Secure%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202015/ObliVM%20A%20Programming%20Framework%20for%20Secure%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1134043543998984192&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;ObliVM：安全计算编程框架&quot; data-poster=&quot;https://pic2.zhimg.com/v2-f3c6c88bc65211e0a5428862604b6751.jpg&quot; data-lens-id=&quot;1134043543998984192&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-f3c6c88bc65211e0a5428862604b6751.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;ObliVM：安全计算编程框架&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1134043543998984192&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）大家好，我很高兴能在这里为大家介绍我们的工作：ObliVM，这是一个安全计算的编程框架。这是我和我的队友们一同完成的工作，队友有Xiao Wang，坐在那里的Kartik，还有Yan Huang，还有Elaine Shi。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;很高兴自己在前面的一个演讲中为大家充分介绍了什么是安全计算，或安全函数求值。我这里只需给出一个简短的介绍。例如，Sheldon和Amy希望互相确认自己是不是对方的另一半。他们都相信基因匹配的效果。因此，他们可以执行一个分析过程，看看他们是否匹配。一个很关键的安全问题是：他们不想把敏感的基因数据泄露给对方。我在前面已经讲过了，安全计算是这一问题的绝佳解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以把这个问题抽象成下述形式：给定两个参与方Alice和Bob，以及他们的秘密输入&lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt;，他们希望联合计算一个公开函数&lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28x%2Cy%29&quot; alt=&quot;f(x,y)&quot; eeimg=&quot;1&quot;/&gt;，得到函数的计算结果。同时，除了计算结果&lt;img src=&quot;https://www.zhihu.com/equation?tex=z&quot; alt=&quot;z&quot; eeimg=&quot;1&quot;/&gt;外，涉及两个秘密输入的计算过程不会向对方泄露任何其它信息。这就是安全计算的概念。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家已经知道，安全计算的解决方案有姚氏乱码电路，还有GMW协议。我们关注什么地方呢？我们的关注点是：如何让安全计算能在实际中得到应用？例如，一个开发者希望开发一个安全计算应用。他们肯定不想把函数写成电路的形式。他们想用C语言、Java语言、或者Python语言编写代码。因此，源程序和安全计算协议之间存在很大的鸿沟。这就是我们ObliVM框架要做的事情。我们的ObliVM是一个工具，可以将源代码转换成实际的安全计算协议。这是ObliVM的框架概览。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里面最主要的问题是什么？Kartik已经提到，主要问题是开发人员喜欢用Python等语言模型编写代码。幻灯片左侧是开发人员撰写的源程序。但实际上，大多数安全计算协议是在电路模型下实现的。因此，在高层语言程序和电路程序之间存在很大的鸿沟。我们的问题是，如何将左侧的代码转换为右侧的协议？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢Kartik的讲解，你已经提出了我们工作的出发点。这里的关键挑战是，如何能让动态内存访问过程不泄露信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是一个不太容易解决的挑战。我们的解决方案是：把RAM模型下的问题转换到不经意RAM模型中。不经意的意思是内存访问和指令追踪过程不依赖于秘密输入。这样一来，不经意程序就可以被进一步转换为电路了。我们可以看到，在转换链路中，后一部分相对比较简单，前一部分非常有挑战性。本次讲座主要关注前一部分，解释如何做到这一点。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有一个非常平凡，也不能说非常平凡的解决方案。这个方案于2013年首先提出，基本思想是使用不经意RAM。不经意RAM，又称ORAM，可以把任意程序编译成不经意程序。基于这一思想，我们去年提出了SCVAM框架。此框架可以仿真通用ORAM。可以证明，我们的渐进性能比所有之前的解决方案都要好。这一解决方案是通用的，也很容易实现。但问题在于，这个方案可能不是最高效的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在过去的几年间，我们观察到研究人员提出了很多定制化安全计算协议。这方面的工作有很多，我实在没办法在幻灯片上把所有相关工作都列出来。这些定制化安全计算协议都很高效，可以这么说，这些协议比我们去年的工作都高效。但问题在于，这些协议的设计成本很高。例如，我们与Nina Taft聊了聊，她是我们的合作方。我们私下针对CCS 2013上面发表的隐私矩阵分解算法进行了讨论。她告诉我们，她们组织了5位研究人员，花费了大约4个月的时间才完成了全部的实现。也就是说，整个过程花费了超过1.5年的研究时间。这里涉及到巨大的工作量。我们的问题是：我们能不能做得更好？我们能否构建一个通用框架，但仍然获得定制化协议的执行效率？这就是我们ObliVM的目标。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们希望非领域专家，例如非密码学家，可以用它实现一些安全计算协议，同时获得定制化协议的执行效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何做到这一点？关键思想是：在ObliVM内部，我们提供很多编程抽象接口。我在幻灯片上具体列举了一些，如不经意数据结构、MapReduce、循环合并等。我后面会介绍其中一个抽象接口。如果想了解更多的细节，请阅读我们的论文。我还想提及的是，Kartik刚刚讲解的GraphSC论文也是一个并行计算编程接口抽象。总之，我们提供了一些编程接口抽象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我这里想简单介绍一下编程接口抽象到底是什么。我们来看看分布式计算社区。我估计绝大多数人都听说过MapReduce，这是谷歌于2004年在OSDI会议上发表的论文。在这篇论文发表之前，并行计算、或者说分布式计算，是一个很困难的任务。但通过MapReduce，开发者只需要将计算过程编码在Mapper和Reducer框架中。开发者不需要关注分布式计算方法，MapReduce框架会实现整个分布式计算过程。因此，与之前的工作相比，使用MapReduce涉及的开发工作量会非常小。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们想用与之非常类似的方法解决这一问题。我们希望提供一些抽象接口，允许开发者将计算任务编码在抽象接口中，这样他们就不需要关注底层的密码学原语，但仍然获得相同的计算性能。这就是我们的目标，这就是我们的解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何对外提供这些编程接口抽象？我们希望实现一个新的语言支持体系。例如，我们想为我们的开发者实现一个新的编程语言。在开发这个语言时，我们脑海中有两个目标。第一个目标是：领域专家或密码学家可以很容易地应用此语言实现不同的编程接口。另一方面，对于非专家来说，他们可能不是特别了解密码学技术，他们可以很容易地使用这些编程语言抽象构建他们自己的应用程序。&lt;/p&gt;&lt;p&gt;结合脑海中的这两个目标，我们的解决方案是构建新的语言特性，支持之前系统未无法支持的功能。我这里列举了一些特性，请大家阅读论文，了解相应的技术细节。后续我们会在幻灯片给出的地址上开源我们的编译器，这样大家可以更好地了解编译器的实现细节。我认为这些特性都很不错。例如，我们可以使用随机类型、虚函数等，从源代码阶段，而不是从后端原语阶段，实现不经意RAM协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有了这些编程接口抽象，开发人员该怎么做呢？例如，我们希望实现一个稀疏图算法。我们已经有了编程接口抽象这样一个武器库了。假设我们想要实现稀疏Dijkstra最短距离算法，我们可以选取适当的不经意数据结构，这里要选择不经意堆。随后，我们使用循环合并抽象实现相应的算法。通过使用这些工具，我们实现了3个不同的稀疏图算法。&lt;/p&gt;&lt;p&gt;整个流程好像都走得通，但我们得到了一个超出期望的结果：我们实现的算法从理论角度也得到了突破，所有3个算法的渐进复杂度都比当前最优算法的渐进复杂度低。这个结论令我们感到十分惊讶。如果想了解算法的更多细节，请阅读我们的论文。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;开发人员具体该做些什么呢？我在几分钟之前已经向大家许诺过了，我会为大家介绍一个编程接口抽象：循环合并。这是非常细节的内容了。在安全计算中，实现秘密循环是非常有挑战性的工作，因为循环次数本身就会泄露信息。这里我们允许编程人员编写有上界循环次数限制的循环语句。例如，我们允许协议保护循环次数，但我们要求开发人员公开告知循环次数的上限。&lt;/p&gt;&lt;p&gt;这是一个嵌套循环代码。这里有趣的地方在于，第4行到第7行的内部循环中，循环次数上界m并不是外部循环中每次迭代的最大迭代次数上界，而是两层嵌套代码中，内部循环的总执行次数上界。这样我们可以避免重复的执行过程。例如，如果我们按照传统方法给出上界，则总迭代次数是n•m，但这样设置的总迭代次数是n+m。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们的编译器会分析这段代码，自动将此类形式的代码转换成右下的代码形式。这段代码看起来像是一个状态机，这样就不会为算法引入额外的复杂度了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;应用所有这些技术以后，我们能得到什么呢？我之前已经提到，实现矩阵分解算法涉及的人力开销大约为1年1.5个研究者。如果使用ObliVM呢？结果非常令人惊讶，只需要一天就够了。一个博士研究生只需要一天就可以实现全部功能。&lt;/p&gt;&lt;p&gt;你可能会想，实现结果是否高效？可能自动化的实现结果并不高效。事实上，我们的实现的算法效率要高10到20倍，因此实现结果甚至更高效了。这就是我们现在得到的优化结果。我相信ObliVM对于所有安全计算开发者来说都是一个福音。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们深入解析一下各个优化点所带来的性能提升情况。我们这里给出的是Dijkstra算法的实现结果。论文中给出了更多的实现结果。虽然我们这里只关注ObliVM的编程语言部分，但实际上ObliVM拥有一个经过深度优化的后端ObliVM-SC。此后端代码也开源了，大家可以访问我们的网站，获取源代码链接。&lt;/p&gt;&lt;p&gt;我们实现了一个当前最优的电路ORAM，此ORAM专门为安全计算进行优化。我们将我们的系统和之前在CCS 2012上公开的最佳结果进行了对比，电路ORAM本身可以为我们带来50倍的性能提升。编程语言和编译器可以为我们带来2500倍的性能提升。我们进一步对后后端的其它部分进行了深度优化，可以在我们的论文中找到相应的技术细节描述。这些深度优化可以为我们带来7倍的性能提升。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总体来说，我们获得了大约100,000倍的性能提升，这是很大的性能提升倍数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里给大家一个更直观的方案效率描述。2012年在同一篇论文中，他们在1GB数据集上执行了二分搜索算法。一次单独问询的计算时间大约为12小时。现在情况又怎么样呢？使用我们的ObliVM框架，每次问询的执行时间仅为7.3秒。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还将我们的SCVM框架与不安全的解决方案进行了效率对比。也就是说，我们直接在计算机上执行明文程序，从而对比效率。我们计算了效率损失量，效率损失量相对还是可以接受的。对于分布式GWAS，效率损失仅为130倍。我们可以期待，未来这一数字可能会进一步降低。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有很多合作方都与我们合作，ObliVM已经在多个场景下得到了应用。我们刚刚赢得了3月份举办的基因分析竞赛，这是大约2个月前举办的竞赛。未来，我们希望在ObliVM框架的基础上实现更多的密码学计算任务，如同态加密等。&lt;/p&gt;&lt;p&gt;非常感谢大家，这就是我讲座的全部内容了，接下来我可以回答一些问题。&lt;/p&gt;&lt;p&gt;（提问者）在演讲开始阶段你给出了一个二分搜索的例子，开发人员应该怎么实现二分搜索？开发人员需要写什么代码？&lt;/p&gt;&lt;p&gt;（演讲者）你指的是哪个例子？&lt;/p&gt;&lt;p&gt;（提问者）在最开始的地方，你给出了一个二分搜索的例子，那时候你提到…&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）这张图中左侧是开发人员实现循环合并时要编写的代码。你提到了二分搜索的例子，对吧？&lt;/p&gt;&lt;p&gt;（提问者）是的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）我觉得用二分搜索举例子会比较好。开发人员要做的事情是…我们回到那页幻灯片上。在这里。&lt;/p&gt;&lt;p&gt;（提问者）就是这里。&lt;/p&gt;&lt;p&gt;（演讲者）这就是开发人员需要编写的代码…我看看这个代码能不能编译通过…是的，可以用我们的ObliVM编译器编译这个程序。编译器会自主处理内存访问过程。&lt;/p&gt;&lt;p&gt;（提问者）是的&lt;/p&gt;&lt;p&gt;（演讲者）是的，编译器会识别相应的模块，判断哪些部分要替换为ORAM，哪些部分不需要替换。&lt;/p&gt;&lt;p&gt;（提问者）ObliVM是不是有一种潜在使用方法，就是让ObliVM输出C代码，而不是电路，这样我们就可以把任意一个程序输入给ObliVM，使得程序无法被旁路攻击？&lt;/p&gt;&lt;p&gt;（演讲者）这是一个非常好的问题。一个非常有趣的事实是，我们的ObliVM编译器输出的是Java代码。&lt;/p&gt;&lt;p&gt;（提问者）明白。&lt;/p&gt;&lt;p&gt;（演讲者）随后，执行Java代码，会生成一个电路。所以我觉得你提的问题非常好。我认为未来一个很有趣的研究方向是，如何阻止ObliVM编译器遭到旁路攻击。&lt;/p&gt;&lt;p&gt;（提问者）好的，谢谢。&lt;/p&gt;&lt;p&gt;（演讲者）谢谢你。&lt;/p&gt;&lt;p&gt;（演讲者）什么？你可以使用麦克风的。&lt;/p&gt;&lt;p&gt;（合作者）我们的编译器没办法被旁路攻击。如果你直接编写类似这样的代码，编译的输出结果是通用ORAM程序。但你也可以调用我们提供的不经意数据结构。我们在不经意数据结构中实现了二分搜索树，如果直接调用不经意数据结构抽象接口，编译时间会减少log(n)倍。&lt;/p&gt;&lt;p&gt;（提问者）明白。&lt;/p&gt;&lt;p&gt;（合作者）很容易让编译器输出C代码，修改后端编译器即可。比较困难的点在于前端，如何编译得到一个高效的电路。&lt;/p&gt;&lt;p&gt;（主持人）感谢Elaine的解释。&lt;/p&gt;&lt;p&gt;（演讲者）是的，感谢Elaine。&lt;/p&gt;&lt;p&gt;（主持人）再次感谢我们的演讲者。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-07-15-73618400</guid>
<pubDate>Mon, 15 Jul 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
