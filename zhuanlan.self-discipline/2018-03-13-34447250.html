<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>递归函数（五）：递归集与递归可枚举集</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34447250">原文</a></p>
<h2><b>回顾</b></h2><p>上文中我们讨论了全函数和部分函数，以及计算的可终止性。<br>本文我们从数论函数开始，给原始递归函数集增加一种新的运算，得到了一个更大的集合。<br>然后根据递归函数，我们可以定义递归集和递归可枚举集，<br>为以后讨论可计算性与可判定性打好基础。</p><h2><b>数论函数</b></h2><img src="https://pic3.zhimg.com/v2-00ebc8699bbcc75935897546101678be_r.jpg" data-caption="" data-size="normal" data-rawwidth="415" data-rawheight="214"><p>自然数集一般记为 <equation>N=\lbrace 0,1,2,\cdots \rbrace</equation> ，那么 <equation>n</equation> 个自然数集的笛卡尔积记为 <equation>N^n</equation> ，<br>于是，我们称集合 <equation>N^n</equation> 到 <equation>N</equation> 的部分函数为<b><equation>n</equation> 元部分数论函数</b>。<br>作为数论函数， <equation>2x</equation> 是一个全函数，而 <equation>x/2</equation> ， <equation>x-y</equation> ， <equation>\sqrt{x}</equation> 只是部分函数，<br>它们的计算结果， <equation>3/2</equation> ， <equation>4-6</equation> ， <equation>\sqrt{5}</equation> 都不在 <equation>N</equation> 中，<br>于是相应定义域中的点可视为没有定义。</p><p>为什么讨论数论函数呢，其一是因为它是一个典型数学的问题，<br>另外一点，则是因为我们经常把其他数学问题转换成数论问题，例如，<a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0">哥德尔编码</a>。<br>本文中，使用数论函数，可以简化我们的描述方式。</p><p>一个<b>谓词</b>，指的是返回布尔值的函数，<br>我们还可以将谓词看做值域为 <equation>\lbrace 0,1\rbrace</equation> 的一个数论函数。<br> <equation>0</equation> 代表<code class="inline">True</code>， <equation>1</equation> 代表<code class="inline">False</code>。</p><h2><b>极小化算子</b></h2><img src="https://pic3.zhimg.com/v2-cfab5b6b86d286530c4f9ea57cb8905f_r.jpg" data-caption="" data-size="normal" data-rawwidth="235" data-rawheight="214"><p>在前一篇中，我们从三个初始函数出发，<br>通过合成运算和原始递归运算，得到了原始递归函数集，<br>递归函数集是相对于这两种运算封闭的。</p><p>然而，这样定义的原始递归函数，并不能包括所有的数论函数，<br>一个典型的例子就是，<a href="https://zh.wikipedia.org/zh/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B8">阿克曼函数</a>，</p><code lang="haskell">ackermann :: Int -&gt; Int -&gt; Int 
ackermann 0 x = x+1
ackermann k 0 = ackermann (k-1) 1
ackermann k x = ackermann (k-1) $ ackermann k x-1</code><p><b>它并不是一个原始递归函数</b>，（证略<br>因此原始递归函数集并不足以表示计算机程序中的所有函数。</p><p>为此，我们需要对原始递归函数集进行扩充，我们定义一个新的运算，称为<b>极小化运算</b>，<br>设 <equation>P(x_1,\cdots ,x_n,t)</equation> 是一个谓词，令 <equation>f(x_1,\cdots ,x_n)=min\ P(x_1,\cdots ,x_n,t)</equation> 。</p><p><equation>f(x_1,\cdots ,x_n)</equation> 的值，或者是使 <equation>P(x_1,\cdots ,x_n,t)</equation> 为真的最小 <equation>t</equation> 值，<br>或者无定义，此时不存在 <equation>t</equation> 使得 <equation>P(x_1,\cdots ,x_n,t)</equation> 为真。<br>这样通过 <equation>min</equation> 得到 <equation>f(x_1,\cdots ,x_n)</equation> 的过程称为<b>极小化运算</b>，<br>也称部分函数 <equation>f(x_1,\cdots ,x_n)</equation> 是由谓词经过极小化运算得到的。</p><p>以上我们给谓词定义了极小化运算，现在我们将极小化运算推广到一般的函数上面，<br>设 <equation>g(x_1,\cdots ,x_n,t)</equation> 是一个 <equation>n+1</equation> 元函数，令<br> <equation>f(x_1,\cdots ,x_n)=min\lbrace g(x_1,\cdots ,x_n,t)=0\rbrace</equation> <br>则称部分函数 <equation>f(x_1,\cdots ,x_n)</equation> 是由函数 <equation>g(x_1,\cdots ,x_n,t)</equation> 经过极小化运算得到的。</p><h2><b>递归函数集</b></h2><p>和定义原始递归函数集一样，我们从以下三个初始函数出发，<br>（1）零函数 <equation>n(x)=0</equation> <br>（2）后继函数 <equation>s(x)=x+1</equation> <br>（3）投影函数 <equation>u^n_i(x_1,\cdots ,x_n)=x_i</equation> ， <equation>1\leqslant i\leqslant n</equation> <br>由初始函数，经过有限次合成运算，原始递归运算，以及极小化运算，<br>得到的函数称为<b>递归函数</b>。</p><p>递归函数并不一定是全函数，因为极小化运算可能会导致结果函数在某些点无定义，<br>递归的部分函数称为<b>部分递归函数</b>。</p><p>可以证明阿克曼函数是递归函数，但不是原始递归函数，<br>因此，原始递归函数集是递归函数集的真子集。</p><h2><b>递归可枚举集</b></h2><img src="https://pic1.zhimg.com/v2-707e7082ba20ea7f7b155d8bb50da75a_r.jpg" data-caption="" data-size="normal" data-rawwidth="518" data-rawheight="353"><p>在具体实践中，我们经常会遇到这样的问题，<br>给定一个元素，我们需要判断这个元素是否属于某个集合。<br>这种问题，称为集合的成员资格问题。</p><p>沿用这一思路，我们可以使用一个谓词 <equation>\chi _B</equation> 来定义相应的集合 <equation>B\subseteq N</equation> ，<br> <equation>B=\lbrace x\in N|\chi _B(x)\rbrace</equation> <br>谓词 <equation>\chi _B(x)</equation> 为真，则 <equation>x\in B</equation> 。<br>这个谓词 <equation>\chi _B(x)</equation> ，通常称为集合 <equation>B</equation> 的<b>特征函数</b>。</p><p>如果特征函数 <equation>\chi _B</equation> 是一个递归的全函数，<br>则我们总是可以判断 <equation>\chi _B(x)</equation> 等于 <equation>0</equation> 还是 <equation>1</equation> ，<br>这样的集合 <equation>B</equation> 称为<b>递归集</b>。</p><p>如果存在部分递归函数 <equation>g</equation> ，使得 <equation>B=\lbrace x\in N|g(x)\downarrow \rbrace</equation> ，<br>即， <equation>x\in B</equation> 当且仅当 <equation>g</equation> 在 <equation>x</equation> 处有定义，<br>则称集合 <equation>B</equation> 是一个<b>递归可枚举集</b>。<br>每一个部分递归函数，都确定出一个递归可枚举集。</p><p>因此，对于每一个自然数 <equation>x\in N</equation> ，<br>我们总是可以通过递归集 <equation>B</equation> 的特征函数 <equation>\chi _B</equation> ，来判断 <equation>x</equation> 是否 <equation>B</equation> 的成员。<br>而对于递归可枚举集，就不容乐观了，<br>如果某个自然数 <equation>x\in N</equation> 是 <equation>B</equation> 的成员，那么我们可以断定这件事，因为 <equation>g(x)</equation> 有定义，<br>但是如果某个自然数 <equation>y\in N</equation> 不是 <equation>B</equation> 的成员，我们就不能确定，因为这时候 <equation>g(x)</equation> 无定义。<br>（ <equation>g(x)</equation> 无定义，则它对应的图灵机不停机，后文我们详细讨论</p><p>因此，集合 <equation>B</equation> 是递归的当且仅当 <equation>B</equation> 和 <equation>\bar{B}</equation> 是递归可枚举的，<br>其中 <equation>\bar{B}</equation> 为 <equation>B</equation> 的补集。</p><h2><b>总结</b></h2><p>本文介绍了数论函数，递归函数集，然后用递归函数分别定义了递归集和递归可枚举集，<br>可是为什么递归可枚举集是“可枚举”的呢？</p><p>是因为每一个递归可枚举集可以一一对应一个自然数，这是怎样做到的呢？<br>这需要我们理解总共有多少个可能的程序，以及什么是通用程序。</p><hr><h2><b>参考</b></h2><p><a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E9%9B%86%E5%90%88">递归集</a> <br><a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E5%8F%AF%E6%9E%9A%E4%B8%BE%E9%9B%86%E5%90%88">递归可枚举集</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
