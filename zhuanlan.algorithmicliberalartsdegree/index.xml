<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>算法少女</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/</link>
<description>一些看起来好像很酷的算法结论. 来自于UIUC理论CS PhD学生.</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 12 Jan 2018 14:52:56 +0800</lastBuildDate>
<item>
<title>震惊！有向图中的k割之王！背后的秘密居然是这样的！</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2018-01-12-32863460.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;震惊！有向图中的k割之王！背后的秘密居然是这样的！&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32863460&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c6d5b6998a4787b66f0f5296bb0dc304_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;让 &lt;equation&gt;G=(V,E)&lt;/equation&gt; 为一个无向图, 一个集合 &lt;equation&gt;F\subseteq E&lt;/equation&gt; 叫做k-cut(k割), 如果删除这个边的集合, 则新的图里至少有k个连通分量. 2-cut就是图上的割. 割在各种优化问题中都会出现, 比如计算视觉里的图像分割.&lt;/p&gt;&lt;p&gt;我们的目的是找到minimum k-cut. 就是边数最小的k-cut. (或者最小权值的k-cut, 一样的方法), 而边数最小的k割我们称之为&lt;b&gt;k割之王&lt;/b&gt;. &lt;/p&gt;&lt;p&gt;难以置信的是, 无向图上的minimum k-cut竟然是可以在多项式时间内解决的! 有兴趣知道已知算法的话可以看&lt;a href=&quot;http://chaoxu3.web.engr.illinois.edu/paper/hypergraph_k_cut.pdf&quot;&gt;最近的一篇文章里的introduction&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当然, k-cut还有其他的不同的但是在无向图上等价的定义. 比如, 一个边的集合F叫做k-cut, 如果&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;equation&gt;G-F&lt;/equation&gt; 里存在 &lt;equation&gt;k&lt;/equation&gt; 个顶点T, 使得对于任意 &lt;equation&gt;v\in T&lt;/equation&gt; ,  &lt;equation&gt;v&lt;/equation&gt; 最多能达到&lt;equation&gt;T&lt;/equation&gt;中的一个顶点.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;G-F&lt;/equation&gt; 里存在 &lt;equation&gt;k&lt;/equation&gt; 个顶点T, 使得对于任意 &lt;equation&gt;v\in V&lt;/equation&gt; ,  &lt;equation&gt;v&lt;/equation&gt; 最多能达到&lt;equation&gt;T&lt;/equation&gt;中的一个顶点.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这两个定义里的区别只有一个字符,  &lt;equation&gt;T&lt;/equation&gt; 被换成了 &lt;equation&gt;V&lt;/equation&gt; . 这两个定义在无向图里是一模一样的. 但是在&lt;b&gt;有向图&lt;/b&gt;中就不同了. &lt;/p&gt;&lt;p&gt;我们发现如果使用第一个定义的话, 在有向图里, 我们仍未知道2-cut是否是可以多项式时间内解决. 谁能做出来将获得我贡献的$100美元.&lt;/p&gt;&lt;p&gt;但是如果用第二个定义, 却可以证明对于任意常数k, k-cut可以多项式时间内解决. &lt;/p&gt;&lt;p&gt;文章以下都用第二个定义.&lt;/p&gt;&lt;p&gt;正式的说明一下问题. &lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;有向图上的最小k割问题&lt;/b&gt;&lt;br&gt;&lt;b&gt;输入:&lt;/b&gt; 一个有向图 &lt;equation&gt;G=(V,E)&lt;/equation&gt;&lt;br&gt;&lt;b&gt;输出:&lt;/b&gt;  最小的&lt;equation&gt;F\subseteq E&lt;/equation&gt; , 使得 &lt;equation&gt;G-F&lt;/equation&gt; 里存在 &lt;equation&gt;k&lt;/equation&gt; 个顶点 &lt;equation&gt;T&lt;/equation&gt; , 使得对于任意 &lt;equation&gt;v\in V&lt;/equation&gt; ,  &lt;equation&gt;v&lt;/equation&gt; 最多能达到&lt;equation&gt;T&lt;/equation&gt;中的一个顶点. &lt;/blockquote&gt;&lt;p&gt;这个看起来实际上是非常像NP-hard的问题, 但神奇的是竟然可以多项式时间内解决. 注意这里k是常数, 如果k也属于输入则是NP-hard的.&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定义:&lt;/b&gt; 对于一个有向图G, 一个顶点集合的 &lt;equation&gt;S&lt;/equation&gt; 的值是 &lt;equation&gt;f(S)&lt;/equation&gt; , 定义为有多少条边的头在 &lt;equation&gt;S&lt;/equation&gt; 里, 尾在 &lt;equation&gt;V\setminus S &lt;/equation&gt; 里.&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定理1:&lt;/b&gt; &lt;equation&gt;G&lt;/equation&gt; 里存在 &lt;equation&gt;k&lt;/equation&gt; 个顶点 &lt;equation&gt;T&lt;/equation&gt; , 使得对于任意 &lt;equation&gt;v\in V&lt;/equation&gt; ,  &lt;equation&gt;v&lt;/equation&gt; 最多只能达到&lt;equation&gt;T&lt;/equation&gt;中的一个顶点. 有且仅有存在k个互不相交的 &lt;equation&gt;V&lt;/equation&gt; 的非空子集, &lt;equation&gt;V_1,...,V_k&lt;/equation&gt; , 使得对于任意 &lt;equation&gt;i&lt;/equation&gt; , &lt;equation&gt;V_i&lt;/equation&gt; 的值为0&lt;/blockquote&gt;&lt;p&gt;k个不相交的非空集合叫做k-subpartition. 这说明了只要我们能找到k个k-subpartition  &lt;equation&gt;V_1,...,V_k&lt;/equation&gt; , 使得 &lt;equation&gt;\sum_{i} f(V_i)&lt;/equation&gt; 最小即可. 那么我们现在要解决的问题就是找最优的k-subpartition, 也就是让里面的集合的值的和最小的k-subpartition.&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定义:&lt;/b&gt; 一个集合S叫做实心的, 如果对于任意 &lt;equation&gt;\emptyset\subsetneq S&#39;\subsetneq S&lt;/equation&gt;, &lt;equation&gt;f(S) &amp;lt; f(S&#39;)&lt;/equation&gt; .&lt;/blockquote&gt;&lt;p&gt;很明显, 存在一个最优的k-subpartition, 使得里面的每一个集合都是实心的. 整个算法&lt;b&gt;背后&lt;/b&gt;最重要的&lt;b&gt;秘密&lt;/b&gt;是下面的这个定理. &lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定理2:&lt;/b&gt; 存在一颗树 &lt;equation&gt;T&lt;/equation&gt; , 使得对于任意实心集合 &lt;equation&gt;U&lt;/equation&gt; ,  &lt;equation&gt;T[U]&lt;/equation&gt; 是一颗树. 并且给定有向图G, 这棵树可以多项式时间内找到. [1]&lt;/blockquote&gt;&lt;p&gt;因为存在一个全是实心的最优解. 我们可以假设这个最优解为 &lt;equation&gt;S_1,\ldots,S_k&lt;/equation&gt; . 则我们知道存在 &lt;equation&gt;T &lt;/equation&gt; 的k-1个边, 使得删掉之后得到k个连通分量 &lt;equation&gt;U_1,\ldots,U_k&lt;/equation&gt; . 并且 &lt;equation&gt;S_i\subseteq U_i&lt;/equation&gt; . 所以我们可以尝试所有的 &lt;equation&gt;k-1&lt;/equation&gt; 个边. 最后, 有了下面的定理, 就能在给了 &lt;equation&gt;U_i&lt;/equation&gt; 的情况下找到 &lt;equation&gt;S_i&lt;/equation&gt; .&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定理3:&lt;/b&gt; 给定G和一个顶点子集U, 则可以在多项式时间找到一个包含在U里的最小值的实心集合.&lt;/blockquote&gt;&lt;p&gt;放在一起就多项式时间了.&lt;/p&gt;&lt;p&gt;定理1和3都很容易证明, 定理2比较难, 还是看paper比较好.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;P.S.&lt;/p&gt;&lt;p&gt;今年不少人觉得SODA的文章质量下降了不少啊.&lt;/p&gt;&lt;p&gt;我现在所知的信息感觉Mathematical Programming似乎是很容易发的journal啊.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;[1] &lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/S0167637704001002&quot;&gt;An algorithm for source location in directed graphs&lt;/a&gt; &lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2018-01-12-32863460</guid>
<pubDate>Fri, 12 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>洁癖朋友吃寿司卷</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-10-11-30007391.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;洁癖朋友吃寿司卷&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30007391&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ab8dd95e6824d6a17543fa68fff03242_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;这是很久远的问题了, 认识我的人应该都听过这题的样子. 但是这次在伯克利碰到两个CS本科生&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/b81d09436441d8ecbcfc90e1003ed384&quot; data-hash=&quot;b81d09436441d8ecbcfc90e1003ed384&quot; data-hovercard=&quot;p$b$b81d09436441d8ecbcfc90e1003ed384&quot;&gt;@林习习&lt;/a&gt;和另一个人时, 给了他们这个题. 因为我常用的另一个题他们竟然听过了.&lt;/p&gt;&lt;p&gt;我喜欢这种题当做面试题. 因为这题可以看人解决问题的思路. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现实模型&lt;/p&gt;&lt;p&gt;有两种寿司卷, a个红色寿司卷和b个蓝色寿司卷(a和b都可以被2整除). 填满在一个nxm的矩阵里. 所以nxm=a+b. &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e116e9c2b748b6372b78bebd187b3099_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;960&quot; data-rawheight=&quot;609&quot;&gt;&lt;p&gt;两个有洁癖的人分寿司卷. 因为寿司卷放的很紧. 用筷子夹的时候要么碰到上下两个寿司卷(如果存在的话), 要么会碰到左右两个寿司卷(如果存在的话). 而另一个人是不会吃这个人碰到的寿司卷的. &lt;/p&gt;&lt;p&gt;设计一个算法. 告诉这两个人如何轮流夹寿司卷. 使得每个人都吃到a/2个红色寿司卷b/2个蓝色寿司卷.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;某个解答的方法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们假设 &lt;equation&gt;n\leq m&lt;/equation&gt; . &lt;/p&gt;&lt;p&gt;让 &lt;equation&gt;r_i&lt;/equation&gt; 为第 &lt;equation&gt;i&lt;/equation&gt; 列的红色寿司的个数. 假设对于任意 &lt;equation&gt;i&lt;/equation&gt; , &lt;equation&gt;r_i\leq r_{i+1}&lt;/equation&gt;. 因为我们暂时不会横着夹任何东西, 所以可以有这样的assumption. &lt;/p&gt;&lt;p&gt;我们的目标是让两个人取走一样多的行.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;case 1: 存在 &lt;equation&gt;i\neq j&lt;/equation&gt; 使得 &lt;equation&gt;r_i=r_j&lt;/equation&gt; . 这样两个人各取一列. （这包含了n+1&amp;lt;m的case) 后面case假设case 1不成立.&lt;/p&gt;&lt;p&gt;case 2: 如果 &lt;equation&gt;n+1=m&lt;/equation&gt; , &lt;equation&gt;m\geq 4&lt;/equation&gt; . 则对于任意 &lt;equation&gt;i&lt;/equation&gt; ,  &lt;equation&gt;r_i = i-1&lt;/equation&gt; . 所以我们有 &lt;equation&gt;r_1 + r_m = r_2 + r_{m-1}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;case 3: 如果 &lt;equation&gt;n=m&lt;/equation&gt; ,  &lt;equation&gt;m\geq 4&lt;/equation&gt; ,  &lt;equation&gt;r_1\neq 0&lt;/equation&gt; . 则对于任意 &lt;equation&gt;i&lt;/equation&gt; , &lt;equation&gt;r_i=i&lt;/equation&gt; .  &lt;equation&gt;r_1 + r_m = r_2 + r_{m-1}&lt;/equation&gt; . &lt;/p&gt;&lt;p&gt;case 4: 如果 &lt;equation&gt;n=m&lt;/equation&gt; ,  &lt;equation&gt;m\geq 4&lt;/equation&gt; ,  &lt;equation&gt;r_1=0&lt;/equation&gt; . 则矩阵里每行都有一个蓝色的寿司卷. 我们可以红色蓝色对调并且旋转一下矩阵获得case 3.&lt;/p&gt;&lt;p&gt;case 5. n和m之间必须有一个是偶数. 现在只剩下要考虑 &lt;equation&gt;(n,m)&lt;/equation&gt; 为下列三种情况 &lt;equation&gt;\{(1,2),(2,2),(2,3)\}&lt;/equation&gt; . 利用a,b都是偶数这个属性. 可以搞定最后的几个可能.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果足够careful可以利用这个写出一个O(nm)的算法... 有点麻烦就是了...&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;更多问题:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;如果矩阵没有被摆满呢?&lt;/li&gt;&lt;li&gt;如果第一个人想吃到k个红寿司卷, l个蓝寿司卷, 第二个人要吃a-k个红寿司卷, b-l个蓝寿司卷呢? 这时对a,b的偶数要求也没有了. &lt;/li&gt;&lt;li&gt;寿司卷摆在一个nxmxr的cube里, 有两个有洁癖的四维生物用二维的筷子呢?&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;题图是游戏 Asami&#39;s Sushi Shop. &lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-10-11-30007391</guid>
<pubDate>Wed, 11 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>亲属术语以及其算法</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-08-28-25012875.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;亲属术语以及其算法&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25012875&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;美国人的亲属术语非常简单. Read就研究过它的代数结构[2]. 所有的人只有2个维度: 最近的祖先的辈分以及辈分区别. &lt;/p&gt;&lt;p&gt;只要这几个维度一样, 美国的(单个)亲属术语就无法区分他们(特别近的关系还会多一个性别). 比如&lt;b&gt;父亲的哥哥的女儿&lt;/b&gt;和&lt;b&gt;母亲的妹妹的儿子&lt;/b&gt;都是&lt;b&gt;first cousin&lt;/b&gt;. 他们各自的孩子都叫做&lt;b&gt;first cousin once removed&lt;/b&gt;.&lt;/p&gt;&lt;p&gt;在中文中, 这两个不同的关系的术语并不一样. 中文的亲属术语属于&lt;a href=&quot;https://en.wikipedia.org/wiki/Sudanese_kinship&quot;&gt;苏丹型系统&lt;/a&gt;, 也称之为描述型系统. 这个系统里面要考虑到更多的可能. 为此, Read也提出过用一个半群来描述所有&lt;i&gt;描述型系统可能区分的亲属关系.&lt;/i&gt; 叫这个&lt;b&gt;亲属半群&lt;/b&gt;. 注意这里有两个概念, 亲属术语和亲属关系. 亲属术语是用来描述亲属关系的. 可以想象亲属关系是一个抽象概念, 而亲属术语是一个字符串. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;亲属半群有4个生成元, f,m,s,d. 各自代表父, 母, 儿, 女. &lt;/p&gt;&lt;p&gt;通过这四个元素可以获得所有的亲属关系. 当我们写下一个关系, 比如ffms的时候, 意思是&quot;父亲的父亲的母亲的儿子&quot;. 用这4个生成元的字符串做出的描述叫做&lt;b&gt;标准描述&lt;/b&gt;.&lt;/p&gt;&lt;p&gt;fs就是&quot;父亲的儿子&quot;, 也就是&quot;兄弟&quot;. 当然, ms也代表兄弟. 所以同一个亲属关系的标准描述并不唯一. &lt;/p&gt;&lt;p&gt;对于任意一个定义在f,m,s,d上的字符串, f和m的sign是+, s和d的sign是-. f和s的性别一样. m和d的性别一样. &lt;/p&gt;&lt;p&gt;我们在这里定义一些相同的关系. 对于任意 &lt;equation&gt;a,b,c \in \{f,m,s,d\}&lt;/equation&gt; &lt;/p&gt;&lt;ol&gt;&lt;li&gt;abc = c, 如果abc的sign是+-+或者-+-. 比如 fdf=f (父亲的女儿的父亲=父亲) &lt;/li&gt;&lt;li&gt;ac=bc, 如果ac和bc的sign都是+-或者都是-+. 比如fs=ms (父亲的儿子=母亲的儿子), sf=df(女儿的父亲=儿子的父亲)&lt;/li&gt;&lt;li&gt;abc=a如果abc的sign是--+, 然后a和c的性别相同. 比如 ddm = d (女儿的女儿的母亲=女儿)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所有标准描述, 如果代表相同的关系, 则都能通过使用上面的几个等式获得.  &lt;/p&gt;&lt;p&gt;这个模型有一些问题, 评论里也提到了. 文末有回应. 但是当亲属关系被抽象为亲属半群之后, 就成为了一个&lt;b&gt;纯粹的数学模型&lt;/b&gt;了. 我考虑的一切都是在这模型下的世界. &lt;b&gt;和真实的一个人的亲属一点关系都没有&lt;/b&gt;. (&lt;i&gt;做理论真爽, 都不用关心模型是否正确, 有好玩的题就好...&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;想象一个正在学中文的人去见家长. 他试图描述自己的某个非常成功的亲戚和自己的关系. 由于词汇量有限, 所以只能使用他懂的词汇. 但是他想要用最少的词汇来描述这段关系, 这样可以让对方家长刮目相看. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过这么特定又明确但奇怪motivation, 可以很容易抽象出一个算法问题:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;亲属关系问题&lt;/b&gt; &lt;b&gt;输入&lt;/b&gt;: 给一个目标亲属关系x. 以及可以使用的术语集合S以及它们对应的亲属关系.&lt;br&gt;&lt;b&gt;输出&lt;/b&gt;: 用最少个数的术语描述x. (这称之为最短的描述)&lt;/blockquote&gt;&lt;p&gt;这里我们假设亲属关系的给定方法是标准描述. 也就是每一个亲属关系在输入的时候用半群的那4个生成元来表示.&lt;/p&gt;&lt;p&gt;例子&lt;/p&gt;&lt;p&gt;&lt;b&gt;输入&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;目标关系: ffffm
可用术语: {父亲 =f, 爷爷= ff, 奶奶 = fm, 母亲=m}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;爷爷的父亲的奶奶 &lt;/code&gt;&lt;p&gt;另2个可能, 但是只要能输出任意一个就好了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;爷爷的爷爷的母亲
父亲的爷爷的奶奶&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;更加极端一点的例子&lt;/p&gt;&lt;p&gt;&lt;b&gt;输入&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;目标关系: ffs
可用术语: {骉=ffddf, 儿子=s, 犇=smm}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;骉的犇的儿子&lt;/code&gt;&lt;p&gt;怎么看出来一样的? (加粗标注了用了哪个相同rule来化简)&lt;/p&gt;&lt;blockquote&gt;ffd&lt;b&gt;dfs&lt;/b&gt;mms = ff&lt;b&gt;dsm&lt;/b&gt;ms = f&lt;b&gt;fdm&lt;/b&gt;s = f&lt;b&gt;ms&lt;/b&gt; =  ffs&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;小米的内置的计算器里就有这样亲属关系的计算器, 但是遇到稍微长一点的input就不行了, 没法找到最短的表示方式.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-41880e91da9e17a2eb9423698926f1a6_r.png&quot; data-rawwidth=&quot;609&quot; data-rawheight=&quot;495&quot;&gt;&lt;p&gt;而文章题图里的三姑六婆 app也是无法解决这个问题的. (&lt;a href=&quot;https://www.zhihu.com/question/28494810/answer/117692322&quot;&gt;三姑六婆的实现方式&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;&lt;b&gt;问题: 是否有一个多项式时间的算法?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;n是输入的总长度. &lt;a href=&quot;http://qianzhang.me/&quot;&gt;Qian Zhang&lt;/a&gt;和我对这个问题做了下研究. 已知 &lt;equation&gt;O(n^3)&lt;/equation&gt; 可以找到一个多项式长度的straight-line grammar, 使得的它能生成这个最短的术语来描述目标关系. 对算法有兴趣可以看文末的appendix.straight-line grammar是一个压缩了的表示方式, 真的把写出答案却可能很长. 而最终的算法复杂度为 &lt;equation&gt;O(n^3 + s)&lt;/equation&gt; , 而 &lt;equation&gt;s&lt;/equation&gt; 是输出的长度. 所以这个问题的算法部分完全完成了. 但是只有s是多项式大小的时候算法才是多项式时间的. 这样只剩下一个纯粹的数学问题了.  &lt;/p&gt;&lt;p&gt;&lt;b&gt;问题: 是否总有一个多项式长度的解?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;抽象一点, 给一个半群S和一个子集B. 我们可以定义一个元素 &lt;equation&gt;x\in S&lt;/equation&gt; 的B长度.  &lt;equation&gt;\|x\|_B= \min \{ k | x_1\ldots x_k = x, x_i\in B\}&lt;/equation&gt; . 对于 &lt;equation&gt;X\subseteq S&lt;/equation&gt; , 它的B长度为所有元素B长度的和.  &lt;equation&gt;\|X\|_B = \sum_{x\in X} \|x\|_B&lt;/equation&gt; . &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对于一个半群S和生成集合B, 我们可以问以下的问题&lt;/p&gt;&lt;blockquote&gt;找到一个函数g, 使得对于任意有限集合 &lt;equation&gt;T\subseteq S &lt;/equation&gt; 和一个可以被 &lt;equation&gt;T&lt;/equation&gt; 生成的元素 &lt;equation&gt;x&lt;/equation&gt; , 我们都有&lt;br&gt; &lt;equation&gt;\|x\|_{T} \leq g(\|T\|_B + \|x\|_B)&lt;/equation&gt; .&lt;/blockquote&gt;&lt;p&gt;我们想要证明的是&lt;b&gt;对于亲属半群和B={f,m,d,s}, 我们可以取一个多项式g. &lt;/b&gt;而对于很多半群, 甚至群, 这样的函数g根本不存在. 这也就是为什么很多群上的看起来应该很简单的算法问题实际上都是不可判定问题. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;暂时看起来, 这个问题似乎非常难解决. 首先亲属关系半群看起来和2个生成元的自由群很像. 但是就是对两个生成元的自由群, 上述的问题我都不是很清楚. 如果我的理解是对的, 那么[1]里面的Theorem 5.14就代表对于任意自由群, 存在一个多项式的g. 可惜我实际上不懂为什么, 背景过于薄弱. 而且我感觉并没有办法直接把自由群上的结论用到亲属半群上来.&lt;/p&gt;&lt;p&gt;如果在geometric group theory这方面有背景的人可以来讨论这个问题啊.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Acknowledgements&lt;/b&gt;&lt;/p&gt;&lt;p&gt;感谢&lt;a href=&quot;http://xilinyu2.web.engr.illinois.edu/&quot;&gt;Xilin Yu&lt;/a&gt;读了第一个草稿以及给了有用的建议. 感谢三姑六婆的作者和我讨论过他(们?)的app的实现方式. &lt;/p&gt;&lt;h2&gt;References&lt;/h2&gt;&lt;p&gt;[1] ALEXEI MYASNIKOV, ANDREY NIKOLAEV, AND ALEXANDER USHAKOV, &quot;KNAPSACK PROBLEMS IN GROUPS&quot;, MATHEMATICS OF COMPUTATION&lt;br&gt;Volume 84, Number 292, March 2015, Pages 987–1016. &lt;a href=&quot;https://arxiv.org/abs/1302.5671&quot;&gt;Arxiv&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;[2] Read, Dwight W., et al. “An Algebraic Account of the American Kinship Terminology [and Comments and Reply].” &lt;i&gt;Current Anthropology&lt;/i&gt;, vol. 25, no. 4, 1984, pp. 417–449. &lt;i&gt;JSTOR&lt;/i&gt;, www.jstor.org/stable/2742902.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Appendix&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;没有儿子的男性, 为什么可以用&quot;儿子的母亲“来描述妻子这样一个关系呢? (只考虑血缘的亲属关系. 没有小孩的话妻子和自己就没有任何血缘关系.)&lt;/li&gt;&lt;li&gt;怎么会一个人一生只和另一个人有小孩啊? (可以考虑sm和sm不同的状态... 因为不同的儿子的母亲可能不一样.., 但这样就没有半群了... 就不好玩了... 就没算法题了...) &lt;/li&gt;&lt;li&gt;如果两个人已经有一定亲属关系的人生了小孩呢? (不代表模型给的结论是错的, 只不过可能有更简单的描述. )&lt;/li&gt;&lt;li&gt;年龄呢? 这不被考虑. 模型只能分辨苏丹型系统可以分辨的关系.&lt;/li&gt;&lt;li&gt;同性的关系就不被考虑了? 这不政治正确! (这就是为啥我不敢在Quora上发这样的文章 :)&lt;/li&gt;&lt;li&gt;写小说的时设计新的语言的时候. 可能会发现这个算法有点用吧. 这种motivation至少比某些算法竞赛题里面的“今天是你的生日, 所以想要送你一个整数数组”来的好多了吧. (如Codeforces: &lt;a href=&quot;http://codeforces.com/problemset/problem/351/E&quot;&gt;351E&lt;/a&gt;,  &lt;a href=&quot;http://codeforces.com/problemset/problem/354/C&quot;&gt;354C&lt;/a&gt;, &lt;a href=&quot;http://codeforces.com/problemset/problem/451/B&quot;&gt;451B&lt;/a&gt;, &lt;a href=&quot;http://codeforces.com/problemset/problem/703/D&quot;&gt;703D&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;能不能简单介绍一下算法? 多项式时间生成 straight line grammar很简单. 可以通过目标关系生成一个context-free language(CFL) &lt;equation&gt;L&lt;/equation&gt; (为啥是context free要证), 使得 &lt;equation&gt;L&lt;/equation&gt; 为所有目标关系的标准描述. 而可以使用的术语的标准描述的集合为 &lt;equation&gt;W&lt;/equation&gt; . 我们求 &lt;equation&gt;L\cap W^*&lt;/equation&gt; 里最小weight的string. 用这种方法能做到 &lt;equation&gt;O(n^5)&lt;/equation&gt; , 要达到 &lt;equation&gt;O(n^3)&lt;/equation&gt; 的话时间复杂度则需要做更多. 根本不碰context-free language. 保证一切都在regular language的状态下.  &lt;equation&gt;R(X)&lt;/equation&gt; 为可以从 &lt;equation&gt;X&lt;/equation&gt; 开始, 可以通过apply string rewriting rules  &lt;equation&gt;abc\to d&lt;/equation&gt; 写出来的string(这里要求abc=d). 如果 &lt;equation&gt;X&lt;/equation&gt; 是regular的, 则 &lt;equation&gt;R(X)&lt;/equation&gt; 是regular的 (难度来自于创建数据结构, 对于 &lt;equation&gt;R(X)&lt;/equation&gt; 里每一个string都能输出它的weight). &lt;equation&gt;S(x)&lt;/equation&gt; 为从 &lt;equation&gt;x&lt;/equation&gt; 开始通过apply string rewriting rules  &lt;equation&gt;ac\to bc&lt;/equation&gt; 能写出来的所有string(这里要求ac=bc). 我们求 &lt;equation&gt;S(x) \cap R(W^*)&lt;/equation&gt; 中weight最小的string, 这里x是目标关系的标准描述. 虽然看起来简单 但是有一大堆东西需要证明...&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-08-28-25012875</guid>
<pubDate>Mon, 28 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Weighted linear matroid parity问题</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-07-06-27679823.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Weighted linear matroid parity问题&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27679823&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今年的STOC best papers之一是&lt;a href=&quot;http://www.opt.mist.i.u-tokyo.ac.jp/~iwata/&quot; data-editable=&quot;true&quot; data-title=&quot;Satoru Iwata&quot;&gt;Satoru Iwata&lt;/a&gt;和&lt;a href=&quot;http://infoshako.sk.tsukuba.ac.jp/~kobayashi/eindex.html&quot; data-editable=&quot;true&quot; data-title=&quot;Yusuke Kobayashi&quot;&gt;Yusuke Kobayashi&lt;/a&gt;的文章. A weighted linear matroid parity algorithm. &lt;/p&gt;&lt;p&gt;这个实际上2011年Pap和Iwata都独自说已经有算法了, 但是花了这么多年才把paper写出来... Pap的文章还没有发出来... 有兴趣的可以去看那个快60页纸的technical report, 全是算法的描述和证明. &lt;a href=&quot;http://www.keisu.t.u-tokyo.ac.jp/research/techrep/data/2017/METR17-01.pdf&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;u-tokyo.ac.jp 的页面&quot;&gt;http://www.keisu.t.u-tokyo.ac.jp/research/techrep/data/2017/METR17-01.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;那么什么是weighted linear matroid parity(也叫matroid matching)问题, 为什么这文章可以拿STOC best paper呢?&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;b&gt;Input:&lt;/b&gt; 给一些集合&lt;equation&gt;S_1,\ldots,S_n&lt;/equation&gt;. 每个集合里有两个向量(任何域都可以). 集合&lt;equation&gt;S_i&lt;/equation&gt;有weight &lt;equation&gt;w(S_i)&lt;/equation&gt;. 让&lt;equation&gt;S=\bigcup_{i=1}^n S_i&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;&lt;b&gt;Output: &lt;/b&gt;找到&lt;equation&gt;X\subset [n]&lt;/equation&gt;, 使得 &lt;/p&gt;&lt;p&gt;1. 对于任意&lt;equation&gt;i, j\in X&lt;/equation&gt;,&lt;equation&gt;i\neq j&lt;/equation&gt;,不存在向量同时存在于&lt;equation&gt;S_i&lt;/equation&gt;和&lt;equation&gt;S_j
&lt;/equation&gt;中.&lt;/p&gt;&lt;p&gt;2. &lt;equation&gt;\bigcup_{i\in X} S_i&lt;/equation&gt;是&lt;equation&gt;S
&lt;/equation&gt;的一个基.&lt;/p&gt;&lt;p&gt;3. 满足上诉两个条件的&lt;equation&gt;X&lt;/equation&gt;下&lt;equation&gt;\sum_{i \in X} w(S_i)&lt;/equation&gt;最小.&lt;/p&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;一个算法问题, 见得多了之后, 感觉如果有多项式时间算法, 也就那几种.&lt;/p&gt;&lt;p&gt;一般的设计方法, 自然是算法课上的那些常见的设计方法. DP啊, Greedy啊这些常见的小锤子. 不行的话, 就要开始拿稍微强劲一点的锤子来砸了.&lt;/p&gt;&lt;br&gt;&lt;p&gt;有两个稍微常见的锤子&lt;/p&gt;&lt;p&gt;- min-cost (integral) flow&lt;/p&gt;&lt;p&gt;- max weight matching&lt;/p&gt;&lt;br&gt;&lt;p&gt;这两个锤子在无向图上都可以规约到一个更高端的问题, 最大weight的vertex disjoint S-path问题.&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;给一个图G=(V,E), 以及一个一些特殊的顶点&lt;equation&gt;T\subset V&lt;/equation&gt;. &lt;equation&gt;T&lt;/equation&gt;被partition为&lt;equation&gt;\mathcal{S}=\{S_1,\ldots,S_k\}&lt;/equation&gt; , 其中&lt;equation&gt;S_i\subset V&lt;/equation&gt;. 每个边上有一个weight. 一个path叫做&lt;equation&gt;\mathcal{S}&lt;/equation&gt;-path, 如果这个path的起点属于&lt;equation&gt;S_i&lt;/equation&gt;, 终点属于&lt;equation&gt;S_j&lt;/equation&gt;, 中间不通过任何其他&lt;equation&gt;T&lt;/equation&gt;里面的顶点.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\mathcal{S}&lt;/equation&gt; -path问题: 找到一些vertex disjoint的S-paths, 使得weight的和最大.&lt;/p&gt;&lt;p&gt;这个看起来非常NP-hard的问题可以规约到weighted linear matroid parity问题上. 而Iwata和Kobayashi的这个文章就解决了这个问题, 给了我们可以合二为一的大锤子. 现在我挥舞着这个锤子会想我以前的哪些钉子/手机可以用这个来敲...&lt;/p&gt;&lt;br&gt;&lt;p&gt;最近在日本这边交流, 和上诉的作者都见过面聊了聊. 我在想的几个问题被告知是一些我听都没有听过的问题的特殊版本. 不愧是(理论的)组合优化强国啊.&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-07-06-27679823</guid>
<pubDate>Thu, 06 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>大新闻: 线性时间凸多边形最大内接三角形又变成了未解问题</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-06-02-27222683.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;大新闻: 线性时间凸多边形最大内接三角形又变成了未解问题&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27222683&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
昨天arXiv上出现了这篇文章.&lt;a href=&quot;https://arxiv.org/abs/1705.11035&quot; data-editable=&quot;true&quot; data-title=&quot;[1705.11035] Maximum-Area Triangle in a Convex Polygon, Revisited&quot; class=&quot;&quot;&gt;[1705.11035] Maximum-Area Triangle in a Convex Polygon, Revisited&lt;/a&gt;&lt;br&gt;&lt;p&gt;文章中提到那个常见的&lt;equation&gt;O(n)&lt;/equation&gt;时间的找凸多边形里最大的三角形的算法是错误的. 给了一个counterexample, 并且给出了一个新的&lt;equation&gt;O(n\log n)&lt;/equation&gt;时间的算法. &lt;/p&gt;&lt;p&gt;所以&lt;equation&gt;O(n)&lt;/equation&gt;时间找凸多边形里最大的三角形是个open problem了.&lt;/p&gt;&lt;p&gt;有不少算法 比如找凸多边形内最大内接k边形的算法用了找最大三角形的算法做subroutine.&lt;/p&gt;&lt;br&gt;&lt;p&gt;这样看起来下面这个问题里的回答都是有问题(包括我自己的)或者解决了open problem了.&lt;/p&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/46395055&quot; data-editable=&quot;true&quot; data-title=&quot;如何计算凸包的最大内接四边形面积? - 知乎&quot; class=&quot;&quot;&gt;如何计算凸包的最大内接四边形面积? - 知乎&lt;/a&gt;&lt;p&gt;&lt;b&gt;更新 6/6/2017 3:17AM GMT+8:&lt;/b&gt; &lt;a href=&quot;https://www.zhihu.com/people/shi-qi-si/answers&quot; class=&quot;&quot; data-title=&quot;石奇偲&quot;&gt;石奇偲&lt;/a&gt;给了一个简单的文章的描述: &lt;a href=&quot;https://www.zhihu.com/question/60726749/answer/179433208&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;为什么常见的O(n)时间的找凸多边形内最大内接三角形的那个算法是错误的? - 知乎&quot;&gt;为什么常见的O(n)时间的找凸多边形内最大内接三角形的那个算法是错误的? - 知乎&lt;/a&gt;&lt;/p&gt;&lt;p&gt;---&lt;br&gt;&lt;/p&gt;&lt;p&gt;顺便广告一下自己的LaTeX包&lt;a href=&quot;https://github.com/chaoxu/naivemoha&quot; data-editable=&quot;true&quot; data-title=&quot;chaoxu/naivemoha&quot; class=&quot;&quot;&gt;naivemoha&lt;/a&gt;.&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-06-02-27222683</guid>
<pubDate>Fri, 02 Jun 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何利用割来获得一个hypergraph?</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-05-10-26812775.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;如何利用割来获得一个hypergraph?&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26812775&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于一个hypergraph, &lt;equation&gt;c&lt;/equation&gt;是它的割函数. &lt;equation&gt;c(X)&lt;/equation&gt;是多少条边有一个顶点在&lt;equation&gt;X&lt;/equation&gt;里有一个顶点在&lt;equation&gt;X&lt;/equation&gt;外. 有一个图&lt;equation&gt;G=(V,E)&lt;/equation&gt;, 如果你有一个oracle, input为一个集合&lt;equation&gt;X&lt;/equation&gt;, output为&lt;equation&gt;c(X)&lt;/equation&gt;. 用多少次query可以获得这个图呢? 一个很简单的方法可以得到这个图. &lt;equation&gt;c(\{u\})+c(\{v\})-c(\{u,v\}) = 0&lt;/equation&gt;则不存在边uv, 不然边uv存在. 就算图是有权的, 同样的方法也可以. 所以只用query所有小于等于2的大小的集合的割的值就能获得原来的图. &lt;br&gt;&lt;/p&gt;&lt;p&gt;一个rank r hypergraph为一个所有的边的包含的顶点个数都小于等于r. 对于rank r hypergraph同样的方可行吗? 是否得到所有的满足&lt;equation&gt;|X|\leq r&lt;/equation&gt;的&lt;equation&gt;c(X)&lt;/equation&gt;的值, 就可以唯一确定割函数? (注意只是得到割函数, 因为存在多个hypergraph拥有同样的割函数)&lt;/p&gt;&lt;i&gt;我觉得这并不显然, 但怀疑实际上非常显然. 如果是的话我想知道为什么显然. &lt;/i&gt;&lt;p&gt;我是用了möbius inversion证明的.&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义&lt;/b&gt;: 对于一个函数&lt;equation&gt;f:2^V\to \mathbb{R}&lt;/equation&gt;, &lt;equation&gt;f&lt;/equation&gt;的möbius inversion为&lt;equation&gt;\hat{f}:2^V\to \mathbb{R}&lt;/equation&gt;, 这里&lt;equation&gt;\hat{f}(X) = \sum_{Y\subset X} (-1)^{|X\setminus Y|} f(Y)&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;从定义可以很显然的看出&lt;equation&gt;f+g&lt;/equation&gt;的möbius inversion为&lt;equation&gt;\hat{f}+\hat{g}&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义: &lt;/b&gt;一个函数&lt;equation&gt;f&lt;/equation&gt;的möbius rank为r, 如果对于任意&lt;equation&gt;|X|&amp;gt; r&lt;/equation&gt;的集合&lt;equation&gt;X&lt;/equation&gt;, &lt;equation&gt;\hat{f}(X)=0&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理&lt;/b&gt;: 获得möbius rank为r的函数&lt;equation&gt;f&lt;/equation&gt;, 只需要query所有小于等于r的集合的&lt;equation&gt;X&lt;/equation&gt;的值就可以了.&lt;/p&gt;&lt;p&gt;&lt;b&gt;证明&lt;/b&gt;: 计算&lt;equation&gt;\hat{f}(X)&lt;/equation&gt;, 就只用query oracle所有的&lt;equation&gt;f(Y)&lt;/equation&gt;, &lt;equation&gt;Y\subseteq X&lt;/equation&gt;即可. &lt;equation&gt;f&lt;/equation&gt;f和&lt;equation&gt;\hat{f}&lt;/equation&gt;是一一对应的, 这样获得了&lt;equation&gt;\hat{f}&lt;/equation&gt;就能获得&lt;equation&gt;f&lt;/equation&gt;. 这个可以看一下&lt;a href=&quot;http://blog.jiaweigao.com/notes/2015/11/21/Zeta-Transform-and-Mobius-Transform/&quot; data-editable=&quot;true&quot; data-title=&quot;高嘉蔚美少女的notes&quot; class=&quot;&quot;&gt;高嘉蔚的notes&lt;/a&gt;. (顺便说这种把note写出来发在网上的都是业界良心)&lt;br&gt;&lt;/p&gt;&lt;p&gt;最后一步就是证明对于只有一条边的rank r hypergraph, 它的möbius rank是r(这很容易证明). 然后用induction on the number of edges就好了. 因为很容易看出möbius rank为r的函数的和也是möbius rank为r的函数.&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt;Open problem&lt;/b&gt;: Rank 3 free hypergraph为不包含任何大小为3的边的hypergraph. 是否对应一个hypergraph割函数的rank 3 free hypergraph只有一个?&lt;/p&gt;&lt;p&gt;我感觉也应该是个很显然的东西但是没有花时间去证...&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-05-10-26812775</guid>
<pubDate>Wed, 10 May 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>结对编程的分配问题</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-03-15-25737917.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;结对编程的分配问题&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25737917&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现实世界:&lt;/p&gt;&lt;p&gt;公司高层学到了结对编程(pair programming)这个概念. 对于每一个任务, 要保证有两个程序员同时在编. 于是此高层下令任何任务必须有两个程序员同时在写. 一个任务要么两个程序员在做, 要么没有人做. 每个任务只能被分配给拥有解决这个任务的能力的程序员. 那么是否可以保证至少k个任务被分配出去呢?&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以得到下面的一个问题:&lt;/p&gt;&lt;p&gt;给一个二分图&lt;equation&gt;G=(A\cup B, E)&lt;/equation&gt;. 找到一个&quot;匹配&quot; &lt;equation&gt;M\subset E&lt;/equation&gt;, 使得在&lt;equation&gt;G&#39;=(A\cup B, M)&lt;/equation&gt;里,&lt;/p&gt;&lt;p&gt;1. 每一个A的顶点&lt;equation&gt;v&lt;/equation&gt;,&lt;equation&gt;\deg(v) \in \{0,t\}&lt;/equation&gt;. 且 &lt;equation&gt;\deg(v)=t&lt;/equation&gt;的顶点至少有k个.&lt;/p&gt;&lt;p&gt;2. 每一个B的顶点&lt;equation&gt;v&lt;/equation&gt;,&lt;equation&gt; \deg(v) \in \{0,1\}&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;这里的M叫做t匹配.&lt;/p&gt;&lt;p&gt;t=1的时候, 是常见的二分图匹配问题.&lt;br&gt;&lt;/p&gt;&lt;p&gt;t=2的时候, 就是我们要解决的问题.&lt;br&gt;&lt;/p&gt;&lt;p&gt;t=3的时候, 这个问题是3-dimensional matching, 是NP-hard的. 所以还好没有什么trio programming...&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么t=2的时候问题可以多项式时间解么? 另一个同样的描述方法, 是找到k个的vertex disjoint的&lt;equation&gt;K_{1,2}&lt;/equation&gt;, 使得center在A里面. 一般人会猜这个是NP-hard的问题. 因为如果同样的问题, &lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/S0167637707000028&quot;&gt;不要求center在A里面的话, 那就是NP-hard的&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个问题是可以多项式时间解答的. 可以规约到最大权值完美匹配.&lt;/p&gt;&lt;p&gt;方法如下.&lt;/p&gt;&lt;p&gt;创建一个新的图&lt;equation&gt;G&#39;=(V&#39;,E&#39;)&lt;/equation&gt;. 假设&lt;equation&gt;|B|=n&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;C=\{t_1,\ldots,t_{n-2k}\}&lt;/equation&gt;, 是一个有&lt;equation&gt;n-2k&lt;/equation&gt;个新顶点的集合.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;V&#39; = A\cup \{ v_1,v_2 | v\in B\}\cup C&lt;/equation&gt;&lt;/p&gt;&lt;p&gt;对于每一个&lt;equation&gt;v\in A&lt;/equation&gt;, 有一个边&lt;equation&gt;v_1v_2&lt;/equation&gt;, 权值0.&lt;/p&gt;&lt;p&gt;对于每一个&lt;equation&gt;v\in A, u\in B&lt;/equation&gt;, 有边&lt;equation&gt;v_1u&lt;/equation&gt;和&lt;equation&gt;v_2u&lt;/equation&gt;,权值都为1.&lt;/p&gt;&lt;p&gt;对于每一个&lt;equation&gt;v\in A,u\in C&lt;/equation&gt;, 有边&lt;equation&gt;uv&lt;/equation&gt;, 权值为0.&lt;/p&gt;&lt;p&gt;原来的问题有解, 有且仅有在&lt;equation&gt;G&#39;&lt;/equation&gt;上的最大权值完美匹配的值为&lt;equation&gt;2k&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;原先的问题的有权值的版本也能用类似的方法做出来.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现实世界:&lt;/p&gt;&lt;p&gt;由于结对编程导致程序员强烈不满, 高层允许梨子编程(pear programming).&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Open problems:&lt;/p&gt;&lt;p&gt;1. 如果每一个边上都有权值w, 然后2-匹配 M 的值为 &lt;equation&gt;c(M) = \sum_{a \in V} \min \{ w(e) | a \in b \in M\}&lt;/equation&gt;. 如何找到值最大的2-匹配? 因为pair programming的时会被弱一点的人拉后腿. &lt;b&gt;[几乎解决: NP-hard, 存在2-approximation, APX-hard. 不知道是否存在更好的approximation]&lt;/b&gt; &lt;/p&gt;&lt;p&gt;2. &lt;equation&gt;A&#39;\subseteq A&lt;/equation&gt;叫做nice, 如果存在一个2-匹配,使得&lt;equation&gt;A&#39;&lt;/equation&gt;里每一个顶点的度都是2. 找到最少的nice集合, 使得他们的并集是A. &lt;b&gt;[已解决: OPT+1-approximation!]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;3. &lt;equation&gt;B&#39;\subseteq B&lt;/equation&gt;叫做nice, 如果存在一个2-匹配,使得&lt;equation&gt;B&#39;&lt;/equation&gt;里每一个顶点的度都是1. 找到最少的nice集合, 使得他们的并集是B. &lt;b&gt;[已解决: 存在多项式时间解]&lt;/b&gt; &lt;/p&gt;&lt;p&gt;4. 一个scheduling问题的拓展: scheduling on unrelated parallel machines minimizing makespan allowing preemption, 加上一个新的条件: 任何时候一个job要有两个worker, 而且有些worker不能做某些job. &lt;b&gt;[已解决: 存在多项式时间解]&lt;/b&gt;&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-03-15-25737917</guid>
<pubDate>Wed, 15 Mar 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>平面图的算法有什么用</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-03-12-21841596.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;平面图的算法有什么用&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21841596&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我读博刚开始的时候研究bounded genus graph. 这里包括各种能嵌入在不同surface上的图, 比如平面图和toroidal graph. &lt;/p&gt;&lt;p&gt;为了能在聚会的时候有话可说, 那个时候会考虑自己做的研究有什么用.&lt;/p&gt;&lt;br&gt;&lt;p&gt;树是平面图+树的用处广 =&amp;gt; 平面图用处广. 这很尴尬, 很多时候问题用不到树的平面图属性. 用到的只是树的&lt;a href=&quot;https://en.wikipedia.org/wiki/Treewidth&quot; data-editable=&quot;true&quot; data-title=&quot;treewidth&quot; class=&quot;&quot;&gt;treewidth&lt;/a&gt;的属性. 很多树上的算法可以普及到bounded treewidth的图上, 但是试图放到平面图上却会失败.&lt;/p&gt;&lt;br&gt;&lt;p&gt;要真的说平面图有用, 就需要看treewidth比较大的平面图. 比如网格图. 一般来说, 网格上的问题的难度和平面图上的问题的难度是一样的. 计算视觉里面的图像分割有些方法就是在网格上做min-cut. 有一个程序叫&lt;a href=&quot;gridcut.com&quot; data-title=&quot;GridCut&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;GridCut&lt;/a&gt;, 专门解决这类型问题. 可惜3D网格不是平面的. 并且网格里面每个正方形里都加上两个对角线的话, 也不再planar. 令人伤心. &lt;/p&gt;&lt;p&gt;有一个这样的问题, 一般人看到完全不会想到用用平面图来做: 给两个string S和T, 求S和T的每一个substring的edit distance. 一般算edit distance的方法, 其实可以建立成一个平面图(那个DP的表可以用一个DAG来表示). 然后找上面的最短路径. 用同样的道理, 这问题能转换成为一个face上的all pair shortest path(&lt;a href=&quot;http://stackoverflow.com/questions/17412543/semi-local-levenshtein-distance&quot; data-editable=&quot;true&quot; data-title=&quot;David Eisenstat在stackoverflow上就有这样的回答&quot; class=&quot;&quot;&gt;David Eisenstat在stackoverflow上就有这样的回答&lt;/a&gt;). 这个非常适合在聚会上使用. 特别是对于没有什么理论基础但是刷过很多算法题的人, 能得到不错的反响. &lt;/p&gt;&lt;p&gt;如果聚会上的人问torus上的图的用处. 那就更可以打开话匣. 假如人类要星际殖民. 遇到了一个被打了一个大洞的星球, 要在那星球表面做一个交通系统, 就是在toroidal graph上做network design. 问题是这样的星球是否存在呢? (当然, 拓扑上来说, 任意小的洞都可以. 所以我们想要更加有意思一点的例子.) &lt;/p&gt;&lt;p&gt;Star Trek Beyond的片尾里就有这样的星球. &lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b56ffbfb229cbe2de12ea42d0b425d4f_r.png&quot; data-rawwidth=&quot;1281&quot; data-rawheight=&quot;540&quot;&gt;或者Super Mario Galaxy (这个图里的洞有些多)&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1f4a4d3257d4bd2cde2985d7dd75d7b9_r.png&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;281&quot;&gt;&lt;p&gt;&lt;a href=&quot;http://io9.gizmodo.com/what-would-the-earth-be-like-if-it-was-the-shape-of-a-d-1515700296&quot; data-editable=&quot;true&quot; data-title=&quot;Anders Sandberg写了个文说torus一样的星球是可能存在的&quot;&gt;Anders Sandberg写了个文说torus一样的星球是可能存在的&lt;/a&gt;, &lt;a href=&quot;https://www.zhihu.com/question/28591211&quot;&gt;知乎上也有这样的问题&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;我现在不再研究这类型的问题了, 也不需要想象这种奇怪的应用了. &lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-03-12-21841596</guid>
<pubDate>Sun, 12 Mar 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Hypergraph st-最小割</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2016-07-13-21579839.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Hypergraph st-最小割&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21579839&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
刚刚submit了点和&lt;a href=&quot;https://en.wikipedia.org/wiki/Hypergraph&quot; data-editable=&quot;true&quot; data-title=&quot;hypergraph&quot;&gt;hypergraph&lt;/a&gt;有关的东西给SODA 2017(更新: 也被accepted了), 我&lt;a href=&quot;http://web.engr.illinois.edu/~chaoxu3/&quot; data-editable=&quot;true&quot; data-title=&quot;主页&quot; class=&quot;&quot;&gt;主页&lt;/a&gt;可以看到.&lt;p&gt;一些我们发现了但是感觉不足挂齿的结果, 也就没有写进去. 其中一个是hypergraph &lt;equation&gt;st&lt;/equation&gt;-最小割问题: 在hypergraph &lt;equation&gt;H&lt;/equation&gt;上删除最少的边, 使得&lt;equation&gt;s&lt;/equation&gt;和&lt;equation&gt;t&lt;/equation&gt;不联通. 以前各种文章里出现的做法都是下面这样的:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;转换这个hypergraph到&lt;a href=&quot;https://en.wikipedia.org/wiki/Hypergraph#Bipartite_graph_model&quot; data-title=&quot;incidence graph&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;incidence graph&lt;/a&gt;. 每个代表边的顶点都有capacity 1.&lt;br&gt;&lt;/li&gt;&lt;li&gt;拆顶点, 获得有向图 &lt;equation&gt;G&lt;/equation&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;跑st最大流在&lt;equation&gt;G&lt;/equation&gt;上.&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;p&gt;这个方法也能用在有权值的hypergraph上. 假如&lt;equation&gt;H&lt;/equation&gt;有&lt;equation&gt;n&lt;/equation&gt;个顶点, &lt;equation&gt;m&lt;/equation&gt;个边, 顶点的度之和为&lt;equation&gt;p&lt;/equation&gt;. 则&lt;equation&gt;G&lt;/equation&gt;有&lt;equation&gt;O(n+m)&lt;/equation&gt;个顶点, &lt;equation&gt;O(p)&lt;/equation&gt;个边. 跑最大流要&lt;equation&gt;O((n+m) p)&lt;/equation&gt;的时间, 而&lt;equation&gt;m&lt;/equation&gt;可能比&lt;equation&gt;n&lt;/equation&gt;大很多. 很多文章里也就把这个速度做为最好的速度了. 似乎里面也有人问这是否是最优的.&lt;/p&gt;&lt;p&gt;有意思的是好像并没有人知道(或者知道也懒得写出来)实际上可以做的更好.&lt;/p&gt;&lt;p&gt;有一个简单的&lt;a href=&quot;https://en.wikipedia.org/wiki/Dinic%27s_algorithm&quot; data-title=&quot;Dinic&#39;s algorithm&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;Dinic&#39;s algorithm&lt;/a&gt; + &lt;a href=&quot;https://en.wikipedia.org/wiki/Link/cut_tree&quot; data-editable=&quot;true&quot; data-title=&quot;dynamic tree&quot; class=&quot;&quot;&gt;dynamic tree&lt;/a&gt;的最大流算法算法. (Sleator and Tarjan 1982), 叫这个算法A的话.&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;b&gt;Theorem&lt;/b&gt;:  用算法A, &lt;equation&gt;G&lt;/equation&gt;上最大流可以在&lt;equation&gt;\tilde{O}(np)&lt;/equation&gt;时间算出.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Proof&lt;/i&gt;: &lt;equation&gt;G&lt;/equation&gt;里最长的路径的长度是&lt;equation&gt;O(n)&lt;/equation&gt;, 每一次blocking flow, &lt;equation&gt;s&lt;/equation&gt;和&lt;equation&gt;t&lt;/equation&gt;的距离增加至少1. 所以最多&lt;equation&gt;O(n)&lt;/equation&gt;次blocking flow, 而每一次blocking flow可以&lt;equation&gt;\tilde{O}(p)&lt;/equation&gt;时间做到.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们感觉这个很trivial而且和我们文章没啥关系就懒得指出了.&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Remark&lt;/b&gt; 当然, 有时候指出一些&quot;显然易见&quot;的东西还是会帮助一些其他人的. 有一些人在研究一些网络安全的东西的时候, 遇到了一个优化问题. 他们的解法是用integer program或者heuristic. 而Yamaguchi等人发现了这问题不过是hypergraph最小割问题... 于是指出来了并且发在了一个IF 4+的地方. 哈哈哈这可是理论人想都不敢想的. (这里提到IF纯属搞笑. 不代表作者的任何观点.). [&lt;a href=&quot;http://www-sys.ist.osaka-u.ac.jp/~ymgc/slide/SGC2014.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;slides&quot;&gt;slides&lt;/a&gt;].&lt;/blockquote&gt;&lt;br&gt;&lt;blockquote&gt;P.S. 有时候我也想知道其他领域有没有啥东西我可以去帮忙解决.&lt;/blockquote&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2016-07-13-21579839</guid>
<pubDate>Wed, 13 Jul 2016 00:00:00 +0800</pubDate>
</item>
<item>
<title>满足连通性的稀疏化</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2016-02-18-20581305.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;满足连通性的稀疏化&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20581305&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑这样一个现实的问题. 有n个数据中心, 已经知道其中的一些被光纤连了起来. 但是光纤的租用费用还是蛮多的.  我们希望保证切除任何k个光纤, 都能保证数据中心还能互相交流. 是否可以少租一些光纤呢?&lt;/p&gt;&lt;p&gt;当然, 如果要保证使用最少个数的光纤, 在k=2的时候就已经是NP-hard的. 所以我们可以r要求只用O(kn)个光纤.&lt;/p&gt;由此我们可以获得一个抽象的问题. 让&lt;equation&gt;\lambda_G(x,y)&lt;/equation&gt;为图&lt;equation&gt;G&lt;/equation&gt;上顶点x和y的边连通度, 也就是最少的要删除的边的个数使得没有x到y的路径.&lt;p&gt;对于一个无向图G, &lt;a href=&quot;http://link.springer.com/article/10.1007%2FBF01758778&quot; data-editable=&quot;true&quot; data-title=&quot;Nagamochi和Ibaraki&quot; class=&quot;&quot;&gt;Nagamochi和Ibaraki&lt;/a&gt;发现了一个O(m)时间找到只有O(kn)边的子图H, 使得对于任意x,y, 我们有&lt;/p&gt;&lt;equation&gt;\lambda_H(x,y) \geq \min(k,\lambda_G(x,y))&lt;/equation&gt;.&lt;p&gt;我们称之这个为满足连通性的稀疏化.&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果只关心k边连通度, 则这个可以用来大量减少边的个数. 任何O(f(m,n))时间的算法变成O(m+f(kn,n))时间的算法: 首先找到子图H, 然后跑原来的算法在图H上而不是G上. &lt;/p&gt;&lt;p&gt;这方法之所以速度这么快, 因为根本没有计算&lt;equation&gt;\lambda_G(x,y)&lt;/equation&gt;究竟是什么. 只是找到了一个满足这个属性的子图. 而计算&lt;equation&gt;\lambda_G(x,y)&lt;/equation&gt;本身是比找这个稀疏化要难的.&lt;/p&gt;&lt;p&gt;因为&lt;equation&gt;\lambda_G&lt;/equation&gt;可以定义在有向图上. 所以也可以问, 是否存在一个有&lt;equation&gt;O(kn)&lt;/equation&gt;边的稀疏图, 保证所有的边连通度? &lt;/p&gt;&lt;p&gt;如果是有向图, 这是不可能的: 考虑一个完全二分图, 所有的边从一个partition到另一个partition.&lt;/p&gt;&lt;p&gt;如果弱化要求呢? 给一个有向图G以及一个顶点r. 是否存在一个有&lt;equation&gt;O(kn)&lt;/equation&gt;个边的子图H, 使得对于任意x, 我们有&lt;/p&gt;&lt;equation&gt;\lambda_H(r,x)\geq \min(k,\lambda_G(r,x))&lt;/equation&gt;&lt;p&gt;这个以前在cs theory上问过. 过了很久再次去考虑的时候&lt;a href=&quot;http://cstheory.stackexchange.com/questions/25268/sparse-subgraph-preserving-rooted-edge-connectivity-up-to-k&quot; data-editable=&quot;true&quot; data-title=&quot;发现了答案&quot; class=&quot;&quot;&gt;发现了答案&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;有意思的是以下的算法可以得到这样的子图.&lt;/p&gt;&lt;p&gt;1. 选择一个没有选择过的x. 找到r到x的值为&lt;equation&gt;\min(k,\lambda_G(r,x))&lt;/equation&gt;的网络流&lt;/p&gt;&lt;p&gt;2. 删除所有的不在f里且指向x的边.&lt;/p&gt;&lt;p&gt;3. 回到1.&lt;/p&gt;&lt;p&gt;显然, 最后得到的图的边的个数满足这个要求. 然后简单的用submodular的属性就能证明这实际上满足边连通度的要求. 但是这实在是太慢了, 要n次max flow. 有意思的是, 当&lt;equation&gt;k=\min_x \lambda(r,x)&lt;/equation&gt;, 可以保证&lt;equation&gt;O(km)&lt;/equation&gt;的时间 (&lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/S0022000085710227&quot; data-title=&quot;用特殊的matroid intersection&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;用特殊的matroid intersection&lt;/a&gt;). 但是对于其他的k, 并不知比算n次max flow更好的方法.&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2016-02-18-20581305</guid>
<pubDate>Thu, 18 Feb 2016 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
