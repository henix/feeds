<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>证否双重否定律</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/56233770">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-85e06eef9d42cb401ac7d82fe78961f8_b.jpg" alt=""></div><p>今天是除夕，祝各位读者新年快乐。</p><p>我其实特别想把标题取为<b>震惊，双重否定律竟然是错的</b>，但想了想还是算了。</p><p>这篇文章将介绍在同伦类型论（homotopy type theory）的框架下证否双重否定律的过程，使用 agda 和配套的 hott-agda 库进行形式验证。</p><p>作为基础，推荐先看看<a href="https://zhuanlan.zhihu.com/p/22389755" class="internal">这篇文章</a>了解一下构造主义和 hott 是啥，写的比我好得多。</p><h2>双重否定律</h2><p>首先是双重否定律的定义：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+A%3A%5Cmathcal%7BU%7D.%5Clnot+%28%5Clnot+A%29%5Crightarrow+A" alt="\forall A:\mathcal{U}.\lnot (\lnot A)\rightarrow A" eeimg="1"> </p><p>以及 agda 代码：</p><div class="highlight"><pre><code class="language-agda"><span></span>dnl <span class="ow">=</span> <span class="o">(</span>A <span class="ow">:</span> Type0<span class="o">)</span> <span class="ow">→</span> ¬ <span class="o">(</span>¬ A<span class="o">)</span> <span class="ow">→</span> A
</code></pre></div><p>在布尔代数中，这是一个公理，但在构造主义的数学中这不成立，同样不成立的还有一票与之等价的命题，如排中律和皮尔士定理。</p><h2>Univalence axiom</h2><p>Univalence axiom （简称 ua）是同伦类型论的核心内容，ua 告诉我们，<b>如果两个类型是同构的，那么它们相等。</b></p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathrm%7Bua%7D%3A%5Cforall+A%2CB+%3A+%5Cmathcal%7BU%7D.A+%5Csimeq+B+%5Cto+A%3DB" alt="\mathrm{ua}:\forall A,B : \mathcal{U}.A \simeq B \to A=B" eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span><span class="nf">ua</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>i<span class="o">}</span> <span class="o">{</span>A B <span class="ow">:</span> Type i<span class="o">}</span> <span class="ow">→</span> <span class="o">(</span>A ≃ B<span class="o">)</span> <span class="ow">→</span> A <span class="ow">==</span> B
</code></pre></div><p>原本我们是没法说两个不同的类型相等的，但有了 ua ，我们就可以通过给出两个类型同构的证明来说明两个类型相等。而有了两个类型相等的证明，我们就可以使用 transport 函数把所有对类型 A 成立的定理 transport 到类型 B 上。下面是 transport 和几个其他辅助函数的定义。</p><div class="highlight"><pre><code class="language-agda"><span></span><span class="nf">ap</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>i j<span class="o">}</span> <span class="o">{</span>A <span class="ow">:</span> Type i<span class="o">}</span> <span class="o">{</span>B <span class="ow">:</span> Type j<span class="o">}</span> <span class="o">(</span>f <span class="ow">:</span> A <span class="ow">→</span> B<span class="o">)</span> <span class="o">{</span>x y <span class="ow">:</span> A<span class="o">}</span>
  <span class="ow">→</span> <span class="o">(</span>x <span class="ow">==</span> y <span class="ow">→</span> f x <span class="ow">==</span> f y<span class="o">)</span>
ap f idp <span class="ow">=</span> idp

<span class="nf">coe</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>i<span class="o">}</span> <span class="o">{</span>A B <span class="ow">:</span> Type i<span class="o">}</span> <span class="o">(</span>p <span class="ow">:</span> A <span class="ow">==</span> B<span class="o">)</span> <span class="ow">→</span> A <span class="ow">→</span> B
coe idp x <span class="ow">=</span> x

<span class="nf">transport</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>i j<span class="o">}</span> <span class="o">{</span>A <span class="ow">:</span> Type i<span class="o">}</span> <span class="o">(</span>B <span class="ow">:</span> A <span class="ow">→</span> Type j<span class="o">)</span> <span class="o">{</span>x y <span class="ow">:</span> A<span class="o">}</span> <span class="o">(</span>p <span class="ow">:</span> x <span class="ow">==</span> y<span class="o">)</span>
  <span class="ow">→</span> <span class="o">(</span>B x <span class="ow">→</span> B y<span class="o">)</span>
transport B p <span class="ow">=</span> coe <span class="o">(</span>ap B p<span class="o">)</span>

<span class="nf">apd</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>i j<span class="o">}</span> <span class="o">{</span>A <span class="ow">:</span> Type i<span class="o">}</span> <span class="o">{</span>B <span class="ow">:</span> A <span class="ow">→</span> Type j<span class="o">}</span> <span class="o">(</span>f <span class="ow">:</span> <span class="o">(</span>a <span class="ow">:</span> A<span class="o">)</span> <span class="ow">→</span> B a<span class="o">)</span>
      <span class="o">{</span>x y <span class="ow">:</span> A<span class="o">}</span> <span class="ow">→</span> <span class="o">(</span>p <span class="ow">:</span> x <span class="ow">==</span> y<span class="o">)</span> <span class="ow">→</span> transport B p <span class="o">(</span>f x<span class="o">)</span> <span class="ow">==</span> f y
apd f idp <span class="ow">=</span> idp
</code></pre></div><p>ap 是说把一个函数 f 应用到等号两边等式仍然成立。</p><p>coe 是说我们可以如果有 <img src="https://www.zhihu.com/equation?tex=A%3DB" alt="A=B" eeimg="1"> ，那么我们可以拿到对应的同构函数。</p><p>apd 与 ap 类似，打算 apd 应用的函数返回值的类型是依赖参数类型的，所以等号左边需要通过 transport 把类型变到右边一样。</p><p>下面就可以开始证明了。</p><h2>证明</h2><p>在构造主义的数学中 <img src="https://www.zhihu.com/equation?tex=%5Clnot+a+%3D+a+%5Cto+%5Cbot" alt="\lnot a = a \to \bot" eeimg="1"> ，要证否双重否定律，我们只需要使用 <img src="https://www.zhihu.com/equation?tex=f+%3A%5Cforall+A+%3A+%5Cmathcal%7BU%7D+%5Cto+%5Clnot+%28%5Clnot+A%29+%5Cto++A" alt="f :\forall A : \mathcal{U} \to \lnot (\lnot A) \to  A" eeimg="1"> 构造出 <img src="https://www.zhihu.com/equation?tex=%5Cbot" alt="\bot" eeimg="1"> 类型的值就好。</p><p>首先我们可以构造一个 <img src="https://www.zhihu.com/equation?tex=e+%3A+Bool+%5Csimeq+Bool" alt="e : Bool \simeq Bool" eeimg="1"> ，定义 <img src="https://www.zhihu.com/equation?tex=e%28true%29%3Dfalse" alt="e(true)=false" eeimg="1"> 且 <img src="https://www.zhihu.com/equation?tex=e%28false%29%3Dtrue" alt="e(false)=true" eeimg="1"> 。再通过 ua 我们可以得到 <img src="https://www.zhihu.com/equation?tex=p+%3A+Bool+%3D+Bool" alt="p : Bool = Bool" eeimg="1"> 。</p><div class="highlight"><pre><code class="language-agda"><span></span><span class="nf">e</span> <span class="ow">:</span> Bool ≃ Bool
e <span class="ow">=</span> <span class="o">(</span>b-&gt;b , λ <span class="kr">where</span>
  <span class="ow">.</span>g <span class="ow">→</span> b-&gt;b
  <span class="ow">.</span>f-g true <span class="ow">→</span> idp
  <span class="ow">.</span>f-g false <span class="ow">→</span> idp
  <span class="ow">.</span>g-f true <span class="ow">→</span> idp
  <span class="ow">.</span>g-f false <span class="ow">→</span> idp
  <span class="ow">.</span>adj true <span class="ow">→</span> idp
  <span class="ow">.</span>adj false <span class="ow">→</span> idp<span class="o">)</span>
  <span class="kr">where</span>
    <span class="nf">b-&gt;b</span> <span class="ow">:</span> Bool <span class="ow">→</span> Bool
    b-&gt;b true <span class="ow">=</span> false
    b-&gt;b false <span class="ow">=</span> true

    <span class="kr">open</span> is-equiv

<span class="nf">p</span> <span class="ow">:</span> Bool <span class="ow">==</span> Bool
p <span class="ow">=</span> ua e
</code></pre></div><p>然后使用 apd 函数把 <img src="https://www.zhihu.com/equation?tex=f+%3A%5Cforall+A+%3A+%5Cmathcal%7BU%7D+%5Cto+%5Clnot+%28%5Clnot+A%29+%5Cto++A" alt="f :\forall A : \mathcal{U} \to \lnot (\lnot A) \to  A" eeimg="1"> 应用到 <img src="https://www.zhihu.com/equation?tex=p" alt="p" eeimg="1"> 类型里的 <img src="https://www.zhihu.com/equation?tex=Bool" alt="Bool" eeimg="1"> 上。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathrm%7Bapd%7D_f%28p%29%3A%5Cmathrm%7Btransport%7D%5E%7BA%5Cmapsto%28%5Clnot%28%5Clnot+A%29%5Cto+A%29%7D%28p%2Cf%28Bool%29%29%3Df%28Bool%29" alt="\mathrm{apd}_f(p):\mathrm{transport}^{A\mapsto(\lnot(\lnot A)\to A)}(p,f(Bool))=f(Bool)" eeimg="1"> </p><div class="highlight"><pre><code class="language-agda"><span></span><span class="nf">apdfp</span> <span class="ow">:</span> transport <span class="o">(</span>λ A <span class="ow">→</span> ¬ <span class="o">(</span>¬ A<span class="o">)</span> <span class="ow">→</span> A<span class="o">)</span> <span class="o">(</span>f Bool<span class="o">)</span> <span class="ow">==</span> f Bool
apdfp <span class="ow">=</span> apd f p
</code></pre></div><p>这里我们需要一个引理（hott book 上的 2.9.4）：</p><div class="highlight"><pre><code class="language-agda"><span></span><span class="nf">l294</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>i j<span class="o">}</span> <span class="o">{</span>X <span class="ow">:</span> Type i<span class="o">}</span> <span class="o">{</span>x1 x2 <span class="ow">:</span> X<span class="o">}</span> <span class="o">(</span>p <span class="ow">:</span> x1 <span class="ow">==</span> x2<span class="o">)</span>
       <span class="o">{</span>A B <span class="ow">:</span> X <span class="ow">→</span> Type j<span class="o">}</span> <span class="o">(</span>f <span class="ow">:</span> A x1 <span class="ow">→</span> B x1<span class="o">)</span> <span class="ow">→</span>
       transport <span class="o">(</span>λ x <span class="ow">→</span> A x <span class="ow">→</span> B x<span class="o">)</span> p f <span class="ow">==</span>
       λ x <span class="ow">→</span> transport B p <span class="o">(</span>f <span class="o">(</span>transport A <span class="o">(</span>! p<span class="o">)</span> x<span class="o">))</span>
l294 idp f <span class="ow">=</span> λ= λ x <span class="ow">→</span> idp
</code></pre></div><p>应用这个引理， apdfp 的类型则变为:</p><div class="highlight"><pre><code class="language-agda"><span></span>λ x <span class="ow">→</span> transport <span class="o">(</span>λ A <span class="ow">→</span> A<span class="o">)</span> p <span class="o">(</span>f Bool <span class="o">(</span>transport <span class="o">(</span>λ A <span class="ow">→</span> ¬ <span class="o">(</span>¬ A<span class="o">)</span> <span class="ow">→</span> A<span class="o">)</span> <span class="o">(</span>! p<span class="o">)</span> x<span class="o">))</span> <span class="ow">==</span> f Bool
</code></pre></div><p>等号两边同时应用到 <img src="https://www.zhihu.com/equation?tex=%5Cmathrm%7Bu%7D+%3A+%5Clnot+%28%5Clnot+Bool%29" alt="\mathrm{u} : \lnot (\lnot Bool)" eeimg="1"> 上：</p><div class="highlight"><pre><code class="language-agda"><span></span><span class="nf">u</span> <span class="ow">:</span> ¬ <span class="o">(</span>¬ A<span class="o">)</span>
u <span class="ow">=</span> λ z <span class="ow">→</span> z true

<span class="nf">apdfp'</span> <span class="ow">:</span> transport <span class="o">(</span>λ A <span class="ow">→</span> A<span class="o">)</span> p <span class="o">(</span>f Bool <span class="o">(</span>transport <span class="o">(</span>λ A <span class="ow">→</span> ¬ <span class="o">(</span>¬ A<span class="o">))</span> <span class="o">(</span>! p<span class="o">)</span> u<span class="o">))</span> <span class="ow">==</span> f Bool u
</code></pre></div><p>而对任意 <img src="https://www.zhihu.com/equation?tex=x%2Cy%3A%5Cbot" alt="x,y:\bot" eeimg="1"> ， <img src="https://www.zhihu.com/equation?tex=x%3Dy" alt="x=y" eeimg="1"> ，那么任意 <img src="https://www.zhihu.com/equation?tex=u%2Cv+%3A+%5Clnot+%28%5Clnot+Bool%29" alt="u,v : \lnot (\lnot Bool)" eeimg="1"> 因为 <img src="https://www.zhihu.com/equation?tex=u%28x%29%2C+v%28x%29+%3A+%5Cbot" alt="u(x), v(x) : \bot" eeimg="1"> 有 <img src="https://www.zhihu.com/equation?tex=u%28x%29%3Dv%28x%29" alt="u(x)=v(x)" eeimg="1"> ，所以 <img src="https://www.zhihu.com/equation?tex=u%3Dv" alt="u=v" eeimg="1"> 。而 <img src="https://www.zhihu.com/equation?tex=%5Cmathrm%7Btransport%7D%5E%7BA+%5Cmapsto+%C2%AC+%28%C2%AC+A%29%7D+%28+p%5E%7B-1%7D%2C+u%29+%3A+%5Clnot+%28%5Clnot+Bool%29" alt="\mathrm{transport}^{A \mapsto ¬ (¬ A)} ( p^{-1}, u) : \lnot (\lnot Bool)" eeimg="1"> ，有 <img src="https://www.zhihu.com/equation?tex=%5Cmathrm%7Btransport%7D%5E%7BA+%5Cmapsto+%C2%AC+%28%C2%AC+A%29%7D+%28+p%5E%7B-1%7D%2C+u%29+%3D+u" alt="\mathrm{transport}^{A \mapsto ¬ (¬ A)} ( p^{-1}, u) = u" eeimg="1"> 。appfp' 的类型变为：</p><div class="highlight"><pre><code class="language-agda"><span></span>transport <span class="o">(</span>λ A <span class="ow">→</span> A<span class="o">)</span> p <span class="o">(</span>f Bool u<span class="o">)</span> <span class="ow">==</span> f Bool u
</code></pre></div><p>这意味着 <img src="https://www.zhihu.com/equation?tex=e%28f%28Bool%2Cu%29%29%3Df%28Bool%2Cu%29" alt="e(f(Bool,u))=f(Bool,u)" eeimg="1"> ，其与 <img src="https://www.zhihu.com/equation?tex=e%28true%29%3Dfalse%2Ce%28false%29%3Dtrue" alt="e(true)=false,e(false)=true" eeimg="1"> 相矛盾，而一个命题和它的否定相应用可以构造出一个 <img src="https://www.zhihu.com/equation?tex=%5Cbot" alt="\bot" eeimg="1"> 类型的值：</p><div class="highlight"><pre><code class="language-agda"><span></span><span class="nf">ff</span> <span class="ow">:</span> <span class="ow">∀</span> x <span class="ow">→</span> coe p x <span class="ow">==</span> x <span class="ow">→</span> ⊥
<span class="nf">tt</span> <span class="ow">:</span> <span class="ow">∀</span> u <span class="ow">→</span> coe p <span class="o">(</span>f Bool u<span class="o">)</span> <span class="ow">==</span> f Bool u

ff <span class="o">(</span>f Bool u<span class="o">)</span> <span class="o">(</span>tt u<span class="o">)</span> <span class="ow">:</span> ⊥
</code></pre></div><p>由此，我们便证否了双重否定律。</p><p>完整的 agda 代码在 github 上：</p><a href="http://link.zhihu.com/?target=https%3A//github.com/lwoo1999/SomeAgdaCode/blob/master/hottstuff.agda" data-draft-node="block" data-draft-type="link-card" data-image="https://pic3.zhimg.com/v2-9cd0def1666c355a4674cc140eb8cd42_ipico.jpg" data-image-width="400" data-image-height="400" class=" wrap external" target="_blank" rel="nofollow noreferrer">lwoo1999/SomeAgdaCode</a><h2>感想</h2><p>这是我用 hott-agda 库作的第一个证明，能把书上的定理证明过程直接搬到 agda 代码里让人十分开心。</p><p>hott-agda 与 agda-stdlib 的风格差异还是蛮大的，比如 sym 函数在 hott-agda 里变成了 !，让我找了半天。</p><p>ua 在 hott 里是作为 postulate 引入的，换言之，它不能运行，比如上面证明中 coe p true 就不能计算出值，需要使用库中的一些定理进行繁琐的 rewrite。据说 cubical type theory 可以使 ua 能够进行计算，我有打算去了解一下。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
