<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>理解 Rust 中的 Closure</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/64417628">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-4910aa27ee411357590b8de05657865c_b.jpg" alt=""></div><h2>原理</h2><p>有些语言中没有 closure 和普通函数的区分，但 Rust 有。对 Rust 来说普通函数就是一段代码。而 closure 和 C++ 类似：每个 closure 会创建一个匿名的<code>struct</code>，编译器会在当前上下文捕获 closure 代码中的外部变量然后塞进这个结构体里面。</p><p>这件事非常重要，请默念三遍<b>一个 closure 就是一个捕获了当前上下文变量的结构体</b>（外加一段代码，这不重要）。</p><p>这解释了为什么 Rust 中两个参数和返回值一样的 closure 不被视作同一类型<sup data-text="其实所有的普通函数也都是唯一的类型。被视作 Zero Sized Types。" data-url="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts" data-draft-node="inline" data-draft-type="reference" data-numero="1">[1]</sup>，因为它们背后的匿名结构体不同，有着不同的大小、字段和 lifetime。</p><div class="highlight"><pre><code class="language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// 等价于
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeUnknownType</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">m</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">c</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">f64</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SomeUnknownType</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">x</span>: <span class="kt">f64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">c</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><i>例子来源于 <a href="https://link.zhihu.com/?target=https%3A//stevedonovan.github.io/rustifications/2018/08/18/rust-closures-are-hard.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Why Rust Closures are (Somewhat) Hard</a>。</i></p><p>这也是 closure 难用的根源：</p><ol><li>Rust 中结构体的可变性以及 liftime 本身就很烦人。</li><li>Closure 的规则都是隐式的：closure 捕获值的方式及所生成的closure的类型都是按照隐式的规则决定的。</li><li>Closure 一直会捕获整个复合类型，如 <code>struct</code>, <code>tuple</code> 和 <code>enum</code> 。而不只是单个字段<sup data-text="Reference - Closure Types" data-url="https://doc.rust-lang.org/reference/types/closure.html" data-draft-node="inline" data-draft-type="reference" data-numero="2">[2]</sup>。</li></ol><p>对于 (3)，<a href="https://link.zhihu.com/?target=https%3A//github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md" class=" wrap external" target="_blank" rel="nofollow noreferrer">Rust 团队已经接受了一个提案</a>，旨在改进不相交字段的捕获规则。（当前看起来没多少进展）</p><h3>为什么</h3><p>对于 (1) 和 (2) 是语言设计思路所带来的结果，为什么会这样呢？</p><p>因为 closure 很好用，但是我们不想付出运行时代价。所有语言都有类似的东西，但是它们把 closure 捕获的结构丢到堆上以保证所有 closure 类型大小一样，且借助了 GC 管理资源。</p><p>Rust选择「零额外开销」（Zero Overhead）所以必须用这种方式来实现 closure。使用高级抽象的同时保持了性能无损。比如说我们能用很函数式的方法处理迭代器，但最后生成的汇编和手写循环没什么区别。</p><p>并且Rust提供了<code>Box&lt;Fn() -&gt; T&gt;</code>和<code>Rc</code>让你可以手动做到别的语言自动做到的事情。你需要显式使用这些设施，因为这代表额外的开销。</p><p>而选择隐式的捕获规则是因为closure被设计为在某个特定上下文内以短小、简洁而频繁的方式书写<sup data-text="比如说参数和返回值的类型都可以省略" data-url="" data-draft-node="inline" data-draft-type="reference" data-numero="3">[3]</sup>。因此采用了这种隐式且最保守的捕获方式。代价就是容易让人摸不着头脑。虽说利大于弊，但的确是一个缺点（参见下一节的引用部分）。</p><h2>规则</h2><p>捕获规则最简单的情形是 <code>move || {...}</code> 它会尝试获取closure中用到的值的ownership，如果值是 <code>Copy</code> 的则 copy 一个。</p><p>而默认的捕获方式是：</p><ol><li>如果可以，则尽量用 <code>&amp;</code> 借用</li><li>否则，如果可以，则总是 <code>&amp;mut</code> 借用</li><li>最后，无计可施必须要 ownership 的话，才会 move</li></ol><p>捕获之后，根据你在 closure 代码中<b>如何使用捕获到的值</b>，编译器会为 closure 实现函数 traits。最后实现了哪些 traits 和捕获的方式（有没有加<code>move</code>）或者捕获到了哪些变量是无关的。</p><ul><li>所有函数都至少能调用一次，所以都会实现<code>FnOnce</code>。</li><ul><li>另外，对于那些<i>不会<b>移走</b>匿名结构体中变量</i>的 closure 实现 <code>FnMut</code>。</li><ul><li>并且，对于那些<i>不会<b>修改</b>匿名结构体中变量</i>的 closure 实现 <code>Fn</code>。</li></ul></ul></ul><p><code>FnOnce</code>, <code>FnMut</code> 和 <code>Fn</code>，下图中可以看出这三者是包含的关系。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-4910aa27ee411357590b8de05657865c_b.jpg" data-caption="" data-size="normal" data-rawwidth="1125" data-rawheight="588" class="origin_image zh-lightbox-thumb" width="1125" data-original="https://pic1.zhimg.com/v2-4910aa27ee411357590b8de05657865c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-4910aa27ee411357590b8de05657865c_b.jpg" data-caption="" data-size="normal" data-rawwidth="1125" data-rawheight="588" class="origin_image zh-lightbox-thumb lazy" width="1125" data-original="https://pic1.zhimg.com/v2-4910aa27ee411357590b8de05657865c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-4910aa27ee411357590b8de05657865c_b.jpg"/></figure><p>(<a href="https://link.zhihu.com/?target=https%3A//docs.google.com/drawings/d/1yuCkfuHW693Lg93in3Vk_hvIwJIQeOsfkX_2q5sC5H8/edit%3Fusp%3Dsharing" class=" wrap external" target="_blank" rel="nofollow noreferrer">Google Docs</a>)</p><p>其中<code>FnMut</code>和<code>Fn</code>能调用多次。<code>FnMut</code>调用时需要对自己匿名结构体的<code>&amp;mut self</code>引用。调用<code>Fn</code>只需要<code>&amp;self</code>引用就足够了。</p><blockquote>以下内容可以跳过。<br/>即使是面临必须要 ownership 的情况，如果值可以 <code>Copy</code>，编译器依然会避免 move，而是用 <code>&amp;</code> 的方式借用值，之后在需要的时候 <code>*</code>。相关文章是《<a href="https://link.zhihu.com/?target=https%3A//iovxw.net/p/rust-closure-and-copy/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Rust 闭包环境捕获行为与 Copy trait</a>》。<br/>我们都认为是 bug，直到<a href="https://link.zhihu.com/?target=https%3A//github.com/rust-lang/rust/issues/60413%23issuecomment-487965668" class=" wrap external" target="_blank" rel="nofollow noreferrer">语言团队成员回复说这是预料中的行为</a>。之后我注意到这是规则1较为反直觉的特例。</blockquote><h2>实践</h2><p>现在来写下不同类型的 closure。然后去看编译器产出的 MIR。</p><p>MIR 是中级中间表示（简称中二表示）详细可以看<a href="https://link.zhihu.com/?target=https%3A//blog.rust-lang.org/2016/04/19/MIR.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">官方博客的这篇文章</a>。我们关注的只是少部分内容，大部分看不懂也没关系。</p><p>总而言之，MIR 告诉我们「代码究竟会变成什么样」但又保留了类型信息，不像汇编那样面目全非。</p><h3>FnOnce</h3><p>Closure 中必须移走某个变量的 ownership，这种 closure 需要 <code>self</code> 来执行，所以只能 <code>FnOnce</code>。</p><p><a href="https://link.zhihu.com/?target=https%3A//play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2018%26gist%3D49be2b83ebe6e9dc7c85fb833c7fd9d5" class=" wrap external" target="_blank" rel="nofollow noreferrer">Playground</a> （点右上角 “RUN” 按钮旁的「…」按钮，再点 “MIR” 看结果。）</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">homu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Homura</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">get_homu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">homu</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">get_homu</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>调用时的 MIR</p><div class="highlight"><pre><code class="language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_4</span>: <span class="p">[</span><span class="n">closure</span><span class="o">@</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">9</span>:<span class="mi">20</span>: <span class="mi">9</span>:<span class="mi">27</span><span class="w"> </span><span class="n">homu</span>:<span class="nc">Homura</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_5</span>: <span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="nb">FnOnce</span>::<span class="n">call_once</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="n">_4</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="n">_5</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">bb1</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>可以看到它是以 <code>FnOnce</code> 方式调用的。</p><p><code>_4</code> 作为第一个参数传进去，它的类型 <code>[closure@src/main.rs:10:20: 10:27 homu:Homura]</code> 就是本文一直在叨念的匿名结构体了。其中 <code>home:Homura</code> 则是这个结构体捕获的变量和她的类型。</p><p><code>_5: ()</code> 代表着无参数。</p><p>Closure 代码所编译成的普通函数：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">main</span>::<span class="p">(</span><span class="n">_1</span>: <span class="p">[</span><span class="n">closure</span><span class="o">@</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">9</span>:<span class="mi">20</span>: <span class="mi">9</span>:<span class="mi">27</span><span class="w"> </span><span class="n">homu</span>:<span class="nc">Homura</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Homura</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_0</span>: <span class="nc">Homura</span><span class="p">;</span><span class="w">                  </span><span class="c1">// return place
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="n">bb0</span>: <span class="p">{</span><span class="w">                              
</span><span class="w">        </span><span class="n">_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="p">(</span><span class="n">_1</span><span class="p">.</span><span class="mi">0</span>: <span class="nc">Homura</span><span class="p">);</span><span class="w">        </span><span class="c1">// bb0[0]: scope 0 at src/main.rs:9:23: 9:27
</span><span class="c1"></span><span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w">                          </span><span class="c1">// bb0[1]: scope 0 at src/main.rs:9:27: 9:27
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>注意这里 <code>_1</code> 的类型：<code>[closure@src/main.rs:9:20: 9:27 homu:Homura]</code> 前没有 <code>&amp;</code> 或者 <code>&amp;mut</code>，代表这个调用后会消耗掉匿名结构体。</p><p><code>_0 = move (_1.0: Homura);</code> 可以看见内部移走了 <code>homu</code>。</p><h2>FnMut</h2><p>在 closure 中修改某个可变的引用<sup data-text="有一种符合直觉的例外在这里" data-url="https://doc.rust-lang.org/reference/types/closure.html#unique-immutable-borrows-in-captures" data-draft-node="inline" data-draft-type="reference" data-numero="4">[4]</sup>，但无需移走任何捕获到的值。这种 closure 必须请求一个<code>&amp;mut</code>，所以有<code>FnMut</code>。</p><p><a href="https://link.zhihu.com/?target=https%3A//play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2018%26gist%3Dec4a6dfb4373776899a44d4ab6f5efb7" class=" wrap external" target="_blank" rel="nofollow noreferrer">Playground</a></p><p>调用时：</p><div class="highlight"><pre><code class="language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_6</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">closure</span><span class="o">@</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">9</span>:<span class="mi">25</span>: <span class="mi">9</span>:<span class="mi">41</span><span class="w"> </span><span class="n">madoka</span>:<span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">std</span>::<span class="n">option</span>::<span class="nb">Option</span><span class="o">&lt;</span><span class="n">Madoka</span><span class="o">&gt;</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_7</span>: <span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">_5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="nb">FnMut</span>::<span class="n">call_mut</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="n">_6</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="n">_7</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">bb1</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>Closure 所生成的函数体：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">main</span>::<span class="p">(</span><span class="n">_1</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">closure</span><span class="o">@</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">9</span>:<span class="mi">25</span>: <span class="mi">9</span>:<span class="mi">41</span><span class="w"> </span><span class="n">madoka</span>:<span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">std</span>::<span class="n">option</span>::<span class="nb">Option</span><span class="o">&lt;</span><span class="n">Madoka</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以看到 <code>_1</code> 变成一个 <code>&amp;mut</code> 引用了。能多次调用而不会消耗匿名结构体。</p><p>被捕获的值变成了 <code>madoka:&amp;mut std::option::Option&lt;Madoka&gt;</code> 。于是在这个 closure 销毁之前别人都不能访问 <code>madoka</code> 了。</p><h3>Fn</h3><p>在 closure 中只会读取外部的值，只需要 <code>&amp;self</code> 就能执行，当然全部三种都实现了。</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">homu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Homura</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">mado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Madoka</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">marry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">homu</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mado</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">marry</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><a href="https://link.zhihu.com/?target=https%3A//play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2018%26gist%3D111e670f19717bfb7331e38e206bb165" class=" wrap external" target="_blank" rel="nofollow noreferrer">Playground</a></p><p>调用时：</p><div class="highlight"><pre><code class="language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_7</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">closure</span><span class="o">@</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">10</span>:<span class="mi">17</span>: <span class="mi">10</span>:<span class="mi">34</span><span class="w"> </span><span class="n">homu</span>:<span class="kp">&amp;</span><span class="nc">Homura</span><span class="p">,</span><span class="w"> </span><span class="n">mado</span>:<span class="kp">&amp;</span><span class="nc">Madoka</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_8</span>: <span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">_6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="nb">Fn</span>::<span class="n">call</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="n">_7</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="n">_8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">bb1</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>是用 <code>Fn</code> 的方式调用的。</p><p>Closure 生成的函数体：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">main</span>::<span class="p">(</span><span class="n">_1</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">closure</span><span class="o">@</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">10</span>:<span class="mi">17</span>: <span class="mi">10</span>:<span class="mi">34</span><span class="w"> </span><span class="n">homu</span>:<span class="kp">&amp;</span><span class="nc">Homura</span><span class="p">,</span><span class="w"> </span><span class="n">mado</span>:<span class="kp">&amp;</span><span class="nc">Madoka</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="o">&amp;</span><span class="n">Homura</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Madoka</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果 closure 根本不捕获任何东西，则匿名结构体是 <a href="https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/nomicon/exotic-sizes.html%23zero-sized-types-zsts" class=" wrap external" target="_blank" rel="nofollow noreferrer">Zero Sized Types</a>，在运行时不会被创建。这类 closure 等价于普通函数，自然也实现了全部三种。代码略。</p><h3>实现哪些 traits 和捕获到的值无关</h3><p>就算用 <code>move</code> 强制捕获变量的所有权，只要不移走它而仅仅是修改或读取它。这种情况依然会实现 <code>FnMut</code> 或 <code>Fn</code>。<a href="https://link.zhihu.com/?target=https%3A//play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2018%26gist%3D4e5061559d9d80ac364278e33caed614" class=" wrap external" target="_blank" rel="nofollow noreferrer">Playground</a></p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">homu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Homura</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">mado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Madoka</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">marry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="o">&amp;</span><span class="n">homu</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mado</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">marry</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这种代码，用了 <code>move</code> 所以会捕获 <code>homu</code> 和 <code>mado</code> 的所有权，但是MIR可以看到是通过 <code>Fn::call</code> 调用的：</p><div class="highlight"><pre><code class="language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_5</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">closure</span><span class="o">@</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">10</span>:<span class="mi">17</span>: <span class="mi">12</span>:<span class="mi">6</span><span class="w"> </span><span class="n">homu</span>:<span class="nc">Homura</span><span class="p">,</span><span class="w"> </span><span class="n">mado</span>:<span class="nc">Madoka</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_6</span>: <span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="nb">Fn</span>::<span class="n">call</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="n">_5</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="n">_6</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">bb1</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>看看closure所生成的函数体吧：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">main</span>::<span class="p">(</span><span class="n">_1</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">closure</span><span class="o">@</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">10</span>:<span class="mi">17</span>: <span class="mi">12</span>:<span class="mi">6</span><span class="w"> </span><span class="n">homu</span>:<span class="nc">Homura</span><span class="p">,</span><span class="w"> </span><span class="n">mado</span>:<span class="nc">Madoka</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_0</span>: <span class="p">();</span><span class="w">                      </span><span class="c1">// return place
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_2</span>: <span class="p">(</span><span class="o">&amp;</span><span class="n">Homura</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Madoka</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_3</span>: <span class="kp">&amp;</span><span class="nc">Homura</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">_4</span>: <span class="kp">&amp;</span><span class="nc">Madoka</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">bb0</span>: <span class="p">{</span><span class="w">                              
</span><span class="w">        </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">        </span><span class="n">_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">_1</span><span class="p">).</span><span class="mi">0</span>: <span class="nc">Homura</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">_1</span><span class="p">).</span><span class="mi">1</span>: <span class="nc">Madoka</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">_2</span><span class="p">.</span><span class="mi">0</span>: <span class="kp">&amp;</span><span class="nc">Homura</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="n">_3</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">_2</span><span class="p">.</span><span class="mi">1</span>: <span class="kp">&amp;</span><span class="nc">Madoka</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="n">_4</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不同于前一个没有加 <code>move</code> 的例子。<code>homu:Homura</code> 和 <code>mado:Madoka</code> 前<b>没有</b> <code>&amp;</code>，代表匿名结构体捕获了这两个变量的所有权。</p><p>然而捕获了那些变量的匿名结构体本身又是以 <code>_1: &amp;[closure...]</code> 的方式传入的。因为函数体内根本不会移走 <code>homu</code> 或者 <code>mado</code>。</p><p>如果修改这份代码在 closure 过程内修改 <code>mado</code> 的话会变成什么样呢？留作习题。</p><hr/><p><i>感谢 Telegram「Rust 众」群网友们对本文的帮助。</i></p><h2>相关阅读</h2><ol><li><a href="https://link.zhihu.com/?target=https%3A//stevedonovan.github.io/rustifications/2018/08/18/rust-closures-are-hard.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Why Rust Closures are (Somewhat) Hard</a></li><li><a href="https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/reference/types/closure.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Closure types</a></li><li><code><a href="https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/ops/index.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">std::ops::{Fn, FnMut, FnOnce}</a></code></li><li><a href="https://zhuanlan.zhihu.com/p/23710601" class="internal">闭包 - Rust编程</a></li><li><a href="https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/nomicon/hrtb.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Higher-Rank Trait Bounds (HRTBs)</a></li></ol><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
