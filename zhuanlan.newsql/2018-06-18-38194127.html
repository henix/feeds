<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Succinct Data Structure</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/38194127">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-ff9172b4ded7b8341521e52359f5736f_r.jpg" alt=""></div><blockquote>作者：唐刘</blockquote><p><br></p><p>最近看了一篇论文 <a href="https://db.cs.cmu.edu/papers/2018/mod601-zhangA-hm.pdf">SuRF: Practical Range Query Filtering with Fast Succinct Tries</a>，里面提到使用一种新的数据结构 Succinct Range Filter(SuRF) 替换掉了 RocksDB 默认的 Bloom filter， 在一些性能测试上面，尤其是 seek 上面，性能提升了不少，并且也降低了很多 I/O 开销，这一下子就引起了我的兴趣。</p><p>大家都知道，RocksDB 里面，为了加速 key 查询的速度，使用了 Bloom filter，但 Bloom filter 只适用于 point get，对于 seek 就无能为力了。虽然 RocksDB 后面引入了 <a href="https://github.com/facebook/rocksdb/wiki/Prefix-Seek-API-Changes">prefix seek</a>，但对于 key 的格式有要求，使用比较受限。为了提高 RocksDB range query 的速度，论文的作者引入了一种省空间的数据结构，也就是 SuRF。</p><p>在了解 SuRF 之前，首先要了解掌握的就是 Succinct data structure 相关的知识，这篇文章主要是讲 Succinct data structure 相关的东西，后面再讨论 SuRF 如何实现的。</p><h2><b>Rank 和 Select</b></h2><p>Succinct data structure 第一次提出，应该是 Guy Jacobson 的论文 "Succinct static data structures"，但实话，我在网上找了半天，都没找到这篇 paper，只是找到了作者另一篇 <a href="https://www.computer.org/csdl/proceedings/focs/1989/1982/00/063533.pdf">Space-efficient static trees and graphs</a>。它的主要思想就是使用非常少量的空间（接近信息编码的下界）来存储数据。你可以认为就是使用了一种非常高效的压缩算法，但不同于压缩，它同时来提供非常高效的查询。</p><p>对于 Succinct data structure 来说，我们会将数据按 0 和 1 来编码，所以可以用 bits，而不是 bytes。操作 succinct 数据，通常的就是几个操作函数：</p><ul><li><code class="inline">rank1(x)</code> - 返回在 range <code class="inline">[0, x] </code>里面 1 的个数</li><li><code class="inline">select1(y)</code> - 返回第 y 个 1 所在的位置</li></ul><p>上面我们只是列举了 rank1 和 select1，对应的也有 rank0 和 select0，这里就不需要解释了。这么说有点过于抽象，这里举一个简单的例子。假设我们有一个 bits 序列 <code class="inline">11000001</code>，那么 rank1 和 select1 可以映射如下：</p><img src="https://pic3.zhimg.com/v2-72b4ddac338988955659d310baa8fb06_r.jpg" data-caption="" data-size="normal" data-rawwidth="627" data-rawheight="154" data-watermark="watermark" data-original-src="v2-72b4ddac338988955659d310baa8fb06" data-watermark-src="v2-e1efc8d4d59f1d646f99911c5336ba78" data-private-watermark-src=""><p>另外，大家可以注意到，rank 和 select 其实是相反的，上面的例子，<code class="inline">select1(3) = 7</code>，然后我们也会发现，<code class="inline">rank1(7) = 3</code>。</p><h2><b>Level Order Unary Degree Sequence</b></h2><p>上面简单介绍了下 Succinct data structure 的 rank 和 select。 在 SuRF 里面，它参考的基础编码方式，是 Level order unary degree sequence(LOUDS)，在 LOUDS 里面，我们会将一颗树，分层依次进行编码。而规则也是非常的简单，如果这个树的节点有 N 个子节点，那么就用 N 个 1 来编码，然后最后加上 0。</p><p>假设我们有如下的 tree：</p><img src="https://pic3.zhimg.com/v2-db87a1aa60b4a0a3faf5e95b4b8d5487_r.jpg" data-caption="" data-size="normal" data-rawwidth="628" data-rawheight="418" data-watermark="watermark" data-original-src="v2-db87a1aa60b4a0a3faf5e95b4b8d5487" data-watermark-src="v2-cc129d1610a5eabd1c020d73c88d82e4" data-private-watermark-src=""><p>为了计算简单，LOUDS 会加入一个 pseudo root 节点，这里我们变成如下的 tree：</p><img src="https://pic4.zhimg.com/v2-9d23f7729fb2bb3d41fbaaa614c8af52_r.jpg" data-caption="" data-size="normal" data-rawwidth="625" data-rawheight="524" data-watermark="watermark" data-original-src="v2-9d23f7729fb2bb3d41fbaaa614c8af52" data-watermark-src="v2-ce54c62bc874167f09514a4cd17ff9df" data-private-watermark-src=""><p>然后我们对这个 tree 进行编码，得到：</p><img src="https://pic1.zhimg.com/v2-82332386cb20c9cdbc75bf0307ccb1e4_r.jpg" data-caption="" data-size="normal" data-rawwidth="625" data-rawheight="523" data-watermark="watermark" data-original-src="v2-82332386cb20c9cdbc75bf0307ccb1e4" data-watermark-src="v2-3f2e25516bb2a09b69e7d647c26fb76f" data-private-watermark-src=""><p>那么生成的 bits 序列为：</p><img src="https://pic2.zhimg.com/v2-612fed57670c2200ed027168d0da223f_r.jpg" data-caption="" data-size="normal" data-rawwidth="695" data-rawheight="229" data-watermark="watermark" data-original-src="v2-612fed57670c2200ed027168d0da223f" data-watermark-src="v2-0fa3ee7e129088f6ed765c1545e8d0fc" data-private-watermark-src=""><p>那么我们拿到了这一个序列到底有什么用呢？在 LOUDS 里面，我们可以非常方便的进行很多操作，假设我们的 node 就是按照上面的，0，1，2，这样的 number 来标记的，position 对应的就是 bits 里面的 position。我们通常会用两个计算公式来得到 node number 和 position 的对应关系：</p><ul><li><code class="inline">node-num = rank1(i)</code>：在 position i 得到对应的 node number，譬如 <code class="inline">rank1(2) = 2</code></li><li><code class="inline">i = select1(node-num)</code>，根据 node number，知道对应的 position，譬如 <code class="inline">select1(2) = 2</code></li></ul><p>有了上面的公式，我们就能对这个 tree 进行操作了：</p><ul><li><code class="inline">first_child(i) = select0(rank1(i)) + 1</code> - 得到第 i 个位置所在节点的第一个子节点所在的 position</li><li><code class="inline">last_child(i) = select0(rank1(i) + 1) - 1</code> - 得到第 i 个位置所在节点的最后一个子节点所在的 position</li><li><code class="inline">parent(i) = select1(rank0(i))</code> - 得到第 i 个位置所在节点的父节点所在的 position</li><li><code class="inline">children(i) = last_child(i) - first_child(i) + 1</code> - 得到第 i 个位置所在节点的子节点的个数</li><li><code class="inline">child(i, num) = first_child(i) + num</code> 得到第 i 个位置所在节点的第 num 个子节点所在的 position，<code class="inline">num &gt;= 0</code></li></ul><p>上面这些公式感觉好绕，那么我们来一个简单的例子，以节点 4 为例。从上面的 tree 可以知道，4 的 parent node 是 1，它的第一个子节点是 7，最后一个是 8，总共有两个子节点。</p><p>首先我们需要计算节点 4 的位置，根据上面的公式 <code class="inline">select1(4)</code> 我们得到 position 是 4。那么第一个子节点位置就是 <code class="inline">first_child(4) = select0(rank1(4)) + 1 = select0(4) + 1 = 9 + 1 = 10</code>，那么第一个子节点就是 <code class="inline">rank1(10) = 7</code>。</p><p>我们再来计算最后一个子节点，根据公式，最后一个就是 <code class="inline">last_child(4) = select0(rank1(4) + 1) - 1 = select0(4 + 1) - 1 = 12 - 1 = 11</code>，那么最后一个子节点就是 <code class="inline">rank1(11) = 8</code>。</p><p>再来看看父节点，就是 <code class="inline">parent(4) = select1(rank0(4)) = select1(1) = 0</code>，那么父节点就是 <code class="inline">rank1(0) = 1</code>。</p><h2><b>Epilogue</b></h2><p>使用 LODUS，我们可以用 bits 方便的编码一棵树，然后用 rank 和 select 操作，就能方便的对 tree 进行遍历，业内已经有很多 paper，能将 rank 和 select 做到 O(1) 的开销，所以速度还是很快的。</p><p>但在实际中，如果光用 LODUS，性能还是没法保证的，所以这也是为啥会有 SuRF 的原因，关于 SuRF，后面会在说明。</p><p>在数据库领域，Succinct 是一个比较有趣的研究方向，也有很多数据库采用了 succinct 来保存数据，毕竟如果能用更少的空间存放数据，memory 能装的更多，cache 更友好，性能就更好。但现在 succinct 还没有大规模的落地，可以看看后续的发展。如果你对构建新的存储引擎有兴趣，欢迎联系我 <a href="mailto:tl@pingcap.com">tl@pingcap.com</a>。</p><p><br></p><p><a href="https://www.jianshu.com/p/36781efac8e9">原文链接</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
