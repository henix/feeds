<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>递归函数（六）：最多有多少个程序</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34484014">原文</a></p>
<h2><b>回顾</b></h2><p>上一篇中，我们通过引入极小化算子定义了递归函数，<br>使用递归函数，我们又定义了递归集与递归可枚举集，<br>本文我们要讨论，为什么递归可枚举集是“可枚举”的，以及什么是可计算函数。</p><h2><b>可计算性</b></h2><img src="https://pic2.zhimg.com/v2-a4af83dc0f3607efe72758004eb1e9f5_r.jpg" data-caption="" data-size="normal" data-rawwidth="410" data-rawheight="429"><p>我们听说过，现代计算机在计算能力上是与图灵机等价的，<br>什么叫做计算能力呢？<br>它指的是图灵机可计算的函数集，与现代计算机可计算的函数集是相等的。</p><p>为了简单起见，我们不去讨论图灵机，而是从现代计算机直接说起，<br>设 <equation>\mathscr{P}</equation> 是一段程序， <equation>n</equation> 是一个正整数，<br>我们称数论函数 <equation>\psi (x_1,x_2,\cdots ,x_n)</equation> 为<b>程序 <equation>\mathscr{P}</equation> 所计算的</b> <equation>n</equation> 元部分函数，<br>如果对于相同的输入，<br>要么：（1）程序 <equation>\mathscr{P}</equation> 的计算可以终止，此时计算结果等于 <equation>\psi (x_1,x_2,\cdots ,x_n)</equation> 的相应函数值；<br>要么：（2）程序 <equation>\mathscr{P}</equation> 的计算不能终止，此时 <equation>\psi (x_1,x_2,\cdots ,x_n)</equation> 无定义。</p><p>设 <equation>f(x_1,x_2,\cdots ,x_n)</equation> 是一个部分函数，<br>如果存在程序 <equation>\mathscr{P}</equation> 可计算 <equation>f</equation> ，则称 <equation>f</equation> 是<b>部分可计算的</b>。<br>如果一个函数，既是部分可计算的，又是全函数，则称这个函数是<b>可计算的</b>。</p><p>可以证明，所有的原始递归函数和递归函数都是部分可计算的。</p><h2><b>通用程序</b></h2><p>我们使用现代计算机进行编程的时候，并不是直接把程序的输入传给程序，<br>而是将程序本身以及它的输入，传给计算机，最后由计算机得到计算结果，<br>像这种接受任何程序和它的输入作为自己的输入，返回程序执行结果的程序，称为<b>通用程序</b>。<br>为此，通用程序需要把输入的程序进行<b>编码</b>。</p><p>常用的编码方法，涉及<a href="https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0">配对函数</a>和<a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0">哥德尔编码</a>。<br>为了不引入太多的复杂性，我们可以将程序的编码理解为存储程序的二进制数据，<br>不同的程序会有不同的二进制表示，每一个二进制表示可以对应一段程序<br>（虽然可能不合法）。</p><p>哥德尔编码做的事情就是将程序和自然数集一一对应起来。</p><img src="https://pic3.zhimg.com/v2-9a7c9ce767daf3bef81c5e3e7d5c152e_r.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="565"><p>因此，所有程序的个数是<b>可数的</b>，而这些程序可计算的函数个数也一定是可数的，<br>它们可能是全函数，也可能是部分函数。<br>（其中，“可数”指的是可数集，<b>可数集</b>是与自然数集之间存在一一映射的集合。</p><p>然而，自然数集上的函数全体并不可数，（证略<br>所以肯定存在程序不可计算的函数。</p><h2><b>集合个数的可枚举性</b></h2><img src="https://pic4.zhimg.com/v2-216f0ef423d8f37598db6eee7ed05452_r.jpg" data-caption="" data-size="normal" data-rawwidth="389" data-rawheight="182"><p>程序 <equation>\mathscr{P}</equation> 所计算的函数，我们可以记为 <equation>\psi (x_1,x_2,\cdots ,x_n)</equation> ，<br>由此，我们可以定义通用程序 <equation>\Phi</equation> ，则有，<br> <equation>\Phi (x_1,x_2,\cdots ,x_n,y)=\psi (x_1,x_2,\cdots ,x_n)</equation> <br>其中， <equation>y</equation> 是程序 <equation>\mathscr{P}</equation> 的编码。</p><p>因为，所有的程序与自然数集一一对应，<br>所以， <equation>\Phi (x_1,x_2,\cdots ,x_n,0),\Phi (x_1,x_2,\cdots ,x_n,1),\cdots</equation> <b>枚举了所有的 <equation>n</equation> 元可计算函数。</b></p><p>我们定义 <equation>W_y=\lbrace x\in N|\Phi(x,y)\downarrow \rbrace</equation> ，<br>根据递归可枚举集的定义，每一个 <equation>W_y</equation> 是一个递归可枚举集。</p><p>又因为 <equation>\Phi(x,0),\Phi(x,1),\cdots</equation> 枚举了所有的可计算函数，<br>而上一篇中我们看到，递归可枚举集是由部分递归函数（即，可计算函数）定义的，<br>一个部分递归函数确定出一个递归可枚举集，<br>所以， <equation>W_0,W_1,\cdots</equation> <b>枚举了所有的递归可枚举集</b>。</p><p>因此，集合 <equation>B</equation> 是递归可枚举的，当且仅当存在 <equation>y\in N</equation> ，使得 <equation>B=W_y</equation> ，<br>称为<b>枚举定理</b>，这就是“枚举”的含义。</p><p>令 <equation>K=\lbrace n\in N|n\in W_n\rbrace</equation> ，<br>则 <equation>K</equation> 是递归可枚举的，但不是递归的，（证略<br>因此， <equation>\bar{K}</equation> 不是递归可枚举的，否则 <equation>K</equation> 就是递归集了。<br>（根据，集合 <equation>B</equation> 是递归的当且仅当 <equation>B</equation> 和 <equation>\bar{B}</equation> 是递归可枚举的，见上一篇</p><p>因此，我们找到了一个非递归的递归可枚举集 <equation>K</equation> ，<br>以及一个非递归可枚举集 <equation>\bar{K}</equation> 。</p><h2><b>停机问题</b></h2><img src="https://pic2.zhimg.com/v2-2649469b93d96783266c38873773ab78_r.jpg" data-caption="" data-size="normal" data-rawwidth="374" data-rawheight="234"><p>任给一个程序和一个自然数，问该程序对这个自然数输入的计算是否停止，<br>这个问题称为<b>停机问题</b>。</p><p>我们可以用谓词 <equation>H(x,y)</equation> 描述这个问题，<br> <equation>H(x,y)</equation> ，表示以 <equation>y</equation> 为代码的程序对输入 <equation>x</equation> 的计算最终停止。<br>那么， <equation>H(x,y)</equation> 是不可计算的，即，不存在一个程序来计算 <equation>H(x,y)</equation> 。</p><p>我们来证明一下，假设有一个程序可以计算 <equation>H(x,y)</equation> ，<br>那么我们就能用它来构造一个新程序 <equation>\mathscr{P}</equation> ，它的输入是 <equation>x</equation> ，<br>这段程序当 <equation>H(x,x)</equation> 为真时，计算不停止，而当 <equation>H(x,x)</equation> 为假时，计算停止。</p><p>程序 <equation>\mathscr{P}</equation> 也可以进行编码，假设为 <equation>y_0</equation> ，现在我们来判断 <equation>H(y_0,y_0)</equation> 。</p><p>如果 <equation>H(y_0,y_0)</equation> 为真，意味着编码为 <equation>y_0</equation> 的程序以 <equation>y_0</equation> 作为输入最终停止，<br>即程序 <equation>\mathscr{P}</equation> ，输入为 <equation>y_0</equation> 时，最终停止，<br>可是根据 <equation>\mathscr{P}</equation> 的定义，此时 <equation>H(x,x)=H(y_0,y_0)</equation> 为假才会停止，矛盾。</p><p>如果 <equation>H(y_0,y_0)</equation> 为假，意味着编码为 <equation>y_0</equation> 的程序以 <equation>y_0</equation> 作为参数最终不会停止，<br>即程序 <equation>\mathscr{P}</equation> ，输入为 <equation>y_0</equation> 时，最终不停止，<br>可是根据 <equation>\mathscr{P}</equation> 的定义，此时 <equation>H(x,x)=H(y_0,y_0)</equation> 为真才不会停止，矛盾。</p><p><equation>H(y_0,y_0)</equation> 不能为真也不能为假，矛盾，<br>因此，计算 <equation>H(x,y)</equation> 的程序<b>不存在</b>，我们也无法用它来构造程序 <equation>\mathscr{P}</equation> 。</p><h2><b>可判定性</b></h2><img src="https://pic2.zhimg.com/v2-2b6940df2115ed418d982f28f5263301_r.jpg" data-caption="" data-size="normal" data-rawwidth="500" data-rawheight="380"><p><b>可判定性问题</b>，指的是一个询问真或者假的问题是否可以被回答。<br>如果我们总能回答出这个问题是真或者是假，就称该问题是<b>可判定的</b>，<br>如果我们只能当问题为真的时候确定为真，为假的时候所进行的计算可能不会终止，<br>那么就称该问题是<b>半可判定的</b>。</p><p>某元素是否属于一个递归集，是可判定的，<br>某元素是否属于一个递归可枚举集，是半可判定的。</p><p>因为，递归集是使用一个递归的全函数定义的，<br>而递归可枚举集是使用第一个部分递归函数定义的，<br>我们无法判断某个部分递归函数，在接受某参数时，是没有定义，还是计算尚未停止。<br>即，判断元素是否属于某递归可枚举集的程序可能永不停机<b>。</b></p><h2><b>总结</b></h2><p>本文介绍了函数的可计算性，通用程序，以及最多有多少个程序，<br>还了解了停机问题和可判定性问题。</p><p>这些都是可计算性理论的基础，我们清晰的看到了人类的计算能力，<br>以及用递归所能计算的函数范围，后文中我们开始讨论不动点理论，<br>这同样是一个有趣的话题。</p><h2><b>附</b></h2><p>配对函数和哥德尔数，是对数偶和有穷数列的一种编码方式。</p><p><b>（1）配对函数</b></p><p>令 <equation>\langle x,y\rangle=2^x(2y+1)-1</equation> ，称 <equation>\langle x,y\rangle</equation> 为<b>配对函数</b>，它是一个原始递归函数。</p><p>任给一个数 <equation>z</equation> ，存在唯一的一对数 <equation>x</equation> 和 <equation>y</equation> ，使得 <equation>\langle x,y\rangle =z</equation> 。<br> <equation>x</equation> 是 <equation>z+1</equation> 含有因子 <equation>2</equation> 的个数，即使得 <equation>2^t|(z+1)</equation> 的 <equation>t</equation> 的最大值。<br> <equation>(z+1)/2^x</equation> 必为奇数， <equation>y</equation> 是 <equation>2y+1=(z+1)/2^x</equation> 的唯一解。</p><p>一般的，记 <equation>l(z)=x</equation> ， <equation>r(z)=y</equation> ，则 <equation>l(z)</equation> 和 <equation>r(z)</equation> 也是原始递归函数。</p><p><b>（2）哥德尔数</b></p><p>记 <equation>[a_1,a_2,\cdots ,a_n]=\prod_{i=1}^{n}p_i^{a_i}</equation> ，<br> <equation>[a_1,a_2,\cdots ,a_n]</equation> 称为有穷数列 <equation>(a_1,a_2,\cdots ,a_n)</equation> 的哥德尔数，其中， <equation>p_i</equation> 是第 <equation>i</equation> 个素数。</p><p>例如，[ <equation>[2,0,1,3]=2^2\cdot 3^0\cdot 5^1\cdot 7^3=6860</equation> 。<br>对于每一个固定的 <equation>n</equation> ， <equation>[a_1,a_2,\cdots ,a_n]</equation> 是原始递归函数，并且这种编码具有唯一性。</p><hr><h2><b>参考</b></h2><p><a href="https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0">配对函数</a> <br><a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0">哥德尔数</a> <br><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%95%B8%E9%9B%86">可数集</a> <br><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7">可判定性</a> <br><a href="https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E6%89%98%E5%B0%94%E5%AE%9A%E7%90%86">康托尔定理</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
