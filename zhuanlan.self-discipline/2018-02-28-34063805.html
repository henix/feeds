<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>柯里化的前生今世（三）：语言和同像性</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34063805">原文</a></p>
<p>按照故事情节的正常发展，我们这一篇该介绍Racket语言的语法了。<br>可是，在大局观上，我们还没有达成共识。<br>对于一个概念来说，我们不止要学会怎样描述它，还要学会理解它的内涵。<br>因此，这篇还是在打基础，俗称，引言。。</p><h2><b>关于</b></h2><p>本文是系列文章中的第三篇，发布在<a href="https://zhuanlan.zhihu.com/c_166576777">业余程序员的个人修养</a>这个专栏中：<br><a href="https://zhuanlan.zhihu.com/p/34060802">柯里化的前生今世（一）：函数面面观</a> <br><a href="https://zhuanlan.zhihu.com/p/34063576">柯里化的前生今世（二）：括号神教</a></p><p>在上一篇中，我们提到了Lisp语言家族，看到了关于Lisp最美丽的传说，我们提到了Racket，以及它的IDE，DrRacket。</p><p>本文将从目标语言和元语言，同像性（Homoiconicity），引用等这些角度来深入的讨论Lisp，<br>浅尝辄止，毕竟不是一个好习惯。</p><h2><b>目标语言和元语言</b></h2><p>当我们讨论一件事物时，我们所使用的语言被称为对象语言。<br>而当我们谈论一种语言时，我们所使用的语言被称为元语言。</p><p>在任何语言研究中，都有一种作为研究对象的语言，还有一种由研究者用来谈论对象语言的元语言。<br>对象语言与元语言是相对而言的。<br>任何语言，无论它多么简单或者多么复杂，当它作为被谈论的对象的时候，它就是对象语言；<br>当它用来讨论一种语言的时候，它就是元语言。</p><p>区分开目标语言和元语言，是学好Lisp的第一步，也是理解Lisp元编程的第一步。</p><h2><b>形式语言</b></h2><p>日常生活中，我们有了这样的认识。<br>我们所了解的汉字总是有限的，但是我们能说的话，却是无限的。<br>可以说出任意长度的汉字序列。</p><p>程序语言也是如此。<br>有人说编程，不就是输入A到Z吗，指的就是这个编程语言的“字母表”。<br>字母表所包含的字母，是有限的，但是可以写出无限多个“句子”。</p><p>“语言”，正是这些“句子”的集合。<br>所谓形式语言，指的是用精确的数学，或机器可处理的公式，定义的语言。<br>相应的数学和计算机科学分支叫做形式语言与自动机理论，<br>它只研究语言的语法而不讨论它的语义。</p><p>当初，为了研究语言的性质，人们从两个角度出发，<br>一个是从语言的识别角度来看，提出了自动机理论。<br>另一个是从语言的生成角度来看，有乔姆斯基开创的形式语言理论。<br>这两个理论之间，又是互相关联的。</p><h2><b>文法</b></h2><p>文法提供了一种方便的方法来定义“句子”的无限集。</p><p>为了描述语言的结构，John Backus和Peter Naur创造了一种语言的描述方法，<br>称为BNF（Backus-Naur Form）。</p><code lang="bnf">expr ::= term { "+" term | "-" term }.
term ::= factor { "*" factor | "/" factor }.
factor ::= "(" expr ")".</code><p>BNF表示中的每一行，称为一个“产生式”，<code class="inline">::=</code>表示左边的项可以由右边的项来产生。<br>其中，用引号括起来的项，称为“终结符”，相当于字面量。<br>不用引号括起来的项，称为“非终结符”，它们可以由其他项组成。</p><p><code class="inline">{…}</code>是约定好了的符号，用来表示它包含的项可以出现0次或更多次。<br>常用的还有<code class="inline">[…]</code>，用来表示，可以出现也可以不出现。</p><p>以上BNF描述了算术表达式的语法。<br>例如：<code class="inline">1*(2+3)</code>，可以从<code class="inline">expr</code>开始生成出来，</p><code lang="text">expr
=&gt; factor “*” factor
=&gt; factor “*” “(” expr “)”
=&gt; factor “*” “(” term “+” term “)”
=&gt; 1 “*” “(” 2 “+” 3 “)”</code><p><code class="inline">expr</code>称为“开始符号”。</p><p>综上，一个语言的所有终结符，非终结符，产生式，开始符号，<br>构成了这个语言的文法。</p><h2><b>语言的分类</b></h2><p>乔姆斯基，根据语言文法产生式的特点，把语言分为了4类。<br>不同的文法，能描述不同范围的语言集合，虽然它们都是无限集。</p><p>0型文法，能力最强，可以产生递归可枚举语言。<br>1型文法，能力稍弱，可以产生上下文有关语言。<br>2型文法，能力次之，可以产生上下文无关语言。<br>3型文法，能力最弱，可以产生正则语言。</p><p>这些文法，建立了一个从大到小，互相包含的，语言集合的层次关系。<br>例如：正则语言，一定是上下文无关语言，反之，则不成立。<br>其中，2型和3型文法用的最多，有特殊的名字，称为，上下文无关文法，正则文法。</p><p>我们似乎发现了，这里也出现了“正则”两个字，难道与正则表达式有关？<br>确实，正则表达式，是正则文法的便利写法。<br>正则表达式所描述的语言，就是正则语言。</p><h2><b>S表达式</b></h2><p>了解过Racket之后，我们发现Racket程序都用一种称为S表达式的语法写成。<br>S表达式，是Lisp语言的特色，它是二叉树的一种线性编码。</p><p>我们知道二叉树是很重要的数据结构，可以用来存储结构化的数据。例如：</p><code lang="text">     *
   /   \
  *     *
 / \   / \
a   b c   d</code><p>二叉树的每个节点，或者是叶节点，或者有2个子节点，叶节点可以用来存储数据。<br>可是，这样表示二叉树，太麻烦了，不容易书写。<br>于是，先哲们发明了“点对表示法”，<code class="inline">((a . b) . (c . d))</code>可以表示上面的二叉树，<br>其中“<code class="inline">.</code>”表示节点。</p><p>S表达式是点对表示法的形式定义：</p><code lang="bnf">Atom ::= Num | Symbol
S-exp ::= Atom | "(" S-exp "." S-exp ")"</code><p>所以，S表达式或者是原子（Atom），或者是递归的由其他S表达式构成的点对。</p><p>实际使用时，书写S表达式，还要同时写很多点号“<code class="inline">.</code>”，这也是一件麻烦的事情。<br>因此，Lisp语言定义了一套S表达式的化简规则。<br>（1）如果一个点号右邻一个左括号，那么就可以将这个点号，左括号以及匹配的右括号，一起去掉。<br>例如：<code class="inline">(a . (b . c)) &lt;=&gt; (a b . c)</code></p><p>（2）如果一个点号右邻原子<code class="inline">nil</code>，那么就可以把这个点号和原子<code class="inline">nil</code>，一起去掉。<br>例如：<code class="inline">(a . (b . nil)) &lt;=&gt; (a b . nil) &lt;=&gt; (a b)</code></p><h2><b>同像性（Homoiconicity）</b></h2><p>同像性，指的是程序和程序所操作的数据采用了统一编码。</p><p>Lisp语言使用了S表达式，例如，<code class="inline">(fn x)</code>，<br>既可以看做是程序，用参数x调用函数fn，<br>也可以看做是数据，由符号fn和符号x构成的列表。</p><p>同像性使得我们，可以像处理数据一样处理代码。<br>做一些代码转换之类的工作，十分简单。</p><p>例如，<br>当遇到<code class="inline">(fn x)</code>时，<br>我们可以让它先转换成，</p><code lang="racket">(begin
    (display x)
    (gn x))</code><p>然后再执行。</p><p>甚至也可以用来定义变量，</p><code lang="racket">(define-with-display (f a)
    (g a))</code><p>转换成，</p><code lang="racket">(define (f a)
    (display a)
    (g a))</code><p>这种代码层面的转换称为“宏”(macro)。</p><h2><b>引用</b></h2><p>在Lisp语言中，引用（quotation）是一个很独特的概念。<br>这与按引用传参（call by reference）完全是两码事。</p><p>在Lisp程序中，我们知道<code class="inline">(+ 1 2)</code>是一个加法调用，<br>但是它也可以表示由3个符号<code class="inline">+</code>，<code class="inline">1</code>和<code class="inline">2</code>构成的列表。<br>列表是数据，加法调用是程序，它们虽然采用了相同的编码，可是我们没有办法区分。</p><p>首先想到的就是让它们采用不同的编码。例如：<br>我们把函数调用编码为<code class="inline">+[1;2]</code>，而列表编码为<code class="inline">(+ 1 2)</code><br>人们一开始也是这么做的，<code class="inline">+[1;2]</code>称为M表达式，<code class="inline">(+ 1 2)</code>称为S表达式。</p><p>可是，后来人们发现，如果用Lisp语言来处理Lisp程序文本时，<br>不同的编码，会增加难度，即，失去了同像性的种种优势。</p><p>另一方面，程序主要是由函数调用组成的，把程序看成数据是更少见的一种场景。<br>所以，人们进行了以下编码，<br>函数调用编码为<code class="inline">(+ 1 2)</code><br>而列表编码为<code class="inline">(quote (+ 1 2))</code></p><p>即，<code class="inline">(+ 1 2)</code>求值，会导致函数调用。<br><code class="inline">(quote (+ 1 2))</code>求值，会得到一个列表。<br>于是，我们就统一的用S表达式，完成了对程序和数据的相同编码。</p><h2><b>后文所需要的基础</b></h2><p>下一篇文章，我们要回到高阶函数上来了，我们要写一个简易的解释器，<br>实现词法作用域，然后自然的得到闭包这种数据结构。<br>所以，Racket语法方面，大家还是抽空多了解下吧，需要介绍吗？</p><hr><h2><b>参考</b></h2><p><a href="http://baike.baidu.com/view/10291477.htm">元语言</a> <br><a href="https://zh.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80">形式语言</a> <br><a href="https://zh.wikipedia.org/zh/S-%E8%A1%A8%E8%BE%BE%E5%BC%8F">S表达式</a> <br><a href="https://en.wikipedia.org/wiki/Homoiconicity">同像性</a> <br><a href="https://book.douban.com/subject/2152385/">程序设计语言：实践之路</a> <br><a href="https://book.douban.com/subject/5904140/">LISP语言</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
