<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>业界 | 一文概览2017年Facebook AI Research的计算机视觉研究进展</title>
</head>
<body>
<p><a href="https://mp.weixin.qq.com/s?timestamp=1522272895&amp;src=3&amp;ver=1&amp;signature=xPCn*voBMX4aVNBBnj9pyqCdg0*cETaNED9C0KGj7xMFHXl7YPwB4ZJnLgL*O0GHTX*bn7PpiaqlikaprjnNVK0woAzyvIX18ATL5-zKc4iMTI*S8Q4zyHZTimNQcIspFodnnBMrBN555H*Lgv2-B0BOHtWAYO0wp2E0mKmDoug=">原文</a></p>
<div id="img-content">
                
                <h2 class="rich_media_title" id="activity-name">
                    业界 | 一文概览2017年Facebook AI Research的计算机视觉研究进展                                    </h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                            <em id="post-date" class="rich_media_meta rich_media_meta_text">2018-03-19</em>

                                        <a class="rich_media_meta rich_media_meta_link rich_media_meta_nickname" href="##" id="post-user">机器之心</a>
                    <span class="rich_media_meta rich_media_meta_text rich_media_meta_nickname">机器之心</span>


                    <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                        <div class="profile_inner">
                            <strong class="profile_nickname">机器之心</strong>
                            <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                            <p class="profile_meta">
                            <label class="profile_meta_label">微信号</label>
                            <span class="profile_meta_value">almosthuman2014</span>
                            </p>

                            <p class="profile_meta">
                            <label class="profile_meta_label">功能介绍</label>
                            <span class="profile_meta_value">专业的人工智能媒体和产业服务平台</span>
                            </p>
                            
                        </div>
                        <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                            <i class="profile_arrow arrow_out"></i>
                            <i class="profile_arrow arrow_in"></i>
                        </span>
                    </div>
                </div>
                
                
                
                
                                                
                                                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;"></span></p><section style="max-width: 100%;color: rgb(62, 62, 62);font-size: 16px;white-space: normal;background-color: rgb(255, 255, 255);line-height: 28.4444px;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section data-id="85660" data-custom="rgb(117, 117, 118)" data-color="rgb(117, 117, 118)" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section data-id="85660" data-custom="rgb(117, 117, 118)" data-color="rgb(117, 117, 118)" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: currentcolor;font-family: 微软雅黑;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="margin-top: 2em;padding-top: 0.5em;padding-bottom: 0.5em;max-width: 100%;border-style: solid none;font-family: inherit;text-decoration: inherit;border-top-color: rgb(204, 204, 204);border-bottom-color: rgb(204, 204, 204);border-top-width: 1px;border-bottom-width: 1px;box-sizing: border-box !important;word-wrap: break-word !important;"><p style="margin-top: -1.2em;max-width: 100%;min-height: 1em;text-align: center;line-height: 1.75em;border-width: initial;border-style: initial;border-color: currentcolor;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(255, 255, 255);background-color: rgb(117, 117, 118);box-sizing: border-box !important;word-wrap: break-word !important;">选自<span style="max-width: 100%;font-size: 14px;">skrish13</span></span></p><section data-style="white-space: normal; text-align: left;font-size: 14px;line-height: 1.5em; color: rgb(12, 12, 12);" style="padding: 16px 16px 10px;max-width: 100%;font-family: inherit;box-sizing: border-box !important;word-wrap: break-word !important;"><p style="max-width: 100%;min-height: 1em;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 12px;color: rgb(136, 136, 136);box-sizing: border-box !important;word-wrap: break-word !important;">作者：Krish</span></strong></p><p style="max-width: 100%;min-height: 1em;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 12px;color: rgb(136, 136, 136);box-sizing: border-box !important;word-wrap: break-word !important;">机器之心编译</span></strong></p><p style="max-width: 100%;min-height: 1em;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 12px;color: rgb(136, 136, 136);box-sizing: border-box !important;word-wrap: break-word !important;">参与：路雪、刘晓坤</span></strong></p></section></section></section></section></section></section></section></section></section></section></section></section><p style="max-width: 100%;min-height: 1em;color: rgb(62, 62, 62);font-size: 16px;white-space: normal;background-color: rgb(255, 255, 255);text-align: justify;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 14px;box-sizing: border-box !important;word-wrap: break-word !important;">  </span></p><blockquote><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;color: rgb(136, 136, 136);">本文概述了 2017年Facebook AI 研究院（FAIR）在计算机视觉上的研究进展，包括基础构建模块创新、CNN、one shot 目标检测模块等，然后介绍实例分割方面的创新，最后介绍用弱半监督方式来扩展实例分割。</span><br></p></blockquote><p><span style="font-size: 14px;text-align: justify;"><br></span></p><p style="text-align: center;"><span style="font-size: 16px;"><strong><span style="text-align: justify;">特征金字塔网络（FPN）</span></strong></span><br></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">首先我们先来介绍著名的<a href="http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650729285&amp;idx=3&amp;sn=ae6d28f7423b24bf1f63143af52c79d8&amp;chksm=871b2f3bb06ca62d6e7c6e6db251f754d27b7cd36a9aea7f86fa073f8e710a93924fbb6a4535&amp;scene=21#wechat_redirect" target="_blank">特征金字塔网络</a> [1]（发表在 CVPR 2017 上）。FPN 论文非常棒，要知道，构建一个可在多项任务、子主题和应用领域中使用的基线模型并不简单。FPN 是通用特征提取网络（如 ResNet、DenseNet）的扩展。你可以从喜欢的 DL 库中选择预训练的 FPN 模型，然后像使用其他模型一样使用它！</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">图像目标通常有多个尺度和大小。一般的数据集无法捕捉所有这些属性，因此人们使用图像金字塔（图像的多种分辨率降级），以方便 CNN 处理。但是这样很慢。因此人们使用单个尺度预测，一些人可能从中间层获取预测结果，它是在特征空间中进行的。这很好理解，在几个 ResNet 模块后放置一个反卷积层，获取分割输出（就分类而言，可能是 1x1 卷积和 GlobalPool）。现在大量此类架构在有辅助信息和辅助损失的情况下使用。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">回到主题，FPN 的作者发现一种有效改善上述方法的方式。他们不只使用侧向连接，还使用自上而下的路径。这非常有效！他们使用一个简单的 MergeLayer（mode=『addition』）将二者结合起来。该想法的关键是底层特征图（初始卷积层）的语义不够强，无法用于分类。而深层特征图有更强的语义。这里还有一个优势，即自上而下的路径 FMaps（特征图），可以达到最深层网络同样的效果。这是因为结合了侧向连接和自上而下的连接。</span></p><p style="text-align: justify;line-height: 1.75em;"><br></p><p><img class="" data-copyright="0" data-ratio="0.9452054794520548" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxEuZ91UfMutRlK2nY2vW5we8dx9axmEm0ZzPWVXw7Knu8ia5CKv1Zn9bGFQlLuQYtMNJyZMOdqNw/640?wx_fmt=png" data-type="png" data-w="730" style=""></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 14px;">细节</span></strong></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">金字塔：同样大小的所有特征图属于同一个阶段。最后一层的输出是金字塔的 reference FMaps。如：ResNet，第 2、3、4、5 个模块的输出。你可以根据内存和特定使用情况改变金字塔。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">侧向连接：1x1 卷积和自上而下的路径都经过两倍上采样。上层特征自上而下生成粗糙的特征，而侧向连接从自下而上的路径添加更细粒度的细节。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">那篇论文中介绍了一个简单的 demo，展示了这个想法结合简单的设计思路的效果。</span></p><p style="text-align: justify;line-height: 1.75em;"><br></p><p><img class="" data-copyright="0" data-ratio="0.6821480406386067" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxEuZ91UfMutRlK2nY2vW5mMpwZfunQbLBUDuVuufrP1RsKRicibKV9Sic5cWTicw5NIyJhUuDmk1jNw/640?wx_fmt=png" data-type="png" data-w="689" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;"></span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">如前所述，这是一个可以在多项任务中使用的基线模型，如目标检测、分割、姿态估计、人脸检测，以及所有应用领域。这篇论文问世不过寥寥数月，但引用量已经超过 100！这篇论文的题目是《FPNs for Object Detection》，因此作者继续在 RPN（区域建议网络）和 Faster-RCNN 网络中使用 FPN 作为基线模型。所有关键细节这篇论文中都有讲述，这里我列出了一些要点。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 14px;">实验要点</span></strong></p><p><br></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">在 RPN 中使用 FPN：将单个尺度 FMap 替换成 FPN。他们在每一级都有单尺度 anchor（由于使用了 FPN，所以没必要使用多尺度 anchor）。作者还展示了金字塔所有层级都共享类似的语义水平。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">Faster RCNN：他们用类似图像金字塔输出的方式处理这个金字塔。因此 RoI 使用以下公式被分配至特定的级别：</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;"></span></p></li></ul><p><br></p><p><img class="" data-copyright="0" data-ratio="0.11702127659574468" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxEuZ91UfMutRlK2nY2vW5z17tnNF1Jl0KECiaiaJRpFNMsqatXLq7dDNBW99H0jZKtvBAG2QCK7Bw/640?wx_fmt=png" data-type="png" data-w="188" style=""></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">其中 w、h 代表宽度、高度。k 代表 RoI 被分配的级别。k_0 是 w,h=224,224 映射至的级别。</span></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">在 COCO 数据集上获取当前最优结果，没有任何不必要的功能。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">他们对每个模块的功能进行了 ablation 研究，因此他们能够从一开始就证明了自己的说法。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">他们还基于 DeepMask 和 SharpMask 论文展示了如何使用 FPN 进行分割建议生成（segmentation proposal generation）。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;"></span></p><p><br></p></li></ul><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">对实现细节、实验设置等感兴趣的同学应该认真阅读这篇论文。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 14px;">代码</span></strong></p><p><br></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;"> Official Caffe2 - https://github.com/facebookresearch/Detectron/tree/master/configs/12_2017_baselines</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">Caffe - https://github.com/unsky/FPN</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">PyTorch - https://github.com/kuangliu/pytorch-fpn (just the network)</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">MXNet - https://github.com/unsky/FPN-mxnet</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">Tensorflow - https://github.com/yangxue0827/FPN_Tensorflow</span></p></li></ul><p><br></p><p style="text-align: center;line-height: 1.75em;"><span style="font-size: 16px;"><strong>RetinaNet：在密集目标检测中使用 Focal Loss</strong></span><br></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">该架构由同一个团队所开发，也是同一个一作。这篇论文 [2] 在 ICCV 2017 上发表。该论文中有两个关键点：通用损失函数 Focal Loss（FL）和单阶段的目标检测器 RetinaNet。两者的组合使其在 COCO 目标检测任务中表现得非常好，并打败了上述的 FPN 基准结果。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 14px;">Focal Loss</span></strong></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">该论文中的方法相当聪明和简单。如果你熟悉加权损失的话，那么该方法其实就是使用了巧妙的加权，让训练更加聚焦于分类难度高的样本。公式如下所示，其含义是很明显的。</span></p><p><br></p><p><img class="" data-copyright="0" data-ratio="0.3172043010752688" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxEuZ91UfMutRlK2nY2vW5QzUAzibCcDoicJa9e4X4uNsibJHR8lQ3SSWp4jIIfbVneQE2GZwAfWe3g/640?wx_fmt=png" data-type="png" data-w="372" style=""></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">γ是一个可改变的超参数。p_t 是分类器输出的样本概率。将 γ 设为大于 0 将减小分类结果较好的样本的权重。α_t 是通常的加权损失函数中的类别权重。在论文中它被称为 α-balanced 损失。需要注意，这个是分类损失，它将和 smooth L1 损失结合，用于 RetinaNet 的目标检测任务。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 14px;">RetinaNet</span></strong></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">FAIR 竟然会发布单阶段检测器，这令人难以置信。直到目前，YOLOv2 和 SSD 仍在单阶段场景中占据主导地位。但作者指出，它们都没有接近当前最佳的结果。而 RetinaNet 可以轻松地做到，仅使用了单阶段，并且速度很快。他们称其顶尖结果源于新型损失函数的应用，而不是简单的网络（其后端为 FPN）。其中利用的思想是单阶段检测器将面临很多背景和正类别不平衡的情况（不是正类别之间的不平衡）。作者称加权损失函数仅仅是为了平衡，而 FL 是针对难度小/大的样本，而两者是可以结合的。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 14px;">注意：</span></strong></p><p><br></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">两阶段检测器无需担心不平衡的情况，因为第一阶段就移除了几乎所有不平衡。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">两部分：主干网络（卷积特征提取器，如 FPN）和两个特定任务的子网络（分类器和边界框回归器）。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">在选择不同的组件设计时，（性能）没有太多变化。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">Anchor 或 AnchorBoxes 是 RPN 的相同 Anchor [5]。其中心围绕滑动窗口，且与长宽比有关。大小和长宽比分别对应 32^2 到 51^2 和 {1:2, 1:1, 2:1}。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">在 FPN 的每一阶段，我们都有 cls+bbox 子网络，给出 anchor 中所有位置的对应输出。</span></p></li></ul><p><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 14px;">代码</span></strong></p><p><br></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;"> Official Caffe2 - https://github.com/facebookresearch/Detectron/tree/master/configs/12_2017_baselines</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">PyTorch - https://github.com/kuangliu/pytorch-retinanet</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">Keras - https://github.com/fizyr/keras-retinanet</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">MXNet - https://github.com/unsky/RetinaNet</span></p></li></ul><p><br></p><p style="text-align: center;line-height: 1.75em;"><span style="font-size: 16px;"><strong>Mask R-CNN</strong></span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><a href="http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650724526&amp;idx=2&amp;sn=10ccdf74b480da89fce21ca7501718c1&amp;chksm=871b1cd0b06c95c60c0a03580f5a21abd03c06193f1ac67440e6fb69609af5e7b7c029355568&amp;scene=21#wechat_redirect" target="_blank"><span style="font-size: 14px;">Mask R-CNN</span></a><span style="font-size: 14px;"> [3] 几乎是同一个团队开发的，发表在 ICCV 2017 上，该模型用于实例分割。对于外行来说，这不过是不使用边界框的目标检测，任务是给出目标的准确分割掩码。你可以说它只是一个简单的想法，但是使之运行并成为当前最佳，为预训练模型提供最快的实现，这可是惊人的工作！</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">TL;DR：如果你了解 Faster-RCNN，那么 Mask R-CNN 很简单，只需要添加一个用于分割的 head（分支）。因此基本上是 3 个分支，分别用于分类、边界框回归和分割。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">再次强调，其重点在于使用简单、基础的网络设计来展示该方法的效率。他们不需要什么花哨的功能就实现了当前最佳。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">我很喜欢这篇论文，它很简单，但是看似简单的东西有大量解释。例如，多项式掩码 vs 独立掩码的使用（softmax vs sigmoid）。此外，它并未假设大量先验知识，也没有要解释一切。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">如果你仔细查看这篇论文，你可能会找到他们（基于现有设置）的新想法无法有效运行的原因。以下解释基于你对 Faster RCNN 已经有了基础了解：</span></p><p><br></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">Mask R-CNN 与 FasterRCNN 类似，两阶段，第一阶段是 RPN。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">添加一个并行分支用于预测分割掩码——FCN。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">损失是 L_cls、L_box、L_maskLcls、L_box、L_mask 的总和。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">用 ROIAlign 层替换 ROIPool。这不像 ROIPool 那样将你的（x/spatial_scale）fraction 四舍五入成整数，而是通过双线性内插法找出特定浮点值的像素。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">例如：ROI 高度和宽度分别是 54、167。空间尺度基本上是图像大小／FMap 大小（H/h），在此语境中也叫作 stride。通常是 224/14 = 16 (H=224,h=14)。</span></p></li></ul><p><br></p><ul class=" list-paddingleft-2" style="list-style-type: circle;"><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">ROIPool: 54/16, 167/16 = 3,10</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">ROIAlign: 54/16, 167/16 = 3.375, 10.4375</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">现在，我们使用双线性内插法对其进行上采样。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">类似的逻辑适用于根据 ROIAlign 输出形状（如 7x7）将对应的区域分割成合适的子区域。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">使用 Chainer folks 检查 ROIPooling 的 Python 实现，并尝试自己实现 ROIAlign。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">ROIAlign 代码可在不同库中获取，可查看下面给出的代码 repo。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">主干网络是 ResNet-FPN。</span></p></li></ul><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">我曾专门写文章介绍过 Mask-RCNN，文章地址：https://coming.soon/。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 14px;">代码</span></strong></p><p><br></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;"> Official Caffe2 - https://github.com/facebookresearch/Detectron/tree/master/configs/12_2017_baselines</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">Keras - https://github.com/matterport/Mask_RCNN/</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">PyTorch - https://github.com/soeaver/Pytorch_Mask_RCNN/</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">MXNet - https://github.com/TuSimple/mx-maskrcnn</span></p></li></ul><p><br></p><p style="text-align: center;line-height: 1.75em;"><span style="font-size: 16px;"><strong>学习分割 Every Thing</strong></span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">如题目《<a href="http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650734172&amp;idx=4&amp;sn=85be53241bf4e1c450fd8233ebf06d7e&amp;chksm=871b3a22b06cb334c4c5507d811afe390e751611434e2d618f654b5369efd3973a6a4d69ceb5&amp;scene=21#wechat_redirect" target="_blank">Learning to Segment Every Thing</a>》所示，这篇论文是关于分割的，具体来说，是实例分割问题。计算机视觉中的标准分割数据集对于现实应用而言规模太小。即使是 2018 年最流行、最丰富的 COCO 数据集 [7] 也仅有 80 个目标类别。这根本无法达到实用的要求。相比之下，目标识别和目标检测数据集如 OpenImages [8] 就有将近 6000 个分类类别和 545 个检测类别。除此之外，来自斯坦福的另一个数据集 Visual Genome 拥有 3000 个目标类别。那为什么人们不选用这些数据集呢？因为每个类别中包含的目标数量太少了，从而 DNN 无法在这个数据集上取得足够好的性能，即使这些数据集在实际应用上更加丰富、有用。需要注意的是该数据集并没有任何分割标注，仅有 3000 个目标检测（边界框）标签类别。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">接下来介绍论文 [4]。实际上，就领域而言，边界框和分割标注之间并不存在太大的区别，区别仅在于后者比前者更加精确。因此既然 Visual Genome [9] 数据集中有 3000 个类别，那么为什么不用来训练分割任务呢？这正是作者所做的，这种方法可称为弱监督学习（或弱半监督）学习，其中不需要相关任务的完整监督信息。如果他们使用的是 COCO+Visual Genome 数据集（即分割标签 + 边界框标签），这同样可称为半监督学习。</span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">这篇论文简直不能再 cool，其网络架构有如下特点：</span></p><p><br></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">它建立在 Mask-RCNN 之上。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">同时使用有掩码和无掩码的输入进行训练。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">在掩码和边界框掩码之间添加了一个权重迁移函数。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">当传递了一个没有掩码的输入时，将 ω_seg 函数预测的权重和掩码特征相乘。当传递了一个有掩码的输入时，则不使用该函数，而使用一个简单的 MLP。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">如下图所示：A 是 COCO 数据集，B 是 VG 数据集。注意其中对不同输入的不同训练路径。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">将两个损失同时进行反向传播将导致 ω_seg 的权重不一致，因为对于 COCO 和 VG 之间的共有类别，有两个损失（掩码和边界框），而对于非共有类别，则仅有一个损失（边界框）。作者使用的修改方法是：</span></p></li></ul><ul class=" list-paddingleft-2" style="list-style-type: circle;"><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">Fix：当反向传播掩码损失时，计算预测掩码权重 (τ) 关于权重迁移函数参数θ的梯度，而对边界框权重ω^c_det 不进行该计算。</span></p></li><li><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">w^c_seg=τ(stop_grad(w^c_seg); θ)，其中 τ 预测掩码权重。</span></p></li></ul><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.40682095006090135" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxEuZ91UfMutRlK2nY2vW50ZiaMicz64ZsRpDtwFk12BnMdibUcEEiaJF62WEBqS9UJs7nFFEJNamR4A/640?wx_fmt=png" data-type="png" data-w="821" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="color: rgb(136, 136, 136);font-size: 12px;"><em> 图 2：Mask^X RCNN 方法的细节展示。Mask^X RCNN 使用学得的权重迁移函数 τ，从对应的检测参数ω_det 预测类别的分割参数 ω_seg，而不是直接学习掩码预测参数 ω_seg。在训练过程中，τ 仅需要数据集 A 中类别的掩码数据，而在测试时可以应用到 A、B 数据集的所有类别。作者还用补充性的全连接多层感知机（MLP）增强了掩码头（mask head）。</em></span></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;">由于 VG 数据集没有分割标注，从而无法给出在该数据集上的分割准确率。因此他们在可验证的数据集上展示结果。PASCAL-VOC 数据集有 20 个类别，全部包含于 COCO 数据集。因此，对于这 20 个类别，他们使用 VOC 的分割标注和 COCO 中这 20 个类别的边界框标签进行训练。论文展示了在 COCO 数据集中这 20 个类别上的实例分割任务结果。此外由于两个数据集包含两种真实标注，他们还对相反的情况进行了训练。结果如下图所示。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;"><br></span></p><p><img class="" data-copyright="0" data-ratio="0.2660178426601784" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicxEuZ91UfMutRlK2nY2vW5gAXG7oZTs919zLD79W3ZqGatwX1uIjLicFGkNLLgUmEmc7qRwSyeKuw/640?wx_fmt=png" data-type="png" data-w="1233" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="color: rgb(136, 136, 136);font-size: 12px;"><em> 表 2：Mask^X RCNN 的端到端训练。如表 1 所示，作者使用了 τ 的 'cls+box、2-layer、LeakyReLU' 实现，并添加了 MLP 掩码分支（迁移函数+MLP），然后使用相同的评估流程。作者还报告了 AP_50 和 AP_75（0.5 和 0.75 IoU 阈值的平均精度评估），以及在小、中、大型目标上的 AP 值（AP_S、AP_M、AP_L）。该方法使用 ResNet-50-FPN 和 ResNet-101-FPN 主干架构时（没有使用掩码训练数据）都显著超越了数据集 B 上的基线结果。</em></span><span style="font-size: 14px;"><img class="" data-copyright="0" data-ratio="0.3287671232876712" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9IcHbFIoLic1VEVWUYDcOQOd6kYzKSNx7GpKhf1OMhgW30B8WEsyibXYuvBogNHE5TQTpUQGLsWmeQ/640?wx_fmt=png" data-type="png" data-w="73" style="text-align: justify;white-space: normal;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;visibility: visible !important;width: 51px !important;" width="51px"></span></p><p><span style="font-size: 14px;text-align: justify;"><br></span></p><p style="text-align: center;"><span style="font-size: 16px;"><strong><span style="text-align: justify;">参考文献</span></strong></span><br></p><p><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 12px;color: rgb(136, 136, 136);">[1] Lin, Tsung-Yi, Piotr Dollár, Ross B. Girshick, Kaiming He, Bharath Hariharan and Serge J. Belongie.「Feature Pyramid Networks for Object Detection.」*2017 IEEE Conference on Computer Vision and Pattern Recognition (CVPR)* (2017): 936-944.</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 12px;color: rgb(136, 136, 136);">[2] Lin, Tsung-Yi, Priya Goyal, Ross B. Girshick, Kaiming He and Piotr Dollár.「Focal Loss for Dense Object Detection.」*2017 IEEE International Conference on Computer Vision (ICCV)* (2017): 2999-3007.</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 12px;color: rgb(136, 136, 136);">[3] He, Kaiming, Georgia Gkioxari, Piotr Dollár and Ross B. Girshick.「Mask R-CNN.」*2017 IEEE International Conference on Computer Vision (ICCV)* (2017): 2980-2988.</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 12px;color: rgb(136, 136, 136);">[4] Hu, Ronghang, Piotr Dollár, Kaiming He, Trevor Darrell and Ross B. Girshick.「Learning to Segment Every Thing.」*CoRR*abs/1711.10370 (2017): n. pag.</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 12px;color: rgb(136, 136, 136);">[5] Ren, Shaoqing, Kaiming He, Ross B. Girshick and Jian Sun.「Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks.」*IEEE Transactions on Pattern Analysis and Machine Intelligence* 39 (2015): 1137-1149.</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 12px;color: rgb(136, 136, 136);">[6] Chollet, François.「Xception: Deep Learning with Depthwise Separable Convolutions.」2017 IEEE Conference on Computer Vision and Pattern Recognition (CVPR) (2017): 1800-1807.</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 12px;color: rgb(136, 136, 136);">[7] Lin, Tsung-Yi, Michael Maire, Serge J. Belongie, James Hays, Pietro Perona, Deva Ramanan, Piotr Dollár and C. Lawrence Zitnick.「Microsoft COCO: Common Objects in Context.」ECCV (2014).</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 12px;color: rgb(136, 136, 136);">[8] Krasin, Ivan and Duerig, Tom and Alldrin, Neil and Ferrari, Vittorio et al. OpenImages: A public dataset for large-scale multi-label and multi-class image classification. Dataset available from https://github.com/openimages</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 12px;color: rgb(136, 136, 136);">[9] Krishna, Ranjay, Congcong Li, Oliver Groth, Justin Johnson, Kenji Hata, Joshua Kravitz, Stephanie Chen, Yannis Kalantidis, David A. Shamma, Michael S. Bernstein and Li Fei-Fei.「Visual Genome: Connecting Language and Vision Using Crowdsourced Dense Image Annotations.」International Journal of Computer Vision 123 (2016): 32-73.</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 14px;"><br></span></p><p><span style="color: rgb(136, 136, 136);font-size: 12px;"><em><span style="color: rgb(136, 136, 136);text-align: justify;">原文链接：https://skrish13.github.io/articles/2018-03/fair-cv-saga</span></em></span></p><p><span style="font-size: 14px;text-align: justify;"><br></span></p><p><span style="font-size: 14px;text-align: justify;"></span></p><p style="max-width: 100%;min-height: 1em;text-align: justify;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><br></p><p style="margin-bottom: 20px;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;text-align: justify;line-height: 25.6px;font-family: 微软雅黑;font-size: 14px;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(127, 127, 127);box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;color: rgb(62, 62, 62);line-height: 25.6px;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(127, 127, 127);box-sizing: border-box !important;word-wrap: break-word !important;">本文为机器之心编译，<strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">转载请联系本公众号获得授权</span></strong></span></strong>。</span></strong></p><p style="margin-bottom: 5px;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);font-size: 18px;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(127, 127, 127);line-height: 25.6px;font-family: 微软雅黑;text-align: justify;box-sizing: border-box !important;word-wrap: break-word !important;">✄------------------------------------------------</span></p><p style="margin-bottom: 5px;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);font-size: 18px;font-family: 微软雅黑;text-align: center;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(217, 33, 66);font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">加入机器之心（全职记者/实习生）：hr@jiqizhixin.com</span></strong></p><p style="max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);font-size: 18px;font-family: 微软雅黑;text-align: center;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(217, 33, 66);line-height: 1.6;font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">投稿或寻求报道：editor@jiqizhixin.com</span></strong></p><p style="max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);font-size: 18px;font-family: 微软雅黑;text-align: center;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 12px;color: rgb(217, 33, 66);line-height: 1.6;box-sizing: border-box !important;word-wrap: break-word !important;">广告&amp;商务合作：bd@jiqizhixin.com</span></strong></p>
                </div>
                <script nonce="1168497871" type="text/javascript">
                    var first_sceen__time = (+new Date());

                    if ("" == 1 && document.getElementById('js_content')) {
                        document.getElementById('js_content').addEventListener("selectstart",function(e){ e.preventDefault(); });
                    }

                    
                    (function(){
                        if (navigator.userAgent.indexOf("WindowsWechat") != -1){
                            var link = document.createElement('link');
                            var head = document.getElementsByTagName('head')[0];
                            link.rel = 'stylesheet';
                            link.type = 'text/css';
                            link.href = "//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg/page_mp_article_improve_winwx31619e.css";
                            head.appendChild(link);
                        }
                    })();
                </script>
                
                
                                
                <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display:none;"></div>

                
                                <div class="reward_area tc" id="js_preview_reward" style="display:none;">
                    <p id="js_preview_reward_wording" class="tips_global reward_tips" style="display:none;"></p>
                    <p>
                        <a class="reward_access" id="js_preview_reward_link" href="##"><span class="icon-reward"></span>赞赏</a>

                    </p>
                </div>
                <div class="reward_qrcode_area reward_area tc" id="js_preview_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                    <p id="js_preview_reward_ios_wording" class="reward_tips" style="display:none;"></p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" src="//res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_reward_qrcode.2x3534dd.png"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                            </div><div class="rich_media_tool" id="js_toobar3">
                
                                
                                            <div id="js_read_area3" class="media_tool_meta tips_global meta_primary" style="display:none;">阅读 <span id="readNum3"></span></div>

                <span style="display:none;" class="media_tool_meta meta_primary tips_global meta_praise" id="like3">
                    <i class="icon_praise_gray"></i><span class="praise_num" id="likeNum3"></span>
                </span>

                <a id="js_report_article3" style="display:none;" class="media_tool_meta tips_global meta_extra" href="##">投诉</a>

            </div><div class="rich_media_tool" id="js_sg_bar">
                
                                
                                
            </div>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
