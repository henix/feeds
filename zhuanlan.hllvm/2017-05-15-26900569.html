<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Memory Management, Garbage Collection on the JVM</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/26900569">原文</a></p>
<p>本来计划继续接着“<a href="https://zhuanlan.zhihu.com/p/26389041" data-title="invokedynamic and MethodHandle缘由" class="" data-editable="true">invokedynamic and MethodHandle缘由</a>”，讲些已经公开的invokedynamic指令优化，以及Methodhandle的优化方面的话题。但是后来想想本来出发点就是科普入门的，而且目前对普通开发人员来说，用invokedynamic指令的还没有那么多，还是先暂时放弃了，将来再补上。　</p><p>言归正传，这次讲讲关于Memory, Garbage Collection, and Performance的问题。其实这个话题非常大，而且自己本身并没有在这方面做非常大的深入，就总结一些自己所了解的或者想法。不讲Hotspot, J9 的GC算法了，尤其是Hotspot的那几个策略，大部分人应该算是很清楚了。</p><h2><u>1，Tracing GC vs. Reference Counting （RC）</u></h2><h2>不能说RC GC一定不好<br></h2><p>目前主流的都是用的Tracing GC(e.g., parallel GC, CMG, Balanced GC and so on), 性能和效率上比较高。而Reference Counting没有这么大的普及，主要是由于</p><ul><li>性能。counter所带来的性能开销，尤其是对很多young and short live object 进行计数带来的开销。<br></li><li>cycles的不友好。</li><li>Defragmentation. </li></ul><p>而且从前一直没有那么大的重视。 <br></p><p>针对RC的这些问题，也有不少的改进，比较关注过的 Deferral Reference Count, 大概意思就是对某些variables所引用的对象不进行count (比如 frequently modified variables on stack and registers) 来减少整体开销的代价，但需要编译器方面的支持。 另外一种Coalescing，原话是“Only the initial and final states of the reference are necessary to calculate correct reference counts. Intervening mutations generate increments and decrements that cancel each other out"，白话理解就是一个引用，只有最初和最终状态时候，这个引用所指向的对象才需要去counting,　而中间状态所指向的对象是不需要counting，因为加加减减相互抵消了。</p><p>另外不得不说的是关于Jikes JVM上面的一个实现RC Immix, 这个是基于 Mark-region 来管理Free-list。这个作者的老板Steve Blackburn原先是Intel后来回袋鼠国 一个大学当教授和MS合作弄的。这个方法的出发点有几个：RC fragmentation, cache locality (Poor locality occurs because free-list allocators typically disperse contemporaneously allocated objects in memory, which degrades locality compared to allocating them together in space) and instruction overhead (programming languages require objects to be pre-initialized to zero.)的问题。他们的方法大概就是讲Free memory 分成 Block，然后Block由多个line组成。每个line计数多少个live object, 同样的也适用于Block。和传统的RC方式不一样的地方　在于这个方法中GC的时候就按照Line和Block为单位进行，而不是以对象的方式来进行了。</p><h2><u>2，GC and Hardware</u></h2><p>大家还是多想想GC和你的机器硬件的关系吧。单纯的从GC算法来改进吞吐量或者延时的空间我个人觉得远远不如想着如何去更大发挥你的机器硬件来的有效直接。这里的其中一个硬件就是NUMA(non-uniform memory access). </p><p>NUMA的硬件核心思想是多个Processor Nodes and each processor has its local memory. It is fast for a node to access its local memory, while slow to access remote memory of other nodes. 传统的机器就是多个处理器，大家通过BUS来共享一块内存。</p><p>因此，新的这种结构，就带来了很多新的GC玩法。比如NumGic, 作者以前是MS@Cambridge，后来去法国INRIA的。大概思路就是GC的时候(比如Mark live objects), 当前A thread at a processor visits local object A, which refers to B at remote memory.  因为从当前Thread去访问另外一个节点的内存慢，所以他们就发送消息给另外 Processor上的thread, 当前线程不阻塞。待到Remote thread complete时候再回馈结果。</p><p>另外关于NUMA的是IBM的Balanced GC，是将内存分为多个region, 回收的时候，通过不同策略构造Collection Set和Eden Regions。Balanced GC官方文档最大卖点是 NUMA awared, 很遗憾，文档少的可怜，我也没有细细研究过到底是如何支持这个NUMA的。</p><h2><u>3，GC相关优化</u></h2><p>其实普通程序员，会Hotspot GC Tuning就差不多了。同样，对于GC实现优化，仅仅立足于GC本身个人觉得能做的东西不是很大。因此，有人就考虑GC和其它的领域相结合，比如Cache, dataminning等。。</p><p>Christian wimmer在10年前修改了Hotpsot的GC实现(应该是他自己的私有版本，不了解Hotspot实现)，来实现Object co-location. 大概思想是groups heap objects together and sorts them so that their order in memory matches their access order in the program. 他做这个的出发点就是为了经验提高cache locality和为了做Object fusion的目的。通过GC stop and copy将一些有引用关系的group(或者对象)实现locailty, 然后将field load的指令为address arithmetic操作。</p><p>这里八卦下，说起christian, 就要说他从前作为博士的学校 澳大利亚的JKU。 由于和Oracle的关系，基本上O家在英国做Graal全是JKU出来的人。14年的时候遇见Christian, 在做广告：我在做Graal, 你们有兴趣吗，我们在招人！  1.8不止的个子，英国腔，面对面讨论让我觉得压抑感太强了。他的队伍里面还有Chris Seaton(先前做JRuby的), Stefan Marr, 和Manuel Rigger. 全是JKU出来的。 对Manuel印象比较深刻，好像还只是个博士. 有一次开会休息的时候跑过来说我做 sulong的，你看我们这名字就是中文翻译过来的. Anyway, 从JKU出来的人估计把持了 Oracle家Graal大半江山吧！</p><p>另外自己本人从前做过GC相关的原型，大概思想是想利用GC的信息做点名堂。比如每次GC释放掉的对象，我去跟踪最早new 这些对象的指令。之后通过每次GC的信息，我来建立new 指令相关性和模型，将来用这个模型我来实现memory allocator, 来增加locailty 和 less fragmentation. 当然只是个原型，后来也扔给其他工程师去深入研究细化了。<br></p><p>Disclaimer </p><ol><li>关于这篇文章的参考文献目前还没有组织，很多都是靠印象写的，将来补上，或者大家也可以帮我补上。</li><li>由于个人知识范围有限，而GC以及性能相关的优化太大了，不可能面面俱到，不足或者错误的地方谢谢指出来帮忙改正。</li></ol>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
