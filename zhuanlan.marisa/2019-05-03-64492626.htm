<div class="title-image"><img src="https://pic2.zhimg.com/v2-5b3d234fd8d6654988fc9ae93ea1dda4_b.jpg" alt=""></div><p><b>前言</b></p><p>最近状态不太好，有点懒，啥都不想干（可能发现自己岁数大了，有点闹情绪－ －|||）。想出去玩，风太大了，电视剧和动漫也看得“呕心沥血”了，因此切换下思路，就看了看下面这篇文章。我简单念叨念叨，大家看看就好，有想法的就想一想。</p><p><b>正题</b></p><p>PL知名学者Yannis Smaragdakis教授前两天在他的主页上放了一篇挺有意思的paper draft，题目是</p><blockquote>“Next-Paradigm Programming Languages: <br/>What Will They Look Like and What Changes Will They Bring?”</blockquote><p>嗯，题目有点大。</p><p>简单介绍一下这篇文章作者的背景。</p><p>Yannis这个人呢，是个实用语言主义者，他以前是美国佐治亚理工的教授，后来去了马萨诸塞(UMass)做教授，貌似12年左右被希腊引进回国了，现在是雅典大学的教授。他在PL的理论和应用方面都有所涉猎，具体研究内容如下所示。</p><blockquote><b>Program analysis</b> (static analysis, test generation, invariant inference, symbolic execution)<br/><b>Language mechanisms for abstraction</b> (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming)<br/><b>Languages and tools for systems</b> (programming models for concurrency, language support for distributed computing, memory management and program locality)</blockquote><p>最近10年，Yannis主要在基础程序分析方面建树较大。他是前ACM SIGPLAN 执行委员会的成员，OOPSLA&#39;16的PC Chair，TOSEM的Editor，SPLASH&#39;19的GC。主页在这里：<a href="https://link.zhihu.com/?target=http%3A//yanniss.github.io/" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://yanniss.github.io</a>（介绍这么多是想说，他这篇文章，尽管题目大且显而易见没有标准答案，但是还是可以看一看，想一想，引发一些思考的）</p><p class="ztext-empty-paragraph"><br/></p><p>接下来，为了方便理解题目，我先简单介绍一下编程语言范式（Programming Paradigm）。</p><p>实际上，我理解编程语言的范式主要有三种：</p><ul><li>Imperative Programming (IP) 命令式编程</li><li>Functional Programming (FP) 函数式编程</li><li>Logic Programming (LP) 逻辑式编程</li></ul><p>简单来说</p><p><b>IP基于时序</b>：在IP中，指令一个一个给出，用条件、循环等来控制逻辑（指令执行的顺序），同时这些逻辑通过程序变量不断修改程序状态，最终计算出结果。我觉得，尽管IP现在都是高级语言了，但是本质上并没有太脱离那种“类似汇编的，通过读取、写入等指令操作内存数据”的编程方式。也许是C语言的成功和后续历史的机缘巧合，让程序员们不断适应了这种编程方式吧。国内高等教育中接触的绝大多数编程语言都是IP的，比如Java, C, C++等。</p><p><b>FP基于抽象：</b>在FP中，逻辑（用函数来表达）可以像数据一样抽象起来，复杂的逻辑（高阶函数）可以通过操纵（传递、调用、返回）简单的逻辑（低阶函数）和数据来表达，没有了时序与状态，隐藏了计算的很多细节。不同的逻辑因为没有被时序和状态耦合在一起，程序本身模块化更强，也更利于不同逻辑被并行的处理。（我应该举个栗子的，但是我懒，见前言）</p><p><b>LP基于表达：</b>LP抽象的能力就更强了，计算细节干脆不见了。把你想表达的逻辑直观说出来就好了：如，“第三代火影的徒弟” 且 不是“女性” 且 “其徒弟也是火影” ==&gt; ”自来也“。嗯，学会”与或非“，编程都不怕。 </p><p>总结一下就是IP强调计算的过程，而FP和LP更倾向于表达计算的目的（其中FP和LP抽象计算的方式不同）。由于IP比FP、LP对计算细节的把控能力更强，它常常能表达并实现出更高性能的计算。相应的，FP和LP因为抽象能力更好，在表达很多复杂计算时会更方便和简洁。当然，很多流行的编程语言都是将它们不同的能力结合起来设计使用的，其中IP和FP结合比较常见，例如JavaScript, Python, Scala等，Java 8之后也有一些糖化FP的改进了。至于IP、FP与LP的结合也有，但据我所知并不多。</p><p>我不太喜欢将”面向对象“（OO）也说成是一种单独的编程语言范式（貌似Martin Odersky也是这个观点），因为我觉得把OO加进来就很难特征鲜明地区分语言类别了（实际上OO可以分别和上述三类语言范式结合起来）。当然，讨论这个意义不大，学界也没有统一论调，你说它是也是可以的，能够方便交流就好。</p><p>以上是一些背景。</p><p>“Next-Paradigm Programming Languages”这篇文章，虽然通篇拿Datalog语言来举例子，但是我觉得其观点和很多内容也适用其它语言。文章不是特别容易理解，这里我把最核心的几个观点拿出来总结一下，按照我的理解描述一下，方便大家参考。</p><p>文章在介绍中就先给出了“免死金牌”，作者说：</p><blockquote>下一代编程语言范式可能是基于那种通过训练大规模代码实例的“机器学习或统计技术”，或者是通过符号推理和复杂约束求解的“程序生成技术”，或者是在大规模计算和存储能力下的新的“高阶语言设计技术”，或者很多其他技术...... <br/>但是，无论这些未来编程范式基于什么技术，作者觉得一些基本的原则是不可避免的，他这篇文章就是来阐述这些所谓的基本原则（Principles）</blockquote><p>嗯，作者在说，他并不是在预测下一代编程语言范式到底是什么（所以你不用因为不同意而激动），他只是根据过去20年来对编程语言研究和使用的经验，总结一些他觉得下一代编程语言范式可能需要具备的基本原则。</p><p>那么都有哪些原则呢？</p><p>原则1</p><blockquote><b>Principle 1</b> (<b>Productivity and Performance Tied Together</b>). <br/>If a language can give orders-of-magnitude improvements in <b>productivity</b> then its implementation has the potential for orders-of-magnitude changes in <b>performance</b></blockquote><p>作者进一步解释到</p><blockquote>Large variations in both productivity and performance are functions of a language being abstract. Neither is possible with the current, ultra-concrete mainstream languages. <b>If one needs to explicitly specify “loops and arrays”, neither large productivity gains, nor large performance variations are possible</b>. Instead, the language implementation (or “compiler” for short) of a high-productivity, next-paradigm language will likely be able to effect orders-of-magnitude performance differences via dynamic or static optimization.</blockquote><p>我简单解释一下，作者觉得，下一代编程范式应该是侧重“高生产力”（high-productivity）的，即“编程应该是越来越容易的”，进而“编程开发效率是越来越高的”。他说如果一个编程语言让程序员显示地规定“循环和数组”应该怎么设计使用，那么这个语言既不能高效（high-productivity），也不会容许程序的性能有太大的改变空间（毕竟数据结构和执行逻辑都被程序员定死了）。</p><p>我个人觉得作者在这里就是剑指Imperative Programming（IP）的，他可能觉得IP的这种编程方式没法让程序员从编程中解放生产力（“生产力是编程发展的第一要素”，嗯，我从他全文中都嗅出这样的口号，虽然他没说的那么直白...）。作者觉得，编程语言应该抽象得易于使用（嗯，这里他应该是在更偏向于Functional和Logic Programming，我觉得LP更多一些），很多实现的细节应该交由以后的Compiler来自动地处理，这里的Compiler作者是一个泛指，它可能包括<b>interpreter</b> or <b>compiler</b> (ahead-of-time or just-int-time) and a <b>runtime system</b>。</p><p>因此，有了下面的见解</p><blockquote>Programs ≠ Algorithms + Data Structures. Instead,<br/>Compiler(Program) = Algorithms + Data Structures</blockquote><p>总结一下原则1就是，下一代编程语言范式应该注重High-productivity和Convenient编程，程序的性能在当今“丰富计算能力和资源”的背景下，可以让语言实现系统本身（如上面提到的Compiler）来发挥，进而解放编程生产力。</p><p>原则2</p><blockquote><b>Principle 2</b> (<b>Need For Firm Mental Grounding</b>). <br/>The programming model of next-paradigm languages will offer strong semantic guarantees (about what code can do and how new code can affect old).</blockquote><p>原则2提出的背景，实际上也是基于原则1的。想象一下，一个编程语言如果使用起来高效方便，会不免依赖很多语言实现系统背后的自动化技术。这样一来，相比于传统语言编写的程序，程序的一点变动可能会变得更不可控。因此，语言和语言系统本身应该提供一下基本的Invariant和properties以让程序员在开发时对语言能做什么，改动之后有什么变化等问题有一定的了解甚至保证。</p><p>比如，Datalog就有很强的一种semantic invariant，那就是monotonicity。有了monotonicity，在程序中添加rules就保证不会invalidate先前rules的输出，由此，就可以通过local inspection来非常方便地理解和编写程序。下一代编程语言范式应该有更多有用的关于语言本身的semantic guarantees来支撑语言的易用性。</p><p>原则3</p><blockquote><b>Principle 3 </b>(<b>Workflows Will Change</b>). <br/>Next-paradigm programming languages will change well-established patterns in current programming workflow.</blockquote><p>选择什么样的编程语言实际上并不会从本质上影响传统的软件开发流程，比如需求分析，架构设计，编码实现，测试等等。然而，作者觉得，如果使用的是一个high-productivity和high-abstraction的编程语言，尽管软件开发流程整体不会受太大影响，但是这个流程的每一个环节会产生很大的变化。作者是这样解释的：</p><blockquote>Orders-of-magnitude productivity improvements will, very likely, disrupt the established workflow of program development<b>. Code will be much more terse and abstract, resembling a formal specification</b>. Small changes will have a huge impact on both functionality and performance. It is hard to fully grasp precisely how today’s common practices will evolve.</blockquote><p>编码实现更接近于formal specification本身（开发更容易了），但是对于程序的调试、分析、测试会变得更有难度（可能更多依托于自动化技术）。不难看出，实际上原则3也是原则1的一个衍生物。我觉得作者是想说，在设计新的编程范式时，也应该考虑它对于整个软件开发过程的影响。</p><p>以上，就是文中系统阐述的下一代编程语言范式需要考虑的三个主要原则。</p><p><b>我对于这篇文章的看法</b></p><p>实际上，以我对作者的了解，他是倾向于将下一代编程语言范式向logic programming，比如Datalog靠拢的，毕竟他最近十多年一直在从事这方面的研究和工作。我在读博士的前几年也是用Datalog写分析器的，确实好用，把算法想清楚了，按照语言的语法语义写rules比较直观，不用纠结背后的数据结构和执行系统，把逻辑想清楚表达出来就好了。在这一方面我是支持作者观点的。</p><p>但是实际上也有一些弊端，比如，Datalog在表达部分逻辑时，例如universal quatification时就很不方便，需要通过negation来实现，当然，这一点是可以通过语言层面的，比如语法语义的改进来修补的。此外，因为不太明确执行Datalog的engine的执行顺序和原则，有的时候添加修改rules时会带来一些性能上的问题（虽然不多见，但是确实遇到过几次，很无奈）。如此一来，让我想到，如果程序员真的要编好这样的程序with high-producitivity，还需要理解好背后语言运行系统的执行策略，这本身就是一种对于解放编程生产力的束缚（虽然一旦摆脱了这种束缚，就有可能编的飞起...）</p><p>此外，我对于文中一些小的观点有些不同看法，比如Corollary 3.3关于Different balance of formal reasoning and coding（有兴趣的同学可以看一下，虽然code和specification更近了，但是这种alleviation的一部分是通过转嫁到对compiler和runtime system更heavy的reasoning而获得的）。</p><p><b>我关于下一代编程语言范式的看法</b></p><p>我倾向于主流imperative programming（IP）这种编程方式在以后会有较大的转变，因为很多应用下的程序，相比于逻辑，更多服务于数据，这样一部分需求可以被functional programming (FP) 或者 logic programming (LP) 更好的消化，实际上很多主流语言也支持或开始支持FP了（IP+FP）。我觉得随着一些新的需求和应用的出现，IP+LP或IP+FP+LP也会越来越多，估计会在一些专家领域或特别的应用中先出现。有的人可能会问，为什么新的语言范式都要加一个IP？因为利益啊，遗留的系统，遗留的知识，遗留的固守成规。。。至于说有没有可能有一种或几种全新的编程范式在未来出现并惠及天下，我的答案是当然。</p><p>说到这里又不得不惋惜一叹啊，希望咱们国家更重视一下编程语言的教育和科研，每年输出这么多程序员，每年又输入这么多对编程好奇、感兴趣的学生，于国于民，千秋万代啊。</p><p>嗯，就唠叨这么多。</p><p></p>