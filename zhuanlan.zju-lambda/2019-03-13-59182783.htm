<p>阅读本文需要读者了解一些基本的函数式语言概念和 C++ 11 知识。</p><p>Steak 语言是我两年前写的一个项目，最近又翻出来优化了一下，早就说要写篇文章总结一下，结果一直咕咕咕（</p><a href="http://link.zhihu.com/?target=https%3A//github.com/nicekingwei/steak" data-draft-node="block" data-draft-type="link-card" class=" wrap external" target="_blank" rel="nofollow noreferrer">steak</a><p>Steak 语言设计的初衷是把 GADT、惰性求值、模式匹配等函数式语言特性引入 C++。C++ 11 以后，语言里逐渐出现了一些支持函数式编程的特性，例如 lambda 表达式，但他们用起来又不是特别好用（等以后有了 Ranges，情况会好转一些）。因此我想设计一个库或语言，让 C++ 使用者能更舒服地编写函数式程序。当然目前的结果只是个玩具，因为编译太慢了：）。</p><p><br></p><h2><b>惰性求值</b></h2><p>C++11 原生支持了 lambda 表达式，因此我们可以用一个 lambda 闭包来表达一个待求值的块，例如</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">auto</span> <span class="n">lazy_double</span> <span class="o">=</span> <span class="p">[]()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span> <span class="p">};</span>
</code></pre></div><p>这时的 lazy_double 即是一个惰性求值的块，<code>sqrt(2.0)</code> 只有在你用到 <code>lazy_double</code> 的时候才会被计算。但如果我们多次引用 <code>lazy_double</code>，<code>sqrt(2.0)</code> 便会被执行多次，我们希望它能只计算一次。所以，<code>lazy_double</code> 要么是 double，要么是返回一个 double 的函数。因为我们知道，C++ 有隐式转换特性，我们只需要在类里实现一个形如</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">operator</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">T</span><span class="p">{};</span>
<span class="p">}</span>
</code></pre></div><p>的函数，即可将该类的实例隐式转换为 T 的实例。</p><p>更进一步，我们还可以表达异步计算的语义。如果我们之前声明了一个块，这个块的计算需要耗费大量的时间，于是我们利用 C++ 标准库的 <code>std::async</code>  来获得一个 <code>std::future</code> ，发起异步的计算。在我们需要用它的时候，再阻塞地拿到值。</p><p>不知不觉中，我们抽象掉了具体的计算过程及方法。在我们主要的程序中，我们只是声明了数据流动的方式，而并非给机器施加了计算的指令。这其实也是函数式编程与命令式编程在思维方式上的微小差异。扯远了，我们回到 <code>lazy_type</code> 的问题上来。</p><p>于是我们就可以利用 <code>std::variant</code> 定义出 <code>lazy_type</code> ，为了方便，我统一使用了智能指针：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">lazy_type_t</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">block_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">data_t</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">future_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">store_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">block_t</span><span class="p">,</span> <span class="n">data_t</span><span class="p">,</span> <span class="n">future_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="err">​</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">lazy_type_t</span><span class="p">;</span>
<span class="err">​</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">store_t</span><span class="o">&gt;</span> <span class="n">ptr_data</span><span class="p">;</span>
<span class="err">​</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">lazy_type_t</span><span class="p">()</span> <span class="o">:</span> <span class="n">ptr_data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">store_t</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{}</span>
    <span class="n">lazy_type_t</span><span class="p">(</span><span class="k">const</span> <span class="n">data_t</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">ptr_data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">store_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{}</span>
    <span class="n">lazy_type_t</span><span class="p">(</span><span class="k">const</span> <span class="n">lazy_type_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">ptr_data</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">ptr_data</span><span class="p">)</span> <span class="p">{}</span>
    
    <span class="k">explicit</span> <span class="n">lazy_type_t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">store_t</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">ptr_data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{}</span>
    
    <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    
    <span class="n">lazy_type_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">async</span><span class="p">();</span>
    
    <span class="k">operator</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="err">​</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">lazy_type_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="err">​</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">lazy_type_t</span><span class="o">&lt;</span><span class="n">return_type_t</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&gt;</span> <span class="n">transform</span><span class="p">(</span><span class="k">const</span> <span class="n">Y</span> <span class="o">&amp;</span><span class="n">fun</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="err">​</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">lazy_type_t</span><span class="o">&lt;</span><span class="n">return_type_t</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&gt;</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span><span class="k">const</span> <span class="n">Y</span> <span class="o">&amp;</span><span class="n">fun</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p><code>block_t</code> 是返回 T 的函数，<code>future_t</code> 是返回 T 的 <code>future</code> ，<code>store_t</code> 即是 <code>block_t</code>、<code>future_t</code>、<code>T</code> 三种类型的和类型，即任意时刻，<code>store_t</code> 存的值是上述三种类型的一种。<code>block_t</code> 可以通过 <code>async</code> 调用进入异步计算模式，即转变为 <code>future_t</code>，而两者均在<code>get</code> 时转换为 <code>T</code> 类型存下来。 </p><p><code>transform</code> 函数和 <code>|</code> 运算符用于把一个函数应用到该类型上，产生一个新的 <code>lazy_type_t</code> 的值。这里用到了一个模板 <code>return_type_t</code>，这是用来计算类型 <code>Y</code> 的返回值类型的。它的实现我是抄的 Stack Overflow 上的答案。链接在<a href="http://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/27822277/finding-out-the-return-type-of-a-function-lambda-or-function" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a>。</p><p>最终实现的效果如下，以下代码节选自 <a href="http://link.zhihu.com/?target=https%3A//github.com/nicekingwei/steak/blob/master/examples/lazy.cpp" class=" wrap external" target="_blank" rel="nofollow noreferrer">lazy.cpp</a></p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">auto</span> <span class="n">l4</span> <span class="o">=</span> <span class="n">lazy_call</span><span class="p">(</span><span class="n">time_consuming_compute</span><span class="p">).</span><span class="n">async</span><span class="p">();</span>
<span class="err">​</span>
<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="err">​</span>
<span class="k">auto</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">lazy_type_t</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">l1</span><span class="p">.</span><span class="n">transform</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="sc">'a'</span><span class="p">;</span> <span class="p">});</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">l3</span> <span class="o">=</span> <span class="n">lazy_call</span><span class="p">([]()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"eval l3</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="sc">'v'</span><span class="p">;</span>
<span class="p">});</span>
<span class="err">​</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l3</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="err">​</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l4</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l4</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="err">​</span>
<span class="n">lazy_type_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">l5</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">));</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l5</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">l5</span><span class="p">);</span>
<span class="err">​</span>
<span class="k">auto</span> <span class="n">l6</span> <span class="o">=</span> <span class="n">lazy_type_t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="o">|</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="o">|</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="o">|</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="s">"hello world"</span><span class="p">;</span>
<span class="p">};</span>
<span class="err">​</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l6</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div><p><br></p><h2><b>积类型</b></h2><p>单纯实现积类型非常简单，直接使用 <code>std::tuple</code> 即可，但在支持模式匹配路上遇到了许多困难，最后我选择了自己实现积类型 <code>zipped_pair_t</code>。</p><p>首先定义一个接收任意数量的类型参数的实现</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">zipped_pair_t</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">K</span><span class="p">...)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><p>然后进行特化，首先需要用 <code>lazy_type_t</code> 存一个数据，然后定义各种情况下的模式匹配函数，区别对待左值、右值和占位符。模式匹配时，碰到左值则进行数据绑定（在这里是拷贝），碰到右值进行比较，碰到占位符默认返回成功。</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">zipped_pair_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">lazy_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="err">​</span>
    <span class="n">zipped_pair_t</span><span class="p">()</span> <span class="p">{}</span>
<span class="err">​</span>
    <span class="n">zipped_pair_t</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="err">​</span>
    <span class="n">zipped_pair_t</span><span class="p">(</span><span class="k">const</span> <span class="n">lazy_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="err">​</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">zipped_pair_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="err">​</span>
    <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T1</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">place_holder_t</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v1</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="err">​</span>
    <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T1</span> <span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">place_holder_t</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">v1</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">data</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="p">}</span>
<span class="err">​</span>
    <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">T1</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="err">​</span>
    <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">T1</span> <span class="o">&amp;&amp;</span><span class="n">v1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">data</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="c1">// ......</span>
<span class="p">};</span>
</code></pre></div><p>然后是多个参数的情况，这里采用了一个递归定义的类模板，进行具体处理时，只需处理第一个参数，然后对第二个参数递归对应的处理函数。成员函数的具体实现略去。</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">zipped_pair_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">lazy_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">zipped_pair_t</span><span class="o">&lt;</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;&gt;</span>
<span class="p">{</span>
    <span class="c1">// .......</span>
<span class="p">};</span>
</code></pre></div><p><br></p><p>对于传进来进行模式匹配的参数，我定义了一个 <code>forward_and_zip</code> 函数将他们打包成 <code>zipped_pair</code>，并且通过完美转发保留了他们原本的类型。</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="kr">inline</span> <span class="k">auto</span> <span class="nf">forward_and_zip</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_</span><span class="p">;</span>
<span class="p">}</span>
<span class="err">​</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">auto</span> <span class="n">forward_and_zip</span><span class="p">(</span><span class="n">T1</span> <span class="o">&amp;&amp;</span><span class="n">v1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">_</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sec</span><span class="p">));</span>
<span class="p">}</span>
<span class="err">​</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">auto</span> <span class="n">forward_and_zip</span><span class="p">(</span><span class="n">T1</span> <span class="o">&amp;&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="n">Ts</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">vs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">forward_and_zip</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vs</span><span class="p">)...);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sec</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div><p><br></p><h2><b>和类型</b></h2><p>和类型直接封装 <code>std::variant</code>，并提供模式匹配接口即可。</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">data_class_t</span> <span class="p">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">data_class_label</span> <span class="o">=</span> <span class="kt">char</span><span class="p">;</span>
<span class="err">​</span>
    <span class="n">data_class_t</span><span class="p">()</span> <span class="p">{}</span>
<span class="err">​</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
    <span class="n">data_class_t</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
<span class="err">​</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">G</span><span class="p">,</span> <span class="k">typename</span> <span class="n">S</span><span class="o">&gt;</span>
    <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">ghost_t</span><span class="o">&lt;</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">search_t</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;&gt;::</span><span class="n">search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="err">​</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">data_class_t</span><span class="o">&lt;</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">search_t</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;&gt;::</span><span class="n">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="err">​</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">show</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">search_t</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;&gt;::</span><span class="n">show</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="err">​</span>
    <span class="k">auto</span> <span class="n">get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><p>在类模板参数不固定的情况下，遍历每个模板参数显得有些困难，于是不得不采用一些取巧的方法。上面出现的 <code>search_t</code> 就是这样的帮助递归遍历每个模板参数的辅助类。</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">search_t</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">show</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span> <span class="o">*</span><span class="n">var</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="o">&amp;</span><span class="n">data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">index</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="p">);</span>
            <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_variant_access</span> <span class="o">&amp;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">search_t</span><span class="o">&lt;</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;::</span><span class="n">show</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">var</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ......</span>
<span class="p">};</span>
<span class="err">​</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">search_t</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">show</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span> <span class="o">*</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// ......</span>
<span class="p">};</span>
</code></pre></div><p>上面这段节选了 show 函数，即将一个 <code>std::variant</code> 打印出来的函数。递归尝试 <code>std::variant</code> 的类型，失败就尝试下一个类型，成功就打印该变量。</p><p><br></p><h2><b>用法</b></h2><p>你可以通过宏来使用 Steak 语言，大概长这样：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">RegCons</span><span class="p">(</span><span class="n">Nil</span><span class="p">)</span> <span class="n">RegCons</span><span class="p">(</span><span class="n">Cons</span><span class="p">)</span>
<span class="n">Data</span><span class="p">(</span><span class="n">Va</span><span class="p">,</span><span class="n">List</span><span class="p">,</span><span class="n">RealType</span><span class="p">(</span><span class="n">Nil</span><span class="p">),</span><span class="n">RealType</span><span class="p">(</span><span class="n">Cons</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">))</span>
    <span class="n">Cons0</span><span class="p">(</span><span class="n">Va</span><span class="p">,</span><span class="n">Nil</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="n">Cons2</span><span class="p">(</span><span class="n">Va</span><span class="p">,</span><span class="n">Cons</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">DerivingShow</span><span class="p">(</span><span class="n">Va</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">)</span>
<span class="err">​</span>
<span class="n">RegCons</span><span class="p">(</span><span class="n">Nothing</span><span class="p">)</span> <span class="n">RegCons</span><span class="p">(</span><span class="n">Just</span><span class="p">)</span>
<span class="n">Data</span><span class="p">(</span><span class="n">Va</span><span class="p">,</span><span class="n">Maybe</span><span class="p">,</span><span class="n">RealType</span><span class="p">(</span><span class="n">Nothing</span><span class="p">),</span><span class="n">RealType</span><span class="p">(</span><span class="n">Just</span><span class="p">,</span><span class="n">a</span><span class="p">))</span>
    <span class="n">Cons0</span><span class="p">(</span><span class="n">Va</span><span class="p">,</span><span class="n">Nothing</span><span class="p">,</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="n">Cons1</span><span class="p">(</span><span class="n">Va</span><span class="p">,</span><span class="n">Just</span><span class="p">,</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
<span class="n">DerivingShow</span><span class="p">(</span><span class="n">Va</span><span class="p">,</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">)</span>
<span class="err">​</span>
<span class="n">RegCons</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="n">RegCons</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="n">Data</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">Peano</span><span class="p">,</span><span class="n">RealType</span><span class="p">(</span><span class="n">Z</span><span class="p">),</span><span class="n">RealType</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">Peano</span><span class="p">))</span>
    <span class="n">Cons0</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">Peano</span><span class="p">)</span>
    <span class="n">Cons1</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">Peano</span><span class="p">,</span><span class="n">Peano</span><span class="p">)</span>
<span class="n">DerivingShow</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">Peano</span><span class="p">)</span>
<span class="err">​</span>
<span class="err">​</span>
<span class="n">Va</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">out</span><span class="o">&lt;&lt;</span><span class="sc">'['</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">first</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">a</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">With</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">Case</span><span class="p">(</span><span class="n">Cons</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">l</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="n">first</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
                <span class="k">else</span> <span class="n">out</span><span class="o">&lt;&lt;</span><span class="sc">','</span><span class="p">;</span>
                <span class="n">out</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="p">;</span>
            <span class="n">Case</span><span class="p">(</span><span class="n">Nil</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="n">EndWith</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">&lt;&lt;</span><span class="sc">']'</span><span class="p">;</span>
<span class="p">}</span>
<span class="err">​</span>
<span class="kt">int</span> <span class="n">maybe_sum</span><span class="p">(</span><span class="n">steak</span><span class="o">::</span><span class="n">lazy_type_t</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">With</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">Case</span><span class="p">(</span><span class="n">Cons</span><span class="p">,</span><span class="n">UnZip</span><span class="p">(</span><span class="n">Just</span><span class="p">,</span><span class="n">y</span><span class="p">),</span><span class="n">l</span><span class="p">)</span>
                <span class="n">x</span><span class="o">+=</span><span class="n">y</span><span class="p">;</span>
            <span class="n">Case</span><span class="p">(</span><span class="n">Nil</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">Case</span><span class="p">(</span><span class="n">Cons</span><span class="p">,</span><span class="n">UnZip</span><span class="p">(</span><span class="n">Nothing</span><span class="p">),</span><span class="n">l</span><span class="p">)</span>
                <span class="p">;</span>            
        <span class="n">EndWith</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>或者使用我用 Haskell 写的编译器进行代码生成，代码会清爽一些：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">a</span><span class="o">&gt;</span>
<span class="n">dataclass</span> <span class="n">Maybe</span>
<span class="p">{</span>
    <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="n">Nothing</span><span class="p">();</span>
    <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="n">Just</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">};</span>
<span class="err">​</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">a</span><span class="o">&gt;</span>
<span class="n">dataclass</span> <span class="n">List</span>
<span class="p">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="n">Nil</span><span class="p">();</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="n">Cons</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">List</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">};</span>
<span class="err">​</span>
<span class="kt">int</span> <span class="n">maybe_sum</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">flag</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">match</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">case</span> <span class="n">Cons</span><span class="p">(</span><span class="n">Just</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="n">l</span><span class="p">)</span><span class="o">:</span>
                <span class="n">x</span><span class="o">+=</span><span class="n">y</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nf">Cons</span><span class="p">(</span><span class="n">Nothing</span><span class="p">(),</span><span class="n">l</span><span class="p">)</span><span class="o">:</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nf">Nil</span><span class="p">()</span><span class="o">:</span>
                <span class="n">flag</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><br></p><h2><b>结尾</b></h2><p>Steak 语言运行时的核心就是这些啦，对于这些需求，我的实现方式可能也不是最好的，欢迎大家在评论区讨论 C++ 更好的用法。没展示出来的代码都是用来处理一些边界情况，或让代码看起来更漂亮的。</p><p><br></p><p>（给自己打个广告，我最近在找工作，如果各位朋友知道有 PL、编译器、DB 相关的岗位，可以私信告诉我，谢谢大家！）</p>