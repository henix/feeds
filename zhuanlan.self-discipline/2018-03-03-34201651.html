<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>柯里化的前生今世（十二）：多态性</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34201651">原文</a></p>
<h2><b>关于</b></h2><p>本文借用Haskell介绍了自定义类型，带参数的类型，Ad-hoc多态性，kind，<br>其中，带参数的类型在类型上可以做“柯里化”。</p><h2><b>1. 自定义类型</b></h2><p>Haskell中使用<code class="inline">data</code>自定义类型。</p><code lang="haskell">data Bool = True | False</code><p>其中，<code class="inline">Bool</code>是类型名，<code class="inline">True</code>和<code class="inline">False</code>是该类型的值。</p><p>一个值可以包含多种不同类型的字段（field），例如，</p><code lang="haskell">data BookType = BookValue Int String</code><p>其中<code class="inline">BookType</code>是类型名，<code class="inline">BookValue</code>是值构造器（Value constructor）。<br>一个<code class="inline">BookType</code>类型的值，可以这样定义，</p><code lang="haskell">bookValue = BookValue 12 "ab"</code><p>注：<br>类型名和值构造器会在不同上下文中使用，<br>因此，常把它们写成同一个名字，应当注意区分。</p><code lang="haskell">data Book = Book Int String</code><h2><b>2. 抽象与具体化</b></h2><code lang="haskell">lengthInt :: [Int] -&gt; Int
lengthInt [] = 0
lengthInt (_:xs) = 1 + lengthInt xs

lengthChar :: [Char] -&gt; Int
lengthChar [] = 0
lengthChar (_:xs) = 1 + lengthChar xs</code><p><code class="inline">lengthInt</code>和<code class="inline">lengthChar</code>虽然类型不同，但是计算过程相同，<br>如果我们想计算不同类型列表的长度，就需要写多个不同的函数，<br>这违背了软件工程中基本的设计原则：</p><blockquote>Abstraction principle:<br>Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.</blockquote><p>和通常的代码不同，这里提到的<code class="inline">varying parts</code>指的是类型，<br>我们需要提取出一个抽象的类型<code class="inline">[a]</code>，<br>然后再实例化为不同的具体类型<code class="inline">[Int]</code>或<code class="inline">[Char]</code>。</p><h2><b>3. 多态类型系统</b></h2><blockquote>Type systems that allow a single piece of code to be used with multiple types are collectively known as polymorphic systems (poly = many, morph = form).</blockquote><p>如果一个类型系统，允许一段代码在不同的上下文中具有不同的类型，<br>这样的类型系统就称为多态类型系统。</p><p>现代编程语言，包含了不同形式的多态性：<br>参数化多态，Ad-hoc多态，子类型多态。</p><p><b>（1）参数化多态（Parametric polymorphism）</b></p><code lang="haskell">data Maybe a = Just a | Nothing</code><p>以上代码定义了一个带参数的类型<code class="inline">Maybe</code>，它不能表示某个值的类型，<br>而<code class="inline">Maybe Int</code>放在一起，才是一个具体的类型，<br>类型名<code class="inline">Maybe</code>也称为类型构造器（Type constructor）。</p><code lang="haskell">length :: [a] -&gt; Int
length [] = 0
length (_:xs) = 1 + length xs</code><p>如果某个函数（函数是一种值）的类型是一个带参数的类型，<br>函数的计算过程就可以写到一个地方，<br>不同的调用场景，会将<code class="inline">length</code>函数具体化为不同的类型。</p><p><code class="inline">length [1,2,3]</code>，<code class="inline">length</code>被具体化为<code class="inline">[Int] -&gt; Int</code>，<br><code class="inline">length ['a','b','c']</code>，<code class="inline">length</code>被具体化为<code class="inline">[Char] -&gt; Char</code>。</p><p><b>（2）Ad-hoc多态（Ad-hoc polymorphism）</b></p><p>某个Ad-hoc多态类型的值，看做不同类型时，会有不同的行为。<br>重载（Overloading）就是一种Ad-hoc多态，<br>它可以让一个函数具有不同的实现。<br>每次函数调用，编译器（或运行时系统）会选择适当的实现。</p><code lang="haskell">class BasicEq a where 
    isEqual :: a -&gt; a -&gt; Bool

instance BasicEq Bool where 
    isEqual True True = True 
    isEqual False False = True 
    isEqual _ _ = False</code><p>Haskell中的typeclass使用了Ad-hoc多态，<br>函数<code class="inline">isEqual</code>在具体化为不同的类型时，可以有不同的实现。</p><p><b>（3）子类型多态（Subtype polymorphism）</b></p><p>它允许某个类型的值，在包含关系上，可以看做它也是父类型的值。<br>在面向对象语言社区，经常把子类型多态，简称为多态。</p><p>注：<br>同一种语言可能具有不同的多态性，<br>例如，Standard ML提供了参数化多态，内置运算符重载（Ad-hoc多态），<br>但是没有提供子类型多态。<br>而Java提供了子类型多态，函数重载（Ad-hoc多态），泛型（参数化多态）。</p><h2><b>4. kind</b></h2><p>关于带参数的类型，<br>与函数Currying相似，类型构造器也可以『Currying』，<br>例如，我们定义以下带两个参数的<code class="inline">Either</code>类型，</p><code lang="haskell">data Either a b = Left a | Right b</code><p>其中<code class="inline">Either</code>是一个类型构造器，接受两个类型参数<code class="inline">Int</code>和<code class="inline">String</code>，<br>得到具体类型<code class="inline">Either Int String</code>。</p><p>如果只提供一个类型参数呢？<br><code class="inline">Either Int</code>仍然是一个类型构造器，它接受一个类型参数<code class="inline">String</code>，<br>得到具体类型<code class="inline">Either Int String</code>。</p><p>正因为有这种差异性，<br>Haskell中使用<code class="inline">kind</code>来区分不同的类型。</p><code lang="haskell">ghci&gt; :k Int
Int :: *

ghci&gt; :k Maybe
Maybe :: * -&gt; *

ghci&gt; :k Maybe Int
Maybe Int :: *

ghci&gt; :k Either
Either :: * -&gt; * -&gt; *

ghci&gt; :k Either Int
Either Int :: * -&gt; *

ghci&gt; :k Either Int String
Either Int String :: *</code><h2><b>5. <code class="inline">&gt;&gt;=</code>的多态性</b></h2><p>函数<code class="inline">&gt;&gt;=</code>定义在<code class="inline">Monad typeclass</code>中，</p><code lang="haskell">class Monad m where
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code><p>其中，<code class="inline">m</code>是<code class="inline">Monad typeclass</code>的实例类型，它的<code class="inline">kind</code>是<code class="inline">* -&gt; *</code>，<br>类型<code class="inline">m a</code>是一个具体类型，该类型的值称为monad value。</p><p>我们看到，在<code class="inline">m</code>确定的情况下，<code class="inline">&gt;&gt;=</code>的类型签名中仍然包含类型变量。<br>因此，对于<code class="inline">Monad typeclass</code>的某个实例来说，<br><code class="inline">&gt;&gt;=</code>可以操作相同<code class="inline">m</code>类型但是不同<code class="inline">a</code>类型的<code class="inline">monad value :: m a</code>。</p><p>以<code class="inline">Monad typeclass</code>的实例<code class="inline">IO</code>为例，对于<code class="inline">IO</code>来说，<code class="inline">IO</code> monad value称为IO action。</p><code lang="haskell">main :: IO ( )
main = do
    putStrLn "Please input: "
    inpStr &lt;- getLine
    putStrLn $ "Hello " ++ inpStr</code><p>其中，<code class="inline">putStrLn :: String -&gt; IO ( )</code>，<code class="inline">getLine :: IO String</code>。</p><p>我们来分析一下这3个IO action的类型吧，</p><code lang="haskell">putStrLn "Please input: " :: IO ( )
getLine :: IO String
putStrLn $ "Hello " ++ inpStr :: IO ( )</code><p>它们的具体类型都是<code class="inline">m a</code>，<br><code class="inline">m</code>相同，<code class="inline">m = IO</code>，<br>而<code class="inline">a</code>不同，分别是<code class="inline">( )</code>，<code class="inline">String</code>，<code class="inline">( )</code>。</p><p>我们知道do notation是<code class="inline">&gt;&gt;=</code>的语法糖，我们将do notation转换成<code class="inline">&gt;&gt;=</code>的串联形式，</p><code lang="haskell">(putStrLn "Please input: ") &gt;&gt;= (\ _ -&gt; (getLine &gt;&gt;= (\inpStr -&gt; (putStrLn $ "Hello " ++ inpStr ))))</code><p>对于第一个<code class="inline">&gt;&gt;=</code>，我们能推断出它的大概类型，</p><code lang="haskell">&gt;&gt;= :: IO ( ) -&gt; (( ) -&gt; IO ?) -&gt; IO ?</code><p>其中“?”表示尚未确定的类型。</p><p>而第二个<code class="inline">&gt;&gt;=</code>的类型，可以完全确定下来。</p><code lang="haskell">&gt;&gt;= :: IO String -&gt; (String -&gt; IO ( )) -&gt; IO ( )</code><p>最后，第一个&gt;&gt;=的类型也就可以完全确定下来了，</p><code lang="haskell">&gt;&gt;= :: IO ( ) -&gt; (( ) -&gt; IO ( )) -&gt; IO ( )</code><p>由此可见，<br>第一个<code class="inline">&gt;&gt;= :: IO ( ) -&gt; (( ) -&gt; IO ( )) -&gt; IO ( )</code><br>第二个<code class="inline">&gt;&gt;= :: IO String -&gt; (String -&gt; IO ( )) -&gt; IO ( )</code><br>两个<code class="inline">&gt;&gt;=</code>的类型不同，它们同时出现了。</p><p>因此，在参数化类型中，类型变量的解和数学方程中未知数的解，意义不同，<br>在数学方程中，同名未知数对应相同的解，<br>而在不同的程序上下文中，同名类型变量可以被确定为不同的具体类型。</p><p>当类型具有多态性时，为了让整个程序类型合法，<br>类型变量就必须满足各个表达式的类型约束条件（constraints），<br>只不过，不同位置的类型变量取值可以不同。</p><p><code class="inline">&gt;&gt;=</code>的定义中包含了参量<code class="inline">m</code>，<code class="inline">a</code>和<code class="inline">b</code>，</p><code lang="haskell">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code><p>在同一个程序中，<code class="inline">m</code>确定为<code class="inline">IO</code>，<code class="inline">a</code>在有的地方确定为<code class="inline">( )</code>，有的地方确定为<code class="inline">String</code>。</p><p>确定这些类型变量的过程，称为类型重建（type reconstruction），<br>有时也称为类型推导（type inference）。</p><h2><b>6. <code class="inline">1 :: Num a =&gt; a</code></b></h2><p>我们来看看<code class="inline">1</code>的类型</p><code lang="haskell">ghci&gt; :t 1
1 :: Num a =&gt; a</code><p>这说明<code class="inline">1</code>具有Ad-hoc多态性，它是<code class="inline">Num typeclass</code>中定义的值。</p><p>在使用Haskell的typeclass时，如果和面向对象语言中的interface类比，<br>就很容易产生一个误区，认为typeclass中只能定义函数。<br>而实际上，typeclass中定义了一些具有Ad-hoc多态类型的值。<br>这个值，当然可以是函数类型的。</p><p>例如：</p><code lang="haskell">class TypeClassWithValue t where 
    plainValue :: t 
    functionValue :: t -&gt; t</code><p>我们来检测下：</p><code lang="haskell">ghci&gt; :t plainValue
plainValue :: TypeClassWithValue t =&gt; t

ghci&gt; :t functionValue
functionValue :: TypeClassWithValue t =&gt; t -&gt; t</code><p><b>注：</b><br>在Haskell规范中并不是这样解释字面量<code class="inline">1</code>的，</p><blockquote>An integer literal represents the application of the function fromInteger to the appropriate value of type Integer.</blockquote><p>其中<code class="inline">fromInteger :: (Num a) =&gt; Integer -&gt; a</code>，<br>因此，整数字面量的类型就是<code class="inline">(Num a) =&gt; a</code>了。</p><p>整数字面量之所以用这种间接的方式来定义，<br>是为了让它们具有Ad-hoc多态性，<br>可以在<code class="inline">Num typeclass</code>不同的实例类型中使用它们。</p><hr><h2>参考</h2><p><a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">Polymorphism</a> <br><a href="https://book.douban.com/subject/1761910/">Types and Programming Languages</a> <br><a href="https://www.haskell.org/onlinereport/haskell2010/">Haskell 2010 Language Report</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
