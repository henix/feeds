<p>曾经有同事问我, 写递归代码有什么秘诀么? 彼时的我说不出什么秘诀, 只觉得写递归代码, 是像呼吸一般自然的事情, 在这之前, 我还真不觉得会有人问 “怎么写递归代码” 这样的问题, 就好像不会有人问你 “怎么呼吸空气” 一样.</p><p>但是秉着 “你表达不出来是因为你理解得不够深入” 的信念, 我一直没有忘记这个问题. 虽然那时我已经 刷完了hackerrank上的FP领域所有recursion标签的习题, 以及codewars上的几乎所有Haskell 1kyu习题, 能用组合子和递归程序解决生产环境的各种编码需求,并且一直坚持避免手写任何无谓的循环, 但是, 不能把我脑子里的技巧, 总结成方法, 或者说不能把我脑子里的方法, 写成纸面上的方法, 这的确一直让我耿耿于怀.</p><p>今天, 在学习函数式编程多年后, 我觉得我终于可以尝试对 “递归” 这个话题, 做一个阶段性的小结了. 本文标题 “递归的五种定式” 中, 之所以借用围棋术语 “定式”, 是因为递归程序正如围棋一样, 规则简单而又千变万化, 这里提到的 “五种” 绝不是一种严格的分类, 它们只是对这万千变化之中的一些常见模式的捕捉和总结.</p><p>这篇文章需要你对编写递归程序有一定经验和体会, 才能领会各种定式之间的差别, 所以, 另一种阅读本文的推荐方式是, 先把里面的习题找出来做一遍, 再回过头来读这篇文章.</p><p>总之, 希望我对这些递归定式的分类和总结能给后来人的学习提供一些帮助.</p><p><i>(备注: 本文还有很多未完善的地方, 比如有些定式缺少一些典型的例子进行说明, 但是我一时间可能很难在脑子里搜寻出这么一个既简单又典型的问题作为例子. 所以如果你有好的例子可以提供, 或者任何改进的建议, 欢迎评论或私信联系)</i></p><hr/><h2>Cata型递归 (cata style recursion)</h2><p class="ztext-empty-paragraph"><br/></p><p>所谓cata型递归, 就是可以利用子结构的计算结果直接构造出父结构的计算结果的情形. 它通常沿着某个递归数据结构 (如列表, 玫瑰树, 抽象语法树等) 进行, 用来求取递归结构的某些归纳性质 (如大小, 总和, 最值等等).</p><p>典型的比如:</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">sum</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">sum</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">sum</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">x</span> <span class="o">+</span> <span class="nf">sum</span> <span class="nf">xs</span>

<span class="nf">size</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">size</span> <span class="p">(</span><span class="kt">Node</span> <span class="nf">label</span> <span class="nf">subtrees</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">sum</span> <span class="p">(</span><span class="nf">map</span> <span class="nf">size</span> <span class="nf">subtrees</span><span class="p">)</span></code></pre></div><p>cata 类型的递归是首选的考虑, 它很常见, 并且它的停机性, 正确性, 复杂度等性质非常易于分析.</p><p>另外, 值得一提的是, cata型递归, 其实还可以用 cata 函数来实现, 当然前提是你要处理的这个递归结构是个函子 (Functor):</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">sum</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">sum</span> <span class="ow">=</span> <span class="nf">cata</span> <span class="p">(</span><span class="nf">\</span><span class="kr">case</span> <span class="kr">of</span> <span class="kt">NilF</span> <span class="ow">-&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="kt">ConsF</span> <span class="nf">x</span> <span class="nf">total</span> <span class="ow">-&gt;</span> <span class="nf">x</span> <span class="o">+</span> <span class="nf">total</span><span class="p">)</span></code></pre></div><p>cata 函数的意思就是, 如果你要求取一个递归结构的某个归纳属性, 那么你只需要提供这样的逻辑片段即可:</p><p><i>“把容器中盛放的递归子结构给替换成要归纳求取的属性值, 然后你据此返回根结构的属性值“</i></p><p>值得注意的是, 这个逻辑片段中是不需要递归调用的, 所以使用 cata 就可以在不使用显式递归的情况下, 实现递归逻辑了.  (不妨想想看, 类似的函数你还能想到哪些呢?</p><p>另外, 列表的 fold 其实可以看作是 cata 函数针对列表的一个特化实现, 比如上述的 sum 就可以类似地用 foldr 实现为:</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">sum</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">sum</span> <span class="ow">=</span> <span class="nf">foldr</span> <span class="p">(</span><span class="nf">\x</span> <span class="nf">total</span> <span class="ow">-&gt;</span> <span class="nf">x</span> <span class="o">+</span> <span class="nf">total</span><span class="p">)</span> <span class="mi">0</span></code></pre></div><p>事实上, 通用的 cata 函数的类型是比较复杂的, 其中涉及到 base functor 啊 recursion schemes 啊等等这些 Haskell 里的的高阶概念, 这里暂时不赘述.</p><p>由于典型的 cata型递归 通常都是比较朴素的, 可能出现在代码里就是一个 fold 或者是一个很简单的直接递归, 所以这里并没有给出专门的练习题, 如果你有兴趣的话, 可以尝试将其它练习题刻意转换为 cata 型递归来完成.</p><hr/><h2>直接递归 (direct recursion)</h2><p class="ztext-empty-paragraph"><br/></p><p>所谓直接递归, 就是直接利用递归子调用的返回结果, 构造当前调用的返回结果, 的递归过程.</p><p>例如比较简单且典型的阶乘运算:</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">fact</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">fact</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fact</span> <span class="nf">n</span> <span class="ow">=</span> <span class="nf">fact</span> <span class="p">(</span><span class="nf">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nf">n</span></code></pre></div><p>以及经典的斐波那契数列:</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">fib</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">fib</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">fib</span> <span class="mi">1</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fib</span> <span class="nf">n</span> <span class="ow">=</span> <span class="nf">fib</span> <span class="p">(</span><span class="nf">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fib</span> <span class="p">(</span><span class="nf">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span></code></pre></div><p>这里值得一提的是, 虽然说 n 是个自然数, 没有结构, 但是其实可以根据皮亚诺公理想象一个递归结构, 或者也可以把 n 构造成 [0..n] 这样的递归结构, 从而将问题转化为可以用cata型递归来解决.</p><p>这一类按照递归分支的数量可以分为线型递归和树型递归两种, 这两种在思维方式上基本是相似的, 主要是对复杂度的预期不同. 如果是线型递归那么一般可以预期它的最坏复杂度上限是线性复杂度. 但是如果是树型递归, 那么它的最坏复杂度上限则是指数的, 其底数是多少其实取决于所有逻辑分支中, 递归分支最多的递归分支数量, 比如上面的 fib 函数, 它的前两个逻辑分支 (当n 等于 0 或 1 时) 中, 递归分支个数都是零 (即并未出现递归调用), 而最后一个分支中, 递归分支个数则是2, 所以它的最坏复杂度上限是 2 的 n 次方, 但这仅仅是一个上限估计, 并非意味着树型递归总是指数复杂度的, 一个典型的例子是比如我们遍历二维格点 (比如棋盘) 的时候, 也会用到树型递归, 但是它的复杂度则是平方级的, 因为树并不满. 当然以上的分析都基于一个基本的前提: 递归参数总是严格减小的, 如果这个前提不满足, 例如3n+1问题这种的话, 那么其实并不能对其复杂度有任何预期, 因为它甚至有可能不会停机.</p><p>Cata型递归 可以认为是 直接递归 的一种特殊情形, 你完全可以用 直接递归 来解决 cata型递归 可以解决的问题, 另一方面你也可以通过构造(或者想象)递归结构来把 直接递归 转化为 cata型递归.</p><p>习题:</p><p><a href="https://link.zhihu.com/?target=https%3A//www.hackerrank.com/challenges/string-mingling/problem" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">hackerrank.com/challeng</span><span class="invisible">es/string-mingling/problem</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.hackerrank.com/challenges/string-o-permute/problem" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">hackerrank.com/challeng</span><span class="invisible">es/string-o-permute/problem</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.hackerrank.com/challenges/prefix-compression/problem" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">hackerrank.com/challeng</span><span class="invisible">es/prefix-compression/problem</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.hackerrank.com/challenges/functional-programming-warmups-in-recursion---gcd/problem" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">hackerrank.com/challeng</span><span class="invisible">es/functional-programming-warmups-in-recursion---gcd/problem</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.hackerrank.com/challenges/super-digit/problem" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">hackerrank.com/challeng</span><span class="invisible">es/super-digit/problem</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.hackerrank.com/challenges/pascals-triangle/problem" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">hackerrank.com/challeng</span><span class="invisible">es/pascals-triangle/problem</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.codewars.com/kata/simple-repeated-words/train/haskell" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">codewars.com/kata/simpl</span><span class="invisible">e-repeated-words/train/haskell</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.codewars.com/kata/title-case/train/haskell" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">codewars.com/kata/title</span><span class="invisible">-case/train/haskell</span><span class="ellipsis"></span></a></p><hr/><h2>间接递归 (indirect recursion)</h2><p class="ztext-empty-paragraph"><br/></p><p>直接递归非常容易想到, 但是有些时候, 你要实现的目标函数可能不适合直接用于递归, 有时候是因为, 它们需要递归向下传递一些额外的状态参数, 另一些时候是因为, 它们需要向上传递一些额外的返回值.  这些时候, 就需要寻找一个更加合适的递归函数, 我称之为 “递归核”,  然后, 目标函数其实就是对递归核函数的一层很薄的封装, 它只需要对输入做一些简单的预处理, 然后把它们交给递归核, 并且把递归核返回的结果做一些后处理即可.</p><p>例如, 在利用矩阵的快速幂运算实现一个高效的 fib 函数的时候, 我们的递归函数并不是 fib 本身, 而是带有一个额外的矩阵作为状态参数的 matPow 函数, 并且这个递归核的返回值也是一个矩阵而并非我们直接要返回的 fib n 的值:</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">import</span> <span class="nn">Data.Matrix</span> <span class="k">as</span> <span class="n">Mat</span>

<span class="nf">fib</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">fib</span> <span class="nf">n</span> <span class="ow">=</span> <span class="kt">Mat</span><span class="o">.</span><span class="nf">getElem</span> <span class="mi">1</span> <span class="mi">2</span> <span class="p">(</span><span class="nf">matPow</span> <span class="p">(</span><span class="kt">Mat</span><span class="o">.</span><span class="nf">fromList</span> <span class="mi">2</span> <span class="mi">2</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="nf">n</span><span class="p">)</span> <span class="kr">where</span>
    <span class="nf">matPow</span> <span class="nf">m</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Mat</span><span class="o">.</span><span class="nf">identity</span> <span class="mi">2</span>
    <span class="nf">matPow</span> <span class="nf">m</span> <span class="nf">n</span> <span class="o">|</span> <span class="nf">even</span> <span class="nf">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">m&#39;</span> <span class="ow">=</span> <span class="nf">matPow</span> <span class="nf">m</span> <span class="p">(</span><span class="nf">n</span> <span class="p">`</span><span class="nf">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="kr">in</span> <span class="nf">m&#39;</span> <span class="p">`</span><span class="kt">Mat</span><span class="o">.</span><span class="nf">multStd</span><span class="p">`</span> <span class="nf">m&#39;</span>
    <span class="nf">matPow</span> <span class="nf">m</span> <span class="nf">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">m&#39;</span> <span class="ow">=</span> <span class="nf">matPow</span> <span class="nf">m</span> <span class="p">(</span><span class="nf">n</span> <span class="p">`</span><span class="nf">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="kr">in</span> <span class="nf">m&#39;</span> <span class="p">`</span><span class="kt">Mat</span><span class="o">.</span><span class="nf">multStd</span><span class="p">`</span> <span class="nf">m&#39;</span> <span class="p">`</span><span class="kt">Mat</span><span class="o">.</span><span class="nf">multStd</span><span class="p">`</span> <span class="nf">m</span></code></pre></div><p>习题:</p><p><a href="https://link.zhihu.com/?target=https%3A//www.hackerrank.com/challenges/sequence-full-of-colors/problem" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">hackerrank.com/challeng</span><span class="invisible">es/sequence-full-of-colors/problem</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.hackerrank.com/challenges/functional-programming-the-sums-of-powers/problem" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">hackerrank.com/challeng</span><span class="invisible">es/functional-programming-the-sums-of-powers/problem</span><span class="ellipsis"></span></a></p><hr/><h2>尾递归 (tail recursion)</h2><p class="ztext-empty-paragraph"><br/></p><p>有时候, 你并不希望为每一步都构造返回结果, 你希望只有到达特定状态的时候, 再去构造返回结果, 而其它时候, 只需要更新一些状态变量即可.</p><p>这种情况下, 对于熟悉命令式编程的程序员来说, 最容易想到的实现方式是循环, 你可以在每一步维护状态变量, 然后当循环结束的时候, 再根据之前构造的状态变量去构造最终结果.</p><p>比如当我们想写一个更高效一丢丢的, 线性复杂度版本的 fib 的时候:</p><div class="highlight"><pre><code class="language-cpp"><span class="c1">//迭代(循环)实现
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">a_next</span> <span class="o">=</span> <span class="n">b</span> <span class="p">,</span> <span class="n">b_next</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">;</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">a_next</span> <span class="p">;</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">b_next</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span>
<span class="p">}</span>
</code></pre></div><p>而在FP风格中, 我们使用尾递归来做这样的事情. 所谓尾递归, 是指在递归函数的函数体的每一个逻辑分支中, 所有递归调用都是尾调用, 即被直接 return 而外面没有包裹其它额外运算. 不满足尾递归定义的递归也被称为 guarded recursion (意指递归的返回值会被守在递归出口的运算逻辑捕获).</p><div class="highlight"><pre><code class="language-cpp"><span class="c1">//尾递归实现
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">fib_iter</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">fib_iter</span><span class="p">(</span><span class="n">b</span> <span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fib_iter</span><span class="p">(</span><span class="mi">0</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>以上 cpp 代码等价的 haskell 代码:</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">fib</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">fib</span> <span class="nf">n</span> <span class="ow">=</span> <span class="nf">iter</span> <span class="mi">0</span> <span class="mi">1</span> <span class="nf">n</span> <span class="kr">where</span>
    <span class="nf">iter</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">n</span> <span class="ow">=</span> <span class="kr">if</span> <span class="nf">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="nf">a</span> <span class="kr">else</span> <span class="nf">iter</span> <span class="nf">b</span> <span class="p">(</span><span class="nf">a</span><span class="o">+</span><span class="nf">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></code></pre></div><p>如果你已经写就循环版本, 那么通过一个非常 trivial 的转换即可得到对应的尾递归版本, 没错, 尾递归和循环这两种形式的代码是等价的, 它们可以很容易地进行互转, 这在我之前的一篇回答中已经提到了: <a href="https://www.zhihu.com/question/20761771/answer/20672305" class="internal">什么是尾递归？</a></p><p>之前一些组里的小盆友反馈学习Haskell的体验时表示, 很多题给他循环都能写出来的, 但是不给循环就不会写了, 这其实是不熟悉尾递归的原因, 遇到这种情况其实大不了先把循环版本写下来, 再手动改成尾递归即可, 熟悉之后你就会更乐于写尾递归版本了, 毕竟尾递归版本不用关心对迭代变量的赋值顺序, 只需要专注于构造下一个状态即可.</p><p>还有人说递归没有 break 和 continue 不方便, 其实还是不够动脑筋, continue 相当于直接递归调用转移到下一个状态即可, break 的话, 因为你写尾递归版本, 可以在任何一个逻辑分支直接构造最终结果并返回, 所以本来就相当于可以随时 break, 真正写一下就知道这根本不会是问题.</p><p>一个不方便使用结果递归但是很适合使用尾递归的例子:  <a href="https://link.zhihu.com/?target=https%3A//www.codewars.com/kata/range-extraction/train/haskell" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">codewars.com/kata/range</span><span class="invisible">-extraction/train/haskell</span><span class="ellipsis"></span></a></p><p>由于尾递归会引入额外的状态参数, 一般至少会引入一个用来存储将要返回的结果的状态参数, 所以尾递归常常被用作递归核, 而很少会直接对外暴露.</p><p>尾递归也可以和直接递归互相转换:</p><p>一方面, 尾递归本身就可以被视为一种特殊的线型直接递归, 它的特殊之处在于, 它在所有包含递归调用的逻辑分支中, 总是直接返回递归调用的返回值, 而不会对返回值进行更多的处理.</p><p>另一方面, 直接递归, 不论是线型, 还是树型, 都可以转换为尾递归形式:</p><p>将线型直接递归转换为尾递归的方式是, 引入一个额外的状态参数, 用于储存部分结果.</p><p>而将树型直接递归转换为尾递归时, 则需要引入一个额外的状态参数, 用于存储调用栈的栈帧. 这和通常说的 “递归转循环” 是类似的过程.</p><p class="ztext-empty-paragraph"><br/></p><p>习题(尝试不用循环实现):</p><p><a href="https://link.zhihu.com/?target=https%3A//www.codewars.com/kata/can-you-get-the-loop/train/haskell" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">codewars.com/kata/can-y</span><span class="invisible">ou-get-the-loop/train/haskell</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.codewars.com/kata/valid-braces/train/haskell" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">codewars.com/kata/valid</span><span class="invisible">-braces/train/haskell</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.codewars.com/kata/simple-assembler-interpreter/train/haskell" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">codewars.com/kata/simpl</span><span class="invisible">e-assembler-interpreter/train/haskell</span><span class="ellipsis"></span></a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.codewars.com/kata/longest-consecutive-sequence-of-squares/train/haskell" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">codewars.com/kata/longe</span><span class="invisible">st-consecutive-sequence-of-squares/train/haskell</span><span class="ellipsis"></span></a></p><hr/><h2>互递归 (mutual recursion)</h2><p class="ztext-empty-paragraph"><br/></p><p>互递归的一个典型例子就是自顶向下的手写 parser.</p><p>理论上, 互递归和直接递归也可以互相转换:</p><p>一方面, 直接递归本来就是一种特殊的互递归 (trivial case).</p><p>另一方面, 互递归可以通过代入消除 (类似 inline 的过程) 的方式, 转换为直接递归, 一些情况下, 这样转换产生的代码长度不会发生太大的变化, 仍然在可接受范围内, 而另一些情况下, 这样转换之后的代码将变得冗长而不可读, 所以这种转换也可以当成是判断是否真的有必要使用互递归的一个标准.</p><p>有些时候, 我们会把直接递归代码中, 递归部分的一些重复模式提出来, 作为函数去调用, 以减少重复, 这种时候就会很自然地得到互递归的代码了.</p><p>(关于互递归的习题, 除了 parser 题之外, 我一时没有找到特别典型的例子, 如果后续碰到, 我会在这里补上, 如果你遇到了很好的例子, 也欢迎告诉我</p><hr/><h2>它们的关系</h2><p class="ztext-empty-paragraph"><br/></p><p>Cata型递归 和 尾递归 其实是从直接递归中剥离出来的两类特殊情形. 它们因为其各自的独特性质而被拎出来单独探讨.</p><p>而 间接递归 和 互递归 其实都是对直接递归的拓展, 只是它们各自拓展的维度不同.</p><div class="highlight"><pre><code class="language-text">              ~~~~~~~~     ~~~~
             cata型递归   尾递归
             ~~~~~~~~~~~~~~~~~~~
                  直接递归 
~~~~~~~~~~~~~~~~~~~~~~~~~~~
    间接递归     ~~~~~~~~~~~~~~~~~~~~~~~
                            互递归</code></pre></div><p class="ztext-empty-paragraph"><br/></p><p>最后, 需要注意的是, 这里对习题的分类不是严格和强制的, 同一个问题, 我们总是可以尝试用各种不同的方法去解决. 我这里会尽量选择典型的习题, 也即, 这些习题用相应的方式去解, 是最直接的, 当然这个 “直接” 也会因人而异, 所以我并不能对此做任何保证, 但是尝试用不同的方式去解决同一个问题, 这本身也是一种极有趣的练习, 不是么 :)</p><p><br/>(题图待补充, 欢迎热心观众赞助 :)</p>