<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Rails 中 ActiveRecord 的不当使用产生 SQLi 风险</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/27131797">原文</a></p>
Ruby on Rails 是一个经典的 MVC 框架。其中，ActiveRecord 是 MVC 中的 M（模型），负责处理数据和业务逻辑。每一个数据库表对应创建一个类，类的每一个对象实例对应于数据库中表的一行记录，通常表的每个字段在类中都有相应的 Field。ActiveRecord 同时负责把自己持久化，在 ActiveRecord 中封装了对数据库的访问，即 CURD。<br><br>使用 ActiveRecord 执行 SQL 语句的大概顺序是：<br><ol><li>把提供的查询方法转换为等价的 SQL 查询。</li><li>触发 SQL 查询并从数据库中检索对应的结果。<br></li><li>为每个查询结果实例化对应的模型对象。<br></li><li>当存在回调时，先调用 after_find 回调再调用 after_initialize 回调。<br></li></ol><br>只要能够理解第一步中的转换规则，那么针对 ActiveRecord 的 SQL 注入和普通的 SQL 注入并没有什么区别。<p>然而，Rails 为 ActiveRecord 方法提供了内置的 SQL 过滤器，用于转义 '、"、NULL 和换行符，使得大部分 SQL 注入都失去作用。但这并不代表开发者写出来的代码就是绝对安全的。如果没有对用户输入手动进行过滤，并且错误运用了某些方法，那么仍然存在 SQL 注入的风险。具体来讲，在使用某些方法时，需要手动触发这个过滤器。</p><p>所谓“错误使用“指的是，向某些方法传入 String 而不是 Array 或 Hash。因为在这种情况下，过滤器不会被触发。</p><img src="https://pic1.zhimg.com/v2-75b92d2df83de4662e105a85fca20ae1_r.png" data-rawwidth="970" data-rawheight="619"><h2><b>where</b></h2><p>以常用的 where 方法作例子，它能够接受的参数类型有 string,array 和 hash。然而，过滤器只有当传入的参数是 array 或 hash 时才是生效。如果开发者直接传入一个 string 类型的参数，那么会带来严重的安全隐患，看下面这个例子:<br></p><code lang="text">User.where("name = '#{params[:name]}' AND password = '#{params[:password]}'")</code><p>其中，params[:name]和params[:password] 是表单提交的用户名和密码。转换后的 SQL 语句为：<br></p><code lang="text">SELECT "users".* FROM "users" WHERE (name = 'params[:name]'  AND password = ' params[:password]')</code><p>如果输入的 name为“') OR 1=1--“，那么 SQL 语句就会变成：<br></p><code lang="text">SELECT "users".* FROM "users" WHERE (name = '') OR 1=1--' AND password = '')</code><p>“OR 1”后面的内容全部被注释掉了，这是很常见的一句话密码，它和不使用 ORM 的情况下SQL 注入的 PAYLOAD 并无二异。</p><p>安全的写法如下：</p><ol><li>传入 Array：<br><code lang="text">User.where("name = ? AND password =?" , entered_user_name, entered_password)</code><br></li><li>或者传入 Hash：<br><code lang="text">User.where(name : entered_user_name, password : entered_password )</code><br></li></ol><p>这两种情况下过滤器会被触发，输入的引号会被转义引起报错：<br></p><code lang="text">SELECT "users".* FROM "users" WHERE (name = '\') OR 1=1--' AND password = '')</code><h2><b>find_by</b></h2><p>同理，find_by 方法也有相同的问题，因为它等价于 where(*args).take:<br></p><code lang="text">params[:id] = "admin = '’ OR 1=1 )#"
User.find_by params[:id]</code><p>SQL 语句：<br></p><code lang="text">SELECT "users".* FROM "users" WHERE (admin = '’ OR 1=1 )#) LIMIT ?</code><br><p>最安全的方式是传入 Hash:<br></p><code lang="text">User.find_by admin: params[:id]</code><h2><b>Select/pluck</b></h2><code lang="text">Model.select(:field)</code><p>select 方法用于指定查询字段，如果传入的是 String,那么输入完全不会被转义：<br></p><code lang="text">params[:column] = "* FROM users WHERE admin = 't' #"
User.select(params[:column])</code><p><br>SQL：<br></p><code lang="text">SELECT * FROM users WHERE admin = 't' # FROM "users"</code><p>需要注意 select 方法返回的是 Model 类。<br>pluck 方法和 select 方法作用的地方一致，唯一的不同是 pluck 方法返回一个数组。<br></p><code lang="text">User.select(:id).map { |c| c.id } </code><p><br>等价于：<br></p><code lang="text">User.pluck(:id)</code><p>因为 select 和 pluck 方法作用于 SQL 语句的最开始，因此 SQL 注入的方式非常灵活。<br></p><h2><b>delete_all/destroy_all/update_all</b></h2><p>这三个批量操作方法都可以进行 SQL 注入，只要传入的参数是 String。<br>delete_all 和 destroy_all 的区别是 destroy_all 会触发 ActiveRecord 的回调，而 delete_all 会直接把 SQL 语句传给数据库，所以理论上 destroy_all 比 delete_all 更安全一点。总之，正确的使用方法是传入 Hash。<br></p><br><h2><b>参考链接</b></h2><a href="https://rails-sqli.org/" data-editable="true" data-title="Rails SQL Injection Examples">Rails SQL Injection Examples</a>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
