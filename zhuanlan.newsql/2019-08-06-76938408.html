<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TiDB Binlog 源码阅读系列文章（三）Pump client 介绍</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/76938408">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-548816c2ee059830d19edbb17354f7b3_b.jpg" alt=""></div><p>作者：黄佳豪</p><p>在 <a href="https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-binlog-source-code-reading-2/" class=" wrap external" target="_blank" rel="nofollow noreferrer">上篇文章</a> 中，我们介绍了 Pump 的作用是存储 TiDB 产生的 binlog。本篇将介绍 Pump client，希望大家了解 TiDB 把 binlog 写到 Pump，以及输出数据的过程。</p><h2>gRPC API</h2><p>Pump client 的代码在 tidb-tools 下这个 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/tree/v3.0.0-rc.3/tidb-binlog/pump_client" class=" wrap external" target="_blank" rel="nofollow noreferrer">路径</a>，TiDB 会直接 import 这个路径使用 Pump client package。TiDB 跟 Pump 之间使用 gRPC 通信，相关的 proto 文件定义在 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tipb/tree/87cb1e27ab4a86efc534fd4c5b62fda621e38465/proto/binlog" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a>。Pump server 提供以下两个接口：</p><div class="highlight"><pre><code class="language-text">// Interfaces exported by Pump.
service Pump {
    // Writes a binlog to the local file on the pump machine.
    // A response with an empty errmsg is returned if the binlog is written successfully.
    rpc WriteBinlog(WriteBinlogReq) returns (WriteBinlogResp) {}

    // Sends binlog stream from a given location.
    rpc PullBinlogs(PullBinlogReq) returns (stream PullBinlogResp) {}
}</code></pre></div><p>本文我们主要介绍 RPC <code>WriteBinlog</code> 这个接口，Pump client 会通过这个接口写 binlog 到 Pump。</p><p><code>WriteBinlogReq</code> 里面包含的 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tipb/blob/87cb1e27ab4a86efc534fd4c5b62fda621e38465/proto/binlog/binlog.proto%23L57" class=" wrap external" target="_blank" rel="nofollow noreferrer">binlog event</a>：</p><div class="highlight"><pre><code class="language-text">// Binlog contains all the changes in a transaction, which can be used to reconstruct SQL statement, then export to
// other systems.
message Binlog {
    optional BinlogType    tp             = 1 [(gogoproto.nullable) = false];

    // start_ts is used in Prewrite, Commit and Rollback binlog Type.
    // It is used for pairing prewrite log to commit log or rollback log.
    optional int64         start_ts       = 2 [(gogoproto.nullable) = false];

    // commit_ts is used only in binlog type Commit.
    optional int64         commit_ts      = 3 [(gogoproto.nullable) = false];

    // prewrite key is used only in Prewrite binlog type.
    // It is the primary key of the transaction, is used to check that the transaction is
    // commited or not if it failed to pair to commit log or rollback log within a time window.
    optional bytes         prewrite_key   = 4;

    // prewrite_data is marshalled from PrewriteData type,
    // we do not need to unmarshal prewrite data before the binlog have been successfully paired.
    optional bytes         prewrite_value = 5;

    // ddl_query is the original ddl statement query.
    optional bytes         ddl_query      = 6;

    // ddl_job_id is used for DDL Binlog.
    // If ddl_job_id is setted, this is a DDL Binlog and ddl_query contains the DDL query.
    optional int64         ddl_job_id     = 7 [(gogoproto.nullable) = false];
}</code></pre></div><h2>TiDB 如何写 binlog</h2><p>TiDB 的事务采用 2-phase-commit 算法，一次事务提交会分为 Prewrite 和 Commit 阶段，有兴趣的可以看下相关文章<a href="https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-transaction-model/" class=" wrap external" target="_blank" rel="nofollow noreferrer">《TiKV 事务模型概览，Google Spanner 开源实现》</a>。</p><p>大家可以先猜想一下 TiDB 是如何写 binlog 的？</p><p>如果只写一条 binlog 的话可行吗？可以很容易想到，如果只写一条 binlog 的话必须确保写 binlog 操作和事务提交操作是一个原子操作，那么就要基于事务模型再构建一个复杂的 2PC 模型，从复杂度方面考虑这个方案几乎是不可行的。</p><p>实际上，在 TiDB 的实现中，TiDB 会每个阶段分别写一条 binlog， 即：Prewrite binlog 和 Commit binlog，下面会简称 P-binlog 和 C-binlog ，具体写入流程如下：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-a0d9bd1b443902939ed6a5fadb65deb2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1002" data-rawheight="672" class="origin_image zh-lightbox-thumb" width="1002" data-original="https://pic3.zhimg.com/v2-a0d9bd1b443902939ed6a5fadb65deb2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-a0d9bd1b443902939ed6a5fadb65deb2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1002" data-rawheight="672" class="origin_image zh-lightbox-thumb lazy" width="1002" data-original="https://pic3.zhimg.com/v2-a0d9bd1b443902939ed6a5fadb65deb2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-a0d9bd1b443902939ed6a5fadb65deb2_b.jpg"/></figure><p>这里我们说的 P-binlog 和 C-binlog 都是通过 RPC <code>WriteBinlog</code> 接口写入，对应着参数 <code>WriteBinlogReq</code> 里面包含的 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tipb/blob/87cb1e27ab4a86efc534fd4c5b62fda621e38465/proto/binlog/binlog.proto%23L57" class=" wrap external" target="_blank" rel="nofollow noreferrer">binlog event</a>，只是字段有些区别：</p><ul><li>P-binlog 对应的 <code>tp</code> 是 <code>Prewrite</code>，C-binlog 的 <code>tp</code> 是 <code>Commit</code> 或者 <code>Rollback</code>。</li><li>同个事务的 P-binlog 和 C-binlog 包含相同 <code>start_ts</code>。</li><li>只有 P-binlog 包含对应事务修改数据 <code>prewrite_value</code>。</li><li>只有 C-binlog 包含事务的 <code>commit_ts</code>。</li></ul><p>在 Prepare 的阶段，TiDB 会把 Prewrite 的数据发到 TiKV，同时并发写一条 P-binlog 到其中一个 Pump。 两个操作全部成功后才会进行 Commit 阶段，所以我们提交事务时就可以确定 P-binlog 已经成功保存。写 C-binlog 是在 TiKV 提交事务后异步发送的，告诉  Pump 这个事务提交了还是回滚了。</p><h3> 写 binlog 对事务延迟的影响</h3><ul><li>Prepare 阶段：并发写 P-binlog 到 Pump 和 Prewrite data 到 TiKV，如果请求 Pump 写 P-binlog 的速度快于写 TiKV 的速度，那么对延迟没有影响。一般而言写入 Pump 会比写入 TiKV 更快。</li><li>Commit 阶段：异步的去写 C-binlog，对延迟也没有影响。</li></ul><h3>写 binlog 失败</h3><ol><li>写 P-binlog 失败，那么 transaction 不会 commit，不会对系统有任何影响。</li><li>写 C-binlog 失败，Pump 会等待最多 <code>max transaction timeout</code> 的时间（这是一个 TiDB/Pump 的配置，默认为 10 分钟），然后向 TiKV 去查询 transaction 的提交状态来补全 C-binlog，但是此时同步延迟也等于 <code>max transaction timeout</code> 。这种情况经常发生于 TiDB 进程重启或者挂掉的场景。</li><li>写 P-binlog 成功，但是 Prewrite 失败，那么也会和 2 类似。</li></ol><h2>Pump client 源码</h2><p>Pump client 的代码维护在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/tree/master/tidb-binlog/pump_client" class=" wrap external" target="_blank" rel="nofollow noreferrer">pump_client</a></code>，提供了 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/client.go%23L125" class=" wrap external" target="_blank" rel="nofollow noreferrer">NewPumpsClient</a></code> 方法来创建一个 Pump client  实例。Pump client 的主要功能就是维护所有 Pump 状态（将 Pump 分为 avaliable 和 unavailable 两种状态），以此为依据将 TiDB 生成的 binlog 发送到合适的 Pump。为此 Pump client 主要实现了以下几个机制：</p><ol><li>watch etcd<br/>Pump 在运行时会将自己的状态信息上报到 PD（etcd）中，并且定时更新自己的状态。在创建 Pump client 的时候，会 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/client.go%23L227" class=" wrap external" target="_blank" rel="nofollow noreferrer">首先从 PD（etcd）中获取所有的 Pump 状态信息</a>，根据 Pump 状态是否为 Online 初步判断 Pump 为 avaliable 或者 unavailable。然后 Pump client 会 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/client.go%23L478" class=" wrap external" target="_blank" rel="nofollow noreferrer">watch</a> etcd 中的 Pump 状态变更，及时更新内存中维护的 Pump 状态。</li><li>binlog 重试机制<br/>对于每个 Pump，在 Pump client 中都维护了一个变量 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/pump.go%23L70" class=" wrap external" target="_blank" rel="nofollow noreferrer">ErrNum</a></code> 来记录该 Pump 写 binlog 的失败次数，当 ErrNum 超过一定的阈值，则判断 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/pump.go%23L174" class=" wrap external" target="_blank" rel="nofollow noreferrer">该 Pump 不可用</a>，如果写 binlog 成功，则 href=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/pump.go%23L162" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/tidb</span><span class="invisible">-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/pump.go#L162</span><span class="ellipsis"></span></a>&#34;&gt;重置 ErrNum。</li><li>发送探活请求<br/>在某些情况下，比如网络抖动，可能会导致 Pump 写 binlog 失败，因此该 Pump 被 Pump client 判断状态为 unavailable，但是当网络恢复后，该 Pump 仍然可以提供写 binlog 服务。Pump client 实现了 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/client.go%23L531" class=" wrap external" target="_blank" rel="nofollow noreferrer">detect</a> 机制，会定期向 unavailable 状态的 Pump 发送探活请求，如果探活请求成功，则更新 Pump 状态为 avaliable。</li></ol><p>为了将 binlog 均匀地分发到所有 Pump，Pump client 使用 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/selector.go%23L47" class=" wrap external" target="_blank" rel="nofollow noreferrer">PumpSelector</a></code> 为每一个 binlog 选择一个合适的 Pump，<code>PumpSelector</code> 是一个接口，提供 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/selector.go%23L49" class=" wrap external" target="_blank" rel="nofollow noreferrer">SetPumps</a></code> 方法来设置可选的 Pump 列表，提供 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/selector.go%23L52" class=" wrap external" target="_blank" rel="nofollow noreferrer">Select</a></code> 来为 binlog 选择 Pump。目前主要实现了 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/selector.go%23L59" class=" wrap external" target="_blank" rel="nofollow noreferrer">Hash</a> 和 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/selector.go%23L109" class=" wrap external" target="_blank" rel="nofollow noreferrer">Round-Robin</a> 两种策略。</p><p>为了提高 Pump client 的健壮性，binlog 写失败后会提供一定的重试，每个 Pump 可以重试写多次，同时也会尽量尝试所有的 Pump，这样就可以保证部分 Pump 有故障或者临时的网络抖动也不影响 TiDB 写 binlog，可以查看 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/c969908e6130dfbdb4ab80fb84f275df2a6fd877/tidb-binlog/pump_client/client.go%23L242" class=" wrap external" target="_blank" rel="nofollow noreferrer">WriteBinlog</a></code>了解具体实现方式。</p><h2>小结</h2><p>本文给大家介绍了 TiDB 如何通过 Pump client 写 binlog 到 Pump，以及 binlog 的主要内容，后续我们将继续介绍 Pump server 是对应如何处理相应请求的。</p><p><b>阅读原文：</b></p><a href="https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-binlog-source-code-reading-3/" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg" data-image-width="1200" data-image-height="1200" class=" wrap external" target="_blank" rel="nofollow noreferrer">TiDB Binlog 源码阅读系列文章（三）Pump client 介绍 | PingCAP</a><p><b>更多 TiDB Binlog 源码阅读：</b></p><a href="https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/%23TiDB-Binlog-%25E6%25BA%2590%25E7%25A0%2581%25E9%2598%2585%25E8%25AF%25BB" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg" data-image-width="1200" data-image-height="1200" class=" wrap external" target="_blank" rel="nofollow noreferrer">Blog-cns | PingCAP</a><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
