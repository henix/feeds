<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>你好，类型（三）：Combinatory logic</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34699469">原文</a></p>
<p></p><img src="https://pic2.zhimg.com/v2-287adfd6b025ac4b76c62ee1f9ff40d5_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="698"><h2><b>回顾</b></h2><p>上一篇中，我们介绍了 <equation>\lambda</equation> 演算，它是由一堆<b>合法的符号</b>和一些<b>推导规则</b>构成的<b>公理系统</b>，<br>在众多 <equation>\lambda</equation> 演算中，我们介绍了最常用的 <equation>\lambda_\beta</equation> 系统，<br>它指定了 <equation>\alpha</equation> 和 <equation>\beta</equation> 两种对 <equation>\lambda</equation> 项的变换规则。</p><p>作为形式系统，上一篇中，我们展现了它的编码能力，<br>将邱奇编码，与公理集合论中自然数的归纳集定义，进行了对比。</p><p>本文我们将介绍另一套形式系统，<b>组合子逻辑</b>（combinatory logic）。</p><h2><b>1. 组合子逻辑</b></h2><img src="https://pic4.zhimg.com/v2-ef80bd38f8b0ceeaa3a69f47020c193d_r.jpg" data-caption="" data-size="normal" data-rawwidth="379" data-rawheight="133"><p><equation>CL</equation> （<b>组合子逻辑</b>），与 <equation>\lambda</equation> 演算很相似，只是不需要对变量进行绑定，<br>和函数作用在值上不同的是，组合子作用在函数上，从而生成另一个函数。</p><p>例如，我们可以定义一个组合子 <equation>B</equation> ，使得 <equation>(B(f,g))(x) = f(g(x))</equation> ，<br>其中， <equation>f</equation> 和 <equation>g</equation> 都是函数。</p><p>为了避免过早的谈及语义，我们和 <equation>\lambda</equation> 演算一样，使用公理化的方法来定义它，<br>首先我们要说明什么是<b>公理</b>，即什么是<b>合法的 <equation>CL</equation> 项</b>，<br>（1）所有的变量，常量，以及组合子 <equation>I</equation> ， <equation>K</equation> ， <equation>S</equation> ，都是合法的 <equation>CL</equation> 项，<br>（2）如果 <equation>X</equation> 和 <equation>Y</equation> 是合法的 <equation>CL</equation> 项，那么 <equation>(XY)</equation> 也是。</p><p>例如，以下字符串都是合法的 <equation>CL</equation> 项， <equation>((S(KS))K)</equation> ， <equation>((S(Kv_0))((SK)K))</equation> 。</p><p>同样为了简化，某些情况下括号是可以省略的，如果我们默认各个 <equation>CL</equation> 项都是左结合的，<br>因此， <equation>(((UV)W)X)</equation> 可以简写为 <equation>UVWX</equation> 。</p><h2><b>2. Weak reduction</b></h2><img src="https://pic3.zhimg.com/v2-039de867b1267bba559051a625e3300a_r.jpg" data-caption="" data-size="normal" data-rawwidth="500" data-rawheight="340"><p>现在，我们要完成公理化的第二步了，那就是给合法的 <equation>CL</equation> 项指定<b>变换规则</b>，<br>在 <equation>CL</equation> （组合子逻辑中）中，我们称之为<b>weak reduction</b>，即我们令，<br>（1） <equation>IX</equation> ，可以变换为 <equation>X</equation> ，<br>（2） <equation>KXY</equation> ，可以变换为 <equation>X</equation> ，<br>（3） <equation>SXYZ</equation> ，可以变换为 <equation>XZ(YZ)</equation> 。</p><p>如果 <equation>U</equation> 经过有限步weak reduction转换为 <equation>V</equation> ，就写为 <equation>U\triangleright_w V</equation> 。</p><p>与 <equation>\lambda</equation> 项的 <equation>\beta</equation> 范式一样，我们将不能再继续进行weak reduction的 <equation>CL</equation> 项，<br>称为<b>weak范式</b>（weak normal form）。</p><p>我们来看一个例子，设 <equation>B=S(KS)K</equation> ，来计算 <equation>BXYZ</equation> ，<br> <equation>BXYZ=S(KS)KXYZ</equation> <br> <equation>\triangleright_w KSX(KX)YZ</equation> ，因为 <equation>S(KS)KX\triangleright_w KSX(KX)</equation> ，<br> <equation>\triangleright_w S(KX)YZ</equation> ，因为 <equation>KSX\triangleright_w S</equation> ，<br> <equation>\triangleright_w KXZ(YZ)</equation> ，<br> <equation>\triangleright_w X(YZ)</equation> 。</p><p>有了合法的 <equation>CL</equation> 项（公理），以及weak reduction（推导规则），<br>我们就建立了另一个形式系统 <equation>CL_w</equation> 。</p><h2><b>3.</b> <b>CL与<i>λ</i>演算之间的关系</b></h2><img src="https://pic2.zhimg.com/v2-9d8d89d30817ab781c9e69e1a14bb7eb_r.jpg" data-caption="" data-size="normal" data-rawwidth="513" data-rawheight="190"><p>以上我们看到 <equation>CL</equation> 项，似乎只能进行项的应用（application）操作，<br>对应于 <equation>\lambda</equation> 项的用法为 <equation>(MN)</equation> ，<br>然而，其实 <equation>CL</equation> 的威力却不止于此，它的<b>计算能力</b>是与 <equation>\lambda</equation> 演算相当的。</p><p>为了证明等价性，建立 <equation>CL</equation> 项与 <equation>\lambda</equation> 项之间的关系，<br>现在我们用 <equation>I</equation> ， <equation>K</equation> ， <equation>S</equation> 三个组合子，来定义与 <equation>\lambda x.M</equation> 相似的概念。</p><p>对于任意的 <equation>CL</equation> 项 <equation>M</equation> ，以及任意的变量 <equation>x</equation> ，我们定义 <equation>[x].M</equation> 用如下方式表示，<br>（1） <equation>[x].M=KM</equation> ，如果 <equation>M</equation> 中不含有 <equation>x</equation> ，<br>（2） <equation>[x].x=I</equation> ，<br>（3） <equation>[x].Ux=U</equation> ，如果 <equation>U</equation> 中不含有 <equation>x</equation> ，<br>（4） <equation>[x].UV=S([x].U)([x].V)</equation> ，如果（1）和（3）都不适用的话。</p><p>例如，<br> <equation>[x].xy=S([x].x)([x].y)=SI(Ky)</equation> </p><p>可见， <equation>[x].M</equation> 可以完全用 <equation>I</equation> ， <equation>K</equation> ， <equation>S</equation> 三个组合子来构建出来，<br>它表示了与 <equation>\lambda x.M</equation> 相对应的概念。</p><p>因此，我们可以建立 <equation>\lambda</equation> 项与 <equation>CL</equation> 项的对应关系了，<br>在 <equation>CL</equation> 中， <equation>X=Y</equation> ，相当于 <equation>\lambda</equation> 演算中， <equation>X\equiv_\alpha Y</equation> ，可以统一记为 <equation>X\equiv Y</equation> 。<br> <equation>X\triangleright_w Y</equation> ，相当于 <equation>X\triangleright_\beta Y</equation> ，可以统一记为 <equation>X\triangleright_{\beta,w} Y</equation> 。</p><p>相应的， <equation>I</equation> ， <equation>K</equation> ， <equation>S</equation> 也可以使用 <equation>\lambda</equation> 项来表示，<br> <equation>I=\lambda x.x</equation> ， <equation>K=\lambda xy.x</equation> ， <equation>S=\lambda xyz.xz(yz)</equation> 。</p><h2><b>4. 不动点定理</b></h2><p>在 <equation>\lambda</equation> 演算和 <equation>CL</equation> 中，存在组合子 <equation>Y</equation> ，使得 <equation>Yx\triangleright_{\beta,w} x(Yx)</equation> 。</p><p>证明：令 <equation>U=\lambda ux.x(uux)</equation> ， <equation>Y=UU</equation> ，则，<br> <equation>Yx=(\lambda u.(\lambda x.x(uux)))Ux=x(UUx)=x(Yx)</equation> 。</p><h2><b>总结</b></h2><p>本文我们用公理化的方法，创建了另一个形式系统 <equation>CL_w</equation> ，<br>接着，我们发现 <equation>CL_w</equation> 实际上是与 <equation>\lambda_\beta</equation> 等价的。</p><p>可悲的是，知道 <equation>\lambda</equation> 演算的人很多，<br>但是知道 <equation>CL</equation> （组合子逻辑）的人却很少，这简直是不可思议的。<br>下文中，我们将继续沿着公理化和形式系统的道路向前走，敲开数理逻辑的大门。</p><hr><h2><b>参考</b></h2><p><a href="https://book.douban.com/subject/4323391/">Lambda-Calculus and Combinators，an Introduction</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
