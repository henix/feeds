<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>最清晰的比特币白皮书解析3-工作量证明</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/44050124">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-d77484395746a6d77e841733fb50dcd3_r.jpg" alt=""></div><p><b>4. 工作量证明</b></p><p>先看本节要讲什么。白皮书第一句话就点明了该节的目的。</p><p>To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof- of-work system similar to Adam Back's Hashcash [6], rather than newspaper or Usenet posts. </p><p>为了在点对点的去中心化环境下实现分布式时间戳服务，我们使用类似于Adam在Hashcash中提出的一个工作量证明系统，而不是使用报纸或者新闻组这样的方法。</p><p>所以本节全部围绕着如何具体实现上节的时间戳。由于是在点对点的环境下，所以该时间戳是一个分布式时间戳。本节讨论的就是分布式时间戳实现的方法，是对上节时间戳概念的落实。（为什么要实现时间戳呢？因为要解决双花问题。时间戳为什么能够解决双花问题呢？因为要形成一个唯一的不可更改的交易记录账本）</p><p>注意Hashcash也是一个电子现金系统，是由Adam提出的。中本聪受到该系统的启发，并且在白皮书中引用了该论文。此外，上面说了不使用在上节说的报纸或者新闻组来实现时间戳。那么通过什么方法来实现呢？白皮书上说了，通过一个叫“工作量证明”的方法。什么是工作量证明呢？紧接着白皮书给出了说明。</p><p>The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash. </p><p>工作量证明就是求解一个哈希值（例如通过SHA-256求解哈希值），要求该哈希值的最高位含有若干个0。平均情况下，该工作量与0的个数呈指数级关系，即哈希值中0的个数的增加将会让求解工作量呈指数级增长。而验证该哈希值的正确性可以通过执行哈希函数来进行。</p><p>上面说明了工作量证明的难度，即求解满足要求的哈希值所花费的时间，与哈希值的最高位含有多少个0有直接关系。这样就把工作量证明与时间挂上了钩。那么具体如何实现工作量证明呢？白皮书紧接着说了。</p><p>For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block's hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it. </p><p>为了构建我们的时间戳网络，我们需要实现工作量证明机制，而该机制是通过不断递增一个区块中的随机数，直到发现一个满足要求的区块哈希值。所以工作量证明就是不断的取一个随机数去求解区块的哈希值，没有捷径可言，就是不断的尝试，不断的计算。一旦CPU的算力用于完成了工作量证明，即发现了一个满足要求的哈希值，也就是找到了放到区块中的那个随机数，则如果想改变该区块中的数据的话，必须再做同样的事情，即花费CPU的算力去完成工作量证明。如果该区块后面又有新的区块，则改变该区块中的数据所花费的工作量将包括后面的所有区块，所以工作量大大增加。</p><p>看到这里，是不是想到了时间戳服务那节所说的：如果想篡改某一个区块的时间戳，必须篡改其后的所有时间戳才可以。而这里恰好通过工作量证明机制实现了时间戳服务。至此，你清楚了吗？工作量证明机制是干吗的。</p><p>工作量证明机制还有另外一个特性，紧接着白皮书说到：</p><p>The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added. </p><p>工作量证明机制还解决了谁是大多数的问题。如果决定大多数的方式是基于IP地址的，即一IP地址一票，则该机制将被能够分配大量IP地址的人所破坏。而工作量证明机制的本质则是一CPU一票。大多数人的决定被表达为最长的链，因为最长的链包含了最大的工作量。如果大多数的CPU为诚实的节点控制，那么诚实的链条将以最快的速度延长，并超越其他的竞争链条。如果想要对以往的区块进行修改，攻击者必须完成该区块以及其后所有区块的工作量证明，然后才能赶上和超越诚实节点的工作量。我们将在后面说明，当随后的块不断增加时，一个较慢的攻击者追赶上的概率将呈指数级递减。</p><p>To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they're generated too fast, the difficulty increases. </p><p>随着时间的推移，为了应对硬件速度的日益增长以及网络中各个节点参与的不同利益，工作量证明的难度以平均每小时出块数作为波动平均值。如果每小时的出块数太快，将增加工作量证明的难度。</p><p>文章首发在微信公众号：btc201800</p><p><a href="https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK">http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK</a> (二维码自动识别)</p><p>相应的音频，已发布到喜马拉雅“解读区块链白皮书”上，欢迎收听。</p><p><a href="https://link.zhihu.com/?target=http%3A//m.ximalaya.com/42927243/sound/119777482">http://m.ximalaya.com/42927243/sound/119777482</a>(二维码自动识别)</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
