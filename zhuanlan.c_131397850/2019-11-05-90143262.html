<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Congruence Closure</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/90143262">原文</a></p>
<h2>0. OofOof</h2><p>Lecture note of CSE 507 - Computer-Aided Reasoning for Software.</p><p>新学期很忙，前段时间刷知乎发现自己很久没有水文章了...所以为了证明我还活着，计划在这里水一篇这个学期选的一门讲SAT / SMT Solver的课(CSE 507)的笔记好了（虽然讲这个的Lecture距离现在已经过去好几周了）...Congruence Closure是一个并查集(disjoint set)的一个应用。所以如果你会并查集，这篇文章将十分浅显易懂。</p><p>P.S. 果断选择了CC因为可以在一小时内码完字(光速逃)</p><h2>Quick Intro</h2><p>一个经典的问题：</p><p>公式 <img src="https://www.zhihu.com/equation?tex=f%28f%28f%28x%29%29%29%3Dx+%5Cwedge+f%28f%28f%28f%28f%28x%29%29%29%29%29%3Dx%5Cwedge+f%28x%29%5Cneq+x" alt="f(f(f(x)))=x \wedge f(f(f(f(f(x)))))=x\wedge f(x)\neq x" eeimg="1"/> 是否可满足？</p><p>显然，我们通过 <img src="https://www.zhihu.com/equation?tex=f%28f%28f%28x%29%29%29%3Dx" alt="f(f(f(x)))=x" eeimg="1"/> 可以将 <img src="https://www.zhihu.com/equation?tex=f%28f%28f%28f%28f%28x%29%29%29%29%29%3Dx" alt="f(f(f(f(f(x)))))=x" eeimg="1"/> 转化为 <img src="https://www.zhihu.com/equation?tex=f%28f%28x%29%29%3Dx" alt="f(f(x))=x" eeimg="1"/> ；再将 <img src="https://www.zhihu.com/equation?tex=f%28f%28f%28x%29%29%29%3Dx" alt="f(f(f(x)))=x" eeimg="1"/> 转化为 <img src="https://www.zhihu.com/equation?tex=f%28x%29%3Dx" alt="f(x)=x" eeimg="1"/> ，得出与 <img src="https://www.zhihu.com/equation?tex=f%28x%29%5Cneq+x" alt="f(x)\neq x" eeimg="1"/> 矛盾，于是这个公式是unsat的。</p><p>我们发现，这些式子中只有两个要素：</p><ol><li>Uninterpreted functions</li><li>Equality</li></ol><p>于是我们称这类问题&#34;Theory of Equality with Uninterpreted Functions&#34;, 以下称其为 <img src="https://www.zhihu.com/equation?tex=T_%3D" alt="T_=" eeimg="1"/> .</p><p>那么给定一个 <img src="https://www.zhihu.com/equation?tex=T_%3D" alt="T_=" eeimg="1"/> 的Conjunction formula，我们如何判定它的满足性呢？这就是Congruence Closure要解决的问题。</p><h2>Definitions</h2><ul><li>Theories: Domain of discourse.</li><li>Signature: All Symbols (变量，运算符)</li><li>Axioms: 定义的性质</li></ul><p>对于 <img src="https://www.zhihu.com/equation?tex=T_%3D" alt="T_=" eeimg="1"/> ：</p><p>Signature: <img src="https://www.zhihu.com/equation?tex=%5C%7B%3D%2Ca%2Cb%2Cc...%5C%7D" alt="\{=,a,b,c...\}" eeimg="1"/> 。</p><p>Axioms:</p><ul><li>Reflexivity(自反性): <img src="https://www.zhihu.com/equation?tex=%5Cforall+x.+x+%3D+x" alt="\forall x. x = x" eeimg="1"/> </li><li>Symmetry(对称性): <img src="https://www.zhihu.com/equation?tex=%5Cforall+x%2Cy.%5C+x+%3D+y+%5Cto+y+%3D+x" alt="\forall x,y.\ x = y \to y = x" eeimg="1"/> </li><li>Transitivity(传递性): <img src="https://www.zhihu.com/equation?tex=%5Cforall+x%2Cy%2Cz.%5C+x%3Dy+%5Cwedge+y%3Dz+%5Cto+x+%3D+z" alt="\forall x,y,z.\ x=y \wedge y=z \to x = z" eeimg="1"/> </li><li><i>Congruence </i>: <img src="https://www.zhihu.com/equation?tex=%5Cforall+x%2Cy.%5C+x%3Dy+%5Cto+f%28x%29%3Df%28y%29" alt="\forall x,y.\ x=y \to f(x)=f(y)" eeimg="1"/> </li></ul><p>Side Note: 不知道Congruence在这里翻译成什么比较好，先称它为“全等”吧(</p><p>当然Congruence的性质适用于n-ary的函数：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+x_1+%5Ccdots+x_n%2C+y_1+%5Ccdots+y_n.%5C+%28%5Cbigwedge_%7B1+%5Cleq+i+%5Cleq+n%7D+x_i+%3D+y_i%29+%5Cto+f%28x_1%2C+%5Ccdots+%2Cx_n%29+%3D+f%28y_1%2C+%5Ccdots+%2Cy_n%29" alt="\forall x_1 \cdots x_n, y_1 \cdots y_n.\ (\bigwedge_{1 \leq i \leq n} x_i = y_i) \to f(x_1, \cdots ,x_n) = f(y_1, \cdots ,y_n)" eeimg="1"/> </p><h2>Definitions (Cont.)</h2><p><b>本部分内容参考The Calculus of Computation，作者：Bradley, Manna</b></p><h2>Relations</h2><p>令 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 为集合 <img src="https://www.zhihu.com/equation?tex=S" alt="S" eeimg="1"/> 上的二元关系，且对于两个元素 <img src="https://www.zhihu.com/equation?tex=s_1%2Cs_2%5Cin+S" alt="s_1,s_2\in S" eeimg="1"/> ，我们有 <img src="https://www.zhihu.com/equation?tex=s_1R%5C+s_2" alt="s_1R\ s_2" eeimg="1"/> 和它的否命题 <img src="https://www.zhihu.com/equation?tex=%5Cneg%28s_1R%5C+s_2%29" alt="\neg(s_1R\ s_2)" eeimg="1"/> 。若关系 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 满足Reflexivity, Symmetry和Transitivity，那么我们称 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 为<b>等价关系</b>(Equivalence Relation)。若一个等价关系 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 满足Congruence，那么我们称 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 为<b>全等关系</b>(Congruence Relation)。</p><h2>Classes</h2><p>令 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 为集合 <img src="https://www.zhihu.com/equation?tex=S" alt="S" eeimg="1"/> 上的一个等价关系。对于任意元素 <img src="https://www.zhihu.com/equation?tex=s%5Cin+S" alt="s\in S" eeimg="1"/> ， 定义 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"/> 的等价类 <img src="https://www.zhihu.com/equation?tex=%5Bs%5D_%5Cmathcal%7BE%7D" alt="[s]_\mathcal{E}" eeimg="1"/> 为  <img src="https://www.zhihu.com/equation?tex=%7Bs%5E%5Cprime+%5Cin+S%5C+%7C%5C+s%5C+R%5C+s%5E%5Cprime+%7D" alt="{s^\prime \in S\ |\ s\ R\ s^\prime }" eeimg="1"/> 。若 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 是集合 <img src="https://www.zhihu.com/equation?tex=S" alt="S" eeimg="1"/> 上的全等关系，则我们称这个集合为全等类(记作 <img src="https://www.zhihu.com/equation?tex=%5Bs%5D_%5Cmathcal%7BC%7D" alt="[s]_\mathcal{C}" eeimg="1"/> )。</p><h2>Relation Refinements</h2><p>令 <img src="https://www.zhihu.com/equation?tex=R_1" alt="R_1" eeimg="1"/> , <img src="https://www.zhihu.com/equation?tex=R_2" alt="R_2" eeimg="1"/> 为集合 <img src="https://www.zhihu.com/equation?tex=S" alt="S" eeimg="1"/> 上的二元关系。定义 <img src="https://www.zhihu.com/equation?tex=R_1" alt="R_1" eeimg="1"/> 是 <img src="https://www.zhihu.com/equation?tex=R_2" alt="R_2" eeimg="1"/> 的refinement，记作 <img src="https://www.zhihu.com/equation?tex=R_1+%5Cprec+R_2" alt="R_1 \prec R_2" eeimg="1"/> ，为： <img src="https://www.zhihu.com/equation?tex=%5Cforall+s_1%2Cs_2.%5C+s_1R_1s_2+%5Cto+s_1R_2s_2" alt="\forall s_1,s_2.\ s_1R_1s_2 \to s_1R_2s_2" eeimg="1"/> </p><p>例如： <img src="https://www.zhihu.com/equation?tex=R_1+%3A+%5C%7BaR_1b%5C%7D" alt="R_1 : \{aR_1b\}" eeimg="1"/> , <img src="https://www.zhihu.com/equation?tex=R_2%3A%5C%7BaR_2b%2CbR_2c%5C%7D" alt="R_2:\{aR_2b,bR_2c\}" eeimg="1"/> ； <img src="https://www.zhihu.com/equation?tex=R_1+%5Cprec+R_2" alt="R_1 \prec R_2" eeimg="1"/> </p><p>若将 <img src="https://www.zhihu.com/equation?tex=R_1" alt="R_1" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=R_2" alt="R_2" eeimg="1"/> 看作集合，那么： <img src="https://www.zhihu.com/equation?tex=R_1+%5Cprec+R_2+%5Ciff+R_1+%5Csubseteq+R_2" alt="R_1 \prec R_2 \iff R_1 \subseteq R_2" eeimg="1"/> </p><h2>Closure</h2><p>令 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 为集合 <img src="https://www.zhihu.com/equation?tex=S" alt="S" eeimg="1"/> 上的一个等价关系。定义 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 的等价闭包(Equivalence Closure) <img src="https://www.zhihu.com/equation?tex=R_c" alt="R_c" eeimg="1"/> 为<b>覆盖</b> <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> <b>所描述等价关系的最小二元关系</b>。More formally: <img src="https://www.zhihu.com/equation?tex=R_c" alt="R_c" eeimg="1"/> 满足： </p><ul><li><img src="https://www.zhihu.com/equation?tex=R+%5Cprec+R_c" alt="R \prec R_c" eeimg="1"/> </li><li><img src="https://www.zhihu.com/equation?tex=%5Cforall+R%5E%5Cprime.%5C+R%5Cprec+R%5E%5Cprime+%5Cto+%28R_c+%5Cprec+R%5E%5Cprime+%5Cvee+R_c%5Cequiv+R%5E%5Cprime%29" alt="\forall R^\prime.\ R\prec R^\prime \to (R_c \prec R^\prime \vee R_c\equiv R^\prime)" eeimg="1"/> </li></ul><p>例如： <img src="https://www.zhihu.com/equation?tex=R%3D%5C%7BaRb%5C%7D" alt="R=\{aRb\}" eeimg="1"/> 。那么 <img src="https://www.zhihu.com/equation?tex=R_c%3D%5C%7BaRa%2CbRb%2CaRb%2CbRa%5C%7D" alt="R_c=\{aRa,bRb,aRb,bRa\}" eeimg="1"/> </p><p>若 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 是一个全等关系，那么 <img src="https://www.zhihu.com/equation?tex=R_c" alt="R_c" eeimg="1"/> 为 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 的全等闭包(Congruence Closure)。</p><h2>Congruence Closure</h2><p>CC算法就是利用并查集维护全等类和给定等价关系构造出的全等闭包。算法分为两大步： 1. 通过公式给定的 <img src="https://www.zhihu.com/equation?tex=xRy" alt="xRy" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=%5Cneg%28xRy%29" alt="\neg(xRy)" eeimg="1"/> 构造 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 的等价闭包 2. 通过公式给定的 <img src="https://www.zhihu.com/equation?tex=%5Cneg%28x_iRy_i%29" alt="\neg(x_iRy_i)" eeimg="1"/> 查询公式的可满足性。</p><p>限制：输入的公式 <img src="https://www.zhihu.com/equation?tex=F" alt="F" eeimg="1"/> 是Conjunction of formula in <img src="https://www.zhihu.com/equation?tex=T_%3D" alt="T_=" eeimg="1"/> 。</p><h2>构造全等闭包</h2><p>对于一个公式，我们可以将其表示为一个DAG。例如 <img src="https://www.zhihu.com/equation?tex=f%28f%28x%2Cy%29%2Cy%29" alt="f(f(x,y),y)" eeimg="1"/> 可以表示为：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-30dd454f5bbead485335e91adf7e4b13_b.png" data-caption="" data-size="normal" data-rawwidth="121" data-rawheight="171" class="content_image" width="121"/></noscript><img src="https://pic4.zhimg.com/v2-30dd454f5bbead485335e91adf7e4b13_b.png" data-caption="" data-size="normal" data-rawwidth="121" data-rawheight="171" class="content_image lazy" width="121" data-actualsrc="https://pic4.zhimg.com/v2-30dd454f5bbead485335e91adf7e4b13_b.png"/></figure><p>更直观的表示：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-d335143bb440f02da70d65b6d215693e_b.png" data-caption="" data-size="normal" data-rawwidth="141" data-rawheight="211" class="content_image" width="141"/></noscript><img src="https://pic3.zhimg.com/v2-d335143bb440f02da70d65b6d215693e_b.png" data-caption="" data-size="normal" data-rawwidth="141" data-rawheight="211" class="content_image lazy" width="141" data-actualsrc="https://pic3.zhimg.com/v2-d335143bb440f02da70d65b6d215693e_b.png"/></figure><p>对于一个子公式(subformulae) <img src="https://www.zhihu.com/equation?tex=E_i" alt="E_i" eeimg="1"/> ，我们记录以下信息： </p><ul><li><i>fn </i>: 函数 / 变量名 </li><li><i>ccpar </i>: Common Congruence Parent，其实就是一个全等类中所有公式的最近父结点的集合.</li><li><i>find </i>: Congruence Class Representative，其实就是并查集的根结点</li><li><i>children </i>: 该结点的孩子结点(直接)</li></ul><p>以上图的 <img src="https://www.zhihu.com/equation?tex=f%28f%28x%2Cy%29%2Cy%29" alt="f(f(x,y),y)" eeimg="1"/> 为例 </p><ul><li><i>fn</i> = <img src="https://www.zhihu.com/equation?tex=f" alt="f" eeimg="1"/> </li><li><i>ccpar</i> = <img src="https://www.zhihu.com/equation?tex=%5Cemptyset" alt="\emptyset" eeimg="1"/> </li><li><i>find</i> = <img src="https://www.zhihu.com/equation?tex=f%28f%28x%2Cy%29%2Cy%29" alt="f(f(x,y),y)" eeimg="1"/> </li><li>children = <img src="https://www.zhihu.com/equation?tex=%5Bf%28x%2Cy%29%2C+y%5D" alt="[f(x,y), y]" eeimg="1"/> </li></ul><p>初始情况下，所有结点的<i>find</i>都是它自己；若一个结点不是根结点，那么它的<i>ccpar </i>集合仅包含它的父亲结点(By definition)。</p><h3>Find</h3><p>查询两个公式是否存在于同一个全等类(找到所在全等类的representative)。这个操作和并查集完全一致。</p><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">node</span><span class="p">:</span><span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
    <span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">find</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">find</span>
    <span class="k">return</span> <span class="n">node</span></code></pre></div><h3>Same Closure</h3><p>和并查集一样。pass。</p><div class="highlight"><pre><code class="language-python3"><span class="k">def</span> <span class="nf">same_closure</span><span class="p">(</span><span class="n">f1</span><span class="p">:</span><span class="n">Node</span><span class="p">,</span> <span class="n">f2</span><span class="p">:</span><span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span> <span class="o">==</span> <span class="n">find</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span></code></pre></div><h3>Union</h3><p>将两个全等类合并。这个操作和并查集完全一致。</p><p>Note: 合并之后，由于“被合并”的结点不再是这个全等类的representative，我们需要将它的<i>ccpar</i>设置为空集。</p><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">):</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>
    <span class="n">r1</span><span class="o">.</span><span class="n">find</span> <span class="o">=</span> <span class="n">r2</span>
    <span class="n">r2</span><span class="o">.</span><span class="n">ccpar</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">ccpar</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">ccpar</span><span class="p">)</span>
    <span class="n">r1</span><span class="o">.</span><span class="n">ccpar</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span></code></pre></div><h3>Congruence</h3><p>判断两个公式是否全等。</p><p>两个公式全等，当且仅当 </p><ul><li>两个公式(最外层)函数名(<i>fn</i>)相同</li><li>两个公式所在结点的孩子数量相同</li><li>在公式1的第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 个孩子与公式2的 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 个孩子在同一个全等类</li></ul><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">congurence</span><span class="p">(</span><span class="n">f1</span><span class="p">:</span><span class="n">Node</span><span class="p">,</span> <span class="n">f2</span><span class="p">:</span><span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">f1</span><span class="o">.</span><span class="n">fn</span> <span class="o">==</span> <span class="n">f2</span><span class="o">.</span><span class="n">fn</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">f2</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">same_closure</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="nb">zip</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">f2</span><span class="o">.</span><span class="n">children</span><span class="p">)))</span></code></pre></div><h3>Merge</h3><p>传递全等关系。注意若我们将两个公式所在的全等类合并可能会产生新的全等关系但是我们的 <img src="https://www.zhihu.com/equation?tex=R_c" alt="R_c" eeimg="1"/> 并没有记录。(合并了两个<i>ccpar</i>非空的结点可能导致两个结点的<i>ccpar</i>中不在同一全等类的公式满足全等关系)。所以我们需要将 <img src="https://www.zhihu.com/equation?tex=%28p_1%2C+p_2%29+%5Cin+ccpar_1+%5Ctimes+ccpar_2" alt="(p_1, p_2) \in ccpar_1 \times ccpar_2" eeimg="1"/> 中满足 <img src="https://www.zhihu.com/equation?tex=p_1" alt="p_1" eeimg="1"/> 与 <img src="https://www.zhihu.com/equation?tex=p_2" alt="p_2" eeimg="1"/> 不在同一全等类但 <img src="https://www.zhihu.com/equation?tex=p_1" alt="p_1" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=p_2" alt="p_2" eeimg="1"/> 全等的所有公式对合并(Merge)。</p><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">f1</span><span class="p">:</span><span class="n">Node</span><span class="p">,</span> <span class="n">f2</span><span class="p">:</span><span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r1</span> <span class="o">!=</span> <span class="n">r2</span><span class="p">:</span>
        <span class="n">par1</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">ccpar</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">par2</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">ccpar</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">union</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cartisian</span><span class="p">(</span><span class="n">par1</span><span class="p">,</span> <span class="n">par2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">same_closure</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">congurence</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
                <span class="n">merge</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span></code></pre></div><h2>公式可满足性</h2><p>对于一个 <img src="https://www.zhihu.com/equation?tex=T_%3D" alt="T_=" eeimg="1"/> 的Conjunction Normal Form的公式 <img src="https://www.zhihu.com/equation?tex=F" alt="F" eeimg="1"/> ，我们可以将其分为 <img src="https://www.zhihu.com/equation?tex=F_p+%5Cwedge+F_n" alt="F_p \wedge F_n" eeimg="1"/> 。 <img src="https://www.zhihu.com/equation?tex=F_p" alt="F_p" eeimg="1"/> 中仅存在 <img src="https://www.zhihu.com/equation?tex=x%3Dy" alt="x=y" eeimg="1"/> ， <img src="https://www.zhihu.com/equation?tex=F_n" alt="F_n" eeimg="1"/> 中仅存在 <img src="https://www.zhihu.com/equation?tex=x%5Cneq+y" alt="x\neq y" eeimg="1"/> 。通过CC算法构造 <img src="https://www.zhihu.com/equation?tex=F" alt="F" eeimg="1"/> 的全等类，若 <img src="https://www.zhihu.com/equation?tex=F_n" alt="F_n" eeimg="1"/> 中有 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 个不等关系，查询是否存在一个 <img src="https://www.zhihu.com/equation?tex=i%5Cin+%5B1%2C%5Ccdots%2Ck%5D" alt="i\in [1,\cdots,k]" eeimg="1"/> ，使得 <img src="https://www.zhihu.com/equation?tex=x_i%5Cneq+y_i" alt="x_i\neq y_i" eeimg="1"/> 在 <img src="https://www.zhihu.com/equation?tex=F_n" alt="F_n" eeimg="1"/> 中，且 <img src="https://www.zhihu.com/equation?tex=x_i" alt="x_i" eeimg="1"/> 与 <img src="https://www.zhihu.com/equation?tex=y_i" alt="y_i" eeimg="1"/> 在同一个全等类(即<code>same_closure</code>返回True)。若 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 存在，则 <img src="https://www.zhihu.com/equation?tex=F" alt="F" eeimg="1"/> 不可满足，否则 <img src="https://www.zhihu.com/equation?tex=F" alt="F" eeimg="1"/> 可满足。</p><div class="highlight"><pre><code class="language-python3"><span class="k">def</span> <span class="nf">formulae_to_map</span><span class="p">(</span><span class="n">formulae</span><span class="p">):</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">formulae</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">each</span>
        <span class="n">clause_to_node</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
        <span class="n">clause_to_node</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">formulae</span><span class="p">):</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">formulae_to_map</span><span class="p">(</span><span class="n">formulae</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">formulae</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">each</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="n">rel</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">each</span>
        <span class="k">if</span> <span class="n">rel</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span>
            <span class="n">merge</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UNSAT&#39;</span> <span class="k">if</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">same_closure</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]]),</span> 
                              <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="n">formulae</span><span class="p">)),</span> <span class="kc">True</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;SAT&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span></code></pre></div><h2>Sound &amp; Complete (Informal)</h2><p>这里只是General Idea...</p><h3>Soundness</h3><p><img src="https://www.zhihu.com/equation?tex=%5Bx%5D_%5Cmathcal%7BC%7D%5Cequiv+%5By%5D_%5Cmathcal%7BC%7D+%5Ciff+x+%5Cequiv+y" alt="[x]_\mathcal{C}\equiv [y]_\mathcal{C} \iff x \equiv y" eeimg="1"/> </p><h3>Completeness</h3><p>一个公式的子公式(subformulae)是有限个的。CC的操作(<i>Merge</i>)只会让全等类的数量减少。</p><h2>Corollary</h2><ul><li>仅包含相等关系的公式一定是可满足的。</li><li><img src="https://www.zhihu.com/equation?tex=T_%3D" alt="T_=" eeimg="1"/> is convex (有时间再写这个的Note)</li></ul><h2>Epi</h2><p>这次写得比较仓促质量不高...如果有错误请指正 thx。</p><p>推荐阅读：The Calculus of Computation</p><h2>Appendix - Code</h2><p>屈服于简单暴力....</p><div class="highlight"><pre><code class="language-python3"><span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ccpar</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">find</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s1">&#39;fn: </span><span class="si">{self.fn}</span><span class="s1">; childern: </span><span class="si">{self.children}</span><span class="s1">&#39;</span>

<span class="k">def</span> <span class="nf">clause_to_node</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span><span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">clause</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">return</span> <span class="n">graph</span><span class="p">[</span><span class="n">clause</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">clause</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">clause_to_node</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">graph</span><span class="p">),</span> <span class="n">args</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)):</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ccpar</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">clause</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">clause</span><span class="p">]</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">graph</span><span class="p">[</span><span class="n">clause</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">node</span><span class="p">:</span><span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
    <span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">find</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">find</span>
    <span class="k">return</span> <span class="n">node</span>

<span class="k">def</span> <span class="nf">same_closure</span><span class="p">(</span><span class="n">f1</span><span class="p">:</span><span class="n">Node</span><span class="p">,</span> <span class="n">f2</span><span class="p">:</span><span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span> <span class="o">==</span> <span class="n">find</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">):</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>
    <span class="n">r1</span><span class="o">.</span><span class="n">find</span> <span class="o">=</span> <span class="n">r2</span>
    <span class="n">r2</span><span class="o">.</span><span class="n">ccpar</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">ccpar</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">ccpar</span><span class="p">)</span>
    <span class="n">r1</span><span class="o">.</span><span class="n">ccpar</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">congurence</span><span class="p">(</span><span class="n">f1</span><span class="p">:</span><span class="n">Node</span><span class="p">,</span> <span class="n">f2</span><span class="p">:</span><span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">f1</span><span class="o">.</span><span class="n">fn</span> <span class="o">==</span> <span class="n">f2</span><span class="o">.</span><span class="n">fn</span> \
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">f2</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">same_closure</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="nb">zip</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">f2</span><span class="o">.</span><span class="n">children</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">cartisian</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span><span class="nb">set</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span><span class="nb">set</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">s2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">f1</span><span class="p">:</span><span class="n">Node</span><span class="p">,</span> <span class="n">f2</span><span class="p">:</span><span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r1</span> <span class="o">!=</span> <span class="n">r2</span><span class="p">:</span>
        <span class="n">par1</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">ccpar</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">par2</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">ccpar</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">union</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cartisian</span><span class="p">(</span><span class="n">par1</span><span class="p">,</span> <span class="n">par2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">same_closure</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">congurence</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
                <span class="n">merge</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">formulae_to_map</span><span class="p">(</span><span class="n">formulae</span><span class="p">):</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">formulae</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">each</span>
        <span class="n">clause_to_node</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
        <span class="n">clause_to_node</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">formulae</span><span class="p">):</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">formulae_to_map</span><span class="p">(</span><span class="n">formulae</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">formulae</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">each</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="n">rel</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">each</span>
        <span class="k">if</span> <span class="n">rel</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span>
            <span class="n">merge</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UNSAT&#39;</span> <span class="k">if</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">same_closure</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]]),</span> 
                              <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="n">formulae</span><span class="p">)),</span> <span class="kc">True</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;SAT&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span>


<span class="n">F0</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)]</span>

<span class="n">F1</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span> <span class="p">,(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))),</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))))),</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="s1">&#39;a&#39;</span><span class="p">)]</span>

<span class="n">F2</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span>  <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">))),</span> 
      <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span>  <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">))),</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span> 
      <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span>  <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span> 
      <span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="s1">&#39;x&#39;</span><span class="p">)]</span>

<span class="n">F3</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">))),</span>
      <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">))),</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span>
      <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span>
      <span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">,(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)),</span> <span class="s1">&#39;x&#39;</span><span class="p">)]</span>

<span class="n">F4</span> <span class="o">=</span> <span class="p">[</span>  <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> 
        <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))),</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> 
        <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="s1">&#39;a&#39;</span><span class="p">)]</span></code></pre></div><p></p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
