<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>200行代码编写自己的区块链－2</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/47289448">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-efd514c0c42c2fbd0a7de77a9427c205_r.jpg" alt=""></div><p>这篇文章向您展示了如何编写自己的区块链，并完成哈希和每个新块的验证。但这一切都在一个单独的终端（节点）中运行。我们如何让另一个节点连接到我们的main中并让它们贡献新的块，我们如何将更新的区块链广播到所有其他节点？</p><p>我们马上回告诉你</p><p>工作流程</p><img src="https://pic2.zhimg.com/v2-4ddd49d6a04705b3350ebd956c2bdd7c_r.jpg" data-caption="" data-size="normal" data-rawwidth="1730" data-rawheight="1059" data-watermark="watermark" data-original-src="v2-4ddd49d6a04705b3350ebd956c2bdd7c" data-watermark-src="v2-e6fa186fb2fba5f6218d29809ec08d50" data-private-watermark-src=""><p><br></p><p>第一个终端创建一个创世建块和一个新节点可以连接的TCP服务器</p><p>第一步</p><p>打开其它终端，并与第一个终端建立TCP连接</p><p>新的终端给第一个终端写入一个块</p><p>第二步</p><p>第一个终端验证这个块</p><p>第一个终端将新的区块链广播给其它节点</p><p>第三步</p><p>所有的终端现在都又同步的区块链</p><p>在本教程之后，请自行尝试：让每个新终端充当具有不同TCP端口的“第一个”终端，并让其他终端连接到它以获得真正的网络！</p><p>你将可以做到</p><p>运行一个提供了创世区块的终端</p><p>根据需要启动多个附加终端，并让它们向第一个终端写入块</p><p>让第一终端广播更新的块给其它终端</p><p>你不能做到的</p><p>与上一篇文章一样，本教程的目的是让节点的基本网络正常工作，这样您就可以决定区块链之旅的位置。您将无法将其他网络中的计算机写入您的第一个终端，但这可以通过将您的二进制文件放入云端来实现。此外，区块链广播将被模拟到每个节点。别担心，我们很快就会解释所有这些。</p><p>让我们开始编码吧！</p><p>其中一些将是对最后一篇文章的回顾。我们将使用一些相同的块生成，哈希和验证函数。但我们不会使用任何的HTTP功能，因为我们将在控制台中查看结果，我们将使用TCP进行网络连接。</p><p>TCP和HTTP之间有什么不同</p><p>我们在这并不会详细介绍，但您需要知道的是TCP是一种传输数据的基本协议。HTTP建立在TCP之上，以在Web和浏览器中利用此数据传输。当您查看网站时，您正在使用HTTP，它受基础数据传输协议支持，我们称之为TCP。</p><p>在本教程中，我们将使用TCP，因为我们不需要在浏览器中查看任何内容。Go有一个很好的net包，它提供了我们需要的所有TCP的连接函数。</p><p>设置、导入和回顾</p><p>其中一些将是第1部分的评论。对于区块链生成和验证，我们将使用上一篇文章中的相同函数。在我们进行回顾时请耐心等待。别担心，我们很快就会看到新的东西！</p><p>设置</p><p>在根目录中创建一个.env文件并添加一行：</p><p>ADDR=9000</p><p>我们将要使用的TCP端口号（在本例中为9000）存储在一个名为ADDR的环境变量中。</p><p>如果你还没有做过，就去获取下列软件包：</p><p>go get github.com/davecgh/go-spew/spew 将我们的区块链打印到控制台</p><p>go get github.com/joho/godotenv在我们的.env文件中加载变量 </p><p>创建一个空的main.go文件。我们将把所有代码放在这里。</p><p>导入</p><p>让我们做我们的标准程序包声明并写入我们需要的输入。</p><p>package main</p><p>import (</p><p>"bufio"</p><p>"crypto/sha256"</p><p>"encoding/hex"</p><p>"encoding/json"</p><p>"io"</p><p>"log"</p><p>"net"</p><p>"os"</p><p>"strconv"</p><p>"time"</p><p>"github.com/davecgh/go-spew/spew"</p><p>"github.com/joho/godotenv"</p><p>)</p><p><b><a href="https://gist.github.com/nosequeldeebee/72395bcc58175a7beab520b005cc6879/raw/a73625f1d84c8cc372d888c0fa66c4835f92cc78/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/72395bcc58175a7beab520b005cc6879#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>以下代码片段在第1部分中有更详细的解释。如果您需要复习，请参考它。我们将快速通过这段。</p><p>让我们创建我们的块结构并声明区块链是一种块的累积。</p><p>// Block represents each 'item' in the blockchain</p><p>type Block struct {</p><p>Index int</p><p>Timestamp string</p><p>BPM int</p><p>Hash string</p><p>PrevHash string</p><p>}</p><p>// Blockchain is a series of validated Blocks</p><p>var Blockchain []Block</p><p><b><a href="https://gist.github.com/nosequeldeebee/669357dabf97ea74d5bed574fd139683/raw/22c048323c892779b7b9f64522eb5aa7c2b91ceb/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/669357dabf97ea74d5bed574fd139683#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>现在创建我们在生成新块时需要的哈希函数。</p><p>// SHA256 hashing</p><p>func calculateHash(block Block) string {</p><p>record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash</p><p>h := sha256.New()</p><p>h.Write([]byte(record))</p><p>hashed := h.Sum(nil)</p><p>return hex.EncodeToString(hashed)</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/012ac62ee08fafb86c14b1ed9ee7648b/raw/d350ea711fbe6c5fdb7aa1f6a67c6bc796bb8f05/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/012ac62ee08fafb86c14b1ed9ee7648b#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>我们的块生成函数：</p><p>// create a new block using previous block's hash</p><p>func generateBlock(oldBlock Block, BPM int) (Block, error) {</p><p>var newBlock Block</p><p>t := time.Now()</p><p>newBlock.Index = oldBlock.Index + 1</p><p>newBlock.Timestamp = t.String()</p><p>newBlock.BPM = BPM</p><p>newBlock.PrevHash = oldBlock.Hash</p><p>newBlock.Hash = calculateHash(newBlock)</p><p>return newBlock, nil</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/6b5835fb9872b4fb832aa00243afba07/raw/aaa3ed0f2fc858ef9c87e9c7775211bc917dec89/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/6b5835fb9872b4fb832aa00243afba07#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>通过检查区块的PrevHash值和前一个区块的Hsah值来确保我们的区块是有效的</p><p>// make sure block is valid by checking index, and comparing the hash of   the previous block</p><p>func isBlockValid(newBlock, oldBlock Block) bool {</p><p>if oldBlock.Index+1 !=   newBlock.Index {</p><p>return false</p><p>}</p><p>if oldBlock.Hash !=   newBlock.PrevHash {</p><p>return false</p><p>}</p><p>if calculateHash(newBlock) != newBlock.Hash   {</p><p>return false</p><p>}</p><p>return true</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/2fadb1ccb5da8307df9bd614bfb9524b/raw/827a647b8471efaedcaae84e6575e066368a6f9f/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/2fadb1ccb5da8307df9bd614bfb9524b#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>现在我们确保将最长的链作为真正的区块链：</p><p>/ make sure the chain we're checking is longer than the current blockchain</p><p>func replaceChain(newBlocks []Block) {</p><p>if len(newBlocks) &gt; len(Blockchain)   {</p><p>Blockchain = newBlocks</p><p>}</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/3a9b9a2cd3fa225f18ed710e34d2f1ad/raw/405ebdd1e431a1922d98927f92fdc522ff59ffb3/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/3a9b9a2cd3fa225f18ed710e34d2f1ad#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>太好了！我们基本上已经获得了需要的的所有与区块链相关的函数，并且第1部分中的所有HTTP相关内容都被删除了。我们现在可以进入网络。</p><p>网络通信</p><p>最后！我么已经准备的差不多了。让我们建立一个网络，它可以传递新的块，将它们整合到我们的区块链中，并将新的区块链广播回网络。</p><p>让我们从我们的main函数开始，因为这是一个很好的概念，可以帮助我们理解整体流程。</p><p>在我们这样做之前，让我们在我们的其他结构声明下声明一个名为bcServer（区块链服务器的简称）的全局变量，这是一个接收传入块的channel。</p><p>// bcServer handles incoming concurrent Blocks</p><p>var bcServer chan []Block</p><p><b><a href="https://gist.github.com/nosequeldeebee/d64fafebd1b45e57587ce1a9d73ffd65/raw/0b6934b99a97e509f2c03d9d0a3ffd6a9cce7f38/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/d64fafebd1b45e57587ce1a9d73ffd65#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>旁注：channel是Go最受欢迎的功能之一，可以优雅地简化数据读/写，最常用于防止数据竞争。它们在并发使用时变得特别强大，因为多个Goroutine可以写入同一个channel。传统上使用Java和其他类C语言，您必须通过互斥体打开和关闭传入数据的“门”。Go中的channel使这更容易，尽管Go中的某些位置仍然存在互斥体。学习更多关于channel的知识可以点这里。</p><p>现在让我们声明我们的main函数并从我们位于根目录中的.env文件中加载环境变量 。请记住，唯一的环境变量就是ADDR，它的TCP端口号9000，我们将很快使用它。另外，让我们在main函数中实例化我们的bcServer。</p><p>func main() {</p><p>err := godotenv.Load()</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>bcServer = make(chan []Block)</p><p>// create genesis block</p><p>t := time.Now()</p><p>genesisBlock := Block{0, t.String(), 0, "", ""}</p><p>spew.Dump(genesisBlock)</p><p>Blockchain = append(Blockchain, genesisBlock)</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/5dd05d1ca28778ae46297048bb8554d2/raw/cea2768c0a198b146c595282fa605baf79b0d499/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/5dd05d1ca28778ae46297048bb8554d2#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>现在我们需要编写我们的TCP服务器。请记住，您可以将TCP服务器视为与HTTP服务器类似，但没有浏览器组件。所有数据传输都将通过我们的终端在控制台中完成。我们将处理与TCP端口的多个连接。将这些添加到main函数的最后一行下方。</p><p>// start TCP and serve TCP server</p><p>server, err := net.Listen("tcp", ":"+os.Getenv("ADDR"))</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>defer server.Close()</p><p><b><a href="https://gist.github.com/nosequeldeebee/6a1f412a6fe80dc15b82587862876370/raw/c1f742d4a3489f3127a8f4c6c15d85def9c76c2d/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/6a1f412a6fe80dc15b82587862876370#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>这将在端口9000处激活我们的TCP服务器。重要的是defer server.Close()，当我们不再需要它时，它会把连接快速关闭。在此了解更多defer 信息。</p><p>现在我们需要在每次收到连接请求时创建一个新连接，我们需要提供它。在最后一行下面添加这个。</p><p>for {</p><p>conn, err := server.Accept()</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>go handleConn(conn)</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/40a8c240b5f941369f2a8cfb3e11a2bd/raw/63b0e1ed92306e852cdd5c9d014bda7838a9ab50/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/40a8c240b5f941369f2a8cfb3e11a2bd#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>我们只是在一个无限循环中接受新的连接。我们希望通过GoRoutine中的go handleConn(conn)单独处理程序同时处理每个连接，因此我们不会阻塞我们的for循环。这就是我们如何同时提供多个连接。</p><p>敏锐的读者会跳起来说，“嘿等等！我们没有handleConn函数！“ 你说的对。但是，让我们缓一下。你做的很棒，我们刚写完了整个主函数。它看起来像这样：</p><p>func main() {</p><p>err := godotenv.Load()</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>bcServer = make(chan []Block)</p><p>// create genesis block</p><p>t := time.Now()</p><p>genesisBlock := Block{0, t.String(), 0, "", ""}</p><p>spew.Dump(genesisBlock)</p><p>Blockchain = append(Blockchain, genesisBlock)</p><p>// start TCP and serve TCP server</p><p>server, err := net.Listen("tcp", ":"+os.Getenv("ADDR"))</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>defer server.Close()</p><p>for {</p><p>conn, err := server.Accept()</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>go handleConn(conn)</p><p>}</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/b50624054da55d036b150bac88242013/raw/690f8c5acf388a7917cf6ea36d5d17421184e177/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/b50624054da55d036b150bac88242013#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>我们现在写下这个handleConn函数吧。它只需要一个参数，一个打包好的net.Conn接口。Go中的接口是让人惊奇的，在我们看来，这就是Go与其他所有基于C语言的区别。并发和GoRoutine得到了所有的宣传，但接口隐含满足的事实是它们才是这个语言最强大的功能。如果您尚未在Go中使用接口，请尽快熟悉它们。接口是您成为10x Go开发人员的下一步！</p><p>放入函数的框架，并使用干净的defer语句将其启动，以便在完成后关闭每个连接。</p><p>func handleConn(conn net.Conn) {</p><p>defer conn.Close()</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/97f59bb622dd70294fef5c90c285ea61/raw/97e5ab845ef9f0547c1a32f199b6de4f1643eeb6/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/97f59bb622dd70294fef5c90c285ea61#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>现在我们需要允许用户端添加新块以便我们整合到区块链中。我们将使用第1部分中相同的脉冲速率。记下你每分钟的脉搏速率并将这个数字保留在脑中。这将是我们的BPM（每分钟心脏跳动数）。</p><p>要实现上述目标，我们需要：</p><p>提示用户输入他们的BPM</p><p>扫描来自stdin的用户输入</p><p>使用之前创建的generateBlock，isBlockValid和replaceChain函数，用这个数据创造一个新的区块</p><p>将新的区块链放在我们创建的channel中，以便向网络广播</p><p>允许用户输入新的BPM</p><p>以下是按照上述确切顺序执行此操作的代码</p><p>io.WriteString(conn, "Enter   a new BPM:")</p><p>scanner := bufio.NewScanner(conn)</p><p>// take in BPM from stdin and add it to blockchain after conducting   necessary validation</p><p>go func() {</p><p>for scanner.Scan() {</p><p>bpm, err := strconv.Atoi(scanner.Text())</p><p>if err != nil {</p><p>log.Printf("%v not a number: %v", scanner.Text(), err)</p><p>continue</p><p>}</p><p>newBlock, err := generateBlock(Blockchain[len(Blockchain)-1], bpm)</p><p>if err != nil {</p><p>log.Println(err)</p><p>continue</p><p>}</p><p>if isBlockValid(newBlock,   Blockchain[len(Blockchain)-1]) {</p><p>newBlockchain := append(Blockchain, newBlock)</p><p>replaceChain(newBlockchain)</p><p>}</p><p>bcServer &lt;- Blockchain</p><p>io.WriteString(conn, "\nEnter   a new BPM:")</p><p>}</p><p>}()</p><p><b><a href="https://gist.github.com/nosequeldeebee/54d871590137d5ed12edd2b8b755e1eb/raw/2ff4bbeef97b12c47a590e26b8fb00aed6e522b9/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/54d871590137d5ed12edd2b8b755e1eb#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>我们创建了一个新的scanner，该for scanner.Scan()循环隐藏在自己的Go routine中，因此它可以从其他连接处并行或单独运行。我们对BPM进行快速字符串转换（它总是一个整数，所以我们检查一下）。我们做了我们的标准块生成和验证检查，并使用新块创建新的区块链。</p><p>bcServer &lt;- Blockchain语句只是意味着我们将新的区块链扔进我们创建的channel。然后我们提示用户输入新的BPM以创建下一个块。</p><p>广播</p><p>我们需要将新的区块链广播到我们的TCP服务器所服务的所有连接。由于我们在一台计算机上对其进行编码，因此我们将模拟数据如何传输到所有客户端。在最后一行代码下的相同的handleConn函数中，我们需要：</p><p>将我们的新区块链转换为JSON，以便我们可以很好地阅读它</p><p>将新的区块链写入我们每个连接的控制台</p><p>设置一个定时器来定期执行此操作，这样我们就不会被区块链数据所淹没。这也是您在实时区块链网络中看到的，每隔X分钟就会广播新的区块链。我们将使用30秒</p><p>将主要区块链打印到第一个终端，这样我们就可以看到正在发生的事情并确保不同节点添加的块确实被集成到主区块链中</p><p>下面的就是按照这个准确顺序的编码：</p><p>// simulate receiving broadcast</p><p>go func() {</p><p>for {</p><p>time.Sleep(30 * time.Second)</p><p>output, err := json.Marshal(Blockchain)</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>io.WriteString(conn, string(output))</p><p>}</p><p>}()</p><p>for _ = range bcServer {</p><p>spew.Dump(Blockchain)</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/a25e740219c2329a8c3f2da65e797357/raw/62e0673284fed85375a14a30e06849e8e8cf97c1/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/a25e740219c2329a8c3f2da65e797357#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>太好了！我们的handleConn函数也已经完成。事实上，整个计划已经完成，我们已将其保持在200行以下。这一点都不错，是吗？</p><p>在这里查看完成的代码！</p><p>有意思的地方</p><p>我们来试试吧！让我们通过转到我们的目录启动我们的应用程序go run main.go</p><img src="https://pic4.zhimg.com/v2-ae0cf47fb550dc76b384d07e7273643f_r.jpg" data-caption="" data-size="normal" data-rawwidth="1729" data-rawheight="376" data-watermark="watermark" data-original-src="v2-ae0cf47fb550dc76b384d07e7273643f" data-watermark-src="v2-3f3b745bdc431e763dfcdd5550bec84a" data-private-watermark-src=""><p><br></p><p>正如所料，我们看到了我们的创世块。同时发生的事情是我们在端口9000启动了一个可以接入多个连接的TCP服务器。所以，让我们这样做。</p><p>打开一个新的终端窗口并用nc localhost 9000连接到我们的TCP服务器 。我们将使用不同的颜色终端来明确这些不同的客户端。通过几个终端会话执行此操作几次以激活多个客户端。</p><p> 现在输入BPM到任意客户端。真棒！我们看到新的块添加到第一个终端！网络在运行！</p><img src="https://pic4.zhimg.com/v2-986aa0345d058db73653afc5fe281394_r.jpg" data-caption="" data-size="normal" data-rawwidth="1728" data-rawheight="651" data-watermark="watermark" data-original-src="v2-986aa0345d058db73653afc5fe281394" data-watermark-src="v2-ff65e2af73457f5f77526cca4b5009bc" data-private-watermark-src=""><p><br></p><p>从这得到的结果真的很酷。等30秒，转到其他客户端，您将看到新的区块链广播给所有客户，即使这些客户从未输入过BPM！</p><p>下一步</p><p>恭喜！您不仅可以从上一个教程创建自己的区块链，现在还可以为其添加网络功能。你可以从下面的建议里再学习：</p><p>要在本地环境中运行更大的网络，请创建多个目录，这些目录包含每个具有不同TCP端口的应用程序副本。对于每个终端会话，请提供TCP端口并连接到另一个端口，以便您可以接收和发送数据。</p><p>连接从多个端口流式传输的数据。这是另一个教程的主题，但很容易完成。</p><p>这都是区块链网络。它需要接收输入数据并在外部广播数据。在单个终端会话中进行这两种操作都是一种有效的挖矿设置。</p><p>如果您想与朋友一起尝试，请使用您最喜欢的托管服务提供商在云端设置服务器。让你的朋友连接到它并发送数据。此处还有一些额外的安全注意事项。如果有需求，我们也会为此编写一个教程。</p><p>您正在密切了解区块链的多个方面。从这里开始，我们建议您阅读共识机制的算法，如工作量证明或权益证明。</p><p><br></p><p><br></p><p>===============================================================<br><b>文章首发在微信公众号：btc201800</b><br><b><a href="https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK">http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK</a></b> <b>(二维码自动识别)</b><br><b>音频发布在喜马拉雅上“区块链杂谈 (第2季)“</b></p><p><b>宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。</b></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
