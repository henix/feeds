<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TiDB 源码阅读系列文章（二十二）Hash Aggregation</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/52969666">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-2e665a8d2aeb4f9ccf89d305b5638fe8_b.jpg" alt=""></div><p>作者：徐怀宇</p><h2><b>聚合算法执行原理</b></h2><p>在 SQL 中，聚合操作对一组值执行计算，并返回单个值。TiDB 实现了 2 种聚合算法：Hash Aggregation 和 Stream Aggregation。</p><p>我们首先以 <code>AVG</code> 函数为例（案例参考 <a href="http://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/1471147/how-do-aggregates-group-by-work-on-sql-server/1471167%231471167" class=" wrap external" target="_blank" rel="nofollow noreferrer">Stack Overflow</a>），简述这两种算法的执行原理。</p><p>假设表 <code>t</code> 如下：</p><figure><noscript><img src="https://pic1.zhimg.com/v2-8db01296a4397381f572bfd5a329c488_b.jpg" data-caption="" data-size="normal" data-rawwidth="1232" data-rawheight="504" class="origin_image zh-lightbox-thumb" width="1232" data-original="https://pic1.zhimg.com/v2-8db01296a4397381f572bfd5a329c488_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-8db01296a4397381f572bfd5a329c488_b.jpg" data-caption="" data-size="normal" data-rawwidth="1232" data-rawheight="504" class="origin_image zh-lightbox-thumb lazy" width="1232" data-original="https://pic1.zhimg.com/v2-8db01296a4397381f572bfd5a329c488_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-8db01296a4397381f572bfd5a329c488_b.jpg"></figure><p>SQL:<code>select avg(b) from t group by a</code>, 要求将表<code>t</code>的数据按照<code>a</code>的值分组，对每一组的<code>b</code>值计算平均值。不管 Hash 还是 Stream 聚合，在<code>AVG</code>函数的计算过程中，我们都需要维护 2 个中间结果变量<code>sum</code>和<code>count</code>。Hash 和 Stream 聚合算法的执行原理如下。</p><ul><li><b>Hash Aggregate 的执行原理</b></li></ul><p>在 Hash Aggregate 的计算过程中，我们需要维护一个 Hash 表，Hash 表的键为聚合计算的 <code>Group-By</code> 列，值为聚合函数的中间结果 <code>sum</code> 和 <code>count</code>。在本例中，键为 <code>列 a</code> 的值，值为 <code>sum(b)</code> 和 <code>count(b)</code>。</p><p>计算过程中，只需要根据每行输入数据计算出键，在 Hash 表中找到对应值进行更新即可。对本例的执行过程模拟如下。</p><figure><noscript><img src="https://pic1.zhimg.com/v2-a811115327639d12cea5c777a01121dc_b.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="508" class="origin_image zh-lightbox-thumb" width="1240" data-original="https://pic1.zhimg.com/v2-a811115327639d12cea5c777a01121dc_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-a811115327639d12cea5c777a01121dc_b.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="508" class="origin_image zh-lightbox-thumb lazy" width="1240" data-original="https://pic1.zhimg.com/v2-a811115327639d12cea5c777a01121dc_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-a811115327639d12cea5c777a01121dc_b.jpg"></figure><p>输入数据输入完后，扫描 Hash 表并计算，便可以得到最终结果：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-99647b66dfb1d3e931cb250e08325d72_b.jpg" data-caption="" data-size="normal" data-rawwidth="1238" data-rawheight="230" class="origin_image zh-lightbox-thumb" width="1238" data-original="https://pic3.zhimg.com/v2-99647b66dfb1d3e931cb250e08325d72_r.jpg"></noscript><img src="https://pic3.zhimg.com/v2-99647b66dfb1d3e931cb250e08325d72_b.jpg" data-caption="" data-size="normal" data-rawwidth="1238" data-rawheight="230" class="origin_image zh-lightbox-thumb lazy" width="1238" data-original="https://pic3.zhimg.com/v2-99647b66dfb1d3e931cb250e08325d72_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-99647b66dfb1d3e931cb250e08325d72_b.jpg"></figure><ul><li><b>Stream Aggregation 的执行原理</b></li></ul><p>Stream Aggregate 的计算需要保证输入数据<b>按照</b> <b><code>Group-By</code></b> <b>列有序</b>。在计算过程中，每当读到一个新的 Group 的值或所有数据输入完成时，便对前一个 Group 的聚合最终结果进行计算。</p><p>对于本例，我们首先对输入数据按照 <code>a</code> 列进行排序。排序后，本例执行过程模拟如下。</p><figure><noscript><img src="https://pic3.zhimg.com/v2-ce83f2fe1e9f559028fd5c0552a46552_b.jpg" data-caption="" data-size="normal" data-rawwidth="1592" data-rawheight="658" class="origin_image zh-lightbox-thumb" width="1592" data-original="https://pic3.zhimg.com/v2-ce83f2fe1e9f559028fd5c0552a46552_r.jpg"></noscript><img src="https://pic3.zhimg.com/v2-ce83f2fe1e9f559028fd5c0552a46552_b.jpg" data-caption="" data-size="normal" data-rawwidth="1592" data-rawheight="658" class="origin_image zh-lightbox-thumb lazy" width="1592" data-original="https://pic3.zhimg.com/v2-ce83f2fe1e9f559028fd5c0552a46552_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-ce83f2fe1e9f559028fd5c0552a46552_b.jpg"></figure><p>因为 Stream Aggregate 的输入数据需要保证同一个 Group 的数据连续输入，所以 Stream Aggregate 处理完一个 Group 的数据后可以立刻向上返回结果，不用像 Hash Aggregate 一样需要处理完所有数据后才能正确的对外返回结果。当上层算子只需要计算部分结果时，比如 Limit，当获取到需要的行数后，可以提前中断 Stream Aggregate 后续的无用计算。</p><p>当 <code>Group-By</code> 列上存在索引时，由索引读入数据可以保证输入数据按照 <code>Group-By</code> 列有序，此时同一个 Group 的数据连续输入 Stream Aggregate 算子，可以避免额外的排序操作。</p><h2><b>TiDB 聚合函数的计算模式</b></h2><p>由于分布式计算的需要，TiDB 对于聚合函数的计算阶段进行划分，相应定义了 5 种计算模式：CompleteMode，FinalMode，Partial1Mode，Partial2Mode，DedupMode。不同的计算模式下，所处理的输入值和输出值会有所差异，如下表所示：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-e0330d54b46bfda4ffe89a871977b0b6_b.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="826" class="origin_image zh-lightbox-thumb" width="1240" data-original="https://pic3.zhimg.com/v2-e0330d54b46bfda4ffe89a871977b0b6_r.jpg"></noscript><img src="https://pic3.zhimg.com/v2-e0330d54b46bfda4ffe89a871977b0b6_b.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="826" class="origin_image zh-lightbox-thumb lazy" width="1240" data-original="https://pic3.zhimg.com/v2-e0330d54b46bfda4ffe89a871977b0b6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-e0330d54b46bfda4ffe89a871977b0b6_b.jpg"></figure><p>以上文提到的 <code>select avg(b) from t group by a</code> 为例，通过对计算阶段进行划分，可以有多种不同的计算模式的组合，如：</p><ul><li>CompleteMode</li></ul><p>此时 <code>AVG</code> 函数的整个计算过程只有一个阶段，如图所示：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-18d7246583684dfce6c22c1769a8f4e7_b.jpg" data-caption="" data-size="normal" data-rawwidth="470" data-rawheight="493" class="origin_image zh-lightbox-thumb" width="470" data-original="https://pic4.zhimg.com/v2-18d7246583684dfce6c22c1769a8f4e7_r.jpg"></noscript><img src="https://pic4.zhimg.com/v2-18d7246583684dfce6c22c1769a8f4e7_b.jpg" data-caption="" data-size="normal" data-rawwidth="470" data-rawheight="493" class="origin_image zh-lightbox-thumb lazy" width="470" data-original="https://pic4.zhimg.com/v2-18d7246583684dfce6c22c1769a8f4e7_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-18d7246583684dfce6c22c1769a8f4e7_b.jpg"></figure><ul><li>Partial1Mode –&gt; FinalMode</li></ul><p>此时我们将 <code>AVG</code> 函数的计算过程拆成两个阶段进行，如图所示：<br></p><figure><noscript><img src="https://pic3.zhimg.com/v2-638ea8080df76ae1255c6e340518b5ce_b.jpg" data-caption="" data-size="normal" data-rawwidth="556" data-rawheight="637" class="origin_image zh-lightbox-thumb" width="556" data-original="https://pic3.zhimg.com/v2-638ea8080df76ae1255c6e340518b5ce_r.jpg"></noscript><img src="https://pic3.zhimg.com/v2-638ea8080df76ae1255c6e340518b5ce_b.jpg" data-caption="" data-size="normal" data-rawwidth="556" data-rawheight="637" class="origin_image zh-lightbox-thumb lazy" width="556" data-original="https://pic3.zhimg.com/v2-638ea8080df76ae1255c6e340518b5ce_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-638ea8080df76ae1255c6e340518b5ce_b.jpg"></figure><p>除了上面的两个例子外，还可能有如下的几种计算方式：</p><ol><li>聚合被下推到 TiKV 上进行计算（Partial1Mode），并返回经过预聚合的中间结果。为了充分利用 TiDB server 所在机器的 CPU 和内存资源，加快 TiDB 层的聚合计算，TiDB 层的聚合函数计算可以这样进行：Partial2Mode –&gt; FinalMode。</li><li>当聚合函数需要对参数进行去重，也就是包含 <code>DISTINCT</code> 属性，且聚合算子因为一些原因不能下推到 TiKV 时，TiDB 层的聚合函数计算可以这样进行：DedupMode –&gt; Partial1Mode –&gt; FinalMode。</li></ol><p>聚合函数分为几个阶段执行， 每个阶段对应的模式是什么，是否要下推到 TiKV，使用 Hash 还是 Stream 聚合算子等都由优化器根据数据分布、估算的计算代价等来决定。</p><h2><b>TiDB 并行 Hash Aggregation 的实现</b></h2><ul><li><b>如何构建 Hash Aggregation 执行器</b></li></ul><ol><li><a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/planner/core/logical_plan_builder.go%23L95" class=" wrap external" target="_blank" rel="nofollow noreferrer">构建逻辑执行计划</a> 时，会调用 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/blob/v2.1.0/expression/aggregation/descriptor.go%23L49" class=" wrap external" target="_blank" rel="nofollow noreferrer">NewAggFuncDesc</a> 将聚合函数的元信息封装为一个 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/expression/aggregation/descriptor.go%23L35-L46" class=" wrap external" target="_blank" rel="nofollow noreferrer">AggFuncDesc</a>。 其中 <code>AggFuncDesc.RetTp</code> 由 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/expression/aggregation/descriptor.go%23L146-L163" class=" wrap external" target="_blank" rel="nofollow noreferrer">AggFuncDesc.typeInfer</a> 根据聚合函数类型及参数类型推导而来；<code>AggFuncDesc.Mode</code> 统一初始化为 CompleteMode。</li><li><a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/planner/core/task.go%23L487" class=" wrap external" target="_blank" rel="nofollow noreferrer">构建物理执行计划</a>时，<code>PhysicalHashAgg</code> 和 <code>PhysicalStreamAgg</code> 的 <code>attach2Task</code> 方法会根据当前 <code>task</code> 的类型尝试进行下推聚合计算，如果 <code>task</code> 类型满足下推的基本要求，比如 <code>copTask</code>，接着会调用 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/planner/core/task.go%23L380" class=" wrap external" target="_blank" rel="nofollow noreferrer">newPartialAggregate</a> 尝试将聚合算子拆成 TiKV 上执行的 Partial 算子和 TiDB 上执行的 <code>Final</code> 算子，其中 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/expression/aggregation/agg_to_pb.go%23L25" class=" wrap external" target="_blank" rel="nofollow noreferrer">AggFuncToPBExpr</a> 函数用来判断某个聚合函数是否可以下推。若聚合函数可以下推，则会在 TiKV 中进行预聚合并返回中间结果，因此需要将 TiDB 层执行的 <code>Final</code> 聚合算子的 <code>AggFuncDesc.Mode</code> <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/planner/core/task.go%23L427" class=" wrap external" target="_blank" rel="nofollow noreferrer">修改为 FinalMode</a>，并将其 <code>AggFuncDesc.Args</code> <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/planner/core/task.go%23L403-L426" class=" wrap external" target="_blank" rel="nofollow noreferrer">修改为 TiKV 预聚合后返回的中间结果</a>，TiKV 层的 Partial 聚合算子的 <code>AggFuncDesc</code> 也需要作出对应的修改，这里不再详述。若聚合函数不可以下推，则 <code>AggFuncDesc.Mode</code> 保持不变。</li><li><a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/blob/v2.1.0/executor/builder.go%23L999" class=" wrap external" target="_blank" rel="nofollow noreferrer">构建 HashAgg 执行器</a>时，首先检查当前 <code>HashAgg</code> 算子<a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/blob/v2.1.0/executor/builder.go%23L1037-L1047" class=" wrap external" target="_blank" rel="nofollow noreferrer">是否可以并行执行</a>。目前当且仅当两种情况下 <code>HashAgg</code> 不可以并行执行：</li></ol><ul><li>存在某个聚合函数参数为 DISTINCT 时。TiDB 暂未实现对 DedupMode 的支持，因此对于含有 <code>DISTINCT</code> 的情况目前仅能单线程执行。</li><li>系统变量 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/docs-cn/blob/master/sql/tidb-specific.md%23tidb_hashagg_partial_concurrency" class=" wrap external" target="_blank" rel="nofollow noreferrer">tidb_hashagg_partial_concurrency</a></code> 和 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/docs-cn/blob/master/sql/tidb-specific.md%23tidb_hashagg_final_concurrency" class=" wrap external" target="_blank" rel="nofollow noreferrer">tidb_hashagg_final_concurrency</a></code> 被同时设置为 1 时。这两个系统变量分别用来控制 Hash Aggregation 并行计算时候，TiDB 层聚合计算 partial 和 final 阶段 worker 的并发数。当它们都被设置为 1 时，选择单线程执行。</li></ul><p>若<code>HashAgg</code>算子可以并行执行，使用<a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/builder.go%23L1062" class=" wrap external" target="_blank" rel="nofollow noreferrer">AggFuncDesc.Split</a>根据<code>AggFuncDesc.Mode</code>将 TiDB 层的聚合算子的计算拆分为 partial 和 final 两个阶段，并分别生成对应的<code>AggFuncDesc</code>，设为<code>partialAggDesc</code>和<code>finalAggDesc</code>。若<code>AggFuncDesc.Mode == CompleteMode</code>，则将 TiDB 层的计算阶段拆分为<code>Partial1Mode --&gt; FinalMode</code>；若<code>AggFuncDesc.Mode == FinalMode</code>，则将 TiDB 层的计算阶段拆分为<code>Partial2Mode --&gt; FinalMode</code>。进一步的，我们可以根据<code>partialAggDesc</code>和<code>finalAggDesc</code>分别<a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/builder.go%23L1063-L1066" class=" wrap external" target="_blank" rel="nofollow noreferrer">构造出对应的执行函数</a>。</p><ul><li><b>并行 Hash Aggregation 执行过程详述</b></li></ul><p>TiDB 的并行 Hash Aggregation 算子执行过程中的主要线程有：Main Thead，Data Fetcher，Partial Worker，和 Final Worker：</p><ul><li>Main Thread 一个：</li><ul><li>启动 Input Reader，Partial Workers 及 Final Workers</li><li>等待 Final Worker 的执行结果并返回</li></ul><li>Data Fetcher 一个：</li><ul><li>按 batch 读取子节点数据并分发给 Partial Worker</li></ul><li>Partial Worker 多个：</li><ul><li>读取 Data Fetcher 发送来的数据，并做预聚合</li><li>将预聚合结果根据 Group 值 shuffle 给对应的 Final Worker</li></ul><li>Final Worker 多个：</li><ul><li>读取 PartialWorker 发送来的数据，计算最终结果，发送给 Main Thread</li></ul></ul><p>Hash Aggregation 的执行阶段可分为如下图所示的 5 步：</p><figure><noscript><img src="https://pic1.zhimg.com/v2-65f2027935adc477a4bed0fa5f275d34_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="347" class="origin_image zh-lightbox-thumb" width="939" data-original="https://pic1.zhimg.com/v2-65f2027935adc477a4bed0fa5f275d34_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-65f2027935adc477a4bed0fa5f275d34_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="347" class="origin_image zh-lightbox-thumb lazy" width="939" data-original="https://pic1.zhimg.com/v2-65f2027935adc477a4bed0fa5f275d34_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-65f2027935adc477a4bed0fa5f275d34_b.jpg"></figure><ol><li><b>启动 Data Fetcher，Partial Workers 及 Final Workers。</b></li></ol><p>这部分工作由 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0" class=" wrap external" target="_blank" rel="nofollow noreferrer">prepare4Parallel</a> 函数完成。该函数会启动一个 Data Fetcher，<a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L589-L591" class=" wrap external" target="_blank" rel="nofollow noreferrer">多个 Partial Worker</a> 以及 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L596-L598" class=" wrap external" target="_blank" rel="nofollow noreferrer">多个 Final Worker</a>。Partial Worker 和 Final Worker 的数量可以分别通过 <code>tidb_hashgg_partial_concurrency</code> 和 <code>tidb_hashagg_final_concurrency</code> 系统变量进行控制，这两个系统变量的默认值都为 4。</p><p><b>2.DataFetcher 读取子节点的数据并分发给 Partial Workers。</b></p><p>这部分工作由 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L535" class=" wrap external" target="_blank" rel="nofollow noreferrer">fetchChildData</a> 函数完成。</p><p><b>3.Partial Workers 预聚合计算，及根据 Group Key shuffle 给对应的 Final Workers。</b></p><p>这部分工作由 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L326" class=" wrap external" target="_blank" rel="nofollow noreferrer">HashAggPartialWorker.run</a> 函数完成。该函数调用 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L351" class=" wrap external" target="_blank" rel="nofollow noreferrer">updatePartialResult</a> 函数对 DataFetcher 发来数据执行 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L358-L363" class=" wrap external" target="_blank" rel="nofollow noreferrer">预聚合计算</a>，并将预聚合结果存储到 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L63" class=" wrap external" target="_blank" rel="nofollow noreferrer">partialResultMap</a> 中。其中 <code>partialResultMap</code> 的 key 为根据 <code>Group-By</code> 的值 encode 的结果，value 为 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggfuncs/aggfuncs.go%23L89" class=" wrap external" target="_blank" rel="nofollow noreferrer">PartialResult</a> 类型的数组，数组中的每个元素表示该下标处的聚合函数在对应 Group 中的预聚合结果。<a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L370" class=" wrap external" target="_blank" rel="nofollow noreferrer">shuffleIntermData</a> 函数完成根据 Group 值 shuffle 给对应的 Final Worker。</p><p><b>4.Final Worker 计算最终结果，发送给 Main Thread。</b></p><p>这部分工作由 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L505" class=" wrap external" target="_blank" rel="nofollow noreferrer">HashAggFinalWorker.run</a> 函数完成。该函数调用 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L434" class=" wrap external" target="_blank" rel="nofollow noreferrer">consumeIntermData</a> 函数 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/aggregate.go%23L443" class=" wrap external" target="_blank" rel="nofollow noreferrer">接收 PartialWorkers 发送来的预聚合结果</a>，进而 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L459" class=" wrap external" target="_blank" rel="nofollow noreferrer">合并</a> 得到最终结果。<a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/tree/v2.1.0/executor/aggregate.go%23L459" class=" wrap external" target="_blank" rel="nofollow noreferrer">getFinalResult</a> 函数完成发送最终结果给 Main Thread。</p><p><b>5.Main Thread 接收最终结果并返回。</b></p><h2><b>TiDB 并行 Hash Aggregation 的性能提升</b></h2><p>此处以 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-bench/blob/master/tpch/queries/17.sql" class=" wrap external" target="_blank" rel="nofollow noreferrer">TPC-H query-17</a> 为例，测试并行 Hash Aggregation 相较于单线程计算时的性能提升。引入并行 Hash Aggregation 前，它的计算瓶颈在 <code>HashAgg_35</code>。</p><p>该查询执行计划如下：</p><figure><noscript><img src="https://pic1.zhimg.com/v2-f47abed183d2edbddd6fda0d8ce6098c_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="941" class="origin_image zh-lightbox-thumb" width="939" data-original="https://pic1.zhimg.com/v2-f47abed183d2edbddd6fda0d8ce6098c_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-f47abed183d2edbddd6fda0d8ce6098c_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="941" class="origin_image zh-lightbox-thumb lazy" width="939" data-original="https://pic1.zhimg.com/v2-f47abed183d2edbddd6fda0d8ce6098c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-f47abed183d2edbddd6fda0d8ce6098c_b.jpg"></figure><p>在 TiDB 中，使用 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/docs-cn/blob/master/sql/understanding-the-query-execution-plan.md%23explain-analyze-%25E8%25BE%2593%25E5%2587%25BA%25E6%25A0%25BC%25E5%25BC%258F" class=" wrap external" target="_blank" rel="nofollow noreferrer">EXPLAIN ANALYZE</a> 可以获取 SQL 的执行统计信息。因篇幅原因此处仅贴出 TPC-H query-17 部分算子的 EXPLAIN ANALYZE 结果。</p><p><code>HashAgg</code> 单线程计算时：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-db9b78ba3e21565d4e7d5088e639af8f_b.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="113" class="origin_image zh-lightbox-thumb" width="1240" data-original="https://pic4.zhimg.com/v2-db9b78ba3e21565d4e7d5088e639af8f_r.jpg"></noscript><img src="https://pic4.zhimg.com/v2-db9b78ba3e21565d4e7d5088e639af8f_b.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="113" class="origin_image zh-lightbox-thumb lazy" width="1240" data-original="https://pic4.zhimg.com/v2-db9b78ba3e21565d4e7d5088e639af8f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-db9b78ba3e21565d4e7d5088e639af8f_b.jpg"></figure><p>查询总执行时间 23 分 24 秒，其中 <code>HashAgg</code> 执行时间约 17 分 9 秒。</p><p><code>HashAgg</code> 并行计算时（此时 TiDB 层 Partial 和 Final 阶段的 worker 数量都设置为 16）：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-8be3186bc4261d00467ac4dc110e5b0b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="113" class="origin_image zh-lightbox-thumb" width="1240" data-original="https://pic4.zhimg.com/v2-8be3186bc4261d00467ac4dc110e5b0b_r.jpg"></noscript><img src="https://pic4.zhimg.com/v2-8be3186bc4261d00467ac4dc110e5b0b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="113" class="origin_image zh-lightbox-thumb lazy" width="1240" data-original="https://pic4.zhimg.com/v2-8be3186bc4261d00467ac4dc110e5b0b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-8be3186bc4261d00467ac4dc110e5b0b_b.jpg"></figure><p>总查询时间 8 分 37 秒，其中 <code>HashAgg</code> 执行时间约 1 分 4 秒。</p><p>并行计算时，Hash Aggregation 的计算速度提升约 16 倍。</p><p><br></p><p><i><b>更多 TiDB 源码阅读系列文章：</b></i><br></p><a href="http://link.zhihu.com/?target=https%3A//www.pingcap.com/blog-cn/%23%25E6%25BA%2590%25E7%25A0%2581%25E9%2598%2585%25E8%25AF%25BB" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg" data-image-width="1200" data-image-height="1200" class=" wrap external" target="_blank" rel="nofollow noreferrer">博客</a><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
