<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>东天阳的知乎文章</title>
<link>https://henix.github.io/feeds/zhihu.posts.dong-tian-yang/</link>
<description>微软研究院博士后</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 06 Mar 2020 07:25:36 +0800</lastBuildDate>
<item>
<title>用密码学代替法官玩狼人杀 -- 闲聊乱码电路</title>
<link>https://henix.github.io/feeds/zhihu.posts.dong-tian-yang/2017-04-05-25986848.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25986848&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4a3d7eb4b99fcc7fe1398e82eb9ccd6d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;在今天的文章里，我们结合最近大火的狼人杀游戏，介绍姚期智老师在安全多方计算领域的开山神作 -- &lt;b&gt;乱码电路&lt;/b&gt;。在看完本文之后，你会知道用乱码电路，不用法官也能玩狼人杀！&lt;br&gt;&lt;h2&gt;乱码电路 &lt;/h2&gt;&lt;p&gt;&lt;b&gt;安全多方计算 &lt;/b&gt;是姚期智老师在80年代提出的一个概念。假设甲有数字&lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt;，乙有数字 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt;，他们在不向对方披露自己数字的情况下，共同计算一个二元函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28x%2Cy%29&quot; alt=&quot;f(x,y)&quot; eeimg=&quot;1&quot;&gt;。乱码电路 [1] 是姚老师对安全多方计算的经典解决方案。下面我们来简单介绍一下它是如何实现的。&lt;/p&gt;&lt;br&gt;&lt;h2&gt;预处理：将函数转换成电路&lt;/h2&gt;&lt;p&gt;首先，我们需要将函数转化成布尔电路。布尔电路概念其实很简单，由一些线路（wire）和一些门（gate) 组成。每条线路上面输送一个比特，也就是0或者1。而门有与门（AND），非门（NOT），或门（OR）等等。门的作用是把两个输入比特变成一个输出比特，而门上的具体逻辑由&lt;b&gt;真值表 &lt;/b&gt;给出。例如XOR门的真值表长这个样子&lt;b&gt;：&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/50/v2-e562312d5fbde4058048345a3678c326_b.png&quot; data-rawwidth=&quot;162&quot; data-rawheight=&quot;145&quot; class=&quot;content_image&quot; width=&quot;162&quot;&gt;&lt;p&gt;通常使用的所有函数都可以用布尔电路来表示。例如狼人杀中，法官判断守卫是否守中人，就是在执行一个相等函数：假设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 和&lt;img src=&quot;https://www.zhihu.com/equation?tex=y%0A&quot; alt=&quot;y
&quot; eeimg=&quot;1&quot;&gt; 是整数，代表狼刀玩家和守卫守护玩家的编号。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt;等于&lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt;，那么输出1（守卫守中人），否则输出0（没有守中）。对应的布尔电路见下图，为了简单起见，我们假设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=y%0A&quot; alt=&quot;y
&quot; eeimg=&quot;1&quot;&gt;是0到3之间的整数。&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-a217d7ff2cf9de6e2d3be42db57a23b8_b.png&quot; data-rawwidth=&quot;1188&quot; data-rawheight=&quot;724&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1188&quot; data-original=&quot;https://pic1.zhimg.com/50/v2-a217d7ff2cf9de6e2d3be42db57a23b8_r.png&quot;&gt;&lt;h2&gt;步骤一：将电路乱码化&lt;/h2&gt;&lt;p&gt;好的, 现在我们jiA-一个布尔电路。但是怎样让在乙不知道甲的输入的情况下，还能执行电路，得到结果呢？姚老师的绝妙想法是：对电路中的每一条线路进行加密！在上面的电路中，每条线路上有一个比特--0或者1。而在乱码电路中，对于&lt;b&gt;每条线路&lt;/b&gt;，甲选取两个随机的&lt;b&gt;标签&lt;/b&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=k_0%2C+k_1&quot; alt=&quot;k_0, k_1&quot; eeimg=&quot;1&quot;&gt; 来代表这个线路上的值。即&lt;img src=&quot;https://www.zhihu.com/equation?tex=k_0%0A&quot; alt=&quot;k_0
&quot; eeimg=&quot;1&quot;&gt;对应0，&lt;img src=&quot;https://www.zhihu.com/equation?tex=k_1&quot; alt=&quot;k_1&quot; eeimg=&quot;1&quot;&gt;对应1。&lt;/p&gt;&lt;p&gt;这样，乙就不知道线路上实际的比特是什么了，但是糟糕的是：由于线路上都是乱码，乙要怎么执行这个电路呢？解决方法简单而奇妙，对于每个电路中的门，甲建立一个对应于真值表的&lt;b&gt;乱码真值表&lt;/b&gt;。我们以XOR门为例，来看看乱码真值表是怎么写出来的。 &lt;/p&gt;&lt;p&gt;假设XOR的两条输入线路对应的标签是分别是&lt;img src=&quot;https://www.zhihu.com/equation?tex=A_0%2C+A_1%2C+B_0%2C+B_1.&quot; alt=&quot;A_0, A_1, B_0, B_1.&quot; eeimg=&quot;1&quot;&gt; 而输出线路的标签是&lt;img src=&quot;https://www.zhihu.com/equation?tex=C_0%2C+C_1.&quot; alt=&quot;C_0, C_1.&quot; eeimg=&quot;1&quot;&gt; 为了建立乱码真值表，甲首先把XOR真值表中的比特转换成对应的标签，于是真值表就变成了下面的样子。。。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/50/v2-571616ca98ed9b85e41645359eaf0691_b.png&quot; data-rawwidth=&quot;710&quot; data-rawheight=&quot;255&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;710&quot; data-original=&quot;https://pic2.zhimg.com/50/v2-571616ca98ed9b85e41645359eaf0691_r.png&quot;&gt;现在关键的步骤来了，对于表中的每一行，甲依次用两个输入标签作为&lt;b&gt;密钥&lt;/b&gt;，对输出标签进行&lt;b&gt;加密&lt;/b&gt; 。以第一行为例，见下图&lt;img src=&quot;https://pic2.zhimg.com/50/v2-8e4290f336609937c0d5dfc16046b81d_b.png&quot; data-rawwidth=&quot;1812&quot; data-rawheight=&quot;520&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1812&quot; data-original=&quot;https://pic2.zhimg.com/50/v2-8e4290f336609937c0d5dfc16046b81d_r.png&quot;&gt;&lt;p&gt;这样，得到的乱码真值表的每一行都包含两个输入标签，和一个加密过的输出标签。&lt;/p&gt;&lt;p&gt;最后，甲把生成的所有乱码真值表（每个门一个），和自己的输入值对应的标签一同发送给乙。有了这些乱码真值表和输入标签，乙就可以执行电路运算了。&lt;/p&gt;&lt;h2&gt;步骤二： 忘性传输（Oblivious Transfer）&lt;/h2&gt;&lt;p&gt;我们刚才有意忽略了一个问题，多方计算中，不光甲有输入，乙也是有输入的啊。那么乙怎么获得跟自己的输入值对应的标签呢？ 当然，她不能直接向甲要求标签，因为这样的话，甲立刻就知道她的输入值了。解决的方法，是使用一个叫做 &lt;b&gt;忘性传输( OT ) &lt;/b&gt;的协议。由于篇幅关系，我们只讲忘性传输的功能，而不细讲如何实现了。在 OT协议开始时， 甲拥有两个文件&lt;img src=&quot;https://www.zhihu.com/equation?tex=F_0&quot; alt=&quot;F_0&quot; eeimg=&quot;1&quot;&gt;，&lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1%0A&quot; alt=&quot;F_1
&quot; eeimg=&quot;1&quot;&gt;，乙想获得其中的一个文件。协议完成之后，乙会得到他所选择的文件，但是甲不知道乙获得的是哪个文件。&lt;/p&gt;&lt;p&gt;不得不说，OT又是密码学的又一项令人瞠目的黑科技。。。我们先回到乱码电路：乙只需要对自己的每个输入比特和甲执行一次OT协议，就可以得到对应的标签了！而根据OT的定义，甲是不知道乙要求的是哪个标签的，这样就保护了乙的隐私。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;步骤三：执行乱码电路&lt;/h2&gt;&lt;p&gt;现在乙有了乱码真值表和输入标签，她要如何执行电路呢？ 对于每个门，乙都拥有四个输入标签中的两个，所以她只需要用这两个标签来解密乱码真值表的第三列，就可以得到对应的输出标签。乙就可以这样一步步执行所有的门，得到最终结果。在执行完所有门后。乙得到输出值对应的标签， 并把这些标签告诉甲，由甲来公布最后的明文输出值，协议完成！&lt;/p&gt;&lt;br&gt;&lt;p&gt;我们回顾一下这个协议是怎么保护隐私的。甲的隐私是由标签和加密保护的。由于所有标签都是甲随机选取的字符串，而字符串和比特之间的对应只有甲知道，所以乙只能“盲目执行”这个乱码电路。无论是甲的输入，还是电路执行过程中的中间结果，乙都一无所知。而乙的隐私是由上面的忘性传输来保护。&lt;/p&gt;&lt;h2&gt;------------------------ 分割线 ------------------------------&lt;/h2&gt;&lt;h2&gt;狼人杀可以不用法官玩吗&lt;/h2&gt;&lt;p&gt;狼人杀游戏是一种信息不完全的博弈，安全多方计算可以应用。首先，我们来想一想为什么玩狼人杀需要法官。在白天法官的行动是公开的，所以任何玩家都可以在白天充当法官。晚上，法官说的话都是一样的， 所以可以用预先准备好的录音来代替。那么法官真正的关键功能在哪里呢？没错，是&lt;b&gt;对玩家的隐私输入进行计算 。&lt;/b&gt;例如守卫守人的过程&lt;b&gt;，&lt;/b&gt;要知道有没有守中人，必须得有一个人（法官）同时知道守人和刀人的信息，但是按照规则，任何玩家都无权得到这两份信息。所以是不可以用一个玩家来代替法官的。&lt;/p&gt;&lt;p&gt;但是！用上面所述的密码学协议，我们可以仅通过玩家们互相之间的计算，来代替法官。在把乱码电路应用到狼人杀上之前，我们先需要解决两个问题。&lt;/p&gt;&lt;p&gt;第一，我们可能需要计算参与者得到不同的输出，在上面狼人－守卫的例子里，输出是对双方公开的，所以没有这个问题。然而如果是狼人－预言家进行计算的话，预言家会知道他选验的人是否是狼，而狼人是不知道预言家晚上有没有查到狼的，所以就需要多方计算的每一方有不同的输出。而上面的协议稍加修改后，是可以计算两个函数，把一个结果给甲，第二个给乙的。这里就不谈细节了。&lt;/p&gt;&lt;p&gt;第二，乱码电路解决的是两方计算问题，而在狼人杀中，我们需要的是所有玩家同时参与计算，不然玩家的身份就暴露了。所以我们的协议也需要做相应的修改，来处理参与计算人数大于2的情形。这里略去细节~&lt;/p&gt;&lt;h2&gt;用多方计算代替法官&lt;/h2&gt;&lt;p&gt;先回顾一下法官在夜晚进行的活动[3]  --- &lt;/p&gt;&lt;p&gt;１. 守卫睁眼，比手势告知法官守谁。&lt;br&gt;&lt;/p&gt;&lt;p&gt;２. 狼人睁眼，狼人睁眼相互确认同伴，狼人比号码，狼人闭眼。&lt;/p&gt;&lt;p&gt;３. 预言家睁眼以手势号码告知法官验几号，法官以手势回应，预言家闭眼。&lt;/p&gt;&lt;p&gt;４. 女巫睁眼，如当晚无人死亡或解药已用，法官摇手表示无人死亡，并且不告知女巫谁被杀。如有人被杀死，法官用手势号码告诉女巫刚才狼人杀死的是谁。法官都说“昨晚死的是他，你要救吗？”，女巫以点头摇头表示，然后法官说“你要毒人吗”，女巫以点头和摇头表示，如点头，以手势告知法官要毒的是谁。女巫闭眼。&lt;/p&gt;&lt;p&gt;从上面的流程中，我们可以提炼出法官需要做的三个计算：给预言家信息，给女巫信息，计算出当晚谁死去。为了简单起见，我们做一个假设：&lt;b&gt;所有玩家均遵循游戏规则，不会背离协议&lt;/b&gt;。在此基础上，我们把狼人杀晚上的活动解释为三轮的多方计算，然后就可以轻松实现了。&lt;/p&gt;&lt;p&gt;第一轮输入：所有人输入自己的身份牌。在此基础上，狼人 -- 输入要杀的人的编号 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;&gt;, 守卫 -- 输入要守的人的编号 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt;, 预言家 -- 输入验人编号 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt;，女巫 -- 输入解药是否已用。已经死亡的角色输入-1。&lt;/p&gt;&lt;p&gt;第一轮输出：向预言家输出验人信息，向女巫输出死亡信息，其他所有人输出为-1。 计算验人信息的函数是 ： 如果玩家 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; 是狼，输出1；否则输出0。 输出死亡信息的函数是，如果女巫已经使用解药或者没有人死亡(&lt;img src=&quot;https://www.zhihu.com/equation?tex=k%3D-1&quot; alt=&quot;k=-1&quot; eeimg=&quot;1&quot;&gt; 或 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%3D+s&quot; alt=&quot;k= s&quot; eeimg=&quot;1&quot;&gt;)，那么女巫输出0。否则女巫输出 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;&gt;。&lt;/p&gt;&lt;p&gt;第二轮输入： 女巫 -- 输入是否使用解药 &lt;img src=&quot;https://www.zhihu.com/equation?tex=j&quot; alt=&quot;j&quot; eeimg=&quot;1&quot;&gt;（如果没有解药则女巫输入-1），以及毒药使用对象编号 &lt;img src=&quot;https://www.zhihu.com/equation?tex=d&quot; alt=&quot;d&quot; eeimg=&quot;1&quot;&gt;（如果没有毒药，输入-1）。其他所有人输入为空。 &lt;/p&gt;&lt;br&gt;第二轮输出（白天）：向所有人输出死亡玩家的编号，以及游戏是否结束的信息。死亡玩家的计算方法为 [被毒的玩家] 和[被刀，且没有被救或被守的玩家] （为叙述简单起见，我们不考虑同守同救的情况）。用伪代码表示就是&lt;p&gt;                            死亡玩家 = &lt;img src=&quot;https://www.zhihu.com/equation?tex=d&quot; alt=&quot;d&quot; eeimg=&quot;1&quot;&gt; if( &lt;img src=&quot;https://www.zhihu.com/equation?tex=k+%3D+s&quot; alt=&quot;k = s&quot; eeimg=&quot;1&quot;&gt; or &lt;img src=&quot;https://www.zhihu.com/equation?tex=j+%3D+1&quot; alt=&quot;j = 1&quot; eeimg=&quot;1&quot;&gt; or &lt;img src=&quot;https://www.zhihu.com/equation?tex=k+%3D+-1&quot; alt=&quot;k = -1&quot; eeimg=&quot;1&quot;&gt;); else &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28k%2C+d%29%0A&quot; alt=&quot;(k, d)
&quot; eeimg=&quot;1&quot;&gt;。&lt;/p&gt;&lt;p&gt;计算游戏是否结束：如存活玩家 （= 参与计算玩家 减去 死去玩家）里没有狼人，那么好人胜利。狼人胜利的判断条件随规则而变，这里就留给大家练习了。&lt;br&gt;&lt;/p&gt;&lt;p&gt;其他问题&lt;br&gt;&lt;/p&gt;&lt;p&gt;在多方计算的应用中还会遇到各式各样的问题。例如我们需要考虑到玩家恶意违背规则，以及多个玩家共谋来坑害其他玩家的情形。这就需要对乱码电路的协议再进行修改，来惩罚或者揭露违背规则的玩家。今天就不展开谈了。最后留一道思考题。各位下回再见～&lt;/p&gt;&lt;p&gt;思考题：&lt;i&gt;在乱码电路协议中，一个步骤是对“标签真值表”的输出列加密两次，这是必要的吗?&lt;/i&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;参考文献&lt;/h2&gt;&lt;br&gt;[1] Yao, Andrew Chi-Chih. &quot;How to generate and exchange secrets.&quot; &lt;i&gt;Foundations of Computer Science, 1986., 27th Annual Symposium on&lt;/i&gt;. IEEE, 1986&lt;br&gt;&lt;p&gt;[2] Rosulek, Mike. &quot;Secure Your Data and Compute on It, Too.&quot; &lt;i&gt;XRDS: Crossroads, The ACM Magazine for Students&lt;/i&gt; 21.3 (2015): 36-41.&lt;/p&gt;&lt;p&gt;[3] &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//fanwen.wenku1.com/article/30754744.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;fanwen.wenku1.com/artic&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;le/30754744.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</description>
<author>东天阳</author>
<guid isPermaLink="false">2017-04-05-25986848</guid>
<pubDate>Wed, 05 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用密码学玩暗军棋 -- 闲聊多方计算</title>
<link>https://henix.github.io/feeds/zhihu.posts.dong-tian-yang/2017-03-20-25770963.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25770963&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cbbd7a935e305657af8481a9acad212e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;暗军棋&lt;/h2&gt;&lt;p&gt;我们先来回顾一下儿时玩的军棋游戏，然后探讨一下如何使用密码学来代替裁判。军棋游戏的目标是通过在棋盘上移动自己的部队攻占对方的军旗。 当两方的棋子碰撞时，采取如下规则&lt;/p&gt;&lt;ol&gt;&lt;li&gt;司令 &gt; 军长 &gt; 师长 &gt; 旅长 &gt; 团长 &gt; 营长 &gt; 连长 &gt; 排长 &gt; 工兵&lt;/li&gt;&lt;li&gt;炸弹与任何非军旗棋子相遇时，双方都消失&lt;/li&gt;&lt;li&gt;工兵 &gt; 地雷&lt;/li&gt;&lt;li&gt;地雷 &gt; 除炸弹和工兵以外的任何子力&lt;/li&gt;&lt;li&gt;任何棋子 &gt; 对方的军旗 (游戏结束，一方胜利）。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;军棋有 明 与 暗 两种下法。在明军棋中，双方的棋子正面朝上放置。暗军棋是一种更刺激的玩法，双方把棋子扣过来背面朝上，用来隐藏自己的布阵和行动。但是暗军棋的特点是需要一个裁判：当两枚棋子碰撞的时候，裁判观看棋子的正面，然后执行上述的吃子规则。那么问题来了：如果没有裁判，两个人还可以玩暗军棋吗？&lt;/p&gt;&lt;p&gt;YES! 用密码学不仅能实现暗军棋，还可以不依赖公正的第三方（裁判/法官/拍卖行） 来进行任何博弈（古董拍卖，德州扑克，狼人杀等等。。。）不过实现的方法稍微有一点复杂，所以我们先来讲简单的情形～首先，两枚军棋的碰撞可以抽象成一个比较函数:&lt;/p&gt;&lt;img src=&quot;http://www.zhihu.com/equation?tex=f%28x%2C+y+%29+%3D+1+%5Cmbox%7B+if+%7D+x+%3E+y%2C+-1+%5Cmbox%7B+if+%7D+x+%3Cy%2C+0+%5Cmbox%7B+if+%7D+x+%3D+y&quot; alt=&quot;f(x, y ) = 1 \mbox{ if } x &gt; y, -1 \mbox{ if } x &lt;y, 0 \mbox{ if } x = y&quot; eeimg=&quot;1&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;假设我的军长是10级，对方的连长是3级，那么因为10 &gt; 3, 所以比较的结果是1 ，我的军长吃掉对方的连长。问题是，我拥有数字10，对方拥有数字3， 我们怎么能在不透露具体军阶的情况下，比较这两个数的大小呢？这里我们就要隆重介绍 --- 姚期智院士的百万富翁问题！&lt;/p&gt;&lt;h2&gt;百万富翁问题&lt;/h2&gt;&lt;p&gt;在文章[1]中，姚老师提出了如下问题：&lt;/p&gt;&lt;blockquote&gt;两个富翁的财产是1到10之间的整数。他们如何在不透露自己财产的情况下，比较谁更富有？&lt;/blockquote&gt;&lt;p&gt;很容易看出，百万富翁问题和 暗军棋比较军衔问题是等价的：无非是比较大小。我们下面来介绍姚老师的精妙解法 ---&lt;/p&gt;&lt;p&gt;假设富翁王有&lt;img src=&quot;http://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;&gt;亿资产，李有&lt;img src=&quot;http://www.zhihu.com/equation?tex=j%0A&quot; alt=&quot;j
&quot; eeimg=&quot;1&quot;&gt;亿资产。王选取一个公钥，使得李可以传递加密的信息。&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先，李选取一个随机的大整数 &lt;img src=&quot;http://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; ，把  &lt;img src=&quot;http://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 用王的公钥加密，得到密文 &lt;img src=&quot;http://www.zhihu.com/equation?tex=K&quot; alt=&quot;K&quot; eeimg=&quot;1&quot;&gt;。 李 发送  &lt;img src=&quot;http://www.zhihu.com/equation?tex=K+-j&quot; alt=&quot;K -j&quot; eeimg=&quot;1&quot;&gt;给王。&lt;/p&gt;&lt;p&gt;王收到密文 &lt;img src=&quot;http://www.zhihu.com/equation?tex=c+%3D+K+-+j&quot; alt=&quot;c = K - j&quot; eeimg=&quot;1&quot;&gt; 之后， 对 &lt;img src=&quot;http://www.zhihu.com/equation?tex=c%2B+1%2C+%5Cldots%2C+c%2B+10&quot; alt=&quot;c+ 1, \ldots, c+ 10&quot; eeimg=&quot;1&quot;&gt;进行解密，得到十个数字。再选取一个适当大小的素数 &lt;img src=&quot;http://www.zhihu.com/equation?tex=p&quot; alt=&quot;p&quot; eeimg=&quot;1&quot;&gt;,  把这十个数字除以 &lt;img src=&quot;http://www.zhihu.com/equation?tex=p&quot; alt=&quot;p&quot; eeimg=&quot;1&quot;&gt; 的余数记作 &lt;img src=&quot;http://www.zhihu.com/equation?tex=d_1%2C+%5Cldots%2C+d_%7B10%7D&quot; alt=&quot;d_1, \ldots, d_{10}&quot; eeimg=&quot;1&quot;&gt;.&lt;/p&gt;&lt;p&gt;注意: 这十个数字看起来应该是完全随机的，关键是等式  &lt;img src=&quot;http://www.zhihu.com/equation?tex=d_j+%3D+x+%5Cmod%7Bp%7D&quot; alt=&quot;d_j = x \mod{p}&quot; eeimg=&quot;1&quot;&gt; 成立。&lt;/p&gt;&lt;p&gt;最后，王对这一串数字作如下操作：前面 i 个数不动，后面的数字每个加一，然后发回给李。&lt;br&gt;&lt;/p&gt;&lt;p&gt;这样一通复杂的操作之后，李检查第j个数字。如果等于 &lt;img src=&quot;http://www.zhihu.com/equation?tex=+x+%5Cmod%7Bp%7D&quot; alt=&quot; x \mod{p}&quot; eeimg=&quot;1&quot;&gt; 的话，说明这个数字没有被加一，所以 i &gt;= j. 反之，则 i &lt; j。&lt;/p&gt;&lt;p&gt;这个过程的绝妙之处在于：在协议完成之后，王不知道j的具体值，而李也不知道 i 的值， 但是双方都知道谁的财富更多，这就是&lt;b&gt;安全多方计算&lt;/b&gt;。一般来说，在甲只知道x，乙只知道y的情况下，双方可以合作计算一个函数 f(x,y)。协议完成时，只有函数值是公开的，而彼此都不知道对方的输入值。&lt;/p&gt;&lt;h2&gt;回到暗军棋&lt;/h2&gt;&lt;p&gt;在解决了百万富翁问题之后，暗军棋的玩法就很简单了。 在每次两枚棋子碰撞的时候，只需要对弈两方进行一次上述的比较计算就可以了。有细心的同学要问了：且慢，这种玩法下难道不可以作弊吗？比如我的棋子只是2级，但我可以在比较的时候输入一个10级，而对方是无法发现的，因为计算结果只会表明我的棋子比他大？确实如此，注意到上面的协议是无法确保输入的数字和棋子的军阶是一致的。但是解决的方法也很简单，如在游戏结束之后，双方都翻开自己的所有棋子，再对照游戏记录进行明军棋的复盘，就可以找出有没有人作弊了～&lt;/p&gt;&lt;br&gt;&lt;h2&gt;安全多方计算(secure multiparty computation)&lt;/h2&gt;&lt;p&gt;安全多方计算，可以说是密码学中的又一项黑科技。它可以看作是上面比较函数的一个推广，是可以实现&lt;b&gt;任意数量&lt;/b&gt;的参与者共同计算&lt;b&gt;任意函数&lt;/b&gt;的！它的应用就非常广泛了，所有需要公正裁判的场景，都可以用这个协议来代替裁判～&lt;/p&gt;&lt;p&gt;两个经典的应用：&lt;/p&gt;&lt;p&gt;拍卖 -- 对应的函数是取所有输入的最大值。利用安全多方计算，在拍卖结束后每个人的出价都还保持隐私。&lt;/p&gt;&lt;p&gt;选举 -- 对应的函数是对所有输入求和（假设 1 代表选举人A , 0 代表选举人 B)。在这里，安全多方计算可以确保 每个人的投票是保密的，而且计票完全公正。&lt;/p&gt;&lt;p&gt;两个新颖的应用：&lt;/p&gt;&lt;p&gt;共同好友 -- 两个初次见面的人希望找到彼此的共同好友，而不向对方透露自己所有的好友。这里双方的输入是两个集合，对应的函数是取交集。&lt;/p&gt;&lt;p&gt;合作机器学习 -- 对应的函数是一个训练算法，而输入是每人各自的data set。这个应用是近年来兴起的。如果使用得当，可以打破数据的隐私壁垒。。。&lt;/p&gt;&lt;p&gt;那么这么强大的协议是怎么实现的呢？这就得介绍到姚老师的神作&lt;b&gt; 乱码电路&lt;/b&gt; 了。今天先到这里吧～&lt;/p&gt;&lt;p&gt;&lt;u&gt;附加思考题&lt;/u&gt;：在上面的百万富翁问题的解法，有一步是取十个明文除以素数p的余数。这一步可以省略吗？&lt;/p&gt;&lt;h2&gt;参考文献&lt;/h2&gt;&lt;p&gt;[1] Yao, Andrew C. &quot;Protocols for secure computations.&quot; In Proc. 23rd Annual Symp. on Foundations of
Computer Science (FOCS), pages 160–164. IEEE, 1982.&lt;/p&gt;</description>
<author>东天阳</author>
<guid isPermaLink="false">2017-03-20-25770963</guid>
<pubDate>Mon, 20 Mar 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用一点密码学实现远程猜拳 -- 闲聊commitment scheme</title>
<link>https://henix.github.io/feeds/zhihu.posts.dong-tian-yang/2017-02-27-25241252.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25241252&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-805eaf889db78b69af4a8c59d86d7691_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;小时候和伙伴一起猜拳定胜负的场景还历历在目吧？记得当时往往因为“慢出” 产生争执。 解决争执的方法通常是重新猜拳，或者是找第三个小伙伴来仲裁。然而这些方法有着本质上的局限， 因为没有任何办法能保证两个人 &lt;b&gt;完全 &lt;/b&gt;同时出拳：在猜拳高手的眼中，即使晚出0.01秒， 也可以观察到对手的动作，克敌制胜！不过这并不是一篇武侠小说，所以我们今天讨论的话题是: 如何完成 &lt;b&gt;公平&lt;/b&gt; 的猜拳？！？ &lt;br&gt;&lt;/p&gt;&lt;h2&gt;两人可以见面&lt;/h2&gt;&lt;p&gt;一个最简单的解法是： 每人把自己的决定（石头，剪刀，布）写到一张纸上。再装进一个信封里。然后两人见面，把信封拆开。这样就无法改变自己的决定了。这样的猜拳结果是完全公平的，因为决定已经装在信封里，就无法再更改了！&lt;/p&gt;&lt;p&gt;三国演义中， 诸葛亮和周瑜商量赤壁之战的对策，各在手中写一个“火” 字，使用的是同样的方法。诸葛亮在这里有两个目标：要传达给周瑜自己火攻的计策，同时又想测试一下周瑜是否也想到火攻。周瑜的想法也一样：既要传达这个计策，又想测试对方的能力。这样一来，两方产生了一个有趣的小博弈，看一段原文：&lt;/p&gt;&lt;blockquote&gt;瑜邀孔明入帐共饮。瑜曰：“昨吾主遣使来催督进军，瑜未有奇计，愿先生教我。”孔明曰：“亮乃碌碌庸才，安有妙计？”瑜曰：“某昨观曹操水寨，极其严整有法，非等闲可攻。思得一计，不知可否，先生幸为我一决之。”孔明曰：“都督且休言。各自写于手内，看同也不同。” 瑜大喜，教取笔砚来，先自暗写了，却送与孔明。孔明亦暗写了，两个移近坐榻，各出掌中之字，互相观看，皆大笑。原来周瑜掌中字，乃一‘火’字，孔明掌中，亦一‘火’字。瑜曰：“既我两人所见相同，更无疑矣。幸勿漏泄。”孔明曰：“两家公事，岂有漏泄之理？吾料曹操虽两番经我这条计，然必不为备。今都督尽行之可也。”饮罢分散，诸将皆不知其事。&lt;br&gt;&lt;/blockquote&gt;这里周瑜和诸葛亮掌心写字的方法和使用信封是异曲同工的。&lt;br&gt;&lt;h2&gt;两人不能见面&lt;/h2&gt;&lt;p&gt;现在我们把难度提高一点: 诸葛亮想和曹操猜拳，但是两人身处异地无法见面。这种情况下如何保证公平呢？ &lt;/p&gt;&lt;p&gt;如果诸葛亮把自己的信封用快马送给曹操，那曹操可以拆开看到诸葛亮的出拳之后再写自己的信。所以之前的解法就失效了。信封这个解法不行了，不过如果用一点密码学，还是可以异地猜拳。我们假设诸葛亮有一个抵抗冲撞的哈希函数(collision-resistant hash function) f(x)，满足如下的条件： &lt;/p&gt;&lt;p&gt;(1) 从 x 很容易计算f(x)。&lt;/p&gt;&lt;p&gt;(2) &lt;b&gt;非常难&lt;/b&gt;找到两个x, y 满足f(x) = f(y).&lt;br&gt;&lt;/p&gt;&lt;p&gt;诸葛亮先确定一个选择 m {石头，剪刀，布} 。然后再选择一串随机数r, 把自己的承诺 y = f(r , m) 发给曹操。曹操同样把自己的“承诺&quot; y&#39; 发给诸葛亮。&lt;/p&gt;&lt;p&gt;诸葛亮等自己收到曹操的承诺y&#39;以后，再把随机数r和自己的出拳z发送过去。曹操等收到承诺之后，做同样的事。&lt;/p&gt;&lt;p&gt;曹操通过计算f(r, m) = y 来确保诸葛亮没有作弊。&lt;/p&gt;&lt;br&gt;&lt;p&gt;现在双方可以比较彼此的出拳，来决定谁胜谁负！问题是: 为什么这样可以杜绝一方作弊？ &lt;/p&gt;&lt;p&gt;假设诸葛亮想要作弊，那他必须在收到曹操的所有信息之后再发送（r,z）。现在假设诸葛亮想把自己的出拳改成 m&#39; , 那么他必须找到另一个随机数r&#39;，满足&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;f(r , m) = f(r&#39;, m&#39;). &lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;然而！根据对函数 f 的假设，在有生之年诸葛亮是找不到r&#39; 的。所以他没有办法作弊：任何他能找到的r&#39;, 曹操计算出的承诺 f(r&#39;,m&#39;) 都和 y 对不上，所以曹操能看出他有没有“慢出”！ &lt;/p&gt;&lt;br&gt;&lt;h2&gt;承诺系统 (Commitment Scheme)&lt;/h2&gt;&lt;p&gt;上面介绍的”公平的远程猜拳“方法用到的实际是密码学的一个重要原型 Commitment Scheme。它起源于两篇文章： 1979年Blum的coin flipping over the telephone （如何通电话猜硬币）和 1981年RSA三巨头的 Mental Poker （如何通电话玩扑克）。可以看出来，commitment最大的优势是用来远程进行公平的博弈，而不需要一个第三方裁判的存在。&lt;/p&gt;&lt;p&gt;这里再介绍一个经典的应用场景：假设一件古董的买方和卖方的出价底线分别是a元和b元，他们希望达成如下的协定：如果a &lt; b，那么交易失败；如果 a &gt;= b， 那么交易在中间价格 (a + b)／2 上成交。 &lt;/p&gt;&lt;p&gt;这个看似简单的合同怎么在实际生活中执行呢？当然买家不能把自己的底线a透露给卖家，因为如果a &gt; b，那么卖家可以出价a, 从而在高位成交；反之也同理。如何隐藏自己的底线价格呢？用commitment！原理和之前的异地猜拳完全一样。就是买卖双方(1) 先公开自己出价的commitment，然后(2) 公开价格。由于commitment具有隐藏性，所以在步骤（1）之后双方都无法推测对方的价格；又由于commitment具有不可更改的特性，所以任何一方都无法在步骤（2）中更改自己之前承诺（commit) 的价格 ! &lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt;为何不用微信猜拳？&lt;/h2&gt;&lt;p&gt;看到这里肯定有人要问了： 那微信猜拳呢? 它比上面的用commitment的解法简单粗暴多了：我可以直接发送一个猜拳的表情，然后这个表情会随机变化成石头剪刀布中的一个。为什么还需要引入承诺系统呢？&lt;/p&gt;&lt;p&gt;其实最大的不同在于：微信在猜拳里扮演的是一个 &lt;b&gt;公正的第三方，&lt;/b&gt; 即对话的双方需要都信任微信不会作弊&lt;b&gt;。&lt;/b&gt;其实在有公正的第三方存在的情况下，上面提到的所有问题都可以简单解决。从之前那个古董买卖的例子来看，如果有一个买卖双方都信任的交易行，那么他们只需要把自己的报价a,b提交给交易行，交易行作为一个诚实可靠的机构，会诚实的比较报价并得出最终结论。&lt;/p&gt;&lt;p&gt;然而这个公正第三方往往不是免费的：无论是法官，交易中介，古董拍卖行，都是收取手续费的。 而且这些第三方也不是百分之百可以信任：他们有可能和博弈双方的其中一边合作，来损害另一边的利益。 &lt;br&gt;&lt;/p&gt;&lt;p&gt;而上面的通过 commitment 来博弈的方法是不需要公正第三方的！这也是为什么它在现代密码学中的应用如此的广泛。比如&lt;/p&gt;&lt;p&gt;&lt;i&gt; 数字货币（参见旧文  &lt;a href=&quot;https://zhuanlan.zhihu.com/p/25168970&quot; class=&quot;internal&quot;&gt;Zerocash: 数字货币领域的暗科技&lt;/a&gt; ） &lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt; 多方计算&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;零知识证明&lt;/i&gt;&lt;/p&gt;&lt;p&gt; 等等...都是以后可以展开聊很多的话题，今天就先到这里吧。&lt;/p&gt;</description>
<author>东天阳</author>
<guid isPermaLink="false">2017-02-27-25241252</guid>
<pubDate>Mon, 27 Feb 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Zerocash: 数字货币领域的暗科技</title>
<link>https://henix.github.io/feeds/zhihu.posts.dong-tian-yang/2017-02-14-25168970.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25168970&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ff7e4e6c3917dd35f64365c838447ffc_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;自从Zcash(一种新兴的匿名数字货币)由2016年11月正式上线以来，我一直在关注它的进展。起初的动机很单纯，只是觉得这项黑科技特别高大上，特别神秘：仅仅通过发送一些信息到公网，就可以实现两个匿名用户之间完全隐私的转账: 不仅付款人和收款人的身份保密，甚至连交易金额都完全保密！这种完全匿名究竟是怎么实现的？&lt;/p&gt;&lt;br&gt;&lt;p&gt;Zcash其实可以看作是比特币的加强隐私版: 我们已经知道比特币可以实现点对点之间的快速低费用转账，而不需要通过银行或第三方机构（如支付宝，微信等等）。它在比特币的基础上， 实现了两项创新：&lt;b&gt;转账金额保密&lt;/b&gt; 以及 &lt;b&gt;完全匿名交易&lt;/b&gt;。可以这么说: Zcash是密码学领域的两项黑科技 -- 区块链(blockchain)技术和简短零知识证明(zk-SNARK)的一次联姻。&lt;/p&gt;&lt;br&gt;&lt;p&gt;Zcash的实现有两种方式：可以完全开辟一个新区块链，也可以依附在比特币的区块链上。下面介绍的是第二种实现方式。依附在比特币上有一个好处： 允许用户在ZEC (Zcash的货币单位) 和比特币之间自由转换。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;h2&gt;Zcash的两种交易： Mint （铸币）和 Pour (转账)。&lt;/h2&gt;&lt;h2&gt;铸币交易（Mint )&lt;/h2&gt;&lt;p&gt;先来看铸币的功能：假设我有v单位的比特币，如何转换成ZEC呢？&lt;/p&gt;&lt;p&gt;我们先来回忆一个标准的比特币交易内容：&lt;/p&gt;&lt;blockquote&gt;A: 我要转账   &lt;img src=&quot;http://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt;  比特币給B,   &lt;img src=&quot;http://www.zhihu.com/equation?tex=z&quot; alt=&quot;z&quot; eeimg=&quot;1&quot;&gt;  比特币给C, 我的  &lt;img src=&quot;http://www.zhihu.com/equation?tex=x+%3D+y+%2Bz&quot; alt=&quot;x = y +z&quot; eeimg=&quot;1&quot;&gt; 比特币来源于早前的 block K 交易 T。&lt;/blockquote&gt;&lt;p&gt;这里假设的情形是: 作为一个用户A， 我需要向两个用户B,C转账。&lt;/p&gt;&lt;p&gt;最重要的步骤是， 我需要通过一个身份验证， 来证明我确实拥有block K 交易 T 的比特币的所有权。比特币里是这样实现所有权验证的: 假设在上个月 block K的交易Ｔ中， 用户D转给了我 &lt;img src=&quot;http://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 比特币。为了保证只有我可以动用这笔金额，D会在交易内容中加入一个数字签名验证函数，确保只有我可以通过这个验证。&lt;/p&gt;&lt;p&gt;然后我需要提供 B,C 的地址。当然这里提到的地址不是B,C的家庭住址，而是他们的公钥。 同时，我还需要确定转账金额。 在最后一步, 我要对整个交易内容进行数字签名。现在交易（在我的电脑上是一个字符串）已经生成成功，可以发送到比特币公网上去了！回忆结束~~~~&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;Zcash上的铸币交易可以采取如下的形式: 我们假设用户A需要把面值为v的比特币转化成ZEC。A会首先随机生成三个字符串 &lt;img src=&quot;http://www.zhihu.com/equation?tex=r%2C+s%2C+%5Crho&quot; alt=&quot;r, s, \rho&quot; eeimg=&quot;1&quot;&gt;，然后使用一个commitment scheme来计算两个字符串 cm 和 sn，细节如下图。&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;http://pic2.zhimg.com/v2-60edf78a04f6f353bee8d4156f853985_b.png&quot; data-rawwidth=&quot;383&quot; data-rawheight=&quot;295&quot; class=&quot;content_image&quot; width=&quot;383&quot;&gt;&lt;p&gt;(图片来自Zerocash: Decentralized Anonymous Payments from Bitcoin)&lt;/p&gt;&lt;br&gt;&lt;p&gt;所以ZEC币是完全数字化的，一枚币只不过是一个向量  &lt;img src=&quot;http://www.zhihu.com/equation?tex=%28a_%7Bpk%7D%2C+v%2C+r%2C+s%2C+%5Crho%2C+cm%2C+sn%29&quot; alt=&quot;(a_{pk}, v, r, s, \rho, cm, sn)&quot; eeimg=&quot;1&quot;&gt;。其中 &lt;img src=&quot;http://www.zhihu.com/equation?tex=v&quot; alt=&quot;v&quot; eeimg=&quot;1&quot;&gt; 是这枚ZEC的面值，而cm, sn是用于记录ZEC币的生成和消费历史的，在下面我们还会再次回到这两个重要的数值。&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;然后 A 在比特币的公网上公开如下的交易内容: &lt;/p&gt;&lt;blockquote&gt;A: 我需要用v比特币来铸造金额为v的ZEC, 我的commitment是cm, 我的&lt;img src=&quot;http://www.zhihu.com/equation?tex=v&quot; alt=&quot;v&quot; eeimg=&quot;1&quot;&gt;比特币来源于比特币账本上的第K个block的第T个交易。&lt;/blockquote&gt;&lt;br&gt;&lt;p&gt;注意：这里A仅仅公开了自己的cm和v, 而ZEC的其他信息只有A自己才知道。&lt;/p&gt;&lt;br&gt;&lt;h2&gt;Pour交易&lt;/h2&gt;Okay! 现在我们已经成功地铸造了一枚ZEC。然而新的问题也随之而来：怎么花掉它呢！？！？这就要转到Pour交易了。Pour是Zcash的核心创新， 可以说他是Zcash和比特币的本质区别。Pour的基本功能是：摧毁一个ZEC, 创造两个新ZEC, 满足&lt;b&gt;金额守恒条件&lt;/b&gt;：&lt;blockquote&gt;两个新ZEC的面值之和 = 输入的ZEC的面值。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这两个新ZEC币可以被匿名收款人接收，而且（！）在交易中的所有数额都对公网保密。&lt;/p&gt;&lt;p&gt;那么Pour是如何实现的呢？ 我们用一个实际生活中的情况来举例说明。还记得在Mint中我得到了一个面值为 &lt;img src=&quot;http://www.zhihu.com/equation?tex=v&quot; alt=&quot;v&quot; eeimg=&quot;1&quot;&gt;的ZEC吗？假设我到SF市参加密码学会议，在一个当地的支持ZEC的咖啡馆买了一杯咖啡：假设咖啡的价格为&lt;img src=&quot;http://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; ZEC, 那么我需要在交易中付给咖啡店 &lt;img src=&quot;http://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; , 并且付给自己 &lt;img src=&quot;http://www.zhihu.com/equation?tex=v+-+y&quot; alt=&quot;v - y&quot; eeimg=&quot;1&quot;&gt; (找回的钱）。从我原有的ZEC开始：&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;http://www.zhihu.com/equation?tex=%7B%5Cbf+c%7D+%3D+%28a_%7Bpk%7D%2C+v%2C+r%2C+s%2C+%5Crho%2C+cm%2C+sn%29&quot; alt=&quot;{\bf c} = (a_{pk}, v, r, s, \rho, cm, sn)&quot; eeimg=&quot;1&quot;&gt;&lt;br&gt;&lt;p&gt;首先我需要向咖啡店小哥问到他们的地址&lt;img src=&quot;http://www.zhihu.com/equation?tex=b_%7Bpk%7D&quot; alt=&quot;b_{pk}&quot; eeimg=&quot;1&quot;&gt;，然后我用和铸币相似的手段，生成两个新币&lt;/p&gt;&lt;img src=&quot;http://www.zhihu.com/equation?tex=%7B%5Cbf+c_1%7D+%3D+%28b_%7Bpk%7D%2C+y+%2C+%5Crho_1%2C+r_1%2Cs_1%2C+cm_1%29%0A%0A&quot; alt=&quot;{\bf c_1} = (b_{pk}, y , \rho_1, r_1,s_1, cm_1)

&quot; eeimg=&quot;1&quot;&gt;&lt;br&gt;&lt;p&gt;（这个币将会转给咖啡店）&lt;/p&gt;&lt;p&gt;和 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%7B%5Cbf+c_2%7D+%3D+%28a_%7Bpk%7D%2C+v-+y%2C+%5Crho_2%2C+r_2%2C+s_2%2C+cm_2%29&quot; alt=&quot;{\bf c_2} = (a_{pk}, v- y, \rho_2, r_2, s_2, cm_2)&quot; eeimg=&quot;1&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;（这个币找给自己）。&lt;/p&gt;&lt;p&gt;虽然这两个新币和&lt;img src=&quot;http://www.zhihu.com/equation?tex=%7B%5Cbf+c%7D&quot; alt=&quot;{\bf c}&quot; eeimg=&quot;1&quot;&gt;看起来十分相似，但它们之间有着本质区别的～～&lt;/p&gt;&lt;br&gt;&lt;p&gt;这个区别在于对币&lt;img src=&quot;http://www.zhihu.com/equation?tex=%7B%5Cbf+c_1%7D&quot; alt=&quot;{\bf c_1}&quot; eeimg=&quot;1&quot;&gt;和&lt;img src=&quot;http://www.zhihu.com/equation?tex=%7B%5Cbf+c_2%7D&quot; alt=&quot;{\bf c_2}&quot; eeimg=&quot;1&quot;&gt;, 序列号sn不见了! 我们实际上来到了理解Pour交易的第一个关键点：先回忆一下这个“序列号”是怎么计算出来的：&lt;/p&gt;&lt;img src=&quot;http://www.zhihu.com/equation?tex=sn+%3D+PRF%28a_%7Bsk%7D%2C+%5Crho%29&quot; alt=&quot;sn = PRF(a_{sk}, \rho)&quot; eeimg=&quot;1&quot;&gt;&lt;br&gt;&lt;p&gt;（这里PRF是一个给定的伪随机函数）。现在我们就能看出来，要计算这个序列号，需要两项&lt;/p&gt;&lt;p&gt;信息：第一项是ZEC生成的时候选取的随机数 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Crho&quot; alt=&quot;\rho&quot; eeimg=&quot;1&quot;&gt; , 第二项是&lt;b&gt;收款人的地址密钥&lt;/b&gt;。由于Zcash的设计，在使用任何一枚币的时候是需要出示序列号的。 所以除了收款人本人以外，任何人都无法出示正确的序列号，也就无法使用！&lt;/p&gt;&lt;p&gt;那么细心的各位肯定要问了：收款人虽然有密钥&lt;img src=&quot;http://www.zhihu.com/equation?tex=a_%7Bsk%7D&quot; alt=&quot;a_{sk}&quot; eeimg=&quot;1&quot;&gt; , 但是 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Crho&quot; alt=&quot;\rho&quot; eeimg=&quot;1&quot;&gt; 在付款人手中啊，这样岂不是谁都花不了这笔钱？确实是这样。所以付款人还要把 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Crho&quot; alt=&quot;\rho&quot; eeimg=&quot;1&quot;&gt; 用一种可靠的途径发给收款人。这个发送的方式就多种多样了：可以在用加密的电子邮件传送，或者可以面对面传递小纸条，... &lt;/p&gt;&lt;p&gt;然后我将如下交易信息发送到公网上:  &lt;img src=&quot;http://www.zhihu.com/equation?tex=TX_%7Bpour%7D+%3D+%28sn%2C+cm_1%2C+cm_2%2C+%5Cpi%29.&quot; alt=&quot;TX_{pour} = (sn, cm_1, cm_2, \pi).&quot; eeimg=&quot;1&quot;&gt; 这里注意：我需要向所有人出示自己的序列号sn（证明我确实是币&lt;img src=&quot;http://www.zhihu.com/equation?tex=%7B%5Cbf+c%7D&quot; alt=&quot;{\bf c}&quot; eeimg=&quot;1&quot;&gt;的所有人),  以及生成两个新币的Commitments。那么最后的这个&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cpi&quot; alt=&quot;\pi&quot; eeimg=&quot;1&quot;&gt;是什么呢？它是一个确保我在整个交易过程中的计算诚实可靠的 --- &lt;b&gt;零知识证明。 &lt;/b&gt;关于这个零知识证明是什么？它又怎么样确保我没有在交易中作弊（比如确保我有足够多的钱来完成这笔交易, i.e., &lt;img src=&quot;http://www.zhihu.com/equation?tex=v+%5Cgeq+y&quot; alt=&quot;v \geq y&quot; eeimg=&quot;1&quot;&gt;) ? 请期待下回分解～&lt;/p&gt;&lt;p&gt;（题图来自 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//z.cash/blog/transaction-linkability.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Zcash blog&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; )&lt;/p&gt;</description>
<author>东天阳</author>
<guid isPermaLink="false">2017-02-14-25168970</guid>
<pubDate>Tue, 14 Feb 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
