<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>深入浅出zkSNARKs-Part4</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/56338053">原文</a></p>
<p><b>QSP问题的SNARK</b></p><p>请记住，在QSP中，我们给出多项式v 0，...，v m，w 0，...，w m，目标多项式t（最高阶为d）和二进制输入字符串u。证明者找到a1，...，am ， b 1，...，b m（这些值都取决于u）和多项式h使得</p><p>th =（v 0 + a 1 v 1 + ... + a m v m）（w 0 + b 1 w 1 + ... + b m w m）。</p><p>在上一节中，我们已经解释了CRS如何生成。现在我们选择一个秘密号码s和α并公布公布出来：</p><p>E（S 0），E（S 1），...，E（S d）和E（αS 0），E（αS 1），...，E（αS d）</p><p>因为我们没有单个多项式，而是针对问题这一列多项式是固定的，我们需要把推出的多项式公布出来</p><p>E（t（s）），E（αt（s）），</p><p>E（V 0（S）），...，E（V m（S）），E（αv 0（S）），...，E（αv m（S）），</p><p>E（w0（S）），...，E（wm（S）），E（αw0（S）），...，E（αwm（S）），</p><p>我们还需要之后用的的秘密数字β v，β w ，γ（它们会被用来验那些多项式是推算出来的，而不是任意的多项式），然后把它们公布出来：</p><p>E（γ），E（β v γ），E（β w ^γ）</p><p>E（βv V 1（S）），...，E（βv V m（S））</p><p>E（βw W1（S）），...，E（βw Wm（S））</p><p>E（βv t（S）），E（βw t（S））</p><p>这是完整的CRS(公共引用字符串)。在实际实现中，CRS的一些元素并不是必须的，但这会使表达式复杂化。</p><p>现在证明者还需要做什么？她使用上面解释的还原函数来找到多项式h和值a 1，...，a m， b 1，...，b m。这里有一点非常重要，就是要使用一个 witness-preserving reduction（见上文）因为只有这样，值a 1，...，a m， b 1，...，b m可以与reduction一起计算出来，否则将会非常非常困难。为了描述证明者作为证据发送给验证者的内容，我们必须回到QSP的定义。</p><p>这里有一个限制  a 1，...，a m， b 1，...，b m这些值的单射函数 f：{（i，j）| 1≤i≤n，j∈{0,1}}→{1，...，m} 。因为相对来说 m 是比较大的，所以对于任何输入，函数 f 的输出的都不会包含这些数字。而这些下标没有被限制，然后基于Ifree中的所有下标 k 定义Vfree（X）=Σ ķaķ v ķ（X）， 。对于等式w（x）= b 1 w 1（x）+ ... + b m w m（x） 来说，我们的证明将由下面的式子构成：</p><p>V free：= E（V free（s）），W：= E（w（s）），H：= E（h（s）），</p><p>V' free ：= E（αvfree(s))，W'：= E（αw（s）），H'：= E（αh（s）），</p><p>Y：= E（βv V free （S）+βww（S）））</p><p>最后一个等式用来检验是否使用了正确的多项式（这一部分还没有讲到，不过其他的例子会说到它）。要注意的是，我们所有的加密值，证明者只需要知道 CRS 就可以全部推算出来。</p><p>验证者还要做的有：</p><p>由于k的值（其中k不是“free”下标）可以直接从输入u计算（验证者也知道，这是要验证的值），验证者可以通过v计算出总和：</p><p>E（V’free（S））= E（Σ ķak v ķ（S）），其中k的范围在所有索引不是Ifree。</p><p>有了这个，验证者现在使用配对函数e确认以下等式（不要害怕）：</p><p>e（V ' free，g）= E（V free，gα）=，e（W'，E（1））= e（W，E（α）），e（H’，E（1））= e（H，E（α））</p><p>e（E（γ），Y）= e（E（βv γ），V free）e（E（β w γ），W）</p><p>e（E（v 0（s））E（v in（s））V free，E（w 0（s））W）= e（H，E（t（s）））</p><p>要了解这里关键概念的知识，你必须要知道配对函数是允许我们在加密信息上进行一些有限的计算的：首先我们可以使用任意多次的加法，但是不能使用乘法。其次这个加法是来自加密方法本身的加同态，乘法则是通过配对函数的两个参数来实现的。所以  e（W'，E（1））= e（W，E（α））基本上就是在加密空间中用 1 乘以 W’，然后和α乘以 W 做比较。回想一下上面的定义你就会发现 W 和 W’ 应该就是 E(w(s)) 和 E(α w(s)),如果证明者提供的是正确的证明.</p><p>如果你还记得上面关于如何在一个私密点上推算多项式的话，这三个首先要检查的点基本上就可以确认证明者确实知道一些用 CRS 中的部分构造的多项式。第二个条目往往是用来确保证明者使用的是正确的多项式 v 和 w，而不是任意的多项式。而它背后的逻辑则是除了从E(vfree(s)和E)w(s))中获取精确的值之外，证明者没办法计算出加密组合E（βvvfree（S）+βw w（S）））。因为 βv在 CRS 中是隔离的，并不是 CRS 中的一部分，只有在和多项式 w k（s） 组合起来的时候才知道w k（s） 的值。而将它们“混合”起来的唯一方法则是通过同样的加密 γ。</p><p>假设证明者提供了正确的证明，那么让我们检查一下是否正确。左边和右边分别是</p><p>e（E（γ），Y）= e（E（γ），E（β v vfree（S）+βww（S）））= e（g，g）γ（β v vfree（S ）+βw W（S））</p><p>e（E（β v γ），Vfree）e（E（βw γ），W）= e（E（β v γ），E（vfree（S）））e（E（βw γ） ，E（W（S）））= e（g，g）（β v γ）vfree（S） e（g，g）（β w γ）W（S） = e（g，g）γ（ βvVfree（S）+βw W（S））</p><p>第三项基本上就是检查了（v 0（s）+ a 1 v 1（s）+ ... + a m v m（s））（w 0（s）+ b 1 w 1（s）+ ... + b m w m（s））= h（s）t（s），这也是QSP问题的主要条件。需要注意的是，要将加密值的乘法转换为未加密值的加法，因为E（x）E（y）= g x g y = g x + y = E（x + y）。</p><p><b>添加零知识</b></p><p>正如我在开始时所说的，关于zkSNARKS的显着特征是简洁而不是零知识部分。我们现在将看到如何添加零知识，下一节将简要介绍一下简洁性。</p><p>这个想法就是证明者现在通过一个随机私密的值来进行“移位”，然后再在其他的等式中“移位回来”以取得平衡。证明者会选择 δfree，δ w ，然后在证明中执行下面的替换：</p><p>用 Vfree(s)+δfree t(s)来替换 Vfree(s)</p><p>用w(s)+δw t(s )来替换  w(s)</p><p>通过这两个替换， Vfree 和 W 这两个包含 witness 因子编码的值基本上就变成了无法区别的随机值，因此要从 witness 中提取出来也不可能。大部分的等式检验对修改都是『免疫』的，而我们要确保正确的值就是 H 或者说是 h(s)。那我们就要确保<i>：</i></p><p>（v 0（s）+ a 1 v 1（s）+ ... + a m v m（s））（w 0（s）+ b 1 w 1（s）+ ... + b m w m（s））= h（s）t（s），或换句话说</p><p>（v 0（s）+ v in（s）+ v free（s））（w 0（s）+ w（s））= h（s）t（s）</p><p>这两个等式成立。通过修改，我们得到了</p><p>（V 0（S）+ V in（S）+ V free（S）+δfree t(S))（W 0（s）+ W（s）+δw t（S））</p><p>然后将结果展开，我们看到用h替换h（s）</p><p>h（S）+δfree（W 0（s）+ W（s））+δw（V 0（S）+ Vin（S）+ Vfree（S））+（δfreeδw）t（s）</p><p>。</p><p>在输入和 Witness 大小之间取一个折中的值</p><p>就像你在上面这些小节中看到的一样，我们的证明由一个群（就是一个椭圆曲线）的 7 个元素组成。而且验证者的工作就是检验一些配对函数的等式是否成立以及计算 E(Vin(s)) 这样一个跟随输入大小的线性任务。最主要的是，在这个验证过程中，既不需要  witness 字符串的大小，又不需要计算工作量来验证 QSP（没有 SNARKs）。这就意味着 SNARKs 的校验是个很复杂的问题，而简单的问题往往都是一样的。造成这个结果的主要原因则是，因为我们只在一个单独的点上面检验了多项式的一致性，而不是全部的点。多项式可以变的非常非常复杂，但是一个点始终是一个点。而唯一能影响到验证结果的参数就是安全性的等级（比如群的大小）和输入值的最大尺寸。</p><p>减小第二个参数是可行的，将输入值的一部分移动到 witness 中：</p><p>我们不验证函数 f(u, w)，u 是输入，w 是 witness，而是做一次 hash，然后验证：</p><p>f'（H，（u，w））：= f（u，w）∧h（u）= H</p><p>这样就意味着我们可以用一个 hash 来代表输入 h(u) 了（这样就会变的更短），除了验证 f(x, w)，我们还需要验证某个值 x 的 hash 等于 H(u)（这样的话，那 x 极有可能就等于 u 了）。这样就将原始输入 u 移动到 witness 字符串中了，这样虽然会增大 witness 的大小，但是输入值的大小就减小为一个常数了。</p><p>这是非常了不起的，因为它允许我们在恒定时间内验证任意复杂的语句。</p><p><b>这与以太坊有什么关系？</b></p><p>因为验证计算是以太坊区块链的核心，所zkSNARK和以太坊关系紧密相连。有 zkSNARKs，我们不但可以完成任何人都可证实的私密的计算，而且还可以高效的完成。</p><p>虽然以太坊使用了一个图灵完备的虚拟机，但目前还无法在以太坊中实现zkSNARK验证。验证者任务在概念上看似简单，但配对函数实际上很难计算，而且在单个区块中还会消耗更多的 gas。椭圆曲线乘法已经相对复杂，而配对函数将这个复杂度又增加了一个级别。</p><p>像zCash这样的现有zkSNARK系统对每个任务都使用相同的问题/电路/计算。在zCash里，它是交易验证。在以太坊上，zkSNARKs不会局限于单一的计算问题，而是让所有的人都能够在不发布一个新的区块链的情况下构建他们自己的 zkSNARK 系统。添加到以太坊的每个新zkSNARK系统都需要一个新的私密的可信任的准备阶段（某些部分可以重复使用，但不是全部），即必须生成新的CRS。也可以为“通用虚拟机”添加zkSNARK系统。这样的话当你使用一个新的实例时，你就不需要重新设置了，因为你将不再需要为以太坊上新的智能合约发布一个新的区块链。</p><p><b>将zkSNARKs结合到以太坊上</b></p><p>有多种方法可以为以太坊启用zkSNARK。所有这些都降低了配对函数和椭圆曲线操作的实际成本（其他所需的操作已经足够便宜），因此也可以降低这些操作的gas。</p><p>1.提高（保证）EVM的性能</p><p>2.仅针对某些配对函数和椭圆曲线乘法提高EVM的性能</p><p>第一种选择当然是从长远来看更好的回报，但更难实现。我们目前正致力于为EVM添加功能和限制，如这将更好的支持即时编译和在现存实现下最小改动的解释器的实现，而无需在现有实现中进行太多必需的更改。另一种可能性是完全换掉EVM并使用类似eWASM的东西。</p><p>第二个选项可以通过强制所有以太坊客户端执行现某个确定的配对函数和确定的椭圆曲线上的乘法作为所谓的预编译合约来实现。这样做的好处是可能更容易和更快地实现，缺点是我们固定在确定的配对函数和确定的椭圆曲线上。以太坊的任何新客户都必须重新实施这些预编译合约。此外，如果有什么新的进展并且有人找到更好的zkSNARK，更好的配对函数或更好的椭圆曲线，或者如果在椭圆曲线，配对函数或zkSNARK中发现缺陷，我们将不得不添加新的预编译合约。</p><p>全文结束。。。。。</p><p><br></p><p><br></p><p><br></p><p>===============================================================</p><p><b>文章首发在微信公众号：btc201800</b></p><p><b><a href="http://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">weixin.qq.com/r/GC8UDDj</span><span class="invisible">EjmXxrXxv93oK</span><span class="ellipsis"></span></a>(二维码自动识别)</b></p><p><b>音频发布在喜马拉雅上“区块链杂谈 (第2季)“</b></p><p><b>宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。</b></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
