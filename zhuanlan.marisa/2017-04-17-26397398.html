<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>给 Haskell 用家的 Idris 入坑指南</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/26397398">原文</a></p>
<ol><li>没有 Cabal 或者 Stack 这样的包管理器，也没有 Idris Platform 之类的东西，到官网下二进制包解压完就可以了。</li><li>然而，Idris 确实有「包描述文件」ipkg。安装网上的包的话，你需要把包下载下来，然后运行 idris --install xxx.ipkg。<br></li><li>你几乎不需要开扩展——因为自带的功能已经够多了……扩展几乎是只牵涉到 ER 元编程、DSL Notation 等少数几个高级特性。</li><li>Idris 默认是严格求值的，不过可以用 <b>Lazy</b> 类型实现惰性求值。这个类型是特殊实现的，会自动加上隐式转换。</li><li>Idris 和 Haskell 里面 <b>:</b> 和 <b>::</b> 的用法正好相反。<b>:</b> 用于声明，<b>::</b> 用于数组连接。表达式中的「卡类型」不用 <b>(x : t)</b> 而是用 <b>the</b> 函数：<b>the t x</b>。<br></li><li>Idris 的顶层函数必须写类型声明，而且和 C/C++ 一样，必须先声明再使用。相互递归的话用 <b>mutual</b> 块。</li><li>对 data，构造器和类型名字不能相同。Edwin 的惯例是用 Mk 前缀，我习惯用 New 前缀。</li><li><b>String</b> 是个原始类型，不是 <b>List Char</b>。可以使用 <b>unpack</b> 函数将 <b>String</b> 转换为 <b>List Char</b>，用 <b>pack</b> 转换回来。<br></li><li>用 <b>[]</b> 去围类型来代表 <b>List</b> 的语法糖是没有的，需要完整写 <b>List a</b>。不过，<b>Pair</b>、<b>Unit</b> 的语法糖仍然存在。（虽然……我用 <b>Pair</b> 和 <b>Either</b> 之前铁定会弄俩运算符 <b>/\</b> 和 <b>\/</b>。）</li><li>Idris 的 Type class 叫做接口（Interface），对应的实例叫做实现（Implementation）。接口的方法中什么都可以放，包括次级类型。（不过这么做很容易造成编译的时候推不出来就是了……）<br></li><li>由于箭头是 Binder，因此 Idris 的「<b>-&gt;</b>」不是一个正常的类型构造符，也无法实现接口。对于非依赖的函数，<b>Data.Morphism</b> 中定义了 <b>Morphism</b> 类型（符号是 <b>~&gt;</b>），可以像 Haskell 中的 <b>(-&gt;)</b> 那样实现接口。</li><li>Idris 允许对于名称的直接重载，像 <b>(::)</b> 就被重载过（<b>Vect.(::)</b>, <b>List.(::)</b>, <b>Stream.(::)</b>）。有时候可能需要显式消歧义来处理推不出来的情况。</li><li>Idris 中的 <b>head</b>、<b>index</b> 是不能随便用的，它们的签名中有一个命题项 <b><i>ok</i></b>，你得说服编译器「数组不空」或者「没有越界」。如果不想去哄编译器的话，可以用 <b>head'</b> 和 <b>index'</b>，它们返回一个 <b>Maybe</b>。</li><li>没有 <b>fmap</b>、<b>return </b>和 <b>mapM</b>，用 <b>map</b>、<b>pure </b>和 <b>traverse</b>。</li><li>Haskell 里 <b>Data.Map</b> 对应物是 contrib 包中的 <b>Data.SortedMap</b>，用平衡树实现的。</li><li>因为有 Dependent Type 所以不需要用 <b>Pair </b>做「链表」模拟 <b>Nat</b>。（这条是说给 <a href="http://www.zhihu.com/people/0251012c87c2d3f56ac34de7d71cdcbc" data-hash="0251012c87c2d3f56ac34de7d71cdcbc" class="member_mention" data-editable="true" data-title="@帅气可爱魔理沙" data-hovercard="p$b$0251012c87c2d3f56ac34de7d71cdcbc">@帅气可爱魔理沙</a> 听的。）</li><li>deriving 的功能目前由 Elaborator Reflection 元编程实现：<a href="https://github.com/david-christiansen/derive-all-the-instances" data-editable="true" data-title="david-christiansen/derive-all-the-instances" class="">derive-all-the-instances</a>。使用的时候需要开启 <b>ElabReflection</b> 扩展。</li><li>Idris 默认的导出规则是 <b>private</b>，因此当你需要导出函数的时候请用 <b>export</b>；导出 <b>data</b>、<b>interface</b> 的时候请用 <b>public export</b>。<b>export</b> 和 <b>public export</b> 的区别是，前者只导出其类型，后者会连同定义一起导出。对于类型别名来说，仅仅以 <b>export</b> 导出会导致使用这个别名的模块无法把它和它的本体联系起来。</li><li>Haskell 里面的 Guard Pattern 在 Idris 里面可以用 <b>with</b> 实现。</li><li>尽管写证明很美好，不过测试框架还是很有意义的：Idris 中你可以在 ipkg 文件中声明代表测试的模块，然后 <b>idris --testpkg xxx.pkg</b> 会运行这些模块导出的函数进行测试。可以使用 <a href="https://github.com/david-christiansen/idris-quickcheck" data-editable="true" data-title="david-christiansen/idris-quickcheck" class="">david-christiansen/idris-quickcheck</a> 等模块辅助测试。</li><li>尽管 Idris 有一个 JS 的后端，也有人写了 JavaScript 的 Binding（<a href="https://github.com/idris-hackers/IdrisScript" data-editable="true" data-title="idris-hackers/IdrisScript">IdrisScript</a>），不过这个后端也只是能运行罢了……</li><li>网上很多 Idris 编辑器支持的语法文件都停留在几年前（那个没有 <b>rewrite</b>、<b>interface</b> 还叫 <b>class</b> 的年代）。然而 VSCode 的插件——vscode-idris 里面的语法是对的。<b>因为是我改的。</b></li><li><b>最后，Idris 里有我的代码，在 RTS 里面。</b></li></ol>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
