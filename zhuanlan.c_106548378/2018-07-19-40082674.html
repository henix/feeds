<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>策略||遗传算法</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/40082674">原文</a></p>
<p>通常所说的量化交易，是指使用大量的指标和操作的组合，来定义买/卖操作规则。除了决定使用哪些指标，更重要的是为指标设置正确的参数。</p><p>一个简化的例子（<b>随机写的，请勿作为投资参考</b>）：选择 300成份股 + 市值小于150亿 + 去年分红 + 最近半年有回购行为 的股票。我们可以把不同指标扩展到成千上万个，根据参数做出投资决策。</p><p><br></p><p>为参数寻找最优解的问题，梯度下降法（常用于深度学习）是一个很好的解决方案。但有些时候1、问题有多个局部最优解；2、错误函数不平滑；这时梯度下降算法就不能很好工作。这里我们介绍遗传算法，用来为市场指标的参数找到最优解。</p><p><br></p><p>遗传算法是受物种进化和自然选择启发得到的优化方法。它是一个“古老”的算法，并且在上个世纪就有人尝试应用于金融市场研究。严格来说它不属于机器学习领域，但机器学习工程实际上可以在它的理论基础上来实现。</p><p><br></p><p>遗传算法过程如下:</p><p><b>- 初始化：</b>算法从初始化一个种群开始，可以完全随机生成。每种可能的解决方案 -- 例如每个种群中的个体—被称为染色体。</p><p><br></p><p><b>- 迭代过程：</b></p><p><b>*  交叉：</b>染色体被组合起来，产生一个新的种群。新一代种群中的每一条染色体都是它们祖先的基因（染色体由基因组成）交叉混合组成。</p><p><b>*  突变：</b>通常，还引入突变因子，目的是允许现有基因的特征有一些变化。</p><p><b>*  评估：</b>计算每个新染色体个体的适应值。</p><p>交叉迭代过程的理念是创建一个优于第一代种群的后代，因为只有<b>最合格的个体才能存活下来</b>。 这意味着我们将选择得到最佳结果的染色体作为下一代染色体的父染色体。</p><img src="https://pic3.zhimg.com/v2-1992c9e52486da53afed9fc9b01d2901_r.jpg" data-caption="" data-size="normal" data-rawwidth="356" data-rawheight="325" data-watermark="watermark" data-original-src="v2-1992c9e52486da53afed9fc9b01d2901" data-watermark-src="v2-c009722f801e96dd4f5c6cacbc823612" data-private-watermark-src=""><p><br></p><p><b>-  停止条件：</b>我们可以使用两三种不同的标准作为停止迭代过程的条件：</p><p>   *  群众中个体数量不再变化；</p><p>   *  获得满意的适应性水平。</p><p>   *  算法得到收敛。</p><p><br></p><p>我个人特别喜欢第一和第三个标准（除非时间极为有限，我会使用第二个标准)。</p><p><br></p><p>实现遗传算法实际上是一项简单的任务。最具挑战的部分是如何将我们的问题转化为“染色体”模型。 我们需要可以轻松转换、组合的变量，以及无需大量的内存的算法，那么遗传算法就会有效。</p><p><br></p><p><b>伪算法代码</b></p><p>以下代码是使用Python语法的遗传算法实施的简单示例，其中：</p><p>max_iter：是算法停止前允许的最大迭代次数。</p><p>n_repeats：是允许所有过程中的最佳适应度比通常总体达到的最佳适应度差的最大迭代次数。 这是用来控制方法的收敛程度的简单方法: 如果我们不使用这种方法，当算法已经停在局部最优时，我们还在花时间执行代码。</p><p>N：是在每次迭代中被选择成为下一代父染色体的个体数量。</p><p><br></p><p>i=0 </p><p>fitness = 0 </p><p>counter = 0 </p><p>while i &lt; max_iter: </p><p>   if counter &gt; n_repeats: </p><p>      STOP </p><p>   Y = [ ]</p><p>   fit = [ ] </p><p>   pairs = randompairsfrom (X) </p><p>   for j in pairs: </p><p>      y = crossover ( j )</p><p>      y = randommutation ( y )</p><p>      Y. append (y)</p><p>      fit.append (fitness(y))</p><p>   Y, fit = ordermaxtomin (Y, fit ) </p><p>   bestfitness = fit[ 0 ]</p><p>   if bestfitness &lt; fitness: </p><p>      counter = counter+1</p><p>   else: </p><p>      counter = 0</p><p>      X = Y [0: N] </p><p>      i=i+1 </p><p>      fitness = bestfitness</p><p><br></p><p><b>改进</b><br></p><p>另外一点需要重点考虑到，如上所述，由于遗传算法是一种优化方法，因此很容易得到问题的局部最优值。当发生这种情况时，很难进一步发展并且找到问题的另一最优值 。 为了强制算法“跳出”局部最优，我们可以做的一件事是改变“选择过程”。</p><p><br></p><p>当算法“正常工作”时，我们从由上一代和新一代形成的组合中选择更好的基因。 如果我们发现算法“结果不理想” – 产生了一些迭代之后，最好的适应度没有变得更好 -- 我们就要做一个“强行跳跃”，具体做法是对最后的那一代基因不进行最优选择，然后继续迭代。当然，这样做，当前最优适应度会比上一代差，但是通过改变父亲一代，能让我们跳出当前局部最优，从而找到一套不同的解决方案（我们希望比其他的更好）。</p><p><br></p><p><b>应用</b></p><p>现在你已经知道遗传算法的基本思路了。</p><p>下一步是决定如何将市场指标的参数的映射为对应的染色体。如果我们决定使用一种通用的方法来做转换，那就意味着我们能使用相同的遗传算法来优化多个不同的指标参数。</p><p><br></p><p>还是文章开头的极简例子，如果我们对多个指标进行0、1编码，1表示选中，0表示剔除。那么指标模型就是类似 01110001110001111001 这样的“基因”字符串。通过遗传算法得到的历史数据适应性最佳字符串，就是我们想要的策略了。</p><p><br></p><p>思考1：</p><p>使用遗传算法寻找到市场指标（在时间序列上）的最优参数，有什么好处，又有什么缺点？</p><p>遗传算法的优点是不用花太多的时间找到交易模型的有益参数。缺点也很清楚：使用优化方法的最大风险是过度拟合。算法只能拟合历史数据，在未来的博弈中未必有效。</p><p><br></p><p>继续思考2：如果我们设计一种算法机制，能够检测出当前交易模型的参数不再有良好回报，然后再找到适合当前市场约束条件其它算法，会如何？</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
