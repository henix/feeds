<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>数据安全、隐私保护与密码学技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/</link>
<description>本专栏主要发布如下内容： 1. 国际黑帽子大会（… 本专栏主要发布如下内容： 1. 国际黑帽子大会（Black Hat），国际黑客大会（Def Con）上的演讲内容分析； 2. 密码学、网络安全相关的源代码分析； 3. 密码学、网络安全相关的知识介绍； 4. 业内可公开的安全架构思想； 5. 其他与信息安全相关的内容或转载文章； 欢迎投稿，欢迎指出任何错误~ 希望我们能够一起为普及、分享、研究信息安全相关理论和知识贡献自己的一份力量！</description>
<language>zh-cn</language>
<lastBuildDate>Sun, 06 Oct 2019 19:42:19 +0800</lastBuildDate>
<item>
<title>传输短秘密值的条件下提高OT扩展协议的效率</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-04-76647738.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/76647738&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7b01b1ba136277a4576b00ee4b38443b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;最近收到了一位知友的私信，询问能否把《Winter School on Cryptography 2012: Lattice-Based Cryptography》的一系列字幕也发布出来，供参考和学习。经过与 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b&quot; data-hash=&quot;60a93d8892402f3493146a4fd54c5f2b&quot; data-hovercard=&quot;p$b$60a93d8892402f3493146a4fd54c5f2b&quot;&gt;@i春秋学院&lt;/a&gt; 当时字幕负责人的讨论，由于相关字幕已经发布了很长时间，我已经可以将字幕发布出来供知友们学习了！因此，在接下来一段时间，我会集中整理《Winter School on Cryptography 2012: Lattice-Based Cryptography》的字幕，重新压制视频并放出。感谢 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b&quot; data-hash=&quot;60a93d8892402f3493146a4fd54c5f2b&quot; data-hovercard=&quot;p$b$60a93d8892402f3493146a4fd54c5f2b&quot;&gt;@i春秋学院&lt;/a&gt; 一直以来的支持！&lt;/p&gt;&lt;p&gt;虽然会集中整理之前的字幕，但是我也会不断听写新的视频，如果有任何顶级安全会议中数据安全相关讲座的听译需求，还请知友们私信我，或者直接在评论区留言。对于一些很大工作量的听译工作（如《Winter School on Cryptography 2015: Practical Secure Multi-Party Computation》这类），我也会持续坚持听译，到合适的时间再对外发布，敬请知友们耐心等待。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为知友们带来的视频是CRYPTO 2013论文《Improved OT Extension for Transferring Short Secrets》。OT Extension协议是安全多方计算中最重要、也是最核心的协议。熟悉OT的知友们可能知道，OT Extension中最核心的论文应该是CRYPTO 2003的《Extending Oblivious Transfer Efficiently》以及CCS 2013的《More Efficient Oblivious Transfer and Extensions for Faster Secure Computation》。不过我一直没有找到这两个讲座的视频，如果哪位知友知道视频链接，也可以在评论区告诉我。&lt;/p&gt;&lt;p&gt;《Improved OT Extension for Transferring Short Secrets》的重要程度相对这两篇论文来说没有那么高，但这篇论文是优化GMW协议的重要理论基础。如果想实现基于GMW协议的安全多方计算应用，这篇论文的阅读和实现也是必不可少的。CRYPTO 2013对应的演讲视频介绍了《Improved OT Extension for Transferring Short Secrets》的基本思想，观看视频后再去读论文会有更深入的理解。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//eprint.iacr.org/2013/491.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2013/49&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;1.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;视频链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DAgPZVecLuXs&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=AgPZVecLuXs&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av62237491/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av62&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;237491/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/CRYPTO%25202013/Improved%2520OT%2520Extension%2520for%2520Transferring%2520Short%2520Secrets&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/CRYPTO%202013/Improved%20OT%20Extension%20for%20Transferring%20Short%20Secrets&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1141506723897516032&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png&quot; data-lens-id=&quot;1141506723897516032&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1141506723897516032&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢主持人的介绍。此工作是我与来自贝尔实验室的Vladimir Kalashnikov所共同完成的。我们工作针对的目标是安全计算，这是密码学上一个非常典型、非常普遍的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当前有很多重要的研究进展，尝试让安全计算从理论走向实际。这些工作的目标不仅是要提高协议的渐进效率，还要提高协议的真实执行效率。还有一些工作的方向是具体协议的实现，解决系统层面的问题。&lt;/p&gt;&lt;p&gt;在过去的5年，无论是理论角度还是实际角度，此领域都诞生了极多的突破性成果。从理论角度，我们得到了很多惊人的结论。我们现在只需要引入常数级额外开销，即可完成安全计算或安全函数求值。另一个突破是全同态加密。对于多种类型的函数，我们甚至可以在最优通信复杂度下构建安全计算协议。还可以使用基于ORAM的安全计算协议，利用RAM计算模型的优势完成安全计算，这样我们就能在次线性时间复杂度下完成安全计算。在实践角度，针对姚氏协议和GMW协议，学者们提出了很多算法或实现层面的优化，也尝试混合使用姚氏协议和GMW协议。特别地，姚氏协议的实现结果令人印象深刻。现在，我们可以在637毫秒内执行完AES的乱码电路。&lt;/p&gt;&lt;p&gt;虽然在实现层面和理论层面我们都得到了令人惊讶的成果，但在右侧，效率最高的协议仍然是20世纪80年代提出的姚氏协议和GMW协议。之所以这样，有一个很直观的原因：理论成果虽然引入常数复杂度，但这个常数可能非常大。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际应用时，可能存在这样一个复杂度与效率的层级关系。FHE的复杂度目前、以后也总会比公钥密码学原语的复杂度高几个量级。公钥密码学原语的复杂度目前、以后也总会比对称密码学原语的复杂度高几个量级。对称密码学原语的复杂度目前、以后也总会比一次一密的复杂度高几个量级。本次演讲的主题是OT扩展，其出发点就是减小公钥操作和对称密码操作的效率鸿沟。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在第一部分演讲中，我会详细介绍OT扩展的研究出发点，并解释OT扩展面临的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;诸如密钥协商、不经意传输等公钥密码学原语一般都很难高效实现。公钥密码学原语天生要依赖于某类代数结构，因此也会遭受很多密码学攻击。因此，相应的参数需要设置得比较大。这导致公钥密码学的计算复杂度也相对较高。另一方面，我们更容易实现伪随机数生成器或哈希函数等对称密码学运算。学者们设计出了很多算法，相应的参数要比公钥密码学小得多，实际中也可以更容易、更轻量级地实现对称密码学运算。这个结论背后还有相应的理论支撑。理论上，无法通过黑盒方式应用对称密码学原语构造大多数公钥密码学原语。这意味着公钥密码学原语和对称密码学原语的性能差约为3至4个数量级。对于诸如AES等被广泛使用的特定对称密码学操作，Intel专门提供了对应的指令集，进一步提高了这类运算的执行效率。因此，我们无法通过对称密码学原语实现公钥密码学原语。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那接下来该怎么办？或许可以用少量公钥原语实例和大量对称密码学操作，生成大量公钥实例。这一技术称为“扩展原语”。我们已经知道，很容易扩展公钥加密体制，具体过程是用对称加密算法加密具体的明文，用公钥加密算法加密对称加密的密钥。这样一来，我们只需要执行一次公钥操作。这一技术在我们每天使用的加密过程中起到了非常重要的作用。我们可以很自然地把这个问题展开：是否可以扩展其它公钥密码学原语。如OT？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;回忆一下不经意传输要解决的问题。发送方有两个输入： &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_0&quot; alt=&quot;x_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1&quot; alt=&quot;x_1&quot; eeimg=&quot;1&quot;/&gt; 。接收方有一个输入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。协议执行完毕后，发送方无法得到任何信息，接收方可以得到与其选择比特关联的发送方输入。OT是SFE的基础构建模块。姚氏电路中应用不经意传输实现了乱码密钥的2选1过程。在GMW协议中，OT的用途更加广泛，每个AND门的求值过程都要使用一次OT协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们知道OT的执行开销非常大，我们无法通过对称密码学操作实现OT。但假设我们有一个可以传输短字符串的OT，通过使用标准的伪随机数生成器，我们能得到可以传输长字符串的OT。这一技术称为“OT长度扩展”。&lt;/p&gt;&lt;p&gt;还有一个更难解决的问题，称为“OT实例扩展”，简称“OT扩展”。幸运的是，我们知道OT扩展是可行的。我们只需要 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个公钥密码学操作，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个种子OT，再加上 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 次对称密码学操作。应用这 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 次公钥密码学操作，我们就可以执行任意多项式大小次的OT操作。这一技术大幅降低了公钥密码学运算次数，对SFE的实际应用起到了重要的作用。近期大多数SFE的实现都应用了OT扩展协议，从而提高协议的执行效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Beaver在1996年提出了第一个OT扩展协议。第一个高效的OT扩展协议由Ishai、Kilian、Nissim和Petrank给出。此协议也称为IKNP协议，对应的论文发表在CRYPTO 2003上。后续，学者们期望在恶意攻击场景下提高OT扩展协议的执行效率。学者们同时也在加深对OT扩展协议的理解，从而知道OT扩展协议的上限是什么。在本工作中，我们将在半可信场景下提高IKNP协议的效率。我们给出了协议的渐进优化方法和实际优化方法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在接下来的讲座中，我们会描述Ishai等人的OT扩展协议构造。实际上，我们将直接使用Ishai等人CRYPTO 2003的演讲幻灯片。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;IKNP第一个、也是最重要的步骤是将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT归约为传输 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 比特字符串的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT。这一步骤将引入额外的、线性数量级的对称密码学操作。下一步是长度扩展步骤，我们之前已经讲解过这一步骤了。这可以让我们把长字符串OT协议归约为短字符串OT协议。这一步骤进一步引入了线性数量级的对称密码学操作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在核心归约步骤中，我们让接收方选择一个随机的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5Ctimes+k&quot; alt=&quot;n\times k&quot; eeimg=&quot;1&quot;/&gt; 矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 。随后，发送方选择一个随机的行向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;/&gt; 。接下来，接收方和发送方执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT协议，但此OT协议中两个参与方的角色互换。在每个OT协议中，接收方要选择长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 的两列比特值。每对比特值中。第一列为矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 中的某一列，第二列为第一列比特值与选择向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 的异或结果。发送方实际上应用它随机选择的行向量在接收方的两列比特值中选择一列。&lt;/p&gt;&lt;p&gt;这样，发送方通过OT协议得到了一个矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; 。我们来看看矩阵 Q 满足何种性质。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D0&quot; alt=&quot;r_i=0&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，收到的每对比特值就不太一样了。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，在IKNP协议中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i%5Coplus+s&quot; alt=&quot;q_i=t_i\oplus s&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;注意到，在第一种情况下，接收方知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+&quot; alt=&quot;t_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; 。因此，在第一种情况下，接收方能得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。在第二种情况下， 接收方能得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s+&quot; alt=&quot;q_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; ，也就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 。这意味着我们或许可以使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 作为OT协议中的数据加密密钥。但需要注意的是，我们必须要破坏矩阵中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的相互关系。我们应用随机预言机 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H&quot; alt=&quot;H&quot; eeimg=&quot;1&quot;/&gt; 来破坏 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的相互关系。最后，接收方根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 选择得到它的输出，也就是应用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 进行解密。&lt;/p&gt;&lt;p&gt;IKNP协议非常简单、非常优雅、效率极高。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们考虑 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT协议所需要的通信开销。其中发送方输入的长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L&quot; alt=&quot;L&quot; eeimg=&quot;1&quot;/&gt; 。大家已经了解到，核心归约步骤就是对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_%7Bi%2C0%7D&quot; alt=&quot;x_{i,0}&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_%7Bi%2C1%7D&quot; alt=&quot;x_{i,1}&quot; eeimg=&quot;1&quot;/&gt; 加密，这需要发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nL&quot; alt=&quot;2nL&quot; eeimg=&quot;1&quot;/&gt; 比特的数据。在长度扩展步骤中，我们要应用一个PRG，这需要发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nk&quot; alt=&quot;2nk&quot; eeimg=&quot;1&quot;/&gt; 比特的数据。&lt;/p&gt;&lt;p&gt;在姚氏电路中，我们需要传输长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3Dk&quot; alt=&quot;L=k&quot; eeimg=&quot;1&quot;/&gt; 的密钥，因此核心归约步骤和长度扩展步骤中的通信开销相同。在GMW中，我们只需要传输 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3D1&quot; alt=&quot;L=1&quot; eeimg=&quot;1&quot;/&gt; 的信息。令人惊讶的是，这一场景下长度扩展步骤的通信开销远高于核心归约步骤的通信开销。这就是一个问题了，我们可能可以在这一场景下对通信开销进行优化。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在讲座的后半部分，我们会提出IKNP的通用框架。我们也会向大家展示如何提高IKNP的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们先来详细分析一下IKNP协议。可以看到，接收方要选择这个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5Ctimes+k&quot; alt=&quot;n\times k&quot; eeimg=&quot;1&quot;/&gt; 的随机矩阵。随后，接收方要生成另一个矩阵，这个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列为第一个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列异或选择向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。换句话说， &lt;img src=&quot;https://www.zhihu.com/equation?tex=U%3D+T+%5Coplus+R&quot; alt=&quot;U= T \oplus R&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 是所有列均相等的矩阵，每个列都为接收方的选择向量。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果我们从行的视角看，就会发现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 行为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; ，这意味着 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 的每一行都是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 的一种编码。在IKNP协议中， &lt;img src=&quot;https://www.zhihu.com/equation?tex=0&quot; alt=&quot;0&quot; eeimg=&quot;1&quot;/&gt; 被映射为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=0%5Ek&quot; alt=&quot;0^k&quot; eeimg=&quot;1&quot;/&gt; ，而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 被映射为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1%5Ek&quot; alt=&quot;1^k&quot; eeimg=&quot;1&quot;/&gt; 。因此，我们可以看到IKNP这一高效协议在底层执行了一次逐行重复编码。这自然引出了一个问题：我们是否可以使用更复杂的编码？毕竟，重复编码是一种最简单的编码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;假设我们使用编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; ，并且我们假定 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 属于一个很大的域，域为从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 。我们用编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 映射成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29+&quot; alt=&quot;C(r_i) &quot; eeimg=&quot;1&quot;/&gt; ，这是一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 比特长字符串。现在，接收方需要用选择比特 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 构建矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 。我们来看看，在这个理论框架下IKNP协议的执行过程。&lt;/p&gt;&lt;p&gt;第一步，接收方获得了矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 。随后，接收方用加法秘密分享方案将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 分享为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29%3D+T+%5Coplus+U&quot; alt=&quot;C(R)= T \oplus U&quot; eeimg=&quot;1&quot;/&gt; 。接下来，接收方和发送方角色互换，执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT协议。在第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 个OT中，接收方的输入是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t%5Ei&quot; alt=&quot;t^i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u%5Ei&quot; alt=&quot;u^i&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列。执行完OT协议后，发送方得到矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; 。在IKNP协议中，我们知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 或者等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，或者等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+&quot; alt=&quot;t_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; 。在这一理论框架中，我们可以知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+%28C%28r_i%29+%5Codot+s%29&quot; alt=&quot;q_i=t_i \oplus (C(r_i) \odot s)&quot; eeimg=&quot;1&quot;/&gt; ，结果不算太复杂。&lt;/p&gt;&lt;p&gt;我们可以验证一下，当C是重复编码时 此框架对应的协议就是IKNP协议。特别地，当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D0&quot; alt=&quot;r_i=0&quot; eeimg=&quot;1&quot;/&gt; 时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29&quot; alt=&quot;C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 是一个全 &lt;img src=&quot;https://www.zhihu.com/equation?tex=0&quot; alt=&quot;0&quot; eeimg=&quot;1&quot;/&gt; 向量，因此我们得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; 时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29&quot; alt=&quot;C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 是一个全 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 向量，此时我们可以得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+s&quot; alt=&quot;q_i=t_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。这样一来，我们得到了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 个密钥。后面的执行过程就完全一样了，密钥生成算法为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+%28C%28r%29+%5Codot+s%29&quot; alt=&quot;q_i \oplus (C(r) \odot s)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们仍然可以证明接收方只能知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 。因此接收方只能解密对应的密文，从而得到对应的输入。核心归约步骤在恶意发送方的攻击下是完美安全的。特别地，恶意发送方只能得到矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; ，这是编码的随机独立分享结果。核心归约步骤在半诚实接收方的攻击下是统计安全的。这是因为除了在加密过程中使用了随机预言机之外，核心归约步骤没有安全性损失。因此，整个协议的安全性损失为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 的取值范围，以及 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-d%7D&quot; alt=&quot;2^{-d}&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=d&quot; alt=&quot;d&quot; eeimg=&quot;1&quot;/&gt; 是线性编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 的最小距离。&lt;/p&gt;&lt;p&gt;注意到在此理论框架下，我们可以从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选取消息，因此从效果上看，我们可以实现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT，而不是2选1-OT。但在这种情况下，核心归约步骤的通信开销会从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nL&quot; alt=&quot;2nL&quot; eeimg=&quot;1&quot;/&gt; 提高到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=nmL&quot; alt=&quot;nmL&quot; eeimg=&quot;1&quot;/&gt; 。随后，我们将标准的2选1-OT转换为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%2F%5Clog%28m%29&quot; alt=&quot;n/\log(m)&quot; eeimg=&quot;1&quot;/&gt; 个字符串长度稍长的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT实例，这也允许我们将通信开销表示为与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 相关的函数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我们有了一个自由变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; ，用它来平衡核心归约步骤和长度扩展步骤的开销。具体来说，如果我们使用的是最小距离为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%2F2&quot; alt=&quot;k/2&quot; eeimg=&quot;1&quot;/&gt; 的Hadamard编码，在这种情况下，2选1-OT的通信开销可以降低2倍。在多方GMW协议中，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%3D256&quot; alt=&quot;k=256&quot; eeimg=&quot;1&quot;/&gt; ，则通信开销也可以降低2倍。&lt;/p&gt;&lt;p&gt;也可以进一步优化长度扩展步骤的通信开销，此开销的优化程度是算法层面的，而不是渐进层面的。结合Hadamard编码后，与未优化的IKNP协议相比，新协议的通信开销要降低3.5倍。Asharov等人也独立发现了这一优化点，他们的论文将发表在CCS 2013上。&lt;/p&gt;&lt;p&gt;与IKNP相比，我们从渐进层面降低了每一个OT的通信开销。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3D1&quot; alt=&quot;L=1&quot; eeimg=&quot;1&quot;/&gt; 时，IKNP需要通信 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28k%29&quot; alt=&quot;O(k)&quot; eeimg=&quot;1&quot;/&gt; 比特，而我们需要通信 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28k%2F%5Clog%28k%29%29&quot; alt=&quot;O(k/\log(k))&quot; eeimg=&quot;1&quot;/&gt; 比特。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总结一下，为了平衡公钥密码学原语和对称密码学原语的性能鸿沟，学者们提出了OT扩展协议，这一协议在安全函数求值的实例落地中产生了巨大的影响。在本次讲座中，我们提出了IKNP的编码理论框架。可以在随机预言模型下证明此框架的安全性。随机预言模型也可以换为特定类型哈希函数假设，即相关性健壮哈希函数，这沿用了IKNP中安全性所依赖的相关性健壮哈希函数假设。当使用复杂编码时，此框架提高了多方GMW中2选1-OT和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT的性能。&lt;/p&gt;&lt;p&gt;我想用GMW和姚氏电路的性能对比问题作为讲座的结尾。近期的安全多方计算研究主要关注恶意模型下姚氏电路的性能优化问题。在半可信安全模型下，学者们也提出了很多姚氏电路的优化方法。但近期的一些工作也表明，GMW协议也有很多算法层面的优化点。我们的工作适用于GMW协议。谢谢大家。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-04-76647738</guid>
<pubDate>Fri, 04 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>ObliVM：安全计算编程框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-04-73618400.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/73618400&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-83f24da35d88aef9a1bc7d522f42c2cf_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;使用新的方法撰写密码学会议视频分享文章后，虽然点赞和阅读量并没有提升很多，但是根据知友们的反馈，这样做确实可以大幅度提高阅读体验。更开心的是，向知乎反馈后，知乎的工程师们也是大力配合，现在终于支持上传长度不超过60分钟的视频了，撒花庆祝！接下来的视频分享文章中，我会同时在知乎和B站上传翻译视频。知友们可以根据自己的习惯选择在哪个地方观看。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2015年安全顶级会议Security and Privacy 2015的演讲视频《ObliVM：安全计算编程框架》，对应的论文是《ObliVM: A Programming Framework for Secure Computation》。&lt;/p&gt;&lt;p&gt;上一篇文章《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot; class=&quot;internal&quot;&gt;SoK：安全多方计算通用框架&lt;/a&gt;》的视频中，作者调研了9个开源的通用安全计算框架，而ObliVM就是其中的一个。我个人对于“把Alice和Bob作为编程语言的关键词”这一点仍然记忆犹新。这一次，我们就来详细了解一下ObliVM到底是什么。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文链接：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.cs.umd.edu/~elaine/docs/oblivm.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cs.umd.edu/~elaine/docs&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/oblivm.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;视频链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DQ2QLRcj0Mio%26t%3D92s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=Q2QLRcj0Mio&amp;amp;t=92s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av59239482/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av59&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;239482/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202015/ObliVM%2520A%2520Programming%2520Framework%2520for%2520Secure%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202015/ObliVM%20A%20Programming%20Framework%20for%20Secure%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1134043543998984192&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;ObliVM：安全计算编程框架&quot; data-poster=&quot;https://pic2.zhimg.com/v2-f3c6c88bc65211e0a5428862604b6751.jpg&quot; data-lens-id=&quot;1134043543998984192&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-f3c6c88bc65211e0a5428862604b6751.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;ObliVM：安全计算编程框架&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1134043543998984192&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）大家好，我很高兴能在这里为大家介绍我们的工作：ObliVM，这是一个安全计算的编程框架。这是我和我的队友们一同完成的工作，队友有Xiao Wang，坐在那里的Kartik，还有Yan Huang，还有Elaine Shi。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;很高兴自己在前面的一个演讲中为大家充分介绍了什么是安全计算，或安全函数求值。我这里只需给出一个简短的介绍。例如，Sheldon和Amy希望互相确认自己是不是对方的另一半。他们都相信基因匹配的效果。因此，他们可以执行一个分析过程，看看他们是否匹配。一个很关键的安全问题是：他们不想把敏感的基因数据泄露给对方。我在前面已经讲过了，安全计算是这一问题的绝佳解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以把这个问题抽象成下述形式：给定两个参与方Alice和Bob，以及他们的秘密输入&lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt;，他们希望联合计算一个公开函数&lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28x%2Cy%29&quot; alt=&quot;f(x,y)&quot; eeimg=&quot;1&quot;/&gt;，得到函数的计算结果。同时，除了计算结果&lt;img src=&quot;https://www.zhihu.com/equation?tex=z&quot; alt=&quot;z&quot; eeimg=&quot;1&quot;/&gt;外，涉及两个秘密输入的计算过程不会向对方泄露任何其它信息。这就是安全计算的概念。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家已经知道，安全计算的解决方案有姚氏乱码电路，还有GMW协议。我们关注什么地方呢？我们的关注点是：如何让安全计算能在实际中得到应用？例如，一个开发者希望开发一个安全计算应用。他们肯定不想把函数写成电路的形式。他们想用C语言、Java语言、或者Python语言编写代码。因此，源程序和安全计算协议之间存在很大的鸿沟。这就是我们ObliVM框架要做的事情。我们的ObliVM是一个工具，可以将源代码转换成实际的安全计算协议。这是ObliVM的框架概览。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里面最主要的问题是什么？Kartik已经提到，主要问题是开发人员喜欢用Python等语言模型编写代码。幻灯片左侧是开发人员撰写的源程序。但实际上，大多数安全计算协议是在电路模型下实现的。因此，在高层语言程序和电路程序之间存在很大的鸿沟。我们的问题是，如何将左侧的代码转换为右侧的协议？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢Kartik的讲解，你已经提出了我们工作的出发点。这里的关键挑战是，如何能让动态内存访问过程不泄露信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是一个不太容易解决的挑战。我们的解决方案是：把RAM模型下的问题转换到不经意RAM模型中。不经意的意思是内存访问和指令追踪过程不依赖于秘密输入。这样一来，不经意程序就可以被进一步转换为电路了。我们可以看到，在转换链路中，后一部分相对比较简单，前一部分非常有挑战性。本次讲座主要关注前一部分，解释如何做到这一点。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有一个非常平凡，也不能说非常平凡的解决方案。这个方案于2013年首先提出，基本思想是使用不经意RAM。不经意RAM，又称ORAM，可以把任意程序编译成不经意程序。基于这一思想，我们去年提出了SCVAM框架。此框架可以仿真通用ORAM。可以证明，我们的渐进性能比所有之前的解决方案都要好。这一解决方案是通用的，也很容易实现。但问题在于，这个方案可能不是最高效的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在过去的几年间，我们观察到研究人员提出了很多定制化安全计算协议。这方面的工作有很多，我实在没办法在幻灯片上把所有相关工作都列出来。这些定制化安全计算协议都很高效，可以这么说，这些协议比我们去年的工作都高效。但问题在于，这些协议的设计成本很高。例如，我们与Nina Taft聊了聊，她是我们的合作方。我们私下针对CCS 2013上面发表的隐私矩阵分解算法进行了讨论。她告诉我们，她们组织了5位研究人员，花费了大约4个月的时间才完成了全部的实现。也就是说，整个过程花费了超过1.5年的研究时间。这里涉及到巨大的工作量。我们的问题是：我们能不能做得更好？我们能否构建一个通用框架，但仍然获得定制化协议的执行效率？这就是我们ObliVM的目标。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们希望非领域专家，例如非密码学家，可以用它实现一些安全计算协议，同时获得定制化协议的执行效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何做到这一点？关键思想是：在ObliVM内部，我们提供很多编程抽象接口。我在幻灯片上具体列举了一些，如不经意数据结构、MapReduce、循环合并等。我后面会介绍其中一个抽象接口。如果想了解更多的细节，请阅读我们的论文。我还想提及的是，Kartik刚刚讲解的GraphSC论文也是一个并行计算编程接口抽象。总之，我们提供了一些编程接口抽象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我这里想简单介绍一下编程接口抽象到底是什么。我们来看看分布式计算社区。我估计绝大多数人都听说过MapReduce，这是谷歌于2004年在OSDI会议上发表的论文。在这篇论文发表之前，并行计算、或者说分布式计算，是一个很困难的任务。但通过MapReduce，开发者只需要将计算过程编码在Mapper和Reducer框架中。开发者不需要关注分布式计算方法，MapReduce框架会实现整个分布式计算过程。因此，与之前的工作相比，使用MapReduce涉及的开发工作量会非常小。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们想用与之非常类似的方法解决这一问题。我们希望提供一些抽象接口，允许开发者将计算任务编码在抽象接口中，这样他们就不需要关注底层的密码学原语，但仍然获得相同的计算性能。这就是我们的目标，这就是我们的解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何对外提供这些编程接口抽象？我们希望实现一个新的语言支持体系。例如，我们想为我们的开发者实现一个新的编程语言。在开发这个语言时，我们脑海中有两个目标。第一个目标是：领域专家或密码学家可以很容易地应用此语言实现不同的编程接口。另一方面，对于非专家来说，他们可能不是特别了解密码学技术，他们可以很容易地使用这些编程语言抽象构建他们自己的应用程序。&lt;/p&gt;&lt;p&gt;结合脑海中的这两个目标，我们的解决方案是构建新的语言特性，支持之前系统未无法支持的功能。我这里列举了一些特性，请大家阅读论文，了解相应的技术细节。后续我们会在幻灯片给出的地址上开源我们的编译器，这样大家可以更好地了解编译器的实现细节。我认为这些特性都很不错。例如，我们可以使用随机类型、虚函数等，从源代码阶段，而不是从后端原语阶段，实现不经意RAM协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有了这些编程接口抽象，开发人员该怎么做呢？例如，我们希望实现一个稀疏图算法。我们已经有了编程接口抽象这样一个武器库了。假设我们想要实现稀疏Dijkstra最短距离算法，我们可以选取适当的不经意数据结构，这里要选择不经意堆。随后，我们使用循环合并抽象实现相应的算法。通过使用这些工具，我们实现了3个不同的稀疏图算法。&lt;/p&gt;&lt;p&gt;整个流程好像都走得通，但我们得到了一个超出期望的结果：我们实现的算法从理论角度也得到了突破，所有3个算法的渐进复杂度都比当前最优算法的渐进复杂度低。这个结论令我们感到十分惊讶。如果想了解算法的更多细节，请阅读我们的论文。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;开发人员具体该做些什么呢？我在几分钟之前已经向大家许诺过了，我会为大家介绍一个编程接口抽象：循环合并。这是非常细节的内容了。在安全计算中，实现秘密循环是非常有挑战性的工作，因为循环次数本身就会泄露信息。这里我们允许编程人员编写有上界循环次数限制的循环语句。例如，我们允许协议保护循环次数，但我们要求开发人员公开告知循环次数的上限。&lt;/p&gt;&lt;p&gt;这是一个嵌套循环代码。这里有趣的地方在于，第4行到第7行的内部循环中，循环次数上界m并不是外部循环中每次迭代的最大迭代次数上界，而是两层嵌套代码中，内部循环的总执行次数上界。这样我们可以避免重复的执行过程。例如，如果我们按照传统方法给出上界，则总迭代次数是n•m，但这样设置的总迭代次数是n+m。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们的编译器会分析这段代码，自动将此类形式的代码转换成右下的代码形式。这段代码看起来像是一个状态机，这样就不会为算法引入额外的复杂度了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;应用所有这些技术以后，我们能得到什么呢？我之前已经提到，实现矩阵分解算法涉及的人力开销大约为1年1.5个研究者。如果使用ObliVM呢？结果非常令人惊讶，只需要一天就够了。一个博士研究生只需要一天就可以实现全部功能。&lt;/p&gt;&lt;p&gt;你可能会想，实现结果是否高效？可能自动化的实现结果并不高效。事实上，我们的实现的算法效率要高10到20倍，因此实现结果甚至更高效了。这就是我们现在得到的优化结果。我相信ObliVM对于所有安全计算开发者来说都是一个福音。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们深入解析一下各个优化点所带来的性能提升情况。我们这里给出的是Dijkstra算法的实现结果。论文中给出了更多的实现结果。虽然我们这里只关注ObliVM的编程语言部分，但实际上ObliVM拥有一个经过深度优化的后端ObliVM-SC。此后端代码也开源了，大家可以访问我们的网站，获取源代码链接。&lt;/p&gt;&lt;p&gt;我们实现了一个当前最优的电路ORAM，此ORAM专门为安全计算进行优化。我们将我们的系统和之前在CCS 2012上公开的最佳结果进行了对比，电路ORAM本身可以为我们带来50倍的性能提升。编程语言和编译器可以为我们带来2500倍的性能提升。我们进一步对后后端的其它部分进行了深度优化，可以在我们的论文中找到相应的技术细节描述。这些深度优化可以为我们带来7倍的性能提升。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总体来说，我们获得了大约100,000倍的性能提升，这是很大的性能提升倍数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里给大家一个更直观的方案效率描述。2012年在同一篇论文中，他们在1GB数据集上执行了二分搜索算法。一次单独问询的计算时间大约为12小时。现在情况又怎么样呢？使用我们的ObliVM框架，每次问询的执行时间仅为7.3秒。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还将我们的SCVM框架与不安全的解决方案进行了效率对比。也就是说，我们直接在计算机上执行明文程序，从而对比效率。我们计算了效率损失量，效率损失量相对还是可以接受的。对于分布式GWAS，效率损失仅为130倍。我们可以期待，未来这一数字可能会进一步降低。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有很多合作方都与我们合作，ObliVM已经在多个场景下得到了应用。我们刚刚赢得了3月份举办的基因分析竞赛，这是大约2个月前举办的竞赛。未来，我们希望在ObliVM框架的基础上实现更多的密码学计算任务，如同态加密等。&lt;/p&gt;&lt;p&gt;非常感谢大家，这就是我讲座的全部内容了，接下来我可以回答一些问题。&lt;/p&gt;&lt;p&gt;提问者：在演讲开始阶段你给出了一个二分搜索的例子，开发人员应该怎么实现二分搜索？开发人员需要写什么代码？&lt;/p&gt;&lt;p&gt;主讲人：你指的是哪个例子？&lt;/p&gt;&lt;p&gt;提问者：在最开始的地方，你给出了一个二分搜索的例子，那时候你提到…&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;主讲人：这张图中左侧是开发人员实现循环合并时要编写的代码。你提到了二分搜索的例子，对吧？&lt;/p&gt;&lt;p&gt;提问者：是的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;主讲人：我觉得用二分搜索举例子会比较好。开发人员要做的事情是…我们回到那页幻灯片上。在这里。&lt;/p&gt;&lt;p&gt;提问者：就是这里。&lt;/p&gt;&lt;p&gt;主讲人：这就是开发人员需要编写的代码…我看看这个代码能不能编译通过…是的，可以用我们的ObliVM编译器编译这个程序。编译器会自主处理内存访问过程。&lt;/p&gt;&lt;p&gt;提问者：是的。&lt;/p&gt;&lt;p&gt;主讲人：是的，编译器会识别相应的模块，判断哪些部分要替换为ORAM，哪些部分不需要替换。&lt;/p&gt;&lt;p&gt;提问者：ObliVM是不是有一种潜在使用方法，就是让ObliVM输出C代码，而不是电路，这样我们就可以把任意一个程序输入给ObliVM，使得程序无法被旁路攻击？&lt;/p&gt;&lt;p&gt;主讲人：这是一个非常好的问题。一个非常有趣的事实是，我们的ObliVM编译器输出的是Java代码。&lt;/p&gt;&lt;p&gt;提问者：明白。&lt;/p&gt;&lt;p&gt;主讲人：随后，执行Java代码，会生成一个电路。所以我觉得你提的问题非常好。我认为未来一个很有趣的研究方向是，如何阻止ObliVM编译器遭到旁路攻击。&lt;/p&gt;&lt;p&gt;提问者：好的，谢谢。&lt;/p&gt;&lt;p&gt;主讲人：谢谢你。&lt;/p&gt;&lt;p&gt;主讲人：什么？你可以使用麦克风的。&lt;/p&gt;&lt;p&gt;合作者：我们的编译器没办法被旁路攻击。如果你直接编写类似这样的代码，编译的输出结果是通用ORAM程序。但你也可以调用我们提供的不经意数据结构。我们在不经意数据结构中实现了二分搜索树，如果直接调用不经意数据结构抽象接口，编译时间会减少log(n)倍。&lt;/p&gt;&lt;p&gt;提问者：明白。&lt;/p&gt;&lt;p&gt;合作者：很容易让编译器输出C代码，修改后端编译器即可。比较困难的点在于前端，如何编译得到一个高效的电路。&lt;/p&gt;&lt;p&gt;主持人：感谢Elaine的解释。&lt;/p&gt;&lt;p&gt;主讲人：是的，感谢Elaine。&lt;/p&gt;&lt;p&gt;主持人：再次感谢我们的演讲者。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-04-73618400</guid>
<pubDate>Fri, 04 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>SoK：安全多方计算通用框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-04-72119587.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b38297e2e605b6e0c3739b6eee4bb1e8_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;有段时间没有为知友们带来安全会议的演讲视频翻译了，主要原因是我发现这类文章阅读量并不是很高。业余时间我自己反思了一下，可能是因为知乎到底还是一个问答类社区，文字类型的描述可能更适合知友们快速感知到安全会议演讲视频的内容。为此，在接下来的安全演讲视频文章中，我做了如下几个改变：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;不在知乎上传视频，而是根据视频主讲人的幻灯片展示情况，将对应的演讲稿发出。&lt;/li&gt;&lt;li&gt;演讲视频还是会上传，不过会上传到B站这个专门播放视频的地方。这样，如果有翻译错误，或者有更好的建议，知友或者B站的朋友可以通过弹幕、评论的形式更快地反馈。&lt;/li&gt;&lt;li&gt;演讲视频的中文字幕、时间轴文件（ass格式）、相应的截图等，我会公开在我的GitHub下面，方便知友们下载。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;希望这种方式可以让知友们各取所需。&lt;b&gt;如果知友们还想了解哪些演讲视频，也可以通过知乎评论、GitHub、B站等方式给我留言。我会尽可能满足大家的要求。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2019年5月23日刚刚召开的安全顶级会议Security and Privacy 2019的一个演讲视频《SoK：安全多方计算通用框架》，对应的论文是《SoK: General Purpose Frameworks for Secure Multi-Party Computation》。&lt;/p&gt;&lt;p&gt;这里需要介绍一个背景知识：如果一篇论文的开头是“SoK”，则代表这篇论文是一篇综述论文。SoK的全称是“Systematization of Knowledge Papers&lt;b&gt;”&lt;/b&gt;，Security and Privacy的官方网站（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ieee-security.org/TC/SP2013/cfp.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;ieee-security.org/TC/SP&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;2013/cfp.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;）给出了一个很详尽的解释：&lt;/p&gt;&lt;blockquote&gt;Following the success of the previous years&amp;#39; conferences, we are also soliciting papers focused on systematization of knowledge (SoK). The goal of this call is to encourage work that evaluates, systematizes, and contextualizes existing knowledge. These papers can provide a high value to our community but may not be accepted because of a lack of novel research contributions. Suitable papers include survey papers that provide useful perspectives on major research areas, papers that support or challenge long-held beliefs with compelling evidence, or papers that provide an extensive and realistic evaluation of competing approaches to solving specific problems. Submissions are encouraged to analyze the current research landscape: identify areas that have enjoyed much research attention, point out open areas with unsolved challenges, and present a prioritization that can guide researchers to make progress on solving important challenges.&lt;b&gt;Submissions must be distinguished by a checkbox on the submission form. In addition, the paper title must have the prefix &amp;#34;SoK:&amp;#34;&lt;/b&gt;. They will be reviewed by the full PC and held to the same standards as traditional research papers, except instead of emphasizing novel research contributions the emphasis will be on value to the community. Accepted papers will be presented at the symposium and included in the proceedings.&lt;/blockquote&gt;&lt;p&gt;简单来说，SoK论文的目标是系统化、结构化地评估已有知识体系的论文。这类论文虽然工作量很大，但由于缺乏必要的创新性贡献，所以一般不会被会议所接收。但是，随着相应知识的不断提出和完善，这类论文会对他人进一步的研究带来非常大的帮助。所以，越来越多的会议开始接收SoK论文了。SoK论文的最大特点是：这类论文的题目必须以“SoK”开头。&lt;/p&gt;&lt;p&gt;《SoK: General Purpose Frameworks for Secure Multi-Party Computation》这篇论文非常详尽的分析了现有的安全多方计算通用框架，从各种维度评估了各个框架的优缺点，在不同场景下给出了使用建议。特别地，作者成功构建了所有的通用框架，并把构建环境打包在Docker中。我个人用了一下Docker，样例程序都可以跑通，作者也针对各个框架给出了进一步的文档和注释。这篇文章特别适合准备研究安全多方计算协议，或者准备在实际中使用安全多方计算的研究人员。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DI0bremwQ_ns%26t%3D40s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=I0bremwQ_ns&amp;amp;t=40s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av57765218&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av57&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;765218&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202019/SoK%2520General%2520Purpose%2520Frameworks%2520for%2520Secure%2520Multi-Party%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202019/SoK%20General%20Purpose%20Frameworks%20for%20Secure%20Multi-Party%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;p&gt;感谢知乎工程师们的辛勤工作，知乎现在可以上传60分钟的视频了。为了文章的完整性，我把视频也同步发布在知乎专栏上面。&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1134055356077580288&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic4.zhimg.com/v2-56be736bd7d245f4652fb021facd0c27.jpg&quot; data-lens-id=&quot;1134055356077580288&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic4.zhimg.com/v2-56be736bd7d245f4652fb021facd0c27.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1134055356077580288&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（主讲人）非常感谢主持人的介绍。我是Marcela Hastings。这是一篇SoK论文。我将讲解我们的调研结果。我们考察的工具是安全多方计算。这是一个密码学工具，允许互不信任的参与方根据自己的输入计算任意一个函数，计算过程不泄露除输出结果以外的任何信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;安全多方计算实际应用中最著名的实例是丹麦甜菜拍卖系统。在这个场景中，售卖方是丹麦种田菜的农民，而购买方只有一个，即丹麦唯一的一个甜菜加工公司。售卖方为甜菜出价，表示他们希望按照这个价格售卖甜菜，购买方希望得知市场出清价（即保证供求关系平衡的售卖价格）。但售卖方不希望泄露自己的具体出价。如果常年泄露出价，则其它人就会得知自己的甜菜种植能力和做生意的能力了。因此，他们使用安全多方计算协议，在不泄露售卖方出价的条件下计算市场出清价。&lt;/p&gt;&lt;p&gt;另一个例子是波士顿妇女劳动委员会与企业的合作项目。此项目研究员工性别是否会影响到其实际的工资。公司不希望、从法律角度也不能够对外泄露自己雇员的收入或金融类信息。但通过安全多方计算，他们可以在不给出具体数据的条件下计算相应的统计分析结果。&lt;/p&gt;&lt;p&gt;所有这些例子都告诉我们安全多方计算已经足够高效，可以在实际场景中得到应用了。然而，我们之前看到的所有实际应用实例中，项目方都需要组织一个密码学专家团队，针对特定用例实现专用MPC引擎。如果想让MPC得到更广泛的应用，我们需要让不懂密码学的外行也能使用这一工具。虽然二十世纪八十年代，密码学家就提出了MPC算法，但一直以来MPC协议的效率都很低，无法在实际中使用，直到2004年“公平参与”编译器的提出改变了这一现状。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;“公平参与”是第一个通用MPC框架，可以通过MPC执行任意函数的计算。在接下来的10年，这一框架掀起了学者们针对MPC协议性能优化的浪潮。直至现在，无论从算法角度还是从实现层面，MPC协议得到了巨大的优化。在过去十年间，学者们提出了很多端到端MPC框架。在本工作中，我们重点考察通用端到端MPC框架。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;端到端框架的架构如幻灯片所示。框架一般实现了两个阶段的功能：编译器、执行器。这是因为大多数MPC算法只支持有限的算子，如模质数下的加法和乘法。开发者很难应用这些有限的算子实现所需的计算函数。因此，我们重点考察包含一个编译器的框架。编译器的输入是用高级语言描述的函数。编译器会把函数编译成算法可执行的协议。接下来，执行器会具体执行编译好的协议。协议会在多个参与方上同时执行。每个参与方都以编译器的输出结果和自己的秘密值作为输入，计算得到函数输出结果。当然了，不同框架的架构各不相同，但是它们基本都是这样的结构。&lt;/p&gt;&lt;p&gt;在本综述中，我们想回答这样一些问题：目前都有哪些框架？谁在使用这些框架？这些框架是否可以实现实际的计算过程？这些框架是否可以支持所需函数的计算？这些框架是否可以在实际中使用？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为了回答这些问题，我们调查了9个端到端框架和2个电路编译器。我们记录了这些框架的不同特性，包括框架所实现的协议、框架所支持的数据类型和运算操作、以及其它一些实现的具体细节。我们通过多种可用性标准对这些协议进行评价。为了收集这些数据，我们在每个框架上实现3个样例程序。我们把每个框架的完整构建环境及其对应的样例程序都放在了开源的代码仓库中。结合这些框架的使用经验，我们为各个框架补充了相应的文档。构建代码仓库的总时间约为750人小时。此仓库是开源的。我们仍然在积极地维护这一仓库，非常希望大家能看看这个代码仓库。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我想简单介绍一下完成这些工作后我们所得到的一些结论。总的来说，几乎所有的框架做得都不错。各种框架在不同的安全模型下实现了不同的协议。根据具体用例的不同，框架也提供了一些协议和安全模型的选项。我们可以在几乎所有的框架上实现我们的样例程序。这意味着对于绝大多数场景来说，框架的高层语言具有较好的可表达性。总的来说，大多数框架都是开源的、可编译的、可用的。然而，我们发现了两个重要的改进方向。第一个方向是：框架的工程局限性较高。例如，框架的系统构建环境过于复杂。第二个方向是：框架的可用性较差。其根本原因主要在于框架缺失相应的文档。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在具体讲解这些问题之前，我想先从宏观层面介绍我们的发现。我们考察了9个框架。最下方是2个电路编译器。大家可以从表格中看到框架支持的参与方数量、支持的安全模型。我们有两种安全模型。在半诚实模型中，攻击者会正确执行协议，但是攻击者会尝试得到其它参与方的输入。在恶意模型中，攻击者不会遵从约定执行协议，以错误的协议执行结果中推断信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还对不同的协议进行了简单的分类，这里需要简单解释一下。第一类协议是乱码电路协议，最初由姚期智于二十世纪八十年代提出。自姚期智提出此协议以来，学者们持续不断地对协议进行改进。理论密码学家从不同角度对乱码电路进行了优化。从实际中我们发现，几乎所有的框架都实现了半诚实两方协议，一个参与方对电路加密后将结果发送给另一个参与方，另一个参与方根据输入对电路求值。在乱码电路中，需要把函数表示为布尔电路的形式。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二类协议包含很多不同的协议。我们称这类协议为基于电路的多方计算协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这些协议拥有两个共同的特性。第一个特性是，需要把函数表示为代数电路或者布尔电路的形式。第二个特性是，数据需要用线性秘密分享的形式表示。线性秘密分享意味着协议支持任意数量的参与方。参与方协同工作，依次对门电路求值，将秘密分享输入转换为秘密分享输出。然而，在基于电路的多方计算模型下，不同协议将输入转换为输出的方式不太相同，可以基于信息论安全模型下转换，也可以基于密码安全模型下转换。&lt;/p&gt;&lt;p&gt;我们认为这两类协议可以涵盖大多数框架的基础协议。在理论层面，大多数理论密码学家用非常有限的运算操作定义MPC协议，涉及的运算操作只包含模整数下的加法和乘法，或者逐比特与预算和异或运算。这两类运算操作都是图灵完备的，任何函数都可以用这两种运算操作表示。然而，在实际中我们需要为代数模型下的除法、比较等公共函数定义更优的子协议，这样我们就不用把所有函数都表示为基本运算操作，从而提高函数表达的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们发现有3个框架实现了特定的子协议。我们称这类协议为混合协议。在最下方，大家可以看到2个电路编译器。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当选择适当的框架时，人们需要着重考虑的是：高层语言对协议的抽象能力。不同框架都实现了协议的抽象。我们对这些高层语言展开了考察。我们测试的其中一个样例程序是内积运算。内积运算是指逐位计算乘积，再对各个结果求和。&lt;/p&gt;&lt;p&gt;Frigate是一个电路编译器，它的高层语言是非常传统的C语言风格抽象。大家可以看一下幻灯片上给出的内积运算代码实现。初始化结果变量，在向量上构建循环语句，循环中依次取出向量中的每一个元素，计算各个元素的乘积，最后对乘积求和。实现过程非常直观、通俗易懂。然而，如果你熟悉MPC，你可能会知道在线性秘密分享模型中，我们可以通过一轮交互并行处理所有的乘法运算。如果你希望得到优化后的协议，你可能就需要使用PICCO等框架了。&lt;/p&gt;&lt;p&gt;PICCO会对内积运算的乘法进行了并行优化，它们实现了一个针对内积运算的自定义算子。所以PICCO是一个混合协议框架。大家可以看到，可以用这个非常简单的自定义算子求两个任意长向量的内积结果。即使你不熟悉密码学，也可以很方便地直接使用自定义算子，你也不需要关注底层到底做了什么。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，如果你是一个密码学家，你想实现一个比内积更复杂的函数，你可能会希望对生成的电路做更深度的控制和修改。这种情况下，你可能会使用ABY这样的框架。ABY是一个端到端框架，在C语言上实现了一个函数库。大家可以看到，我们用一个share类管理秘密数据。我们随后放置一个乘法门，ABY会帮助我们实现乘法的并行优化。我们需要一个乘法门对整个向量逐位计算乘法。随后，我们把向量展开，对所有乘法运算结果求和。这可以给我们更大的自由，实现我们想实现的函数。但如果你对密码背景不熟悉，你可能就不想具备这些自定义的能力。这就是我们考察的前后端高层语言的范围。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们下一个想讨论的内容是这些框架的一些限制。正如我前面提到的，软件工程是这些框架中最主要的问题。大家一定要记住，大多数框架都是在学术研究场景下开发的。因此，这些框架在工程落地时会有很多的限制。在我讲解下面内容的过程中，大家要把这一点牢记于心。&lt;/p&gt;&lt;p&gt;最主要的痛点是构建系统。系统的整个构建过程非常复杂。你需要从源代码层面编译特定版本的OpenSSL库，这就要花费很长的时间，或者你需要建立一个自定义的证书认证机构，从而建立秘密通信信道。光编译每一个框架平均就要花费我们1-2周的时间。这个过程苦不堪言。但是大家很幸运，我们已经把编译好的环境放在了Docker仓库里，所以大家不需要再重复一遍此项工作了。&lt;/p&gt;&lt;p&gt;在系统构建之上，要使用这些软件框架项目，我们还需要很多的软件开发工作。正确实现密码学协议已经很困难了，但在这之上，开发者还需要实现很多支持系统，例如分布式通信、用安全语言实现与其它通信系统的交互。这方面的结论虽然比较细节，但仍然令人沮丧。例如，在ObliVM中，我们无法编写一个返回结果超过32比特的计算函数。我们可以通过进一步的代码开发来解决这个问题。由于框架都是在学术层面上开发的，框架在实现层面上都不太完美。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个比较严重的问题是可用性，尤其是文档比较匮乏。如幻灯片所示，我们定义了5类文档，一半框架都缺失了至少3类文档。我这里不详细介绍每一类文档的细节，而是想给大家展示几个例子，从而证明语言文档的缺失极大地影响框架的可用性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;语言文档指的是描述如何使用高层语言的文档。CBMC-GC是一个电路编译器，可以将代码编译成乱码电路。大多数人都熟悉C语言。假设我们要实现这样一个简单的程序：把两个数直接相乘。这个代码感觉上是正确的。然而，我们会得到一个编译错误：我们忘记返回一个值。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上，在CBMC-GC中，计算过程中的所有秘密输入的变量名都需要以input开头。这根本不算是一个问题，但是并没有文档说明这一点，我们有必要告诉大家。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个例子来自于ObliVM，这是一个将类Java语言作为高层语言的端到端框架。与前面相同，我们的程序是计算两个数的乘积，但我们碰上了解析错误。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;事实上，Alice和Bob是此高层语言中的保留关键词。因此，我们不能把这两个词作为变量名。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Wisteria是开发编程语言的人所撰写的端到端框架。此框架使用函数式语言来描述计算函数。此框架包含了一个详尽的语言指南，告诉大家如何使用函数式语言编写计算函数。然而，语言文档没有考虑到解析器的限制要求。开发者需要在代码中放置很多的括号，编译器才能编译通过。&lt;/p&gt;&lt;p&gt;EMP-toolkit是一个我们非常喜欢使用的框架。这是一个基于乱码电路的框架。然而，我们发现平均600行代码才会有1行注释，并且没有单独的代码解释文档。这些问题都会导致框架难以使用。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，有一些框架的文档工作做得很好，我真挚地感谢这些框架的作者。对于那些维护一个较大开源项目框架的开发者，我想给出两个重要的建议。&lt;/p&gt;&lt;p&gt;第一个建议是，即使针对不同方面的很简单的文档，也会大幅提高框架的可用性。不同类型的文档指的是，可能有一个文档解释框架的架构，另一个文档是带注释的样例程序，演示一些高层语言的特性。&lt;/p&gt;&lt;p&gt;第二个建议是在线资源，例如提供一个邮件列表或在GitHub上开启问题追踪。这是一个持续生成、持续更新框架文档的好方法。问题追踪就像一个在线问答平台，这样你就不用通过邮件重复回答相同的问题了。问题追踪也是用户之间相互交流的平台，他们可以互相回答遇到的问题。如果你不再想维护你的框架，用户仍然可以相互讨论，解答相应的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;即使有这些工程和可用性方面的问题，MPC框架的实现情况还是非常乐观的。我们可以在框架上实现很多样例程序。总体来说，实现过程还是很顺利的。社区也发现了框架可用性的问题。IARPA HECTOR项目正在赞助下一代MPC框架的实现。在赞助中，它们专门提出了可用性评价标准。&lt;/p&gt;&lt;p&gt;我们强烈建议后续的开发者们可以与编程语言研究者合作。大多数框架都是由密码学家实现的，因此前后端语言的设计可能不是很规范。编译器经验充分的开发人员介入，会对语言设计有更好的帮助。&lt;/p&gt;&lt;p&gt;插播一条广告，我们仍然在积极维护我们的代码仓库，我们随时准备接受新框架、已有框架的提交请求。如果你在维护其中一些框架，或者想在学术项目中使用这些框架，建议看看此代码仓库。&lt;/p&gt;&lt;p&gt;最后一条广告，我们在寻找MPC的落地项目，如果你是潜在合作方，如果你有一个有趣的项目，请稍后与我们联系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢。&lt;/p&gt;&lt;p&gt;（主持人）非常感谢。如果有问题的话，请用麦克风提问。&lt;/p&gt;&lt;p&gt;（提问者）你好，首先非常感谢你们所做的工作。社区迫切需要你们所做的工作，这个工作非常令人激动。我知道你们完成了这一概览性的工作。你们也得到了一些好的结论，一些不好的结论。但你们没有给出类似这样的结论：这是正确的框架，社区应该在这个框架的基础上继续构建，或者类似的结论。这样的结论可能会非常重要，因为如果没有这样的结论，最后的情况可能就是：哦不，这里有12个标准，我们要尝试构建一个标准，然后我们就得到了第13个标准。你能给出类似这样的结论吗？&lt;/p&gt;&lt;p&gt;（演讲人）当然可以。在论文中，我们明确给出了建议，推荐使用哪些框架。如果你在为某个特定场景寻求建议，我这里可以给出4个不同场景下的推荐。对于乱码电路框架来说，Obliv-C是一个不错的通用框架。如果你一些密码学专业知识，EMP-toolkit会更适合你。SCALE-MAMBA最适合多参与方场景，或者说这是一个混合协议框架。因此，这是最好的线性秘密分享协议框架。此框架的适用性很广泛，更新仍然很活跃。如果你有特定的安全需求，你可能会对Sharemind感兴趣，这是唯一一个付费开发者维护的框架，而且开发者是学术领域的研究人员。这就是我给出的推荐建议。&lt;/p&gt;&lt;p&gt;（主持人）谢谢，我绝对也会开发一个将Alice和Bob作为保留关键词的编程语言，这太酷了。再次感谢你的精彩演讲。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-04-72119587</guid>
<pubDate>Fri, 04 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>安全机器学习：可扩展隐私保护机器学习系统</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-04-54108699.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/54108699&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d93ddfcf2db7be0818d187a604cfada4_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;2019年10月04日更新：重新上传了视频，将讲解内容的幻灯片截图和每页幻灯片对应的演讲内容附在了文章中。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;引言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这次为各位知友带来的视频是Yupeng Zhang在2017年信息安全旗舰会议《Security &amp;amp; Privacy》上的论文演讲，论文的题目是《安全机器学习：可扩展隐私保护机器学习系统》（SecureML: A System for Scalable Privacy-Preserving Machine Learning）。&lt;/p&gt;&lt;p&gt;这篇论文是数据安全技术领域的一位好朋友向我推荐。他建议我仔细阅读论文，有相关想法就一起讨论。可惜的是，目前我的日常工作和前沿数据安全技术关系比较小，因此论文阅读的进度比较慢。在浏览了讲座视频后，我初步感觉应用安全多方计算（Secure Multi-Party Computation，SMPC）技术解决数据流转，特别是B2B场景下的数据流转，是未来一个非常重要、也是值得深挖的方向。因此，我先把视频听译并分享出来，希望有更多的知友了解到这个领域。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//eprint.iacr.org/2017/396&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cryptology ePrint Archive: Report 2017/396&lt;/a&gt;&lt;/li&gt;&lt;li&gt;视频链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DCQxwdqzlgWI&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SecureML: A System for Scalable Privacy-Preserving Machine Learning&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av57764994/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av57&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;764994/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/S%2520%2526%2520P/S%2520%2526%2520P%25202017/SecureML%2520-%2520A%2520system%2520for%2520scalable%2520Privacy-Preserving%2520Machine%2520Learning&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/S%20%26%20P/S%20%26%20P%202017/SecureML%20-%20A%20system%20for%20scalable%20Privacy-Preserving%20Machine%20Learning&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;解释论文工作更全面的PPT：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//legacydirs.umiacs.umd.edu/~zhangyp/presentations/SecureML.pptx&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;legacydirs.umiacs.umd.edu&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/~zhangyp/presentations/SecureML.pptx&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;背景知识：安全多方计算及其问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;安全多方计算要研究的问题是：在无可信第三方的情况下，多个参与方如何安全地计算一个约定函数的输出结果。以安全多方计算提出者姚期智院士的百万富翁问题为例：有两个百万富翁Alice和Bob，他们相对比一下互相之间谁的资产更多，但又不想向对方透露自己的资产数额。在这个场景下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;百万富翁Alice的输入为Alice的资产量A。&lt;/li&gt;&lt;li&gt;百万富翁Bob的输入为Bob的资产量B。&lt;/li&gt;&lt;li&gt;约定的函数为：如果A&amp;gt;B，返回1，如果A&amp;lt;B，返回-1，否则返回0。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在完成计算后，Alice（Bob）获得了约定函数的计算结果，但无法得知B（或者A）的具体值。&lt;/p&gt;&lt;p&gt;在当前互联网场景下，各个公司都拥有海量的数据，但是尚不能完成数据之间的安全流转。安全多方计算协议的应用很可能解决此类问题，各公司在不对外明确提供数据的条件下，与其它公司共同完成数据计算，从而得到更好的数据计算结果。&lt;/p&gt;&lt;p&gt;目前，密码学家已经提出了多个实现任意函数的安全多方计算协议。从理论上讲，给定任意一个函数，我们都可以构造一个安全多方计算协议。然而，目前提出的安全多方协议有如下几个尚未解决的问题：（1）实现比较复杂的计算任务时效率较低（如实现高次多项式求值）；（2）安全多方计算协议会引入比较大的通信开销。目前来看，通用优化方案寻找起来相对比较困难。但在特定的计算场景下，是否可以找到比较好的优化方案，是一个非常有意思的研究领域。&lt;/p&gt;&lt;p&gt;本论文就在特定计算场景下实现了安全多方计算的优化。针对线性回归、逻辑回归、神经网络训练问题，本论文给出了优化方案，并通过理论证明和实际验证说明了方案的可行性。&lt;/p&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1163514753825185792&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic3.zhimg.com/v2-ede09ee76003acc48921f38a200ae85e.jpg&quot; data-lens-id=&quot;1163514753825185792&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic3.zhimg.com/v2-ede09ee76003acc48921f38a200ae85e.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1163514753825185792&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4c98c7868fff134bb50c7f654527d938_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-4c98c7868fff134bb50c7f654527d938_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4c98c7868fff134bb50c7f654527d938_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-4c98c7868fff134bb50c7f654527d938_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4c98c7868fff134bb50c7f654527d938_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家好，我是Yupeng Zhang，来自马里兰大学。今天。我要讲解我们撰写的论文：《安全机器学习：一个可扩展隐私保护机器学习系统》。这个工作由我和来自VISA研究院的Payman共同完成。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6721477e54585b952b82531819340465_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-6721477e54585b952b82531819340465_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6721477e54585b952b82531819340465_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-6721477e54585b952b82531819340465_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-6721477e54585b952b82531819340465_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现今，机器学习已被用在各个领域中，且引发了各个领域的变革。例如，机器学习可以用于图像处理、语音识别、异常检测、甚至下围棋。机器学习之所以在实际中的应用效果如此之好，是因为我们使用了大量的数据来训练机器学习模型。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c16fee1577c6e9d6eed416a8bc824874_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c16fee1577c6e9d6eed416a8bc824874_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c16fee1577c6e9d6eed416a8bc824874_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c16fee1577c6e9d6eed416a8bc824874_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c16fee1577c6e9d6eed416a8bc824874_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;虽然机器学习引发了变革，此技术也引入了安全问题：我们应该如何保护数据的隐私性？这里需要澄清一点，这里所指的隐私性与前面讲座中的隐私性不太相同。这里我们考虑的是用于训练机器学习模型的数据，如何保证这些数据的隐私性。毕竟作为终端用户，我们不想向公司分享我们的数据，让它们可以运行机器学习算法。我们应该如何解决这个问题？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9cce75892926c59bca8ef71d5c7b97fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9cce75892926c59bca8ef71d5c7b97fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9cce75892926c59bca8ef71d5c7b97fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9cce75892926c59bca8ef71d5c7b97fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9cce75892926c59bca8ef71d5c7b97fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;隐私保护机器学习为这类安全问题提供了一个解决方案，它允许公司执行相同的机器学习算法，但不需要得知用户的实际数据。这样一来，用户仍然可以获得机器学习算法带来的益处，同时可以实现数据隐私保护、不将数据泄露给公司。隐私保护机器学习研究领域已经有了很多的前置学术成果，幻灯片上列举了其中一些论文。这是一个非常前沿，进展速度很快的研究领域。&lt;/p&gt;&lt;p&gt;在我们的论文中，我们聚焦于下述安全模型：双服务器模型。在这个模型中，我们假定两个服务器分别属于两个不同的公司。两个服务器不会实施共谋攻击。作为终端用户，我们首先将数据拆分成两个分享值，分别将分享值发送给两个服务器。这样，单一服务器无法得到原始数据任何信息，因为它只能得到其中一个分享值。随后，两个服务器互相交互，执行两方安全计算，生成机器学习模型。这一安全模型的优点在于，首先，此模型将多方安全计算过程归约为两方安全计算过程，以此大幅提高计算效率。其次，上传数据后，用户即可处于离线状态，模型训练过程中用户不需要与服务器交互。此模型也可以解决下述问题：两个公司想共同训练模型，但不想将数据分享给对方。很多前置学术成果都使用了这一安全模型。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3082c37176c3af3a720265eb8ef3f408_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-3082c37176c3af3a720265eb8ef3f408_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3082c37176c3af3a720265eb8ef3f408_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-3082c37176c3af3a720265eb8ef3f408_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3082c37176c3af3a720265eb8ef3f408_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;本篇论文的主要贡献是，在此安全模型下，我们提出新的协议，支持隐私保护线性回归、逻辑回归、神经网络。特别地，我们综合使用了秘密分享、预计算三元组代数运算、以及混淆电路技术。从实现角度看，我们的系统与前置工作相比，效率有了量级上的提升。我们的系统支持大数据集模型训练，可以支持百万量级的数据集，五千个特征。本次讲座，我们主要关注线性回归和逻辑回归。相关技术可以推广到神经网络模型训练中，大家可以阅读我们的论文，以了解更多的技术细节。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-41652e8cfd49e1d648fc31518e3dad28_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-41652e8cfd49e1d648fc31518e3dad28_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-41652e8cfd49e1d648fc31518e3dad28_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-41652e8cfd49e1d648fc31518e3dad28_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-41652e8cfd49e1d648fc31518e3dad28_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先，什么是线性回归？假设我们将数据点和与之相关的结果值画在图中，如幻灯片所示。线性回归要根据图中的点，尝试拟合出一条与点尽可能吻合的线。形式化地讲，输入是数据值对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 。这里 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 可以是一个向量，我们也称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 为特征值。 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 是一个单值，我们也称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 为标签值。输出的模型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+w&quot; alt=&quot;\vec w&quot; eeimg=&quot;1&quot;/&gt; 是一个系数向量，其维度大小与输入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 的维度大小相同。我们要求 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+w&quot; alt=&quot;\vec w&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 的内积结果应该与y值非常近似。实际上，模型定义了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+x&quot; alt=&quot;\vec x&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 之间的线性关系。&lt;/p&gt;&lt;p&gt;为了训练模型，我们这里引入随机梯度下降算法，简称SGD算法。我们把这个问题看成一个最优化问题，尝试找到一个最佳模型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+w&quot; alt=&quot;\vec w&quot; eeimg=&quot;1&quot;/&gt; ，使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y%5E%2A&quot; alt=&quot;y^*&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 的距离取得最小值。算法首先将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+w&quot; alt=&quot;\vec w&quot; eeimg=&quot;1&quot;/&gt; 初始化到一个随机位置上。随后，算法从数据集中选取一个随机样本。算法根据当前模型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec+w&quot; alt=&quot;\vec w&quot; eeimg=&quot;1&quot;/&gt; 计算预测值，并将结果与正确的标签值进行比较。比较结果将告诉算法，应该往哪个方向移动，以得到最优解。可以证明，如果重复上述步骤，最终模型会收敛到最优位置。这就是SGD算法。&lt;/p&gt;&lt;p&gt;对于线性回归这一特殊算法，更新函数可以用幻灯片上的公式表示。正如大家所看到的，更新公式非常简单，更新公式只涉及到乘法运算和减法运算。因此，一种很自然地实现隐私保护线性回归的方法是，将秘密分享与分享值代数运算直接应用到线性回归算法上，这应该可以解决隐私问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0bb0bd37729f445e18a3c10f08a94ed8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-0bb0bd37729f445e18a3c10f08a94ed8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0bb0bd37729f445e18a3c10f08a94ed8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-0bb0bd37729f445e18a3c10f08a94ed8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-0bb0bd37729f445e18a3c10f08a94ed8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;整个场景描述如下。用户首先将数据和标签值进行秘密分享。服务器随机初始化模型，同样对模型执行秘密分享。随后，我们直接应用预计算的三元组，一遍又一遍地在分享值上执行更新函数，这就能解决问题了。但这里有一个很大的问题，因为秘密分享和分享值代数运算只能在整数域上执行，例如在模质数下的整数域执行，但只有当参数带小数时，线性回归和SGD算法才能正确执行。我们如何在整数域上实现带小数的运算？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-61c24ce104b5bd979ebb4602ce96dda6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-61c24ce104b5bd979ebb4602ce96dda6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-61c24ce104b5bd979ebb4602ce96dda6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-61c24ce104b5bd979ebb4602ce96dda6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-61c24ce104b5bd979ebb4602ce96dda6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这就引出了我们的第一个贡献。我们给出了一种方法，可以在整数域上直接执行带小数乘法。具体思想如下。考虑存在两个幻灯片上所示的带小数点的数，我们知道这两个数对应的明文。随后，在不丧失计算精度的条件下将两个数相乘，我们可以得到结果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 的小数部分为原来的2倍。这里我们假定整数部分足够大，不会超过有限域的范围。如果不考虑小数点，小数部分的乘法运算和整数部分的乘法运算完全一致，这很不错。问题在于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 会变长，如此计算下去， &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 的长度会越来越长，最终超过整数域的范围，导致溢出。解决此问题的一种直观方法是进行截断，即直接扔掉 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 的小数点最后几位。这样一来， &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 的长度就和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 、 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;/&gt; 相同了。这一方法称为定点乘法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9ff86746686645d10ad92c790d729f54_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9ff86746686645d10ad92c790d729f54_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9ff86746686645d10ad92c790d729f54_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9ff86746686645d10ad92c790d729f54_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9ff86746686645d10ad92c790d729f54_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在论文中我们证明：可以在分享值上应用相同的截断技巧。具体来说，这里我们有两个服务器上分享的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;/&gt; ，也就是说，这两个数分别被一个大整数域上的大随机数所遮盖。随后，我们应用预计算三元组执行乘法操作，得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 的分享值，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_0&quot; alt=&quot;c_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1&quot; alt=&quot;c_1&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_0&quot; alt=&quot;c_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1&quot; alt=&quot;c_1&quot; eeimg=&quot;1&quot;/&gt; 中编码了全精度乘法计算结果。随后，两个服务器分别独立地对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_0&quot; alt=&quot;c_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1&quot; alt=&quot;c_1&quot; eeimg=&quot;1&quot;/&gt; 进行截断，此过程不引入任何通信开销。我们证明截断后，应用两个分享值仍然可以以很高的概率恢复出定点乘法的计算结果，只不过计算结果的最后一位小数上会增加一个非常小的误差值。这就是我们的技术方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2541e0fe3f6f1307a264c58853b10eec_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-2541e0fe3f6f1307a264c58853b10eec_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2541e0fe3f6f1307a264c58853b10eec_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-2541e0fe3f6f1307a264c58853b10eec_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2541e0fe3f6f1307a264c58853b10eec_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;回到协议层面上，应用此技术方案，每一次乘法运算中，我们都对结果分享值简单截断，这样就完成了整个隐私保护线性回归协议的实现。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b93bd666ce96e03cc107f6b766a8a143_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b93bd666ce96e03cc107f6b766a8a143_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b93bd666ce96e03cc107f6b766a8a143_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b93bd666ce96e03cc107f6b766a8a143_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b93bd666ce96e03cc107f6b766a8a143_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里向大家展示截断技术的应用效果。由于此技术只在计算结果的最后一个比特中引入了非常小的噪声，因此整个计算过程的执行时间几乎和在明文上应用小数执行整个计算过程的时间相同。具体来说，在各种不同的场景下，我们所提出的技术要比定点乘法混淆电路快4-8倍。线性回归部分就这些内容。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b1df5c578a2d6070d526a954c34ce7d1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-b1df5c578a2d6070d526a954c34ce7d1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b1df5c578a2d6070d526a954c34ce7d1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-b1df5c578a2d6070d526a954c34ce7d1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b1df5c578a2d6070d526a954c34ce7d1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;下一部分，逻辑回归。逻辑回归主要用在分类问题上，我们要尝试将数据分成两个类型。形式化地讲，逻辑回归中的数据值对和线性回归相同。但在逻辑回归中， &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt; 是一个比特值，取值为0或者1，分别表示两种分类结果。&lt;/p&gt;&lt;p&gt;逻辑回归和线性回归的区别是，我们要在内积结果上进一步执行一个额外的函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f&quot; alt=&quot;f&quot; eeimg=&quot;1&quot;/&gt; ，此函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f&quot; alt=&quot;f&quot; eeimg=&quot;1&quot;/&gt; 一般称为激活函数。逻辑回归中的激活函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f&quot; alt=&quot;f&quot; eeimg=&quot;1&quot;/&gt; 为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B1%2Be%5E%7B-u%7D%7D&quot; alt=&quot;\frac{1}{1+e^{-u}}&quot; eeimg=&quot;1&quot;/&gt; ，函数图像如幻灯片所示。&lt;/p&gt;&lt;p&gt;我们仍然可以使用SGD算法来训练模型。令人惊讶的是，逻辑回归的更新函数几乎与线性回归完全相同，唯一的区别是我们要在内积结果上额外调用一次激活函数f。更新函数的其它地方都与线性回归完全相同。这意味着如果我们可以通过安全多方计算的方式计算函数f，我们就可以把这个计算过程应用到原始线性回归协议中，即可实现逻辑回归。但事实证明，这会面临巨大的挑战，因为函数f涉及到精确到小数的自然对数求幂。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97be932c275c66b2c23331bf46004a4a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-97be932c275c66b2c23331bf46004a4a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97be932c275c66b2c23331bf46004a4a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-97be932c275c66b2c23331bf46004a4a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97be932c275c66b2c23331bf46004a4a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如何实现此计算过程？传统方法是应用所谓的多项式近似方式。幻灯片给出了10阶多项式近似激活函数f的图像。正如大家所看到的，近似图像与逻辑回归激活函数非常接近，但是通过安全计算方式实现近似函数的计算，会引入较大的计算开销，因为我们至少需要执行10次乘法计算，才能完成10阶近似多项式的计算过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-03cf6704ad1088671c35ad928a245f5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-03cf6704ad1088671c35ad928a245f5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-03cf6704ad1088671c35ad928a245f5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-03cf6704ad1088671c35ad928a245f5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-03cf6704ad1088671c35ad928a245f5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在我们的论文中，我们重点考虑，激活函数的作用究竟是什么？因为我们要解决的是分类问题，我们实际需要的是一个值域为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B0%2C1%5D&quot; alt=&quot;[0,1]&quot; eeimg=&quot;1&quot;/&gt; 的激活函数，并且此函数在0点附近应该大幅递增。那么，我们能不能用这样一个函数作为激活函数？我们证明，把此函数作为激活函数，所得模型的准确性和原始逻辑回归函数准确性相同。但更重要的是，我们可以应用混淆电路高效地通过安全多方计算方式实现此激活函数。此激活函数只涉及到减法运算和与0比大小，后者本质上是查看最高位比特值是否为0。&lt;/p&gt;&lt;p&gt;因此，这引出了我们论文的另一个贡献。我们提出了一个新的概念：适用于安全多方计算的激活函数。我们不再通过已有方法近似计算激活函数，我们后退一步，思考我们到底需要满足何种条件的激活函数。随后，我们尝试提出一个新的激活函数，其可以高效地通过多方安全计算的方式实现。回到协议中来，我前面也讲到，我们只需要执行和线性回归相同的协议。在计算内积结果后，我们转换到混淆电路上计算激活函数的结果，再切换回原始协议中。这就是隐私保护逻辑回归的完整协议了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-796f835b0d3c9b9650841246d01b3a1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-796f835b0d3c9b9650841246d01b3a1d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-796f835b0d3c9b9650841246d01b3a1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-796f835b0d3c9b9650841246d01b3a1d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-796f835b0d3c9b9650841246d01b3a1d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还在论文中引入了一些其它的优化方法，如向量化，即所有计算过程都可以用矩阵形式表示。这种方式可以大幅提高计算效率。进一步，这一技术可以推广到神经网络训练中。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cf0b00452707e7093ed008a3af8054fc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cf0b00452707e7093ed008a3af8054fc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cf0b00452707e7093ed008a3af8054fc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cf0b00452707e7093ed008a3af8054fc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cf0b00452707e7093ed008a3af8054fc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后，我给大家讲解我们的实验结果。我们在包含10万条数据、每条数据包含500个特征的数据集上进行了实验。我们的协议可以很自然地分为2个阶段。第一个阶段是与数据无关的离线阶段，此阶段要生成乘法三元组。第二个阶段是在线阶段，此阶段要训练算法。&lt;/p&gt;&lt;p&gt;在局域网环境下，网络带宽为1.2GB/s，网络时延为0.17ms。协议的离线阶段需要花费大约400秒。协议的在线阶段执行速度非常快，只需要花费1.4秒，只比明文数据训练慢2倍。&lt;/p&gt;&lt;p&gt;在广域网环境下，网络带宽为9MB/s，网络时延为72ms。离线阶段大约要花费9000秒，在线阶段要花费141秒。即使在广域网环境下，我们系统的执行效率也要比前置工作快54倍。&lt;/p&gt;&lt;p&gt;进一步，我们观察到离线阶段是我们系统的性能瓶颈。我们进一步提出了一个替代方案，在用户的帮助下生成乘法三元组。应用这一方案，我们可以大幅降低离线阶段的时间开销，稍稍提高在线阶段的时间开销。不过此方案会减弱系统的安全模型。如果应用此方案，我们需要进一步假设客户端不与任意一个服务器实施共谋攻击。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-87fb0a4865bf486be9a0ebc5c646d3ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-87fb0a4865bf486be9a0ebc5c646d3ad_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-87fb0a4865bf486be9a0ebc5c646d3ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-87fb0a4865bf486be9a0ebc5c646d3ad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-87fb0a4865bf486be9a0ebc5c646d3ad_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接下来是逻辑回归的实验结果。正如我前面所讲到的那样，我们协议的一大优势在于，与线性回归相比，逻辑回归不会额外使用更多的预计算乘法三元组。因此，逻辑回归离线阶段时间消耗与线性回归离线阶段的时间消耗相同。在线阶段，我们需要进一步执行一次混淆电路，并引入一次额外的信息交互，额外增加的时间消耗如幻灯片所示。总消耗时间与线性回归仍处在同一个量级。据我们所知，这是在此安全模型下第一个实现隐私保护逻辑回归的研究成果。此系统可以支持100万条数据集，每条数据集包含5000个特征。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3506e296911e54bcf75803779e2a594c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-3506e296911e54bcf75803779e2a594c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3506e296911e54bcf75803779e2a594c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-3506e296911e54bcf75803779e2a594c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3506e296911e54bcf75803779e2a594c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后是神经网络。我们实现了包含2个隐藏层，每层包含128个神经元的神经网络。这里我们直接给出端到端的性能测试结果。综合考虑了在线阶段和离线阶段，在局域网环境下，训练此神经网络的时间大约为25,000秒，训练所消耗的时间是明文训练所消耗时间的35倍。在广域网环境下，性能会变得更加糟糕。对于此量级的数据集，总训练时间约为200,000秒。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fd9a25e319b65dfca10473fb7e8f0113_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-fd9a25e319b65dfca10473fb7e8f0113_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fd9a25e319b65dfca10473fb7e8f0113_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-fd9a25e319b65dfca10473fb7e8f0113_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-fd9a25e319b65dfca10473fb7e8f0113_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后是总结。本文提出了一个新的协议，实现隐私保护线性回归、逻辑回归、神经网络。特别地，我们引入了一种新的方法，可以直接在整数域下实现带小数乘法。我们提出了一个容易通过安全多方计算方式实现的激活函数。我们引入了向量化优化方式。从实现角度看，我们系统的执行效率比前置工作高几个数量级，可以支持大数据集训练。这就是我讲座的全部内容了，谢谢大家。&lt;/p&gt;&lt;p&gt;主持人：台下有两个麦克风，听众可以用麦克风提问。&lt;/p&gt;&lt;p&gt;提问者：我来问个问题。在SGD算法下，你们给出了三个技术提高了安全多方计算场景下SGD算法的效率。你是否可以介绍一下，每个技术分别对算法提供了多大的优化量？&lt;/p&gt;&lt;p&gt;主讲人：我们在论文中给出了详细的基准测试结果。简单总结一下，与通用方案相比，每个独立的技术都将算法速度提高了10倍左右，但需要把这几个技术组合起来使用。例如，带小数乘法运算不能用在混淆电路上，你只能在分享值代数计算过程中应用带小数乘法计算的相关优化技术。把各技术综合起来，算法的总执行效率会提高好几个量级。&lt;/p&gt;&lt;p&gt;提问者：非常感谢。&lt;/p&gt;&lt;p&gt;提问者：你好，我是John Percival，来自罗切斯特大学。我有个很简单的问题。你们是通过仿真完成的广域网实验，还是在真实的广域网环境下完成的实验？&lt;/p&gt;&lt;p&gt;主讲人：我们在亚马逊的机器上实现了我们的方案。一台机器位于美国东海岸，一台机器位于美国西海岸。因此，这是个真实的实验，没有仿真过程。&lt;/p&gt;&lt;p&gt;提问者：好的，谢谢。&lt;/p&gt;&lt;p&gt;主讲人：好的。&lt;/p&gt;&lt;p&gt;主持人：我们再次对演讲者表示感谢。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-04-54108699</guid>
<pubDate>Fri, 04 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Ouroboros：可证明安全的权益证明协议</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-10-04-43005995.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43005995&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4b90b274ea0062a31690c5d092b90f1d_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;2019年10月04日更新：重新上传了视频，将讲解内容的幻灯片截图和每页幻灯片对应的演讲内容附在了文章中。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;演讲视频简介&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;今天给各位知友带来另外一个存货视频《Ourboros：可证明安全的权益证明协议》。替代工作量证明机制（Proof of Work，PoW）的权益证明机制（Proof of Stake，PoS）已经成为了区块链领域的一个重点研究方向。与PoW相比，PoS具有下述优势（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Proof of Stake FAQs&lt;/a&gt;）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不需要消耗大量的电力来保证区块链的安全性。&lt;/li&gt;&lt;li&gt;由于不需要大量电力消耗，参与方不需要得到更多的代币奖励即可参与到网络中。&lt;/li&gt;&lt;li&gt;权益证明的使用可以进一步在区块链中引入博弈论机制，从而形成市场经济体制。&lt;/li&gt;&lt;li&gt;降低系统中心化的风险。&lt;/li&gt;&lt;li&gt;有能力应用经济学惩罚措施使得51%的攻击代价变得更高。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;以太坊权益证明机制优势的原始英文描述如下，供参考：&lt;br/&gt;1. &lt;b&gt;No need to consume large quantities of electricity&lt;/b&gt; in order to secure a blockchain (e.g. it&amp;#39;s estimated that both Bitcoin and Ethereum burn over $1 million worth of electricity and hardware costs per day as part of their consensus mechanism).&lt;br/&gt;2. Because of the lack of high electricity consumption, there is &lt;b&gt;not as much need to issue as many new coins&lt;/b&gt; in order to motivate participants to keep participating in the network. It may theoretically even be possible to have &lt;i&gt;negative&lt;/i&gt; net issuance, where a portion of transaction fees is &amp;#34;burned&amp;#34; and so the supply goes down over time.&lt;br/&gt;3. Proof of stake opens the door to a wider array of techniques that use game-theoretic mechanism design in order to better &lt;b&gt;discourage centralized cartels&lt;/b&gt; from forming and, if they do form, from acting in ways that are harmful to the network (e.g. like &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;selfish mining&lt;/a&gt; in proof of work).&lt;br/&gt;4. &lt;b&gt;Reduced centralization risks&lt;/b&gt;, as economies of scale are much less of an issue. $10 million of coins will get you exactly 10 times higher returns than $1 million of coins, without any additional disproportionate gains because at the higher level you can afford better mass-production equipment, which is an advantage for Proof-of-Work.&lt;br/&gt;5. Ability to use economic penalties to &lt;b&gt;make various forms of 51% attacks vastly more expensive&lt;/b&gt;to carry out than proof of work - to paraphrase Vlad Zamfir, &amp;#34;it&amp;#39;s as though your ASIC farm burned down if you participated in a 51% attack&amp;#34;.&lt;/blockquote&gt;&lt;p&gt;PoS的这些优势使得著名区块链平台以太坊（Ethereum）都宣布要用PoS代替PoW，并且已经提出了两种替代方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;综合使用PoS和PoW的协议：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ethereum/research/blob/master/papers/casper-basics/casper_basics.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Casper the Friendly Finality Gadget&lt;/a&gt;，由Vitalik Buterin（以太坊创始人）和Virgil Griffith提出。&lt;/li&gt;&lt;li&gt;不应用PoW，完全的PoS协议：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ethereum/research/blob/master/papers/CasperTFG/CasperTFG.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Casper the Firendly GHOST: Correct by Construction&lt;/a&gt;，由Vlad Zamfir提出。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但是，如何构造一个可证明安全的PoS机制是区块链社区、也是学术界研究的一个重点方向。在密码学最顶级的会议CRYPTO 2017上，Aggelos Kiayias、Alexander Russell、Bernardo David、Roman Oliynykow给出了一个证明安全的PoS协议：Ouroboros。而本次带来的视频，就是论文作者之一Aggelos Kiayias在CRYPTO 2016会议上的论文演讲视频。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;相关信息&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;论文下载链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//eprint.iacr.org/2016/889.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;eprint.iacr.org/2016/88&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;9.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DfBKCbhX-dXI%26t%3D983s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=fBKCbhX-dXI&amp;amp;t=983s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av70033085/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av70&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;033085/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;中文字幕视频&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;知乎已经支持长视频的上传，我们也就没有必要将一个视频拆分为两个了。视频经过了一轮校对，修改了几个错字。&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1163474128312201216&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic2.zhimg.com/v2-93a05431754cd2ef75de353fcbb8add1.jpg&quot; data-lens-id=&quot;1163474128312201216&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-93a05431754cd2ef75de353fcbb8add1.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1163474128312201216&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5e55c07180c8823e104c147d8e672711_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-5e55c07180c8823e104c147d8e672711_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5e55c07180c8823e104c147d8e672711_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-5e55c07180c8823e104c147d8e672711_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5e55c07180c8823e104c147d8e672711_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;感谢大家前来聆听本会场的最后一个讲座，这一天确实比较漫长。在本讲座中，我将向大家介绍Ouroboros，一个可证明安全的权益证明协议。这是我和Alexander Russell、Bernardo David和Roman Oliynykov的工作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c21f8755cf4bda8ac94c58c9e704740d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-c21f8755cf4bda8ac94c58c9e704740d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c21f8755cf4bda8ac94c58c9e704740d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-c21f8755cf4bda8ac94c58c9e704740d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c21f8755cf4bda8ac94c58c9e704740d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;既然大家来到本会场听讲座，应该已经了解我们想实现的账本目标了。我们的目标是构造一个协议，实现一个健壮的交易账本。这是由Juan Garay、我、以及Nikos Leonardos提出的目标，论文缩写为GKL，我们给出了形式化定义。这就是我们的目标，这也引出了其它一些后续工作。这些工作对模型进行了精炼，给出了更好的定义。一些工作也出现在本会场前面的讲座中。我们现在可以认为，我们最终得到了一个基于仿真的、可组合的目标定义。一旦有了设计目标，有了很明确的方向，我们就会问这样一个问题：我们是否知道实现这一目标的最佳方法？而本会场最后这个讲座的目标就是要回答这个问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-738b5f1ab18e932a09fd0de9d9b23740_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-738b5f1ab18e932a09fd0de9d9b23740_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-738b5f1ab18e932a09fd0de9d9b23740_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-738b5f1ab18e932a09fd0de9d9b23740_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-738b5f1ab18e932a09fd0de9d9b23740_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们知道，可以通过比特币等其它我所引用的前人工作所提到的技术来实现账本目标。但我们也知道，在现实生活中执行的协议效果告诉我们，目前实现的账本目标具有扩展性差、能源消耗多等缺点。我们是否可以用一种更高效的方法实现账本目标？至少到目前为止，我们有一个称为权益证明的思想。比特币社区早在2011年就提出了这个想法，这可能是一种设计高效账本记录方式的方法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e590a082723faaea39bf54f5631bda1c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-e590a082723faaea39bf54f5631bda1c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e590a082723faaea39bf54f5631bda1c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-e590a082723faaea39bf54f5631bda1c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e590a082723faaea39bf54f5631bda1c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;权益证明的基本思想和技术背景是什么呢？前面其它学者的讲座中也强调，可以认为比特币执行过程的核心目标是实现选举过程。下一个区块是通过选举来产生的。某个协议参与方，也就是矿工，会被选择上，有权利对链进行扩展。被选择上的概率正比于参与方计算哈希值的能力。同时，全网通过一定的规则来解决碰撞问题。一般使用最长链规则或最大难度链规则。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-850656bbb240318bef016ca7c8c2be08_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-850656bbb240318bef016ca7c8c2be08_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-850656bbb240318bef016ca7c8c2be08_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-850656bbb240318bef016ca7c8c2be08_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-850656bbb240318bef016ca7c8c2be08_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;权益证明背后也遵从类似的思想，但权益证明使用实体所拥有的权益来完成选取。个体拥有的权益同样体现在账本上。权益证明将个体的权益考虑其中，通过随机化过程选举出下一个扩展链的实体。从某种角度上看，这一过程的基本逻辑也反应出当前现实生活中协议的执行逻辑，因为在现实生活中，我们可以用资金来购买哈希计算能力，通过投入更多的资金 你可以提高在系统中被选择上的概率。但权益证明从某种程度上看舍弃了协议执行过程中物理层面的印记，直接使用区块链本身记录的权益作为实体选举过程的参考，用于对区块链进行扩展。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2367110a07c9df17a00943df65f086eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-2367110a07c9df17a00943df65f086eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2367110a07c9df17a00943df65f086eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-2367110a07c9df17a00943df65f086eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2367110a07c9df17a00943df65f086eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以按照我们感兴趣的两个维度，对所有的协议进行分类。图中y轴表示执行协议的性能或消耗的能量高低，越大表示性能越好，能量消耗越低。x轴表示协议支持的去中心化程度。当同时考虑这两个因素时，我们可以认为我们的目标是实现一个账本。一方面我们已经有了中心化的数据库，很容易知道此数据库位于图中的左上角。我们也有比特币，它位于图中的右下角，更去中心化，但能源消耗很大。还可以直接将其它业务场景下的协商协议引入账本。我们可以看到，这种账本与比特币相比更加中心化，并且效率比中心化数据库低。毕竟在中心化数据库中，单一节点失效会使得全节点失效。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3460399bbb5e0cc2e5d15591e664c44d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-3460399bbb5e0cc2e5d15591e664c44d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3460399bbb5e0cc2e5d15591e664c44d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-3460399bbb5e0cc2e5d15591e664c44d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3460399bbb5e0cc2e5d15591e664c44d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果我们可以设计出权益证明协议，至少我们认为其有希望位于图中的右上角，因为权益证明协议会比通过协商协议实现的账本更加去中心化，因为权益的分布情况会随时间的变化而变化。但同时，协议可以实现每一次心跳都生成一个区块。如果执行协议的参与方变得特别多，协议的执行结果也不会变得太过糟糕。如果能实现这样一个协议，我们就既可以做到去中心化，又可以做到协议高效执行。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e92e61dd072c56d972ad8f2183d64a6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-e92e61dd072c56d972ad8f2183d64a6d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e92e61dd072c56d972ad8f2183d64a6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-e92e61dd072c56d972ad8f2183d64a6d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e92e61dd072c56d972ad8f2183d64a6d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在最早期刚提出权益证明思想的时候，人们认为权益证明有可能达成上述目的。但很快，人们就意识到，设计权益证明协议会遇到很严重的挑战。第一个挑战是存在所谓的“粉碎攻击”，因为选举过程成为了一个可计算协议，并且选取过程也会反应在区块链上，与比特币工作量证明协议相比，攻击者可以绕过协议的理想执行过程。部分实体可能利用其计算能力使协议的执行结果发生偏斜，使结果对自己有利。所有基于权益证明的区块链协议都会面临粉碎攻击问题。另一个被广泛研究的权益证明协议攻击方法称为“无权益风险”攻击。这一攻击反应的事实是，权益拥有者没必要严格按照协议对指定的链进行扩展。权益拥有者可以尝试同时扩展多个链。最后，权益证明还面临一个循环的问题。从某种角度看，我们在区块链上执行一个协议，产生随机量。但与此同时，协议的安全性也就不得不依赖于区块链。因此，如果要证明协议的安全性，我们要绕开随机量生成与区块链安全性的约束关系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-973dca3199eca3da1a27eaaf5847d333_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-973dca3199eca3da1a27eaaf5847d333_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-973dca3199eca3da1a27eaaf5847d333_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-973dca3199eca3da1a27eaaf5847d333_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-973dca3199eca3da1a27eaaf5847d333_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这就是我们的境地。现在的问题是，是否可以只使用权益证明思想实现我们期望的账本目标？我们简单论述一下协议。假定全网是同步的，时间按轮数进行划分，每一轮称为一个时间槽。网络中的每一条消息都可以在全网扩散。在前面的两个讲座中，大家应该也看到过与之相同的网络模型。攻击者非常激进，这意味着攻击者掌握了很多攻击能力。他可以传递消息、篡改消息、在消息中注入自己想要的内容、重排列消息接收顺序，可以将一些消息只发送给部分参与方，可以拒绝将自己接收的消息发送给别人。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f9e2c0d12183127ae9dc77bab8dde043_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-f9e2c0d12183127ae9dc77bab8dde043_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f9e2c0d12183127ae9dc77bab8dde043_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-f9e2c0d12183127ae9dc77bab8dde043_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f9e2c0d12183127ae9dc77bab8dde043_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在这样的场景下，我们首先来看看我们协议的执行过程。这是协议执行的第一步。此时我们需要假设权益是静态的。我们拥有固定量级的权益拥有者。每一位权益拥有者的权益都在最开始时初始化好。每一位权益拥有者都拥有特定的权益量。权益量是预定义好的，权益拥有者的权益量写在创始区块中。创世区块还包含一个种子。可以认为这个种子是一个随机字符串。种子可以为每一个时间槽随机选择并指派一个所谓的领导者。这个领导者将负责在特定的时间槽内生成区块。对于每一个时间槽，只有一个实体负责生成区块。由于种子包含在创始区块中，因此系统已经确定好每一个时间槽所对应的领导者了。时间槽领导者的采样权重源于权益拥有者所拥有的权益分布。这意味着拥有的权益越多，权益拥有者越有可能被选为特定时间槽的领导者。除此之外，整个选举过程是独立随机的。现在，协议开始执行。所有权益拥有者拥有一个公钥和一个私钥，用于生成数字签名。现在，对于每一个时间槽，协议的执行过程都非常简单。每一个时间槽都指定了一个领导者，这个领导者将生成一个区块。但是，实际中实体并不会严格执行此协议。例如，某个时间槽领导者可能处于离线状态，他也可能被攻击者所控制，拒绝执行协议。此种情况下，整个协议仍然继续执行。参与方会根据最长链规则扩展前一个区块。协议非常简单，和比特币基本完全一致，但参与方不需要在解决困难问题了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0d0d6300fa7e7f7a31f2c1986bd5f70_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-c0d0d6300fa7e7f7a31f2c1986bd5f70_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0d0d6300fa7e7f7a31f2c1986bd5f70_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic1.zhimg.com/v2-c0d0d6300fa7e7f7a31f2c1986bd5f70_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c0d0d6300fa7e7f7a31f2c1986bd5f70_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;整个协议非常简单。但如何分析这个协议呢？幻灯片给出了我们对协议的安全性分析方法。我们需要了解的第一个重要目标是所谓的“特征字符串”。特征字符串的长度与系统执行过程涉及到的时间槽数量一致。当时间槽归属诚实实体，则对应字符为0。如果归属恶意实体，则对应字符为1。注意到参与方本身无法知道特征字符串的取值，但我们可以观察协议执行过程和攻击者的执行策略获取特征字符串的取值。假定幻灯片上给出的就是协议执行过程中生成的特征字符串，我们来看看协议是如何执行的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-04c5cb9a016f53e68fa3440409d26f39_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-04c5cb9a016f53e68fa3440409d26f39_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-04c5cb9a016f53e68fa3440409d26f39_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-04c5cb9a016f53e68fa3440409d26f39_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-04c5cb9a016f53e68fa3440409d26f39_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;根据协议执行过程，我们可以定义一个区块树，我们称之为“分叉”，可以通过特征字符串生成这一区块树。最开始的特征字符为0，对应的是创始区块。我们假定创始区块的参与方总是诚实的。现在，我们有了第一个时间槽。一个诚实的参与方生成了区块1。接下来，我们看到了一个关联了攻击者的时间槽。不失一般性，攻击者不一定非要在轮到他操作的一瞬间就采取行动。攻击者可以等待，当时间槽将要切换到诚实参与方操作的时候再采取行动。攻击者可以执行下述攻击行为：控制时间槽2的攻击者将产生一个区块，使得诚实参与方将在3的位置生成区块。现在，区块链将会分为两个分支。因此，这个诚实参与方将会沿着上面的分支进行扩展。我们称此现象为一个尖叉。整个攻击过程会导致区块链出现3个分支，而攻击者可以规划整个攻击方式，他可以强制沿着中间分支扩展区块链。我们来看看位置5所发生的事情。在这一时刻，攻击者控制了时间槽4，他在下方生成区块，并告知时间槽5关联的参与方。注意到此参与方会发现，包含创始区块在内，中间和下方两个分支的长度都为3。由于攻击者可以控制消息的发送顺序，他可以说服参与方在5的位置扩展区块链。攻击者随后通过类似的方法在6的位置扩展区块链。最后，攻击者说服参与方在9的位置生成新的区块。我们观察到的结果是，前面所描述的简单协议，其实际执行结果可能非常复杂。这是因为攻击者可以控制诚实参与方，使其对区块链上不同的位置进行扩展。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1e5349d537befcfb3a482f0f8d27406d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-1e5349d537befcfb3a482f0f8d27406d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1e5349d537befcfb3a482f0f8d27406d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-1e5349d537befcfb3a482f0f8d27406d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-1e5349d537befcfb3a482f0f8d27406d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这会出现什么问题呢？从工作量证明开始。我们已经广泛研究了共识机制。如何从共识机制角度考虑此协议？正如所见，我们面临的情况和工作量证明不太一样。首先，攻击者的攻击难度会大幅降低。与基于工作量证明的协议执行过程相比，攻击者更容易实施攻击。为什么？因为攻击者可以事先知道哪个权益拥有者将会被激活。攻击者可以在不付出任何代价的前提下，在相同的时间槽中创建多个不同的区块。这与比特币的执行机制不同。在比特币中，攻击者需要投入计算资源来扩展区块链，但现在情况不一样了。最后，攻击者可以等到快到诚实节点行动的时候再采取行动。当时间槽指向攻击者自己时，他完全可以先等待，不采取任何行动。他可以等到诚实节点激活的时候再采取行动。他可以根据情况采取最佳攻击策略。因此，攻击者不需要提前告知其想如何扩展区块链。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c9db570bec62ce361f85ae446dd3ba6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-c9db570bec62ce361f85ae446dd3ba6d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c9db570bec62ce361f85ae446dd3ba6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-c9db570bec62ce361f85ae446dd3ba6d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c9db570bec62ce361f85ae446dd3ba6d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们来观察一下特征字符串。幻灯片给出了两个特征字符串。在协议实际执行过程中，特征字符串的可能性有指数多个。攻击者更喜欢看到哪个特征字符串呢？大家可以看到，很明显攻击者不喜欢结果为000的特征字符串。攻击者无法对这种特征字符串对应的区块链实施任何攻击。区块按顺序组织，没有分叉。另一方面，看看这个特征字符串00110001。攻击者完全可以对这个特征字符串对应的区块链实施攻击，我们称其为可分叉的。攻击者如何实施攻击？大家可以看看，为何我们称此字符串是可分叉的呢？仔细看看当前区块链的状态。如果你是下一个被激活的诚实参与方，你该如何行动？我们来看看会发生什么。大家可以看到，攻击者有明确的自主权，决定产生分叉的时间上限和时间下限。这是因为上方分叉的长度为5，下方分叉的长度为4，但是攻击者控制着此时间槽。因此，当你作为诚实参与方生成区块时，你沿着哪个分叉进行扩展完全由攻击者决定。这种情况下，攻击者可以成功实施攻击。此特征字符串比较糟糕，我们称其为可分叉。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23d6071afc168e2ea32458bdb3081987_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-23d6071afc168e2ea32458bdb3081987_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23d6071afc168e2ea32458bdb3081987_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-23d6071afc168e2ea32458bdb3081987_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-23d6071afc168e2ea32458bdb3081987_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里的核心点在于，如果我们随机选择一个特征字符串，其可分叉的概率有多大？这就是安全性分析的核心点。为了明白这一点，我们需要引入两个很有帮助的参数，两个参数分别称为到达量和边缘量。我们首先要关注的是所谓的封闭分叉。封闭分叉指的是分叉的结尾区块与一个诚实参与方关联，区块树的叶子节点是一个诚实参与方。注意，我们不需要考虑结尾区块与攻击者关联的分叉，因为攻击者随时可以在适当的时间在与攻击者关联的分叉后方填充任意区块。对于一个封闭区块，我们可以定义两个很有用的参数。第一个参数是保留量，其表示攻击者可以在后方增加多少个区块。幻灯片上，上方分叉的保留量是3，因为后面有三个时间槽是属于攻击者的。例如，当诚实参与方在第3时间槽上激活时，攻击者可以保留3个区块，并增加到后方。同时，还可以定义另一个参数，称为间隔量，表示此分支成为主链所需的时间。&lt;/p&gt;&lt;p&gt;如果我们用保留量减去间隔量，我们就定义了所谓的到达量。这个量告诉我们，此分叉需要多长时间才能成为主链。在我们的概率分析中，到达量和边缘量是两个非常重要的参数。好消息是，组合这几个参数后我们可以知道，如果一个特征字符串是可分叉的，当且仅当存在一个封闭区块，此区块的边缘量为0，或者至少为0。而边缘量指的是我们取最长链的到达量，将最长链的到达量与第二长链的到达量进行对比，并且计算这两个链到达量的差，我们应用到达量和边缘量建立了概率分析模型。&lt;/p&gt;&lt;p&gt;我们会发现，当新的权益拥有者增加区块时，到达量和边缘量构成了随机游走过程。当特征字符为1时，表示此时间槽被攻击，此时到达量和边缘量都增加了1。另一方面，当特征字符为0时 到达量和边缘量都会降低。这一过程反应在幻灯片最下方的这行公式上。如果事实真的如此，则到达量和边缘量构成简单的随机游走过程，但实际的协议执行过程中，只有最下方情况到达量和边缘量都会降低。在处于最下方情况时，到达量和边缘量都会降低。但实际上，到达量不可能降低到小于0。如果到达量是0，则到达量保持为0，因为到达量描述了攻击者的攻击优势。这个迭代公式中非常有趣的一点是，如果边缘量为0，则到达量会降低，因为攻击者可以在牺牲到达量的条件下对边缘量进行补偿。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-994232fa10530a7b1bed4fc4b60fd047_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-994232fa10530a7b1bed4fc4b60fd047_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-994232fa10530a7b1bed4fc4b60fd047_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-994232fa10530a7b1bed4fc4b60fd047_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-994232fa10530a7b1bed4fc4b60fd047_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，如果我们应用这个迭代公式，并且将此迭代公式应用在时间槽领导者采样实验中，我们实际上会得到一个二维随机游走过程。这个二维随机游走过程实际上非常简单，到达量和边缘量会交替为正或者为负。因此，这两个变量会构成一个简单的随机游走过程。但当到达量为正时，边缘量会降低，直到固定为0。因此，这个二维随机游走过程体现出了边缘量和到达量之间的相互关系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6eebc838015b7790dbcd00d2bb5c9e42_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-6eebc838015b7790dbcd00d2bb5c9e42_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6eebc838015b7790dbcd00d2bb5c9e42_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-6eebc838015b7790dbcd00d2bb5c9e42_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6eebc838015b7790dbcd00d2bb5c9e42_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在我们要考虑的问题是，当在这个随机游走过程中随机取一个长特征字符串，则最终得到边的边缘量至少为0的概率是多少？我们可以证明，这一情况出现的概率非常小，等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-%5Csqrt%7Bn%7D%7D&quot; alt=&quot;2^{-\sqrt{n}}&quot; eeimg=&quot;1&quot;/&gt; 乘以一个常数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d05a464763088403b8595dd4244dff0f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-d05a464763088403b8595dd4244dff0f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d05a464763088403b8595dd4244dff0f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-d05a464763088403b8595dd4244dff0f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d05a464763088403b8595dd4244dff0f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;关键点在于，我们可以把二维空间划分为3个区域，分别称为热区、脆弱区、冷区。脆弱区指的是边缘量和到达量的取值都接近为0，这实际上就是初始化状态。我们还有冷区 此时边缘值为负，此种情况下区块链是安全的。我们还有热区，此时区块链是不安全的。我们可以证明，在游戏开始时我们的初始状态为脆弱状态。从脆弱状态转移到热状态的概率无限接近于0，为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-%5Csqrt%7Bn%7D%7D&quot; alt=&quot;2^{-\sqrt{n}}&quot; eeimg=&quot;1&quot;/&gt; 。但从脆弱状态转移到冷状态的概率为常数。核心观察结论在于，一旦转移到了冷状态，则区块链将永远为冷状态，也就是说，随机游走过程的位置已经远离脆弱区和热区，我们是安全的。由于转移到热区的概率是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-%5Csqrt%7Bn%7D%7D&quot; alt=&quot;2^{-\sqrt{n}}&quot; eeimg=&quot;1&quot;/&gt; ，而转移到冷区的概率是常数，我们要做的是把时间划分成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Csqrt%7Bn%7D&quot; alt=&quot;\sqrt{n}&quot; eeimg=&quot;1&quot;/&gt; 个区域，证明在任意一个处理过程中，区块链都会有很高的概率从脆弱状态转移到冷状态，这意味着我们是安全的。最后，这意味着获得一个可分叉特征字符串的概率也是可忽略的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0c512ba97b9c67d864d9d28e9f1b7563_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-0c512ba97b9c67d864d9d28e9f1b7563_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0c512ba97b9c67d864d9d28e9f1b7563_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-0c512ba97b9c67d864d9d28e9f1b7563_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0c512ba97b9c67d864d9d28e9f1b7563_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有了这样一个基础协议，我们可以进一步设计出权益动态变化下的协议。在权益动态变化的条件下，我们要做的是在特定数量的时间槽中执行基础协议。当然，我们要假定创始区块初始化了一个随机种子。现在，假定我们有一个神奇的锚点，当区块链生成到给定的锚点时，我们可以得到一个新的种子，从而重新根据权益拥有者的权益分布生成新的记账顺序。到达锚点后，锚点会给我们另一个种子，我们用这个种子重新分配记账顺序。我们需要利用区块链自身的特性来更新权益拥有者的记账概率分布，而新的记账概率分布由一系列交易执行过程后，各个参与方的新权益量所决定。也就是说，我们根据区块链的一部分记录结果，应用锚点重新生成种子，然后再用新的种子创建更新后的权益拥有者记账概率分布，协议继续执行下去。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-95f6ed294841d11c690d6ea8f6b2866d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-95f6ed294841d11c690d6ea8f6b2866d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-95f6ed294841d11c690d6ea8f6b2866d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-95f6ed294841d11c690d6ea8f6b2866d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-95f6ed294841d11c690d6ea8f6b2866d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当然了，在现实生活中我们没有这样一个可信锚点，这么解决这个问题呢？答案是利用G.O.D，即保证“产出交付的硬币投掷”。“保证产出交付的硬币投掷”，或称G.O.D硬币投掷，可以确保输出的随机性。其基本意思是，如果协议的大多数执行方都是诚实的，则保证输出结果是无偏随机种子。我们要做的是要执行一小段时间的基础协议，产生一部分区块片段，这样我们就可以执行G.O.D硬币投掷协议，从而为下一个纪元产出一个随机种子。整个协议执行过程需要应用一个称为公开可验证密钥协商协议的工具，而我们可以通过简单的密码学工具构建公开可验证密钥协商协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-00aeab008d141d5227b7c705ff35c14a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-00aeab008d141d5227b7c705ff35c14a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-00aeab008d141d5227b7c705ff35c14a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-00aeab008d141d5227b7c705ff35c14a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-00aeab008d141d5227b7c705ff35c14a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;应用上述提到的所有工具和协议，我们最终证明账本可以达到目标。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0a9bbd1a013db7acf7329d10ff2ac76f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-0a9bbd1a013db7acf7329d10ff2ac76f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0a9bbd1a013db7acf7329d10ff2ac76f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-0a9bbd1a013db7acf7329d10ff2ac76f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0a9bbd1a013db7acf7329d10ff2ac76f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;虽然我没有时间讲解整个证明的细节，但我们可以通过理论证明，假定攻击者具有一定程度的适应性攻击能力，则Ouroboros协议的公共前缀、链质量、链生长速度等的错误率都是k的可忽略函数，这意味着可以用Ouroboros实现一个健壮的交易账本。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bfc7079a178aa3081ddff3b7a5ede2bb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-bfc7079a178aa3081ddff3b7a5ede2bb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bfc7079a178aa3081ddff3b7a5ede2bb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-bfc7079a178aa3081ddff3b7a5ede2bb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bfc7079a178aa3081ddff3b7a5ede2bb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt; 我在本次讲座中没时间讲解论文的全部内容了，各位可以在论文中发现一些其它成果。除了上述协议之外，我们还设计出了一个基于权重的激励模型。我这里跳过这几页幻灯片，我们直接来看最后的结论吧。我们证明，在Ouroboros协议上执行所设计的激励奖励机制可达到近似纳什均衡，而且与比特币相比，我们的激励机制与协议是完全兼容的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8efe4930a987dd381deeed5fae753dbe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-8efe4930a987dd381deeed5fae753dbe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8efe4930a987dd381deeed5fae753dbe_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic3.zhimg.com/v2-8efe4930a987dd381deeed5fae753dbe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-8efe4930a987dd381deeed5fae753dbe_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;进一步，我们设计实验测试了协议的性能，具体结论在这页幻灯片上。我们在亚马逊云上用40个节点运行了实验。我们实现了协议，并测试了协议的性能。大家可以看到，权益证明协议可以达到良好的性能。在这种简单的协议实现下，每秒确认的交易数量可以达到250个，大家可以把这个结果和每秒确认7、8、或者9个的比特币协议进行对比。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2382731de9641da1c019d84164fac2ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-2382731de9641da1c019d84164fac2ad_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2382731de9641da1c019d84164fac2ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-2382731de9641da1c019d84164fac2ad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2382731de9641da1c019d84164fac2ad_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;后续工作中，我们将解决本工作尚没有解决的问题。后续工作将解决半异步、或者部分同步网络，攻击者合谋条件下的协议设计问题。这个工作是我和Bernardo David、Peter Gazi和Alexander Russell一起完成的，大家可以在ePrint上读到此篇论文。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-39f33f7e35e9d8d44b59f30c840c745f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-39f33f7e35e9d8d44b59f30c840c745f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-39f33f7e35e9d8d44b59f30c840c745f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-39f33f7e35e9d8d44b59f30c840c745f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-39f33f7e35e9d8d44b59f30c840c745f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这些也是后续工作，大家在网上可以找到演讲视频。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d84722498c325ac5fca8d61d7e774f7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-5d84722498c325ac5fca8d61d7e774f7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d84722498c325ac5fca8d61d7e774f7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-5d84722498c325ac5fca8d61d7e774f7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-5d84722498c325ac5fca8d61d7e774f7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;讲座时间快到了，这些是相关工作，大家可以在ePrint版本或会议版本找到相关文献。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dc6001ef88678ec103a0e8c506db1f71_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-dc6001ef88678ec103a0e8c506db1f71_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dc6001ef88678ec103a0e8c506db1f71_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic2.zhimg.com/v2-dc6001ef88678ec103a0e8c506db1f71_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-dc6001ef88678ec103a0e8c506db1f71_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这就是幻灯片的最后一页了，感谢大家前来聆听讲座。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;一些思考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;从数学角度看，PoS协议是可以做到可证明安全的。但是，从非数学角度看，PoS是可证明安全的吗？其核心点在于我们如何定义权益？权益到底是什么？在没有公认锚点的情况下，权益的定义一旦有问题，整个区块链的机制似乎就不成立了。在此，我仅引入“橙皮书”对Nervos创始人Jan的采访。&lt;/p&gt;&lt;blockquote&gt;2018年08月27日更新：感谢匿名知友指出的问题，对Nervos创始人Jan的访谈不是由“区块链头条”采访的，是由“橙皮书”采访并原创的，原链接为：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/giniWFxxAFGT0fr2qbZc_Q&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;对话Nervos：中国最懂以太坊的人，却选择了一条和以太坊截然不同的道路&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;知友们可以结合Jan的观点和PoS本身、再结合自己所具有的区块链相关知识，得到自己的结论：&lt;/p&gt;&lt;blockquote&gt;橙皮书：为什么不看好 PoS ？&lt;br/&gt;&lt;br/&gt;Jan：我总觉得 PoS有点问题。因为共识是要创造信任，信任是不可能自己创造自己。你想象一条蛇在咬自己的尾巴。PoS用系统自己发布的资产作为押金，去保证这个系统的安全。它没有锚定任何的东西，是漂浮在空中的。我没有看到任何的信任是通过 PoS这样的方式创造出来的。我觉得信任的创造还是要锚定能量。美元锚定是美国的军事实力。如果哪天美国没有这种军事实力，那美元的价值我觉得要打很多问号。PoW是相当于用军队锚定，PoS 是用美元锚定美元。&lt;br/&gt;&lt;br/&gt;这个问题你会思考很久。因为你可能又会想，归根到底这两种方式，好像都是用资本去锚定，因为电力本质上也是一种资本。但再想想，这两种资本好像是不太一样的。PoW 是体系外的资本。所以，PoS 我总觉得有点问题。&lt;/blockquote&gt;&lt;p&gt;那么为什么以太坊还要引入PoS呢？我个人的观点是：PoS本身的权益是漂浮在空中的，但是&lt;b&gt;如果PoS权益之前已经被认定为是一个有价值的东西（以太坊中的Eth），用一个公认有价值的东西反过来做为权益，PoS似乎就不漂浮在空中了&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;但是，Eth有价值吗？这个问题，有点深奥… 欢迎知友在评论区讨论。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-10-04-43005995</guid>
<pubDate>Fri, 04 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>传输短秘密值的条件下提高OT扩展协议的效率</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-08-05-76647738.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/76647738&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7b01b1ba136277a4576b00ee4b38443b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;最近收到了一位知友的私信，询问能否把《Winter School on Cryptography 2012: Lattice-Based Cryptography》的一系列字幕也发布出来，供参考和学习。经过与 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b&quot; data-hash=&quot;60a93d8892402f3493146a4fd54c5f2b&quot; data-hovercard=&quot;p$b$60a93d8892402f3493146a4fd54c5f2b&quot;&gt;@i春秋学院&lt;/a&gt; 当时字幕负责人的讨论，由于相关字幕已经发布了很长时间，我已经可以将字幕发布出来供知友们学习了！因此，在接下来一段时间，我会集中整理《Winter School on Cryptography 2012: Lattice-Based Cryptography》的字幕，重新压制视频并放出。感谢 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b&quot; data-hash=&quot;60a93d8892402f3493146a4fd54c5f2b&quot; data-hovercard=&quot;p$b$60a93d8892402f3493146a4fd54c5f2b&quot;&gt;@i春秋学院&lt;/a&gt; 一直以来的支持！&lt;/p&gt;&lt;p&gt;虽然会集中整理之前的字幕，但是我也会不断听写新的视频，如果有任何顶级安全会议中数据安全相关讲座的听译需求，还请知友们私信我，或者直接在评论区留言。对于一些很大工作量的听译工作（如《Winter School on Cryptography 2015: Practical Secure Multi-Party Computation》这类），我也会持续坚持听译，到合适的时间再对外发布，敬请知友们耐心等待。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为知友们带来的视频是CRYPTO 2013论文《Improved OT Extension for Transferring Short Secrets》。OT Extension协议是安全多方计算中最重要、也是最核心的协议。熟悉OT的知友们可能知道，OT Extension中最核心的论文应该是CRYPTO 2003的《Extending Oblivious Transfer Efficiently》以及CCS 2013的《More Efficient Oblivious Transfer and Extensions for Faster Secure Computation》。不过我一直没有找到这两个讲座的视频，如果哪位知友知道视频链接，也可以在评论区告诉我。&lt;/p&gt;&lt;p&gt;《Improved OT Extension for Transferring Short Secrets》的重要程度相对这两篇论文来说没有那么高，但这篇论文是优化GMW协议的重要理论基础。如果想实现基于GMW协议的安全多方计算应用，这篇论文的阅读和实现也是必不可少的。CRYPTO 2013对应的演讲视频介绍了《Improved OT Extension for Transferring Short Secrets》的基本思想，观看视频后再去读论文会有更深入的理解。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DAgPZVecLuXs&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=AgPZVecLuXs&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av62237491/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av62&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;237491/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/CRYPTO%25202013/Improved%2520OT%2520Extension%2520for%2520Transferring%2520Short%2520Secrets&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/CRYPTO%202013/Improved%20OT%20Extension%20for%20Transferring%20Short%20Secrets&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1141506723897516032&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png&quot; data-lens-id=&quot;1141506723897516032&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1141506723897516032&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢主持人的介绍。此工作是我与来自贝尔实验室的Vladimir Kalashnikov所共同完成的。我们工作针对的目标是安全计算，这是密码学上一个非常典型、非常普遍的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当前有很多重要的研究进展，尝试让安全计算从理论走向实际。这些工作的目标不仅是要提高协议的渐进效率，还要提高协议的真实执行效率。还有一些工作的方向是具体协议的实现，解决系统层面的问题。&lt;/p&gt;&lt;p&gt;在过去的5年，无论是理论角度还是实际角度，此领域都诞生了极多的突破性成果。从理论角度，我们得到了很多惊人的结论。我们现在只需要引入常数级额外开销，即可完成安全计算或安全函数求值。另一个突破是全同态加密。对于多种类型的函数，我们甚至可以在最优通信复杂度下构建安全计算协议。还可以使用基于ORAM的安全计算协议，利用RAM计算模型的优势完成安全计算，这样我们就能在次线性时间复杂度下完成安全计算。在实践角度，针对姚氏协议和GMW协议，学者们提出了很多算法或实现层面的优化，也尝试混合使用姚氏协议和GMW协议。特别地，姚氏协议的实现结果令人印象深刻。现在，我们可以在637毫秒内执行完AES的乱码电路。&lt;/p&gt;&lt;p&gt;虽然在实现层面和理论层面我们都得到了令人惊讶的成果，但在右侧，效率最高的协议仍然是20世纪80年代提出的姚氏协议和GMW协议。之所以这样，有一个很直观的原因：理论成果虽然引入常数复杂度，但这个常数可能非常大。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际应用时，可能存在这样一个复杂度与效率的层级关系。FHE的复杂度目前、以后也总会比公钥密码学原语的复杂度高几个量级。公钥密码学原语的复杂度目前、以后也总会比对称密码学原语的复杂度高几个量级。对称密码学原语的复杂度目前、以后也总会比一次一密的复杂度高几个量级。本次演讲的主题是OT扩展，其出发点就是减小公钥操作和对称密码操作的效率鸿沟。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在第一部分演讲中，我会详细介绍OT扩展的研究出发点，并解释OT扩展面临的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;诸如密钥协商、不经意传输等公钥密码学原语一般都很难高效实现。公钥密码学原语天生要依赖于某类代数结构，因此也会遭受很多密码学攻击。因此，相应的参数需要设置得比较大。这导致公钥密码学的计算复杂度也相对较高。另一方面，我们更容易实现伪随机数生成器或哈希函数等对称密码学运算。学者们设计出了很多算法，相应的参数要比公钥密码学小得多，实际中也可以更容易、更轻量级地实现对称密码学运算。这个结论背后还有相应的理论支撑。理论上，无法通过黑盒方式应用对称密码学原语构造大多数公钥密码学原语。这意味着公钥密码学原语和对称密码学原语的性能差约为3至4个数量级。对于诸如AES等被广泛使用的特定对称密码学操作，Intel专门提供了对应的指令集，进一步提高了这类运算的执行效率。因此，我们无法通过对称密码学原语实现公钥密码学原语。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那接下来该怎么办？或许可以用少量公钥原语实例和大量对称密码学操作，生成大量公钥实例。这一技术称为“扩展原语”。我们已经知道，很容易扩展公钥加密体制，具体过程是用对称加密算法加密具体的明文，用公钥加密算法加密对称加密的密钥。这样一来，我们只需要执行一次公钥操作。这一技术在我们每天使用的加密过程中起到了非常重要的作用。我们可以很自然地把这个问题展开：是否可以扩展其它公钥密码学原语。如OT？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;回忆一下不经意传输要解决的问题。发送方有两个输入： &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_0&quot; alt=&quot;x_0&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1&quot; alt=&quot;x_1&quot; eeimg=&quot;1&quot;/&gt; 。接收方有一个输入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。协议执行完毕后，发送方无法得到任何信息，接收方可以得到与其选择比特关联的发送方输入。OT是SFE的基础构建模块。姚氏电路中应用不经意传输实现了乱码密钥的2选1过程。在GMW协议中，OT的用途更加广泛，每个AND门的求值过程都要使用一次OT协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们知道OT的执行开销非常大，我们无法通过对称密码学操作实现OT。但假设我们有一个可以传输短字符串的OT，通过使用标准的伪随机数生成器，我们能得到可以传输长字符串的OT。这一技术称为“OT长度扩展”。&lt;/p&gt;&lt;p&gt;还有一个更难解决的问题，称为“OT实例扩展”，简称“OT扩展”。幸运的是，我们知道OT扩展是可行的。我们只需要 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个公钥密码学操作，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个种子OT，再加上 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 次对称密码学操作。应用这 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 次公钥密码学操作，我们就可以执行任意多项式大小次的OT操作。这一技术大幅降低了公钥密码学运算次数，对SFE的实际应用起到了重要的作用。近期大多数SFE的实现都应用了OT扩展协议，从而提高协议的执行效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Beaver在1996年提出了第一个OT扩展协议。第一个高效的OT扩展协议由Ishai、Kilian、Nissim和Petrank给出。此协议也称为IKNP协议，对应的论文发表在CRYPTO 2003上。后续，学者们期望在恶意攻击场景下提高OT扩展协议的执行效率。学者们同时也在加深对OT扩展协议的理解，从而知道OT扩展协议的上限是什么。在本工作中，我们将在半可信场景下提高IKNP协议的效率。我们给出了协议的渐进优化方法和实际优化方法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在接下来的讲座中，我们会描述Ishai等人的OT扩展协议构造。实际上，我们将直接使用Ishai等人CRYPTO 2003的演讲幻灯片。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;IKNP第一个、也是最重要的步骤是将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT归约为传输 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 比特字符串的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT。这一步骤将引入额外的、线性数量级的对称密码学操作。下一步是长度扩展步骤，我们之前已经讲解过这一步骤了。这可以让我们把长字符串OT协议归约为短字符串OT协议。这一步骤进一步引入了线性数量级的对称密码学操作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在核心归约步骤中，我们让接收方选择一个随机的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5Ctimes+k&quot; alt=&quot;n\times k&quot; eeimg=&quot;1&quot;/&gt; 矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 。随后，发送方选择一个随机的行向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;/&gt; 。接下来，接收方和发送方执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT协议，但此OT协议中两个参与方的角色互换。在每个OT协议中，接收方要选择长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 的两列比特值。每对比特值中。第一列为矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 中的某一列，第二列为第一列比特值与选择向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 的异或结果。发送方实际上应用它随机选择的行向量在接收方的两列比特值中选择一列。&lt;/p&gt;&lt;p&gt;这样，发送方通过OT协议得到了一个矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; 。我们来看看矩阵 Q 满足何种性质。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D0&quot; alt=&quot;r_i=0&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，收到的每对比特值就不太一样了。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; ，在IKNP协议中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i%5Coplus+s&quot; alt=&quot;q_i=t_i\oplus s&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;注意到，在第一种情况下，接收方知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+&quot; alt=&quot;t_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; 。因此，在第一种情况下，接收方能得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。在第二种情况下， 接收方能得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s+&quot; alt=&quot;q_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; ，也就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，但无法得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 。这意味着我们或许可以使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 作为OT协议中的数据加密密钥。但需要注意的是，我们必须要破坏矩阵中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的相互关系。我们应用随机预言机 &lt;img src=&quot;https://www.zhihu.com/equation?tex=H&quot; alt=&quot;H&quot; eeimg=&quot;1&quot;/&gt; 来破坏 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+s&quot; alt=&quot;q_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 的相互关系。最后，接收方根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 选择得到它的输出，也就是应用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 进行解密。&lt;/p&gt;&lt;p&gt;IKNP协议非常简单、非常优雅、效率极高。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们考虑 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;/&gt; 个OT协议所需要的通信开销。其中发送方输入的长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L&quot; alt=&quot;L&quot; eeimg=&quot;1&quot;/&gt; 。大家已经了解到，核心归约步骤就是对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_%7Bi%2C0%7D&quot; alt=&quot;x_{i,0}&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_%7Bi%2C1%7D&quot; alt=&quot;x_{i,1}&quot; eeimg=&quot;1&quot;/&gt; 加密，这需要发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nL&quot; alt=&quot;2nL&quot; eeimg=&quot;1&quot;/&gt; 比特的数据。在长度扩展步骤中，我们要应用一个PRG，这需要发送 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nk&quot; alt=&quot;2nk&quot; eeimg=&quot;1&quot;/&gt; 比特的数据。&lt;/p&gt;&lt;p&gt;在姚氏电路中，我们需要传输长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3Dk&quot; alt=&quot;L=k&quot; eeimg=&quot;1&quot;/&gt; 的密钥，因此核心归约步骤和长度扩展步骤中的通信开销相同。在GMW中，我们只需要传输 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3D1&quot; alt=&quot;L=1&quot; eeimg=&quot;1&quot;/&gt; 的信息。令人惊讶的是，这一场景下长度扩展步骤的通信开销远高于核心归约步骤的通信开销。这就是一个问题了，我们可能可以在这一场景下对通信开销进行优化。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在讲座的后半部分，我们会提出IKNP的通用框架。我们也会向大家展示如何提高IKNP的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们先来详细分析一下IKNP协议。可以看到，接收方要选择这个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%5Ctimes+k&quot; alt=&quot;n\times k&quot; eeimg=&quot;1&quot;/&gt; 的随机矩阵。随后，接收方要生成另一个矩阵，这个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列为第一个矩阵的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列异或选择向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r&quot; alt=&quot;r&quot; eeimg=&quot;1&quot;/&gt; 。换句话说， &lt;img src=&quot;https://www.zhihu.com/equation?tex=U%3D+T+%5Coplus+R&quot; alt=&quot;U= T \oplus R&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 是所有列均相等的矩阵，每个列都为接收方的选择向量。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果我们从行的视角看，就会发现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 行为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; ，这意味着 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R&quot; alt=&quot;R&quot; eeimg=&quot;1&quot;/&gt; 的每一行都是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 的一种编码。在IKNP协议中， &lt;img src=&quot;https://www.zhihu.com/equation?tex=0&quot; alt=&quot;0&quot; eeimg=&quot;1&quot;/&gt; 被映射为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=0%5Ek&quot; alt=&quot;0^k&quot; eeimg=&quot;1&quot;/&gt; ，而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 被映射为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1%5Ek&quot; alt=&quot;1^k&quot; eeimg=&quot;1&quot;/&gt; 。因此，我们可以看到IKNP这一高效协议在底层执行了一次逐行重复编码。这自然引出了一个问题：我们是否可以使用更复杂的编码？毕竟，重复编码是一种最简单的编码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;假设我们使用编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; ，并且我们假定 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 属于一个很大的域，域为从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 。我们用编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 映射成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29+&quot; alt=&quot;C(r_i) &quot; eeimg=&quot;1&quot;/&gt; ，这是一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 比特长字符串。现在，接收方需要用选择比特 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 构建矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 。我们来看看，在这个理论框架下IKNP协议的执行过程。&lt;/p&gt;&lt;p&gt;第一步，接收方获得了矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 。随后，接收方用加法秘密分享方案将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29&quot; alt=&quot;C(R)&quot; eeimg=&quot;1&quot;/&gt; 分享为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28R%29%3D+T+%5Coplus+U&quot; alt=&quot;C(R)= T \oplus U&quot; eeimg=&quot;1&quot;/&gt; 。接下来，接收方和发送方角色互换，执行 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 个OT协议。在第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 个OT中，接收方的输入是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t%5Ei&quot; alt=&quot;t^i&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u%5Ei&quot; alt=&quot;u^i&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;/&gt; 的第 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; 列。执行完OT协议后，发送方得到矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; 。在IKNP协议中，我们知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i&quot; alt=&quot;q_i&quot; eeimg=&quot;1&quot;/&gt; 或者等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; ，或者等于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+&quot; alt=&quot;t_i \oplus s &quot; eeimg=&quot;1&quot;/&gt; 。在这一理论框架中，我们可以知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+%28C%28r_i%29+%5Codot+s%29&quot; alt=&quot;q_i=t_i \oplus (C(r_i) \odot s)&quot; eeimg=&quot;1&quot;/&gt; ，结果不算太复杂。&lt;/p&gt;&lt;p&gt;我们可以验证一下，当C是重复编码时 此框架对应的协议就是IKNP协议。特别地，当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D0&quot; alt=&quot;r_i=0&quot; eeimg=&quot;1&quot;/&gt; 时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29&quot; alt=&quot;C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 是一个全 &lt;img src=&quot;https://www.zhihu.com/equation?tex=0&quot; alt=&quot;0&quot; eeimg=&quot;1&quot;/&gt; 向量，因此我们得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i&quot; alt=&quot;q_i=t_i&quot; eeimg=&quot;1&quot;/&gt; 。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i%3D1&quot; alt=&quot;r_i=1&quot; eeimg=&quot;1&quot;/&gt; 时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=C%28r_i%29&quot; alt=&quot;C(r_i)&quot; eeimg=&quot;1&quot;/&gt; 是一个全 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 向量，此时我们可以得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+s&quot; alt=&quot;q_i=t_i \oplus s&quot; eeimg=&quot;1&quot;/&gt; 。这样一来，我们得到了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 个密钥。后面的执行过程就完全一样了，密钥生成算法为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q_i+%5Coplus+%28C%28r%29+%5Codot+s%29&quot; alt=&quot;q_i \oplus (C(r) \odot s)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们仍然可以证明接收方只能知道 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t_i&quot; alt=&quot;t_i&quot; eeimg=&quot;1&quot;/&gt; 。因此接收方只能解密对应的密文，从而得到对应的输入。核心归约步骤在恶意发送方的攻击下是完美安全的。特别地，恶意发送方只能得到矩阵 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Q&quot; alt=&quot;Q&quot; eeimg=&quot;1&quot;/&gt; ，这是编码的随机独立分享结果。核心归约步骤在半诚实接收方的攻击下是统计安全的。这是因为除了在加密过程中使用了随机预言机之外，核心归约步骤没有安全性损失。因此，整个协议的安全性损失为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_i&quot; alt=&quot;r_i&quot; eeimg=&quot;1&quot;/&gt; 的取值范围，以及 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2%5E%7B-d%7D&quot; alt=&quot;2^{-d}&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=d&quot; alt=&quot;d&quot; eeimg=&quot;1&quot;/&gt; 是线性编码 &lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot; eeimg=&quot;1&quot;/&gt; 的最小距离。&lt;/p&gt;&lt;p&gt;注意到在此理论框架下，我们可以从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=1&quot; alt=&quot;1&quot; eeimg=&quot;1&quot;/&gt; 到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选取消息，因此从效果上看，我们可以实现 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT，而不是2选1-OT。但在这种情况下，核心归约步骤的通信开销会从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2nL&quot; alt=&quot;2nL&quot; eeimg=&quot;1&quot;/&gt; 提高到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=nmL&quot; alt=&quot;nmL&quot; eeimg=&quot;1&quot;/&gt; 。随后，我们将标准的2选1-OT转换为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n%2F%5Clog%28m%29&quot; alt=&quot;n/\log(m)&quot; eeimg=&quot;1&quot;/&gt; 个字符串长度稍长的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT实例，这也允许我们将通信开销表示为与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 相关的函数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我们有了一个自由变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; ，用它来平衡核心归约步骤和长度扩展步骤的开销。具体来说，如果我们使用的是最小距离为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%2F2&quot; alt=&quot;k/2&quot; eeimg=&quot;1&quot;/&gt; 的Hadamard编码，在这种情况下，2选1-OT的通信开销可以降低2倍。在多方GMW协议中，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k%3D256&quot; alt=&quot;k=256&quot; eeimg=&quot;1&quot;/&gt; ，则通信开销也可以降低2倍。&lt;/p&gt;&lt;p&gt;也可以进一步优化长度扩展步骤的通信开销，此开销的优化程度是算法层面的，而不是渐进层面的。结合Hadamard编码后，与未优化的IKNP协议相比，新协议的通信开销要降低3.5倍。Asharov等人也独立发现了这一优化点，他们的论文将发表在CCS 2013上。&lt;/p&gt;&lt;p&gt;与IKNP相比，我们从渐进层面降低了每一个OT的通信开销。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=L%3D1&quot; alt=&quot;L=1&quot; eeimg=&quot;1&quot;/&gt; 时，IKNP需要通信 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28k%29&quot; alt=&quot;O(k)&quot; eeimg=&quot;1&quot;/&gt; 比特，而我们需要通信 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O%28k%2F%5Clog%28k%29%29&quot; alt=&quot;O(k/\log(k))&quot; eeimg=&quot;1&quot;/&gt; 比特。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2560&quot; data-original=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总结一下，为了平衡公钥密码学原语和对称密码学原语的性能鸿沟，学者们提出了OT扩展协议，这一协议在安全函数求值的实例落地中产生了巨大的影响。在本次讲座中，我们提出了IKNP的编码理论框架。可以在随机预言模型下证明此框架的安全性。随机预言模型也可以换为特定类型哈希函数假设，即相关性健壮哈希函数，这沿用了IKNP中安全性所依赖的相关性健壮哈希函数假设。当使用复杂编码时，此框架提高了多方GMW中2选1-OT和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot; eeimg=&quot;1&quot;/&gt; 选1-OT的性能。&lt;/p&gt;&lt;p&gt;我想用GMW和姚氏电路的性能对比问题作为讲座的结尾。近期的安全多方计算研究主要关注恶意模型下姚氏电路的性能优化问题。在半可信安全模型下，学者们也提出了很多姚氏电路的优化方法。但近期的一些工作也表明，GMW协议也有很多算法层面的优化点。我们的工作适用于GMW协议。谢谢大家。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-08-05-76647738</guid>
<pubDate>Mon, 05 Aug 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>ObliVM：安全计算编程框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-07-15-73618400.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/73618400&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-83f24da35d88aef9a1bc7d522f42c2cf_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;使用新的方法撰写密码学会议视频分享文章后，虽然点赞和阅读量并没有提升很多，但是根据知友们的反馈，这样做确实可以大幅度提高阅读体验。更开心的是，向知乎反馈后，知乎的工程师们也是大力配合，现在终于支持上传长度不超过60分钟的视频了，撒花庆祝！接下来的视频分享文章中，我会同时在知乎和B站上传翻译视频。知友们可以根据自己的习惯选择在哪个地方观看。&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2015年安全顶级会议Security and Privacy 2015的演讲视频《ObliVM：安全计算编程框架》，对应的论文是《ObliVM: A Programming Framework for Secure Computation》。&lt;/p&gt;&lt;p&gt;上一篇文章《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot; class=&quot;internal&quot;&gt;SoK：安全多方计算通用框架&lt;/a&gt;》的视频中，作者调研了9个开源的通用安全计算框架，而ObliVM就是其中的一个。我个人对于“把Alice和Bob作为编程语言的关键词”这一点仍然记忆犹新。这一次，我们就来详细了解一下ObliVM到底是什么。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DQ2QLRcj0Mio%26t%3D92s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=Q2QLRcj0Mio&amp;amp;t=92s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av59239482/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av59&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;239482/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202015/ObliVM%2520A%2520Programming%2520Framework%2520for%2520Secure%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202015/ObliVM%20A%20Programming%20Framework%20for%20Secure%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1134043543998984192&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;ObliVM：安全计算编程框架&quot; data-poster=&quot;https://pic2.zhimg.com/v2-f3c6c88bc65211e0a5428862604b6751.jpg&quot; data-lens-id=&quot;1134043543998984192&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic2.zhimg.com/v2-f3c6c88bc65211e0a5428862604b6751.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;ObliVM：安全计算编程框架&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1134043543998984192&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dfa9266c22dd67c35e48fb574b0f33f4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）大家好，我很高兴能在这里为大家介绍我们的工作：ObliVM，这是一个安全计算的编程框架。这是我和我的队友们一同完成的工作，队友有Xiao Wang，坐在那里的Kartik，还有Yan Huang，还有Elaine Shi。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8a9ef0ebfc38e623edd73ece9f8bb8c3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;很高兴自己在前面的一个演讲中为大家充分介绍了什么是安全计算，或安全函数求值。我这里只需给出一个简短的介绍。例如，Sheldon和Amy希望互相确认自己是不是对方的另一半。他们都相信基因匹配的效果。因此，他们可以执行一个分析过程，看看他们是否匹配。一个很关键的安全问题是：他们不想把敏感的基因数据泄露给对方。我在前面已经讲过了，安全计算是这一问题的绝佳解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-33f431d5843e472e9988a350ab492b3b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以把这个问题抽象成下述形式：给定两个参与方Alice和Bob，以及他们的秘密输入&lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;/&gt;，他们希望联合计算一个公开函数&lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28x%2Cy%29&quot; alt=&quot;f(x,y)&quot; eeimg=&quot;1&quot;/&gt;，得到函数的计算结果。同时，除了计算结果&lt;img src=&quot;https://www.zhihu.com/equation?tex=z&quot; alt=&quot;z&quot; eeimg=&quot;1&quot;/&gt;外，涉及两个秘密输入的计算过程不会向对方泄露任何其它信息。这就是安全计算的概念。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d50cd934285487e70a3190230431220b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家已经知道，安全计算的解决方案有姚氏乱码电路，还有GMW协议。我们关注什么地方呢？我们的关注点是：如何让安全计算能在实际中得到应用？例如，一个开发者希望开发一个安全计算应用。他们肯定不想把函数写成电路的形式。他们想用C语言、Java语言、或者Python语言编写代码。因此，源程序和安全计算协议之间存在很大的鸿沟。这就是我们ObliVM框架要做的事情。我们的ObliVM是一个工具，可以将源代码转换成实际的安全计算协议。这是ObliVM的框架概览。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1a1dd665059ebf74c4791a4d12200062_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里面最主要的问题是什么？Kartik已经提到，主要问题是开发人员喜欢用Python等语言模型编写代码。幻灯片左侧是开发人员撰写的源程序。但实际上，大多数安全计算协议是在电路模型下实现的。因此，在高层语言程序和电路程序之间存在很大的鸿沟。我们的问题是，如何将左侧的代码转换为右侧的协议？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-701ef2653252f04ea738e48ed714ef9d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢Kartik的讲解，你已经提出了我们工作的出发点。这里的关键挑战是，如何能让动态内存访问过程不泄露信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-105c7ca94ee1cc9ae3bc8c92be83feea_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是一个不太容易解决的挑战。我们的解决方案是：把RAM模型下的问题转换到不经意RAM模型中。不经意的意思是内存访问和指令追踪过程不依赖于秘密输入。这样一来，不经意程序就可以被进一步转换为电路了。我们可以看到，在转换链路中，后一部分相对比较简单，前一部分非常有挑战性。本次讲座主要关注前一部分，解释如何做到这一点。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3bb184d3bee0e14014522f54f3194b5a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有一个非常平凡，也不能说非常平凡的解决方案。这个方案于2013年首先提出，基本思想是使用不经意RAM。不经意RAM，又称ORAM，可以把任意程序编译成不经意程序。基于这一思想，我们去年提出了SCVAM框架。此框架可以仿真通用ORAM。可以证明，我们的渐进性能比所有之前的解决方案都要好。这一解决方案是通用的，也很容易实现。但问题在于，这个方案可能不是最高效的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-955e1a2eab7adbdc7f678a636f382540_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在过去的几年间，我们观察到研究人员提出了很多定制化安全计算协议。这方面的工作有很多，我实在没办法在幻灯片上把所有相关工作都列出来。这些定制化安全计算协议都很高效，可以这么说，这些协议比我们去年的工作都高效。但问题在于，这些协议的设计成本很高。例如，我们与Nina Taft聊了聊，她是我们的合作方。我们私下针对CCS 2013上面发表的隐私矩阵分解算法进行了讨论。她告诉我们，她们组织了5位研究人员，花费了大约4个月的时间才完成了全部的实现。也就是说，整个过程花费了超过1.5年的研究时间。这里涉及到巨大的工作量。我们的问题是：我们能不能做得更好？我们能否构建一个通用框架，但仍然获得定制化协议的执行效率？这就是我们ObliVM的目标。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c9f988ecc18cf85af9b286db1b0907aa_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们希望非领域专家，例如非密码学家，可以用它实现一些安全计算协议，同时获得定制化协议的执行效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-be11502e40916e7fce56fd066986b44a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何做到这一点？关键思想是：在ObliVM内部，我们提供很多编程抽象接口。我在幻灯片上具体列举了一些，如不经意数据结构、MapReduce、循环合并等。我后面会介绍其中一个抽象接口。如果想了解更多的细节，请阅读我们的论文。我还想提及的是，Kartik刚刚讲解的GraphSC论文也是一个并行计算编程接口抽象。总之，我们提供了一些编程接口抽象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9d9f3ca789ed2333d422d43601e5b974_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我这里想简单介绍一下编程接口抽象到底是什么。我们来看看分布式计算社区。我估计绝大多数人都听说过MapReduce，这是谷歌于2004年在OSDI会议上发表的论文。在这篇论文发表之前，并行计算、或者说分布式计算，是一个很困难的任务。但通过MapReduce，开发者只需要将计算过程编码在Mapper和Reducer框架中。开发者不需要关注分布式计算方法，MapReduce框架会实现整个分布式计算过程。因此，与之前的工作相比，使用MapReduce涉及的开发工作量会非常小。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c81b6971cdbc2adde4082575355f7829_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们想用与之非常类似的方法解决这一问题。我们希望提供一些抽象接口，允许开发者将计算任务编码在抽象接口中，这样他们就不需要关注底层的密码学原语，但仍然获得相同的计算性能。这就是我们的目标，这就是我们的解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f112668c71b7c24368129e3abdc3aa10_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们如何对外提供这些编程接口抽象？我们希望实现一个新的语言支持体系。例如，我们想为我们的开发者实现一个新的编程语言。在开发这个语言时，我们脑海中有两个目标。第一个目标是：领域专家或密码学家可以很容易地应用此语言实现不同的编程接口。另一方面，对于非专家来说，他们可能不是特别了解密码学技术，他们可以很容易地使用这些编程语言抽象构建他们自己的应用程序。&lt;/p&gt;&lt;p&gt;结合脑海中的这两个目标，我们的解决方案是构建新的语言特性，支持之前系统未无法支持的功能。我这里列举了一些特性，请大家阅读论文，了解相应的技术细节。后续我们会在幻灯片给出的地址上开源我们的编译器，这样大家可以更好地了解编译器的实现细节。我认为这些特性都很不错。例如，我们可以使用随机类型、虚函数等，从源代码阶段，而不是从后端原语阶段，实现不经意RAM协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9353af312dbcd1bf7e57c5e2def4c0eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有了这些编程接口抽象，开发人员该怎么做呢？例如，我们希望实现一个稀疏图算法。我们已经有了编程接口抽象这样一个武器库了。假设我们想要实现稀疏Dijkstra最短距离算法，我们可以选取适当的不经意数据结构，这里要选择不经意堆。随后，我们使用循环合并抽象实现相应的算法。通过使用这些工具，我们实现了3个不同的稀疏图算法。&lt;/p&gt;&lt;p&gt;整个流程好像都走得通，但我们得到了一个超出期望的结果：我们实现的算法从理论角度也得到了突破，所有3个算法的渐进复杂度都比当前最优算法的渐进复杂度低。这个结论令我们感到十分惊讶。如果想了解算法的更多细节，请阅读我们的论文。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8aedbc7eec43f0ef939b7d7d2cebb7bc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;开发人员具体该做些什么呢？我在几分钟之前已经向大家许诺过了，我会为大家介绍一个编程接口抽象：循环合并。这是非常细节的内容了。在安全计算中，实现秘密循环是非常有挑战性的工作，因为循环次数本身就会泄露信息。这里我们允许编程人员编写有上界循环次数限制的循环语句。例如，我们允许协议保护循环次数，但我们要求开发人员公开告知循环次数的上限。&lt;/p&gt;&lt;p&gt;这是一个嵌套循环代码。这里有趣的地方在于，第4行到第7行的内部循环中，循环次数上界m并不是外部循环中每次迭代的最大迭代次数上界，而是两层嵌套代码中，内部循环的总执行次数上界。这样我们可以避免重复的执行过程。例如，如果我们按照传统方法给出上界，则总迭代次数是n•m，但这样设置的总迭代次数是n+m。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-625397a668f586d620e6a6b5d67caf3f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们的编译器会分析这段代码，自动将此类形式的代码转换成右下的代码形式。这段代码看起来像是一个状态机，这样就不会为算法引入额外的复杂度了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9ecbfeeaf6c37ca5137ba24c3c9a3de9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;应用所有这些技术以后，我们能得到什么呢？我之前已经提到，实现矩阵分解算法涉及的人力开销大约为1年1.5个研究者。如果使用ObliVM呢？结果非常令人惊讶，只需要一天就够了。一个博士研究生只需要一天就可以实现全部功能。&lt;/p&gt;&lt;p&gt;你可能会想，实现结果是否高效？可能自动化的实现结果并不高效。事实上，我们的实现的算法效率要高10到20倍，因此实现结果甚至更高效了。这就是我们现在得到的优化结果。我相信ObliVM对于所有安全计算开发者来说都是一个福音。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-42eadc0c0a39536a992df26209cbac0a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们深入解析一下各个优化点所带来的性能提升情况。我们这里给出的是Dijkstra算法的实现结果。论文中给出了更多的实现结果。虽然我们这里只关注ObliVM的编程语言部分，但实际上ObliVM拥有一个经过深度优化的后端ObliVM-SC。此后端代码也开源了，大家可以访问我们的网站，获取源代码链接。&lt;/p&gt;&lt;p&gt;我们实现了一个当前最优的电路ORAM，此ORAM专门为安全计算进行优化。我们将我们的系统和之前在CCS 2012上公开的最佳结果进行了对比，电路ORAM本身可以为我们带来50倍的性能提升。编程语言和编译器可以为我们带来2500倍的性能提升。我们进一步对后后端的其它部分进行了深度优化，可以在我们的论文中找到相应的技术细节描述。这些深度优化可以为我们带来7倍的性能提升。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4722bbf7b517abd9b56ad264d2fcaf81_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;总体来说，我们获得了大约100,000倍的性能提升，这是很大的性能提升倍数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5d2d5c92051d01d6db6c3358d7a656fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里给大家一个更直观的方案效率描述。2012年在同一篇论文中，他们在1GB数据集上执行了二分搜索算法。一次单独问询的计算时间大约为12小时。现在情况又怎么样呢？使用我们的ObliVM框架，每次问询的执行时间仅为7.3秒。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1c5cff76f101975d7101122ab2210716_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还将我们的SCVM框架与不安全的解决方案进行了效率对比。也就是说，我们直接在计算机上执行明文程序，从而对比效率。我们计算了效率损失量，效率损失量相对还是可以接受的。对于分布式GWAS，效率损失仅为130倍。我们可以期待，未来这一数字可能会进一步降低。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b369f0a954f57d3c57cebd3374dcf283_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;有很多合作方都与我们合作，ObliVM已经在多个场景下得到了应用。我们刚刚赢得了3月份举办的基因分析竞赛，这是大约2个月前举办的竞赛。未来，我们希望在ObliVM框架的基础上实现更多的密码学计算任务，如同态加密等。&lt;/p&gt;&lt;p&gt;非常感谢大家，这就是我讲座的全部内容了，接下来我可以回答一些问题。&lt;/p&gt;&lt;p&gt;（提问者）在演讲开始阶段你给出了一个二分搜索的例子，开发人员应该怎么实现二分搜索？开发人员需要写什么代码？&lt;/p&gt;&lt;p&gt;（演讲者）你指的是哪个例子？&lt;/p&gt;&lt;p&gt;（提问者）在最开始的地方，你给出了一个二分搜索的例子，那时候你提到…&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-204d4a095eccb20a54437f1b27dc0b07_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）这张图中左侧是开发人员实现循环合并时要编写的代码。你提到了二分搜索的例子，对吧？&lt;/p&gt;&lt;p&gt;（提问者）是的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c3e21c18b0b067154d23ecf8a45d2a80_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（演讲者）我觉得用二分搜索举例子会比较好。开发人员要做的事情是…我们回到那页幻灯片上。在这里。&lt;/p&gt;&lt;p&gt;（提问者）就是这里。&lt;/p&gt;&lt;p&gt;（演讲者）这就是开发人员需要编写的代码…我看看这个代码能不能编译通过…是的，可以用我们的ObliVM编译器编译这个程序。编译器会自主处理内存访问过程。&lt;/p&gt;&lt;p&gt;（提问者）是的&lt;/p&gt;&lt;p&gt;（演讲者）是的，编译器会识别相应的模块，判断哪些部分要替换为ORAM，哪些部分不需要替换。&lt;/p&gt;&lt;p&gt;（提问者）ObliVM是不是有一种潜在使用方法，就是让ObliVM输出C代码，而不是电路，这样我们就可以把任意一个程序输入给ObliVM，使得程序无法被旁路攻击？&lt;/p&gt;&lt;p&gt;（演讲者）这是一个非常好的问题。一个非常有趣的事实是，我们的ObliVM编译器输出的是Java代码。&lt;/p&gt;&lt;p&gt;（提问者）明白。&lt;/p&gt;&lt;p&gt;（演讲者）随后，执行Java代码，会生成一个电路。所以我觉得你提的问题非常好。我认为未来一个很有趣的研究方向是，如何阻止ObliVM编译器遭到旁路攻击。&lt;/p&gt;&lt;p&gt;（提问者）好的，谢谢。&lt;/p&gt;&lt;p&gt;（演讲者）谢谢你。&lt;/p&gt;&lt;p&gt;（演讲者）什么？你可以使用麦克风的。&lt;/p&gt;&lt;p&gt;（合作者）我们的编译器没办法被旁路攻击。如果你直接编写类似这样的代码，编译的输出结果是通用ORAM程序。但你也可以调用我们提供的不经意数据结构。我们在不经意数据结构中实现了二分搜索树，如果直接调用不经意数据结构抽象接口，编译时间会减少log(n)倍。&lt;/p&gt;&lt;p&gt;（提问者）明白。&lt;/p&gt;&lt;p&gt;（合作者）很容易让编译器输出C代码，修改后端编译器即可。比较困难的点在于前端，如何编译得到一个高效的电路。&lt;/p&gt;&lt;p&gt;（主持人）感谢Elaine的解释。&lt;/p&gt;&lt;p&gt;（演讲者）是的，感谢Elaine。&lt;/p&gt;&lt;p&gt;（主持人）再次感谢我们的演讲者。&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-07-15-73618400</guid>
<pubDate>Mon, 15 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>SoK：安全多方计算通用框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-07-15-72119587.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b38297e2e605b6e0c3739b6eee4bb1e8_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;有段时间没有为知友们带来安全会议的演讲视频翻译了，主要原因是我发现这类文章阅读量并不是很高。业余时间我自己反思了一下，可能是因为知乎到底还是一个问答类社区，文字类型的描述可能更适合知友们快速感知到安全会议演讲视频的内容。为此，在接下来的安全演讲视频文章中，我做了如下几个改变：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;不在知乎上传视频，而是根据视频主讲人的幻灯片展示情况，将对应的演讲稿发出。&lt;/li&gt;&lt;li&gt;演讲视频还是会上传，不过会上传到B站这个专门播放视频的地方。这样，如果有翻译错误，或者有更好的建议，知友或者B站的朋友可以通过弹幕、评论的形式更快地反馈。&lt;/li&gt;&lt;li&gt;演讲视频的中文字幕、时间轴文件（ass格式）、相应的截图等，我会公开在我的GitHub下面，方便知友们下载。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;希望这种方式可以让知友们各取所需。&lt;b&gt;如果知友们还想了解哪些演讲视频，也可以通过知乎评论、GitHub、B站等方式给我留言。我会尽可能满足大家的要求。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2019年5月23日刚刚召开的安全顶级会议Security and Privacy 2019的一个演讲视频《SoK：安全多方计算通用框架》，对应的论文是《SoK: General Purpose Frameworks for Secure Multi-Party Computation》。&lt;/p&gt;&lt;p&gt;这里需要介绍一个背景知识：如果一篇论文的开头是“SoK”，则代表这篇论文是一篇综述论文。SoK的全称是“Systematization of Knowledge Papers&lt;b&gt;”&lt;/b&gt;，Security and Privacy的官方网站（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ieee-security.org/TC/SP2013/cfp.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;ieee-security.org/TC/SP&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;2013/cfp.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;）给出了一个很详尽的解释：&lt;/p&gt;&lt;blockquote&gt;Following the success of the previous years&amp;#39; conferences, we are also soliciting papers focused on systematization of knowledge (SoK). The goal of this call is to encourage work that evaluates, systematizes, and contextualizes existing knowledge. These papers can provide a high value to our community but may not be accepted because of a lack of novel research contributions. Suitable papers include survey papers that provide useful perspectives on major research areas, papers that support or challenge long-held beliefs with compelling evidence, or papers that provide an extensive and realistic evaluation of competing approaches to solving specific problems. Submissions are encouraged to analyze the current research landscape: identify areas that have enjoyed much research attention, point out open areas with unsolved challenges, and present a prioritization that can guide researchers to make progress on solving important challenges.&lt;b&gt;Submissions must be distinguished by a checkbox on the submission form. In addition, the paper title must have the prefix &amp;#34;SoK:&amp;#34;&lt;/b&gt;. They will be reviewed by the full PC and held to the same standards as traditional research papers, except instead of emphasizing novel research contributions the emphasis will be on value to the community. Accepted papers will be presented at the symposium and included in the proceedings.&lt;/blockquote&gt;&lt;p&gt;简单来说，SoK论文的目标是系统化、结构化地评估已有知识体系的论文。这类论文虽然工作量很大，但由于缺乏必要的创新性贡献，所以一般不会被会议所接收。但是，随着相应知识的不断提出和完善，这类论文会对他人进一步的研究带来非常大的帮助。所以，越来越多的会议开始接收SoK论文了。SoK论文的最大特点是：这类论文的题目必须以“SoK”开头。&lt;/p&gt;&lt;p&gt;《SoK: General Purpose Frameworks for Secure Multi-Party Computation》这篇论文非常详尽的分析了现有的安全多方计算通用框架，从各种维度评估了各个框架的优缺点，在不同场景下给出了使用建议。特别地，作者成功构建了所有的通用框架，并把构建环境打包在Docker中。我个人用了一下Docker，样例程序都可以跑通，作者也针对各个框架给出了进一步的文档和注释。这篇文章特别适合准备研究安全多方计算协议，或者准备在实际中使用安全多方计算的研究人员。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DI0bremwQ_ns%26t%3D40s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=I0bremwQ_ns&amp;amp;t=40s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av57765218&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av57&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;765218&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202019/SoK%2520General%2520Purpose%2520Frameworks%2520for%2520Secure%2520Multi-Party%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202019/SoK%20General%20Purpose%20Frameworks%20for%20Secure%20Multi-Party%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;中文字幕视频&lt;/h2&gt;&lt;p&gt;感谢知乎工程师们的辛勤工作，知乎现在可以上传60分钟的视频了。为了文章的完整性，我把视频也同步发布在知乎专栏上面。&lt;/p&gt;&lt;a class=&quot;video-box&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1134055356077580288&quot; target=&quot;_blank&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-name=&quot;&quot; data-poster=&quot;https://pic4.zhimg.com/v2-56be736bd7d245f4652fb021facd0c27.jpg&quot; data-lens-id=&quot;1134055356077580288&quot;&gt;&lt;img class=&quot;thumbnail&quot; src=&quot;https://pic4.zhimg.com/v2-56be736bd7d245f4652fb021facd0c27.jpg&quot;/&gt;&lt;span class=&quot;content&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;z-ico-extern-gray&quot;&gt;&lt;/span&gt;&lt;span class=&quot;z-ico-extern-blue&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;url&quot;&gt;&lt;span class=&quot;z-ico-video&quot;&gt;&lt;/span&gt;https://www.zhihu.com/video/1134055356077580288&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（主讲人）非常感谢主持人的介绍。我是Marcela Hastings。这是一篇SoK论文。我将讲解我们的调研结果。我们考察的工具是安全多方计算。这是一个密码学工具，允许互不信任的参与方根据自己的输入计算任意一个函数，计算过程不泄露除输出结果以外的任何信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;安全多方计算实际应用中最著名的实例是丹麦甜菜拍卖系统。在这个场景中，售卖方是丹麦种田菜的农民，而购买方只有一个，即丹麦唯一的一个甜菜加工公司。售卖方为甜菜出价，表示他们希望按照这个价格售卖甜菜，购买方希望得知市场出清价（即保证供求关系平衡的售卖价格）。但售卖方不希望泄露自己的具体出价。如果常年泄露出价，则其它人就会得知自己的甜菜种植能力和做生意的能力了。因此，他们使用安全多方计算协议，在不泄露售卖方出价的条件下计算市场出清价。&lt;/p&gt;&lt;p&gt;另一个例子是波士顿妇女劳动委员会与企业的合作项目。此项目研究员工性别是否会影响到其实际的工资。公司不希望、从法律角度也不能够对外泄露自己雇员的收入或金融类信息。但通过安全多方计算，他们可以在不给出具体数据的条件下计算相应的统计分析结果。&lt;/p&gt;&lt;p&gt;所有这些例子都告诉我们安全多方计算已经足够高效，可以在实际场景中得到应用了。然而，我们之前看到的所有实际应用实例中，项目方都需要组织一个密码学专家团队，针对特定用例实现专用MPC引擎。如果想让MPC得到更广泛的应用，我们需要让不懂密码学的外行也能使用这一工具。虽然二十世纪八十年代，密码学家就提出了MPC算法，但一直以来MPC协议的效率都很低，无法在实际中使用，直到2004年“公平参与”编译器的提出改变了这一现状。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;“公平参与”是第一个通用MPC框架，可以通过MPC执行任意函数的计算。在接下来的10年，这一框架掀起了学者们针对MPC协议性能优化的浪潮。直至现在，无论从算法角度还是从实现层面，MPC协议得到了巨大的优化。在过去十年间，学者们提出了很多端到端MPC框架。在本工作中，我们重点考察通用端到端MPC框架。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;端到端框架的架构如幻灯片所示。框架一般实现了两个阶段的功能：编译器、执行器。这是因为大多数MPC算法只支持有限的算子，如模质数下的加法和乘法。开发者很难应用这些有限的算子实现所需的计算函数。因此，我们重点考察包含一个编译器的框架。编译器的输入是用高级语言描述的函数。编译器会把函数编译成算法可执行的协议。接下来，执行器会具体执行编译好的协议。协议会在多个参与方上同时执行。每个参与方都以编译器的输出结果和自己的秘密值作为输入，计算得到函数输出结果。当然了，不同框架的架构各不相同，但是它们基本都是这样的结构。&lt;/p&gt;&lt;p&gt;在本综述中，我们想回答这样一些问题：目前都有哪些框架？谁在使用这些框架？这些框架是否可以实现实际的计算过程？这些框架是否可以支持所需函数的计算？这些框架是否可以在实际中使用？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为了回答这些问题，我们调查了9个端到端框架和2个电路编译器。我们记录了这些框架的不同特性，包括框架所实现的协议、框架所支持的数据类型和运算操作、以及其它一些实现的具体细节。我们通过多种可用性标准对这些协议进行评价。为了收集这些数据，我们在每个框架上实现3个样例程序。我们把每个框架的完整构建环境及其对应的样例程序都放在了开源的代码仓库中。结合这些框架的使用经验，我们为各个框架补充了相应的文档。构建代码仓库的总时间约为750人小时。此仓库是开源的。我们仍然在积极地维护这一仓库，非常希望大家能看看这个代码仓库。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我想简单介绍一下完成这些工作后我们所得到的一些结论。总的来说，几乎所有的框架做得都不错。各种框架在不同的安全模型下实现了不同的协议。根据具体用例的不同，框架也提供了一些协议和安全模型的选项。我们可以在几乎所有的框架上实现我们的样例程序。这意味着对于绝大多数场景来说，框架的高层语言具有较好的可表达性。总的来说，大多数框架都是开源的、可编译的、可用的。然而，我们发现了两个重要的改进方向。第一个方向是：框架的工程局限性较高。例如，框架的系统构建环境过于复杂。第二个方向是：框架的可用性较差。其根本原因主要在于框架缺失相应的文档。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在具体讲解这些问题之前，我想先从宏观层面介绍我们的发现。我们考察了9个框架。最下方是2个电路编译器。大家可以从表格中看到框架支持的参与方数量、支持的安全模型。我们有两种安全模型。在半诚实模型中，攻击者会正确执行协议，但是攻击者会尝试得到其它参与方的输入。在恶意模型中，攻击者不会遵从约定执行协议，以错误的协议执行结果中推断信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还对不同的协议进行了简单的分类，这里需要简单解释一下。第一类协议是乱码电路协议，最初由姚期智于二十世纪八十年代提出。自姚期智提出此协议以来，学者们持续不断地对协议进行改进。理论密码学家从不同角度对乱码电路进行了优化。从实际中我们发现，几乎所有的框架都实现了半诚实两方协议，一个参与方对电路加密后将结果发送给另一个参与方，另一个参与方根据输入对电路求值。在乱码电路中，需要把函数表示为布尔电路的形式。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二类协议包含很多不同的协议。我们称这类协议为基于电路的多方计算协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这些协议拥有两个共同的特性。第一个特性是，需要把函数表示为代数电路或者布尔电路的形式。第二个特性是，数据需要用线性秘密分享的形式表示。线性秘密分享意味着协议支持任意数量的参与方。参与方协同工作，依次对门电路求值，将秘密分享输入转换为秘密分享输出。然而，在基于电路的多方计算模型下，不同协议将输入转换为输出的方式不太相同，可以基于信息论安全模型下转换，也可以基于密码安全模型下转换。&lt;/p&gt;&lt;p&gt;我们认为这两类协议可以涵盖大多数框架的基础协议。在理论层面，大多数理论密码学家用非常有限的运算操作定义MPC协议，涉及的运算操作只包含模整数下的加法和乘法，或者逐比特与预算和异或运算。这两类运算操作都是图灵完备的，任何函数都可以用这两种运算操作表示。然而，在实际中我们需要为代数模型下的除法、比较等公共函数定义更优的子协议，这样我们就不用把所有函数都表示为基本运算操作，从而提高函数表达的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们发现有3个框架实现了特定的子协议。我们称这类协议为混合协议。在最下方，大家可以看到2个电路编译器。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当选择适当的框架时，人们需要着重考虑的是：高层语言对协议的抽象能力。不同框架都实现了协议的抽象。我们对这些高层语言展开了考察。我们测试的其中一个样例程序是内积运算。内积运算是指逐位计算乘积，再对各个结果求和。&lt;/p&gt;&lt;p&gt;Frigate是一个电路编译器，它的高层语言是非常传统的C语言风格抽象。大家可以看一下幻灯片上给出的内积运算代码实现。初始化结果变量，在向量上构建循环语句，循环中依次取出向量中的每一个元素，计算各个元素的乘积，最后对乘积求和。实现过程非常直观、通俗易懂。然而，如果你熟悉MPC，你可能会知道在线性秘密分享模型中，我们可以通过一轮交互并行处理所有的乘法运算。如果你希望得到优化后的协议，你可能就需要使用PICCO等框架了。&lt;/p&gt;&lt;p&gt;PICCO会对内积运算的乘法进行了并行优化，它们实现了一个针对内积运算的自定义算子。所以PICCO是一个混合协议框架。大家可以看到，可以用这个非常简单的自定义算子求两个任意长向量的内积结果。即使你不熟悉密码学，也可以很方便地直接使用自定义算子，你也不需要关注底层到底做了什么。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，如果你是一个密码学家，你想实现一个比内积更复杂的函数，你可能会希望对生成的电路做更深度的控制和修改。这种情况下，你可能会使用ABY这样的框架。ABY是一个端到端框架，在C语言上实现了一个函数库。大家可以看到，我们用一个share类管理秘密数据。我们随后放置一个乘法门，ABY会帮助我们实现乘法的并行优化。我们需要一个乘法门对整个向量逐位计算乘法。随后，我们把向量展开，对所有乘法运算结果求和。这可以给我们更大的自由，实现我们想实现的函数。但如果你对密码背景不熟悉，你可能就不想具备这些自定义的能力。这就是我们考察的前后端高层语言的范围。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们下一个想讨论的内容是这些框架的一些限制。正如我前面提到的，软件工程是这些框架中最主要的问题。大家一定要记住，大多数框架都是在学术研究场景下开发的。因此，这些框架在工程落地时会有很多的限制。在我讲解下面内容的过程中，大家要把这一点牢记于心。&lt;/p&gt;&lt;p&gt;最主要的痛点是构建系统。系统的整个构建过程非常复杂。你需要从源代码层面编译特定版本的OpenSSL库，这就要花费很长的时间，或者你需要建立一个自定义的证书认证机构，从而建立秘密通信信道。光编译每一个框架平均就要花费我们1-2周的时间。这个过程苦不堪言。但是大家很幸运，我们已经把编译好的环境放在了Docker仓库里，所以大家不需要再重复一遍此项工作了。&lt;/p&gt;&lt;p&gt;在系统构建之上，要使用这些软件框架项目，我们还需要很多的软件开发工作。正确实现密码学协议已经很困难了，但在这之上，开发者还需要实现很多支持系统，例如分布式通信、用安全语言实现与其它通信系统的交互。这方面的结论虽然比较细节，但仍然令人沮丧。例如，在ObliVM中，我们无法编写一个返回结果超过32比特的计算函数。我们可以通过进一步的代码开发来解决这个问题。由于框架都是在学术层面上开发的，框架在实现层面上都不太完美。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个比较严重的问题是可用性，尤其是文档比较匮乏。如幻灯片所示，我们定义了5类文档，一半框架都缺失了至少3类文档。我这里不详细介绍每一类文档的细节，而是想给大家展示几个例子，从而证明语言文档的缺失极大地影响框架的可用性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;语言文档指的是描述如何使用高层语言的文档。CBMC-GC是一个电路编译器，可以将代码编译成乱码电路。大多数人都熟悉C语言。假设我们要实现这样一个简单的程序：把两个数直接相乘。这个代码感觉上是正确的。然而，我们会得到一个编译错误：我们忘记返回一个值。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上，在CBMC-GC中，计算过程中的所有秘密输入的变量名都需要以input开头。这根本不算是一个问题，但是并没有文档说明这一点，我们有必要告诉大家。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个例子来自于ObliVM，这是一个将类Java语言作为高层语言的端到端框架。与前面相同，我们的程序是计算两个数的乘积，但我们碰上了解析错误。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;事实上，Alice和Bob是此高层语言中的保留关键词。因此，我们不能把这两个词作为变量名。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Wisteria是开发编程语言的人所撰写的端到端框架。此框架使用函数式语言来描述计算函数。此框架包含了一个详尽的语言指南，告诉大家如何使用函数式语言编写计算函数。然而，语言文档没有考虑到解析器的限制要求。开发者需要在代码中放置很多的括号，编译器才能编译通过。&lt;/p&gt;&lt;p&gt;EMP-toolkit是一个我们非常喜欢使用的框架。这是一个基于乱码电路的框架。然而，我们发现平均600行代码才会有1行注释，并且没有单独的代码解释文档。这些问题都会导致框架难以使用。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，有一些框架的文档工作做得很好，我真挚地感谢这些框架的作者。对于那些维护一个较大开源项目框架的开发者，我想给出两个重要的建议。&lt;/p&gt;&lt;p&gt;第一个建议是，即使针对不同方面的很简单的文档，也会大幅提高框架的可用性。不同类型的文档指的是，可能有一个文档解释框架的架构，另一个文档是带注释的样例程序，演示一些高层语言的特性。&lt;/p&gt;&lt;p&gt;第二个建议是在线资源，例如提供一个邮件列表或在GitHub上开启问题追踪。这是一个持续生成、持续更新框架文档的好方法。问题追踪就像一个在线问答平台，这样你就不用通过邮件重复回答相同的问题了。问题追踪也是用户之间相互交流的平台，他们可以互相回答遇到的问题。如果你不再想维护你的框架，用户仍然可以相互讨论，解答相应的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;即使有这些工程和可用性方面的问题，MPC框架的实现情况还是非常乐观的。我们可以在框架上实现很多样例程序。总体来说，实现过程还是很顺利的。社区也发现了框架可用性的问题。IARPA HECTOR项目正在赞助下一代MPC框架的实现。在赞助中，它们专门提出了可用性评价标准。&lt;/p&gt;&lt;p&gt;我们强烈建议后续的开发者们可以与编程语言研究者合作。大多数框架都是由密码学家实现的，因此前后端语言的设计可能不是很规范。编译器经验充分的开发人员介入，会对语言设计有更好的帮助。&lt;/p&gt;&lt;p&gt;插播一条广告，我们仍然在积极维护我们的代码仓库，我们随时准备接受新框架、已有框架的提交请求。如果你在维护其中一些框架，或者想在学术项目中使用这些框架，建议看看此代码仓库。&lt;/p&gt;&lt;p&gt;最后一条广告，我们在寻找MPC的落地项目，如果你是潜在合作方，如果你有一个有趣的项目，请稍后与我们联系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢。&lt;/p&gt;&lt;p&gt;（主持人）非常感谢。如果有问题的话，请用麦克风提问。&lt;/p&gt;&lt;p&gt;（提问者）你好，首先非常感谢你们所做的工作。社区迫切需要你们所做的工作，这个工作非常令人激动。我知道你们完成了这一概览性的工作。你们也得到了一些好的结论，一些不好的结论。但你们没有给出类似这样的结论：这是正确的框架，社区应该在这个框架的基础上继续构建，或者类似的结论。这样的结论可能会非常重要，因为如果没有这样的结论，最后的情况可能就是：哦不，这里有12个标准，我们要尝试构建一个标准，然后我们就得到了第13个标准。你能给出类似这样的结论吗？&lt;/p&gt;&lt;p&gt;（演讲人）当然可以。在论文中，我们明确给出了建议，推荐使用哪些框架。如果你在为某个特定场景寻求建议，我这里可以给出4个不同场景下的推荐。对于乱码电路框架来说，Obliv-C是一个不错的通用框架。如果你一些密码学专业知识，EMP-toolkit会更适合你。SCALE-MAMBA最适合多参与方场景，或者说这是一个混合协议框架。因此，这是最好的线性秘密分享协议框架。此框架的适用性很广泛，更新仍然很活跃。如果你有特定的安全需求，你可能会对Sharemind感兴趣，这是唯一一个付费开发者维护的框架，而且开发者是学术领域的研究人员。这就是我给出的推荐建议。&lt;/p&gt;&lt;p&gt;（主持人）谢谢，我绝对也会开发一个将Alice和Bob作为保留关键词的编程语言，这太酷了。再次感谢你的精彩演讲。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-07-15-72119587</guid>
<pubDate>Mon, 15 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>SoK：安全多方计算通用框架</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-07-04-72119587.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72119587&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b38297e2e605b6e0c3739b6eee4bb1e8_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;写在前面&lt;/h2&gt;&lt;p&gt;有段时间没有为知友们带来安全会议的演讲视频翻译了，主要原因是我发现这类文章阅读量并不是很高。业余时间我自己反思了一下，可能是因为知乎到底还是一个问答类社区，文字类型的描述可能更适合知友们快速感知到安全会议演讲视频的内容。为此，在接下来的安全演讲视频文章中，我做了如下几个改变：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;不在知乎上传视频，而是根据视频主讲人的幻灯片展示情况，将对应的演讲稿发出。&lt;/li&gt;&lt;li&gt;演讲视频还是会上传，不过会上传到B站这个专门播放视频的地方。这样，如果有翻译错误，或者有更好的建议，知友或者B站的朋友可以通过弹幕、评论的形式更快地反馈。&lt;/li&gt;&lt;li&gt;演讲视频的中文字幕、时间轴文件（ass格式）、相应的截图等，我会公开在我的GitHub下面，方便知友们下载。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;希望这种方式可以让知友们各取所需。&lt;b&gt;如果知友们还想了解哪些演讲视频，也可以通过知乎评论、GitHub、B站等方式给我留言。我会尽可能满足大家的要求。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;演讲视频简介&lt;/h2&gt;&lt;p&gt;本次为大家带来的是2019年5月23日刚刚召开的安全定义会议Security and Privacy 2019的一个演讲视频《SoK：安全多方计算通用框架》，对应的论文是《SoK: General Purpose Frameworks for Secure Multi-Party Computation》。&lt;/p&gt;&lt;p&gt;这里需要介绍一个背景知识：如果一篇论文的开头是“SoK”，则代表这篇论文是一篇综述论文。SoK的全称是“Systematization of Knowledge Papers&lt;b&gt;”&lt;/b&gt;，Security and Privacy的官方网站（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.ieee-security.org/TC/SP2013/cfp.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;ieee-security.org/TC/SP&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;2013/cfp.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;）给出了一个很详尽的解释：&lt;/p&gt;&lt;blockquote&gt;Following the success of the previous years&amp;#39; conferences, we are also soliciting papers focused on systematization of knowledge (SoK). The goal of this call is to encourage work that evaluates, systematizes, and contextualizes existing knowledge. These papers can provide a high value to our community but may not be accepted because of a lack of novel research contributions. Suitable papers include survey papers that provide useful perspectives on major research areas, papers that support or challenge long-held beliefs with compelling evidence, or papers that provide an extensive and realistic evaluation of competing approaches to solving specific problems. Submissions are encouraged to analyze the current research landscape: identify areas that have enjoyed much research attention, point out open areas with unsolved challenges, and present a prioritization that can guide researchers to make progress on solving important challenges.&lt;b&gt;Submissions must be distinguished by a checkbox on the submission form. In addition, the paper title must have the prefix &amp;#34;SoK:&amp;#34;&lt;/b&gt;. They will be reviewed by the full PC and held to the same standards as traditional research papers, except instead of emphasizing novel research contributions the emphasis will be on value to the community. Accepted papers will be presented at the symposium and included in the proceedings.&lt;/blockquote&gt;&lt;p&gt;简单来说，SoK论文的目标是系统化、结构化地评估已有知识体系的论文。这类论文虽然工作量很大，但由于缺乏必要的创新性贡献，所以一般不会被会议所接收。但是，随着相应知识的不断提出和完善，这类论文会对他人进一步的研究带来非常大的帮助。所以，越来越多的会议开始接收SoK论文了。SoK论文的最大特点是：这类论文的题目必须以“SoK”开头。&lt;/p&gt;&lt;p&gt;《SoK: General Purpose Frameworks for Secure Multi-Party Computation》这篇论文非常详尽的分析了现有的安全多方计算通用框架，从各种维度评估了各个框架的优缺点，在不同场景下给出了使用建议。特别地，作者成功构建了所有的通用框架，并把构建环境打包在Docker中。我个人用了一下Docker，样例程序都可以跑通，作者也针对各个框架给出了进一步的文档和注释。这篇文章特别适合准备研究安全多方计算协议，或者准备在实际中使用安全多方计算的研究人员。&lt;/p&gt;&lt;h2&gt;演讲视频信息&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;原始视频来源：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DI0bremwQ_ns%26t%3D40s&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v=I0bremwQ_ns&amp;amp;t=40s&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;中文翻译视频：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av57765218&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/video/av57&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;765218&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;双语字幕链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/SP%25202019/SoK%2520General%2520Purpose%2520Frameworks%2520for%2520Secure%2520Multi-Party%2520Computation&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/liuweiran900&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;217/SecurityConferenceLectures/tree/master/SP%202019/SoK%20General%20Purpose%20Frameworks%20for%20Secure%20Multi-Party%20Computation&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;演讲视频字幕&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0ec714fdbc319950e50cf3ec6cd0052e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（主讲人）非常感谢主持人的介绍。我是Marcela Hastings。这是一篇SoK论文。我将讲解我们的调研结果。我们考察的工具是安全多方计算。这是一个密码学工具，允许互不信任的参与方根据自己的输入计算任意一个函数，计算过程不泄露除输出结果以外的任何信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-344986b9e5d531bcfa10295b413d37da_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;安全多方计算实际应用中最著名的实例是丹麦甜菜拍卖系统。在这个场景中，售卖方是丹麦种田菜的农民，而购买方只有一个，即丹麦唯一的一个甜菜加工公司。售卖方为甜菜出价，表示他们希望按照这个价格售卖甜菜，购买方希望得知市场出清价（即保证供求关系平衡的售卖价格）。但售卖方不希望泄露自己的具体出价。如果常年泄露出价，则其它人就会得知自己的甜菜种植能力和做生意的能力了。因此，他们使用安全多方计算协议，在不泄露售卖方出价的条件下计算市场出清价。&lt;/p&gt;&lt;p&gt;另一个例子是波士顿妇女劳动委员会与企业的合作项目。此项目研究员工性别是否会影响到其实际的工资。公司不希望、从法律角度也不能够对外泄露自己雇员的收入或金融类信息。但通过安全多方计算，他们可以在不给出具体数据的条件下计算相应的统计分析结果。&lt;/p&gt;&lt;p&gt;所有这些例子都告诉我们安全多方计算已经足够高效，可以在实际场景中得到应用了。然而，我们之前看到的所有实际应用实例中，项目方都需要组织一个密码学专家团队，针对特定用例实现专用MPC引擎。如果想让MPC得到更广泛的应用，我们需要让不懂密码学的外行也能使用这一工具。虽然二十世纪八十年代，密码学家就提出了MPC算法，但一直以来MPC协议的效率都很低，无法在实际中使用，直到2004年“公平参与”编译器的提出改变了这一现状。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48ec5f1426218da43eae5456f754c713_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;“公平参与”是第一个通用MPC框架，可以通过MPC执行任意函数的计算。在接下来的10年，这一框架掀起了学者们针对MPC协议性能优化的浪潮。直至现在，无论从算法角度还是从实现层面，MPC协议得到了巨大的优化。在过去十年间，学者们提出了很多端到端MPC框架。在本工作中，我们重点考察通用端到端MPC框架。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-de75c38e1fe3f7e73303d4091be753e0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;端到端框架的架构如幻灯片所示。框架一般实现了两个阶段的功能：编译器、执行器。这是因为大多数MPC算法只支持有限的算子，如模质数下的加法和乘法。开发者很难应用这些有限的算子实现所需的计算函数。因此，我们重点考察包含一个编译器的框架。编译器的输入是用高级语言描述的函数。编译器会把函数编译成算法可执行的协议。接下来，执行器会具体执行编译好的协议。协议会在多个参与方上同时执行。每个参与方都以编译器的输出结果和自己的秘密值作为输入，计算得到函数输出结果。当然了，不同框架的架构各不相同，但是它们基本都是这样的结构。&lt;/p&gt;&lt;p&gt;在本综述中，我们想回答这样一些问题：目前都有哪些框架？谁在使用这些框架？这些框架是否可以实现实际的计算过程？这些框架是否可以支持所需函数的计算？这些框架是否可以在实际中使用？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-efeb27377bcd2976295c4b815f02f98a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为了回答这些问题，我们调查了9个端到端框架和2个电路编译器。我们记录了这些框架的不同特性，包括框架所实现的协议、框架所支持的数据类型和运算操作、以及其它一些实现的具体细节。我们通过多种可用性标准对这些协议进行评价。为了收集这些数据，我们在每个框架上实现3个样例程序。我们把每个框架的完整构建环境及其对应的样例程序都放在了开源的代码仓库中。结合这些框架的使用经验，我们为各个框架补充了相应的文档。构建代码仓库的总时间约为750人小时。此仓库是开源的。我们仍然在积极地维护这一仓库，非常希望大家能看看这个代码仓库。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-50057c1610e827062ba9bdddeebad16a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在，我想简单介绍一下完成这些工作后我们所得到的一些结论。总的来说，几乎所有的框架做得都不错。各种框架在不同的安全模型下实现了不同的协议。根据具体用例的不同，框架也提供了一些协议和安全模型的选项。我们可以在几乎所有的框架上实现我们的样例程序。这意味着对于绝大多数场景来说，框架的高层语言具有较好的可表达性。总的来说，大多数框架都是开源的、可编译的、可用的。然而，我们发现了两个重要的改进方向。第一个方向是：框架的工程局限性较高。例如，框架的系统构建环境过于复杂。第二个方向是：框架的可用性较差。其根本原因主要在于框架缺失相应的文档。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9af1dc5cc32096b6007c0068060453d0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在具体讲解这些问题之前，我想先从宏观层面介绍我们的发现。我们考察了9个框架。最下方是2个电路编译器。大家可以从表格中看到框架支持的参与方数量、支持的安全模型。我们有两种安全模型。在半诚实模型中，攻击者会正确执行协议，但是攻击者会尝试得到其它参与方的输入。在恶意模型中，攻击者不会遵从约定执行协议，以错误的协议执行结果中推断信息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-353bd3f76c214407082b2d0a68ef270c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们还对不同的协议进行了简单的分类，这里需要简单解释一下。第一类协议是乱码电路协议，最初由姚期智于二十世纪八十年代提出。自姚期智提出此协议以来，学者们持续不断地对协议进行改进。理论密码学家从不同角度对乱码电路进行了优化。从实际中我们发现，几乎所有的框架都实现了半诚实两方协议，一个参与方对电路加密后将结果发送给另一个参与方，另一个参与方根据输入对电路求值。在乱码电路中，需要把函数表示为布尔电路的形式。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-bb4fe9ecfc948472cb3a71d09dec5fb4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二类协议包含很多不同的协议。我们称这类协议为基于电路的多方计算协议。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2da86f1a4040499d0be4fcf9dcaea2a2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这些协议拥有两个共同的特性。第一个特性是，需要把函数表示为代数电路或者布尔电路的形式。第二个特性是，数据需要用线性秘密分享的形式表示。线性秘密分享意味着协议支持任意数量的参与方。参与方协同工作，依次对门电路求值，将秘密分享输入转换为秘密分享输出。然而，在基于电路的多方计算模型下，不同协议将输入转换为输出的方式不太相同，可以基于信息论安全模型下转换，也可以基于密码安全模型下转换。&lt;/p&gt;&lt;p&gt;我们认为这两类协议可以涵盖大多数框架的基础协议。在理论层面，大多数理论密码学家用非常有限的运算操作定义MPC协议，涉及的运算操作只包含模整数下的加法和乘法，或者逐比特与预算和异或运算。这两类运算操作都是图灵完备的，任何函数都可以用这两种运算操作表示。然而，在实际中我们需要为代数模型下的除法、比较等公共函数定义更优的子协议，这样我们就不用把所有函数都表示为基本运算操作，从而提高函数表达的效率。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a5629a998aaebea762af26c216a94b89_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们发现有3个框架实现了特定的子协议。我们称这类协议为混合协议。在最下方，大家可以看到2个电路编译器。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-597c4c92a2a4cc25afcefc4359802371_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当选择适当的框架时，人们需要着重考虑的是：高层语言对协议的抽象能力。不同框架都实现了协议的抽象。我们对这些高层语言展开了考察。我们测试的其中一个样例程序是内积运算。内积运算是指逐位计算乘积，再对各个结果求和。&lt;/p&gt;&lt;p&gt;Frigate是一个电路编译器，它的高层语言是非常传统的C语言风格抽象。大家可以看一下幻灯片上给出的内积运算代码实现。初始化结果变量，在向量上构建循环语句，循环中依次取出向量中的每一个元素，计算各个元素的乘积，最后对乘积求和。实现过程非常直观、通俗易懂。然而，如果你熟悉MPC，你可能会知道在线性秘密分享模型中，我们可以通过一轮交互并行处理所有的乘法运算。如果你希望得到优化后的协议，你可能就需要使用PICCO等框架了。&lt;/p&gt;&lt;p&gt;PICCO会对内积运算的乘法进行了并行优化，它们实现了一个针对内积运算的自定义算子。所以PICCO是一个混合协议框架。大家可以看到，可以用这个非常简单的自定义算子求两个任意长向量的内积结果。即使你不熟悉密码学，也可以很方便地直接使用自定义算子，你也不需要关注底层到底做了什么。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c58f73f6d507fd4b147f6d5bf07d5eb2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，如果你是一个密码学家，你想实现一个比内积更复杂的函数，你可能会希望对生成的电路做更深度的控制和修改。这种情况下，你可能会使用ABY这样的框架。ABY是一个端到端框架，在C语言上实现了一个函数库。大家可以看到，我们用一个share类管理秘密数据。我们随后放置一个乘法门，ABY会帮助我们实现乘法的并行优化。我们需要一个乘法门对整个向量逐位计算乘法。随后，我们把向量展开，对所有乘法运算结果求和。这可以给我们更大的自由，实现我们想实现的函数。但如果你对密码背景不熟悉，你可能就不想具备这些自定义的能力。这就是我们考察的前后端高层语言的范围。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e1968f0d7f484b2ace1dc8f25ce02fd7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们下一个想讨论的内容是这些框架的一些限制。正如我前面提到的，软件工程是这些框架中最主要的问题。大家一定要记住，大多数框架都是在学术研究场景下开发的。因此，这些框架在工程落地时会有很多的限制。在我讲解下面内容的过程中，大家要把这一点牢记于心。&lt;/p&gt;&lt;p&gt;最主要的痛点是构建系统。系统的整个构建过程非常复杂。你需要从源代码层面编译特定版本的OpenSSL库，这就要花费很长的时间，或者你需要建立一个自定义的证书认证机构，从而建立秘密通信信道。光编译每一个框架平均就要花费我们1-2周的时间。这个过程苦不堪言。但是大家很幸运，我们已经把编译好的环境放在了Docker仓库里，所以大家不需要再重复一遍此项工作了。&lt;/p&gt;&lt;p&gt;在系统构建之上，要使用这些软件框架项目，我们还需要很多的软件开发工作。正确实现密码学协议已经很困难了，但在这之上，开发者还需要实现很多支持系统，例如分布式通信、用安全语言实现与其它通信系统的交互。这方面的结论虽然比较细节，但仍然令人沮丧。例如，在ObliVM中，我们无法编写一个返回结果超过32比特的计算函数。我们可以通过进一步的代码开发来解决这个问题。由于框架都是在学术层面上开发的，框架在实现层面上都不太完美。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-65a0db604606bdba3f04e3b12773d959_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个比较严重的问题是可用性，尤其是文档比较匮乏。如幻灯片所示，我们定义了5类文档，一半框架都缺失了至少3类文档。我这里不详细介绍每一类文档的细节，而是想给大家展示几个例子，从而证明语言文档的缺失极大地影响框架的可用性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-48050d8c8f3d71c8fc4503249f683e5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;语言文档指的是描述如何使用高层语言的文档。CBMC-GC是一个电路编译器，可以将代码编译成乱码电路。大多数人都熟悉C语言。假设我们要实现这样一个简单的程序：把两个数直接相乘。这个代码感觉上是正确的。然而，我们会得到一个编译错误：我们忘记返回一个值。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0efc113073c4abd564168a2f3afb0065_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上，在CBMC-GC中，计算过程中的所有秘密输入的变量名都需要以input开头。这根本不算是一个问题，但是并没有文档说明这一点，我们有必要告诉大家。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c1c9b91233a48d7b66d6a56cd104be12_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一个例子来自于ObliVM，这是一个将类Java语言作为高层语言的端到端框架。与前面相同，我们的程序是计算两个数的乘积，但我们碰上了解析错误。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-11805629adcf19afd1db5fdf684aedfc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;事实上，Alice和Bob是此高层语言中的保留关键词。因此，我们不能把这两个词作为变量名。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f639fe8b083a31e43fd0f1825245bdc9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Wisteria是开发编程语言的人所撰写的端到端框架。此框架使用函数式语言来描述计算函数。此框架包含了一个详尽的语言指南，告诉大家如何使用函数式语言编写计算函数。然而，语言文档没有考虑到解析器的限制要求。开发者需要在代码中放置很多的括号，编译器才能编译通过。&lt;/p&gt;&lt;p&gt;EMP-toolkit是一个我们非常喜欢使用的框架。这是一个基于乱码电路的框架。然而，我们发现平均600行代码才会有1行注释，并且没有单独的代码解释文档。这些问题都会导致框架难以使用。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-30226493812ea7f73272f8b6f850c67a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，有一些框架的文档工作做得很好，我真挚地感谢这些框架的作者。对于那些维护一个较大开源项目框架的开发者，我想给出两个重要的建议。&lt;/p&gt;&lt;p&gt;第一个建议是，即使针对不同方面的很简单的文档，也会大幅提高框架的可用性。不同类型的文档指的是，可能有一个文档解释框架的架构，另一个文档是带注释的样例程序，演示一些高层语言的特性。&lt;/p&gt;&lt;p&gt;第二个建议是在线资源，例如提供一个邮件列表或在GitHub上开启问题追踪。这是一个持续生成、持续更新框架文档的好方法。问题追踪就像一个在线问答平台，这样你就不用通过邮件重复回答相同的问题了。问题追踪也是用户之间相互交流的平台，他们可以互相回答遇到的问题。如果你不再想维护你的框架，用户仍然可以相互讨论，解答相应的问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cbef34c91cf5fdb02b94eed7232b6498_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;即使有这些工程和可用性方面的问题，MPC框架的实现情况还是非常乐观的。我们可以在框架上实现很多样例程序。总体来说，实现过程还是很顺利的。社区也发现了框架可用性的问题。IARPA HECTOR项目正在赞助下一代MPC框架的实现。在赞助中，它们专门提出了可用性评价标准。&lt;/p&gt;&lt;p&gt;我们强烈建议后续的开发者们可以与编程语言研究者合作。大多数框架都是由密码学家实现的，因此前后端语言的设计可能不是很规范。编译器经验充分的开发人员介入，会对语言设计有更好的帮助。&lt;/p&gt;&lt;p&gt;插播一条广告，我们仍然在积极维护我们的代码仓库，我们随时准备接受新框架、已有框架的提交请求。如果你在维护其中一些框架，或者想在学术项目中使用这些框架，建议看看此代码仓库。&lt;/p&gt;&lt;p&gt;最后一条广告，我们在寻找MPC的落地项目，如果你是潜在合作方，如果你有一个有趣的项目，请稍后与我们联系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-664cc9d1d7136af91a002d9f4a8eb26a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;非常感谢。&lt;/p&gt;&lt;p&gt;（主持人）非常感谢。如果有问题的话，请用麦克风提问。&lt;/p&gt;&lt;p&gt;（提问者）你好，首先非常感谢你们所做的工作。社区迫切需要你们所做的工作，这个工作非常令人激动。我知道你们完成了这一概览性的工作。你们也得到了一些好的结论，一些不好的结论。但你们没有给出类似这样的结论：这是正确的框架，社区应该在这个框架的基础上继续构建，或者类似的结论。这样的结论可能会非常重要，因为如果没有这样的结论，最后的情况可能就是：哦不，这里有12个标准，我们要尝试构建一个标准，然后我们就得到了第13个标准。你能给出类似这样的结论吗？&lt;/p&gt;&lt;p&gt;（演讲人）当然可以。在论文中，我们明确给出了建议，推荐使用哪些框架。如果你在为某个特定场景寻求建议，我这里可以给出4个不同场景下的推荐。对于乱码电路框架来说，Obliv-C是一个不错的通用框架。如果你一些密码学专业知识，EMP-toolkit会更适合你。SCALE-MAMBA最适合多参与方场景，或者说这是一个混合协议框架。因此，这是最好的线性秘密分享协议框架。此框架的适用性很广泛，更新仍然很活跃。如果你有特定的安全需求，你可能会对Sharemind感兴趣，这是唯一一个付费开发者维护的框架，而且开发者是学术领域的研究人员。这就是我给出的推荐建议。&lt;/p&gt;&lt;p&gt;（主持人）谢谢，我绝对也会开发一个将Alice和Bob作为保留关键词的编程语言，这太酷了。再次感谢你的精彩演讲。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>刘巍然-学酥</author>
<guid isPermaLink="false">2019-07-04-72119587</guid>
<pubDate>Thu, 04 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>详细解读《数据安全管理办法（征求意见稿）》十大亮点（上）</title>
<link>https://henix.github.io/feeds/zhuanlan.datasec/2019-06-01-67678553.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/67678553&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-772cf29145340fd65893bd50821ab1e5_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1.概述《数据安全管理办法（征求意见稿）》（下称：办法）&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;性质：&lt;/b&gt;办法效力高于《信息安全技术个人信息安全规范》（下称《规范》）、《互联网个人信息安全保护指南》（下称指南），规范与指南本身没有强制约束力，而办法相当于部门规章（部级立法），在全国范围内具有强制约束力，如果办法与地方性法规（地方人大立法）冲突的话，终极裁决权在全国人大常委会手中。&lt;/p&gt;&lt;p&gt;&lt;b&gt;保护客体：&lt;/b&gt;个人信息、重要数据&lt;/p&gt;&lt;p&gt;&lt;b&gt;依据：&lt;/b&gt;主要是《网络安全法》&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;&lt;b&gt;亮点一&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;收集使用规则&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;亮点：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;仅当用户知悉收集使用规则并明确同意后，网络运营者方可收集个人信息；可包含于隐私政策中，但要集中展示，不能散见于各条款中。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;收集使用规则要体现数据安全责任人姓名，根据《网络安全法》第六十三条规定，因网络安全问题受过行政处罚五年内不得担任，受到刑事处罚的终身不得担任。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;用户在使用过程中享有撤销同意权、删除权，意味着用户可以随时不同意网络运营者收集其信息，并要求删除。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;《办法》第7、8、9、10条&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;第七条&lt;/b&gt; 网络运营者通过网站、应用程序等产品收集使用个人信息，应当分别制定并公开收集使用规则。收集使用规则可以包含在网站、应用程序等产品的隐私政策中，也可以其他形式提供给用户。&lt;br/&gt;&lt;b&gt;第八条&lt;/b&gt; 收集使用规则应当明确具体、简单通俗、易于访问，突出以下内容：&lt;br/&gt;　　（一）网络运营者基本信息；&lt;br/&gt;　　（二）网络运营者主要负责人、数据安全责任人的姓名及联系方式；&lt;br/&gt;　　（三）收集使用个人信息的目的、种类、数量、频度、方式、范围等；&lt;br/&gt;　　（四）个人信息保存地点、期限及到期后的处理方式；&lt;br/&gt;　　（五）向他人提供个人信息的规则，如果向他人提供的；&lt;br/&gt;　　（六）个人信息安全保护策略等相关信息；&lt;br/&gt;　　（七）个人信息主体撤销同意，以及查询、更正、删除个人信息的途径和方法；&lt;br/&gt;　　（八）投诉、举报渠道和方法等；&lt;br/&gt;　　（九）法律、行政法规规定的其他内容。&lt;br/&gt;&lt;b&gt;第九条&lt;/b&gt; 如果收集使用规则包含在隐私政策中，应相对集中，明显提示，以方便阅读。另仅当用户知悉收集使用规则并明确同意后，网络运营者方可收集个人信息。&lt;br/&gt;&lt;b&gt;第十条&lt;/b&gt; 网络运营者应当严格遵守收集使用规则，网站、应用程序收集或使用个人信息的功能设计应同隐私政策保持一致，同步调整。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不足：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果允许用户任意撤回同意或者删除信息，一方面对数据进行改动成本可能非常大，特别是底层的数据，几个用户申请尚可，如果是千万级别的用户同时申请，必然会影响网络运营者的正常运行。&lt;/p&gt;&lt;p&gt;收集使用协议一般晦涩难懂，应当以表格形式对收集信息进行分门别类展示，具体可参考《规范》：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ff838f74130a1d0d446267f68c31d832_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1019&quot; data-rawheight=&quot;500&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1019&quot; data-original=&quot;https://pic3.zhimg.com/v2-ff838f74130a1d0d446267f68c31d832_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ff838f74130a1d0d446267f68c31d832_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1019&quot; data-rawheight=&quot;500&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1019&quot; data-original=&quot;https://pic3.zhimg.com/v2-ff838f74130a1d0d446267f68c31d832_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ff838f74130a1d0d446267f68c31d832_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;建议：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;将第八条第七款修改为：&lt;/b&gt;个人信息主体撤销同意，以及查询、更正、删除个人信息的途径和方法，但网络运营者可以设定合理的操作期限；&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;增加：收集使用协议对收集的信息应当以表格形式展示，并分类列举。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;&lt;b&gt;亮点二&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;不得因用户拒绝非核心条款而拒绝用户使用产品&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;亮点：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;用户享有真正的否决权，有权拒绝或者撤销同意收集非核心功能信息，而网络运营者不得拒绝提供核心业务功能服务。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;以往，各类APP虽然会提示用户认真阅读隐私条款，但真正会去看的用户少之又少，就连美国大法官都公开表示自己平时用这些产品的时候压根不会去看所谓的隐私协议，包括我本人在内也是闭着眼睛点同意就开始用。即使现实中是这种情况，那为什么政府部门与各大网络运营者还是不留余力的“推销”隐私政策，企业夸自己的隐私政策多么透明，多么规范。在我看来，这样的隐私政策不过是信息保护的一块遮羞布，只管形式上的合规，不管用户真正的利益与体验。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我也时常在想，为什么会出现这种情况？后来我发现真正的原因不是用户懒，不是用户不重视自己的隐私，而是用户知道即使自己不同意其中的条款，也法改变什么，不点同意，意味着让你出门左拐，连用都不让你用。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;而现在的《办法》有望解决这个痛点，并且网络运营者不能再以提升用户体验的“漂亮话”默认用户授权，意思是，非核心功能的信息收集必须列出来让用户明确同意。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;《办法》第11条&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;第十一条 &lt;/b&gt;网络运营者不得以改善服务质量、提升用户体验、定向推送信息、研发新产品等为由，以默认授权、功能捆绑等形式强迫、误导个人信息主体同意其收集个人信息。&lt;br/&gt;个人信息主体同意收集保证网络产品核心业务功能运行的个人信息后，网络运营者应当向个人信息主体提供核心业务功能服务，不得因个人信息主体拒绝或者撤销同意收集上述信息以外的其他信息，而拒绝提供核心业务功能服务。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不足：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如何甄别网站、应用中哪些是核心功能？哪些是非核心功能？如果这个没有明确的解决方式，那么这个条款可能会沦为僵尸条款，因为这个问题属于业务层面问题，企业拥有绝对的主动权。虽然《规范》中规定：“个人信息控制者应根据一般用户对上述因素的最可能的认识和理解，而非自身想法来确定用户的主要需求和期待来划定基本业务功能。一般来说，如果产品或服务不提供基本业务功能，个人信息主体将不会选择使用该产品或服务。”，该规定本质上还是主观判定，可操作空间较大。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;建议：&lt;/p&gt;&lt;p&gt;增加：网络运营者应当明确列明核心业务功能，并说明理由，并接受监督。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;&lt;b&gt;亮点三&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;用户有权关掉精准广告&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;亮点：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;精准广告其实已经相当成熟了，并且也向市场证明了其商业价值，但早在精准广告刚进入用户视线的时候，还是有不少用户感到恐慌，认为自己被监控了，一举一动都暴露在网络运营者的眼中，刚浏览过减肥的信息，马上打开其他应用时，就会有一波减肥产品的广告砸框而来。这次《办法》让用户有权永久性关掉精准广告。&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;《办法》第23条&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;第二十三条&lt;/b&gt; 网络运营者利用用户数据和算法推送新闻信息、商业广告等（以下简称“定向推送”），应当以明显方式标明“定推”字样，为用户提供停止接收定向推送信息的功能；用户选择停止接收定向推送信息时，应当停止推送，并删除已经收集的设备识别码等用户数据和个人信息。&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不足：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;该细则从某种程度上来说，已经否定了“定向广告”（精准广告）这种商业模式。用户不仅有权选择停止接收定向广告，网络运营者还必须将已经收集的设备识别码等用户数据和个人信息删除，这基本上把定向广告的后路全部堵死。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;至于定向广告的商业价值不必多说，但以法规的形式直接否定一种商业模式的行为却是值得商榷的，当然，我个人是反对的。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;何为“利用用户数据和算法”推送广告？用户数据仅指个人信息还是？该规定过于模糊。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果说定向广告侵犯了用户的隐私权，甚至说只是使用了用户的个人信息，那关停定向广告尚有一定依据；倘若通过技术手段，或者以法律认为不侵犯用户权益的方式（朱烨诉百度案，法院认为cookie不属于可识别个人的信息）进行定向广告的推送，那这种定向广告是否还应当被禁止？或者说，用户是否还有权利禁止？我认为答案是否定的，因为此种情况下，用户与网络运营者之间就是正常的平等主体关系，法律法规无理由再干涉二者间的意思自治。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;另外，该细则规定，用户关停定向广告后，网络运营者必须删除已经收集的设备识别码等用户数据和个人信息，这个规定忽略了，设备识别码等用户数据和个人信息不仅仅用于定向广告，还可能用于其他各项服务，所以不能仅因用户关停定向广告，就要求删掉所有设备识别码等信息。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;说个题外话，即使用户关停了定向广告，网络运营者同样可以给用户发送普通广告，所以，用户关停定向广告的这个动作同时也是一个选择动作，即选择了普通广告。所以，从这点出发，网络运营者在草拟相关条款与设置相应操作界面的时候，可以着重向用户提示清楚这层含义，毕竟相比普通广告，相信用户更喜欢看定向广告。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;建议：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;将第二十三条修改为：&lt;/p&gt;&lt;p&gt;网络运营者利用用户数据和算法推送新闻信息、商业广告等（以下简称“定向推送”），应当以明显方式标明“定推”字样，为用户提供停止接收定向推送信息的功能，但不利用用户个人信息或未侵犯用户隐私的可不予提供停止接收定向推送信息的功能，但仍应标明“定推”字样；用户选择停止接收定向推送信息时，应当停止推送，并删除已经收集的设备识别码等用户数据和个人信息，但提供其他服务确实需要使用的可不予删除，但应当告知用户。&lt;/p&gt;&lt;hr/&gt;&lt;blockquote&gt;解读人 | 姜斯勇  &lt;br/&gt;首发 | 公号「 摇滚大数据 」&lt;br/&gt;个人交流微信 | scottlawyer&lt;/blockquote&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;接下来我们将在公号陆续推出：&lt;br/&gt;&lt;b&gt;详细解读《数据安全管理办法（征求意见稿）》十大亮点（中）&lt;/b&gt;&lt;br/&gt;&lt;b&gt;详细解读《数据安全管理办法（征求意见稿）》十大亮点（下）&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>姜斯勇</author>
<guid isPermaLink="false">2019-06-01-67678553</guid>
<pubDate>Sat, 01 Jun 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
