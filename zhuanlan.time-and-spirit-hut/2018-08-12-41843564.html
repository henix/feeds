<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Rust并发模式系列文章导读</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/41843564">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-0f49d040a3f07ae977a925883f9c5b0c_r.jpg" alt=""></div><blockquote>有朋友说新闻里发的并发模式三篇文章难以理解，所以我在这里帮忙做一个导读。</blockquote><h2><b>Rust并发模式文章Part 1导读：通过共享Sender通信</b></h2><p>在阅读本文前，最好能对Rust的Channel有比较详细的了解。</p><ul><li>Rust和Go都奉行「通过通信来共享」的原则，但要注意Rust和Go中Channel的不同。</li><li>Rust中的mpsc，指的是多生产者，单消费者FIFO队列。</li><li>Rust的通道两端只能有同时由一个线程「拥有」，但是Sender端是可以通过clone来共享给多个线程，这就是所谓的mpsc。</li><li>而Go的表现则是一个mpmc，多生产者多消费者。</li><li>Rust channel默认支持异步channel，可以使用SyncChannle支持同步channel。</li></ul><p>文章中用于说明Rust channel用法的示例主要采用下面并发架构：</p><ul><li>主线程从生产者（producer）那里接受消息</li><li>根据producer的消息，将任务分配给工作池</li><li>将工作的结果聚合给消费者</li><li>最终将结果返回给主线程</li></ul><p>因此需要下面几个并发组件：</p><ul><li>producer， 生产要一些「工作任务」</li><li>主线程，指派工作任务</li><li>一组 worker执行任务</li><li>Consumer， 接收工作任务结果</li><li> 一切完成以后回到主线程</li></ul><p>具体的实现流程：</p><ol><li>创建和分享channel。 首先需要在主线程建立两个channel： 用于接收consumer结果，以及用于从producer接收任务。</li><li>创建了一个loop循环，使用mpsc_select，提供了Select，可以同时处理 consumer结果和producer任务的句柄。也可以使用第三方库  crossbeam-channel</li><li>如果只有一个输出端（recevier），如何通过channel给 worker分配任务？答案是建立一个新的channle（如第一条所说），并将sender放到一个VecDeque双端队列里面，循环使用。</li><li>将所有工作汇总到给消费者，完成后回到主线程</li></ol><p>其中的一些术语：</p><blockquote>扇入(Fan-out): 多个函数可以同时从一个channel接收数据，直到channel关闭，这种情况被称作扇出(想象一下，扇形)。这是一种将工作分布给一组工作者的方法，目的是并行使用CPU和I/O。<br>扇出（Fan-in）一个函数同时接收并处理多个channel输入并转化为一个输出channel，直到所有的输入channel都关闭后，关闭输出channel。这种情况称作扇入。</blockquote><p>此外，还有围绕该示例的一些重要问题思考，可以参考完整源码去阅读。 </p><p><a href="https://medium.com/@polyglot_factotum/rust-concurrency-patterns-communicate-by-sharing-your-sender-11a496ce7791">https://medium.com/@polyglot_factotum/rust-concurrency-patterns-communicate-by-sharing-your-sender-11a496ce7791</a></p><p>源码： <a href="https://github.com/gterzian/workflow_executor">gterzian/workflow_executor</a></p><hr><h2><b>Rust并发模式文章Part 2 导读：天生管道流</b></h2><p>本文是对Go 管道模式的实现，但不是模仿Go，而是构建Rusty的管道</p><p><b>管道介绍：</b></p><p>管道是一系列联通的阶段（stage），在每一段中：</p><ul><li>通过 流入channel接收上游数据</li><li>运行一些函数处理数据，产生新的值</li><li>通过流出channel将数据发送给下游</li></ul><p>每一个阶段都有任意个流入channel或流出channel，其中，第一个阶段只有流入channel，最后一个阶段只有流出channel。第一个阶段有时候被称为源或者生产者，最后一个被称为槽或者消费者。</p><p>（想象一下，古人取水通过竹节一段一段连通而成的运水管道）</p><p>本文用Rust实现的管道，包含三个阶段：</p><ul><li>generate 生成数字</li><li>square  使用worker对数字求平方</li><li>merge，对结果进行合并</li></ul><p>本文使用以下特性来实现Rusty的管道：</p><ul><li>thread</li><li>Iterator trait</li><li>for循环</li><li>mpsc::Receiver </li><li>Drop trait</li></ul><p>实现了三个函数：generate、square和merge。</p><ul><li>generate函数中， 生成一个子线程，通过gen_chan的Sender来发送生成的数字</li><li>square函数，同样生成一个子线程，并且构建了新的channel，将接收到的数字通过迭代进行计算，将计算结果发送给merge channel</li><li>merge函数，同样生成一个子线程，并且构建了新的channel，将接收到的square计算结果发送给主线程</li></ul><p>想想 并发模式第一篇文章</p><p><a href="https://medium.com/@polyglot_factotum/rust-concurrency-patterns-natural-born-pipelines-4d599e7612fc">https://medium.com/@polyglot_factotum/rust-concurrency-patterns-natural-born-pipelines-4d599e7612fc</a></p><p><a href="https://github.com/gterzian/pipeline">gterzian/pipeline</a> </p><hr><h2><b>Rust并发模式导读：No context, no cancel, no leaks</b></h2><p>在上一篇文章里，使用Rust实现类似于Go的管道模式。但是在Go中，需要使用Context（上下文）来防止内存泄漏。</p><p>Go语言，表面看起来好像比Rust更简单。但是面对当前的问题，Rust解决的方式更简单。由于Rust的语言特性，比如迭代器、Drop、所有权等，所以我们基本不需要写多余的代码来处理资源泄漏的问题。</p><p>（虽然Rust是保证内存安全，但实际上资源泄漏不在这个内存安全的范围内，纵然如此，使用Rust也很难资源泄漏，除非是通过精心构造循环引用）</p><p>所以在Rust中不需要Context这种东西，也不需要显式地取消channel。</p><p>本文主要是依赖第二篇的例子来说明，用Rust编写并发代码时候，处理垃圾，防止资源泄漏有多简单。</p><p>比如在for循环中，达到条件break出来之后，将channel的reciver直接丢弃即可，Rust中的所有权机制会帮助你处理。</p><p><a href="https://medium.com/@polyglot_factotum/rust-concurrency-patterns-no-context-no-cancel-no-leak-b6c1ec2dafa5">https://medium.com/@polyglot_factotum/rust-concurrency-patterns-no-context-no-cancel-no-leak-b6c1ec2dafa5</a> </p><hr><h2><b>小结：</b></h2><p>Go语言，虽然语法简单，但是它在真正处理问题的时候，复杂性会表现出来。</p><p>Rust语法看上去难，但处理起具体的问题反而十分简洁。</p><p>看你喜欢哪种。</p><p>友情提示：请不要在本文下面进行语言之争。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
