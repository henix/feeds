<div class="title-image"><img src="https://pic1.zhimg.com/v2-9f45089d17fb0ea88ebe8c4252b17473_b.jpg" alt=""></div><p>这里不会对 trie 本身进行介绍。</p><p>让我们首先从一道题目说起 <a href="https://link.zhihu.com/?target=http%3A//codeforces.com/problemset/problem/916/D" class=" wrap external" target="_blank" rel="nofollow noreferrer">CF916D Jamie and To-do List</a></p><p>题目要求设计出一种储存字符串的优先级的数据结构，支持如下操作：</p><ol><li>set a x，将字符串 a 的 priority 设置为x，假若a原本存在，则将原优先级修改为x。</li><li>remove a，将字符串 a 的记录移除，假若 a 不存在，则do nothing。</li><li>query a，查询有多少个字符串的 priority 严格小于 a</li><li>undo d，假设当前是第 i 次操作，则将结构恢复到第 i-d-1 操作后的状态</li><li>操作次数上限为10^5，字符串长度不会超过15，x 范围是[1,10^9]，保证 undo 操作合法</li></ol><p>我们首先不考虑 undo 操作的话，经过思考，我们会发现应该需要两个数据结构，第一个用于维护字符串和 priority 的对应关系；第二个用于储存所有的 priority 用于查询 rank。显然，第一个结构随便用一个 hashmap 或者 trie，第二个使用一个能够查询 rank 的BST，e.g. treap, splay就能够完成。</p><p class="ztext-empty-paragraph"><br/></p><hr/><p class="ztext-empty-paragraph"><br/></p><p>ds&lt;-&gt; data structure </p><p>然而，现在+上了undo操作，这意味着我们需要把历史记录保存下来。具体实现便是使用两个数组 firstds[max_operation_num], secondds[max_operation_num] 在进行第i次操作时便读取 firstds[i-1] 和 secondds[i-1] 中的数据结构，然后将修改之后的数据结构放入 firstds[i] 和 secondds[i] 中，注意！我们这里不能够对第i-1位上的两个数据结构进行任何修改。</p><p>假设我们依然采用之前的 hashmap 和 BST，每一次操作我们都需要将之前的结构 copy 一遍然后再进行操作，无论是空间上还是时间上都感觉......太暴力了。</p><p class="ztext-empty-paragraph"><br/></p><hr/><p class="ztext-empty-paragraph"><br/></p><p>让我们考虑一下第一个结构使用 trie 以及 set 一个原本不存在的字符串的情况。无妨说第一条指令是 set aaa 5，insert 之后的结果就是</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-648a1a135dca27e0e618223bacf2bd6c_b.jpg" data-size="normal" data-rawwidth="916" data-rawheight="522" class="origin_image zh-lightbox-thumb" width="916" data-original="https://pic1.zhimg.com/v2-648a1a135dca27e0e618223bacf2bd6c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-648a1a135dca27e0e618223bacf2bd6c_b.jpg" data-size="normal" data-rawwidth="916" data-rawheight="522" class="origin_image zh-lightbox-thumb lazy" width="916" data-original="https://pic1.zhimg.com/v2-648a1a135dca27e0e618223bacf2bd6c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-648a1a135dca27e0e618223bacf2bd6c_b.jpg"/><figcaption>图1</figcaption></figure><p class="ztext-empty-paragraph"><br/></p><p class="ztext-empty-paragraph"><br/></p><p>第二条指令是 set bbb 4，再次 insert 之后的结果就是</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-bee381fb883c8143c81520ddd1655b7f_b.jpg" data-size="normal" data-rawwidth="986" data-rawheight="591" class="origin_image zh-lightbox-thumb" width="986" data-original="https://pic4.zhimg.com/v2-bee381fb883c8143c81520ddd1655b7f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-bee381fb883c8143c81520ddd1655b7f_b.jpg" data-size="normal" data-rawwidth="986" data-rawheight="591" class="origin_image zh-lightbox-thumb lazy" width="986" data-original="https://pic4.zhimg.com/v2-bee381fb883c8143c81520ddd1655b7f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-bee381fb883c8143c81520ddd1655b7f_b.jpg"/><figcaption>图2</figcaption></figure><p class="ztext-empty-paragraph"><br/></p><p>可以看出，前后的 trie 仅仅只有一条链的变化。说得更加详细一点：</p><ol><li>一个 set a x 操作后的 trie 必然会至少多出一个新节点 n，就是用于存储新字符串优先级的节点(图一中的5和图二中的4，因为该字符串原本不存在</li><li>对于1中所说的新节点 n，我们需要一个新节点 n&#39; 来使 n&#39; 成为 n 的父亲，其中 n&#39; 通过 a 中的最后一个字符指向 n</li><li>由于 n&#39; 同样是一个新节点，我们依然需要一个新节点 n&#39;&#39; 来使 n&#39;&#39; 成为 n&#39; 的父亲，其中 n&#39;&#39; 通过a中的倒数第二个字符指向 n&#39;</li><li>......按照上述做法不断往上新建节点，最终就形成了一条链</li></ol><p>同样也是前后只有一条链的变化，很容易让人联想到可持久化线段树中的操作。</p><p>因此我们 copy 实际上并不是 copy 整个 trie 树，而是<b>仅仅只是新建一条链，剩下的节点和之前的树共用</b>。下图是存有 aaa 的 trie 中先插入 aab 再插入 cc 的过程。第一排代表着理论上发生的情况，第二排是实际上共用了节点的情况</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-50b4ff314b0e57c943f30ea2e163ac0e_b.jpg" data-size="normal" data-rawwidth="1525" data-rawheight="815" class="origin_image zh-lightbox-thumb" width="1525" data-original="https://pic3.zhimg.com/v2-50b4ff314b0e57c943f30ea2e163ac0e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-50b4ff314b0e57c943f30ea2e163ac0e_b.jpg" data-size="normal" data-rawwidth="1525" data-rawheight="815" class="origin_image zh-lightbox-thumb lazy" width="1525" data-original="https://pic3.zhimg.com/v2-50b4ff314b0e57c943f30ea2e163ac0e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-50b4ff314b0e57c943f30ea2e163ac0e_b.jpg"/><figcaption>图3</figcaption></figure><p class="ztext-empty-paragraph"><br/></p><p class="ztext-empty-paragraph"><br/></p><p class="ztext-empty-paragraph"><br/></p><p>刚刚讨论的情况是 set 一个原本不存在的字符串，假若是 set 是更新一个字符串的 priority 呢？按照如上的分析，结果是一样的，同样是修改了一条链而已。对于 remove a 操作呢？看做 set a 0 即可。可持久化 trie 的基本思想到此结束</p><p class="ztext-empty-paragraph"><br/></p><hr/><p class="ztext-empty-paragraph"><br/></p><p>二进制 trie：用于储存整数的 trie，可以用于查询 rank。对于一个 int，我们由高位向低位储存一个整数。与普通 trie 不同的是，二进制 trie 在插入的时候并不是仅仅是最后一个节点有特别的值，而是从根节点开始到最后一个节点整条链上的值都进行修改。例如，向二进制 trie中插入1、2和3如图4</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-9cd6f057699c8425de338323b5174bd8_b.jpg" data-size="normal" data-rawwidth="1377" data-rawheight="423" class="origin_image zh-lightbox-thumb" width="1377" data-original="https://pic1.zhimg.com/v2-9cd6f057699c8425de338323b5174bd8_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-9cd6f057699c8425de338323b5174bd8_b.jpg" data-size="normal" data-rawwidth="1377" data-rawheight="423" class="origin_image zh-lightbox-thumb lazy" width="1377" data-original="https://pic1.zhimg.com/v2-9cd6f057699c8425de338323b5174bd8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-9cd6f057699c8425de338323b5174bd8_b.jpg"/><figcaption>图4</figcaption></figure><p class="ztext-empty-paragraph"><br/></p><p class="ztext-empty-paragraph"><br/></p><p>我们可以发现，从根节点到某一个节点n所经过的路径 path，节点n上的对应的值就是以 path为前缀的 int 出现次数。那么对应某一个 int n 我们如何查询它的 rank 呢？算法描述如下：</p><p>定义局部变量 now=root，ans=0表示答案，迭代变量 i : 从 n 的最高位-&gt;n 的最低位</p><div class="highlight"><pre><code class="language-cpp"><span class="err">•</span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
<span class="err">•</span>   <span class="n">ans</span><span class="o">=</span><span class="n">ans</span><span class="o">+</span><span class="p">(</span><span class="n">now经过0所指向的节点上的值</span><span class="p">)</span>
<span class="err">•</span><span class="n">now</span><span class="o">=</span><span class="p">(</span><span class="n">now经过i所指向的节点</span><span class="p">)</span>
</code></pre></div><p>正确性？想一想就知道了嘛</p><p class="ztext-empty-paragraph"><br/></p><hr/><p class="ztext-empty-paragraph"><br/></p><p>最后，题目的 AC 代码:</p><p><a href="https://link.zhihu.com/?target=http%3A//codeforces.com/contest/916/submission/34342389" class=" wrap external" target="_blank" rel="nofollow noreferrer">好懂的递归写法</a></p><p><a href="https://link.zhihu.com/?target=http%3A//codeforces.com/contest/916/submission/56698896" class=" wrap external" target="_blank" rel="nofollow noreferrer">可读性没有上面好的循环写法</a></p><p>在循环写法中 set 与 add 的时候为什么需要一个 tmp 变量呢？答案是我们需要让新节点指向原来的相同位置上的节点的子节点来达到共用的效果，tmp 变量跟随着 now 同时向下移动来进行 copy node 的操作。假若 tmp 为空了，那么也就没有子节点可以共用了，tmp 也就没有意义了。</p>