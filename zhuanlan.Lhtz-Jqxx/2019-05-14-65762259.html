<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>用深度强化学习打造不亏钱的交易机器人（附代码）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/65762259">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-7aeeb40c67f3c43081550dbe43d1c82e_b.jpg" alt=""></div><p>作者：Adam King</p><p>编译：公众号海外编辑部</p><h2><b>前言</b></h2><p>在本文中，我们将创建深度强化学习agents，学习如何通过比特币交易赚钱。在本文中，我们将使用OpenAI的gym和来自stable-baselines库的PPOagent，这是OpenAI baselines 库的一个分支。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-8856ee137166192f7f13be4381c2e574_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="483" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-8856ee137166192f7f13be4381c2e574_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-8856ee137166192f7f13be4381c2e574_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="483" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-8856ee137166192f7f13be4381c2e574_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-8856ee137166192f7f13be4381c2e574_b.jpg"/></figure><p>十分感谢<b>OpenAI</b>和<b>DeepMind</b>在过去几年为深度学习研究人员提供的开源软件。</p><p>正如Teddy Roosevelt所说：</p><blockquote><i>Nothing worth having comes easy.</i></blockquote><p>所以，与其学习如何交易自己，不如制造一个机器人来为我们做这件事。本文的标的将应用在<b>比特币</b>上。</p><h2><b>正文</b></h2><p>本文中，我们将使用Zielak生成的Kaggle数据集。.csv数据文件在这里下载：</p><p><i><a href="https://link.zhihu.com/?target=https%3A//www.kaggle.com/mczielinski/bitcoin-historical-data" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">kaggle.com/mczielinski/</span><span class="invisible">bitcoin-historical-data</span><span class="ellipsis"></span></a></i></p><p>首先，让我们导入所有必要的库。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-7107af52723d70201949b7cdc5050b5d_b.jpg" data-caption="" data-size="normal" data-rawwidth="603" data-rawheight="111" class="origin_image zh-lightbox-thumb" width="603" data-original="https://pic2.zhimg.com/v2-7107af52723d70201949b7cdc5050b5d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-7107af52723d70201949b7cdc5050b5d_b.jpg" data-caption="" data-size="normal" data-rawwidth="603" data-rawheight="111" class="origin_image zh-lightbox-thumb lazy" width="603" data-original="https://pic2.zhimg.com/v2-7107af52723d70201949b7cdc5050b5d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-7107af52723d70201949b7cdc5050b5d_b.jpg"/></figure><p>接下来，让我们为环境创建类。我们将需要传入一个 pandas dataframe，以及一个可选的 initial_balance 和一个l ookback_window_size，它将指示agent在过去的每一步将观察多少时间步长。我们将把每笔交易的佣金默认为0.075%，即Bitmex的当前利率，把 serial 参数默认为false，这意味着我们的dataframe将在默认情况下以随机切片的形式遍历。</p><p>我们还在数据帧上调用dropna() 和 r eset_index() 来首先删除任何带有 NaN 值的行，然后重置frame的索引，因为我们已经删除了数据。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-2caec4eaca6c2b5d051f795986c9194c_b.jpg" data-caption="" data-size="normal" data-rawwidth="632" data-rawheight="411" class="origin_image zh-lightbox-thumb" width="632" data-original="https://pic1.zhimg.com/v2-2caec4eaca6c2b5d051f795986c9194c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-2caec4eaca6c2b5d051f795986c9194c_b.jpg" data-caption="" data-size="normal" data-rawwidth="632" data-rawheight="411" class="origin_image zh-lightbox-thumb lazy" width="632" data-original="https://pic1.zhimg.com/v2-2caec4eaca6c2b5d051f795986c9194c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-2caec4eaca6c2b5d051f795986c9194c_b.jpg"/></figure><p>这里的 action_space 表示为一个由3个选项组成的离散集合（买进、卖出或持有）和另一个由10个数量组成的离散集合（1/10、2/10、3/10，等等）。当购买操作被选中时，我们将购买 amount * self.balance 平衡BTC值。对于卖出操作，我们将卖出 amount * self.btc_held 持有BTC的价值。当然，hold动作将忽略数量，什么也不做。</p><p>我们的observation_space被定义为0到1之间的连续浮点数集，其大小为(10, lookback_window_size + 1)。+1 表示当前的时间步长。对于窗口中的每个时间步长，我们将观察OHCLV值、我们的净资产、BTC买卖的金额以及在这些BTC上花费或收到的总额。</p><p>接下来，我们需要编写reset方法来初始化环境。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-406974f1b684557b60f227cafa0cbbe1_b.jpg" data-caption="" data-size="normal" data-rawwidth="578" data-rawheight="290" class="origin_image zh-lightbox-thumb" width="578" data-original="https://pic2.zhimg.com/v2-406974f1b684557b60f227cafa0cbbe1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-406974f1b684557b60f227cafa0cbbe1_b.jpg" data-caption="" data-size="normal" data-rawwidth="578" data-rawheight="290" class="origin_image zh-lightbox-thumb lazy" width="578" data-original="https://pic2.zhimg.com/v2-406974f1b684557b60f227cafa0cbbe1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-406974f1b684557b60f227cafa0cbbe1_b.jpg"/></figure><p>这里我们同时使用 self._reset_session 和 self._next_observation，让我们来定义它们。</p><h2><b>交易时段</b></h2><p>我们环境的一个重要部分是交易时段的概念。如果我们将这个agent部署到外部，我们可能永远不会一次运行它超过几个月。 出于这个原因，我们将限制 self.df 中连续frames的数量，我们的agent将连续看到这些帧frames。</p><p>在我们的 _reset_session 方法中，我们首先将 current_step 重置为0。接下来，我们将 steps_left 设置为一个介于1和 MAX_TRADING_SESSION 之间的随机数，现在我们将在代码最前面定义这个随机数。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-6bd8099b8013c9de9077fbad39cdb572_b.png" data-caption="" data-size="normal" data-rawwidth="832" data-rawheight="71" class="origin_image zh-lightbox-thumb" width="832" data-original="https://pic3.zhimg.com/v2-6bd8099b8013c9de9077fbad39cdb572_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-6bd8099b8013c9de9077fbad39cdb572_b.png" data-caption="" data-size="normal" data-rawwidth="832" data-rawheight="71" class="origin_image zh-lightbox-thumb lazy" width="832" data-original="https://pic3.zhimg.com/v2-6bd8099b8013c9de9077fbad39cdb572_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-6bd8099b8013c9de9077fbad39cdb572_b.png"/></figure><p>接下来，如果我们连续遍历frame，我们将设置要遍历的整个frame，否则我们将 frame_start 设置为 self.df 中的随机点，并创建一个名为 active_df 的新数frame，它只是一个切片 self.df 从 frame_start 到 frame_start + steps_left 。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-203f7273ccaee865b859528cd3a60b17_b.jpg" data-caption="" data-size="normal" data-rawwidth="645" data-rawheight="231" class="origin_image zh-lightbox-thumb" width="645" data-original="https://pic4.zhimg.com/v2-203f7273ccaee865b859528cd3a60b17_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-203f7273ccaee865b859528cd3a60b17_b.jpg" data-caption="" data-size="normal" data-rawwidth="645" data-rawheight="231" class="origin_image zh-lightbox-thumb lazy" width="645" data-original="https://pic4.zhimg.com/v2-203f7273ccaee865b859528cd3a60b17_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-203f7273ccaee865b859528cd3a60b17_b.jpg"/></figure><p>在随机切片中遍历dataframe的一个不好的地方是，当经过长时间的训练，我们的agent将有更多独特的数据可用。例如，如果我们只以串行方式遍历dataframe（即从 0 到 len(df) 的顺序），那么我们只会拥有与dataframe中相同数量的惟一数据点。我们的观测空间甚至只能在每一个时间步长上呈现出离散的状态。</p><p>然而，通过随机遍历dataframe的各个部分，我们通过为初始数据集中的每个时间步创建更有趣的帐户余额、所进行的交易和以前看到的价格行为组合，本质上生成了更独特的数据点。</p><p>在重置串行环境后的时间步骤10中，我们的agent将始终在dataframe中的同一时间内，并且在每个时间步骤中有3个选择：买进、卖出或持有。对于这三个选项中的每一个，都需要另外一种选择：10%、20%、……或者100%。这意味着我们的代理可以经历任何(1⁰³)¹⁰总状态，总共1⁰³⁰可能的独特体验。</p><p>现在考虑随机切片的环境。在第10步时，我们的agent可以位于dataframe中的任何 len(df) 时间步长。给定在每个时间步骤做出的相同选择，这意味着该代理可以在相同的10个时间步骤中经历任何 len (df)³⁰ 可能的唯一状态。</p><p>虽然这可能会给大型数据集增加相当多的噪音，但我们认为它应该允许agent从我们有限的数据量中学到更多。我们仍将以串行方式遍历测试数据集，以便更准确地理解算法对新颖申万、看似“实时”数据的有用性。</p><h2><b>Agent Eyes</b></h2><p>它通常有助于可视化环境的观察空间，以便了解你的agent将使用哪些类型的特征。例如，下面是使用OpenCV呈现的观察空间的可视化。<br/></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-94e3f03802ae1bd26bb407a2d9b7aaac_b.jpg" data-caption="" data-size="normal" data-rawwidth="836" data-rawheight="202" class="origin_image zh-lightbox-thumb" width="836" data-original="https://pic1.zhimg.com/v2-94e3f03802ae1bd26bb407a2d9b7aaac_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-94e3f03802ae1bd26bb407a2d9b7aaac_b.jpg" data-caption="" data-size="normal" data-rawwidth="836" data-rawheight="202" class="origin_image zh-lightbox-thumb lazy" width="836" data-original="https://pic1.zhimg.com/v2-94e3f03802ae1bd26bb407a2d9b7aaac_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-94e3f03802ae1bd26bb407a2d9b7aaac_b.jpg"/></figure><p>OpenCV visualization of the environment’s observation space</p><p>图像中的每一行代表我们的observation_space中的一行。 前4行类似频率的红线代表OHCL数据，正下方的虚假橙色和黄色点代表成交量。 下方波动的蓝色条形是agent的净值，而下方的较轻的条形代表agent的交易。</p><p>我们将定义_next_observation方法，将观察到的数据从0缩放到1。</p><p><b><i>It’s important to only scale the data the agent has observed so far to prevent look-ahead biases.</i></b></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-c31c89d44ad1a107ce9f3a58c74ec75a_b.jpg" data-caption="" data-size="normal" data-rawwidth="607" data-rawheight="272" class="origin_image zh-lightbox-thumb" width="607" data-original="https://pic3.zhimg.com/v2-c31c89d44ad1a107ce9f3a58c74ec75a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-c31c89d44ad1a107ce9f3a58c74ec75a_b.jpg" data-caption="" data-size="normal" data-rawwidth="607" data-rawheight="272" class="origin_image zh-lightbox-thumb lazy" width="607" data-original="https://pic3.zhimg.com/v2-c31c89d44ad1a107ce9f3a58c74ec75a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-c31c89d44ad1a107ce9f3a58c74ec75a_b.jpg"/></figure><h2><b>采取行动</b></h2><p>现在我们已经建立了我们的观察空间，是时候编写我们的 step 函数了，然后，执行agent的指定操作。当我们当前交易时段的 self.steps_left == 0 时，我们将出售所持有的任何BTC，并调用 _reset_session()。否则，我们将 reward 设置为当前的净资产，并且只有当我们的钱用完时才将 done 设置为 True。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-2ae344a9d781925bf2889df20f129f44_b.jpg" data-caption="" data-size="normal" data-rawwidth="585" data-rawheight="272" class="origin_image zh-lightbox-thumb" width="585" data-original="https://pic1.zhimg.com/v2-2ae344a9d781925bf2889df20f129f44_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-2ae344a9d781925bf2889df20f129f44_b.jpg" data-caption="" data-size="normal" data-rawwidth="585" data-rawheight="272" class="origin_image zh-lightbox-thumb lazy" width="585" data-original="https://pic1.zhimg.com/v2-2ae344a9d781925bf2889df20f129f44_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-2ae344a9d781925bf2889df20f129f44_b.jpg"/></figure><p>采取行动与 current_price、确定指定的操作以及买卖指定数量的BTC一样简单。让我们快速编写 _take_action，以便测试我们的环境。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-4a0fff15812a6e02345b2a352dcb5738_b.jpg" data-caption="" data-size="normal" data-rawwidth="622" data-rawheight="345" class="origin_image zh-lightbox-thumb" width="622" data-original="https://pic1.zhimg.com/v2-4a0fff15812a6e02345b2a352dcb5738_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-4a0fff15812a6e02345b2a352dcb5738_b.jpg" data-caption="" data-size="normal" data-rawwidth="622" data-rawheight="345" class="origin_image zh-lightbox-thumb lazy" width="622" data-original="https://pic1.zhimg.com/v2-4a0fff15812a6e02345b2a352dcb5738_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-4a0fff15812a6e02345b2a352dcb5738_b.jpg"/></figure><p>最后，用同样的方法，我们将把交易附加到 self.trades 和更新我们的净值和帐户历史。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-c8d35effba7b3dd1ac6706a30c4f4779_b.jpg" data-caption="" data-size="normal" data-rawwidth="603" data-rawheight="313" class="origin_image zh-lightbox-thumb" width="603" data-original="https://pic2.zhimg.com/v2-c8d35effba7b3dd1ac6706a30c4f4779_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-c8d35effba7b3dd1ac6706a30c4f4779_b.jpg" data-caption="" data-size="normal" data-rawwidth="603" data-rawheight="313" class="origin_image zh-lightbox-thumb lazy" width="603" data-original="https://pic2.zhimg.com/v2-c8d35effba7b3dd1ac6706a30c4f4779_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-c8d35effba7b3dd1ac6706a30c4f4779_b.jpg"/></figure><p>我们的agent现在可以启动一个新环境，遍历该环境，并采取影响该环境的操作。是时候看他们交易了。</p><h2><b>交易机器人</b></h2><p>我们的 render 方法可以像调用 print(self.net_worth) 这样简单，但这并不有趣。相反，我们将绘制一个简单的烛台图表。</p><p>我们将使用 StockTradingGraph.py 中的代码，并利用它来呈现我们的比特币环境。</p><p>我们要做的第一个改变是将 self.df [&#39;Date&#39;] 更新到 self.df [&#39;Timestamp&#39;]。并删除所有对 date2num 的调用，因为我们的日期已经采用unix时间戳格式。接下来，在我们的 render 方法中，我们将更新日期标签，以打印我们可读的日期，而不是数字。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-bb198a84a17b93f90f4336d1654422ca_b.gif" data-caption="" data-size="normal" data-rawwidth="279" data-rawheight="208" data-thumbnail="https://pic3.zhimg.com/v2-bb198a84a17b93f90f4336d1654422ca_b.jpg" class="content_image" width="279"/></noscript><img src="https://pic3.zhimg.com/v2-bb198a84a17b93f90f4336d1654422ca_b.gif" data-caption="" data-size="normal" data-rawwidth="279" data-rawheight="208" data-thumbnail="https://pic3.zhimg.com/v2-bb198a84a17b93f90f4336d1654422ca_b.jpg" class="content_image lazy" width="279" data-actualsrc="https://pic3.zhimg.com/v2-bb198a84a17b93f90f4336d1654422ca_b.gif"/></figure><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-dde4ef3b9104112a7924b857776f54de_b.png" data-caption="" data-size="normal" data-rawwidth="834" data-rawheight="75" class="origin_image zh-lightbox-thumb" width="834" data-original="https://pic3.zhimg.com/v2-dde4ef3b9104112a7924b857776f54de_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-dde4ef3b9104112a7924b857776f54de_b.png" data-caption="" data-size="normal" data-rawwidth="834" data-rawheight="75" class="origin_image zh-lightbox-thumb lazy" width="834" data-original="https://pic3.zhimg.com/v2-dde4ef3b9104112a7924b857776f54de_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-dde4ef3b9104112a7924b857776f54de_b.png"/></figure><p>首先，导入 datetime 库，然后使用 utcfromtimestamp 方法从每个时间戳获取UTC字符串，并使用 strftime 将字符串格式化为 Y-m-d H:M 格式。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-05aa81e665c5ce532dd91ea6c0e03a31_b.png" data-caption="" data-size="normal" data-rawwidth="829" data-rawheight="97" class="origin_image zh-lightbox-thumb" width="829" data-original="https://pic2.zhimg.com/v2-05aa81e665c5ce532dd91ea6c0e03a31_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-05aa81e665c5ce532dd91ea6c0e03a31_b.png" data-caption="" data-size="normal" data-rawwidth="829" data-rawheight="97" class="origin_image zh-lightbox-thumb lazy" width="829" data-original="https://pic2.zhimg.com/v2-05aa81e665c5ce532dd91ea6c0e03a31_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-05aa81e665c5ce532dd91ea6c0e03a31_b.png"/></figure><p>最后，我们将 self.df df[&#39;Volume&#39;] 更改为 self.df[&#39;Volume_(BTC)&#39;] 来匹配我们的数据集。回到 BitcoinTradingEnv 中，我们现在可以编写渲染方法来显示图形。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-c04560bae7c22c78644ad4472cb03b35_b.jpg" data-caption="" data-size="normal" data-rawwidth="827" data-rawheight="307" class="origin_image zh-lightbox-thumb" width="827" data-original="https://pic2.zhimg.com/v2-c04560bae7c22c78644ad4472cb03b35_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-c04560bae7c22c78644ad4472cb03b35_b.jpg" data-caption="" data-size="normal" data-rawwidth="827" data-rawheight="307" class="origin_image zh-lightbox-thumb lazy" width="827" data-original="https://pic2.zhimg.com/v2-c04560bae7c22c78644ad4472cb03b35_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-c04560bae7c22c78644ad4472cb03b35_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-4824f3e70549c1898b0aab41375dd9b9_b.jpg" data-caption="" data-size="normal" data-rawwidth="763" data-rawheight="575" class="origin_image zh-lightbox-thumb" width="763" data-original="https://pic2.zhimg.com/v2-4824f3e70549c1898b0aab41375dd9b9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-4824f3e70549c1898b0aab41375dd9b9_b.jpg" data-caption="" data-size="normal" data-rawwidth="763" data-rawheight="575" class="origin_image zh-lightbox-thumb lazy" width="763" data-original="https://pic2.zhimg.com/v2-4824f3e70549c1898b0aab41375dd9b9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-4824f3e70549c1898b0aab41375dd9b9_b.jpg"/></figure><p>绿色表示BTC买入，红色表示卖出。右上角的白色标签是agent当前的净资产，右下角的标签是比特币当前的价格。现在，是时候训练我们的agent了，看看我们能赚多少钱!</p><h2><b>训练时间</b></h2><p>一种常见的交叉验证形式称为k-fold 验证，在这种验证中，将数据分成k个相等的组，逐个单独将一个组作为测试组，并使用其余的数据作为训练组。然而，<b>时间序列数据高度依赖于时间，这意味着以后的数据高度依赖于以前的数据</b>。所以k-fold行不通，因为我们的agent会在交易之前从未来的数据中学习，这是一个不公平的优势。</p><p><b>当应用于时间序列数据时，同样的缺陷也适用于大多数其他交叉验证策略</b>。因此，我们只需要从整个dataframe中取一小部分作为训练集，从frame的开始到任意索引，然后使用其余的数据作为测试集。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-77f03dfc94f71fb62f3b9c377b6c0f73_b.png" data-caption="" data-size="normal" data-rawwidth="834" data-rawheight="123" class="origin_image zh-lightbox-thumb" width="834" data-original="https://pic4.zhimg.com/v2-77f03dfc94f71fb62f3b9c377b6c0f73_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-77f03dfc94f71fb62f3b9c377b6c0f73_b.png" data-caption="" data-size="normal" data-rawwidth="834" data-rawheight="123" class="origin_image zh-lightbox-thumb lazy" width="834" data-original="https://pic4.zhimg.com/v2-77f03dfc94f71fb62f3b9c377b6c0f73_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-77f03dfc94f71fb62f3b9c377b6c0f73_b.png"/></figure><p>接下来，由于我们的环境只设置为处理单个dataframe，所以我们将创建两个环境，一个用于训练数据，一个用于测试数据。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-80d6ab3a207f30ccf7e3c63526556785_b.jpg" data-caption="" data-size="normal" data-rawwidth="834" data-rawheight="150" class="origin_image zh-lightbox-thumb" width="834" data-original="https://pic2.zhimg.com/v2-80d6ab3a207f30ccf7e3c63526556785_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-80d6ab3a207f30ccf7e3c63526556785_b.jpg" data-caption="" data-size="normal" data-rawwidth="834" data-rawheight="150" class="origin_image zh-lightbox-thumb lazy" width="834" data-original="https://pic2.zhimg.com/v2-80d6ab3a207f30ccf7e3c63526556785_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-80d6ab3a207f30ccf7e3c63526556785_b.jpg"/></figure><p>现在，训练我们的模型就像用我们的环境创建一个代理并调用 model.learn 一样简单。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-6175edeccd1cad1d743b0ab31c79293f_b.jpg" data-caption="" data-size="normal" data-rawwidth="841" data-rawheight="177" class="origin_image zh-lightbox-thumb" width="841" data-original="https://pic4.zhimg.com/v2-6175edeccd1cad1d743b0ab31c79293f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-6175edeccd1cad1d743b0ab31c79293f_b.jpg" data-caption="" data-size="normal" data-rawwidth="841" data-rawheight="177" class="origin_image zh-lightbox-thumb lazy" width="841" data-original="https://pic4.zhimg.com/v2-6175edeccd1cad1d743b0ab31c79293f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-6175edeccd1cad1d743b0ab31c79293f_b.jpg"/></figure><p><br/>在这里，我们使用了tensorboard，这样我们就可以很容易地可视化我们的tensorflow图，并查看关于代理的一些量化指标。例如，这里有一张图表，显示了许多agent在20万步以上的时间内获得的rewards：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-258cc6448141a5ac36a84c72728a4cdd_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="300" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic2.zhimg.com/v2-258cc6448141a5ac36a84c72728a4cdd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-258cc6448141a5ac36a84c72728a4cdd_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="300" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic2.zhimg.com/v2-258cc6448141a5ac36a84c72728a4cdd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-258cc6448141a5ac36a84c72728a4cdd_b.jpg"/></figure><p>看来我们的agent非常赚钱！我们最好的agent甚至能够在20万步的过程中使他的余额增加1000倍，而其余的平均至少增加了30倍！</p><p>就在这个时候，我们意识到环境中存在一个bug……在修复了这个bug之后，下面是新的图：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-b9876831840d35de097bef3f26c76801_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="299" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic2.zhimg.com/v2-b9876831840d35de097bef3f26c76801_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-b9876831840d35de097bef3f26c76801_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="299" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic2.zhimg.com/v2-b9876831840d35de097bef3f26c76801_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-b9876831840d35de097bef3f26c76801_b.jpg"/></figure><p>正如你所看到的，我们的一些agent做得很好，而其余的人都破产了。然而，表现良好的agent最多能够将初始余额提高10倍甚至60倍。我们必须承认，<b>所有盈利的agent都是在没有佣金的环境下接受训练和测试的</b>，所以我们的agent想要赚到真正的钱还是完全不现实的。</p><p>让我们在测试环境中测试我们的agent（使用他们从未见过的新数据），看看他们学习如何交易比特币。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-176a56e6c12d3d58775d6af36606f7d7_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="564" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic4.zhimg.com/v2-176a56e6c12d3d58775d6af36606f7d7_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-176a56e6c12d3d58775d6af36606f7d7_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="564" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic4.zhimg.com/v2-176a56e6c12d3d58775d6af36606f7d7_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-176a56e6c12d3d58775d6af36606f7d7_b.jpg"/></figure><p>显然，我们还有很多工作要做。通过简单转换我们的模型使用stable-baseline A2C，而不是当前PPO2 agent，我们可以大大提高我们在此数据集上的性能。最后，根据Sean O&#39;Gorman的建议，我们可以略微更新我们的奖励功能，以便我们奖励净值增加，而不仅仅是实现高净值并留在那里。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-60d0c9585178b06db34d2dd0cadfb31f_b.png" data-caption="" data-size="normal" data-rawwidth="836" data-rawheight="75" class="origin_image zh-lightbox-thumb" width="836" data-original="https://pic4.zhimg.com/v2-60d0c9585178b06db34d2dd0cadfb31f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-60d0c9585178b06db34d2dd0cadfb31f_b.png" data-caption="" data-size="normal" data-rawwidth="836" data-rawheight="75" class="origin_image zh-lightbox-thumb lazy" width="836" data-original="https://pic4.zhimg.com/v2-60d0c9585178b06db34d2dd0cadfb31f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-60d0c9585178b06db34d2dd0cadfb31f_b.png"/></figure><p>仅这两个变化就极大地提高了相同数据集上的性能，正如你在下面看到的，我们最终能够在训练集之外的新数据上实现盈利。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-8b27362ace571bb4e1fe12dc91adea0a_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="581" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic3.zhimg.com/v2-8b27362ace571bb4e1fe12dc91adea0a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-8b27362ace571bb4e1fe12dc91adea0a_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="581" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic3.zhimg.com/v2-8b27362ace571bb4e1fe12dc91adea0a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-8b27362ace571bb4e1fe12dc91adea0a_b.jpg"/></figure><p>我们可以做得更好。为了改善这些结果，我们需要优化超参数，并对agent进行更长时间的训练。</p><p>在后续的文章中，我们将使用<b>贝叶斯优化</b>来为我们的问题空间划分最佳超参数，并为使用CUDA对GPU进行训练/测试准备环境。</p><p>推荐一篇文章：<i><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1807.02811.pdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">arxiv.org/pdf/1807.0281</span><span class="invisible">1.pdf</span><span class="ellipsis"></span></a></i></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-fcd4e300d425bebe9d5cc77e0a74e977_b.jpg" data-caption="" data-size="normal" data-rawwidth="1073" data-rawheight="678" class="origin_image zh-lightbox-thumb" width="1073" data-original="https://pic4.zhimg.com/v2-fcd4e300d425bebe9d5cc77e0a74e977_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-fcd4e300d425bebe9d5cc77e0a74e977_b.jpg" data-caption="" data-size="normal" data-rawwidth="1073" data-rawheight="678" class="origin_image zh-lightbox-thumb lazy" width="1073" data-original="https://pic4.zhimg.com/v2-fcd4e300d425bebe9d5cc77e0a74e977_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-fcd4e300d425bebe9d5cc77e0a74e977_b.jpg"/></figure><h2><b>结论</b></h2><p>虽然我们还没有完全成功地利用新数据打造出一个盈利的比特币交易机器人，但我们已经比当初设定目标时更接近目标了。下一次，我们将确保我们的agent能够从测试数据上赚钱，而不仅仅是训练数据。</p><p><i>原文：</i></p><p><a href="https://link.zhihu.com/?target=https%3A//towardsdatascience.com/creating-bitcoin-trading-bots-that-dont-lose-money" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">towardsdatascience.com/</span><span class="invisible">creating-bitcoin-trading-bots-that-dont-lose-money</span><span class="ellipsis"></span></a></p><h2><b>MATLAB EXPO 2019 微信直播</b></h2><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-95d3176fbcfcca0bb263ce1303f8d559_b.jpg" data-caption="" data-size="normal" data-rawwidth="1012" data-rawheight="378" class="origin_image zh-lightbox-thumb" width="1012" data-original="https://pic2.zhimg.com/v2-95d3176fbcfcca0bb263ce1303f8d559_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-95d3176fbcfcca0bb263ce1303f8d559_b.jpg" data-caption="" data-size="normal" data-rawwidth="1012" data-rawheight="378" class="origin_image zh-lightbox-thumb lazy" width="1012" data-original="https://pic2.zhimg.com/v2-95d3176fbcfcca0bb263ce1303f8d559_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-95d3176fbcfcca0bb263ce1303f8d559_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-d54dd388960c02812506542888068ed4_b.jpg" data-size="normal" data-rawwidth="1080" data-rawheight="608" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-d54dd388960c02812506542888068ed4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-d54dd388960c02812506542888068ed4_b.jpg" data-size="normal" data-rawwidth="1080" data-rawheight="608" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-d54dd388960c02812506542888068ed4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-d54dd388960c02812506542888068ed4_b.jpg"/><figcaption>免费报名参加</figcaption></figure><p><i>—End—</i></p><p>量化投资与机器学习微信公众号，是业内垂直于<b>Quant</b>、<b>MFE</b>、<b>CST</b>等专业的主流自媒体。公众号拥有来自<b>公募、私募、券商、银行、海外</b>等众多圈内<b>10W+</b>关注者。每日发布行业前沿研究成果和最新资讯。</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
