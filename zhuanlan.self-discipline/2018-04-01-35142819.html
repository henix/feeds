<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>语言背后的代数学（五）：Σ代数</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/35142819">原文</a></p>
<p></p><img src="https://pic2.zhimg.com/v2-034808153565717b07d4744f9dd8df32_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="698" data-watermark="watermark" data-original-src="v2-034808153565717b07d4744f9dd8df32" data-watermark-src="v2-13bfa86dbd2cd74be7d0a3d75c9c1078" data-private-watermark-src=""><h2><b>回顾</b></h2><p>上文我们介绍了哥德尔定理，它指出了<b>形式化方法的局限性</b>，<br>任何包含初等算术 <equation>\Pi</equation> 的形式理论，都是不完全的，<br>且自身的协调性无法在系统内部被证明。</p><p>为了理解这句话，上文中我们做出了严谨的定义，<br>仔细建立了语法和语义之间的联系。</p><p>实际上，语法（符号）层面的推导，属于公式的<b>证明</b>，<br>而语义（模型）层面的推导，属于逻辑结论的<b>推理</b>。<br>证明和推理之间的关系由系统的可靠性和完全性给出。</p><h2><b>1. 简单类型化<i>λ</i>演算</b></h2><img src="https://pic3.zhimg.com/v2-7b5497ef5a6fe22bf3b233700e9eeee5_r.jpg" data-caption="" data-size="normal" data-rawwidth="260" data-rawheight="262" data-watermark="watermark" data-original-src="v2-7b5497ef5a6fe22bf3b233700e9eeee5" data-watermark-src="v2-e7acc58db936e56f4febcf7515118356" data-private-watermark-src=""><p>在《<a href="https://zhuanlan.zhihu.com/p/34815896">你好，类型</a>》系列文章中，<br>我们介绍了简单类型化 <equation>\lambda</equation> 演算（simply typed lambda calculus） <equation>\lambda^\to</equation> ，<br>它是一个形式系统，采用公理化的方式定义。</p><p>当时我们看来，系统中的 <equation>\lambda</equation> 项，只是一堆符合推导规则的符号，<br>我们并不知道它到底代表什么含义。</p><p>例如， <equation>\lambda x:T.x+1</equation> ，只是一个符号串，<br>自然数集上的后继函数<code class="inline">f(x)=x+1</code>，能不能作为它的解释，我们是不清楚的，<br>只是猜想可能是。</p><p>不幸的是，后继函数并<b>不足以</b>作为 <equation>\lambda x:T.x+1</equation> 的解释，<br>因为，集合上的后继函数是没有不动点的，而 <equation>\lambda x:T.x+1</equation> 有不动点 <equation>\perp</equation> 。<br>我们曾经在《<a href="https://zhuanlan.zhihu.com/p/34604220">递归函数</a>》系列文章中给出过证明。</p><h2><b>2.</b> <b>Σ代数</b></h2><img src="https://pic1.zhimg.com/v2-292ed54ba3bf86dd48ebbc5ed994cce6_r.jpg" data-caption="" data-size="normal" data-rawwidth="258" data-rawheight="196" data-watermark="watermark" data-original-src="v2-292ed54ba3bf86dd48ebbc5ed994cce6" data-watermark-src="v2-1e9cbd0184ce4df0998eb6104397fd8a" data-private-watermark-src=""><p>一般有两种通用的方法，来给出简单类型化 <equation>\lambda</equation> 演算 <equation>\lambda^\to</equation> 的语义，<br>一种是<b>Henkin模型</b>，另一种是笛卡尔闭范畴。</p><p>范畴论我们可以稍后再介绍，这里先介绍Henkin模型，<br>不过在这之前，我们还得先了解一些 <equation>\Sigma</equation> 代数相关的内容。</p><p><equation>\Sigma</equation> 代数是一种数学结构，<br>一个 <equation>\Sigma</equation> 代数，包含了一个或多个集合，称为<b>载体</b>（carrier），<br>以及一些<b>特征元素</b>，和载体上的一些一阶<b>函数</b>， <equation>f:A_1\times \cdots \times A_k \rightarrow A</equation> 。</p><p>例如， <equation>\Sigma</equation> 代数 <equation>\mathscr{N}=\left \langle N,0,1,+,\cdot\right \rangle</equation> ，具有载体 <equation>N</equation> ，它是自然数集，<br>具有特征元素， <equation>0,1\in N</equation> ，以及函数， <equation>+,*:N \times N \rightarrow N</equation> 。<br>其中，特征元素可以看成<b>零元函数</b>。</p><p>带有多个载体的例子是 <equation>\Sigma</equation> 代数， <equation>\mathscr{A}_{pcf}=\left \langle N,B,0,1,\cdots ,+,true,false,Eq?,\cdots ,\right \rangle</equation> ，<br>其中 <equation>N</equation> 是自然数集， <equation>B</equation> 是布尔值集， <equation>0,1,\cdots</equation> 是自然数， <equation>+</equation> 是加法函数。</p><h2><b>3. 代数数据类型的签名（signature）</b></h2><img src="https://pic4.zhimg.com/v2-833f6e712c91fade3f7cc868965a2a82_r.jpg" data-caption="" data-size="normal" data-rawwidth="230" data-rawheight="198" data-watermark="watermark" data-original-src="v2-833f6e712c91fade3f7cc868965a2a82" data-watermark-src="v2-e1988e84facc4da74411b540ab23a61d" data-private-watermark-src=""><p>在简单类型化 <equation>\lambda</equation> 演算 <equation>\lambda^\to</equation> 中，类型属于形式系统中的概念，<br><b>它并不代表类型中值的集合。<br></b>这种认识可能有助于澄清人们对编程语言中类型的<b>误解</b>。</p><p>例如，我们可以为初等算术系统 <equation>\Pi</equation> 赋予类型，<br>指定 <equation>0:nat</equation> ， <equation>1:nat</equation> ， <equation>+:nat\times nat\to nat</equation> ， <equation>\cdot:nat\times nat\to nat</equation> ，<br>分别为常元符号 <equation>0</equation> 和 <equation>1</equation> ，以及二元函数符号 <equation>+</equation> 和 <equation>\cdot</equation> 的类型。</p><p>常元符号也可以看成是<b>零元</b>函数符号。</p><p>这里，我们称以下二元组 <equation>\left \langle S,F \right \rangle</equation> ，为初等算术系统 <equation>\Pi</equation> 的<b>类型签名</b>。<br>其中， <equation>S</equation> 是系统中类型的集合 <equation>\{nat\}</equation> ，<br> <equation>F</equation> 是函数符号的集合 <equation>\{0:nat,1:nat,+:nat\times nat\to nat,\cdot:nat\times nat\to nat\}</equation> 。</p><p>一般的，一个<b>类型签名</b>（signature） <equation>\Sigma=\left \langle S,F \right \rangle</equation> ，由以下两部分构成，<br>（1） <equation>S</equation> 是以类型为元素构成的集合，<br>（2） <equation>F</equation> 是类型上函数符号的集合， <equation>F=\left \{ f:s_1\times \cdots \times s_k\rightarrow s \right \}</equation> <br>其中， <equation>s_1,\cdots ,s_k,s\in S</equation> 。</p><p>并且，除了初等算术系统 <equation>\Pi</equation> ，某些系统中可能还会包含<b>变量</b>，<br>因此，为了完成类型化，我们还需为这些变量指定类型。</p><p>我们称有限集 <equation>\Gamma=\left \{ x_1:s_1,\cdots ,x_k:s_k \right \}</equation> ，<br>为变量 <equation>x_1,\cdots,x_k</equation> 的一个<b>指派</b>（assignment）。<br>其中， <equation>s_1,\cdots,x_k</equation> 是类型。</p><p>有了<b>签名</b>和<b>指派</b>之后，类型为 <equation>s</equation> 的项的集合 <equation>Terms^s\left ( \Sigma,\Gamma \right )</equation> 就可以这样定义了，<br>（1）如果 <equation>x:s\in \Gamma</equation> 则 <equation>x\in Terms^s\left ( \Sigma,\Gamma \right )</equation> <br>（2）如果 <equation>f:s_1\times \cdots \times s_k\rightarrow s</equation> 且 <equation>M_i\in Terms^{s_i}\left ( \Sigma,\Gamma \right )</equation> ， <equation>i=1,\cdots ,n</equation> ，<br>则 <equation>fM_1\cdots M_k\in Terms^s\left ( \Sigma,\Gamma \right )</equation> </p><p>具有多种类型的项的集合可以记为 <equation>\left \{ Terms^s\left ( \Sigma,\Gamma \right ) \right \}_{s\in S}</equation> ，其中 <equation>S</equation> 为类型的集合。</p><h2><b>4. 项的解释</b></h2><img src="https://pic3.zhimg.com/v2-ee34ec271f8c2d19cb9e404b7ab32a13_r.jpg" data-caption="" data-size="normal" data-rawwidth="500" data-rawheight="310" data-watermark="watermark" data-original-src="v2-ee34ec271f8c2d19cb9e404b7ab32a13" data-watermark-src="v2-fd34250bc10452675241a0c19d3d6ee4" data-private-watermark-src=""><p><equation>\Sigma</equation> 代数，与类型化的项的集合之间，存在着<b>解释</b>关系。</p><p>如果满足以下两个条件，<br>（1）对于每一个类型 <equation>s\in S</equation> ，恰好存在 <equation>\Sigma</equation> 代数中的一个载体 <equation>A^s</equation> 与之对应，<br>（2）每一个函数符号 <equation>f:s_1\times \cdots \times s_k\rightarrow s</equation> ，<br>恰好存在集合上的一个函数 <equation>\mathscr{I}(f):A^{s_1}\times \cdots \times A^{s_k}\rightarrow A^s</equation> 与之对应，<br> <equation>\mathscr{I}(f)</equation> 也可以写成 <equation>f^{\mathscr{A}}</equation> 。</p><p>我们就称 <equation>\mathscr{A}=\left \langle \left \{ A^s \right \}_{s\in S}, \mathscr{I} \right \rangle</equation> 就是 <equation>\left \{ Terms^s\left ( \Sigma,\Gamma \right ) \right \}_{s\in S}</equation> <b>所对应</b>的 <equation>\Sigma</equation> 代数。</p><p>为了解释含变量的类型化的项，我们需要定义<b>环境</b>的概念。<br> <equation>\Sigma</equation> 代数 <equation>\mathscr{A}</equation> 的环境 <equation>\eta</equation> ，指的是把变量映射到 <equation>\mathscr{A}</equation> 的各载体中元素的一个映射，<br> <equation>\eta :\mathscr{V} \rightarrow\cup _sA^s</equation> </p><p>对于含变量 <equation>x</equation> 的项 <equation>M</equation> ， <equation>\eta</equation> 为它指定了载体上的一个唯一确定的值。<br>如果对于指派 <equation>\Gamma</equation> 而言， <equation>\forall x:s\in\Gamma</equation> ，都有 <equation>\eta(x)\in A^s</equation> ，我们就说环境 <equation>\eta</equation> <b>满足</b>指派 <equation>\Gamma</equation> 。</p><p>假定 <equation>\Sigma</equation> 代数 <equation>\mathscr{A}</equation> 的一个环境 <equation>\eta</equation> 满足指派 <equation>\Gamma</equation> ，<br>在这个环境中，我们就可以将任何项 <equation>M\in Terms\left ( \Sigma ,\Gamma \right )</equation> 的含义 <equation>\mathscr{A}[\![M]\!]\eta</equation> 定义如下，<br>（1） <equation>\mathscr{A}[\![x]\!]\eta =\eta (x)</equation> <br>（2） <equation>\mathscr{A}[\![fM_1\cdots M_k]\!]\eta =f^{\mathscr{A}}(\mathscr{A}[\![M_1]\!]\eta ,\cdots ,\mathscr{A}[\![M_k]\!]\eta )</equation> </p><h2><b>5. 例子</b></h2><img src="https://pic3.zhimg.com/v2-6ec544aeea09d77518f5f928dbe782eb_r.jpg" data-caption="" data-size="normal" data-rawwidth="388" data-rawheight="384" data-watermark="watermark" data-original-src="v2-6ec544aeea09d77518f5f928dbe782eb" data-watermark-src="v2-00c10ea44965a352ea337c9e8269311f" data-private-watermark-src=""><p>上文我们介绍了初等算术系统 <equation>\Pi</equation> 的类型签名 <equation>\left \langle S,F \right \rangle</equation> ，其中， <equation>S=\{nat\}</equation> ， <br><equation>F=\{0:nat,1:nat,+:nat\times nat\to nat,\cdot:nat\times nat\to nat\}</equation> 。</p><p>我们可以选择 <equation>\Sigma</equation> 代数 <equation>\mathscr{N}=\left \langle N,0,1,+,\cdot\right \rangle</equation> 作为它的解释，<br>它的载体为自然数集 <equation>N</equation> ， <equation>0,1,+,\cdot</equation> 分别为自然数集上的零元和一元函数。</p><p>如果初等算术系统 <equation>\Pi</equation> 中的项包含变量，我们就可以为 <equation>\Sigma</equation> 代数 <equation>\mathscr{N}</equation> 指定环境 <equation>\eta</equation> 。</p><p>例如，我们可以假定环境 <equation>\eta</equation> 满足 <equation>\eta(x)=0</equation> ，<br>则在这个环境中， <equation>x+1</equation> 的语义就可以按下式确定了。<br> <equation>[\![x+1]\!]\eta=+^\mathscr{N}([\![x]\!]\eta,[\![1]\!])\eta=+^\mathscr{N}(\eta(x),1^\mathscr{N})=+^\mathscr{N}(0^\mathscr{N},1^\mathscr{N})=1</equation> </p><h2><b>总结</b></h2><p>本文介绍了一种称为 <equation>\Sigma</equation> 代数的数学结构，它可以用来解释带有类型签名的项。</p><p>可是，要想让这样的 <equation>\Sigma</equation> 代数称为 <equation>\lambda^\to</equation> 项的模型，还是不够的，<br>我们还必须保证每一个 <equation>\lambda^\to</equation> 项的解释，都在模型中。<br>为此 <equation>\Sigma</equation> 代数还要满足一些额外的条件。</p><p>下文我们再详细讨论这些条件。</p><hr><h2><b>参考</b></h2><p><a href="https://zhuanlan.zhihu.com/p/34815896">你好，类型（六）：Simply typed lambda calculus</a><br><a href="https://zhuanlan.zhihu.com/p/34604220">递归函数（九）：最小不动点定理</a><br><a href="https://book.douban.com/subject/1944729/">程序设计语言理论基础</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
