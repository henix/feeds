<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Milo的编程</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Thu, 18 Oct 2018 17:51:04 +0800</lastBuildDate>
<item>
<title>自然而然</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-10-14-46698082.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46698082&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main() {
    unsigned i, j, k = 0, n = 1e8;
    for (i = 0; i &amp;lt; n; i++)
        for (j = 0; j &amp;lt; RAND_MAX; j += rand())
            k++;
    printf(&quot;%f\n&quot;, (double)k / n);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;console&quot;&gt;$ gcc -O3 a.c &amp;amp;&amp;amp; ./a.out
2.718219&lt;/code&gt;&lt;p&gt;&lt;a href=&quot;http://mathworld.wolfram.com/UniformSumDistribution.html&quot;&gt;Uniform Sum Distribution&lt;/a&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-10-14-46698082</guid>
<pubDate>Sun, 14 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用C语言实现井字棋（上）</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-07-25-39581573.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39581573&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c43e48d68c4d756e3a1a016f910f1382_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.zhihu.com/question/284523599/answer/438445079&quot;&gt;Milo Yip：用C++编写游戏容易吗？有什么开源的小游戏吗？能分享一下吗？&lt;/a&gt; 这个答案中，我提到学习游戏编程可从回合制游戏开始，例如井字棋。&lt;/p&gt;&lt;p&gt;考虑到一些&lt;b&gt;初学者&lt;/b&gt;的学习需求，我就写一个井字棋的教程吧。上篇实现二人游戏，下篇加上「人工智能」后约有 100 行 C 语言代码。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 游戏状态的表示&lt;/h2&gt;&lt;p&gt;首先，我认为表示方法（representation）是编程中应最先要考虑的事情。对于回合制游戏，我们需要存储一个回合中的游戏状态（game state）。&lt;/p&gt;&lt;p&gt;以下用一个结构体表示井字棋一个回合中的状态，并加入函数作初始化：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct {
    int board[3][3];    // -1 = empty, 0 = O, 1 = X
    int turn;           // O first
} state;

void init(state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; j++)
        for (i = 0; i &amp;lt; 3; i++)
            s-&amp;gt;board[j][i] = -1;
    s-&amp;gt;turn = 0;
}&lt;/code&gt;&lt;p&gt;以上用二维数组存储棋盘（board）是其中一种表示方式，另一种方式则是记录每个回合下棋子的位置。我们采用前者是因为它较容易实现胜负判定。有些回合制游戏可能使用冗余的表示方式，以方便实现各种规则。&lt;/p&gt;&lt;p&gt;而使用结构体而不是直接用全局变量，可带来一些优点，例如增强可读性及内聚性。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 显示游戏状态&lt;/h2&gt;&lt;p&gt;编写游戏时，我们通常希望先显示游戏状态，之后才加入其他规则，因为这样可以方便测试。&lt;/p&gt;&lt;p&gt;我希望用这样的文本显示游戏状态，当空置时写上位置编号（1-9），以方便玩家输入下棋位置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt; 1 | 2 | 3 
---+---+---
 4 | 5 | 6 
---+---+---
 7 | 8 | 9 &lt;/code&gt;&lt;p&gt;简单直白地编写代码的话：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void display(const state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; j++) {
        for (i = 0; i &amp;lt; 3; i++) {
            switch (s-&amp;gt;board[j][i]) {
                case -1: printf(&quot; %d &quot;, j * 3 + i + 1); break;
                case  0: printf(&quot; O &quot;); break;
                case  1: printf(&quot; X &quot;); break;
            }
            if (i &amp;lt; 2)
                printf(&quot;|&quot;);
            else
                printf(&quot;\n&quot;);
        }
        if (j &amp;lt; 2)
            printf(&quot;---+---+---\n&quot;);
        else
            printf(&quot;\n&quot;);
    }
}&lt;/code&gt;&lt;p&gt;由于 &lt;code class=&quot;inline&quot;&gt;display()&lt;/code&gt; 只读而不改变游戏状态，所以其参数类型为 &lt;code class=&quot;inline&quot;&gt;const state*&lt;/code&gt;。 &lt;/p&gt;&lt;p&gt;我们稍压缩一下代码：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void display(const state* s) {
    int i, j;
    for (j = 0; j &amp;lt; 3; printf(++j &amp;lt; 3 ? &quot;---+---+---\n&quot; : &quot;\n&quot;))
        for (i = 0; i &amp;lt; 3; putchar(&quot;||\n&quot;[i++]))
            printf(&quot; %c &quot;, s-&amp;gt;board[j][i] == -1 ? &#39;1&#39; + j * 3 + i : &quot;OX&quot;[s-&amp;gt;board[j][i]]);
}&lt;/code&gt;&lt;p&gt;我们可以加入 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 函数去显示初始化的状态：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
} &lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe0.c&quot;&gt;tictactoe0.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 实现下棋&lt;/h2&gt;&lt;p&gt;然后，我们加入第一个游戏规则，就是下棋：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int move(state* s, int i, int j) {
    if (s-&amp;gt;board[j][i] != -1)
        return 0;
    s-&amp;gt;board[j][i] = s-&amp;gt;turn++ % 2;
    return 1;
}&lt;/code&gt;&lt;p&gt;函数内做了一个合法性判断，如果该位置已有棋子，则返回 0 表示失败。成功的话，在偶数回合填入 0，表示 O；奇数回合填入 1，表示 X；然后都把回合加一。&lt;/p&gt;&lt;p&gt;更改 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 简单测试： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    move(&amp;amp;s, 1, 1);
    display(&amp;amp;s);
    move(&amp;amp;s, 0, 1);
    display(&amp;amp;s);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-416ea35bcab6968eb0f15953cac392c5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;162&quot; data-rawheight=&quot;504&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe1.c&quot;&gt;tictactoe1.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;4. 处理输入&lt;/h2&gt;&lt;p&gt;在每一回合中，提示当前玩家（O 或 X），并让玩家输入一个下棋位置（1-9），如果位置不合法，则重新输入：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void human(state* s) {
    char c;
    do {
        printf(&quot;%c: &quot;, &quot;OX&quot;[s-&amp;gt;turn % 2]);
        c = getchar();
        while (getchar() != &#39;\n&#39;);
        printf(&quot;\n&quot;);
    } while (c &amp;lt; &#39;1&#39; || c &amp;gt; &#39;9&#39; || !move(s, (c - &#39;1&#39;) % 3, (c - &#39;1&#39;) / 3));
}&lt;/code&gt;&lt;p&gt;在标准输入中，要到回车键才能处理输入，所以这里我们读了第一个输入字符后，就忽略其他字符直到读到换行符。我们把表示位置的字符转换成二维数组索引。&lt;/p&gt;&lt;p&gt;然后，就可以修改 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 实现二人下棋的流程： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    while (s.turn &amp;lt; 9) {
        human(&amp;amp;s);
        display(&amp;amp;s);
    } 
}&lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe2.c&quot;&gt;tictactoe2.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;5. 胜负判定&lt;/h2&gt;&lt;p&gt;众所周知，井字棋的胜利条件，是有三个棋子在横线、直线或斜线连成一线。我们实现一个 &lt;code class=&quot;inline&quot;&gt;evaluate()&lt;/code&gt; 函数去评估棋局的状态，如果 O 胜出则返回 1，X 胜出则返回 -1，不分胜负则返回 0：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define CHECK(j1, i1, j2, i2, j3, i3) \
    if (s-&amp;gt;board[j1][i1] != -1 &amp;amp;&amp;amp; s-&amp;gt;board[j1][i1] == s-&amp;gt;board[j2][i2] &amp;amp;&amp;amp; s-&amp;gt;board[j1][i1] == s-&amp;gt;board[j3][i3]) \
        return s-&amp;gt;board[j1][i1] == 0 ? 1 : -1;

int evaluate(const state* s) {
    int i;
    for (i = 0; i &amp;lt; 3; i++) {
        CHECK(i, 0, i, 1, i, 2);    // horizontal
        CHECK(0, i, 1, i, 2, i);    // vertical
    }
    CHECK(0, 0, 1, 1, 2, 2);        // diagonal
    CHECK(0, 2, 1, 1, 2, 0);        // diagonal
    return 0;
}&lt;/code&gt;&lt;p&gt;上面的代码使用了一个宏 &lt;code class=&quot;inline&quot;&gt;CHECK()&lt;/code&gt; 去检测三个位置是否都为相同的棋子，如是则直接返回胜方。&lt;/p&gt;&lt;p&gt;最后，我们在 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 中，待每次下棋及显示状态后， 判定是否出现胜方，如果到达第 9 个回合（回合从 0 开始），则判定是平局（draw）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    state s;
    init(&amp;amp;s);
    display(&amp;amp;s);
    while (s.turn &amp;lt; 9) {
        human(&amp;amp;s);
        display(&amp;amp;s);
        switch (evaluate(&amp;amp;s)) {
            case  1: printf(&quot;O win\n&quot;); return 0;
            case -1: printf(&quot;X win\n&quot;); return 0;
        }
    } 
    printf(&quot;Draw\n&quot;);
}&lt;/code&gt;&lt;p&gt;此阶段的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/tictactoe/tictactoe3.c&quot;&gt;tictactoe3.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;6. 总结&lt;/h2&gt;&lt;p&gt;本篇实现了二人井字棋，它是一个简单的回合制游戏。我们先选择了游戏的状态表示方式（&lt;code class=&quot;inline&quot;&gt;state&lt;/code&gt;结构体及&lt;code class=&quot;inline&quot;&gt;init()&lt;/code&gt;函数），然后把状态以文本形式显示（&lt;code class=&quot;inline&quot;&gt;display()&lt;/code&gt;函数），加入每回合下棋规则（&lt;code class=&quot;inline&quot;&gt;move()&lt;/code&gt;函数），以及人类玩家的输入处理（&lt;code class=&quot;inline&quot;&gt;human()&lt;/code&gt;函数），并作胜负判定（&lt;code class=&quot;inline&quot;&gt;evaluate()&lt;/code&gt;函数），最后在&lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt;里则实现了按回合的循环及输出胜负结果。&lt;/p&gt;&lt;p&gt;虽然这个游戏本身以及 60 行的示例代码都很简单，但这个框架可以用于实现其他（更复杂的）回合制游戏。实时游戏（如动作游戏）的主要区别，其实也只在于把输入部分做成非阻塞的函数，而该循环则称为游戏循环（game loop）。&lt;/p&gt;&lt;p&gt;下篇将加入不败的「人工智能」。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-07-25-39581573</guid>
<pubDate>Wed, 25 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用C语言画希尔伯特曲线</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-06-20-38276467.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38276467&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d34f3e5d10cf51d8af90f99b49bdcf03_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B8%8C%E7%88%BE%E4%BC%AF%E7%89%B9%E6%9B%B2%E7%B7%9A&quot;&gt;希尔伯特曲线&lt;/a&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_curve&quot;&gt;Hilbert curve&lt;/a&gt;）是一种空间填充曲线（space filling curve）的分形图案，由德国数学家 &lt;a href=&quot;https://en.wikipedia.org/wiki/David_Hilbert&quot;&gt;David Hilbert&lt;/a&gt;（1862-1943）发现 [1]。简单来说，空间填充曲线就是可以用「一笔画」的方式填充整个二维、三维或更高维的空间。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d7c0d2f1d9b096b85e79f50e8569082f_r.jpg&quot; data-caption=&quot;[1] 中的插图，展示第1、2、3阶的希尔伯特曲线&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;612&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d7c0d2f1d9b096b85e79f50e8569082f&quot; data-watermark-src=&quot;v2-6aee5a02d11ac9d243a38a809e655eae&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;本文描述用 C 语言绘画这种曲线的方法和技巧。&lt;/p&gt;&lt;p&gt;（题图是一个三维的希尔伯特曲线雕塑，来自 &lt;a href=&quot;http://mathbun.com/&quot;&gt;http://mathbun.com/&lt;/a&gt;）&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 递归、坐标变换&lt;/h2&gt;&lt;p&gt;最初，我在 [2] 找到一种基于矢量的绘画方法。它的原理是，一阶的希尔伯特曲线是一个「⊓」的形状，我们可以生成四个顶点，把顶点连接起来。而第二阶则是用第一阶的四个顶点位置，加上旋转和缩小，去画4 个「⊓」形状。只要把最后生成的顶点连接起来，就可以生成整个曲线：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7833b4f3a74fe531aa941a95f9822920_r.jpg&quot; data-caption=&quot;左图是一阶，起点在左下角。右图黑线部分是4个「⊓」形状，它们的中心为左图的顶点位置，加上旋转 -90、0、0、90度、以及缩小为一半。最后把所有顶点连起来，增加了灰线部分。&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;397&quot; data-rawheight=&quot;182&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7833b4f3a74fe531aa941a95f9822920&quot; data-watermark-src=&quot;v2-a802e01794c71709cd1f2128de4b9241&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们用一个影像缓冲去绘画这些垂直、水平线，最后用 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/26525083&quot;&gt;极简的 PNG 编码函数 svpng()&lt;/a&gt;  来存储。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &quot;svpng.inc&quot;
#define S 512

unsigned char img[S * S * 3];
float px = 0.0f, py = 0.0f;

void setpixel(int x, int y) { /* ... */}
void lineto(float tx, float ty) {/* ... */}

void hilbert(float x, float y, float xi, float xj, float yi, float yj, int n) {
    if (n) {
        hilbert(x,                   y,                    yi / 2,  yj / 2,  xi / 2,  xj / 2, n - 1);
        hilbert(x + xi / 2,          y + xj / 2,           xi / 2,  xj / 2,  yi / 2,  yj / 2, n - 1);
        hilbert(x + xi / 2 + yi / 2, y + xj / 2 + yj / 2,  xi / 2,  xj / 2,  yi / 2,  yj / 2, n - 1);
        hilbert(x + xi / 2 + yi,     y + xj / 2 + yj,     -yi / 2, -yj / 2, -xi / 2, -xj / 2, n - 1);
    }
    else
        lineto(x + (xi + yi) / 2, y + (xj + yj) / 2);
}

int main() {
    hilbert(0.0f, 0.0f, 0.0f, S, S, 0.0f, 4);
    svpng(fopen(&quot;hilbert.png&quot;, &quot;wb&quot;), S, S,img, 0);
}&lt;/code&gt;&lt;p&gt;4阶的结果（为方便起见，起点位于左上角）：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-41985853acabc9b888e3c4d28051e63f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-41985853acabc9b888e3c4d28051e63f&quot; data-watermark-src=&quot;v2-07d283a9aeeb319dbbbcf5ea05f91046&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;注：&lt;code class=&quot;inline&quot;&gt;setpixel()&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;lineto()&lt;/code&gt;较锁碎，不在此展示，完整代码位于&lt;a href=&quot;https://github.com/miloyip/misc/blob/master/hilbert/hilbert.c&quot;&gt;https://github.com/miloyip/misc/blob/master/hilbert/hilbert.c&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 方向编码&lt;/h2&gt;&lt;p&gt;第一个方法要计算每个顶点的位置，计算量较大。另一种绘画希尔伯特曲线的方式，是考虑它的 L-system：&lt;/p&gt;&lt;blockquote&gt;变数: L, R&lt;br&gt;常数: F, +, -&lt;br&gt;公理: L&lt;br&gt;规则:&lt;br&gt;L → − R F + L F L + F R −&lt;br&gt;R → − L F + R F R + F L −&lt;br&gt;F ： 向前&lt;br&gt;- ： 右转90°&lt;br&gt;+ ： 左转90°&lt;/blockquote&gt;&lt;p&gt;我们可以看到，两条规则其实是对称的，我们只需要把在迭归时，从 L 变成 R时把旋转方向反转。我参考了[3]的代码实现，但每次向前移动只绘画两个像素，当中&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;为笔的当前像素位置，参数&lt;code class=&quot;inline&quot;&gt;d&lt;/code&gt;为当前方向，&lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt;记录旋转：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &quot;svpng.inc&quot;
#include &amp;lt;stdlib.h&amp;gt;

unsigned char* img, *p;
const int n = 4, s = (2 &amp;lt;&amp;lt; n) - 1;

void step(int d) {
    int a[] = { 3, s * 3, -3, s * -3 }, i;
    for (i = 0; i &amp;lt; 2; i++, p += a[d &amp;amp; 3])
        p[0] = p[1] = p[2] = 255;
}

void hilbert(int d, int r, int n) {
    if (n--) {
        hilbert(d + r, -r, n); step(d + r);
        hilbert(d,      r, n); step(d    );
        hilbert(d,      r, n); step(d - r);
        hilbert(d - r, -r, n);
    }
}

int main() {
    p = img = calloc(s * s, 3);
    hilbert(0, 1, n);
    p[0] = p[1] = p[2] = 255;
    svpng(fopen(&quot;hilbert2.png&quot;, &quot;wb&quot;), s, s, img, 0);
    free(img);
}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b39f241a8582cf0669bfb3a0af68cf1c_r.jpg&quot; data-caption=&quot;放大 16 倍后的4阶结果&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;496&quot; data-rawheight=&quot;496&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b39f241a8582cf0669bfb3a0af68cf1c&quot; data-watermark-src=&quot;v2-5f1180c240c8f3460c447eb1b0e68d50&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这种实现方式较简单，也能用最少的影像尺寸存储结果。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 简单文本&lt;/h2&gt;&lt;p&gt;既然可以用较小的画布尺寸，我们直接把每个像素变换成&lt;code class=&quot;inline&quot;&gt;**&lt;/code&gt; 两个字符：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

char* img, *p;
const int n = 4, s = (2 &amp;lt;&amp;lt; n) - 1, a[] = { 2, s * 2, -2, -s * 2 };

void step(int d) {
    int i;
    for (i = 0; i &amp;lt; 2; i++, p += a[d &amp;amp; 3])
        p[0] = p[1] = &#39;*&#39;;
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    memset(p = img = malloc(s * s * 2), &#39; &#39;, s * s * 2);
    hilbert(0, 1, n);
    p[0] = p[1] = &#39;*&#39;;
    for (p = img; p &amp;lt; img + s * s * 2; p += s * 2)
        printf(&quot;%.*s\n&quot;, s * 2, p);
    free(img);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bab9624e85060beacb77194ae95ec8f8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;890&quot; data-rawheight=&quot;898&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bab9624e85060beacb77194ae95ec8f8&quot; data-watermark-src=&quot;v2-2b008e151d8579c2b45fddf22dcb3081&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;h2&gt;4. ASCII 字符美化&lt;/h2&gt;&lt;p&gt;上面的输出有点丑。我在 [4] 里找到一种美化方法，可通过方向的改变来决定用什么字符，该映射为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┌&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt; _&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┐&lt;/code&gt; →  &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;└&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;|_&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;┘&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;| &lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;│&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;| &lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;─&lt;/code&gt; → &lt;code class=&quot;inline&quot;&gt;__&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9f1bf3371387712e2ce38bf9536636b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;186&quot; data-rawheight=&quot;106&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我通过记录上一次的方向，与当前要步进的方向，去做这个映射。例如之前是向下的（&lt;code class=&quot;inline&quot;&gt;l=3&lt;/code&gt;）当前要向右（&lt;code class=&quot;inline&quot;&gt;d=0&lt;/code&gt;），即&lt;code class=&quot;inline&quot;&gt;└&lt;/code&gt; 的情况，便在笔的位置写进&lt;code class=&quot;inline&quot;&gt;|_&lt;/code&gt;这两个字符。针对 &lt;equation&gt;4\times4=16&lt;/equation&gt; 种组合，我用字符串表示：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

char* img, *p;
const int n = 4 , s = 1 &amp;lt;&amp;lt; n, a[] = { 2, s * 2, -2, -s * 2 };
int l = 3;

void step(int d) {
    d &amp;amp;= 3;
    p[0] = &quot;_  ||||   _|   |&quot;[l * 4 + d];
    p[1] = &quot;_   _    ____   &quot;[l * 4 + d];
    p += a[d];
    l = d;
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    p = img = malloc(s * s * 2);
    hilbert(0, 1, n);
    p[0] = p[1] = &#39; &#39;;
    for (p = img; p &amp;lt; img + s * s * 2; p += s * 2)
        printf(&quot;%.*s\n&quot;, s * 2, p);
    free(img);
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f6d81fe1327e9a92219de371b4cca505_r.jpg&quot; data-caption=&quot;4阶&quot; data-size=&quot;small&quot; data-rawwidth=&quot;768&quot; data-rawheight=&quot;478&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f6d81fe1327e9a92219de371b4cca505&quot; data-watermark-src=&quot;v2-6f64734912d4820a49f0e40933b5835c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0f01b2e77086e678da2860a55fcba3b7_r.jpg&quot; data-caption=&quot;6阶&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1290&quot; data-rawheight=&quot;1308&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0f01b2e77086e678da2860a55fcba3b7&quot; data-watermark-src=&quot;v2-10deb3eb183f553e27a6da9f87a629de&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;h2&gt;5. 无内存分配&lt;/h2&gt;&lt;p&gt;为了尽一步简化，我希望能去掉画步的内存分配。方法是把逻辑改为，从上至下左至右打印字符，每画两个字符我们都遍历整个曲线，若曲线的位置和当前打印位置相同，才把那两个字符打印出来。这样会增加大量运算，但可以减少代码量。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

const int n = 4, s = 1 &amp;lt;&amp;lt; n, a[] = { 1, s, -1, -s };
int l = 3, p, q;

void step(int d) {
    d &amp;amp;= 3;
    if (p == q)
        printf(&quot;%.2s&quot;, &amp;amp;&quot;__    | |_| |      ___|_ _    | &quot;[l * 8 + d * 2]);
    p += a[l = d];
}

void hilbert(int d, int r, int n) { /* ... */ }

int main() {
    for (; q &amp;lt; s * s; q++, p = 0) {
        hilbert(0, 1, n);
        if (q % s == s - 1)
            putchar(&#39;\n&#39;);
    }
}&lt;/code&gt;&lt;h2&gt;6. 代码压缩&lt;/h2&gt;&lt;p&gt;最后，我把上面的代码压缩成 256 个字符：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;const n=4,s=1&amp;lt;&amp;lt;n,a[]={1,s,-1,-s};
l=3,p,q;
t(d){d&amp;amp;=3;p-q||printf(&quot;%.2s&quot;,&amp;amp;&quot;__    | |_| |      ___|_ _    | &quot;[l*8+d*2]);p+=a[l=d];}
h(d,r,n){n--&amp;amp;&amp;amp;(h(d+r,-r,n),t(d+r),h(d,r,n),t(d),h(d,r,n),t(d-r),h(d-r,-r,n));}
main(){for(;p=0,q&amp;lt;s*s;++q%s||putchar(10))h(0,1,n);}&lt;/code&gt;&lt;a href=&quot;https://tio.run/##VY7RaoQwEEV/RYSVxMwU3e1DIeZLREIwuC6k2Zik7IP665vGdvvQCwNz7syFO@JolL2mNN5tiIUV7xBE23UWVD@ItYUA2AKGnRtxAQcLj0TTVVfiwh0u2@b8zcaJlKe3cyihKqUssrZik3mKH0kpN1m8/LI39QfT9Xmg3DGheiP0wPeZaPBg6WoRq4pkZB7wcCAeO4W/j4P/E/5e8RWgfP9UN0voOt094U40sHShDpyx5RRy4684zsqTtqF0Jg20OcP3lJ7jZNQ1JHx8Aw&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Try It Online&lt;/a&gt;&lt;p&gt;本文所有代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/tree/master/hilbert&quot;&gt;https://github.com/miloyip/misc/tree/master/hilbert&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;相关文章&lt;/h2&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24688522&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b082e4583bfbf99f53a075d4510a2f25&quot; data-image-width=&quot;1439&quot; data-image-height=&quot;1080&quot; data-image-size=&quot;180x120&quot;&gt;Milo Yip：用 C 语言画科赫雪花&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23692828&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b5818ef7694bbb3236a1bdc7e9a8b572&quot; data-image-width=&quot;1620&quot; data-image-height=&quot;1080&quot; data-image-size=&quot;180x120&quot;&gt;Milo Yip：如何用 C 语言画这个图&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/27015321/answer/35028446&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;b92e467997b0f799cfb7f085dc06833a&quot; data-image-width=&quot;1018&quot; data-image-height=&quot;884&quot; data-image-size=&quot;ipico&quot;&gt;如何用 C 语言画一个“圣诞树”？&lt;/a&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] D. Hilbert, &lt;a href=&quot;http://www.digizeitschriften.de/dms/img/?PPN=PPN235181684_0038&amp;amp;DMDID=dmdlog40&quot;&gt;Über die stetige Abbildung einer Linie auf ein Flächenstück&lt;/a&gt;, Mathematische Annalen 38 (1891), 459–460.&lt;/p&gt;&lt;p&gt;[2] &lt;a href=&quot;http://www.soc.napier.ac.uk/~andrew/hilbert.html&quot;&gt;http://www.soc.napier.ac.uk/~andrew/hilbert.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[3] &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35358486&quot;&gt;形形色色的空间填充曲线 和 L-System&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[4] &lt;a href=&quot;https://codegolf.stackexchange.com/questions/104392/ascii-hilbert-curve&quot;&gt;ASCII Hilbert Curve&lt;/a&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-06-20-38276467</guid>
<pubDate>Wed, 20 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>波兰表示法与表达式树</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-06-13-38013510.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38013510&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e53026a0f73a4bcaba68b7aa7ae0619f_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;昨晚撰写答案《&lt;a href=&quot;https://www.zhihu.com/question/280630276/answer/415398747&quot;&gt;Milo Yip：怎么用 C 语言画出二叉树的图形？&lt;/a&gt;》，以 ASCII 字符打印任意深度的满二叉树（full binary tree）。评论中问及如何打印非满二叉树。我记起，整个满二叉树可存储在单个一维数组。那么，可以先把非满二叉树的节点写到一维数组，然后修改打印程序，如果数组中存有该序号的节点，才打印该节点及其指向父节点的连线，否则打印空白占位字符。&lt;/p&gt;&lt;p&gt;我的回评或过于简短，不够清晰，因此我想用实际代码解释。然而，怎样建一个非满二叉树？我想到可以写一个简单的表达式解析器，支持加减乘除，不支持负数操作数。程序也能打印出其表达式树。&lt;/p&gt;&lt;p&gt;最简单的表达式语法，莫过于&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95&quot;&gt;波兰表示法&lt;/a&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;Polish notation&lt;/a&gt;）。波兰表示法又称为前缀表示法，即运算符写在前面。波兰表示法的特点是不需要括号。例如，表达式(&lt;code class=&quot;inline&quot;&gt;1 + 2) * (3 - 4)&lt;/code&gt; 的波表示法是 &lt;code class=&quot;inline&quot;&gt;* + 1 2 - 3 4&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;（题图 &lt;a href=&quot;https://unsplash.com/photos/4xEfxMShEUM&quot;&gt;photo by Elliott Engelmann&lt;/a&gt;）&lt;/p&gt;&lt;hr&gt;&lt;p&gt;首先设计解析后的数据结构，表达式树的节点可能是运算符或操作数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef enum { NUM, ADD, SUB, MUL, DIV } Type;

typedef struct NodeTag {
    union {
        double number;
        struct NodeTag *children[2];
    } u;
    Type type;
} Node;&lt;/code&gt;&lt;p&gt;因为一个节点不会同时为运算符或操作数，采用 &lt;code class=&quot;inline&quot;&gt;union&lt;/code&gt;可能节省一点内存。&lt;/p&gt;&lt;p&gt;波兰表示法的解释器非常简单，可通过递归实现，不需要额外的数据结构：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Node* parse(char** s) {
    while (isspace(**s))
        (*s)++;    
    if (**s == &#39;\0&#39;)
        return NULL;
    else {
        Node* n = (Node*)calloc(1, sizeof(Node));
        if (isdigit(**s)) {
            n-&amp;gt;type = NUM;
            n-&amp;gt;u.number = strtod(*s, s);
        }
        else {
            int i;
            switch (**s) {
                case  &#39;+&#39;: n-&amp;gt;type = ADD; break;
                case  &#39;-&#39;: n-&amp;gt;type = SUB; break;
                case  &#39;*&#39;: n-&amp;gt;type = MUL; break;
                case  &#39;/&#39;: n-&amp;gt;type = DIV; break;
                default: release(n); return NULL;
            }
            (*s)++;
            for (i = 0; i &amp;lt; 2; i++)
                if ((n-&amp;gt;u.children[i] = parse(s)) == NULL) {
                    release(n);
                    return NULL;
                }
        }
        return n;
    }
}&lt;/code&gt;&lt;p&gt;每次有内存分配，都匹对释放，也是递归：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void release(Node* n) {
    int i;
    if (n-&amp;gt;type != NUM)
        for (i = 0; i &amp;lt; 2; i++)
            if (n-&amp;gt;u.children[i])
                release(n-&amp;gt;u.children[i]);
    free(n);
}&lt;/code&gt;&lt;p&gt;然后我们可以打印中缀表示法：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define OPERATOR_CHAR(n) (&quot;+-*/&quot;[n-&amp;gt;type - ADD])

void printInfix(const Node *n) {
    if (n-&amp;gt;type == NUM)
        printf(&quot;%lg&quot;, n-&amp;gt;u.number);
    else {
        putchar(&#39;(&#39;);
        printInfix(n-&amp;gt;u.children[0]);
        printf(&quot; %c &quot;, OPERATOR_CHAR(n));
        printInfix(n-&amp;gt;u.children[1]);
        putchar(&#39;)&#39;);
    }
}&lt;/code&gt;&lt;p&gt;以及对表达式树求值：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;double eval(const Node* n) {
    switch (n-&amp;gt;type) {
        case ADD: return eval(n-&amp;gt;u.children[0]) + eval(n-&amp;gt;u.children[1]);
        case SUB: return eval(n-&amp;gt;u.children[0]) - eval(n-&amp;gt;u.children[1]);
        case MUL: return eval(n-&amp;gt;u.children[0]) * eval(n-&amp;gt;u.children[1]);
        case DIV: return eval(n-&amp;gt;u.children[0]) / eval(n-&amp;gt;u.children[1]);
        case NUM: return n-&amp;gt;u.number;
    }
}&lt;/code&gt;&lt;p&gt;编写&lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt;： &lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main(int argc, char** argv) {
    if (argc != 2)
        return printf(&quot;Help: pntree \&quot;+ * 1 2 3\&quot;&quot;);
    else {
        char** p = &amp;amp;argv[1];
        Node* root = parse(p);
        if (root) {
            printInfix(root);
            printf(&quot; = %lg\n&quot;, eval(root));
            release(root);
        }
        else
            return printf(&quot;Invalid input\n&quot;);
    }
}&lt;/code&gt;&lt;p&gt;测试：&lt;/p&gt;&lt;code lang=&quot;console&quot;&gt;$ ./pntree &quot;* + 1 2 - 3 4&quot;
((1 + 2) * (3 - 4)) = -3&lt;/code&gt;&lt;hr&gt;&lt;p&gt;接下来，我们要修改之前的满二叉树打印程序。和之前的需求不一样，树的深度是随输入改变的，所以需先求出最大高度（深度）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int maxDepth(const Node* n) {
    if (n-&amp;gt;type == NUM)
        return 1;
    else {
        int maximum = 0, i, d;
        for (i = 0; i &amp;lt; 2; i++)
            if (maximum &amp;lt; (d = maxDepth(n-&amp;gt;u.children[i])))
                maximum = d;
        return maximum + 1;
    }
}&lt;/code&gt;&lt;p&gt;接着是分配一个 &lt;equation&gt;2^d-1&lt;/equation&gt; 大小的数组，把序号映射至节点：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void fillMap(Node** map, Node* n, int index) {
    int i;
    map[index] = n;
    if (n-&amp;gt;type != NUM)
        for (i = 0; i &amp;lt; 2; i++)
            fillMap(map, n-&amp;gt;u.children[i], index * 2 + i + 1);
}

void printTree(Node* n) {
    int depth = maxDepth(n), i, j, index;
    Node** map = (Node**)calloc((1 &amp;lt;&amp;lt; depth) - 1, sizeof(Node*));
    fillMap(map, n, 0);
    // ...
    free(map);
}&lt;/code&gt;&lt;p&gt;这里和原答案一样，使用广度优先遍历去打印节点。先忽略连线的部分：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void putchars(char c, int n) {
    while (n--)
        putchar(c);
}

int printNode(Node* n, int w) {
    if (n-&amp;gt;type == NUM)
        return printf(&quot;%*lg&quot;, w, n-&amp;gt;u.number);
    else
        return printf(&quot;%*c&quot;, w, &quot;+-*/&quot;[n-&amp;gt;type - ADD]);
}

void printTree(Node* n) {
    int depth = maxDepth(n), i, j, index;
    Node** map = (Node**)calloc((1 &amp;lt;&amp;lt; depth) - 1, sizeof(Node*));
    fillMap(map, n, 0);
    for (j = 0, index = 0; j &amp;lt; depth; j++) {
        int w = 1 &amp;lt;&amp;lt; (depth - j + 1);
        // Curve to parent ...
        // Node content
        for (i = 0; i &amp;lt; 1 &amp;lt;&amp;lt; j; i++, index++)
            if (map[index])
                putchars(&#39; &#39;, w * 2 - printNode(map[index], w));
            else
                putchars(&#39; &#39;, w * 2);
        putchar(&#39;\n&#39;);
    }
    free(map);
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;putchars(c, n)&lt;/code&gt;连续打印 n 个相同字符。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;printNode(n, w)&lt;/code&gt; 打印节点的内容（运算符或操作数），打印寛度为&lt;code class=&quot;inline&quot;&gt;w&lt;/code&gt;个字符，返回实际打印字符数目。&lt;/p&gt;&lt;p&gt;在 &lt;code class=&quot;inline&quot;&gt;printTree(n)&lt;/code&gt;中，采用之前相同的两层循环，在内循环里递增序号&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt;，并获取当前节点&lt;code class=&quot;inline&quot;&gt;map[index]&lt;/code&gt;。若该序号没有节点，则打印空白字符。 &lt;/p&gt;&lt;p&gt;最终结果：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-327cf535e573aca9c44c62564fc3f19e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1710&quot; data-rawheight=&quot;446&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-327cf535e573aca9c44c62564fc3f19e&quot; data-watermark-src=&quot;v2-cd05f5e7509ba8ea3ed3824ddbf85739&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;本文简单示范如何实现波兰表示法的计算器，并打印其非满二叉表达式树。此方法需要 &lt;equation&gt;O(2^d)&lt;/equation&gt; 的时间和空间复杂度。如实际节点数量远低于 &lt;equation&gt;2^d&lt;/equation&gt; ，可考虑用哈希表存储该映射表，但时间复杂度始终无法降低。另一简单优化方法，是用二维数组存储字符输出，那就只需绘画表达式树含有的节点。&lt;/p&gt;&lt;p&gt;完整代码位于 &lt;a href=&quot;https://github.com/miloyip/misc/blob/master/pntree/pntree.c&quot;&gt;pntree.c&lt;/a&gt;。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-06-13-38013510</guid>
<pubDate>Wed, 13 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从零开始的 JSON 库教程（八）：访问与其他功能</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-06-04-37618664.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37618664&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-58d55d45d37aa51b9ba19f3e3cec0b22_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文是&lt;a href=&quot;https://zhuanlan.zhihu.com/json-tutorial&quot;&gt;《从零开始的 JSON 库教程》&lt;/a&gt;的第八个单元。代码位于 &lt;a href=&quot;https://github.com/miloyip/json-tutorial/blob/master/tutorial08&quot;&gt;json-tutorial/tutorial08&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;（题图Photo by &lt;a href=&quot;https://unsplash.com/photos/9Q_pLLP_jmA?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Rob Lambert&lt;/a&gt;）&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 对象键值查询&lt;/h2&gt;&lt;p&gt;我们在第六个单元实现了 JSON 对象的数据结构，它仅为一个 &lt;code class=&quot;inline&quot;&gt;lept_value&lt;/code&gt; 的数组：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;struct lept_value {
    union {
        struct { lept_member* m; size_t size; }o;
        /* ... */
    }u;
    lept_type type;
};

struct lept_member {
    char* k; size_t klen;   /* member key string, key string length */
    lept_value v;           /* member value */
};&lt;/code&gt;&lt;p&gt;为了做相应的解析测试，我们实现了最基本的查询功能：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;size_t lept_get_object_size(const lept_value* v);
const char* lept_get_object_key(const lept_value* v, size_t index);
size_t lept_get_object_key_length(const lept_value* v, size_t index);
lept_value* lept_get_object_value(lept_value* v, size_t index);&lt;/code&gt;&lt;p&gt;在实际使用时，我们许多时候需要查询一个键值是否存在，如存在，要获得其相应的值。我们可以提供一个函数，简单地用线性搜寻实现这个查询功能（时间复杂度 &lt;equation&gt;\mathrm{O}(n)&lt;/equation&gt; ）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define LEPT_KEY_NOT_EXIST ((size_t)-1)

size_t lept_find_object_index(const lept_value* v, const char* key, size_t klen) {
    size_t i;
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_OBJECT &amp;amp;&amp;amp; key != NULL);
    for (i = 0; i &amp;lt; v-&amp;gt;u.o.size; i++)
        if (v-&amp;gt;u.o.m[i].klen == klen &amp;amp;&amp;amp; memcmp(v-&amp;gt;u.o.m[i].k, key, klen) == 0)
            return i;
    return LEPT_KEY_NOT_EXIST;
}}&lt;/code&gt;&lt;p&gt;若对象内没有所需的键，此函数返回 &lt;code class=&quot;inline&quot;&gt;LEPT_KEY_NOT_EXIST&lt;/code&gt;。使用时：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value o;
size_t index;
lept_init(&amp;amp;o);
lept_parse(&amp;amp;o, &quot;{\&quot;name\&quot;:\&quot;Milo\&quot;, \&quot;gender\&quot;:\&quot;M\&quot;}&quot;);
index = lept_find_object_index(&amp;amp;o, &quot;name&quot;, 4);
if (index != LEPT_KEY_NOT_EXIST) {
    lept_value* v = lept_get_object_value(&amp;amp;o, index);
    printf(&quot;%s\n&quot;, lept_get_string(v));
}
lept_free(&amp;amp;o);&lt;/code&gt;&lt;p&gt;由于一般也是希望获取键对应的值，而不需要索引，我们再加入一个辅助函数，返回类型改为 &lt;code class=&quot;inline&quot;&gt;lept_value*&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value* lept_find_object_value(lept_value* v, const char* key, size_t klen) {
    size_t index = lept_find_object_index(v, key, klen);
    return index != LEPT_KEY_NOT_EXIST ? &amp;amp;v-&amp;gt;u.o.m[index].v : NULL;
}&lt;/code&gt;&lt;p&gt;上述例子便可简化为：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value o, *v;
/* ... */
if ((v = lept_find_object_value(&amp;amp;o, &quot;name&quot;, 4)) != NULL)
    printf(&quot;%s\n&quot;, lept_get_string(v));&lt;/code&gt;&lt;hr&gt;&lt;h2&gt;2. 相等比较&lt;/h2&gt;&lt;p&gt;在实现数组和对象的修改之前，为了测试结果的正确性，我们先实现 &lt;code class=&quot;inline&quot;&gt;lept_value&lt;/code&gt; 的&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E9%97%9C%E4%BF%82%E9%81%8B%E7%AE%97%E5%AD%90&quot;&gt;相等比较&lt;/a&gt;（equality comparison）。首先，两个值的类型必须相同，对于 true、false、null 这三种类型，比较类型后便完成比较。而对于数字和字符串，需进一步检查是否相等：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int lept_is_equal(const lept_value* lhs, const lept_value* rhs) {
    assert(lhs != NULL &amp;amp;&amp;amp; rhs != NULL);
    if (lhs-&amp;gt;type != rhs-&amp;gt;type)
        return 0;
    switch (lhs-&amp;gt;type) {
        case LEPT_STRING:
            return lhs-&amp;gt;u.s.len == rhs-&amp;gt;u.s.len &amp;amp;&amp;amp; 
                memcmp(lhs-&amp;gt;u.s.s, rhs-&amp;gt;u.s.s, lhs-&amp;gt;u.s.len) == 0;
        case LEPT_NUMBER:
            return lhs-&amp;gt;u.n == rhs-&amp;gt;u.n;
        /* ... */
        default:
            return 1;
    }
}&lt;/code&gt;&lt;p&gt;由于值可能复合类型（数组和对象），也就是一个树形结构。当我们要比较两个树是否相等，可通过递归实现。例如，对于数组，我们先比较元素数目是否相等，然后递归检查对应的元素是否相等：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int lept_is_equal(const lept_value* lhs, const lept_value* rhs) {
    size_t i;
    /* ... */
    switch (lhs-&amp;gt;type) {
        /* ... */
        case LEPT_ARRAY:
            if (lhs-&amp;gt;u.a.size != rhs-&amp;gt;u.a.size)
                return 0;
            for (i = 0; i &amp;lt; lhs-&amp;gt;u.a.size; i++)
                if (!lept_is_equal(&amp;amp;lhs-&amp;gt;u.a.e[i], &amp;amp;rhs-&amp;gt;u.a.e[i]))
                    return 0;
            return 1;
        /* ... */
    }
}&lt;/code&gt;&lt;p&gt;而对象与数组的不同之处，在于概念上对象的键值对是无序的。例如，&lt;code class=&quot;inline&quot;&gt;{&quot;a&quot;:1,&quot;b&quot;:2}&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;{&quot;b&quot;:2,&quot;a&quot;:1}&lt;/code&gt; 虽然键值的次序不同，但这两个 JSON 对象是相等的。我们可以简单地利用 &lt;code class=&quot;inline&quot;&gt;lept_find_object_index()&lt;/code&gt; 去找出对应的值，然后递归作比较。这部分留给读者作为练习。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 复制、移动与交换&lt;/h2&gt;&lt;p&gt;本单元的重点，在于修改数组和对象的内容。我们将会实现一些接口做修改的操作，例如，为对象设置一个键值，我们可能会这么设计：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_set_object_value(lept_value* v, const char* key, size_t klen, const lept_value* value);

void f() {
    lept_value v, s;
    lept_init(&amp;amp;v);
    lept_parse(&amp;amp;v, &quot;{}&quot;);
    lept_init(&amp;amp;s);
    lept_set_string(&amp;amp;s, &quot;Hello&quot;, 5);
    lept_set_object_keyvalue(&amp;amp;v, &quot;s&quot;, &amp;amp;s); /* {&quot;s&quot;:&quot;Hello&quot;} */
    lept_free(&amp;amp;v)
    lept_free(&amp;amp;s);  /* 第二次释放！*/
}&lt;/code&gt;&lt;p&gt;凡涉及赋值，都可能会引起资源拥有权（resource ownership）的问题。值 &lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt; 并不能以指针方式简单地写入对象 &lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;，因为这样便会有两个地方都拥有 &lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;，会做成重复释放的 bug。我们有两个选择：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 中，把参数 &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_copying#Deep_copy&quot;&gt;深度复制&lt;/a&gt;（deep copy）一个值，即把整个树复制一份，写入其新增的键值对中。&lt;/li&gt;&lt;li&gt;在 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 中，把参数 &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; 拥有权转移至新增的键值对，再把 &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; 设置成 null 值。这就是所谓的移动语意（move semantics）。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;深度复制是一个常用功能，使用者也可能会用到，例如把一个 JSON 复制一个版本出来修改，保持原来的不变。所以，我们实现一个公开的深度复制函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_copy(lept_value* dst, const lept_value* src) {
    size_t i;
    assert(src != NULL &amp;amp;&amp;amp; dst != NULL &amp;amp;&amp;amp; src != dst);
    switch (src-&amp;gt;type) {
        case LEPT_STRING:
            lept_set_string(dst, src-&amp;gt;u.s.s, src-&amp;gt;u.s.len);
            break;
        case LEPT_ARRAY:
            /* \todo */
            break;
        case LEPT_OBJECT:
            /* \todo */
            break;
        default:
            lept_free(dst);
            memcpy(dst, src, sizeof(lept_value));
            break;
    }
}&lt;/code&gt;&lt;p&gt;C++11 加入了右值引用的功能，可以从语言层面区分复制和移动语意。而在 C 语言中，我们也可以通过实现不同版本的接口（不同名字的函数），实现这两种语意。但为了令接口更简单和正交（orthgonal），我们修改了 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 的设计，让它返回新增键值对的值指针，所以我们可以用 &lt;code class=&quot;inline&quot;&gt;lept_copy()&lt;/code&gt; 去复制赋值，也可以简单地改变新增的键值：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;/* 返回新增键值对的指针 */
lept_value* lept_set_object_value(lept_value* v, const char* key, size_t klen);

void f() {
    lept_value v;
    lept_init(&amp;amp;v);
    lept_parse(&amp;amp;v, &quot;{}&quot;);
    lept_set_string(lept_set_object_value(&amp;amp;v, &quot;s&quot;), &quot;Hello&quot;, 5);
    /* {&quot;s&quot;:&quot;Hello&quot;} */
    lept_copy(
        lept_add_object_keyvalue(&amp;amp;v, &quot;t&quot;),
        lept_get_object_keyvalue(&amp;amp;v, &quot;s&quot;, 1));
    /* {&quot;s&quot;:&quot;Hello&quot;,&quot;t&quot;:&quot;Hello&quot;} */
    lept_free(&amp;amp;v);
}
&lt;/code&gt;&lt;p&gt;我们还提供了 &lt;code class=&quot;inline&quot;&gt;lept_move()&lt;/code&gt;，它的实现也非常简单：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_move(lept_value* dst, lept_value* src) {
    assert(dst != NULL &amp;amp;&amp;amp; src != NULL &amp;amp;&amp;amp; src != dst);
    lept_free(dst);
    memcpy(dst, src, sizeof(lept_value));
    lept_init(src);
}&lt;/code&gt;&lt;p&gt;类似地，我们也实现了一个交换值的接口：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_swap(lept_value* lhs, lept_value* rhs) {
    assert(lhs != NULL &amp;amp;&amp;amp; rhs != NULL);
    if (lhs != rhs) {
        lept_value temp;
        memcpy(&amp;amp;temp, lhs, sizeof(lept_value));
        memcpy(lhs,   rhs, sizeof(lept_value));
        memcpy(rhs, &amp;amp;temp, sizeof(lept_value));
    }
}&lt;/code&gt;&lt;p&gt;当我们要修改对象或数组里的值时，我们可以利用这 3 个函数。例如：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;const char* json = &quot;{\&quot;a\&quot;:[1,2],\&quot;b\&quot;:3}&quot;;
char *out;
lept_value v;
lept_init(&amp;amp;v);
lept_parse(&amp;amp;v, json);
lept_copy(
    lept_find_object_value(&amp;amp;v, &quot;b&quot;, 1),
    lept_find_object_value(&amp;amp;v, &quot;a&quot;, 1));
printf(&quot;%s\n&quot;, out = lept_stringify(&amp;amp;v, NULL)); /* {&quot;a&quot;:[1,2],&quot;b&quot;:[1,2]} */
free(out);

lept_parse(&amp;amp;v, json);
lept_move(
    lept_find_object_value(&amp;amp;v, &quot;b&quot;, 1),
    lept_find_object_value(&amp;amp;v, &quot;a&quot;, 1));
printf(&quot;%s\n&quot;, out = lept_stringify(&amp;amp;v, NULL)); /* {&quot;a&quot;:null,&quot;b&quot;:[1,2]} */
free(out);

lept_parse(&amp;amp;v, json);
lept_swap(
    lept_find_object_value(&amp;amp;v, &quot;b&quot;, 1),
    lept_find_object_value(&amp;amp;v, &quot;a&quot;, 1));
printf(&quot;%s\n&quot;, out = lept_stringify(&amp;amp;v, NULL)); /* {&quot;a&quot;:3,&quot;b&quot;:[1,2]} */
free(out);

lept_free(&amp;amp;v);&lt;/code&gt;&lt;p&gt;在使用时，可尽量避免 &lt;code class=&quot;inline&quot;&gt;lept_copy()&lt;/code&gt;，而改用 &lt;code class=&quot;inline&quot;&gt;lept_move()&lt;/code&gt; 或 &lt;code class=&quot;inline&quot;&gt;lept_swap()&lt;/code&gt;，因为后者不需要分配内存。当中 &lt;code class=&quot;inline&quot;&gt;lept_swap()&lt;/code&gt; 更是无须做释放的工作，令它达到 &lt;equation&gt;\mathrm{O}(1)&lt;/equation&gt; 时间复杂度，其性能与值的内容无关。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;4. 动态数组&lt;/h2&gt;&lt;p&gt;在此单元之前的实现里，每个数组的元素数目在解析后是固定不变的，其数据结构是：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;struct lept_value {
    union {
        /* ... */
        struct { lept_value* e; size_t size; }a; /* array:  elements, element count*/
        /* ... */
    }u;
    lept_type type;
};&lt;/code&gt;&lt;p&gt;用这种数据结构增删元素时，我们需要重新分配一个数组，把适当的旧数据拷贝过去。但这种做法是非常低效的。例如我们想要从一个空的数组加入 &lt;equation&gt;n&lt;/equation&gt; 个元素，便要做 &lt;equation&gt;n(n - 1)/2&lt;/equation&gt; 次元素复制，即 &lt;equation&gt;\mathrm{O}(n^2)&lt;/equation&gt; 的时间复杂度。&lt;/p&gt;&lt;p&gt;其中一个改进方法，是使用动态数组（&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_array&quot;&gt;dynamic array&lt;/a&gt;，或称可增长数组／growable array）的数据结构。C++ STL 标准库中最常用的 &lt;code class=&quot;inline&quot;&gt;std::vector&lt;/code&gt; 也是使用这种数据结构的容器。&lt;/p&gt;&lt;p&gt;改动也很简单，只需要在数组中加入容量 &lt;code class=&quot;inline&quot;&gt;capacity&lt;/code&gt; 字段，表示当前已分配的元素数目，而 &lt;code class=&quot;inline&quot;&gt;size&lt;/code&gt; 则表示现时的有效元素数目：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;        /* ... */
        struct { lept_value* e; size_t size, capacity; }a; /* array:  elements, element count, capacity */
        /* ... */&lt;/code&gt;&lt;p&gt;我们终于提供设置数组的函数，而且它可提供初始的容量：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_set_array(lept_value* v, size_t capacity) {
    assert(v != NULL);
    lept_free(v);
    v-&amp;gt;type = LEPT_ARRAY;
    v-&amp;gt;u.a.size = 0;
    v-&amp;gt;u.a.capacity = capacity;
    v-&amp;gt;u.a.e = capacity &amp;gt; 0 ? (lept_value*)malloc(capacity * sizeof(lept_value)) : NULL;
}&lt;/code&gt;&lt;p&gt;我们需要稍修改 &lt;code class=&quot;inline&quot;&gt;lept_parse_array()&lt;/code&gt;，调用 &lt;code class=&quot;inline&quot;&gt;lept_set_array()&lt;/code&gt; 去设置类型和分配空间。&lt;/p&gt;&lt;p&gt;另外，类似于 &lt;code class=&quot;inline&quot;&gt;lept_get_array_size()&lt;/code&gt;，也加入获取当前容量的函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;size_t lept_get_array_capacity(const lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    return v-&amp;gt;u.a.capacity;
}&lt;/code&gt;&lt;p&gt;如果当前的容量不足，我们需要扩大容量，标准库的 &lt;code class=&quot;inline&quot;&gt;realloc()&lt;/code&gt; 可以分配新的内存并把旧的数据拷背过去：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_reserve_array(lept_value* v, size_t capacity) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    if (v-&amp;gt;u.a.capacity &amp;lt; capacity) {
        v-&amp;gt;u.a.capacity = capacity;
        v-&amp;gt;u.a.e = (lept_value*)realloc(v-&amp;gt;u.a.e, capacity * sizeof(lept_value));
    }
}&lt;/code&gt;&lt;p&gt;当数组不需要再修改，可以使用以下的函数，把容量缩小至刚好能放置现有元素：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_shrink_array(lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    if (v-&amp;gt;u.a.capacity &amp;gt; v-&amp;gt;u.a.size) {
        v-&amp;gt;u.a.capacity = v-&amp;gt;u.a.size;
        v-&amp;gt;u.a.e = (lept_value*)realloc(v-&amp;gt;u.a.e, v-&amp;gt;u.a.capacity * sizeof(lept_value));
    }
}&lt;/code&gt;&lt;p&gt;我们不逐一检视每个数组修改函数，仅介绍一下两个例子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;lept_value* lept_pushback_array_element(lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY);
    if (v-&amp;gt;u.a.size == v-&amp;gt;u.a.capacity)
        lept_reserve_array(v, v-&amp;gt;u.a.capacity == 0 ? 1 : v-&amp;gt;u.a.capacity * 2);
    lept_init(&amp;amp;v-&amp;gt;u.a.e[v-&amp;gt;u.a.size]);
    return &amp;amp;v-&amp;gt;u.a.e[v-&amp;gt;u.a.size++];
}

void lept_popback_array_element(lept_value* v) {
    assert(v != NULL &amp;amp;&amp;amp; v-&amp;gt;type == LEPT_ARRAY &amp;amp;&amp;amp; v-&amp;gt;u.a.size &amp;gt; 0);
    lept_free(&amp;amp;v-&amp;gt;u.a.e[--v-&amp;gt;u.a.size]);
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;lept_pushback_array_element()&lt;/code&gt; 在数组末端压入一个元素，返回新的元素指针。如果现有的容量不足，就需要调用 &lt;code class=&quot;inline&quot;&gt;lept_reserve_array()&lt;/code&gt; 扩容。我们现在用了一个最简单的扩容公式：若容量为 0，则分配 1 个元素；其他情况倍增容量。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;lept_popback_array_element()&lt;/code&gt; 则做相反的工作，记得删去的元素需要调用 &lt;code class=&quot;inline&quot;&gt;lept_free()&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;下面这 3 个函数留给读者练习：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;lept_insert_array_element()&lt;/code&gt; 在 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 位置插入一个元素；&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;lept_erase_array_element()&lt;/code&gt; 删去在 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 位置开始共 &lt;code class=&quot;inline&quot;&gt;count&lt;/code&gt; 个元素（不改容量）；&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;lept_clear_array()&lt;/code&gt; 清除所有元素（不改容量）。&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;c&quot;&gt;lept_value* lept_insert_array_element(lept_value* v, size_t index);
void lept_erase_array_element(lept_value* v, size_t index, size_t count);
void lept_clear_array(lept_value* v);&lt;/code&gt;&lt;hr&gt;&lt;h2&gt;5. 动态对象&lt;/h2&gt;&lt;p&gt;动态对象也是采用上述相同的结构，所以直接留给读者修改结构体，并实现以下函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void lept_set_object(lept_value* v, size_t capacity);
size_t lept_get_object_capacity(const lept_value* v);
void lept_reserve_object(lept_value* v, size_t capacity);
void lept_shrink_object(lept_value* v);
void lept_clear_object(lept_value* v);
lept_value* lept_set_object_value(lept_value* v, const char* key, size_t klen);
void lept_remove_object_value(lept_value* v, size_t index);&lt;/code&gt;&lt;p&gt;注意 &lt;code class=&quot;inline&quot;&gt;lept_set_object_value()&lt;/code&gt; 会先搜寻是否存在现有的键，若存在则直接返回该值的指针，不存在时才新增。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;6. 总结与练习&lt;/h2&gt;&lt;p&gt;本单元主要加入了数组和对象的访问、修改方法。当中的赋值又引申了三种赋值的方式（复制、移动、交换）。这些问题是各种编程语言中都需要考虑的事情，为了减少深度复制的成本，有些程序库或运行时还会采用&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD&quot;&gt;写入时复制&lt;/a&gt;（copy-on-write, COW）。而浅复制（shallow copy）则需要 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0&quot;&gt;引用计数&lt;/a&gt;（reference count）或 &lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)&quot;&gt;垃圾回收&lt;/a&gt;（garbage collection, GC）等技术。&lt;/p&gt;&lt;p&gt;另外，我们实现了以动态数组的数据结构，能较高效地对数组和对象进行增删操作。至此，我们已经完成本教程的所有核心功能。做完下面的练习后，我们还会作简单讲解，然后将迎来本教程的最后一个单元。&lt;/p&gt;&lt;p&gt;本单元练习内容：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;完成 &lt;code class=&quot;inline&quot;&gt;lept_is_equal()&lt;/code&gt; 里的对象比较部分。不需要考虑对象内有重复键的情况。&lt;/li&gt;&lt;li&gt;打开 &lt;code class=&quot;inline&quot;&gt;test_array_access()&lt;/code&gt; 里的 &lt;code class=&quot;inline&quot;&gt;#if 0&lt;/code&gt;，实现 &lt;code class=&quot;inline&quot;&gt;lept_insert_array_element()&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;lept_erase_array_element()&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;lept_clear_array()&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;打开 &lt;code class=&quot;inline&quot;&gt;test_object_access()&lt;/code&gt; 里的 &lt;code class=&quot;inline&quot;&gt;#if 0&lt;/code&gt;，参考动态数组，实现第 5 部分列出的所有函数。&lt;/li&gt;&lt;li&gt;完成 &lt;code class=&quot;inline&quot;&gt;lept_copy()&lt;/code&gt; 里的数组和对象的复制部分。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 &lt;a href=&quot;https://github.com/miloyip/json-tutorial/issues&quot;&gt;issue&lt;/a&gt; 中提出，让所有人一起讨论。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-06-04-37618664</guid>
<pubDate>Mon, 04 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何用 C 语言画小猪佩奇</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-05-19-37031514.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37031514&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ff5a359eb78ce2a1da7ee035376ed610_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;我们曾在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30745861&quot;&gt;用 C 语言画光（一）：基础&lt;/a&gt;》中，使用到带符号距离场（signed distance field, SDF）表示圆形：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\phi_\text{circle}(\mathbf{x})=\| \mathbf{x} - \mathbf{c}\| - r\tag{1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;沿用这个方法表示形状，但这次我们想利用 ASCII 字符&lt;code class=&quot;inline&quot;&gt;|/=\&lt;/code&gt;画出形状的外框，并填充内部，类似这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   =====
 //.....\\
||.......||
 \\.....//
   =====&lt;/code&gt;&lt;p&gt;SDF 的梯度（gradient）代表 SDF 变化最大的方向，可用这个方向去决定用哪一个字符。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-86ad876b201bb9bf1309cc1c3a0822a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1340&quot; data-rawheight=&quot;830&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-86ad876b201bb9bf1309cc1c3a0822a0&quot; data-watermark-src=&quot;v2-ee44f61ebefd2f643693ff57d1bd8eee&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们通过&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%88%86&quot;&gt;差分&lt;/a&gt;求 SDF 的梯度近似值，然后用 &lt;code class=&quot;inline&quot;&gt;atan2()&lt;/code&gt; 求出梯度的角度：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} \theta &amp;amp;= \mathrm{atan2} \left(\frac{\partial \phi(\mathbf{x})}{\partial y}, \frac{\partial \phi(\mathbf{x})}{\partial x} \right) \tag{2}\\ &amp;amp;\approx \mathrm{atan2} \left(\phi(x,y+\Delta) - \phi(x,y-\Delta), \phi(x+\Delta,y) - \phi(x-\Delta,y)\right) \tag{3}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;用 C 语言简单实现，在 &lt;equation&gt;[-1, 1]\times[-1,1]&lt;/equation&gt; 画布中画一个半径 0.8 并带有 0.1 寛度外框的圆形：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &amp;lt;math.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#define T double

T f(T x, T y) {
    return sqrt(x * x + y * y) - 0.8f;
}

char outline(T x, T y) {
    T delta = 0.001;
    if (fabs(f(x, y)) &amp;lt; 0.05) {
        T dx = f(x + delta, y) - f(x - delta, y);
        T dy = f(x, y + delta) - f(x, y - delta);
        return &quot;|/=\\|/=\\|&quot;[(int)((atan2(dy, dx) / 6.2831853072 + 0.5) * 8 + 0.5)];
    }
    else if (f(x, y) &amp;lt; 0)
        return &#39;.&#39;;
    else
        return &#39; &#39;;
}

int main() {
    for (T y = -1; y &amp;lt; 1; y += 0.05, putchar(&#39;\n&#39;))
        for (T x = -1; x &amp;lt; 1; x += 0.025)
            putchar(outline(x, y));
}&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2389220aa8dc0f9658208817d02d8bc0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;856&quot; data-rawheight=&quot;798&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2389220aa8dc0f9658208817d02d8bc0&quot; data-watermark-src=&quot;v2-3d7249bd69aad46ffd4e1fc3bdeff6b0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;然后，我们就可以画多个圆形，把它们适当地旋转和缩放，用&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30748318&quot;&gt;构造实体几何&lt;/a&gt;比它们组合起来，那么用19行代码就可以画出小猪佩奇了：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;// ASCII Peppa Pig by Milo Yip
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#define T double
T c(T x,T y,T r){return sqrt(x*x+y*y)-r;}
T u(T x,T y,T t){return x*cos(t)+y*sin(t);}
T v(T x,T y,T t){return y*cos(t)-x*sin(t);}
T fa(T x,T y){return fmin(c(x,y,0.5),c(x*0.47+0.15,y+0.25,0.3));}
T no(T x,T y){return c(x*1.2+0.97,y+0.25,0.2);}
T nh(T x,T y){return fmin(c(x+0.9,y+0.25,0.03),c(x+0.75,y+0.25,0.03));}
T ea(T x,T y){return fmin(c(x*1.7+0.3,y+0.7,0.15),c(u(x,y,0.25)*1.7,v(x,y,0.25)+0.65,0.15));}
T ey(T x,T y){return fmin(c(x+0.4,y+0.35,0.1),c(x+0.15,y+0.35,0.1));}
T pu(T x,T y){return fmin(c(x+0.38,y+0.33,0.03),c(x+0.13,y+0.33,0.03));}
T fr(T x,T y){return c(x*1.1-0.3,y+0.1,0.15);}
T mo(T x,T y){return fmax(c(x+0.15,y-0.05,0.2),-c(x+0.15,y,0.25));}
T o(T x,T y,T(*f)(T,T),T i){T r=f(x,y);return fabs(r)&amp;lt;0.02?(atan2(f(x,y+1e-3)-r,f(x+1e-3,y)-r)+0.3)*1.273+6.5:r&amp;lt;0?i:0;}
T s(T x,T y,T(*f)(T,T),T i){return f(x,y)&amp;lt;0?i:0;}
T f(T x,T y){return o(x,y,no,1)?fmax(o(x,y,no,1),s(x,y,nh,12)):fmax(o(x,y,fa,1),fmax(o(x,y,ey,11),fmax(o(x,y,ea,1),fmax(o(x,y,mo,1),fmax(s(x,y,fr,13),s(x,y,pu,12))))));}
int main(int a,char**b){for(T y=-1,s=a&amp;gt;1?strtod(b[1],0):1;y&amp;lt;0.6;y+=0.05/s,putchar(&#39;\n&#39;))for(T x=-1;x&amp;lt;0.6;x+=0.025/s)putchar(&quot; .|/=\\|/=\\| @!&quot;[(int)f(u(x,y,0.3),v(x,y,0.3))]);}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-31638f949e3a92e6f0bbf345bfb94f6e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;660&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-31638f949e3a92e6f0bbf345bfb94f6e&quot; data-watermark-src=&quot;v2-64070d0e4c7b0c8040f6527a47ff0bfb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;2倍：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-64060e12365c0667d3c69d8cf87ca2aa_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1334&quot; data-rawheight=&quot;1306&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-64060e12365c0667d3c69d8cf87ca2aa&quot; data-watermark-src=&quot;v2-27d5d9e7d76ea331f803f0ef42fc7fa6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;4 倍：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-76b9b97233b9a35332a8a44c7828474d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1070&quot; data-rawheight=&quot;1044&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-76b9b97233b9a35332a8a44c7828474d&quot; data-watermark-src=&quot;v2-b784a78e92973aa49f5a45c5eadf883b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;8 倍：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c7087e6e76862c7379dee7a68856a2a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2184&quot; data-rawheight=&quot;1800&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c7087e6e76862c7379dee7a68856a2a0&quot; data-watermark-src=&quot;v2-8d18514a07ad93aad74ba25fa52ae9ee&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;blockquote&gt;今天也是精致的猪猪女孩～&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-05-19-37031514</guid>
<pubDate>Sat, 19 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Milo的知乎2017</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-01-01-32521954.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32521954&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-81c07ee78170e087a12805873c62e3e2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;2017年为了改善自己的身体状况，在知乎&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25493253&quot;&gt;休息&lt;/a&gt;了一段时间，所以今年投入创作的时间减少了。另外，本年有幸获得知乎盐 Club 荣誉会员（获 3568 票）。&lt;/p&gt;&lt;p&gt;按2018元旦的累积数字和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24664465&quot;&gt;去年&lt;/a&gt;对比，得到以下数据，括号内的为累积总数（自 2011 年）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;回答了 277 个问题（1474）&lt;/li&gt;&lt;li&gt;发布了 19 篇文章（51）&lt;/li&gt;&lt;li&gt;发布了 41 个想法（41）&lt;/li&gt;&lt;li&gt;获 68919 个赞同（197509）&lt;/li&gt;&lt;li&gt;获 6233 个感谢（28570）&lt;/li&gt;&lt;li&gt;获 43949 次收藏（131802）&lt;/li&gt;&lt;li&gt;获 43979 人关注（125095）&lt;/li&gt;&lt;li&gt;获 436.47 元（2309.33）&lt;/li&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f763464f917228f0387bf4ea4c526d21_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;742&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-558b4db991dc6aab99df5536b1d881b6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;742&quot;&gt;&lt;p&gt;感谢各位支持，2018 年继续努力（填坑）。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-01-01-32521954</guid>
<pubDate>Mon, 01 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>《写生机器人》制作经验分享（上）</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-12-25-32084037.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32084037&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic7.zhimg.com/v2-2227224aab303f50deea51da1e4ff436_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;我在《&lt;a href=&quot;https://www.zhihu.com/question/263477736/answer/269707887&quot;&gt;对编程感兴趣的程序员是否都对电路、单片机也怀有浓厚的兴趣？ &lt;/a&gt;》展示了前两年制作的一个写生机器人，不少网友表示感兴趣，故撰本文回顾制作历程及感悟。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 起源&lt;/h2&gt;&lt;p&gt;在 2014 年，当时我已经开发&lt;b&gt;软件&lt;/b&gt;算有二十多年（第一个主导的商业游戏项目《王子传奇》在1995年台湾发行）。然而，除了懂得一些简单的、中学物理课学到的电子知识，从来没接触过&lt;b&gt;硬件&lt;/b&gt;开发。和读计算机相关专业的朋友不一样，我本科读的是认知科学（cognitive science，在香港大学属社会科学院），完全没有硬件方面的课。&lt;/p&gt;&lt;p&gt;因此，那个时候想学习一下硬件开发，扩阔视野。&lt;/p&gt;&lt;p&gt;最初，我在网上买了一套一百多块的 Arduino 入门套装，按着 [1] 的例子学习，如控制 LED／7段 LED、处理按钮／电位器输入、控制电机／舵机等。有赖 Arduino 团队的努力，开发环境和 API 都十分简单易用，熟悉 C/C++的程序员可轻松入门。&lt;/p&gt;&lt;p&gt;但经验告诉我，&lt;/p&gt;&lt;blockquote&gt;要提升一门技术的水平，最好是从做一个项目中学习。&lt;/blockquote&gt;&lt;p&gt;当时，我工作的部门（腾讯／IEG 互动娱乐事业群／研发部）正宣传举办第一届的《Intel杯创新大赛》，让IEG 同事创作作品，范围包括智能硬件、VR／AR 等，每年举办两次。我便鼓起勇气参加了。那么，做什么好呢？&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 构思&lt;/h2&gt;&lt;p&gt;我先考虑自己懂什么，以及想做些什么。&lt;/p&gt;&lt;p&gt;最后的构思源于以下的经历：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;本科专业是&lt;b&gt;认知科学&lt;/b&gt;，研究信息如何在大脑中形成及转录过程的跨领域学科；&lt;/li&gt;&lt;li&gt;对计算机图形学比较了解，有幸成为知乎计算机图形学的优秀回答者；&lt;/li&gt;&lt;li&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23725230&quot;&gt;程序员可以学画画吗？ &lt;/a&gt;》提及我在业余学过基本&lt;b&gt;素描&lt;/b&gt;和&lt;b&gt;油画&lt;/b&gt;；&lt;/li&gt;&lt;li&gt;我想做一些&lt;b&gt;会动&lt;/b&gt;的东西，因为以前做的软件，即使有动画及互动内容，都是困于屏幕之中。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我曾在 YouTube 看过一个绘画机器人的艺术项目 [2]，我觉得和我上述的经历吻合，引发了一些思考。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-081992f24b7efbe42c1fffb82dc8339c_r.jpg&quot; data-caption=&quot;Portrait drawing by Paul the robot [2]&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot;&gt;&lt;p&gt;我以前学画的时候，也会想一些问题，也和老师讨论过。&lt;/p&gt;&lt;p&gt;绘画是越写实越好么？不是。要写实的话，摄影更写实。绘画和摄影有相似的地方，但不能互相取代。&lt;/p&gt;&lt;p&gt;绘画（以下主要指写生）和摄影的主要区别是什么？画家在构图后，还可以选择要表达的重点。另外，写生是一个较长期的渐进过程，从整体粗略至局部细致，过程中不断观察比对画作和对象。这和摄影通常一次曝光（通常是几十分之一秒），然后显影很不一样。&lt;/p&gt;&lt;p&gt;也因此，同一对象、同一灯光、同一构图下，即使不同的摄影师也几乎得到相同的作品。而画家则会因当时对对象的不同观察和想法、不同的手法表现，得出独一无二的作品。这也许存在争议，纯粹是个人的一个想法。&lt;/p&gt;&lt;p&gt;我当时想到，如果要做一个机器人模仿人类进行写生，要怎么做才可以重现出这种区别，创作出独一无二的作品，而不只是用相机拍下然后打印？我想到 3 点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;模仿人的&lt;b&gt;多关节肢体&lt;/b&gt;，使用真实绘画素材（如铅笔、走珠笔、绘图笔、秀丽笔、油漆笔），而非用打印机。虽然用 XY plotter 也可用上绘画素材，但完全不像人的手。&lt;/li&gt;&lt;li&gt;模仿人的&lt;b&gt;视觉系统&lt;/b&gt;，可以持续观察写生对象及当前的画作，进行对比。&lt;/li&gt;&lt;li&gt;模仿人的&lt;b&gt;渐进写生过程&lt;/b&gt;，而非完全的机械式输入处理输出。而且，对象可能会随时间改变（如人像、风景），作品可包含这些时间的变化。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我没怎么想商业价值，觉得这个机器人更像是一个互动的装置艺术。我希望每张作品都是独一无二的艺术品。&lt;/p&gt;&lt;p&gt;记得以前读认知科学时，要评估一些认知能力模型是否好，其中一个方法是用计算机去模拟出来，看看能否模仿生物的那些能力。所以从研究的角度来说，这个项目也许涉及艺术风格的模仿及研究。&lt;/p&gt;&lt;p&gt;不过，我并没有把上述的所有构思都实现。基于时间和能力所限，只是做一个非常简化的版本。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 设计&lt;/h2&gt;&lt;p&gt;如果只做算法部分，或可购买现成的机器臂，或是组装现成的套件。但我没学过机械设计，希望借这个项目尝试一下。&lt;/p&gt;&lt;p&gt;当时常见到的玩具机器人和机器臂，一般都使用舵机（摇控模型的直流伺服电机／RC servo）作为致动器（actuator），而 [1] 的机器臂也是用这种构造。这种机器臂构造简单，控制也容易（用 PWM 信号控制目标角度），但缺点也是很明显的，角度不够精确，也难以控制转动的速度，画出来的作品抖动明显。&lt;/p&gt;&lt;p&gt;我从 [3] 学习到一些致动器原理及传动系统，似乎步进电机（stepper motor）是更好的选择，可以用一个脉冲控制电机旋转一个很小的角度。那么我可以用编程的方法，精准地控制旋转速度。&lt;/p&gt;&lt;p&gt;我没有读机器臂相关的书，只是从需求去设计：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;画在 A3 大小的纸张。一般的玩具机器臂没有这么大的移动范围。&lt;/li&gt;&lt;li&gt;容易制作。因为没有技术、设备。&lt;/li&gt;&lt;li&gt;成本比较低。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我想，最简单需要一个水平二维移动的手，再加上一个垂直移动的持笔装置。二维移动需要至少两个自由度（degree of freedom, DOF），加上垂直移动共 3 个 DOF。那么，需要模拟上臂、下臂和手三部分。&lt;/p&gt;&lt;p&gt;构造上，最简单的是把电机放到关节上，但步进电机一般比舵机重，而机器臂也要足够长，会不会太重？太重有两个问题：上臂的关节要承受因重力而生的大力矩，底座要很重才能平衡。&lt;/p&gt;&lt;p&gt;因此，我想到的方案是把电机都放在底座，通过带子传动。后来知道这些构件称为同步轮（synchornized wheel）和同步带（synchronized belt）。我想到这个设计还有 4 个好处：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;手臂不用放置电机，使手臂轻很多，旋转两个关节所需的力矩变小。&lt;/li&gt;&lt;li&gt;上臂的关节不用直接使用步进电机的输出轴，而可以用上更粗、更坚固的轴，令系统更强健。&lt;/li&gt;&lt;li&gt;系统中最重的部件（步进电机）位于底座，而且可放在手臂的另一端，令重心接近第一关节，更稳定。&lt;/li&gt;&lt;li&gt;采用不同大小的同步轮，可作进一步减速，提升精确性。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;要做设计，首先要知道有什么零件可以使用。我在网上找寻合适的零件，包括电机、传动和结构上的。我发现最平宜的结构是用板材配合立柱，用螺丝紧固。&lt;/p&gt;&lt;p&gt;然后绘画各部分的草图：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ae3cb7ce87c60d0fb7bff6cd891ef455_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1481&quot;&gt;&lt;p&gt;我最不了解的是各种轴承（bearing），没想到会这样复杂，不确定是否需要这么多轴承。设计时要匹配各种轴承的尺寸，我通过不断搜寻轴承目录，试各种尺寸的组合，才得出设计方案。同步轮也有同样问题，设计都是要配合现成能买到的规格。&lt;/p&gt;&lt;p&gt;另外，垂直移动的持笔装置也是设计的难点。我看到一些持笔装置是用舵机的，感觉不能很精确控制高度，而且持笔不够稳固。如果要用秀丽笔控制高度来画不同粗细，最好还是精确一点。最后我的方案是用直线轴承，轴承中放置铝管，铝管中固定笔枝，再配合小型的直线步进电机。直线步进电机常见于光驱，控制激光的轨道位置，可以非常精确。因为笔支不重，细小的直线步进电机已经足够，而且它的控制也和其他步进电机一样简单。&lt;/p&gt;&lt;p&gt;我没学过机械制图，只有 3dsMax、SketchUp的使用经验。我找了一下流行的相关设计软件，最后下载了 SolidWorks 的试用版本来学习。 SolidWorks 确实是十分容易使用，我花了两周左右（如没记错）的工余时间便学习并画出以下的设计图和渲染圖：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6c7a05acb0fb621319f1d8a36835b4ba_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1191&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-27040ae6596d492ea5a1b1a8cc3ff41f_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;960&quot;&gt;&lt;p&gt;不过，我还是不太了解 SolidWorks 的约束系统，第一次画图应该有很多问题。而设计时，很多数值（例如光轴要多粗的、板材要多厚的、电机要多大力矩的）我也没有深究，应该都是高于实际的要求。我并没有做力学方面的模拟，做了的话应该可以再降低成本。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;4. 机器臂制作&lt;/h2&gt;&lt;p&gt;我在网上找公司按图切割铝合金板，并购买所有的部件。制作中还需要一些工序，所以后来也购买了电钻床和夹钳等工具。&lt;/p&gt;&lt;p&gt;如同模型一样，组装这个机器臂是很好玩的环节。在设计时，我并没有很在意组装次序，所以组装时发现确实是有点难度，试过错放漏放部件，要拆掉重来。&lt;/p&gt;&lt;p&gt;持笔的铝管需要固定笔枝，我采用的是在管铝上攻丝，这样也方便更换笔枝。第一次手工攻丝还是觉得有点难度，记得做了两枝铝管才成功。&lt;/p&gt;&lt;p&gt;主要部分完成组装后，就接上电机控制器和 Arduino 去测试。非常成功地旋转了！但是⋯⋯同步带不够紧！&lt;/p&gt;&lt;p&gt;当初设计时，我参考了一个网站，按同步带类型／长度、同步轮半径去计算轴距的长度。然而，没想到最后还是有点松。看了一些其他用同步带的设计，原来都要加一个可调的滑轮去控制松紧！没辨法之下，我要拆开部件钻孔，买立柱和轴承作为滑轮。&lt;/p&gt;&lt;p&gt;而且！我设计时没考虑到怎样检测手臂复位！我买的是没有角度回馈的步进电机，在开始时需要把手臂转到一个初始角度做复位。我唯有临时加上了两个微动开关去检测手臂是否到达初始角度。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-043ccd20bdd3e9b64544e6b00974de21_r.jpg&quot; data-caption=&quot;红圈中的是后来加入的滑轮，黄圈中的是后来加入的微动开关&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;919&quot;&gt;&lt;p&gt;这两个失误说明，经验还是很重要的。不过，第一次做这方面的设计，能正常地动起来，我已经很满足了。而且整个手臂很坚固，旋转也很顺滑细致，单凭想像力去做的设计还算不错吧。&lt;/p&gt;&lt;p&gt;经过简单测试（用固定频率旋转两个轴），设置步进电机驱动器使用16 微步进（micro stepping）模式没什么问题，能实现两个关节 旋转，最高 末端精度（距离底座半径越大精度越低）。这样已经足够了，编程随便画些东西！&lt;/p&gt;&lt;p&gt;很久以后我发图出来，才有网友说这不是&lt;a href=&quot;https://en.wikipedia.org/wiki/SCARA&quot;&gt;SCARA&lt;/a&gt;嘛。啊？我真不知道。如果有导师指导应该会好很多，不过胡猜瞎试也是另一种乐趣。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cbd5c076959cc92f741cd552df2e364e_r.jpg&quot; data-caption=&quot;三菱的SCARA机器臂&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1188&quot;&gt;&lt;hr&gt;&lt;h2&gt;5. 绘画直线算法&lt;/h2&gt;&lt;p&gt;除了画点以外，最简单的图形应该是直线。我比较熟悉在光栅图像里画线的方法，最近也写过一篇《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30553006&quot;&gt;用 C 语言画直线&lt;/a&gt;》。然而，Bresenham 画线算法源于控制 XY plotter，不能用在旋转关节。&lt;/p&gt;&lt;p&gt;设计机械臂硬件的时候，我也没有仔细去想怎样编程，心想：「应该没什么问题吧，到时再想。」&lt;/p&gt;&lt;p&gt;我不但没学过机械设计，也没学过控制。在图形学中学过逆向运动学（inverse kinematics），可以把目标的世界坐标转换成关节的角度。但似乎不行，我不知道世界坐标中应该步进多长的距离，两个旋转角度又怎样用多个单步、什么频率？&lt;/p&gt;&lt;p&gt;这次我也没有直接去找相关专著找答案。我觉得这应该不会是十分困难的问题，我尝试自行想个算法解决。&lt;/p&gt;&lt;p&gt;分析一下，先不考虑频率，我们每个离散步只能有 8 种输出：每个轴顺时针步进／逆时针步进／待机，但不会两个轴同时待机， &lt;equation&gt;3^2-1= 8&lt;/equation&gt;  。那么，我们可以分别对 8 种输出，计算出旋转后的末端世界坐标。然后，找出向直线方向移动（不应回头）而又最接近直线的一种输出！&lt;/p&gt;&lt;p&gt;我实验用这个算法，画各种角度的直线、正方形，效果也不错！ ⋯⋯但是有点抖。&lt;/p&gt;&lt;p&gt;这是因为，每次移动的距离是不一样的，但我都只是简单地延迟相同的间隔，所以直线上的移动速度并不平均。这并不难解决，只要按该步的欧氏距离及目标速度，就能计算出该步的延迟时间。实验也成功显示这样会减少抖动。&lt;/p&gt;&lt;p&gt;还有一个问题，就是开始和结束的时候的抖动。这是因为我们开始时从静止突然加速到目标速度，结束时则相反。解决方法是引入线性加速度，让笔从慢至快、快至慢地移动。以下实际上是第二届比赛前录制的视频，但能演示画直线的动作：&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic4.zhimg.com/80/v2-d6990bd74059cc4e09d585c492cb2377_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/928749126110298112&quot; data-name=&quot;&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;928749126110298112&quot;&gt;&lt;/video&gt;&lt;hr&gt;&lt;h2&gt;6. 第一届Intel杯创新大赛&lt;/h2&gt;&lt;p&gt;因为当时已接近第一届的比赛日子，我决定这一届只提交机器臂的部分。我继续写了个简单的 SVG 解析器，把 Bezier 曲线分割成线段绘画。下面是画一幅 SVG 的过程片段：&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic4.zhimg.com/80/v2-8c617f47adaa140b990c8a0388f24157_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/928757235193114624&quot; data-name=&quot;&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;928757235193114624&quot;&gt;&lt;/video&gt;&lt;p&gt;最后做 presentation、演讲、即场演示，赢得第一届Intel杯创新大赛一等奖！&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-db8105ef03e5673b895b2a5c504efc67_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1062&quot;&gt;&lt;p&gt;从最初构想至第一届创新大赛比赛日大约历时一年，但实际上有很多个月都没有搞，估计大约花了三个月左右的工余时间。由于工具和硬件都在公司，而我晚上又坐班车回家，所以除了设计阶段在家里进行，其他都是用午饭时间搞的。&lt;/p&gt;&lt;p&gt;此阶段的制作成本（不包括工具）一览：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{array}{lr} 部件 &amp;amp; \text{RMB}\\ \hline \text{7075铝合金3mm板材及切割} &amp;amp; 217\\ 铝合金支柱及紧固件 &amp;amp; 100\\ 42步进电机\times 2、光驱步进电机及驱动 &amp;amp; 170\\ 同步轮及同步带 &amp;amp; 160\\ 铬镀轴光轴及轴承 &amp;amp; 30\\ \text{Arduino Mega} &amp;amp; 34\\ \hline 合计 &amp;amp; 711\\ \end{array}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;下篇讲述继续参加第二届创新大赛，加入 Intel RealSense 和实现素描算法，以及对这个项目的感悟。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] McRoberts, Michael, Brad Levy, and Cliff Wootton. &lt;i&gt;Beginning Arduino&lt;/i&gt;. New York.: Apress, 2010.《Arduino从基础到实践》，杨继志、郭敬译，电子工业出版社，2013。（已有中文版第二版）&lt;/p&gt;&lt;p&gt;[2] Tresset, Patrick, and Frederic Fol Leymarie. &quot;Portrait drawing by Paul the robot.&quot; Computers &amp;amp; Graphics 37.5 (2013): 348-363.&lt;/p&gt;&lt;p&gt;[3] Roberts, Dustyn. &lt;i&gt;Making Things Move DIY Mechanisms for Inventors, Hobbyists, and Artists&lt;/i&gt;. McGraw Hill Professional, 2010. 《Maker机械电子创意实现与项目制作》，郭洪红译， 科学出版社，2013。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-12-25-32084037</guid>
<pubDate>Mon, 25 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用C语言画光（七）：比尔-朗伯定律</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-12-11-31901449.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31901449&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fd045c136f75263c865390c69518016a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31127076&quot;&gt;（五）折射&lt;/a&gt; 和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31534769&quot;&gt;（六）菲涅耳方程&lt;/a&gt; 里，我们谈及光怎样穿过表面，透射至物体内部。我们假设了光在物体中传播时不会衰减。然而，除了真空，光线通过不同物质都会被散射和吸收，例如我们看到天空是蓝色的，也是因为不同波长的光被空气粒子散射程度不一样所致；如果阳光没有被空气粒子散射，天空应该是透明的。&lt;/p&gt;&lt;p&gt;本文描述一种简单方法去模拟光被材质吸收，也会首次尝试加入色彩。&lt;/p&gt;&lt;h2&gt;1. 比尔-朗伯定律&lt;/h2&gt;&lt;p&gt;比尔-朗伯定律（Beer-Lambert law）描述电磁波（如可见光）通过物体时，物体吸收部分电磁波，而吸收率与物体的厚度（光程距离）、物质的吸光系数及其浓度相关。[1] P.393 给出的比尔-朗伯定律形式为：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T = e^{-\alpha&#39;cd}\tag{1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;当中， &lt;equation&gt;T\in[0,1]&lt;/equation&gt; 为透射率， &lt;equation&gt;\alpha&#39; \in [0, \infty)&lt;/equation&gt; 为物质的吸光系数， &lt;equation&gt;c \in [0, \infty)&lt;/equation&gt; 为浓度， &lt;equation&gt;d \in [0, \infty)&lt;/equation&gt; 为光程距离。&lt;/p&gt;&lt;p&gt;若物体是均质的，那么 &lt;equation&gt;\alpha&#39;&lt;/equation&gt; 和 &lt;equation&gt;c&lt;/equation&gt; 为常量，可以看到(1)是服从&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E8%A1%B0%E5%87%8F&quot;&gt;指数衰减&lt;/a&gt;的。例如，若光通过距离 &lt;equation&gt;\Delta d&lt;/equation&gt; 会衰减成原来的 50%，那么通过 &lt;equation&gt;2\Delta d&lt;/equation&gt; 的话就会衰减成原来的 25%。&lt;/p&gt;&lt;p&gt;在这里应用时，由于 &lt;equation&gt;\alpha&#39;&lt;/equation&gt; 和 &lt;equation&gt;c&lt;/equation&gt; 为物理上的单位，而它们又是常数，我们可用单个参数 &lt;equation&gt;a = \alpha&#39;c&lt;/equation&gt; 去表示材质对吸收的光收特性：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T = e^{-ad}\tag{2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;下图展示 &lt;equation&gt;a&lt;/equation&gt; 分别为 1, 2, 3, 4, 5 时，距离 &lt;equation&gt;d&lt;/equation&gt; 和透射率 &lt;equation&gt;T&lt;/equation&gt; 的关系：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-41469ee5da7f9051049920ff291d5010_r.jpg&quot; data-caption=&quot;图 1：指数衰减&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;326&quot;&gt;&lt;h2&gt;2. 实现&lt;/h2&gt;&lt;p&gt;实现只需三步。第一步，简单把 (2) 写成一行 C 函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float beerLambert(float a, float d) {
    return expf(-a * d);
}&lt;/code&gt;&lt;p&gt;第二步，在场景定义中加入吸收率：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct { float sd, emissive, reflectivity, eta, absorption; } Result;&lt;/code&gt;&lt;p&gt;第三步，追踪到表面时，依追踪距离计算吸收率，乘以从那个方向得到的光强总量：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float trace(float ox, float oy, float dx, float dy, int depth) {
    // ...
    for (int i = 0; i &amp;lt; MAX_STEP &amp;amp;&amp;amp; t &amp;lt; MAX_DISTANCE; i++) {
        // ...
        if (r.sd * sign &amp;lt; EPSILON) {
            float sum = r.emissive;
            // 计算反射和折射
            return sum * beerLambert(r.absorption, t); // &amp;lt;－ 只改这一行
        }
        // ...
    }
    // ...
}&lt;/code&gt;&lt;p&gt;我们把一个长方形设置 &lt;equation&gt;a=4&lt;/equation&gt; ，和之前的结果比较：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result scene(float x, float y) {
    Result a = { circleSDF(x, y, -0.2f, -0.2f, 0.1f), 10.0f, 0.0f, 0.0f, 0.0f };
    Result b = {    boxSDF(x, y, 0.5f, 0.5f, 0.0f, 0.3, 0.2f), 0.0f, 0.2f, 1.5f, 4.0f };
    return unionOp(a, b);
}&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cd8ae4706fda58f5d1fdc419c73a84a5_r.jpg&quot; data-caption=&quot;图2：开启比尔-朗伯定律的前后比较&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;516&quot; data-rawheight=&quot;276&quot;&gt;&lt;p&gt;可以清楚看到，图2(b)中光线通过物体表面后，距离越远就变得越暗。&lt;/p&gt;&lt;p&gt;不过，单色的效果不太好看，如果物质对不同波长的吸收率不一样，效果就会更明显了。&lt;/p&gt;&lt;h2&gt;3. 色彩&lt;/h2&gt;&lt;p&gt;为了简单起见，之前我们一直只是用单色光，生成灰阶图像。我们使用 RGB 色彩模型，把色彩定义为三维矢量 &lt;equation&gt;\mathbb{R}^3&lt;/equation&gt; ，并需要三个运算：加法、乘法（哈达马积／&lt;a href=&quot;https://en.wikipedia.org/wiki/Hadamard_product_(matrices)&quot;&gt;Hadamard product&lt;/a&gt;）及缩放（乘以纯量），实现如下：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define BLACK { 0.0f, 0.0f, 0.0f }

typedef struct { float r, g, b; } Color;

Color colorAdd(Color a, Color b) {
    Color c = { a.r + b.r, a.g + b.g, a.b + b.b };
    return c;
}

Color colorMultiply(Color a, Color b) {
    Color c = { a.r * b.r, a.g * b.g, a.b * b.b };
    return c;
}

Color colorScale(Color a, float s) {
    Color c = { a.r * s, a.g * s, a.b * s };
    return c;
}&lt;/code&gt;&lt;p&gt;为了方便，上面还定义了一个 &lt;equation&gt;\texttt{BLACK}&lt;/equation&gt; 的宣代表黑色 &lt;equation&gt;\texttt{Color}&lt;/equation&gt; 的初始值。&lt;/p&gt;&lt;p&gt;然后，我们把想要支持色彩的场景定义参数（如自发光和吸收率）的类型，从 &lt;equation&gt;\texttt{float}&lt;/equation&gt; 改为 &lt;equation&gt;\texttt{Color}&lt;/equation&gt; ：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct {
    float sd, reflectivity, eta;
    Color emissive, absorption;
} Result;&lt;/code&gt;&lt;p&gt;实际上， &lt;equation&gt;\texttt{reflectivity}&lt;/equation&gt; 和 &lt;equation&gt;\texttt{eta}&lt;/equation&gt; 都可以支持色彩，不过暂时本文不作这支持。&lt;/p&gt;&lt;p&gt;然后， &lt;equation&gt;\texttt{beerLambert()}&lt;/equation&gt; 、 &lt;equation&gt;\texttt{trace()}&lt;/equation&gt; 和 &lt;equation&gt;\texttt{sample()}&lt;/equation&gt; 函数都改为返回 &lt;equation&gt;\texttt{Color}&lt;/equation&gt; 类型。我们甚至可以通过编译的错误信息，来找到需要修改的代码，以下展示了这些改动：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Color beerLambert(Color a, float d) {
    Color c = { expf(-a.r * d), expf(-a.g * d), expf(-a.b * d) };
    return c;
}

Color trace(float ox, float oy, float dx, float dy, int depth) {
    // ...
    for (int i = 0; i &amp;lt; MAX_STEP &amp;amp;&amp;amp; t &amp;lt; MAX_DISTANCE; i++) {
        // ...
        if (r.sd * sign &amp;lt; EPSILON) {
            Color sum = r.emissive;
            if (depth &amp;lt; MAX_DEPTH &amp;amp;&amp;amp; r.eta &amp;gt; 0.0f) {
                // ...
                if (r.eta &amp;gt; 0.0f) {
                    if (refract(/* ... */) {
                        // ...
                        sum = colorAdd(sum, colorScale(trace(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1), 1.0f - refl));
                    }
                    // ...
                }
                if (refl &amp;gt; 0.0f) {
                    // ...
                    sum = colorAdd(sum, colorScale(trace(x + nx * BIAS, y + ny * BIAS, rx, ry, depth + 1), refl));
                }
            }
            return colorMultiply(sum, beerLambert(r.absorption, t));
        }
        // ...
    }
    Color black = BLACK;
    return black;
}

Color sample(float x, float y) {
    Color sum = BLACK;
    for (int i = 0; i &amp;lt; N; i++) {
        float a = TWO_PI * (i + (float)rand() / RAND_MAX) / N;
        sum = colorAdd(sum, trace(x, y, cosf(a), sinf(a), 0));
    }
    return colorScale(sum, 1.0f / N);
}&lt;/code&gt;&lt;p&gt;最后，在输出每个像素时，分别顺序写入R、G 和 B 通道，就能生成彩色图像：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    unsigned char* p = img;
    for (int y = 0; y &amp;lt; H; y++)
        for (int x = 0; x &amp;lt; W; x++, p += 3) {
            Color c = sample((float)x / W, (float)y / H);
            p[0] = (int)(fminf(c.r * 255.0f, 255.0f));
            p[1] = (int)(fminf(c.g * 255.0f, 255.0f));
            p[2] = (int)(fminf(c.b * 255.0f, 255.0f));
        }
     // ...
}&lt;/code&gt;&lt;p&gt;我们加入一个新的正多边形 SDF（本文暂不阐述），并让它吸收更多的绿色和红色：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result scene(float x, float y) {
    Result a = { circleSDF(x, y, 0.5f, -0.2f, 0.1f), 0.0f, 0.0f, { 10.0f, 10.0f, 10.0f }, BLACK };
    Result b = {   ngonSDF(x, y, 0.5f, 0.5f, 0.25f, 5.0f), 0.0f, 1.5f, BLACK, { 4.0f, 4.0f, 1.0f} };
    return unionOp(a, b);
}&lt;/code&gt;&lt;p&gt;渲染结果：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c6884a16e001c3dfa4b5eaad2df97eb1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;h2&gt;4. 结语&lt;/h2&gt;&lt;p&gt;本文用了比尔-朗伯定律模拟了光线被物体吸收，可以模拟一些透明（有色）物体。而真实世界中，一些粒子除了吸收光，也会散射至其他方向，其模拟会复杂很多。&lt;/p&gt;&lt;p&gt;另外，本文也讲解如何把单色渲染改为彩色渲染，作为练习，读者也可把反射及折射率加入彩色的处理，不过折射率的改动会多一些，留给读者思考。&lt;/p&gt;&lt;p&gt;我们一连三篇模拟了三个物理定律（斯涅尔、菲涅耳、比尔-朗伯），下一篇我们换一个话题。&lt;/p&gt;&lt;p&gt;本文的源代码位于 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/beerlambert.c&quot;&gt;beerlambert.c&lt;/a&gt;、&lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/beerlambert_color.c&quot;&gt;beerlambert_color.c&lt;/a&gt; 及 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/heart.c&quot;&gt;heart.c&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] Akenine-Möller, Tomas, Eric Haines, and Naty Hoffman. &lt;i&gt;Real-time rendering,&lt;/i&gt; Third Edition. CRC Press, 2008.&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-12-11-31901449</guid>
<pubDate>Mon, 11 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 C 语言画光（六）：菲涅耳方程</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-12-07-31534769.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31534769&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2f5c7ff4302d60da320d4a5bfd734f97_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31127076&quot;&gt;上一篇&lt;/a&gt;我们实现了折射，也假设了反射和折射的比重是恒定的。但现实上，这个比重与材质和入射角相关。&lt;/p&gt;&lt;p&gt;题图是我 2006 年在九寨沟拍摄的相片。相片底部，视角较接近垂直，可以看到较清晰的水下景物，倒影较暗；而在远处，视角较与水面平行，则几乎只看见倒影，难以看到水下景物。&lt;/p&gt;&lt;p&gt;你现在也可以把一个马克杯装满水，放在屏幕前观察水面。如果眼睛接近水平面，就可以清楚地看到屏幕倒影；如果视点往上移，那么屏幕倒影变暗，更多看到杯里的颜色。&lt;/p&gt;&lt;p&gt;这个现象称为菲涅耳反射（Fresnel reflectance）。奥古斯丁·菲涅耳（Augustin Fresnel， 1788－1827）为法国物理学家，注意 Fresnel 为法语姓氏，s 是不发音的。&lt;/p&gt;&lt;h2&gt;1. 菲涅耳方程&lt;/h2&gt;&lt;p&gt;菲涅耳方程（Fresnel equation）描述了光线经过两个介质的界面时，反射和透射的光强比重。参考下图的符号：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5b458ba05cceb8eb94c257fb93f77de1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;710&quot; data-rawheight=&quot;709&quot;&gt;&lt;p&gt;当中 &lt;equation&gt;R \in [0, 1]&lt;/equation&gt; 为反射比，因能量守恒，透射比为 &lt;equation&gt;T=1-R&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于电介质（dielectric）而言，菲涅耳方程为：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} R_s &amp;amp;= \left(\frac{\eta_1\cos\theta_i-\eta_2\cos\theta_t}{\eta_1\cos\theta_i+\eta_2\cos\theta_t}\right)^2\\ R_p &amp;amp;=\left(\frac{\eta_1\cos\theta_t-\eta_2\cos\theta_i}{\eta_1\cos\theta_t+\eta_2\cos\theta_i}\right)^2 \end{align}\tag{1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;R_s&lt;/equation&gt; 和 &lt;equation&gt;R_p&lt;/equation&gt; 分别对应入射光的 s 偏振（senkrecht polarized）和 p 偏振（parallel polarized）所造成的反射比。图形学中通常考虑光是无偏振的（unpolarized），也就是两种偏振是等量的，所以可以取其平均值：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;R = \frac{R_s + R_p}{2}\tag{2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;那么，给定入射角、透射角的余弦，以及两个介质的折射率，就可简单实现：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float fresnel(float cosi, float cost, float etai, float etat) {
    float rs = (etat * cosi - etai * cost) / (etat * cosi + etai * cost);
    float rp = (etai * cosi - etat * cost) / (etai * cosi + etat * cost);
    return (rs * rs + rp * rp) * 0.5f;
}&lt;/code&gt;&lt;p&gt;透射角实际上是使用斯涅尔定律从入射角得出的，所以假设折射率是常数，菲涅耳反射比是入射角的函数。下图展示了光线从空气射向不同材质时的菲涅耳反射比（来自[1] P. 233，&lt;equation&gt;R_F&lt;/equation&gt;为菲涅耳反射比）：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-03de0b4495739ab29a32215d82590591_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;1186&quot;&gt;&lt;p&gt;在趋向 &lt;equation&gt;90^\circ&lt;/equation&gt; 入射角时，不论什么材质反射比都趋向 1。&lt;/p&gt;&lt;p&gt;另外，导体（conductor）和半导体（semiconductor）的菲涅耳方程会更复杂一些，而且不同对波长的影响较大（上图中红色和紫色曲线分别对应 RGB 三种波长），我们稍后再讨论。&lt;/p&gt;&lt;h2&gt;2. 修改实现&lt;/h2&gt;&lt;p&gt;这个函数用于取代原来恒定的 &lt;equation&gt;\texttt{reflectivity}&lt;/equation&gt; ，我们原来的追踪代码是这样的：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;if (depth &amp;lt; MAX_DEPTH &amp;amp;&amp;amp; (r.reflectivity &amp;gt; 0.0f || r.eta &amp;gt; 0.0f)) {
    /* ... */
    if (r.eta &amp;gt; 0.0f) {
        if (refract(dx, dy, nx, ny, sign &amp;lt; 0.0f ? r.eta : 1.0f / r.eta, &amp;amp;rx, &amp;amp;ry))
            sum += (1.0f - refl) * trace(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1);
        else
            refl = 1.0f; // Total internal reflection
    }
    /* ... */
}&lt;/code&gt;&lt;p&gt;当有折射发生时，我们利用点积计算入射角和透射角的余弦，然后用 &lt;equation&gt;\texttt{fresnel()}&lt;/equation&gt; 获取反射比。和调用 &lt;equation&gt;\texttt{refract()}&lt;/equation&gt; 时相似，我们要考虑光是从空气（&lt;equation&gt;\eta=1&lt;/equation&gt;）进入物体，还是相反：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;if (depth &amp;lt; MAX_DEPTH &amp;amp;&amp;amp; (r.reflectivity &amp;gt; 0.0f || r.eta &amp;gt; 0.0f)) {
    /* ... */
    if (r.eta &amp;gt; 0.0f) {
        if (refract(dx, dy, nx, ny, sign &amp;lt; 0.0f ? r.eta : 1.0f / r.eta, &amp;amp;rx, &amp;amp;ry)) {
            float cosi = -(dx * nx + dy * ny);
            float cost = -(rx * nx + ry * ny);
            refl = sign &amp;lt; 0.0f ? fresnel(cosi, cost, r.eta, 1.0f) : fresnel(cosi, cost, 1.0f, r.eta);
            sum += (1.0f - refl) * trace(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1);
        }
        else
            refl = 1.0f; // Total internal reflection
    }
    /* ... */
}&lt;/code&gt;&lt;p&gt;我们比较一下，上一篇使用恒定反射比和本篇使用菲涅耳方程的渲染结果：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf10bea58952361cfbe6ad8d294eccab_r.jpg&quot; data-caption=&quot;恒定 20% 的反射比&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1032&quot; data-rawheight=&quot;256&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3d5a34424bf8d4724ff976244fcbbdfe_r.jpg&quot; data-caption=&quot;使用菲涅耳方程&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1032&quot; data-rawheight=&quot;256&quot;&gt;&lt;p&gt;比较明显的区别是，光线垂直射向凸透镜和凹透镜时，使用恒定反比射会产生很亮的反射光斑，而使用菲涅耳方程的反射光斑就会暗得多，大部分光能穿过了透镜。&lt;/p&gt;&lt;h2&gt;3. Schlick 近似&lt;/h2&gt;&lt;p&gt;鉴于导体的菲涅耳方程较复杂，Schlick [2] 提供了一个近似的函数：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;R(\theta_i) \approx R(0)+(1-R(0))(1-\cos\theta_i)^5\tag{3}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;此函数只需要对材质提供光线垂直反射时的 &lt;equation&gt;R(0)&lt;/equation&gt; 值，就能近似地计算出不同入射角旳菲涅耳反射比。下图展示此近似函数（虚线）与菲涅耳方程（实线）的比较（自 [1] P. 234）：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e6fdb3b1ebbf053dcfc55466fec10ec4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1234&quot; data-rawheight=&quot;1144&quot;&gt;&lt;p&gt;对于电介质，我们可以使用 (2) 计算出 &lt;equation&gt;R(0)&lt;/equation&gt; ：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;R(0)=\left(\frac{\eta_i-\eta_t}{\eta_i+\eta_t}\right)^2\tag{4}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于导体，我们就需要提供 &lt;equation&gt;R(0)&lt;/equation&gt; 的值（可能需要多个频率，如 RGB）。另一点要注意的事，从低折射率材质到高折射率材质时，要使用 &lt;equation&gt;\theta_t&lt;/equation&gt; ：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float schlick(float cosi, float cost, float etai, float etat) {
    float r0 = (etai - etat) / (etai + etat);
    r0 *= r0;
    float a = 1.0f - (etai &amp;lt; etat ? cosi : cost);
    float aa = a * a;
    return r0 + (1.0f - r0) * aa * aa * a;
}&lt;/code&gt;&lt;p&gt;这个函数采用和 &lt;equation&gt;\texttt{fresnel()}&lt;/equation&gt; 相同的接口，可以在例子中替换。但如果要支持导体，则要改变接口。&lt;/p&gt;&lt;p&gt;这个例子中用 Schlick 近似并没有肉眼能分辨的差异，就不显示渲染结果了。&lt;/p&gt;&lt;h2&gt;4. 结语&lt;/h2&gt;&lt;p&gt;我们依据菲涅耳方程，以入射角及材质特性推断出光线的反射比和透射比，这样更接近真实世界的情况。&lt;/p&gt;&lt;p&gt;Schlick 近似被广泛应用在实时的基于物理渲染（physically based rendering, PBR）中，除了运算简单快捷，以 &lt;equation&gt;R(0)&lt;/equation&gt; 作为参数更容易让美术理解──白光直射材质所反射的颜色。用物理量（如本文未提及的波阻抗和磁导率）作为参数的话就很不友好。&lt;/p&gt;&lt;p&gt;本文的代码位于 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/fresnel.c&quot;&gt;fresnel.c&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] Akenine-Möller, Tomas, Eric Haines, and Naty Hoffman. &lt;i&gt;Real-time rendering,&lt;/i&gt; Third Edition. CRC Press, 2008.&lt;/p&gt;&lt;p&gt;[2] Schlick, Christophe. &quot;&lt;a href=&quot;http://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf&quot;&gt;An Inexpensive BRDF Model for Physically‐based Rendering&lt;/a&gt;.&quot; &lt;i&gt;Computer graphics forum&lt;/i&gt;. Vol. 13. No. 3. Blackwell Science Ltd, 1994.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;更新1：谢 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/164344a9ffe3949bfd9e387663119ecd&quot; data-hash=&quot;164344a9ffe3949bfd9e387663119ecd&quot; data-hovercard=&quot;p$b$164344a9ffe3949bfd9e387663119ecd&quot;&gt;@codeworm96&lt;/a&gt; 指出，公式 (4) 右侧需平方，已修正。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-12-07-31534769</guid>
<pubDate>Thu, 07 Dec 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
