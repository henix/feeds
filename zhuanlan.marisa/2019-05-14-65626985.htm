<div class="title-image"><img src="https://pic1.zhimg.com/v2-11e1ed02fda8354157f6711554a721d4_b.jpg" alt=""></div><p>类型系统是编程语言的重要组成部分，本文是对</p><a href="https://link.zhihu.com/?target=http%3A//lucacardelli.name/papers/typesystems.pdf" data-draft-node="block" data-draft-type="link-card" class=" wrap external" target="_blank" rel="nofollow noreferrer">type system</a><p>的阅读笔记和梗概，强烈推荐感兴趣的同学阅读文章本身。</p><h2>前置知识</h2><h2>类型系统的目的</h2><p><b>类型系统(type system)</b>的基本目标是防止程序在运行时发生类型错误。当且仅当语言运行时不存在任何形式的类型错误，那么它就是<b>sound</b>的。soundness是类型系统研究的重要目标。</p><h2>对类型系统的描述</h2><p>描述类型系统使用的是一种符号系统，它来自于<b>自然推演</b>(Natural Deduction)。有如下几个组成部分：</p><h3>Judgments</h3><p>Judgement是一条断言，一般具有如下形式:</p><p><img src="https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+%5CIm" alt="\Gamma \vdash \Im" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=%5CGamma" alt="\Gamma" eeimg="1"/> 表示<b>已知的事实</b>，<img src="https://www.zhihu.com/equation?tex=%5Cvdash" alt="\vdash" eeimg="1"/> 表示<b>推导出</b>，<img src="https://www.zhihu.com/equation?tex=%5CIm" alt="\Im" eeimg="1"/> 表示<b>推导的结果</b>，类型断言一般用来表示变量具有指定类型。例如：</p><p><img src="https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+M%3AA" alt="\Gamma \vdash M:A" eeimg="1"/> </p><p>表示在类型环境 <img src="https://www.zhihu.com/equation?tex=%5CGamma" alt="\Gamma" eeimg="1"/> 中，自由变量M具有类型A。</p><p>有一条常用的通用断言：</p><p><img src="https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+%5Cdiamond" alt="\Gamma \vdash \diamond" eeimg="1"/> </p><p>表示类型环境 <img src="https://www.zhihu.com/equation?tex=%5CGamma" alt="\Gamma" eeimg="1"/> 是<b>形式良好(well formed)的</b>。</p><p>还有一种语义： <img src="https://www.zhihu.com/equation?tex=%5CGamma%2C%5C+%5CGamma%27+%5Cvdash+e" alt="\Gamma,\ \Gamma&#39; \vdash e" eeimg="1"/> ,这表示了已知环境 <img src="https://www.zhihu.com/equation?tex=%5CGamma" alt="\Gamma" eeimg="1"/> 加上一个本地环境 <img src="https://www.zhihu.com/equation?tex=%5CGamma%27" alt="\Gamma&#39;" eeimg="1"/>，可以推导出e。</p><h3>Type rules</h3><p>类型规则通过一条或多条断言来决定一条断言的正确性，一般有如下形式：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Rule%5C+name%29%5C+%5C+%28Annotations%29+%5C+%5CGamma_1+%5Cvdash+%5CIm_1+%E2%80%A6+%5CGamma_n+%5Cvdash+%5CIm_n%5C+%28Annotations%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5CIm%7D" alt="\frac{\begin{gather} (Rule\ name)\ \ (Annotations) \ \Gamma_1 \vdash \Im_1 … \Gamma_n \vdash \Im_n\ (Annotations) \end{gather} }{\Gamma \vdash \Im}" eeimg="1"/> </p><p>横线上方是一条或多条判断，描述了规则的<b>前提(premise)</b>。下方只能有一个判断，描述了规则的<b>结论(conclusion)</b>。顶部可以标注规则的名称和注释。前提的右边也可以写一些注释。</p><p>我们来举个例子：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+n%29%5C+%5C+%28n+%3D+0%2C%5C+1%2C%5C+%E2%80%A6%29+%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+n%3ANat%7D%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+%2B%29+%5C+%5CGamma+%5Cvdash+M%3ANat%5C+%5C+%5C+%5CGamma+%5Cvdash+N%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+M%2BN%3ANat%7D" alt="\frac {\begin{gather} (Val\ n)\ \ (n = 0,\ 1,\ …) \ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash n:Nat}\ \ \  \frac {\begin{gather} (Val\ +) \ \Gamma \vdash M:Nat\ \ \ \Gamma \vdash N:Nat \end{gather} } {\Gamma \vdash M+N:Nat}" eeimg="1"/> </p><p>这个例子认为在一个行为良好的类型环境中，所有的自然数都有类型Nat，两个类型同为Nat的表达式M和N相加的结果也为一个自然数。</p><p>有一条基本规则：空的环境是类型良好的，不需要任何假设：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D" alt="\frac{\begin{gather} (Env\ \varnothing)\ \  \end{gather} }{\varnothing \vdash \diamond}" eeimg="1"/> </p><p>一系列类型规则组成的集合称为一个正式的类型系统。</p><h3>Type derivations</h3><p><b>类型导出(Type derivations)</b>在一个给定的类型系统中，是一颗树，它的底部的根节点和顶部的叶节点都是类型断言，且每条断言都可以由它上方的断言结合类型系统的规则直接获得。给定一个类型断言，我们可以将它放置在类型导出的根部（底部），利用类型规则一步一步向上推导，如果能够顺利推出，说明断言是合法的。</p><p>例如根据我们此前的规则，可以判断 <img src="https://www.zhihu.com/equation?tex=%5Cvarnothing+%5Cvdash+1%2B2%3ANat" alt="\varnothing \vdash 1+2:Nat" eeimg="1"/> 是否合法：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B+%5Cfrac%7B%7D%7B%5Cfrac%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D%7B%5Cvarnothing+%5Cvdash+1%3ANat%7D%7D+%5C+%5C++%5Cfrac%7B%7D%7B%5Cfrac%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D%7B%5Cvarnothing+%5Cvdash+2%3ANat%7D%7D+%7D%7B%5Cvarnothing+%5Cvdash+1+%2B+2%3A+Nat%7D" alt="\frac{ \frac{}{\frac{\varnothing \vdash \diamond}{\varnothing \vdash 1:Nat}} \ \  \frac{}{\frac{\varnothing \vdash \diamond}{\varnothing \vdash 2:Nat}} }{\varnothing \vdash 1 + 2: Nat}" eeimg="1"/> </p><h3>Type inference</h3><p>给定一个项M，如果它在类型环境 <img src="https://www.zhihu.com/equation?tex=%5CGamma" alt="\Gamma" eeimg="1"/> 中是<b>良型的(well typed)</b>，那么存在一个类型A可以赋给M。通过类型导出为M确定A，称为<b>类型推导(Type inference)</b>。</p><h2>System <img src="https://www.zhihu.com/equation?tex=F_1" alt="F_1" eeimg="1"/> </h2><h2>基础构成</h2><h3>语法</h3><p><b>一阶类型化的</b> <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="\lambda" eeimg="1"/> <b>演算(first-order typed </b><img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="\lambda" eeimg="1"/> <b>-calculus)</b>被称作System <img src="https://www.zhihu.com/equation?tex=F_1" alt="F_1" eeimg="1"/> 。我们可以给 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="\lambda" eeimg="1"/> 演算添加类型注释，它的语法如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+A%2C+B+%26%3A%3A%3D%5C+types+%5C%5C+%26K%5C+%5C+%5C+%5C+K+%5Cin+Basic+%26basic%5C+types+%5C%5C+%26A+%5Crightarrow+B+%26function%5C+types+%5C%5C+M%2CN+%26%3A%3A%3D%5C+terms+%5C%5C+%26x+%26variable+%5C%5C+%26%5Clambda+x%3AA.M+%26function+%5C%5C+%26M+N+%26application+%5Cend%7Balign%7D" alt="\begin{align} A, B &amp;::=\ types \\ &amp;K\ \ \ \ K \in Basic &amp;basic\ types \\ &amp;A \rightarrow B &amp;function\ types \\ M,N &amp;::=\ terms \\ &amp;x &amp;variable \\ &amp;\lambda x:A.M &amp;function \\ &amp;M N &amp;application \end{align}" eeimg="1"/> </p><h3>断言</h3><p>对于 <img src="https://www.zhihu.com/equation?tex=F_1" alt="F_1" eeimg="1"/> 我们只需要三条简单的断言：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D" alt="\begin{align} &amp;\Gamma \vdash \diamond\\ &amp;\Gamma \vdash A \\ &amp;\Gamma \vdash M:A \end{align}" eeimg="1"/> </p><h3>规则</h3><p>有了这三条断言，我们可以写出它的类型规则：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C++%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+x+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C%5C+x%3AA+%5Cvdash+%5Cdiamond%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Const%29%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond%5C+%5C+%5C+%5C+K+%5Cin+Basic+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+K%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Arrow%29%5C%5C+%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A+%5Crightarrow+B%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+x%29%5C%5C+%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+x%3AA%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun%29%5C%5C+%5CGamma%2C%5C+x%3AA+%5Cvdash+M%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+x%3AA.M%3AA+%5Crightarrow+B%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl%29%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Crightarrow+B%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M+N%3AB%7D+%5Cend%7Balign%7D" alt="\begin{align} &amp;\frac{\begin{gather} (Env\ \varnothing)\\ \  \end{gather} }{\varnothing \vdash \diamond} \ \ \ \  \frac{\begin{gather} (Env\ x)\\  \Gamma \vdash A\ \ \ \ x \notin dom(\Gamma) \end{gather} }{\Gamma,\ x:A \vdash \diamond} \\ \\ &amp;\frac{\begin{gather} (Type\ Const)\\ \Gamma \vdash \diamond\ \ \ \ K \in Basic \end{gather} }{\Gamma \vdash K}\ \ \ \  \frac{\begin{gather} (Type\ Arrow)\\ \Gamma \vdash A\ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash A \rightarrow B} \\ \\ &amp;\frac{\begin{gather} (Val\ x)\\ \Gamma&#39;,\ x:A,\ \Gamma&#39;&#39; \vdash \diamond \end{gather} }{\Gamma&#39;,\ x:A,\ \Gamma&#39;&#39; \vdash x:A}\ \ \ \  \frac{\begin{gather} (Val\ Fun)\\ \Gamma,\ x:A \vdash M:B \end{gather} }{\Gamma \vdash \lambda x:A.M:A \rightarrow B}\ \ \ \  \frac{\begin{gather} (Val\ Appl)\\ \Gamma \vdash M:A \rightarrow B\ \ \ \  \Gamma \vdash N:A \end{gather} }{\Gamma \vdash M N:B} \end{align}" eeimg="1"/> </p><h2>基础类型</h2><p>我们有了System <img src="https://www.zhihu.com/equation?tex=F_1" alt="F_1" eeimg="1"/> 的基础骨架后，就可以给它增加一些基础类型。</p><h3>Unit Type</h3><p>Unit Type很常见，在很多语言中它又叫<code>Void</code>或<code>Null</code>。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Unit%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Unit%7D%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Unit%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+unit%3AUnit%7D" alt="\frac {\begin{gather} (Type\ Unit) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Unit}\ \ \  \frac {\begin{gather} (Val\ Unit) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash unit:Unit}" eeimg="1"/> </p><h3>Bool Type</h3><p>Bool Type也很常见，它是布尔值的类型，它一般拥有一个有用的操作，即通常语言中的<code>if else</code>语句，我们在这里称为<code>cond</code>:</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Bool%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Bool%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+True%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+true%3ABool%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+False%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+false%3ABool%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Cond%29+%5C%5C+%5CGamma+%5Cvdash+M%3ABool+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N_1%3AA+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N_2%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28if_A%5C+M%5C+then%5C+N_1%5C+else%5C+N_2%29%3AA%7D" alt="\frac {\begin{gather} (Type\ Bool) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Bool} \ \ \ \   \frac {\begin{gather} (Val\ True) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash true:Bool} \ \ \ \   \frac {\begin{gather} (Val\ False) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash false:Bool} \\ \\ \frac {\begin{gather} (Val\ Cond) \\ \Gamma \vdash M:Bool \ \ \ \  \Gamma \vdash N_1:A \ \ \ \  \Gamma \vdash N_2:A \end{gather} } {\Gamma \vdash (if_A\ M\ then\ N_1\ else\ N_2):A}" eeimg="1"/> </p><p>在Cond中我们需要通过下标A来告诉类型检查器，结果应该是类型A，来消除潜在的类型检查困难。</p><h3>Nat Type</h3><p>Nat Type就是自然数的类型。假设我们有0和<code>Succ</code>，则1为<code>Succ 0</code>，2为<code>Succ Succ 0</code>。Nat还存在两种计算：<code>pred</code>和<code>isZero</code>，前者用来得到当前自然数前一位的自然数，后者用来判断自然数是否为0.</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Nat%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Nat%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Zero%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+0%3ANat%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Succ%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+succ%5C+M%3ANat%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pred%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+pred%5C+M%3ANat%7D%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+IsZero%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+isZero%5C+M%3ABool%7D" alt="\frac {\begin{gather} (Type\ Nat) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Nat} \ \ \ \   \frac {\begin{gather} (Val\ Zero) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash 0:Nat} \ \ \ \   \frac {\begin{gather} (Val\ Succ) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash succ\ M:Nat} \\ \\ \frac {\begin{gather} (Val\ Pred) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash pred\ M:Nat}\ \ \ \  \frac {\begin{gather} (Val\ IsZero) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash isZero\ M:Bool}" eeimg="1"/> </p><h2>结构类型</h2><h3>Product Types</h3><p>Product Types是一对类型，由两个类型构成，例如 <img src="https://www.zhihu.com/equation?tex=A_1+%5Ctimes+A_2" alt="A_1 \times A_2" eeimg="1"/> 就是一个product type。这两个类型可以通过<code>first</code>和<code>second</code>操作符来提取出来。通过<code>with</code>语句，我们可以把product type解构为两个单独的变量 <img src="https://www.zhihu.com/equation?tex=x_1" alt="x_1" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=x_2" alt="x_2" eeimg="1"/> ，应用在作用域N中。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Product%29%5C%5C+%5CGamma+%5Cvdash+A_1%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A_1+%5Ctimes+A_2%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pair%29%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_2%3AA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clangle+M1%2CM2+%5Crangle%3A+A_1+%5Ctimes+A_2%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+First%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2++%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+first%5C+M%3AA_1%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Second%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2++%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+second%5C+M%3AA_2%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+With%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_1%3AA_1%2C%5C+x_2%3AA_2+%5Cvdash+N%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%28with+%28x_1%3AA_1%2C+x_2%3AA_2%29+%3A%3D+M%5C+do%5C+N%29%3AB%7D+%5Cend%7Balign%7D" alt="\begin{align} &amp;\frac{\begin{gather} (Type\ Product)\\ \Gamma \vdash A_1\ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash A_1 \times A_2}\ \ \ \  \frac{\begin{gather} (Val\ Pair)\\ \Gamma \vdash M_1:A_1\ \ \ \  \Gamma \vdash M_2:A_2 \end{gather} }{\Gamma \vdash \langle M1,M2 \rangle: A_1 \times A_2} \\ \\ &amp;\frac{\begin{gather} (Val\ First)\\ \Gamma \vdash M:A_1 \times A_2  \end{gather} }{\Gamma \vdash first\ M:A_1}\ \ \ \  \frac{\begin{gather} (Val\ Second)\\ \Gamma \vdash M:A_1 \times A_2  \end{gather} }{\Gamma \vdash second\ M:A_2} \\ \\ &amp;\frac{\begin{gather} (Val\ With)\\ \Gamma \vdash M:A_1 \times A_2\ \ \ \  \Gamma,\ x_1:A_1,\ x_2:A_2 \vdash N:B \end{gather} }{\Gamma \vdash (with (x_1:A_1, x_2:A_2) := M\ do\ N):B} \end{align}" eeimg="1"/> </p><h3>Union Types</h3><p>Union Types指的是结合类型。例如一个union type <img src="https://www.zhihu.com/equation?tex=A_1%2BA_2" alt="A_1+A_2" eeimg="1"/> 可以认为是一个带有left标记的类型为 <img src="https://www.zhihu.com/equation?tex=A_1" alt="A_1" eeimg="1"/> 的元素或带有right的类型为 <img src="https://www.zhihu.com/equation?tex=A_2" alt="A_2" eeimg="1"/> 的元素。这一标记可以由<code>isLeft</code>和<code>isRight</code>来进行测试，相应的类型可以由<code>asLeft</code>或<code>asRight</code>来提取。和之前Bool Type的Cond语句类似，<code>asLeft</code>和<code>asRight</code>也需要下标来帮助类型检查器进行判断。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Union%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A_1+%2B+A_2%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+inLeft%29+%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+inLeft_%7BA_2%7D+M_1%3AA_1+%2B+A_2%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+inRight%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_2%3AA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+inRight_%7BA_1%7D+M_2%3AA_1+%2B+A_2%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+isLeft%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+isLeft%5C+M%3ABool%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+isRight%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+isRight%5C+M%3ABool%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+asLeft%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+asLeft%5C+M%3AA_1%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+asRight%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+asRight%5C+M%3AA_2%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Case%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_1%3AA_1+%5Cvdash+N_1%3AB+%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_2%3AA_2+%5Cvdash+N_2%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%28case_B+M%5C+of%5C+x_1%3AA_1%5C+then%5C+N_1%5C+%7C%5C+x_2%3AA_2%5C+then%5C+N_2%29%3AB%7D+%5Cend%7Balign%7D" alt="\begin{align} &amp;\frac {\begin{gather} (Type\ Union) \\ \Gamma \vdash A_1 \ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash A_1 + A_2} \ \ \ \  \frac {\begin{gather} (Val\ inLeft) \\ \Gamma \vdash M_1:A_1 \ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash inLeft_{A_2} M_1:A_1 + A_2} \ \ \ \  \frac {\begin{gather} (Val\ inRight) \\ \Gamma \vdash A_1 \ \ \ \  \Gamma \vdash M_2:A_2 \end{gather} }{\Gamma \vdash inRight_{A_1} M_2:A_1 + A_2} \\ \\ &amp;\frac {\begin{gather} (Val\ isLeft) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash isLeft\ M:Bool} \ \ \ \  \frac {\begin{gather} (Val\ isRight) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash isRight\ M:Bool} \\ \\ &amp;\frac {\begin{gather} (Val\ asLeft) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash asLeft\ M:A_1} \ \ \ \  \frac {\begin{gather} (Val\ asRight) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash asRight\ M:A_2} \\ \\ &amp;\frac {\begin{gather} (Val\ Case) \\ \Gamma \vdash M:A_1+A_2 \ \ \ \  \Gamma,\ x_1:A_1 \vdash N_1:B \ \ \ \  \Gamma,\ x_2:A_2 \vdash N_2:B \end{gather} }{\Gamma \vdash (case_B M\ of\ x_1:A_1\ then\ N_1\ |\ x_2:A_2\ then\ N_2):B} \end{align}" eeimg="1"/> </p><p>如果<code>asRight</code>被错误的应用在了由<code>isLeft</code>标记的元素上，那么我们就得到了一个被捕获的异常，这个异常不属于forbidden error。因此有了union Type，我们可以定义一个典型的被捕获的错误类型：</p><p><img src="https://www.zhihu.com/equation?tex=error_A+%3D+asRight%28inLeft_A%28unit%29%29%3AA" alt="error_A = asRight(inLeft_A(unit)):A" eeimg="1"/> </p><p>我们可以用它来表示任何类型的异常。</p><h3>Record Types</h3><p>Record Types是product types的升级版，它由product types迭代而来。对于record M中的每个组成变量 <img src="https://www.zhihu.com/equation?tex=x_1+%E2%80%A6+x_2" alt="x_1 … x_2" eeimg="1"/> ，都有名称 <img src="https://www.zhihu.com/equation?tex=l_1+%E2%80%A6+l_2" alt="l_1 … l_2" eeimg="1"/> 和它绑定。与product types相似，record types也有with语句。Product types <img src="https://www.zhihu.com/equation?tex=A_1+%5Ctimes+A_2" alt="A_1 \times A_2" eeimg="1"/> 在record types中可以定义为 <img src="https://www.zhihu.com/equation?tex=Record%28first%3A+A_1%2C+second%3A+A_2%29" alt="Record(first: A_1, second: A_2)" eeimg="1"/> 。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Record%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+Record%28l_1%3AA_1%2C+%E2%80%A6%2C+l_n%3AA_n%29%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val+Record%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1+%E2%80%A6+%5CGamma+%5Cvdash+M_n%3AA_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+record%28l_1%3DM_1%2C%E2%80%A6%2Cl_n%3DM_n%29%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%7D%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Record%5C+Select%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M.l_j%3AA_j%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Record%5C+With%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C++%5CGamma%2Cx_1%3AA_1%2C%E2%80%A6%2Cx_n%3AA_n+%5Cvdash+N%3AB+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+%28with+%28l_1%3Dx_1%3AA_1%2C%E2%80%A6%2Cl_n%3Dx_n%3AA_n%29+%3A%3D+M%5C+do%5C+N%29%3AB%7D+%5Cend%7Balign%7D" alt="\begin{align} &amp;\frac {\begin{gather} (Type\ Record)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \end{gather}} {\Gamma \vdash Record(l_1:A_1, …, l_n:A_n)} \ \ \ \  \frac {\begin{gather} (Val Record)\ \ \ \  (l_i distinct) \\ \Gamma \vdash M_1:A_1 … \Gamma \vdash M_n:A_n \end{gather}} {\Gamma \vdash record(l_1=M_1,…,l_n=M_n):Record(l_1:A_1,…,l_n:A_n)}\\ \\ &amp;\frac {\begin{gather} (Val\ Record\ Select) \\ \Gamma \vdash M:Record(l_1:A_1,…,l_n:A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M.l_j:A_j} \\ \\ &amp;\frac {\begin{gather} (Val\ Record\ With) \\ \Gamma \vdash M:Record(l_1:A_1,…,l_n…A_n)\ \ \ \  \Gamma,x_1:A_1,…,x_n:A_n \vdash N:B \end{gather}} {\Gamma \vdash (with (l_1=x_1:A_1,…,l_n=x_n:A_n) := M\ do\ N):B} \end{align}" eeimg="1"/> </p><h3>Variant Types</h3><p>与recotd types和product的关系类似，variant types也由union types迭代而来。Union types <img src="https://www.zhihu.com/equation?tex=A_1+%2B+A_2" alt="A_1 + A_2" eeimg="1"/> 在variant types中可以被定义为 <img src="https://www.zhihu.com/equation?tex=Variant%28left%3AA_1%2C+right%3AA_2%29" alt="Variant(left:A_1, right:A_2)" eeimg="1"/> 。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Variant%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+Variant%28l_1%3AA_1%2C+%E2%80%A6%2C+l_n%3AA_n%29%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_j%3AA_j+%5C+%5C+%5C+%5C++j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+variant_%7Bl_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%7D%28l_j%3DM_j%29%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%7D%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+Is%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M%5C+is%5C+l_j%3ABool%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+As%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M%5C+as%5C+l_j%3AA_j%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+Case%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C++%5CGamma%2C+x_1%3AA_1+%5Cvdash+N_1%3AB+%E2%80%A6+%5CGamma%2Cx_n%3AA_n+%5Cvdash+N_n%3AB+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+%28case_B%5C+M%5C+of%5C+l_1%3Dx_1%3AA_1%5C+then%5C+N_1%5C+%7C%E2%80%A6%7C%5C+l_n%3Dx_n%3AA_n%5C+then%5C+N_n%29%3AB%7D+%5Cend%7Balign%7D" alt="\begin{align} &amp;\frac {\begin{gather} (Type\ Variant)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \end{gather}} {\Gamma \vdash Variant(l_1:A_1, …, l_n:A_n)} \ \ \ \  \frac {\begin{gather} (Val\ Variant)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \ \ \ \  \Gamma \vdash M_j:A_j \ \ \ \  j \in 1..n \end{gather}} {\Gamma \vdash variant_{l_1:A_1,…,l_n:A_n}(l_j=M_j):Variant(l_1:A_1,…,l_n:A_n)}\\ \\ &amp;\frac {\begin{gather} (Val\ Variant\ Is) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n:A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M\ is\ l_j:Bool} \\ \\ &amp;\frac {\begin{gather} (Val\ Variant\ As) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n…A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M\ as\ l_j:A_j} \\ \\ &amp;\frac {\begin{gather} (Val\ Variant\ Case) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n…A_n)\ \ \ \  \Gamma, x_1:A_1 \vdash N_1:B … \Gamma,x_n:A_n \vdash N_n:B \end{gather}} {\Gamma \vdash (case_B\ M\ of\ l_1=x_1:A_1\ then\ N_1\ |…|\ l_n=x_n:A_n\ then\ N_n):B} \end{align}" eeimg="1"/> </p><h3>Reference Types</h3><p>引用类型在命令式语言中很常见，它用来包裹地址可变的元素。可以由<code>ref</code>分配，由<code>assign</code>更新，并由<code>deref</code>解除。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Ref%29+%5C%5C+%5CGamma+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Ref%5C+A%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Ref%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+ref%5C+M%3ARef%5C+A%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Deref%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARef%5C+A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+deref%5C+M%3AA%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Assign%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARef%5C+A+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+M%3A%3DN%3AUnit%7D+%5Cend%7Balign%7D" alt="\begin{align} &amp;\frac {\begin{gather} (Type\ Ref) \\ \Gamma \vdash A \end{gather} }{\Gamma \vdash Ref\ A} \ \ \ \   \frac {\begin{gather} (Val\ Ref) \\ \Gamma \vdash M:A \end{gather} } {\Gamma \vdash ref\ M:Ref\ A} \\ \\ &amp;\frac {\begin{gather} (Val\ Deref) \\ \Gamma \vdash M:Ref\ A \end{gather} } {\Gamma \vdash deref\ M:A} \ \ \ \  \frac {\begin{gather} (Val\ Assign) \\ \Gamma \vdash M:Ref\ A \ \ \ \  \Gamma \vdash N:A \end{gather} } {\Gamma \vdash M:=N:Unit} \end{align}" eeimg="1"/> </p><h3>Recursive Types</h3><p>递归类型需要为环境中扩展一个<b>类型变量X</b>。类型变量的应用形式为 <img src="https://www.zhihu.com/equation?tex=%5Cmu+X.A" alt="\mu X.A" eeimg="1"/> 。例如有一个树类型 <img src="https://www.zhihu.com/equation?tex=%5Calpha+%3D+unit+%2B+int+%5Ctimes+%5Calpha+%5Ctimes+%5Calpha" alt="\alpha = unit + int \times \alpha \times \alpha" eeimg="1"/> ，我们可以将等式写为 <img src="https://www.zhihu.com/equation?tex=%5Calpha+%3D+%5Ctau" alt="\alpha = \tau" eeimg="1"/> ，如果存在 <img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="\tau" eeimg="1"/> 不是 <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="\alpha" eeimg="1"/> ，且有唯一解使等式成立的情况。那么我们将这个解写为 <img src="https://www.zhihu.com/equation?tex=%5Cmu+%5Calpha+.+%5Ctau" alt="\mu \alpha . \tau" eeimg="1"/> 。我们通过方式表示这个recursive type。由于在这里 <img src="https://www.zhihu.com/equation?tex=%5Calpha+%3D+%5Ctau" alt="\alpha = \tau" eeimg="1"/> ，那么等式 <img src="https://www.zhihu.com/equation?tex=%5Cmu+%5Calpha+.+%5Ctau+%3D+%5Ctau+%7B%5Cfrac+%7B%5Cmu+%5Calpha+.+%5Ctau%7D+%7B%5Calpha%7D%7D" alt="\mu \alpha . \tau = \tau {\frac {\mu \alpha . \tau} {\alpha}}" eeimg="1"/> 是成立的。我们把从做向右变换的操作称为<code>unfold</code>，把从右向左变换的过程称为<code>fold</code>。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Env%5C+X%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5C+%5C+%5C+%5C++X+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C+X+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Rec%29+%5C%5C+%5CGamma%2C+X+%5Cvdash+A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%5Cmu+X.A%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fold%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5B%5Cmu+X.A%2FX%5DA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+fold_%7B%5Cmu+X.A%7D+M%3A%5Cmu+X.A%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Unfold%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cmu+X.A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+unfold_%7B%5Cmu+X.A%7D+M%3A%5B%5Cmu+X.A+%2F+X%5D+A%7D+%5Cend%7Balign%7D" alt="\begin{align} &amp;\frac {\begin{gather} (Env\ X) \\ \Gamma \vdash \diamond \ \ \ \  X \notin dom(\Gamma) \end{gather} }{\Gamma, X \vdash \diamond} \ \ \ \   \frac {\begin{gather} (Type\ Rec) \\ \Gamma, X \vdash A \end{gather} } {\Gamma \vdash \mu X.A} \\ \\ &amp;\frac {\begin{gather} (Val\ Fold) \\ \Gamma \vdash M:[\mu X.A/X]A \end{gather} } {\Gamma \vdash fold_{\mu X.A} M:\mu X.A} \ \ \ \  \frac {\begin{gather} (Val\ Unfold) \\ \Gamma \vdash M:\mu X.A \end{gather} } {\Gamma \vdash unfold_{\mu X.A} M:[\mu X.A / X] A} \end{align}" eeimg="1"/> </p><h2>System <img src="https://www.zhihu.com/equation?tex=F_2" alt="F_2" eeimg="1"/> </h2><h2>Type Parameters</h2><p>我们使用一种新语法来表示类型的参数： <img src="https://www.zhihu.com/equation?tex=%5Clambda+X.M" alt="\lambda X.M" eeimg="1"/> ，表示程序M中有类型变量X，例如对于<code>id</code>函数 <img src="https://www.zhihu.com/equation?tex=%5Clambda+x%3AA.x" alt="\lambda x:A.x" eeimg="1"/> 就可以被写为带有类型变量的： <img src="https://www.zhihu.com/equation?tex=id+%5Ctriangleq+%5Clambda+X.%5Clambda+x%3AX.x" alt="id \triangleq \lambda X.\lambda x:X.x" eeimg="1"/> ，将类型A代入X，写为<code>id A</code>，就可以得到 <img src="https://www.zhihu.com/equation?tex=%5Clambda+x%3AA.x" alt="\lambda x:A.x" eeimg="1"/> 。</p><h3>Universally Quantified Types</h3><p>对应新的项： <img src="https://www.zhihu.com/equation?tex=%5Clambda+X.M" alt="\lambda X.M" eeimg="1"/> ，我们有新的<b>universally quantified types</b>，前式可写为 <img src="https://www.zhihu.com/equation?tex=%5Cforall+X.A" alt="\forall X.A" eeimg="1"/> ，表示对于所有的X，程序体M都有类型A。例如上文中的<code>id</code>为： <img src="https://www.zhihu.com/equation?tex=%5Cforall+X.X+%5Crightarrow+X" alt="\forall X.X \rightarrow X" eeimg="1"/> ，表示对于所有的X，<code>id X</code>都有类型 <img src="https://www.zhihu.com/equation?tex=X+%5Crightarrow+X" alt="X \rightarrow X" eeimg="1"/> 。</p><h2>基础构成</h2><h3>语法</h3><p>System <img src="https://www.zhihu.com/equation?tex=F_2" alt="F_2" eeimg="1"/> 的类型如下，由于我们有了类型参数，所以System <img src="https://www.zhihu.com/equation?tex=F_1" alt="F_1" eeimg="1"/> 中的基础类型K被去掉了。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+A%2C+B+%26%3A%3A%3D%5C+types+%5C%5C+%26X+%26type%5C+variable+%5C%5C+%26A+%5Crightarrow+B+%26function%5C+type+%5C%5C+%26%5Cforall+X.A+%26universally%5C+quantified%5C+type+%5C%5C+M%2CN+%26%3A%3A%3D%5C+terms+%5C%5C+%26x+%26variable+%5C%5C+%26%5Clambda+x%3AA.M+%26function+%5C%5C+%26M+N+%26application+%5C%5C+%26%5Clambda+X.M+%26polymorphic%5C+abstraction+%5C%5C+%26M+A+%26type%5C+instantiation+%5Cend%7Balign%7D" alt="\begin{align} A, B &amp;::=\ types \\ &amp;X &amp;type\ variable \\ &amp;A \rightarrow B &amp;function\ type \\ &amp;\forall X.A &amp;universally\ quantified\ type \\ M,N &amp;::=\ terms \\ &amp;x &amp;variable \\ &amp;\lambda x:A.M &amp;function \\ &amp;M N &amp;application \\ &amp;\lambda X.M &amp;polymorphic\ abstraction \\ &amp;M A &amp;type\ instantiation \end{align}" eeimg="1"/> </p><h3>断言</h3><p>对于 <img src="https://www.zhihu.com/equation?tex=F_2" alt="F_2" eeimg="1"/> ，断言和 <img src="https://www.zhihu.com/equation?tex=F_1" alt="F_1" eeimg="1"/> 完全相同：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D" alt="\begin{align} &amp;\Gamma \vdash \diamond\\ &amp;\Gamma \vdash A \\ &amp;\Gamma \vdash M:A \end{align}" eeimg="1"/> </p><h3>规则</h3><p>相比 <img src="https://www.zhihu.com/equation?tex=F_1" alt="F_1" eeimg="1"/> ， <img src="https://www.zhihu.com/equation?tex=F_2" alt="F_2" eeimg="1"/> 的类型环境添加了类型变量X。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C++%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+x+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C%5C+x%3AA+%5Cvdash+%5Cdiamond%7D%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5C+%5C+%5C+%5C+X+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%2C+X+%5Cvdash+%5Cdiamond%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+X%29%5C%5C+%5CGamma%27%2C+X%2C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C+X%2C+%5CGamma%27%27+%5Cvdash+X%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Arrow%29%5C%5C+%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A+%5Crightarrow+B%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Forall%29%5C%5C+%5CGamma+X%2C+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Cforall+X.A%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+x%29%5C%5C+%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+x%3AA%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun%29%5C%5C+%5CGamma%2C%5C+x%3AA+%5Cvdash+M%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+x%3AA.M%3AA+%5Crightarrow+B%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl%29%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Crightarrow+B%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M+N%3AB%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun2%29%5C%5C+%5CGamma%2C+X+%5Cvdash+M%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+X.M%3A%5Cforall+X.A%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl2%29%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cforall+X.A+%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M%5C+B+%3A+%5BB%2FX%5DA%7D+%5Cend%7Balign%7D" alt="\begin{align} &amp;\frac{\begin{gather} (Env\ \varnothing)\\ \  \end{gather} }{\varnothing \vdash \diamond} \ \ \ \  \frac{\begin{gather} (Env\ x)\\  \Gamma \vdash A\ \ \ \ x \notin dom(\Gamma) \end{gather} }{\Gamma,\ x:A \vdash \diamond}\ \ \ \  \frac {\begin{gather} (Env\ x)\\ \Gamma \vdash \diamond \ \ \ \ X \notin dom(\Gamma) \end{gather}} {\Gamma , X \vdash \diamond} \\ \\ &amp;\frac{\begin{gather} (Type\ X)\\ \Gamma&#39;, X, \Gamma&#39;&#39; \vdash \diamond \end{gather} }{\Gamma&#39;, X, \Gamma&#39;&#39; \vdash X}\ \ \ \  \frac{\begin{gather} (Type\ Arrow)\\ \Gamma \vdash A\ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash A \rightarrow B} \ \ \ \  \frac{\begin{gather} (Type\ Forall)\\ \Gamma X, \vdash A \end{gather} }{\Gamma \vdash \forall X.A} \\ \\ &amp;\frac{\begin{gather} (Val\ x)\\ \Gamma&#39;,\ x:A,\ \Gamma&#39;&#39; \vdash \diamond \end{gather} }{\Gamma&#39;,\ x:A,\ \Gamma&#39;&#39; \vdash x:A}\ \ \ \  \frac{\begin{gather} (Val\ Fun)\\ \Gamma,\ x:A \vdash M:B \end{gather} }{\Gamma \vdash \lambda x:A.M:A \rightarrow B}\ \ \ \  \frac{\begin{gather} (Val\ Appl)\\ \Gamma \vdash M:A \rightarrow B\ \ \ \  \Gamma \vdash N:A \end{gather} }{\Gamma \vdash M N:B} \\ \\ &amp;\frac{\begin{gather} (Val\ Fun2)\\ \Gamma, X \vdash M:A \end{gather} }{\Gamma \vdash \lambda X.M:\forall X.A}\ \ \ \  \frac{\begin{gather} (Val\ Appl2)\\ \Gamma \vdash M:\forall X.A \ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash M\ B : [B/X]A} \end{align}" eeimg="1"/> </p><p>Appl2中的 <img src="https://www.zhihu.com/equation?tex=%5BB%2FX%5DA" alt="[B/X]A" eeimg="1"/> 是指用B替换A中出现的X。</p><h3>Existentially Quantified Types</h3><p>与universally quantified types相反，existentially quantified types表示存在某个类型可以满足等式。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Exists%29+%5C%5C+%5CGamma%2C+X+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Cexists+X.A%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pack%29+%5C%5C+%5CGamma+%5Cvdash+%5BB%2FX%5DM%3A%5BB%2FX%5DA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28pack_%7B%5Cexists+X.A%7DX+%3D+B%5C+with%5C+M%29%3A+%5Cexists+X.A%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Open%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cexists+X.A+%5C+%5C+%5C+%5C++%5CGamma%2CX%2Cx%3AA+%5Cvdash+N%3AB+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28open_B%5C+M%5C+as%5C+X%2C+x%3AA%5C+in%5C+N%29%3AB%7D" alt="\frac {\begin{gather} (Type\ Exists) \\ \Gamma, X \vdash A \end{gather} }{\Gamma \vdash \exists X.A} \ \ \ \   \frac {\begin{gather} (Val\ Pack) \\ \Gamma \vdash [B/X]M:[B/X]A \end{gather} } {\Gamma \vdash (pack_{\exists X.A}X = B\ with\ M): \exists X.A} \\ \\ \frac {\begin{gather} (Val\ Open) \\ \Gamma \vdash M:\exists X.A \ \ \ \  \Gamma,X,x:A \vdash N:B \ \ \ \  \Gamma \vdash B \end{gather} } {\Gamma \vdash (open_B\ M\ as\ X, x:A\ in\ N):B}" eeimg="1"/></p><p>关于pack和open，<a href="https://zhuanlan.zhihu.com/p/65626985/%5Bhttp://notebook.xyli.me/TAPL/type-system/%5D(http://notebook.xyli.me/TAPL/type-system/)" class="internal">这篇文章</a>的解释非常详细，推荐阅读。</p><h2>子类型</h2><p>子类型的定义很简单：如果A是B的子类型，则任何A中的元素都属于B，记为： <img src="https://www.zhihu.com/equation?tex=A+%3C%3A+B" alt="A &lt;: B" eeimg="1"/> 。带有子类型的系统的断言如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+A+%3C%3A+B+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D" alt="\begin{align} &amp;\Gamma \vdash \diamond\\ &amp;\Gamma \vdash A \\ &amp;\Gamma \vdash A &lt;: B \\ &amp;\Gamma \vdash M:A \end{align}" eeimg="1"/> </p><h3>Contravariant &amp; Covariant</h3><p><b>逆变(contravariant)和协变(covariant)</b>是与子类型密切相关。如果有函数类型 <img src="https://www.zhihu.com/equation?tex=A+%5Crightarrow+B" alt="A \rightarrow B" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=A%27+%5Crightarrow+B%27" alt="A&#39; \rightarrow B&#39;" eeimg="1"/> ，前者是后者的子类型。那么A一定接受任何A&#39;，所以A&#39;是A的子类型，而产生的B一定属于任何B&#39;，那么B是B&#39;的子类型。可以看出参数的子类型方向变化和函数整体是相反的，所以A是逆变的。而返回结果则是一致的，所以B是协变的。</p><p>总是出现在第奇数个箭头左边的类型是函数类型的逆变。</p><p>子类型可以与 <img src="https://www.zhihu.com/equation?tex=F_1" alt="F_1" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=F_2" alt="F_2" eeimg="1"/> 结合，没有难以理解的部分，推荐阅读原文 。</p>