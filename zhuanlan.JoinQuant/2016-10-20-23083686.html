<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>【量化交易课堂】kd 树算法之详细篇</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/23083686">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-be15d9c85bbde5fa37c4297c29b36e8a_b.jpg" alt=""></div><p>导语：在上一篇《<a href="https://link.zhihu.com/?target=https%3A//www.joinquant.com/post/2627%3Ff%3Dzh" class=" wrap external" target="_blank" rel="nofollow noreferrer">kd 树算法之思路篇</a>》中，我们介绍了如何用二叉树格式记录空间内的距离，并以其为依据进行高效的索引。在本篇文章中，我们将详细介绍 kd 树的构造以及 kd 树上的 kNN 算法。</p><p>阅读本文前请掌握<u><a href="https://link.zhihu.com/?target=https%3A//www.joinquant.com/post/2227%3Ff%3Dzh" class=" wrap external" target="_blank" rel="nofollow noreferrer">kNN</a></u>（level-1）的知识。</p><p>kd 树的结构</p><p>kd树是一个二叉树结构，它的每一个节点记载了【特征坐标，切分轴，指向左枝的指针，指向右枝的指针】。</p><p>其中，特征坐标是线性空间 Rn 中的一个点 (x1,x2,…,xn)。</p><p>切分轴由一个整数 r 表示，这里 1≤r≤n，是我们在 n 维空间中沿第 r 维进行一次分割。</p><p>节点的左枝和右枝分别都是 kd 树，并且满足：如果 y 是左枝的一个特征坐标，那么 yr≤xr；并且如果 z 是右枝的一个特征坐标，那么 zr≥xr。</p><p>给定一个数据样本集 S⊆Rn 和切分轴 r，以下递归算法将构建一个基于该数据集的 kd 树，每一次循环制作一个节点：</p><p>−− 如果 |S|=1，记录 SS 中唯一的一个点为当前节点的特征数据，并且不设左枝和右枝。（|S| 指集合 S 中元素的数量）</p><p>−− 如果 |S|&gt;1：</p><p>∙ 将 SS 内所有点按照第 rr 个坐标的大小进行排序；</p><p>∙ 选出该排列后的中位元素（如果一共有偶数个元素，则选择中位左边或右边的元素，左或右并无影响），作为当前节点的特征坐标，并且记录切分轴 r；</p><p>∙ 将 SL设为在 S 中所有排列在中位元素之前的元素； SR 设为在 S 中所有排列在中位元素后的元素；</p><p>∙ 当前节点的左枝设为以 SL 为数据集并且 r 为切分轴制作出的 kd 树；当前节点的右枝设为以 SR 为数据集并且 r 为切分轴制作出的 kd 树。再设 r←(r+1)modn。（这里，我们想轮流沿着每一个维度进行分割；modn 是因为一共有 n 个维度，在沿着最后一个维度进行分割之后再重新回到第一个维度。）</p><p>构造 kd 树的例子</p><p>上面抽象的定义和算法确实是很不好理解，举一个例子会清楚很多。首先随机在 R2 中随机生成 13 个点作为我们的数据集。起始的切分轴 r=0；这里 r=0 对应 x 轴，而 r=1 对应 y 轴。</p><figure><noscript><img src="https://pic3.zhimg.com/v2-b0d171febff21a80ff6964521e993fd6_b.png" data-rawwidth="873" data-rawheight="585" class="origin_image zh-lightbox-thumb" width="873" data-original="https://pic3.zhimg.com/v2-b0d171febff21a80ff6964521e993fd6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-b0d171febff21a80ff6964521e993fd6_b.png" data-rawwidth="873" data-rawheight="585" class="origin_image zh-lightbox-thumb lazy" width="873" data-original="https://pic3.zhimg.com/v2-b0d171febff21a80ff6964521e993fd6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-b0d171febff21a80ff6964521e993fd6_b.png"/></figure><br/><p>首先先沿 x 坐标进行切分，我们选出 x 坐标的中位点，获取最根部节点的坐标</p><figure><noscript><img src="https://pic4.zhimg.com/v2-0be041d94e45d19aedafbdab2874b54b_b.png" data-rawwidth="180" data-rawheight="66" class="content_image" width="180"/></noscript><img src="https://pic4.zhimg.com/v2-0be041d94e45d19aedafbdab2874b54b_b.png" data-rawwidth="180" data-rawheight="66" class="content_image lazy" width="180" data-actualsrc="https://pic4.zhimg.com/v2-0be041d94e45d19aedafbdab2874b54b_b.png"/></figure><p>并且按照该点的x坐标将空间进行切分，所有 x 坐标小于 6.27 的数据用于构建左枝，x坐标大于 6.27 的点用于构建右枝。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-3a4a779671f9857af6642312dd950edd_b.png" data-rawwidth="874" data-rawheight="583" class="origin_image zh-lightbox-thumb" width="874" data-original="https://pic2.zhimg.com/v2-3a4a779671f9857af6642312dd950edd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-3a4a779671f9857af6642312dd950edd_b.png" data-rawwidth="874" data-rawheight="583" class="origin_image zh-lightbox-thumb lazy" width="874" data-original="https://pic2.zhimg.com/v2-3a4a779671f9857af6642312dd950edd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-3a4a779671f9857af6642312dd950edd_b.png"/></figure><p>在下一步中 r=0+1=1mod2 对应 y 轴，左右两边再按照 y 轴的排序进行切分，中位点记载于左右枝的节点。得到下面的树，左边的x 是指这该层的节点都是沿 x 轴进行分割的。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-dbc6151d4e3678c835c1936be4da2105_b.png" data-rawwidth="417" data-rawheight="172" class="content_image" width="417"/></noscript><img src="https://pic2.zhimg.com/v2-dbc6151d4e3678c835c1936be4da2105_b.png" data-rawwidth="417" data-rawheight="172" class="content_image lazy" width="417" data-actualsrc="https://pic2.zhimg.com/v2-dbc6151d4e3678c835c1936be4da2105_b.png"/></figure><p>空间的切分如下</p><figure><noscript><img src="https://pic4.zhimg.com/v2-f699cc74825a6236fe90b7816e229fcb_b.png" data-rawwidth="873" data-rawheight="585" class="origin_image zh-lightbox-thumb" width="873" data-original="https://pic4.zhimg.com/v2-f699cc74825a6236fe90b7816e229fcb_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-f699cc74825a6236fe90b7816e229fcb_b.png" data-rawwidth="873" data-rawheight="585" class="origin_image zh-lightbox-thumb lazy" width="873" data-original="https://pic4.zhimg.com/v2-f699cc74825a6236fe90b7816e229fcb_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-f699cc74825a6236fe90b7816e229fcb_b.png"/></figure><p>下一步中 r≡1+1≡0mod2，对应 x 轴，所以下面再按照 x 坐标进行排序和切分，有</p><figure><noscript><img src="https://pic2.zhimg.com/v2-f524647d8f4a246a06dfda19e838e2f1_b.png" data-rawwidth="817" data-rawheight="279" class="origin_image zh-lightbox-thumb" width="817" data-original="https://pic2.zhimg.com/v2-f524647d8f4a246a06dfda19e838e2f1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-f524647d8f4a246a06dfda19e838e2f1_b.png" data-rawwidth="817" data-rawheight="279" class="origin_image zh-lightbox-thumb lazy" width="817" data-original="https://pic2.zhimg.com/v2-f524647d8f4a246a06dfda19e838e2f1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-f524647d8f4a246a06dfda19e838e2f1_b.png"/></figure><figure><noscript><img src="https://pic4.zhimg.com/v2-e4f7b68e882d1adae170aae981828ba3_b.png" data-rawwidth="874" data-rawheight="585" class="origin_image zh-lightbox-thumb" width="874" data-original="https://pic4.zhimg.com/v2-e4f7b68e882d1adae170aae981828ba3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-e4f7b68e882d1adae170aae981828ba3_b.png" data-rawwidth="874" data-rawheight="585" class="origin_image zh-lightbox-thumb lazy" width="874" data-original="https://pic4.zhimg.com/v2-e4f7b68e882d1adae170aae981828ba3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-e4f7b68e882d1adae170aae981828ba3_b.png"/></figure><p>最后每一部分都只剩一个点，将他们记在最底部的节点中。因为不再有未被记录的点，所以不再进行切分。<br/></p><figure><noscript><img src="https://pic4.zhimg.com/v2-fba3e0643266dad08ca6b08d91c66417_b.png" data-rawwidth="836" data-rawheight="281" class="origin_image zh-lightbox-thumb" width="836" data-original="https://pic4.zhimg.com/v2-fba3e0643266dad08ca6b08d91c66417_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-fba3e0643266dad08ca6b08d91c66417_b.png" data-rawwidth="836" data-rawheight="281" class="origin_image zh-lightbox-thumb lazy" width="836" data-original="https://pic4.zhimg.com/v2-fba3e0643266dad08ca6b08d91c66417_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-fba3e0643266dad08ca6b08d91c66417_b.png"/></figure><figure><noscript><img src="https://pic1.zhimg.com/v2-a0f5590bbf909486f78733a4b0ad6534_b.png" data-rawwidth="867" data-rawheight="588" class="origin_image zh-lightbox-thumb" width="867" data-original="https://pic1.zhimg.com/v2-a0f5590bbf909486f78733a4b0ad6534_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-a0f5590bbf909486f78733a4b0ad6534_b.png" data-rawwidth="867" data-rawheight="588" class="origin_image zh-lightbox-thumb lazy" width="867" data-original="https://pic1.zhimg.com/v2-a0f5590bbf909486f78733a4b0ad6534_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-a0f5590bbf909486f78733a4b0ad6534_b.png"/></figure><p>就此完成了 kd 树的构造。</p><p>kd 树上的 kNN 算法</p><p>给定一个构建于一个样本集的 kd 树，下面的算法可以寻找距离某个点 p 最近的 k 个样本。</p><p>零、设 L 为一个有 k 个空位的列表，用于保存已搜寻到的最近点。</p><p>一、根据 p 的坐标值和每个节点的切分向下搜索（也就是说，如果树的节点是按照 xr=a 进行切分，并且 p 的 r 坐标小于 a，则向左枝进行搜索；反之则走右枝）。</p><p>二、当达到一个底部节点时，将其标记为访问过。如果 L 里不足 k 个点，则将当前节点的特征坐标加入 L ；如果 L 不为空并且当前节点的特征与 p 的距离小于 L 里最长的距离，则用当前特征替换掉 L 中离 p 最远的点。</p><p>三、如果当前节点不是整棵树最顶端节点，执行 (a)；反之，输出 L，算法完成。</p><p>a. 向上爬一个节点。如果当前（向上爬之后的）节点未曾被访问过，将其标记为被访问过，然后执行 (1) 和 (2)；如果当前节点被访问过，再次执行 (a)。</p><p>1. 如果此时 L 里不足 k 个点，则将节点特征加入 L；如果 L 中已满 k 个点，且当前节点与 p 的距离小于 L 里最长的距离，则用节点特征替换掉 L 中离最远的点。</p><p>2. 计算 p 和当前节点切分线的距离。如果该距离大于等于 L 中距离 p 最远的距离，则在切分线另一边不会有更近的点，执行(三)；如果该距离小于 L 中最远的距离，则切分线另一边可能有更近的点，因此在当前节点的另一个枝从 (一) 开始执行。</p><p>啊呃… 被这算法噎住了，赶紧喝一口下面的例子</p><p>设我们想查询的点为 p=(−1,−5)，设距离函数是普通的 L2 距离，我们想找距离问题点最近的 k=3 个点。如下：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-1b5b2cc626746f400193623cdfaab485_b.png" data-rawwidth="858" data-rawheight="581" class="origin_image zh-lightbox-thumb" width="858" data-original="https://pic2.zhimg.com/v2-1b5b2cc626746f400193623cdfaab485_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-1b5b2cc626746f400193623cdfaab485_b.png" data-rawwidth="858" data-rawheight="581" class="origin_image zh-lightbox-thumb lazy" width="858" data-original="https://pic2.zhimg.com/v2-1b5b2cc626746f400193623cdfaab485_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-1b5b2cc626746f400193623cdfaab485_b.png"/></figure><p>首先执行 (一)，我们按照切分找到最底部节点。首先，我们在顶部开始</p><figure><noscript><img src="https://pic1.zhimg.com/v2-58fe11d18b32017bbc9c1fd8d82594e4_b.png" data-rawwidth="841" data-rawheight="283" class="origin_image zh-lightbox-thumb" width="841" data-original="https://pic1.zhimg.com/v2-58fe11d18b32017bbc9c1fd8d82594e4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-58fe11d18b32017bbc9c1fd8d82594e4_b.png" data-rawwidth="841" data-rawheight="283" class="origin_image zh-lightbox-thumb lazy" width="841" data-original="https://pic1.zhimg.com/v2-58fe11d18b32017bbc9c1fd8d82594e4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-58fe11d18b32017bbc9c1fd8d82594e4_b.png"/></figure><p>和这个节点的 x 轴比较一下，</p><figure><noscript><img src="https://pic2.zhimg.com/v2-7b628501a9c5633165faa8d56b4fc851_b.png" data-rawwidth="859" data-rawheight="581" class="origin_image zh-lightbox-thumb" width="859" data-original="https://pic2.zhimg.com/v2-7b628501a9c5633165faa8d56b4fc851_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-7b628501a9c5633165faa8d56b4fc851_b.png" data-rawwidth="859" data-rawheight="581" class="origin_image zh-lightbox-thumb lazy" width="859" data-original="https://pic2.zhimg.com/v2-7b628501a9c5633165faa8d56b4fc851_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-7b628501a9c5633165faa8d56b4fc851_b.png"/></figure><br/><p>p 的 x 轴更小。因此我们向左枝进行搜索：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-27b108e1c06e90725eabdac2ffdb7145_b.png" data-rawwidth="852" data-rawheight="284" class="origin_image zh-lightbox-thumb" width="852" data-original="https://pic2.zhimg.com/v2-27b108e1c06e90725eabdac2ffdb7145_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-27b108e1c06e90725eabdac2ffdb7145_b.png" data-rawwidth="852" data-rawheight="284" class="origin_image zh-lightbox-thumb lazy" width="852" data-original="https://pic2.zhimg.com/v2-27b108e1c06e90725eabdac2ffdb7145_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-27b108e1c06e90725eabdac2ffdb7145_b.png"/></figure><p>这次对比 y 轴，</p><figure><noscript><img src="https://pic3.zhimg.com/v2-f773b1556af7aa137444dc1139eda2e2_b.png" data-rawwidth="862" data-rawheight="582" class="origin_image zh-lightbox-thumb" width="862" data-original="https://pic3.zhimg.com/v2-f773b1556af7aa137444dc1139eda2e2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-f773b1556af7aa137444dc1139eda2e2_b.png" data-rawwidth="862" data-rawheight="582" class="origin_image zh-lightbox-thumb lazy" width="862" data-original="https://pic3.zhimg.com/v2-f773b1556af7aa137444dc1139eda2e2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-f773b1556af7aa137444dc1139eda2e2_b.png"/></figure><p>p 的 y 值更小，因此向左枝进行搜索：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-38232abbe8eb6d892f82ddc4017401b7_b.png" data-rawwidth="854" data-rawheight="280" class="origin_image zh-lightbox-thumb" width="854" data-original="https://pic4.zhimg.com/v2-38232abbe8eb6d892f82ddc4017401b7_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-38232abbe8eb6d892f82ddc4017401b7_b.png" data-rawwidth="854" data-rawheight="280" class="origin_image zh-lightbox-thumb lazy" width="854" data-original="https://pic4.zhimg.com/v2-38232abbe8eb6d892f82ddc4017401b7_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-38232abbe8eb6d892f82ddc4017401b7_b.png"/></figure><p>这个节点只有一个子枝，就不需要对比了。由此找到了最底部的节点 (−4.6,−10.55)。</p><figure><noscript><img src="https://pic1.zhimg.com/v2-9d8a08ddaee0eb951e394d299d58ef48_b.png" data-rawwidth="855" data-rawheight="290" class="origin_image zh-lightbox-thumb" width="855" data-original="https://pic1.zhimg.com/v2-9d8a08ddaee0eb951e394d299d58ef48_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-9d8a08ddaee0eb951e394d299d58ef48_b.png" data-rawwidth="855" data-rawheight="290" class="origin_image zh-lightbox-thumb lazy" width="855" data-original="https://pic1.zhimg.com/v2-9d8a08ddaee0eb951e394d299d58ef48_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-9d8a08ddaee0eb951e394d299d58ef48_b.png"/></figure><p>在二维图上是</p><figure><noscript><img src="https://pic1.zhimg.com/v2-7a61c7bca0cfe8f74266531bd243b970_b.png" data-rawwidth="856" data-rawheight="576" class="origin_image zh-lightbox-thumb" width="856" data-original="https://pic1.zhimg.com/v2-7a61c7bca0cfe8f74266531bd243b970_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-7a61c7bca0cfe8f74266531bd243b970_b.png" data-rawwidth="856" data-rawheight="576" class="origin_image zh-lightbox-thumb lazy" width="856" data-original="https://pic1.zhimg.com/v2-7a61c7bca0cfe8f74266531bd243b970_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-7a61c7bca0cfe8f74266531bd243b970_b.png"/></figure><p>此时我们执行 (二)。将当前结点标记为访问过，并记录下 L=[(−4.6,−10.55)]。啊，访问过的节点就在二叉树上显示为被划掉的好了。</p><p>然后执行 (三)，嗯，不是最顶端节点。好，执行 (a)，我爬。上面的是 (−6.88,−5.4)。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-8d3a25b7916bb486e5a25b956d046e09_b.png" data-rawwidth="843" data-rawheight="274" class="origin_image zh-lightbox-thumb" width="843" data-original="https://pic2.zhimg.com/v2-8d3a25b7916bb486e5a25b956d046e09_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-8d3a25b7916bb486e5a25b956d046e09_b.png" data-rawwidth="843" data-rawheight="274" class="origin_image zh-lightbox-thumb lazy" width="843" data-original="https://pic2.zhimg.com/v2-8d3a25b7916bb486e5a25b956d046e09_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-8d3a25b7916bb486e5a25b956d046e09_b.png"/></figure><figure><noscript><img src="https://pic1.zhimg.com/v2-4f17d3c005170962bb6e275c16796e24_b.png" data-rawwidth="884" data-rawheight="585" class="origin_image zh-lightbox-thumb" width="884" data-original="https://pic1.zhimg.com/v2-4f17d3c005170962bb6e275c16796e24_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-4f17d3c005170962bb6e275c16796e24_b.png" data-rawwidth="884" data-rawheight="585" class="origin_image zh-lightbox-thumb lazy" width="884" data-original="https://pic1.zhimg.com/v2-4f17d3c005170962bb6e275c16796e24_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-4f17d3c005170962bb6e275c16796e24_b.png"/></figure><br/><p>执行 (1)，因为我们记录下的点只有一个，小于 k=3，所以也将当前节点记录下，有 L=[(−4.6,−10.55),(−6.88,−5.4)]。再执行 (2)，因为当前节点的左枝是空的，所以直接跳过，回到步骤 (三)。(三) 看了一眼，好，不是顶部，交给你了，(a)。于是乎 (a) 又往上爬了一节。</p><figure><noscript><img src="https://pic4.zhimg.com/v2-5854bc728f56786464550a8e75878857_b.png" data-rawwidth="840" data-rawheight="281" class="origin_image zh-lightbox-thumb" width="840" data-original="https://pic4.zhimg.com/v2-5854bc728f56786464550a8e75878857_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-5854bc728f56786464550a8e75878857_b.png" data-rawwidth="840" data-rawheight="281" class="origin_image zh-lightbox-thumb lazy" width="840" data-original="https://pic4.zhimg.com/v2-5854bc728f56786464550a8e75878857_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-5854bc728f56786464550a8e75878857_b.png"/></figure><figure><noscript><img src="https://pic1.zhimg.com/v2-cb82f973279acd241aff5d13a7bf87d0_b.png" data-rawwidth="884" data-rawheight="590" class="origin_image zh-lightbox-thumb" width="884" data-original="https://pic1.zhimg.com/v2-cb82f973279acd241aff5d13a7bf87d0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-cb82f973279acd241aff5d13a7bf87d0_b.png" data-rawwidth="884" data-rawheight="590" class="origin_image zh-lightbox-thumb lazy" width="884" data-original="https://pic1.zhimg.com/v2-cb82f973279acd241aff5d13a7bf87d0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-cb82f973279acd241aff5d13a7bf87d0_b.png"/></figure><br/><p>(1) 说，由于还是不够三个点，于是将当前点也记录下，有 L=[(−4.6,−10.55),(−6.88,−5.4),(1.24,−2.86)]。当然，当前结点变为被访问过的。</p><p>(2) 又发现，当前节点有其他的分枝，并且经计算得出 p 点和 L 中的三个点的距离分别是 6.62,5.89,3.10，但是 p 和当前节点的分割线的距离只有 2.14，小于与 L 的最大距离：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-a01f7dffd35b38df9493cd0b7360b535_b.png" data-rawwidth="863" data-rawheight="585" class="origin_image zh-lightbox-thumb" width="863" data-original="https://pic2.zhimg.com/v2-a01f7dffd35b38df9493cd0b7360b535_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-a01f7dffd35b38df9493cd0b7360b535_b.png" data-rawwidth="863" data-rawheight="585" class="origin_image zh-lightbox-thumb lazy" width="863" data-original="https://pic2.zhimg.com/v2-a01f7dffd35b38df9493cd0b7360b535_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-a01f7dffd35b38df9493cd0b7360b535_b.png"/></figure><p>因此，在分割线的另一端可能有更近的点。于是我们在当前结点的另一个分枝从头执行 (一)。好，我们在红线这里：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-56b4da466cb574abea0366d888552feb_b.png" data-rawwidth="849" data-rawheight="287" class="origin_image zh-lightbox-thumb" width="849" data-original="https://pic4.zhimg.com/v2-56b4da466cb574abea0366d888552feb_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-56b4da466cb574abea0366d888552feb_b.png" data-rawwidth="849" data-rawheight="287" class="origin_image zh-lightbox-thumb lazy" width="849" data-original="https://pic4.zhimg.com/v2-56b4da466cb574abea0366d888552feb_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-56b4da466cb574abea0366d888552feb_b.png"/></figure><p>要用 p 和这个节点比较 x 坐标:</p><figure><noscript><img src="https://pic1.zhimg.com/v2-be2a942ac8ac45707a9111c90617d904_b.png" data-rawwidth="865" data-rawheight="579" class="origin_image zh-lightbox-thumb" width="865" data-original="https://pic1.zhimg.com/v2-be2a942ac8ac45707a9111c90617d904_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-be2a942ac8ac45707a9111c90617d904_b.png" data-rawwidth="865" data-rawheight="579" class="origin_image zh-lightbox-thumb lazy" width="865" data-original="https://pic1.zhimg.com/v2-be2a942ac8ac45707a9111c90617d904_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-be2a942ac8ac45707a9111c90617d904_b.png"/></figure><p>p 的 x 坐标更大，因此探索右枝 (1.75,12.26)，并且发现右枝已经是最底部节点，因此启动 (二)。</p><figure><noscript><img src="https://pic4.zhimg.com/v2-b8db607ac1bf959400af30808a0cc97f_b.png" data-rawwidth="833" data-rawheight="283" class="origin_image zh-lightbox-thumb" width="833" data-original="https://pic4.zhimg.com/v2-b8db607ac1bf959400af30808a0cc97f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-b8db607ac1bf959400af30808a0cc97f_b.png" data-rawwidth="833" data-rawheight="283" class="origin_image zh-lightbox-thumb lazy" width="833" data-original="https://pic4.zhimg.com/v2-b8db607ac1bf959400af30808a0cc97f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-b8db607ac1bf959400af30808a0cc97f_b.png"/></figure><p>经计算，(1.75,12.26) 与 pp 的距离是 17.48，要大于 p 与 L 的距离，因此我们不将其放入记录中。</p><figure><noscript><img src="https://pic3.zhimg.com/v2-e0199d17de9f647b7768126c1d98791a_b.png" data-rawwidth="860" data-rawheight="576" class="origin_image zh-lightbox-thumb" width="860" data-original="https://pic3.zhimg.com/v2-e0199d17de9f647b7768126c1d98791a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-e0199d17de9f647b7768126c1d98791a_b.png" data-rawwidth="860" data-rawheight="576" class="origin_image zh-lightbox-thumb lazy" width="860" data-original="https://pic3.zhimg.com/v2-e0199d17de9f647b7768126c1d98791a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-e0199d17de9f647b7768126c1d98791a_b.png"/></figure><p>然后 (三) 判断出不是顶端节点，呼出 (a)，爬。</p><figure><noscript><img src="https://pic1.zhimg.com/v2-46794560a6274592f951607d11f6e920_b.png" data-rawwidth="851" data-rawheight="293" class="origin_image zh-lightbox-thumb" width="851" data-original="https://pic1.zhimg.com/v2-46794560a6274592f951607d11f6e920_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-46794560a6274592f951607d11f6e920_b.png" data-rawwidth="851" data-rawheight="293" class="origin_image zh-lightbox-thumb lazy" width="851" data-original="https://pic1.zhimg.com/v2-46794560a6274592f951607d11f6e920_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-46794560a6274592f951607d11f6e920_b.png"/></figure><p>(1) 出来一算，这个节点与 p 的距离是 4.91，要小于 p与 L 的最大距离 6.62。</p><figure><noscript><img src="https://pic4.zhimg.com/v2-fb51986176499947b997e7b4580ad86b_b.png" data-rawwidth="852" data-rawheight="581" class="origin_image zh-lightbox-thumb" width="852" data-original="https://pic4.zhimg.com/v2-fb51986176499947b997e7b4580ad86b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-fb51986176499947b997e7b4580ad86b_b.png" data-rawwidth="852" data-rawheight="581" class="origin_image zh-lightbox-thumb lazy" width="852" data-original="https://pic4.zhimg.com/v2-fb51986176499947b997e7b4580ad86b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-fb51986176499947b997e7b4580ad86b_b.png"/></figure><p>因此，我们用这个新的节点替代 L 中离 p最远的 (−4.6,−10.55)。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-27e0502605ec7d67f4af0f968d9785b9_b.png" data-rawwidth="855" data-rawheight="588" class="origin_image zh-lightbox-thumb" width="855" data-original="https://pic2.zhimg.com/v2-27e0502605ec7d67f4af0f968d9785b9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-27e0502605ec7d67f4af0f968d9785b9_b.png" data-rawwidth="855" data-rawheight="588" class="origin_image zh-lightbox-thumb lazy" width="855" data-original="https://pic2.zhimg.com/v2-27e0502605ec7d67f4af0f968d9785b9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-27e0502605ec7d67f4af0f968d9785b9_b.png"/></figure><p>然后 (2) 又来了，我们比对 p 和当前节点的分割线的距离</p><figure><noscript><img src="https://pic2.zhimg.com/v2-5d871d4f96d586ee75e518bd2cdd9df9_b.png" data-rawwidth="857" data-rawheight="587" class="origin_image zh-lightbox-thumb" width="857" data-original="https://pic2.zhimg.com/v2-5d871d4f96d586ee75e518bd2cdd9df9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-5d871d4f96d586ee75e518bd2cdd9df9_b.png" data-rawwidth="857" data-rawheight="587" class="origin_image zh-lightbox-thumb lazy" width="857" data-original="https://pic2.zhimg.com/v2-5d871d4f96d586ee75e518bd2cdd9df9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-5d871d4f96d586ee75e518bd2cdd9df9_b.png"/></figure><p>这个距离小于 L 与 p 的最小距离，因此我们要到当前节点的另一个枝执行 (一)。当然，那个枝只有一个点，直接到 (二)。</p><figure><noscript><img src="https://pic1.zhimg.com/v2-cde69114f2f2b99dfb8a523894254400_b.png" data-rawwidth="844" data-rawheight="279" class="origin_image zh-lightbox-thumb" width="844" data-original="https://pic1.zhimg.com/v2-cde69114f2f2b99dfb8a523894254400_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-cde69114f2f2b99dfb8a523894254400_b.png" data-rawwidth="844" data-rawheight="279" class="origin_image zh-lightbox-thumb lazy" width="844" data-original="https://pic1.zhimg.com/v2-cde69114f2f2b99dfb8a523894254400_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-cde69114f2f2b99dfb8a523894254400_b.png"/></figure><p>计算距离发现这个点离 p 比 L 更远，因此不进行替代。</p><figure><noscript><img src="https://pic3.zhimg.com/v2-e4119f20ed6a3f7bd09886d3e630f70a_b.png" data-rawwidth="862" data-rawheight="585" class="origin_image zh-lightbox-thumb" width="862" data-original="https://pic3.zhimg.com/v2-e4119f20ed6a3f7bd09886d3e630f70a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-e4119f20ed6a3f7bd09886d3e630f70a_b.png" data-rawwidth="862" data-rawheight="585" class="origin_image zh-lightbox-thumb lazy" width="862" data-original="https://pic3.zhimg.com/v2-e4119f20ed6a3f7bd09886d3e630f70a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-e4119f20ed6a3f7bd09886d3e630f70a_b.png"/></figure><p>(三) 发现不是顶点，所以呼出 (a)。我们向上爬，</p><figure><noscript><img src="https://pic1.zhimg.com/v2-db2175252b5828fd578b00672a3ccd14_b.png" data-rawwidth="838" data-rawheight="272" class="origin_image zh-lightbox-thumb" width="838" data-original="https://pic1.zhimg.com/v2-db2175252b5828fd578b00672a3ccd14_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-db2175252b5828fd578b00672a3ccd14_b.png" data-rawwidth="838" data-rawheight="272" class="origin_image zh-lightbox-thumb lazy" width="838" data-original="https://pic1.zhimg.com/v2-db2175252b5828fd578b00672a3ccd14_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-db2175252b5828fd578b00672a3ccd14_b.png"/></figure><p>这个是已经访问过的了，所以再来（a），</p><figure><noscript><img src="https://pic1.zhimg.com/v2-1e3034c11f18aa78cc33ae8abe8a5ae4_b.png" data-rawwidth="848" data-rawheight="286" class="origin_image zh-lightbox-thumb" width="848" data-original="https://pic1.zhimg.com/v2-1e3034c11f18aa78cc33ae8abe8a5ae4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-1e3034c11f18aa78cc33ae8abe8a5ae4_b.png" data-rawwidth="848" data-rawheight="286" class="origin_image zh-lightbox-thumb lazy" width="848" data-original="https://pic1.zhimg.com/v2-1e3034c11f18aa78cc33ae8abe8a5ae4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-1e3034c11f18aa78cc33ae8abe8a5ae4_b.png"/></figure><p>好，（a）再爬，</p><figure><noscript><img src="https://pic2.zhimg.com/v2-60fe0842058da7013a721f1962134441_b.png" data-rawwidth="846" data-rawheight="289" class="origin_image zh-lightbox-thumb" width="846" data-original="https://pic2.zhimg.com/v2-60fe0842058da7013a721f1962134441_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-60fe0842058da7013a721f1962134441_b.png" data-rawwidth="846" data-rawheight="289" class="origin_image zh-lightbox-thumb lazy" width="846" data-original="https://pic2.zhimg.com/v2-60fe0842058da7013a721f1962134441_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-60fe0842058da7013a721f1962134441_b.png"/></figure><p>啊！到顶点了。所以完了吗？当然不，还没轮到 (三) 呢。现在是 (1) 的回合。</p><p>我们进行计算比对发现顶端节点与p的距离比L还要更远，因此不进行更新。</p><figure><noscript><img src="https://pic3.zhimg.com/v2-35c6314838a929e9f403f7665806cc0a_b.png" data-rawwidth="851" data-rawheight="583" class="origin_image zh-lightbox-thumb" width="851" data-original="https://pic3.zhimg.com/v2-35c6314838a929e9f403f7665806cc0a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-35c6314838a929e9f403f7665806cc0a_b.png" data-rawwidth="851" data-rawheight="583" class="origin_image zh-lightbox-thumb lazy" width="851" data-original="https://pic3.zhimg.com/v2-35c6314838a929e9f403f7665806cc0a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-35c6314838a929e9f403f7665806cc0a_b.png"/></figure><p>然后是 (2)，计算 p 和分割线的距离发现也是更远。</p><figure><noscript><img src="https://pic4.zhimg.com/v2-704cbc9285a697b8ca5f611de854dda3_b.png" data-rawwidth="862" data-rawheight="582" class="origin_image zh-lightbox-thumb" width="862" data-original="https://pic4.zhimg.com/v2-704cbc9285a697b8ca5f611de854dda3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-704cbc9285a697b8ca5f611de854dda3_b.png" data-rawwidth="862" data-rawheight="582" class="origin_image zh-lightbox-thumb lazy" width="862" data-original="https://pic4.zhimg.com/v2-704cbc9285a697b8ca5f611de854dda3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-704cbc9285a697b8ca5f611de854dda3_b.png"/></figure><p>因此也不需要检查另一个分枝。</p><p>然后执行 (三)，判断当前节点是顶点，因此计算完成！输出距离 pp 最近的三个样本是 L=[(−6.88,−5.4),(1.24,−2.86),(−2.96,−2.5)]。</p><p>结语</p><p>kd 树的 kNN 算法节约了很大的计算量（虽然这点在少量数据上很难体现），但在理解上偏于复杂，希望本篇中的实例可以让读者清晰地理解这个算法。喜欢动手的读者可以尝试自己用代码实现 kd 树算法，但也可以用现成的机器学习包 scikit-learn 来进行计算。量化课堂的下一篇文章就将讲解如何用 scikit-learn 进行 kNN 分类。</p><p>到JoinQuant查看策略并与作者交流讨论：<a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//www.joinquant.com/post/2843%3Ff%3Dzh" target="_blank" rel="nofollow noreferrer">【量化课堂】kd 树算法之详细篇</a></p><p>JoinQuant量化交易社区 &gt;&gt; <a href="https://link.zhihu.com/?target=https%3A//www.joinquant.com/algorithm/live/shareList%3Ff%3Dzh%26m%3D23083686" class=" wrap external" target="_blank" rel="nofollow noreferrer">策略擂台</a> 栏目前4名展示：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-e48336c5bc38518aede4d5f9c17e4565_b.png" data-rawwidth="750" data-rawheight="821" class="origin_image zh-lightbox-thumb" width="750" data-original="https://pic2.zhimg.com/v2-e48336c5bc38518aede4d5f9c17e4565_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-e48336c5bc38518aede4d5f9c17e4565_b.png" data-rawwidth="750" data-rawheight="821" class="origin_image zh-lightbox-thumb lazy" width="750" data-original="https://pic2.zhimg.com/v2-e48336c5bc38518aede4d5f9c17e4565_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-e48336c5bc38518aede4d5f9c17e4565_b.png"/></figure>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
