<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>柯里化的前生今世（一）：函数面面观</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34060802">原文</a></p>
<h2><b>关于</b></h2><p>本文作为开篇，介绍了出场人物，并形象化的引入了高阶函数，<br>得到了柯里化的概念。</p><p>后续文章，会介绍高阶函数的实现方式，词法作用域和闭包，参数化类型，类型上的柯里化，<br>敬请期待。</p><p><b>注：</b>由于某些不可名状的历史原因，写作目的<b>居然</b>放在了<a href="https://zhuanlan.zhihu.com/p/34064164">第四篇</a>末尾“关于写作意图”一节。。<br>所以，如果你想知道我为什么要写这些东西，请参考第四篇。。<br>来跟我一起<b>穿越</b><a href="https://zhuanlan.zhihu.com/p/34064164">过去</a>。。<br><br>哈哈，不想多说了。。哈哈，让我再笑一会。。 _(:зゝ∠)_</p><h2><b>人物介绍</b></h2><p><b>球星库里</b></p><img src="https://pic2.zhimg.com/v2-8a110ad50cc45d363fbde22a470c7119_r.jpg" data-caption="" data-size="normal" data-rawwidth="220" data-rawheight="139"><p>库里，Stephen Curry，1988年3月14日出生于美国俄亥俄州阿克伦（Akron, Ohio），<br>美国职业篮球运动员，司职控球后卫，效力于NBA金州勇士队。</p><p>斯蒂芬·库里2009年通过选秀进入NBA后一直效力于勇士队，新秀赛季入选最佳新秀第一阵容；<br>2014-15赛季随勇士队获得NBA总冠军；<br>两次当选常规赛MVP，两次入选最佳阵容第一阵容，三次入选全明星赛西部首发阵容。</p><p><b>Haskell Curry</b></p><img src="https://pic1.zhimg.com/v2-e2cbfdc8634bfc6c242cef9b17e65242_r.jpg" data-caption="" data-size="normal" data-rawwidth="90" data-rawheight="109"><p>这次我们说的不是NBA的库里，而是美国著名的数学家，逻辑学家Haskell Curry，它在组合子逻辑方面有杰出贡献。<br>Curry本科就读于哈佛大学医学专业，业余选修了数学，1917年转到了数学系。<br>毕业后，在通用电气找到了一份电气工程师工作，继续在麻省理工进修电气工程，但意识到自己更适合做理论研究，而非应用科学。<br>1922年转专业到了物理学，但物理学哈佛会更好些，于是作为助教回到了哈佛，1924年拿到了物理硕士学位。<br>随后，在哈佛攻读数学博士学位。</p><p>1924年，他最开始的研究方向是微分方程理论，与此同时他接触了一些逻辑学。<br>阅读了罗素和怀特海的《数学原理》之后，他产生了使用组合子来分析代换规则的设想。<br>于是，放弃了微分方程的研究，准备撰写一篇逻辑方面的博士论文。<br>1929年，他的第一篇论文《逻辑代换的分析》在《美国数学报》发表。</p><p>之后，Curry在宾夕法尼亚大学担任教员直至1966年退休，期间曾担任国家研究委员，普林斯顿的高级学会会员。<br>发表的论文包括，《组合子逻辑的全称量词》《组合子理论的补遗》《显式变量的组合逻辑观点》《组合逻辑中相等性及推导的几个性质》。<br>1942年，Curry作为符号逻辑学会会长，发表了离职演说《数理逻辑的组合子基础》。<br>Curry阐明了组合子逻辑与Chruch的lambda演算之间的密切联系，<br>建立了一套类似于Church和Rosser的完备系统。</p><p>第二次世界大战期间，Curry又开始研究应用数学，1943年发表了《Heaviside演算》。<br>1946年，Curry在应用物理实验室工作后，去了阿伯丁实验场，发布了《使用ENIAC的逆向插值法研究》和《使用ENIAC的四阶插值法研究》。</p><p>主要著作有，《组合逻辑》和《数理逻辑基础》。<br>（<b>注：</b>这里说的这么仔细，是有原因的。组合子逻辑和lambda演算 ，我们多多少少也会提到。</p><h2><b>柯里化</b></h2><p><b>名字的由来</b></p><p>以下是维基百科关于Currying的定义：<br>In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.</p><p>Currying这个概念，首先是由Gottlob Frege引入的，以逻辑学家Haskell Curry命名。<br>虽然，这个概念是Moses Schönfinkel发明的。</p><p><b>表达式的值和类型</b></p><img src="https://pic1.zhimg.com/v2-79d4dc4eef668863d67af133cad32dce_r.jpg" data-caption="" data-size="normal" data-rawwidth="147" data-rawheight="185"><p>为了说明Currying我们先引入类型的概念。<br>我们知道编程语言中的表达式是有值的，我们常说，表达式的值为<code class="inline">1</code>，值为<code class="inline">'a'</code>。<br>他们在内存中的存储方式是一样的，都是二进制方式。</p><p>但是，感觉上，他们应该是不同的东西，于是，我们用不同的类型加以区分。<br>我们称值<code class="inline">1</code>的类型是<code class="inline">Int</code>，整型，<br>值<code class="inline">'a'</code>的类型是<code class="inline">Char</code>，字符型。</p><p>于是，我们就在值的概念上建立了一层抽象，不同的值因此有了不同的属性。<br>用数学语言来说，类型作为值集上的一种等价关系，诱导出了对该值集的一种划分，<br>相同类型的值构成了一个等价类。<br>（<b>注：</b>我们后面将会看到函数类型的引入，让事情变得不是这么简单了。</p><p><b>函数面面观</b></p><p>函数用来将一个或多个值变成另一个值，函数也是一种值，它同样具有类型。<br>例如，加法函数<code class="inline">add</code>是把两个整型值变成一个整型值，假如我们已经定义好了<code class="inline">add</code>函数，我们可以这样调用它。</p><p>（<b>注：</b>我们这里使用的编程语言，函数调用是不用加括号的，具有最高优先级。<code class="inline">add 1 2</code>类似于<code class="inline">add(1,2)</code>。</p><code lang="haskell">add 1 2
= 3</code><p>现在我们考虑一个问题，如果我们只给<code class="inline">add</code>提供一个参数，结果是什么呢？<br>即，<code class="inline">add 1</code>是什么？</p><img src="https://pic2.zhimg.com/v2-6d272f983c75866de0725ef21304f0a6_r.jpg" data-caption="" data-size="normal" data-rawwidth="196" data-rawheight="284"><p>我们可以形象化的这样考虑，先考虑<code class="inline">add</code>，<br><code class="inline">add</code>就像一台有两个插槽的机器，<br>如果两个插槽分别提供了<code class="inline">1</code>和<code class="inline">2</code>，那么它会弹出结果<code class="inline">3</code>。</p><p>问，如果只有一个插槽提供了<code class="inline">1</code>，那它是什么？<br>很显然，它还是一台机器，只不过只有一个插槽罢了。<br>因此，<code class="inline">add 1</code>还是一个函数，只不过它只接受一个参数罢了，<br>它返回参数值加<code class="inline">1</code>的结果，它的类型我们可以记为，</p><code lang="haskell">add 1 :: Int -&gt; Int</code><p>我们再回过头来考虑<code class="inline">add</code>的类型，我们看到，<br><code class="inline">add</code>接受<code class="inline">1</code>作为参数，返回<code class="inline">add 1</code>这个函数。<br>因此，我们对<code class="inline">add</code>就有另外一种看法了，<br>它是一台有一个插槽的机器，接受参数<code class="inline">1</code>后，<br>弹出的结果是另一台有一个插槽的机器<code class="inline">add 1</code>。</p><p>因此<code class="inline">add</code>的类型我们可以记为，</p><code lang="haskell">add :: Int -&gt; (Int -&gt; Int)</code><p>为了书写方便，我们假定<code class="inline">-&gt;</code>具有右结合律，因此，</p><code lang="haskell">add :: Int -&gt; Int -&gt; Int</code><p><b>高阶函数</b></p><p>事实上，Currying指的是这样的一个高阶函数，</p><code lang="haskell">curry :: ((a, b) -&gt; c) -&gt; (a -&gt; b -&gt; c)</code><p>它把函数<code class="inline">f</code>变成函数<code class="inline">g</code>，</p><code lang="haskell">f :: ((a, b) -&gt; c)
g :: a -&gt; b -&gt; c

g = curry f
f = uncurry g</code><p>使得任意的x，y，满足，</p><code lang="haskell">f (x, y) = g x y</code><hr><h2><b>参考</b></h2><p><a href="http://zoomq.qiniudn.com/ZQScrapBook/ZqFLOSS/data/20120221141634/">柯里生平</a> <br><a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a> <br><a href="https://en.wikipedia.org/wiki/Currying">Currying</a> <br><a href="https://wiki.haskell.org/Currying">Currying - HaskellWiki</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
