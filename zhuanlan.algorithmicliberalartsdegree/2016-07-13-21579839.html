<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Hypergraph st-最小割</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/21579839">原文</a></p>
刚刚submit了点和<a href="https://en.wikipedia.org/wiki/Hypergraph" data-editable="true" data-title="hypergraph">hypergraph</a>有关的东西给SODA 2017(更新: 也被accepted了), 我<a href="http://web.engr.illinois.edu/~chaoxu3/" data-editable="true" data-title="主页" class="">主页</a>可以看到.<p>一些我们发现了但是感觉不足挂齿的结果, 也就没有写进去. 其中一个是hypergraph <equation>st</equation>-最小割问题: 在hypergraph <equation>H</equation>上删除最少的边, 使得<equation>s</equation>和<equation>t</equation>不联通. 以前各种文章里出现的做法都是下面这样的:</p><ol><li>转换这个hypergraph到<a href="https://en.wikipedia.org/wiki/Hypergraph#Bipartite_graph_model" data-title="incidence graph" class="" data-editable="true">incidence graph</a>. 每个代表边的顶点都有capacity 1.<br></li><li>拆顶点, 获得有向图 <equation>G</equation><br></li><li>跑st最大流在<equation>G</equation>上.<br></li></ol><br><p>这个方法也能用在有权值的hypergraph上. 假如<equation>H</equation>有<equation>n</equation>个顶点, <equation>m</equation>个边, 顶点的度之和为<equation>p</equation>. 则<equation>G</equation>有<equation>O(n+m)</equation>个顶点, <equation>O(p)</equation>个边. 跑最大流要<equation>O((n+m) p)</equation>的时间, 而<equation>m</equation>可能比<equation>n</equation>大很多. 很多文章里也就把这个速度做为最好的速度了. 似乎里面也有人问这是否是最优的.</p><p>有意思的是好像并没有人知道(或者知道也懒得写出来)实际上可以做的更好.</p><p>有一个简单的<a href="https://en.wikipedia.org/wiki/Dinic%27s_algorithm" data-title="Dinic's algorithm" class="" data-editable="true">Dinic's algorithm</a> + <a href="https://en.wikipedia.org/wiki/Link/cut_tree" data-editable="true" data-title="dynamic tree" class="">dynamic tree</a>的最大流算法算法. (Sleator and Tarjan 1982), 叫这个算法A的话.<br></p><blockquote><p><b>Theorem</b>:  用算法A, <equation>G</equation>上最大流可以在<equation>\tilde{O}(np)</equation>时间算出.</p><p><i>Proof</i>: <equation>G</equation>里最长的路径的长度是<equation>O(n)</equation>, 每一次blocking flow, <equation>s</equation>和<equation>t</equation>的距离增加至少1. 所以最多<equation>O(n)</equation>次blocking flow, 而每一次blocking flow可以<equation>\tilde{O}(p)</equation>时间做到.</p></blockquote><p>我们感觉这个很trivial而且和我们文章没啥关系就懒得指出了.</p><blockquote><b>Remark</b> 当然, 有时候指出一些"显然易见"的东西还是会帮助一些其他人的. 有一些人在研究一些网络安全的东西的时候, 遇到了一个优化问题. 他们的解法是用integer program或者heuristic. 而Yamaguchi等人发现了这问题不过是hypergraph最小割问题... 于是指出来了并且发在了一个IF 4+的地方. 哈哈哈这可是理论人想都不敢想的. (这里提到IF纯属搞笑. 不代表作者的任何观点.). [<a href="http://www-sys.ist.osaka-u.ac.jp/~ymgc/slide/SGC2014.pdf" data-editable="true" data-title="slides">slides</a>].</blockquote><br><blockquote>P.S. 有时候我也想知道其他领域有没有啥东西我可以去帮忙解决.</blockquote>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
