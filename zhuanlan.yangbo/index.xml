<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>杨博的长答案</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Tue, 01 Jan 2019 06:44:43 +0800</lastBuildDate>
<item>
<title>你觉得Binding.scala好不好啊？</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2018-05-28-24669230.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24669230&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/Binding.scala&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Binding.scala&lt;/a&gt;是Scala上的数据绑定框架，如果配合Scala.js，可以作为前端框架使用。本文收集了全球用户对Binding.scala的反馈。&lt;/p&gt;&lt;p&gt;Ólafur Páll Geirsson:&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;Hi，我只想对 &lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/people/atry&quot; class=&quot;internal&quot;&gt;@杨博&lt;/a&gt;&lt;br&gt; 你说声谢谢，Binding.scala 真棒！我花了一会儿功夫让脑子绕清楚`.bind`的用法和时机。但一旦搞清楚了，前端（包括路由和其他很酷的功能）开发过程就变得非常直截了当。&lt;br&gt;TodoMVC对新手上手来说是个极好的例子。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D57bc5dd087f779f0691f0b2a&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gitter.im/ThoughtWorksI&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;nc/Binding.scala?at=57bc5dd087f779f0691f0b2a&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Justin Maat:&lt;/p&gt;&lt;blockquote&gt;Binding.scala感觉非常简单，不像其他库那么复杂&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D5720f1cb9b4160fa760a6470&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gitter.im/ThoughtWorksI&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;nc/Binding.scala?at=5720f1cb9b4160fa760a6470&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;dafcok:&lt;/p&gt;&lt;blockquote&gt;感觉Binding.scala精简至极。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.reddit.com/r/scala/comments/4dvsbn/announcing_bindingscala_a_reactive_web_framework/d1vui5n&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;reddit.com/r/scala/comm&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ents/4dvsbn/announcing_bindingscala_a_reactive_web_framework/d1vui5n&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Milad Khajavi:&lt;/p&gt;&lt;blockquote&gt;感谢你，我发现Binding.scala和我见过的其他框架相比，Binding.scala非常简单。伟大的作品。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D581bf9952d4796175f4015ba&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gitter.im/ThoughtWorksI&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;nc/Binding.scala?at=581bf9952d4796175f4015ba&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;Binding.scala之简洁，远超其他数据绑定框架，还支持XML字面量。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//twitter.com/khajavi/status/819885381621518338&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;twitter.com/khajavi/sta&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;tus/819885381621518338&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Philip Stutz:&lt;/p&gt;&lt;blockquote&gt;嘿杨兄，Binding.scala真的很酷，是迄今为止web应用的客户端开发最最方便的方式。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D57bacaddbb6fad403cf53794&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gitter.im/ThoughtWorksI&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;nc/Binding.scala?at=57bacaddbb6fad403cf53794&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Markus Herrmann:&lt;/p&gt;&lt;blockquote&gt;真的很酷！Binding.scala——Scala数据绑定框架&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//twitter.com/datalabrat/status/765483174587670529&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;twitter.com/datalabrat/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;status/765483174587670529&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Rahel Lüthy:&lt;/p&gt;&lt;blockquote&gt;Binding.scala——ThoughtWorks的reactive web框架，感觉极其简洁&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//twitter.com/netzwerg999/status/718751672974118912&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;twitter.com/netzwerg999&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/status/718751672974118912&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Adam Hibble:&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//twitter.com/thoughtworks&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;@thoughtworks&lt;/a&gt; Binding.scala简单极了。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//twitter.com/Algomancer/status/783445081927720960&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;twitter.com/Algomancer/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;status/783445081927720960&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;我真的很喜欢用Binding.scala做些小巧、可重用、可隔离的组件。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.reddit.com/r/scala/comments/55whc1/a_really_simple_full_stack_scala_starter_with/d8g58bh&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;reddit.com/r/scala/comm&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ents/55whc1/a_really_simple_full_stack_scala_starter_with/d8g58bh&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Walfie:&lt;/p&gt;&lt;blockquote&gt;在我使用Binding.scala至今，绝大多数时间 Binding.scala 都给了我丝般柔顺的体验。多亏有了Binding.scala&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//twitter.com/walfieee/status/778365304355291136&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;twitter.com/walfieee/st&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;atus/778365304355291136&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;jfilali:&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/Atry&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;@Atry&lt;/a&gt; Binding.scala 看起来真伟大。恭喜。你的所作所为是真正的创新。以前，我评估了各种库的品质时、搭建了开发环境，包括scala-react、material-ui的包装库、material-ui的JavaScript依赖、diode、JavaScript打包、JavaScript依赖。现在，我怀疑所有这些工作还有什么价值。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D584d355628d755bf14ef4a3a&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gitter.im/ThoughtWorksI&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;nc/Binding.scala?at=584d355628d755bf14ef4a3a&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;（……关于Binding.scala支持定制XML组件）让我能乐上一整天。实际上我已经把Binding.scala和flux/Model用在一起了。尽管底层是可变模型，一样能运转得很好。我遵守以下编码风格：利用容器连接存储和视觉组件，组件接受的参数都是Binding[Node]对象。我发现这种方式可伸缩性非常好。&lt;br&gt;目前我需要写几篇博客，但至今我体验到Binding.scala真的非常好。我的生产力大大提高。我以前写了个ReactJS项目花了两个月，react-scala-js项目花了一个月，而Binding.scala项目只用两周。&lt;br&gt;不久以后我会写一篇博客谈谈我的经验。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D5879bd26074f7be763cc550f&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gitter.im/ThoughtWorksI&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;nc/Binding.scala?at=5879bd26074f7be763cc550f&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Pedro Larroy:&lt;/p&gt;&lt;blockquote&gt;Binding.scala是Scala的reactive web应用库，比ReactJS易用。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//twitter.com/plarroy/status/715955108928962561&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;twitter.com/plarroy/sta&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;tus/715955108928962561&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;chris-tek:&lt;/p&gt;&lt;blockquote&gt;我以前学过ELM、Scala.js+diode，最近开始调研Scala.js+Binding.scala，构建纯粹完全响应式的GUI。&lt;br&gt;现在我已经有些阶段性成果，成功让GUI和后端（RabbitMQ + stomp，websocket协议）交换数据。不可思议，程序运行得非同寻常的棒。&lt;br&gt;Binding.scala那坨代码写得真好。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D57c69070ca24c06c638a5ff5&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gitter.im/ThoughtWorksI&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;nc/Binding.scala?at=57c69070ca24c06c638a5ff5&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Anthony Homan:&lt;/p&gt;&lt;blockquote&gt;Binding.scala绝对是最卓越的！我承认我才刚刚开始接触Binding.scala，但即便如此，Binding.scala真真是我寻觅已久的那块拼板，让Scala.js真正值得投资。&lt;br&gt;我会继续试着把我现有的AngularJS（前端）/Scala（后端）应用，移植到全栈Scala上，用Scala.js和Binding.scala代替AngularJS。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//groups.google.com/d/msg/scala-js/xJsjE-zFeuk/gqIgTXi2AwAJ&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;groups.google.com/d/msg&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/scala-js/xJsjE-zFeuk/gqIgTXi2AwAJ&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Simone Scarduzio:&lt;/p&gt;&lt;blockquote&gt;今天涨点知识：Binding.scala，用Scala代替ReactJS的明智选择&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//twitter.com/s_scarduzio/status/763501825484087300&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;twitter.com/s_scarduzio&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/status/763501825484087300&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-05-28-24669230</guid>
<pubDate>Mon, 28 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>有人知道Java异常声明的正确用法吗？</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2018-02-09-33731510.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33731510&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;王垠十分喜欢Java中的异常声明功能。前段时间，他对Kotlin不支持Checked Exception表示十分失望，写了很长的文章来阐述“Checked Exception的重要性”。王垠的心情我可以理解，异常处理确实很重要，但王垠可能犯了“诉诸动机”的谬误。&lt;/p&gt;&lt;p&gt;因为实践中我没有见过任何库符合王垠理想的Checked Exception用法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;破坏向后兼容性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;按王垠的理论，Checked Exception可以在方法签名上标明具体错误原因，但实践中，每次在签名上增加一个新的异常，都会破坏向后兼容性。对于需要复用的框架和库来说，直接就给这个功能判了死刑。&lt;/p&gt;&lt;p&gt;王垠推荐的 FileNotFoundException 这种写法，实践中举步维艰，现在已经越来越罕见了。&lt;/p&gt;&lt;p&gt;比如说你十年前写了个 naive 的 FileOutputStream 构造函数用来打开文件，会抛 FileNotFoundException。现在你发现其实除了 FileNotFoundException 之外，你还需要处理权限不足的问题，但为了保持向后兼容性又不可能在签名中加入权限不足异常。这时 Checked Exception 就十分尴尬了。&lt;/p&gt;&lt;p&gt;这就是为什么现在 Java 7的 Files.newOutputStream 就只标记为 IOException 而不写FileNotFoundException这种具体类型。&lt;/p&gt;&lt;p&gt;类似的异常还有 SQLException 、 ServletException 等，都不写明具体原因了。很多库明明就算抛了异常，还要在异常里面包装一个errorCode，而不用继承的异常，也是这个缘故。&lt;/p&gt;&lt;p&gt;所以王垠在文章中作为反例的“最糟糕的异常处理代码”，即捕获异常的超类而不捕获具体异常，恰好是实践中所有框架，包括 Java 标准库的做法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Checked Exception和Java标准库自相矛盾&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Checked Exception的本意是类型安全。但是，Java标准库一直以一种不类型安全的方式使用异常,比如我们知道 Java 里有一个 Callable ，长成这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public interface Callable&amp;lt;V&amp;gt; {
  V call() throws Exception;
}&lt;/code&gt;&lt;p&gt;你看，这个接口会抛出一切异常，正好就是王垠所说的“最糟糕的异常处理代码”。换句话说，只要你使用Java标准库，Java标准库就会强迫你写出王垠眼中“最糟糕的异常处理代码”。&lt;/p&gt;&lt;p&gt;实际上 Java 语言本身支持泛型异常，比如 Callable 完全可以设计成这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public interface Callable&amp;lt;V, E extends Exception&amp;gt; {
  V call() throws E;
}&lt;/code&gt;&lt;p&gt;不幸的是，看起来 Java 标准库并没有用这种更安全的设计。&lt;/p&gt;&lt;p&gt;Oracle 收购 Sun 以后，似乎 Checked Exception 越来越被标准库所摒弃。Java 7的Files API 用的还是基类IOException，Java 8的Function、BiFunction，压根就不支持 Checked Exception。如果你要用 Stream API 的话，必须手动在 UncheckedIOException 和 IOException 之间包来包去。&lt;/p&gt;&lt;p&gt;把异常不分青红皂白包装成 RuntimeException 的“设计模式”，早已是 Java 程序员大家都知道的秘密，但标准库中加入 UncheckedIOException 可能算是第一次官方承认这个秘密吧。&lt;/p&gt;&lt;p&gt;&lt;b&gt;结论&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在几乎所有的 Java 框架和库中，包括 Java 标准库，Checked Exception 都从未以王垠理想的方式使用过。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-02-09-33731510</guid>
<pubDate>Fri, 09 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>JVM也是玄学</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2018-01-30-33445689.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33445689&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前段时间， &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/7fa583366d87dfe45694c2057b98cb12&quot; data-hash=&quot;7fa583366d87dfe45694c2057b98cb12&quot; data-hovercard=&quot;p$b$7fa583366d87dfe45694c2057b98cb12&quot;&gt;@陈亮&lt;/a&gt; 发现一件怪事，&lt;a href=&quot;https://www.zhihu.com/question/58735131/answer/158460810&quot;&gt;java循环长度的相同、循环体代码相同的两次for循环的执行时间相差了100倍&lt;/a&gt;！&lt;/p&gt;&lt;p&gt;有些同学说这是因为GC或者cache missing。但我掐指一算，这些同学可能是错的。&lt;/p&gt;&lt;p&gt;因为，就算空跑这么多次循环也不止15毫秒。&lt;/p&gt;&lt;p&gt;考虑到15毫秒是Windows里计时器的最小间隔，跑出15毫秒只有一个可能：JVM的优化编译器发现整段循环都没有副作用，于是把整个循环全删了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不过回答装箱拆箱的同学可能沾点边，因为这段代码中，JVM决定是否能把整段循环删掉取决于它怎么分析Integer.valueOf。&lt;/p&gt;&lt;p&gt;在JVM不优化的情况下，每次内层循环会调用Integer.value 8000次，其中有读取7999次缓存，创建1次new Integer。如果JVM把valueOf和new Integer都内联，然后做了逃逸分析的话，new Integer是可以完全优化掉的。&lt;/p&gt;&lt;p&gt;虽然new Integer调用次数很少，但是JVM需要把new Integer内联之后才能分析出整段代码都没有副作用。所以我猜测new Integer是否被内联可能是影响性能的关键因素。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不幸的是，JVM的优化行为，对用户来说很难预测。&lt;/p&gt;&lt;p&gt;比如实际上new Integer的调用次数相当少。由于new Integer不是热点，JVM倾向于不内联new Integer那也不奇怪。&lt;/p&gt;&lt;p&gt;更难预测之处在于，在嵌套函数调用的情况下，JVM先内联里层还是先内联外层也会对优化结果产生影响。本文的例子倒还好说，如果涉及forEach之类的高阶函数调用时，会碰上monomorphic call的问题，虽然外层函数调用次数很少，但必须内联外层才能消除内层的虚函数调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;总而言之，这种代码属于JVM的阴暗角落，就好像C语言里的i+++++i一样恶心。对于应用开发者来说，如果不是特别在乎性能的场合，别碰。甚至说不定升级一下JVM，性能就自动变好了。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-01-30-33445689</guid>
<pubDate>Tue, 30 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>我爱“不可变编程”，但我更爱Binding.scala的Var</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2018-01-26-33314153.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33314153&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/ba3acd2a624b861556652d4454f11608&quot; data-hash=&quot;ba3acd2a624b861556652d4454f11608&quot; data-hovercard=&quot;p$b$ba3acd2a624b861556652d4454f11608&quot;&gt;@蠢毛毛&lt;/a&gt; 最近在Coursera上学习Scala的课程，在一次课程的作业中，有一个函数的实现在Instruction中特别指出使用while循环实现，然而之前的作业中是从未使用while循环的，同样的功能通常使用递归形式或者foreach、map等函数来实现，避开使用变量。&lt;br&gt;这时突然提出要用while循环来做，那就避免不了使用var变量了，然而这完全与函数式编程的理念相悖。于是有小伙伴提出了问题，最后的几张图是教员的回复，大概意思是说Scala中for“循环”会被展开成foreach的调用，中间会有成吨的性能损耗，而且foreach底层实现也是用while循环，干脆直接用while循环算了。。。&lt;br&gt;另外也有小伙伴表示，Scala对与简单for循环没有优化性能极差，是一个众所周知的问题，并甩出了一个ISSUE的链接。。。&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//issues.scala-lang.org/browse/SI-1338&quot;&gt;https://issues.scala-lang.org/browse/SI-1338&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;我推荐的风格是所以情况都不用while和局部变量var，可以用foldLeft和尾递归代替。&lt;/p&gt;&lt;p&gt;foldLeft性能差一点，适合性能不敏感的场合。尾递归性能和while差不多。&lt;/p&gt;&lt;p&gt;可读性上来讲，foldLeft和尾递归不比while差，但可能初学者需要一点时间适应一下。&lt;/p&gt;&lt;p&gt;从保证程序的正确性上讲，无论尾递归还是while都有可能写错，写成死循环，foldLeft却能保证循环的次数，不可能写成死循环。再者，var还有额外的风险，如果写错了的话，可能会不小心改错了值。&lt;/p&gt;&lt;p&gt;所以我推荐所有场合都不用while和局部变量var，一律用foldLeft和尾递归即可。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;我只强调“局部变量var”一律用foldLeft和尾递归代替，是因为类里面的var和可变数据结构更棘手些，不可一概而论。&lt;/p&gt;&lt;p&gt;棘手的原因有三点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;类里的var造成的潜在危害很大，可能在并发或者重入的情况下，导致很难解决的bug。&lt;/li&gt;&lt;li&gt;不容易完全消除类里的var，如果一定要消除，会导致代码变长、性能变差。&lt;/li&gt;&lt;li&gt;如果你本来就是为可变模型建模，用var最顺手。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以，类里的var是架构设计问题，而不只是编码问题。&lt;/p&gt;&lt;p&gt;举个例子，我在&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/Binding.scala&quot;&gt;Binding.scala&lt;/a&gt;中做了一个艰难的设计决策。我让Binding.scala的内部数据在初始构建数据绑定表达式时不可变，但在运行时可变。&lt;/p&gt;&lt;p&gt;我在&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/Binding.scala/blob/9.0.x/README-zh.md%23%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2591%25E5%25AE%259A%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%25E7%259A%2584%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F%25E7%25AE%25A1%25E7%2590%2586&quot;&gt;数据绑定表达式的生命周期管理&lt;/a&gt;一节写到：&lt;/p&gt;&lt;blockquote&gt;简而言之，Binding.scala 将函数分为两类：&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;用户定义的 @dom 方法，用于产生不带副作用的纯函数式的数据绑定表达式。&lt;/li&gt;&lt;li&gt;调用 dom.render 以及 Binding.watch 的函数，自动地管理所有副作用。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可能某些人会诟病Binding.scala的数据模型不够“purity”，因为运行起来会变。&lt;/p&gt;&lt;p&gt;但实际上用起来，这种混合做法却很顺畅。因为用户定义的数据绑定表达式只描述数据之间的关系，而不修改任何变量，所有的变量修改都由Binding.scala框架负责。那么，只要我写的框架没有bug，用户就很难自己写出bug。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-01-26-33314153</guid>
<pubDate>Fri, 26 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用sbt-best-practice为Scala库设置Travis CI上的持续集成和持续交付</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2017-08-17-22371242.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22371242&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github上有很多 Scala 开源库。它们都有自动测试的功能。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如 README 页面上有个小图标（build passing）表示当前版本是否通过了测试。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/8e8fa025d59af31425ede63348dd370a_b.png&quot; data-rawwidth=&quot;2276&quot; data-rawheight=&quot;918&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2276&quot; data-original=&quot;https://pic3.zhimg.com/8e8fa025d59af31425ede63348dd370a_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/8e8fa025d59af31425ede63348dd370a_b.png&quot; data-rawwidth=&quot;2276&quot; data-rawheight=&quot;918&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2276&quot; data-original=&quot;https://pic3.zhimg.com/8e8fa025d59af31425ede63348dd370a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/8e8fa025d59af31425ede63348dd370a_b.png&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;再如，每当有人提交 Pull Request 的时候，也会有个小勾勾报告这次修改能不能通过测试。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/916699913e7dbf3895d424feb3695d19_b.png&quot; data-rawwidth=&quot;2352&quot; data-rawheight=&quot;1404&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2352&quot; data-original=&quot;https://pic2.zhimg.com/916699913e7dbf3895d424feb3695d19_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/916699913e7dbf3895d424feb3695d19_b.png&quot; data-rawwidth=&quot;2352&quot; data-rawheight=&quot;1404&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2352&quot; data-original=&quot;https://pic2.zhimg.com/916699913e7dbf3895d424feb3695d19_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/916699913e7dbf3895d424feb3695d19_b.png&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;还有，这些库还会发布到 Maven 中心仓库，我如果要在自己的项目使用它们的话，只要在自己的 sbt 配置中添加依赖就可以自动下载了。&lt;/p&gt;&lt;p&gt;这些自动测试和发布功能属于持续集成和持续交付，可以用 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//travis-ci.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Travis CI&lt;/a&gt; 和 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/sbt-best-practice&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;sbt-best-practice&lt;/a&gt; 实现。&lt;/p&gt;&lt;p&gt;Travis CI 是个持续集成服务。一旦你的 Github 仓库启用了 Travis CI ，每当有人在仓库推送代码或者提交 Pull Request 时，就会触发 Travis CI 执行一段脚本。&lt;/p&gt;&lt;p&gt;对于 Scala 项目来说，一般用 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.scala-sbt.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;sbt&lt;/a&gt; 管理构建过程，所以我们会希望 Travis CI 被触发以后，执行测试和发布的 sbt 任务。这样就可以完成题主要求的所有功能了。&lt;/p&gt;&lt;p&gt;第一步：启用 Travis CI&lt;/p&gt;&lt;p&gt;Travis CI 的构建过程配置在 .travis.yml 文件中。Scala 库的 .travis.yml 应该写成这样：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# 告诉 Travis CI 应该用已经安装了 Scala 的系统镜像来执行本文件中配置的脚本&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;scala&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 应执行 sbt test 任务来进行自动测试&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;p p-Indicator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;sbt test&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 如果存在 deploy.sbt 文件，就执行 sbt &quot;release with-defaults&quot; 任务来进行自动发布&lt;/span&gt;
&lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;deploy&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;skip_cleanup&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;provider&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;script&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;sbt &quot;release with-defaults&quot;&lt;/span&gt;
  &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;-e ./deploy.sbt&lt;/span&gt;
    &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;all_branches&lt;/span&gt;&lt;span class=&quot;p p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l l-Scalar l-Scalar-Plain&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有了 .travis.yml，你还需要访问&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//travis-ci.org/profile&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;你在 Travis CI 的 Profile 页面&lt;/a&gt;，为 Github 仓库启用 Travis CI。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/bec2d73be3f0489403b57835aebc7221_b.png&quot; data-rawwidth=&quot;684&quot; data-rawheight=&quot;384&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;684&quot; data-original=&quot;https://pic2.zhimg.com/bec2d73be3f0489403b57835aebc7221_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/bec2d73be3f0489403b57835aebc7221_b.png&quot; data-rawwidth=&quot;684&quot; data-rawheight=&quot;384&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;684&quot; data-original=&quot;https://pic2.zhimg.com/bec2d73be3f0489403b57835aebc7221_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/bec2d73be3f0489403b57835aebc7221_b.png&quot;&gt;&lt;/figure&gt;&lt;p&gt;然后，CI 会自动执行 sbt test 测试每次提交。此外，CI 还会检测 deploy.sbt 是否存在，如果存在，就执行 sbt &quot;release with-defaults&quot; 任务来进行自动发布。&lt;/p&gt;&lt;p&gt;第二步：添加 Sbt 插件&lt;/p&gt;&lt;p&gt;sbt test 和 sbt &quot;release with-defaults&quot; 两个任务由 Sbt 插件提供。编辑project/plugins.sbt ，启用 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/sbt-best-practice&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;sbt-best-practice&lt;/a&gt; 插件，这些任务就会自动配置好。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;addSbtPlugin(&quot;com.thoughtworks.sbt-best-practice&quot; % &quot;sbt-best-practice&quot; % &quot;latest.release&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;添加测试框架&lt;/p&gt;&lt;p&gt;对于自动测试，你还需要添加测试框架依赖并编写自己的测试用例。&lt;/p&gt;&lt;p&gt;在 Scala 社区，常用的测试框架有 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//junit.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JUnit&lt;/a&gt; 、&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.scalatest.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ScalaTest&lt;/a&gt;、&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//etorreborre.github.io/specs2/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Specs2&lt;/a&gt; 和 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lihaoyi/utest&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;µTest&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;以 µTest 为例，编辑或创建 build.sbt:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libraryDependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;com.lihaoyi&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;utest&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0.4.3&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;testFrameworks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestFramework&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utest.runner.Framework&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样一来，在 src/test/scala 编写的测试用例就会被 sbt test 所执行了。&lt;/p&gt;&lt;p&gt;第三步：提供自动发布时的项目信息开源许可证&lt;/p&gt;&lt;p&gt;要发布到 Maven 中心仓库的软件必须是开源软件。你需要准备一个 LICENSE 文件。比如我们常用的 Apache License 的内容可以在这里找到：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.apache.org/licenses/LICENSE-2.0&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;apache.org/licenses/LIC&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ENSE-2.0&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;组织名和项目名&lt;/p&gt;&lt;p&gt;当然，你还需要指定库的名称。 sbt 项目用组织名外加项目名的组合作为唯一标识。编辑或创建 build.sbt 设置如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;organizatio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;com.thoughtworks.q&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;q&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;版本号&lt;/p&gt;&lt;p&gt;版本号应该保存在 version.sbt 中：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThisBuild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1.0.0-SNAPSHOT&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第四步：设置自动发布时的密码、密钥等鉴权机制申请 Sonatype 帐号&lt;/p&gt;&lt;p&gt;Maven 中心仓库中的大部分软件都是从 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.sonatype.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Sonatype&lt;/a&gt; 上同步过来的。所以，只要你把项目发布到 Sonatype ，就会自动发布到 Maven 中心仓库。&lt;/p&gt;&lt;p&gt;首先，你需要注册一个 Sonatype 帐号：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//issues.sonatype.org/secure/Signup%21default.jspa&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;issues.sonatype.org/sec&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ure/Signup!default.jspa&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;然后，填写表单，申请权限以发布项目到 Sonatype ：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//issues.sonatype.org/secure/CreateIssue.jspa%3Fissuetype%3D21%26pid%3D10134&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;amp;amp;pid=10134&lt;/a&gt; &lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/b6194475835107f913616c38a663a583_b.png&quot; data-rawwidth=&quot;1072&quot; data-rawheight=&quot;1285&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1072&quot; data-original=&quot;https://pic4.zhimg.com/b6194475835107f913616c38a663a583_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/b6194475835107f913616c38a663a583_b.png&quot; data-rawwidth=&quot;1072&quot; data-rawheight=&quot;1285&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1072&quot; data-original=&quot;https://pic4.zhimg.com/b6194475835107f913616c38a663a583_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/b6194475835107f913616c38a663a583_b.png&quot;&gt;&lt;/figure&gt;&lt;p&gt;你可以参照我申请时的格式来填写：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//issues.sonatype.org/browse/OSSRH-22779&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;issues.sonatype.org/bro&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;wse/OSSRH-22779&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;生成和上传 PGP 密钥&lt;/p&gt;&lt;p&gt;发布到 Sonatype 的软件必须用 PGP 签名。所以你得生成一对 PGP 密钥。&lt;/p&gt;&lt;p&gt;你可以用 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.gnupg.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GnuPG&lt;/a&gt; 来生成密钥。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span&gt;&lt;/span&gt;gpg --gen-key
gpg --export --armor --output pubring.asc
gpg --export-secret-keys --armor --output secring.asc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;填写密钥所需的信息，其中一个步骤需要填写加密口令，直接按回车填写空口令即可。&lt;br&gt;当前目录就会出现私钥文件 secring.asc 和公钥文件 pubring.asc 。&lt;/p&gt;&lt;p&gt;接下来，你需要上传公钥。&lt;/p&gt;&lt;p&gt;访问 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//pgp.mit.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MIT PGP Key Server&lt;/a&gt; ，把 pubring.asc 的内容粘贴到 “Enter ASCII-armored PGP key here:” 处，然后点击“Submit this key to the keyserver!”。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/481bd96062fd239e8a4b124a7a75ada0_b.png&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;1063&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;732&quot; data-original=&quot;https://pic1.zhimg.com/481bd96062fd239e8a4b124a7a75ada0_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/481bd96062fd239e8a4b124a7a75ada0_b.png&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;1063&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;732&quot; data-original=&quot;https://pic1.zhimg.com/481bd96062fd239e8a4b124a7a75ada0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/481bd96062fd239e8a4b124a7a75ada0_b.png&quot;&gt;&lt;/figure&gt;&lt;p&gt;生成 Github Personal Access Token&lt;/p&gt;&lt;p&gt;在发布 Scala 库时， CI 会通过 sbt-best-practice 插件会自动给 Github 仓库中的版本设置一个版本 tag 。&lt;br&gt;所以需要为 CI 设置 Github 仓库的修改权限。这可以通过 Github Personal Access Token 实现。&lt;/p&gt;&lt;p&gt;访问 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/settings/tokens/new&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Sign in to GitHub · GitHub&lt;/a&gt; ，然后填写 Token description 并勾选public_repo 权限。&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/f20404b12f59ccfefef28ef4dbe18262_b.png&quot; data-rawwidth=&quot;1151&quot; data-rawheight=&quot;1190&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1151&quot; data-original=&quot;https://pic3.zhimg.com/f20404b12f59ccfefef28ef4dbe18262_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/f20404b12f59ccfefef28ef4dbe18262_b.png&quot; data-rawwidth=&quot;1151&quot; data-rawheight=&quot;1190&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1151&quot; data-original=&quot;https://pic3.zhimg.com/f20404b12f59ccfefef28ef4dbe18262_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/f20404b12f59ccfefef28ef4dbe18262_b.png&quot;&gt;&lt;/figure&gt;&lt;p&gt;Github 会生成一段类似 74bf3a944382ec8e07625a6e55eb05a416ca585d 的 Personal Access Token 。请保存这段 Personal Access Token 供稍后使用。&lt;/p&gt;&lt;p&gt;创建一个 Secret Gist 保存所有密码和密钥&lt;/p&gt;&lt;p&gt;上述所有的这些密码和密钥都可以通过 Sbt 来设置。但是，我觉得你恐怕不会愿意把你的密码放在公共仓库中。&lt;/p&gt;&lt;p&gt;所以我建议你把密码和密钥放在只有自己才知道的 Secret Gist 中。然后把 Secret Gist 的 URL 设置在 Travis CI 的秘密环境变量中。那么， CI 运行 sbt 任务时，就可以读取环境变量访问 Secret Gist 获得所有这些密码和密钥。&lt;/p&gt;&lt;p&gt;访问 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//gist.github.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gist.github.com/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt; ，点击“Add file”按钮，添加三个文件：&lt;/p&gt;&lt;p&gt;secret.sbt&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 此处应填写刚才生成的 Github Personal Access Token&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;githubCredential&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Global&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PersonalAccessToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;74bf3a944382ec8e07625a6e55eb05a416ca585d&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 此处应填写你刚才注册 Sonatype 时使用的帐号和密码&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;credentials&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Global&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Credentials&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Sonatype Nexus Repository Manager&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;oss.sonatype.org&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;你的 Sonatype 帐号&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;你的 Sonatype 密码&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentDirectory&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sourcecode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getParentFile&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;pgpSecretRing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentDirectory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;secring.asc&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;pgpPublicRing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentDirectory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;pubring.asc&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;pgpPassphrase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;secring.asc&lt;/p&gt;&lt;p&gt;请把 GnuPG 生成的 secring.asc 内容复制到此处。&lt;/p&gt;&lt;p&gt;pubring.asc&lt;/p&gt;&lt;p&gt;请把 GnuPG 生成的 pubring.asc 内容复制到此处。&lt;/p&gt;&lt;p&gt;最后点击“Create secret gist”按钮，生成这个 Secret Gist 。&lt;/p&gt;&lt;p&gt;请记下新生成的 Secret Gist 网址，类似 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//gist.github.com/Atry/xxxxxxxxxxxxxxxxxxxx&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gist.github.com/Atry/xx&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;xxxxxxxxxxxxxxxxxx&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;创建 Travis CI 的秘密环境变量&lt;/p&gt;&lt;p&gt;在你的 Travis CI 项目设置面板中添加 SECRET_GIST 环境变量，设为你刚生成的 Secret Gist 网址 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//gist.github.com/Atry/xxxxxxxxxxxxxxxxxxxx&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gist.github.com/Atry/xx&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;xxxxxxxxxxxxxxxxxx&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/7f572b7c22dc3a135ff2c3f443f6cf3a_b.png&quot; data-rawwidth=&quot;1072&quot; data-rawheight=&quot;843&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1072&quot; data-original=&quot;https://pic3.zhimg.com/7f572b7c22dc3a135ff2c3f443f6cf3a_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/7f572b7c22dc3a135ff2c3f443f6cf3a_b.png&quot; data-rawwidth=&quot;1072&quot; data-rawheight=&quot;843&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1072&quot; data-original=&quot;https://pic3.zhimg.com/7f572b7c22dc3a135ff2c3f443f6cf3a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/7f572b7c22dc3a135ff2c3f443f6cf3a_b.png&quot;&gt;&lt;/figure&gt;&lt;p&gt;创建 deploy.sbt 读取 SECRET_GIST 环境变量&lt;/p&gt;&lt;p&gt;deploy.sbt 包含了发布 Scala 库时的设置。我们启用 Travis 和 SonatypeRelease ，然后读取 SECRET_GIST 环境变量并加载 Secret Gist 中的 secret.sbt 文件&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enablePlugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Travis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;enablePlugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SonatypeRelease&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;lazy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secret&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;settings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;publishArtifact&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;configure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secret&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SECRET_GIST&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gitUri&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;secret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addSbtFilesFromGit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gitUri&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;secret.sbt&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;secret&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;日常使用注意事项&lt;/p&gt;&lt;p&gt;关于 deploy.sbt.disabled&lt;/p&gt;&lt;p&gt;把 .travis.yml 、 project/plugins.sbt 、 LICENSE 、 build.sbt 、 deploy.sbt 几个文件推送到 Git 仓库后， CI 会触发自动测试和自动发布。每次发布成功后，sbt-best-practice 会自动把 deploy.sbt 改名为 deploy.sbt.disabled ，因此，如果将来再有提交，就只会触发自动测试，而不会触发自动发布。如果你想发布下一个新版本，手动把deploy.sbt.disabled 改名为 deploy.sbt 就能触发 CI 执行自动发布流程了。&lt;/p&gt;&lt;p&gt;关于版本号&lt;/p&gt;&lt;p&gt;一旦触发发布，CI 会自动修改 version.sbt 中记录的版本号。比如你的仓库中原本版本号是 1.0.0-SNAPSHOT ，触发自动发布时， CI 会首先把版本号改为 1.0.0 然后标上 GIT tag，然后再把版本号改为 1.0.1-SNAPSHOT 。如果你希望下次发布的版本号是 1.5.0 ，那么你需要在触发下一次自动发布以前，手动把 version.sbt 中记录的版本号改为 1.5.0-SNAPSHOT 。&lt;/p&gt;&lt;p&gt;相关链接&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//scala-lang.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Scala&lt;/a&gt; - 一门多范式的编程语言，也是本文的涉及的全部技术的基础。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/scala-project-template&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;scala-project-template&lt;/a&gt; - Scala项目模板，类似本文描述的结构，但改用私有 Git 仓库来保存密码而非 Secret Gist，因此 deploy.sbt 内容稍有不同。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/Q.scala&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Q.scala&lt;/a&gt; - 完整设置了自动测试和发布的 Scala 库。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.scala-sbt.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Sbt&lt;/a&gt; - Simple Build Tool, Scala 社区最为广泛实用的构建工具。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/ThoughtWorksInc/sbt-best-practice&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;sbt-best-practice&lt;/a&gt; - Sbt 插件，提供了本文提及的全部发布功能。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lihaoyi/utest&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;µTest&lt;/a&gt; - 一个简单好用的 Scala 测试框架。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//travis-ci.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Travis CI&lt;/a&gt; - 为 Github 项目提供了持续集成服务。除了 Travis CI ，其他持续集成方案还有我司的 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.go.cd/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GoCD&lt;/a&gt; 、 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//jenkins.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Jenkins&lt;/a&gt; 、 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.atlassian.com/software/bamboo&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bamboo&lt;/a&gt; 等。相比这些方案，Travis CI 很精简，完全省略了 pipeline 的概念，我很喜欢。开源项目可以免费使用 Travis CI。我见过的开源项目中最常见的持续集成服务就是 Travis CI。&lt;/li&gt;&lt;/ul&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2017-08-17-22371242</guid>
<pubDate>Thu, 17 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Scala起源</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2017-07-12-25138340.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25138340&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Scala起源&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Martin Odersky访谈（第一部分）&lt;/p&gt;&lt;p&gt;by Bill Venners and Frank Sommers&lt;/p&gt;&lt;p&gt;译者：杨博&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.artima.com/scalazine/articles/origins_of_scala.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Origins of Scala&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;摘要&lt;/b&gt;

Martin Odersky与Bill Venners谈论Scala编程语言如何创立的相关历史。&lt;/p&gt;&lt;p&gt;Scala，一门通用用途、面向对象、函数式的JVM语言，是瑞士洛桑联邦理工大学教授Martin Odersky的心血结晶。本访谈系列由多部分组成。本文是第一部分，Martin Odersky与Artima网站的Bill Venners谈论了Scala的历史。&lt;/p&gt;&lt;p&gt;&lt;b&gt;发现编译器的魅力&lt;/b&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: 我们从头开始谈谈吧。你最早是如何开始涉猎编程语言的呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 编译器和编程语言一直都是我最喜欢的主题。我第一次钻研编译器是在1980年。那时我还是个本科生，想编写一个自己的编译器。 当时我唯一能远程用上的电脑是Sinclair ZX 80。它上面有1KB内存。我差点就在上面开始尝试了。但幸好我很快就得到更强大的机器Osborne-1。这是世界上第一款“便携式”计算机，远看就像一台倾斜90度的缝纫机。 它的屏幕五英寸大，每行只能显示52个小小的字符。但它亦有惊人之处。内存多达56KB，软盘驱动器有两个，每个容量90KB。&lt;/p&gt;&lt;p&gt;那些日子，我花了一些时间与另一个叫做Peter Sollich的同学呆在一起。我们学了一门新语言Modula-2。我们觉得它既优雅又精致。 于是我们诞生出了一个新计划：我们要为8位计算机Z80编写Modula-2编译器。编写时有个小问题，Osborene附带的唯一语言是微软的Basic语言。Basic语言完全不合乎我们设想，它甚至不支持带参数的例程——除了全局变量就别无所有了。而当时其他编译器对我们穷学生来说太贵了。 因此，我们决定采用经典的自举（bootstrapping）技术。 Peter用Z80汇编语言写了第一个编译器，支持Pascal的小部分语言子集。接着，我们使用这个编译器来编译一个稍大的语言。以此类推，在几次迭代后，我们终于可以编译完整的Modula-2代码了。它可以生成解释型字节码，以及Z80二进制文件。 它生成的字节码，在当年所有系统中，文件最小；它生成的二进制文件，在8位计算机中，速度最快。在当时，算得上能力很强的系统了。&lt;/p&gt;&lt;p&gt;在我们快完成编译器之时，Borland公司推出了Turbo Pascal，还在考虑进入Modula-2市场。事实上，Borland公司决定购买我们的Modula-2的编译器、命名为Turbo Modula-2再卖到CP/M，此外他们还想开发IBM PC版。 我们愿意为他们开发IBM PC版，但他们告诉我们，他们另有计划。 不幸的是，他们开发IBM PC版所费时间远超预期。 产品发布已经是三四年后。实现团队已经从公司分拆，成为了我们所知的TopSpeed Modula-2。由于缺了IBM PC版，Borland公司从未为Turbo-Modula-2提供营销资源， 所以它一直没什么名气。&lt;/p&gt;&lt;p&gt;我们完成Modula-2编译器之际，Borland公司立时就邀请我和Peter加入。Peter去了他们公司。我差点也去了。但我的问题是，我还有一年课程要读，还有硕士项目要做。那时我差点没忍住辍学的诱惑。 最后，我决定坚持上大学。 在我硕士项目期间（关于增量解析），我发现我挺喜欢科研的。所以最后，我放弃加入Borland编写编译器，转而攻读博士学位。我的导师是Pascal和Modula-2的发明者，苏黎世联邦理工学院的Niklaus Wirth。&lt;/p&gt;&lt;p&gt;&lt;b&gt;改善Java的工作&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: Scala是怎么诞生的？有什么历史吗？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 在我快要离开苏黎世时，大约1988年至1989年，我越来越喜欢函数式编程了。所以我继续科研之路，并最终成为德国卡尔斯鲁厄大学教授。 我最初工作更偏向编程的理论方面，比如call-by-need lambda演算. 这项工作与Phil Wadler共同完成。当时他在格拉斯哥大学。 有一天，Phil告诉我，他的组里有个热血助理听说一门新的语言刚出来，仍处于Alpha阶段，名叫Java。 助理向Phil宣告：“瞧瞧我大Java，它有移植性，有字节码，能运行在Web上，还有垃圾收集。这东西可以完爆你。你打算怎么办呢？”Phil说：“呃，可能他说得有点道理。”&lt;/p&gt;&lt;p&gt;答案是，我和Phil Wadler决定从函数式编程中提取一些点子，移植到Java界。 我们的努力转化成为一门名叫Pizza的语言，其中具备函数式编程的三大特性：泛型、高阶函数和模式匹配。Pizza首次发布于1996年，即Java推出后一年。Pizza还算成功，因为它表明，JVM平台上可以实现函数式语言特性。&lt;/p&gt;&lt;p&gt;接着，Sun核心开发团队的Gilad Bracha和David Stoutamire联系了我们。他们说：“我们对你已经做的泛型什么的东西还真挺感兴趣。我们来做个新项目专注这个功能吧。”这个新项目就成了GJ（Generic Java）。 因此，我们在1997/1998年开发了GJ。6年后，GJ再加上当时我们还没做的额外功能，就成为了Java 5中的泛型。那个没做的额外功能就是Java泛型的通配符功能，后来由Gilad Bracha和奥胡斯大学的人独立开发。&lt;/p&gt;&lt;p&gt;虽然我们的泛型扩展被搁置了6年，但Sun对我为GJ写的编译器产生了强烈的兴趣。有证据表明，GJ比他们的第一个Java编译器更稳定，更易于维护。 因此，他们决定，在2000年发布的Java 1.3版及以后版本的中，都采用GJ编译器作为标准javac编译器。&lt;/p&gt;&lt;p&gt;&lt;b&gt;设计比Java更好的语言&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 此刻，在Pizza和GJ的经验中，我常常感到沮丧，因为Java是一门具有硬性约束的语言。因此，我做很多事情时都不能用我本来想用的方式，不能用我确信正确的方式来做。毕竟那时候我的工作重点是改善Java。所以，在那段时期过去以后，我决定，我该退一步了。我想从一张白纸开始，看看我能不能设计出比Java更好的东西。但同时我又知道我不能完全从头开始。 我必须利用上现有的基础设施，不然的话，光是无中生有的自举，没有任何库，工具之类的东西，根本就不现实。&lt;/p&gt;&lt;p&gt;所以我决定，即使我想设计不同于Java的语言，总归得连接到Java的基础设施——即JVM和Java库。 我的想法就是这样。 当时我正有个大好机会，因为当时我在洛桑联邦理工学院做教授，这让我有了独立研究的良好环境。我可以组成一个小团体的研究人员，可以专心工作，不会因外部的赞助人而耗光我所有的时间。&lt;/p&gt;&lt;p&gt;起初我们相当激进。 我们想创造的东西，基于一种非常优美的并发模型，叫做&lt;b&gt;join演算&lt;/b&gt;。我们创造了面向对象版的join演算，叫做Functional Nets，还创造了一门语言，叫做Funnel。过了一段时间，我们发现，Funnel语言的确非常纯粹，但却算不上很实用。 Funnel根植于非常小的内核。 人们认为理所当然应具备的功能（比如类、模式匹配）都必须要对内核编码才能提供。从学术角度看，这技术非常优雅。但实践中不大行得通。 初学者想要找出该怎么编码会相当困难，而专家却发现一次又一次重复编码又很无聊。&lt;/p&gt;&lt;p&gt;结果，我们决定再次重头做点事情，介于纯粹的学术语言Funnel，以及非常务实但受限重重的GJ之间。我们要创造的东西，将会既具有实用价值，又比Java中的先进。2002年时，我们开始开发这门新的语言。我们叫它Scala。首次公开发布于2003年。 2006年年初时有一次相对较大的重新设计。 此后它一直持续成长并逐渐稳定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;改善Java时所受的约束&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: 你说，你需要与Java向后兼容，你受到重重约束，因而多次让你感到沮丧。你能否具体举些例子说说，有哪些事，戴着镣铐跳舞时无法做到，而只保证二进制兼容但无视源代码兼容时就可以做到？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 设计泛型时，我遇到许多非常非常紧的约束。最紧的约束，最难应付的，就是被迫要完全向后兼容&lt;b&gt;无泛型Java&lt;/b&gt;。这个故事是这样的，Java1.2才刚刚加入集合库，Sun不想仅仅因为推出了泛型就另外新增一整套集合库。而不这么做，泛型就得以完全透明的方式实现。&lt;/p&gt;&lt;p&gt;这就是存在一些相当丑陋的东西的原因。 你不得不处处让无泛型类型和泛型类型一起工作，即所谓的&lt;b&gt;raw类型&lt;/b&gt;。而且你还不能改变数组的行为不然就会碰上unchecked警告。最重要的是，处理数组时无法按你想要的方式来做，比如创建具有类型参数T的数组，或者创建你还不知道元素类型的数组。反正你就是没办法做。后来我们在Scala中确实找到了办法，但前提条件是我们让Scala的数组不再支持协变和逆变。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: 你能否阐述一下Java的协变数组有些什么问题吗？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: Java发布初版时，Bill Joy、James Gosling以及Java团队的其他成员都觉得Java就该支持泛型，可惜他们没有时间好好设计。所以考虑到Java（至少初版）不支持泛型，他们觉得至少要让数组能支持协变。这就意味着，举例说吧，String数组就是Object数组的子类型。这么做的原因是，他们想要支持编写某种&lt;b&gt;泛型&lt;/b&gt;排序方法，接受一个Object数组参数，以及一个比较器（comparator）参数，而该方法可以把Object数组排序。然后，允许你把String数组传入其中。总而言之，这类设计算得上一般意义上的类型错乱了。这就是你在Java中会遇到数组修改异常的罪魁祸首。实际上，也正是它导致泛型数组无法正常实现以及数组在Java泛型中根本没法用的原因。你不能声明字符串列表的数组，压根就做不到。你必须用丑陋的raw类型，只能永无止尽地使用列表的数组。因此，它有点像原罪。 他们做得很快，觉得这只是权宜之计。它实际上把未来的每一次设计决定全都毁了。 因此，为了不再次陷入同样的陷阱，我们不得不另寻他路。现在我们宣布，不会与Java向上兼容，有些事情，我们想要做得不同。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2017-07-12-25138340</guid>
<pubDate>Wed, 12 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Scala起源</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2017-02-08-25138340.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25138340&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Scala起源&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Martin Odersky访谈（第一部分）&lt;/p&gt;&lt;p&gt;by Bill Venners and Frank Sommers&lt;/p&gt;&lt;p&gt;译者：杨博&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://www.artima.com/scalazine/articles/origins_of_scala.html&quot;&gt;The Origins of Scala&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;摘要&lt;/b&gt;

Martin Odersky与Bill Venners谈论Scala编程语言如何创立的相关历史。&lt;/p&gt;&lt;p&gt;Scala，一门通用用途、面向对象、函数式的JVM语言，是瑞士洛桑联邦理工大学教授Martin Odersky的心血结晶。本访谈系列由多部分组成。本文是第一部分，Martin Odersky与Artima网站的Bill Venners谈论了Scala的历史。&lt;/p&gt;&lt;p&gt;&lt;b&gt;发现编译器的魅力&lt;/b&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: 我们从头开始谈谈吧。你最早是如何开始涉猎编程语言的呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 编译器和编程语言一直都是我最喜欢的主题。我第一次钻研编译器是在1980年。那时我还是个本科生，想编写一个自己的编译器。 当时我唯一能远程用上的电脑是Sinclair ZX 80。它上面有1KB内存。我差点就在上面开始尝试了。但幸好我很快就得到更强大的机器Osborne-1。这是世界上第一款“便携式”计算机，远看就像一台倾斜90度的缝纫机。 它的屏幕五英寸大，每行只能显示52个小小的字符。但它亦有惊人之处。内存多达56KB，软盘驱动器有两个，每个容量90KB。&lt;/p&gt;&lt;p&gt;那些日子，我花了一些时间与另一个叫做Peter Sollich的同学呆在一起。我们学了一门新语言Modula-2。我们觉得它既优雅又精致。 于是我们诞生出了一个新计划：我们要为8位计算机Z80编写Modula-2编译器。编写时有个小问题，Osborene附带的唯一语言是微软的Basic语言。Basic语言完全不合乎我们设想，它甚至不支持带参数的例程——除了全局变量就别无所有了。而当时其他编译器对我们穷学生来说太贵了。 因此，我们决定采用经典的自举（bootstrapping）技术。 Peter用Z80汇编语言写了第一个编译器，支持Pascal的小部分语言子集。接着，我们使用这个编译器来编译一个稍大的语言。以此类推，在几次迭代后，我们终于可以编译完整的Modula-2代码了。它可以生成解释型字节码，以及Z80二进制文件。 它生成的字节码，在当年所有系统中，文件最小；它生成的二进制文件，在8位计算机中，速度最快。在当时，算得上能力很强的系统了。&lt;/p&gt;&lt;p&gt;在我们快完成编译器之时，Borland公司推出了Turbo Pascal，还在考虑进入Modula-2市场。事实上，Borland公司决定购买我们的Modula-2的编译器、命名为Turbo Modula-2再卖到CP/M，此外他们还想开发IBM PC版。 我们愿意为他们开发IBM PC版，但他们告诉我们，他们另有计划。 不幸的是，他们开发IBM PC版所费时间远超预期。 产品发布已经是三四年后。实现团队已经从公司分拆，成为了我们所知的TopSpeed Modula-2。由于缺了IBM PC版，Borland公司从未为Turbo-Modula-2提供营销资源， 所以它一直没什么名气。&lt;/p&gt;&lt;p&gt;我们完成Modula-2编译器之际，Borland公司立时就邀请我和Peter加入。Peter去了他们公司。我差点也去了。但我的问题是，我还有一年课程要读，还有硕士项目要做。那时我差点没忍住辍学的诱惑。 最后，我决定坚持上大学。 在我硕士项目期间（关于增量解析），我发现我挺喜欢科研的。所以最后，我放弃加入Borland编写编译器，转而攻读博士学位。我的导师是Pascal和Modula-2的发明者，苏黎世联邦理工学院的Niklaus Wirth。&lt;/p&gt;&lt;p&gt;&lt;b&gt;改善Java的工作&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: Scala是怎么诞生的？有什么历史吗？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 在我快要离开苏黎世时，大约1988年至1989年，我越来越喜欢函数式编程了。所以我继续科研之路，并最终成为德国卡尔斯鲁厄大学教授。 我最初工作更偏向编程的理论方面，比如call-by-need lambda演算. 这项工作与Phil Wadler共同完成。当时他在格拉斯哥大学。 有一天，Phil告诉我，他的组里有个热血助理听说一门新的语言刚出来，仍处于Alpha阶段，名叫Java。 助理向Phil宣告：“瞧瞧我大Java，它有移植性，有字节码，能运行在Web上，还有垃圾收集。这东西可以完爆你。你打算怎么办呢？”Phil说：“呃，可能他说得有点道理。”&lt;/p&gt;&lt;p&gt;答案是，我和Phil Wadler决定从函数式编程中提取一些点子，移植到Java界。 我们的努力转化成为一门名叫Pizza的语言，其中具备函数式编程的三大特性：泛型、高阶函数和模式匹配。Pizza首次发布于1996年，即Java推出后一年。Pizza还算成功，因为它表明，JVM平台上可以实现函数式语言特性。&lt;/p&gt;&lt;p&gt;接着，Sun核心开发团队的Gilad Bracha和David Stoutamire联系了我们。他们说：“我们对你已经做的泛型什么的东西还真挺感兴趣。我们来做个新项目专注这个功能吧。”这个新项目就成了GJ（Generic Java）。 因此，我们在1997/1998年开发了GJ。6年后，GJ再加上当时我们还没做的额外功能，就成为了Java 5中的泛型。那个没做的额外功能就是Java泛型的通配符功能，后来由Gilad Bracha和奥胡斯大学的人独立开发。&lt;/p&gt;&lt;p&gt;虽然我们的泛型扩展被搁置了6年，但Sun对我为GJ写的编译器产生了强烈的兴趣。有证据表明，GJ比他们的第一个Java编译器更稳定，更易于维护。 因此，他们决定，在2000年发布的Java 1.3版及以后版本的中，都采用GJ编译器作为标准javac编译器。&lt;/p&gt;&lt;p&gt;&lt;b&gt;设计比Java更好的语言&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 此刻，在Pizza和GJ的经验中，我常常感到沮丧，因为Java是一门具有硬性约束的语言。因此，我做很多事情时都不能用我本来想用的方式，不能用我确信正确的方式来做。毕竟那时候我的工作重点是改善Java。所以，在那段时期过去以后，我决定，我该退一步了。我想从一张白纸开始，看看我能不能设计出比Java更好的东西。但同时我又知道我不能完全从头开始。 我必须利用上现有的基础设施，不然的话，光是无中生有的自举，没有任何库，工具之类的东西，根本就不现实。&lt;/p&gt;&lt;p&gt;所以我决定，即使我想设计不同于Java的语言，总归得连接到Java的基础设施——即JVM和Java库。 我的想法就是这样。 当时我正有个大好机会，因为当时我在洛桑联邦理工学院做教授，这让我有了独立研究的良好环境。我可以组成一个小团体的研究人员，可以专心工作，不会因外部的赞助人而耗光我所有的时间。&lt;/p&gt;&lt;p&gt;起初我们相当激进。 我们想创造的东西，基于一种非常优美的并发模型，叫做&lt;b&gt;join演算&lt;/b&gt;。我们创造了面向对象版的join演算，叫做Functional Nets，还创造了一门语言，叫做Funnel。过了一段时间，我们发现，Funnel语言的确非常纯粹，但却算不上很实用。 Funnel根植于非常小的内核。 人们认为理所当然应具备的功能（比如类、模式匹配）都必须要对内核编码才能提供。从学术角度看，这技术非常优雅。但实践中不大行得通。 初学者想要找出该怎么编码会相当困难，而专家却发现一次又一次重复编码又很无聊。&lt;/p&gt;&lt;p&gt;结果，我们决定再次重头做点事情，介于纯粹的学术语言Funnel，以及非常务实但受限重重的GJ之间。我们要创造的东西，将会既具有实用价值，又比Java中的先进。2002年时，我们开始开发这门新的语言。我们叫它Scala。首次公开发布于2003年。 2006年年初时有一次相对较大的重新设计。 此后它一直持续成长并逐渐稳定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;改善Java时所受的约束&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: 你说，你需要与Java向后兼容，你受到重重约束，因而多次让你感到沮丧。你能否具体举些例子说说，有哪些事，戴着镣铐跳舞时无法做到，而只保证二进制兼容但无视源代码兼容时就可以做到？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: 设计泛型时，我遇到许多非常非常紧的约束。最紧的约束，最难应付的，就是被迫要完全向后兼容&lt;b&gt;无泛型Java&lt;/b&gt;。这个故事是这样的，Java1.2才刚刚加入集合库，Sun不想仅仅因为推出了泛型就另外新增一整套集合库。而不这么做，泛型就得以完全透明的方式实现。&lt;/p&gt;&lt;p&gt;这就是存在一些相当丑陋的东西的原因。 你不得不处处让无泛型类型和泛型类型一起工作，即所谓的&lt;b&gt;raw类型&lt;/b&gt;。而且你还不能改变数组的行为不然就会碰上unchecked警告。最重要的是，处理数组时无法按你想要的方式来做，比如创建具有类型参数T的数组，或者创建你还不知道元素类型的数组。反正你就是没办法做。后来我们在Scala中确实找到了办法，但前提条件是我们让Scala的数组不再支持协变和逆变。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Bill Venners&lt;/b&gt;: 你能否阐述一下Java的协变数组有些什么问题吗？&lt;/p&gt;&lt;p&gt;&lt;b&gt;Martin Odersky&lt;/b&gt;: Java发布初版时，Bill Joy、James Gosling以及Java团队的其他成员都觉得Java就该支持泛型，可惜他们没有时间好好设计。所以考虑到Java（至少初版）不支持泛型，他们觉得至少要让数组能支持协变。这就意味着，举例说吧，String数组就是Object数组的子类型。这么做的原因是，他们想要支持编写某种&lt;b&gt;泛型&lt;/b&gt;排序方法，接受一个Object数组参数，以及一个比较器（comparator）参数，而该方法可以把Object数组排序。然后，允许你把String数组传入其中。总而言之，这类设计算得上一般意义上的类型错乱了。这就是你在Java中会遇到数组修改异常的罪魁祸首。实际上，也正是它导致泛型数组无法正常实现以及数组在Java泛型中根本没法用的原因。你不能声明字符串列表的数组，压根就做不到。你必须用丑陋的raw类型，只能永无止尽地使用列表的数组。因此，它有点像原罪。 他们做得很快，觉得这只是权宜之计。它实际上把未来的每一次设计决定全都毁了。 因此，为了不再次陷入同样的陷阱，我们不得不另寻他路。现在我们宣布，不会与Java向上兼容，有些事情，我们想要做得不同。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2017-02-08-25138340</guid>
<pubDate>Wed, 08 Feb 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>内存溢出 ≠ 内存不足</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2017-01-17-24928828.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24928828&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很多人，比如&lt;a href=&quot;https://www.zhihu.com/people/6e20ed7f6a42010d62d63d09f54793c7&quot; data-hash=&quot;6e20ed7f6a42010d62d63d09f54793c7&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@赵北云&quot; data-hovercard=&quot;p$b$6e20ed7f6a42010d62d63d09f54793c7&quot;&gt;@赵北云&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/7a7768ec9018494013255730c34cfcd0&quot; data-hash=&quot;7a7768ec9018494013255730c34cfcd0&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@Kifile&quot; data-hovercard=&quot;p$b$7a7768ec9018494013255730c34cfcd0&quot;&gt;@Kifile&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/5818bea8dc799bce35ddb3c7af649e7a&quot; data-hash=&quot;5818bea8dc799bce35ddb3c7af649e7a&quot; class=&quot;member_mention&quot; data-title=&quot;@戴帽子的狗&quot; data-editable=&quot;true&quot; data-hovercard=&quot;p$b$5818bea8dc799bce35ddb3c7af649e7a&quot;&gt;@戴帽子的狗&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/8ff71e48d8431145e99f39f732c7fcc5&quot; data-hash=&quot;8ff71e48d8431145e99f39f732c7fcc5&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@武大郎&quot; data-hovercard=&quot;p$b$8ff71e48d8431145e99f39f732c7fcc5&quot;&gt;@武大郎&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/c17a2fa8908b8dfc9b80fc3170d4d13e&quot; data-hash=&quot;c17a2fa8908b8dfc9b80fc3170d4d13e&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@支浩宇&quot; data-hovercard=&quot;p$b$c17a2fa8908b8dfc9b80fc3170d4d13e&quot;&gt;@支浩宇&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/bdbb011fa8e73b808445ca48dafdfd31&quot; data-hash=&quot;bdbb011fa8e73b808445ca48dafdfd31&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@韩葆-逸松&quot; data-hovercard=&quot;p$b$bdbb011fa8e73b808445ca48dafdfd31&quot;&gt;@韩葆-逸松&lt;/a&gt;认为：&lt;/p&gt;&lt;blockquote&gt;内存溢出 = stackoverflow = 内存不足&lt;/blockquote&gt;&lt;p&gt;事实上，虽然stackoverflow可以看成是栈内存不足的一种体现。但内存溢出并不一定跟内存分配有什么关系，因为还有一种情况是缓冲区溢出。&lt;br&gt;&lt;/p&gt;&lt;p&gt;C/C++标准库有个strcpy，会一直复制内存，直到遇到\0。比如如果你用C++写了一个游戏服务器，其中读取客户端网络包的代码写成这样：&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;code lang=&quot;cpp&quot;&gt;const MAX_LENGTH = 16;
bool is_administrator = false;
char destination[MAX_LENGTH];

std::string source = read_string_from_client();
strcpy(destination, source.c_str());
&lt;/code&gt;&lt;br&gt;&lt;p&gt;那么如果黑客构造出的source长于16字节，那么就会修改到destination之外的内存。很多平台的栈变量是跟按地址顺序倒着分配的。所以destination溢出以后会修改先前定义的变量。比如黑客可以用这个办法把is_administrator修改成true。&lt;br&gt;这种情况就是缓冲区溢出攻击。&lt;/p&gt;假如黑客黑掉服务器之后，把你的服务端程序偷出来开私服。由于私服泛滥，游戏失败了。于是你的新游戏决定抛弃了C++，改用C99标准的C语言。这次你这样写：&lt;br&gt;&lt;code lang=&quot;c&quot;&gt;int length = read_int_from_client();
char buffer[length];
int data = read_int_from_client();
&lt;/code&gt;&lt;p&gt;这里会在栈上分配length字节的空间，然后再往栈顶放上一个data。当length很大时，会把data挤到栈空间之外。这种情况下，假如编译器生成的代码没有越界检查的话，那么黑客只要用客户端发送特定的length和data组合，就能够改写服务器的任意内存。黑客通常会修改服务器代码的机器码，比如注入一些jmp指令，让线程跳到黑客想执行的函数。&lt;/p&gt;那么这一次你又被“栈溢出”攻击黑掉了服务器。&lt;p&gt;从这两个例子可以看出，内存溢出就是内存越界。我们说内存溢出这个词是往往指的是栈溢出或缓冲区溢出。&lt;/p&gt;&lt;p&gt;无论栈溢出还是缓冲区溢出都是安全漏洞的温床。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2017-01-17-24928828</guid>
<pubDate>Tue, 17 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用全栈Scala架构开发的web游戏工具</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2017-01-01-24669379.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24669379&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
有一个日本手机游戏叫做《碧蓝幻想》。大概长成这样：&lt;img src=&quot;https://pic2.zhimg.com/a86564a518b5f54efe29d320df2c2d78_r.jpg&quot; data-rawwidth=&quot;1037&quot; data-rawheight=&quot;1200&quot;&gt;&lt;br&gt;这个游戏和魔兽世界一样，也有所谓的副本，需要组队才能打得过。不幸的是，这个游戏没有组队系统，而是提供了“在微博上组队”的功能，点一下就会发一条类似这样的信息：&lt;img src=&quot;https://pic2.zhimg.com/2a356d020a73910a17d5fe48399ff40a_r.png&quot; data-rawwidth=&quot;861&quot; data-rawheight=&quot;937&quot;&gt;&lt;p&gt;要想组队的玩家，就得去微博上寻找队友，然后把参战ID复制到游戏里面。&lt;/p&gt;&lt;p&gt;那么，你想要组队，你就得在微博上搜索别人发的组队信息，看看Boss等级、三围、队伍配置是否匹配。这个过程非常麻烦，你需要点开一大堆微博，挨个筛选。&lt;/p&gt;有一个程序员（&lt;a href=&quot;https://twitter.com/walfieee&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;@walfieee&quot;&gt;@walfieee&lt;/a&gt;）不堪忍受懒惰的开发商，于是自己用&lt;a href=&quot;https://github.com/ThoughtWorksInc/Binding.scala&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;Binding.scala&quot;&gt;Binding.scala&lt;/a&gt;帮《碧蓝幻想》做了个&lt;a href=&quot;https://github.com/walfie/gbf-raidfinder&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;组队系统&quot;&gt;组队系统&lt;/a&gt;。&lt;br&gt;&lt;img src=&quot;https://pic2.zhimg.com/14bdc21cb604c84e79d96374583203ac_r.png&quot; data-rawwidth=&quot;1305&quot; data-rawheight=&quot;910&quot;&gt;&lt;p&gt;这样大家就可以解放双手，批量刷副本啦。&lt;/p&gt;&lt;br&gt;&lt;a href=&quot;https://twitter.com/walfieee&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;@walfieee&quot;&gt;@walfieee&lt;/a&gt;开发的组队系统是个完整的网站，包含了前后端代码。&lt;p&gt;项目已经开源到Github上（&lt;a href=&quot;https://github.com/walfie/gbf-raidfinder&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;walfie/gbf-raidfinder&quot;&gt;walfie/gbf-raidfinder&lt;/a&gt;），所有代码都是用Scala写的。后端使用Redis+Play，前端用MDL+Binding.scala，前后端通信使用WebSocket+protobuf。可以自动部署到heroku。&lt;/p&gt;&lt;p&gt;难能可贵的是，&lt;a href=&quot;https://twitter.com/walfieee&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;@walfieee&quot;&gt;@walfieee&lt;/a&gt;撰写了很好的开发文档（&lt;a href=&quot;https://github.com/walfie/gbf-raidfinder/blob/master/docs/project.md&quot; data-editable=&quot;true&quot; data-title=&quot;project.md&quot; class=&quot;&quot;&gt;project.md&lt;/a&gt;），让人可以根据文档快速搭建开发环境。&lt;/p&gt;&lt;p&gt;除了这个项目以外，&lt;a href=&quot;https://github.com/Algomancer/Full-Stack-Scala-Starter&quot; data-editable=&quot;true&quot; data-title=&quot;Full-Stack-Scala-Starter&quot; class=&quot;&quot;&gt;Full-Stack-Scala-Starter&lt;/a&gt;提供了全栈Scala的项目模板，也很不错。&lt;/p&gt;&lt;p&gt;我觉得这两个项目对于想要搭建全栈Scala架构的网站的人来说，都是很好的参考实现。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2017-01-01-24669379</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>你觉得Binding.scala好不好啊？</title>
<link>https://henix.github.io/feeds/zhuanlan.yangbo/2017-01-01-24669230.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24669230&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ThoughtWorksInc/Binding.scala&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;github.com 的页面&quot;&gt;Binding.scala&lt;/a&gt;是Scala上的数据绑定框架，如果配合Scala.js，可以作为前端框架使用。本文收集了全球用户对Binding.scala的反馈。&lt;/p&gt;&lt;p&gt;Ólafur Páll Geirsson:&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;blockquote&gt;Hi，我只想对 &lt;br&gt;&lt;a class=&quot;&quot; href=&quot;https://www.zhihu.com/people/atry&quot; data-editable=&quot;true&quot; data-title=&quot;@杨博&quot;&gt;@杨博&lt;/a&gt;&lt;br&gt; 你说声谢谢，Binding.scala 真棒！我花了一会儿功夫让脑子绕清楚`.bind`的用法和时机。但一旦搞清楚了，前端（包括路由和其他很酷的功能）开发过程就变得非常直截了当。&lt;br&gt;TodoMVC对新手上手来说是个极好的例子。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D57bc5dd087f779f0691f0b2a&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57bc5dd087f779f0691f0b2a&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57bc5dd087f779f0691f0b2a&lt;/a&gt;&lt;/p&gt;Justin Maat:&lt;br&gt;&lt;blockquote&gt;Binding.scala感觉非常简单，不像其他库那么复杂&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D5720f1cb9b4160fa760a6470&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=5720f1cb9b4160fa760a6470&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=5720f1cb9b4160fa760a6470&lt;/a&gt;&lt;/p&gt;dafcok:&lt;br&gt;&lt;blockquote&gt;感觉Binding.scala精简至极。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/scala/comments/4dvsbn/announcing_bindingscala_a_reactive_web_framework/d1vui5n&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://www.reddit.com/r/scala/comments/4dvsbn/announcing_bindingscala_a_reactive_web_framework/d1vui5n&quot;&gt;https://www.reddit.com/r/scala/comments/4dvsbn/announcing_bindingscala_a_reactive_web_framework/d1vui5n&lt;/a&gt;&lt;/p&gt;Milad Khajavi:&lt;br&gt;&lt;blockquote&gt;感谢你，我发现Binding.scala和我见过的其他框架相比，Binding.scala非常简单。伟大的作品。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D581bf9952d4796175f4015ba&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=581bf9952d4796175f4015ba&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=581bf9952d4796175f4015ba&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;Binding.scala之简洁，远超其他数据绑定框架，还支持XML字面量。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/khajavi/status/819885381621518338&quot; data-editable=&quot;true&quot; data-title=&quot;twitter.com 的页面&quot; class=&quot;&quot;&gt;https://twitter.com/khajavi/status/819885381621518338&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;br&gt;Philip Stutz:&lt;br&gt;&lt;blockquote&gt;嘿杨兄，Binding.scala真的很酷，是迄今为止web应用的客户端开发最最方便的方式。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D57bacaddbb6fad403cf53794&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57bacaddbb6fad403cf53794&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57bacaddbb6fad403cf53794&lt;/a&gt;&lt;/p&gt;Markus Herrmann:&lt;br&gt;&lt;blockquote&gt;真的很酷！Binding.scala——Scala数据绑定框架&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/datalabrat/status/765483174587670529&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/datalabrat/status/765483174587670529&quot;&gt;https://twitter.com/datalabrat/status/765483174587670529&lt;/a&gt;&lt;/p&gt;Rahel Lüthy:&lt;br&gt;&lt;blockquote&gt;Binding.scala——ThoughtWorks的reactive web框架，感觉极其简洁&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/netzwerg999/status/718751672974118912&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/netzwerg999/status/718751672974118912&quot;&gt;https://twitter.com/netzwerg999/status/718751672974118912&lt;/a&gt;&lt;/p&gt;Adam Hibble:&lt;br&gt;&lt;blockquote&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/thoughtworks&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;@thoughtworks&quot;&gt;@thoughtworks&lt;/a&gt; Binding.scala简单极了。&lt;/blockquote&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/Algomancer/status/783445081927720960&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/Algomancer/status/783445081927720960&quot;&gt;https://twitter.com/Algomancer/status/783445081927720960&lt;/a&gt;&lt;br&gt;&lt;blockquote&gt;我真的很喜欢用Binding.scala做些小巧、可重用、可隔离的组件。&lt;/blockquote&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/scala/comments/55whc1/a_really_simple_full_stack_scala_starter_with/d8g58bh&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://www.reddit.com/r/scala/comments/55whc1/a_really_simple_full_stack_scala_starter_with/d8g58bh&quot;&gt;https://www.reddit.com/r/scala/comments/55whc1/a_really_simple_full_stack_scala_starter_with/d8g58bh&lt;/a&gt;&lt;br&gt;Walfie:&lt;br&gt;&lt;blockquote&gt;在我使用Binding.scala至今，绝大多数时间 Binding.scala 都给了我丝般柔顺的体验。多亏有了Binding.scala&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/walfieee/status/778365304355291136&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/walfieee/status/778365304355291136&quot;&gt;https://twitter.com/walfieee/status/778365304355291136&lt;/a&gt;&lt;/p&gt;jfilali:&lt;br&gt;&lt;blockquote&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Atry&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;@Atry&quot;&gt;@Atry&lt;/a&gt; Binding.scala 看起来真伟大。恭喜。你的所作所为是真正的创新。以前，我评估了各种库的品质时、搭建了开发环境，包括scala-react、material-ui的包装库、material-ui的JavaScript依赖、diode、JavaScript打包、JavaScript依赖。现在，我怀疑所有这些工作还有什么价值。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D584d355628d755bf14ef4a3a&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=584d355628d755bf14ef4a3a&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=584d355628d755bf14ef4a3a&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;blockquote&gt;（……关于Binding.scala支持定制XML组件）让我能乐上一整天。实际上我已经把Binding.scala和flux/Model用在一起了。尽管底层是可变模型，一样能运转得很好。我遵守以下编码风格：利用容器连接存储和视觉组件，组件接受的参数都是Binding[Node]对象。我发现这种方式可伸缩性非常好。&lt;br&gt;目前我需要写几篇博客，但至今我体验到Binding.scala真的非常好。我的生产力大大提高。我以前写了个ReactJS项目花了两个月，react-scala-js项目花了一个月，而Binding.scala项目只用两周。&lt;br&gt;不久以后我会写一篇博客谈谈我的经验。&lt;/blockquote&gt;&lt;a href=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=5879bd26074f7be763cc550f&quot; data-editable=&quot;true&quot; data-title=&quot;gitter.im 的页面&quot; class=&quot;&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=5879bd26074f7be763cc550f&lt;/a&gt;&lt;br&gt;&lt;br&gt;Pedro Larroy:&lt;br&gt;&lt;blockquote&gt;Binding.scala是Scala的reactive web应用库，比ReactJS易用。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/plarroy/status/715955108928962561&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/plarroy/status/715955108928962561&quot;&gt;https://twitter.com/plarroy/status/715955108928962561&lt;/a&gt;&lt;/p&gt;chris-tek:&lt;br&gt;&lt;blockquote&gt;我以前学过ELM、Scala.js+diode，最近开始调研Scala.js+Binding.scala，构建纯粹完全响应式的GUI。&lt;br&gt;现在我已经有些阶段性成果，成功让GUI和后端（RabbitMQ + stomp，websocket协议）交换数据。不可思议，程序运行得非同寻常的棒。&lt;br&gt;Binding.scala那坨代码写得真好。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/ThoughtWorksInc/Binding.scala%3Fat%3D57c69070ca24c06c638a5ff5&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57c69070ca24c06c638a5ff5&quot;&gt;https://gitter.im/ThoughtWorksInc/Binding.scala?at=57c69070ca24c06c638a5ff5&lt;/a&gt;&lt;/p&gt;Anthony Homan:&lt;br&gt;&lt;blockquote&gt;Binding.scala绝对是最卓越的！我承认我才刚刚开始接触Binding.scala，但即便如此，Binding.scala真真是我寻觅已久的那块拼板，让Scala.js真正值得投资。&lt;br&gt;我会继续试着把我现有的AngularJS（前端）/Scala（后端）应用，移植到全栈Scala上，用Scala.js和Binding.scala代替AngularJS。&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//groups.google.com/d/msg/scala-js/xJsjE-zFeuk/gqIgTXi2AwAJ&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://groups.google.com/d/msg/scala-js/xJsjE-zFeuk/gqIgTXi2AwAJ&quot;&gt;https://groups.google.com/d/msg/scala-js/xJsjE-zFeuk/gqIgTXi2AwAJ&lt;/a&gt;&lt;/p&gt;Simone Scarduzio:&lt;br&gt;&lt;blockquote&gt;今天涨点知识：Binding.scala，用Scala代替ReactJS的明智选择&lt;br&gt;&lt;/blockquote&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//twitter.com/s_scarduzio/status/763501825484087300&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;https://twitter.com/s_scarduzio/status/763501825484087300&quot;&gt;https://twitter.com/s_scarduzio/status/763501825484087300&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;很惭愧，就做了一点微小的工作。&lt;/p&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2017-01-01-24669230</guid>
<pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
