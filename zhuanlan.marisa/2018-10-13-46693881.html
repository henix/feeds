<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>代码编辑器系列 #3 文本的存储 进化篇</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/46693881">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-d695aa142b6fe04d3f6579a57771fa31_r.jpg" alt=""></div><p><a href="http://ice1000.org/2018/09/24/CodeEditor4/">ice1000.org</a> 这是原文，发表在我的博客。</p><p>在<a href="http://ice1000.org/2018/04/29/CodeEditor2/">上上篇文章</a>中我说过，</p><blockquote>以后的方向主要是讲 JB 式编辑器的实现</blockquote><p>在<a href="http://ice1000.org/2018/06/05/CodeEditor3/">上一篇文章</a>中我又说，</p><blockquote>那么这篇文章先说点别的吧</blockquote><p>简直是王镜泽定理的完美演绎啊。 为什么我要在半个月来第一篇博客开头说这个呢？因为这次讲的依然不是 JB 式编辑器的实现，真香。</p><p>关于上一篇博客在说 gap buffer 的时候提到的数据结构论文 Flexichain，我当时说读下来没学到什么东西。 实际上论文有两篇，内容应该基本上都在另一篇讲实现的里面。这是某活跃于 freenode #lisp 的 CL 厨告诉我的。</p><p>在我最近的新项目里，我使用了 Flexichain 论文里提到的 Hemlock 编辑器使用的数据结构 （我的那个使用C++实现，改自一个单独的 Java 项目 <a href="https://github.com/ice1000/text-sequence">text-sequence</a>，前文提到的实验项目也换成了这个项目里的 <code class="inline">GapBuffer</code>）， 这个数据结构在 <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.1265&amp;rep=rep1&amp;type=pdf">piece table 的论文</a>里有一个类似物叫 Line Span，于是我就直接叫它 <code class="inline">LineSpan</code> 了。</p><p>本文包含这篇论文中的大部分知识。</p><p>前文说，</p><blockquote>由于 Swing 的 API 看起来更低效</blockquote><p>其实不是的， Swing 文本编辑器内部实现是一个 <code class="inline"><a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/text/GapContent.html">GapContent</a></code>， 也就是一个过度 OO 设计的 <code class="inline">GapBuffer</code>（可见写 Swing 的人并不是文盲，而且文化程度不低），这比我那时候用的更高效，所以我那时的想法还是太幼稚了。</p><p>既然本文是现代篇（对应上一篇的远古篇），那么讲的肯定是现代编辑器使用的数据结构啦。</p><p>介绍一个概念 end of line ，通常是 <code class="inline">\n</code> 但考虑到有些情况下还有别的行分隔符就使用了 end of line 代表这个东西。</p><h2>Code 早期使用的数据结构</h2><p>应该很少有人使用可执行文件的名字来称呼这个全名叫 Visual Studio Code 的编辑器吧，正好可以显得很装逼（逃。 根据黑历史考据，我看到 Code 团队在 <a href="https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation">blog</a> 里自述曾经使用按行存储的策略， 然后他们获得的好处是可以按行运行 Tokenizer ，可以提高代码高亮的性能（意思就是直接不考虑包含 end of line 的 Token ，很符合前端人员的编程思想）。</p><p>这历史应该是黑成碳了。根据上面那个链接里的博客来看，他们也没有使用优化 active line 的策略（比如我使用 GapBuffer ）。 不过呢，按行存储可以进行渲染上的优化（因为行可以被视为一个渲染单位，而且在屏幕移动时每行渲染出来的样子是不变的）， 这在某种意义上也是一种好处了（根据一个研究超算的软粉的说法，Visual Studio 会缓存每行的代码渲染后得到的 texture）。</p><p>LineSpan 的实现相对 GapBuffer 较为繁琐，它在插入的时候需要检查是否有插入 end of line 来考虑是否要拆掉当前的 active line 、 需要在删除的时候检查是否删除了一个 end of line 来考虑是否要合并当前行和下一行。 好处是，可以对行进行批量操作。</p><p>目前我的编辑器也是临时使用的这种数据结构，而且比起他们这个还提高了当前行的编辑效率和获取行的效率。 我原本计划使用一个线段树维护每行的长度的前缀和（之所以没有选择我最喜欢的树状数组，是因为我还需要删点），这样可以获得 <code class="inline">O(log(n))</code> 的 <code class="inline">getLineInfoAt</code> 等函数。 但是在后来发现要获取对应行的迭代器还需要对链表进行高效的随机访问（或者存储迭代器到线段树里，但这意义已经没有那么大了，因为要换 Piece Table 实现），我就放弃了。 不过鄙视人家的黑历史也没什么意思，毕竟 Code 除了代码编辑的其他地方做的还是很不错的。</p><p><br>我做了一个 LineSpan 的数据结构可视化（非常妙），上传到了 <a href="https://www.bilibili.com/video/av32595178/">bilibili</a> 和 <a href="https://youtu.be/GOsf8OdeS08">YouTube</a>。</p><h2>其他杂七杂八的数据结构</h2><ul><li>Split-Merge Tree ，保证 Rope 的最小单位 Sequence 在一个长度范围内，超过就拆，小于就合并两个相邻的，是比平衡树更平衡的平衡树</li><li>Fixed-Size-Buffer ，扁平版 Split-Merge Tree，你也可以叫它 Split-Merge LinkedList</li></ul><h2>文本序列数据结构的通用性质</h2><p>看到这里，我们脑中应该已经有了一个文本序列数据结构的一个通用模型了。 在前文讲 Rope 的时候我曾经提到，它是将最小的文本表示作为了一种抽象结构并使用平衡树组合他们，然后举例了几种可能的实现—— 一个获取文本的函数、字符数组（C 风格字符串）、惰性读取的文件、另一颗平衡树等。 GapBuffer 其实也是一种实现。</p><p>我们可以尝试把这种思想套到 LineSpan 上，然后发现也完全适用——它其实只是提出了一种新的最小文本表示的实现—— <code class="inline">Line</code>，并使用链表或者平衡树去组合他们而已。 我们来给这个抽象里的概念起个名字吧。</p><ul><li>一个 item 指文本序列的最小单位，通常是 <code class="inline">char</code> 或者 <code class="inline">wchar_t</code></li><li>一个 sequence 指一系列以各种方式组合并在逻辑上是连续的 item ，即刚才提到的抽象结构，比如 <code class="inline">LinkedList&lt;Character&gt;</code>, <code class="inline">std::list&lt;char&gt;</code></li><li>一个 buffer 指一段在物理上连续的 item ，一般只在实现中涉及</li><ul><li>比如 <code class="inline">std::vector&lt;char&gt;::data</code>, <code class="inline">java.util.ArrayList&lt;Character&gt;</code> 里面的那个数组</li><li>比如 mmap</li></ul></ul><p><br></p><ul><li>一个 item 序列如果同时是 sequence 和 buffer 那么它是一个 span</li><ul><li>比如 <code class="inline">java.lang.String</code>, <code class="inline">std::string</code></li><li>buffer 中的逻辑连续的一部分可以算作一个 span ，比如 GapBuffer</li></ul></ul><p><br></p><ul><li>一个 descriptor 指描述一段 sequence 的数据结构，比如 LineSpan 中通常需要一个 <code class="inline">LineInfo</code> 来保存 span 的位置、长度，那么这个 <code class="inline">LineInfo</code> 就是一个 descriptor</li><ul><li>descriptor 通常持有一个 sequence 的指针</li><li>这个定义和<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.1265&amp;rep=rep1&amp;type=pdf">论文</a>里说的不太一样，是我觉得更好的定义</li></ul></ul><p><br></p><p>然后我们来总结一下我们见过的各种东西吧：</p><ul><li><code class="inline">java.lang.Character</code>, <code class="inline">char</code>, <code class="inline">wchar_t</code>, <code class="inline">ImWchar</code> 是 item</li><li>Ruby/Lua/JavaScript/Dart/Perl 等语言中的 <code class="inline">string</code> 是 span</li><li>Rope 是一个递归的 sequence （<code class="inline">type Rope = BalancedTree (Either Span Rope)</code>）</li><ul><li>平衡树的 <code class="inline">Node</code> 类可以看作 span 的 descriptor</li></ul></ul><p><br></p><ul><li><code class="inline">java.lang.StringBuilder</code> 是一个大 buffer ，最左边那部分是一个 span， descriptor 持有这个 <code class="inline">StringBuilder</code> 要 build 的 <code class="inline">String</code> 的长度</li><li>GapBuffer 内部有一个大 buffer ，它由两个中间有一个 gap 的不断变化的 span 组成</li><ul><li>第一个 span 的 descriptor 存储这个 span 的长度，第二个 span 的 descriptor 存储这个 span 在大 buffer 里的的起始点</li></ul></ul><p><br></p><ul><li>LineSpan 可以看作一个 <code class="inline">java.util.LinkedList&lt;java.lang.CharSequence&gt;</code> 或者 <code class="inline">std::list&lt;std::string&gt;</code> 的封装，属于 sequence</li><ul><li>链表的迭代器就是 descriptor ，里面存的是 sequence ， Code 早期的这些 sequence 全是 span ，我的实现里 active line 是 sequence ，其他行是 span</li></ul></ul><p><br></p><p>是不是一下子就搞懂这些名词的含义了？下面我们将使用这套名词介绍一个新数据结构。</p><h2>Piece Table</h2><p>这是我目前觉得最好的文本编辑器存储数据所使用的数据结构。</p><p>Piece Table 由一个巨大的、 immutable 的、最好是 lazy 的 buffer （mmap 很适合作为这个 buffer）和一系列指向 span 的 descriptor 组成。 Descriptor 保存两个信息，头指针和长度。这一系列 descriptor 可以由链表保存（实现简单），也可以使用平衡树保存（更高效）。 由于我们不需要修改或者删除这些 descriptor 指向的 span ，我们可以把他们持有的 span 放进一个 buffer ，我们称之为 add buffer ，可以理解为一个 <code class="inline">ArrayList&lt;Item&gt;</code>。</p><p>在创建一个 Piece Table 的时候，我们需要初始化这个巨大的 buffer ，比如文本编辑器打开一个文件的时候就可以使用文件的 mmap 。 此时我们也初始化第一个 descriptor ，头指针指向大 buffer 的开头，长度就是整个 buffer 。</p><h2>查询</h2><p>如果给定 <code class="inline">offset</code> 要取一个 Item ，就涉及存储 descriptor 的数据结构了—— 链表的话从头开始遍历 descriptor ，找到这个 <code class="inline">offset</code> 所在的 descriptor 然后就可以从 buffer 里取值了，复杂度 <code class="inline">O(n)</code>。 如果是平衡树就可以直接从 <code class="inline">offset</code> 去找，复杂度 <code class="inline">O(log(n))</code>。</p><h2>插入</h2><p>插入任意内容时（假设输入了 <code class="inline">offset</code>（即<code class="inline">index</code>）和 <code class="inline">sequence</code>），类似 LineSpan 插入 end of line 的情况，需要把这个 <code class="inline">offset</code> 所在的那个 descriptor 拆掉，变成两个分别描述原本的 descriptor 在 <code class="inline">offset</code> 前的那一半和后的那一半，然后把 <code class="inline">sequence</code> 添加到 add buffer 的尾部， 然后在刚才这两个 descriptor 的中间插入一个指向这个 <code class="inline">sequence</code> 在 add buffer 中位置的 descriptor 。</p><p>举个例子，假设我们有一个文件，里面有 <code class="inline">Piece</code> 这几个字符。我们用它创建一个 Piece Table 后，大 buffer 里就是 <code class="inline">Piece</code> ，长度为 5。 Descriptor 序列是这样的：</p><img src="https://pic1.zhimg.com/v2-aff8738ffefa9bc905cc7170c57aab5e_r.jpg" data-caption="" data-size="normal" data-rawwidth="305" data-rawheight="80" data-watermark="watermark" data-original-src="v2-aff8738ffefa9bc905cc7170c57aab5e" data-watermark-src="v2-581d89340a84dabbbc456a3306380204" data-private-watermark-src=""><p>我们对他进行 <code class="inline">insert(1, "Tb")</code> ，那么先把 1 这个 <code class="inline">offset</code> 所在的 0 号（查找 descriptor 的方法同查询） descriptor 拆开，原本长度为 5 的变成一个长度为 1 的和一个长度为 4 的：</p><img src="https://pic3.zhimg.com/v2-7ee1f223b5c8a3abd3976c4d41f0ec9a_r.jpg" data-caption="" data-size="normal" data-rawwidth="307" data-rawheight="107" data-watermark="watermark" data-original-src="v2-7ee1f223b5c8a3abd3976c4d41f0ec9a" data-watermark-src="v2-2785f3696d94ccfb3e4b4d72d30c5bb3" data-private-watermark-src=""><p>然后向 add buffer 添加 <code class="inline">T</code> 和 <code class="inline">b</code> 这两个 Item ，然后在刚才两个 descriptor 中间插入一个新的 descriptor ：</p><img src="https://pic1.zhimg.com/v2-e27847c18603aa4f1e62ccd12d8cc238_r.jpg" data-caption="" data-size="normal" data-rawwidth="311" data-rawheight="151" data-watermark="watermark" data-original-src="v2-e27847c18603aa4f1e62ccd12d8cc238" data-watermark-src="v2-a505be4ef946b61cc3c4af3114f8b31f" data-private-watermark-src=""><h2>删除</h2><p>查找到 <code class="inline">offset</code> 所在的 descriptor ，拆成两个并让左边那个的长度减一即可。</p><h2>Piece Table 的优良性质</h2><ul><li>可持久化数据结构</li><li>背后的大 buffer 可以完全 lazy 化，内存中的数据量将会巨小</li><li>descriptor 数量少</li><li>可以方便地使用平衡树优化</li><li>可以被翻译成『坨坨桌子』，很可爱</li><li>它可是 Code 使用的数据结构啊，搞懂了之后拿来吹的时候逼格挺高的</li></ul><h2>Benchmark</h2><p>看论文去。</p><p>&lt;end of blog&gt;</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
