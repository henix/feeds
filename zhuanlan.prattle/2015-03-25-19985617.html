<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Javascript: 世纪机器语言？</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/19985617">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/e80a1b1b0209909ae0ea2f96bad8b744_r.jpg" alt=""></div><p>在我写了「颠覆者的游戏 - 程序语言」和「elixir - 灵丹妙药？or 徒有其名？」后，就有同学就让我讲讲javascript。对于这门让人又爱又恨的语言，真要讲，我都不知道怎么开头了。套用『北京人在纽约』里的台词：<b>「如果你爱TA，请让TA用Javascript，做为一个程序员，TA此生无忧；如果你恨TA，请让TA用Javascript，做为一个程序员，TA基本毁了」</b>。</p><br><h3>无所不在的javascript</h3><br><p>说Javascript程序员此生无忧有很多理由，最大的理由就是：web无处不在，有web存在的地方，就有javascript存在的地方，所以javascript程序员是皇上的女儿不愁嫁。一个好的javascript程序员，他的痛苦是：这么多工作机会，到底哪个是Sandberg说的rocket ship? [<a href="#_footnote_1" data-editable="true" data-title="1">1</a>]</p><br><p>javascript在web frontend的统治地位是毋庸置疑的。不像backend那么多千奇百怪的选择，在frontend，二十年来大浪淘沙，有且只有一门能在任何浏览器中运行的语言：javascript。而自 prototype 和 script.aculo.us 开启了小团队的web2.0之旅后，javascript的生态圈呈爆炸性的繁荣。</p><br><p>web backend不必多说，nodejs已经火热了几年，早年的流行词LAMP [<a href="#_footnote_2" data-editable="true" data-title="2">2</a>] 都换成了MEAN [<a href="#_footnote_3" data-editable="true" data-title="3">3</a>] 这样的full stack js framework。这让很多前端工程师努努力就变成了全栈，一下子转扶摇而上，冲到了鄙视链的上层。</p><br><p>在mobile frontend上，cordova，ionic等html5 mobile app framework在不断努力让生活在WebView下的基于javascript的hybrid mobile app能够达到接近native app的表现。作为移动领域的头牌，apple对javascript也是又爱又恨 —— 爱其繁荣的生态圈，快速产品化的能力 [<a href="#_footnote_4" data-editable="true" data-title="4">4</a>]，恨其一次编写到处运行的优势，无奈这股浪潮已经势不可当，于是在iOS 8里，apple终于在面对WebView也提供了早就在safari中提供的Nitro JIT engine。我倒不是说hybrid mobile app完全会取代native app，目前还不具备这个可能，但很多应用场景，hybrid app已经能够很好胜任。</p><br><p>桌面系统的领地，被node-webkit，atom-shell等一大票基于CEF [<a href="#_footnote_5" data-editable="true" data-title="5">5</a>] 的chrome衍生品也攻克了。CEF的理念很简单：每个app就是一个退化的chrome（可以简单认为把沙箱的限制取消了），跑开发者定制的html/css/javascript。由于chrome是跨平台的，所以这样的软件也跨平台，而且界面和web一样，可以无比丰富（也可无比贴近本地应用）。</p><br><p>硬件开发？有的是创业公司，比如tessel，看中了javascript在程序员群体的可达性，尝试提供基于javascript的SDK，来直接操纵硬件。也许有一天，FPGA的逻辑可以用javascript来描述。</p><br><h3>设计拙劣的javascript</h3><br><p>作为一门语言，javascript是一俊遮百丑的典范。随便试几例： [<a href="#_footnote_6" data-editable="true" data-title="6">6</a>]：</p><br><img src="https://pic2.zhimg.com/2c913545553f1c99c1d58048f7e17a27_r.jpg" data-rawwidth="910" data-rawheight="640"><br><p>如果你的另一半如此捉摸不定，是不是很想抽丫一大耳光，转身离去？可惜这也就止于意淫 —— 谁让人家颜值太高，小性子坏脾气再多，你也得忍着，对么？</p><br><p>javascript是可能现代编程语言中设计周期最短的，据说Brendan Eich只有10天时间来设计它，基本思路是他自己的背景（函数式编程）和网景/Sun的背景（Java和面向对象编程）的大杂烩 [<a href="#_footnote_7" data-editable="true" data-title="7">7</a>]：</p><br><p>(1) C的基本语法</p><br><p>(2) Java的数据类型和内存管理</p><br><p>(3) Scheme的函数能力（函数是一等公民）</p><br><p>(4) Self的 prototype 的继承机制</p><br><p>和其它深思熟虑设计出来的语言（比如说clojure [<a href="#_footnote_8" data-editable="true" data-title="8">8</a>]），javascript就是一个灾难。而更大的灾难是：原本只是在浏览器里跑一跑，对DOM进行简单操作，响应DOM事件，让静止的网页能够和用户有更多交互性的一门表达能力并不很强的，从来没想过单个应用会超过上千行代码（所以javascript连最基本的module都没提供）的语言，慢慢地成了世间万物（web）的主宰！</p><br><h3>javascript程序员的撕扯人生</h3><br><p>这真是件撕扯的事情。一方面语言有不少弱点，另一方面你又需要用这种语言去完成越来越多的事情。</p><br><p>比如说让人又爱又恨的 this。有好几种不同的 scope 或者 context 会使用 this，在层层嵌套的函数里，多少人用起来战战兢兢？</p><br><p>还有基于prototype的继承，有多少人真正研究一下prototype的概念，以及这么处理继承和其他主流面向对象语言的异同？优劣？</p><br><p>我们知道在学习一门新的语言时，大家往往会进行比较严格的语言训练，否则想把代码写正确并且写漂亮很难。但javascript不同，似乎没有人特别认真对待它，很多前端工程师或者后端工程师几乎就是翻一两个教程，因项目需要，顺带着把自己的语言能力扩展到javascript，根本没有系统学习，所以 —— 不得不直面各种各样的惨淡人生。</p><br><p>要getting things right，你需要了解其good part，避免其缺陷或者容易跑偏的部分。</p><br><p><img src="https://pic3.zhimg.com/1da6fc51f7a7e6a272b0398f7f3b684e_r.jpg" data-rawwidth="800" data-rawheight="450">（内涵图啊）</p><br><h3>救星：compile to javascript</h3><br><p>摆脱这种困境最直接的方法是静下心来好好学习javascript，取其精华，去其糟粕。遗憾的是，这并不如想象的那样简单。有人看到了其中的机会：既然javascript不可替换，那何不发明（利用）一门语言，将其编译成javascript呢？就像C语言被编译成机器指令，或者java被编译成byte code？</p><br><p><img src="https://pic4.zhimg.com/53979861f0bc9473707f3849475c047f_r.jpg" data-rawwidth="879" data-rawheight="907">（准机器代码）</p><br><p><img src="https://pic4.zhimg.com/ef8bac02383329fdbc7c52079dbd2ae1_r.jpg" data-rawwidth="1280" data-rawheight="476">（web世界的准机器代码）</p><br><p>于是，compile to javascript的语言便如雨后春笋般涨了出来。它们大致可以分三类：</p><br><p>1) 新语言，取javascript的子集（good parts）。如asm.js [<a href="#_footnote_9" data-editable="true" data-title="9">9</a>]，coffeescript。coffeescript用更好更简洁的语法撰写代码，编译出来的javascript比较优美。使用起来毫无压力，大爱 →，⇒ 和其函数式编程的风格。</p><br><p>2) 新语言，在javascript语言基础上扩展。如typescript。javascript的超集。没用过。</p><br><p>3) 已有语言的子集，能编译出javascript的子集。如coffeescript，gopher2js。</p><br><p><a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS" data-editable="true" data-title="List of languages that compile to JS · jashkenas/coffeescript Wiki · GitHub" class="">这里</a> 可以看到完整的compile to javascript的清单。</p><br><p>编译这事，并不简单，严复说译事三难：「信，达，雅」。这三点对应于编译就是：</p><br><p>1) 准确无误。不能歪曲了程序员的意思。</p><br><p>2) 不拘泥于原文，尽可能优化。在这里就是minify的能力要到位。</p><br><p>3) 编译结果越小越好。在这里就是dead code elimination。</p><br><p>你看一个标准的gcc编译器，这三点在不同的 -O 选项下，都能做到 [<a href="#_footnote_10" data-editable="true" data-title="10">10</a>]。而在compile to javascript领域里，做到（好） 2)与3)的很少。minify应该是编译时的动作，很多语言（比如coffeescript）都忽略它，而是使用各种现成的uglifier在编译后进行。少了AST [<a href="#_footnote_11" data-editable="true" data-title="11">11</a>]层面的支持，很多minify的事情都做不了。</p><br><p>dead code elimination更是如此，一个jQuery的Lib你可能就用到了dom operation，那各种animation的代码就是dead code。90%以上的语言在这个领域毫无作为。</p><br><p>这里要专门赞一下clojurescript，这三者它都做得很好，而且很美。clojurescript在设计之初，就把google closure compiler作为其编译基础。google closure compiler在优化javascript时的疯狂，堪比gcc的 -O3。它在做到「信」的基础上，最大程度地压缩你的代码，不仅删除所有不在执行路径上的代码，还把你的函数各种inline。当然，这是有代价的：你需要满足特定的约束，写能让closure compiler优化的代码 —— 这几乎不是正常人干的事情。所以clojurescript就替你完成这件事：你用clojure（的子集）写代码，它帮你生成满足closure script约束的javascript。</p><br><p>在小型项目上，compile to javascript的优势并不明显，但项目越大，系统越复杂，这种优势就越明显。atom是coffeescript写的，lighttable是clojurescript写的。我相信，随着这些compile to javascript的项目本身的逐渐成熟，以及其生态圈的逐渐完善，越来越多的复杂系统，会不再使用手写的javascript，转而使用表达能力更强的语言。</p><br><p>如果您觉得这篇文章不错，请点赞。多谢！</p><br><p>欢迎订阅公众号『程序人生』（搜索微信号 programmer_life）。每篇文章都力求原汁原味，北京时间中午12点左右，美西时间下午8点左右与您相会。</p><br><a href="#_footnoteref_1" data-editable="true" data-title="1">1</a>. If you’re offered a seat on a rocket ship, don’t ask what seat. Just get on.<br><a href="#_footnoteref_2" data-editable="true" data-title="2">2</a>. linux, apache, mysql, php<br><a href="#_footnoteref_3" data-editable="true" data-title="3">3</a>. mongodb, express, angular, nodejs<br><a href="#_footnoteref_4" data-editable="true" data-title="4">4</a>. 意味着单位时间能产生更多的app<br><a href="#_footnoteref_5" data-editable="true" data-title="5">5</a>. Chromium Embedded Framework<br><a href="#_footnoteref_6" data-editable="true" data-title="6">6</a>. 更多可以参见阮一峰的javascript 10个设计缺陷：<a href="http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html" data-editable="true" data-title="Javascript的10个设计缺陷" class="">Javascript的10个设计缺陷</a><br><a href="#_footnoteref_7" data-editable="true" data-title="7">7</a>. 见阮一峰的Javascript诞生记：<a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html" data-editable="true" data-title="Javascript诞生记">Javascript诞生记</a><br><a href="#_footnoteref_8" data-editable="true" data-title="8">8</a>. 简直和javascript是两个极端<br><a href="#_footnoteref_9" data-editable="true" data-title="9">9</a>. 这个有空单独撰文描述<br><a href="#_footnoteref_10" data-editable="true" data-title="10">10</a>. 函数inline，指令优化，删除无调用函数等<br><a href="#_footnoteref_11" data-editable="true" data-title="11">11</a>. Abstract Syntax Tree
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
