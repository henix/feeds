<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>流行的秘诀就是新瓶装旧酒</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/19931246">原文</a></p>
<p>Hipster都特别喜欢标榜自己推崇的东西是多么的与众不同。可是我发现了一个问题，Erlang一点都不流行啊。可见，流行并不是因为他们所说的原因。据我长时间仔细观察，发现实际上他们就是不断重复声称某个东西和别的不一样，是否真的不同不重要。</p><p>当Ruby on Rails流行起来的时候，很多人都在喊Convention over Configuration，可是在这一点上和他们的假想敌PHP又有什么本质的不同呢。Node.js更是赤裸裸地宣称在JavaScript里的event-driven相比在别的语言里就是好就是好就是好。而Go把异常改个名字，就有人声称Go里面没有异常了。这个自然是非常好的选择了。毕竟其实人是要花很长时间才能接受不同的想法的。新瓶装旧酒，就能给人以不断在学习新技术的错觉，让人获得满足感。因为没有新东西，愚蠢的地球人会很乐于接受的。这样就把旧东西顺便都卖出去了。</p><p>我记得在Erlang 17之前，很多人都在一直抱怨record，却很少有人抱怨Erlang的头文件和宏。实际上record最恶心的地方不就是因为这玩意儿就是靠头文件和宏这种机制来工作的么。但是Erlang为什么会有头文件这种奇奇怪怪的东西？是这样的，有一天Mike Williams告诉Joe Armstrong说，很多客户都在抱怨Erlang语法太奇怪了，能不能改得更像C一点。Joe Armstrong摇摇头说，Erlang已经这么简单了，没啥语法能砍掉换成类C的了。Mike Williams说，恶心他们一下也没什么，反正他们受得了C。Joe Armstrong说，那好吧，那就学一下C语言里的头文件和宏的概念吧。后面的结果大家都知道了。其实Erlang里Map实现非常简单，说穿了就是两个tuple()。<br></p><p>现在Erlang有了Map，许式伟就提出是时候放弃Erlang了。我想，是时候黑许式伟了。自从许式伟听说Go语言之后，他就一个劲的在黑Erlang，黑来黑去其实挺好的，但是他整天把Erlang的优点当成缺点在黑，也是蛮拼的。不难看出，许式伟不是水货就是在卖私货。卖私货的可能性更大一点。毕竟七牛这个名字，据说就是因为他们有七个大牛。一开始他们用Erlang，结果一个大牛就把所有工作都做完了，另外六个大牛都闲着没事干。老板就不高兴了。后来他们发现了Go，这下七个人都有活干了，Go语言比较新方便宣传，还能把潜在的竞争对手带进沟里去，想必那是极好的。此言一出，就有机智的网友在评论里提醒我七牛是不会承认这点的。那许式伟自然就是水货了。Q.E.D.</p><p>下面就按他是水货的思路来黑</p><p>pth不就是那个用来在那些没实现线程的内核里用来凑合当线程用的东西么，Java一开始还只用类似的东西号称绿色线程呢。这都没听说过，难道不是水货么？(当然从标榜不同的角度讲，反正CERL已经用不着了，和别人相同就相同了)。</p><p>至于那个栈能自动增长。自从编译器有了split stack的功能，C语言里其实也可以这么做的。Go和Rust都用过一段时间split stack，当然都已经不约而同的放弃了，改用别的办法来达到类似的效果了。而且Go语言效果比你在C里面用个库好，那是因为他是一门不同的语言，从语言设计上就可以考虑这个问题。C语言你加私有扩展其实也可以做到的嘛。</p><p>上面也有可能是恰好不了解，也说不定。可其他黑Erlang的地方，只会使用稻草人攻击，段子也编不像样，黑的水准是不是太低了点呢？</p><blockquote><p>首先谈谈对锁的态度，Erlang对锁非常反感，它认为变量不可变可以很大程度避免锁，Erlang认为锁有很大的心智负担所以不应该存在锁。 <br></p></blockquote><p>Erlang没有反对过锁，Erlang从来没有提倡过程序不该用锁，通过变量不可变来避免锁也就无从谈起了。逻辑上需要锁，难道你不用么？好像Erlang相关的工具，有一个帮助你检查哪些可能有死锁的地方的工具(可能是正在开发，不确定没查资料完全凭感觉写的)，难道是来糊弄人的。Erlang反对的是，你自己用CPU指令去实现锁。因为不同的进程可能根本就不在一台机器上，请问怎么用CPU指令去锁？Erlang不鼓励进程之间共享内存，因为不同的进程可能根本就不在一台机器上，请问他们之间怎么共享内存？</p><blockquote><p>那么可能会有人问，那Erlang怎么做高并发呢？其实是两点：第一是每个Erlang物理的进程会有很多的服务器，每个服务器相互是无干扰的，它们可以并发。第二是单服务器想要高并发怎么办？Erlang对这个问题的回答就是请异步IO。 </p></blockquote><p>此处莫非goroutine有魔法了？ <br></p><blockquote><p>首先为什么会有中间状态的引入？因为有异步IO，所以刚刚的某一个请求其实还没有完成，但是它必须把时间让给另外一个请求 ，所以这个时候服务器就要维持刚刚没有完成的那个请求的中间状态。一旦有中间状态的话，这个服务器的状态本身就不干净，单次请求的中间状态要服务器来维持状态，这个是非常不合理的事情。</p></blockquote><p>实际上有些协议要求一个连接能连续发多个请求，且要求你不能等前一个请求处理完再处理下一个请求的。请和制订协议的人去理论去。除非你能告诉我你Go里面怎么用同步的逻辑来实现？难道不是和Erlang一样再起一个进程来处理这个请求吗？ </p><br><blockquote><p>多核时代已经喊了快十年了，但是我们大家可以看到，几乎没有多少语言把执行体这个作为语言内建标准来做，我觉得这是Go很大的创举。</p></blockquote><p>SIMULA-67，Ada等一大帮语言哭了。就语法特别像C的大部分都没有而已。即便是Erlang也比Go先出现，Erlang从来没说这个概念是原创的。</p><blockquote><p>因为Erlang收到请求以后没有办法创建一个子的执行体，然后让它处理某一个具体的请求
不用再管它。但是Erlang里面进程没有共享状态，你要改服务器状态必须用异步IO的方式，把事情做了再把消息扔给服务器对他说你自己改状态。通过消息
改服务器状态，这个成本是比较大的，而且带来了很多问题。</p></blockquote><p>A History of Erlang里就说了</p><blockquote>If a data structure is shared by two phys-<br>ical nodes and if one node fails, then failure recovery is often im-<br>possible. The reason why Erlang shares no data structures and uses<br>pure copying message passing is to sidestep all the nasty problems<br>of figuring out what to replicate and how to cope with failures in a<br>distributed system. </blockquote><p>其实这里有两个问题，一是子进程在另外一台机器上，你根本没办法共享内存。二是，即便能共享内存，通过共享内存改变状态不代表你启动子进程完了就不用管了，子进程改状态改到一半挂了怎么办？你是打算连带着挂掉所有其他子进程呢，还是在你的server进程里处理各种状态改一半就挂了的情况？这不是把问题越搞越复杂了么。当然了，你也可以说你的程序从不出错，是的，我想你可以做到的。</p><blockquote><p>I remember Mike, Robert and I having great fun asking the<br>same question over and over again: “what happens if it fails?”—<br>the answer we got was almost always a variant on “our model<br>assumes no failures.”</p></blockquote><p>许式伟判断一门语言的好坏，主要就看这门语言共享内存是否和C++一样方便。学一门新语言非要去看自己熟悉的语言擅长的地方是不是也都一样好。我求您别学新语言了。Alan J. Perlis就说过</p><blockquote>A language that doesn't affect the way you think about programming, is not worth knowing. <br></blockquote><p>他发现在自己熟悉的语言擅长的地方不一样好，就能立即得出结论</p><blockquote>Erlang语言并没有带来什么实质性的好处。</blockquote><p>Erlang语言在开发的过程中做了大量对比实验来验证Erlang是否真的好。</p><blockquote><p>If you don't run experiments before you start designing a <b>new</b> system, your <b>entire system</b> will be an experiment!</p><p>—Mike Williams</p></blockquote><p>A History of Erlang里就提到了一开始他们就用能找到的各种不同风格的语言实现同一个程序，试图从中选出一门最合适的语言作为基础，结果没一种语言包含足够多他们需要的语言特性，接着他们就开始尝试把各种语言中比较合适的语言特性合并到一起。一开始Joe Armstrong是在Smalltalk的基础上实现的，奈何当时unix上运行的Smalltalk GC一次至少要15分钟，他们就去订购Smalltalk Machine，结果等了几个月快递还没把货送到，正好在这段时间他们在Prolog上已经实现了不少功能了，最后Smalltalk machine终于来了，也不能闲着吧，就让给后来成为UML三巨头之一的那位爷爷去玩了。等到Erlang逐渐成熟起来，他们也用Erlang去实现一个接近实际的项目，和用别的语言实现做对比，发现平均开发效率大约是后者的8倍。<br></p><p>最近出现的一些新语言，很少有像Erlang这样真的用一个比较实际的项目去做实验的。可能Rust比较好一点，Mozilla开发这门语言的时候是真的在用他写一个浏览器，但其实也没有比较严格的对比实验。</p><p>当然你可以认为爱立信是自吹自擂，那摩托罗拉总没必要刻意吹捧竞争对手开发的语言吧。摩托罗拉的研究结果显示，完成相同的功能，Erlang平均只需要C++ 
1/7的代码量，和8倍开发效率大致接近。同时，Erlang的平均响应时间大约是C++的一半，吞吐量却大约是C++的两倍。而且C++程序在超过设计负载没多少的时候就挂掉了，需要手工重启。<a class="" data-title="hw.ac.uk 的页面" data-editable="true" href="http://www.macs.hw.ac.uk/~trinder/papers/CPE2006.pdf"> http://www.macs.hw.ac.uk/~trinder/papers/CPE2006.pdf</a></p><p>Erlang语言概念特别少，主要只有三个，模式，函数和消息。变量是个坏翻译。variable应该翻译成元。从某种角度看，变量就应该是不可变的，所谓的变量不可变根本就不是问题。许式伟所谓的变量可变实际上相当于OCaml里，所有变量都用ref。</p><p>在比较知名的语言里，Erlang可能是唯一一个把错误代码和异常分清楚的。你永远只返回错误代码，调用的一方只匹配能处理的情况。而不能处理的情况，因为没有匹配，会自动引发异常。异常发生时就应该让进程挂掉，因为这不是你代码预期的情况，此时做任何多余的事情最有可能的结果就是让情况变得更糟糕。</p><p>在这之上有supervision tree。万一一个重要的进程莫名奇怪的挂了，可能他就是需要重启一下。</p><blockquote><p>Have you tried turning it off and on again?</p><p>— IT Crowd<br></p></blockquote><p>再往上，Erlang是一门control plane的语言。Erlang比较适合用来写运行在很多台机器上的服务的controller，Erlang就是用来写业务逻辑的。只不过很多语言网络吞吐能力如此糟糕，不做丧心病狂的优化，用来处理data plane竟然还比不过不优化的Erlang。于是他们就宣称Erlang只适合用来转发数据包，不适合用来写复杂的业务逻辑。OpenFlow出来一段时间之后，我还在想为啥就没人用Erlang写个实用的Controller呢，结果其实也没过多久，就听说Tail-f被Cisco收购了。</p><p>我想，你也会觉得Erlang是一门不错的语言的。毕竟</p><blockquote><p>... the rest of the world was wrong and ... we were right</p><p>— A History of Erlang</p></blockquote>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
