<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Rust编程</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/</link>
<description>与 Rust 语言相关的方方面面</description>
<language>zh-cn</language>
<lastBuildDate>Sun, 18 Nov 2018 14:21:26 +0800</lastBuildDate>
<item>
<title>Rust 在 Windows 下使用 CLion 进行调试</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-11-13-49515204.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49515204&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-62ca848fbf03afd0d8a31cf7edf3b1e9_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;前言：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;就性能或者其他各方面来说，在 Windows 上使用 MSVC 作为后端当然是最好的，也是官方默认的安装选项。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c4c8739aaa85004fb659f27166c73130_r.jpg&quot; data-caption=&quot;滚动到页面下方展开即可看到&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1417&quot; data-rawheight=&quot;569&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c4c8739aaa85004fb659f27166c73130&quot; data-watermark-src=&quot;v2-417559ac788bbc55c7ac5b320d5ebd89&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a20851ee3191f905f912bb22a7c16f15_r.jpg&quot; data-caption=&quot;勾选 Visual C++ 生成工具&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1255&quot; data-rawheight=&quot;644&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a20851ee3191f905f912bb22a7c16f15&quot; data-watermark-src=&quot;v2-4cea71ca847a77a19672dd81620759fa&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;只是需要下载大概 800M 左右的数据，占用 5G 左右的安装空间，对开发者来说倒是习以为常，对很多想尝试或者了解的人就有点不太友好了。&lt;/p&gt;&lt;p&gt;初学者可以选择 x86_64-pc-windows-gnu 版本的 msi 安装包（不到 200MB），图形化界面，安装即用（不涉及到需要编译 C/C++ 代码或者 ABI 兼容问题时都是完全 OK 的，出现需求了再配置即可），编译出来的 exe 在性能和大小上和 MSVC 版略有不同：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-df57a5f5d059465ef4ecb556a3149726_r.jpg&quot; data-caption=&quot;影响不大&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;575&quot; data-rawheight=&quot;44&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其实使用 MSVC 后端更主要的问题是调试，参看 &lt;a href=&quot;https://areweideyet.com/&quot;&gt;https://areweideyet.com/&lt;/a&gt; 列出的各 IDE / Editer 的支持情况 。在 Windows 上比较好的解决办法是使用 VS Code ，安装 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools&quot;&gt;C/C++&lt;/a&gt; 插件再稍作配置即可调试，但是就目前的使用体验来说，调试问题是解决了，编码体验却真的不怎么样，&lt;a href=&quot;https://github.com/rust-lang-nursery/rls-vscode&quot;&gt;rls-vscode&lt;/a&gt; 只是勉强能用，而且 issue 提个不断，更新却接近停滞。&lt;/p&gt;&lt;p&gt;使用 CLion + &lt;a href=&quot;https://intellij-rust.github.io/&quot;&gt;intellij-rust&lt;/a&gt; 是比较好的选择，不过 CLion 不支持 MSVC 工具链的调试，所以我们需要使用 windows-gnu 工具链来生成目标代码，然后在 CLion 里使用 GDB 来调试。&lt;/p&gt;&lt;p&gt;推荐的做法是安装 MSYS2，再使用 MSYS2 安装 MinGW toolchains，但是目前 CLion 还不支持 MinGW-w64 的 GDB 8.2 版本：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0ed77109991906e0c969ed8476e6d8fb_r.jpg&quot; data-caption=&quot;踩坑了&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;615&quot; data-rawheight=&quot;341&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0ed77109991906e0c969ed8476e6d8fb&quot; data-watermark-src=&quot;v2-f8ad4bc1c3bb822c37022ec369453677&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;没关系，除了MSYS2，还有 &lt;a href=&quot;https://mingw-w64.org/doku.php&quot;&gt;GCC for Windows 64 &amp;amp; 32 bits [mingw-w64]&lt;/a&gt; 可选择，Cygwin 就算了。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;安装：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;安装很简单，步骤为：&lt;/p&gt;&lt;p&gt;下载 MinGW-w64 并解压 -&amp;gt; 配置环境变量 Path -&amp;gt; 配置 CLion -&amp;gt; 安装或者配置 Rust&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在 &lt;a href=&quot;https://sourceforge.net/projects/mingw-w64/files/&quot;&gt;MinGW-w64 - for 32 and 64 bit Windows&lt;/a&gt; 页面下方可以找到安装文件，可以选择 installer 按步骤安装，也可以直接下载 7z 压缩包，我选择了 GCC-8.1.0 x86_64-posix-seh  7z 包，&lt;a href=&quot;https://wiki.qt.io/MinGW-64-bit&quot;&gt;线程模型和异常处理&lt;/a&gt;和你的 Rust 工具链版本保持一致。解压缩到你喜欢的目录，我解压缩在 C:\Dev 下。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;添加 MinG-w64 的 bin 到环境变量 Path 中：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4d163869d991ebceafbc14c33287c7db_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;527&quot; data-rawheight=&quot;252&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4d163869d991ebceafbc14c33287c7db&quot; data-watermark-src=&quot;v2-dc2691ed45312a66e0ced8ebc32efca1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在 CLion 的 Settings &amp;gt; Build, Execution, Deployment &amp;gt; Toolchains 里配置 MinGW ：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-926786a060dbd6f448e3846e99d03e1a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;610&quot; data-rawheight=&quot;370&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-926786a060dbd6f448e3846e99d03e1a&quot; data-watermark-src=&quot;v2-6b76ae0e6956a2a7e26b08573f839c62&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下载并运行 &lt;a href=&quot;https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-gnu/rustup-init.exe&quot;&gt;x86_64-pc-windows-gnu-rustup-init&lt;/a&gt; ，按提示完成安装即可。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;补充：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果你下载的是默认的 rustup-init.exe ，可以先跳过它的警告，Continue 继续到下一步，输入 2 （Customize installation）回车，在 Default host triple? 下输入 x86_64-pc-windows-gnu ，剩下两项直接回车保持默认，最后输入 1 回车开始安装，效果一样：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-13ddbd9d3cf00cd39693bea5ff4d532e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;591&quot; data-rawheight=&quot;452&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-13ddbd9d3cf00cd39693bea5ff4d532e&quot; data-watermark-src=&quot;v2-5473a6cb83cfe25c84e71e3a8f37ea06&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果你之前已经安装好了Rust，你还是可以方便地通过 rustup 来安装和切换工具链，这也是 Rust 的优点之一。运行 rustup toolchain install xxx 安装，rustup override xxx 和 rustup target xxx 切换，自行 Google。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;打开一个 Rust 项目测试下：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0a2348923ed538eacb2b46dce96b6a02_r.jpg&quot; data-caption=&quot;完美调试&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1078&quot; data-rawheight=&quot;466&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0a2348923ed538eacb2b46dce96b6a02&quot; data-watermark-src=&quot;v2-3b477faa599b0ece0e220bb6c5067a2e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;后记：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;windows-gnu 版本的 Rust 是自带 gcc 和 ld 的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ef634ab2094ed4b104d3aa99a34487b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;649&quot; data-rawheight=&quot;214&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0ef634ab2094ed4b104d3aa99a34487b&quot; data-watermark-src=&quot;v2-cfd8f74863437a817f33d975a35e2e99&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以它可以不依赖 MSVC 生成 exe ，不过目录里的 GCC-WARNING.txt 有云：&lt;/p&gt;&lt;blockquote&gt;gcc.exe contained in this folder cannot be used for compiling C files - it is onlyused &lt;br&gt;as a linker. &lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;CLion 自带的 JRE 是基于 OpenJRE 的，对字体渲染上有点问题，可以把安装目录下的 jre64 删除或者重命名成其他，再在 Oracle 下载一个 .tar.gz 版本的 JRE ，解压缩后文件夹更名为 jre64 粘贴到 CLion 安装目录即可。&lt;/p&gt;</description>
<author>6enmel</author>
<guid isPermaLink="false">2018-11-13-49515204</guid>
<pubDate>Tue, 13 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>新书发布</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-09-14-44576072.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44576072&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6a4affbd8cee44ebfa8ec51d6dede688_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;我已经有一年时间没有给知乎专栏和公众号写新的文章了。因为我的业余时间基本都在写书。最近这本书终于出版了，定名为《深入浅出Rust》。纸质版和电子版都有提供，欢迎各位按需选购。&lt;/p&gt;&lt;p&gt;这本书的构思起源于两年多以前。之所以拖到现在才搞定，主要原因是我低估了写一本书的难度。实际上我的交稿日期比合同规定的晚了十个月，因此我非常感谢机械工业出版社的编辑的耐心。&lt;/p&gt;&lt;p&gt;本书应该是第一本正式出版发行的中文原创Rust书籍，凝聚了我的不少的心血。既然挂上了自己的名字，那么这件事情就事关荣誉，生怕戴上一顶”误人子弟“的帽子。为此我在写书的时候特别注意”言之有据“，所有的功能都有示例代码，没有较大把握的东西就不写了。当然，因为水平有限，错漏之处在所难免，非常欢迎各位读者提出批评和建议。我在github上创建了一个项目 &lt;a href=&quot;https://github.com/F001/rust_book_feedback&quot;&gt;https://github.com/F001/rust_book_feedback&lt;/a&gt;，各位可以到这里给本书提出反馈意见。&lt;/p&gt;&lt;p&gt;从内容的广度上讲，本书覆盖了Rust的绝大多数功能，甚至还有许多未稳定的功能都讲到了。只有极少数稳定功能(比如SIMD)因为时间原因来不及加入了。&lt;/p&gt;&lt;p&gt;从内容的深度上讲，本书应该覆盖了Rust大部分的初级和中级知识点。本人特别不希望把这本书写成英文翻译腔，所有内容都是自己理解消化之后，使用自己的语言重新讲出来，希望这样能让读者更容易接受一点。&lt;/p&gt;&lt;p&gt;这本书可以算是本人学习Rust的一个阶段性总结，也算是了却了一桩心愿。接下来，我给自己定了两个目标：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;重新开始更新知乎专栏和公众号。Rust这段时间还是有不少的进展的，有很多值得写的东西。而且我越来越觉得把一个东西学会了再用自己的语言给别人讲清楚，对自己是一个很好的锻炼。&lt;/li&gt;&lt;li&gt;学习Rust编译器的内部实现，更深入地理解Rust语言。在写书的过程中，我发现和总结了Rust里面还有哪些内容是我目前没有理解没有掌握的。要想深刻理解这些问题，唯一的办法就是搞清楚rustc的实现机制。我最近给Rust编译器实现的一个非常小的功能&lt;a href=&quot;https://github.com/rust-lang/rust/pull/53751&quot;&gt;rfc 2302&lt;/a&gt;已经合并了，这是一个不错的开始。希望我以后能给Rust项目做出更大的贡献。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;广告完毕，我们下次再见！&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2018-09-14-44576072</guid>
<pubDate>Fri, 14 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust 中，常规的 vector 是一种值</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-05-30-37488569.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37488569&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2018/02/01/in-rust-ordinary-vectors-are-values/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;In Rust, ordinary vectors are values&lt;/a&gt;&lt;p&gt;作者：Niko Matsakis  译者：Quan Brew&lt;/p&gt;&lt;p&gt;本文不需要 Rust 基础也能阅读。其中 vector 指的是大多数语言中的 List 或者动态数组。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我最近一直在思考持久化容器 (persistent collections)，特别是它们与 Rust 的关系，我想写下一些我的观察。[1]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;什么是持久化容器&lt;/h2&gt;&lt;p&gt;传统上，持久化容器被看作是一种与众不同的建立容器的方法。传统的容器有类似&lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt;的方法，能让 vector &lt;b&gt;原地&lt;/b&gt;增长：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;
vec.push(element); // 往 `vec` 增加元素&lt;/code&gt;&lt;p&gt;而持久化容器有类似&lt;code class=&quot;inline&quot;&gt;add&lt;/code&gt;的方法，能保留原本的 vector 不动，而返回一个已经被修改的&lt;b&gt;新vector&lt;/b&gt;：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let vec2 = vec.add(element);&lt;/code&gt;&lt;p&gt;此处的关键特性在于&lt;code class=&quot;inline&quot;&gt;vec&lt;/code&gt;没有改变，这使得持久化容器非常适合函数式语言（以及适合并行计算）。&lt;/p&gt;&lt;h2&gt;持久化容器如何运作&lt;/h2&gt;&lt;p&gt;我不会详细介绍任何特定的设计，但是大多数都是基于某种树的。比如说，如果有一个 vector 类似于&lt;code class=&quot;inline&quot;&gt;[1, 2, 3, 4, 5, 6]&lt;/code&gt;，可以想象一下，这些值不是以一大块的方式储存，而是将它们储存在某种树中，值保存在叶子结点里。在下面的示意中，元素被分开放在两个叶子结点，父节点的指针指向这两个节点：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
 [*        *] // &amp;lt;-- 这是 vector 的父节点
  |        |
-----    -----
1 2 3    4 5 6&lt;/code&gt;&lt;p&gt;现在想想我们要改变 vector 中的一个值，比如说我们想把&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;改成&lt;code class=&quot;inline&quot;&gt;10&lt;/code&gt;。这意味着我们必须改变右节点，但可以继续使用左节点。所以我们创建一个新的父节点，这样就能引用新的右节点。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
 [*        *]   // &amp;lt;-- 原 vector
  |        |    //     (仍然存在，没有被改变)
-----    -----
1 2 3    4 5 6
-----
  |      4 5 10 // &amp;lt;-- 右节点的新拷贝
  |      ------
  |        |
 [*        *]   // &amp;lt;-- 新的 vector&lt;/code&gt;&lt;p&gt;对于一个平衡的树中，这通常意味着往一个持久化 vector 中插入元素往往是 &lt;equation&gt;O(\log n)&lt;/equation&gt; ——我们必须复制和修改一些叶子，然后必须复制和修改所有这条路径的父节点。&lt;b&gt;这比修改传统的 vector 开销更大，修改传统的 vector 只是一些CPU指令。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一些意见：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果这个 vector 实际上没有&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%88%AB%E5%90%8D_(%E8%AE%A1%E7%AE%97)&quot;&gt;别名&lt;/a&gt;（多处引用同一段内存），并且你知道它没有别名，那么常常可以避免这些复制，仅仅是原地修改树。稍后，我会谈到 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://docs.rs/dogged/0.2.0/dogged/struct.DVec.html&quot;&gt;DVec&lt;/a&gt;&lt;/code&gt;，一个试验性的 Rust 持久化容器库做到了这个特性。但在典型的基于 GC 的语言中很难做到，因为你永远不知道自己在用的是别名。&lt;/li&gt;&lt;li&gt;持久化容器有非常多的其他设计，其中一些设计偏向于特定的使用模式。比如说，&lt;a href=&quot;https://www.lri.fr/~filliatr/ftp/publis/puf-wml07.pdf&quot;&gt;这个论文&lt;/a&gt;提出了一个针对于类似 Prolog 程序的设计；这个设计内部用了可变方式实现 &lt;equation&gt;O(1)&lt;/equation&gt; 插入，但是在接口上对用户隐藏。当然，这些低开销的插入是有代价的：数据结构的较老的拷贝使用起来开销很大。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;持久化容器让容器变成值&lt;/h2&gt;&lt;p&gt;某些情况下，持久化容器能让代码更容易被理解。因为他们更像一个「普通的值」，没有自己的「秉性」。来看这个JS代码，用整数：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;
function foo() {
    let x = 0;
    let y = x;
    y += 1;
    return y - x;
}&lt;/code&gt;&lt;p&gt;此处我们修改 &lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt; 的时候，不期望 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 也改变，因为 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 只是一个简单的值。但是如果改成用数组：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;
function foo() {
    let x = [];
    let y = x;
    y.push(22);
    use(x, y);
}&lt;/code&gt;&lt;p&gt;现在修改&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;也会跟着改变。也许这正是我们想要的，但有时候不是。当 vector 藏在对象后面的时候，事情会愈发让人摸不清头脑：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;
function foo() {
    let object = {
        field: []
    };
    ...
    let object2 = {
        field: object.field
    };
    ...
    // 现在 `object.field` 和 `object2.field` 在幕后秘密相连
    ...
}&lt;/code&gt;&lt;p&gt;不要误会，有时候&lt;code class=&quot;inline&quot;&gt;object.field&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;object2.field&lt;/code&gt;是指向同一个 vector 是非常方便的。但另一些时候这不是你想要的。我常常发现改成持久化容器能让我的代码更清晰、易于理解。&lt;/p&gt;&lt;h2&gt;Rust 是特别的&lt;/h2&gt;&lt;p&gt;如果你曾看过我对于 Rust 的一次演讲[2]会知道，我反复强调 Rust 设计的一个核心要素：&lt;/p&gt;&lt;blockquote&gt;数据分享和可变：都是好东西，但放在一起就非常可怕。&lt;/blockquote&gt;&lt;p&gt;基本上，这个想法是，当有两个不同的路径访问同样的内存（在上一个例子中的&lt;code class=&quot;inline&quot;&gt;object.field&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;object2.field&lt;/code&gt;），对它进行修改就是非常危险的意图。对于 Rust 试图放弃使用 GC，情况就尤其如此，因为突然不清楚谁应该管理这块内存了。&lt;b&gt;但哪怕使用 GC 也是如此&lt;/b&gt;，因为一个像&lt;code class=&quot;inline&quot;&gt;object.field.push(...)&lt;/code&gt;的修改可能影响比预料中更多的对象，从而导致错误（尤其是但不限于发生在并行线程中的情况）。&lt;/p&gt;&lt;p&gt;那么，如果试图两次访问同一个 vector，在 Rust 中会发生什么？回到刚刚看到的 JavaScript 例子，但这次使用Rust写。第一个例子是用整数，运作得和JS一样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;
let x = 0;
let mut y = x;
y += 1;
return y - x;&lt;/code&gt;&lt;p&gt;但第二个例子，也就是用 vector，根本不会通过编译：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;
let x = vec![];
let mut y = x;
y.push(...);
use(x, y); // ERROR: use of moved value `x`&lt;/code&gt;&lt;p&gt;问题在于，一旦用了 &lt;code class=&quot;inline&quot;&gt;y = x&lt;/code&gt;，就已经拿走了 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 的所有权，这样它就不能再被使用了。&lt;/p&gt;&lt;h2&gt;在 Rust 中，普通的 vector 是值&lt;/h2&gt;&lt;p&gt;可以引出结论。在 Rust 中，日常使用的「普通的容器」&lt;b&gt;已经像值一样行事&lt;/b&gt;：实际任何 Rust 类型都是如此——只要不使用&lt;code class=&quot;inline&quot;&gt;Cell&lt;/code&gt;或者&lt;code class=&quot;inline&quot;&gt;RefCell&lt;/code&gt;。换句话说，假设代码通过编译，你知道你的 vector 没有在多个地方被修改：你可以用一个整数来代替它，而它会有相同的行为。这样很好。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这意味着就 Rust 而言，持久化容器和普通容器相比，不必一定要有「不同的接口」。&lt;/b&gt;例如，我创建了一个名为&lt;a href=&quot;https://crates.io/crates/dogged&quot;&gt;dogged&lt;/a&gt; [3] 的持久化 vector。Dogged 提供了一种称为 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://docs.rs/dogged/0.2.0/dogged/struct.DVec.html&quot;&gt;DVec&lt;/a&gt;&lt;/code&gt; 的 vector 类型，它基于&lt;a href=&quot;https://hypirion.com/musings/understanding-persistent-vector-pt-1&quot;&gt;Clojure 提供的持久化 vector&lt;/a&gt;。但如果看看 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://docs.rs/dogged/0.2.0/dogged/struct.DVec.html&quot;&gt;DVec&lt;/a&gt;&lt;/code&gt; 提供的方法，会发现这是一种标准的容器（有 &lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt; 等等）。&lt;/p&gt;&lt;p&gt;比如说这是一种 &lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt; 的有效操作：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let mut x = DVec::new();
x.push(something);
x.push(something_else);
for element in &amp;amp;x { ... }&lt;/code&gt;&lt;p&gt;尽管如此，一个&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;还是一个持久化数据结构。在实现上，一个 &lt;code class=&quot;inline&quot;&gt;Dvec&lt;/code&gt; 被实现为&lt;a href=&quot;https://zh.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt;。它包含一个 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/sync/struct.Arc.html&quot;&gt;Arc&lt;/a&gt;&lt;/code&gt; （引用计数指针）来引用其内部数据。当调用&lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt;时，我们会更新&lt;code class=&quot;inline&quot;&gt;Arc&lt;/code&gt; 指向新的vector，并把旧数据留在原地。&lt;/p&gt;&lt;p&gt;（顺便说一句，&lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/sync/struct.Arc.html#method.make_mut&quot;&gt;Arc::make_mut&lt;/a&gt;&lt;/code&gt;是一个&lt;b&gt;非常酷的&lt;/b&gt;方法。它检查&lt;code class=&quot;inline&quot;&gt;Arc&lt;/code&gt;的引用计数：如果是1，则给你对内容的唯一（可变）访问权限；如果引用计数&lt;b&gt;不是&lt;/b&gt;1，那么它将复制&lt;code class=&quot;inline&quot;&gt;Arc&lt;/code&gt;（及其内容），并给你这个复制的数据的可变引用。如果回想起持久化数据结构是如何运作的，就能发现这对于更新一个树是&lt;i&gt;完美的&lt;/i&gt;，它让你在容器没有别名的情况下，可以避免复制操作。）&lt;/p&gt;&lt;h2&gt;但持久化容器间是不同的&lt;/h2&gt;&lt;p&gt;一个 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 和一个 &lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt; 之间的主要区别不是它们提供的操作，而在于&lt;b&gt;它们的开销&lt;/b&gt;。也就是说，当在一个标准的&lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt;上&lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt;时，它是一个 &lt;equation&gt;O(1)&lt;/equation&gt; 操作。当复制它的时候，就是 &lt;equation&gt;O(n)&lt;/equation&gt; 。对于一个&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;，开销截然不同：&lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt;是 &lt;equation&gt;O(\log n)&lt;/equation&gt; ​，但是复制是 ​ &lt;equation&gt;O(1)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;尤其对于一个&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;clone&lt;/code&gt;操作只是增加内部的&lt;code class=&quot;inline&quot;&gt;Arc&lt;/code&gt;引用计数，而对于普通vector，&lt;code class=&quot;inline&quot;&gt;clone&lt;/code&gt;必须复制所有数据。&lt;/b&gt;当然，对一个&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;执行&lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt;，会在重建树受影响的部分时复制一部分数据（而&lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt;一般只需要在数组末尾写入数据）。&lt;/p&gt;&lt;p&gt;众所周知，「大O」记法只描述渐进耗时。&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;我已经遇到的一个问题在于，在性能上它很难与标准的&lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt;竞争。单纯地整串复制数据经常比更新树以及分配内存要快。我发现只有在极端情况下才有用&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;的理由——比如说做大量复制操作，或者有大量数据。&lt;/p&gt;&lt;p&gt;当然不全关于性能。如果进行大量复制操作，&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt; 也应该使用更少的内存，因为大量内部数据可以共享。&lt;/p&gt;&lt;h2&gt;结论&lt;/h2&gt;&lt;p&gt;在这里我通过持久化容器试图说明，Rust 的所有权系统是如何以一种巧妙的方式，将函数式风格和命令式风格融合。&lt;b&gt;也就是说，Rust 的标准容器虽然以典型的命令式接口实现，但实际上它们像是「值」一样在运作：&lt;/b&gt;在将一个 vector 从一个地方赋值到另一个地方的时候，如果想继续使用原本的那个，就必须&lt;code class=&quot;inline&quot;&gt;clone&lt;/code&gt;它，这就使得新的拷贝独立于旧的那个。&lt;/p&gt;&lt;p&gt;这不是新的见解。比如说1990年，Phil Wadler 写了一篇&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.5439&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;题为《线性类型可以改变世界！》的论文&lt;/a&gt;，在这之中他得出几乎一摸一样的结论，然而是从相反的起点出发。在论文中他说，依旧能提供一个持久化的接口（例如，&lt;code class=&quot;inline&quot;&gt;vec.add(element)&lt;/code&gt;返回新 vector 的方法），但如果使用线性类型，可以通过一个命令式的数据结构暗地里实现它（例如&lt;code class=&quot;inline&quot;&gt;vec.push(element)&lt;/code&gt;），而不让别人知道。&lt;/p&gt;&lt;p&gt;在摆弄&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;的时候，我发现一个持久化 vector 也提供常规（命令式）接口是很有用的。比如说，我能够非常容易修改&lt;a href=&quot;https://crates.io/crates/ena&quot;&gt;ena 合一库&lt;/a&gt;（在内部它基于一个vector）让它运作在持久化模式（使用&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;）或者命令式模式（使用&lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt;）。基本的点子是将具体的 vector 类型泛型化，如果这些类型提供一样的接口的话这会很简单。&lt;/p&gt;&lt;p&gt;（另外，我乐意看到更多的实验。比如说，如果一个 vector 开始时是一个常规 vector，但是超过某个长度就会变成持久化 vector，我认为是非常有用的。）&lt;/p&gt;&lt;p&gt;&lt;i&gt;特别&lt;/i&gt;对于 Rust，我觉得有其他的原因让人对持久化容器产生兴趣。同时对数据进行分享和修改是一种有风险的模式，但有时候是必要又有用的，而在 Rust 现在用起来感觉是反人类的。&lt;b&gt;我认为我们应该做一些事情来改善这种情况，我也有一些具体的想法&lt;/b&gt;[4]，但我觉得在这里使用「持久化 vs 命令式容器」的表述是不合理的。换句话说，Rust 已经&lt;i&gt;有了&lt;/i&gt;持久化容器，它只是在&lt;code class=&quot;inline&quot;&gt;clone&lt;/code&gt;操作上特别低效。&lt;/p&gt;&lt;h2&gt;脚注&lt;/h2&gt;&lt;p&gt;[1]: 正好，我之前写的 SLG 求解器似乎特别喜欢用持久化容器。&lt;/p&gt;&lt;p&gt;[2]: 如果还没有，那么我觉得&lt;a href=&quot;https://www.sics.se/nicholas-matsakis&quot;&gt;这个&lt;/a&gt;非常好。&lt;/p&gt;&lt;p&gt;[3​]: 在英语中，如果你“dogged”地追求你的目标，你就很坚持不懈 (persistent)。&lt;/p&gt;&lt;p&gt;[4]: 具体的想法，必须等到下一篇博客文章。现在是让我女儿去上学的时间了！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>酿酿酿酿酿泉</author>
<guid isPermaLink="false">2018-05-30-37488569</guid>
<pubDate>Wed, 30 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust - RFC 导读: async/await 特性（二）</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-05-25-37298671.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37298671&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b357cf4b2202c2f3e9edb6c3b6204680_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;由于本篇文章代码较多，如果知乎的排版伤害了你的眼睛，可以暂时移步到 &lt;a href=&quot;https://github.com/andylokandy/article/blob/master/Rust%20-%20RFC%20%E5%AF%BC%E8%AF%BB%20async%20%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89.md&quot;&gt;这里&lt;/a&gt;。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37209852&quot;&gt;上一篇&lt;/a&gt;我们讲到了编译器对 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 的特性支持，相应的，我们要让编译器知道 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 是什么，编译器才能生成匿名的 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 类型。为此，我们就有了第二份 RFC —— 将 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 加入标准库（准确来说是 &lt;code class=&quot;inline&quot;&gt;libcore&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/aturon/rfcs/blob/async-trait/text/0000-async.md&quot;&gt;RFC 2418 companion libs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;注意这篇 RFC 还在讨论阶段并未被 merge，因此最终方案可能会改变，目前已经可以看见讨论区提出了相较于 &lt;code class=&quot;inline&quot;&gt;arbitrary self type&lt;/code&gt;（&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;self&amp;gt;&lt;/code&gt;） 更好的解决方案，这部分是最有可能发生变化的。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Summary&lt;/h2&gt;&lt;p&gt;这篇文章将会深入 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 的实现原理，如果读者只是希望使用现成的库和 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 语法，仅看上一篇文章就已经足够了。而如果你希望开发使用异步实现的库，或者天生有着强烈的好奇心，那么这篇文章就是专门为你定做的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这篇 RFC 并不打算将整个 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 移入标准库，相反极力精简，仅仅加入必要的最基础的构件，把剩余的功能留给社区的库来实现。就算如此，我们也将迎来帮数量众多的新朋友: &lt;code class=&quot;inline&quot;&gt;core::task::{Context, Poll, Wake, Waker, UnsafeWake, Executor, TaskObj, SpawnErrorKind, SpawnObjError}&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;core::ops::Async&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果加上另一篇 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md&quot;&gt;RFC: 2349-pin&lt;/a&gt;，那就还有 &lt;code class=&quot;inline&quot;&gt;core::marker::Unpin&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;core::mem::Pin&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们可以看到，新加入的东西真心不少，但是别担心，它们的存在都是必要而且符合直觉的，接下来我会逐个解释这些东西到底用来干什么的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外，读者可能注意到，这篇 RFC 中并没有出现 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;，这是因为这篇 RFC 写在上一篇 RFC 之后，在这期间社区讨论决定了并不引入 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 全部的功能(比如 &lt;code class=&quot;inline&quot;&gt;map()&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;and_then()&lt;/code&gt;)，而是只定义其中关键一部分 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;，剩余的功能依旧留给 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 库来提供，所以这个被精简的 &lt;code class=&quot;inline&quot;&gt;trait&lt;/code&gt; 不能叫做 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;，那就改名叫作了 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt;。也就是说，async 函数的返回值应该是 &lt;code class=&quot;inline&quot;&gt;impl Async&amp;lt;Output = T&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;让我们先从关键的 &lt;code class=&quot;inline&quot;&gt;Async trait&lt;/code&gt; 入手，下面是它的定义： &lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub trait Async {
    type Output;
    /// Attempt to resolve the computation to a final value, registering
    /// the current task for wakeup if the value is not yet available.
    fn poll(self: Pin&amp;lt;Self&amp;gt;, cx: &amp;amp;mut task::Context) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt;;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 只定义了一个函数 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;，作用是尝试获取异步操作的结果， 熟悉使用 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 的读者想必已经对它十分了解了。如果不是也没关系，我会从头解释一遍。我们先忽略传入参数，只看返回值，它返回的是 &lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 类型：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub enum Poll&amp;lt;T&amp;gt; {
    Ready(T),
    Pending,
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 有两个 variance: &lt;code class=&quot;inline&quot;&gt;Ready(T)&lt;/code&gt; 表示异步操作已经完成并获得返回值, &lt;code class=&quot;inline&quot;&gt;Pendding&lt;/code&gt; 表示异步操作还在进行中，你过会儿再过来看看。&lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 的概念很简单，就不多说了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这就带来了一个问题，我们该什么时候调用 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？它仅仅在完成之后才能给出有用的结果，万一如果返回的是 &lt;code class=&quot;inline&quot;&gt;Pending&lt;/code&gt;, 我们怎么知道什么时候需要再次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？又由谁来负责 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案是我们需要一个 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt;（比如线程池）来帮助我们完成这个调度(scheduling)工作。标准库并不会提供一个现成的 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt;，但标准库提供了定义它们的 &lt;code class=&quot;inline&quot;&gt;trait&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;我们来看一个具体的例子，比如说我们正在打算从 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 接收数据，我们得到了一个 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt;，这时候 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 可能还没准备好，所以第一次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 返回了 &lt;code class=&quot;inline&quot;&gt;Poll::Pending&lt;/code&gt;，这时我们必须把这个 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 交给一个 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt; 保管（就比如说一个由 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 库提供的线程池 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt;），以备过会 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 准备好了再回来 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这个例子里 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt; 实现了 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt;。我们来看看这个东西的定义：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub trait Executor {
    fn spawn_obj(&amp;amp;mut self, task: TaskObj) -&amp;gt; Result&amp;lt;(), SpawnObjError&amp;gt;;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 实际上是一个 &lt;code class=&quot;inline&quot;&gt;Box&amp;lt;Async&amp;lt;Output = ())&amp;gt;&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;spawn_obj()&lt;/code&gt; 用于给 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 安排工作，让 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 负责稍后的 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 工作。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里说个题外话，因为 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 使用了动态派发 （&lt;code class=&quot;inline&quot;&gt;trait object&lt;/code&gt;），所以目前这里的堆分配是必须的。然而我们还有另一套用于 &lt;code class=&quot;inline&quot;&gt;no_std&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;unsafe&lt;/code&gt; 的解决方案可以避免堆分配，有兴趣的读者可以在原文拉到最后了解一下。在不久的将来，在 Rust 支持在栈上存储 &lt;code class=&quot;inline&quot;&gt;dynamic size type(DST)&lt;/code&gt; 的时候 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1909-unsized-rvalues.md&quot;&gt;[Merged] RFC 1909:unsized-rvalues&lt;/a&gt;，这里的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 也会取消，取而代之的是栈上的 &lt;code class=&quot;inline&quot;&gt;Task&lt;/code&gt;，这也是现在取个这么难听名字的原因。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;解决了 who 的问题，那还有 when 问题。我们让 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt; 来负责重新 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; ，那到底什么时候 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？只有 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 知道自己什么时候准备好，所以 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 需要在准备好的时候 “通知” &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt; 重新 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;。这个操作叫做 &lt;code class=&quot;inline&quot;&gt;wake&lt;/code&gt; （唤醒），这意味着，我们要给 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 提供通知 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt; 的方法 —— 让 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 拿着 &lt;code class=&quot;inline&quot;&gt;Arc&amp;lt;ThreadPool&amp;gt;&lt;/code&gt;。完美。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了让 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 能够唤醒 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt;，标准库提供了 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;。&lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 只需握着 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;，就能在准备好的时候调用 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt;，通知 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 该 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;了。 下面是 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 的定义：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub trait Wake: Send + Sync {
    fn wake(&amp;amp;self);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是实现 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 的可以是 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 自己吗？不可以。因为一个 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 上可能托管着成百上千的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt;，直接 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt; 并不能告诉 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 究竟是哪个 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 需要 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;。因此 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 会给每个 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 提供一个唯一标识，然后把这个标识和自己的引用计数指针打包装在一起，弄一个类似 &lt;code class=&quot;inline&quot;&gt;WakeHandler&lt;/code&gt; 的玩意。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct WakeHandler {
    exec: Arc&amp;lt;ThreadPool&amp;gt;,
    id: u64,
}

impl Wake for WakeHandler { .. }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以这里 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 在被第一次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 的时候 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 就会记下这个 &lt;code class=&quot;inline&quot;&gt;WakeHandler&lt;/code&gt;（因为这里 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 的实际类型是 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 提供的），准备好后  &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt;  调用 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt; 根据唯一标识找到对应的 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 然后 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 就会从 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 拿回完成的 &lt;code class=&quot;inline&quot;&gt;Poll::Ready(T)&lt;/code&gt;。完美。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Context&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;明白了 &lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 之后，让我们回过头看看 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 的函数签名：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn poll(self: Pin&amp;lt;Self&amp;gt;, cx: &amp;amp;mut task::Context) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt;;
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们看 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 的第二个参数: &lt;code class=&quot;inline&quot;&gt;task::Context&lt;/code&gt;:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub struct Context&amp;lt;&#39;a&amp;gt; { .. }

impl&amp;lt;&#39;a&amp;gt; Context&amp;lt;&#39;a&amp;gt; {
    pub fn new(waker: &amp;amp;&#39;a Waker, executor: &amp;amp;&#39;a mut Executor) -&amp;gt; Context&amp;lt;&#39;a&amp;gt;;
    /// Get the `Waker` associated with the current task.
    pub fn waker(&amp;amp;self) -&amp;gt; &amp;amp;Waker;
    /// Run an asynchronous computation to completion on the default executor.
    pub fn spawn(&amp;amp;mut self, f: impl Async&amp;lt;Output = ()&amp;gt; + &#39;static + Send);
    /// Get the default executor associated with this task.
    pub fn executor(&amp;amp;mut self) -&amp;gt; &amp;amp;mut BoxExecutor;
}
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Context&lt;/code&gt; 的主要工作十分明了：&lt;/p&gt;&lt;p&gt;&lt;br&gt;-   提供 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; &lt;br&gt;-   提供默认 &lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;spawn()&lt;/code&gt; 是 &lt;code class=&quot;inline&quot;&gt;executor().spawn()&lt;/code&gt; 的捷径（顺带一些错误处理）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里出现了 &lt;code class=&quot;inline&quot;&gt;Waker&lt;/code&gt; 不是 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;Waker&lt;/code&gt; 又是一个这次标准库新加入的类型，里面装着 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; trait object:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub struct Waker {
    wake: &amp;amp;Wake
}

impl Waker {
    pub fn wake(&amp;amp;self) {
        self.wake.wake();
    }
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 类型不在本篇 RFC 范围之内，而且展开了说篇幅会非常的长，有兴趣的话可以前去 RFC 阅读，或者看看 &lt;code class=&quot;inline&quot;&gt;@withoutboat&lt;/code&gt; 关于 &lt;code class=&quot;inline&quot;&gt;&lt;i&gt;borrow across yield point&lt;/i&gt;&lt;/code&gt; 的长篇系列，那里详细地解释了设计上遇到了什么难点，以及为什么一定要引入 &lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 概念。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md&quot;&gt;RFC: 2349-pin&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://boats.gitlab.io/blog/post/2018-01-25-async-i-self-referential-structs/&quot;&gt;Async/Await I: Self-Referential Structs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;目前在这篇 RFC 中，我们只需要知道 Pin 是什么就足够了。简单来说，一般的类型自动实现 &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt;，而有些特殊的的类型会反向实现 &lt;code class=&quot;inline&quot;&gt;!Unpin&lt;/code&gt;，这样特殊的类型在被装进 &lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 之后就不能再移动了(immovable type)。异步函数返回类型也正是这种特殊类型。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 是指针类型，提供比 &lt;code class=&quot;inline&quot;&gt;&amp;amp;mut T&lt;/code&gt; 更严格的规则：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T: Unpin&amp;gt;&lt;/code&gt; 和普通 &lt;code class=&quot;inline&quot;&gt;&amp;amp;mut T&lt;/code&gt; 完全一样。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T: !Unpin&amp;gt;&lt;/code&gt; 只提供 &lt;code class=&quot;inline&quot;&gt;Deref&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;，以防止 T 被移动 (mem::replace())。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们来明确一下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt; &lt;/li&gt;&lt;li&gt;async fn 返回的 &lt;code class=&quot;inline&quot;&gt;impl Async&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;!Unpin&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Box&amp;lt;Async&amp;gt;&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;这篇文章介绍了标准库中加入的 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 和任务类型，通过这些类型的加入，我们可以方便地定义自己的事件循环或者使用现成的库来驱动异步任务。文章并没有涵盖用于 &lt;code class=&quot;inline&quot;&gt;no_std&lt;/code&gt; 环境的类型和解决方案，有兴趣的读者需要自己去阅读一下 RFC。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下一篇文章可能会讲 &lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 类型和关于 Rust &lt;code class=&quot;inline&quot;&gt;immovable type&lt;/code&gt; 的故事，但是这玩意讲起来比裹脚布还长，到时懒起来分分钟就跳票了。&lt;/p&gt;</description>
<author>Andy Lok</author>
<guid isPermaLink="false">2018-05-25-37298671</guid>
<pubDate>Fri, 25 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust - RFC 导读: async/await 特性（二）</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-05-25-37269342.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37269342&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b357cf4b2202c2f3e9edb6c3b6204680_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;由于本篇文章代码较多，如果知乎的排版伤害了你的眼睛，可以暂时移步到 &lt;a href=&quot;https://github.com/andylokandy/article/blob/master/Rust%20-%20RFC%20%E5%AF%BC%E8%AF%BB%20async%20%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89.md&quot;&gt;这里&lt;/a&gt;。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上一篇我们讲到了编译器对 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 的特性支持，相应的，我们要让编译器知道 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 是什么，编译器才能生成匿名的 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 类型。为此，我们就有了第二份 RFC —— 将 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 加入标准库（准确来说是 &lt;code class=&quot;inline&quot;&gt;libcore&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/aturon/rfcs/blob/async-trait/text/0000-async.md&quot;&gt;RFC 2418 companion libs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;注意这篇 RFC 还在讨论阶段并未被 merge，因此最终方案可能会改变，目前已经可以看见讨论区提出了相较于 &lt;code class=&quot;inline&quot;&gt;arbitrary self type&lt;/code&gt;（&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;self&amp;gt;&lt;/code&gt;） 更好的解决方案，这部分是最有可能发生变化的。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Summary&lt;/h2&gt;&lt;p&gt;这篇文章将会深入 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 的实现原理，如果读者只是希望使用现成的库和 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 语法，仅看上一篇文章就已经足够了。而如果你希望开发使用异步实现的库，或者天生有着强烈的好奇心，那么这篇文章就是专门为你定做的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这篇 RFC 并不打算将整个 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 移入标准库，相反极力精简，仅仅加入必要的最基础的构件，把剩余的功能留给社区的库来实现。就算如此，我们也将迎来帮数量众多的新朋友: &lt;code class=&quot;inline&quot;&gt;core::task::{Context, Poll, Wake, Waker, UnsafeWake, Executor, TaskObj, SpawnErrorKind, SpawnObjError}&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;core::ops::Async&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果加上另一篇 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md&quot;&gt;RFC: 2349-pin&lt;/a&gt;，那就还有 &lt;code class=&quot;inline&quot;&gt;core::marker::Unpin&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;core::mem::Pin&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们可以看到，新加入的东西真心不少，但是别担心，它们的存在都是必要而且符合直觉的，接下来我会逐个解释这些东西到底用来干什么的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外，读者可能注意到，这篇 RFC 中并没有出现 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;，这是因为这篇 RFC 写在上一篇 RFC 之后，在这期间社区讨论决定了并不引入 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 全部的功能(比如 &lt;code class=&quot;inline&quot;&gt;map()&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;and_then()&lt;/code&gt;)，而是只定义其中关键一部分 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;，剩余的功能依旧留给 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 库来提供，所以这个被精简的 &lt;code class=&quot;inline&quot;&gt;trait&lt;/code&gt; 不能叫做 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;，那就改名叫作了 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt;。也就是说，async 函数的返回值应该是 &lt;code class=&quot;inline&quot;&gt;impl Async&amp;lt;Output = T&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;让我们先从关键的 &lt;code class=&quot;inline&quot;&gt;Async trait&lt;/code&gt; 入手，下面是它的定义： &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub trait Async {
    type Output;
    /// Attempt to resolve the computation to a final value, registering
    /// the current task for wakeup if the value is not yet available.
    fn poll(self: Pin&amp;lt;Self&amp;gt;, cx: &amp;amp;mut task::Context) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt;;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 只定义了一个函数 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;，作用是尝试获取异步操作的结果， 熟悉使用 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 的读者想必已经对它十分了解了。如果不是也没关系，我会从头解释一遍。我们先忽略传入参数，只看返回值，它返回的是 &lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub enum Poll&amp;lt;T&amp;gt; {
    Ready(T),
    Pending,
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 有两个 variance: &lt;code class=&quot;inline&quot;&gt;Ready(T)&lt;/code&gt; 表示异步操作已经完成并获得返回值, &lt;code class=&quot;inline&quot;&gt;Pendding&lt;/code&gt; 表示异步操作还在进行中，你过会儿再过来看看。&lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 的概念很简单，就不多说了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这就带来了一个问题，我们该什么时候调用 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？它仅仅在完成之后才能给出有用的结果，万一如果返回的是 &lt;code class=&quot;inline&quot;&gt;Pending&lt;/code&gt;, 我们怎么知道什么时候需要再次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？又由谁来负责 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案是我们需要一个 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt;（比如线程池）来帮助我们完成这个调度(scheduling)工作。标准库并不会提供一个现成的 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt;，但标准库提供了定义它们的 &lt;code class=&quot;inline&quot;&gt;trait&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;我们来看一个具体的例子，比如说我们正在打算从 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 接收数据，我们得到了一个 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt;，这时候 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 可能还没准备好，所以第一次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 返回了 &lt;code class=&quot;inline&quot;&gt;Poll::Pending&lt;/code&gt;，这时我们必须把这个 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 交给一个 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt; 保管（就比如说一个由 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 库提供的线程池 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt;），以备过会 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 准备好了再回来 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这个例子里 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt; 实现了 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt;。我们来看看这个东西的定义：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub trait Executor {
    fn spawn_obj(&amp;amp;mut self, task: TaskObj) -&amp;gt; Result&amp;lt;(), SpawnObjError&amp;gt;;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 实际上是一个 &lt;code class=&quot;inline&quot;&gt;Box&amp;lt;Async&amp;lt;Output = ())&amp;gt;&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;spawn_obj()&lt;/code&gt; 用于给 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 安排工作，让 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 负责稍后的 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 工作。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里说个题外话，因为 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 使用了动态派发 （&lt;code class=&quot;inline&quot;&gt;trait object&lt;/code&gt;），所以目前这里的堆分配是必须的。然而我们还有另一套用于 &lt;code class=&quot;inline&quot;&gt;no_std&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;unsafe&lt;/code&gt; 的解决方案可以避免堆分配，有兴趣的读者可以在原文拉到最后了解一下。在不久的将来，在 Rust 支持在栈上存储 &lt;code class=&quot;inline&quot;&gt;dynamic size type(DST)&lt;/code&gt; 的时候 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1909-unsized-rvalues.md&quot;&gt;[Merged] RFC 1909:unsized-rvalues&lt;/a&gt;，这里的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 也会取消，取而代之的是栈上的 &lt;code class=&quot;inline&quot;&gt;Task&lt;/code&gt;，这也是现在取个这么难听名字的原因。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;解决了 who 的问题，那还有 when 问题。我们让 ThreadPool 来负责重新 poll() ，那到底什么时候 poll() 呢？只有 socket 知道自己什么时候准备好，所以 socket 需要在准备好的时候 “通知” ThreadPool 重新 poll()。这个操作叫做 wake （唤醒），这意味着，我们要给 socket 提供通知 ThreadPool 的方法 —— 让 socket 拿着 Arc&amp;lt;ThreadPool&amp;gt;。完美。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了让 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 能够唤醒 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt;，标准库提供了 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;。&lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 只需握着 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;，就能在准备好的时候调用 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt;，通知 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 该 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;了。 下面是 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 的定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub trait Wake: Send + Sync {
    fn wake(&amp;amp;self);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是实现 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 的可以是 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 自己吗？不可以。因为一个 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 上可能托管着成百上千的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt;，直接 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt; 并不能告诉 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 究竟是哪个 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 需要 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;。因此 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 会给每个 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 提供一个唯一标识，然后把这个标识和自己的引用计数指针打包装在一起，弄一个类似 &lt;code class=&quot;inline&quot;&gt;WakeHandler&lt;/code&gt; 的玩意。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;struct WakeHandler {
    exec: Arc&amp;lt;ThreadPool&amp;gt;,
    id: u64,
}

impl Wake for WakeHandler { .. }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以这里 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 在被第一次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 的时候 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 就会记下这个 &lt;code class=&quot;inline&quot;&gt;WakeHandler&lt;/code&gt;（因为这里 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 的实际类型是 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 提供的），准备好后  &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt;  调用 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt; 根据唯一标识找到对应的 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 然后 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 就会从 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 拿回完成的 &lt;code class=&quot;inline&quot;&gt;Poll::Ready(T)&lt;/code&gt;。完美。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Context&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;明白了 &lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 之后，让我们回过头看看 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 的函数签名：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn poll(self: Pin&amp;lt;Self&amp;gt;, cx: &amp;amp;mut task::Context) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt;;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们看 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 的第二个参数: &lt;code class=&quot;inline&quot;&gt;task::Context&lt;/code&gt;:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub struct Context&amp;lt;&#39;a&amp;gt; { .. }

impl&amp;lt;&#39;a&amp;gt; Context&amp;lt;&#39;a&amp;gt; {
    pub fn new(waker: &amp;amp;&#39;a Waker, executor: &amp;amp;&#39;a mut Executor) -&amp;gt; Context&amp;lt;&#39;a&amp;gt;;
    /// Get the `Waker` associated with the current task.
    pub fn waker(&amp;amp;self) -&amp;gt; &amp;amp;Waker;
    /// Run an asynchronous computation to completion on the default executor.
    pub fn spawn(&amp;amp;mut self, f: impl Async&amp;lt;Output = ()&amp;gt; + &#39;static + Send);
    /// Get the default executor associated with this task.
    pub fn executor(&amp;amp;mut self) -&amp;gt; &amp;amp;mut BoxExecutor;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Context&lt;/code&gt; 的主要工作十分明了：&lt;/p&gt;&lt;p&gt;&lt;br&gt;-   提供 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; &lt;br&gt;-   提供默认 &lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;spawn()&lt;/code&gt; 是 &lt;code class=&quot;inline&quot;&gt;executor().spawn()&lt;/code&gt; 的捷径（顺带一些错误处理）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里出现了 &lt;code class=&quot;inline&quot;&gt;Waker&lt;/code&gt; 不是 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;Waker&lt;/code&gt; 又是一个这次标准库新加入的类型，里面装着 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; trait object:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub struct Waker {
    wake: &amp;amp;Wake
}

impl Waker {
    pub fn wake(&amp;amp;self) {
        self.wake.wake();
    }
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 类型不在本篇 RFC 范围之内，而且展开了说篇幅会非常的长，有兴趣的话可以前去 RFC 阅读，或者看看 &lt;code class=&quot;inline&quot;&gt;@withoutboat&lt;/code&gt; 关于 &lt;code class=&quot;inline&quot;&gt;&lt;i&gt;borrow across yield point&lt;/i&gt;&lt;/code&gt; 的长篇系列，那里详细地解释了设计上遇到了什么难点，以及为什么一定要引入 &lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 概念。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md&quot;&gt;RFC: 2349-pin&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://boats.gitlab.io/blog/post/2018-01-25-async-i-self-referential-structs/&quot;&gt;Async/Await I: Self-Referential Structs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;目前在这篇 RFC 中，我们只需要知道 Pin 是什么就足够了。简单来说，一般的类型自动实现 &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt;，而有些特殊的的类型会反向实现 &lt;code class=&quot;inline&quot;&gt;!Unpin&lt;/code&gt;，这样特殊的类型在被装进 &lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 之后就不能再移动了(immovable type)。异步函数返回类型也正是这种特殊类型。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 是指针类型，提供比 &lt;code class=&quot;inline&quot;&gt;&amp;amp;mut T&lt;/code&gt; 更严格的规则：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T: Unpin&amp;gt;&lt;/code&gt; 和普通 &lt;code class=&quot;inline&quot;&gt;&amp;amp;mut T&lt;/code&gt; 完全一样。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T: !Unpin&amp;gt;&lt;/code&gt; 只提供 &lt;code class=&quot;inline&quot;&gt;Deref&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;，以防止 T 被移动 (mem::replace())。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们来明确一下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt; &lt;/li&gt;&lt;li&gt;async fn 返回的 &lt;code class=&quot;inline&quot;&gt;impl Async&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;!Unpin&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Box&amp;lt;Async&amp;gt;&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;这篇文章介绍了标准库中加入的 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 和任务类型，通过这些类型的加入，我们可以方便地定义自己的事件循环或者使用现成的库来驱动异步任务。文章并没有涵盖用于 &lt;code class=&quot;inline&quot;&gt;no_std&lt;/code&gt; 环境的类型和解决方案，有兴趣的读者需要自己去阅读一下 RFC。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下一篇文章可能会讲 &lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 类型和关于 Rust &lt;code class=&quot;inline&quot;&gt;immovable type&lt;/code&gt; 的故事，但是这玩意讲起来比裹脚布还长，到时懒起来分分钟就跳票了。&lt;/p&gt;</description>
<author>Andy Lok</author>
<guid isPermaLink="false">2018-05-25-37269342</guid>
<pubDate>Fri, 25 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust - RFC 导读:  async/await 特性（一）</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-05-23-37209852.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37209852&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-26d18184098ed7b0ce2cfba667b957d9_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在 2018 年五月份 Rust 迎来了 1.26 版本，一并带来不少让人眼前一亮的特性，比如 &lt;code class=&quot;inline&quot;&gt;impl trait&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;match&lt;/code&gt; 自动绑定等等，这是 Rust Core team 和社区在有条不紊地履行着 Roadmap 2018 里的承诺，给 2018 epoch 打下基础。&lt;/p&gt;&lt;p&gt;根据 Roadmap，今年9月份前我们将迎来一个更重磅的特性，&lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt;。Core team 如期给出了两份 RFC，给 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 特性画下个大饼。这篇文章旨在提供对这两份 RFC 的导读，让读者掌握 &lt;code class=&quot;inline&quot;&gt;async&lt;/code&gt; 特性的基本概念。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2394-async_await.md&quot;&gt;RFC 2394-async_await&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/aturon/rfcs/blob/async-trait/text/0000-async.md&quot;&gt;RFC 2418 companion libs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Summary&lt;/h2&gt;&lt;p&gt;在高性能网络服务领域，人们常用异步 IO 而不是阻塞 IO，这是因为异步 IO 更容易扩展从而获得巨大的并发能力，而 Rust 正在逐步涉足网络服务领域，因此能够提供简洁而强大的异步开发能力格外重要。&lt;/p&gt;&lt;p&gt;为此，Rust 社区已经进行了长时间的实验和反馈，尝试了众多的技术方法，社区最终采用了 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; ，因为它能够提供强大的抽象能力，而且简洁，容易学习，是目前的最优方案。&lt;/p&gt;&lt;p&gt;由于这次特性更新影响重大，涉及方面较广，文章将随 RFC 分为两部分，分别为语言特性和标准库两方面。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;语言特性&lt;/h2&gt;&lt;p&gt;本篇 RFC 的重点是为编译器增加四种新的类型：&lt;code class=&quot;inline&quot;&gt;async function&lt;/code&gt;（异步函数），&lt;code class=&quot;inline&quot;&gt;async closure&lt;/code&gt;（异步闭包）， &lt;code class=&quot;inline&quot;&gt;async block&lt;/code&gt;（异步代码块）和一个内建 macro &lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;异步函数&lt;/h2&gt;&lt;p&gt;函数开头加上 &lt;code class=&quot;inline&quot;&gt;async&lt;/code&gt; 关键词就成为了异步函数。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;async fn function(argument: &amp;amp;str) -&amp;gt; usize {
     // ...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;异步函数的行为和普通函数不同，当异步函数被调用时，内部的代码逻辑不会立即执行，相反，异步函数会返回一个匿名的 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 类型，之后当我们 &lt;code class=&quot;inline&quot;&gt;poll&lt;/code&gt; 这个 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 的时候，函数内部的代码才会被执行并且执行到 &lt;code class=&quot;inline&quot;&gt;await&lt;/code&gt; 处停止（如果异步函数内部有的话），直到异步函数结尾。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;异步函数其实是某种 delayed computation （延迟运算）—— 在手动 &lt;code class=&quot;inline&quot;&gt;poll&lt;/code&gt; future 之前，异步函数内部一行代码也不会执行。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;看下面这个例子&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;async fn print_async() {
     println!(&quot;Hello from print_async&quot;)
}

fn main() {
     let future = print_async();
     println!(&quot;Hello from main&quot;);
     futures::block_on(future);
}&lt;/code&gt;&lt;p&gt;Print:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Hello from main
Hello from print_async&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;&quot;Hello from main&quot;&lt;/code&gt; 会在 &lt;code class=&quot;inline&quot;&gt;&quot;Hello from print_async&quot;&lt;/code&gt; 之前 print 出来。&lt;/p&gt;&lt;p&gt;异步函数的类型签名也与普通函数不同&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;async fn foo(args..) -&amp;gt; T&lt;/code&gt; 的实际类型签名是 &lt;code class=&quot;inline&quot;&gt;fn(args..) -&amp;gt; impl Future&amp;lt;Output = T&amp;gt;&lt;/code&gt;，其中的返回的类型是由编译器生成的匿名类型。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;异步闭包&lt;/h2&gt;&lt;p&gt;与函数类似，闭包也可以声明为异步闭包，只需在闭包前加上 &lt;code class=&quot;inline&quot;&gt;async&lt;/code&gt; 关键字。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;异步闭包的返回类型是 &lt;code class=&quot;inline&quot;&gt;impl Future&amp;lt;Output = T&amp;gt;&lt;/code&gt;，调用异步闭包时，内部代码也不会被执行而是返回一个 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;，这与异步函数一模一样。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn main() {
    let closure = async || {
         println(&quot;Hello from async closure.&quot;);
    };
    println!(&quot;Hello from main&quot;);
    let future = closure();
    println!(&quot;Hello from main again&quot;);
    futures::block_on(future);
}&lt;/code&gt;&lt;p&gt;Print:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Hello from main
Hello from main again
Hello from async closure&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;异步块&lt;/h2&gt;&lt;p&gt;通过异步块可以便捷地创建一个 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let my_future = async {
    println!(&quot;Hello from an async block&quot;);
};&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt; 是一个编译器内建的 macro ，用来暂停（pause） &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 的执行流程，并且把执行流程交回给调用方 (&lt;code class=&quot;inline&quot;&gt;yield&lt;/code&gt;)。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// future: impl Future&amp;lt;Output = usize&amp;gt;
let n = await!(future);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt; 展开的逻辑是这样的：&lt;br&gt;1. &lt;code class=&quot;inline&quot;&gt;poll&lt;/code&gt; 传入的 &lt;code class=&quot;inline&quot;&gt;future&lt;/code&gt;。&lt;br&gt;2. 如果 &lt;code class=&quot;inline&quot;&gt;poll&lt;/code&gt; 得到 &lt;code class=&quot;inline&quot;&gt;Poll::Pending&lt;/code&gt; 就将执行权交回给调用方。&lt;br&gt;3. 如果 &lt;code class=&quot;inline&quot;&gt;poll&lt;/code&gt; 得到 &lt;code class=&quot;inline&quot;&gt;Poll::Ready(T)&lt;/code&gt;，得到的值会被作为 &lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt; 表达式的值，从而继续执行 &lt;code class=&quot;inline&quot;&gt;future&lt;/code&gt; 剩下的逻辑代码。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt; 只能用于异步函数，异步闭包或者异步块内部，否则将导致编译错误。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;大饼&lt;/h2&gt;&lt;p&gt;在引入了这些编译器特性之后，我们来看看异步代码可以长成什么样子。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;async fn fetch_rust_lang(client: hyper::Client) -&amp;gt; io::Result&amp;lt;String&amp;gt; {
    let response = await!(client.get(&quot;https://www.rust-lang.org&quot;))?;
    if !response.status().is_success() {
        return Err(io::Error::new(io::ErrorKind::Other, &quot;request failed&quot;))
    }
    let body = await!(response.body().concat())?;
    let string = String::from_utf8(body)?;
    Ok(string)
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 为 Rust 提供了强大的异步抽象，它不止可以助力网络并发，它在文件IO，多线程运算方面也可以大有作为。另外，&lt;code class=&quot;inline&quot;&gt;async&lt;/code&gt; 所涉及的 &lt;code class=&quot;inline&quot;&gt;Generator&lt;/code&gt; 还可用于简化 &lt;code class=&quot;inline&quot;&gt;Iterator&lt;/code&gt; 代码，让迭代器写法更加接近于 Python 等脚本语言，同时保持 Rust 引以为豪的 Zero-Cost-Abstration。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下一篇将着力介绍为了迎接 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt;，标准库要加入的新朋友 &lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt;。&lt;/p&gt;</description>
<author>Andy Lok</author>
<guid isPermaLink="false">2018-05-23-37209852</guid>
<pubDate>Wed, 23 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust&#39;s 2018  roadmap</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-03-21-34724526.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34724526&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1e1e7123a9bf7a25aa7a892c840e9a1d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每年Rust社区会聚在一起公布roadmap. 今年， 除了调查之外，我们还在12月份进行呼吁社区博客帖子，结果是在几周内大家撰写100篇博客文章。结束后，结果合并成　&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2314&quot;&gt;2018 roadmap RFC.&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust: 2018 发行版&lt;/h2&gt;&lt;p&gt;&lt;b&gt;今年我们将交付 Rust 2018, 　这将是从1.0之后的第一个主要的发行版。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;像往常一样，我们继续每六周发布。 但是我们将在今年三个版本（Rust 1.29 - 1.31）中选定一个作为&lt;b&gt;Rust 2018&lt;/b&gt;　这个新的Rust“发行版”将是整年功能稳定的顶点，同时这些特性将带有精美文档，工具和库。&lt;/p&gt;&lt;p&gt;发行版的意图是标记Rust进化中的主要里程碑，它收集了一些新的特征或习惯用法，整体上改变了使用Rust的经验。 隔几年，来评估我们以六周为周期的交付工作。 讲述RUST发展的更大的故事。 将整个我们整体的工作打造成闪光的产品发布。&lt;/p&gt;&lt;p&gt;我们期望每一个发行版将有一个核心专注主题。　考虑到Rust 1.0 作为　“Rust 2015” ，　那我们将有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rust 2015年：稳定性&lt;/li&gt;&lt;li&gt;Rust 2018年：生产力&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;哪些会成为Rust 2018?&lt;/h2&gt;&lt;p&gt;Roadmap 并不是说确定那些会在 Rust 2018，但我们有好的想法，我们将会覆盖以下主要想法。&lt;/p&gt;&lt;h2&gt;文档改进&lt;/h2&gt;&lt;p&gt;Rust 2018 release 的目标之一，对于新增和改进的特性和惯用法提供高质量的文档。　《&lt;a href=&quot;https://doc.rust-lang.org/nightly/book/second-edition/&quot;&gt;The Rust Programming Language book&lt;/a&gt;》 在过去的18月里，已经完成了重写，一年内随着特性到达稳定的编译器支持，它也将更新。 &lt;a href=&quot;https://rustbyexample.com/&quot;&gt;Rust By Example&lt;/a&gt; 今年也将进行修改。还有许多第三方的书籍，如Programming Rust ，会将印刷出版。 &lt;/p&gt;&lt;h2&gt;语言改进&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html&quot;&gt;2017’s ergonomics initiative&lt;/a&gt;  队列中最为优先的语言工作,　几乎所有被接受的RFCs今天都在nightly分支上提供，在接下来的几个月里，它将被打磨和稳定。这些中生产力的改进，会做作为“头条”在主干发布&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Ownership 系统改进&lt;/b&gt;,（所有权系统改进），包括可以通用“&quot;non-lexical lifetimes””来实现更灵活的标记借用,改进的模式匹配集成.&lt;/li&gt;&lt;li&gt;&lt;b&gt;Trait 系统改进&lt;/b&gt;，包括期待已久的处理类型抽象的 impl Trait语法&lt;/li&gt;&lt;li&gt;&lt;b&gt;模块系统改进&lt;/b&gt;　聚焦在增加清晰性和降低复杂度&lt;/li&gt;&lt;li&gt;&lt;b&gt;Generators/async/await：在最优先的异步编程支持方面，工作在快速的进展。&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;另外，　我们期望有更多一些主要的特性在Rust 2018 发布，能稳定起来，包括&lt;b&gt;SIMD&lt;/b&gt;, &lt;b&gt;custom allocators&lt;/b&gt;  和 &lt;b&gt;macros&lt;/b&gt; 2.0&lt;br&gt;&lt;/p&gt;&lt;h2&gt;编译器改进&lt;/h2&gt;&lt;p&gt;Rust 1.24 增量再编译已经支持，在稳定版的编译器已是默认打开，该特性已经使重构建比新构建的速度快得多，但在这一年的时间里，我们预计fresh builds 和re-builds 都会得到持续的改进。 在Rust 2018, 编译器性不能成为生产效率的主要的障碍。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;工具改进&lt;/h2&gt;&lt;p&gt;Rust 2018 将看到高质量的 RLS-1.0  (&lt;a href=&quot;https://github.com/rust-lang-nursery/rls&quot;&gt;Rust Language Server&lt;/a&gt;)　和rustfmt  我们将继续改进。&lt;/p&gt;&lt;p&gt;我们将继续改进 Cargo 稳定客户注册、公共依赖和改进Profile system. 我们也期望将来在&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2136&quot;&gt;Cargo build system integration&lt;/a&gt;, &lt;a href=&quot;https://github.com/rust-lang/cargo/issues/4959&quot;&gt;Xargo integration&lt;/a&gt;, 和 &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2318&quot;&gt;custom test frameworks&lt;/a&gt;　工作，&lt;/p&gt;&lt;p&gt;尽管目前还不清楚这其中有多少将在Rust 2018之前完成。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Library 改进&lt;/h2&gt;&lt;p&gt;在我们去年的工作之上 　我们将发布1.0的　&lt;a href=&quot;https://github.com/rust-lang-nursery/api-guidelines&quot;&gt;Rust API guidelines book&lt;/a&gt;, 继续推动重要的libraries 达到 1.0 状态， 通过改进cookbook 的努力来提高发现能力，并在特定领域的libraries 进行大量投入 - 我们将在下面看到。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;WebSite 改进&lt;/h2&gt;&lt;p&gt;作为Rust 2018的一部分，我们将彻底检修Rust 网站，使它对CTOs和工程师都很有用。在您的用例下，应该更容易找到信息来帮助评估Rust ，并保持最新的工具和生态系统的改进。&lt;/p&gt;&lt;h2&gt;四个目标领域&lt;/h2&gt;&lt;p&gt;Rust 2018 目标之一是演示在特定的领域使用Rust的生产力。　今年我们突出选了四个领域进行投入：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;网络服务&lt;/b&gt; Rust的可靠性和低的资源占用非常匹配网络服务和基础设施，特别在高伸缩领域。&lt;/li&gt;&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/announcing-the-cli-working-group/6872&quot;&gt;Command-line apps&lt;/a&gt;&lt;/b&gt; (CLI).　Rust的可移植性、可靠性、工程效率 以及产生静态二进制文件，综合这些能力对编写CLI应用程序产生巨大影响。&lt;/li&gt;&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/come-join-the-rust-and-webassembly-working-group/6845&quot;&gt;WebAssembly&lt;/a&gt;&lt;/b&gt;. 　“wasm” web 标准允许加载本地二进制到主流的浏览器，但是GC支持还要多年. 　这个领域非常符合Rust的定位，为JS程序员提供一个合适的切入点。&lt;/li&gt;&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/announcing-the-embedded-devices-working-group/6839&quot;&gt;Embedded devices&lt;/a&gt;&lt;/b&gt;. Rust　有潜力使资源受限的设备编程更加高效和有趣!　　我们希望Rust在嵌入式编程今年达到一流的地位。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;今年每一个领域都有一个专门工作小组。这些工作组将以交叉的方式工作，与语言、工具、库和文档工作相结合。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;后续我不太关心就没译完。大家可以继续看原文　&lt;a href=&quot;https://blog.rust-lang.org/2018/03/12/roadmap.html&quot;&gt;英文原文&lt;/a&gt;&lt;/p&gt;</description>
<author>左文建</author>
<guid isPermaLink="false">2018-03-21-34724526</guid>
<pubDate>Wed, 21 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>[译] Rust - None Lexical Lifetimes (NLL) 使用指南</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-01-12-32884290.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32884290&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b7bdc8a3a010ad92012199af2750cc72_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;原文地址 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//santiagopastorino.com/how-to-use-rust-non-lexical-lifetimes-on-nightly/&quot;&gt;https://santiagopastorino.com/how-to-use-rust-non-lexical-lifetimes-on-nightly/&lt;/a&gt;&lt;br&gt;原文作者: Santiago Pastorino&lt;/blockquote&gt;&lt;p&gt;Niko Matsakis, Paul Faria 和我在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//internals.rust-lang.org/t/announcing-the-impl-period-sep-18-dec-17/5676&quot;&gt;impl period&lt;/a&gt; 期间致力于开发None Lexical Lifetimes (暂译为非词法作用域生命周期，下文统称为 NLL)。 代码目前已经合并到 master 分支，你现在可以在 nightly 中体验。&lt;/p&gt;&lt;p&gt;本文将通过几个例子简单直观地展现 NLL 的使用方法。这里我不会涉及 NLL 背后的设计逻辑，如果对设计细节感兴趣，我推荐你进一步阅读 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/rfcs/blob/master/text/2094-nll.md&quot;&gt;RFC&lt;/a&gt;，你想知道的都在里面了。我想你还可以尝试在 pull requests 贡献代码。&lt;/p&gt;&lt;p&gt;话不多说，我们直接上代码。&lt;/p&gt;&lt;p&gt;当然在这之前，你要先确保机器上安装了最新的 nightly 版本 —— 打开命令行运行 &lt;code class=&quot;inline&quot;&gt;rustup install nightly&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们先看这个简单的例子，它在目前的作用域生命周期(scope based lifetimes)规则下不能编译。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![allow(unused_variables)]

fn main() {
    let mut x = 22;

    let p = &amp;amp;mut x; // mutable borrow

    println!(&quot;{}&quot;, x); // later used
}
&lt;/code&gt;&lt;p&gt;这是因为 x 被可变借用，并且在作用域结束前再次被使用。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
 --&amp;gt; src/main.rs:8:20
  |
6 |     let p = &amp;amp;mut x; // mutable borrow
  |                  - mutable borrow occurs here
7 | 
8 |     println!(&quot;{}&quot;, x); // later used
  |                    ^ immutable borrow occurs here
9 | }
  | - mutable borrow ends here

error: aborting due to previous error
&lt;/code&gt;&lt;p&gt;现在我们在开头加入 &lt;code class=&quot;inline&quot;&gt;#![feature(nll)]&lt;/code&gt; 代码开启 NLL 特性。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![feature(nll)]
#![allow(unused_variables)]

fn main() {
    let mut x = 22;

    let p = &amp;amp;mut x;

    println!(&quot;{}&quot;, x);
}
&lt;/code&gt;&lt;p&gt;这段代码顺利编译，因为编译器知道 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 的可变借用并没有持续到作用域结尾，而是在 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 被再次使用之前就结束了，所以这里不存在冲突。&lt;/p&gt;&lt;p&gt;我们在看一个稍微复杂些的例子。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::collections::HashMap;

fn get_default(map: &amp;amp;mut HashMap, key: usize) -&amp;gt; &amp;amp;mut String {
    match map.get_mut(&amp;amp;key) {
        Some(value) =&amp;gt; value,
        None =&amp;gt; {
            map.insert(key, &quot;&quot;.to_string());
            map.get_mut(&amp;amp;key).unwrap()
        }
    }
}

fn main() {
    let map = &amp;amp;mut HashMap::new();
    map.insert(22, format!(&quot;Hello, world&quot;));
    map.insert(44, format!(&quot;Goodbye, world&quot;));
    assert_eq!(&amp;amp;*get_default(map, 22), &quot;Hello, world&quot;);
    assert_eq!(&amp;amp;*get_default(map, 66), &quot;&quot;);
}
&lt;/code&gt;&lt;p&gt;如果我们直接编译，这段代码也会报错，因为 &lt;code class=&quot;inline&quot;&gt;get_mut&lt;/code&gt; 在 &lt;code class=&quot;inline&quot;&gt;match&lt;/code&gt; 里借用 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 直到作用域结尾，这段作用域也覆盖到 &lt;code class=&quot;inline&quot;&gt;None&lt;/code&gt; 分支，而我们在 &lt;code class=&quot;inline&quot;&gt;None&lt;/code&gt; 分支里尝试再次可变借用 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;，编译器自然是十分拒绝的。&lt;/p&gt;&lt;p&gt;错误信息是这样的&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;error[E0499]: cannot borrow `*map` as mutable more than once at a time
  --&amp;gt; src/main.rs:7:13
   |
4  |     match map.get_mut(&amp;amp;key) {
   |           --- first mutable borrow occurs here
...
7  |             map.insert(key, &quot;&quot;.to_string());
   |             ^^^ second mutable borrow occurs here
...
11 | }
   | - first borrow ends here

error[E0499]: cannot borrow `*map` as mutable more than once at a time
  --&amp;gt; src/main.rs:8:13
   |
4  |     match map.get_mut(&amp;amp;key) {
   |           --- first mutable borrow occurs here
...
8  |             map.get_mut(&amp;amp;key).unwrap()
   |             ^^^ second mutable borrow occurs here
...
11 | }
   | - first borrow ends here

error: aborting due to 2 previous errors
&lt;/code&gt;&lt;p&gt;不开启 NLL 的情况下，我们有一种丑陋的技巧可以让它通过编译。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn get_default(map: &amp;amp;mut HashMap, key: usize) -&amp;gt; &amp;amp;mut String {
    match map.get_mut(&amp;amp;key) {
        Some(value) =&amp;gt; return value,
        None =&amp;gt; {
        }
    }
    
    map.insert(key, &quot;&quot;.to_string());
    map.get_mut(&amp;amp;key).unwrap()
}
&lt;/code&gt;&lt;p&gt;这段代码虽然能编译，代价是我们必须使用这种令人难受的写法。&lt;/p&gt;&lt;p&gt;如果我们在原先的例子中加入 &lt;code class=&quot;inline&quot;&gt;#![feature(nll)]&lt;/code&gt; 开启 NLL ...&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![feature(nll)]

use std::collections::HashMap;

fn get_default(map: &amp;amp;mut HashMap, key: usize) -&amp;gt; &amp;amp;mut String {
    match map.get_mut(&amp;amp;key) {
        Some(value) =&amp;gt; value,
        None =&amp;gt; {
            map.insert(key, &quot;&quot;.to_string());
            map.get_mut(&amp;amp;key).unwrap()
        }
    }
}

fn main() {
    let map = &amp;amp;mut HashMap::new();
    map.insert(22, format!(&quot;Hello, world&quot;));
    map.insert(44, format!(&quot;Goodbye, world&quot;));
    assert_eq!(&amp;amp;*get_default(map, 22), &quot;Hello, world&quot;);
    assert_eq!(&amp;amp;*get_default(map, 66), &quot;&quot;);
}
&lt;/code&gt;&lt;p&gt;这段代码完美通过编译，并且再也不用写那种令人智熄的代码。&lt;/p&gt;&lt;p&gt;另一个有趣的东西是用来展示借用错误的叫做 &lt;code class=&quot;inline&quot;&gt;three point error&lt;/code&gt; 的机制。目前为了开启它你需要显式地给编译器传入 &lt;code class=&quot;inline&quot;&gt;-Znll-dump-cause&lt;/code&gt; 参数。&lt;/p&gt;&lt;p&gt;先看这个在 NLL 下产生借用错误的例子。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![feature(nll)]
#![allow(unused_assignments)]

fn main() {
    let mut x = 22;

    let p = &amp;amp;x;

    x = 33;
    
    println!(&quot;{}&quot;, p);
}
&lt;/code&gt;&lt;p&gt;编译时传入 &lt;code class=&quot;inline&quot;&gt;nll-dump-cause&lt;/code&gt;，three point errors 会产生下面这样的的错误信息&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ rustc -Znll-dump-cause main.rs
error[E0506]: cannot assign to `x` because it is borrowed
  --&amp;gt; src/main.rs:9:5
   |
7  |     let p = &amp;amp;x;
   |             -- borrow of `x` occurs here
8  | 
9  |     x = 33;
   |     ^^^^^^ assignment to borrowed `x` occurs here
10 |     
11 |     println!(&quot;{}&quot;, p);
   |                    - borrow later used here

error: aborting due to previous error
&lt;/code&gt;&lt;p&gt;错误信息指出了起始借用，借用赋值和使用借用的位置，这应该可以给你提供对于问题清晰的思路。&lt;/p&gt;&lt;p&gt;这个机制目前还有性能上的问题，因此我们暂时需要自己手动开启。我们打算在解决性能问题后就将它设为默认。我和 Niko 已经着手，请拭目以待 :)。&lt;/p&gt;&lt;p&gt;我和你们一样非常兴奋于 NLL 最终落地，去尝试使用 NLL 写些代码，然后反馈你遇到的 bug 吧。虽然 NLL 已知存在一些问题需要修复，但是我们知道这都会慢慢完善起来的。&lt;/p&gt;&lt;p&gt;最后，我想说些无关紧要的话，我想分享一下我在 impl period 中的参与这个项目的体验。&lt;/p&gt;&lt;p&gt;首先，我从未想过我竟然能够有机会直接与 Niko 共事，更别说这还是我的第一个 Rust 项目。&lt;/p&gt;&lt;p&gt;Niko 是个令人敬仰的专家 (professional)，更重要的是他非常友好，容易亲近。我们在 Gitter 上交谈了很久，打过 call，然后我们还一起在 Rust Belt Rust 工作过 3 天。&lt;/p&gt;&lt;p&gt;我还与其他开发者花了不少时间讨论想法，比如说 Paul, 我非常感谢他的支持。&lt;/p&gt;</description>
<author>Andy Lok</author>
<guid isPermaLink="false">2018-01-12-32884290</guid>
<pubDate>Fri, 12 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>为什么我喜欢Rust</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-09-05-29079046.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29079046&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天写了一个回答：&lt;a href=&quot;https://www.zhihu.com/question/64563945/answer/225704730&quot;&gt;F001：为什么要使用TypeScript？有哪些情景请简单介绍一下，或者来个例子?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我觉得这个回答也可以用来解释，为什么我喜欢Rust编程语言。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我感觉现在很多程序员并没有彻底接受这样的一个思想：产品设计既需要考虑如何方便好用，也需要考虑如何防止误用。大部分人过于强调方便好用的这一面，而忽略了防止误用的令一面。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不论是设计一个函数、类、框架、还是语言，都不仅要想到用户正常使用的时候是怎样的，还要想到哪些使用方式是有问题的，应该如何设计避免这些可能的误用。哪怕是枪械，也还要加个保险栓呢。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个思想，在绝大部分从业人员的大脑中都是薄弱的，哪怕是C/C++的标准库，都存在很多让人极易用错很难用对的设计，在很多编码规范中都要禁止使用这些功能，更不用说平均水平更低的普通开发者，能写出什么稀奇古怪的代码都不奇怪。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;作为一名源代码静态检查工具的开发者(Coverity)，我见过太多太多奇葩的C/C++用例，但是很遗憾的是编译器并没有阻止它们。Coverity的误报率和漏报率在行业内都算顶尖的，但是对某些问题，我们也无法保证百分百能检查出来。在C/C++里面，有些类别的错误，是没办法被“完整无遗漏”地检查出来的，这是C/C++的本质复杂性决定的，这个任务就是 mission impossible，我们能做的是尽最大可能覆盖尽可能多的用例。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust能够“保证”内存安全、保证线程安全，这是一个非常重要的能力，这不是因为Rust的静态检查用了什么特别的算法技术，而是因为他们作弊了，直接简化了被研究对象。从静态检查器的实现的角度来说，Rust比Coverity简单得多，但效果要更好。C/C++里面很多需要费了老劲检查的问题，在Rust中根本不存在。不存在的问题，当然不需要寻找解决方案。当然，这就是Rust设计组牛逼的地方。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-09-05-29079046</guid>
<pubDate>Tue, 05 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>高阶类型 Higher Kinded Type</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-09-03-29021140.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29021140&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近，又有一份重量级的RFC（&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1598&quot;&gt;https://github.com/rust-lang/rfcs/pull/1598&lt;/a&gt;）被接受。它有多个名字，既可以叫 Generic associated type，也可以叫 associated type constructor，还可以叫 higher kinded type。这就是传说中的“高阶类型”。这个功能一直是学院派开发者一直期望的功能，是类型系统重要的一块拼图。&lt;/p&gt;&lt;p&gt;笔者在这方面经验很少，本文只能做一个简单介绍，当作是写给自己的学习总结。欢迎各位老司机做深入探讨。写完这篇文章，感觉对这个问题的理解更清晰了一些。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;什么是高阶&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们知道，在强类型编程语言中，每一个表达式都有类型。有些类型，在这门语言中是内置的、基本的，我们把它们叫做“基础”类型。比如Rust里面的 i32 bool char 等等。还有一些类型，是通过其它类型一起组合出来的，比如函数，&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn double(arg: i32) -&amp;gt; i32 {
    arg * 2
}&lt;/code&gt;&lt;p&gt;这个函数类型指的是，接受一个 i32 类型参数，生成一个 i32 类型返回值。它们的类型都是可以列出来的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression    |   type
------------------------
true          |   bool
1             |   i32
double        |   i32 -&amp;gt; i32
double(2)     |   i32&lt;/code&gt;&lt;p&gt;如果一个函数，可以接受函数作为参数或者返回值，那么它就是所谓的高阶函数(higher ordered function)。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn twice(f: fn(i32)-&amp;gt;i32) -&amp;gt; Box&amp;lt;Fn(i32)-&amp;gt;i32&amp;gt;
{
    Box::new(move |a| f(f(a)))
}

fn double(arg: i32) -&amp;gt; i32 {
    arg * 2
}

fn main() {
    let g = twice(double);
    println!(&quot;{}&quot;, g(2));
}&lt;/code&gt;&lt;p&gt;上例中，这个 twice 函数，就是高阶函数，它的类型为 (i32-&amp;gt;i32) -&amp;gt; (i32-&amp;gt;i32)。&lt;/p&gt;&lt;p&gt;还有一些更复杂的类型，比如 Vec&amp;lt;i32&amp;gt; 比上面的这些类型更复杂。因为 Vec 本身不是一个合法类型，它必须接受一个类型参数 i32 才能成为一个真正的类型 Vec&amp;lt;i32&amp;gt;。我们可以把 Vec 视为针对类型的“函数”，称作“类型构造器”，给它输入一个类型，它会返回一个类型出来。我们定义一个概念“阶(kind)” 来描述这种现象。比如最基本的类型 i32 bool ，它们的kind就是 type。而 Vec 的kind就是 type -&amp;gt; type。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression |  kind
-------------------
i32        |  type
i32 -&amp;gt; i32 |  type
Vec&amp;lt;i32&amp;gt;   |  type
Vec        |  type -&amp;gt; type&lt;/code&gt;&lt;p&gt;类似的，假如我们有一个类型构造器，它本身可以接受类型构造器作为参数，那它就是“高阶类型”。比如，我们要设计一个容器类型，它里面装的一组 i32 整数，但是我们把内部具体实现方式（可以用 Vec 或者 List）开放出来作为参数由用户指定，伪代码类似这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 类似 scala 的伪代码
struct Collection&amp;lt;C&amp;lt;_&amp;gt;&amp;gt; {
    data: C&amp;lt;i32&amp;gt;
}&lt;/code&gt;&lt;p&gt;使用的时候，我们可以这样指定泛型参数 Collection&amp;lt;Vec&amp;gt; Collection&amp;lt;LinkedList&amp;gt;，那么这个 Collection 就是所谓的“高阶类型”。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression          |  kind
-------------------------------------------
Vec&amp;lt;i32&amp;gt;            |  type
Vec                 |  type -&amp;gt; type
Collection          |  (type-&amp;gt;type) -&amp;gt; type
Collection&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;  |  type -&amp;gt; type&lt;/code&gt;&lt;p&gt;在Rust里面，有个特殊的地方是，泛型参数被分成了两类（两种基本的 kind），分别是 type 以及 lifetime。比如，我们最常见的引用类型，它就是类型构造器，且有生命周期泛型参数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression     | kind
-----------------------
&amp;amp;&#39;a i32        | type
&amp;amp;              | (lifetime, type) -&amp;gt; type&lt;/code&gt;&lt;h2&gt;&lt;b&gt;高阶生命周期&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;实际上，现在的Rust已经支持了某种意义上的“高阶类型”，那就是所谓的“高阶生命周期约束”。参考 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;nomicon&lt;/a&gt;。它的语法如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;for&amp;lt;&#39;a&amp;gt; F: Fn(&amp;amp;&#39;a T) -&amp;gt; &amp;amp;&#39;a T&lt;/code&gt;&lt;p&gt;它代表的意思是，对于任意 &#39;a，F 满足 Fn(&amp;amp;&#39;a T) -&amp;gt; &amp;amp;&#39;a T。比如说，标准库中，就有很多地方用到了这个：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Iterator {
    fn filter&amp;lt;P&amp;gt;(self, predicate: P) -&amp;gt; Filter&amp;lt;Self, P&amp;gt;
        where
            P: FnMut(&amp;amp;Self::Item) -&amp;gt; bool
}&lt;/code&gt;&lt;p&gt;这里的泛型参数 P，就用到了高阶生命周期，源码中的写法是省略写法，如果要写完整，它实际上意思是这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;where P: for&amp;lt;&#39;a&amp;gt; FnMut(&amp;amp;&#39;a Self::Item) -&amp;gt; bool&lt;/code&gt;&lt;p&gt;但是这个语法目前只支持生命周期泛型参数，不能用于普通类型参数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;其它语言中的hkt&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这一部分来自于 niko 的博客，本人完全没有把握是否完整理解了 niko 的文章，欢迎各位提意见。&lt;/p&gt;&lt;p&gt;一个直观的 hkt 设计方案，就是直接为这个功能设计一种高阶类型的语法。举个例子，假如我们想设计一个通用函数，它能把一个容器中的整数类型转换为浮点数类型，容器本身是泛型的，可以是 Vec 或者 LinkedList，可以这么设计:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 假设一种表示高阶类型的语法，类似 scala
fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
//              ^^^^ the notation `I&amp;lt;_&amp;gt;` signals that `I` is
//                   not a complete type&lt;/code&gt;&lt;p&gt;这个例子以及解释是从 Nicholas D. Matsakis 的博客搬运过来的。在这个例子中，I 是一个泛型参数，它是一个类型构造器。假如 I 被实例化为 Vec，那么这个函数的类型就被实例化成了 Vec&amp;lt;i32&amp;gt; -&amp;gt; Vec&amp;lt;f32&amp;gt;，假如 I 被实例化为 LinkedList，那么这个函数的类型就被实例化成了 LinkedList&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;。但是这个设计有许多问题，下面逐一分析。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;高阶trait约束&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Rust泛型的类型检查，是在泛型函数、类型定义的时候当场检查的，而不是等到实例化的时候才检查。所以，对于上面这个泛型函数，我们一定需要对它指定合理的约束条件，否则类型 I&amp;lt;i32&amp;gt; 什么都干不了。&lt;/p&gt;&lt;p&gt;假设我们定义下面这样的一个 trait，来对 Vec 和 LinkedList 做一个统一抽象：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;Item&amp;gt; {
    fn empty() -&amp;gt; Self;
    fn add(&amp;amp;mut self, value: Item);
    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; Self::Iter&amp;lt;&#39;iter&amp;gt;;
    type Iter: Iterable&amp;lt;Item&amp;gt;;
}&lt;/code&gt;&lt;p&gt;然后，对上面那个泛型函数添加高阶类型约束条件：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
    where for&amp;lt;T&amp;gt; I&amp;lt;T&amp;gt;: Collection&amp;lt;T&amp;gt;&lt;/code&gt;&lt;p&gt;看起来这个 higher kinded trait bounds 的设计很合理。但是，我们注意到 Haskell 中是不存在 higher kinded trait bounds 这种东西的，它一定是因为某种原因而没有这样设计。所以 Haskell 里面只能这么写，把各种可能性枚举出来：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
    where I&amp;lt;i32&amp;gt;: Collection&amp;lt;i32&amp;gt;,
          I&amp;lt;f32&amp;gt;: Collection&amp;lt;f32&amp;gt;&lt;/code&gt;&lt;p&gt;如果只能用这样的写法呢，是会有问题的。某些情况下，会造成“抽象泄漏”。比如说，像下面这样一个函数：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn process&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(inputs: &amp;amp;I&amp;lt;Input&amp;gt;) -&amp;gt; I&amp;lt;Output&amp;gt;
    where I&amp;lt;Input&amp;gt;: Collection&amp;lt;Input&amp;gt;, I&amp;lt;Output&amp;gt;: Collection&amp;lt;Output&amp;gt;,
{
    struct MyType { ... }

    ...
}&lt;/code&gt;&lt;p&gt;如果这个函数内部定义了一个类型，这个函数的输出类型是 I&amp;lt;MyType&amp;gt;。那我们的这个泛型约束就很难写出来，除非把 MyType 定义到这个函数外边。本来我们希望封装到内部的类型，被迫暴露出去了，这就是抽象泄漏。&lt;/p&gt;&lt;p&gt;对 Haskell 来说，这好像是一个比较常见的问题。随手搜索了一下，看起来 Haskell 的解决方案是使用 &lt;a href=&quot;https://stackoverflow.com/questions/25422342/arbitrary-class-constraints-when-implementing-type-classes-in-haskell&quot;&gt;TypeFamily&lt;/a&gt;。这也是Rust设计组准备采用的方案。&lt;/p&gt;&lt;p&gt;在 Scala 中，如何表达任意的高阶类型约束不清楚，希望有网友能告知。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;高阶Self类型&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在前面，我们定义了一个trait Collection&amp;lt;T&amp;gt;，它的成员类型是 T。因此我们可以对不同的容器写这样的 impl：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl&amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt; {}
//                        ^^ this is a type&lt;/code&gt;&lt;p&gt;在这个impl块中，我们针对的是 Vec&amp;lt;T&amp;gt; 来实现的，它的kind是 type。如果我们要支持高阶类型，那么我们应该支持针对kind为 type-&amp;gt;type 的类型impl。我们现在更进一步，如果我们想定义一个高阶trait，怎么办？意思是，impl 的时候 for 后面的那个目标如果是“类型构造器”的话，是什么情况。假设我们这么设计：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait HkCollection for Self&amp;lt;_&amp;gt; {
//    ^^               ^^^^^^^ declare that `Self` is a type constructor
//    stands for &quot;higher-kinded&quot;

    fn empty&amp;lt;T&amp;gt;() -&amp;gt; Self&amp;lt;T&amp;gt;;
    fn add&amp;lt;T&amp;gt;(self: &amp;amp;mut Self&amp;lt;T&amp;gt;, value: T);
    //    ^^^ the `T` effectively moved from the trait to the methods
    ...
}

impl HkCollection for Vec&amp;lt;_&amp;gt; {
//                    ^^ this is a type constructor
    fn empty&amp;lt;T&amp;gt;() -&amp;gt; Vec&amp;lt;T&amp;gt; {
        Vec::new()
    }
    ...
}&lt;/code&gt;&lt;p&gt;如果有了这样的东西，那么我们可以针对任何一个类型构造器 I，写这样的约束条件 where I: HkCollection，而不需要写 where for&amp;lt;T&amp;gt; I&amp;lt;T&amp;gt;: Collection&amp;lt;T&amp;gt;，因为我们的 HkCollection 是作用到类型构造器上的。&lt;/p&gt;&lt;p&gt;这个设计看起来很不错，但它有非常巨大的缺陷。比如，它无法针对 BitSet 这样的容器 impl。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl HkCollection for BitSet {}
//                    ^^ not a type constructor&lt;/code&gt;&lt;p&gt;另外一个问题是，有些容器，它对内部元素的类型是有约束条件的。比如 HashSet&amp;lt;T&amp;gt;，它要求 T: Hash 条件。在上面这个设计中，像 Self&amp;lt;_&amp;gt; 这样的设计，实际上没有办法约束 _ 应该满足什么条件：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait HkCollection for HashSet&amp;lt;_&amp;gt;
//                     ^^^^^^^ how can we restrict `_` to `Hash` types?&lt;/code&gt;&lt;p&gt;Haskell 的 HKT 似乎是可以应用到任意类型上的，无法指定约束条件。但是在Rust里面，约束条件无处不在，我们如果选择 Foo&amp;lt;_&amp;gt; 这样的设计，那么一定要想个办法来写清楚 _ 的约束条件。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;类型推断&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注意到前面我们说过的，Rust的一个特殊之处在于，它的泛型参数有两种 kind，分别是 type 和 lifetime。假如我们有这样的一个类型：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct ListIter&amp;lt;&#39;iter, T&amp;gt; { ... }&lt;/code&gt;&lt;p&gt;那么，一个完整的 ListIter&amp;lt;&#39;a, T&amp;gt; 它的 kind 是 type，而 ListIter 它的 kind 可以看作 (lifetime, type)-&amp;gt;type。如果我们定义一个类型 type I&amp;lt;&#39;_&amp;gt; = ListIter&amp;lt;&#39;_, i32&amp;gt;，那么 I 的 kind 就是 lifetime-&amp;gt;type。高阶类型内部还可以嵌套，比如 G&amp;lt;_&amp;lt;_&amp;gt;&amp;gt;，那么这个 G 的 kind 就是 (type-&amp;gt;type)-&amp;gt;type。这种设计可以让你把“类型”当成“函数”来看待，有些类型本身接受类型参数，然后生成新的类型。但是，它还有个缺陷是，影响了类型推断 type inference。我们来看这个例子：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;&lt;/code&gt;&lt;p&gt;这里的类型参数 I 的 kind 是 type-&amp;gt;type。这个函数的目的是，把一个容器内部的元素从 i32 转成 f32（Vec&amp;lt;i32&amp;gt; -&amp;gt; Vec&amp;lt;f32&amp;gt; 或者 LinkedList&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;，而不是 Vec&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;）。那么，现在这个类型推断就会出问题了，即便我们已经知道了具体的实参类型和返回值类型，我们还是解不出来这个 I 是什么。&lt;/p&gt;&lt;p&gt;这个问题实际上是这样的，I 实际上是一个“函数”，它输入一个 type，输出一个 type。现在我们可以从实参类型，得到它的其中一个输入以及对应的输出 I&amp;lt;i32&amp;gt; == Vec&amp;lt;i32&amp;gt;。我们还可以从返回类型，得到它的另外一个输入以及对应的输出 I&amp;lt;f32&amp;gt; == Vec&amp;lt;f32&amp;gt;。请问现在这个 I 是什么。这个问题类似于：假设 f(1) == 2 且 f(2) == 3，求函数 f 是什么。这个问题没有“唯一”解。当然，如果我们假设 f 一定是一阶函数，那么我们可以求出来 f(x) = x + 1，但是没有这个条件的情况下就难说了。&lt;/p&gt;&lt;p&gt;Haskell 是没有这个问题的，这是因为 Haskell 限制了泛型参数的应用顺序，即所谓的 Currying。在Rust中没有 Currying，这意味着 Vec&amp;lt;_&amp;gt; 的kind 是 type-&amp;gt;type，Result&amp;lt;_, i32&amp;gt; 的kind是 type-&amp;gt;type，Result&amp;lt;i32, _&amp;gt; 的kind也是 type-&amp;gt;type。所以，假设我们有下面这样一个方程求解：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;?1&amp;lt;?2&amp;gt; = Result&amp;lt;i32, u32&amp;gt;&lt;/code&gt;&lt;p&gt;那么 ?1 = Result&amp;lt;i32, _&amp;gt;, ?2 = u32 或者 ?1 = Result&amp;lt;_, u32&amp;gt;, ?2 = i32，都是这个方程的解。&lt;/p&gt;&lt;p&gt;Rust是不能采用Currying的设计的。第一个原因是它有两种基本的 kind。比如说我们有个类型 Iterable&amp;lt;&#39;a, T&amp;gt;，按Haskell的观点，它的 kind 可以写成 lifetime -&amp;gt; type -&amp;gt; type（实际上它还要求 T: &#39;a，这个就更复杂了先忽略）。我们希望给它一个指定的 T，那么它的kind就会变成 lifetime -&amp;gt; type。但是Currying是不允许这样的，参数是按顺序的，你必须先指定一个固定的lifetime，让它的kind变成 type-&amp;gt;type。&lt;/p&gt;&lt;p&gt;Rust不采用Currying的第二个原因是，在实际中有些类型不是按顺序应用泛型参数的。比如我们的 HashMap 类型，它有三个泛型参数：pub struct HashMap&amp;lt;K, V, S = RandomState&amp;gt;，我们可能希望有一个类型构造器是这样的 M = HashMap&amp;lt;_, _, S&amp;gt;，但是用 Currying 是得不到的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;ATC&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;前面讲了很多为什么不在Rust中直接支持HKT的理由。接下来我们回到正题，说一说这个RFC究竟是一个什么样的提案。从这个提案的名字上，我们就可以看出一点端倪，它叫做 generic associated types (泛型关联类型)，或者叫做 associated type constructors (关联类型构造器)。它的实质就是，允许trait里面的“关联类型”成为“类型构造器”。比如说：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Iterable {
    type Item&amp;lt;&#39;a&amp;gt;; // 注意它携带泛型参数
    // Item 的 kind 是 lifetime -&amp;gt; type
}

trait Foo {
    type Bar&amp;lt;T&amp;gt;;  // 泛型参数可以是生命周期，可以是类型
    // Bar 的 kind 是 type -&amp;gt; type
}&lt;/code&gt;&lt;p&gt;语法上非常简单，就是这么一个小小的扩展。我们来看看在这个功能基础上，怎么设计本文前面的那个 floatify 函数。首先我们当然需要一个 trait，来统一抽象我们的容器类型：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;T&amp;gt; {
    fn empty() -&amp;gt; Self;
    fn add(&amp;amp;mut self, value: T);
    fn iterate(&amp;amp;self) -&amp;gt; Self::Iter;
    type Iter: Iterator&amp;lt;Item=T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;假设我们有一个具体容器，名字叫做 List&amp;lt;T&amp;gt;，我们针对这个类型，实现这个 trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl&amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; for List&amp;lt;T&amp;gt; {
    fn empty() -&amp;gt; List&amp;lt;T&amp;gt; {
        List::new()
    }

    fn add(&amp;amp;mut self, value: T) {
        self.prepend(value);
    }

    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; ListIter&amp;lt;&#39;iter, T&amp;gt; {
        self.iter()
    }

    type Iter = ListIter&amp;lt;&#39;iter, T&amp;gt;;
    //                   ^^^^^ oh, wait, this is not in scope!
}&lt;/code&gt;&lt;p&gt;从这里我们看到了问题所在，在写最后的关联类型的时候，我们发现，这个生命周期参数没法写。这时候，就该ATC这个功能出场了。我们可以让这个关联类型不是一个具体类型，而是一个“类型构造器”，它的 kind 为 lifetime-&amp;gt;type，这样我们可以让它在各种场合下，针对不同的生命周期，生成合适的类型。修改 trait 的设计如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;T&amp;gt; {
    // as before
    fn empty() -&amp;gt; Self;
    fn add(&amp;amp;mut self, value: T);

    // Here, we use associated type constructors:
    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; Self::Iter&amp;lt;&#39;iter&amp;gt;;
    type Iter&amp;lt;&#39;iter&amp;gt;: Iterator&amp;lt;Item=T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;注意这个语法，有点容易混淆，这个关联类型 Iter 在声明的时候有个参数，就代表它是“类型构造器”，在 iterator 方法返回的时候，我们要给 Iter 一个合适的参数，它才能生成具体的类型。我们对具体类型来impl这个trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;use std::slice;
impl&amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt; {
    fn empty() -&amp;gt; Self { vec![] }
    fn add(&amp;amp;mut self, value: T) { self.push(value); }
    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; slice::Iter&amp;lt;&#39;self, T&amp;gt; { self.iter() }
    type Iter&amp;lt;&#39;iter&amp;gt; = slice::Iter&amp;lt;&#39;iter, T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;那么，用这样的一个 trait，我们就可以实现最开始的那个函数了：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify&amp;lt;I, F&amp;gt;(ints: &amp;amp;I) -&amp;gt; F
    where I: Collection&amp;lt;i32&amp;gt;, F: Collection&amp;lt;f32&amp;gt;
{
    let mut floats = F::empty();
    for &amp;amp;f in c.iterate() {
        floats.add(f as f32);
    }
    floats
}&lt;/code&gt;&lt;p&gt;这个函数是可以工作的。但是，它有一个缺点，那就是，不仅可以支持 Vec&amp;lt;i32&amp;gt; -&amp;gt; Vec&amp;lt;f32&amp;gt; 还可以支持 Vec&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn test(x: &amp;amp;Vec&amp;lt;i32&amp;gt;) {
    let y: Vec&amp;lt;f32&amp;gt; = floatify(x); // 可以通过
    let z: LinkedList&amp;lt;f32&amp;gt; = floatify(x); // 可以通过
    let p = floatify(x); // 编译错误，p 的类型无法推断
}&lt;/code&gt;&lt;p&gt;所以，这个实现依然不是我们想要的东西，我们想要的是类似这样的函数：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 输入和输出是同样的容器类型
fn floatify_hkt&amp;lt;I&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
//                        ^^^^^^ wait up, what is `I` here?&lt;/code&gt;&lt;p&gt;接下来，我们要用一种“设计模式”，叫做 type family（也是从 Haskell 学的）。我们另外定义一个trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait CollectionFamily {
    // Member 也是一个 type constructor
    type Member&amp;lt;T&amp;gt;: Collection&amp;lt;T, Family = Self&amp;gt;;
}&lt;/code&gt;&lt;p&gt;针对具体类型 Vec 和 List 实现这个trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct VecFamily;

impl CollectionFamily for VecFamily {
    type Member&amp;lt;T&amp;gt; = Vec&amp;lt;T&amp;gt;;
}

struct ListFamily;

impl CollectionFamily for ListFamily {
    type Member&amp;lt;T&amp;gt; = List&amp;lt;T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;并且在原先的 Collection 中，再添加一个关联类型，指向 family：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;T&amp;gt; {
    // Backlink to `Family`.
    type Family: CollectionFamily;
    ...&lt;/code&gt;&lt;p&gt;接下来，我们用这个 CollectionFamily 来重新实现 floatify:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_family&amp;lt;C&amp;gt;(ints: &amp;amp;C) -&amp;gt; C::Family::Member&amp;lt;f32&amp;gt;
    where C: Collection&amp;lt;i32&amp;gt;
{
    let mut floats = C::Family::Member&amp;lt;f32&amp;gt;::empty();
    for &amp;amp;f in c.iterate() {
        floats.add(f as f32);
    }
    floats
}&lt;/code&gt;&lt;p&gt;上面这个设计圆满了，它满足了我们所有的需求。注意上面我们用到了针对 ATC 的约束：type Member&amp;lt;T&amp;gt;: Collection&amp;lt;T, Family = Self&amp;gt;;，它代表的真实含义实际上是：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;for&amp;lt;T&amp;gt; Self::Member&amp;lt;T&amp;gt;: Collection&amp;lt;T, Family = Self&amp;gt;;&lt;/code&gt;&lt;p&gt;所以，我们也同时做到了针对高阶类型的约束。ATC 这个设计，语法改动小，基本是现有语法的一个自然延伸，而且可以完成高阶类型的功能，非常契合Rust当前的状态，相比而言，直接支持高阶类型语法不是一个好的选择。&lt;/p&gt;&lt;p&gt;目前，Rust编译器里面关于trait的逻辑很乱，还有一些难以修复的bug。因此，niko开了一个新项目 &lt;a href=&quot;https://github.com/nikomatsakis/chalk&quot;&gt;https://github.com/nikomatsakis/chalk&lt;/a&gt;，重写整个trait系统。在这个新的架构下，ATC功能基本是水到渠成顺手就做了的事情。所以，只要等 chalk 什么时候合并到正式编译器里面，用户就可以使用这个功能了，目测2017年有点悬，2018年肯定能实现。&lt;/p&gt;&lt;p&gt;高阶类型的出现，很可能可以解锁一些以前难以实现的问题，这还需要社区做更多的探索。比如，最近就有人提到，Generator 生成器最好是基于ATC来实现，否则有些场景下会出现编译错误，限制用户的发挥，参考 &lt;a href=&quot;https://internals.rust-lang.org/t/streaming-generators/5850&quot;&gt;https://internals.rust-lang.org/t/streaming-generators/5850&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;很长一段时间以来，编程语言界出现了一大批换汤不换药的新语言，它们基本上都在朝一个方向努力，即降低开发难度。Rust偏偏剑走偏锋，主打底层和安全，是一个非常精明的举措。细看Rust的设计，其实也没有什么是独特的创新的，不论语法、安全、抽象、优化等等各方面，都有前人有过充分的研究和探讨。但是Rust设计组把它们组合起来，却进入了一个全新的境界，这应该是第一个把底层控制力、安全性、高级抽象能力各方面做得最平衡的一门语言。既面向底层，又有高级类型系统，恰好市面上没有竞争对手。&lt;/p&gt;&lt;p&gt;随着接下来 const generic 等 RFC 陆续设计完成，Rust在类型系统上的能力还会大幅提高。既要有高阶抽象能力，又要高性能，看起来并不是不可能完成的任务，不是么？或许在这个领域内，以后还会有其它更优秀的语言出现，但这没关系，方向已经指明，前途已经明朗，基础已经铺就，Rust证明了安全性、高级抽象能力、底层控制力，并非水火不相容。&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-09-03-29021140</guid>
<pubDate>Sun, 03 Sep 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
