<p>大家可能在很多编程语言里都看到过QuickCheck这个自动化随机测试库，其实这套方法最初是在Haskell98上实现，原始论文<sup data-text="Koen Claessen and John Hughes. 2000. QuickCheck: a lightweight tool for random testing of Haskell programs. SIGPLAN Not. 35, 9 (September 2000), 268-279. DOI: https://doi.org/10.1145/357766.351266" data-url="" data-draft-node="inline" data-draft-type="reference" data-numero="1">[1]</sup>写于2000年，强烈建议读一读，后来其中一位作者John Hughes用Erlang重新实现还开了家软件测试公司，据说帮Volvo做汽车软件集成测试效果很不错（广告共赢）。测试跟形式验证不同，本质上是反证法，把同一个测试用例算两次做比较，对于spec上的每一行功能说明，单元测试和QuickCheck都在尝试构造反例，如果找不到并不能证明实现是正确的。测试的构造性意味着量变往往无法转化为质变，盲目测试常常就是大海捞针。单元测试是靠人脑想边角案例，人手写测试用例，初始阶段效果可能很好，但后面边际收益很低；QuickCheck是基于Property的，自动生成随机测试用例，所谓Property其实就是返回值为Bool的函数，是剥离掉实现细节对功能说明API做的抽象，往往可以从spec的说明直接翻译成代码，比如加法有单位率，结合律，交换律，事实上任何满足这三种定律某种意义上都可以被称作加法。我建议读一读这篇文章<sup data-text="" data-url="https://fsharpforfunandprofit.com/posts/property-based-testing-2/" data-draft-node="inline" data-draft-type="reference" data-numero="2">[2]</sup>，作者列了七种Property常见的来源，比如算两次，不变性等等。当然数学里各种运算的性质也可以拿过来用，比如分配律，幂等律。如果是写Haskell，类型类公理往往也是Property的来源之一，FRP的发明人Conal Elliott就曾围绕此专门写过文章<sup data-text="Elliott, Conal. (2009). Denotational design with type class morphisms. " data-url="" data-draft-node="inline" data-draft-type="reference" data-numero="3">[3]</sup>谈如何设计没有抽象泄露的API。<br/><br/>好了回到Haskell，单元测试是在写一个形如Eq b =&gt; a -&gt; b的partial函数或者是Eq v =&gt; [(k, v)]，如果是多个参数可以用uncurry转化为这种形式，QuickCheck则是在写一个形似Generative a =&gt; a -&gt; Bool的total函数，如果是多个参数可以用curry加上类型类转化。这一点形式的不同会带来诸多好处，首先GHC能检查一部分totality，比如说模式匹配是否完全，一定程度上（概率为1）我们在测试整个指定的定义域，当然如果想声明前提条件排除一部分值在QuickCheck里也很容易；其次，Haskell默认curry，加上全局类型推导，这种可归纳形式十分有利，多参数的情况完全不必手动uncurry；再者，如果不显式写出类型，GHC会用输入参数最泛化的类型，在Haskell里自由定理保证了函数越泛化能通过类型检查的实现越少，我们写出来的特性自动多了一层安全性和抽象性，这种抽象性反过来还能帮助思考和检查spec错误，随机测试效果也更好。<br/><br/>当然QuickCheck也有缺点。首先围绕API写一个好的特性就不容易，如果测试者用了实现者同样的错误思路来写特性，测试效果为零。其次如果定义域约束比较复杂，用generate-then-filter方法产生输入参数效果很差，得手动写发生器，更复杂的约束甚至得求助于random constraint solver。保证概率为1遍历整个定义域也不代表真正遍历，其实标准设置情况下保证不了概率为1，因为有个隐藏的变量size，SmallCheck可以保证完全遍历某个范围内的全部取值可能。所以要克服以上这些缺点，需要懂一点QuickCheck背后的原理。QuickCheck干净轻量，论文附录就有整个库的代码，不到三百行，不含任何编译器扩展，唯一依赖的外部库是随机序列发生器，当然最初的库没有实现自动shrink反例的功能，因为作者没想到。shrink来自于Andy Gill的想法，我觉得这跟他写的应用是PrettyPrint相关，对于很多递归类型shrink函数的实现并没有直观意义，完全需要依靠problem domain的知识和经验。</p><div class="highlight"><pre><code class="language-haskell"><span class="cm">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="cm">{-# LANGUAGE ApplicativeDo #-}</span>
<span class="cm">{-# LANGUAGE RankNTypes    #-}</span>
<span class="cm">{-# LANGUAGE GADTs         #-}</span>

<span class="kr">import</span> <span class="nn">Data.Bits</span>
<span class="kr">import</span> <span class="nn">Data.List</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>
<span class="kr">import</span> <span class="nn">Data.Monoid</span>
<span class="kr">import</span> <span class="nn">System.Random</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">join</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Arrow</span> <span class="p">((</span><span class="o">&amp;&amp;&amp;</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Text.Show.Functions</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span></code></pre></div><p>我今天重写了一下QuickCheck，用到的数据类型跟库代码有所不同，但实现了它所有的主要特性，而且我相信更容易理解，尤其是shrink过程。首先还是设计数据类型，随机测试需要用到伪随机序列发生器和概率分布来产生输入参数类型的随机值。产生符合期望的随机值这并不容易，数学家到现在都没搞清楚Pi或者2的平方根十进制序列到底是不是性质良好的随机序列，概率就更难，幸好是这里处理的是离散概率分布，简单值类型均匀分布就够了，复杂自定义类型需要注意避免耦合，耦合的结果有时候会违反直觉，比如x是均匀分布的随机值，2*x是均匀分布，但如果耦合x+x却是正态分布。这里有个有趣的问题<sup data-text="" data-url="https://github.com/CppCon/CppCon2016/tree/master/Presentations/What%20C%2B%2B%20Programmers%20Need%20to%20Know%20About%20random" data-draft-node="inline" data-draft-type="reference" data-numero="4">[4]</sup>，如果有枚两面不对称的硬币，如何抛才能产生任意有理数的二项式分布样本，比如最简单的p=0.5，大家可以想想。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Dist</span> <span class="p">{</span> <span class="nf">runDist</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">StdGen</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Distribution</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Dist</span> <span class="o">$</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span>
  <span class="kt">Dist</span> <span class="nf">f</span> <span class="o">&lt;*&gt;</span> <span class="kt">Dist</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Dist</span> <span class="o">$</span> <span class="nf">\s</span> <span class="nf">r</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="nf">r1</span><span class="p">,</span> <span class="nf">r2</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">split</span> <span class="nf">r</span> <span class="kr">in</span> <span class="nf">f</span> <span class="nf">s</span> <span class="nf">r1</span> <span class="p">(</span><span class="nf">a</span> <span class="nf">s</span> <span class="nf">r2</span><span class="p">)</span></code></pre></div><p>分布用Distribution来表示，它是函子，这没有问题，但如果只声明为函子，那写起自定义类型的分布会十分繁琐，QuickCheck额外还定义了Distribution单子的实例，这样就可以随心所欲地使用语法do，不过它违反单子的公理，更糟糕的是对于自定义递归类型，单子意味着稍不注意就会引入耦合，作者在定义单子实例时很小心用split避免了这个问题。我觉得定义合用函子的实例就够了，这样同样可以愉快地使用ApplicativeDo语法，不过它也违反了合用函子的三条公理。我跟作者一样认为这是合理的，因为随机变量本来就没有pointwise equality的定义。你可能会想StdGen是State Monad，Distribution还有点像Reader Monad，为啥不用MTL？这主要是因为如果用State就没法写输入参数是函数的随机值发生器。另外如果利用自由合用函子构造，我们能设计出完全符合合用函子公理的分布，也能写简单函数类型的随机值生成器，但GADT会擦除中间shrinkable的信息，导致最终的Property实现不了shrink功能。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">frequency</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Distribution</span> <span class="nf">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span>
<span class="nf">frequency</span> <span class="nf">fs</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="nf">as</span> <span class="ow">&lt;-</span> <span class="nf">sequenceA</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">snd</span> <span class="nf">fs</span><span class="p">);</span> <span class="nf">w</span> <span class="ow">&lt;-</span> <span class="nf">choose</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">head</span> <span class="nf">ws</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="nf">pure</span> <span class="p">(</span><span class="nf">pick</span> <span class="p">(</span><span class="nf">tail</span> <span class="nf">ws</span><span class="p">)</span> <span class="nf">as</span> <span class="nf">w</span><span class="p">)</span> <span class="p">}</span> 
  <span class="kr">where</span>
    <span class="nf">ws</span> <span class="ow">=</span> <span class="nf">scanr1</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">fst</span> <span class="nf">fs</span><span class="p">)</span>
    <span class="nf">pick</span> <span class="kt">[]</span>     <span class="p">(</span><span class="nf">a</span><span class="kt">:</span><span class="nf">as</span><span class="p">)</span> <span class="nf">r</span> <span class="ow">=</span> <span class="nf">a</span>
    <span class="nf">pick</span> <span class="p">(</span><span class="nf">w</span><span class="kt">:</span><span class="nf">ws</span><span class="p">)</span> <span class="p">(</span><span class="nf">a</span><span class="kt">:</span><span class="nf">as</span><span class="p">)</span> <span class="nf">r</span> <span class="ow">=</span> <span class="kr">if</span> <span class="nf">r</span> <span class="o">&gt;=</span> <span class="nf">w</span> <span class="kr">then</span> <span class="nf">a</span> <span class="kr">else</span> <span class="nf">pick</span> <span class="nf">ws</span> <span class="nf">as</span> <span class="nf">r</span>
<span class="kr">data</span> <span class="kt">Rose</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Rose</span> <span class="nf">a</span> <span class="p">[</span><span class="kt">Rose</span> <span class="nf">a</span><span class="p">]</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
 
<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Arbitrary</span> <span class="p">(</span><span class="kt">Rose</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">sized</span> <span class="nf">arbRose</span> <span class="kr">where</span>
    <span class="nf">arbRose</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Rose</span> <span class="o">&lt;$&gt;</span> <span class="nf">arbitrary</span> <span class="o">&lt;*&gt;</span> <span class="nf">pure</span> <span class="kt">[]</span> 
    <span class="nf">arbRose</span> <span class="nf">n</span> <span class="ow">=</span> <span class="nf">frequency</span>
      <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">arbRose</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kt">Rose</span> <span class="o">&lt;$&gt;</span> <span class="nf">arbitrary</span> <span class="o">&lt;*&gt;</span> <span class="nf">resize</span> <span class="p">(</span><span class="nf">n</span> <span class="p">`</span><span class="nf">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="nf">arbitrary</span><span class="p">)</span>
      <span class="p">]</span></code></pre></div><p>有了合用函子方法，我们就能方便定义智能构造器了。假设现在要定义玫瑰树的分布，很容易写出oneOf [Rose &lt;$&gt; arbitrary &lt;*&gt; [], Rose &lt;$&gt; arbitrary &lt;*&gt; arbitrary]，或者要尽可能多地产生深度大于1的玫瑰树，你会用frequency。但是注意子树对应的arbitrary是递归调用，虽然定义了终止条件，但递归使得终止发生的概率指数级减小，最后生成的玫瑰树可能非常深，根本无法控制大小。为了解决这个问题，Distribution引入一个隐藏的自然数，用来表示类型数据的大小。它是全局的，每轮测试所有参数拿到的都一样，然后逐渐增大。引入size主要是控制随机生成的递归类型数据，比如表示列表的长度或者二叉树的深度。它也可以用来表示值类型数据的范围，比如默认设置库里面整数的取值范围就不是整个31位，可以看出这样测试涉及到整数运算溢出Property时非常容易误用，用下面三个函数可以很方便地重新配置它。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">sized</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span>
<span class="nf">sized</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Dist</span> <span class="o">$</span> <span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="nf">runDist</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">s</span><span class="p">)</span> <span class="nf">s</span>
 
<span class="nf">resize</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span>
<span class="nf">resize</span> <span class="nf">s</span> <span class="nf">d</span> <span class="ow">=</span> <span class="kt">Dist</span> <span class="o">$</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="nf">runDist</span> <span class="nf">d</span> <span class="nf">s</span>
   
<span class="nf">scale</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span>
<span class="nf">scale</span> <span class="nf">f</span> <span class="nf">g</span> <span class="ow">=</span> <span class="nf">sized</span> <span class="o">$</span> <span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="nf">resize</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">s</span><span class="p">)</span> <span class="nf">g</span></code></pre></div><p>有了合用函子的实例和操作size的三个函数，就可以愉快地写我最喜欢的智能构造器了。对于常见基本类型，可以用类型类Arbitrary在编译期保存分布信息，这样通过类型推导，GHC自动会生成输入参数是基本类型的Property。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">class</span> <span class="kt">Arbitrary</span> <span class="nf">a</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">::</span> <span class="kt">Distribution</span> <span class="nf">a</span>
  <span class="nf">shrink</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Succs</span> <span class="nf">a</span>
  <span class="nf">shrink</span> <span class="ow">=</span> <span class="nf">flip</span> <span class="kt">Succs</span> <span class="kt">[]</span>

<span class="nf">choose</span> <span class="ow">::</span> <span class="kt">Random</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span>
<span class="nf">choose</span> <span class="nf">r</span> <span class="ow">=</span> <span class="kt">Dist</span> <span class="o">$</span> <span class="nf">const</span> <span class="p">(</span><span class="nf">fst</span> <span class="o">.</span> <span class="nf">randomR</span> <span class="nf">r</span><span class="p">)</span>

<span class="nf">chooseAny</span> <span class="ow">::</span> <span class="kt">Random</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span>
<span class="nf">chooseAny</span> <span class="ow">=</span> <span class="kt">Dist</span> <span class="o">$</span> <span class="nf">const</span> <span class="p">(</span><span class="nf">fst</span> <span class="o">.</span> <span class="nf">random</span><span class="p">)</span>

<span class="nf">elements</span> <span class="ow">::</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span>
<span class="nf">elements</span> <span class="nf">as</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="nf">n</span> <span class="ow">&lt;-</span> <span class="nf">choose</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">length</span> <span class="nf">as</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="nf">pure</span> <span class="p">(</span><span class="nf">as</span> <span class="o">!!</span> <span class="nf">n</span><span class="p">)</span> <span class="p">}</span>

<span class="nf">oneOf</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Distribution</span> <span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span>
<span class="nf">oneOf</span> <span class="nf">gs</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="nf">as</span> <span class="ow">&lt;-</span> <span class="nf">sequenceA</span> <span class="nf">gs</span><span class="p">;</span> <span class="nf">n</span> <span class="ow">&lt;-</span> <span class="nf">choose</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">length</span> <span class="nf">gs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="nf">pure</span> <span class="p">(</span><span class="nf">as</span> <span class="o">!!</span> <span class="nf">n</span><span class="p">)</span> <span class="p">}</span>

<span class="nf">vectorOf</span> <span class="ow">::</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">vectorOf</span> <span class="nf">g</span> <span class="ow">=</span> <span class="nf">sequenceA</span> <span class="o">.</span> <span class="nf">flip</span> <span class="nf">replicate</span> <span class="nf">g</span>

<span class="nf">listOf</span> <span class="ow">::</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">listOf</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="nf">as</span> <span class="ow">&lt;-</span> <span class="nf">sized</span> <span class="p">(</span><span class="nf">vectorOf</span> <span class="nf">g</span><span class="p">);</span> <span class="nf">n</span> <span class="ow">&lt;-</span> <span class="nf">sized</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="nf">choose</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">s</span><span class="p">));</span> <span class="nf">pure</span> <span class="p">(</span><span class="nf">take</span> <span class="nf">n</span> <span class="nf">as</span><span class="p">)</span> <span class="p">}</span> 

<span class="nf">listOf1</span> <span class="ow">::</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">listOf1</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="nf">as</span> <span class="ow">&lt;-</span> <span class="nf">sized</span> <span class="p">(</span><span class="nf">vectorOf</span> <span class="nf">g</span><span class="p">);</span> <span class="nf">n</span> <span class="ow">&lt;-</span> <span class="nf">sized</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="nf">choose</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">s</span><span class="p">));</span> <span class="nf">pure</span> <span class="p">(</span><span class="nf">take</span> <span class="nf">n</span> <span class="nf">as</span><span class="p">)</span> <span class="p">}</span> 

<span class="nf">orderedList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Arbitrary</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Distribution</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">orderedList</span> <span class="ow">=</span> <span class="nf">sort</span> <span class="o">&lt;$&gt;</span> <span class="nf">listOf</span> <span class="nf">arbitrary</span></code></pre></div><p>刚才说到之所以不用State Monad是为了能自动生成简单函数的分布。首先Distribution (a-&gt;b)是Int-&gt;StdGen-&gt;a-&gt;b外面的一层wrapper，用curry合并输入参数得到(Int, StdGen, a)-&gt;b，注意到(Int, StdGen, a)和(a, Int, StdGen)同构，再用uncurry可以得到a-&gt;(Int-&gt;StdGen-&gt;b)，总结起来就是下面的promote函数。那么怎样才能生成a-&gt;Gen b呢？注意到每个基本类型其实就是内存里一串存储的01序列，函数即值，值也是函数，我们可以把01序列看作分布的扰动器，结合split很容易就能写出以下variant函数，注意扰动的其实是随机序列，并没有任何数学意义，因为函数是point free很难定义其值的分布。这个技巧还可以用在理解foldl::(b-&gt;a-&gt;b)-&gt;b-&gt;t a-&gt;b和foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;t a-&gt;b上，可以把a看作action b-&gt;b，foldl其实就是依次执行这些action，初始状态是b，对于foldr，我们需要进一步把b-&gt;b看作action (b-&gt;b)-&gt;(b-&gt;b)，可以理解为有了前一个action才进行这个action，初始状态是id，我们就能够很容易地用foldr表示foldl。回到产生函数的值分布，基本类型的和积类型也都是内存里面的一串01序列，想想C里面struct的存储，我们用Coarbitrary类型类来表示这一类扰动函数。扰动器区别的是同一类型的不同值并非不同类型，对于自定义类型或者递归类型，只需要把这个类型的值构造器也序列化就行。如果想不清楚这一点，很容易写错比如Either a b很容易错写成coarbitrary (Left a) = coarbitrary a和coarbitrary (Right b) = coarbitrary b，可以试试写一下二叉树的coarbitrary。好了，有了Arbitrary a和Coarbitrary b，GHC就能帮我们自动推导Arbitrary (b -&gt; a)。这里还有最后一个问题，如果输入参数是高阶函数怎么办，函数值貌似无法序列化就无法写Coarbitrary (a-&gt;b)，事实上如果定义了Distribution的单子方法是可以写出来的，但我觉得实在无法解释函数扰动器的作用，函数本来也没有pointwise意义上的相等，如何定义不同函数是否产生不同的扰动效果，而且实际应用中很少有输入参数是高阶函数的。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">promote</span> <span class="ow">::</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">b</span><span class="p">)</span>
<span class="nf">promote</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Dist</span> <span class="o">$</span> <span class="nf">\s</span> <span class="nf">r</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">runDist</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="nf">s</span> <span class="nf">r</span>

<span class="nf">variant</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span>
<span class="nf">variant</span> <span class="nf">n</span> <span class="nf">d</span> <span class="ow">=</span> <span class="kt">Dist</span> <span class="o">$</span> <span class="nf">\s</span> <span class="nf">r</span> <span class="ow">-&gt;</span> <span class="nf">runDist</span> <span class="nf">d</span> <span class="nf">s</span> <span class="p">(</span><span class="nf">iter</span> <span class="nf">r</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="nf">cnt</span>  <span class="ow">=</span> <span class="nf">maybe</span> <span class="mi">64</span> <span class="nf">id</span> <span class="p">(</span><span class="nf">bitSizeMaybe</span> <span class="nf">n</span><span class="p">)</span>
    <span class="nf">bits</span> <span class="ow">=</span> <span class="nf">testBit</span> <span class="nf">n</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="nf">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="nf">iter</span> <span class="ow">=</span> <span class="nf">flip</span> <span class="p">(</span><span class="nf">foldr</span> <span class="p">(</span><span class="nf">\b</span> <span class="nf">r</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="nf">b</span> <span class="kr">then</span> <span class="nf">fst</span> <span class="p">(</span><span class="nf">split</span> <span class="nf">r</span><span class="p">)</span> <span class="kr">else</span> <span class="nf">snd</span> <span class="p">(</span><span class="nf">split</span> <span class="nf">r</span><span class="p">)))</span> <span class="nf">bits</span>  

<span class="kr">class</span> <span class="kt">Coarbitrary</span> <span class="nf">a</span> <span class="kr">where</span>
  <span class="nf">coarbitrary</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">b</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Arbitrary</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Coarbitrary</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Arbitrary</span> <span class="p">(</span><span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">promote</span> <span class="p">(</span><span class="nf">flip</span> <span class="nf">coarbitrary</span> <span class="nf">arbitrary</span><span class="p">)</span></code></pre></div><p>好了我们有了值类型和简单函数类型的分布，还有形如a-&gt;Bool的Property，很自然可以把Property定义成Distribution Bool。但对于测试反例和覆盖率更重要，我们需要在运行时保留这些信息。一般遇到这种需要统计某类数据的情况，往往可以设计成幺半群，比如下面的Result。前面说了，有时候我们会想加前提条件或者把输入分类，这些都可以设计成幺半群，幺半群的积类型仍然是幺半群。同样利用m和m-&gt;m之间的同构，我们可以定义一些智能构造器，比如说label，classify，collect。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Result</span> <span class="ow">=</span> <span class="kt">Result</span>
  <span class="p">{</span> <span class="nf">ok</span>        <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Bool</span>
  <span class="p">,</span> <span class="nf">labels</span>    <span class="ow">::</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Int</span>
  <span class="p">,</span> <span class="nf">classes</span>   <span class="ow">::</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Int</span>
  <span class="p">,</span> <span class="nf">arguments</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
  <span class="p">,</span> <span class="nf">seed</span>      <span class="ow">::</span> <span class="kt">Int</span>
  <span class="p">,</span> <span class="nf">numTests</span>  <span class="ow">::</span> <span class="kt">Int</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
 
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Result</span> <span class="kr">where</span>
  <span class="nf">mempty</span> <span class="ow">=</span> <span class="kt">Result</span> <span class="kt">Nothing</span> <span class="kt">M</span><span class="o">.</span><span class="nf">empty</span> <span class="kt">M</span><span class="o">.</span><span class="nf">empty</span> <span class="kt">[]</span> <span class="mi">0</span> <span class="mi">0</span>
  <span class="nf">r</span><span class="o">@</span><span class="p">(</span><span class="kt">Result</span> <span class="p">(</span><span class="kt">Just</span> <span class="kt">False</span><span class="p">)</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="kr">_</span>           <span class="ow">=</span> <span class="nf">r</span>
  <span class="kr">_</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="nf">r</span><span class="o">@</span><span class="p">(</span><span class="kt">Result</span> <span class="p">(</span><span class="kt">Just</span> <span class="kt">False</span><span class="p">)</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span>           <span class="ow">=</span> <span class="nf">r</span>
  <span class="kt">Result</span> <span class="kt">Nothing</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="nf">r</span>                    <span class="ow">=</span> <span class="nf">r</span>
  <span class="nf">r</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="kt">Result</span> <span class="kt">Nothing</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span>                    <span class="ow">=</span> <span class="nf">r</span>
  <span class="kt">Result</span> <span class="kr">_</span> <span class="nf">ll</span> <span class="nf">lc</span> <span class="nf">la</span> <span class="kr">_</span> <span class="nf">ln</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="kt">Result</span> <span class="kr">_</span> <span class="nf">rl</span> <span class="nf">rc</span> <span class="nf">ra</span> <span class="kr">_</span> <span class="nf">rn</span> <span class="ow">=</span> <span class="kt">Result</span> <span class="p">(</span><span class="kt">Just</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="nf">unionWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="nf">ll</span> <span class="nf">rl</span><span class="p">)</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="nf">unionWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="nf">lc</span> <span class="nf">rc</span><span class="p">)</span> <span class="p">(</span><span class="nf">la</span> <span class="o">++</span> <span class="nf">ra</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">ln</span> <span class="o">+</span> <span class="nf">rn</span><span class="p">)</span></code></pre></div><p>接下来考虑如何shrink，shrink其实是一个函数a-&gt;[a]。QuickCheck库用的是上面提到的玫瑰树来表示，是一个递归数据类型，但以多叉树形式shrink有很多缺点，一是多叉树隐形限制了shrink的order，DFS或者BFS，很难指定其他顺序，二是同一层玫瑰树的子树可能会出现重复，lazy执行会缓解这个问题。其实不如把树拍平，直接用列表来表示，这不是我的想法，来自于Control.Applicative.Successors，我觉得特别优雅，Successor保证了每次最多只shrink一步，还可以提前剔除重复元素，而且作者手动验证了函子，合用函子和单子的公理。不过Successor也有性能缺点，(++)的右结合性意味着取第一个successor需要deconstruct整个左序列，我在想是不是可以把左右两边列表interleave在一起，类似Edward Yang在这篇文章<sup data-text="" data-url="http://web.mit.edu/~ezyang/Public/threemonads.pdf" data-draft-node="inline" data-draft-type="reference" data-numero="5">[5]</sup>提到的Logic Monad，这样既能提高性能，又能改善shrink效果，等有时间研究一下。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Succs</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Succs</span> <span class="p">{</span> <span class="nf">current</span> <span class="ow">::</span> <span class="nf">a</span><span class="p">,</span> <span class="nf">successor</span> <span class="ow">::</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Functor</span><span class="p">)</span>
 
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Succs</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="ow">=</span> <span class="nf">flip</span> <span class="kt">Succs</span> <span class="kt">[]</span>
  <span class="kt">Succs</span> <span class="nf">f</span> <span class="nf">fs</span> <span class="o">&lt;*&gt;</span> <span class="kt">Succs</span> <span class="nf">a</span> <span class="nf">as</span> <span class="ow">=</span> <span class="kt">Succs</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(((</span><span class="o">$</span> <span class="nf">a</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="nf">fs</span><span class="p">)</span> <span class="o">++</span> <span class="p">(</span><span class="nf">f</span> <span class="o">&lt;$&gt;</span> <span class="nf">as</span><span class="p">))</span>
 
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Succs</span> <span class="kr">where</span>
  <span class="nf">return</span> <span class="ow">=</span> <span class="nf">flip</span> <span class="kt">Succs</span> <span class="kt">[]</span>
  <span class="kt">Succs</span> <span class="nf">a</span> <span class="nf">as</span> <span class="o">&gt;&gt;=</span> <span class="nf">mf</span> <span class="ow">=</span> <span class="kt">Succs</span> <span class="p">(</span><span class="nf">current</span> <span class="p">(</span><span class="nf">mf</span> <span class="nf">a</span><span class="p">))</span> <span class="p">(</span><span class="nf">fmap</span> <span class="p">(</span><span class="nf">current</span> <span class="o">.</span> <span class="nf">mf</span><span class="p">)</span> <span class="nf">as</span> <span class="o">++</span> <span class="nf">successor</span> <span class="p">(</span><span class="nf">mf</span> <span class="nf">a</span><span class="p">))</span></code></pre></div><p>现在我们可以定义Property类型了，简单一点可以用Distribution (Succs Result)，这样会违反合用函子的公理，不同于之前这次我们不能简单忽略，因为Property往往是user code，如果用户自定义的话，pure f &lt;*&gt; x /= f &lt;$&gt; x会影响可复现reproducibility。另外也不直观，构造Property的时候我们丢掉许多结构信息。这里可以用我们的老朋友自由合用函子构造，这样既能保留最多信息，而且也非常清晰，Property其实包含的就是Distribution x0, Distribution x1, ..., Distribution xn，以及函数x0-&gt;x1-&gt;...-&gt;xn-&gt;Result，再加上可能的print和shrink函数。当然，前面也说了如果要利用GHC的类型推导，必须把它看作curry的形式，用Testable来抽象。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">Property</span> <span class="ow">=</span> <span class="kt">Prop</span> <span class="p">{</span> <span class="nf">runProperty</span> <span class="ow">::</span> <span class="kt">FreeA</span> <span class="kt">Distribution</span> <span class="p">(</span><span class="kt">Succs</span> <span class="kt">Result</span><span class="p">)</span> <span class="p">}</span>
 
<span class="nf">success</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Prop</span> <span class="o">.</span> <span class="nf">pure</span> <span class="o">.</span> <span class="nf">pure</span><span class="p">)</span> <span class="o">$</span> <span class="nf">mempty</span> <span class="p">{</span> <span class="nf">ok</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="kt">True</span> <span class="p">,</span> <span class="nf">numTests</span> <span class="ow">=</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nf">failure</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Prop</span> <span class="o">.</span> <span class="nf">pure</span> <span class="o">.</span> <span class="nf">pure</span><span class="p">)</span> <span class="o">$</span> <span class="nf">mempty</span> <span class="p">{</span> <span class="nf">ok</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="kt">False</span><span class="p">,</span> <span class="nf">numTests</span> <span class="ow">=</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nf">discard</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Prop</span> <span class="o">.</span> <span class="nf">pure</span> <span class="o">.</span> <span class="nf">pure</span><span class="p">)</span> <span class="o">$</span> <span class="nf">mempty</span> <span class="p">{</span> <span class="nf">ok</span> <span class="ow">=</span> <span class="kt">Nothing</span>   <span class="p">,</span> <span class="nf">numTests</span> <span class="ow">=</span> <span class="mi">1</span> <span class="p">}</span>
  
<span class="kr">class</span> <span class="kt">Testable</span> <span class="nf">a</span> <span class="kr">where</span>
  <span class="nf">property</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
 
<span class="kr">instance</span> <span class="kt">Testable</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="nf">property</span> <span class="nf">b</span> <span class="ow">=</span> <span class="kr">if</span> <span class="nf">b</span> <span class="kr">then</span> <span class="nf">success</span> <span class="kr">else</span> <span class="nf">failure</span>

<span class="nf">forAll&#39;</span> <span class="ow">::</span> <span class="kt">Testable</span> <span class="nf">b</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Succs</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
<span class="nf">forAll&#39;</span> <span class="nf">shrinker</span> <span class="nf">printer</span> <span class="nf">da</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Prop</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="nf">sa</span> <span class="ow">&lt;-</span> <span class="nf">lift</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">shrinker</span> <span class="nf">da</span><span class="p">)</span>
  <span class="nf">sg</span> <span class="ow">&lt;-</span> <span class="nf">lift</span> <span class="p">(</span><span class="nf">pure</span> <span class="o">&lt;$&gt;</span> <span class="nf">promote</span> <span class="p">(</span><span class="nf">unlift</span> <span class="o">.</span> <span class="nf">runProperty</span> <span class="o">.</span> <span class="nf">property</span><span class="p">))</span>
  <span class="nf">pure</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="nf">g</span> <span class="ow">&lt;-</span> <span class="nf">sg</span>
    <span class="p">(</span><span class="nf">b</span><span class="p">,</span> <span class="nf">arg</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">f</span> <span class="o">&amp;&amp;&amp;</span> <span class="nf">printer</span><span class="p">)</span> <span class="nf">sa</span>
    <span class="nf">logArg</span> <span class="nf">arg</span> <span class="o">&lt;$&gt;</span> <span class="nf">g</span> <span class="nf">b</span>

<span class="nf">forAll</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Arbitrary</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Testable</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
<span class="nf">forAll</span> <span class="ow">=</span> <span class="nf">forAll&#39;</span> <span class="nf">shrink</span> <span class="nf">show</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Arbitrary</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Testable</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Testable</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">property</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">forAll&#39;</span> <span class="nf">shrink</span> <span class="nf">show</span> <span class="nf">arbitrary</span> <span class="nf">f</span></code></pre></div><p>最后可以写Property的运行器和设置预设的参数，我们的quickCheck函数就大功告成了。最后我还有几点建议，QuickCheck不是万能的，里面有很多隐藏的默认设置，需要结合problem domain来调整，用默认的分布可能会直接忽略一部分可能的取值，或者产生的大部分随机值都是无效输入，这是我不建议使用(==&gt;)过滤，可以加一层newtype手动写arbitrary。另外Property的不同写法可能是同构的，但具体测试效果可能不同，比如a-&gt;b-&gt;Bool和(a,b)-&gt;Bool，我也建议结合问题手动写arbitrary。遇到要测试复杂嵌套的数据结构，写分布时还有一个技巧就是按照API抽象出状态机<sup data-text="" data-url="https://jaspervdj.be/posts/2015-03-13-practical-testing-in-haskell.html#the-action-trick" data-draft-node="inline" data-draft-type="reference" data-numero="6">[6]</sup>，比如要测试Dropbox，就可以先设计一个action类型，把常见的API-创建，删除，分享，修改等单独包装成Action，这样整个Dropbox其实就是初始状态加上Action的列表，这样写出来的分布测试时会更加有的放矢。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">sample</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">sample</span> <span class="nf">g</span> <span class="ow">=</span> <span class="nf">runDist</span> <span class="p">(</span><span class="nf">sequenceA</span> <span class="p">[</span><span class="nf">resize</span> <span class="nf">n</span> <span class="nf">g</span> <span class="o">|</span> <span class="nf">n</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]])</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">mkStdGen</span> <span class="mi">10</span><span class="p">)</span>
 
<span class="nf">quickCheck</span> <span class="ow">::</span> <span class="kt">Testable</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Result</span>
<span class="nf">quickCheck</span> <span class="nf">a</span> <span class="nf">s</span> <span class="nf">r</span> <span class="ow">=</span> <span class="nf">foldMap</span> <span class="nf">id</span> <span class="o">.</span> <span class="nf">take</span> <span class="mi">100</span> <span class="o">$</span> <span class="nf">zipWith3</span> <span class="p">(</span><span class="nf">\a</span> <span class="nf">b</span> <span class="nf">c</span> <span class="ow">-&gt;</span> <span class="nf">small</span> <span class="p">(</span><span class="nf">execProperty</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">c</span><span class="p">))</span> <span class="p">(</span><span class="nf">repeat</span> <span class="p">(</span><span class="nf">property</span> <span class="nf">a</span><span class="p">))</span> <span class="nf">sizes</span> <span class="nf">rands</span>
  <span class="kr">where</span>
    <span class="nf">sizes</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="nf">s</span><span class="o">..</span><span class="p">]</span>
    <span class="nf">rands</span> <span class="ow">=</span> <span class="nf">fst</span>  <span class="o">&lt;$&gt;</span> <span class="nf">iterate</span> <span class="p">(</span><span class="nf">split</span> <span class="o">.</span> <span class="nf">snd</span><span class="p">)</span> <span class="p">(</span><span class="nf">split</span> <span class="p">(</span><span class="nf">mkStdGen</span> <span class="nf">r</span><span class="p">))</span>
    <span class="nf">small</span> <span class="p">(</span><span class="kt">Succs</span> <span class="nf">x</span> <span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="nf">ok</span> <span class="nf">x</span> <span class="o">/=</span> <span class="kt">Just</span> <span class="kt">False</span> <span class="kr">then</span> <span class="nf">x</span> <span class="kr">else</span> <span class="nf">maybe</span> <span class="nf">x</span> <span class="nf">id</span> <span class="p">(</span><span class="nf">find</span> <span class="p">((</span><span class="o">==</span> <span class="kt">Just</span> <span class="kt">False</span><span class="p">)</span> <span class="o">.</span> <span class="nf">ok</span><span class="p">)</span> <span class="nf">xs</span><span class="p">)</span> 
 
<span class="nf">prop_rev</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">prop_rev</span> <span class="ow">=</span> <span class="nf">\xs</span> <span class="nf">ys</span> <span class="ow">-&gt;</span> <span class="nf">reverse</span> <span class="p">(</span><span class="nf">xs</span> <span class="o">++</span> <span class="nf">ys</span><span class="p">)</span> <span class="o">==</span> <span class="nf">reverse</span> <span class="nf">xs</span> <span class="o">++</span> <span class="nf">reverse</span> <span class="nf">ys</span>
 
<span class="nf">prop_gcd</span> <span class="ow">::</span> <span class="kt">Property</span>
<span class="nf">prop_gcd</span> <span class="ow">=</span> <span class="nf">forAll</span> <span class="p">(</span><span class="nf">choose</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">60</span><span class="p">))</span> <span class="o">$</span> <span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="nf">forAll</span> <span class="p">(</span><span class="nf">choose</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">60</span><span class="p">))</span> <span class="p">((</span><span class="nf">\b</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nf">b</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==&gt;</span> <span class="nf">gcd</span> <span class="nf">a</span> <span class="nf">b</span> <span class="o">/=</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Property</span><span class="p">)</span>

<span class="nf">prop_fuse</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">prop_fuse</span> <span class="ow">=</span> <span class="nf">\f</span> <span class="nf">g</span> <span class="nf">as</span> <span class="ow">-&gt;</span> <span class="nf">fmap</span> <span class="nf">g</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">as</span><span class="p">)</span> <span class="o">==</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">f</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span> <span class="nf">as</span></code></pre></div><p>附录</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">instance</span> <span class="kt">Testable</span> <span class="kt">Property</span> <span class="kr">where</span>
  <span class="nf">property</span> <span class="ow">=</span> <span class="nf">id</span>
 
<span class="nf">logSeed</span>  <span class="nf">s</span> <span class="nf">r</span> <span class="ow">=</span> <span class="nf">r</span> <span class="p">{</span> <span class="nf">seed</span> <span class="ow">=</span> <span class="nf">s</span> <span class="p">}</span>
<span class="nf">logArg</span>   <span class="nf">a</span> <span class="p">(</span><span class="kt">Result</span> <span class="nf">r</span> <span class="nf">l</span> <span class="nf">c</span> <span class="nf">as</span> <span class="nf">s</span> <span class="nf">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Result</span> <span class="nf">r</span> <span class="nf">l</span> <span class="nf">c</span> <span class="p">(</span><span class="nf">maybe</span> <span class="nf">as</span> <span class="p">(</span><span class="nf">const</span> <span class="p">(</span><span class="nf">a</span><span class="kt">:</span><span class="nf">as</span><span class="p">))</span> <span class="nf">r</span><span class="p">)</span> <span class="nf">s</span> <span class="nf">n</span>
<span class="nf">logLabel</span> <span class="nf">l</span> <span class="p">(</span><span class="kt">Result</span> <span class="nf">r</span> <span class="nf">ls</span> <span class="nf">c</span> <span class="nf">a</span> <span class="nf">s</span> <span class="nf">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Result</span> <span class="nf">r</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="nf">insertWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="nf">l</span> <span class="mi">1</span> <span class="nf">ls</span><span class="p">)</span> <span class="nf">c</span> <span class="nf">a</span> <span class="nf">s</span> <span class="nf">n</span> 
 
<span class="kr">infixr</span> <span class="mi">0</span> <span class="o">==&gt;</span>
<span class="p">(</span><span class="o">==&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Testable</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
<span class="kt">True</span>  <span class="o">==&gt;</span> <span class="nf">a</span> <span class="ow">=</span> <span class="nf">property</span> <span class="nf">a</span>
<span class="kt">False</span> <span class="o">==&gt;</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nf">discard</span>
 
<span class="nf">label</span> <span class="ow">::</span> <span class="kt">Testable</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
<span class="nf">label</span> <span class="nf">s</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Prop</span> <span class="o">$</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">logLabel</span> <span class="nf">s</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="nf">runProperty</span> <span class="p">(</span><span class="nf">property</span> <span class="nf">a</span><span class="p">))</span>
 
<span class="nf">classify</span> <span class="ow">::</span> <span class="kt">Testable</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
<span class="nf">classify</span> <span class="kt">True</span> <span class="ow">=</span> <span class="nf">label</span>
<span class="nf">classify</span> <span class="kt">False</span> <span class="ow">=</span> <span class="nf">const</span> <span class="nf">property</span>
 
<span class="nf">collect</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Testable</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
<span class="nf">collect</span> <span class="ow">=</span> <span class="nf">label</span> <span class="o">.</span> <span class="nf">show</span>

<span class="nf">execProperty</span> <span class="ow">::</span> <span class="kt">Property</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">StdGen</span> <span class="ow">-&gt;</span> <span class="kt">Succs</span> <span class="kt">Result</span>
<span class="nf">execProperty</span> <span class="nf">p</span> <span class="ow">=</span> <span class="nf">go</span> <span class="p">(</span><span class="nf">runProperty</span> <span class="nf">p</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="nf">go</span> <span class="ow">::</span> <span class="kt">FreeA</span> <span class="kt">Distribution</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">StdGen</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
    <span class="nf">go</span> <span class="p">(</span><span class="kt">NilA</span> <span class="nf">a</span><span class="p">)</span>    <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nf">a</span>
    <span class="nf">go</span> <span class="p">(</span><span class="kt">ConsA</span> <span class="nf">d</span> <span class="nf">f</span><span class="p">)</span> <span class="nf">s</span> <span class="nf">r</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="nf">r1</span><span class="p">,</span> <span class="nf">r2</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">split</span> <span class="nf">r</span> <span class="kr">in</span> <span class="p">(</span><span class="nf">go</span> <span class="nf">f</span> <span class="nf">s</span> <span class="nf">r1</span><span class="p">)</span> <span class="p">(</span><span class="nf">runDist</span> <span class="nf">d</span> <span class="nf">s</span> <span class="nf">r2</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="nb">()</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">pure</span> <span class="nb">()</span>
   
<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">chooseAny</span>
  <span class="nf">shrink</span> <span class="nf">b</span> <span class="ow">=</span> <span class="kt">Succs</span> <span class="nf">b</span> <span class="p">(</span><span class="kr">if</span> <span class="nf">b</span> <span class="kr">then</span> <span class="p">[</span><span class="kt">False</span><span class="p">]</span> <span class="kr">else</span> <span class="kt">[]</span><span class="p">)</span>
   
<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="kt">Char</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">choose</span> <span class="p">(</span><span class="sc">&#39;</span><span class="se">\0</span><span class="sc">&#39;</span><span class="p">,</span> <span class="sc">&#39;</span><span class="se">\127</span><span class="sc">&#39;</span><span class="p">)</span>
  <span class="nf">shrink</span> <span class="nf">c</span> <span class="ow">=</span> <span class="kt">Succs</span> <span class="nf">c</span> <span class="o">.</span> <span class="nf">nub</span> <span class="o">.</span> <span class="nf">filter</span> <span class="p">(`</span><span class="nf">isLT</span><span class="p">`</span> <span class="nf">c</span><span class="p">)</span> <span class="o">$</span> <span class="p">(</span><span class="nf">toLower</span> <span class="nf">c</span> <span class="kt">:</span> <span class="nf">smalls</span><span class="p">)</span>
    <span class="kr">where</span>
      <span class="nf">smalls</span> <span class="ow">=</span> <span class="s">&#34;abc123 ABC</span><span class="se">\n</span><span class="s">?&#34;</span>
      <span class="nf">isLT</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">measure</span> <span class="nf">a</span> <span class="o">&lt;</span> <span class="nf">measure</span> <span class="nf">b</span>
      <span class="nf">measure</span> <span class="nf">c</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">not</span> <span class="p">(</span><span class="nf">isLower</span> <span class="nf">c</span><span class="p">),</span> <span class="nf">not</span> <span class="p">(</span><span class="nf">isDigit</span> <span class="nf">c</span><span class="p">),</span> <span class="p">(</span><span class="nf">c</span> <span class="o">/=</span> <span class="sc">&#39; &#39;</span><span class="p">),</span> <span class="nf">not</span> <span class="p">(</span><span class="nf">isUpper</span> <span class="nf">c</span><span class="p">),</span> <span class="nf">not</span> <span class="p">(</span><span class="nf">isSpace</span> <span class="nf">c</span><span class="p">),</span> <span class="nf">not</span> <span class="p">(</span><span class="nf">c</span> <span class="p">`</span><span class="nf">elem</span><span class="p">`</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">?.&#34;</span><span class="p">),</span> <span class="nf">c</span><span class="p">)</span>
   
<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">sized</span> <span class="o">$</span> <span class="nf">\n</span> <span class="ow">-&gt;</span> <span class="nf">choose</span> <span class="p">(</span><span class="o">-</span><span class="nf">n</span><span class="p">,</span> <span class="nf">n</span><span class="p">)</span>
  <span class="nf">shrink</span> <span class="nf">n</span> <span class="ow">=</span> <span class="kt">Succs</span> <span class="nf">n</span> <span class="p">([</span><span class="nf">abs</span> <span class="nf">n</span> <span class="o">|</span> <span class="nf">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">++</span> <span class="nf">halves</span><span class="p">)</span> <span class="kr">where</span>
    <span class="nf">halves</span> <span class="ow">=</span> <span class="nf">takeWhile</span> <span class="p">(</span><span class="nf">\x</span> <span class="ow">-&gt;</span> <span class="nf">abs</span> <span class="nf">x</span> <span class="o">&lt;</span> <span class="nf">abs</span> <span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="kt">:</span><span class="p">[</span> <span class="nf">n</span> <span class="o">-</span> <span class="nf">i</span> <span class="o">|</span> <span class="nf">i</span> <span class="ow">&lt;-</span> <span class="nf">tail</span> <span class="p">(</span><span class="nf">iterate</span> <span class="p">(`</span><span class="nf">quot</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="nf">n</span><span class="p">)</span> <span class="p">])</span>
  
<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Arbitrary</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">listOf</span> <span class="nf">arbitrary</span>
  <span class="nf">shrink</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Succs</span> <span class="kt">[]</span> <span class="kt">[]</span>
  <span class="nf">shrink</span> <span class="nf">as</span> <span class="ow">=</span> <span class="kt">Succs</span> <span class="nf">as</span> <span class="p">((</span><span class="nf">flip</span> <span class="nf">take</span> <span class="nf">as</span> <span class="o">&lt;$&gt;</span> <span class="nf">ns</span><span class="p">)</span> <span class="o">++</span> <span class="nf">shrinkOne</span> <span class="nf">as</span><span class="p">)</span>
    <span class="kr">where</span>
      <span class="nf">ns</span> <span class="ow">=</span> <span class="nf">successor</span> <span class="p">(</span><span class="nf">shrink</span> <span class="p">(</span><span class="nf">length</span> <span class="nf">as</span><span class="p">))</span>
      <span class="nf">shrinkOne</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
      <span class="nf">shrinkOne</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[(</span><span class="nf">x&#39;</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="o">|</span> <span class="nf">x&#39;</span> <span class="ow">&lt;-</span> <span class="nf">successor</span> <span class="p">(</span><span class="nf">shrink</span> <span class="nf">x</span><span class="p">)]</span> <span class="o">++</span> <span class="p">[(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="nf">xs&#39;</span> <span class="ow">&lt;-</span> <span class="nf">shrinkOne</span> <span class="nf">xs</span><span class="p">]</span>
   
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Arbitrary</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Arbitrary</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Arbitrary</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span><span class="nf">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="nf">a</span> <span class="ow">&lt;-</span> <span class="nf">arbitrary</span><span class="p">;</span> <span class="nf">b</span> <span class="ow">&lt;-</span> <span class="nf">arbitrary</span><span class="p">;</span> <span class="nf">pure</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span><span class="nf">b</span><span class="p">)</span> <span class="p">}</span>
  <span class="nf">shrink</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="nf">a&#39;</span> <span class="ow">&lt;-</span> <span class="nf">shrink</span> <span class="nf">a</span><span class="p">;</span> <span class="nf">b&#39;</span> <span class="ow">&lt;-</span> <span class="nf">shrink</span> <span class="nf">b</span><span class="p">;</span> <span class="nf">pure</span> <span class="p">(</span><span class="nf">a&#39;</span><span class="p">,</span> <span class="nf">b&#39;</span><span class="p">)</span> <span class="p">}</span>  
     
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Arbitrary</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Arbitrary</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Arbitrary</span> <span class="p">(</span><span class="kt">Either</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">oneOf</span> <span class="p">[</span><span class="kt">Left</span> <span class="o">&lt;$&gt;</span> <span class="nf">arbitrary</span><span class="p">,</span> <span class="kt">Right</span> <span class="o">&lt;$&gt;</span> <span class="nf">arbitrary</span><span class="p">]</span>
  <span class="nf">shrink</span> <span class="p">(</span><span class="kt">Left</span> <span class="nf">a</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">Left</span>  <span class="o">&lt;$&gt;</span> <span class="nf">shrink</span> <span class="nf">a</span>
  <span class="nf">shrink</span> <span class="p">(</span><span class="kt">Right</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="o">&lt;$&gt;</span> <span class="nf">shrink</span> <span class="nf">a</span>  

<span class="kr">instance</span> <span class="kt">Coarbitrary</span> <span class="nb">()</span> <span class="kr">where</span>
  <span class="nf">coarbitrary</span> <span class="nf">a</span> <span class="ow">=</span> <span class="nf">id</span>
 
<span class="kr">instance</span> <span class="kt">Coarbitrary</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="nf">coarbitrary</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kr">if</span> <span class="nf">a</span> <span class="kr">then</span> <span class="nf">variant</span> <span class="mi">0</span> <span class="kr">else</span> <span class="nf">variant</span> <span class="mi">1</span>
 
<span class="kr">instance</span> <span class="kt">Coarbitrary</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="nf">coarbitrary</span> <span class="ow">=</span> <span class="nf">variant</span>

<span class="kr">instance</span> <span class="kt">Coarbitrary</span> <span class="kt">Char</span> <span class="kr">where</span>
  <span class="nf">coarbitrary</span> <span class="ow">=</span> <span class="nf">variant</span> <span class="o">.</span> <span class="nf">ord</span>
 
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Coarbitrary</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Coarbitrary</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Coarbitrary</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span> <span class="nf">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">coarbitrary</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">coarbitrary</span> <span class="nf">a</span> <span class="o">.</span> <span class="nf">coarbitrary</span> <span class="nf">b</span>
 
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Coarbitrary</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Coarbitrary</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Coarbitrary</span> <span class="p">(</span><span class="kt">Either</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">coarbitrary</span> <span class="p">(</span><span class="kt">Left</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">variant</span> <span class="mi">0</span> <span class="o">.</span> <span class="nf">coarbitrary</span> <span class="nf">a</span>
  <span class="nf">coarbitrary</span> <span class="p">(</span><span class="kt">Right</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">variant</span> <span class="mi">1</span> <span class="o">.</span> <span class="nf">coarbitrary</span> <span class="nf">b</span>
 
<span class="kr">instance</span> <span class="kt">Coarbitrary</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Coarbitrary</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="kr">where</span>
  <span class="nf">coarbitrary</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="nf">variant</span> <span class="mi">0</span>
  <span class="nf">coarbitrary</span> <span class="p">(</span><span class="nf">a</span><span class="kt">:</span><span class="nf">as</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">variant</span> <span class="mi">1</span> <span class="o">.</span> <span class="nf">coarbitrary</span> <span class="nf">a</span> <span class="o">.</span> <span class="nf">coarbitrary</span> <span class="nf">as</span>
  
<span class="kr">data</span> <span class="kt">FreeA</span> <span class="nf">f</span> <span class="nf">a</span> <span class="kr">where</span>
  <span class="kt">NilA</span>  <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">FreeA</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="kt">ConsA</span> <span class="ow">::</span> <span class="nf">f</span> <span class="nf">x</span> <span class="ow">-&gt;</span> <span class="kt">FreeA</span> <span class="nf">f</span> <span class="p">(</span><span class="nf">x</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">FreeA</span> <span class="nf">f</span> <span class="nf">a</span>
 
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">FreeA</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">fmap</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">NilA</span> <span class="nf">a</span><span class="p">)</span>    <span class="ow">=</span> <span class="kt">NilA</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span>
  <span class="nf">fmap</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">ConsA</span> <span class="nf">x</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">ConsA</span> <span class="nf">x</span> <span class="p">((</span><span class="nf">f</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="nf">g</span><span class="p">)</span>
 
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">FreeA</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">NilA</span>
  <span class="p">(</span><span class="kt">NilA</span> <span class="nf">f</span><span class="p">)</span>     <span class="o">&lt;*&gt;</span> <span class="nf">ga</span> <span class="ow">=</span> <span class="nf">f</span> <span class="o">&lt;$&gt;</span> <span class="nf">ga</span>
  <span class="p">(</span><span class="kt">ConsA</span> <span class="nf">x</span> <span class="nf">gf</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="nf">ga</span> <span class="ow">=</span> <span class="kt">ConsA</span> <span class="nf">x</span> <span class="o">$</span> <span class="kr">do</span> <span class="p">{</span> <span class="nf">f</span> <span class="ow">&lt;-</span> <span class="nf">gf</span><span class="p">;</span> <span class="nf">a</span> <span class="ow">&lt;-</span> <span class="nf">ga</span><span class="p">;</span> <span class="nf">pure</span> <span class="p">(</span><span class="nf">flip</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="p">}</span>
 
<span class="kr">type</span> <span class="kt">NatF</span> <span class="nf">f</span> <span class="nf">g</span> <span class="ow">=</span> <span class="nf">forall</span> <span class="nf">a</span><span class="o">.</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">g</span> <span class="nf">a</span> <span class="c1">-- f, g must be Functor</span>
<span class="kr">type</span> <span class="kt">NatA</span> <span class="nf">f</span> <span class="nf">g</span> <span class="ow">=</span> <span class="nf">forall</span> <span class="nf">a</span><span class="o">.</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">g</span> <span class="nf">a</span> <span class="c1">-- f, g must be Applicative</span>
 
<span class="nf">hoist</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="nf">f</span><span class="p">,</span> <span class="kt">Applicative</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">NatF</span> <span class="nf">f</span> <span class="nf">g</span> <span class="ow">-&gt;</span> <span class="kt">NatA</span> <span class="p">(</span><span class="kt">FreeA</span> <span class="nf">f</span><span class="p">)</span> <span class="nf">g</span>
<span class="nf">hoist</span> <span class="nf">t</span> <span class="p">(</span><span class="kt">NilA</span> <span class="nf">a</span><span class="p">)</span>    <span class="ow">=</span> <span class="nf">pure</span> <span class="nf">a</span>
<span class="nf">hoist</span> <span class="nf">t</span> <span class="p">(</span><span class="kt">ConsA</span> <span class="nf">x</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">hoist</span> <span class="nf">t</span> <span class="nf">g</span> <span class="o">&lt;*&gt;</span> <span class="nf">t</span> <span class="nf">x</span>

<span class="nf">lower</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="nf">f</span><span class="p">,</span> <span class="kt">Applicative</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">NatA</span> <span class="p">(</span><span class="kt">FreeA</span> <span class="nf">f</span><span class="p">)</span> <span class="nf">g</span> <span class="ow">-&gt;</span> <span class="kt">NatF</span> <span class="nf">f</span> <span class="nf">g</span>
<span class="nf">lower</span> <span class="nf">t</span> <span class="ow">=</span> <span class="nf">t</span> <span class="o">.</span> <span class="nf">flip</span> <span class="kt">ConsA</span> <span class="p">(</span><span class="nf">pure</span> <span class="nf">id</span><span class="p">)</span>
 
<span class="nf">lift</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">FreeA</span> <span class="nf">f</span> <span class="nf">a</span>
<span class="nf">lift</span> <span class="ow">=</span> <span class="nf">lower</span> <span class="nf">id</span>
 
<span class="nf">unlift</span> <span class="ow">::</span> <span class="kt">Applicative</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">FreeA</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">a</span>
<span class="nf">unlift</span> <span class="ow">=</span> <span class="nf">hoist</span> <span class="nf">id</span></code></pre></div><p></p>