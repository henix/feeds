<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>递归函数（四）：全函数与计算的可终止性</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34425726">原文</a></p>
<h2><b>回顾</b></h2><img src="https://pic1.zhimg.com/v2-9488c88c2a5273ccfd75c83a424585ca_r.jpg" data-caption="" data-size="normal" data-rawwidth="300" data-rawheight="300"><p>上文我们讨论了集合上的关系，还讨论了数学归纳法的一种普遍形式，称为良基归纳法，<br>它建立在集合上的良基关系之上。</p><p>本文开始讨论函数，我们将回顾函数的定义，<br>然后解释什么是全函数（total function），什么是部分函数（partial function）。</p><p>我们会看到，在证明一个递归函数是全函数时，<br>良基归纳法起到了重要作用。</p><p>在分析学中，人们似乎很少关心函数的完全性，<br>只关心它的连续性，可导性，可微性与可积性，等等。<br>而在计算机科学领域中，人们更在意计算的可终止性，<br>因此一个函数在某个点是否有定义将经常被提及。</p><p>程序中定义的函数，往往对应于某个集合上的数学函数，<br>为了描述程序的非终止性，就得扩充这个数学函数的定义域和值域。<br>为了理解这些事情，我们先要从函数的定义开始。</p><h2><b>函数</b></h2><p>集合 <equation>A,B</equation> 上的关系，是笛卡尔积 <equation>A\times B</equation> 的一个子集。</p><p>而<b>函数</b> <equation>f:A\rightarrow B</equation> ，则是集合 <equation>A,B</equation> 上的一种特殊关系，<br>它要求 <equation>A</equation> 中的每一个元素，都有 <equation>B</equation> 中<b>唯一确定的</b>元素与之对应。<br>其中，集合 <equation>A</equation> 称为函数 <equation>f</equation> 的<b>定义域</b>，集合 <equation>B</equation> 称为函数的<b>值域</b>。</p><p>函数是我们熟悉的概念，这里只是提到了它本质上是集合上的一个关系。</p><p><b>（1）部分函数（partial function）</b></p><img src="https://pic1.zhimg.com/v2-874ea6c6827de852cd55a96727978878_r.jpg" data-caption="" data-size="normal" data-rawwidth="200" data-rawheight="200"><p>如果 <equation>f</equation> 是从 <equation>A</equation> 到 <equation>B</equation> 的二元关系，且 <equation>\forall a\in A</equation> ， <equation>f(a)=\varnothing</equation> 或 <equation>\lbrace b\rbrace</equation> ，<br>则称 <equation>f</equation> 是从 <equation>A</equation> 到 <equation>B</equation> 的<b>部分函数</b>，或 <equation>A</equation> 上的部分函数。</p><p>其中，如果 <equation>f(a)=\lbrace b\rbrace</equation> ，则称 <equation>f(a)</equation> <b>有定义</b>，记为 <equation>f(a)\downarrow</equation> ，<br>也称 <equation>b</equation> 为 <equation>f</equation> 在 <equation>a</equation> 点的函数值，记为 <equation>f(a)=b</equation> 。<br>如果 <equation>f(a)=\varnothing</equation> ，则称 <equation>f(a)</equation><b> 无定义</b>，记为 <equation>f(a)\uparrow</equation> 。</p><p><b>（2）全函数（total function）</b></p><img src="https://pic4.zhimg.com/v2-98cba4b9c4f902aab70190f355394426_r.jpg" data-caption="" data-size="normal" data-rawwidth="200" data-rawheight="200"><p>如果 <equation>\forall a\in A</equation> 都有 <equation>f(a)\downarrow</equation> ，则称 <equation>f</equation> 是 <equation>A</equation> 上的全函数，<br>此时，可以记为 <equation>f:A\rightarrow B</equation> 。</p><p>可见，我们熟悉的函数，指的是全函数。<br>值得注意的是，部分函数的定义已经包含了我们学过的“函数”的定义，<br>后文中，我们提到的“函数”如果不强调它的完全性的话，都泛指部分函数。</p><h2><b>非终止性</b></h2><p>部分函数在计算机科学中是非常重要的，<br>因为对于每一个 <equation>a\in A</equation> ，一个算法可以表示为，计算出集合 <equation>B</equation> 中与之对应元素的过程，<br>这个算法可能对于某些值 <equation>a\in A</equation> 不会终止，而这种情况是很常见的。</p><p>例如：</p><code lang="haskell">f :: Int -&gt; Int
f 1 = 1
f n = n + f(n-2)</code><p>这样定义的函数<code class="inline">f</code>，对应了数学上的一个部分函数 <equation>f</equation> ，它只在某些情况下有意义，<br>只有当<code class="inline">n</code>是奇数时，我们才能得到终止性的结果。<br>而当<code class="inline">n</code>是偶数时，算法会无限的递归下去，直到堆栈溢出。</p><p>因此，将<code class="inline">Int</code>解释为整数集 <equation>N</equation> ，将<code class="inline">f :: Int -&gt; Int</code>解释为整数集上的函数，<br>似乎是有问题的，因为， <equation>f(2)</equation> 并不是一个整数，它的计算不能终止。</p><p>为了描述非终止性，就需要对整数集进行扩充，<br>我们给整数集加上一个特殊元素“ <equation>\perp</equation> ”，称为<b>bottom</b>，来表示非终止性，<br>而将<code class="inline">f :: Int -&gt; Int</code>解释为集合 <equation>N\cup \lbrace \perp \rbrace</equation> 上的一个数学函数。</p><p>像这种通过构造表达程序含义的数学对象，来对程序进行分析的方法，来自<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E7%A7%B0%E8%AF%AD%E4%B9%89">指称语义学</a>。</p><p>指称语义中，人们会区分函数的严格性，一个函数称为<b>严格的</b>（strict），<br>如果接受一个非终止的输入表达式，函数的计算仍然不会终止，即， <equation>f(\perp )=\perp</equation> 。<br>否则，称函数为<b>不严格的</b>（non-strict）。</p><h2><b>原始递归函数</b></h2><img src="https://pic2.zhimg.com/v2-fcac4612d17b9df75820b2d778789687_r.jpg" data-caption="" data-size="normal" data-rawwidth="271" data-rawheight="186"><p>我们看到在程序中使用递归，可能会导致非终止性的计算，而有些递归又不会。<br>这是为什么呢？</p><p>我们可以从递归函数论中找到一些线索。<br>递归函数论是和图灵机以及 <equation>\lambda</equation> 演算相等价的计算模型，它从另一个角度刻画了可计算性。<br>可计算性是一个有趣的话题，后续文章中，我们会详细讨论。</p><p>在递归函数论中，人们把函数划分为了3个层次，<br>原始递归函数，递归函数，和其他的不能用递归函数表示的“函数”。<br>这些函数集合的范围越来越大。</p><p>本文我们先介绍原始递归函数，<br>为此，我们需要先定义两种运算。</p><p><b>（1）合成运算</b></p><p>设 <equation>f</equation> 是 <equation>k</equation> 元部分函数， <equation>g_1,g_2,\cdots ,g_k</equation> 是 <equation>k</equation> 个 <equation>n</equation> 元部分函数，令，<br> <equation>h(x_1,\cdots ,x_n)=f(g_1(x_1,\cdots ,x_n),\cdots ,g_k(x_1,\cdots ,x_n))</equation> <br>则称 <equation>h</equation> 是由 <equation>f</equation> 和 <equation>g_1,g_2,\cdots ,g_k</equation> ，经过<b>合成运算</b>得到的。</p><p><b>（2）原始递归运算</b></p><p>设 <equation>f</equation> 是一个 <equation>n</equation> 元全函数， <equation>g</equation> 是 <equation>n+2</equation> 元全函数，令，<br> <equation>h(x_1,\cdots ,x_n,0)=f(x_1,\cdots ,x_n)</equation> <br> <equation>h(x_1,\cdots ,x_n,t+1)=g(t,h(x_1,\cdots ,x_n,t),x_1,\cdots ,x_n)</equation> <br>则称 <equation>h</equation> 是由 <equation>f</equation> 和 <equation>g</equation> 经过<b>原始递归运算</b>得到的。</p><p>于是，我们就可以定义原始递归函数了。</p><p>设<b>初始函数</b>包括，<br>（1）零函数 <equation>n(x)=0</equation> <br>（2）后继函数 <equation>s(x)=x+1</equation> <br>（3）投影函数 <equation>u^n_i(x_1,\cdots ,x_n)=x_i</equation> ， <equation>1\leqslant i\leqslant n</equation> <br>则由初始函数经过有限次合成运算和原始递归运算得到的函数，称为<b>原始递归函数</b>。</p><p>原始递归函数有以下这些性质：<br>由原始递归函数经过合成或原始递归得到的函数仍为原始递归函数，<br>因此，原始递归函数的集合在合成与原始递归运算下是封闭的。</p><p>此外，每一个原始递归函数都是全函数。<br>这是因为合成运算虽然是在部分函数上定义的，<br>但是如果 <equation>f</equation> 和 <equation>g_1,g_2,\cdots ,g_k</equation> 是全函数，那么 <equation>h</equation> 也一定是全函数。</p><p>另一方面，在进行原始递归运算时，如果 <equation>f</equation> 和 <equation>g</equation> 是全函数，则 <equation>h</equation> 也一定是全函数，<br>这是因为原始递归运算在 <equation>h</equation> 的参数集上的定义了一个良基关系，<br>由良基归纳法可证， <equation>h</equation> 是全函数。</p><h2><b>总结</b></h2><img src="https://pic3.zhimg.com/v2-a3866f274319c289a42997f7331f9611_r.jpg" data-caption="" data-size="normal" data-rawwidth="259" data-rawheight="246"><p>本文介绍了全函数与部分函数，以及计算可终止性相关的概念，<br>我们对程序中函数的指称，进行了定义域和值域的扩充，<br>随后，我们进一步了解了原始递归函数，以及它的完全性，良基归纳法起到了关键作用。</p><p>下文，我们将深入到可计算性理论，<br>讨论部分可计算函数和可计算函数的区别，讨论递归函数与原始递归函数的关系，<br>引出递归可枚举集这个重要的概念。</p><hr><h2><b>参考</b></h2><p><a href="https://en.wikipedia.org/wiki/Function_(mathematics)">function (mathematics)</a><br><a href="https://en.wikipedia.org/wiki/Strict_function">strict function</a><br><a href="https://book.douban.com/subject/1310925/">可计算性与计算复杂性导引</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
