<div class="title-image"><img src="https://pic1.zhimg.com/v2-a75cee57514e0e1ff05764d05e41fb01_b.jpg" alt=""></div><p>题图: <a href="https://link.zhihu.com/?target=http%3A//new-universe.org/zenphoto/albums/Chapter2/Illustrations/Abrams22.jpg" class=" wrap external" target="_blank" rel="nofollow noreferrer">The Cosmic Uroboros</a>，类似图示亦见于赵凯华《新概念物理教程》。</p><h2>{-# Update #-}</h2><p>简单翻阅了VivadoⓇHLS的文档片段。Cλash/Chisel等所谓「硬件描述语言」仍是完全在RTL层面进行设计，与所谓HLS并无多少关系，这一点需要特别说明。同时笔者为自身在相关领域的无知以及所缺少的敬畏表示抱歉。</p><p>感谢 <a class="member_mention" href="https://www.zhihu.com/people/510c8b17a63363f80da934ff7af10cea" data-hash="510c8b17a63363f80da934ff7af10cea" data-hovercard="p$b$510c8b17a63363f80da934ff7af10cea">@dram</a> 的指出。</p><hr/><h2>鸟瞰</h2><p>这篇文章简要介绍了使用<a href="https://link.zhihu.com/?target=https%3A//clash-lang.org/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Cλash</a>这一基于<code>Haskell</code>的硬件描述语言编写数字电路的基本过程，并用其编写了一个<b>仅用作演示</b>的简陋的多周期CPU的主要部分。</p><p>本文大量参考了<code>Cλash</code>官网列出的<a href="https://link.zhihu.com/?target=http%3A//yager.io/CPU/CPU1.html/" class=" wrap external" target="_blank" rel="nofollow noreferrer">这篇教程</a>。文章仅以此浅谈个人使用过程中的一点感受，更多参考材料可参阅官方给出的<a href="https://link.zhihu.com/?target=https%3A//clash-lang.org/documentation/" class=" wrap external" target="_blank" rel="nofollow noreferrer">列表</a>。请随意指出本文当中的任何错误或不当之处，代码链接位于文末。</p><h2>秘术：Cλash是什么</h2><p><code>Cλash</code>是一门基于<code>Haskell</code>的硬件描述语言，可被编译到可综合的<code>VHDL</code>、<code>Verilog</code>和<code>SystemVerilog</code>代码。其于2009年起开发于荷兰的University of Twente，在献祭了一票Master和PhD后于2019年9月发布了其1.0.0版本，目前由商业公司<a href="https://link.zhihu.com/?target=https%3A//qbaylogic.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">QBayLogic</a>及社区开发维护，目前看上去其还处于日渐活跃的开发阶段（之前很长时间甚至没有完善的安装指南）。值得一提的是，另一与之相似的、基于<code>Scala</code>的硬件描述语言<code>Chisel</code>亦在蓬勃发展，或许是由于深度学习硬件快速发展的刺激？（所以请不要再批评炼丹师了……</p><p><code>Cλash</code>本身是对<code>Haskell</code>的魔改，写代码时不妨就将其当作<code>Haskell</code>的一个库来用。它的编译器<code>clash</code>也是基于<code>GHC</code>的，因此你也可以猜到，它同样有一个基于<code>GHCi</code>的REPL程序<code>clashi</code>。总而言之，<code>Haskell</code>用家应当是写起来比较爽的，尤其是强类型、紧凑的ADT、REPL环境以及各种别的七七八八的小东西都比直接写<code>Verilog</code>舒服一些。</p><p>考虑到空谈并不能给人带来直观的感受，这里借我本学期某次计算机体系课的作业来简单说明。这个小玩具是一个在Xilinx Kintex FPGA板上实现的、非常简陋的MIPS指令集多周期CPU，当然并没有Cache之类的东西，它就是一条条读指令然后执行，它真的只是玩具而已……</p><h2>环境配置</h2><p>按照官方给出的<a href="https://link.zhihu.com/?target=https%3A//clash-lang.org/install/" class=" wrap external" target="_blank" rel="nofollow noreferrer">配置指南</a>即可。我因为懒就直接下载二进制包：</p><div class="highlight"><pre><code class="language-bash">$ snap install clash</code></pre></div><p>安装完成后就可以试一试了：</p><div class="highlight"><pre><code class="language-abap">$ clash --version
Clash, version 1.0.0 (using clash-lib, version: 1.0.0)

$ clash.clashi
Clashi, version 1.0.0 (using clash-lib, version 1.0.0):
http://www.clash-lang.org/  :? for help
Clash.Prelude&gt;</code></pre></div><p>很漂亮。一般我们在<code>clashi</code>里各种玩耍就够了，<code>GHCi</code>里<code>:t</code>和<code>:i</code>之类的东西都可以用，<code>:?</code>可以看到详细的列表。</p><h2>施法：从零开始</h2><p>我们尝试按照「设计思考」而非「文档形式」的顺序进行叙述，因此之后内容可能出现「回溯」和「纠结」的一些体现。</p><h3>类型：从硬件到抽象</h3><p>每个<code>Haskell</code>用家都对类型有特殊的亲切感和敏感度，所以我们首先就来看一下<code>Cλash</code>提供的、我们会用到的类型们。它们当中的大部分都因为十分常用而被放在了<code>Clash.Prelude</code>中。</p><p><code>Cλash</code>提供了数字电路中最常用的定长数字，它们可以在<code>Clash.Sized</code>中找到。我们统一用无符号数<code>Unsigned</code>来承担整个系统当中的信号传递，例如<code>Verilog</code>当中的</p><div class="highlight"><pre><code class="language-verilog"><span class="k">module</span> <span class="n">xxx</span><span class="p">(</span>
    <span class="p">...</span>
    <span class="k">input</span> <span class="n">SW</span><span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">],</span>
    <span class="p">...</span>
<span class="p">)</span>
</code></pre></div><p>就可以用</p><div class="highlight"><pre><code class="language-haskell"><span class="kt">SW</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">5</span></code></pre></div><p>来描述。特别地，32位寄存器和RAM当中的数据都是<code>Unsigned 32</code>类型，这也包括指令。</p><p>很多时候，我们需要精确地操作这些数的二进制位，这可以用<code>BitVector</code>来描述，像是<code>0101 :: BitVector 4</code>。它的一些操作以及与<code>Unsigned</code>之间的转换如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="p">(</span><span class="o">++#</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">KnownNat</span> <span class="nf">m</span> <span class="ow">=&gt;</span> <span class="kt">BitVector</span> <span class="nf">n</span> <span class="ow">-&gt;</span> <span class="kt">BitVector</span> <span class="nf">m</span> <span class="ow">-&gt;</span> <span class="kt">BitVector</span> <span class="p">(</span><span class="nf">n</span> <span class="o">+</span> <span class="nf">m</span><span class="p">)</span>

<span class="nf">slice</span>
<span class="ow">::</span> <span class="p">(</span><span class="kt">BitPack</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">BitSize</span> <span class="nf">a</span> <span class="o">~</span> <span class="p">((</span><span class="nf">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">i</span><span class="p">))</span> <span class="ow">=&gt;</span>
<span class="kt">SNat</span> <span class="nf">m</span> <span class="ow">-&gt;</span> <span class="kt">SNat</span> <span class="nf">n</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">BitVector</span> <span class="p">((</span><span class="nf">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="nf">n</span><span class="p">)</span>

<span class="nf">pack</span> <span class="ow">::</span> <span class="kt">BitPack</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">BitVector</span> <span class="p">(</span><span class="kt">BitSize</span> <span class="nf">a</span><span class="p">)</span>
<span class="nf">unpack</span> <span class="ow">::</span> <span class="kt">BitPack</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">BitVector</span> <span class="p">(</span><span class="kt">BitSize</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="c1">-- e.g.</span>
<span class="c1">-- pack   (114 :: Unsigned 8) == (0111_0010 :: BitVector 8)</span>
<span class="c1">-- unpack (10_0000_0010 :: BitVector 10) == (514 :: Unsigned 10)</span></code></pre></div><p>这里的<code>(++#)</code>就是<code>BitVector</code>的<code>(++)</code>；而<code>slice</code>则将一个<code>BitVector</code>截出我们想要的部分，它依次接收高位位置、低位位置和原数，其中位置是采用<code>SNat n</code>这样的类型来描述，就像</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">d19</span> <span class="ow">::</span> <span class="kt">SNat</span> <span class="mi">19</span>
<span class="c1">-- e.g.</span>
<span class="c1">-- slice d4 d2 (pack (114 :: Unsigned 8)) == (100 :: BitVector 3)</span></code></pre></div><p>假装有了dependent type（笑），这在debug的过程中是很有帮助的。</p><h3>状态：从抽象到更加抽象</h3><p>我们想要实现的功能很简单：从「内存」读取指令，「CPU」解析这条指令并对寄存器和内存做一些读读写写的事情，然后继续读取指令，周而复始。考虑到这是一个多周期CPU，我们还需要把CPU的状态划分为几个不同的阶段，并需要一些额外的寄存器保存之前计算得到的值。因此，这个系统的状态无非是以下几部分内容：</p><ul><li>CPU的当前阶段</li><li>程序计数器(PC)的当前值</li><li>CPU中各个通用寄存器的值</li><li>额外引入的中间状态寄存器的值</li><li>RAM的内容</li></ul><p>仅此而已，现在我们来分别设计它们。</p><h3>CPU阶段</h3><p>CPU对一条指令的执行被人为划分为5个阶段，不同种类的指令所经历的阶段也不尽相同。由于这里的重点并不是体系结构，我们直接引用Patterson, D. A.和Hennessy, J. L.的《计算机组成与设计：硬件、软件接口（第三版）》当中的内容：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-60868f0a7585e79d2a703200d1b5a07a_b.jpg" data-caption="" data-size="normal" data-rawwidth="955" data-rawheight="361" class="origin_image zh-lightbox-thumb" width="955" data-original="https://pic3.zhimg.com/v2-60868f0a7585e79d2a703200d1b5a07a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-60868f0a7585e79d2a703200d1b5a07a_b.jpg" data-caption="" data-size="normal" data-rawwidth="955" data-rawheight="361" class="origin_image zh-lightbox-thumb lazy" width="955" data-original="https://pic3.zhimg.com/v2-60868f0a7585e79d2a703200d1b5a07a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-60868f0a7585e79d2a703200d1b5a07a_b.jpg"/></figure><p>这可以被描述为</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">CPUActivity</span> <span class="ow">=</span> <span class="kt">InstFetch</span> <span class="o">|</span> <span class="kt">InstDecode</span> <span class="o">|</span> <span class="kt">Execute</span> <span class="o">|</span> <span class="kt">MemProcess</span> <span class="o">|</span> <span class="kt">FinishReadMem</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">NFDataX</span> <span class="kt">CPUActivity</span> <span class="kr">where</span>
<span class="nf">rnfX</span> <span class="o">!</span><span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span></code></pre></div><p>这里<code>Generic</code>和<code>NFDataX</code>是生成电路的需要，我们采取最简单的实现即可，这需要打开<code>BangPatterns</code>扩展。</p><p>自然地，指令的类型被描述为</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">OpType</span> <span class="ow">=</span> <span class="kt">RType</span> <span class="o">|</span> <span class="kt">BranchType</span> <span class="o">|</span> <span class="kt">JumpType</span> <span class="o">|</span> <span class="kt">ReadMemType</span> <span class="o">|</span> <span class="kt">WriteMemType</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span></code></pre></div><p>我们顺便实现决定一条指令类型的函数，这是由MIPS指令集的指令格式控制的：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">decodeOp</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span> <span class="ow">-&gt;</span> <span class="kt">OpType</span>
<span class="nf">decodeOp</span> <span class="nf">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="nf">opPart</span> <span class="kr">of</span>
    <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">RType</span>
    <span class="mi">2</span> <span class="ow">-&gt;</span> <span class="kt">JumpType</span>
    <span class="mi">4</span> <span class="ow">-&gt;</span> <span class="kt">BranchType</span>
    <span class="mi">35</span> <span class="ow">-&gt;</span> <span class="kt">ReadMemType</span>
    <span class="mi">43</span> <span class="ow">-&gt;</span> <span class="kt">WriteMemType</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">&#34;Unimplemented instruction(Op error)&#34;</span>
    <span class="kr">where</span>
        <span class="nf">opPart</span> <span class="ow">::</span> <span class="kt">BitVector</span> <span class="mi">6</span>
        <span class="nf">opPart</span> <span class="ow">=</span> <span class="nf">slice</span> <span class="nf">d31</span> <span class="nf">d26</span> <span class="p">(</span><span class="nf">pack</span> <span class="nf">x</span><span class="p">)</span></code></pre></div><h3>程序计数器</h3><p>程序计数器(PC)的内容不过是一个32位数，但我们将它与普通数据稍作区分：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">Ptr</span> <span class="ow">=</span> <span class="kt">Ptr</span> <span class="p">(</span><span class="kt">Unsigned</span> <span class="mi">32</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">NFDataX</span> <span class="kt">Ptr</span> <span class="kr">where</span>
<span class="nf">rnfX</span> <span class="o">!</span><span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="nf">getPtrContents</span> <span class="ow">::</span> <span class="kt">Ptr</span> <span class="ow">-&gt;</span> <span class="kt">Unsigned</span> <span class="mi">32</span>
<span class="nf">getPtrContents</span> <span class="p">(</span><span class="kt">Ptr</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">x</span></code></pre></div><p>与MIPS指令集略有不同，我们完全采用字地址进行表示，这就意味着PC的更新应当是</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">increment</span> <span class="ow">::</span> <span class="kt">Ptr</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span>
<span class="nf">increment</span> <span class="p">(</span><span class="kt">Ptr</span> <span class="nf">addr</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Ptr</span> <span class="p">(</span><span class="nf">addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></code></pre></div><p>而不是<code>(+ 4)</code>。</p><h3>通用寄存器</h3><p>32个通用寄存器和PC直接列出，我们略去一些重复的部分：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Register</span> <span class="ow">=</span> <span class="kt">R0</span>  <span class="o">|</span> <span class="kt">R1</span>  <span class="o">|</span> <span class="kt">R2</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="kt">R31</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Registers</span> <span class="ow">=</span> <span class="kt">Registers</span> <span class="p">{</span>
    <span class="nf">r0</span>  <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span><span class="p">,</span>
    <span class="nf">r1</span>  <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="nf">r31</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span><span class="p">,</span>
    <span class="nf">pc</span> <span class="ow">::</span> <span class="kt">Ptr</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">NFDataX</span> <span class="kt">Registers</span> <span class="kr">where</span>
<span class="nf">rnfX</span> <span class="o">!</span><span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span></code></pre></div><h3>中间寄存器</h3><p>多周期的处理方式要求我们保存几个中间计算结果：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">TempRegs</span> <span class="ow">=</span> <span class="kt">TempRegs</span> <span class="p">{</span>
    <span class="nf">ir</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span><span class="p">,</span>
    <span class="nf">mdr</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span><span class="p">,</span>
    <span class="nf">ra</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span><span class="p">,</span>
    <span class="nf">rb</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span><span class="p">,</span>
    <span class="nf">aluout</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span>
<span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">NFDataX</span> <span class="kt">TempRegs</span> <span class="kr">where</span>
<span class="nf">rnfX</span> <span class="o">!</span><span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span></code></pre></div><h3>RAM</h3><p>RAM存储指令和数据。尽管<code>Cλash</code>可以生成专用的RAM模型，在最简单的实现中不妨只用最简单的数组来模拟它，我们将它定为容量为64个字：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">RAM</span> <span class="ow">=</span> <span class="kt">RAM</span> <span class="p">(</span><span class="kt">Vec</span> <span class="mi">64</span> <span class="p">(</span><span class="kt">Unsigned</span> <span class="mi">32</span><span class="p">))</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">NFDataX</span> <span class="kt">RAM</span> <span class="kr">where</span>
<span class="nf">rnfX</span> <span class="o">!</span><span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span></code></pre></div><p>对RAM和寄存器的读写无非是获取和更新当中的内容，我们对此不再赘述，读者可以查看源代码。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">readRegister</span> <span class="ow">::</span> <span class="kt">Registers</span> <span class="ow">-&gt;</span> <span class="kt">Register</span> <span class="ow">-&gt;</span> <span class="kt">Unsigned</span> <span class="mi">32</span>
<span class="nf">writeRegister</span> <span class="ow">::</span> <span class="kt">Registers</span> <span class="ow">-&gt;</span> <span class="kt">Register</span> <span class="ow">-&gt;</span> <span class="kt">Unsigned</span> <span class="mi">32</span> <span class="ow">-&gt;</span> <span class="kt">Registers</span>
<span class="nf">readRAM</span> <span class="ow">::</span> <span class="kt">RAM</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="ow">-&gt;</span> <span class="kt">Unsigned</span> <span class="mi">32</span>
<span class="nf">writeRAM</span> <span class="ow">::</span> <span class="kt">RAM</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="ow">-&gt;</span> <span class="kt">Unsigned</span> <span class="mi">32</span> <span class="ow">-&gt;</span> <span class="kt">RAM</span></code></pre></div><h3>小结</h3><p>让我们从繁复的细节中探出头来呼吸一口新鲜空气，再回想当初的目标——描述这个系统的状态。现在我们可以着手做这件事了，事实上这不过是以上部分的组合：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">CPUState</span> <span class="ow">=</span> <span class="kt">CPUState</span> <span class="kt">CPUActivity</span> <span class="kt">Registers</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">NFDataX</span> <span class="kt">CPUState</span> <span class="kr">where</span>
<span class="nf">rnfX</span> <span class="o">!</span><span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="kr">type</span> <span class="kt">SystemState</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">CPUState</span><span class="p">,</span> <span class="kt">RAM</span><span class="p">,</span> <span class="kt">TempRegs</span><span class="p">)</span></code></pre></div><p>仅此而已！环顾四周，这个<code>SystemState</code>是不是已经完整描述了这个系统？</p><h3>时序：从抽象到硬件</h3><p>如何描述一个时序电路？我们还记得一个叫做Mealy模型的东西，或者我们至少还记得「寄存器」这件事，这就足够了。它们无非说了同一件事，由一个旧状态和输入值得到新的状态和输出值，周而复始：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">cpuHardWare</span> <span class="ow">::</span> <span class="kt">OldState</span> <span class="ow">-&gt;</span> <span class="kt">Input</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">NewState</span><span class="p">,</span> <span class="kt">Output</span><span class="p">)</span></code></pre></div><p>各位<code>Haskell</code>用家一定不会对此感到陌生 :)</p><p>我们似乎看到了将看似抽象的描述落到硬件上的可能性，现在来着手考虑上面这个函数的实现。最复杂的「状态」的描述已经分析清楚，接下来考虑这里的输入和输出是什么东西。回想硬件课上拨来拨去的开关、闪闪发亮的LED灯和数码管，我们意识到输入和输出完全可以按照我们的心情和板上的硬件来选择——只要我们能把想对机器说的话传达到，并接受机器的心意就好了。那么为了简便，我们把输入定为一个5位的数字，代表我们想要了解的寄存器编号；输出则是一个8位数，代表寄存器内容的低8位（为什么不把32位都打出来？因为我不想碰数码管，而最简单的LED灯只有8个 :) ）。</p><p>之前实现的<code>SystemState</code>类型可以描述系统的状态，我们想要的函数现在长这样：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">cpuHardware</span> <span class="ow">::</span> <span class="kt">SystemState</span> <span class="ow">-&gt;</span> <span class="kt">Unsigned</span> <span class="mi">5</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">SystemState</span><span class="p">,</span> <span class="kt">Unsigned</span> <span class="mi">8</span><span class="p">)</span></code></pre></div><p>又近了一步！</p><p>什么？我们还什么都没有做？对也不对，毕竟我们对CPU是如何从一个阶段变化到下一个阶段的还没有任何描述，然而这并没有什么难度，现在就来考虑它。我们喜欢纯函数，这里的输入输出看上去有些不舒服，我们尝试把它分离出来。</p><p>事实上，<code>SystemState</code>就已经完整描述了系统的所有信息，这里的输入输出不过是把某些信息从这个状态中提取出来。这启发我们可以写一个这样的函数，这里的<code>decodeReg</code>把二进制数解析到对应号码的寄存器：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">getOutput</span> <span class="ow">::</span> <span class="kt">Input</span> <span class="ow">-&gt;</span> <span class="kt">SystemState</span> <span class="ow">-&gt;</span> <span class="kt">Output</span>
<span class="nf">getOutput</span> <span class="nf">n</span> <span class="p">(</span><span class="kt">CPUState</span> <span class="kr">_</span> <span class="nf">regs</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">unpack</span> <span class="o">$</span> <span class="nf">slice</span> <span class="nf">d7</span> <span class="nf">d0</span> <span class="p">(</span><span class="nf">pack</span> <span class="p">(</span><span class="nf">readRegister</span> <span class="nf">regs</span> <span class="nf">reg</span><span class="p">))</span>
    <span class="kr">where</span> <span class="nf">reg</span> <span class="ow">=</span> <span class="nf">decodeReg</span> <span class="o">$</span> <span class="nf">pack</span> <span class="nf">n</span></code></pre></div><p>现在我们在考虑各阶段转移的时候就无需考虑输入输出的事情了，于是现在的需求变成了这样：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">cycle</span> <span class="ow">::</span> <span class="kt">SystemState</span> <span class="ow">-&gt;</span> <span class="kt">SystemState</span></code></pre></div><p>纯函数，非常舒服。有当前阶段、RAM、寄存器和PC信息，我们发挥体系结构的相关内容不难把下一个阶段的系统状态找出来。看似最困难的地方三言两语就解决了（当然，实现起来还是最复杂的），感兴趣的读者可以查看源代码。</p><p>现在可以着手组装这台机器了。我们最终想要的函数不难写成：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">cpuHardware</span> <span class="ow">::</span> <span class="kt">SystemState</span> <span class="ow">-&gt;</span> <span class="kt">Unsigned</span> <span class="mi">5</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">SystemState</span><span class="p">,</span> <span class="kt">Unsigned</span> <span class="mi">8</span><span class="p">)</span>
<span class="nf">cpuHardware</span> <span class="nf">oldState</span> <span class="nf">input</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">newState</span><span class="p">,</span> <span class="nf">getOutput</span> <span class="nf">newState</span><span class="p">)</span>
    <span class="kr">where</span> <span class="nf">newState</span> <span class="ow">=</span> <span class="nf">cycle</span> <span class="nf">oldState</span></code></pre></div><p>非常漂亮。现在我们只要给这台巨大的「寄存器」一个初值，它便能一直运行下去。当然，我们并没有实现可编程的RAM，所以想要运行的程序是预先硬编码在这个初值里的，但作为玩具，这已经足够了，后面我们可以为它增加更多功能。</p><p><code>Cλash</code>为我们提供了内置的Mealy模型，它可以由一个「状态转移」函数和一个初始值生成对应的硬件描述。我们只需要简单的一行代码：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">device</span> <span class="ow">=</span> <span class="nf">mealy</span> <span class="nf">cpuHardware</span> <span class="nf">initSystemState</span></code></pre></div><p>其中<code>initSystemState</code>描述了系统的初始状态，包括寄存器、PC和RAM内容——当然也包括要执行的「代码」片段，我们会在后文简单说明，读者可以查看源代码。</p><p>终于迎来了最后一步！我们要把这个巨大的「机器」导出到可综合的<code>Verilog</code>模块。Cλash要求所导出的顶层模块函数名为<code>topEntity</code>，其中可以自行决定要不要暴露<code>clk</code>、<code>rst</code>和<code>en</code>等接口，这里选择使用<code>exposeClockResetEnable</code>将它们都暴露出来：</p><div class="highlight"><pre><code class="language-haskell"><span class="cm">{-# ANN topEntity
</span><span class="cm">    (Synthesize
</span><span class="cm">    { t_name   = &#34;SimpleMCPU&#34;
</span><span class="cm">    , t_inputs = [PortName &#34;clk&#34;, PortName &#34;rst&#34;, PortName &#34;en&#34;, PortName &#34;SW&#34;]
</span><span class="cm">    , t_output = PortName &#34;ALED&#34;
</span><span class="cm">    })　#-}</span>

<span class="nf">topEntity</span>
<span class="ow">::</span> <span class="kt">Clock</span> <span class="kt">System</span>
<span class="ow">-&gt;</span> <span class="kt">Reset</span> <span class="kt">System</span>
<span class="ow">-&gt;</span> <span class="kt">Enable</span> <span class="kt">System</span>
<span class="ow">-&gt;</span> <span class="kt">Signal</span> <span class="kt">System</span> <span class="p">(</span><span class="kt">Unsigned</span> <span class="mi">5</span><span class="p">)</span>
<span class="ow">-&gt;</span> <span class="kt">Signal</span> <span class="kt">System</span> <span class="p">(</span><span class="kt">Unsigned</span> <span class="mi">8</span><span class="p">)</span>
<span class="nf">topEntity</span> <span class="ow">=</span> <span class="nf">exposeClockResetEnable</span> <span class="nf">device</span></code></pre></div><p>那坨奇怪的注解是什么？它被称为「综合注解」，顾名思义，它控制了综合过程中所生成的硬件描述代码的一些行为，例如上面我们就控制了所生成模块以及各个接口的名称（否则会出现<code>c$case_alt</code>这种奇奇怪怪的名字，使得引脚约束写起来十分不爽），更加详细的内容可以参考官方文档。</p><p>结束了！在<code>clashi</code>中利用<code>:l foo.hs</code>导入这个文件，随后用<code>:verilog</code>命令即可编译到可综合的<code>Verilog</code>模块。在Xilinx Vivado之类的工具中导入模块，并自行编写引脚约束文件（显然，这种高度基于特定硬件的内容是不可能自动生成的），这时候就可以综合、生成<code>.bit</code>文件并烧录到板子了！</p><h2>一些注解</h2><p>现在我们对一些可能碰到的问题进行讨论。首先，如何为生成的硬件编程？由于我们采用了最简单的 RAM 实现方式，所有的指令和数据需要预先硬编码到初始状态当中。同时我们也没有为二进制指令作方便使用的抽象，因此我们目前需要用汇编器将汇编代码汇编到二进制，然后写入 RAM 的初始状态中。简单的示例是这样的：</p><div class="highlight"><pre><code class="language-nasm"><span class="nf">add</span> <span class="kc">$</span><span class="nv">t0</span><span class="p">,</span> <span class="kc">$</span><span class="nv">t0</span><span class="p">,</span> <span class="kc">$</span><span class="nv">t1</span>
<span class="nf">add</span> <span class="kc">$</span><span class="nv">t0</span><span class="p">,</span> <span class="kc">$</span><span class="nv">t0</span><span class="p">,</span> <span class="kc">$</span><span class="nv">t1</span>
<span class="nf">...</span>
<span class="nf">add</span> <span class="kc">$</span><span class="nv">t0</span><span class="p">,</span> <span class="kc">$</span><span class="nv">zero</span><span class="p">,</span> <span class="kc">$</span><span class="nv">zero</span>
<span class="nf">j</span> <span class="mh">0x0</span></code></pre></div><p>初始寄存器除<code>$t1</code>外都设为<code>0</code>,我们应当可以观察到<code>$t0</code>这个寄存器内容逐次累加又清零的过程，相关代码类似：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">initSystemState</span> <span class="ow">::</span> <span class="kt">SystemState</span>
<span class="nf">initSystemState</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">CPUState</span> <span class="nf">initActivity</span> <span class="nf">initRegs</span><span class="p">,</span> <span class="nf">initRAM</span><span class="p">,</span> <span class="nf">initTempRegs</span><span class="p">)</span>
    <span class="kr">where</span> <span class="nf">initActivity</span> <span class="ow">=</span> <span class="kt">InstFetch</span>
        <span class="nf">initRegs</span> <span class="ow">=</span> <span class="kt">Registers</span> <span class="p">{</span> <span class="nf">r0</span>  <span class="ow">=</span> <span class="mi">0</span>
                             <span class="p">,</span> <span class="nf">r1</span>  <span class="ow">=</span> <span class="mi">0</span>
                               <span class="o">...</span>
                             <span class="p">,</span> <span class="nf">r8</span>  <span class="ow">=</span> <span class="mi">0</span> <span class="c1">-- $t0</span>
                             <span class="p">,</span> <span class="nf">r9</span>  <span class="ow">=</span> <span class="mi">1</span> <span class="c1">-- $t1</span>
                             <span class="p">,</span> <span class="nf">r10</span> <span class="ow">=</span> <span class="mi">0</span>
                               <span class="o">...</span>
                             <span class="p">,</span> <span class="nf">r31</span> <span class="ow">=</span> <span class="mi">0</span>
                             <span class="p">,</span> <span class="nf">pc</span>  <span class="ow">=</span> <span class="kt">Ptr</span> <span class="mi">0</span>
                         <span class="p">}</span>
    <span class="nf">initTempRegs</span> <span class="ow">=</span> <span class="kt">TempRegs</span> <span class="p">{</span> <span class="nf">ir</span>  <span class="ow">=</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="p">,</span> <span class="nf">mdr</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="p">,</span> <span class="nf">ra</span>  <span class="ow">=</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="p">,</span> <span class="nf">rb</span>  <span class="ow">=</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="p">,</span> <span class="nf">aluout</span> <span class="ow">=</span> <span class="mi">0</span>
                        <span class="p">}</span>
    <span class="nf">initRAM</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">a</span> <span class="ow">=</span> <span class="mh">0x01094020</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span> <span class="c1">-- add $t0, $t0, $t1</span>
                  <span class="nf">r</span> <span class="ow">=</span> <span class="mh">0x00004020</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span> <span class="c1">-- add $t0, $zero, $zero</span>
                  <span class="nf">j</span> <span class="ow">=</span> <span class="mh">0x08000000</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span> <span class="c1">-- j 0x0</span>
              <span class="kr">in</span> <span class="kt">RAM</span> <span class="p">(</span><span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span>
                      <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span>
                      <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span>
                      <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span>
                      <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span>
                      <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span>
                      <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span>
                      <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">a</span> <span class="kt">:&gt;</span> <span class="nf">r</span> <span class="kt">:&gt;</span> <span class="nf">j</span> <span class="kt">:&gt;</span> <span class="kt">Nil</span><span class="p">)</span></code></pre></div><p>虽不漂亮，但作为示例已经足够。</p><p>此外，使用编译出的<code>Verilog</code>模块时，可能需要编写一些辅助模块。比如我所使用的开发板提供的是<code>clk200P</code>和<code>clk200N</code>两个differential clock而不是我们想要的<code>clk</code>，这就需要我们自己写一个小的时钟转换模块。需要指出，与直接修改生成的代码相比，更好的做法可能是编写一个「最终」的顶层模块，然后将生成的模块和其他辅助部分用到里面，这样也便于对<code>Cλash</code>代码修改后快速部署到硬件。由于这是课程作业，我不确定是否应当把最终调整过的Vivado项目放上来，不过感兴趣的话，读者应该不难自行编写后其烧录到自己特定的开发板上。</p><h2>总结：Ouroboros</h2><p>经过了与Cλash的亲密接触，我们可以回到最初的起点，想一想「为什么要用它」这个问题了。首先，我们在整个设计实现过程中几乎没有考虑「连线」这件事，而是更多从高一些的层次上进行把握 —— 系统的整体逻辑是怎样的，状态是怎样的，输入输出是怎样与系统结合的……写完上面的小玩具，我们脑中清晰地呈现了它从整体到细节的结构蓝图，这一点在我编写<code>Verilog</code>的过程中是不容易获得的，至少没有那么清晰和直观。</p><p>第二，得益于<code>Haskell</code>的各种设施加成，我们实际上获得了不少便利。「类型」贯穿了我们的实现全过程，它实际上解决了可能遇到的大部分bug，这一点与软件开发是一致的；REPL环境与<code>Haskell</code>「分离纯与非纯部分」哲学一起大大加速了实现过程，我们不必在实现完一个模块后去仿真观察实现逻辑是否有问题，而是可以<code>:r</code>进REPL环境进行调试，非时序的模块自不必说，时序的模块我们也有<code>Signal</code>之类的抽象来借助<code>simulate</code>等函数来调试。抛开调试效率和准确性不谈，这个过程显然是比来回写仿真代码给人的感受舒服一些；另外高阶函数之类的「自然而然被使用」的东西也无形中增添了不少便利，就像从R-型指令中提取功能 —— 也就是决定它是加还是减，还是什么其他的算术运算 —— 的时候，我们可以直接写</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">decodeFunct</span> <span class="ow">::</span> <span class="kt">Unsigned</span> <span class="mi">32</span> <span class="ow">-&gt;</span> <span class="kt">Unsigned</span> <span class="mi">32</span> <span class="ow">-&gt;</span> <span class="kt">Unsigned</span> <span class="mi">32</span> <span class="ow">-&gt;</span> <span class="kt">Unsigned</span> <span class="mi">32</span>
<span class="nf">decodeFunct</span> <span class="nf">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="nf">slice</span> <span class="nf">d5</span> <span class="nf">d0</span> <span class="p">(</span><span class="nf">pack</span> <span class="nf">x</span><span class="p">)</span> <span class="kr">of</span>
    <span class="mi">32</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
    <span class="mi">34</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span>
    <span class="mi">36</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">and</span><span class="o">#</span><span class="p">)</span>
    <span class="mi">37</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">or</span><span class="o">#</span><span class="p">)</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">&#34;Unimplemented instruction(Funct error)&#34;</span></code></pre></div><p>直接返回<code>(+)</code>这样的函数，非常自然且舒服；紧凑的ADT形式也天然地适合硬件描述，相信看了上面对系统状态的表达就会有所感受（当然这可能也与个人口味有关）。总而言之，它让编写硬件代码的过程变得「舒服」了一些。</p><p>第三，抛开工业界应用的可能性不谈，我个人认为这样「高抽象」的描述方式是十分符合教学目的的。以我个人修读本科硬件课程的体验来说，这些课程在完成教学要求的同时常常（不得已地）被混入了太多的「杂质」，例如绘制繁复的连线、处理无意引入又难以查出的接口问题，以及将太多精力放在与特定硬件相关的输入输出当中……而这些本不是课程想要达到的最重要的目的，尤其是在较为初级的课程当中。而基于抽象程度较高的语言进行设计实现，我们「被迫」去思考系统的整体结构和逻辑、分析设计当中较为「本质」的东西，避免了沦为「对着ppt连线」和「对着书本写完了各个模块却不知道它们做了什么」这样的问题，至少在我看来是有一定帮助的。然而大部分本科生并不熟悉<code>Haskell</code>或<code>Scala</code>这类语言，只怕语言本身会成为新的、巨大的杂质……</p><p>当然，我们也看到其作为硬件描述的缺点。像是老生常谈的生成代码可读性极低且体积很大、硬件效率不如手写等问题依旧存在，且短期内很难有可观的改善；另外虽然称为「高抽象层次」的语言，其实际上仍旧是在写硬件代码，难以称得上High Level Synthesis，硬件的概念依然需要时刻装在脑中，理论上我们写的东西都可以用Verilog行为描述完整地实现出来 —— 并没有什么本质上的不同；限于硬件与软件根本上的不同，<code>Haskell</code>的设施也并非全部都可以应用到当中来，官方文档对此也有相关的讨论。</p><p>总之，我们依然十分欣喜地看到这一「抽象」的创新，据说也已有商业公司将其应用了实际生产中（QbayLogic本身，以及好像有个做deep learning accelerator的？但是我找不到了QwQ（Update：<a href="https://link.zhihu.com/?target=https%3A//myrtle.ai/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Myrtle.AI</a>））。抛开「有没有用」不谈，<code>Cλash</code>与<code>Chisel</code>它们确确实实地在把 「用高抽象的方式描述硬件」这个想法推向越来越远。从手工连线，到EDA工具的出现，再到HLS技术的蓬勃发展、高抽象语言的应用……我们看到了人类一步步的创造过程。从硬件到抽象，从抽象到更加抽象，再从抽象回到硬件。这一「衔尾蛇 (Ouroboros)」模式无疑是美而神秘的，这也是题图和标题的来源。</p><p>代码位于<a href="https://link.zhihu.com/?target=https%3A//github.com/Commelina/LaMCPU" class=" wrap external" target="_blank" rel="nofollow noreferrer">GitHub</a>。</p><p></p>