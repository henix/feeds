<div class="title-image"><img src="https://pic4.zhimg.com/v2-836b76d7336dd4773fa26f12a252efdd_b.jpg" alt=""></div><h2>前言 </h2><p>近日NSA向微软公布了一个基于ECC加密的漏洞(CVE-2020-0601)，该漏洞出现于Windows CryptoAPI(Crypt32.dll)做签名验证的部分，该漏洞可能导致严重的威胁。我对此十分好奇，于是学习了ECC相关的知识，在这里和大家分享一下。</p><h2><b>ECC原理介绍</b></h2><p>首先我们来学习一下ECC(椭圆曲线加密)的原理。ECC全称为“Ellipse Curve Ctyptography”，是一种基于椭圆曲线数学的公开密钥加密算法。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。与传统的基于大质数分解难题的加密算法不同，该加密方式基于 “<b>离散对数</b>” 这种数学难题。该算法的主要优势是可以使用更小的密钥病提供相当高等级的安全。ECC164位的密钥产生一个安全级，相当于RSA 1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国居民二代身份证正在使用 256 位的椭圆曲线密码，虚拟货币比特币也选择ECC作为加密算法。</p><p class="ztext-empty-paragraph"><br/></p><p><b>一、数学基础</b></p><blockquote>以下内容我们小学二年级就学过，带领大家复习一下</blockquote><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-237a786b91d53bd1ce9e86559caad35c_b.jpg" data-caption="" data-size="normal" data-rawwidth="400" data-rawheight="364" class="content_image" width="400"/></noscript><img src="https://pic1.zhimg.com/v2-237a786b91d53bd1ce9e86559caad35c_b.jpg" data-caption="" data-size="normal" data-rawwidth="400" data-rawheight="364" class="content_image lazy" width="400" data-actualsrc="https://pic1.zhimg.com/v2-237a786b91d53bd1ce9e86559caad35c_b.jpg"/></figure><p>首先我们来介绍一下<b>射影</b>。传统的几何几何系统中，我们可以在《几何原本》中照到如下定理：</p><ul><li>由任意一点到任意一点可作直线。</li><li>一条有限线段可以无限延长</li><li>凡直角皆相等</li><li>三角形内角和为180度</li><li>同一平面内一条直线a和另外两条直线b.c相交，若在a某一侧的两个内角的和小于两直角，则b.c两直线经无限延长后在该侧相交</li></ul><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-b7661474115d211f3773840bc6792a90_b.jpg" data-caption="" data-size="normal" data-rawwidth="677" data-rawheight="449" class="origin_image zh-lightbox-thumb" width="677" data-original="https://pic1.zhimg.com/v2-b7661474115d211f3773840bc6792a90_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-b7661474115d211f3773840bc6792a90_b.jpg" data-caption="" data-size="normal" data-rawwidth="677" data-rawheight="449" class="origin_image zh-lightbox-thumb lazy" width="677" data-original="https://pic1.zhimg.com/v2-b7661474115d211f3773840bc6792a90_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-b7661474115d211f3773840bc6792a90_b.jpg"/></figure><p>以上内容属于欧式几何，然后又一些大佬觉得欧几里得说的不对，他们觉得第五条定理不能作为公理，而且三角形的内角和也不是180度。所以，有些强者就建立了新的几何体系，比如，俄国的罗巴切夫斯基提出“至少可以找到两条相异的直线，且都通过P点，并不与直线R相交”代替第五公设，然后与欧氏几何的四个公设结合成一个公理系统，简称“罗氏几何(双曲几何)”。黎曼大佬也插了一脚，他觉得“找不到一条直线可以通过P点，并且不与直线R相交”，于是建立了黎曼几何(椭圆几何).数学就是这样神奇，只要你能自圆其说，满足自洽性，你也能建立自己的体系。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-491efabee3c81a637a20cd77fa35f220_b.jpg" data-caption="" data-size="normal" data-rawwidth="400" data-rawheight="101" class="content_image" width="400"/></noscript><img src="https://pic1.zhimg.com/v2-491efabee3c81a637a20cd77fa35f220_b.jpg" data-caption="" data-size="normal" data-rawwidth="400" data-rawheight="101" class="content_image lazy" width="400" data-actualsrc="https://pic1.zhimg.com/v2-491efabee3c81a637a20cd77fa35f220_b.jpg"/></figure><p>我们把上面的两种几何体系称之为非欧几何。定义平行线相交于无穷远点P∞，使平面上所有直线都统一为有唯一的交点，那么：</p><ul><li>一条直线只有一个无穷远点；一对平行线有公共的无穷远点</li><li>任何两条直线有不同的无穷远点</li><li>平面上的无穷远点构成的集合组成一条无穷远直线</li></ul><blockquote><b>射影平面</b>可被认为是个具有额外的“<b>无穷远点</b>”之一般平面，平行线会于该点相交。因此，在射影平面上的两条线会相交于一个且仅一个点。</blockquote><p><b>（一）椭圆曲线</b></p><p><b>椭圆曲线</b>就是在射影平面上满足魏尔斯特拉斯方程(Weierstrass)的点构成曲线。对于有限域上的椭圆曲线，一般我们用如下方程定义：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-c130a730c465dc4dc6e558dc7fc3d4d5_b.png" data-caption="" data-size="normal" data-rawwidth="154" data-rawheight="34" class="content_image" width="154"/></noscript><img src="https://pic2.zhimg.com/v2-c130a730c465dc4dc6e558dc7fc3d4d5_b.png" data-caption="" data-size="normal" data-rawwidth="154" data-rawheight="34" class="content_image lazy" width="154" data-actualsrc="https://pic2.zhimg.com/v2-c130a730c465dc4dc6e558dc7fc3d4d5_b.png"/></figure><p>其图像一般如下：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-51cd8a743fbbfcaf1216b692327fbf9a_b.jpg" data-caption="" data-size="normal" data-rawwidth="360" data-rawheight="195" class="content_image" width="360"/></noscript><img src="https://pic3.zhimg.com/v2-51cd8a743fbbfcaf1216b692327fbf9a_b.jpg" data-caption="" data-size="normal" data-rawwidth="360" data-rawheight="195" class="content_image lazy" width="360" data-actualsrc="https://pic3.zhimg.com/v2-51cd8a743fbbfcaf1216b692327fbf9a_b.jpg"/></figure><p>椭圆曲线的定义也要求曲线是非奇异的(即处处可导的)。几何上来说，这意味着图像里面没有尖 点、自相交或孤立点。代数上来说，这成立当且仅当判别式: <br/> </p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-5870451c5fac936a0b0ee861c07e9701_b.png" data-caption="" data-size="normal" data-rawwidth="194" data-rawheight="34" class="content_image" width="194"/></noscript><img src="https://pic2.zhimg.com/v2-5870451c5fac936a0b0ee861c07e9701_b.png" data-caption="" data-size="normal" data-rawwidth="194" data-rawheight="34" class="content_image lazy" width="194" data-actualsrc="https://pic2.zhimg.com/v2-5870451c5fac936a0b0ee861c07e9701_b.png"/></figure><p>不为0.这里主要是满足其可导性。</p><p><b>（二）近世代数</b></p><p>群</p><p>群（group）是由一种集合以及一个二元运算所组成的，并且符合“群公理”。群公理包含下述四个性质的代数结构。这四个性质是：</p><ul><li>封闭性：对于所有G中a, b，运算a·b的结果也在G中。</li><li>结合律：对于所有G中的a, b和c，等式 `(a·b)·c = a·(b·c)`成立。</li><li>单位元：存在G中的一个元素e，使得对于所有G中的元素a，总有等式`e·a = a·e = a`成立。</li><li>对于集合中所有元素存在逆元素</li></ul><p><b>特殊的群：</b></p><p>    满足交换律的群称为<b>交换群</b>（阿贝尔群），不满足交换律的群称为非交换群（非阿贝尔群）。</p><p>    设 (G, · )为一个群，若存在一G内的元素g，使得</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-02ad22bec46f50e9928ef922a2f1bcd7_b.png" data-caption="" data-size="normal" data-rawwidth="211" data-rawheight="32" class="content_image" width="211"/></noscript><img src="https://pic4.zhimg.com/v2-02ad22bec46f50e9928ef922a2f1bcd7_b.png" data-caption="" data-size="normal" data-rawwidth="211" data-rawheight="32" class="content_image lazy" width="211" data-actualsrc="https://pic4.zhimg.com/v2-02ad22bec46f50e9928ef922a2f1bcd7_b.png"/></figure><p>则称G关于运算“ · ”形成一个<b>循环群</b>。</p><p>元素的<b>阶</b>(order)：</p><p>一个群内的一个元素a之阶（有时称为周期）是指会使得am = e的最小正整数m（其中的e为这个群的单位元素，且am为a的m次幂）。若没有此数存在，则称a有无限阶。有限群的所有元素有有限阶。</p><p>一个群G的阶被标记为ord(G)或|G|,他表示群内元素的个数，而一个元素的阶则标记为ord(a)或|a|。</p><p><b>有限域</b></p><p>&amp;emsp;&amp;emsp;在数学中，有限域（finite field）或伽罗瓦域（Galois field，为纪念埃瓦里斯特·伽罗瓦命名）是包含有限个元素的域。与其他域一样，有限域是进行加减乘除运算都有定义并且满足特定规则的集合。有限域最常见的例子是当 p 为素数时，整数对 p 取模。有限域的元素个数称为它的阶(order)。可以看出域是满足更多运算的群。</p><p>这里我们规定一个有限域Fp</p><ul><li>取大质数p，则有限域中有p-1个有限元：0，1，2...p-1</li><li>Fp上的加法为模p加法`a+b≡c(mod p)`</li><li>Fp上的乘法为模p乘法`a×b≡c(mod p)`</li><li>Fp上的除法就是乘除数的乘法逆元`a÷b≡c(mod p)`，即 `a×b^(-1)≡c (mod p)`</li><li>Fp的乘法单位元为1，零元为0</li><li>Fp域上满足交换律，结合律，分配律</li></ul><p>在这个域上我们希望使用椭圆曲线构造加密函数，但是考虑到曲线本身是连续的，不适合做加密，因此我们得想办法在椭圆曲线上构造一种离散的运算。这是我们可以构造一个阿贝尔群：</p><p>给定曲线</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-10bc4913a141c3a5a8444b7e87069b7c_b.png" data-caption="" data-size="normal" data-rawwidth="150" data-rawheight="39" class="content_image" width="150"/></noscript><img src="https://pic1.zhimg.com/v2-10bc4913a141c3a5a8444b7e87069b7c_b.png" data-caption="" data-size="normal" data-rawwidth="150" data-rawheight="39" class="content_image lazy" width="150" data-actualsrc="https://pic1.zhimg.com/v2-10bc4913a141c3a5a8444b7e87069b7c_b.png"/></figure><p>P，Q为曲线上的点，我们规定加法：</p><p>实P + Q = R是曲线上点的加法运算，任意取椭圆曲线上两点P、Q（若P、Q两点重合，则作P点的切线），作直线交于椭圆曲线的另一点R&#39;，过R&#39;做y轴的平行线交于R，定义P+Q=R。这样，加法的和也在椭圆曲线上，并同样具备加法的交换律、结合律:</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-36ef558b5f3572354ae5f3d0c2f603d9_b.jpg" data-caption="" data-size="normal" data-rawwidth="497" data-rawheight="415" class="origin_image zh-lightbox-thumb" width="497" data-original="https://pic2.zhimg.com/v2-36ef558b5f3572354ae5f3d0c2f603d9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-36ef558b5f3572354ae5f3d0c2f603d9_b.jpg" data-caption="" data-size="normal" data-rawwidth="497" data-rawheight="415" class="origin_image zh-lightbox-thumb lazy" width="497" data-original="https://pic2.zhimg.com/v2-36ef558b5f3572354ae5f3d0c2f603d9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-36ef558b5f3572354ae5f3d0c2f603d9_b.jpg"/></figure><p>若P与Q点重合，则求P的切线交曲线的另一点为R‘。若有k个相同的点P相加，如3P = P + P + P</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-18e3bda910608ecc8127eb3b11f72068_b.jpg" data-caption="" data-size="normal" data-rawwidth="281" data-rawheight="291" class="content_image" width="281"/></noscript><img src="https://pic1.zhimg.com/v2-18e3bda910608ecc8127eb3b11f72068_b.jpg" data-caption="" data-size="normal" data-rawwidth="281" data-rawheight="291" class="content_image lazy" width="281" data-actualsrc="https://pic1.zhimg.com/v2-18e3bda910608ecc8127eb3b11f72068_b.jpg"/></figure><p>下面我们利用小学二年级就学过的微积分的知识求一下相关方程：</p><ul><li>无穷远点 O∞是零元，有O∞+ O∞= O∞，O∞+P=P</li><li>P(x,y)的负元是 (x,-y mod p)= (x,p-y) ，有P+(-P)= O∞</li><li>P(x1,y1),Q(x2,y2)的和R(x3,y3) 有如下关系：</li></ul><div class="highlight"><pre><code class="language-python"><span class="n">x3</span><span class="err">≡</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)(</span><span class="n">mod</span> <span class="n">p</span><span class="p">)</span>
<span class="n">y3</span><span class="err">≡</span><span class="p">(</span><span class="n">k</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x3</span><span class="p">)</span><span class="o">-</span><span class="n">y1</span><span class="p">)(</span><span class="n">mod</span> <span class="n">p</span><span class="p">)</span>
<span class="err">这里对等式两边求全微分，即可求出</span><span class="n">k</span> <span class="o">=</span> <span class="n">dy</span><span class="o">/</span><span class="n">dx</span>
<span class="err">若</span><span class="n">P</span><span class="o">=</span><span class="n">Q</span> <span class="err">则</span> <span class="n">k</span><span class="o">=</span><span class="p">((</span><span class="mi">3</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="n">y1</span><span class="p">)</span><span class="n">mod</span> <span class="n">p</span>
<span class="err">这里</span><span class="n">PQ为不同的点</span><span class="err">，直接计算斜率</span>
<span class="err">若</span><span class="n">P</span><span class="err">≠</span><span class="n">Q</span><span class="err">，则</span><span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span> <span class="n">mod</span> <span class="n">p</span></code></pre></div><p>若kP = O ∞ ，那么k就是点P的阶(order)</p><blockquote>这个就是上面群里元素的阶的定义</blockquote><p>上面这个椭圆曲线上点的加法运算，就构成了一个阿贝尔群，数学基础到此结束。</p><p class="ztext-empty-paragraph"><br/></p><p><b>二、ElGamal离散对数密码体制</b></p><p>我们来介绍一下基于离散对数的加密算法，首先密钥与公钥的生成步骤如下：</p><p><b>（一）公钥密钥生成：</b></p><p>1. Alice首先构造一条椭圆曲线E，在曲线上选择一点G作为生成元，并求G的阶为n，要求n必须为质数。此时构成了一个循环群\&lt;G&gt;。</p><p>2. Alice选择一个私钥k (k &lt; n),生成公钥 Q = kG</p><p>3. Alice将公钥组E、Q、G发送给Bob</p><p><b>（二）加密过程</b></p><p>1、Bob收到信息后，将明纹编码为M，M为曲线上一点，并选择一个随机数r（r &lt; n, n为G的阶）</p><p>2、Bob计算点Cipher1与Cipher2即两段密文，计算方法如下</p><ul><li>Cipher1 = M + rQ</li><li>Cipher2 = rG</li></ul><p>3、Bob把Cipher1和Cipher2发给Alice</p><p><b>（三） 解密过程</b></p><p>1、Alice收到密文后，为了获得M，只需要Cipher1 - k · Cipher2,因为</p><div class="highlight"><pre><code class="language-python"><span class="n">Cipher1</span> <span class="o">-</span> <span class="n">k</span><span class="o">*</span><span class="n">Cipher2</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">rQ</span> <span class="o">-</span> <span class="n">krG</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">rkG</span> <span class="o">-</span> <span class="n">krG</span> <span class="o">=</span> <span class="n">M</span></code></pre></div><p>2、将M解码即可</p><p><b>（四）技术要求</b></p><p>在选择参数时有一下要求：</p><ul><li>大质数p越大安全性越好，但是速度会降低，200位左右可以满足一般安全要求</li><li>n应为质数</li><li>椭圆曲线上所有点的个数m与n相除的商的整数部分为h，h≤4；p≠n×h ；pt≠1(mod n) (1≤t＜20)</li><li>满足椭圆曲线的判别式</li></ul><p><b>（五）代码实现</b></p><p>接下来我们用python写个简单的demo加深一下理解。</p><p>解释一下几个基本函数：</p><p>这个函数是扩展欧几里得算法，就是我们常说的辗转相除法求出最大公因数后反向带入的过程，返回最大公因数a和满足</p><div class="highlight"><pre><code class="language-text">sa + tb = gcd(a,b)</code></pre></div><p>(这是贝祖等式)的s0和t0。gcd(a, b)函数的功能是求a，b的最大公因数。</p><div class="highlight"><pre><code class="language-python"><span class="c1"># Extended GCD</span>
<span class="k">def</span> <span class="nf">egcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span>
        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s0</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">s1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t0</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">t1</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">s0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">a</span></code></pre></div><p>inv()这个函数实现了求乘法逆元的功能，使用扩展欧几里得算法。</p><div class="highlight"><pre><code class="language-python"><span class="c1"># Get invert element</span>
<span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="c1"># div on ç a/b mod q as a * inv(b, q) mod q</span>
    <span class="c1"># n*inv % q = 1 =&gt; n*inv = q*m + 1 =&gt; n*inv + q*-m = 1</span>
    <span class="c1"># =&gt; egcd(n, q) = (inv, -m, 1) =&gt; inv = egcd(n, q)[0] (mod q)</span>
    <span class="k">return</span> <span class="n">egcd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">q</span></code></pre></div><p>sqrt()这个函数实现了开平方的算法，需要注意的是这里的乘法运算是有限域上的模乘，因此采用试根的方式。q - i 与 i 构成一对相反数。</p><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="c1"># sqrt on PN module: returns two numbers or exception if not exist</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">q</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">%</span> <span class="n">q</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">q</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">pass</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&#34;not found&#34;</span><span class="p">)</span></code></pre></div><p>下面我们构造椭圆曲线类EC：</p><ul><li>构造函数中a，b为EC的参数，p为模p有限域的大质数</li><li>`is_valid(self, p)`判断点p是否在曲线上</li><li>`at(self, x)`，求出党x为横坐标是对应的y值</li><li>`neg(self, p)`,求关于x轴对称的点</li><li>`add(self, p1, p2)`，求点p1，p2在椭圆曲线上的加法</li><li>`mul(self, p, n)`，把p点累加n次</li><li>`order(self, g)`，求g点的阶</li></ul><div class="highlight"><pre><code class="language-python"><span class="c1"># System of Elliptic Curve</span>
<span class="k">class</span> <span class="nc">EC</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="c1"># elliptic curve as: (y**2 = x**3 + a * x + b) mod q</span>
    <span class="c1"># - a, b: params of curve formula</span>
    <span class="c1"># - p: prime number</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">27</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">%</span> <span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="c1"># just as unique ZERO value representation for &#34;add&#34;: (not on curve)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zero</span> <span class="o">=</span> <span class="n">Coord</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">pass</span>

    <span class="c1"># Judge if the coordinate in the curve</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="k">return</span> <span class="n">l</span> <span class="o">==</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># find points on curve at x</span>
        <span class="c1"># - x: int &lt; p</span>
        <span class="c1"># - returns: ((x, y), (x,-y)) or not found exception</span>

        <span class="k">assert</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">ysq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">my</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">ysq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Coord</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">Coord</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">my</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">neg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="c1"># negate p</span>
        <span class="k">return</span> <span class="n">Coord</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># 1.无穷远点 O∞是零元，有O∞+ O∞= O∞，O∞+P=P</span>
    <span class="c1"># 2.P(x,y)的负元是 (x,-y mod p)= (x,p-y) ，有P+(-P)= O∞</span>
    <span class="c1"># 3.P(x1,y1),Q(x2,y2)的和R(x3,y3) 有如下关系：</span>
    <span class="c1"># x3≡k**2-x1-x2(mod p)</span>
    <span class="c1"># y3≡k(x1-x3)-y1(mod p)</span>
    <span class="c1"># 若P=Q 则 k=(3x2+a)/2y1mod p</span>
    <span class="c1"># 若P≠Q，则k=(y2-y1)/(x2-x1) mod p</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="c1"># of elliptic curve: negate of 3rd cross point of (p1,p2) line</span>
        <span class="k">if</span> <span class="n">p1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p2</span>
        <span class="k">if</span> <span class="n">p2</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p1</span>
        <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">p2</span><span class="o">.</span><span class="n">x</span> <span class="ow">and</span> <span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="n">y</span> <span class="ow">or</span> <span class="n">p1</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># p1 + -p1 == 0</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero</span>
        <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="p">:</span>
            <span class="c1"># p1 + p1: use tangent line of p1 as (p1,p1) line</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">p1</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">p1</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
            <span class="k">pass</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="n">p1</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="k">return</span> <span class="n">Coord</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># n times of elliptic curve</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">p</span>
        <span class="c1"># O(log2(n)) add</span>
        <span class="k">while</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
                <span class="k">pass</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="c1"># order of point g</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
            <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&#34;Invalid order&#34;</span><span class="p">)</span>
    <span class="k">pass</span></code></pre></div><p>然后我们实现ElGmamal算法 </p><p>构造函数生成曲线ec，生成元g，以及g的阶n</p><ul><li>`gen(self, priv)`，生成公钥pub</li><li>`enc(self, plain, pub, r)`,把明文plain（已编码为曲线上的点）进行加密</li><li> `dec(self, cipher, priv)`，解密的明文</li></ul><div class="highlight"><pre><code class="language-python"> <span class="k">class</span> <span class="nc">ElGamal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># ElGamal Encryption</span>
    <span class="c1"># pub key encryption as replacing (mulmod, powmod) to (ec.add, ec.mul)</span>
    <span class="c1"># - ec: elliptic curve</span>
    <span class="c1"># - g: (random) a point on ec</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ec</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">ec</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ec</span> <span class="o">=</span> <span class="n">ec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priv</span><span class="p">):</span>
        <span class="c1"># generate pub key</span>
        <span class="c1"># - priv: priv key as (random) int &lt; ec.q</span>
        <span class="c1"># - returns: pub key as points on ec</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">priv</span><span class="p">)</span>
       
    <span class="k">def</span> <span class="nf">enc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plain</span><span class="p">,</span> <span class="n">pub</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1"># encrypt</span>
        <span class="c1"># - plain: data as a point on ec</span>
        <span class="c1"># - pub: pub key as points on ec</span>
        <span class="c1"># - r: randam int &lt; ec.q</span>
        <span class="c1"># - returns: (cipher1, ciper2) as points on ec</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">plain</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">pub</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">plain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">pub</span><span class="p">,</span> <span class="n">r</span><span class="p">)))</span>

	<span class="k">def</span> <span class="nf">dec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cipher</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">public</span><span class="p">,</span> <span class="n">recv_public</span><span class="p">):</span>
        <span class="c1"># decrypt</span>
        <span class="c1"># - chiper: (chiper1, chiper2) as points on ec</span>
        <span class="c1"># - priv: private key as int &lt; ec.q</span>
        <span class="c1"># - returns: plain as a point on ec</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">public</span><span class="p">,</span> <span class="n">recv_public</span><span class="p">)</span>
        <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">cipher</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ec</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span></code></pre></div><p>最后写个main函数验证一下:</p><div class="highlight"><pre><code class="language-python"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="c1"># shared elliptic curve system of examples</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="n">EC</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">)</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ec</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ec</span><span class="o">.</span><span class="n">p</span>

    <span class="c1"># ElGamal enc/dec usage</span>
    <span class="n">eg</span> <span class="o">=</span> <span class="n">ElGamal</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

    <span class="c1"># mapping value to ec point</span>
    <span class="c1"># &#34;masking&#34;: value k to point ec.mul(g, k)</span>
    <span class="c1"># (&#34;imbedding&#34; on proper n:use a point of x as 0 &lt;= n*v &lt;= x &lt; n*(v+1) &lt; q)</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">[</span><span class="n">ec</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">eg</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">plain</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>

    <span class="n">priv</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">pub</span> <span class="o">=</span> <span class="n">eg</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span>
    
    <span class="n">cipher</span> <span class="o">=</span> <span class="n">eg</span><span class="o">.</span><span class="n">enc</span><span class="p">(</span><span class="n">plain</span><span class="p">,</span> <span class="n">pub</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
    <span class="n">decoded</span> <span class="o">=</span> <span class="n">eg</span><span class="o">.</span><span class="n">dec</span><span class="p">(</span><span class="n">cipher</span><span class="p">,</span> <span class="n">priv</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">decoded</span> <span class="o">==</span> <span class="n">plain</span>
    <span class="k">assert</span> <span class="n">cipher</span> <span class="o">!=</span> <span class="n">pub</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;Success!&#34;</span><span class="p">)</span></code></pre></div><p>运行结果如下：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-57ec04c1f56ae7372742efc52b95ec24_b.png" data-caption="" data-size="normal" data-rawwidth="585" data-rawheight="71" class="origin_image zh-lightbox-thumb" width="585" data-original="https://pic1.zhimg.com/v2-57ec04c1f56ae7372742efc52b95ec24_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-57ec04c1f56ae7372742efc52b95ec24_b.png" data-caption="" data-size="normal" data-rawwidth="585" data-rawheight="71" class="origin_image zh-lightbox-thumb lazy" width="585" data-original="https://pic1.zhimg.com/v2-57ec04c1f56ae7372742efc52b95ec24_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-57ec04c1f56ae7372742efc52b95ec24_b.png"/></figure><p class="ztext-empty-paragraph"><br/></p><p><b>三、基于椭圆曲线的数字签名算法ECDSA</b></p><p>签名算法与上面的加密算法类似，下面我们来看一下过程：</p><ol><li>选择一条椭圆曲线Ep(a,b)，和基点G；</li><li>选择私有密钥k（k&lt;n，n为G的阶），利用基点G计算公开密钥`Q=kG`；</li><li>产生一个随机整数r（r&lt;n），计算点`R=rG`；</li><li>密文为message，计算SHA1(message)做为hash；</li><li>计算`S≡r^-1 *( Hash + k * R.x)(mod n)`; 这里的R.x为R的横坐标</li><li> (R.x, S)做为签名值，如果R和S其中一个为0，重新从第3步开始执行</li></ol><blockquote>注：这里的`r^-1`指的是r的乘法逆元</blockquote><p>验证签名：</p><ol><li>接收方在收到消息m和签名值(R.x, S)后，进行以下运算</li><li>计算明文hash：`hash = SHA1(m)`</li><li>计算P点：`P = S^-1 *(hash*G + R.x*Q)`</li><li>若P点的横坐标P.x == R.x,则说明校验成功。</li></ol><p><b>为什么会这样？</b></p><p>下面我们来推导一下：</p><div class="highlight"><pre><code class="language-text">P = S^{-1} * (hash*G + R.x*Q) ·····1
Q = k*G	·····2
S = r^-1 *(hash + k*R.x)	·····3
R = r*G	·····4
联立1，2,得:
P = S^-1 * (hash + k*R.x)*G	·····5
这时候将3式带入5，即可得：
P = r*G    ·····6
这个时候我们对比4，6式，发现了这个神奇的结论：
P = R</code></pre></div><p>因此，在校验的时候比较P.x与R.x即可验证签名</p><p>我们已经完成数学上的推导，下面我们写个demo实现一下：</p><ul><li>构造函数初始化椭圆曲线EC，生成元g，生成元的阶n</li><li>`gen(self, priv)`生成公钥Q</li><li>`sign(self, hashval, priv, r)`对hashval进行签名，返回签名(R.x, S)</li><li>`validate(self, hashval, sig, pub)`对签名进行验证，检验hashval是否被篡改</li></ul><div class="highlight"><pre><code class="language-python"><span class="k">class</span> <span class="nc">DSA</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># ECDSA</span>
    <span class="c1"># - ec: elliptic curve</span>
    <span class="c1"># - g: a point on ec</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ec</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ec</span> <span class="o">=</span> <span class="n">ec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priv</span><span class="p">):</span>
        <span class="c1"># generate pub key</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">priv</span> <span class="ow">and</span> <span class="n">priv</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">priv</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hashval</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1"># generate signature</span>
        <span class="c1"># - hashval: hash value of message as int</span>
        <span class="c1"># - priv: priv key as int</span>
        <span class="c1"># - r: random int </span>
        <span class="c1"># - returns: signature as (int, int)</span>
    
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="c1"># (R.x, S)	S = r^-1 * (hashval + R.x * k)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">inv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">hashval</span> <span class="o">+</span> <span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">priv</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hashval</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">pub</span><span class="p">):</span>
        <span class="c1"># validate signature</span>
        <span class="c1"># - hashval: hash value of message as int</span>
        <span class="c1"># - sig: signature as (int, int)</span>
        <span class="c1"># - pub: pub key as a point on ec</span>
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">pub</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">pub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">zero</span>
        <span class="c1"># w = S^-1</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span> <span class="o">=</span> <span class="n">hashval</span> <span class="o">*</span> <span class="n">w</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">u1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ec</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">pub</span><span class="p">,</span> <span class="n">u2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">pass</span></code></pre></div><p>我们跑一下下面这段代码试试：</p><div class="highlight"><pre><code class="language-python"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="c1"># shared elliptic curve system of examples</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="n">EC</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">)</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ec</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ec</span><span class="o">.</span><span class="n">q</span>

		<span class="c1"># ECDSA usage</span>
		<span class="n">dsa</span> <span class="o">=</span> <span class="n">DSA</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
	
		<span class="n">priv</span> <span class="o">=</span> <span class="mi">11</span>
		<span class="n">pub</span> <span class="o">=</span> <span class="n">eg</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span>
		<span class="n">hashval</span> <span class="o">=</span> <span class="mi">128</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">7</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="n">dsa</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">hashval</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
		<span class="n">log</span><span class="p">(</span><span class="s2">&#34;sig&#34;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
		<span class="k">assert</span> <span class="n">dsa</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">hashval</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">pub</span><span class="p">)</span>
		<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Success!&#39;</span><span class="p">)</span>
	<span class="k">pass</span></code></pre></div><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-71f7bdac868a1cebf7eefba756e78187_b.jpg" data-caption="" data-size="normal" data-rawwidth="519" data-rawheight="100" class="origin_image zh-lightbox-thumb" width="519" data-original="https://pic4.zhimg.com/v2-71f7bdac868a1cebf7eefba756e78187_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-71f7bdac868a1cebf7eefba756e78187_b.jpg" data-caption="" data-size="normal" data-rawwidth="519" data-rawheight="100" class="origin_image zh-lightbox-thumb lazy" width="519" data-original="https://pic4.zhimg.com/v2-71f7bdac868a1cebf7eefba756e78187_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-71f7bdac868a1cebf7eefba756e78187_b.jpg"/></figure><p>我们可以看到已经验证成功了。</p><h2>CVE-2020-0601分析</h2><p>终于到了分析漏洞的时候了，这个漏洞导致的原因其实很简单，我们注意到在生成公钥的一部分`Q = k*G`的时候k我们是不知到的，而且求解难度很大。但是我们在签名的时候需要用私钥签名，怎么伪造签名呢？假如在对公钥做校验的时候我们没有检测G的值，只检查了Q那么我么就可以假装我们知道私钥。此时：</p><p><b>这里的e是乘法单位元，相当于整数乘法里的1</b></p><ul><li>Q = k*G</li><li>Q&#39; = e*Q = Q</li></ul><p>也就是说，我可以直接把“**1**”作为私钥，然后再去签名:</p><ul><li>公钥：(Q, G)</li><li>原签名：(R.x，S)</li></ul><div class="highlight"><pre><code class="language-text">Q = k*G
R = r*Q
S = r^{-1} *(hash + R.x*k)</code></pre></div><ul><li>伪造公钥：(Q&#39;，G&#39;)</li><li>伪造签名：(R&#39;.x, S&#39;)</li></ul><div class="highlight"><pre><code class="language-text">Q&#39; = 1*Q = Q
R&#39; = r*Q&#39; = r*Q
S&#39; = r^{-1} *(hash + R&#39;.x*1)</code></pre></div><p>那么我们来分析验证过程：</p><div class="highlight"><pre><code class="language-text">P = S^{-1} *hash*G + S^{-1} *R.x*Q</code></pre></div><p>假如我们把S‘和R‘.x以及公钥(G&#39;, Q)代入后可以得到</p><div class="highlight"><pre><code class="language-text">S’^{-1} = r*(hash + Q.x)^{-1}
P = S&#39;^{-1}*(hash*Q + Q.x*Q)
进一步代入S^-1得：
P = r*(hash + Q.x)^{-1} * (hash + Q.x)*Q = r*Q = R</code></pre></div><p>我们看到验证通过。系统在验证公钥得生成元Q == Q‘之后，并没有进一步验证生成元G。这就是**CVE-2020-0601**漏洞利用的原理，crypt32.dll在做校验时，只检查了Q，因此我们用单位元伪造私钥后进行的签名会被验证通过。</p><p>下面我们写个脚本验证一下：</p><div class="highlight"><pre><code class="language-python"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="c1"># shared elliptic curve system of examples</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="n">EC</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">)</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ec</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ec</span><span class="o">.</span><span class="n">p</span>

    <span class="c1"># ECDSA usage</span>
    <span class="n">dsa</span> <span class="o">=</span> <span class="n">DSA</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="c1"># G&#39; = Q = k*G</span>
    <span class="n">fake</span> <span class="o">=</span> <span class="n">DSA</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">ec</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
    <span class="c1"># print(g, ec.mul(g, 1))</span>

    <span class="n">priv</span> <span class="o">=</span> <span class="mi">11</span>
    <span class="n">pub</span> <span class="o">=</span> <span class="n">eg</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span>
    
    <span class="c1"># R‘ = r*Q’ = 1 * Q = Q</span>
    <span class="c1"># 因此fake_pub = pub</span>
    <span class="n">fake_pub</span> <span class="o">=</span> <span class="n">pub</span>
    <span class="n">log</span><span class="p">(</span><span class="s2">&#34;fake_pub&#34;</span><span class="p">,</span><span class="n">fake_pub</span> <span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s2">&#34;pub&#34;</span><span class="p">,</span> <span class="n">pub</span><span class="p">)</span>

    <span class="n">hashval</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">7</span>

    <span class="c1"># 随机数r设置为不同的值</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">dsa</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">hashval</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">fsig</span> <span class="o">=</span> <span class="n">fake</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">hashval</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s2">&#34;sig&#34;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s2">&#34;fsig&#34;</span><span class="p">,</span> <span class="n">fsig</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">sig</span> <span class="o">!=</span> <span class="n">fsig</span>

    <span class="c1"># 分别进行签名校验</span>
    <span class="k">assert</span> <span class="n">dsa</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">hashval</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">pub</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">fake</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">hashval</span><span class="p">,</span> <span class="n">fsig</span><span class="p">,</span> <span class="n">fake_pub</span><span class="p">)</span>
    
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Success!&#39;</span><span class="p">)</span>

    <span class="k">pass</span></code></pre></div><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-6b2442f547a6aaeced8f6872dc7b0a98_b.jpg" data-caption="" data-size="normal" data-rawwidth="488" data-rawheight="145" class="origin_image zh-lightbox-thumb" width="488" data-original="https://pic1.zhimg.com/v2-6b2442f547a6aaeced8f6872dc7b0a98_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-6b2442f547a6aaeced8f6872dc7b0a98_b.jpg" data-caption="" data-size="normal" data-rawwidth="488" data-rawheight="145" class="origin_image zh-lightbox-thumb lazy" width="488" data-original="https://pic1.zhimg.com/v2-6b2442f547a6aaeced8f6872dc7b0a98_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-6b2442f547a6aaeced8f6872dc7b0a98_b.jpg"/></figure><p>运行结果如下，我们可以看到用不同的私钥加密获得的签名是不同的,但是由于公钥的生成元G被我们篡改，所以验证也会通过。</p><p>最后我们提供一个能用的[poc](<a href="https://link.zhihu.com/?target=https%3A//github.com/ollypwn/cve-2020-0601" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/ollypwn/cve-</span><span class="invisible">2020-0601</span><span class="ellipsis"></span></a>),仅供学习交流。</p><h2>总结</h2><p>这个漏洞的原理其实十分简单，就是小学二年级学过的代数。我们应该注意密码的完整性的校验，更要好好学数学。</p><h2>参考：</h2><p>[维基百科](<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/ElGamal%25E5%258A%25A0%25E5%25AF%2586%25E7%25AE%2597%25E6%25B3%2595" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">zh.wikipedia.org/wiki/E</span><span class="invisible">lGamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95</span><span class="ellipsis"></span></a>)</p><p>[安全客](<a href="https://link.zhihu.com/?target=https%3A//www.anquanke.com/post/id/159893" class=" wrap external" target="_blank" rel="nofollow noreferrer">简析ECC攻击方法之Pohlig-Hellman - 安全客，安全资讯平台</a>)</p><p>[ECC原理解析](<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Kalafinaian/p/7392505.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">ECC椭圆曲线详解(有具体实例) - Kalafinaian - 博客园</a>)</p><p></p>