<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>所有权</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/21671588">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/1679078e382b25c85a887d4ae4d8b723_r.jpg" alt=""></div><p>本文讲解Rust的所有权(Ownership)概念。所有权，是Rust实现内存安全的重要概念。</p><h2>什么是所有权</h2><p>拿C语言的代码来打个比方，我们可能会在堆上创建一个对象，然后使用一个指针来管理这个对象：</p><code lang="text">Foo *p = make_object("args");
</code><p>接下来，我们可能需要使用这个对象：</p><code lang="text">use_object(p);
</code><p>然而，这段代码之后，谁能猜得到，指针p指向的对象究竟发生了什么？它还存在吗，是否已经被释放？是否有另外一个指针现在也同时指向这个对象？我们还能继续释放这个对象吗？实际上除了去了解use_object的内部实现之外，我们没办法回答。</p><p>C++对此进行了一个改进，通过使用“智能指针”来描述“所有权”概念，一定程度上减少了内存使用bug，实现了“半自动化”的内存管理。而Rust在此基础上更进一步，将所有权的理念直接融入到了语言之中。</p><h2>默认的move语义</h2><p>在Rust中，一般情况下，每一个“变量绑定”都对它绑定的那块内存拥有所有权。当这个拥有所有权的变量绑定，生命周期结束的时候，会执行自动释放资源的操作。比如说，对于动态数组：</p><code lang="text">fn func1() {
    let v = vec![1, 2, 3];
}
</code><p>进入函数的时候，变量v绑定到了一个动态数组，这个动态数组不仅在栈上有数据(包括指向具体数据的指针，容量以及真实长度)，而且在堆上也分配了内存空间(存储变长数组数据)。当函数退出的时候，变量v就不能再被访问，它的“生命周期”也就结束了，在这个时候，程序会自动释放它拥有的所有内存，既包括“堆”上的，也包括“栈”上的。</p><p>所有权可以被“借用(borrow)”，也可以被“转移(move)”。</p><p>用文件系统来打个比方，转移所有权就像是“剪切 粘贴”操作，被剪切的那个文件在操作之后就被“移动”到另外一个地方去了，原先的那个已经不存在，不能被使用。</p><p>接上例，我们在函数内部，在堆上分配了一块内存，如果函数一退出，这块内存就被自动释放，那么堆就没什么存在意义了。实际上，如果我们希望这块内存还能被继续使用，那么我们可以将这块内存的所有权转移出去，比如这样：</p><code lang="text">fn func1() -&gt; Vec&lt;isize&gt; {
   let v = vec![1, 2, 3];
   v  // 此处不带分号，利用表达式作为返回，也可以写作 return v;
}

fn func2() {
   let v = func1();
}
</code><p>在func1中，我们创建的动态数组，在函数结束的时候，将所有权转移出去了。在func1返回的时候，在栈上分配的内存需要通过拷贝操作，复制出去，而堆动态申请的内存并没有执行释放操作，func2中的变量v获取了这个动态数组的所有权。这个过程称作所有权转移，即move语义。</p><p>不仅是函数返回会发生所有权转移，普通的变量绑定操作也会发生所有权转移。Rust中发生所有权转移后，新的变量绑定接管了原先的那块内存的管理权，原先的变量生命周期就结束了，如果我们再次使用，就会发生编译错误。</p><code lang="text">fn main() {
    // 声明了一个变量绑定
    let v1 = vec![1, 2, 3];

    // 执行变量绑定操作，此处发生所有权转移，v1将它管理的内存的所有权转移给了v2
    // 因此v1的生命周期到此为止，在后面如果再使用v1，是错误的用法
    let v2 = v1;

    // 试图再次使用v1读取数据内容
    println!("{:?}", v1);
}
</code><p>编译报错。错误信息为“use of moved value: v1”。</p><p>这个编译错误是所有Rust语言初学者都会碰到的编译错误，而且大家在将来还会碰到许多次。</p><p>Rust中的所有权转移的重要特点是，它是所有类型的<strong>默认</strong>语义。比如说，我们定义了一个新的类型：</p><code lang="text">struct Foo {
    data : i32
}

fn main() {
    let v1 = Foo { data : 0 };
    let v2 = v1;
    println!("{:?}", v1.data);
}
</code><p>再次发生同样的编译错误。之所以重复一遍，是要请大家牢牢记住，Rust中的变量绑定操作，<strong>缺省</strong> 是move语义，执行了新的变量绑定后，原先的变量就不能再被使用！一定要记住！</p><p>在Rust中，每一次的变量绑定，move语义很可能就执行了，不仅会出现在let语句中，还可能出现在，函数调用中，match语句中，等等：</p><code lang="text">fn move_in_match(x : Option&lt;String&gt;) {

  match x { // 这里的 x 会执行 move 语义
    op_string @ Some(s) =&gt; {} 
    // x 的所有权转移到了 op_string 中，
    //而 s 也意图绑定内部的 String 数据，这样 op_string 和 s 都试图拥有同一块数据
    None =&gt; {}
  }
}

fn main() {
    let s = Some("Hello, world!".to_owned());
    move_in_match(s);
}
</code><p>这个错误的原因是，在match语句中，我们希望x的所有权被转移到op_string中去，然而同时还希望它的内部包含的字符串被转移到s中去。</p><p>在Rust中，只要一个对象实例的部分成员发生了所有权转移，那么这个实例就无法再被使用。Rust中不允许存在部分合法、部分非法的对象状态。示例如下：</p><code lang="text">struct Foo {
   s1 : String,
   s2 : String
}

impl Foo {
   fn print(&amp;self) -&gt; String {
      let mut temp = String::new();
      temp.push_str(&amp;self.s1);
      temp.push_str(&amp;self.s2);
      temp
   }
}

fn main() {
    let v = Foo {
        s1 : "hello".to_owned(),
        s2 : "world".to_owned(),
    };

    let part1 = v.s1; // v 的一个成员被 move 出去了
    println!("{}", part1);     // part1 是有效变量

    println!("{}", v.print()); // v的数据已经被破坏掉了
}
</code><p>可以看到，变量v的一个成员s1已经被转移出去了，因此后面使用变量v的时候，发生了编译错误：</p><code lang="text">error: use of partially moved value: `v`
</code><h2>可选的copy语义</h2><p>讲到这里大家一定会有一个疑惑，前面的章节中我们也大量使用了变量绑定操作，为什么没有出现这样的编译错误？比如说，下面这个程序就可以正常编译通过：</p><code lang="text">fn main() {
    let v1 : isize = 0;
    let v2 = v1;
    println!("{}", v1);
}
</code><p>编译器并没有阻止我们说v1不能被使用，这是为什么呢？</p><p>因为Rust中，有一部分“特殊照顾过”的类型，变量绑定操作是Copy语义。所谓的Copy语义，是说在执行变量绑定操作的时候，v2是对v1所属数据的一份拷贝复制。v1所管理的这块内存依然存在，并未失效，而v2是新开辟了一块内存，它的内容是从v1管理的内存中拷贝而来。</p><p>使用文件系统来打比方，Copy语义就像“拷贝 粘贴”操作。操作完成后，原先的那份数据依然存在，而新的数据是原先那份数据的复制品。</p><p>在Rust中，在普通变量绑定/函数传参/模式匹配等场景中，凡是实现了std::marker::Copy trait的类型，都是执行的copy语义。</p><p>既然如此，我们来对自定义类型实现Copy trait，Copy trait是一种marker trait，里面没有任何函数，我们先试试：</p><code lang="text">struct Foo {
    data : i32
}

impl Copy for Foo {}

fn main() {
    let v1 = Foo { data : 0 };
    let v2 = v1;
    println!("{:?}", v1.data);
}
</code><p>咦，编译错误，错误信息是“the trait core::clone::Clone is not implemented for the type Foo”。赶紧查一下源码，我们发现，原来Copy继承了Clone，我们要实现Copy trait必须一起实现Clone trait。把代码改成如下所示：</p><code lang="text">struct Foo {
    data : i32
}

impl Clone for Foo {
    fn clone(&amp;self) -&gt; Foo {
        Foo { data : self.data }
    }
}

impl Copy for Foo {}

fn main() {
    let v1 = Foo { data : 0 };
    let v2 = v1;
    println!("{:?}", v1.data);
}
</code><p>编译通过。现在我们的Foo类型也拥有了默认Copy语义。在执行变量绑定、函数参数传递的时候，原先的变量不会失效，而是会新开辟一块内存，将原先的数据拷贝过来。</p><p><b>注意：</b>不是所有类型都可以实现 Copy trait。只有简单的<a href="https://en.wikipedia.org/wiki/Passive_data_structure">POD </a>类型才被允许。内部带指针的类型，带析构函数的类型，都是不允许实现 Copy trait 的。</p><h2>所有权转移的意义</h2><p>前面讲了那么多语法规则，那么，为什么Rust要这样设计呢？</p><p>要回答这个问题，我们先讲一下Copy操作在Rust中是什么含义。为了更精确地表达清楚这些概念背后的含义，我们先定义一下两种类型的拷贝语义：</p><br><p>1. 浅拷贝(shallow copy)</p><p>浅拷贝就是简单的内存复制，等同于调用memcpy函数。比如，有一个tuple类型(Box&lt;usize&gt;, u64)，在64位系统上，它占用了16字节的空间，我们对这个类型执行拷贝的时候，可以简单地对这16个字节进行复制即可。不涉及其它的对指针指向内容的处理。</p><br><p>2. 深拷贝(deep copy)</p><p>深拷贝则需要考虑数据内部的成员类型，如果它内部有指针，间接对另外一块内存也拥有所有权，则需要把所指向的那块内存也一起复制。比如动态数组类型Vec&lt;T&gt;，它的内部数据是存在堆上的，栈上只有指向堆内存的指针、数组总长度、实际占用长度。执行深拷贝操作的时候不能仅仅把这个变量存在栈上的内容拷贝一次，而且还需要重新分配一块新的内存，并把它指向的数据也都拷贝过来，而且还要保证新的 Vec 里面的指针指向了新分配的内存。</p><p>如果所有类型都使用浅拷贝的话，就容易引发一个问题：对于内部存在指针，可以管理间接内存的类型，直接基于字节拷贝是浅拷贝，会出现两个指针都指向同一块内存，从而引发两次释放的问题。而如果所有类型都使用深拷贝的话，效率又太低。这个问题可以有多种的解决方案：</p><p><b>方案一</b></p><br><p>像C语言一样，放任不管，由程序员自己来决定怎么处理。赋值、参数传递等场合，默认使用浅拷贝，如果需要深拷贝需要自己写函数实现。C语言不帮程序员做任何决定，也不提供“析构函数”这样的功能。这部分内存是被正常释放，还是释放两次，或者泄漏掉了，完全取决于程序员。</p><br><p><b>方案二</b></p><p>像C++语言一样，允许程序员自定义拷贝构造函数，还有赋值运算符重载，于是程序员有机会在这样的地方实现“自定义拷贝行为”的功能。在执行赋值语句的时候，究竟发生什么事，由程序员自主掌控，可能是浅拷贝，可能是深拷贝，也可能是所有权转移。当然，如果实现得有问题，责任自负，编译器是没办法猜测程序员的意图的，所以也没能力做出完整的静态检查。</p><br><p><b>方案三</b></p><p>像Rust语言一样，把赋值操作默认看作是“所有权转移”，在转移之后，前一个变量就失去了对它所掌控的那部分内存的所有权，它的生命周期到此结束，后面再不能被使用了。</p><p>比如说我们的Box指针，它就不能也不应该具有Copy语义。Box指针对它指向的内存拥有所有权，当它的生命周期结束的时候，有权将它管理的这部分内存释放掉。如果有两个Box指针指向了同一块内存，就会出问题，这部分内存将会被释放两次。对于Vec这样的类型也是一样的。</p><p>当然，对于简单的<a href="https://en.wikipedia.org/wiki/Passive_data_structure">POD </a>类型，它内部一定不存在间接引用的其它内存，对它执行浅拷贝和深拷贝是完全一样的。所以，我们如果让这种类型默认执行“基于字节的拷贝”，是没问题的。所以Rust提供了 Copy trait 可以供我们使用。</p><p>在Rust中，我们同样也能通过主动调用clone()函数执行“自定义拷贝行为”。相比于C++的方案，Rust的设计只是改变了（变量绑定/函数参数传递等）默认的语义而已，并未减少灵活性，但增强了编译器的静态代码分析能力。</p><p>在C++标准中也存在一个类似Box指针的智能指针unique_ptr，它同样也能够实现动态申请内存、所有权转移等等功能。但是，跟Rust语言的最大的区别是，unique_ptr虽然实现了“所有权转移”的概念，但它无法避免程序员的误用。</p><p><br>比如说，我们依然可以继续使用一个已经将所有权转移出去的unique_ptr，不会发生编译错误，而是发生运行时错误。在C++中，执行赋值操作的背后可能发生什么事情，每个类型执行的操作都是有可能不同的。在留下巨大灵活性的同时，也就意味所有权概念只能存在于程序员的脑海中，编译器不可能推理出来，一个指针究竟对它背后的内存拥有所有权，还是仅仅是借用关系。这样的信息，我们可以通过智能指针等技巧进行模拟，而无法像Rust一样使编译器执行完整的所有权检查。</p><p>示例如下：</p><code lang="text">// 不靠谱代码，仅为示例，切勿模仿
#include &lt;memory&gt;
#include &lt;iostream&gt;

using namespace std;

void use_value(unique_ptr&lt;int&gt; p) {
  cout &lt;&lt; "value is " &lt;&lt; *p &lt;&lt; endl;
}

int main() {
  unique_ptr&lt;int&gt; x(new int(1));
  unique_ptr&lt;int&gt; y(move(x));
  use_value(move(y));
  use_value(move(x));
  return 0;
}
</code><p>在这个示例中，我们可以看到，即便我们将对象的所有权从x转移给了y，x的生命周期也并未终止，我们依然可以使用变量x 作为函数参数，没有发生编译错误。但是这种写法究竟还是错误的，执行这个程序，会发生 “Segmentation fault” 错误。</p><p>从内存安全性角度来看，Rust的设计思路和C++是有巨大区别的。在C++里面，不论哪种用处的指针，都是用的同一种表示方式，编译器并不理解这个指针背后的意图是什么。我们可以用库来模拟出各种不同用处的智能指针，但是依然存在各种被误用的可能性。保证内存安全的规则是存在于各种 Best Practices 的教程中，程序员需要学习了解这些规则，避免误用。在Rust里面，将不同用处的指针，分别采取了不同的表示方式，强制要求程序员告诉编译器我希望用这个指针做什么。不同的指针类型，代表的是程序员的不同的“意图”。Rust编译器就可以据此来做一系列的各种静态检查。Rust可以向使用者保证，在不使用 unsafe 语句块的情况下，使用者没办法构造出“内存不安全”。因此Rust的一个重要缺陷就是，编译错误特别多，学习曲线比较陡峭，对新手不友好。</p><p>但是话又说回来，对于“内存不安全”这样严重的错误，在执行阶段造成的损失要远大于编译错误造成的损失。对于那些带有严重缺陷的代码，如果可以轻松编译通过，也未必是什么好事情。大部分情况下，Rust编译器报告的那些错误，基本都正确反映了代码设计中的固有缺陷。</p><p>我们都知道，一个软件在其整个生命周期内，解决错误的代价和成本是不断变化的。bug发现得越早，付出的代价越少，解决的成本越低。如果问题在需求分析阶段被发现，那可以很快被修正，几乎没有影响；如果问题在编码阶段被发现，那么单个程序员即可解决，问题不大；如果问题在测试阶段被发现，还是团队内部问题，没有影响用户；如果是产品发布之后发现问题，麻烦大了，成本开销成数十倍百倍增加；如果在产品发布之后，发现了程序崩溃问题，而且是偶然出现，难以复现，debug难度极高，严重影响了用户，那这样的bug造成的代价是无法估量的，解决这样的bug的成本更是难以估算。实际上，即便是一些使用非常广泛的著名的优秀程序，也会有一定几率的诡异的内存问题发生，这样的问题往往累积多年都无法彻底清除干净。</p><p>Rust的优点在于，把内存安全相关的问题暴露在了编译阶段。从解决问题的成本上来看，这是代价最低的方案。bug是客观存在的，通过增加code review，增加测试代码覆盖率等方法，总是会有漏网之鱼，Rust的这一整套设计，从根源上杜绝了“内存不安全”代码存在的可能性，对于我们的工程实践，是非常有意义的。</p><blockquote><p>Failing early is almost better than later.</p></blockquote><img src="https://pic1.zhimg.com/4734854e5c696e6aff1b0aa543d98813_r.png" data-rawwidth="500" data-rawheight="330"><br><p>为了彻底贯彻“内存安全”的理念，Rust选择将一些重要的Best Practices变成硬性规定，强制执行。与“默认move语义”相配合，Rust还规定了其它的一整套的内存检查规则，通过这些规则的互相配合，Rust通过编译阶段检查杜绝了“空指针”、“使用未初始化变量”、“使用野指针”、“内存被释放两次”、“指针越界”、“内存段错误”等问题。所有权概念和默认move行为是这一整套静态检查体系中的一个重要部分。</p><p>本文同步发布在微信公众号：<b>Rust编程</b>，欢迎关注。</p><br>​
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
