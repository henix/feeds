<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Sat, 04 May 2019 16:25:37 +0800</lastBuildDate>
<item>
<title>PFPL 读书笔记 2 —— 归纳定义</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-03-64552881.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64552881&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f4edfb308976de77bfa5f49c860421cc_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;归纳定义&lt;/h2&gt;&lt;p&gt;在学习编程语言的过程中，归纳定义是必不可少的工具。一个归纳定义是由各种各样 &lt;i&gt;判断&lt;/i&gt; 的推导过程形成的 &lt;i&gt;规则&lt;/i&gt; 集合组成的。判断是某个特定类别的语法对象的表达式。规则表述了一条判断有效的充分必要条件。&lt;/p&gt;&lt;h2&gt;判断&lt;/h2&gt;&lt;p&gt;判断是一个语法对象的表达式，举例来说：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5f9c554affc4db186c94c6d3224a687c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1640&quot; data-rawheight=&quot;434&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1640&quot; data-original=&quot;https://pic1.zhimg.com/v2-5f9c554affc4db186c94c6d3224a687c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5f9c554affc4db186c94c6d3224a687c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1640&quot; data-rawheight=&quot;434&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1640&quot; data-original=&quot;https://pic1.zhimg.com/v2-5f9c554affc4db186c94c6d3224a687c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5f9c554affc4db186c94c6d3224a687c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（不支持表格图又糊得要死。。）&lt;/p&gt;&lt;p&gt;一条判断表示语法对象具有某种性质或者几个语法对象直接有某种关系。这种性质或者关系被称为 &lt;i&gt;判断式&lt;/i&gt;，这里的语法对象称为这种判断形式的 &lt;i&gt;实例&lt;/i&gt;。判断式也被称为 &lt;i&gt;谓语&lt;/i&gt;，对应的实例被称为 &lt;i&gt;主语&lt;/i&gt;。我们用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a+~+J+&quot; alt=&quot; a ~ J &quot; eeimg=&quot;1&quot;/&gt; 表示断言 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; 对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 成立。不需要关心判断的主语时，用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; 来表示不确定的判断。为了能够更直观地表达，可能会使用前缀，中缀或混合词缀表示一条特定的判断。&lt;/p&gt;&lt;h2&gt;推理规则&lt;/h2&gt;&lt;p&gt;一个判断式的 &lt;i&gt;归纳定义&lt;/i&gt; 由一组规则组成。一条 &lt;i&gt;规则&lt;/i&gt; 可以表示为&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7BJ_1+~+%E2%80%A6+~++J_k%7D%7BJ%7D+%5Ctag%7B2.1%7D+%5C&quot; alt=&quot;\frac{J_1 ~ … ~  J_k}{J} \tag{2.1} \&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;在横线以上的称为这条规则的 &lt;i&gt;假设&lt;/i&gt;，横线以下的称为它的 &lt;i&gt;结论&lt;/i&gt;。如果一条规则没有假设，那么这条规则被称为 &lt;i&gt;公理&lt;/i&gt;。一条规则所表示的意思是它的假设是它的结论的 &lt;i&gt;充分条件&lt;/i&gt;：要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; ，只需要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J_1%2C%E2%80%A6%2CJ_k&quot; alt=&quot;J_1,…,J_k&quot; eeimg=&quot;1&quot;/&gt; 。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;/&gt; 为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7Bzero%7D&quot; alt=&quot;\text{zero}&quot; eeimg=&quot;1&quot;/&gt; 时，它的结论永远都是成立的。一般地，可能会有多条规则拥有同样的结论，因此一条规则的结论成立不一定意味着它的假设也成立，结论可能可以由其它的规则推导出来。&lt;/p&gt;&lt;p&gt;举例来说，以下规则是一条判断 $a ~ \text{nat}$ 的归纳定义：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7D%7B%5Ctext%7Bzero%7D+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.2a%7D+%5C+&quot; alt=&quot;\frac{}{\text{zero} ~ \text{nat}} \tag{2.2a} \ &quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+~+%5Ctext%7Bnat%7D%7D%7Bsucc%28a%29+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.2b%7D+%5C&quot; alt=&quot;\frac{a ~ \text{nat}}{succ(a) ~ \text{nat}} \tag{2.2b} \&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这两条规则说明了当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7Bzero%7D&quot; alt=&quot;\text{zero}&quot; eeimg=&quot;1&quot;/&gt; 或者是另一个自然数的后继时，是一个自然数。类似地，也可以给出一棵二叉树的定义：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7D%7B%5Ctext%7Bempty%7D+~+%5Ctext%7Btree%7D%7D+%5Ctag%7B2.3a%7D+&quot; alt=&quot;\frac{}{\text{empty} ~ \text{tree}} \tag{2.3a} &quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba_1+~+%5Ctext%7Btree%7D+~~+a_2+~+%5Ctext%7Btree%7D%7D%7Bnode%28a_1%3Ba_2%29+~+%5Ctext%7Btree%7D%7D+%5Ctag%7B2.3b%7D&quot; alt=&quot;\frac{a_1 ~ \text{tree} ~~ a_2 ~ \text{tree}}{node(a_1;a_2) ~ \text{tree}} \tag{2.3b}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这两条规则说明一棵二叉树要么为空，要么两个节点都是一棵二叉树。&lt;/p&gt;&lt;p&gt;表示自然数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;/&gt;  相等的判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a%3Db&quot; alt=&quot;a=b&quot; eeimg=&quot;1&quot;/&gt; 可以定义为：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7D%7B%5Ctext%7Bzero%7D+%3D+%5Ctext%7Bzero%7D+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.4a%7D&quot; alt=&quot;\frac{}{\text{zero} = \text{zero} ~ \text{nat}} \tag{2.4a}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+%3D+b+~+%5Ctext%7Bnat%7D%7D%7Bsucc%28a%29+%3D+succ%28b%29+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.4b%7D+&quot; alt=&quot;\frac{a = b ~ \text{nat}}{succ(a) = succ(b) ~ \text{nat}} \tag{2.4b} &quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;在这些例子中我们都使用有限的形式声明了无限个规则。&lt;/p&gt;&lt;p&gt;如果有一些规则，通过这些规则可以推导出一条判断，就说这条判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; 闭合与这些规则。如果这些规则同时还是&lt;i&gt;必要&lt;/i&gt; 的，称判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; 强闭合于这些规则。&lt;/p&gt;&lt;h2&gt;推导过程&lt;/h2&gt;&lt;p&gt;要证明一条归纳定义的判断成立，只需要列出它的 &lt;i&gt;推导过程&lt;/i&gt;。推导过程从公理开始，结束于要证明的判断。它可以被看成是一棵树，一个节点的子树就是它的假设的推导过程。如果&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7BJ_1+~+%E2%80%A6+~++J_k%7D%7BJ%7D++%5C%5C&quot; alt=&quot;\frac{J_1 ~ … ~  J_k}{J}  \\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CDelta_1%2C%E2%80%A6%2C%5CDelta_k&quot; alt=&quot;\Delta_1,…,\Delta_k&quot; eeimg=&quot;1&quot;/&gt; 分别是这些假设的推导过程，可以将 $J$ 的推导过程写为 &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cfrac%7B%5CDelta_1+~+%E2%80%A6+~++%5CDelta_k%7D%7BJ%7D+%5C%5C&quot; alt=&quot; \frac{\Delta_1 ~ … ~  \Delta_k}{J} \\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;例如， &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28succ%28succ%28zero%29%29%29+~+%5Ctext%7Bnat%7D&quot; alt=&quot;succ(succ(succ(zero))) ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 的推导过程写为&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cfrac%7B%5Cfrac%7B%5Cfrac%7B%7D%7Bzero+~+%5Ctext%7Bnat%7D%7D%7D%7Bsucc%28zero%29+~+%5Ctext%7Bnat%7D%7D%7D%7Bsucc%28succ%28zero%29%29+~+%5Ctext%7Bnat%7D%7D%7D%7Bsucc%28succ%28succ%28zero%29%29%29+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.5%7D+%5C%5C&quot; alt=&quot;\frac{\frac{\frac{\frac{}{zero ~ \text{nat}}}{succ(zero) ~ \text{nat}}}{succ(succ(zero)) ~ \text{nat}}}{succ(succ(succ(zero))) ~ \text{nat}} \tag{2.5} \\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;要证明一条判断能被推导出来，只需要找到一个推导过程。主要有两种方法用于得到推导过程。一个是 &lt;i&gt;正向查询&lt;/i&gt;，从公理出发，直到推导出最终结论。另一个是 &lt;i&gt;反向查询&lt;/i&gt;，是从结论出发直到顶层的假设都为公理。正向查询维护一个判断的集合，初始为空，然后找到所有假设都在该集合中的规则，将它的结论也加入集合，直到需要推导的判断出现在这个集合中。如果一条判断是可推导的，那么这个方法总是可以找到它的推导过程，但是如果一条判断无法被推导，那么运算永远不会终止，此时无法判断它是否可以推导。反向查询则维护一个队列，初始时只有这条需要推导的判断，随后每一次操作都移除队列中的一条判断，将它的假设加入队列中，如果有多条规则可以推导出这条判断，那么需要分别执行这个过程，知道队列为空。如果一条判断是可推导的，这个方法也能找到它的推导过程，但是同样地，如果一条判断不可被推导，那么可能会有无限条规则加入到队列中，永远不会被清空。&lt;/p&gt;&lt;h2&gt;规则归纳&lt;/h2&gt;&lt;p&gt;如果当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28J_1%29%2C%E2%80%A6%2CP%28J_k%29&quot; alt=&quot;P(J_1),…,P(J_k)&quot; eeimg=&quot;1&quot;/&gt; 成立时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28J%29&quot; alt=&quot;P(J)&quot; eeimg=&quot;1&quot;/&gt; 也成立，那么称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P&quot; alt=&quot;P&quot; eeimg=&quot;1&quot;/&gt; 闭合于规则&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7BJ_1+~+%E2%80%A6+~++J_k%7D%7BJ%7D+%5C%5C&quot; alt=&quot;\frac{J_1 ~ … ~  J_k}{J} \\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;规则归纳表示如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P&quot; alt=&quot;P&quot; eeimg=&quot;1&quot;/&gt; 闭合于一些规则，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P&quot; alt=&quot;P&quot; eeimg=&quot;1&quot;/&gt; 对于任何由这些规则定义的判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=J&quot; alt=&quot;J&quot; eeimg=&quot;1&quot;/&gt; 是成立的。例如对于规则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.2%29%7D&quot; alt=&quot;\text{(2.2)}&quot; eeimg=&quot;1&quot;/&gt; 要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(a ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; ，只要证明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28zero+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(zero ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; ，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28zero+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(zero ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28a%29+~+%5Ctext%7Bnat%7D+&quot; alt=&quot;succ(a) ~ \text{nat} &quot; eeimg=&quot;1&quot;/&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28succ%28a%29+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(succ(a) ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这个与数学归纳法很像，它是规则归纳的一个特例。&lt;/p&gt;&lt;p&gt;类似地对于规则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%282.3%29&quot; alt=&quot;(2.3)&quot; eeimg=&quot;1&quot;/&gt; ，要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Btree%7D%29&quot; alt=&quot;P(a ~ \text{tree})&quot; eeimg=&quot;1&quot;/&gt; 对于任何 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Btree%7D&quot; alt=&quot;a ~ \text{tree}&quot; eeimg=&quot;1&quot;/&gt; 成立，只需要证明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28empty+~+%5Ctext%7Btree%7D%29&quot; alt=&quot;P(empty ~ \text{tree})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1&quot; alt=&quot;a_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_2&quot; alt=&quot;a_2&quot; eeimg=&quot;1&quot;/&gt; ，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1+~+%5Ctext%7Btree%7D&quot; alt=&quot;a_1 ~ \text{tree}&quot; eeimg=&quot;1&quot;/&gt; ，&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a_1+~+%5Ctext%7Btree%7D%29+&quot; alt=&quot;P(a_1 ~ \text{tree}) &quot; eeimg=&quot;1&quot;/&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_2+~+%5Ctext%7Btree%7D&quot; alt=&quot;a_2 ~ \text{tree}&quot; eeimg=&quot;1&quot;/&gt; ，&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a_2+~+%5Ctext%7Btree%7D%29&quot; alt=&quot;P(a_2 ~ \text{tree})&quot; eeimg=&quot;1&quot;/&gt; ，那么可以得出 &lt;img src=&quot;https://www.zhihu.com/equation?tex=node%28a_1%3Ba_2%29+~+%5Ctext%7Btree%7D&quot; alt=&quot;node(a_1;a_2) ~ \text{tree}&quot; eeimg=&quot;1&quot;/&gt; 与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28node%28a_1%3Ba_2%29+~+%5Ctext%7Btree%7D%29&quot; alt=&quot;P(node(a_1;a_2) ~ \text{tree})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这被称为树形归纳，也是规则归纳的一种形式。&lt;/p&gt;&lt;p&gt;用这种方法可以证明很多性质，比如：&lt;/p&gt;&lt;p&gt;&lt;b&gt;引理. &lt;/b&gt; 如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a = a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;i&gt;证明&lt;/i&gt;：根据规则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%282.4a%29&quot; alt=&quot;(2.4a)&quot; eeimg=&quot;1&quot;/&gt; ，&lt;img src=&quot;https://www.zhihu.com/equation?tex=zero+%3D+zero+~+%5Ctext%7Bnat%7D&quot; alt=&quot;zero = zero ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 。假设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a = a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; ，那么根据规则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%282.4b%29&quot; alt=&quot;(2.4b)&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28a%29+%3D+succ%28a%29+~+%5Ctext%7Bnat%7D&quot; alt=&quot;succ(a) = succ(a) ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 成立。&lt;/p&gt;&lt;p&gt;类似地也能证明如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28a_1%29+%3D+succ%28a_2%29&quot; alt=&quot;succ(a_1) = succ(a_2)&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1+%3D+a_2+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a_1 = a_2 ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;h2&gt;迭代归纳与相互归纳&lt;/h2&gt;&lt;p&gt;归纳定义经常是迭代定义的，即一条归纳定义是在另一条的基础上构成的。在迭代归纳定义中，一条规则的假设即可能是之前有定义的判断，也可以是当前定义的判断，例如定义一个自然数列表 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Blist%7D&quot; alt=&quot;a ~ \text{list}&quot; eeimg=&quot;1&quot;/&gt; ：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7D%7Bnil+~+%5Ctext%7Blist%7D%7D+%5Ctag%7B2.7a%7D&quot; alt=&quot;\frac{}{nil ~ \text{list}} \tag{2.7a}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+~+%5Ctext%7Bnat%7D+~~+b+~+%5Ctext%7Blist%7D%7D%7Bcons%28a%3Bb%29+~+%5Ctext%7Blist%7D%7D+%5Ctag%7B2.7b%7D&quot; alt=&quot;\frac{a ~ \text{nat} ~~ b ~ \text{list}}{cons(a;b) ~ \text{list}} \tag{2.7b}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;第一条假设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 是前面定义过的判断，而第二条 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Blist%7D&quot; alt=&quot;b ~ \text{list}&quot; eeimg=&quot;1&quot;/&gt; 则是当前正在定义的。&lt;/p&gt;&lt;p&gt;很多时候，有两条或者更多判断使用相互归纳的方式同时定义。相互归纳定义推导出多条判断，其中每一条判断都可能出现在其中一些规则的假设中。因为它们在定义的时候彼此依赖，所以只能同时给出它们的定义。例如定义一个自然数是奇数或者偶数：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%7D%7Bzero+~+%5Ctext%7Beven%7D%7D+%5Ctag%7B2.8a%7D&quot; alt=&quot;\frac{}{zero ~ \text{even}} \tag{2.8a}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+~+%5Ctext%7Bodd%7D%7D%7Bsucc%28a%29+~+%5Ctext%7Beven%7D%7D+%5Ctag%7B2.8b%7D&quot; alt=&quot;\frac{a ~ \text{odd}}{succ(a) ~ \text{even}} \tag{2.8b}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+~+%5Ctext%7Beven%7D%7D%7Bsucc%28a%29+~+%5Ctext%7Bodd%7D%7D+%5Ctag%7B2.8c%7D&quot; alt=&quot;\frac{a ~ \text{even}}{succ(a) ~ \text{odd}} \tag{2.8c}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;类似地根据规则归纳，如果要证明对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Beven%7D&quot; alt=&quot;a ~ \text{even}&quot; eeimg=&quot;1&quot;/&gt; 有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Beven%7D%29&quot; alt=&quot;P(a ~ \text{even})&quot; eeimg=&quot;1&quot;/&gt; ，对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bodd%7D&quot; alt=&quot;a ~ \text{odd}&quot; eeimg=&quot;1&quot;/&gt; 有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bodd%7D%29&quot; alt=&quot;P(a ~ \text{odd})&quot; eeimg=&quot;1&quot;/&gt; ，只需要证明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28zero+~+%5Ctext%7Beven%7D%29&quot; alt=&quot;P(zero ~ \text{even})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bodd%7D%29&quot; alt=&quot;P(a ~ \text{odd})&quot; eeimg=&quot;1&quot;/&gt; 那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28succ%28a%29+~+%5Ctext%7Beven%7D%29&quot; alt=&quot;P(succ(a) ~ \text{even})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Beven%7D%29&quot; alt=&quot;P(a ~ \text{even})&quot; eeimg=&quot;1&quot;/&gt; 那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28succ%28a%29+~+%5Ctext%7Bodd%7D%29&quot; alt=&quot;P(succ(a) ~ \text{odd})&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;举一个最简单的例子，证明 (1) 如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Beven%7D&quot; alt=&quot;a ~ \text{even}&quot; eeimg=&quot;1&quot;/&gt; 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; ，(2) 如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bodd%7D&quot; alt=&quot;a ~ \text{odd}&quot; eeimg=&quot;1&quot;/&gt; 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; ：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.2a%29%7D&quot; alt=&quot;\text{(2.2a)}&quot; eeimg=&quot;1&quot;/&gt; 显然 &lt;img src=&quot;https://www.zhihu.com/equation?tex=zero+~+%5Ctext%7Bnat%7D&quot; alt=&quot;zero ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.2b%29%7D&quot; alt=&quot;\text{(2.2b)}&quot; eeimg=&quot;1&quot;/&gt; ，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bodd%7D&quot; alt=&quot;a ~ \text{odd}&quot; eeimg=&quot;1&quot;/&gt; 时有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28a%29+~+%5Ctext%7Bnat%7D&quot; alt=&quot;succ(a) ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.2b%29%7D&quot; alt=&quot;\text{(2.2b)}&quot; eeimg=&quot;1&quot;/&gt; ，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Beven%7D&quot; alt=&quot;a ~ \text{even}&quot; eeimg=&quot;1&quot;/&gt; 时有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=succ%28a%29+~+%5Ctext%7Bnat%7D&quot; alt=&quot;succ(a) ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因此得证。&lt;/p&gt;&lt;h2&gt;用规则定义函数&lt;/h2&gt;&lt;p&gt;归纳定义也经常被用来定义函数，这时只需要给出输入与输出的对应关系，并且证明输出是由输入唯一确定的即可。例如定义一个自然数的加法 $sum(a;b;c)$，表示 $c$ 为 $a$ 与 $b$ 的和：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Bb+~+%5Ctext%7Bnat%7D%7D%7Bsum%28zero%3Bb%3Bb%29%7D%5Ctag%7B2.9a%7D&quot; alt=&quot;\frac{b ~ \text{nat}}{sum(zero;b;b)}\tag{2.9a}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Bsum%28a%3Bb%3Bc%29%7D%7Bsum%28succ%28a%29%3Bb%3Bsucc%28c%29%29%7D%5Ctag%7B2.9b%7D&quot; alt=&quot;\frac{sum(a;b;c)}{sum(succ(a);b;succ(c))}\tag{2.9b}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这两条规则定义了一个自然数的三元关系，我们需要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 是由 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;/&gt; 确定的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理.&lt;/b&gt; 对于任意的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 都存在唯一的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 符合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;&lt;i&gt;证明&lt;/i&gt;：这里的证明分为两个部分：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;（存在性）如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; ，存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;li&gt;（唯一性）如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%27%29&quot; alt=&quot;sum(a;b;c&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c%3Dc%27&quot; alt=&quot;c=c&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;存在性：设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(a ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; 的含义为 对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;/&gt; 为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7Bzero%7D&quot; alt=&quot;\text{zero}&quot; eeimg=&quot;1&quot;/&gt; 时，根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.9a%29%7D&quot; alt=&quot;\text{(2.9a)}&quot; eeimg=&quot;1&quot;/&gt; 显然成立，此时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c+%3D+b&quot; alt=&quot;c = b&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/li&gt;&lt;li&gt;假设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(a ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; 成立，需要证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28succ%28a%29+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(succ(a) ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; 成立，即对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28succ%28a%29%3Bb%3Bc%29&quot; alt=&quot;sum(succ(a);b;c)&quot; eeimg=&quot;1&quot;/&gt; 。因为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a+~+%5Ctext%7Bnat%7D%29&quot; alt=&quot;P(a ~ \text{nat})&quot; eeimg=&quot;1&quot;/&gt; ，因此对于这个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;/&gt; 存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c%27&quot; alt=&quot;c&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%27%29&quot; alt=&quot;sum(a;b;c&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; 。根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.9b%29%7D+&quot; alt=&quot;\text{(2.9b)} &quot; eeimg=&quot;1&quot;/&gt; 有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28succ%28a%29%3Bb%3Bsucc%28c%27%29%29&quot; alt=&quot;sum(succ(a);b;succ(c&amp;#39;))&quot; eeimg=&quot;1&quot;/&gt; ，因此可令 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c%3Dsucc%28c%27%29&quot; alt=&quot;c=succ(c&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;唯一性：我们证明如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc_1%29&quot; alt=&quot;sum(a;b;c_1)&quot; eeimg=&quot;1&quot;/&gt; 与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc_2%29&quot; alt=&quot;sum(a;b;c_2)&quot; eeimg=&quot;1&quot;/&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1+%3D+c_2+~+%5Ctext%7Bnat%7D&quot; alt=&quot;c_1 = c_2 ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+%5Ctext%7Bzero%7D&quot; alt=&quot;a = \text{zero}&quot; eeimg=&quot;1&quot;/&gt; 时，根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.9a%29%7D+&quot; alt=&quot;\text{(2.9a)} &quot; eeimg=&quot;1&quot;/&gt; 有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1+%3D+b&quot; alt=&quot;c_1 = b&quot; eeimg=&quot;1&quot;/&gt; 与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_2+%3D+b&quot; alt=&quot;c_2 = b&quot; eeimg=&quot;1&quot;/&gt; 。根据前面的引理可得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1+%3D+c_2&quot; alt=&quot;c_1 = c_2&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/li&gt;&lt;li&gt;设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%27%3Bb%3Bc_1%27%29&quot; alt=&quot;sum(a&amp;#39;;b;c_1&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+succ%28a%27%29&quot; alt=&quot;a = succ(a&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1+%3D+succ%28c_1%27%29&quot; alt=&quot;c_1 = succ(c_1&amp;#39;)&quot; eeimg=&quot;1&quot;/&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc_2%29&quot; alt=&quot;sum(a;b;c_2)&quot; eeimg=&quot;1&quot;/&gt; ，根据 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctext%7B%282.9b%29%7D+&quot; alt=&quot;\text{(2.9b)} &quot; eeimg=&quot;1&quot;/&gt; 有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28succ%28a%27%29%3Bb%3Bsucc%28c_1%27%29%29&quot; alt=&quot;sum(succ(a&amp;#39;);b;succ(c_1&amp;#39;))&quot; eeimg=&quot;1&quot;/&gt; ，即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc_1%29&quot; alt=&quot;sum(a;b;c_1)&quot; eeimg=&quot;1&quot;/&gt; ，因为它们来源于同一条规则所以 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1+%3D+c_2&quot; alt=&quot;c_1 = c_2&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;模式&lt;/h2&gt;&lt;p&gt;在一条判断中，一些参数是由另外参数决定的，这被称为判断的 &lt;i&gt;模式声明&lt;/i&gt;。例如自然数加法 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 具有模式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cforall%2C+%5Cforall%2C+%5Cexists%29&quot; alt=&quot;(\forall, \forall, \exists)&quot; eeimg=&quot;1&quot;/&gt; 。它表示对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 与任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 都存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 。如果要说明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 是唯一确定的，就写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cforall%2C%5Cforall%2C%5Cexists%21%29&quot; alt=&quot;(\forall,\forall,\exists!)&quot; eeimg=&quot;1&quot;/&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 不一定存在，写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cforall%2C%5Cforall%2C%5Cexists%5E%7B%5Cle1%7D%29&quot; alt=&quot;(\forall,\forall,\exists^{\le1})&quot; eeimg=&quot;1&quot;/&gt; ，意为对于任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+~+%5Ctext%7Bnat%7D&quot; alt=&quot;a ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; 与任意 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+~+%5Ctext%7Bnat%7D&quot; alt=&quot;b ~ \text{nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;b&gt;最多&lt;/b&gt;存在一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=sum%28a%3Bb%3Bc%29&quot; alt=&quot;sum(a;b;c)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;可以看到，一条判断可能同时满足多个模式声明。一般来说，全称量词修饰的参数被当做是输入，而存在量词修饰的参数当做输出。但是一般会有一个我们希望的主要的模式，一般使用等号来表达输入和输出的关系，例如重新定义加法：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+~+%5Ctext%7Bnat%7D%7D%7Ba+%2B+zero+%3D+a+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.10a%7D&quot; alt=&quot;\frac{a ~ \text{nat}}{a + zero = a ~ \text{nat}} \tag{2.10a}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Ba+%2B+b+%3D+c+~+%5Ctext%7Bnat%7D%7D%7Ba+%2B+succ%28b%29+%3D+succ%28c%29+~+%5Ctext%7Bnat%7D%7D+%5Ctag%7B2.10b%7D&quot; alt=&quot;\frac{a + b = c ~ \text{nat}}{a + succ(b) = succ(c) ~ \text{nat}} \tag{2.10b}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;用这种方式表示等号右侧的参数是由左边的参数决定的。当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%2B+b+%3D+c+~+%5Ctext%7Bnat%7D+&quot; alt=&quot;a + b = c ~ \text{nat} &quot; eeimg=&quot;1&quot;/&gt; 时，可以直接使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%2B+b&quot; alt=&quot;a + b&quot; eeimg=&quot;1&quot;/&gt; 来表示 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c&quot; alt=&quot;c&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;这部分介绍了归纳定义以及它的一些使用。我们不仅可以使用归纳的方法定义一些判断，同时还可以使用归纳的方法证明它们的一些性质。其中基于自然数定义的归纳方法就是通常情况下所说的数学归纳法，另外还可以通过类似的方法把归纳法推广到任何拥有类似结构的定义，如上面提到的树形归纳和相互归纳。归纳定义也可以用来定义函数，一条判断中的一些参数可能由另一些参数决定，它们分别可以看成函数的输入与输出，这些性质决定了它符合哪些模式声明。&lt;/p&gt;</description>
<author>Means88</author>
<guid isPermaLink="false">2019-05-03-64552881</guid>
<pubDate>Fri, 03 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>下一代编程语言范式？</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-03-64492626.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64492626&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5b3d234fd8d6654988fc9ae93ea1dda4_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;前言&lt;/b&gt;&lt;/p&gt;&lt;p&gt;最近状态不太好，有点懒，啥都不想干（可能发现自己岁数大了，有点闹情绪－ －|||）。想出去玩，风太大了，电视剧和动漫也看得“呕心沥血”了，因此切换下思路，就看了看下面这篇文章。我简单念叨念叨，大家看看就好，有想法的就想一想。&lt;/p&gt;&lt;p&gt;&lt;b&gt;正题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;PL知名学者Yannis Smaragdakis教授前两天在他的主页上放了一篇挺有意思的paper draft，题目是&lt;/p&gt;&lt;blockquote&gt;“Next-Paradigm Programming Languages: &lt;br/&gt;What Will They Look Like and What Changes Will They Bring?”&lt;/blockquote&gt;&lt;p&gt;嗯，题目有点大。&lt;/p&gt;&lt;p&gt;简单介绍一下这篇文章作者的背景。&lt;/p&gt;&lt;p&gt;Yannis这个人呢，是个实用语言主义者，他以前是美国佐治亚理工的教授，后来去了马萨诸塞(UMass)做教授，貌似12年左右被希腊引进回国了，现在是雅典大学的教授。他在PL的理论和应用方面都有所涉猎，具体研究内容如下所示。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Program analysis&lt;/b&gt; (static analysis, test generation, invariant inference, symbolic execution)&lt;br/&gt;&lt;b&gt;Language mechanisms for abstraction&lt;/b&gt; (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming)&lt;br/&gt;&lt;b&gt;Languages and tools for systems&lt;/b&gt; (programming models for concurrency, language support for distributed computing, memory management and program locality)&lt;/blockquote&gt;&lt;p&gt;最近10年，Yannis主要在基础程序分析方面建树较大。他是前ACM SIGPLAN 执行委员会的成员，OOPSLA&amp;#39;16的PC Chair，TOSEM的Editor，SPLASH&amp;#39;19的GC。主页在这里：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//yanniss.github.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://yanniss.github.io&lt;/a&gt;（介绍这么多是想说，他这篇文章，尽管题目大且显而易见没有标准答案，但是还是可以看一看，想一想，引发一些思考的）&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;接下来，为了方便理解题目，我先简单介绍一下编程语言范式（Programming Paradigm）。&lt;/p&gt;&lt;p&gt;实际上，我理解编程语言的范式主要有三种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Imperative Programming (IP) 命令式编程&lt;/li&gt;&lt;li&gt;Functional Programming (FP) 函数式编程&lt;/li&gt;&lt;li&gt;Logic Programming (LP) 逻辑式编程&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;简单来说&lt;/p&gt;&lt;p&gt;&lt;b&gt;IP基于时序&lt;/b&gt;：在IP中，指令一个一个给出，用条件、循环等来控制逻辑（指令执行的顺序），同时这些逻辑通过程序变量不断修改程序状态，最终计算出结果。我觉得，尽管IP现在都是高级语言了，但是本质上并没有太脱离那种“类似汇编的，通过读取、写入等指令操作内存数据”的编程方式。也许是C语言的成功和后续历史的机缘巧合，让程序员们不断适应了这种编程方式吧。国内高等教育中接触的绝大多数编程语言都是IP的，比如Java, C, C++等。&lt;/p&gt;&lt;p&gt;&lt;b&gt;FP基于抽象：&lt;/b&gt;在FP中，逻辑（用函数来表达）可以像数据一样抽象起来，复杂的逻辑（高阶函数）可以通过操纵（传递、调用、返回）简单的逻辑（低阶函数）和数据来表达，没有了时序与状态，隐藏了计算的很多细节。不同的逻辑因为没有被时序和状态耦合在一起，程序本身模块化更强，也更利于不同逻辑被并行的处理。（我应该举个栗子的，但是我懒，见前言）&lt;/p&gt;&lt;p&gt;&lt;b&gt;LP基于表达：&lt;/b&gt;LP抽象的能力就更强了，计算细节干脆不见了。把你想表达的逻辑直观说出来就好了：如，“第三代火影的徒弟” 且 不是“女性” 且 “其徒弟也是火影” ==&amp;gt; ”自来也“。嗯，学会”与或非“，编程都不怕。 &lt;/p&gt;&lt;p&gt;总结一下就是IP强调计算的过程，而FP和LP更倾向于表达计算的目的（其中FP和LP抽象计算的方式不同）。由于IP比FP、LP对计算细节的把控能力更强，它常常能表达并实现出更高性能的计算。相应的，FP和LP因为抽象能力更好，在表达很多复杂计算时会更方便和简洁。当然，很多流行的编程语言都是将它们不同的能力结合起来设计使用的，其中IP和FP结合比较常见，例如JavaScript, Python, Scala等，Java 8之后也有一些糖化FP的改进了。至于IP、FP与LP的结合也有，但据我所知并不多。&lt;/p&gt;&lt;p&gt;我不太喜欢将”面向对象“（OO）也说成是一种单独的编程语言范式（貌似Martin Odersky也是这个观点），因为我觉得把OO加进来就很难特征鲜明地区分语言类别了（实际上OO可以分别和上述三类语言范式结合起来）。当然，讨论这个意义不大，学界也没有统一论调，你说它是也是可以的，能够方便交流就好。&lt;/p&gt;&lt;p&gt;以上是一些背景。&lt;/p&gt;&lt;p&gt;“Next-Paradigm Programming Languages”这篇文章，虽然通篇拿Datalog语言来举例子，但是我觉得其观点和很多内容也适用其它语言。文章不是特别容易理解，这里我把最核心的几个观点拿出来总结一下，按照我的理解描述一下，方便大家参考。&lt;/p&gt;&lt;p&gt;文章在介绍中就先给出了“免死金牌”，作者说：&lt;/p&gt;&lt;blockquote&gt;下一代编程语言范式可能是基于那种通过训练大规模代码实例的“机器学习或统计技术”，或者是通过符号推理和复杂约束求解的“程序生成技术”，或者是在大规模计算和存储能力下的新的“高阶语言设计技术”，或者很多其他技术...... &lt;br/&gt;但是，无论这些未来编程范式基于什么技术，作者觉得一些基本的原则是不可避免的，他这篇文章就是来阐述这些所谓的基本原则（Principles）&lt;/blockquote&gt;&lt;p&gt;嗯，作者在说，他并不是在预测下一代编程语言范式到底是什么（所以你不用因为不同意而激动），他只是根据过去20年来对编程语言研究和使用的经验，总结一些他觉得下一代编程语言范式可能需要具备的基本原则。&lt;/p&gt;&lt;p&gt;那么都有哪些原则呢？&lt;/p&gt;&lt;p&gt;原则1&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Principle 1&lt;/b&gt; (&lt;b&gt;Productivity and Performance Tied Together&lt;/b&gt;). &lt;br/&gt;If a language can give orders-of-magnitude improvements in &lt;b&gt;productivity&lt;/b&gt; then its implementation has the potential for orders-of-magnitude changes in &lt;b&gt;performance&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;作者进一步解释到&lt;/p&gt;&lt;blockquote&gt;Large variations in both productivity and performance are functions of a language being abstract. Neither is possible with the current, ultra-concrete mainstream languages. &lt;b&gt;If one needs to explicitly specify “loops and arrays”, neither large productivity gains, nor large performance variations are possible&lt;/b&gt;. Instead, the language implementation (or “compiler” for short) of a high-productivity, next-paradigm language will likely be able to effect orders-of-magnitude performance differences via dynamic or static optimization.&lt;/blockquote&gt;&lt;p&gt;我简单解释一下，作者觉得，下一代编程范式应该是侧重“高生产力”（high-productivity）的，即“编程应该是越来越容易的”，进而“编程开发效率是越来越高的”。他说如果一个编程语言让程序员显示地规定“循环和数组”应该怎么设计使用，那么这个语言既不能高效（high-productivity），也不会容许程序的性能有太大的改变空间（毕竟数据结构和执行逻辑都被程序员定死了）。&lt;/p&gt;&lt;p&gt;我个人觉得作者在这里就是剑指Imperative Programming（IP）的，他可能觉得IP的这种编程方式没法让程序员从编程中解放生产力（“生产力是编程发展的第一要素”，嗯，我从他全文中都嗅出这样的口号，虽然他没说的那么直白...）。作者觉得，编程语言应该抽象得易于使用（嗯，这里他应该是在更偏向于Functional和Logic Programming，我觉得LP更多一些），很多实现的细节应该交由以后的Compiler来自动地处理，这里的Compiler作者是一个泛指，它可能包括&lt;b&gt;interpreter&lt;/b&gt; or &lt;b&gt;compiler&lt;/b&gt; (ahead-of-time or just-int-time) and a &lt;b&gt;runtime system&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，有了下面的见解&lt;/p&gt;&lt;blockquote&gt;Programs ≠ Algorithms + Data Structures. Instead,&lt;br/&gt;Compiler(Program) = Algorithms + Data Structures&lt;/blockquote&gt;&lt;p&gt;总结一下原则1就是，下一代编程语言范式应该注重High-productivity和Convenient编程，程序的性能在当今“丰富计算能力和资源”的背景下，可以让语言实现系统本身（如上面提到的Compiler）来发挥，进而解放编程生产力。&lt;/p&gt;&lt;p&gt;原则2&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Principle 2&lt;/b&gt; (&lt;b&gt;Need For Firm Mental Grounding&lt;/b&gt;). &lt;br/&gt;The programming model of next-paradigm languages will offer strong semantic guarantees (about what code can do and how new code can affect old).&lt;/blockquote&gt;&lt;p&gt;原则2提出的背景，实际上也是基于原则1的。想象一下，一个编程语言如果使用起来高效方便，会不免依赖很多语言实现系统背后的自动化技术。这样一来，相比于传统语言编写的程序，程序的一点变动可能会变得更不可控。因此，语言和语言系统本身应该提供一下基本的Invariant和properties以让程序员在开发时对语言能做什么，改动之后有什么变化等问题有一定的了解甚至保证。&lt;/p&gt;&lt;p&gt;比如，Datalog就有很强的一种semantic invariant，那就是monotonicity。有了monotonicity，在程序中添加rules就保证不会invalidate先前rules的输出，由此，就可以通过local inspection来非常方便地理解和编写程序。下一代编程语言范式应该有更多有用的关于语言本身的semantic guarantees来支撑语言的易用性。&lt;/p&gt;&lt;p&gt;原则3&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Principle 3 &lt;/b&gt;(&lt;b&gt;Workflows Will Change&lt;/b&gt;). &lt;br/&gt;Next-paradigm programming languages will change well-established patterns in current programming workflow.&lt;/blockquote&gt;&lt;p&gt;选择什么样的编程语言实际上并不会从本质上影响传统的软件开发流程，比如需求分析，架构设计，编码实现，测试等等。然而，作者觉得，如果使用的是一个high-productivity和high-abstraction的编程语言，尽管软件开发流程整体不会受太大影响，但是这个流程的每一个环节会产生很大的变化。作者是这样解释的：&lt;/p&gt;&lt;blockquote&gt;Orders-of-magnitude productivity improvements will, very likely, disrupt the established workflow of program development&lt;b&gt;. Code will be much more terse and abstract, resembling a formal specification&lt;/b&gt;. Small changes will have a huge impact on both functionality and performance. It is hard to fully grasp precisely how today’s common practices will evolve.&lt;/blockquote&gt;&lt;p&gt;编码实现更接近于formal specification本身（开发更容易了），但是对于程序的调试、分析、测试会变得更有难度（可能更多依托于自动化技术）。不难看出，实际上原则3也是原则1的一个衍生物。我觉得作者是想说，在设计新的编程范式时，也应该考虑它对于整个软件开发过程的影响。&lt;/p&gt;&lt;p&gt;以上，就是文中系统阐述的下一代编程语言范式需要考虑的三个主要原则。&lt;/p&gt;&lt;p&gt;&lt;b&gt;我对于这篇文章的看法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;实际上，以我对作者的了解，他是倾向于将下一代编程语言范式向logic programming，比如Datalog靠拢的，毕竟他最近十多年一直在从事这方面的研究和工作。我在读博士的前几年也是用Datalog写分析器的，确实好用，把算法想清楚了，按照语言的语法语义写rules比较直观，不用纠结背后的数据结构和执行系统，把逻辑想清楚表达出来就好了。在这一方面我是支持作者观点的。&lt;/p&gt;&lt;p&gt;但是实际上也有一些弊端，比如，Datalog在表达部分逻辑时，例如universal quatification时就很不方便，需要通过negation来实现，当然，这一点是可以通过语言层面的，比如语法语义的改进来修补的。此外，因为不太明确执行Datalog的engine的执行顺序和原则，有的时候添加修改rules时会带来一些性能上的问题（虽然不多见，但是确实遇到过几次，很无奈）。如此一来，让我想到，如果程序员真的要编好这样的程序with high-producitivity，还需要理解好背后语言运行系统的执行策略，这本身就是一种对于解放编程生产力的束缚（虽然一旦摆脱了这种束缚，就有可能编的飞起...）&lt;/p&gt;&lt;p&gt;此外，我对于文中一些小的观点有些不同看法，比如Corollary 3.3关于Different balance of formal reasoning and coding（有兴趣的同学可以看一下，虽然code和specification更近了，但是这种alleviation的一部分是通过转嫁到对compiler和runtime system更heavy的reasoning而获得的）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;我关于下一代编程语言范式的看法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我倾向于主流imperative programming（IP）这种编程方式在以后会有较大的转变，因为很多应用下的程序，相比于逻辑，更多服务于数据，这样一部分需求可以被functional programming (FP) 或者 logic programming (LP) 更好的消化，实际上很多主流语言也支持或开始支持FP了（IP+FP）。我觉得随着一些新的需求和应用的出现，IP+LP或IP+FP+LP也会越来越多，估计会在一些专家领域或特别的应用中先出现。有的人可能会问，为什么新的语言范式都要加一个IP？因为利益啊，遗留的系统，遗留的知识，遗留的固守成规。。。至于说有没有可能有一种或几种全新的编程范式在未来出现并惠及天下，我的答案是当然。&lt;/p&gt;&lt;p&gt;说到这里又不得不惋惜一叹啊，希望咱们国家更重视一下编程语言的教育和科研，每年输出这么多程序员，每年又输入这么多对编程好奇、感兴趣的学生，于国于民，千秋万代啊。&lt;/p&gt;&lt;p&gt;嗯，就唠叨这么多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>啥玩应啊</author>
<guid isPermaLink="false">2019-05-03-64492626</guid>
<pubDate>Fri, 03 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Haskell的生成OpenCL调用代码的实践</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-01-64420931.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64420931&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b062ca1c4dce747076060362eabda24b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;这是一篇关于Haskell在日常开发过程中的实践的文章，主要介绍了Haskell在代码生成方面的实现和使用。&lt;/p&gt;&lt;p&gt;现在常用的高性能计算中，使用GPU来加速是一种非常重要的方法，而OpenCL因为其良好的跨平台特性，可以在Windows、Linux、macOS、Android和嵌入式Linux系统上使用，可以在多种硬件平台上运行，比如AMD、Nvidia、高通、ARM mali的GPU上运行，甚至可以在FPGA上运行。因此，在工程实践中大量使用OpenCL来实现并行化的高性能计算。&lt;/p&gt;&lt;p&gt;当我们在写一个需要大量使用OpenCL来加速计算的项目时，会有很多个OpenCL的kernel函数来实现这些并行化的加速计算。这个时候我们就需要写大量的调用OpenCL的kernel函数的代码，而且这些代码都是很机械的设置kernel的参数，然后调用函数clEnqueueNDRangeKernel。如下所示：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;cl_int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clSetKernelArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cl_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clSetKernelArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cl_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clSetKernelArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cl_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clSetKernelArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intt32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clSetKernelArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intt32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;chk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;matrixMul&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clEnqueueNDRangeKernel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matrixMul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;globalSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;localSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;chk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;matrixMul clEnqueueNDRangeKernel&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;写这些代码是很枯燥乏味的，那有没有工具可以自动生成这些代码呢？我看了不少工程项目，都没有使用自动生成代码的方式，也没有找到这样的工具。于是就决定自己做一个这样的工具，而Haskell有一个很好用的C/C++语言解析的包，是language-c，这是一个历史悠久的包，里面的作者都是Haskell的高手。但是这个language-c的包目前不支持OpenCL的解析，我看了一下代码，觉得可以自己加上支持OpenCL的解析的功能。于是就花了几个晚上修改了language-c的代码，顺利的增加了OpenCL解析的功能。&lt;/p&gt;&lt;p&gt;有了language-c的支持后，接下来就开始写解析OpenCL的kernel源代码的*.cl文件并生成上面的调用OpenCL的kernel函数的代码了。得益于language-c的良好设计，并参考了一个解析C语言的范例，很快就写好了这个工具的代码。加上脚本的配合，现在已经可以从kernel源代码的*.cl文件自动生成调用OpenCL的kernel函数的代码了。&lt;/p&gt;&lt;p&gt;使用如下从这个链接&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.olcf.ornl.gov/tutorials/opencl-game-of-life/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;olcf.ornl.gov/tutorials&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/opencl-game-of-life/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;拿到的GOL-kernels.cl文件，这个文件如下所示：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;n&quot;&gt;__kernel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ghostRows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;__global&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// We want id to range from 1 to dim
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_global_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Copy first real row to bottom ghost row
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Copy last real row to top ghost row
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;n&quot;&gt;__kernel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ghostCols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;__global&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// We want id to range from 0 to dim+1
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_global_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Copy first real column to right most ghost column
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Copy last real column to left most ghost column
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;n&quot;&gt;__kernel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;__global&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;__global&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_global_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_global_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Get the number of neighbors for a given grid point
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//upper lower
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;                 &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;//right left
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;                 &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//diagonals
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;                 &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt;
 
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Here we have explicitly all of the game rules
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numNeighbors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newGrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用这个工具后，可以生成如下的OpenCL的kernel的调用代码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;stdint.h&amp;gt;

int oclGOL(
	cl_command_queue command_queu,
	const size_t* globalSize,
	const size_t* localSize,
	intt32_t dim,
	cl_mem grid,
	cl_mem newGrid)
{
	cl_int status = 0;

	status |= clSetKernelArg(GOL, 0, sizeof(intt32_t), &amp;amp;dim);
	status |= clSetKernelArg(GOL, 1, sizeof(cl_mem), &amp;amp;grid);
	status |= clSetKernelArg(GOL, 2, sizeof(cl_mem), &amp;amp;newGrid);
	chk(status, &amp;#34;GOL&amp;#34;);

#ifdef DEBUG_KERNEL
	cl_event debug_event;
	status = clEnqueueNDRangeKernel(command_queue, GOL,
		2, NULL, globalSize, localSize, 0, NULL, &amp;amp;debug_event);
	chk(status, &amp;#34;GOL clEnqueueNDRangeKernel&amp;#34;);
	CheckKernelEvent(debug_event, &amp;#34;GOL&amp;#34;);
	clReleaseEvent(debug_event);
#else
	status = clEnqueueNDRangeKernel(command_queue, GOL,
		2, NULL, globalSize, localSize, 0, NULL, NULL);
	chk(status, &amp;#34;GOL clEnqueueNDRangeKernel&amp;#34;);
#endif
	return (int)status;
}

int oclghostCols(
	cl_command_queue command_queu,
	const size_t* globalSize,
	const size_t* localSize,
	intt32_t dim,
	cl_mem grid)
{
	cl_int status = 0;

	status |= clSetKernelArg(ghostCols, 0, sizeof(intt32_t), &amp;amp;dim);
	status |= clSetKernelArg(ghostCols, 1, sizeof(cl_mem), &amp;amp;grid);
	chk(status, &amp;#34;ghostCols&amp;#34;);

#ifdef DEBUG_KERNEL
	cl_event debug_event;
	status = clEnqueueNDRangeKernel(command_queue, ghostCols,
		2, NULL, globalSize, localSize, 0, NULL, &amp;amp;debug_event);
	chk(status, &amp;#34;ghostCols clEnqueueNDRangeKernel&amp;#34;);
	CheckKernelEvent(debug_event, &amp;#34;ghostCols&amp;#34;);
	clReleaseEvent(debug_event);
#else
	status = clEnqueueNDRangeKernel(command_queue, ghostCols,
		2, NULL, globalSize, localSize, 0, NULL, NULL);
	chk(status, &amp;#34;ghostCols clEnqueueNDRangeKernel&amp;#34;);
#endif
	return (int)status;
}

int oclghostRows(
	cl_command_queue command_queu,
	const size_t* globalSize,
	const size_t* localSize,
	intt32_t dim,
	cl_mem grid)
{
	cl_int status = 0;

	status |= clSetKernelArg(ghostRows, 0, sizeof(intt32_t), &amp;amp;dim);
	status |= clSetKernelArg(ghostRows, 1, sizeof(cl_mem), &amp;amp;grid);
	chk(status, &amp;#34;ghostRows&amp;#34;);

#ifdef DEBUG_KERNEL
	cl_event debug_event;
	status = clEnqueueNDRangeKernel(command_queue, ghostRows,
		2, NULL, globalSize, localSize, 0, NULL, &amp;amp;debug_event);
	chk(status, &amp;#34;ghostRows clEnqueueNDRangeKernel&amp;#34;);
	CheckKernelEvent(debug_event, &amp;#34;ghostRows&amp;#34;);
	clReleaseEvent(debug_event);
#else
	status = clEnqueueNDRangeKernel(command_queue, ghostRows,
		2, NULL, globalSize, localSize, 0, NULL, NULL);
	chk(status, &amp;#34;ghostRows clEnqueueNDRangeKernel&amp;#34;);
#endif
	return (int)status;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样我们就可以直接调用这些封装好的OpenCL的kernel的调用函数，直接传入C/C++中的普通的参数即可。当有大量（好几十个）的kernel函数需要调用时，可以让我们少写很多这种枯燥无味的调用OpenCL的kernel的代码，减少写这些代码的时间，并且不会在参数较多的情况下出现参数设置错误的情况，正确性有保障。&lt;/p&gt;&lt;p&gt;这个工具的实现比较简单，总共只有195行代码。首先，写一个handler，响应language-c中解析*.cl文件时的事件。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;usage&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;give file to parse&amp;#34;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;opts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;c_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;liftM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getArgs&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compiler&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newGCC&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;gcc&amp;#34;&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;ast&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseCFile&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compiler&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;opts&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;c_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;checkResult&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;[parsing]&amp;#34;&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;runTrav&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withExtDeclHandler&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;analyseAST&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
         &lt;span class=&quot;kt&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;errs&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;errors: &amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;concat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;errToString&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;errs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
         &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;header&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;takeWhile&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;takeBaseName&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;c_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                    &lt;span class=&quot;nf&quot;&gt;mapM_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;putStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;outputFunDef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;userState&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                    &lt;span class=&quot;nf&quot;&gt;putStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;footer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;funName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;userState&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;handler函数如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DeclEvent&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Trav&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DeclEvent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FunctionDef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;FunctionDef not implemented&amp;#34;&lt;/span&gt;
           &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DeclEvent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Declaration&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;VarDecl&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;varName&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;declAttr&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getVarDecl&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;d&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FunctionType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FunType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isVaradic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;makeOclCallFun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asS&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;varName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isVaradic&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                  &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
                       &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
                       &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;modifyUserState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                     &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，通过函数makeOclCallFun生成中间的OclCallDef数据结构&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallParamType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;OclCallParam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;makeOclCallFun&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ParamDecl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Attributes&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;makeOclCallFun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isVaradic&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;attrs&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rtype&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;s&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;toOclCallDef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;traverse&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getOclCallParam&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;toOclCallDef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ps&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ps&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;rtype&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;oclParamType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnType&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，搜集到所有的OclCallDef后，通过函数outputFunDef生成调用OpenCL的kernel的C代码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;outputFunDef&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;outputFunDef&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;OclCallDef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;int ocl&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; 
  &lt;span class=&quot;s&quot;&gt;&amp;#34;cl_command_queue command_queu,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;const size_t* globalSize,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;const size_t* localSize,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;intercalate&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;{&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;cl_int status = 0;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;concat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printSetKernelArg&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;chk(status, &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#ifdef DEBUG_KERNEL&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;cl_event debug_event;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;status = clEnqueueNDRangeKernel(command_queue, &amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2, NULL, globalSize, localSize, 0, NULL, &amp;amp;debug_event);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;chk(status, &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34; clEnqueueNDRangeKernel&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;CheckKernelEvent(debug_event, &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;clReleaseEvent(debug_event);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;#else&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;status = clEnqueueNDRangeKernel(command_queue, &amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2, NULL, globalSize, localSize, 0, NULL, NULL);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;chk(status, &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34; clEnqueueNDRangeKernel&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;#endif&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;return (int)status;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Haskell在代码生成方面还是比较好用的，有着很多好用的基础库，可以很方便的写出类似的代码生成的功能。&lt;/p&gt;</description>
<author>parker liu</author>
<guid isPermaLink="false">2019-05-01-64420931</guid>
<pubDate>Wed, 01 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Evolvable Programming</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-01-64386866.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64386866&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：这跟genetic programming毫无关系。&lt;/p&gt;&lt;p&gt;最近，我有一个任务：我要写一个Partial Evaluator。&lt;/p&gt;&lt;p&gt;更具体的，这是个Simply Typed Lambda Calculus加上Reference/ADT的Partial Evaluator（PE）。Lambda Calculus上的PE很多人都做过，但是加上Reference就不好办了。我找了很多Scheme/ML的PE的paper，但是在里面，很多都对Effect闭口不提。就算提Effect，也是‘遇到Effect不做PE，跳过就好’。&lt;/p&gt;&lt;p&gt;没办法，我只好自己设计。凭借着我对Partial Evaluation跟Staging的理解，我弄了一个这样的设计：&lt;/p&gt;&lt;p&gt;0：我们先写一个Definitional Interpreter。&lt;/p&gt;&lt;p&gt;1：我们reify the Store。&lt;/p&gt;&lt;p&gt;2：我们利用MetaOCaml式的LetList写一个ANF converter。&lt;/p&gt;&lt;p&gt;3：我们把Definitional Interpreter的Value lift上Partially Static Domain，然后跟ANF converter‘合并’- 这样，Partially Evaluated Code会生成ANF代码，于是就没有code duplication跟capture avoidance substitution的问题。&lt;/p&gt;&lt;p&gt;别急，我们来一步步来看这是啥意思。&lt;/p&gt;&lt;blockquote&gt;0：我们先写一个Definitional Interpreter。&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type (&amp;#39;a, &amp;#39;b) sum = Left of &amp;#39;a | Right of &amp;#39;b

type var = Var of int

type term =
  | Let of (var * term * term)
  | FromVar of var
  | Abs of (var * term)
  | App of (term * term)
  | Unit
  | Int of int
  | Add of (term * term)
  | Mult of (term * term)
  | IfZero of (term * term * term)
  | MkProd of (term * term)
  | Zro of term
  | Fst of term
  | MkRef of term
  | SetRef of (term * term)
  | GetRef of term
  | TLeft of term
  | TRight of term
  | Match of term * term * term

type &amp;#39;a env = int -&amp;gt; &amp;#39;a

let emptyStore _ = raise Not_found

let extend e v x = function i when i == v -&amp;gt; x | i -&amp;gt; e i

let genCounter () =
  let cnt = ref 0 in
  let gen () =
    let ret = !cnt in
    cnt := ret + 1 ;
    ret
  in
  gen

let freshVar = genCounter ()

type value =
  | VFun of (value -&amp;gt; value)
  | VUnit
  | VInt of int
  | VProd of value * value
  | VRef of value ref
  | VSum of (value, value) sum

(* The standard metacircular evaluator. *)
let rec evalAux (e : value env) : term -&amp;gt; value =
  let recurse t = evalAux e t in
  let app x y = match x with VFun f -&amp;gt; f y in
  function
  | Let (Var var, v, body) -&amp;gt;
      let rv = recurse v in
      evalAux (extend e var rv) body
  | FromVar (Var v) -&amp;gt; e v
  | Abs (Var v, b) -&amp;gt; VFun (fun p -&amp;gt; evalAux (extend e v p) b)
  | App (f, x) -&amp;gt; app (recurse f) (recurse x)
  | Unit -&amp;gt; VUnit
  | Int f -&amp;gt; VInt f
  | Add (x, y) -&amp;gt; (
      let rx = recurse x in
      let ry = recurse y in
      match (rx, ry) with VInt x, VInt y -&amp;gt; VInt (x + y) )
  | Mult (x, y) -&amp;gt; (
      let rx = recurse x in
      let ry = recurse y in
      match (rx, ry) with VInt x, VInt y -&amp;gt; VInt (x * y) )
  | IfZero (i, z, nz) -&amp;gt; (
    match recurse i with VInt 0 -&amp;gt; recurse z | VInt _ -&amp;gt; recurse nz )
  | MkProd (x, y) -&amp;gt;
      let rx = recurse x in
      let ry = recurse y in
      VProd (rx, ry)
  | Zro x -&amp;gt; ( match recurse x with VProd (x, _) -&amp;gt; x )
  | Fst x -&amp;gt; ( match recurse x with VProd (_, y) -&amp;gt; y )
  | MkRef x -&amp;gt; VRef (ref (recurse x))
  | SetRef (r, v) -&amp;gt; (
      let vr = recurse r in
      let vv = recurse v in
      match vr with VRef r -&amp;gt;
        r := vv ;
        VUnit )
  | GetRef r -&amp;gt; ( match recurse r with VRef r -&amp;gt; !r )
  | TLeft x -&amp;gt; VSum (Left (recurse x))
  | TRight x -&amp;gt; VSum (Right (recurse x))
  | Match (s, lcase, rcase) -&amp;gt; (
      let ps = recurse s in
      let pl = recurse lcase in
      let pr = recurse rcase in
      match ps with VSum (Left x) -&amp;gt; app pl x | VSum (Right x) -&amp;gt; app pr x )

let eval = evalAux emptyStore&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就是个标准，中规中矩的Definitional Interpreter。&lt;/p&gt;&lt;blockquote&gt;1：我们reify the Store。&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let freshStoreId = genCounter ()

type storeId = StoreId of int

type rValue =
  | RFun of (rValue -&amp;gt; rValue)
  | RUnit
  | RInt of int
  | RProd of rValue * rValue
  | RRef of storeId
  | RSum of (rValue, rValue) sum

(* The evaluator, but with the store reified -
   it is now represented and manipulated explicitly. *)
let rec rEvalAux (curStore : rValue env ref) (e : rValue env) : term -&amp;gt; rValue
    =
  let recurse t = rEvalAux curStore e t in
  let app x y = match x with RFun f -&amp;gt; f y in
  function
  | Let (Var var, v, body) -&amp;gt;
      let rv = recurse v in
      rEvalAux curStore (extend e var rv) body
  | FromVar (Var v) -&amp;gt; e v
  | Abs (Var v, b) -&amp;gt; RFun (fun p -&amp;gt; rEvalAux curStore (extend e v p) b)
  | App (f, x) -&amp;gt; app (recurse f) (recurse x)
  | Unit -&amp;gt; RUnit
  | Int f -&amp;gt; RInt f
  | Add (x, y) -&amp;gt; (
      let rx = recurse x in
      let ry = recurse y in
      match (rx, ry) with RInt x, RInt y -&amp;gt; RInt (x + y) )
  | Mult (x, y) -&amp;gt; (
      let rx = recurse x in
      let ry = recurse y in
      match (rx, ry) with RInt x, RInt y -&amp;gt; RInt (x * y) )
  | IfZero (i, z, nz) -&amp;gt; (
    match recurse i with RInt 0 -&amp;gt; recurse z | RInt _ -&amp;gt; recurse nz )
  | MkProd (x, y) -&amp;gt;
      let rx = recurse x in
      let ry = recurse y in
      RProd (rx, ry)
  | Zro x -&amp;gt; ( match recurse x with RProd (x, _) -&amp;gt; x )
  | Fst x -&amp;gt; ( match recurse x with RProd (_, y) -&amp;gt; y )
  | MkRef x -&amp;gt;
      let rx = recurse x in
      let id = freshStoreId () in
      curStore := extend !curStore id rx ;
      RRef (StoreId id)
  | SetRef (r, v) -&amp;gt;
      let rr = recurse r in
      let rv = recurse v in
      (match rr with RRef (StoreId s) -&amp;gt; curStore := extend !curStore s rv) ;
      RUnit
  | GetRef r -&amp;gt; ( match recurse r with RRef (StoreId s) -&amp;gt; !curStore s )
  | TLeft x -&amp;gt; RSum (Left (recurse x))
  | TRight x -&amp;gt; RSum (Right (recurse x))
  | Match (s, lcase, rcase) -&amp;gt; (
      let rs = recurse s in
      let rl = recurse lcase in
      let rr = recurse rcase in
      match rs with RSum (Left x) -&amp;gt; app rl x | RSum (Right x) -&amp;gt; app rr x )

let rEval = rEvalAux (ref emptyStore) emptyStore&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们不用OCaml原生的reference，而是自己建一个数据结构来实现reference。reference的Value则从metalevel的reference，成为这个数据结构的一个索引。这就是reification的意思：我们把一个抽象的概念（heap）变成具体的代码（我们的reference的实现）。&lt;/p&gt;&lt;blockquote&gt;2：我们利用MetaOCaml式的LetList写一个ANF converter。&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(* letList bind complex expression to a simple variable,
   so one can construct some complex expression, and use it
   as a variable by storing a binding in the letlist. *)
type letList = (term -&amp;gt; term) ref

let withLetList f =
  let l = ref (fun x -&amp;gt; x) in
  let res = f l in
  !l res

let pushVar l v x =
  let lv = !l in
  l := fun t -&amp;gt; lv (Let (v, x, t))

let push l x =
  let v = Var (freshVar ()) in
  pushVar l v x ; FromVar v

(* Using the letList to do anf conversion by &amp;#39;running&amp;#39; the program in compile time. *)
let rec anfAux (l : letList) : term -&amp;gt; term =
  let recurse t = anfAux l t in
  function
  | Let (Var var, v, body) -&amp;gt;
      pushVar l (Var var) (recurse v) ;
      recurse body
  | FromVar (Var v) -&amp;gt; FromVar (Var v)
  | Abs (Var v, b) -&amp;gt; push l (Abs (Var v, withLetList (fun l -&amp;gt; anfAux l b)))
  | App (f, x) -&amp;gt; push l (App (recurse f, recurse x))
  | Unit -&amp;gt; Unit
  | Int f -&amp;gt; Int f
  | Add (x, y) -&amp;gt; push l (Add (recurse x, recurse y))
  | Mult (x, y) -&amp;gt; push l (Mult (recurse x, recurse y))
  | IfZero (i, z, nz) -&amp;gt; push l (IfZero (recurse i, recurse z, recurse nz))
  | MkProd (x, y) -&amp;gt; push l (MkProd (recurse x, recurse y))
  | Zro x -&amp;gt; push l (Zro (recurse x))
  | Fst x -&amp;gt; push l (Fst (recurse x))
  | MkRef x -&amp;gt; push l (MkRef (recurse x))
  | SetRef (r, v) -&amp;gt; push l (SetRef (recurse r, recurse v))
  | GetRef r -&amp;gt; push l (GetRef (recurse r))
  | TLeft x -&amp;gt; push l (TLeft (recurse x))
  | TRight x -&amp;gt; push l (TRight (recurse x))
  | Match (s, lcase, rcase) -&amp;gt;
      push l (Match (recurse s, recurse lcase, recurse rcase))

let anf x = withLetList (fun l -&amp;gt; anfAux l x)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ANF的意思是说代码中没有compound expression：1 + 2 + 3这样的代码不可能出现，而是需要写成let a = 1 + 2 in let b = a + 3 in b这样形式的。这样，我们的所有表达式都会有一个binding。（注：ANF容许let a = 1 + 2 in a + 3，但我们不容许，因为这样最后表达式没binding，不满足我们等下的需求）&lt;/p&gt;&lt;blockquote&gt;3：我们把Definitional Interpreter的Value lift上Partially Static Domain，然后。。。&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(* The partially-static value is just like value with store reified, but might be empty,
   and always come with a term that is semantically equivalent to the original expression.
   The term must not be a compound expression as it duplicate computation and effect. *)
type sValue =
  | SFun of (letList -&amp;gt; pValue -&amp;gt; pValue)
  | SUnit
  | SInt of int
  | SProd of pValue * pValue
  | SRef of storeId
  | SSum of (pValue, pValue) sum

and pValue = {pStatic: sValue option; dynVal: term}

let static s d = {pStatic= Some s; dynVal= d}

let staticInt i = static (SInt i) (Int i)

let dynamic d = {pStatic= None; dynVal= d}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;partially static data是partial evaluator界的一个常规操作，具体就是一个value可以是‘普通’的value（static），或者可以是代码（dynamic）。为了简化，我们强制一定有dynamic（dynVal）。这也同时保证一个value不会被多次转成code。同时，我们限制dynamic为atomic term - 也就是说，dynVal的term只能有场数大小。那复合term怎么样？存进LetList里。&lt;/p&gt;&lt;blockquote&gt;跟ANF converter‘合并’- 这样，Partially Evaluated Code会生成ANF代码，于是就没有code duplication跟capture avoidance substitution的问题。&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(* rEval on the static part(if exist), anf on the dynamic part.
   Will try to recurse aggressively to optimize even with value/control unknown.
   Must clear curStore when unknown code is executed, as the store is contaminated. *)
let rec peAux (curStore : pValue env ref) (e : pValue env) (l : letList) :
    term -&amp;gt; pValue =
  let recurse t = peAux curStore e l t in
  let app x y =
    match x.pStatic with
    | Some (SFun f) -&amp;gt; f l y
    | _ -&amp;gt;
        curStore := emptyStore ;
        dynamic (push l (App (x.dynVal, y.dynVal)))
  in
  function
  | Let (Var var, v, body) -&amp;gt;
      let pv = recurse v in
      pushVar l (Var var) pv.dynVal ;
      peAux curStore (extend e var pv) l body
  | FromVar (Var v) -&amp;gt; e v
  | Abs (Var v, b) -&amp;gt;
      static
        (SFun (fun l p -&amp;gt; peAux curStore (extend e v p) l b))
        (push l
           (Abs
              ( Var v
              , withLetList (fun l -&amp;gt;
                    (peAux (ref emptyStore)
                       (extend e v (dynamic (FromVar (Var v))))
                       l b)
                      .dynVal ) )))
  | App (f, x) -&amp;gt; app (recurse f) (recurse x)
  | Unit -&amp;gt; static SUnit Unit
  | Int f -&amp;gt; staticInt f
  | Add (x, y) -&amp;gt; (
      let px = recurse x in
      let py = recurse y in
      match (px.pStatic, py.pStatic) with
      | Some (SInt x), Some (SInt y) -&amp;gt; staticInt (x + y)
      | _ -&amp;gt; dynamic (push l (Add (px.dynVal, py.dynVal))) )
  | Mult (x, y) -&amp;gt; (
      let px = recurse x in
      let py = recurse y in
      match (px.pStatic, py.pStatic) with
      | Some (SInt x), Some (SInt y) -&amp;gt; staticInt (x * y)
      | _ -&amp;gt; dynamic (push l (Mult (px.dynVal, py.dynVal))) )
  | IfZero (i, z, nz) -&amp;gt; (
      let pi = recurse i in
      match pi.pStatic with
      | Some (SInt 0) -&amp;gt; recurse z
      | Some (SInt _) -&amp;gt; recurse nz
      | _ -&amp;gt;
          let res =
            dynamic
              (push l
                 (IfZero
                    ( pi.dynVal
                    , (peAux (ref !curStore) e l z).dynVal
                    , (peAux (ref !curStore) e l nz).dynVal )))
          in
          curStore := emptyStore ;
          res )
  | MkProd (x, y) -&amp;gt;
      let px = recurse x in
      let py = recurse y in
      static (SProd (px, py)) (push l (MkProd (px.dynVal, py.dynVal)))
  | Zro x -&amp;gt; (
      let px = recurse x in
      match px.pStatic with
      | Some (SProd (x, _)) -&amp;gt; x
      | _ -&amp;gt; dynamic (push l (Zro px.dynVal)) )
  | Fst x -&amp;gt; (
      let px = recurse x in
      match px.pStatic with
      | Some (SProd (_, y)) -&amp;gt; y
      | _ -&amp;gt; dynamic (push l (Fst px.dynVal)) )
  | MkRef x -&amp;gt;
      let px = recurse x in
      let id = freshStoreId () in
      curStore := extend !curStore id px ;
      static (SRef (StoreId id)) (push l (MkRef px.dynVal))
  | SetRef (r, v) -&amp;gt;
      let pr = recurse r in
      let pv = recurse v in
      let _ = push l (SetRef (pr.dynVal, pv.dynVal)) in
      ( match pr.pStatic with
      | Some (SRef (StoreId s)) -&amp;gt; curStore := extend !curStore s pv
      | _ -&amp;gt; curStore := emptyStore ) ;
      static SUnit Unit
  | GetRef r -&amp;gt; (
      let pr = recurse r in
      try
        match pr.pStatic with
        | Some (SRef (StoreId s)) -&amp;gt; !curStore s
        | _ -&amp;gt; raise Not_found
      with _ -&amp;gt; dynamic (push l (GetRef pr.dynVal)) )
  | TLeft x -&amp;gt;
      let px = recurse x in
      static (SSum (Left px)) (push l (TLeft px.dynVal))
  | TRight x -&amp;gt;
      let px = recurse x in
      static (SSum (Right px)) (push l (TRight px.dynVal))
  | Match (s, lcase, rcase) -&amp;gt; (
      let ps = recurse s in
      let pl = recurse lcase in
      let pr = recurse rcase in
      match ps.pStatic with
      | Some (SSum (Left x)) -&amp;gt; app pl x
      | Some (SSum (Right x)) -&amp;gt; app pr x
      | _ -&amp;gt;
          curStore := emptyStore ;
          dynamic (push l (Match (ps.dynVal, pl.dynVal, pr.dynVal))) )

let pe x = withLetList (fun l -&amp;gt; (peAux (ref emptyStore) emptyStore l x).dynVal)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;剩下的代码。当Definitional Interpreter可以跑的时候，用之simplify，否则就用ANF生成dynamic term。在执行未知代码的时候，我们会利用store被reify的特性，直接复制/清空 store。&lt;/p&gt;&lt;p&gt;你可以看到，在这个代码中，我们做了三件事：reify the store，然后跟ANF合并，最后，在一定情况special case，清空store。&lt;/p&gt;&lt;p&gt;但是，有一个问题：我们这个‘更改’，‘合并’，都是在语言外进行的，所以我们的代码中，也许不会有一个reified evaluator，但是一定会有一个简单的interpreter，会有一个ANF convertor，然后还需要特定的去写一个partial evaluator。&lt;/p&gt;&lt;p&gt;为什么我们不能在一个语言中，写一个evaluator，然后写‘对reference如此这般改一下’，得到一个reified evaluator，然后写一个ANF Convertor，然后写‘合并ANF跟rEval’，然后再写‘对lambda, if else，setref，match special case一下，清空store’？这几个步骤是毫无二义性的，也不需要任何搜索，应该可以做进语言啊。&lt;/p&gt;&lt;p&gt;如果在什么语言里面，的确可以这样写，请告诉我。&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//arxiv.org/abs/0910.2654&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MLPolyR&lt;/a&gt;好像能做一半，但是merge做不了。&lt;/p&gt;&lt;p&gt;再多说点，在静态分析（&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//matt.might.net/papers/might2006gcfa.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Abstract Garbage Collection&lt;/a&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//matt.might.net/papers/vanhorn2010abstract.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Abstracting Abstract Machine&lt;/a&gt;）里，往往会从一个Abstract Machine出发，一步步修改该Abstract Machine。Program Transformation（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.brics.dk/RS/01/23/BRICS-RS-01-23.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Defunctionalization At Work&lt;/a&gt;，The Algebra of Programming）里面，也会同样先出现一个简单的算法，然后一步步，通过各自手段（CPS Conversion，Defunctionalization，Fusion）得出最后的算法。这些估计更难做，但大体idea还是一样的。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2019-05-01-64386866</guid>
<pubDate>Wed, 01 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Philis的LLVM魔导书（1）：实现一个简单的Function Pass来优化你的IR</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-04-24-63568031.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/63568031&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-804f905d148966c695b4bd50c3a78db8_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;中文网络上能找到许多介绍LLVM的文章，但大多是概览类。这个系列的目的是用更加具体的实例来让对编译器知识有一定了解的读者掉入LLVM这个史瓦西半径甚大的坑。&lt;/p&gt;&lt;p&gt;比起内部组织形式晦涩难懂的gcc，优化过程不对用户透明的jvm、.net等虚拟机，LLVM的优化pass提供了一种清晰易懂的优化过程组织方式。每个pass对LLVM来说都是一个小的库，用户可以以即插即用的方式来为自己的编译器添加新的优化过程，也可以自由地在已有的优化pass中选择想要的部分。在这篇文章里，我们将要实现一个简单的pass，&lt;code&gt;Dead Blocks Elimination&lt;/code&gt;，来优化我们生成的LLVM IR。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;环境设置&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先，我们需要设置build环境，根据你的LLVM版本不同，具体过程也会有些区别。旧版的LLVM使用&lt;code&gt;gmake&lt;/code&gt;作为其主要的build工具，后续的版本中逐渐在向&lt;code&gt;cmake&lt;/code&gt;迁移。默认读者采用的是笔者写文章时的最新的发布版本&lt;code&gt;8.0.0&lt;/code&gt;，请同时参考对应版本文档中官方手册的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//llvm.org/docs/WritingAnLLVMPass.html%23setting-up-the-build-environment&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这一节&lt;/a&gt;来配置。&lt;/p&gt;&lt;p&gt;在&lt;code&gt;&amp;lt;你的LLVM安装目录&amp;gt;/lib/Transforms/&lt;/code&gt;下建立一个名为&lt;code&gt;DeadBlock&lt;/code&gt;的目录，进入并新建&lt;code&gt;CMakeLists.txt&lt;/code&gt;，将以下代码复制入：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cmake&quot;&gt;&lt;span class=&quot;nb&quot;&gt;add_llvm_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;DeadBlock&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;MODULE&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;DeadBlock.cpp&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;PLUGIN_TOOL&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;opt&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;随后，退入到上级目录，打开&lt;code&gt;&amp;lt;你的LLVM安装目录&amp;gt;/lib/Transforms/CMakeLists.txt&lt;/code&gt;，并添加:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cmake&quot;&gt;&lt;span class=&quot;nb&quot;&gt;add_subdirectory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此，LLVM的build工具就可以正常地读取我们添加的新pass了。&lt;/p&gt;&lt;blockquote&gt;题外话：众所周之，软件行业每年进步最快的永远是版本号，笔者实际用的是14年的远古版本3.5.0（为了编译一个远古项目），还在用Makefile来构建pass。而现在开发中的版本号已经爬到了9.0.0+，趴&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Dead Blocks Elimination是什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这其实是一个原理非常简单的优化过程，常常出现在优化链的中段。假设在对代码进行了一定优化之后，我们得到了如下的IR：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;; ModuleID = &amp;#39;test.bc&amp;#39;
​
define i32 @main() {
b1:
  br label %b2
​
dead:                                             ; No predecessors!
  br label %b3
​
b2:                                               ; preds = %b1
  br label %b3
​
b3:                                               ; preds = %dead, %b2
  %b = phi i32 [ 1, %b2 ], [ 2, %dead ]
  ret i32 %b
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意，由于之前已经进行了一些神秘的优化或者代码本身如此，名为&lt;code&gt;dead&lt;/code&gt;的这个base block实际是无法被访问到的！&lt;code&gt;b1&lt;/code&gt;中的无条件&lt;code&gt;br&lt;/code&gt;永远只会跳转到&lt;code&gt;b2&lt;/code&gt;，而不是&lt;code&gt;dead&lt;/code&gt;。我们现在要实现的&lt;code&gt;DeadBlock&lt;/code&gt; pass正是要消去这样的base block。&lt;/p&gt;&lt;p&gt;不过，并不是直接删掉&lt;code&gt;dead&lt;/code&gt;就完事了，在&lt;code&gt;b3&lt;/code&gt;之中，我们有一个&lt;code&gt;phi node&lt;/code&gt;。为了让原来的代码保持正确，我们还需要调整或者删除受影响的&lt;code&gt;phi node&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;如果你不了解LLVM IR和phi node的话，可以阅读&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-cn/%25E9%259D%2599%25E6%2580%2581%25E5%258D%2595%25E8%25B5%258B%25E5%2580%25BC%25E5%25BD%25A2%25E5%25BC%258F&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这篇wiki&lt;/a&gt;来了解什么是SSA形式的IR，阅读&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//releases.llvm.org/3.5.0/docs/LangRef.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;LLVM的手册&lt;/a&gt;来了解LLVM IR的基本语法。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;第一铲土&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在了解要做什么之后，我们就可以开始动工了。在刚刚建立的&lt;code&gt;DeadBlock&lt;/code&gt;目录下添加&lt;code&gt;DeadBlock.cpp&lt;/code&gt;，这将是我们编写pass的地方，大部分LLVM优化pass都将代码组织在单个&lt;code&gt;.cpp&lt;/code&gt;文件中。和所有C++项目一样，讨厌的第一步总是添加所需的header：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/Pass.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/IR/Function.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/Support/raw_ostream.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/ADT/DepthFirstIterator.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/IR/CFG.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;set&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个pass的主干将看起来是这个样子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;llvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;DeadBlock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionPass&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runOnFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;llvm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// pass的入口
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 下一小节，我们将在这里添加代码
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// LLVM会利用pass的地址来为这个id赋值，所以初始值并不重要
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 注册pass，这个pass可能会改变CFG，所以将第三个参数设为true
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegisterPass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;deadblock&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;Dead blocks elimination pass&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;LLVM的pass有许多种，本次要实现的是一个&lt;code&gt;FunctionPass&lt;/code&gt;，也就是说这个pass将会在每个函数上运行一次。因此，我们的&lt;code&gt;DeadBlock&lt;/code&gt;构造体需要继承&lt;code&gt;FunctionPass&lt;/code&gt;。在搭建完骨架之后，我们就可以在&lt;code&gt;runOnFunction&lt;/code&gt;中逐步添加代码来实现具体的功能了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;造楼&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们需要一些本地变量来暂时存放需要的值：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;changed&lt;/code&gt;: 用来指示这个pass是否改变了目标function，如果改变了，则要标记为&lt;code&gt;true&lt;/code&gt;。这个值将是我们的返回值&lt;/li&gt;&lt;li&gt;&lt;code&gt;visitedSet&lt;/code&gt;： 我们将会从这个函数的root block开始，遍历这个root block可能会达到的block，被遍历到的block将会存放到这个set中&lt;/li&gt;&lt;li&gt;&lt;code&gt;unreachableSet&lt;/code&gt;：在得到&lt;code&gt;visitedSet&lt;/code&gt;之后，我们可以将其和这个函数中所有block做比较，如果有不在&lt;code&gt;visitedSet&lt;/code&gt;中的block，就将其添加到&lt;code&gt;unreachableSet&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;了解要做什么之后，就来一起向&lt;code&gt;visitedSet&lt;/code&gt;和&lt;code&gt;unreachableSet&lt;/code&gt;里加内容吧：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 从EntryBlock开始深度优先遍历整个函数内可以访问的BaseBlock
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 将已被访问过的BaseBlock存放在visitedSet中
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_ext_begin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_ext_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 遍历函数内所有BaseBlock，将不在vistitedSet中的BaseBlock添加到unreachableSet中
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;BB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然只是短短几行代码，LLVM库的强大可见一斑。我们无需自己手动实现深度优先遍历，只需调用&lt;code&gt;DepthFirstIterator.h&lt;/code&gt;里的&lt;code&gt;df_ext_begin&lt;/code&gt;和&lt;code&gt;df_ext_end&lt;/code&gt;两个模板，就能轻松遍历整个函数，并将访问过的block添加到&lt;code&gt;visitedSet&lt;/code&gt;之中。有了&lt;code&gt;unreachableSet&lt;/code&gt;之后，我们就可以判断是否会修改目标函数了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 标记目标函数是否会被修改
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后只要删除掉不想要的block并返回&lt;code&gt;changed&lt;/code&gt;，就大功告成：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;BB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;succ_begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;succ_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removePredecessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eraseFromParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这时，细心的读者可能会说：“诶诶？！是不是漏掉了什么？刚才说要处理受影响的phi node的呢？”不要着急，这段代码里其实已经处理了这部分啦。&lt;code&gt;removePredecessor()&lt;/code&gt;函数会通知该block有predecessor已被移除，随后这个block会检查自己是否有会受到影响的phi node并自动做出修改。怎么样，是不是觉得LLVM的库用起来很方便？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;测试结果&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面，就来编译并测试一下我们的成果吧。退回到LLVM安装目录的根目录下，在控制台里输入&lt;code&gt;make&lt;/code&gt;来编译刚完成的新pass。如果一切顺利的话，你就能在&lt;code&gt;Debug+Asserts/lib/&lt;/code&gt;下看到新生成的&lt;code&gt;DeadBlock.so&lt;/code&gt;了。&lt;/p&gt;&lt;p&gt;就来用一开始提到的示例IR作为测试代码好了，用LLVM自带的assembler来编译IR到bytecode：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;llvm-as test.ll&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，我们用LLVM自带的&lt;code&gt;opt&lt;/code&gt;工具来动态载入新pass并执行。重新进到&lt;code&gt;&amp;lt;你的LLVM安装目录&amp;gt;/lib/Transforms/DeadBlock&lt;/code&gt;下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;opt -load ../../../Debug+Asserts/lib/DeadBlock.so -deadblock &amp;lt; test.bc &amp;gt; optimized.bc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用&lt;code&gt;llvm-dis&lt;/code&gt;来看一下优化过的代码吧：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;llvm-dis optimized.bc
; ModuleID = &amp;#39;optimized.bc&amp;#39;
​
define i32 @main() {
b1:
  br label %b2
​
b2:                                               ; preds = %b1
  br label %b3
​
b3:                                               ; preds = %b2
  ret i32 1
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和原来的代码对比一下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-llvm&quot;&gt;&lt;span class=&quot;c&quot;&gt;; ModuleID = &amp;#39;test.bc&amp;#39;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;@main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;b1:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%b2&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;dead:&lt;/span&gt;                                             &lt;span class=&quot;c&quot;&gt;; No predecessors!
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%b3&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;b2:&lt;/span&gt;                                               &lt;span class=&quot;c&quot;&gt;; preds = %b1
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%b3&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;b3:&lt;/span&gt;                                               &lt;span class=&quot;c&quot;&gt;; preds = %dead, %b2
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;%b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%b2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%dead&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%b&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，&lt;code&gt;dead&lt;/code&gt;已经被移除，多余的phi node也被去除，替换成了常量。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;完整代码&lt;/b&gt;&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/Pass.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/IR/Function.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/Support/raw_ostream.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/ADT/DepthFirstIterator.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;#34;llvm/IR/CFG.h&amp;#34;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;set&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;llvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;DeadBlock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionPass&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runOnFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;llvm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// visitedSet 用于存放已经被访问过的BaseBlock
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// unreachableSet 则在最后用于存放无法被访问到的block
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 从EntryBlock开始深度优先遍历整个函数内可以访问的BaseBlock
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 将已被访问过的BaseBlock存放在visitedSet中
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_ext_begin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_ext_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 遍历函数内所有BaseBlock，将不在vistitedSet中的BaseBlock添加到unreachableSet中
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;BB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitedSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 标记目标函数是否会被修改
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 遍历unreachableSet，通知其successor移除多余的phi node
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BasicBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;BB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreachableSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;succ_begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;succ_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removePredecessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eraseFromParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// LLVM会利用pass的地址来为这个id赋值，所以初始值并不重要
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 注册pass，这个pass可能会改变CFG，所以将第三个参数设为true
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegisterPass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DeadBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;deadblock&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#34;Dead blocks elimination pass&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原载于&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//monetaphilis.github.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;自己的博客&lt;/a&gt;，欢迎来玩～&lt;/p&gt;</description>
<author>李愚</author>
<guid isPermaLink="false">2019-04-24-63568031</guid>
<pubDate>Wed, 24 Apr 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>计算春秋： MOS 6502</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-04-24-63566404.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/63566404&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2bc988d6f4958d7291ab1e9445387702_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&amp;#34;我们把6502装在罐子里卖，实际上只有罐子最上面那层能用&amp;#34;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;滥觞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;1974年，查尔斯·“恰克”·佩德尔将手里的计划书丢进垃圾桶，愤然离开摩托罗拉公司的大门。就在一年之前，恰克参与了摩托罗拉6800微处理器的设计。嗅觉敏锐的他早就闻到了价值300美金的6800给市场带来的真空——是的，6800太昂贵了。1974年的300美金购买力相当于2019年的1200美金，要用这个价位的处理器构建一台独立的计算机，至少也要2500美金上下，一台普通的家用轿车也不过是这两倍价格罢了。很难想象会有家庭或个人心甘情愿掏出如此巨款购买这样一台奇怪臃肿、不知应该用来做什么的机器，寥寥的潜在买家大多是感兴趣的企业和高校。他想着，如果微处理器的价格能降到50美金以下，必定能填补家用计算机这一片巨大的蓝色海洋。恰克将自己的想法告诉了摩托罗拉的上层，得到的回复却十分简单：&lt;/p&gt;&lt;blockquote&gt;&amp;#34;请放弃吧。&amp;#34;&lt;/blockquote&gt;&lt;p&gt;恰克离开了，但他并非是孤身一人，和他一起离开的还有原6800团队的不少成员。我们无法得知他率部加入MOS科技这家当时并不知名的年轻公司时的确切心情：或有对前上司无知的愤怒，或有对自己怀才不遇的叹息，抑或有对新东家的期待。但不论是哪种心情，这种心情并没有熄灭他的才华和斗志。3年之后，一颗名为6502的芯片将从这个不起眼的公司中诞生，扬起家用计算机的燎原之火。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5208cf59ba3f13f29d39ff64afb9f204_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;600&quot; data-original=&quot;https://pic1.zhimg.com/v2-5208cf59ba3f13f29d39ff64afb9f204_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5208cf59ba3f13f29d39ff64afb9f204_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;600&quot; data-original=&quot;https://pic1.zhimg.com/v2-5208cf59ba3f13f29d39ff64afb9f204_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5208cf59ba3f13f29d39ff64afb9f204_b.jpg&quot;/&gt;&lt;figcaption&gt;MOS 6502的手绘蓝图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;汇流&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;一年之后，1975年的威斯康星，一本杂志刊出了一则奇怪的广告，宣称一家科技公司将在本地的电子技术爱好者展会上以及其低廉的价格出售微处理器，刊登广告的正是恰克本人。这也是MOS 6502在市场——如果这种爱好者集会也算是市场的话，上的第一次亮相。&lt;/p&gt;&lt;p&gt;从现在的视角来看，那天的恰克不论是人力还是物力的准备都是不足的。为了节约资金，他甚至打算直接摆地摊出售，直至赶到现场时才被主办方通知禁止，最后无奈的恰克只好乖乖掏钱买了一个正规摊位。而为了张罗人手，他甚至拉上了自己的妻子一起来叫卖。贩卖的6502芯片更是连像样的包装都没有，一块块封装在DIP-40中的芯片像是酱黄瓜一样挤在一个透明玻璃罐头里。最过分的是那一大堆芯片中只有最上面的一层能正常工作，剩下都是滥竽充数的空壳——正因此有了文章最开始的那段话。实际上这种“充门面”的手段并不新鲜，雅达利之前就用过木头做的的假Pong游戏机在展会上冒充真货。摊位虽然寒酸，但恰克和伙伴们知道，他们有一个制胜的武器——那就是6502那仅有25美元的低廉价格——而他们也只需要这唯一的武器，便能一招制敌。&lt;/p&gt;&lt;p&gt;那天，来买新鲜出炉的6502的人中，有一个圆脸络腮胡的极客、一个年轻英俊的商人、还有一位方脸的工程师。前二者正是史蒂夫·沃兹尼亚克和史蒂夫·乔布斯，而后者是雅达利2600的缔造者约瑟夫·德奎尔。第二年，在高登·法兰奇家的车库里，神奇沃兹将6502接上主电路板。一百一十伏特的电源接通，三万两千七百六十八个DRAM单元苏醒，四十个针脚间信息流转；Apple-1型电脑的心脏颤动了第一下，随后开始以一兆赫兹的频率跳动。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6c54941cc9b487dcd11713f6bac431b5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;728&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1200&quot; data-original=&quot;https://pic2.zhimg.com/v2-6c54941cc9b487dcd11713f6bac431b5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6c54941cc9b487dcd11713f6bac431b5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;728&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1200&quot; data-original=&quot;https://pic2.zhimg.com/v2-6c54941cc9b487dcd11713f6bac431b5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-6c54941cc9b487dcd11713f6bac431b5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;滔滔&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果说6502是酵母，而70年代末的市场就像是30摄氏度的新鲜面团。仅仅25美元的价格让一切变得可能，市场上基于6502的微型电脑如雨后春笋般出现，Atari 2600、Apple ][、NES、Commodore 64、BBC Micro⋯⋯从数千美金一台的商用微型计算机，到只有几百美金的家用计算机，曾经只属于军队、大型企业、大学的计算机正是在这段时间内走入了寻常百姓家。而家用计算机的普及也推动了应用软件的演进：字处理软件、电子表格软件、图形界面、BASIC语言、电子游戏⋯⋯那个时代的普通人几乎全都是从搭载着6502的家用计算机上首次接触到这些现代青年习以为常的概念。&lt;/p&gt;&lt;p&gt;恰克可能没有预见到自己并没有花太长时间设计的这块芯片会统治家庭计算机十数年之久，也让这块芯片成为了摩尔定律支配下计算史上最常青的一块微处理器。时至今日，依然有诸多爱好者仿制6502和用它搭建怀旧电脑。即使和同时代的英特尔8080, 摩托罗拉6800相比，它也是平平无奇的：3510个晶体管，56个指令，最高3 MHz的主频。看似平庸的6502依靠着仅有对手15%的价格、亲民的姿态、和车库文化交融的理念构成了美国60到70一代年轻计算机爱好者的集体记忆。今日在顶级会议上投稿的计算机学者们，又有多少是在一台Apple ][或是Commodore 64里敲下他们的第一行代码呢？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9d0994071015856712223516a48ffbc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;306&quot; class=&quot;content_image&quot; width=&quot;389&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9d0994071015856712223516a48ffbc9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;306&quot; class=&quot;content_image lazy&quot; width=&quot;389&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9d0994071015856712223516a48ffbc9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;原载于&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//monetaphilis.github.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;自己的博客&lt;/a&gt;，欢迎来玩～&lt;/p&gt;</description>
<author>李愚</author>
<guid isPermaLink="false">2019-04-24-63566404</guid>
<pubDate>Wed, 24 Apr 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>PFPL 读书笔记 1 —— 语法对象</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-30-60920045.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60920045&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7f919b07f53a8fc3dbd8ea7551513998_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前记&lt;/h2&gt;&lt;p&gt;PFPL，即 Practical Foundations for Programming Languages，是关于编程语言的类型结构和语法表现的一本书。有一定编程经验的人都知道不同的语言有不同的特点。通俗地举例来说，一些语言的变量类型在编写的时候就确定了，而有一些要在运行的时候才知道；有一些语言对变量类型的检查比较“严格”，而有一些则比较“宽松”。继续深入地思考，就会发现它们有很多奇妙的地方。其中似乎有一些规律，但又无法清楚地描述究竟是什么。PFPL 就是一本解释这方面内容的书。&lt;/p&gt;&lt;p&gt;纸上得来终觉浅，但目前又没有合适的方式让我将其运用到实践中，只好把书上的内容复述一遍，记录下想法，希望能对自己的理解有所帮助。&lt;/p&gt;&lt;h2&gt;语法对象&lt;/h2&gt;&lt;p&gt;编程语言是一种语言，它们用于表示计算机和人类都能理解的计算过程。一门编程语言的语法确定了它可以由哪些语句组成。那么这些语句是如何确定的，程序是如何组成的呢？&lt;/p&gt;&lt;p&gt;当提到语法的时候，可能表示的是几个不同的概念。一个是 &lt;i&gt;表层语法&lt;/i&gt;，表示语句是如何输入并展示在计算机上的，通常是一些字符串等形式。而 &lt;i&gt;抽象语法&lt;/i&gt; 表示语句之间是如何组合在一起的。从这个层面来说，语法是一颗树，称为 &lt;i&gt;抽象语法树&lt;/i&gt;。这种树的节点是运算符，将几个语句组合在一起。另外还有关于标识符的声明和使用的问题，这部分结构称为 &lt;i&gt;绑定&lt;/i&gt;。这个层次的语法称为 &lt;i&gt;抽象绑定树&lt;/i&gt;，它在 &lt;i&gt;抽象语法树&lt;/i&gt; 的基础上增加了绑定和作用域的概念。&lt;/p&gt;&lt;h2&gt;抽象语法树&lt;/h2&gt;&lt;p&gt;一棵 &lt;i&gt;抽象语法树&lt;/i&gt;（&lt;i&gt;abstract syntax tree&lt;/i&gt;，简称为 &lt;i&gt;ast&lt;/i&gt;），是一棵有序树。它的叶子节点是 &lt;i&gt;变量&lt;/i&gt;，内部节点是 &lt;i&gt;运算符&lt;/i&gt;，&lt;i&gt;运算符&lt;/i&gt; 的参数是它的子树。Ast 可以分为很多种 &lt;i&gt;类别&lt;/i&gt;，表示不同形式的语法。&lt;i&gt;变量&lt;/i&gt; 代表特定类别的语法中一个未确定的片段。Ast 可以用 &lt;i&gt;运算符&lt;/i&gt; 组合起来。&lt;i&gt;运算符&lt;/i&gt; 具有类别和 &lt;i&gt;参数表&lt;/i&gt;，&lt;i&gt;参数表&lt;/i&gt; 使用类别的有限序列来表示它的参数数量和每个参数的类别。举例来说，如果一个运算符具有类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 和参数表 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_n&quot; alt=&quot;s_1,…,s_n&quot; eeimg=&quot;1&quot;&gt; ，那么它可以将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;&gt; 个分别属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_n&quot; alt=&quot;s_1,…,s_n&quot; eeimg=&quot;1&quot;&gt; 的 ast 组合成一个类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的 ast。如果一个运算符不接受参数，那么称它为 &lt;i&gt;零元&lt;/i&gt; 运算符，同理还有 &lt;i&gt;一元&lt;/i&gt; 运算符、&lt;i&gt;二元&lt;/i&gt; 运算符等等。&lt;/p&gt;&lt;p&gt;变量在其中是一个很重要的概念。在数学领域，变量一般表示某个作用域下的未知对象（如未知的实数），而在这里变量表示的是某个类别的 ast。因为这是一个未知的量，所以只有在 &lt;i&gt;代换&lt;/i&gt; 的时候变量才能获得意义。例如数学中我们可能会将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cpi&quot; alt=&quot;\pi&quot; eeimg=&quot;1&quot;&gt; 代入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 计算结果。在 ast 中也是类似的，只需要将一个 ast 中的变量换成另一个 ast 即可。&lt;/p&gt;&lt;p&gt;举例来说，有一门简单的语言用于表示数字、加法和乘法。它的语法中只有一个类别 Exp，以及一个无限的运算符集合：&lt;img src=&quot;https://www.zhihu.com/equation?tex=num%5Bn%5D&quot; alt=&quot;num[n]&quot; eeimg=&quot;1&quot;&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=n+%5Cin+N&quot; alt=&quot;n \in N&quot; eeimg=&quot;1&quot;&gt; ，包含 Exp 类别的零元运算符， &lt;img src=&quot;https://www.zhihu.com/equation?tex=plus&quot; alt=&quot;plus&quot; eeimg=&quot;1&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=times&quot; alt=&quot;times&quot; eeimg=&quot;1&quot;&gt; 是二元运算符，且参数都是 Exp 类别的。如这个含 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 的表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2+%2B+%283+%5Ctimes+x%29&quot; alt=&quot;2 + (3 \times x)&quot; eeimg=&quot;1&quot;&gt; 可以表示为 ast&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=plus%28num%5B2%5D%3Btimes%28num%5B3%5D%3B+x%29%29%5C%5C+&quot; alt=&quot;plus(num[2];times(num[3]; x))\\ &quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;如果将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=num%5B4%5D&quot; alt=&quot;num[4]&quot; eeimg=&quot;1&quot;&gt; 代入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; ，就能得到 ast&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=plus%28num%5B2%5D%3Btimes%28num%5B3%5D%3B+num%5B4%5D%29%29%5C%5C&quot; alt=&quot;plus(num[2];times(num[3]; num[4]))\\&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;即表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2+%2B+%283+%5Ctimes+4%29&quot; alt=&quot;2 + (3 \times 4)&quot; eeimg=&quot;1&quot;&gt; 。当然也可以将其它 ast 代入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 得到更加复杂的结果。&lt;/p&gt;&lt;p&gt;Ast 的树形结构支持一种非常有用的原则推理，称为 &lt;i&gt;结构归纳&lt;/i&gt;。假设我们想证明对于一个类别中所有的 ast， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; ，都具有性质 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%28a%29+%E2%80%8B&quot; alt=&quot; P(a) ​&quot; eeimg=&quot;1&quot;&gt; ，那么可以考虑所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 是怎么生成的，并且证明在每种情况下都具有该性质。所以根据刚才对 Exp 的定义，我们需要证明&lt;/p&gt;&lt;ol&gt;&lt;li&gt;所有 Exp 类别的变量 $ x $ 都具有该性质： &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28x%29&quot; alt=&quot;P(x)&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;对于所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+n+%5Cin+N+&quot; alt=&quot; n \in N &quot; eeimg=&quot;1&quot;&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=num%5Bn%5D+&quot; alt=&quot;num[n] &quot; eeimg=&quot;1&quot;&gt; 都具有该性质： &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%28num%5Bn%5D%29&quot; alt=&quot; P(num[n])&quot; eeimg=&quot;1&quot;&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=+n+%5Cin+N+&quot; alt=&quot; n \in N &quot; eeimg=&quot;1&quot;&gt;.&lt;/li&gt;&lt;li&gt;假设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1&quot; alt=&quot;a_1&quot; eeimg=&quot;1&quot;&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_2&quot; alt=&quot;a_2&quot; eeimg=&quot;1&quot;&gt; 都具有该性质，证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=plus%28a_1%3Ba_2%29+&quot; alt=&quot;plus(a_1;a_2) &quot; eeimg=&quot;1&quot;&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=times%28a_1%3Ba_2%29+&quot; alt=&quot;times(a_1;a_2) &quot; eeimg=&quot;1&quot;&gt; 都具有该性质：if &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a_1%29&quot; alt=&quot;P(a_1)&quot; eeimg=&quot;1&quot;&gt; and &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a_2%29&quot; alt=&quot;P(a_2)&quot; eeimg=&quot;1&quot;&gt; , then &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%28plus%28a_1%3Ba_2%29%29&quot; alt=&quot; P(plus(a_1;a_2))&quot; eeimg=&quot;1&quot;&gt; and &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%28times%28a_1%3Ba_2%29%29+&quot; alt=&quot; P(times(a_1;a_2)) &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因为以上过程说明了所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 的可能性，所以可以证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a%29&quot; alt=&quot;P(a)&quot; eeimg=&quot;1&quot;&gt; 对所有 Exp 类别的 ast 成立。&lt;/p&gt;&lt;p&gt;接下来考虑更加一般的情况。设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=S&quot; alt=&quot;S&quot; eeimg=&quot;1&quot;&gt; 是类别的有限集合， &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5C%7B+O_s+%5C%7D%7Bs+%5Cin+S%7D+&quot; alt=&quot; \{ O_s \}{s \in S} &quot; eeimg=&quot;1&quot;&gt;是运算符族，其中的运算符 &lt;img src=&quot;https://www.zhihu.com/equation?tex=o&quot; alt=&quot;o&quot; eeimg=&quot;1&quot;&gt; 都属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; ，参数表为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=ar%28o%29+%3D+%28s_1%2C%E2%80%A6s_n%29+&quot; alt=&quot;ar(o) = (s_1,…s_n) &quot; eeimg=&quot;1&quot;&gt; 。设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7BX_s%5C%7D_%7Bs+%5Cin+S%7D&quot; alt=&quot;\{X_s\}_{s \in S}&quot; eeimg=&quot;1&quot;&gt; 为类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的变量族。那么类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的 ast 族 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5BX%5D+%3D+%5C%7BA%5Bx%5D_s%5C%7D_%7Bs+%5Cin+S%7D&quot; alt=&quot;A[X] = \{A[x]_s\}_{s \in S}&quot; eeimg=&quot;1&quot;&gt; 的定义如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;一个类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的变量是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的一个 ast：if &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%5Cin+X_s&quot; alt=&quot; x \in X_s&quot; eeimg=&quot;1&quot;&gt; , then &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+A%5BX%5D_s&quot; alt=&quot;x \in A[X]_s&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;运算符可以组合 ast：if &lt;img src=&quot;https://www.zhihu.com/equation?tex=o+%5Cin+O_s&quot; alt=&quot;o \in O_s&quot; eeimg=&quot;1&quot;&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=+ar%28o%29+%3D+%28s_1%2C%E2%80%A6s_n%29+&quot; alt=&quot; ar(o) = (s_1,…s_n) &quot; eeimg=&quot;1&quot;&gt; and &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_1+%5Cin+A%5BX%5D_%7Bs_1%7D&quot; alt=&quot; a_1 \in A[X]_{s_1}&quot; eeimg=&quot;1&quot;&gt; ,…, &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_n+%5Cin+A%5BX%5D_%7Bs_n%7D+&quot; alt=&quot; a_n \in A[X]_{s_n} &quot; eeimg=&quot;1&quot;&gt; , then &lt;img src=&quot;https://www.zhihu.com/equation?tex=+o%28a_1%3B%E2%80%A6%3Ba_n%29+%5Cin+A%5BX%5D_s&quot; alt=&quot; o(a_1;…;a_n) \in A[X]_s&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;同样地，这个方法也可以用于证明所有 ast 具有性质 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P&quot; alt=&quot;P&quot; eeimg=&quot;1&quot;&gt; 。要证明所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a+%5Cin+A%5BX%5D+&quot; alt=&quot; a \in A[X] &quot; eeimg=&quot;1&quot;&gt; 具有性质 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a%29&quot; alt=&quot;P(a)&quot; eeimg=&quot;1&quot;&gt; ，只需要证明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;if &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+X_s&quot; alt=&quot;x \in X_s&quot; eeimg=&quot;1&quot;&gt; , then &lt;img src=&quot;https://www.zhihu.com/equation?tex=P_s%28x%29&quot; alt=&quot;P_s(x)&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;if &lt;img src=&quot;https://www.zhihu.com/equation?tex=+o+%5Cin+O_s&quot; alt=&quot; o \in O_s&quot; eeimg=&quot;1&quot;&gt; and &lt;img src=&quot;https://www.zhihu.com/equation?tex=+ar%28o%29+%3D+%28s_1%2C%E2%80%A6%2Cs_n%29&quot; alt=&quot; ar(o) = (s_1,…,s_n)&quot; eeimg=&quot;1&quot;&gt; , then if &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P_%7Bs_1%7D%28a_1%29&quot; alt=&quot; P_{s_1}(a_1)&quot; eeimg=&quot;1&quot;&gt; and … and &lt;img src=&quot;https://www.zhihu.com/equation?tex=P_%7Bs_n%7D%28a_n%29&quot; alt=&quot;P_{s_n}(a_n)&quot; eeimg=&quot;1&quot;&gt; , then &lt;img src=&quot;https://www.zhihu.com/equation?tex=P_s%28o%28a_1%3B%E2%80%A6%3Ba_n%29%29&quot; alt=&quot;P_s(o(a_1;…;a_n))&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;根据上面的原理，我们可以轻松地证明如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X+%5Csubseteq+Y&quot; alt=&quot;X \subseteq Y&quot; eeimg=&quot;1&quot;&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5BX%5D+%5Csubseteq+A%5BY%5D&quot; alt=&quot;A[X] \subseteq A[Y]&quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; 是一个变量族， &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 是一个类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的变量且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cnotin+X_s&quot; alt=&quot;x \notin X_s&quot; eeimg=&quot;1&quot;&gt; ，那么称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X%2C+x+&quot; alt=&quot;X, x &quot; eeimg=&quot;1&quot;&gt; 为将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 邻接于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; ，具体含义如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D++X%2Cx+%3D+%5Cbegin%7Bcases%7D++X_i+%5Ccup+%7Bx%7D%26+i%3Ds%5C%5C++X_i%26+i+%5Cneq+s++%5Cend%7Bcases%7D+%5Cquad+i+%5Cin+S++%5Cend%7Bequation%7D+%5C%5C&quot; alt=&quot;\begin{equation}  X,x = \begin{cases}  X_i \cup {x}&amp;amp; i=s\\  X_i&amp;amp; i \neq s  \end{cases} \quad i \in S  \end{equation} \\&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;&lt;i&gt;代换&lt;/i&gt; 赋予变量意义。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 类别的变量， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%5Cin+A%5BX%2C+x%5D_%7Bs%27%7D&quot; alt=&quot;a \in A[X, x]_{s&#39;}&quot; eeimg=&quot;1&quot;&gt; ，且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+%5Cin+A%5BX%5D_s&quot; alt=&quot;b \in A[X]_s&quot; eeimg=&quot;1&quot;&gt; ，那么可以将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 中出现的所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;&gt; 进行代换，记为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da&quot; alt=&quot;[b/x]a&quot; eeimg=&quot;1&quot;&gt; ，且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da+%5Cin+A%5BX%5D_%7Bs%27%7D&quot; alt=&quot;[b/x]a \in A[X]_{s&#39;}&quot; eeimg=&quot;1&quot;&gt; 。其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 被称为 &lt;i&gt;代换目标&lt;/i&gt;， &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 被称为 &lt;i&gt;代换项&lt;/i&gt;。代换可以定义为以下等式：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Dx+%3D+b+&quot; alt=&quot;[b/x]x = b &quot; eeimg=&quot;1&quot;&gt; and &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Dy+%3D+y+%E2%80%8B&quot; alt=&quot; [b/x]y = y ​&quot; eeimg=&quot;1&quot;&gt; if &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cneq+y+%E2%80%8B&quot; alt=&quot;x \neq y ​&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Do%28a_1%3B%E2%80%A6%3Ba_n%29+%3D+o%28%5Bb%2Fx%5Da1%3B%E2%80%A6%3B%5Bb%2Fx%5Da_n%29+&quot; alt=&quot;[b/x]o(a_1;…;a_n) = o([b/x]a1;…;[b/x]a_n) &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;例如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bnum%5B2%5D%2Fx%5Dplus%28x%3Bnum%5B3%5D%29+%3D+plus%28num%5B2%5D%3Bnum%5B3%5D%29+&quot; alt=&quot; [num[2]/x]plus(x;num[3]) = plus(num[2];num[3]) &quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理 1.1.&lt;/b&gt; 如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%5Cin+A%5BX%2Cx%5D+&quot; alt=&quot;a \in A[X,x] &quot; eeimg=&quot;1&quot;&gt; ，那么对于每一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+b+%5Cin+A%5BX%5D+&quot; alt=&quot; b \in A[X] &quot; eeimg=&quot;1&quot;&gt; 都存在唯一的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c+%5Cin+A%5BX%5D+&quot; alt=&quot;c \in A[X] &quot; eeimg=&quot;1&quot;&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da+%3D+c+&quot; alt=&quot;[b/x]a = c &quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;p&gt;&lt;i&gt;证明：&lt;/i&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a+%3D+x&quot; alt=&quot; a = x&quot; eeimg=&quot;1&quot;&gt; ，根据定义 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+%3D+c&quot; alt=&quot;b = c&quot; eeimg=&quot;1&quot;&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+y+%5Cneq+x+&quot; alt=&quot;a = y \neq x &quot; eeimg=&quot;1&quot;&gt; ，同样根据定义 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+y+%3D+c+&quot; alt=&quot; y = c &quot; eeimg=&quot;1&quot;&gt; 。否则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+o%28a_1%2C%E2%80%A6%2Ca_n%29+&quot; alt=&quot;a = o(a_1,…,a_n) &quot; eeimg=&quot;1&quot;&gt; ，使用归纳法假设存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1%2C%E2%80%A6%2Cc_n&quot; alt=&quot;c_1,…,c_n&quot; eeimg=&quot;1&quot;&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Da_1+%3D+c_1&quot; alt=&quot; [b/x]a_1 = c_1&quot; eeimg=&quot;1&quot;&gt; , …, &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da_n+%3D+c_n&quot; alt=&quot;[b/x]a_n = c_n&quot; eeimg=&quot;1&quot;&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+c+%3D+o%28c_1%3B%E2%80%A6%3Bc_n%29+&quot; alt=&quot; c = o(c_1;…;c_n) &quot; eeimg=&quot;1&quot;&gt; 。可得对于所有的情况都成立。&lt;/p&gt;&lt;p&gt;大部分情况下可以提前枚举出所有运算符，但是在一些情况下却不行，有些运算符只能在固定的上下文生效，此时运算符的集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O&quot; alt=&quot;O&quot; eeimg=&quot;1&quot;&gt; 不是确定的，所以必须留出扩展性。这时可以将 &lt;i&gt;形式参数&lt;/i&gt; 作为运算符族的索引。如有一个零元运算符族 &lt;img src=&quot;https://www.zhihu.com/equation?tex=cls%5Bu%5D&quot; alt=&quot;cls[u]&quot; eeimg=&quot;1&quot;&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u&quot; alt=&quot;u&quot; eeimg=&quot;1&quot;&gt; 是 &lt;i&gt;活跃&lt;/i&gt; 的形式参数集合中的元素，其中不同的形式参数对应不同的运算符：如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u&quot; alt=&quot;u&quot; eeimg=&quot;1&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v&quot; alt=&quot;v&quot; eeimg=&quot;1&quot;&gt; 是活跃的形式参数且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+u+%5Cneq+v&quot; alt=&quot; u \neq v&quot; eeimg=&quot;1&quot;&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=cls%5Bu%5D+%5Cneq+cls%5Bv%5D&quot; alt=&quot;cls[u] \neq cls[v]&quot; eeimg=&quot;1&quot;&gt; 。需要扩展新的运算符时，只需要添加新的形式参数即可。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u&quot; alt=&quot;u&quot; eeimg=&quot;1&quot;&gt; 是不活跃的， &lt;img src=&quot;https://www.zhihu.com/equation?tex=+cls%5Bu%5D&quot; alt=&quot; cls[u]&quot; eeimg=&quot;1&quot;&gt; 没有意义，但当它活跃时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=+cls%5Bu%5D&quot; alt=&quot; cls[u]&quot; eeimg=&quot;1&quot;&gt; 就是一个零元运算符。&lt;/p&gt;&lt;p&gt;形式参数可能会和变量混淆，但它们是根本不相同的两个概念。变量是一个未知的 ast，而形式参数不代表任何东西，它只是用来区分其它的形式参数。我们用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+A%5BU%3BX%5D&quot; alt=&quot; A[U;X]&quot; eeimg=&quot;1&quot;&gt; 表示一个 ast 的集合，其中的变量属于集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; ，形式参数属于集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;h2&gt;抽象绑定树&lt;/h2&gt;&lt;p&gt;抽象绑定树（&lt;i&gt;abstract binding tree&lt;/i&gt;，简称为 &lt;i&gt;abt&lt;/i&gt;）,为 ast 添加了新变量和形式参数的声明，称为 &lt;i&gt;绑定&lt;/i&gt;，以及他们的有效范围，称为 &lt;i&gt;作用域&lt;/i&gt;，一个绑定的作用域是被绑定的标识符所在的 abt。因此一棵子树的活跃标识符集合可能比外层的集合大，不同的子树也可能会包含不同的标识符。但是所有的标识符都只是一个引用，也就是说选用不同的标识符所表达的含义是一致的，因此我们总是可以给绑定关联一个不同的标识符。&lt;/p&gt;&lt;p&gt;比如有一个表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=let+%7E+x+%7E+be+%7E+a_1+%7E+in+%7E+a_2&quot; alt=&quot;let ~ x ~ be ~ a_1 ~ in ~ a_2&quot; eeimg=&quot;1&quot;&gt; ，声明了一个变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 在表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_2+&quot; alt=&quot;a_2 &quot; eeimg=&quot;1&quot;&gt; 中代表 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1&quot; alt=&quot;a_1&quot; eeimg=&quot;1&quot;&gt; ，而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1&quot; alt=&quot;a_1&quot; eeimg=&quot;1&quot;&gt; 中的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 即使拥有相同的名字，也是不同的变量。相同的绑定更换名字不改变它的含义，如表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+x%2Ax+%7E+in+%7E+x+%2B+x+&quot; alt=&quot; let ~ x ~ be ~ x*x ~ in ~ x + x &quot; eeimg=&quot;1&quot;&gt;与&lt;img src=&quot;https://www.zhihu.com/equation?tex=+let+%7E+y+%7E+be+%7E+x%2Ax+%7E+in+%7E+y+%2B+y+&quot; alt=&quot; let ~ y ~ be ~ x*x ~ in ~ y + y &quot; eeimg=&quot;1&quot;&gt; 是等价的。而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+y%2Ay+%7E+in+%7E+x+%2B+x+&quot; alt=&quot; let ~ x ~ be ~ y*y ~ in ~ x + x &quot; eeimg=&quot;1&quot;&gt; 与前面两个表达式都不同，因为这里的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; 代表的可能是外层 abt 中的另一个变量。另外在改变变量命名时不能改变引用的结构，如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+2+%7E+in+%7E+let+%7E+y+%7E+be+%7E+3+%7E+in+%7E+x+%2B+x+&quot; alt=&quot; let ~ x ~ be ~ 2 ~ in ~ let ~ y ~ be ~ 3 ~ in ~ x + x &quot; eeimg=&quot;1&quot;&gt; 与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=let+%7E+y+%7E+be+%7E+2+%7E+in+%7E+let+%7E+y+%7E+be+%7E+3+%7E+in+%7E+y+%2B+y&quot; alt=&quot;let ~ y ~ be ~ 2 ~ in ~ let ~ y ~ be ~ 3 ~ in ~ y + y&quot; eeimg=&quot;1&quot;&gt; 所表示的意义不同。后者的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+y+%2B+y&quot; alt=&quot; y + y&quot; eeimg=&quot;1&quot;&gt; 中的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; 表示的是内部结构的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; 而不是外部的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;let x be 2 in
    let y be 3 in
        x + x

let y be 2 in
    let y be 3 in
        y + y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Abt 可以给运算符参数绑定有限个变量，记作 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1%2C%E2%80%A6%2Cx_k.a+&quot; alt=&quot;x_1,…,x_k.a &quot; eeimg=&quot;1&quot;&gt; 。变量序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x_1%2C%E2%80%A6%2Cx_k&quot; alt=&quot; x_1,…,x_k&quot; eeimg=&quot;1&quot;&gt; 绑定在 abt &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 中，当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+k+%3D+0+&quot; alt=&quot; k = 0 &quot; eeimg=&quot;1&quot;&gt; 时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=.a&quot; alt=&quot;.a&quot; eeimg=&quot;1&quot;&gt; 可以省略为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 。如表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+a_1+%7E+in+%7E+a_2&quot; alt=&quot; let ~ x ~ be ~ a_1 ~ in ~ a_2&quot; eeimg=&quot;1&quot;&gt; 写作 abt 就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=let%28a_1%3Bx.a_2%29&quot; alt=&quot;let(a_1;x.a_2)&quot; eeimg=&quot;1&quot;&gt; 。另外使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cvec%7Bx%7D&quot; alt=&quot; \vec{x}&quot; eeimg=&quot;1&quot;&gt; 表示有限不重复序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1%2C%E2%80%A6%2Cx_n+&quot; alt=&quot;x_1,…,x_n &quot; eeimg=&quot;1&quot;&gt; ，所以 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1%2C%E2%80%A6%2Cx_n.a&quot; alt=&quot;x_1,…,x_n.a&quot; eeimg=&quot;1&quot;&gt; 也可以写作 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cvec%7Bx%7D.a&quot; alt=&quot; \vec{x}.a&quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;p&gt;为了表示绑定，abt 中运算符的参数表使用 &lt;i&gt;格&lt;/i&gt; 的有限序列表示。这个序列的长度表示参数的数量，其中每个格表示一个参数的类别和绑定的变量类别。一个格用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%28s_1%2C%E2%80%A6%2Cs_k%29s&quot; alt=&quot; (s_1,…,s_k)s&quot; eeimg=&quot;1&quot;&gt; 的形式表示 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;&gt; 个类别分别为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_k+&quot; alt=&quot;s_1,…,s_k &quot; eeimg=&quot;1&quot;&gt; 的变量绑定在类别为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的参数上，并且使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bs%7D&quot; alt=&quot;\vec{s}&quot; eeimg=&quot;1&quot;&gt; 表示有限序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_n&quot; alt=&quot;s_1,…,s_n&quot; eeimg=&quot;1&quot;&gt; 。如果变量序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bx%7D&quot; alt=&quot;\vec{x}&quot; eeimg=&quot;1&quot;&gt; 和类别序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cvec%7Bs%7D&quot; alt=&quot; \vec{s}&quot; eeimg=&quot;1&quot;&gt; 具有相同的长度，且每个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_i+&quot; alt=&quot;x_i &quot; eeimg=&quot;1&quot;&gt; 都属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_i+&quot; alt=&quot;s_i &quot; eeimg=&quot;1&quot;&gt; ，那么称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bx%7D&quot; alt=&quot;\vec{x}&quot; eeimg=&quot;1&quot;&gt; 属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bs%7D&quot; alt=&quot;\vec{s}&quot; eeimg=&quot;1&quot;&gt; 。举例来说， &lt;img src=&quot;https://www.zhihu.com/equation?tex=let&quot; alt=&quot;let&quot; eeimg=&quot;1&quot;&gt; 运算符的参数表为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%28%5Ctext%7BExp%7D%2C+%28%5Ctext%7BExp%7D%29%5Ctext%7BExp%7D%29&quot; alt=&quot; (\text{Exp}, (\text{Exp})\text{Exp})&quot; eeimg=&quot;1&quot;&gt; ，表示第一个参数是 Exp 类别的且没有绑定的变量，第二个参数是 Exp 类别的且绑定了一个 Exp 类别的变量。表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=let+%7E+x+%7E+be+%7E+2+%2B+2+%7E+in+%7E+x+%5Ctimes+x+&quot; alt=&quot;let ~ x ~ be ~ 2 + 2 ~ in ~ x \times x &quot; eeimg=&quot;1&quot;&gt; 写作 abt 是&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=let%28plus%28num%5B2%5D%3Bnum%5B2%5D%29%3Bx.times%28x%3Bx%29%29%5C%5C&quot; alt=&quot;let(plus(num[2];num[2]);x.times(x;x))\\&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O&quot; alt=&quot;O&quot; eeimg=&quot;1&quot;&gt; 是运算符族，其中的运算符 &lt;img src=&quot;https://www.zhihu.com/equation?tex=o&quot; alt=&quot;o&quot; eeimg=&quot;1&quot;&gt; 的参数表为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=ar%28o%29&quot; alt=&quot;ar(o)&quot; eeimg=&quot;1&quot;&gt; 。对于变量族 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; ，对应的 abt 族 &lt;img src=&quot;https://www.zhihu.com/equation?tex=B%5BX%5D&quot; alt=&quot;B[X]&quot; eeimg=&quot;1&quot;&gt; 的定义与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5BX%5D&quot; alt=&quot;A[X]&quot; eeimg=&quot;1&quot;&gt; 类似，但是它活跃的变量会随着绑定的变量而改变：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+X_s&quot; alt=&quot;x \in X_s&quot; eeimg=&quot;1&quot;&gt; , 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+B%5BX%5D_s&quot; alt=&quot;x \in B[X]_s&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=ar%28o%29+%3D+%28%28%5Cvec%7Bs_1%7D%29s_1%2C%E2%80%A6%2C%28%5Cvec%7Bs_n%7D%29s_n%29+&quot; alt=&quot;ar(o) = ((\vec{s_1})s_1,…,(\vec{s_n})s_n) &quot; eeimg=&quot;1&quot;&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bx_i%7D+&quot; alt=&quot;\vec{x_i} &quot; eeimg=&quot;1&quot;&gt; 属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cvec%7Bs_i%7D+&quot; alt=&quot; \vec{s_i} &quot; eeimg=&quot;1&quot;&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_i+%5Cin+B%5BX%2C+%5Cvec%7Bx_i%7D%5D_%7Bs_i%7D+&quot; alt=&quot;a_i \in B[X, \vec{x_i}]_{s_i} &quot; eeimg=&quot;1&quot;&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+%5Cin+B%5BX%5D_s+&quot; alt=&quot;o(\vec{x_1}.a_1;…;\vec{x_n}.a_n) \in B[X]_s &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这个定义有一点问题，考虑下面这个 abt： &lt;img src=&quot;https://www.zhihu.com/equation?tex=+let%28a_1%3Bx.let%28a_2%3Bx.a_3%29%29&quot; alt=&quot; let(a_1;x.let(a_2;x.a_3))&quot; eeimg=&quot;1&quot;&gt; 。根据上面的定义，这个 abt 是不合法的。内层的 abt 在构造的时候引入了变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; ，因此变量族从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; 变为了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X%2Cx&quot; alt=&quot;X,x&quot; eeimg=&quot;1&quot;&gt; 。接下来考虑外层的时候，需要把 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 邻接于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X%2Cx&quot; alt=&quot;X,x&quot; eeimg=&quot;1&quot;&gt; ，这就产生了冲突。因为两个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 的符号相同，但是表示的意思是不同的。实际上选取不同的变量名不应该造成含义上的区别，因此可以修改第二条定义，考虑重命名变量：&lt;/p&gt;&lt;p&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=ar%28o%29+%3D+%28%28%5Cvec%7Bx_1%7D%29s_1%2C%E2%80%A6%2C%28%5Cvec%7Bx_n%7D%29s_n%29+&quot; alt=&quot;ar(o) = ((\vec{x_1})s_1,…,(\vec{x_n})s_n) &quot; eeimg=&quot;1&quot;&gt; ，且对于每个重命名 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cpi_i%3A%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bx_i%27%7D+%7E%7E%7E%7E+%28%24+%5Cvec%7Bx_i%27%7D+%5Cnotin+X+%24%29&quot; alt=&quot;\pi_i:\vec{x_i} \leftrightarrow \vec{x_i&#39;} ~~~~ ($ \vec{x_i&#39;} \notin X $)&quot; eeimg=&quot;1&quot;&gt; ，都有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cpi_i+%5Ccdot+a_i+%5Cin+B%5BX%2C%5Cvec%7Bx_i%27%7D%5D+&quot; alt=&quot; \pi_i \cdot a_i \in B[X,\vec{x_i&#39;}] &quot; eeimg=&quot;1&quot;&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+%5Cin+B%5BX%5D_s+%E2%80%8B&quot; alt=&quot;o(\vec{x_1}.a_1;…;\vec{x_n}.a_n) \in B[X]_s ​&quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;p&gt;这个重命名规则避免了外部的变量和内部的变量冲突的情况。它保证了所有绑定的变量都与外围环境无关。&lt;/p&gt;&lt;p&gt;类似于 ast，如果需要证明一个性质 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a%29%5BX%5D+&quot; alt=&quot;P(a)[X] &quot; eeimg=&quot;1&quot;&gt; 对于所有的 abt &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%5Cin+B%5BX%5D&quot; alt=&quot;a \in B[X]&quot; eeimg=&quot;1&quot;&gt; 都成立，那么只需要证明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+X_s&quot; alt=&quot;x \in X_s&quot; eeimg=&quot;1&quot;&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%5BX%5D_s%28x%29+&quot; alt=&quot; P[X]_s(x) &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;对于任意属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; ，具有参数表 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%28%5Cvec%7Bs_1%7D%29s_1%2C%E2%80%A6%2C%28%5Cvec%7Bs_n%7D%29s_n+&quot; alt=&quot; (\vec{s_1})s_1,…,(\vec{s_n})s_n &quot; eeimg=&quot;1&quot;&gt; 的运算符 &lt;img src=&quot;https://www.zhihu.com/equation?tex=o&quot; alt=&quot;o&quot; eeimg=&quot;1&quot;&gt; ，如果对于每个重命名 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cpi_i%3A%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bx_i%27%7D+&quot; alt=&quot;\pi_i:\vec{x_i} \leftrightarrow \vec{x_i&#39;} &quot; eeimg=&quot;1&quot;&gt; 都有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%5BX%2C+%5Cvec%7Bx_i%27%7D%5D_%7Bs_i%7D%28%5Cpi_i+%5Ccdot+a_i%29&quot; alt=&quot; P[X, \vec{x_i&#39;}]_{s_i}(\pi_i \cdot a_i)&quot; eeimg=&quot;1&quot;&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%5BX%5D_s%28o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29%29&quot; alt=&quot; P[X]_s(o(\vec{x_1}.a_1;…;\vec{x_n}.a_n))&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这也是一个归纳性的推理，遵循了上面构造 abt 的过程。举例来说，我们定义一个命题 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%5Cin+a+%7E%7E%7E+%28a+%5Cin+B%5BX%2C+x%5D+%29&quot; alt=&quot; x \in a ~~~ (a \in B[X, x] )&quot; eeimg=&quot;1&quot;&gt; ，表示 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 中是自由变量。具体来说，它的意思是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 变量绑定在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 之外，而不是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 内部。那么要证明这个命题只需要说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+x&quot; alt=&quot;x \in x&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;如果存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+1+%5Cle+i+%5Cle+n&quot; alt=&quot; 1 \le i \le n&quot; eeimg=&quot;1&quot;&gt; 对于每个重命名 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cpi+%3A+%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bz_i%7D&quot; alt=&quot; \pi : \vec{x_i} \leftrightarrow \vec{z_i}&quot; eeimg=&quot;1&quot;&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%5Cin+%5Cpi+%5Ccdot+a_i+&quot; alt=&quot; x \in \pi \cdot a_i &quot; eeimg=&quot;1&quot;&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%5Cin+o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29&quot; alt=&quot; x \in o(\vec{x_1}.a_1;…;\vec{x_n}.a_n)&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一个条件说明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 本身中是自由的，但是在任何其它的变量中不是自由的。第二个条件表面如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 在某个参数中，无论使用那个绑定的变量名称，都是自由的，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 在整个 abt 中是自由的。&lt;/p&gt;&lt;p&gt;如果两个 abt， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;&gt; ，无论选取什么绑定变量名都是相同的，则称为 &lt;i&gt;α 等价&lt;/i&gt;，记为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D_%5Calpha+b+&quot; alt=&quot;a =_\alpha b &quot; eeimg=&quot;1&quot;&gt; 。它的具体定义如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%3D_%5Calpha+x+&quot; alt=&quot; x =_\alpha x &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;对于每个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+1+%5Cle+i+%5Cle+n+&quot; alt=&quot; 1 \le i \le n &quot; eeimg=&quot;1&quot;&gt; 和所有新的重命名 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cpi_i+%3A+%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bz_i%7D+&quot; alt=&quot; \pi_i : \vec{x_i} \leftrightarrow \vec{z_i} &quot; eeimg=&quot;1&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cpi_i%27%3A%5Cvec%7Bx_i%27%7D+%5Cleftrightarrow+%5Cvec%7Bz_i%7D&quot; alt=&quot;\pi_i&#39;:\vec{x_i&#39;} \leftrightarrow \vec{z_i}&quot; eeimg=&quot;1&quot;&gt; ，都有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+o%28%5Cvec%7Bx_i%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+&quot; alt=&quot; o(\vec{x_i}.a_1;…;\vec{x_n}.a_n) &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D_%5Calpha+b&quot; alt=&quot;a =_\alpha b&quot; eeimg=&quot;1&quot;&gt; ，那么称它们互为 &lt;i&gt;α 变体&lt;/i&gt;。&lt;/p&gt;&lt;p&gt;考虑 abt 中将某个自由变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 的 &lt;i&gt;代换&lt;/i&gt; 为同类别的 abt，可以粗略地定义为：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5D%3Db+&quot; alt=&quot;[b/x]=b &quot; eeimg=&quot;1&quot;&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Dy+%3D+y+%7E+%28x+%5Cneq+y%29&quot; alt=&quot; [b/x]y = y ~ (x \neq y)&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;对于每个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+1+%5Cle+i+%5Cle+n&quot; alt=&quot; 1 \le i \le n&quot; eeimg=&quot;1&quot;&gt; ，要求 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cvec%7Bx_i%7D+%5Cnotin+b+&quot; alt=&quot; \vec{x_i} \notin b &quot; eeimg=&quot;1&quot;&gt; ，且若 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%5Cnotin+%5Cvec%7Bx_i%7D+&quot; alt=&quot; x \notin \vec{x_i} &quot; eeimg=&quot;1&quot;&gt; ，设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_i%27+%3D+%5Bb%2Fx%5Da_i+&quot; alt=&quot; a_i&#39; = [b/x]a_i &quot; eeimg=&quot;1&quot;&gt; ，否则设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_i%27+%3D+a_i+&quot; alt=&quot; a_i&#39; = a_i &quot; eeimg=&quot;1&quot;&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Do%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29&quot; alt=&quot; [b/x]o(\vec{x_1}.a_1;…;\vec{x_n}.a_n)&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;从第二个条件可以看出，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 绑定于某个参数中，那么参数中的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 不会进行代换，因为这两个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 的含义是不同的，所以需要判断是否 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cnotin+%5Cvec%7Bx_i%7D+&quot; alt=&quot;x \notin \vec{x_i} &quot; eeimg=&quot;1&quot;&gt; 。同样地， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bx_i%7D+%5Cnotin+b&quot; alt=&quot;\vec{x_i} \notin b&quot; eeimg=&quot;1&quot;&gt; 也是为了保证代换后的变量不会与原来的绑定变量发生冲突，造成含义的混淆。如果这两个条件不都成立，那么这个代换是没有定义的。为了解决这种没有定义的问题，可以在条件中添加新的重命名的设定。我们知道对于任意新的重命名 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cpi_i+%3A+%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bx_i%27%7D+&quot; alt=&quot; \pi_i : \vec{x_i} \leftrightarrow \vec{x_i&#39;} &quot; eeimg=&quot;1&quot;&gt; ，代换 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5D+%28%5Cpi_i+%5Ccdot+a_i%29+&quot; alt=&quot;[b/x] (\pi_i \cdot a_i) &quot; eeimg=&quot;1&quot;&gt; 都是合法的。所以对于选定的新的重命名，我们可以定义&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Do%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+%3D+o%28%5Cvec%7Bx_1%27%7D.%5Bb%2Fx%5D+%28%5Cpi_1+%5Ccdot+a_1%29%3B%E2%80%A6%3B%5Cvec%7Bx_n%27%7D.%5Bb%2Fx%5D+%28%5Cpi_n+%5Ccdot+a_n%29%29%5C%5C&quot; alt=&quot; [b/x]o(\vec{x_1}.a_1;…;\vec{x_n}.a_n) = o(\vec{x_1&#39;}.[b/x] (\pi_1 \cdot a_1);…;\vec{x_n&#39;}.[b/x] (\pi_n \cdot a_n))\\&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;这样我们就不需要关注 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cnotin+%5Cvec%7Bx_i%7D+&quot; alt=&quot;x \notin \vec{x_i} &quot; eeimg=&quot;1&quot;&gt; 这个条件了，因为通过重命名可以保证这个条件的成立。另外，我们也可以通过选择一个不包含冲突变量名的 α 变体作为代换目标，这样就可以安全地进行代换。换句话说，abt 的代换是定义在整个 α 等价类上的。为了避免绑定带来的其它问题，我们将所有 α 等价的 abt 看成是相同的。也就是说所有对于 abt 的讨论都针对整个 α 等价类，而非某个 abt 本身。因此当我们研究一个 abt 时，只需要选择一个具有代表性的 abt，而不用关系它的变量名。&lt;/p&gt;&lt;p&gt;和变量类似，形式参数也可以绑定在运算符的参数上。为了表示形式参数，我们把格扩展为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cvec%7Bs_1%7D%3B%5Cvec%7Bs_2%7D%29s&quot; alt=&quot;(\vec{s_1};\vec{s_2})s&quot; eeimg=&quot;1&quot;&gt; ，表示类别为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+s_1+&quot; alt=&quot; s_1 &quot; eeimg=&quot;1&quot;&gt; 的形式参数和类别为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_2&quot; alt=&quot;s_2&quot; eeimg=&quot;1&quot;&gt; 的变量绑定在类别为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的参数上。Abt 族 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+B%5BU%3BX%5D+&quot; alt=&quot; B[U;X] &quot; eeimg=&quot;1&quot;&gt; 的形式参数来源于集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;&gt; ，变量来源于集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; 。按照习惯，用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u&quot; alt=&quot;u&quot; eeimg=&quot;1&quot;&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=v&quot; alt=&quot;v&quot; eeimg=&quot;1&quot;&gt; 表示形式参数，用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; 表示变量。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;这部分介绍了语法的基本概念，将 &lt;i&gt;表层语法&lt;/i&gt; 和 &lt;i&gt;抽象语法&lt;/i&gt; 进行了区分。在抽象语法中又分为仅包含语句结构的 &lt;i&gt;抽象语法树&lt;/i&gt; 和包含标识符定义和作用域的 &lt;i&gt;抽象绑定树&lt;/i&gt;，并提出了相关的定义和定理。其中运用了大量的归纳法，从定义出发按照构造的过程对一些定义进行了说明。这部分是后面更为深入的内容的基础，需要熟悉里面的符号表示并理解概念。&lt;/p&gt;&lt;p&gt;区分这几个不同层次的概念可以帮助我们更好地理解语法结构，也能够知道在遇到什么问题时要从什么地方下手。如重构代码时，需要保证重命名前后的变量在语义上保持一致，且不与其它的变量名产生冲突。这部分涉及到变量的绑定问题，就需要从 abt 层面进行解决。以 JavaScript 为例，@babel/parser 可以将代码转化为 ast，但根据刚刚的分析，仅仅根据这个是很难帮助我们完成重命名的操作的。这时候可以借助 @babel/traverse 遍历 ast，在遍历的过程中能够访问到当前节点的作用域以及绑定等信息，这样就有了更多的信息，可以保证重命名前后语法的一致性。&lt;/p&gt;</description>
<author>Means88</author>
<guid isPermaLink="false">2019-03-30-60920045</guid>
<pubDate>Sat, 30 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>0x07：SICP 的魔法 - 元语言抽象</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-21-59996663.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59996663&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7a397e027ba36ea5e82efe73ee883863_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;我的github地址：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;lfkdsk&lt;/a&gt;，还创建了相关的仓库，可以clone下来看：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk/SICP-Magical-Book&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SICP 的魔法&lt;/a&gt;，这个仓库还绑定了 gitbook 可以去下载。&lt;/blockquote&gt;&lt;p&gt;从这一篇文章开始就进入了 SICP 第四章的内容了，在前三章的内容之中我们接触了 &lt;code&gt;数据抽象&lt;/code&gt;，&lt;code&gt;过程抽象&lt;/code&gt;，&lt;code&gt;模块化&lt;/code&gt; 三个，第四章的内容主要就是实现了一个元循环解释器 (meta-circular) 并对其进行不断地改造引申出别的问题。从篇幅内容来看这一章的主要内容反倒是对当时初读的我最为简单的，因为在学过编译原理的相关课程之后，笔者已经尝试使用了自举的方式实现了一些基于 JVM 的编程语言(这里也建议大家在学习理论的同时也要加强知识的运用，否则没有实际的使用过很多知识就不是那么立体)。本章我们对这个 Scheme 求值器的具体实现不会介绍的特别具体，毕竟书上已经把全部代码都贴上去了，这里更想关注一些引申的问题。&lt;/p&gt;&lt;p&gt;在之前的篇幅之中我们讨论了很多和程序设计相关的内容，主要研究的三个内容是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;数据抽象：如何组合程序的基本元素，构造更复杂的结构&lt;/li&gt;&lt;li&gt;过程抽象：如何将复杂的结构抽象出高层组件，提供更高维度的组合型&lt;/li&gt;&lt;li&gt;模块化，通过高抽象层次的组织方法，提高系统的模块性&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;通过这些手段已经足够我们设计大部分程序了，但是现实世界中遇到的问题可能更为复杂，或者可能类似的问题出现在同一个领域内。这时候我们可能就要在程序之中引入 &lt;b&gt;DSL&lt;/b&gt;(领域内语言)了。本质上来讲我们引入 DSL 就是通过语言设计，为程序提供一种 &lt;b&gt;语言层的抽象&lt;/b&gt; ，来进一步提高我们程序的模块化。&lt;/p&gt;&lt;h2&gt;元语言抽象&lt;/h2&gt;&lt;p&gt;这节之中我们会试着用 Scheme 来实现一个 Scheme 的解释器，用一种语言实现其自身的求值器，称为元循环（meta-circular）。这里我们可以复习一下 &lt;code&gt;3.2&lt;/code&gt; 节之中出现的求值模型，其中的求值流程分成两步：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;求值组合式（非特殊形式）时&lt;/li&gt;&lt;li&gt;先求值组合式的各子表达式&lt;/li&gt;&lt;li&gt;把运算符子表达式的值作用于运算对象子表达式的值&lt;/li&gt;&lt;li&gt; 把复合过程应用于实参，是在一个新环境里求值过程体&lt;/li&gt;&lt;li&gt;新环境：过程对象（里环境指针指向）的环境加一个新框架&lt;/li&gt;&lt;li&gt;新框架里是过程的形参与对应实参的约束&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这两个步骤构成了 Scheme 求值的基本循环，这两个步骤也是能相互调用和递归 (自己递归或相互递归。求值的子表达式可能要应用复合过程，过程体本身通常又是组合式)，逐步规约到：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;符号 (从 env 里面取值）&lt;/li&gt;&lt;li&gt;基本过程（直接调用基本过程的代码）&lt;/li&gt;&lt;li&gt;值类型 (primary type 直接取值)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上的两个步骤可以被抽象为过程 eval 和 apply ，其中 eval 负责表达式的求值，apply 把一个过程对象应用于一组实际参数，这两者相互递归调用，eval 还有自递归。eval 和 apply 就像下图的这个像是太极图一样的图里，两者相互调用相互生成。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ec53e1568b737c4761f975ab7c7ecd80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1542&quot; data-rawheight=&quot;878&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1542&quot; data-original=&quot;https://pic1.zhimg.com/v2-ec53e1568b737c4761f975ab7c7ecd80_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ec53e1568b737c4761f975ab7c7ecd80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1542&quot; data-rawheight=&quot;878&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1542&quot; data-original=&quot;https://pic1.zhimg.com/v2-ec53e1568b737c4761f975ab7c7ecd80_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ec53e1568b737c4761f975ab7c7ecd80_b.jpg&quot;&gt;&lt;/figure&gt;&lt;h3&gt;基础的递归解释器&lt;/h3&gt;&lt;h3&gt;核心 eval 和 apply&lt;/h3&gt;&lt;p&gt;整个 &lt;code&gt;eval&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 的过程直接看代码实现就可以了，这里可以看到 &lt;code&gt;eval&lt;/code&gt; 的过程就是接受一个表达式 exp 和一个环境变量 env ，根据表达式类型的不同进行分别处理。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;cond &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;self-evaluating?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;; 基本表达式&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;variable?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lookup-variable-value&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; 特殊形式&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;quoted?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;text-of-quotation&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;assignment?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;eval-assignment&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;definition?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;eval-definition&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;                                               &lt;span class=&quot;c1&quot;&gt;; 组合形式&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unknown expression type: EVAL&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据 exp 分情况来处理的过程，里面大概有三种类型的处理：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;基本表达式：包括能够自求值的表达式、变量&lt;/li&gt;&lt;li&gt;各种特殊表达式：if、quote、lambda、cond 里面还会涉及到和 env 操作的部分&lt;/li&gt;&lt;li&gt;过程结构：递归的对各个子表达式进行求值，然后 apply 应用过程&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这里用 &lt;code&gt;cond&lt;/code&gt; 写了一个 &lt;code&gt;switch&lt;/code&gt; 结构的过程，这对处理的逻辑顺序有很多的要求，比如在一个 cond 的逻辑之中不同的分支的拜访位置不能有问题，不如使用数据分发的方式去设计这个 eval 的结构，还记得我们在第二章设计数据导向的 API 的时候做的事情么？首先是抽象一个 api 的表格：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; 操作／类型 ／过程&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;op&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;type&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;item&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 操作／类型&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;op&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;type&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后给数据类型打上 tag 然后在使用前预先 install 对应的 api，这里我们甚至可以把不同类型的相同实现给出相同的名称，方便直接根据 data-type 去调用：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;install-rectangular-package&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; internal procedures&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;real-part &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;car &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;imag-part &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;; ... 省略其中的过程&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;make-from-real-imag&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;rectangular&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-from-real-imag&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;make-from-mag-ang&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;rectangular&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-from-mag-ang&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&#39;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过暂时我们先不这么做，因为现在明显我们的 &lt;code&gt;eval&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 的过程是混杂在一起，我们并没有对 expr 进行相应的预处理给每种数据结构打上 tag，这里可以看到 &lt;code&gt;eval&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 的互生带来了解释器设计和实现上的便利，但是也在具体的效率、代码编写的规范和拓展性上有了一定的问题。&lt;/p&gt;&lt;p&gt;接着来看核心的 &lt;code&gt;apply&lt;/code&gt; 过程吧，&lt;code&gt;apply&lt;/code&gt; 的应用过程就简单了很多，把 &lt;code&gt;dispatch&lt;/code&gt; 放到比较具体的调用环境：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;cond &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;primitive-procedure?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; primary procedure&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;apply-primitive-procedure&lt;/span&gt; 
          &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt; 
          &lt;span class=&quot;nv&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;compound-procedure?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; compound procedure&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;eval-sequence&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;procedure-body&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;extend-environment&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;procedure-parameters&lt;/span&gt; 
              &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;nv&quot;&gt;arguments&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;procedure-environment&lt;/span&gt; 
              &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unknown procedure type: APPLY&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;primitive procedure 是 Scheme 里面也会出现的原生过程，这部分在 &lt;code&gt;apply&lt;/code&gt; 的时候会直接下发给 Scheme 自带的 &lt;code&gt;apply procedure&lt;/code&gt; ，因此我们在自己定义 &lt;code&gt;apply&lt;/code&gt; 之前记得先保存下默认的实现。&lt;/li&gt;&lt;li&gt;compound-procedure 这个看起来也很简单，就是把各个 procedure 分别 eval 处理过之后又会回到 &lt;code&gt;apply&lt;/code&gt; 过程之中，一个互生的调用又出现了。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;表达式处理和派生表达式&lt;/h3&gt;&lt;p&gt;要是详细的介绍对各种表达式的处理过程未免失与琐碎，这里就只挑选一个有代表性的 &lt;code&gt;if&lt;/code&gt; 语句来介绍处理过程，&lt;code&gt;if&lt;/code&gt; 的具体 eval 实现过程如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;eval-if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;true?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-predicate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-consequent&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-alternative&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个过程非常的简单，其中的 &lt;code&gt;if-predicate&lt;/code&gt; , &lt;code&gt;if-consequent&lt;/code&gt; , &lt;code&gt;if-alternative&lt;/code&gt; 都很不过是取出整个 &lt;code&gt;if-expr&lt;/code&gt; 之中的不同部分的：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tagged-list?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-predicate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cadr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-consequent&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;caddr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-alternative&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;not &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;null? &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdddr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cadddr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;ss&quot;&gt;&#39;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;整个 &lt;code&gt;if&lt;/code&gt; 的流程就这样拆解完了，根据 &lt;code&gt;predicate&lt;/code&gt; 拆借出来的结果运算流程重新进入了 &lt;code&gt;eval&lt;/code&gt; 投入了其他表达式类型的求值过程之中。这里使用 &lt;code&gt;if&lt;/code&gt; 作为例子还有一个因素就是这个 DSL 实现之中的 &lt;code&gt;cond&lt;/code&gt; 语句没有自己的具体实现逻辑，而是依赖组合的 &lt;code&gt;if&lt;/code&gt; 实现的，这被称作派生表达式。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tagged-list?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-clauses&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-else-clause?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-predicate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-predicate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;car &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-actions&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-&amp;gt;if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;expand-clauses&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-clauses&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;expand-clauses&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clauses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;null? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;clauses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;ss&quot;&gt;&#39;false&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;; no else clause&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;car &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;clauses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;clauses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-else-clause?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;null? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sequence-&amp;gt;exp&lt;/span&gt; 
                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-actions&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ELSE clause isn&#39;t &lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;                        last: COND-&amp;gt;IF&quot;&lt;/span&gt;
                       &lt;span class=&quot;nv&quot;&gt;clauses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-predicate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sequence-&amp;gt;exp&lt;/span&gt; 
                      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-actions&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;expand-clauses&lt;/span&gt; 
                      &lt;span class=&quot;nv&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这段代码比较核心的也就是 &lt;code&gt;cond-&amp;gt;if&lt;/code&gt; 相关的函数了，但是也非常的简单就是解析 &lt;code&gt;cond&lt;/code&gt; 的结构，层层解析然后通过 &lt;code&gt;make-&amp;gt;if&lt;/code&gt; 生成逐级的 &lt;code&gt;nested-if&lt;/code&gt; 。&lt;/p&gt;&lt;h3&gt;解释器环境操作&lt;/h3&gt;&lt;p&gt;解释器的运行环境和我们在第一章、第二章里面解释过的运行环境基本上是一个东西，这不过这里面我们要来手动实现这个环境。这里我们把环境理解为绑定参数的表格就好了。这里给出了环境提供的默认的几个 API：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lookup-variable-value&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;extend-environment&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;base-env&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;define-variable!&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-variable-value!&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;其中的 &lt;code&gt;lookup-variable-value&lt;/code&gt; 负责了在环境之中查找对应的变量，而  &lt;code&gt;extend-environment&lt;/code&gt; 则是在根据上级环境来拓展新的 env。&lt;/li&gt;&lt;li&gt;&lt;code&gt;define-variable!&lt;/code&gt; 和 &lt;code&gt;set-variable-value!&lt;/code&gt; 这一对 API 就比较简单了在环境之中定义变量和修改变量。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt; Tips 基础递归解释器的 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk/SICP-Magical-Book/blob/master/code/meta-evaluator/evaluator.rkt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;源码&lt;/a&gt;：&lt;br&gt; 这里给出了基础的递归解释器的实现代码，这里的程序可以直接使用 &lt;code&gt;racket&lt;/code&gt; 运行，记得要安装 &lt;code&gt;sicp&lt;/code&gt; 的包。&lt;br&gt; PS：这里还有一个问题，就是之前提到要提前把 &lt;code&gt;apply&lt;/code&gt; 方法保存起来，但是如果保存的过程和 &lt;code&gt;apply&lt;/code&gt; 的定义同时出现在一个文件里，就会被 &lt;code&gt;racket&lt;/code&gt; 认为是提前使用未定义方法 orz，因此这里我们单独把这个方法单独提出到一个文件里面引用了。&lt;br&gt; &lt;/blockquote&gt;&lt;h3&gt;以数据作为程序&lt;/h3&gt;&lt;p&gt;在上一节 &lt;code&gt;基础的递归解释器&lt;/code&gt; 之中我们实现了一个用 Scheme 描述的 Scheme 解释器，我们意识到一个元循环解释器本质上也是一个 Scheme procedure 本身，只不过输入的内容变成了 Scheme 程序本身。这也就是本节标题的意味，我们以数据作为求值器的输入，因此我们能够把数据作为程序来使用。&lt;/p&gt;&lt;p&gt;举出一个我们非常熟悉的 &lt;code&gt;factorial&lt;/code&gt; 过程：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;= &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;* &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们把这个过程看做一台机器，那我们就获得了一台只能够计算斐波那契数的机器：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a748e2250040f10540e9a6fc7b1b4d1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;324&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;500&quot; data-original=&quot;https://pic2.zhimg.com/v2-a748e2250040f10540e9a6fc7b1b4d1d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a748e2250040f10540e9a6fc7b1b4d1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;324&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;500&quot; data-original=&quot;https://pic2.zhimg.com/v2-a748e2250040f10540e9a6fc7b1b4d1d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a748e2250040f10540e9a6fc7b1b4d1d_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;如果我们接受了这种设定，那我们就可以以更高维度的眼光来看我们上述的元循环求值器。如果 &lt;code&gt;factorial&lt;/code&gt; 是一个特定的机器，那本身求值器就可以被认为是一台通用机器 (要素察觉)，其输入不再是一个具体的内容而是另一台机器（程序）的描述，而功能则变成了对这个机器的模拟过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-138b930b9c48b12eeb6a1377b4c30ba5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;479&quot; data-rawheight=&quot;289&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;479&quot; data-original=&quot;https://pic2.zhimg.com/v2-138b930b9c48b12eeb6a1377b4c30ba5_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-138b930b9c48b12eeb6a1377b4c30ba5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;479&quot; data-rawheight=&quot;289&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;479&quot; data-original=&quot;https://pic2.zhimg.com/v2-138b930b9c48b12eeb6a1377b4c30ba5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-138b930b9c48b12eeb6a1377b4c30ba5_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;这里我们意识到，我们上面的描述 &quot;另一台机器&quot; 并不准确，求值器是 Scheme 的一个 procedure ，因此求值器本身也可以描述自己。这也就是在书中元循环解释器为什么会被描述为编程语言和用户之间的桥梁，因为用户的输入本身成为了程序运行的一部分，现代的大多数语言也大多都实现了应用内的 &lt;code&gt;eval&lt;/code&gt; 过程。&lt;/p&gt;&lt;p&gt;其实在书中我们曾经提供以数据为程序的思想，当时的方式是把过程当成可传递的元素来处理，而现在我们能够提供更高层次的数据抽象 —— 抽象到语言。&lt;/p&gt;&lt;h3&gt;图灵机&lt;/h3&gt;&lt;p&gt;我们在上文中提到了求值器本质上是一个 &lt;code&gt;&quot;通用机器&quot;&lt;/code&gt; ，这种描述方式让人感觉似曾相识。按照我们上文讨论的说法，我们通过 Scheme 本身实现了一个 Scheme 的解释器，忽略时间和空间的角度上来讲一个解释器可以模拟任意的其他解释器。这样原则上可计算的概念向我们揭示了一个有关 &lt;code&gt;可计算性的&lt;/code&gt; 全新的领域，图灵根据上文的相似思想给出了称为图灵机的计算模型，证明了计算机的可实现。&lt;/p&gt;&lt;p&gt;图灵的基本思想是用机器来模拟人们用纸笔进行&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%2595%25B0%25E5%25AD%25A6&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;数学&lt;/a&gt;运算的过程，他把这样的过程看作下列两种简单的动作：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在纸上写上或擦除某个符号；&lt;/li&gt;&lt;li&gt;把注意力从纸的一个位置移动到另一个位置；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而在每个阶段，人要决定下一步的动作，依赖于（a）此人当前所关注的纸上某个位置的符号和（b）此人当前思维的状态。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-af98d4613865db3338ecd8422f11938e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;78&quot; class=&quot;content_image&quot; width=&quot;300&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-af98d4613865db3338ecd8422f11938e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;78&quot; class=&quot;content_image lazy&quot; width=&quot;300&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-af98d4613865db3338ecd8422f11938e_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3c21478a6a1aad0e5565d0e5f630a5b9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;84&quot; class=&quot;content_image&quot; width=&quot;300&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3c21478a6a1aad0e5565d0e5f630a5b9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;84&quot; class=&quot;content_image lazy&quot; width=&quot;300&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3c21478a6a1aad0e5565d0e5f630a5b9_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了模拟人的这种运算过程，图灵构造出一台假想的机器，该机器由以下几个部分组成：&lt;/p&gt;&lt;ol&gt;&lt;li&gt; 一条无限长的纸带&lt;b&gt;TAPE&lt;/b&gt;。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号 ${\displaystyle \square } $ 表示空白。纸带上的格子从左到右依次被编号为0, 1, 2, ...，纸带的右端可以无限伸展。&lt;br&gt; &lt;/li&gt;&lt;li&gt; 一个读写头&lt;b&gt;HEAD&lt;/b&gt;。该读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。&lt;br&gt; &lt;/li&gt;&lt;li&gt; 一套控制规则&lt;br&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;TABLE&lt;/p&gt;&lt;p&gt;。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态，按照以下顺序告知图灵机命令：&lt;/p&gt;&lt;ol&gt;&lt;li&gt; 写入（替换）或擦除当前符号；&lt;br&gt; &lt;/li&gt;&lt;li&gt; 移动 &lt;b&gt;HEAD&lt;/b&gt;， &#39;L&#39;向左， &#39;R&#39;向右或者&#39;N&#39;不移动；&lt;br&gt; &lt;/li&gt;&lt;li&gt; 保持当前状态或者转到另一状态&lt;br&gt; &lt;/li&gt;&lt;li&gt; 一个&lt;b&gt;状态寄存器&lt;/b&gt;。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态，称为&lt;i&gt;停机状态&lt;/i&gt;。&lt;br&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;注意这个机器的每一部分都是有限的，但它有一个潜在的无限长的纸带，因此这种机器只是一个理想的设备。图灵认为这样的一台机器就能模拟人类所能进行的任何计算过程。图灵机这样的定义在我们现在看来是显然的，基本上就是一个 &lt;code&gt;有限状态机&lt;/code&gt;的通俗化描述，但是在计算机还未诞生的当时代表了一种伟大的思想性革命。&lt;/p&gt;&lt;p&gt;结合上文，如果和我们使用的 Scheme 类比，每个 procedure 都能类比为一个特定的图灵机，那我们制作的 Scheme 解释器就可以类比于 &lt;code&gt;元图灵机(Universal Turing-Machine)&lt;/code&gt; ，元图灵机以其他的图灵机作为输入能够模拟其他图灵机的行为，这也是为何我们说 &lt;code&gt;通用机器&lt;/code&gt; 的描述不谋而合了。&lt;/p&gt;&lt;blockquote&gt; Tips: 关于可计算性 (Computability) &lt;br&gt; 关于图灵机、可计算性相关的知识笔者也只有概念上的理解。涉及到具体知识的学习笔者在看 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//introtcs.org/public/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CS121 Introduction to Theoretical Computer Science&lt;/a&gt; 这门入门课和 《Computability》这本书。&lt;br&gt; &lt;/blockquote&gt;&lt;h3&gt;停机问题&lt;/h3&gt;&lt;p&gt;在上一节图灵机的描述里面我们提到了图灵机有一个特殊的停机问题，通俗地说，停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。这个题目也出现在了书中的 4.15 题目之中：&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Exercise 4.15:&lt;/b&gt; Given a one-argument procedure &lt;code&gt;p&lt;/code&gt; and an object &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; is said to “halt” on &lt;code&gt;a&lt;/code&gt; if evaluating the expression &lt;code&gt;(p a)&lt;/code&gt;returns a value (as opposed to terminating with an error message or running forever). Show that it is impossible to write a procedure &lt;code&gt;halts?&lt;/code&gt; that correctly determines whether &lt;code&gt;p&lt;/code&gt; halts on &lt;code&gt;a&lt;/code&gt; for any procedure &lt;code&gt;p&lt;/code&gt; and object &lt;code&gt;a&lt;/code&gt;. Use the following reasoning: If you had such a procedure &lt;code&gt;halts?&lt;/code&gt;, you could implement the following program:&lt;br&gt; &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run-forever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run-forever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;halts?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run-forever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;ss&quot;&gt;&#39;halted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 &lt;code&gt;halts&lt;/code&gt; 肯定是找不到的，&lt;code&gt;try&lt;/code&gt; 的实现本身就是 &lt;b&gt;交叉&lt;/b&gt; 矛盾的，如果有 &lt;code&gt;(halts? p p )&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; 那就会 &lt;code&gt;run-forever&lt;/code&gt; 持续运行下去，而如果 &lt;code&gt;(halts? p p)&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt;，那么程序又会 &lt;code&gt;halted&lt;/code&gt; 。因此我们能非常直观的从程序而非逻辑、数学的角度来发现这个问题。&lt;/p&gt;&lt;blockquote&gt; Tips 其实图灵发现的这个奇怪的反证方法并不是靠灵光一闪，而是康托尔 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25B0%258D%25E8%25A7%2592%25E8%25AB%2596%25E8%25AD%2589%25E6%25B3%2595&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;对角线方法&lt;/a&gt; 的一个实质的应用，读一下 《Gödel, Escher, Bach: An Eternal Golden Braid》 之中的相关章节，能获得更多的情报。&lt;br&gt; &lt;/blockquote&gt;&lt;h3&gt;内部定义&lt;/h3&gt;&lt;p&gt;内部定义这一节里我们主要讨论的问题的主要是关于查找环境引用，我们上面实现的 &lt;code&gt;eval &amp;amp; apply&lt;/code&gt; 系统之中环境的置入都是按照顺序的，好在我们的 Scheme 求值器的方法定义和实际使用的求值时机不同。例子可以看一下这个互调的方法示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;even? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;= &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;odd? &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;odd? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;= &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;even? &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rest&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;even&lt;/code&gt; 的过程被定义的时候 &lt;code&gt;odd&lt;/code&gt; 的实现还没有被定义，按照我们的定义的语义应该是 &lt;code&gt;even&lt;/code&gt; 和 &lt;code&gt;odd&lt;/code&gt; 同时被加入该环境。这在实际之中很难被实现，不过我们也应该能很简单的想出解决办法，可以在原部分放一个名字或者一个假的引用，当对应的 &lt;code&gt;define&lt;/code&gt; 被填充进去了之后被调用就能正常被 link 到了。书中给出的方法其实也是其中的一种方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vars&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;; 转换成&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vars&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;*unassigned*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;*unassigned*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set! &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set! &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里是通过自动为每个定义块自动提前添加一个 &lt;code&gt;let&lt;/code&gt; 的定义项目，然后先设置为预定义状态，然后当对应的项目被定义之后再对其进行重定义。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;这一节的内容比较的简单，主要是通过对前几章提供的抽象手段，再一次提供一个更为深入的抽象方法 —— 语言抽象。随即我们引入 &lt;code&gt;eval &amp;amp; apply&lt;/code&gt; 的核心流程、增加解释器的环境操作，完成了基础的 Scheme 元循环解释器。随后又讨论了和程序抽象环境查找的一些 case ，浅尝辄止的引入了和图灵机、停机问题的相关讨论。下一章里面我们会对基础的 Scheme 解释器实现进行修改，增加诸如 JIT、amb 实现等相关内容。&lt;/p&gt;</description>
<author>lfkdsk</author>
<guid isPermaLink="false">2019-03-21-59996663</guid>
<pubDate>Thu, 21 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>试论 co- 的译法：余弦 cosine 词源漫谈</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-21-56285253.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56285253&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-67648d140ef6622892298c7b7d3b66a7_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;本文作为生日礼物题献给 &lt;/b&gt;&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/67ebe1bd8e4a63f17a42572e40afaac7&quot; data-hash=&quot;67ebe1bd8e4a63f17a42572e40afaac7&quot; data-hovercard=&quot;p$b$67ebe1bd8e4a63f17a42572e40afaac7&quot;&gt;@兴趣使然千里冰封&lt;/a&gt;&lt;b&gt;，内容以深度优先遍历的方式论述。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;题图为&lt;/b&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.pixiv.net/member_illust.php%3Fmode%3Dmedium%26illust_id%3D66039061&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;鬼人正邪&lt;/a&gt;&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;#2019-3-14 更新&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;在思考了各种现行翻译和词义演变的现象后，笔者最终还是决定在一些情况下将 co- 译作「余」，即将「余」字的含义泛化，等同于 co-。这样处理后可以避免各种歧义和不必要的联想，也方便翻译工作。如果有人好奇 co- 翻译成「余」的原因，那么可以将本文作为参考来源告知。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;根据评论里 Sora 的说法：&lt;/p&gt;&lt;blockquote&gt;私以为 coinductive 用“余”还更好点，因为它有“恰到好处的疏离感”。跟其他的， where “逆”有特定含义的数学分支凑在一起时，这样反而可能引起不好的联想，逆似乎暗示着某种结合性。上同调那个就是很好的例子，并不是什么都反过来了。要是动用一点“空间想象”，我们也可以把 inductive 跟 coinductive 当成图论里那种对偶--在概念的空间里互相插空--的关系。&lt;br&gt;另外，似乎 co- 因能指广泛被（懒惰的）数学家拿来当 gateway 用才让事情变得这么麻烦的&lt;/blockquote&gt;&lt;p&gt;以下为原文：&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;从勾股定理到三角函数&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;数之法，出于圆方。圆出于方，方出于矩。矩出于九九八十一。故折矩，以为句广三，股修四，径隅五。既方之外，半其一矩。环而共盘，得成三、四、五。两矩共长二十有五，是谓积矩。&lt;/blockquote&gt;&lt;p&gt;这段话出自我国的第一部数学著作《周髀算经》，开篇即是商高对勾股定理的最早表述。因此勾股定理又称商高定理。其中「句广三，股修四，径隅五」为勾股定理最经典的一个特例。后人则直接简称为「勾三股四弦五」来表述勾股定理。&lt;br&gt;&lt;br&gt;呃..简称？简在哪了？句怎么变成了勾？径怎么变成了弦？「广」「修」「隅」又是什么鬼？这要从甲古文说起。&lt;br&gt;&lt;br&gt;先说勾。其实汉字在隶变之前并没有这个字，而只有「句（gōu）」字。句源于丩，甲古文和金文如下图所示，很像一个钩子上挂了东西：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ce7512d8460d8b8b724e852cd8c63d5d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;514&quot; data-rawheight=&quot;267&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;514&quot; data-original=&quot;https://pic2.zhimg.com/v2-ce7512d8460d8b8b724e852cd8c63d5d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ce7512d8460d8b8b724e852cd8c63d5d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;514&quot; data-rawheight=&quot;267&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;514&quot; data-original=&quot;https://pic2.zhimg.com/v2-ce7512d8460d8b8b724e852cd8c63d5d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ce7512d8460d8b8b724e852cd8c63d5d_b.jpg&quot;&gt;&lt;figcaption&gt;「句」的演变&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;丩在演变成金文时，多了下面的口字，许是用来钩鱼嘴的。一直到小篆，下面这个口都是可选的，后来才慢慢定了下来。在汉字的书体隶变时，口变成了厶，才有了现在的勾。同样因隶变而成为异体字的的还有「强」和「強」。&lt;br&gt;&lt;br&gt;那么「句」又是如何有了「语句」的意思呢？原因是古文中没有标点，教学时要明句读。为了辅助标记，便在断句处的字旁边勾一个𠄌，久而久之，「勾」便有了语句的意思。勾句自此分化。兴许是为了表示区分，用带厶的表示勾批，用带口的表示语句。至于朱批句读画出的圆圈变成了句号，那是后话了。&lt;br&gt;&lt;br&gt;说到这里，不得不提一下被万千程序员吐槽的「句柄（handle）」。「柄」好理解，「句」哪来的？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;句柄乎？勾柄乎？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;「句柄」一词最早的考证来自于一本编译原理的著作，指的是语句中最先被归约的部分。维基百科中该词条给出的来源如下：&lt;/p&gt;&lt;blockquote&gt;康奈尔大学副教授David Gries所著的《Compiler Construction for Digital Computer》. John Wiley and Sons, New York, 1971, 491 pages, ISBN 0-471-32776-X，给出如下定义：&lt;br&gt;(2.3.10) DEFINITION. A handle of any sentential form is a leftmost simple phrase.&lt;br&gt;&lt;br&gt;在该书的中译本： D.格里斯著,仲萃豪等译：《数字计算机的编译程序构造》，科学出版社, 1976年版，给出了如下翻译：&lt;br&gt;(2.3.10) 定义. 任一句型的句柄就是此句型的最左简单短语。&lt;/blockquote&gt;&lt;p&gt;这里似乎应当读 jù 了，可后面紧接着又来了一句：&lt;/p&gt;&lt;blockquote&gt;「句」字在汉语中发 gōu 音时，做「查考」之义，如:句校(查考校核);句考(查考);句稽(查考;核算)。&lt;/blockquote&gt;&lt;p&gt;而「句」作「查考」解的来源，则是古人在查阅卷集时「勾批」的动作衍生而来的。&lt;/p&gt;&lt;p&gt;很明显，原文中只是「句子」，并无「查考」之意。&lt;br&gt;&lt;br&gt;然而，handle 还有另一个意思：&lt;/p&gt;&lt;blockquote&gt;在程序设计中，句柄（handle）是 Windows 操作系统用来标识被应用程序所创建或使用的对象的整数。其本质相当于带有引用计数的智能指针。&lt;/blockquote&gt;&lt;p&gt;这个解释更为广大程序员所熟知。在这里，「句柄」变成了用以索取对象这个大头的小钩子，正如提起一只樱桃时双指捏住的果柄。而在使用 git cherry-pick 时，散列值（hash）便成了对应提交（commit）的勾柄（handle）或指针（pointer）。&lt;br&gt;&lt;br&gt;handle 本有两义，在翻译成汉语时也应区别对待。仲老古汉语修为颇深，在翻译语句的 handle 时想到了「柄」字。而后人遇到了作为指针的 handle 时，前面的「句」想也不想便直接拿来用了。而巧合的是，「句」作「勾」解居然也是可以的。&lt;/p&gt;&lt;p&gt;网上有人说「句柄」是「勾柄」打错了字，虽是臆测，不过也不失为一个好写法。有鉴于此，我比较倾向于&lt;a href=&quot;https://www.zhihu.com/question/64808475/answer/224510814&quot; class=&quot;internal&quot;&gt;「句柄」的句应该读jù还是gōu？ - 思無邪SyiMyuZya的回答&lt;/a&gt;，即表示语句（sentence）时，读 jù。而作指针解时，「勾柄」则是现代汉语中更好的写法。&lt;br&gt;&lt;br&gt;其实「勾柄」这个东西，99%的中国人都见过，也都用过。用白话说，勾柄就是弯弯的「把手」，它长这样：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-70afcc93359534c44200465ee5fe31d9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2000&quot; data-rawheight=&quot;1250&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2000&quot; data-original=&quot;https://pic2.zhimg.com/v2-70afcc93359534c44200465ee5fe31d9_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-70afcc93359534c44200465ee5fe31d9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2000&quot; data-rawheight=&quot;1250&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2000&quot; data-original=&quot;https://pic2.zhimg.com/v2-70afcc93359534c44200465ee5fe31d9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-70afcc93359534c44200465ee5fe31d9_b.jpg&quot;&gt;&lt;figcaption&gt;门把手&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;而还有一种东西，它在某宝上的名字叫「勾柄直杆伞」，它长这样：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0074ca36aad3b04f9a2145317cb21dce_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3500&quot; data-rawheight=&quot;2372&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;3500&quot; data-original=&quot;https://pic3.zhimg.com/v2-0074ca36aad3b04f9a2145317cb21dce_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0074ca36aad3b04f9a2145317cb21dce_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3500&quot; data-rawheight=&quot;2372&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;3500&quot; data-original=&quot;https://pic3.zhimg.com/v2-0074ca36aad3b04f9a2145317cb21dce_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0074ca36aad3b04f9a2145317cb21dce_b.jpg&quot;&gt;&lt;figcaption&gt;Pixiv ID: 72998875&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;相信你已经知道什么是句柄了。&lt;/p&gt;&lt;p&gt;跑个题：「套接管」长这个样子：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0a45495ec4cc024ddb7a530deabdbb84_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;309&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;580&quot; data-original=&quot;https://pic1.zhimg.com/v2-0a45495ec4cc024ddb7a530deabdbb84_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0a45495ec4cc024ddb7a530deabdbb84_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;309&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;580&quot; data-original=&quot;https://pic1.zhimg.com/v2-0a45495ec4cc024ddb7a530deabdbb84_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-0a45495ec4cc024ddb7a530deabdbb84_b.jpg&quot;&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;修广长宽，径隅成弦&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;说完了句，后面就好说了。「修」表示长，「广」表示宽。「宽广」「修长」，汉语中很常见的近义字组词。《诗经·小雅·六月》中亦有「四牡修广，其大有颙」来形容战马的长宽高大。&lt;br&gt;「股」是大腿，「句」是曲折勾起来的脚。用勾股来形容短边长边，再合适不过了。&lt;br&gt;（&lt;b&gt;此处应有冰冰黑丝勾股照.jpg&lt;/b&gt;）有趣的是，广本意为宽，到了矩形里却成了短边。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2be199ce7efa402491a2ab696319480_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;375&quot; data-rawheight=&quot;281&quot; class=&quot;content_image&quot; width=&quot;375&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2be199ce7efa402491a2ab696319480_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;375&quot; data-rawheight=&quot;281&quot; class=&quot;content_image lazy&quot; width=&quot;375&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a2be199ce7efa402491a2ab696319480_b.jpg&quot;&gt;&lt;figcaption&gt;曲尺&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;「折矩」语出《礼记 - 玉藻》：「周还中规，折还中矩。」后亦有《复庄卫生书》：「周规折矩，尺步绳趋」。用矩尺定的折角，就是直角。&lt;/p&gt;&lt;p&gt;「径」为形声字，从「彳(chì)」「巠」声。本义为步行小路。「远上寒山石径斜」就是这个意思。「勾股」成曲，「径直」走的近路便是指长边了。&lt;/p&gt;&lt;p&gt;「隅」为角落，「偏安一隅」就是这个意思。把一根棍子搭在墙角，就是径隅。&lt;br&gt;&lt;br&gt;「故折矩，以为句广三，股修四，径隅五。」&lt;br&gt;&lt;br&gt;这句话翻译成现代汉语就是：如果有一个直角，短边宽三，长边长四，那么搭在这个角上的斜边就是五。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-93d0fb80cde6b41f31ddb943482f9db4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;330&quot; data-rawheight=&quot;266&quot; class=&quot;content_image&quot; width=&quot;330&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-93d0fb80cde6b41f31ddb943482f9db4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;330&quot; data-rawheight=&quot;266&quot; class=&quot;content_image lazy&quot; width=&quot;330&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-93d0fb80cde6b41f31ddb943482f9db4_b.jpg&quot;&gt;&lt;figcaption&gt;勾股定理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;现在还有个问题：径是怎么变成弦的？&lt;/p&gt;&lt;p&gt;弦即弓弦，下面这个图形叫「弓形」，其中的线段 AB 就是「弦」：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8ed4dedf989fb2cecbc33f03dfbb519f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1238&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-8ed4dedf989fb2cecbc33f03dfbb519f_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8ed4dedf989fb2cecbc33f03dfbb519f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1238&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-8ed4dedf989fb2cecbc33f03dfbb519f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8ed4dedf989fb2cecbc33f03dfbb519f_b.jpg&quot;&gt;&lt;figcaption&gt;弓形&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当弦最长时，所得弓形即为半圆。&lt;/p&gt;&lt;p&gt;周朝的《周髀算经》虽然记载了商高对勾股定理的描述，但并没有给出严格的证明。到了三国时期，赵爽在他的《周髀算经注·勾股圆方图说》中第一次给出了勾股定理的严格证明。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a614f7c2b42e522274d5fef0e590a568_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;871&quot; data-rawheight=&quot;475&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;871&quot; data-original=&quot;https://pic1.zhimg.com/v2-a614f7c2b42e522274d5fef0e590a568_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a614f7c2b42e522274d5fef0e590a568_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;871&quot; data-rawheight=&quot;475&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;871&quot; data-original=&quot;https://pic1.zhimg.com/v2-a614f7c2b42e522274d5fef0e590a568_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a614f7c2b42e522274d5fef0e590a568_b.jpg&quot;&gt;&lt;figcaption&gt;赵爽 - 勾股圆方图&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cf26c0f675c973e07d3aaaedf5817b38_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;236&quot; class=&quot;content_image&quot; width=&quot;270&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cf26c0f675c973e07d3aaaedf5817b38_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;236&quot; class=&quot;content_image lazy&quot; width=&quot;270&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cf26c0f675c973e07d3aaaedf5817b38_b.jpg&quot;&gt;&lt;figcaption&gt;泰勒斯定理：如果AC是直径，那么∠ABC是直角。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;到了这里，勾股定理和圆的联系已呼之欲出，径也自然变成了直角三角的弦。魏晋时期的《九章算术》所用术语已于今无二：「勾股各自乘，并之，为弦实。开方除之，即弦。」我们终于可以说「勾三股四弦五」了。随之而来的「周三径一」，径也有了圆的直径的意思。后世宋朝的祖冲之也沿用了这一名词。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;西学东渐，余正相生&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;时光荏苒，转眼已到了明朝末年，这是第一次西学东渐开始的时代。&lt;/p&gt;&lt;blockquote&gt;三角学传入中国，始于明崇祯 4 年（1631年）。是年，邓玉函、汤若望和徐光启合编《大测》，作为历书的一部份呈献给朝廷，这是我国第一部编译的三角学。在《大测》中，首先将 sine 译为「正半弦」，简称「正弦」，这就成了「正弦」一词的由来。&lt;/blockquote&gt;&lt;p&gt;其实 sine 源于拉丁语 sinus，本意为「衣物的褶边，弯曲，曲线，女人的胸部」。可是本来表示弯曲的词，怎么又变成了直的弦了呢？&lt;/p&gt;&lt;p&gt;原来在最初，印度人将连结弧的两端的弦称为 ज्या (jyā)，源自梵语弓弦 जीव (jīva)。后来 jīva 这个词被中世纪伊斯兰数学家沿用了下来，译成了阿拉伯语     (jība)。由于阿拉伯语不写短元音，就以长元音 yāʾ 表示，写成了同形异义词 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+++++%E2%80%8E&quot; alt=&quot;     ‎&quot; eeimg=&quot;1&quot;&gt; (jayb)，意为「胸部，乳房」。到了 12 世纪中叶，意大利克雷莫纳的 Gherardo 在将一本阿拉伯文的几何学著作转译成中世纪拉丁语时，没有辨清词义，把本应指弓弦的 jayb 直译成了拉丁语中对应的乳房「sinus」。1590 年代，Thomas Fale 在他论述日晷的著作《Horologiographia, the Art of Dialling》一书中首先用 sinus 来表示现代三角学意义上的正弦函数。之后演变成了英语中的 sine。这样一来，「弦」就被掰弯了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0cf8f042eaca02e5cdd731d15a02b68_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;376&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;498&quot; data-original=&quot;https://pic1.zhimg.com/v2-c0cf8f042eaca02e5cdd731d15a02b68_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0cf8f042eaca02e5cdd731d15a02b68_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;376&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;498&quot; data-original=&quot;https://pic1.zhimg.com/v2-c0cf8f042eaca02e5cdd731d15a02b68_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c0cf8f042eaca02e5cdd731d15a02b68_b.jpg&quot;&gt;&lt;figcaption&gt;维基百科：梵语 jyā 的字面意思&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;而徐光启并未受此影响，因为他直接看到了三角函数的图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;470&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;676&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;470&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;676&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot;&gt;&lt;figcaption&gt;三角函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当然他看到的并不是这张图，但相信与此类似。中国古代研究圆时，向来以直径为基准，因此有「周三径一」的说法。徐光启在《大测》中，以圆的直径为基准，∠AOB 正对弓形 ADB 的弦 AB，即为正弦，线段 AC 则为正半弦。&lt;/p&gt;&lt;p&gt;而他在和利玛窦合译《几何原本》第三卷《圆与角》时，发现书中以半径为基准。由于三角函数的「正弦」描述的其实是正弦与直径之比，而等比缩放不改变比例关系，因此正半弦与半径之比自然还应该叫「正弦」。&lt;br&gt;&lt;br&gt;三角之于圆，有三条直线：弦线，切线和割线。sine line 为弦线，tangent line 为切线，secant line 为割线。如果把下图的 sin 和 tan 沿横轴对称补上，sec 以圆心对称补上，那就是汉语里原本意义上的弦、切和割了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4018dcbdeb6bfb115b5d5786b08f1e88_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;599&quot; class=&quot;content_image&quot; width=&quot;410&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4018dcbdeb6bfb115b5d5786b08f1e88_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;599&quot; class=&quot;content_image lazy&quot; width=&quot;410&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4018dcbdeb6bfb115b5d5786b08f1e88_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;相信不少人曾有这样的困惑：「切」和「割」有什么区别呢？其实在日常生活中，二者意思很接近。「割」就是割开，一分为二；「切」呢？还是切开的意思。&lt;/p&gt;&lt;p&gt;然而在「切线」这里，「切」其实应该读 qiè。《广雅》中有「切，摩也。」的解释。确切来说，就是「密合，贴近，紧挨着」的意思。「切脉」不是割脉，而是手指贴着脉来感受；「切肤之痛」也不是皮肤被划破了，而是与自身关系极为密切，自己能切身感受的痛苦。如果你是还不能理解，那么别人在对你表示亲切问候，深切关怀时，请做好防御准备（病娇控除外）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-89a970c841c649877f05e8b24d17e3d4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;450&quot; data-original=&quot;https://pic1.zhimg.com/v2-89a970c841c649877f05e8b24d17e3d4_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-89a970c841c649877f05e8b24d17e3d4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;450&quot; data-original=&quot;https://pic1.zhimg.com/v2-89a970c841c649877f05e8b24d17e3d4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-89a970c841c649877f05e8b24d17e3d4_b.jpg&quot;&gt;&lt;figcaption&gt;切与割&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;「切」读 qiē 时，和割还是有些区别的。割其实还有个「划拉」的动作，你可以从「割肉」「切水果」感受出来。&lt;/p&gt;&lt;p&gt;到这里，「正弦」「正切」「正割」已经溯本清源。现在终于轮到本文的主角「余」了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;470&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;676&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;470&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;676&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot;&gt;&lt;figcaption&gt;三角函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们还来看这张图。现在想象你站在圆心 O 点，向 E 处看去。∠AOB 是你可以清楚看到的范围，正前方的正弦是你看到的画面。然而当你注视前方时，你会还会发现视角的两边也能感受到模糊的画面，这叫做眼角的「余光」。余光所看到的画面（图中蓝线），就是余弦。&lt;br&gt;&lt;br&gt;「余」即剩余，我们在数学中最早接触的「余」就是「余数」，表示除不尽剩下的数。如果我们把正视的角叫「正角」∠AOB，那么余光所视的角就是它的「余角」∠AOF。于是我们得到了余角的定义：&lt;/p&gt;&lt;p&gt;若两角之和为直角（即 90°），则称这两个角「互为余角（complementary angles）」，简称「互余」。余角所对的弦，就是余弦。&lt;/p&gt;&lt;p&gt;顺带一提，若两角之和为平角（即 180°），则称这两个角「互为补角（supplementary angle）」，简称「互补」。&lt;/p&gt;&lt;p&gt;互余（complementary）的前缀 com-，和余弦（cosine）的 co- 其实来自同一个词源，作为拉丁语的前缀表示「一起，相伴（with, together）」的意思。com- 放到元音和轻音之前，变成了 co-；在 -g- 前，为 cog- 或 con-；在 -l- 前，为 col-；在 -r- 前为 cor-；在 -c-、-d-、-j-、-n-、-q-、-s-、-t- 和 -v- 前则化成了 con-。&lt;/p&gt;&lt;p&gt;一根射线将直角分为两半，二角相伴相生，此消彼长。所对应的正弦余弦亦是如此。然而在中文里，「余」只有剩余的意思，因此并不能把所有的 co- 都翻译成余。实际上，一切相生相克的东西，都是互 co- 的。男是 co-女，阴是 co-阳，天是 co-地，柔是 co-刚。&lt;/p&gt;&lt;p&gt;所以 co- 有了太多太多的译法：&lt;br&gt;&lt;br&gt;coerce 是围在一起，成了约制；covariant 是一起变型，成了协变；collect 是选出来放在一起，成了收集；conjugate 比作马车曲木的两端，成了共轭。coauthor 是合作者；codomain 是陪域。&lt;/p&gt;&lt;p&gt;余、共、互、逆、陪、伴、协、同、交、合、配、对、逆、反、偶、上……我们在看到这个词头时，不必像意呆利那个把胸部当成 jiba 的曲直不分的家伙那样直译，而是像徐光启那样，直接看清它的本质是什么。&lt;b&gt;知其变，守其恒，为天下式。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当我看到陈意云老师把 coinduction 翻译成「余归纳」的时候，我很困惑：「余」在哪了？而当我发现 coinduction 就是把归纳的过程反过来后，自然就有了它的译法：逆归纳。「反」是一个静态的描述，而「逆」是一个动态的表述。当归纳的箭头有了流动的方向，逆流而上便是把箭头反过来最自然的想法了。于是在英语世界，有了很多关于 co- 的妙语：&lt;/p&gt;&lt;blockquote&gt;Q : What does a category theorist call a reader?&lt;br&gt;A : A &quot;co-author&quot;.&lt;br&gt;问：范畴论学家把读者称为什么？&lt;br&gt;答：「协作者」。&lt;br&gt;&lt;br&gt;&quot;I had a dream last night. I cheated on my wife and she knew it.&quot;&lt;br&gt;&quot;But dream is coreality.&quot;&lt;br&gt;&quot;So the reality is?&quot;&lt;br&gt;&quot;Your wife cheated on you and you didn&#39;t know it.&quot;&lt;br&gt;「我做了一个梦，梦见我对我妻子出轨了，被我妻子知道了。」&lt;br&gt;「可是梦是与现实伴生的（co-现实）。」&lt;br&gt;「所以现实应该是？」&lt;br&gt;「你的妻子对你出轨了，而你还不知道。」&lt;br&gt;&lt;br&gt;A mathematician is a machine that turns coffee into theorems.&lt;br&gt;A comathematician is a comachine that coturns cotheorems onto ffee.&lt;br&gt;&lt;br&gt;在一个叫“上古卷轴”的游戏里，有一个卫兵的膝盖中了一箭。&lt;br&gt;在一个叫“古卷轴”的游戏里，有一枚上箭从上士兵的上膝盖里上射了出来。&lt;br&gt;&lt;br&gt;A coconut is just a nut.&lt;br&gt;（椰子就是坚果。）&lt;/blockquote&gt;&lt;p&gt;负负得正，看来 co- 是对合（involution）的。&lt;/p&gt;&lt;p&gt;本文其实已经接近尾声了，不过还有一个词的翻译差点让咱想瞒混过去：上同调（cohomology）。&lt;/p&gt;&lt;p&gt;「上」是哪来的？带着这个疑问，咱打开了维基百科的 cohomology 词条：&lt;/p&gt;&lt;blockquote&gt;In mathematics, specifically in homology theory and algebraic topology, cohomology is a general term for a sequence of abelian groups associated to a topological space, often defined from a cochain complex. Cohomology can be viewed as a method of assigning richer algebraic invariants to a space than homology. Some versions of cohomology arise by dualizing the construction of homology. In other words, cochains are functions on the group of chains in homology theory.&lt;/blockquote&gt;&lt;p&gt;当时咱就这个表情：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f7cdfa69c480febaa6fa8984227588f5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;400&quot; class=&quot;content_image&quot; width=&quot;400&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f7cdfa69c480febaa6fa8984227588f5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;400&quot; class=&quot;content_image lazy&quot; width=&quot;400&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f7cdfa69c480febaa6fa8984227588f5_b.jpg&quot;&gt;&lt;figcaption&gt;这啥？.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;不过既然是「上」，说不定有可以看出「上」的图来呢？Google 一下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-209d7c0633b2a752d1f9d6b374858b40_b.png&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;197&quot; data-rawheight=&quot;300&quot; class=&quot;content_image&quot; width=&quot;197&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-209d7c0633b2a752d1f9d6b374858b40_b.png&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;197&quot; data-rawheight=&quot;300&quot; class=&quot;content_image lazy&quot; width=&quot;197&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-209d7c0633b2a752d1f9d6b374858b40_b.png&quot;&gt;&lt;figcaption&gt;上环OwO？&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0bbb2bae7021842acbd6f5793c254ce_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1896&quot; data-rawheight=&quot;1720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1896&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0bbb2bae7021842acbd6f5793c254ce_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0bbb2bae7021842acbd6f5793c254ce_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1896&quot; data-rawheight=&quot;1720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1896&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0bbb2bae7021842acbd6f5793c254ce_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b0bbb2bae7021842acbd6f5793c254ce_b.jpg&quot;&gt;&lt;figcaption&gt;螺旋升天OwO？&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0cec68c0cc89f7878f9c9dfa3a8ec4f6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0cec68c0cc89f7878f9c9dfa3a8ec4f6_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0cec68c0cc89f7878f9c9dfa3a8ec4f6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0cec68c0cc89f7878f9c9dfa3a8ec4f6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0cec68c0cc89f7878f9c9dfa3a8ec4f6_b.jpg&quot;&gt;&lt;figcaption&gt;啥啥啥？这都是啥OwO？&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;好吧看来不行。不过那边有个 cochain complex，似乎很有关系，咱去瞅瞅：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-af9d7351ba4666bfb1ae22a7d368d261_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1075&quot; data-rawheight=&quot;1421&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1075&quot; data-original=&quot;https://pic2.zhimg.com/v2-af9d7351ba4666bfb1ae22a7d368d261_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-af9d7351ba4666bfb1ae22a7d368d261_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1075&quot; data-rawheight=&quot;1421&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1075&quot; data-original=&quot;https://pic2.zhimg.com/v2-af9d7351ba4666bfb1ae22a7d368d261_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-af9d7351ba4666bfb1ae22a7d368d261_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;虽然还是看不懂，不过这里能感受到某种对称性，最直观的就是反过来的箭头，那么「逆」或许是个不错的译法。不过且慢……&lt;/p&gt;&lt;p&gt;&lt;b&gt;chain complex&lt;/b&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28A_%7B%5Cbullet+%7D%2Cd_%7B%5Cbullet+%7D%29&quot; alt=&quot;(A_{\bullet },d_{\bullet })&quot; eeimg=&quot;1&quot;&gt; ↔ &lt;b&gt;cochain complex&lt;/b&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28A%5E%7B%5Cbullet+%7D%2Cd%5E%7B%5Cbullet+%7D%29&quot; alt=&quot;(A^{\bullet },d^{\bullet })&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;cochain&lt;/b&gt; 里的黑点、数字和字母都标在右上角，所以 co 是「上」；&lt;b&gt;chain&lt;/b&gt; 里标在右下角的记法就是「下」了。我们在范畴论和各种 cohomology 里也能找到很多这种&lt;b&gt;上下角标对偶&lt;/b&gt;记法：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-839f826a55991a6d815db9de84890a7d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1079&quot; data-rawheight=&quot;238&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1079&quot; data-original=&quot;https://pic2.zhimg.com/v2-839f826a55991a6d815db9de84890a7d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-839f826a55991a6d815db9de84890a7d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1079&quot; data-rawheight=&quot;238&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1079&quot; data-original=&quot;https://pic2.zhimg.com/v2-839f826a55991a6d815db9de84890a7d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-839f826a55991a6d815db9de84890a7d_b.jpg&quot;&gt;&lt;figcaption&gt;注意 π 的上下角标对换了&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;哈哈，看来「上同调」的译者早已深谙此道了。&lt;br&gt;&lt;br&gt;这就是 co-，一个相生为伴，互克而消的故事。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这篇文章其实咱早就有了把它写出来的打算，可无奈拖延症+懒癌作怪，也想着收集更多的资料去印证各种想法。然而精力和学识有限，无法面面俱到，至臻完美。恰逢冰冰要作一个关于 CuTT 的演讲，里面很多术语找不到很好的译法，于是咱肝了两天把它写了出来，以作参考。同时，今天也是冰冰的生日，于是作为生日礼物送给他。&lt;b&gt;冰冰酱生快喵~！=w=&lt;/b&gt;&lt;br&gt;&lt;br&gt;本文参考了大量的资料，但写着写着网页就开了太多，内存被 Chrome 吞噬掉了，于是只好看完一点就关掉。很多参考来源已经不好找了，还要翻历史记录。后期咱会把引用来源慢慢补上。&lt;br&gt;&lt;br&gt;因为咱毕竟是 CS 专业的，这些内容很多属于词源学，所以超出了咱的专业范畴，本文可信度也略有折扣。文中字词之解时有妄测，Cat Oling 在这里恳请各位 reader 们能够真的作为 CO-author 帮忙审校斧正，在咱说「波乃水之皮时」能戏以「然则滑，水之骨也？」驳之。&lt;/p&gt;&lt;p&gt;其实在语言文字的演化过程中，我们会发现和生物演化很像的现象。生物演化的单位是基因（gene），而文化演化的单位是模因（meme），它们在历史的长河中演进、分化、变异、融合。时而复制出错，产生了功能完全不同的「蛋白质」，又反过来作用于文化自身，继续奔流涌进。正如有些生命会偷取其它基因片段一样，文化里也会拿来直接用。古人用典，今人玩梗，十分有趣。而有些在不同语言中本不相干的东西，因为巧合而变得更加挠人心魄。不过这些表面的东西，总是难以触碰到本质的。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;如果你对知识进行了彻底的分析而非某种机械的套弄，在你脑中生成的概念与生硬的文字之间已经没有很强的相似性，我们就认为这个概念是被理解的。彻底的分析和非凡的变换，是获得真知的标志性特征。—— 蛛酱&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;咱在写作过程中，发现了很多有用的网站，在这里推荐给大家：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.zdic.net/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;汉典&lt;/a&gt; 用于查找古汉语的字词之源&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.etymonline.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Online Etymology Dictionary&lt;/a&gt; 用于查询英语词源&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.wiktionary.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;维基词典&lt;/a&gt; 同样用于查询词源词义&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//wikisource.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;维基文库&lt;/a&gt; 查阅古籍很好用&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.geogebra.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GeoGebra&lt;/a&gt; 很棒的几何绘图工具&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//humanum.arts.cuhk.edu.hk/Lexis/lexi-mf/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;汉语多功能字库&lt;/a&gt; 汉语词源&lt;/p&gt;&lt;p&gt;其它还有维基百科、百度百科、知乎、雅虎问答、Quora、Stack Overflow 等都可以用来参考。当然，你必须能够&lt;b&gt;正常访问互联网&lt;/b&gt;，毕竟我们仍在西学东渐中，多几个没有生在明末的徐光启总是好的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;引用来源（持续补充中）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//tw.answers.yahoo.com/question/index%3Fqid%3D20060408000012KK11826%26guccounter%3D1&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《周髀算经》首段翻译&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/28528431/answer/45928559&quot; class=&quot;internal&quot;&gt;「勾」与「句」二字（一字）是如何演变的？ - restraint的回答 - 知乎&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wiktionary.org/zh-hans/%25E4%25B8%25A9&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;丩 - 维基词典&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/64808475/answer/224510814&quot; class=&quot;internal&quot;&gt;「句柄」的句应该读jù还是gōu？ - 思無邪SyiMyuZya的回答 - 知乎&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/22950899/answer/25216796&quot; class=&quot;internal&quot;&gt;为什么handle会被翻译成句柄？ - Peng DU的回答 - 知乎&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/20127354/answer/14062370&quot; class=&quot;internal&quot;&gt;三角函数：正弦、余弦、正切、余切、正割、余割，这些名字的来源是什么？ - 知乎&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/31643084&quot; class=&quot;internal&quot;&gt;在数学里co-这个词头是个什么感觉?&lt;/a&gt;&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2019-03-21-56285253</guid>
<pubDate>Thu, 21 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（七）初见 Hylomorphism</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-19-59661152.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59661152&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;到目前为止，我们已经讨论了相当多种 recursion schemes。Catamorphism 和 Anamorphisms 对数据结构进行折叠和展开。Paramorphisms 和 Apomorphisms 在维持上述操作的同时还能保持额外的信息，而 Histomorphisms 和 Futumorphisms 可以让我们在折叠时使用历史的信息，或者在展开时使用自定义的控制流。&lt;/p&gt;&lt;p&gt;对于每种折叠操作 &lt;code&gt;cata&lt;/code&gt;，&lt;code&gt;para&lt;/code&gt;，&lt;code&gt;histo&lt;/code&gt;，我们通过“翻转箭头”来导出对应的展开操作。更正式一点地说，我们实际上求解的是折叠操作范畴上的对偶操作。现在我们知道可以通过折叠操作来导出展开操作（反之亦然）。再加上函数的组合性质，一个新的问题呼之欲出“如果我们把展开操作和折叠操作组合起来会发生什么？”我们这次就来讨论这个问题。（这篇文章的所以代码均使用 Haskell，所有出现的代码均可以在&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/patrickt/recschemes/blob/master/src/Part5.lhs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;找到）&lt;/p&gt;&lt;h2&gt;折叠与基质&lt;/h2&gt;&lt;p&gt;Meijer et. al 在 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//maartenfokkinga.github.io/utwente/mmf91m.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bananas, Lenses, Envelopes, and Barbed Wire&lt;/a&gt; 中回答了这一问题，我们首先从一个种子数值里生成某种数据结构，接着在该数据结构上通过折叠计算最终结果，这样得到的复合操作我们称为 Hylomorphism[1]，这个名字实在难以直观理解，我更喜欢将这一方法称为‘生产者消费者方法’，其中展开操作负责生产，而折叠操作则负责消费。&lt;/p&gt;&lt;p&gt;如果你理解了之前的关于 Catamorphism（折叠）与 Anamorphism（展开）的概念，那么 Hylomorphism 是非常简单的。就是后者紧接着前者即可，所以容易得到：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hylo&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Coalgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;hylo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ana&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cata&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;非常直观，对吧？&lt;code&gt;ana&lt;/code&gt; 负责展开并提供 coalgebra，&lt;code&gt;cata&lt;/code&gt; 负责折叠并提供 algebra。&lt;/p&gt;&lt;p&gt;Hylomorphism 中的 hylo 来做 希腊语 hyle， ὕλη，意思是基质。古希腊人用基质代表一个物体产生之前的原料，我们这里的 Hylomorphism 正是作为某种将基质转换为最终结果的函数。&lt;/p&gt;&lt;p&gt;有趣的一点是 &lt;code&gt;Term&lt;/code&gt;，作为 &lt;code&gt;Functor&lt;/code&gt; 的不动点，在 &lt;code&gt;hylo&lt;/code&gt; 的函数签名中并没有出现。尽管 &lt;code&gt;ana&lt;/code&gt; 和 &lt;code&gt;cata&lt;/code&gt; 的函数签名中均包含 &lt;code&gt;Term f&lt;/code&gt;，但它在最终的函数签名中被抵消掉了，唯一必要的是一个可以生成 algebra 和 coalgebra 的 &lt;code&gt;Functor&lt;/code&gt;。类似地，在 Kmett 的&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html%23v%3Ahylo&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;形式化&lt;/a&gt;中，&lt;code&gt;hylo&lt;/code&gt; 也不使用 &lt;code&gt;Base&lt;/code&gt; 函子。&lt;/p&gt;&lt;h2&gt;形形色色的 Hylo&lt;/h2&gt;&lt;p&gt;Hylomorphism 并不仅仅是一个漂亮的理论结果，它可以被看做是许多我们日常计算的抽象，一个陈词滥调的例子是阶乘函数。单实际上 Hylo 的能力远不仅仅于此，尽管我们常常未能注意到这一一般性，我们在各个地方都会使用 hylomorphism：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;聚合某些数据结构的属性，比如决定一组数据的平均数或是中位数&lt;/li&gt;&lt;li&gt;从某种文字嵌套结构中解释或编译得到最终结果&lt;/li&gt;&lt;li&gt;实现递归的分治结构，比如快速排序，归并排序，甚至于快速傅里叶变换&lt;/li&gt;&lt;li&gt;计算两种结构上的差异，比如字符串的编辑距离或莱文斯坦距离&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们来看一个 &lt;code&gt;hylo&lt;/code&gt; 的实践例子。我们使用 &lt;code&gt;hylo&lt;/code&gt; 来搭建一个&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Reverse_Polish_notation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;逆波兰表达式计算器&lt;/a&gt;。给出字符串 &lt;code&gt;1 2 +&lt;/code&gt;，我们应该计算 &lt;code&gt;1 + 2&lt;/code&gt;，而 &lt;code&gt;2 1 12 3 / - +&lt;/code&gt; 则对应 &lt;code&gt;2 + 1 - 12 / 3&lt;/code&gt;：每个逆波兰表达式都有唯一确定的解析形式，使用逆波兰表达式可以不使用中缀表达式中我们常见的括号。我们的 coalgebra 会将一个字符串展开为操作的列表，接着 algrbra 会消费这个列表，从而得到一个一组计算结果。&lt;/p&gt;&lt;p&gt;如前所述，我们的逆波兰表达式的计算器包括两种值：数值运算或整数字面量。我们定义 &lt;code&gt;Token&lt;/code&gt; 类型来表示：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;
  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意到我们的构造函数里包括一个函数 &lt;code&gt;Int -&amp;gt; Int -&amp;gt; Int&lt;/code&gt;，而非一个字符串表示，由于函数没有有意义的字符串表示，导致 &lt;code&gt;Token&lt;/code&gt; 不是 &lt;code&gt;Show&lt;/code&gt; 的一个实例。但这样会简化我们的实现，当我们需要使用这个函数时，我们只需从栈中弹出这个函数，并直接应用计算即可。&lt;/p&gt;&lt;p&gt;我们还需要将字符串解析为 &lt;code&gt;Token&lt;/code&gt;，正统一点的做法将是使用一个解析函数库，例如 &lt;code&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//hackage.haskell.org/package/megaparsec&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;megaparsec&lt;/a&gt;&lt;/code&gt;或 &lt;code&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//hackage.haskell.org/package/trifecta&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;trifecta&lt;/a&gt;&lt;/code&gt; 甚至使用 &lt;code&gt;Maybe&lt;/code&gt; 函子去做错误处理。但这里出于代码简洁性考虑，我们就简单地使用 &lt;code&gt;read&lt;/code&gt;，如果有不合法数据，就直接抛出运行时错误。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;+&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码很好理解，我们使用模式匹配得到对应的数学表达式，放入 &lt;code&gt;Op&lt;/code&gt; 中，如果是数字的话，我们使用 &lt;code&gt;read&lt;/code&gt; 来获取 &lt;code&gt;Int&lt;/code&gt; 包裹成字面量。&lt;/p&gt;&lt;p&gt;一个先进先出的栈在 Haskell 中可以很好地用列表来表示，&lt;code&gt;push&lt;/code&gt; 操作使用 &lt;code&gt;:&lt;/code&gt;，&lt;code&gt;pop&lt;/code&gt; 操作可以使用 &lt;code&gt;tail&lt;/code&gt; 即可。尽管上一章中我们讨论了如何使用 &lt;code&gt;Base&lt;/code&gt; 类型类来使 Haskell 中的 &lt;code&gt;[]&lt;/code&gt; 兼容 recursion schemes。但我们还是在这里使用我们自己定义的方式。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们已经有了 &lt;code&gt;List&lt;/code&gt; 用来存放 &lt;code&gt;Token&lt;/code&gt;，那么我们下一步就要定义 &lt;code&gt;Coalgebra&lt;/code&gt; 来从 &lt;code&gt;String&lt;/code&gt; 中得到 &lt;code&gt;Token&lt;/code&gt;。回忆我们此前 &lt;code&gt;Coalgebra&lt;/code&gt; 的定义：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Coalgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的种子值 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;String&lt;/code&gt;，而 &lt;code&gt;f&lt;/code&gt; 为 &lt;code&gt;List Token&lt;/code&gt;，我们将类型签名代入 &lt;code&gt;Coalgebra&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Coalgebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;记住 &lt;code&gt;List Token&lt;/code&gt; 是部分应用的，它的签名是 &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;，所以 &lt;code&gt;f a&lt;/code&gt; 是 &lt;code&gt;List Token String&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样也是合理的，在每一步，我们展开列表中的元素，并得到 &lt;code&gt;Token&lt;/code&gt;，以及其余需要解析的 &lt;code&gt;String&lt;/code&gt; 直到我们得到 &lt;code&gt;Nil&lt;/code&gt;，这时我们就停止展开，因为 &lt;code&gt;Nil&lt;/code&gt; 也是 &lt;code&gt;List Token String&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;现在我们来实现 &lt;code&gt;rpn&lt;/code&gt; 的函数体。最简单地情况是处理空字符串，对于空字符串我们不需要做任何展开，直接返回 &lt;code&gt;Nil&lt;/code&gt; 即可。（&lt;code&gt;ana&lt;/code&gt; 知道在遇到 &lt;code&gt;Nil&lt;/code&gt; 时停止递归是因为递归的 &lt;code&gt;fmap&lt;/code&gt; 在这时会停止，&lt;code&gt;Nil&lt;/code&gt; 不包含其它子节点）&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于非空字符串的情形会更有趣一些，我们首先从字符串 &lt;code&gt;str&lt;/code&gt; 中按空格分割，并将第一段传给 &lt;code&gt;parseToken&lt;/code&gt;，将结果 &lt;code&gt;Cons&lt;/code&gt; 的 &lt;code&gt;a&lt;/code&gt; 部分，而将剩余的字符串作为 &lt;code&gt;b&lt;/code&gt; 部分。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;     &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;   &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dropWhile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将两种情况合并起来：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Coalgebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;     &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;   &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dropWhile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看起来还不错，仅仅只有六行代码，如果输入是 &lt;code&gt;3 4 +&lt;/code&gt;，我们运行 &lt;code&gt;ana parseRPN&lt;/code&gt;，就会得到与列表 &lt;code&gt;Lit 3, Lit 4, Op +, Nil&lt;/code&gt; 等价的结果。&lt;/p&gt;&lt;p&gt;现在我们还要实现 &lt;code&gt;Algebra&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们这里的 &lt;code&gt;f&lt;/code&gt; 也将是 &lt;code&gt;List Token&lt;/code&gt;，但是 &lt;code&gt;a&lt;/code&gt; 是不一样的，我们希望这里的类型是一个整数栈，既可以压元素入栈，也可以使用 &lt;code&gt;Op&lt;/code&gt; 来操作。具体的定义如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么代入类型签名得到：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但这时我们遇上了问题，考虑一个逆波兰表达式 &lt;code&gt;2 3 +&lt;/code&gt; 或 &lt;code&gt;4 2 5 * + 1 3 2 * + /&lt;/code&gt;，我们需要由左向右求解，将字面量压入栈中，接着对于栈顶的两个元素应用操作，这意味着我们的求值器必须由左向右进行计算（类似 &lt;code&gt;foldl&lt;/code&gt;）而不能由右向左计算（即 &lt;code&gt;foldr&lt;/code&gt;）。但我们的 &lt;code&gt;cata&lt;/code&gt; 是右折叠的，它一直递归到 &lt;code&gt;Nil&lt;/code&gt; 元素，并从这里开始向上传递结果。而 &lt;code&gt;holy&lt;/code&gt; 并没有给我们逆转解析完成的数组的机会，我们该怎么解决这个问题呢？ &lt;/p&gt;&lt;p&gt;答案也很简单，我们并不会使用一般的 &lt;code&gt;Stack&lt;/code&gt; 元素作为返回值。而是返回一个由 &lt;code&gt;Stack&lt;/code&gt; 到 &lt;code&gt;Stack&lt;/code&gt; 的函数：&lt;code&gt;Stack -&amp;gt; Stack&lt;/code&gt;。而对于最后返回的函数，我们使用一个空栈来激活计算并获得最终结果。&lt;i&gt;因为最左边的元素是最晚处理的，所以得到的结果函数中会最先处理最左边的元素&lt;/i&gt;。这样我们就可以由左到右完成计算，直到 &lt;code&gt;Nil&lt;/code&gt;。而这一函数的输入参数就是计算使用的初始值。&lt;/p&gt;&lt;p&gt;下图也许能够对于理解这一问题有所帮助：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1022&quot; data-rawheight=&quot;766&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1022&quot; data-original=&quot;https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1022&quot; data-rawheight=&quot;766&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1022&quot; data-original=&quot;https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;构建过程如蓝线所示：自右向左构建函数，初始函数为 id，并对后续元素不断调用 algebra 来获取之后生成的函数。 1. cata 函数从这里进入，并递归只最右侧。 2. 从最右侧元素开始自右向左构建返回函数。 求值过程如红线所示：函数最先操作最后生成的节点，由左向右进行。 3. 函数调用位置为 cata 函数结束的位置，自左向右完成调用。 4. 最后获得最终结果 [9]。&lt;/p&gt;&lt;p&gt;通过将返还值改为返回函数，我们就可以将 cata 的由右至左求值顺序改写为由左至右求值，这一过程往往令人疑惑。通过改变返回值我们增强了 &lt;code&gt;cata&lt;/code&gt; 的能力。而这一个在函数式编程领域人所共知的技巧。而这里的 &lt;code&gt;Stack&lt;/code&gt; 就是某种差分结构，一如 Haskell 中 &lt;code&gt;Show&lt;/code&gt; 的实现。&lt;/p&gt;&lt;p&gt;下面我们使用 &lt;code&gt;Stack -&amp;gt; Stack&lt;/code&gt; 改写下上面的代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们展开 &lt;code&gt;Algebra&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在实现时我们需要考虑 &lt;code&gt;Nil&lt;/code&gt; 和 &lt;code&gt;Cons&lt;/code&gt; 两种情况，&lt;code&gt;Nil&lt;/code&gt; 的情况比较简单，我们只需要返回同样的函数即可，因为没有任何需要对原函数进行更改的地方。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 即 `id`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;尽管这里我们需要返回的是一个函数，但我们可以将它的参数 &lt;code&gt;Stack&lt;/code&gt; 视为 &lt;code&gt;evalRPN&lt;/code&gt; 的参数[2]。&lt;/p&gt;&lt;p&gt;下面我们处理需要修改 &lt;code&gt;Stack&lt;/code&gt; 值的情况。对于一个包含整数的 &lt;code&gt;Lit&lt;/code&gt; 字面量，为了使 &lt;code&gt;Stack -&amp;gt; Stack&lt;/code&gt; 方法运行下去，我们只需将当前值压入栈中，并使用之后的函数进行调用即可。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于 &lt;code&gt;Op&lt;/code&gt; 的情况是类似的，我们提取 &lt;code&gt;stack&lt;/code&gt; 的头部两个元素，接着应用到 &lt;code&gt;Op&lt;/code&gt; 上，在将结果压回栈中：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于其他情况，我们直接报错退出[3]：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;too few arguments on stack: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们合并起来看一下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;                      &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;      &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;                        &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;too few arguments on stack: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样我们可以清晰地看到，求值的过程会在 &lt;code&gt;Nil&lt;/code&gt; 处停止，而在 &lt;code&gt;Cons&lt;/code&gt; 中通过 &lt;code&gt;cont&lt;/code&gt; 的调用传递下去。&lt;/p&gt;&lt;p&gt;下面我们在 GHCi 中将 &lt;code&gt;parseRPN&lt;/code&gt; 和 &lt;code&gt;evalRPN&lt;/code&gt; 传入 &lt;code&gt;hylo&lt;/code&gt;，并显示函数的类型：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hylo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parseRPN&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这也是合理的，&lt;code&gt;String&lt;/code&gt; 是我们初始需要解析的字符串，&lt;code&gt;Stack&lt;/code&gt; 是 RPN 栈的初始状态，因此我们可以再封装一层，以空列表作为栈的初始状态：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rpn&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;rpn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hylo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面我们做一个简单测试，如果在 GHCi 中调用：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rpn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;15 7 1 1 + - / 3 * 2 1 1 + + -&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;得到：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完美。&lt;/p&gt;&lt;p&gt;尽管 RPN 计算器并没有多么复杂，但我们的实现显示出了 recursion schemes 的本质：是我们在&lt;i&gt;做什么&lt;/i&gt;和我们&lt;i&gt;怎么做&lt;/i&gt;分离开，这使我们得以把精力放到问题的主要部分解析字符串和栈操作上，而无需关心数据是怎样完成遍历的。这些机制全部包含在了 &lt;code&gt;hylo&lt;/code&gt; 内部，而我们只需要关心问题的本质即可。&lt;/p&gt;&lt;h2&gt;深度优化&lt;/h2&gt;&lt;p&gt;实际上我们不需要调用 &lt;code&gt;cata&lt;/code&gt; 或 &lt;code&gt;ana&lt;/code&gt; 而仅仅使用 algrbra 和 coalgebra 就能表示 Hylomorphism。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hylo&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Coalgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;hylo&#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hylo&#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;尽管这样的实现不能清晰地看出 Hylomorphism 是 Anamorphism 和 Catamorphism 的组合，但是这样做也有好处：我们对 &lt;code&gt;fmap&lt;/code&gt; 的调用会降低到原来的一半。&lt;/p&gt;&lt;p&gt;对于我们之前的定义，&lt;code&gt;hylo&lt;/code&gt; 使用 &lt;code&gt;ana&lt;/code&gt; 展开 &lt;code&gt;List&lt;/code&gt; 需要调用 n 次 &lt;code&gt;fmap&lt;/code&gt;，其中 n 为 &lt;code&gt;Token&lt;/code&gt; 的个数。接着折叠的时候，&lt;code&gt;cata&lt;/code&gt; 需要再调用 n 次 &lt;code&gt;fmap&lt;/code&gt;。而在我们新的定义中，&lt;code&gt;fmap&lt;/code&gt; 的调用次数下降为 n 次，我们在每次展开后立即进行折叠，每一层的结构会直接在 &lt;code&gt;coalg&lt;/code&gt; 展开后被 &lt;code&gt;alg&lt;/code&gt; 所调用。这项优化对于嵌套结构很深的数据类型能显著提升运行速度。&lt;/p&gt;&lt;h2&gt;时不我待&lt;/h2&gt;&lt;p&gt;尽管 Meijer 等人在介绍 Catamorphism 和 Anamorphism 时就引入了 Hylomorphism，但 Uustalu 和 Vene 的论文却没有讨论组合 Histomorphism 和 Futumorphism 会发生什么。直到整整九年后，Edward Kmett 在 #haskell IRC 频道中，将其命名为 Chronomorphism —— chrono（χρόνος）是一个表示时间的词缀。&lt;/p&gt;&lt;p&gt;Chronomorphism 的定义与 Hylomorphism 类似：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;chrono&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CVAlgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CVCoalgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;chrono&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cvalg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cvcoalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;futu&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cvcoalg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;histo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cvalg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;非常直观地：&lt;code&gt;futu&lt;/code&gt; 展开一个多层的数据结构，接着 &lt;code&gt;histo&lt;/code&gt; 负责折叠数据。&lt;/p&gt;&lt;p&gt;然而不幸地是，Chronomorphism 并不像 Hylomorphism 那样具有丰富地应用实例。我们在之前文章中提到的生命游戏或许是个很接近的例子，我们使用 Futumorphism 来生成植物生命，但我们只需使用 Catamorphism 来将它打印出来。当然我们可以用 Histomorphism 来代替 Catamorphism，但我们并没有使用这样带来的红利。我一直未能找到一个有意义的使用 &lt;code&gt;chrono&lt;/code&gt; 的场景，如果你发现了可以联系我。但是至少 Chronomorphism 的发明者也&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//twitter.com/kmett/status/318410115101380608&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;想不到合适的例子&lt;/a&gt;。不过 &lt;code&gt;chrono&lt;/code&gt; 可以用于实现 &lt;code&gt;dynamorphism&lt;/code&gt;，这是一种为动态规划问题特化的递归模板。我们或许会在下篇文章中进行介绍。（或许 Uustalu 和 Vene 正是因为无法找到合理的应用，而没有提及它）&lt;/p&gt;&lt;h2&gt;Elgot Algebra 的优化&lt;/h2&gt;&lt;p&gt;Histomorphism 清晰地分离了 “做什么” 和 “怎样做” 这两个问题，但在实践中，有时我们在构造数据时会发现输入数据与预期不符，或者在解析数据时会有可以优化的状态。&lt;/p&gt;&lt;p&gt;我们当然可以结合去 &lt;code&gt;hylo&lt;/code&gt; 错误处理的函子来表达这一模式，但 Jiří Adámek，Stefan Milius 和 Jiří Velebil 在他们的文章中提出了一个更好的解决方案，&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//arxiv.org/pdf/cs/0609040.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Elgot Algebra&lt;/a&gt;，在范畴论的框架下为这个问题提供了解决方案，从而避免避免使用错误处理的手段。其命名来源于美国数学家 Calvin Elgot，他致力于弥合数学与软件工程间上的差距。Elgot Algebra 和 CoAlgebra 对 Hylomorphism，Catamorphism 和 Anamorphism 作了泛化，使其更加简洁和实用。文章本身非常的&lt;i&gt;困难&lt;/i&gt;。但是 Kmett 一如既往地为社区做出贡献，将其转化为了 Haskell 的代码。&lt;/p&gt;&lt;p&gt;让我们考虑一个将 &lt;code&gt;Algebra&lt;/code&gt; 和 &lt;code&gt;CoAlgebra&lt;/code&gt; 均代入后得到的 &lt;code&gt;hylo&lt;/code&gt; 的类型签名：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hylo&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个方法告诉我们，给出一个 &lt;code&gt;a&lt;/code&gt; 的 F-CoAlgebra 以及一个 &lt;code&gt;b&lt;/code&gt; 的 F-Algebra，怎样从 &lt;code&gt;a&lt;/code&gt; 得到 &lt;code&gt;b&lt;/code&gt;。但是如果我们有捷径呢？我们可以直接短接掉整个 Hylomorphism，而返回 &lt;code&gt;b&lt;/code&gt;。然后我们可以直接使用 &lt;code&gt;hylo&lt;/code&gt; 来描述这样的短路，而不需要引入 &lt;code&gt;Maybe&lt;/code&gt;，&lt;code&gt;Either&lt;/code&gt; 这些函子。&lt;/p&gt;&lt;p&gt;为了达到这个目的，&lt;code&gt;a -&amp;gt; f a&lt;/code&gt; 必须支持返回两种值，&lt;code&gt;f a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 来用于短接，显然 Haskell 提供了 &lt;code&gt;Either&lt;/code&gt; 功能来完成这一工作。我们把 &lt;code&gt;Elgot&lt;/code&gt; 改写如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;elgot&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们需要一个辅助函数来定义 Elgot Algebra，给出函数 &lt;code&gt;b -&amp;gt; a&lt;/code&gt;，和函数 &lt;code&gt;c -&amp;gt; a&lt;/code&gt;，得到一个 &lt;code&gt;Either b c&lt;/code&gt; 返回 &lt;code&gt;a&lt;/code&gt; 的函数。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|||&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以将这个函数当做或操作的升级版，它操作的是函数 &lt;code&gt;f&lt;/code&gt; 或 &lt;code&gt;g&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们可以直接从之前 &lt;code&gt;hylo&lt;/code&gt; 的定义推导出 &lt;code&gt;elgot&lt;/code&gt;，如果我们得到 &lt;code&gt;Right&lt;/code&gt; 值则继续进行递归。这一部分与 &lt;code&gt;hylo&lt;/code&gt; 表现一致。而如果我们得到 &lt;code&gt;Left&lt;/code&gt; 值，则我们停止递归并跳出。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;elgot&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;elgot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elgot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们使用 Elgot Algebra 为 RPN 计算器带来更多的安全性。我们不使用 &lt;code&gt;error&lt;/code&gt; 而自定义一下成功和失败的类型。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;
  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParseError&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TooFewArguments&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正如上文我们所提到的，我们依然要使用 CPS 风格，但是不是一个 &lt;code&gt;Stack&lt;/code&gt; 的函数，而是一个 &lt;code&gt;Result&lt;/code&gt; 的函数。为了简便起见，我们定义&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cont&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们重写 &lt;code&gt;parseToken&lt;/code&gt;，我们使用 &lt;code&gt;readMaybe&lt;/code&gt; 来获取 &lt;code&gt;Maybe Int&lt;/code&gt;，接着其转换为 &lt;code&gt;Either&lt;/code&gt; 类型。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cont&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;+&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readMaybe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Left&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ParseError&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与之类似，&lt;code&gt;parseRPN&lt;/code&gt; 可以重写为 &lt;code&gt;safeRPN&lt;/code&gt;，&lt;code&gt;parsed&lt;/code&gt; 作为 &lt;code&gt;Right&lt;/code&gt; 值而使用 do 语法隐式处理 &lt;code&gt;Left&lt;/code&gt; 值。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;safeRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeRPN&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;   &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dropWhile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;parsed&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parsed&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样我们要重写 &lt;code&gt;safeEval&lt;/code&gt; 这里需要使用模式匹配来处理 &lt;code&gt;Success&lt;/code&gt; 的值，当函数调用参数不足时，我们可以使用 &lt;code&gt;TooFewArguments&lt;/code&gt; 来作为值：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;safeEval&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cont&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeEval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeEval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;          &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TooFewArguments&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeEval&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样我们可以隐式的处理这些错误，并且不需要调用 &lt;code&gt;throw&lt;/code&gt; 等就可以错误处理模式。&lt;/p&gt;&lt;p&gt;而对它的调用是十分简单的，我们只需将 &lt;code&gt;hylo&lt;/code&gt; 替换为 &lt;code&gt;elgot&lt;/code&gt;，并且使用空 &lt;code&gt;Success&lt;/code&gt; 即可求值。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;safeRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elgot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeEval&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeParse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他使用了 Elgot Algebra 的工作非常少，Vanessa McHale 在她的&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//blog.vmchale.com/article/elgot-performance&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;博客&lt;/a&gt;中有一个用来计算&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//esolangs.org/wiki/Collatz_sequence&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Collatz 序列&lt;/a&gt;的例子，文章表明，这样的实现与同样效果的基于 rust 的底层实现计算能力上是相近的。&lt;/p&gt;&lt;h2&gt;再次翻转箭头&lt;/h2&gt;&lt;p&gt;在上面定义 &lt;code&gt;elgot&lt;/code&gt; 时，我们使用了 &lt;code&gt;|||&lt;/code&gt; 来表达区分左右值的情况，同样我们也可以在这里进行翻转箭头的操作，折叠就会变成展开，而对 Elgot Algebra 进行翻转箭头，我们就可以得到可以在折叠时短路的 Hylomorphism。&lt;/p&gt;&lt;p&gt;翻转箭头的把戏与我们之前常见的相同，&lt;code&gt;alg&lt;/code&gt; 变为 &lt;code&gt;coalg&lt;/code&gt;，&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 变为 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;，而 &lt;code&gt;|||&lt;/code&gt; 的对偶稍微有些棘手，还记得之前 &lt;code&gt;Either a b&lt;/code&gt; 的对偶是元祖 &lt;code&gt;(a,b)&lt;/code&gt; 吗？所以相应对偶是 &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由此我们可以得到 Coelgot：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;coelgot&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;coelgot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coelgot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以我们可以将 Elgot Algebra 看作是 &lt;code&gt;RCoalgebra&lt;/code&gt; 和 &lt;code&gt;Algebra&lt;/code&gt; 的结合，而对偶地来讲，我们可以将 Elgot Coalgebra 看作是 &lt;code&gt;RAlgebra&lt;/code&gt; 和 &lt;code&gt;Coalgebra&lt;/code&gt; 的结合，那么我们甚至可以构建更加强大的 &lt;code&gt;RAlgebra&lt;/code&gt; 与 &lt;code&gt;RCoalgebra&lt;/code&gt; 的结合：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hypo&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RAlgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RCoalgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;hypo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ralg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcoalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcoalg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;para&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ralg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就我所知来讲，这一构造形式尚未被命名，我们把它称为 Hypomorphism，之后的工作与 &lt;code&gt;hylo&lt;/code&gt; 类似，这里留作练习，不在赘述。&lt;/p&gt;&lt;h2&gt;致谢&lt;/h2&gt;&lt;p&gt;我要感谢 Manuel Chakravarty 为这个系列做的严谨的校对，以及 Colin Barrett，Ross Angle 和 Scott Voke 为本系列提出的宝贵意见。&lt;/p&gt;&lt;p&gt;我还要感谢读者们耐心地读到了这里，下一篇文章中，我们将讨论折叠展开这些操作的本质，以及如何抓住这些本质，来使上面的种种 Recursion Schemes 可以更快地运行。&lt;/p&gt;&lt;h2&gt;译者的话&lt;/h2&gt;&lt;p&gt;首先抱歉拖更了这么久，译者原本的翻译计划本来到此为止的，但是原文作者在上个月似乎又更新了一篇，所以，本着不挖坑的想法，应该会把下一篇也翻译一下。之后的专栏更新可能会考虑做一些函数编程的工程实践，或者从范畴论的角度讨论一下“翻转箭头”的本质。两个方向的内容笔者目前都在做，具体情况需要再看看。&lt;/p&gt;&lt;p&gt;最后打个广告，下面是笔者建的一个范畴论讨论电报群，主要希望能为正在学习范畴论的新手，提供一个迅速交流的地方，欢迎大家加入~&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//t.me/wecattheory&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;t.me/wecattheory&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;[1]:如果你在谷歌上搜索 Hylomorphism，那么很有可能你的结果中只包括亚里士多德提出在他的哲学理论中提出的同名&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Hylomorphism&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;哲学概念&lt;/a&gt;。尽管这一理论与 recursion schemes 并无关联，我们仍然要解释一下为什么这一命名对于我们定义的这一复合计算是适当的。 &lt;/p&gt;&lt;p&gt;[2]:换句话说 Haskell 对于 &lt;code&gt;a -&amp;gt; b -&amp;gt; c&lt;/code&gt; 和 &lt;code&gt;a -&amp;gt; (b -&amp;gt; c)&lt;/code&gt; 两者在语法表示上并无差别。 &lt;/p&gt;&lt;p&gt;[3]:如果我们小心地选取初始值来保持栈中始终有足够元素，比如将初始值设为无限长的列表 [0, 0...]，那么我们就不用保留错误处理的情形了。&lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2019-03-19-59661152</guid>
<pubDate>Tue, 19 Mar 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
