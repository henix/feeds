<div class="title-image"><img src="https://pic4.zhimg.com/v2-293f623031f5ff84c8349bf6a845e200_b.jpg" alt=""></div><p>最近在做债券收益率曲线绘制的相关项目，会涉及到一些插值方法的实现。为了弄清楚不同插值方法之间的差异，自己查询了一些相关的资料，但发现网上的资料不够系统，零零散散，便想着做一个读书笔记之类的东西以做留存。其中的疏漏在所难免，欢迎各位指正。</p><p>本文主要通过代码实现来加深大家对不同插值方法之间差异的理解，具体的推导过程网上很容易搜索到相关资料，这里就不再赘述。</p><p>常见的插值方法：</p><ul><li>多项式插值</li><ul><li>Lagrange 插值</li><ul><li>线性插值</li><li>抛物线插值</li><li>...</li></ul><li>Newton 插值</li></ul><li>分段插值</li><ul><li>Constant</li><li>Linear </li><li>Hermite </li><li>Cubic Spline</li><ul><li>Natural Spline</li><li>Clamped Spline</li><li>Periodic Spline</li><li>....</li></ul></ul></ul><p><b>一、多项式插值（Polynomial Interpolation）</b></p><p>多项式插值，顾名思义，即以一个多项式的形式来刻画经过一系列点的曲线。为了更加严谨一些，这里参考Wiki的定义。</p><p>给定一组 <img src="https://www.zhihu.com/equation?tex=n%2B1" alt="n+1" eeimg="1"/> 个数据点 <img src="https://www.zhihu.com/equation?tex=%28x_i%2C+y_i%29" alt="(x_i, y_i)" eeimg="1"/> ，其中任意两个 <img src="https://www.zhihu.com/equation?tex=x_i" alt="x_i" eeimg="1"/> 都不相同，需要找到一个满足 <img src="https://www.zhihu.com/equation?tex=p%28x_i%29+%3D+y_i%2C+i%3D0%2C+1%2C+...%2C+n" alt="p(x_i) = y_i, i=0, 1, ..., n" eeimg="1"/> 的不大于 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"/> 阶的 <img src="https://www.zhihu.com/equation?tex=p+" alt="p " eeimg="1"/> 阶多项式。 </p><p><b>&gt;&gt; 拉格朗日插值（Lagrange Interpolation）</b></p><p>设 <img src="https://www.zhihu.com/equation?tex=l_%7Bi%7D%28x%29" alt="l_{i}(x)" eeimg="1"/> 是 <img src="https://www.zhihu.com/equation?tex=n+" alt="n " eeimg="1"/> 次多项式，且在插值节点 <img src="https://www.zhihu.com/equation?tex=x_%7B0%7D%2Cx_%7B1%7D%2C...%2C+x_%7Bn%7D" alt="x_{0},x_{1},..., x_{n}" eeimg="1"/> 上满足：当 <img src="https://www.zhihu.com/equation?tex=i%3Dk" alt="i=k" eeimg="1"/> 时， <img src="https://www.zhihu.com/equation?tex=l_%7Bk%7D%28x_i%29%3D1+" alt="l_{k}(x_i)=1 " eeimg="1"/> ；当 <img src="https://www.zhihu.com/equation?tex=i+%5Cne+k" alt="i \ne k" eeimg="1"/> 时， <img src="https://www.zhihu.com/equation?tex=l_%7Bk%7D%28x_i%29%3D0+" alt="l_{k}(x_i)=0 " eeimg="1"/> 。称 <img src="https://www.zhihu.com/equation?tex=l_%7Bk%7D%28x%29" alt="l_{k}(x)" eeimg="1"/> 为节点 <img src="https://www.zhihu.com/equation?tex=x_0%2C+x_1%2C+...%2C+x_n" alt="x_0, x_1, ..., x_n" eeimg="1"/> 上的 <img src="https://www.zhihu.com/equation?tex=n+" alt="n " eeimg="1"/> 次Lagrange基函数。由插值基函数可得插值多项式为：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bn%7D%28x%29+%3D+%5Csum_%7Bk%3D0%7D%5E%7Bn%7Dy_%7Bk%7Dl_%7Bk%7D%28x%29%3D%5Csum_%7Bk%3D0%7D%5E%7Bn%7Dy_%7Bk%7D%5Cprod_%7Bi%3D0%2C+i+%5Cne+k%7D%5E%7Bn%7D%5Cfrac%7Bx-x_i%7D%7Bx_k-x_i%7D" alt="L_{n}(x) = \sum_{k=0}^{n}y_{k}l_{k}(x)=\sum_{k=0}^{n}y_{k}\prod_{i=0, i \ne k}^{n}\frac{x-x_i}{x_k-x_i}" eeimg="1"/> </p><p>当n=1和2时，即为线性插值多项式和抛物线插值多项式。</p><div class="highlight"><pre><code class="language-python3"><span class="k">def</span> <span class="nf">lagrange</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_val</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">basis</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">l_i</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_val</span><span class="p">))</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">l_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_val</span><span class="p">)))</span></code></pre></div><p>拉格朗日插值虽然简单易用，但是有个很大的局限，即每增加一个新的插值点时，整个基函数就需要重新构建，这大大增加了运算量。为此，我们需要寻找一种新的基函数，其能够在节点增加时，只需要在原有的基函数上增加一些新的基函数即可，而无需对原始的基函数进行重构。</p><p><b>&gt;&gt; 牛顿插值（Newton Interpolation）</b></p><p>设插值节点为 <img src="https://www.zhihu.com/equation?tex=x_%7B0%7D%2Cx_%7B1%7D%2C...%2C+x_%7Bn%7D" alt="x_{0},x_{1},..., x_{n}" eeimg="1"/> ，考虑函数组</p><p><img src="https://www.zhihu.com/equation?tex=%5Cphi_%7B0%7D%28x%29%3D1+" alt="\phi_{0}(x)=1 " eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=%5Cphi_%7B1%7D%28x%29%3Dx-x_0" alt="\phi_{1}(x)=x-x_0" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=+%5Cphi_%7B2%7D%28x%29%3D%28x-x_0%29%28x-x_1%29++" alt=" \phi_{2}(x)=(x-x_0)(x-x_1)  " eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=......+" alt="...... " eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bn%7D%28x%29%3D%28x-x_0%29%28x-x_1%29...%28x-x_%7Bn-1%7D%29+" alt="\phi_{n}(x)=(x-x_0)(x-x_1)...(x-x_{n-1}) " eeimg="1"/> </p><p>其中 <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bk%7D%28x%29" alt="\phi_{k}(x)" eeimg="1"/> 是 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 次多项式，且相互之间线性无关，为此可以使用其构造基函数。该基函数的一个优点是当增加一个新的插值节点 <img src="https://www.zhihu.com/equation?tex=x_%7Bn%2B1%7D" alt="x_{n+1}" eeimg="1"/> 时，只需在原有基函数的基础上增加一个新的函数 <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bn%2B1%7D%28x%29" alt="\phi_{n+1}(x)" eeimg="1"/> 即可。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bn%2B1%7D%28x%29%3D%28x-x_0%29%28x-x_1%29...%28x-x_%7Bn-1%7D%29%28x-x_%7Bn%7D%29" alt="\phi_{n+1}(x)=(x-x_0)(x-x_1)...(x-x_{n-1})(x-x_{n})" eeimg="1"/> </p><p>则牛顿插值多项式可以表示为：</p><p><img src="https://www.zhihu.com/equation?tex=N%28x%29+%3D+%5Csum_%7Bk%3D0%7D%5E%7Bn%7D%7Ba_%7Bk%7Dn_%7Bk%7D%28x%29%7D%3D+%5Csum_%7Bk%3D0%7D%5E%7Bn%7D%7Ba_%7Bk%7D%7D%5Cprod_%7Bi%3D0%7D%5E%7Bk-1%7D%28x-x_i%29" alt="N(x) = \sum_{k=0}^{n}{a_{k}n_{k}(x)}= \sum_{k=0}^{n}{a_{k}}\prod_{i=0}^{k-1}(x-x_i)" eeimg="1"/> </p><p>其中， <img src="https://www.zhihu.com/equation?tex=a_%7Bk%7D+%3D+%5By_0%2C+...%2C+y_k%5D" alt="a_{k} = [y_0, ..., y_k]" eeimg="1"/> 表示差商， <img src="https://www.zhihu.com/equation?tex=n_%7Bk%7D%28x%29" alt="n_{k}(x)" eeimg="1"/> 为插值基函数</p><p><b>&gt;  差商</b></p><p>设节点为 <img src="https://www.zhihu.com/equation?tex=x_0%2C+x_1%2C+...%2C+x_n" alt="x_0, x_1, ..., x_n" eeimg="1"/> ，则称：</p><p><img src="https://www.zhihu.com/equation?tex=f%5Bx_i%2C+x_j%5D+%3D+%5Cfrac%7Bf%28x_j%29+-+f%28x_i%29%7D%7Bx_j+-+x_i%7D" alt="f[x_i, x_j] = \frac{f(x_j) - f(x_i)}{x_j - x_i}" eeimg="1"/> 为 <img src="https://www.zhihu.com/equation?tex=f%28x%29" alt="f(x)" eeimg="1"/> 关于节点 <img src="https://www.zhihu.com/equation?tex=x_i%2C+x_j" alt="x_i, x_j" eeimg="1"/> 的一阶差商；</p><p><img src="https://www.zhihu.com/equation?tex=f%5Bx_i%2C+x_j%2C+x_k%5D+%3D+%5Cfrac%7Bf%5Bx_j%2C+x_k%5D+-+f%5Bx_i%2C+x_j%5D%7D%7Bx_k+-+x_i%7D" alt="f[x_i, x_j, x_k] = \frac{f[x_j, x_k] - f[x_i, x_j]}{x_k - x_i}" eeimg="1"/> 为 <img src="https://www.zhihu.com/equation?tex=f%28x%29" alt="f(x)" eeimg="1"/> 关于节点 <img src="https://www.zhihu.com/equation?tex=x_i%2C+x_j%2C+x_k" alt="x_i, x_j, x_k" eeimg="1"/> 的二阶差商；</p><p>一般地，</p><p><img src="https://www.zhihu.com/equation?tex=f%5Bx_0%2C+x_1%2C+...%2C+x_k%5D+%3D+%5Cfrac%7Bf%5Bx_1%2C+x_2%2C+...%2C+x_k%5D+-+f%5Bx_0%2C+x_1%2C+...%2C+x_%7Bk-1%7D%5D%7D%7Bx_k+-+x_0%7D" alt="f[x_0, x_1, ..., x_k] = \frac{f[x_1, x_2, ..., x_k] - f[x_0, x_1, ..., x_{k-1}]}{x_k - x_0}" eeimg="1"/> 为 <img src="https://www.zhihu.com/equation?tex=f%28x%29" alt="f(x)" eeimg="1"/> 关于节点 <img src="https://www.zhihu.com/equation?tex=x_0%2C+x_1%2C+...%2C+x_k" alt="x_0, x_1, ..., x_k" eeimg="1"/> 的 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 阶差商</p><p>  利用差商的递推定义, 我们可以构造差商表来计算差商。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-f60ddc27b3bb08aae8b44c94c93e734e_b.jpg" data-caption="" data-size="normal" data-rawwidth="1486" data-rawheight="440" class="origin_image zh-lightbox-thumb" width="1486" data-original="https://pic3.zhimg.com/v2-f60ddc27b3bb08aae8b44c94c93e734e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-f60ddc27b3bb08aae8b44c94c93e734e_b.jpg" data-caption="" data-size="normal" data-rawwidth="1486" data-rawheight="440" class="origin_image zh-lightbox-thumb lazy" width="1486" data-original="https://pic3.zhimg.com/v2-f60ddc27b3bb08aae8b44c94c93e734e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-f60ddc27b3bb08aae8b44c94c93e734e_b.jpg"/></figure><div class="highlight"><pre><code class="language-python3"><span class="k">def</span> <span class="nf">difference_quotient</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_val</span><span class="p">)</span> 
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_val</span><span class="p">)</span>               
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>       
    <span class="n">p</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_val</span>              
    <span class="n">p</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_val</span>              
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>      
        <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_val</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[:</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="p">])</span>
    
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>

<span class="k">def</span> <span class="nf">newton</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">difference_quotient</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">basis</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">l_i</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_i</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">l_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_val</span><span class="p">)))</span></code></pre></div><p>无论是Lagrange插值还是Newton插值，本质都是用一个多项式来进可能精确地描绘过节点的原始函数。但多项式插值的矛盾之处在于，若节点太少，则插值出来的函数与原始函数可能偏离较大，返回的插值结果对于实际的指导用处不大；但若节点太多，则多项式的阶数也会需要相应增加，但太高的阶数容易又会导致绘制出的插值曲线在边缘处不稳定，这便是龙格现象。</p><p><b>龙格现象（Runge Phenomenon）</b></p><p>龙格现象是在一组等间插值点上使用具有高次多项式进行插值时出现的区间边缘处的震荡问题。以函数 <img src="https://www.zhihu.com/equation?tex=f%28x%29+%3D+%5Cfrac%7B1%7D%7B1%2Bx%5E%7B2%7D%7D" alt="f(x) = \frac{1}{1+x^{2}}" eeimg="1"/> 为例，可以发现随着节点个数逐渐增加，插值精度在不断提升，但插值曲线也开始在边缘处变得不够稳定。那是否有什么方法能够做到二者兼顾呢，分段插值应运而生。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-d64bf549690dd3ebcb7b5aeafdbc01e6_b.jpg" data-size="normal" data-rawwidth="1450" data-rawheight="774" class="origin_image zh-lightbox-thumb" width="1450" data-original="https://pic3.zhimg.com/v2-d64bf549690dd3ebcb7b5aeafdbc01e6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-d64bf549690dd3ebcb7b5aeafdbc01e6_b.jpg" data-size="normal" data-rawwidth="1450" data-rawheight="774" class="origin_image zh-lightbox-thumb lazy" width="1450" data-original="https://pic3.zhimg.com/v2-d64bf549690dd3ebcb7b5aeafdbc01e6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-d64bf549690dd3ebcb7b5aeafdbc01e6_b.jpg"/><figcaption>Runge Phenomenon</figcaption></figure><p><b>二、分段插值（Piecewise Interpolation）</b></p><p>为了避免高次插值多项式的缺陷，得到 <img src="https://www.zhihu.com/equation?tex=f%28x%29" alt="f(x)" eeimg="1"/> 较好的近似式, 一般采用分段插值法，即把插值区间 <img src="https://www.zhihu.com/equation?tex=%5Ba%2C+b%5D" alt="[a, b]" eeimg="1"/> 分为若干个子区间，在每个子区间上构造低次插值多项式.</p><p>常见的分段插值主要有分段线性插值，三次Hermite插值以及三次样条插值。</p><p><b>&gt;&gt; 分段线性插值（Piecewise Linear Interpolation）</b></p><p>设 <img src="https://www.zhihu.com/equation?tex=a+%5Cleq+x_0+%5Clt+x_1+%5Clt+...+%5Clt+x_n+%5Cleq+b" alt="a \leq x_0 \lt x_1 \lt ... \lt x_n \leq b" eeimg="1"/> 为 <img src="https://www.zhihu.com/equation?tex=%5Ba%2C+b%5D" alt="[a, b]" eeimg="1"/> 上的互异节点， <img src="https://www.zhihu.com/equation?tex=f%28x%29" alt="f(x)" eeimg="1"/> 在这些节点上的函数值为 <img src="https://www.zhihu.com/equation?tex=y_0%2C+y_1%2C+...%2C+y_n" alt="y_0, y_1, ..., y_n" eeimg="1"/> ，在每个子区间 <img src="https://www.zhihu.com/equation?tex=%5Bx_%7Bk%7D%2C+x_%7Bk%2B1%7D%5D" alt="[x_{k}, x_{k+1}]" eeimg="1"/> 上作线性插值，即取：</p><p><img src="https://www.zhihu.com/equation?tex=f%28x%29+%5Capprox+N_%7B1%2C+k%2B1%7D%28x%29+%3D+f%28x_%7Bk%7D%29+%2B+f%5Bx_%7Bk%7D%2C+x_%7Bk%2B1%7D%5D%28x_%7Bk%2B1%7D+-+x_%7Bk%7D%29%2C+x_k+%3C+x+%3C+x_%7Bk%2B1%7D" alt="f(x) \approx N_{1, k+1}(x) = f(x_{k}) + f[x_{k}, x_{k+1}](x_{k+1} - x_{k}), x_k &lt; x &lt; x_{k+1}" eeimg="1"/> </p><p>记 <img src="https://www.zhihu.com/equation?tex=h_k+%3D+x_%7Bk%2B1%7D+-+x_k" alt="h_k = x_{k+1} - x_k" eeimg="1"/> ，分段函数 <img src="https://www.zhihu.com/equation?tex=I_%7Bh%7D%28x%29" alt="I_{h}(x)" eeimg="1"/> 在小区间 <img src="https://www.zhihu.com/equation?tex=%5Bx_%7Bk%7D%2C+x_%7Bk%2B1%7D%5D" alt="[x_{k}, x_{k+1}]" eeimg="1"/> 上可以表示为：</p><p><img src="https://www.zhihu.com/equation?tex=I_%7Bh%7D%28x%29+%3D+y_%7Bk%7D+%5Cfrac%7Bx+-+x_%7Bk%2B1%7D%7D%7Bx_%7Bk%7D+-+x_%7Bk%2B1%7D%7D+%2B+y_%7Bk%2B1%7D+%5Cfrac%7Bx+-+x_%7Bk%7D%7D%7Bx_%7Bk%2B1%7D+-+x_%7Bk%7D%7D" alt="I_{h}(x) = y_{k} \frac{x - x_{k+1}}{x_{k} - x_{k+1}} + y_{k+1} \frac{x - x_{k}}{x_{k+1} - x_{k}}" eeimg="1"/> <br/>其中 <img src="https://www.zhihu.com/equation?tex=x+%5Cin+%5Bx_k%2C+x_%7Bk%2B1%7D%5D%2C+k+%3D+0%2C+1%2C+...%2C+n-1" alt="x \in [x_k, x_{k+1}], k = 0, 1, ..., n-1" eeimg="1"/> </p><div class="highlight"><pre><code class="language-python3"><span class="k">def</span> <span class="nf">piecewise_linear_interp</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">x_lst</span><span class="p">):</span>
    <span class="n">x_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_lst</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_lst</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">else</span> <span class="n">x_lst</span>
    <span class="n">x_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">x_lst</span><span class="p">)</span>

    <span class="n">res_lst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_lst</span><span class="p">,</span> <span class="n">x_loc</span><span class="p">):</span>
        <span class="n">L_i</span> <span class="o">=</span> <span class="n">y_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> \
              <span class="n">y_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">res_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res_lst</span></code></pre></div><p>分段线性插值在节点处连续但不可导。</p><p>分段低次插值有效地避免了龙格现象, 同时其截断误差也得到了有效的控制, 总体是比较稳定的。但其缺点在于插值条件仅限定函数值在节点处相等，这仅能保证插值函数的连续性, 总体的光滑性不高，若需要得到光滑性更好的插值函数, 我们需要对函数的导数进行约束。</p><p><b>&gt;&gt; 三次Hermite插值（Cubic Hermite Interpolation）</b></p><p>为了简便，我们以常用的两个节点的三次Hermite插值为例进行说明。</p><p>已知函数 <img src="https://www.zhihu.com/equation?tex=y+%3D+f%28x%29" alt="y = f(x)" eeimg="1"/> 在节点 <img src="https://www.zhihu.com/equation?tex=x_%7B0%7D%2C+x_%7B1%7D" alt="x_{0}, x_{1}" eeimg="1"/> 上的函数值 <img src="https://www.zhihu.com/equation?tex=f%28x_i%29+%3D+y_%7Bi%7D" alt="f(x_i) = y_{i}" eeimg="1"/> 和导数值 <img src="https://www.zhihu.com/equation?tex=f%27%28x_i%29+%3D+m_%7Bi%7D%2C+i%3D0%2C+1+" alt="f&#39;(x_i) = m_{i}, i=0, 1 " eeimg="1"/> ，为了表示该函数，可在子区间 <img src="https://www.zhihu.com/equation?tex=%5Bx_%7B0%7D%2C+x_%7B1%7D%5D" alt="[x_{0}, x_{1}]" eeimg="1"/> 上构造三次插值多项式 <img src="https://www.zhihu.com/equation?tex=H_3%28x%29" alt="H_3(x)" eeimg="1"/> ，使其满足 <img src="https://www.zhihu.com/equation?tex=H_%7B3%2C+i%7D%28x_i%29%3Dy_i%2C+H%5E%7B%27%7D_%7B3%2C+i%7D%28x_i%29+%3D+m_i+%28i%3D0%2C+1%2C+...%2C+n%29" alt="H_{3, i}(x_i)=y_i, H^{&#39;}_{3, i}(x_i) = m_i (i=0, 1, ..., n)" eeimg="1"/> 。</p><p>根据Lagrange方法的思想，我们可以采用基函数的方法来构造插值多项式 <img src="https://www.zhihu.com/equation?tex=H_%7B3%2C+i%7D%28x%29" alt="H_{3, i}(x)" eeimg="1"/> ，其可表示为：</p><p><img src="https://www.zhihu.com/equation?tex=H_%7B3%2C+i%7D%28x%29+%3D+y_i%5Calpha_i%28x%29+%2B+y_%7Bj%7D%5Calpha_%7Bj%7D%28x%29+%2B+m_i%5Cbeta_i%28x%29+%2B+m_%7Bj%7D%5Cbeta_%7Bj%7D%28x%29" alt="H_{3, i}(x) = y_i\alpha_i(x) + y_{j}\alpha_{j}(x) + m_i\beta_i(x) + m_{j}\beta_{j}(x)" eeimg="1"/> </p><p>其中，<img src="https://www.zhihu.com/equation?tex=%5Calpha_i%28x%29+%2C+%5Calpha_j%28x%29+%2C+%5Cbeta_i%28x%29+%2C+%5Cbeta_j%28x%29" alt="\alpha_i(x) , \alpha_j(x) , \beta_i(x) , \beta_j(x)" eeimg="1"/> 为插值基函数，均为次数不超过3的多项式，且满足</p><p><img src="https://www.zhihu.com/equation?tex=%5Calpha_j%28x_i%29+%3D+%5Cdelta_%7Bji%7D%2C+%5Calpha%5E%7B%27%7D_%7Bj%7D%28x_i%29+%3D+0+++" alt="\alpha_j(x_i) = \delta_{ji}, \alpha^{&#39;}_{j}(x_i) = 0   " eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=%5Cbeta_j%28x_i%29+%3D+0%2C+%5Cbeta%5E%7B%27%7D_%7Bj%7D%28x_i%29+%3D+%5Cdelta_%7Bji%7D++" alt="\beta_j(x_i) = 0, \beta^{&#39;}_{j}(x_i) = \delta_{ji}  " eeimg="1"/> </p><p>其中 <img src="https://www.zhihu.com/equation?tex=i%2C+j+%3D+0%2C+1+" alt="i, j = 0, 1 " eeimg="1"/> 。</p><p>根据约束条件通过待定系数法可得（具体证明步骤略）：</p><p><img src="https://www.zhihu.com/equation?tex=H_%7B3%2C+i%7D%28x%29+%3D+%281+%2B+2+%5Cfrac%7Bx+-+x_%7Bi-1%7D%7D%7Bh_%7Bi%7D%7D%29%28%5Cfrac%7Bx-+x_%7Bi%7D%7D%7Bh_%7Bi%7D%7D%29%5E2+y_%7Bi-1%7D+%2B+%281+%2B+2%5Cfrac%7Bx_i+-+x%7D%7Bh_i%7D%29%28%5Cfrac%7Bx-x_%7Bi-1%7D%7D%7Bh_i%7D%29%5E2+y_i+%2B+%28x-x_%7Bi-1%7D%29%28%5Cfrac%7Bx-x_%7Bi%7D%7D%7Bh_i%7D%29%5E2+m_%7Bi-1%7D+%2B+%28x-+x_%7Bi%7D%29+%28%5Cfrac%7Bx-x_%7Bi-1%7D%7D%7Bh_%7Bi%7D%7D%29%5E2+m_i" alt="H_{3, i}(x) = (1 + 2 \frac{x - x_{i-1}}{h_{i}})(\frac{x- x_{i}}{h_{i}})^2 y_{i-1} + (1 + 2\frac{x_i - x}{h_i})(\frac{x-x_{i-1}}{h_i})^2 y_i + (x-x_{i-1})(\frac{x-x_{i}}{h_i})^2 m_{i-1} + (x- x_{i}) (\frac{x-x_{i-1}}{h_{i}})^2 m_i" eeimg="1"/> </p><p>其中，<img src="https://www.zhihu.com/equation?tex=h_%7Bi%7D+%3D+x_%7Bi%7D+-+x_%7Bi-1%7D" alt="h_{i} = x_{i} - x_{i-1}" eeimg="1"/> </p><div class="highlight"><pre><code class="language-python3"><span class="k">def</span> <span class="nf">cubic_hermite_interp</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">x_deriv</span><span class="p">,</span> <span class="n">x_interp</span><span class="p">):</span>
    <span class="n">x_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_interp</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_interp</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">else</span> <span class="n">x_interp</span>
    <span class="n">x_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">x_lst</span><span class="p">)</span>

    <span class="n">res_lst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_lst</span><span class="p">,</span> <span class="n">x_loc</span><span class="p">):</span>
        <span class="n">h_i</span> <span class="o">=</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">H_i</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">h_i</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">h_i</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
              <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">h_i</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">h_i</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
              <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">h_i</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_deriv</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
              <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">h_i</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_deriv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="n">res_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_i</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">res_lst</span></code></pre></div><p>但这里需要指出的是，在大部分情况下，我们是无法知道节点处的一阶导数的，所以上面的插值函数实用性并不强。那有没有什么办法来确定一阶导数呢，答案当然是有的，具体逻辑大家可以参考<a href="https://link.zhihu.com/?target=http%3A//www.ams.sunysb.edu/~jiao/teaching/ams527_spring14/lectures/SNA000238.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">Monotone Piecewise Cubic Interpolation</a>，并试着自己实现一下。</p><p><b>&gt;&gt; 三次样条插值（Cubic Spline Interpolation）</b></p><p>设在区间<img src="https://www.zhihu.com/equation?tex=%5Ba%2C+b%5D" alt="[a, b]" eeimg="1"/> 上给定 <img src="https://www.zhihu.com/equation?tex=n%2B1" alt="n+1" eeimg="1"/> 个节点 <img src="https://www.zhihu.com/equation?tex=x_i%28a+%5Cleq+x_0+%5Cleq+...+%5Cleq+x_n+%5Cleq+b%29" alt="x_i(a \leq x_0 \leq ... \leq x_n \leq b)" eeimg="1"/> ，在节点 <img src="https://www.zhihu.com/equation?tex=x_i+" alt="x_i " eeimg="1"/> 处的函数值为 <img src="https://www.zhihu.com/equation?tex=y_i%3Df%28x_i%29%2C+i%3D0%2C+1%2C+...%2C+n" alt="y_i=f(x_i), i=0, 1, ..., n" eeimg="1"/> 。若函数 <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 满足以下条件：</p><p>1）在每个子区间 <img src="https://www.zhihu.com/equation?tex=%5Bx_%7Bi-1%7D%2C+x_%7Bi%7D%5D%2C+%28i%3D1%2C+2%2C+...%2C+n%29" alt="[x_{i-1}, x_{i}], (i=1, 2, ..., n)" eeimg="1"/> 上 <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 是三次多项式</p><p>2）<img src="https://www.zhihu.com/equation?tex=S%28x_i%29+%3D+y_i%2C+i%3D0%2C+1%2C+...%2C+n" alt="S(x_i) = y_i, i=0, 1, ..., n" eeimg="1"/> </p><p>3）在区间 <img src="https://www.zhihu.com/equation?tex=%5Ba%2C+b%5D" alt="[a, b]" eeimg="1"/> 上 <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 的二阶导数 <img src="https://www.zhihu.com/equation?tex=S%27%27%28x%29" alt="S&#39;&#39;(x)" eeimg="1"/> 连续</p><p>则称 <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 为函数 <img src="https://www.zhihu.com/equation?tex=y%3Df%28x%29" alt="y=f(x)" eeimg="1"/> 在区间 <img src="https://www.zhihu.com/equation?tex=%5Ba%2C+b%5D" alt="[a, b]" eeimg="1"/> 上的三次样条插值函数。</p><p>根据定义，可知插值条件为：</p><ul><li>插值特性： <img src="https://www.zhihu.com/equation?tex=S%28x_i%29+%3D+f%28x_i%29" alt="S(x_i) = f(x_i)" eeimg="1"/> </li><li>相互连接： <img src="https://www.zhihu.com/equation?tex=S_%7Bi-1%7D%28x_i%29+%3D+S_%7Bi%7D%28x_i%29" alt="S_{i-1}(x_i) = S_{i}(x_i)" eeimg="1"/> </li><li>一阶导连续： <img src="https://www.zhihu.com/equation?tex=S_%7Bi-1%7D%5E%7B%27%7D%28x_i%29+%3D+S_%7Bi%7D%5E%7B%27%7D%28x_i%29" alt="S_{i-1}^{&#39;}(x_i) = S_{i}^{&#39;}(x_i)" eeimg="1"/> </li><li>二阶导连续： <img src="https://www.zhihu.com/equation?tex=S_%7Bi-1%7D%5E%7B%27%27%7D%28x_i%29+%3D+S_%7Bi%7D%5E%7B%27%27%7D%28x_i%29" alt="S_{i-1}^{&#39;&#39;}(x_i) = S_{i}^{&#39;&#39;}(x_i)" eeimg="1"/> </li></ul><p>由于<img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 是分段三次多项式，故在每个子区间 <img src="https://www.zhihu.com/equation?tex=%5Bx_%7Bi-1%7D%2C+x_%7Bi%7D%5D%2C+i%3D1%2C+2%2C+...%2C+n" alt="[x_{i-1}, x_{i}], i=1, 2, ..., n" eeimg="1"/> 上， <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 有4个待定参数；由于共有 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"/> 个子区间，所以 <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 共有 <img src="https://www.zhihu.com/equation?tex=4n" alt="4n" eeimg="1"/> 个待定参数。根据定义中的条件(3)可知共有 <img src="https://www.zhihu.com/equation?tex=3%28n-1%29" alt="3(n-1)" eeimg="1"/> 个条件，加上定义中的条件(2)的 <img src="https://www.zhihu.com/equation?tex=n%2B1" alt="n+1" eeimg="1"/> 个条件，共有 <img src="https://www.zhihu.com/equation?tex=4n-2" alt="4n-2" eeimg="1"/> 个条件。但有 <img src="https://www.zhihu.com/equation?tex=4n" alt="4n" eeimg="1"/> 个待定参数，所以还需增加两个条件才能确定最终的 <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 。</p><p>根据最终两个条件选择的不同，可以分为不同的样条函数。</p><ul><li>若设定两端节点处的二阶导数值为0，即 <img src="https://www.zhihu.com/equation?tex=S%5E%7B%27%27%7D%28x_0%29+%3D+S%5E%7B%27%27%7D%28x_n%29+%3D+0" alt="S^{&#39;&#39;}(x_0) = S^{&#39;&#39;}(x_n) = 0" eeimg="1"/> ，则得到三次自然样条（Natural Spline）</li><li>若指定两端节点处的一阶导数值，即 <img src="https://www.zhihu.com/equation?tex=S%5E%7B%27%7D%28x_0%29+%3D+%5Cmu%2C+++S%5E%7B%27%7D%28x_n%29+%3D+%5Cupsilon" alt="S^{&#39;}(x_0) = \mu,   S^{&#39;}(x_n) = \upsilon" eeimg="1"/> ，则得到三次钳制样条（Clamped Spline）</li><li>若设定两端节点处的函数值、一阶导、二阶导皆相等，即 <img src="https://www.zhihu.com/equation?tex=S%28x_0%29+%3D+S%28x_n%29%2CS%5E%7B%27%7D%28x_0%29+%3D+S%5E%7B%27%7D%28x_n%29+%2CS%5E%7B%27%27%7D%28x_0%29+%3D+S%5E%7B%27%27%7D%28x_n%29+" alt="S(x_0) = S(x_n),S^{&#39;}(x_0) = S^{&#39;}(x_n) ,S^{&#39;&#39;}(x_0) = S^{&#39;&#39;}(x_n) " eeimg="1"/> ，则得到三次周期样条（Periodic Spline）</li></ul><p>联立约束条件通过待定系数法可得：</p><p><img src="https://www.zhihu.com/equation?tex=+S_%7Bi%7D%28x%29+%3D+M_%7Bi-1%7D%5Cfrac%7B%28x_i+-+x%29%5E%7B3%7D%7D%7B6h_i%7D%2BM_%7Bi%7D%5Cfrac%7B%28x-x_%7Bi-1%7D%29+%5E+%7B3%7D%7D%7B6h_i%7D%2B%28y_%7Bi-1%7D+-+%5Cfrac%7BM_%7Bi-1%7Dh_%7Bi%7D%5E%7B2%7D%7D%7B6%7D%29%5Cfrac%7Bx_i+-+x%7D%7Bh_i%7D%2B%28y_i+-+%5Cfrac%7BM_ih%5E%7B2%7D_i%7D%7B6%7D%29%5Cfrac%7Bx-x_%7Bi-1%7D%7D%7Bh_i%7D+%2C+x+%5Cin+%5Bx_%7Bi-1%7D%2C+x_i%5D" alt=" S_{i}(x) = M_{i-1}\frac{(x_i - x)^{3}}{6h_i}+M_{i}\frac{(x-x_{i-1}) ^ {3}}{6h_i}+(y_{i-1} - \frac{M_{i-1}h_{i}^{2}}{6})\frac{x_i - x}{h_i}+(y_i - \frac{M_ih^{2}_i}{6})\frac{x-x_{i-1}}{h_i} , x \in [x_{i-1}, x_i]" eeimg="1"/> </p><p>其中，</p><p><img src="https://www.zhihu.com/equation?tex=M_i+%3D+S%5E%7B%27%27%7D%28x_i%29%2C+i+%3D+0%2C+1%2C+...%2C+n" alt="M_i = S^{&#39;&#39;}(x_i), i = 0, 1, ..., n" eeimg="1"/> ，是 <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 在节点 <img src="https://www.zhihu.com/equation?tex=x_i" alt="x_i" eeimg="1"/> 处的二阶导数值， <img src="https://www.zhihu.com/equation?tex=h_i+%3D+x_%7Bi%7D+-+x_%7Bi-1%7D" alt="h_i = x_{i} - x_{i-1}" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=u_i+%3D+%5Cfrac%7Bh_i%7D%7Bh_i+%2B+h_%7Bi%2B1%7D%7D%2C+%5Clambda_i+%3D+%5Cfrac%7Bh_%7Bi%2B1%7D%7D%7Bh_i%2Bh_%7Bi%2B1%7D%7D%3D1-u_i" alt="u_i = \frac{h_i}{h_i + h_{i+1}}, \lambda_i = \frac{h_{i+1}}{h_i+h_{i+1}}=1-u_i" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=d_i+%3D+%5Cfrac%7B6%7D%7Bh_i+%2B+h_%7Bi%2B1%7D%7D%5B%5Cfrac%7By_%7Bi%2B1%7D+-+y_%7Bi%7D%7D%7Bh_%7Bi%2B1%7D%7D-%5Cfrac%7By_i-+y_%7Bi-1%7D%7D%7Bh_i%7D%5D%3D6f%5Bx_%7Bi-1%7D%2C+x_i%2C+x_%7Bi%2B1%7D%5D" alt="d_i = \frac{6}{h_i + h_{i+1}}[\frac{y_{i+1} - y_{i}}{h_{i+1}}-\frac{y_i- y_{i-1}}{h_i}]=6f[x_{i-1}, x_i, x_{i+1}]" eeimg="1"/> </p><p>以三次自然样条为例，已知<img src="https://www.zhihu.com/equation?tex=M_0+%3D+M_n+%3D+0" alt="M_0 = M_n = 0" eeimg="1"/> ，则未知量减少了两个，相当于 <img src="https://www.zhihu.com/equation?tex=n-1" alt="n-1" eeimg="1"/> 个等式求解 <img src="https://www.zhihu.com/equation?tex=n-1" alt="n-1" eeimg="1"/> 个变量，且系数矩阵严格对角占优，矩阵可逆，方程组存在唯一解，所以可以快速得到 <img src="https://www.zhihu.com/equation?tex=M_1%2C+M_2%2C+...%2C+M_%7Bn-1%7D" alt="M_1, M_2, ..., M_{n-1}" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=+%5Cbegin%7Bpmatrix%7D+2+%26+%5Clambda_1+%26+%26+%26+%5C%5C++%5Cmu_2+%26+2+%26+%5Clambda_2+%26+%5C%5C+%26+%5Cddots+%26+%5Cddots+%26+%5Cddots+%26+%5C%5C+%26++%26++%5Cmu_%7Bn-2%7D+%26+2+%26+%5Clambda_%7Bn-2%7D%5C%5C+%26++%26++%26+%5Cmu_%7Bn-1%7D+%26+2+%5C%5C+%5Cend%7Bpmatrix%7D++%5Cbegin%7Bpmatrix%7D+M_1+%5C%5C+M_2+%5C%5C+%5Cvdots+%5C%5C+M_%7Bn-2%7D+%5C%5C+M_%7Bn-1%7D+%5C%5C+%5Cend%7Bpmatrix%7D+%3D++%5Cbegin%7Bpmatrix%7D+d_1+%5C%5C+d_2+%5C%5C+%5Cvdots+%5C%5C+d_%7Bn-2%7D+%5C%5C+d_%7Bn-1%7D+%5C%5C+%5Cend%7Bpmatrix%7D+" alt=" \begin{pmatrix} 2 &amp; \lambda_1 &amp; &amp; &amp; \\  \mu_2 &amp; 2 &amp; \lambda_2 &amp; \\ &amp; \ddots &amp; \ddots &amp; \ddots &amp; \\ &amp;  &amp;  \mu_{n-2} &amp; 2 &amp; \lambda_{n-2}\\ &amp;  &amp;  &amp; \mu_{n-1} &amp; 2 \\ \end{pmatrix}  \begin{pmatrix} M_1 \\ M_2 \\ \vdots \\ M_{n-2} \\ M_{n-1} \\ \end{pmatrix} =  \begin{pmatrix} d_1 \\ d_2 \\ \vdots \\ d_{n-2} \\ d_{n-1} \\ \end{pmatrix} " eeimg="1"/> </p><p>初看起来，可能过程有点绕，这里我根据自己的理解简单总结一下。由于 <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 是分段三次多项式，所以其二阶导数形式 <img src="https://www.zhihu.com/equation?tex=S%5E%7B%27%27%7D%28x%29" alt="S^{&#39;&#39;}(x)" eeimg="1"/> 在各子区间内是关于节点二阶导数<img src="https://www.zhihu.com/equation?tex=M_%7Bi-1%7D%2C+M_%7Bi%7D+" alt="M_{i-1}, M_{i} " eeimg="1"/> 的线性函数。根据前文所述的分段线性函数的表现形式，可以通过对 <img src="https://www.zhihu.com/equation?tex=S%5E%7B%27%27%7D%28x%29" alt="S^{&#39;&#39;}(x)" eeimg="1"/> 积分将 <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 的表现形式求解出来，求解后发现 <img src="https://www.zhihu.com/equation?tex=S%28x%29" alt="S(x)" eeimg="1"/> 是关于节点二阶导数 <img src="https://www.zhihu.com/equation?tex=M_i" alt="M_i" eeimg="1"/> 的多项式。再基于节点处的约束条件，来生成求解节点处二阶导数 <img src="https://www.zhihu.com/equation?tex=M_i" alt="M_i" eeimg="1"/> 的矩阵。求出 <img src="https://www.zhihu.com/equation?tex=M_i" alt="M_i" eeimg="1"/> 后将其带入 <img src="https://www.zhihu.com/equation?tex=S_i%28x%29" alt="S_i(x)" eeimg="1"/> 的表达式，即可得到子区间 <img src="https://www.zhihu.com/equation?tex=%5Bx_%7Bi-1%7D%2C+x_i%5D" alt="[x_{i-1}, x_i]" eeimg="1"/> 最终的分段多项式</p><div class="highlight"><pre><code class="language-python3"><span class="k">def</span> <span class="nf">cubic_spline_interp</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">x_interp</span><span class="p">):</span>
    <span class="n">x_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_interp</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_interp</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">else</span> <span class="n">x_interp</span>
    <span class="n">x_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">x_lst</span><span class="p">)</span>    

    <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">difference_quotient</span><span class="p">(</span><span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>   
    
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_val</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">h_vec</span> <span class="o">=</span> <span class="n">x_val</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">_u_vec</span> <span class="o">=</span> <span class="n">h_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="p">(</span><span class="n">h_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">u_vec</span> <span class="o">=</span> <span class="n">_u_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">lam_vec</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">u_vec</span>
    
    <span class="n">diag_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">u_vec</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">lam_vec</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">d_vec</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">m_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solve</span><span class="p">(</span><span class="n">diag_mat</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="n">res_lst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_lst</span><span class="p">,</span> <span class="n">x_loc</span><span class="p">):</span>
        <span class="n">h_i</span> <span class="o">=</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">S_i</span> <span class="o">=</span> <span class="n">m_vec</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">h_i</span><span class="p">)</span> <span class="o">+</span> <span class="n">m_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">h_i</span><span class="p">)</span> <span class="o">+</span> \
              <span class="p">(</span><span class="n">y_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">m_vec</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">h_i</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">h_i</span> <span class="o">+</span> \
              <span class="p">(</span><span class="n">y_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">m_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">h_i</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">h_i</span>
        <span class="n">res_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_i</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">res_lst</span></code></pre></div><p>我们继续使用前文中的函数<img src="https://www.zhihu.com/equation?tex=f%28x%29+%3D+%5Cfrac%7B1%7D%7B1%2Bx%5E%7B2%7D%7D" alt="f(x) = \frac{1}{1+x^{2}}" eeimg="1"/> 来插值，不过区别于使用多项式来进行插值运算，这次我们用分段插值方法来绘制通过节点的曲线，图像如下。可以发现，Runge Phenomenon已经消失。但大家注意看左边的部分，我故意遗漏了一个节点-2，从而导致分段线性插值和三次样条插值得到的结果与原始的函数有较大的差异，所以通过分段插值时，节点的选取对插值结果会有显著的影响。</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-84313834ac6260ae2233fcceb0f70bb6_b.jpg" data-size="normal" data-rawwidth="708" data-rawheight="377" class="origin_image zh-lightbox-thumb" width="708" data-original="https://pic3.zhimg.com/v2-84313834ac6260ae2233fcceb0f70bb6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-84313834ac6260ae2233fcceb0f70bb6_b.jpg" data-size="normal" data-rawwidth="708" data-rawheight="377" class="origin_image zh-lightbox-thumb lazy" width="708" data-original="https://pic3.zhimg.com/v2-84313834ac6260ae2233fcceb0f70bb6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-84313834ac6260ae2233fcceb0f70bb6_b.jpg"/><figcaption>分段低次插值方法比较</figcaption></figure><p>行文至此，主体内容就结束了。<b>各位看官，看在敲了这么多公式的份上，点个👍再走？</b>代码我个人觉得写得已经比较简洁易懂了，大家如果有什么问题欢迎评论。</p><p><b>三、 参考资料</b></p><p>[1] 潘建瑜. 数值分析讲义. 华东师范大学</p><p>[2] <a href="https://link.zhihu.com/?target=http%3A//gr.xjtu.edu.cn/c/document_library/get_file%3FfolderId%3D2553867%26name%3DDLFE-109081.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">分段低次插值多项式</a></p>