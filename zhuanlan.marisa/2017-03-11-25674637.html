<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lambda calculus引论(二): 不动点</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/25674637">原文</a></p>
<p>相信对函数式编程有所听闻的小伙伴应该对不动点这个名称不陌生吧~ 不动点在理论上有着及其深刻的运用, 这里向大家介绍一些和不动点相关的理论.</p><br><br><h2><b>递归结构定义问题:</b></h2><p>在第一节中给出了λ表达式集合<equation>\Lambda^{-}</equation>的定义:</p><equation>\begin{align}
&amp;\Lambda^{-}_{1}:=s\\
&amp;\Lambda^{-}_{n}:=s\;|\;\Lambda^{-}_{n-1}\Lambda^{-}_{n-1}\;|\;\lambda s.\Lambda^{-}_{n-1}\quad(s\in S)\\
&amp;\Lambda^{-}_1=\bigcup_{i=1}^{} \Lambda^{-}_{i}
\end{align}</equation><p><equation>\Lambda^{-}</equation>亦或定义为满足:</p><equation>\Lambda^{-}_2=s\;|\;\Lambda^{-}_2\Lambda^{-}_2\;|\;\lambda s.\Lambda^{-}_2\quad(s\in S)</equation><p>的最小集合.</p><p>给出的第一种定义严格符合结构的递归定义, 第二种直接递归定义更为之直观与更符合直觉. 但是给出的两种定义等价吗, 即<equation>\Lambda^{-}_1\equiv \Lambda^{-}_2</equation>? </p><p>另外来说, 第二种直接递归定义比第一种更广泛的使用, 相信小伙伴肯定见过不少, 自己也写过类似的定义, 类似于Haskell中对二叉树的定义:</p><equation>\begin{align}
&amp;Data\ \textbf{BinaryTree}\ a\\
&amp;\quad=\ Node\ a\ (\textbf{BinaryTree}\ a)\ (\textbf{BinaryTree}\ a)\\
&amp;\quad|\ Leaf
\end{align}</equation><br><p>这种直接递归定义, 虽然直观易理解, 但是定义中存在循环依赖关系, 对于该定义给出的对象有种无中生有的味道. 我们要怎么知道这种定义是满足期望的良好定义呢, 以及何种形式的递归结构是良好定义的呢? 想必小伙伴都知道上面的问题的回答都是肯定的, 那么应该怎么证明呢? (感兴趣的小伙伴们先思考一下)</p><br><br><h2><b>不动点组合子(Fixed-point combinator):</b></h2><p>先把上面的问题稍微放一放喵, 先介绍不动点组合子. 不动点组合子在理论与实践中都有着广泛的应用.</p><br><br><p><b>定义:</b> 自映射<equation>f:A\rightarrow A</equation>不动点为<equation>x\in A,\; x=f(x)</equation>.</p><br><br><p><b>定义: </b>不动点组合子<equation>Y</equation>为满足一下条件的λ-term:</p><equation>Yf=_{\beta}f(Yf)\quad(\forall f\in\Lambda )</equation><br><p>或满足更强性质的:</p><equation>Yf\;\triangleright_{\beta}^{*}\;f(Yf)\quad(\forall f\in\Lambda )</equation><br><p>令<equation>x=Yf</equation>有<equation>x=_{\beta}f(x)</equation>, 即<equation>x=Yf</equation>为<equation>f</equation>的一个不动点. 可理解<equation>Y:\Lambda \rightarrow \Lambda </equation>为求解<equation>f</equation></p><p>不动点的映射, 故得名不动点组合子.</p><br><br><p><b>定理: 不动点定理(Fixed-point theorem) </b>不动点组合子<equation>Y</equation>存在.</p><p>证明: 令<equation>Y=UU\quad where\;U=\lambda u.\lambda x.x(uux)</equation><br></p><p>对于任意λ-term<equation>f</equation>:</p><br><equation>\begin{align}
Yf&amp;=(\lambda u.\lambda x.x(uux))Uf\\
&amp;\triangleright_{\beta}(\lambda x.x(uux))[U/u]f\\
&amp;=(\lambda x.x(UUx))f\\
&amp;\triangleright_{\beta}(x(UUx))[f/x]\\
&amp;=f(UUf)\\
&amp;=f(Yf)
\end{align}</equation><br><p>有<equation>Yf\;\triangleright_{\beta}^{*}\;f(Yf)\Rightarrow Yf=_{\beta}f(Yf)</equation>. 证毕.<br></p><br><br><p><b>定义: </b>不动点组合子</p><equation>\begin{align}
&amp;Y_{Turing}=UU\quad &amp;&amp;where\;U=\lambda u.\lambda x.x(uux)\\
&amp;Y_{Curry-Ros}=\lambda x.VV\quad &amp;&amp;where\;V=\lambda y.x(yy)
\end{align}</equation><br><p><equation>Y_{Turing}</equation>由Alan Turing于1937年提出, <equation>Y_{Curry-Ros}</equation>由Paul Rosenbloom于1950年发表. <equation>Y_{Curry-Ros}</equation>有着更简单的形式, 但<equation>Y_{Curry-Ros}</equation>仅满足<equation>Yf\;\triangleright_{\beta}^{*}\;f(Yf)</equation>. </p><br><br><p><b>推论1: </b>方程<equation>fx_1,\cdots,x_n=M</equation>对于任意λ-term<equation>M</equation>解存在, 即存在: <equation>Fx_1,\dots,x_n=_{\beta}M[F/f]</equation>.</p><p>证明: 令<equation>F=Y(\lambda f. \lambda x_1,\dots,\lambda x_n.M)</equation><br></p><equation>\begin{align}
Fx_1,\dots,x_n&amp;=_{\beta}Y(\lambda f. \lambda x_1,\dots,\lambda x_n.M)x_1\dots x_n\\
&amp;=_{\beta}(\lambda f. \lambda x_1,\dots,\lambda x_n.M)Fx_1,\dots,x_n\\
&amp;=_{\beta}(\lambda x_1,\dots,\lambda x_n.M[F/f])x_1,\dots,x_n\\
&amp;=_{\beta}M[F/f]
\end{align}</equation><br><p>证毕. </p><p>注: <equation>F=Y(\lambda f. \lambda x_1,\dots,\lambda x_n.M)</equation>由于λ-term<equation>M</equation>的任意性, 这个解经常用于生成反例. 例如取<equation>M=f</equation>则存在<equation>F</equation>方程的解:</p><p><equation>fx_1\dots x_n=f</equation>, 对于任意<equation>x_1,\dots,x_n</equation>均成立.<br></p><br><p>由推论1可知, <equation>Y</equation>不动点组合子常用于递归, <equation>Y</equation>将会把表达式自身<equation>F</equation>绑定在表达式<equation>M</equation>的名称<equation>f</equation>中, 即<equation>M[F/f]</equation>. 在表达式中递归即调用名称<equation>f</equation>.<br></p><p>举例: 求Fibonacci number的表达式可写作为</p><equation>Fib=\lambda x.Y(\lambda f. \lambda n.\ \textbf{if}\ n&lt;2\ \textbf{then}\ 1\ \textbf{else}\ f(n-1)+f(n-2))x</equation><br><p>注: 其中的分支结构, 自然数与运算的拓展将在下节介绍.</p><br><br><p><b>定理: 双不动点定理(Double fixed-point theorem) </b>对于任意λ-term<equation>X, Y</equation>存在<equation>A,B</equation>使得:</p><br><equation>XAB=_{\beta}A,\quad YAB=_{\beta}B</equation><br><p>证明: 令:</p><equation>\begin{align}
&amp;A^{'}(b)=\textbf{Y}(\lambda a.Xab)\\
&amp;B=\textbf{Y}(\lambda b.YA^{'}(b)b)\\
&amp;A=A^{'}(B)\\
\end{align}</equation><p>其中<equation>\textbf{Y}</equation>为满足<equation>\textbf{Y}f=_{\beta}f(\textbf{Y}f)\quad(\forall f\in\Lambda )</equation>的λ-term, 由不动点定理知该λ-term存在.<br></p><p>则有:</p><equation>\begin{align}
&amp;A=_{\beta}\textbf{Y}(\lambda a.XaB)=_{\beta}(\lambda a.XaB)A=_{\beta}XAB\\
&amp;B=_{\beta}\textbf{Y}(\lambda b.YA^{'}(b)b)=_{\beta}(\lambda b.YA^{'}(b)b)B=_{\beta}YA^{'}(B)B=YAB
\end{align}</equation><br><p>证毕.</p><br><br><p><b>定理: 第二不动点定理(Second fixed-point theorem) </b>对于任意λ-term<equation>F</equation>均存在<equation>X</equation>满足:</p><p><equation>F\ulcorner \# X\urcorner=X</equation>.<br></p><p>证明: 将在下一节证明.</p><br><p><equation>\# X: \Lambda \rightarrow \mathbb{N}</equation> 为Gödel numbering, 从λ-term到<equation>\mathbb{N}</equation>的单射映射</p><p><equation>\ulcorner n\urcorner: n\mapsto c_n</equation> 为Church numeral, <equation>c_n=\lambda s.\lambda z. s^n(z)</equation>.<br></p><br><br><h2><b>最小不动点定理(Least fixed-point theorem):</b></h2><p><b>定义: </b>偏序集<equation>\langle L, \leq \rangle</equation>若任意<equation>a\in L, b\in L</equation>在<equation>\langle L, \leq \rangle</equation>存在上界, 即<equation>\exists c\in L\quad a&lt;c, b&lt;c</equation>, 则称其为有向集合(directed set).</p><br><br><p><b>定义:</b> 偏序集<equation>\langle L, \leq \rangle</equation>若任意<equation>S\subset L</equation>在<equation>\langle L, \leq \rangle</equation>中均存上确界与下确界, 即<equation>\bigvee S\in L</equation>与<equation>\bigwedge S\in L</equation>,则称其为完全格(complete lattice).</p><p>典型的例子有: 完全布尔代数(complete Boolean algebras)与完全海廷代数(complete Heyting algebras).</p><br><br><p><b>定义: </b>偏序集<equation>\langle L, \leq \rangle</equation>若有向子集<equation>S\subset L</equation>均存上确界, 称其为有向完全偏序(directed-complete partial order). 若有向完全偏序集中存在底元素<equation>\bot </equation>, 则称其为完全偏序(complete partial order).<br></p><p>根据定义有: 所有的完全格均为有向完全偏序.</p><br><br><p><b>定义: </b>在偏序集<equation>\langle L, \leq \rangle</equation>与<equation>\langle L^{'}, \leq \rangle</equation>间的映射<equation>f:L\rightarrow L^{'}</equation>满足: <equation>x\leq y \Rightarrow f(x)\leq f(y)</equation>, 则称其为单调的(monotonic)或保序的(order-preserving). 对偶概念为反单调的(antitone)或反序的(order-reversing)即: <equation>x\leq y \Rightarrow f(x)\geq  f(y)</equation></p><br><p>若单调与反单调映射<equation>f</equation>满足: <equation>x\leq y \Leftrightarrow  f(x)\leq f(y)</equation>, 则<equation>f</equation>为单射的, 称其为序嵌入(order embedding).<br></p><br><br><p><b>定义: 斯科特连续(Scott-</b><b>continuous</b><b>) </b>在偏序集<equation>\langle L, \leq \rangle</equation>与<equation>\langle L^{'}, \leq \rangle</equation>间的映射<equation>f:L\rightarrow L^{'}</equation>保持有向上确界, 即对于有向子集<equation>S\subset L</equation>, <equation>f</equation>满足: <equation>f(\bigvee S)=\bigvee f(S)</equation>, 则称其为连续的(continuous).<br></p><p>映射<equation>f</equation>连续性等价于偏序集在斯科特拓扑(Scott topology)上的连续性.</p><br><br><p><b>引理1: </b>连续性蕴含单调性, 即若<equation>f</equation>为连续的, 则其为单调的.</p><p>证明: 考虑有向集合<equation>S=\{x,y\}</equation>其中<equation>x\leq y</equation>则<equation>\bigvee S=y,\;\bigwedge S=x</equation>.由<equation>f</equation>连续性则有:</p><p><equation>f(y)=\bigvee f(S)\geq f(x)</equation>, 即<equation>f</equation>为单调的.<br></p><br><br><p><b>引理2:</b> 若<equation>f</equation>为单调的, 则<equation>f</equation>为连续的当且仅当对于有向集合子集<equation>S</equation>满足:<equation>f(\bigvee S)\leq \bigvee f(S)</equation>.</p><p>证明: 对于任意<equation>x\in S</equation>均有<equation>x\leq \bigvee S</equation>, 由<equation>f</equation>单调性有<equation>f(x)\leq f(\bigvee S)</equation>, 则<equation>f(\bigvee S)</equation>为<equation>\{f(x)\}</equation>的上界, 故有<equation>f(\bigvee S)\geq  \bigvee f(S)</equation>.</p><equation>\left.\begin{matrix}
f(\bigvee S)\geq  \bigvee f(S)\\ 
f(\bigvee S)\leq \bigvee f(S)
\end{matrix}\right\}\Rightarrow f(\bigvee S)=\bigvee f(S)</equation><br><p>即<equation>f</equation>为连续的. 证毕.</p><br><br><p><b>推论2: </b>给定幂集(Power set)构成的完全偏序集<equation>\langle \wp(S), \subseteq  \rangle</equation>上的单调自映射<equation>f:\wp(S) \rightarrow \wp(S)</equation>为连续的.</p><p>证明: 证明分两步.</p><p>第一步证明: 对于<equation>f:X\to Y</equation>集合<equation>\{S_{i}:i\in I\}</equation>为X子集的集合, 有<equation>f(\bigcup_{i
\in I}S_i) \subseteq  \bigcup_{i
\in I}f(S_i)</equation>.</p><p>令<equation>y\in f\left( \bigcup _{i\in I}S_{i}\right)</equation>, 则存在<equation>x\in \bigcup _{i\in I}S_{i}</equation>满足<equation>f(x)=y</equation>, 故<equation>\exists i\in I\quad x\in S_{i}</equation>满足<equation>f(x)=y</equation>. 继而<equation>\exists i\in I\quad  y\in f(S_{i})</equation>则有<equation>y\in \bigcup _{i\in I}f(S_{i})</equation>. </p><p>因此<equation>f\left( \bigcup _{i\in I}S_{i}\right)\subseteq \bigcup _{i\in I}f(S_{i})</equation>.</p><br><br><p>第二步证明: 令有向子集<equation>A^{\wp}\subseteq  \wp(S)</equation>, 即有<equation>\bigvee A^{\wp}=\bigcup_{A\in A^{\wp}}^{}{A}</equation>, 由单调性有:<equation>\bigvee  f(A^{\wp})=\bigcup_{A\in A^{\wp}}^{} f(A)</equation>. 由第一步证明有: <equation>f(\bigcup_{A\in A^{\wp}}^{}{A})\subseteq \bigcup_{A\in A^{\wp}}^{} f(A)</equation>即<equation>f(\bigvee A^{\wp})\leq \bigvee f(A^{\wp})</equation>.</p><br><p>由引理2得<equation>f(\bigvee A^{\wp})=\bigvee f(A^{\wp})</equation>, 因此<equation>f:\wp(S) \rightarrow \wp(S)</equation>连续. 证毕.</p><br><br><p><b>定义: </b>在偏序集<equation>\langle L, \leq \rangle</equation>上的上方集合与下方集合.</p><br><p>上方集合为<equation>\uparrow X=\left\{ y\in L\;|\;\exists x\in X\;x\leq y \right\} \quad \uparrow x=\uparrow \{x\}</equation></p><p>下方集合为<equation>\downarrow X=\left\{ y\in L\;|\;\exists x\in X\;y\leq x\right\} \quad \downarrow x=\downarrow \{x\}</equation></p><br><br><p><b>定义: </b>在偏序集<equation>\langle L, \leq \rangle</equation>上的自映射<equation>f:L\rightarrow L</equation>的前不动点(pre-fixed point)为: <equation>x\leq f(x)</equation></p><p>后不动点(post-fixed point)为: <equation>x\geq  f(x)</equation>.<br></p><br><br><p><b>定理: </b><b>Knaster-Tarski Theorem</b></p><p>完全格<equation>\langle L, \leq \rangle</equation>上的单调自映射<equation>f:L\rightarrow L</equation>的最小不动点与最大不动点存在且不动点集构成完全格.</p><p>证明: 证明分两步.</p><p>第一步证明: <equation>f</equation>的最小与最大不动点存在.</p><p>令<equation>f</equation>的前不动点集合为<equation>P=\{x\;|\;x\leq f(x)\}</equation>, 令<equation>u=\bigvee P</equation>.</p><p>对于任意<equation>x\in P</equation>, 有<equation>x\leq f(x)</equation>. 且<equation>u \geq x</equation>, 由<equation>f</equation>的单调性有<equation>f(u)\geq f(x)</equation>, 即<equation>x\leq f(x)\leq f(u)</equation>. 故<equation>f(u)</equation>为<equation>P</equation>的一个上界, 又有<equation>u</equation>为<equation>P</equation>的上确界, 故<equation>u\leq f(u)</equation>. 因此<equation>u \in P</equation>. 继而<equation>f(u) \in P</equation>因为<equation>f(u)\leq f(f(u))</equation>. 又因为<equation>u</equation>为<equation>P</equation>的上确界, 则<equation>u\geq f(u)</equation>. 所以有<equation>u=f(u)</equation>, <equation>u</equation>为<equation>f</equation>的不动点.</p><p>而<equation>f</equation>的所有不动点均在<equation>P</equation>内, 且<equation>u</equation>为<equation>P</equation>的上确界, 故<equation>u</equation>为<equation>f</equation>的最大不动点.</p><p>在对偶完全格<equation>\langle L, \geq  \rangle</equation>上, <equation>f</equation>仍保持单调性, 在对偶完全格中由上述证明存在最大不动点. 则在<equation>\langle L, \leq \rangle</equation>上为最小不动点. 因此<equation>\langle L, \leq \rangle</equation>中<equation>f</equation>的最小与最大不动点存在.<br></p><br><br><p>第二步证明: <equation>f</equation>的不动点构成完全格. </p><p>即证明不动点偏序集<equation>\langle P, \leq \rangle\quad(x\in P,\;x=f(x))</equation>为完全格.</p><p>对于任意<equation>P</equation>的子集<equation>S\subseteq P</equation>:</p><p>令<equation>W=\uparrow \bigvee S</equation>, 有<equation>\bigwedge W=\bigvee S</equation>与<equation>\bigwedge W\in W</equation>.</p><p><equation>\bigvee W= \bigvee L</equation>由于<equation>\bigvee W\geq \bigvee S</equation>故<equation>\bigvee W\in W</equation>.<br></p><p><equation>W</equation>为<equation>L</equation>的子集, 并且包含自身上确界与下确界. 故<equation>W</equation>为完全格. 令<equation>w\in W</equation>, <equation>\bigvee S=\bigwedge W \leq w\leq f(w)</equation>因此<equation>f(w)\in W</equation>. 令<equation>f^{'}:W\to W</equation>, <equation>f^{'}(w)=f(w)</equation>, 显然<equation>f^{'}</equation>为单调映射. 由第一步证明得<equation>f^{'}</equation>在<equation>W</equation>中存在最小不动点<equation>w^{\vee}</equation>同时是<equation>S</equation>的上界, 且<equation>w^{\vee}</equation>亦为<equation>f</equation>的不动点故<equation>w^{\vee}\in P</equation>. <equation>w^{\vee}</equation>为<equation>S</equation>在<equation>P</equation>中的上确界. 对偶证明可得下确界存在. 故<equation>\langle P, \leq \rangle</equation>为完全格.</p><p>证毕.</p><br><br><p><b>定理: Kleene fixed-point theorem</b></p><p>完全偏序集<equation>\langle L, \leq \rangle</equation>上的连续自映射<equation>f:L\rightarrow L</equation>存在最小不动点, 记<equation>f</equation>的最小不动点<equation>x</equation>为:</p><equation>Y_Lf=\bigvee_{n\in\mathbb{N}}{}f^n(\bot )\quad \quad x=Y_Lf</equation><br><p>证明: 证明分三步.</p><p>第一步证明: 在<equation>\langle L, \leq \rangle</equation>中<equation>x</equation>存在.</p><br><p>由于<equation>f</equation>为连续映射, 则<equation>f</equation>单调, <equation>\bot \leq f(\bot )</equation>. 归纳假设<equation>f^{n}(\bot )\leq f^{n+1}(\bot )</equation>, 则对于<equation>n+1</equation>情况: <equation>f^{n+1}(\bot )\leq f^{n+2}(\bot )\Leftrightarrow f(f^{n}(\bot ))\leq f(f^{n+1}(\bot ))</equation>, 由于<equation>f</equation>单调, 故<equation>n+1</equation>情况亦然成立. 由归纳得<equation>\forall n\in\mathbb{N}\quad f^{n}(\bot )\leq f^{n+1}(\bot )</equation>成立. </p><p><equation>\bot\leq f(\bot)\leq\cdots\leq f^n(\bot)</equation>为有向链, 故集合<equation>\left\{ f^{n}(\bot)\;|\; n\in\mathbb{N}\right\} </equation>为有向集合. 由完全偏序性质得<equation>\bigvee_{n\in\mathbb{N}}{}f^n(\bot )</equation>上确界存在, 即<equation>x</equation>存在.</p><br><br><p>第二步证明: <equation>x</equation>为<equation>f</equation>的不动点.</p><p>由于<equation>f</equation>为连续映射, 令<equation>y_n=f^n(\bot )</equation>, 有<equation>\bigvee_{n\in\mathbb{N}}{}f(y_n)=f\left( \bigvee_{n\in\mathbb{N}}{}y_n\right)</equation>, 故:<br></p><equation>x=Y_Lf=\bigvee_{n\in\mathbb{N}}{}f^n(\bot )=\bigvee_{n\in\mathbb{N}}{}f^{n+1}(\bot )=f\left( \bigvee_{n\in\mathbb{N}}{}f^n(\bot ) \right) =f(Y_Lf)=f(x)</equation><br><p>即<equation>x</equation>为<equation>f</equation>的不动点.<br></p><br><br><p>第三步证明: <equation>x</equation>为<equation>f</equation>的最小不动点.<br></p><p>令<equation>y=f(y)</equation>为<equation>f</equation>的不动点. 显然<equation>\bot\leq y</equation>, 归纳假设<equation>f^{n}(\bot )\leq y</equation>, 则对于<equation>n+1</equation>情况: 由于<equation>f</equation>单调<equation>f^{n+1}(\bot )\leq f(y)=y</equation>, 即<equation>f^{n+1}(\bot )\leq y</equation>亦然成立. 由归纳得<equation>\forall n\in\mathbb{N}\quad f^{n}(\bot )\leq y</equation>, 即<equation>y</equation>是<equation>\left\{ f^{n}(\bot)\;|\; n\in\mathbb{N}\right\} </equation>的上界, 故对于任意不动点<equation>y</equation>均有<equation>\bigvee_{n\in\mathbb{N}}{}f^n(\bot )\leq y</equation>, 即<equation>x=\bigvee_{n\in\mathbb{N}}{}f^n(\bot )</equation>为最小不动点.</p><p>证毕.</p><br><br><p>Knaster-Tarski Theorem揭示了若映射单调则最小不动点的存在性, 更进一步的, 若映射连续, 则Kleene fixed-point theorem给出了最小不动点的构造性表示.<br></p><br><br><p><b>引理3: </b>所有通过完全偏序集<equation>\langle \wp(S), \subseteq  \rangle</equation>的单调自映射<equation>\wp(S) \rightarrow \wp(S)</equation>, <equation>S</equation>为全集(universe), 定义的最小集合均是良好定义的(well defined).</p><p>证明: 若定义为直接定义, 则是平凡情况, 集合为良好定义的.</p><p>若为递归定义, 定义完全偏序集<equation>\langle \wp(S), \subseteq  \rangle</equation>, 该最小集合即为<equation>f</equation>的最小不动点, 根据推论2得<equation>f</equation>是连续的, 由Kleene fixed-point theorem得, <equation>f</equation>的最小不动点为<equation>Y_{\wp(S)}f</equation>即为该集合. 故集合为良好定义的. 证毕.</p><br><br><p>引理3回答了上文的递归结构定义问题, 在<equation>\Lambda^{-}=s\;|\;\Lambda^{-}\Lambda^{-}\;|\;\lambda s.\Lambda^{-}</equation>定义中:</p><p>令<equation>f(x)=s\;|\;xx\;|\;\lambda s.x</equation></p><br><equation>\Lambda^{-}</equation>为<equation>f(x)</equation>的最小不动点, 显然<equation>f(x)</equation>是单调的, 由引理3, 其构造性定义为:<br><p><equation>\Lambda^{-}=Y_{\wp(S)}f=\bigcup_{n\in\mathbb{N}}{}f^n(\bot )</equation> 其中 <equation>\bot =\{\}</equation><br></p><br><p>展开即是:</p><equation>\begin{align}
&amp;\Lambda^{-}_{1}:=s\\
&amp;\Lambda^{-}_{n}:=s\;|\;\Lambda^{-}_{n-1}\Lambda^{-}_{n-1}\;|\;\lambda s.\Lambda^{-}_{n-1}\quad(s\in S)\\
&amp;\Lambda^{-}=\bigcup_{i=1}^{} \Lambda^{-}_{i}
\end{align}</equation><br><p>所以递归定义是良好的, 并且两种定义是等价的.</p><p>注: 一些看似"非良好定义"的集合实际上也是良好定义的, 比如令<equation>f(x)=x</equation></p><p>那么<equation>A=f(A)</equation>即为<equation>A=A</equation>, 给出的<equation>A</equation>是</p><p><equation>A=Y_{\wp(S)}f=\bigcup_{n\in\mathbb{N}}{}f^n(\bot )</equation> 其中 <equation>\bot =\{\}</equation></p><p>显然<equation>f^n(\bot )=\bot =\{\}</equation>, 因此<equation>A=\{\}</equation>. <equation>A</equation>的定义亦然是良好的, 尽管<equation>A</equation>的递归是"死循环"的.</p><p>同样地可以对上文里地二叉树进行分析, 值得注意的是在程序中的递归结构和递归语义是基于不动点理论的, 特别指的是最小不动点(因为不动点不一定唯一), 下文的不动点逻辑将会给出这类递归定义结构的形式化表示.</p><br><br><h2><b>不动点逻辑(Fixed-point logic):</b></h2><p>上面的不动点定理给出了递归定义的良好定义性质, 接下来通过对一阶逻辑(first order logic)引入不动点拓展, 为这类的可递归枚举的(recursively enumerable)递归结构给出形式化定义.</p><br><br><p><b>模型论(Model Theory):</b></p><p>模型论中使用代数方法结合逻辑对结构的表示(representation)进行研究, 这里非常简单地介绍模型论与其中的不动点逻辑.<br></p><br><br><p><b>定义: 模型(Model)</b></p><p>模型定义在某个标署(signatures)σ上, 称为σ-structure, 构成为:</p><equation>\mathfrak{A}=\langle A, \sigma \rangle</equation><br><equation>\mathfrak{A}=\langle A,\left\{ c_i^{\mathfrak{A}} \right\},\left\{ R_i^{\mathfrak{A}} \right\},   \left\{ f_i^{\mathfrak{A}} \right\} \rangle</equation><br><p>其中<equation>A</equation>为全集, <equation>\sigma </equation>为:</p><equation>\sigma =(\left\{ c_i^{\mathfrak{A}} \right\},\left\{ R_i^{\mathfrak{A}} \right\},   \left\{ f_i^{\mathfrak{A}} \right\})</equation><br><p><equation>\left\{ c_i^{\mathfrak{A}} \right\}</equation>为常量符号集合, <equation> c_i^{\mathfrak{A}} \in A</equation><br></p><p><equation>\left\{ R_i^{\mathfrak{A}} \right\}</equation>为<equation>A</equation>上的<equation>k</equation>元关系, 即<equation>R_i^{\mathfrak{A}} \subseteq A^{k}</equation><br></p><p><equation>\left\{ f_i^{\mathfrak{A}} \right\}</equation>为<equation>k</equation>元函数, <equation>f_i^{\mathfrak{A}}:A^{k}\to A</equation><br></p><p>例如实数域可定义为: <equation>\mathbf{R}=\langle \mathbb{R}, \{0,1\},\{&lt;\},\{+,\times\} \rangle</equation><br></p><p>如果标署σ中没有函数, 则称模型为关系模型(relational).</p><p>若<equation>A</equation>为有限集合则称模型为有限模型.</p><br><p><equation>\boldsymbol{STRUCT}[\sigma ]</equation>为所有σ-structure的集合.<br></p><br><br><p>在模型上的一阶逻辑公式记作<equation>\mathfrak{A}\models\varphi(\vec{a})</equation>读作<equation>\varphi(\vec{a})</equation>在<equation>\mathfrak{A}</equation>上为真.<br></p><p><equation>\varphi</equation>中的自由符号为<equation>x_1,\dots,x_n</equation>, <equation>\vec{a}\in A^{n}</equation><br></p><p>推导规则如下:</p><p><equation>\mathfrak{A}\models\varphi(\vec{a})\quad (\varphi(x_1,\dots,x_n)\equiv x_i=x_j)</equation>  当且仅当<equation>a_i=a_j</equation><br></p><p><equation>\mathfrak{A}\models\varphi(\vec{a})\quad (\varphi(x_1,\dots,x_n)\equiv R(x_1,\dots,x_n))</equation>  当且仅当<equation>\{x_1,\dots,x_n\}\in R</equation><br></p><p><equation>\mathfrak{A}\models\neg \varphi(\vec{a})</equation>  当且仅当<equation>\mathfrak{A}\models\varphi(\vec{a})</equation>非真</p><p><equation>\mathfrak{A}\models\varphi_1(\vec{a})\vee \varphi_2(\vec{a})</equation>  当且仅当<equation>\mathfrak{A}\models\varphi_1(\vec{a})</equation>或<equation>\mathfrak{A}\models\varphi_2(\vec{a})</equation><br></p><p><equation>\mathfrak{A}\models\varphi_1(\vec{a})\wedge  \varphi_2(\vec{a})</equation>  当且仅当<equation>\mathfrak{A}\models\varphi_1(\vec{a})</equation>且<equation>\mathfrak{A}\models\varphi_2(\vec{a})</equation><br></p><p><equation>\mathfrak{A}\models\varphi(\vec{a})\quad (\varphi(\vec{x})\equiv \exists y\;\psi (y,\vec{x}))</equation>  当且仅当存在某一<equation>a^{'}\in A</equation>使得<equation>\mathfrak{A}\models\varphi(a^{'},\vec{a})</equation></p><p><equation>\mathfrak{A}\models\varphi(\vec{a})\quad (\varphi(\vec{x})\equiv \forall y\;\psi (y,\vec{x}))</equation>  当且仅当对于所有<equation>a^{'}\in A</equation>均有<equation>\mathfrak{A}\models\varphi(a^{'},\vec{a})</equation><br></p><p>例如群可定义为如下:<br></p><equation>\sigma =(\left\{ 1_e \right\},\left\{ \right\},   \left\{\cdot \right\})</equation><br><equation>\mathfrak{A}\in\boldsymbol{STRUCT}[\sigma ]</equation><br><equation>\begin{align}
\mathfrak{A}\models\forall u,v,w\quad&amp;(u\cdot v)\cdot w=u\cdot (v\cdot w)\;&amp;\wedge \\
&amp;u \cdot 1_e=u\;&amp;\wedge \\
&amp;1_e \cdot u=u\;&amp;\wedge \\
&amp;\exists u^{-1}\quad u \cdot u^{-1}=1_e\;&amp;\wedge \\
&amp;\exists u^{-1}\quad u^{-1} \cdot u=1_e\;&amp;\\
\end{align}</equation><br><br><p><b>定义: </b>模型同构<equation>\mathfrak{A}\cong\mathfrak{B}</equation>当且仅当对于描述模型<equation>\mathfrak{A}</equation>的公式<equation>\varphi_{\mathfrak{A}}</equation>有:</p><equation>\mathfrak{B}\models\varphi_\mathfrak{A}</equation><br><br><p>一阶逻辑是非常强的条件.</p><p>对于每个在同构下闭合的有限模型, 都有一个一阶逻辑公式来描述该模型.</p><p>有限模型<equation>Mod(\varphi)=\left\{ \mathfrak{A}\;|\;\mathfrak{A}\models\varphi \right\} </equation>是可判定(decidable)的.</p><p>同时, 过强的约束导致存在递归可枚举(recursively enumerable)的模型无法描述, 可用对角法证明.<br></p><br><br><p><b>定义: </b>迭代关系为在幂集<equation>A^k</equation>上的完全偏序集<equation>\langle \wp(A^{k}), \subseteq  \rangle</equation>间的自映射: </p><br><equation>F_{\varphi }:\wp(A^{k})\to\wp(A^{k})</equation><br><equation>F_{\varphi }(X)=\left\{\; \vec{a}\;|\;\mathfrak{A}\models\varphi_{X}(\vec{a}) \;\right\} </equation><br><br><p><b>定义: </b>一阶逻辑公式<equation>\varphi </equation>关于关系<equation>R</equation>为正向的(positive)当且仅当<equation>\varphi </equation>中的所有关系<equation>R</equation>被偶数层的否定<equation>\neg </equation>所包围.</p><br><br><p><b>引理4: </b>若<equation>\varphi </equation>关于关系<equation>R</equation>为正向的, 则迭代关系<equation>F_{\varphi }(X)</equation>为单调的, 进而可由推论2得<equation>F_{\varphi }(X)</equation>是连续的.<br></p><br>证明: 由德摩根定律(De Morgan's laws), 将所有否定向下移动合并, 由于<equation>\varphi </equation>中的所有关系<equation>R</equation>被偶数层否定<equation>\neg </equation>所包围, 则所有关系<equation>R</equation>前无否定. 即可得迭代关系<equation>F_{\varphi }(X)</equation>单调. 证毕.<br><br><p><b>定义: 最小不动点逻辑(least fixed-point logic)</b><br></p><br><p><equation>\varphi_{R}(\vec{x}) </equation>是关于关系<equation>R</equation>的正向一阶逻辑公式, 其中的自由符号为<equation>\vec{t}</equation>, <equation>R</equation>为<equation>k</equation>元关系, 并且有<equation>\left| \vec{t} \right| =\left| \vec{x} \right| =k</equation></p><br><equation>[lpf_{R,\vec{x}}\;\varphi_{R}(\vec{x}) ](\vec{a})\quad(\vec{a}\in A^{k})</equation><br><p>为最小不动点的一阶逻辑逻辑拓展.</p><br>语义为:<p><equation>\mathfrak{A}\models[lpf_{R,\vec{x}}\;\varphi_{R}(\vec{x}) ](\vec{a})</equation>  当且仅当  <equation>\vec{a}\in YF_\varphi </equation><br></p><p>(其中<equation>Yf=\bigvee_{n\in\mathbb{N}}{}f^n(\bot ),\;\bot =\{\}</equation>)</p><p>由<equation>\varphi_{R}(\vec{x}) </equation>是关于关系<equation>R</equation>的正向公式, 由引理4得<equation>F_\varphi </equation>是连续的, 根据Kleene fixed-point theorem得<equation>YF_\varphi </equation>即是<equation>F_\varphi </equation>的最小不动点.</p><p>因此对于该有限递归结构存在与之对应的一阶逻辑公式.</p><br><br><p>在引入了最小不动点逻辑后, 模型可以表达递归结构</p><br><p>例如: </p><p>连通图表示为</p><equation>\mathfrak{A}\models\forall u,v\;[lpf_{R,(x,y)}\;(x=y\vee (\exists z\;E(x,z)\wedge  R(z,y))) ](u,v)</equation><br><p>无环图可表示为</p><equation>\mathfrak{A}\models\forall u\;[lpf_{R,x}\; (\forall y\;E(y,x)\rightarrow R(y))](u)</equation><br><p>(以上的<equation>\varphi </equation>显然是正向的)</p><p>那么树就可以表示为连通图+无环图. 二叉树是所有节点的度小于3的树.</p><p>等等的递归结构都可以容易地在不动点逻辑中表示出来.</p><br><br><p>由Curry–Howard isomorphism得, 逻辑命题对应于类型. 在模型论中基于一阶逻辑定义的结构均可在类型系统中给出定义. 对于例子中的连通图与无环图的类型需要使用到依值类型(dependent type), 这部分的相关内容将会在以后章节中讲到.</p><p>除了least fixed point logic外还有inflationary fixed point logic, 构造形式稍微有些不同, 可以证明的是这两种不动点表达能力是等价的.</p><br><br><p>(我感觉我跑题很远呀喵! 这节真正和λ-calculus相关的内容不是很多, 倒是介绍了不少别的和不动点有关的知识)</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
