<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>工程趣闻（四）：不要制造问题</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/37669640">原文</a></p>
<h2><b>XY问题</b></h2><img src="https://pic4.zhimg.com/v2-278fb2bc7f11a3ad58a044c4a6d22569_r.jpg" data-rawwidth="440" data-rawheight="298" data-caption="" data-size="normal" data-watermark="watermark" data-original-src="v2-278fb2bc7f11a3ad58a044c4a6d22569" data-watermark-src="v2-95d00e0f158ee2c853cfb4c18676246a" data-private-watermark-src=""><p>这个问题，最早是在<a href="http://coolshell.cn/articles/10804.html">酷壳：X-Y Problem</a>中看到的。</p><p>对于X-Y Problem的意思如下：<br>1）有人想解决问题X<br>2）他觉得Y可能是解决X问题的方法<br>3）但是他不知道Y应该怎么做<br>4）于是他去问别人Y应该怎么做？<br>简而言之，没有去问怎么解决问题X，而是<b>去问</b>解决方案Y应该怎么去实现和操作。</p><p><b>于是乎：</b><br>1）热心的人们帮助并告诉这个人Y应该怎么搞，但是大家都觉得Y这个方案有点怪异。<br>2）在经过大量地讨论和浪费了大量的时间后，热心的人终于明白了原始问题X是怎么一回事。<br>3）于是大家都发现，Y根本就不是用来解决X的合适的方案。</p><p>X-Y Problem最大的严重的问题就是：<br><b>在一个根本错误的方向上浪费他人大量的时间和精力！</b></p><hr><h2><b>Accidental complexity</b></h2><p><b>Neal Ford</b>指出，<br><b>Essential complexity</b>指的是问题与生俱来的，无法避免的困难。<br><b>Accidental complexity</b>，是人们解决Essential complexity的过程中衍生的。</p><p>系统设计的初衷是解决Essential complexity，<br>但是解决方案本身带来了新的问题。</p><p>许多软件框架和厂商提供的“解决方案”都表现出Accidental complexity的症状。<br>解决特定问题的框架很管用，<br>但<b>设计过度的框架</b>增加的复杂性反而超过了它应该缓解的复杂性。</p><p>在大型软件项目中，关注Essential complexity，消除Accidental complexity，<br>抽丝剥茧制订解决方案，才是真正的挑战。</p><blockquote>It's the duty of the architect to solve the problems inherent in essential complexity without introducing accidental complexity.</blockquote><p>注：<br>就英语：accidental的这个字眼而言，并不是指偶然发生的意思，<br>也不是意外不幸的意思，而是比较接近<b>伴随的</b>或次要的意思。</p><b><hr></b><h2><b>关注难点</b></h2><img src="https://pic4.zhimg.com/v2-0687103524cfe50bcb5d6e1f332181bb_r.jpg" data-rawwidth="460" data-rawheight="460" data-caption="" data-size="normal" data-watermark="watermark" data-original-src="v2-0687103524cfe50bcb5d6e1f332181bb" data-watermark-src="v2-c4d0521f7621d8e084ddbd074a59b915" data-private-watermark-src=""><p><b>Frederick P. Brooks</b>在论文<a href="http://worrydream.com/refs/Brooks-NoSilverBullet.pdf">No Silver Bullet</a>中将软件开发的困难分为两类：<br>（1）<b>Essential Difficulties：</b>打造由抽象软件实体构成的复杂概念结构<br>（2）<b>Accidental Difficulties：</b>使用编程语言表达这些抽象实体，在空间和时间限制内将它们映射成机器语言</p><p>软件开发真正的困难，是在于这种<b>概念构造</b>的规格制定、设计和测试。<br>而并非在孜孜矻矻于它的呈现方式，以及测试该呈现方式的精确程度。</p><p>Accidental Difficulties会随着工具的改善而逐渐淡化，<br>反而是Essential Difficulties最难以解决，<br>因为大部分的活动是发生在人们的<b>脑海里</b>，缺乏有效的辅助工具。</p><p>Brooks认为现在是关注软件任务中的必要活动的时候了，<br>也就是那些和构造异常复杂的<b>抽象概念</b>结构有关的部分。</p><p>他提出了几个建议：<br>（1）仔细地进行市场调研，避免开发已上市的产品，<br>构建软件最可能的彻底解决方案是<b>不开发任何软件</b>。</p><p>（2）在获取和制订软件需求时，将快速原型开发作为迭代计划的一部分。<br>因为，开发软件系统的过程中，最困难的部分是<b>确切地决定搭建什么样的系统</b>。</p><p>（3）增量开发——增长，而非搭建系统。<br>有机地更新软件，随着系统的运行、使用和测试，<b>逐渐添加</b>越来越多的功能。</p><p>（4）不断挑选和培养杰出的概念设计人员，<br>软件行业的核心，一如既往的是<b>人员</b>。</p><blockquote>Good programmers spend much of the other 90% thinking, researching, and experimenting to find the best design. Bad programmers spend much of that 90% debugging code by randomly making changes and seeing if they work.</blockquote><b><hr></b><h2><b>参考</b></h2><p><a href="http://xyproblem.info/">The XY Problem</a><br><a href="https://book.douban.com/subject/4745287/">软件架构师应该知道的97件事</a><br><a href="https://book.douban.com/subject/1102259/">人月神话</a><br><a href="https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9">没有银弹</a><br><a href="http://automagical.rationalmind.net/2010/08/17/some-lesser-known-truths-about-programming/">Some lesser known truths about programming</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
