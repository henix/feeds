<div class="title-image"><img src="https://pic1.zhimg.com/v2-001defcec440e6006959d0179e91a0f9_b.jpg" alt=""></div><p>决策树是一种非参的监督性机器学习方法。它可以用来做<b>分类判断</b>和<b>回归预测</b>。决策树的基本原理是通过学习现有数据的特征，得到简单的决策规律，再根据这些决策规律对目标进行判断。 </p><p class="ztext-empty-paragraph"><br/></p><p class="ztext-empty-paragraph"><br/></p><p><b>一、决策树的概念</b></p><p>决策树是在已知各种情况发生概率的基础上，通过构成决策树来判断下一预测点，判断其是否会发生的分析方法，是直观运用概率分析的一种图解法。由于这种决策树分支的图形很像树的枝干，故称决策树。下面是一个决策树的例子：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-7d97b2f1fb5f3ecdc5c976b16acf6b5d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1131" data-rawheight="607" class="origin_image zh-lightbox-thumb" width="1131" data-original="https://pic2.zhimg.com/v2-7d97b2f1fb5f3ecdc5c976b16acf6b5d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-7d97b2f1fb5f3ecdc5c976b16acf6b5d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1131" data-rawheight="607" class="origin_image zh-lightbox-thumb lazy" width="1131" data-original="https://pic2.zhimg.com/v2-7d97b2f1fb5f3ecdc5c976b16acf6b5d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-7d97b2f1fb5f3ecdc5c976b16acf6b5d_b.jpg"/></figure><p>在上面例子中我们需要对新的兔子进行判断，根据这一问题建立一棵决策树，上图也展示了决策树的组成部分：根节点，分支和叶子。首先上述决策树的根节点是“毛色”，在这一基础上延伸出两个分支“黑褐色”和“白色”，倘若为黑褐色，进入叶子得到结论这是一只“中国白兔；倘若为“白色”则进入下一个节点判断，一直到没有节点的叶子为止。对于一只40厘米的白色成年兔子，首先判断其毛色为白色，进入长度节点，然后长度大于30cm，基于此我们可判断这只成年兔子为新西兰兔。</p><p class="ztext-empty-paragraph"><br/></p><p>决策树本质上是基于过去的特征信息对过去目标结论的判断的总结，运用于金融预测领域直观的解释就是：由于这件事在过去相同特征的环境下大概率发生，所以此时这件事也很可能会发生，及“历史总是惊人的相似”。决策树在机器学习领域的应用在于可以把人从浩如烟海的数据中解放出来，让计算机去寻找数据之间的内在规律用于下一步研究，也可以直接使用决策树的结论进行判断，但不需要可视化的情况下目前更多的会去选择Randomforest，Boosting等决策树的改进。决策树基于的假设较少，适用于大部分情况。</p><p class="ztext-empty-paragraph"><br/></p><p>但其缺点也很明显：</p><p><b>1、精度较低</b> </p><p><b>2、他每次只会根据单一特征划分数据，不会根据数据组合切分。</b>如下图, 他只会根据年龄或经验区分数据，但当两者有联系时，决策树只会用多次切分拟合这一情况。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-360be0f5afb11545e1be9d53c7542c34_b.jpg" data-caption="" data-size="normal" data-rawwidth="449" data-rawheight="289" class="origin_image zh-lightbox-thumb" width="449" data-original="https://pic1.zhimg.com/v2-360be0f5afb11545e1be9d53c7542c34_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-360be0f5afb11545e1be9d53c7542c34_b.jpg" data-caption="" data-size="normal" data-rawwidth="449" data-rawheight="289" class="origin_image zh-lightbox-thumb lazy" width="449" data-original="https://pic1.zhimg.com/v2-360be0f5afb11545e1be9d53c7542c34_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-360be0f5afb11545e1be9d53c7542c34_b.jpg"/></figure><p><b>3、受误差值影响较大</b></p><p class="ztext-empty-paragraph"><br/></p><p class="ztext-empty-paragraph"><br/></p><p><b>二、决策树的生成过程</b></p><p>了解了决策树的原理，那如何根据问题生成决策树呢？我们知道决策树是由根节点，分叉，叶组成的，决策树的生成就是寻找根节点、节点和如何生成分叉了。决策树生成的核心思想就是找出更加纯净的子集，最好每个子集里都是结论极其单一的数据。判断纯度的方法不同决策树的生成也不同，常用的判断方法有：</p><p>1、ID3算法使用信息增益作纯度判断；</p><p>2、C4.5算法使用信息增益率作纯度判断；</p><p>3、CART算法使用基尼系数作纯度判断。</p><p class="ztext-empty-paragraph"><br/></p><p><b>决策树生成过程：</b></p><p>1、寻找最适合分割的特征</p><p>2、根据纯度判断方法，寻找最优的分割点，基于这一特征把数据分割成纯度更高的两部分数据</p><p>3、判断是否达到要求，若未达到，重复步骤一继续分割，直到达到要求停止为止。</p><p>4、剪枝，防止过拟合。</p><p>纯度判断和过拟合的具体做法在下面两部分讲到</p><p class="ztext-empty-paragraph"><br/></p><p><b>数据纯净度的判别</b></p><p>决策树生成时，我们希望每个分支的数据尽量属于同一类别，也就是寻找纯净的分类，判断数据纯净程度的方法也决定了我们如何生成分支，目前主流的方法包括ID3，C4.5和CART三种。</p><p>在介绍这三种方法之前先简单介绍信息熵：</p><p class="ztext-empty-paragraph"><br/></p><p><b>信息熵：</b></p><p>熵是衡量系统混乱程度的一个指标，熵值越大表示对应的系统越混乱，决策树中引入信息熵的概念来衡量数据的纯净程度。假定目标集合S中有n种样本，第k种样本所占比例为pk（k=1,2,3,…,n）,则S的信息熵为：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-ae67183a75cd418c605c60e83459d16b_b.jpg" data-caption="" data-size="normal" data-rawwidth="211" data-rawheight="71" class="content_image" width="211"/></noscript><img src="https://pic4.zhimg.com/v2-ae67183a75cd418c605c60e83459d16b_b.jpg" data-caption="" data-size="normal" data-rawwidth="211" data-rawheight="71" class="content_image lazy" width="211" data-actualsrc="https://pic4.zhimg.com/v2-ae67183a75cd418c605c60e83459d16b_b.jpg"/></figure><p><b>ID3算法：</b></p><p>ID3算法用信息增益来衡量混乱程度</p><p><b>信息增益：</b></p><p>Gain(k)=分裂前目标变量的信息熵-对特征值k分裂后的目标变量信息熵 若总数据量为D，分裂后数据成为有M个叶节点的分叉树，那么Gain（k）为</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-cab7c5dc04c21b8d187fe8dcc0b97681_b.jpg" data-caption="" data-size="normal" data-rawwidth="299" data-rawheight="82" class="content_image" width="299"/></noscript><img src="https://pic2.zhimg.com/v2-cab7c5dc04c21b8d187fe8dcc0b97681_b.jpg" data-caption="" data-size="normal" data-rawwidth="299" data-rawheight="82" class="content_image lazy" width="299" data-actualsrc="https://pic2.zhimg.com/v2-cab7c5dc04c21b8d187fe8dcc0b97681_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>分叉点的选择：遍历全部现有可能分叉点，选择信息增益最大的分叉点建立新的分叉。 </p><p>停止分裂的条件： 1，节点中全部样本的目标变量同属于一个类别 2，如果分叉后的样本数目小于给定的阀值，也停止进行分叉。</p><p>叶节点的属性：选择叶节点里数量最多的类别作为叶节点的类别 </p><p class="ztext-empty-paragraph"><br/></p><p><b>C4.5算法：</b></p><p>C4.5算法用信息增益率来衡量混乱程度</p><p>信息增益率: Gain_ratio(k)=信息增益率/被选分叉点本来的熵</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-c048b23ec900e49eef3e521153f0cccc_b.jpg" data-caption="" data-size="normal" data-rawwidth="294" data-rawheight="74" class="content_image" width="294"/></noscript><img src="https://pic1.zhimg.com/v2-c048b23ec900e49eef3e521153f0cccc_b.jpg" data-caption="" data-size="normal" data-rawwidth="294" data-rawheight="74" class="content_image lazy" width="294" data-actualsrc="https://pic1.zhimg.com/v2-c048b23ec900e49eef3e521153f0cccc_b.jpg"/></figure><p>其中，</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-64957b024b2d33b47138523f572bc5a1_b.jpg" data-caption="" data-size="normal" data-rawwidth="243" data-rawheight="66" class="content_image" width="243"/></noscript><img src="https://pic2.zhimg.com/v2-64957b024b2d33b47138523f572bc5a1_b.jpg" data-caption="" data-size="normal" data-rawwidth="243" data-rawheight="66" class="content_image lazy" width="243" data-actualsrc="https://pic2.zhimg.com/v2-64957b024b2d33b47138523f572bc5a1_b.jpg"/></figure><p>Ent(Dk)和Ent(S)的区别是：一个计算的是总集合S的熵，一个计算的是总集合S中节点k的熵。</p><p>分叉点的选择：遍历全部现有可能分叉点，选择信息增益率最大的分叉点建立新的分叉。 </p><p>停止分裂的条件： 1 节点中全部样本的目标变量同属于一个类别 2 如果分叉后的样本数目小于给定的阀值，也停止进行分叉。</p><p>叶节点的属性：选择叶节点里数量最多的类别作为叶节点的类别</p><p>特征：比起ID3算法来，C4.5更倾向于选择区直更少的特征值分叉。</p><p class="ztext-empty-paragraph"><br/></p><p><b>CART算法：</b></p><p>CART算法用基尼指数来衡量数据集混乱程度 </p><p><b>基尼值：</b></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-e6d2b6a0904edf0686c482bdb678470b_b.jpg" data-caption="" data-size="normal" data-rawwidth="190" data-rawheight="80" class="content_image" width="190"/></noscript><img src="https://pic4.zhimg.com/v2-e6d2b6a0904edf0686c482bdb678470b_b.jpg" data-caption="" data-size="normal" data-rawwidth="190" data-rawheight="80" class="content_image lazy" width="190" data-actualsrc="https://pic4.zhimg.com/v2-e6d2b6a0904edf0686c482bdb678470b_b.jpg"/></figure><p>基尼值(S)指的是从数据S中随机取两个不同类别值的概率，因此Gini值越大意味着数据越混乱。<br/>若总数据量为D，分裂后数据成为有M个叶节点的分叉树，那么Gini_index(k)为</p><p><b>基尼指数：</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-87f5efb0ccd5f087cb501641ca9d5f48_b.jpg" data-caption="" data-size="normal" data-rawwidth="252" data-rawheight="84" class="content_image" width="252"/></noscript><img src="https://pic1.zhimg.com/v2-87f5efb0ccd5f087cb501641ca9d5f48_b.jpg" data-caption="" data-size="normal" data-rawwidth="252" data-rawheight="84" class="content_image lazy" width="252" data-actualsrc="https://pic1.zhimg.com/v2-87f5efb0ccd5f087cb501641ca9d5f48_b.jpg"/></figure><p><b>分叉点的选择：</b>遍历全部现有可能分叉点，选择基尼指数最小的分叉点建立新的分叉。 </p><p><b>停止分裂的条件：</b><br/>1，决策树到达最大深度<br/>2，分叉节点的样本数小于阀值<br/>3，分叉的叶内的样本数小于阀值 </p><p><b>叶节点的属性：</b>选择叶节点里数量最多的类别作为叶节点的类别</p><p class="ztext-empty-paragraph"><br/></p><p><b>过拟合处理</b></p><p>在决策树学习过程中，因为随着子集样本越小，混乱程度必然下降，这意味着决策树分叉总是向着过拟合的方向。为了降低过拟合风险，需要主动去除一些分类效果不明显的分叉来防止过拟合，这一过程被称为剪枝。<br/>剪枝主要有两种方法：预剪枝和后剪枝<br/> </p><p><b>预剪枝：</b><br/>预剪枝是在生成决策树过程中，对节点划分先进性预估，若节点分叉不能使决策树得到泛化提升，则停止分叉生成叶。代表算法是悲观错误剪枝法PEP（Pesimistic-Error Pruning）<br/> </p><p><b>后剪枝：</b><br/>后剪枝是生成一颗完整的决策树后，自下而上对每个叶片和节点进行评估，若减少分叉可以使决策树得到泛化提升，则转化分叉为一个叶。代表算法有错误率降低剪枝REP（Reduced-Error Pruning），代价复杂度剪枝CCP（Cost-Complexity Pruning）</p><p class="ztext-empty-paragraph"><br/></p><p class="ztext-empty-paragraph"><br/></p><p><b>三、决策树的Python代码实现</b></p><p>决策树在实际中一般有两个用处：</p><p>1、直接用于预测。</p><p>2、借助决策树的实现图形寻找规律。<br/>第一种很好理解，和大多数模型一样，建立模型预测。<br/>第二种的实现是基于决策树的原理与人类思考接近。决策树的实现过程本来就是纯化子集的过程，生成决策树后，他的每一个叶子都应该是比较纯净的，及它可以找到在某些特征条件下结论较为一致的情境。研究者可以根据决策树找到的一些纯净度比较高的情境，省去大量找规律的时间。</p><p class="ztext-empty-paragraph"><br/></p><p><b>1、学习</b></p><p>首先我们使用机器学习库sklearn中的数据来介绍决策树的主要功能。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-7e599ebf2c2e9db8519f5a250250f446_b.jpg" data-caption="" data-size="normal" data-rawwidth="1075" data-rawheight="285" class="origin_image zh-lightbox-thumb" width="1075" data-original="https://pic3.zhimg.com/v2-7e599ebf2c2e9db8519f5a250250f446_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-7e599ebf2c2e9db8519f5a250250f446_b.jpg" data-caption="" data-size="normal" data-rawwidth="1075" data-rawheight="285" class="origin_image zh-lightbox-thumb lazy" width="1075" data-original="https://pic3.zhimg.com/v2-7e599ebf2c2e9db8519f5a250250f446_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-7e599ebf2c2e9db8519f5a250250f446_b.jpg"/></figure><p>首先导入必要的包和数据，在这我们以预测第111个数据作为例子</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-9de8ed88ae80ae5528f9d00b2da9f14c_b.jpg" data-caption="" data-size="normal" data-rawwidth="1086" data-rawheight="282" class="origin_image zh-lightbox-thumb" width="1086" data-original="https://pic1.zhimg.com/v2-9de8ed88ae80ae5528f9d00b2da9f14c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-9de8ed88ae80ae5528f9d00b2da9f14c_b.jpg" data-caption="" data-size="normal" data-rawwidth="1086" data-rawheight="282" class="origin_image zh-lightbox-thumb lazy" width="1086" data-original="https://pic1.zhimg.com/v2-9de8ed88ae80ae5528f9d00b2da9f14c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-9de8ed88ae80ae5528f9d00b2da9f14c_b.jpg"/></figure><p>查看用作例子的数据的各个特征值，将其特征值带入建立好的决策树预测，可以看到结果与真实值相同。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-02fc940d5f1f8ac1f016b4d70a13cae8_b.jpg" data-caption="" data-size="normal" data-rawwidth="1112" data-rawheight="102" class="origin_image zh-lightbox-thumb" width="1112" data-original="https://pic1.zhimg.com/v2-02fc940d5f1f8ac1f016b4d70a13cae8_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-02fc940d5f1f8ac1f016b4d70a13cae8_b.jpg" data-caption="" data-size="normal" data-rawwidth="1112" data-rawheight="102" class="origin_image zh-lightbox-thumb lazy" width="1112" data-original="https://pic1.zhimg.com/v2-02fc940d5f1f8ac1f016b4d70a13cae8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-02fc940d5f1f8ac1f016b4d70a13cae8_b.jpg"/></figure><p><b>predict_proba</b>可以用来观察决策树判断的依据。决策树的结论是： 这一数据属于0,1,2的概率分别为0,0.22,0.978，选取最大概率，这一数据被认为属于第2类。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-b8551d649e3f1fff0a22c02743fe1a9c_b.jpg" data-caption="" data-size="normal" data-rawwidth="1112" data-rawheight="88" class="origin_image zh-lightbox-thumb" width="1112" data-original="https://pic1.zhimg.com/v2-b8551d649e3f1fff0a22c02743fe1a9c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-b8551d649e3f1fff0a22c02743fe1a9c_b.jpg" data-caption="" data-size="normal" data-rawwidth="1112" data-rawheight="88" class="origin_image zh-lightbox-thumb lazy" width="1112" data-original="https://pic1.zhimg.com/v2-b8551d649e3f1fff0a22c02743fe1a9c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-b8551d649e3f1fff0a22c02743fe1a9c_b.jpg"/></figure><p><b>featureimpertances</b>可以用来查看各个因子的重要性。显示因子4重要性占所有因子的100%，整个决策树完全依赖于因子4。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-02b4c9f97854451fe3781dfcde91a4ca_b.jpg" data-caption="" data-size="normal" data-rawwidth="1115" data-rawheight="577" class="origin_image zh-lightbox-thumb" width="1115" data-original="https://pic3.zhimg.com/v2-02b4c9f97854451fe3781dfcde91a4ca_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-02b4c9f97854451fe3781dfcde91a4ca_b.jpg" data-caption="" data-size="normal" data-rawwidth="1115" data-rawheight="577" class="origin_image zh-lightbox-thumb lazy" width="1115" data-original="https://pic3.zhimg.com/v2-02b4c9f97854451fe3781dfcde91a4ca_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-02b4c9f97854451fe3781dfcde91a4ca_b.jpg"/></figure><p>画出决策树，有两个节点3片叶子，叶子的纯度都比较高，都大于90%。</p><p class="ztext-empty-paragraph"><br/></p><p><b>2、实验</b></p><p>接下来举个简单的例子展示决策树在实际股市分析预测中的运用。<br/>已下是一个使用决策树预测HS300涨跌测试函数，用市场平均的：</p><p><b>PCF</b>,<b>turnover_ratio</b>,<b>PE_rate</b>,<b>PB_rate</b>,<b>PS_rate</b>,</p><p>以及宏观数据：</p><p><b>pmi</b>,<b>pmi_rate</b>,<b>leading_idx_rate</b>,<b>M1_rate</b>,<b>M2_rate</b>,<b>CPI_rate</b>,<b>GDP_rate</b>,<b>LOAN6MONTH</b>,<b>LARGEFINANCIAL</b>,<b>SMALLFINANCIAL</b>,<b>dcg</b>,<b>URUR</b></p><p>这些数据使用决策树算法对HS300的涨跌进行预测，预测结果有四种，分别是：‘下跌大于5%’，‘下跌介于5%与0%之间’，‘上涨介于0%和5%’，‘上涨大于5%’，。数据取了2005年5月到2017年11月的全部月数据，以其中70%做训练，以30%数据做测试，所有宏观数据都根据发布时间取了滞后两个月或者一个季度的数据来做预测，以确保实际中可以取到这些值。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-f5ed35090de2137e27de6dd5407171b1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="679" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-f5ed35090de2137e27de6dd5407171b1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-f5ed35090de2137e27de6dd5407171b1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="679" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-f5ed35090de2137e27de6dd5407171b1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-f5ed35090de2137e27de6dd5407171b1_b.jpg"/></figure><p>以上是决策树建立的代码，我们用CART的方法用‘gini值’确定叶数据纯度，并要求节点最少应该有10个数据，每片叶最少有5个数据。<br/>决策树模型的主要参数有：<br/><b>criterion:</b> 决定判断节点纯度的方法。目前sklearn支持”gini”和”entropy”两种，分别对应用基尼指数和信息增益的CART和ID3两种算法，默认算法是“gini”。<br/><b>max_depth:</b> 最大树深度，达到最大数深度即停止分叉，最常用的约束，默认值为None<br/><b>spliter:</b> 决定如何分叉每个节点。目前sklearn支持“best”和“random”两种，指的是选取特征的最优分叉点分叉还是随机分叉点分叉，默认值是“best”<br/><b>max_features:</b> 使用特征值的最大数量，默认为None<br/><b>max_leaf_nodes:</b> 叶节点的数量，默认值为None<br/><b>min_impurity_split:</b> 最小纯度门槛，假如纯度小于最小纯度，则会继续切分，默认值为None<br/><b>min_samples_leaf:</b> 最小叶数据，达到则不再分叉，默认值为1<br/><b>min_samples_split:</b> 最小节点数据，达到则不再分叉，默认值是2 </p><p>决策树的参数一般依情况而定，可以根据需要不断调整。也可以用sklearn的包GridSearchCV用cross validation的方法暴力遍历指定范围参数确定结果。调参在其他机器学习方法如神经网络模型中也是核心问题，一般是使用者的经验加计算机尝试不同的值得到一个相对较好的结果。对于决策树，初学者一般限定树深度即可，其他设置可使用默认参数。</p><p>接下来即可使用决策树进行预测</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-548e39b46ba9ebc8008280c97aef3af2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1112" data-rawheight="127" class="origin_image zh-lightbox-thumb" width="1112" data-original="https://pic3.zhimg.com/v2-548e39b46ba9ebc8008280c97aef3af2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-548e39b46ba9ebc8008280c97aef3af2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1112" data-rawheight="127" class="origin_image zh-lightbox-thumb lazy" width="1112" data-original="https://pic3.zhimg.com/v2-548e39b46ba9ebc8008280c97aef3af2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-548e39b46ba9ebc8008280c97aef3af2_b.jpg"/></figure><p>上述代码即可使用计算机自动生成的决策树图解，其叶片都是比较纯净的子集，可以帮助研究者筛选规律。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-ec2350c9343b3d255b19b40c2446b13e_b.jpg" data-caption="" data-size="normal" data-rawwidth="1304" data-rawheight="1191" class="origin_image zh-lightbox-thumb" width="1304" data-original="https://pic3.zhimg.com/v2-ec2350c9343b3d255b19b40c2446b13e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-ec2350c9343b3d255b19b40c2446b13e_b.jpg" data-caption="" data-size="normal" data-rawwidth="1304" data-rawheight="1191" class="origin_image zh-lightbox-thumb lazy" width="1304" data-original="https://pic3.zhimg.com/v2-ec2350c9343b3d255b19b40c2446b13e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-ec2350c9343b3d255b19b40c2446b13e_b.jpg"/></figure><p>以上是决策树的整个图解，挖掘到了一些特征，例如最右边的叶表示当市场平均的&#39;PB_rate&#39;&lt;=-0.01, ‘PS_rate’&lt;=0.05时，历史上6次这种情况下HS300都发生大跌。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-753487d776c74dab677ca18e9ec11142_b.jpg" data-caption="" data-size="normal" data-rawwidth="1112" data-rawheight="385" class="origin_image zh-lightbox-thumb" width="1112" data-original="https://pic3.zhimg.com/v2-753487d776c74dab677ca18e9ec11142_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-753487d776c74dab677ca18e9ec11142_b.jpg" data-caption="" data-size="normal" data-rawwidth="1112" data-rawheight="385" class="origin_image zh-lightbox-thumb lazy" width="1112" data-original="https://pic3.zhimg.com/v2-753487d776c74dab677ca18e9ec11142_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-753487d776c74dab677ca18e9ec11142_b.jpg"/></figure><p>这是取2005年5月到2017年11月全部数据后，取70%做训练集，30%做测试验证结果，得到的精度统计，表格如下所示：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-04087d431ee7e6d3b38e4acbe8e54efb_b.jpg" data-caption="" data-size="normal" data-rawwidth="342" data-rawheight="132" class="content_image" width="342"/></noscript><img src="https://pic4.zhimg.com/v2-04087d431ee7e6d3b38e4acbe8e54efb_b.jpg" data-caption="" data-size="normal" data-rawwidth="342" data-rawheight="132" class="content_image lazy" width="342" data-actualsrc="https://pic4.zhimg.com/v2-04087d431ee7e6d3b38e4acbe8e54efb_b.jpg"/></figure><p>精度很差，只是略高于一半而已。简单的决策树过于基础，识别能力有限，用于预测股市显然很一般。</p><p>不过决策树是很多机器学习方法的基石，其改进模型往往会有较好表现。此外决策树便于可视化，他的产生的分布图可以用于数据研究，例如决策树的每一片页都是相对比较纯净的数据集，使用者可以抽出一些纯度比较高的叶来研究为何在训练集中这些叶上的数据集纯度较高，从而发现新规律。</p><p class="ztext-empty-paragraph"><br/></p><p class="ztext-empty-paragraph"><br/></p><p><b>四、补充和扩展</b></p><p>写在最后：<br/>决策树由于理论简单，易于理解，在数据可视化，利用计算机寻找数据规律中有不小的作用。但其模型过于简单，对于复杂的模型一般来说只是优于线性模型而已，对比其他算法并没有太大优势，其简单的结构也不能充分利用目前强大的计算机计算能力，已经不怎么活跃了。但是作为极易可视化，逻辑清晰的一种白盒算法，其不仅活跃于数据研究，而且也是其他高级算法的基石。决策树的两个主要改进方向是Randomforest 和 boosting，都在机器学习中有举足轻重的地位。</p><p></p>