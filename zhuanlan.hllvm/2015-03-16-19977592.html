<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>JIT编译，动态编译与自适应动态编译</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/19977592">原文</a></p>
<p>在微博上看到有人在推广这篇介绍Visual C++与RyuJIT的文章：</p><p><a href="http://blog.jobbole.com/84712/" data-editable="true" data-title="每个程序员都应当知道的编译器优化知识">每个程序员都应当知道的编译器优化知识</a><br></p><p>（原文：<a href="https://msdn.microsoft.com/en-us/magazine/dn904673.aspx" data-editable="true" data-title="Compilers - What Every Programmer Should Know About Compiler Optimizations" class="">Compilers - What Every Programmer Should Know About Compiler Optimizations</a>, MSDN Magazine 2015-02）</p><p>这篇文章总体来说写得还不错。不过在描述RyuJIT的功能时略微夸大了一些：</p><blockquote>What’s the difference between RyuJIT and Visual C++ in terms of optimization capabilities? Because it does its work at run time, RyuJIT can perform optimizations that Visual C++ can’t. <b>For example, at run time, RyuJIT might be able to determine that the condition of an if statement is never true in this particular run of the application and, therefore, it can be optimized away.</b></blockquote><p>这说的主要是一种<a href="http://en.wikipedia.org/wiki/Profile-guided_optimization" data-title="PGO优化（profile-guided optimization）" class="" data-editable="true">PGO优化（profile-guided optimization）</a>的效果（注1）。虽然“理论上说”这是可能的，但CLR使用JIT编译器的方式使得RyuJIT实际上无法在JIT编译时做到这种优化。就像评论里<a href="http://www.zhihu.com/people/d073f194bcabc1cec5ef69d0b534de99" data-hash="d073f194bcabc1cec5ef69d0b534de99" class="member_mention" data-editable="true" data-title="@空明流转" data-tip="p$b$d073f194bcabc1cec5ef69d0b534de99">@空明流转</a>大大说的：</p><blockquote>我是觉得，“对JIT编译器抱有过高期望”一直都是非编译器行业的一种长期偏见。<br></blockquote><p>我完全同意。所以才要来解剖一下。</p>想起之前回答过的一个问题：<a href="http://www.zhihu.com/question/26913901/answer/35303563" data-editable="true" data-title="HotSpot是较新的Java虚拟机技术，用来代替JIT技术,那么HotSpot和JIT是共存的吗？ - RednaxelaFX 的回答" class="">HotSpot是较新的Java虚拟机技术，用来代替JIT技术,那么HotSpot和JIT是共存的吗？ - RednaxelaFX 的回答</a><p>本文想写的东西有一半在上面的链接里，请先读完它在继续向后阅读后文。重点是：</p><ul><li><b>动态编译（dynamic compilation）</b>指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫静态编译（static compilation）。<br></li><li><b>JIT编译（just-in-time compilation）</b>狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。JIT编译是动态编译的一种特例。</li><li>JIT编译一词后来被泛化，时常与动态编译等价；但要注意宽泛与狭义的JIT编译所指的区别。</li><li><b>自适应动态编译（adaptive dynamic compilation）</b>也是一种动态编译，但它通常执行的时机比JIT编译迟，先让程序“以某种形式”先运行起来，收集一些信息之后再做动态编译。这样的编译可以更加优化，可以很自然的融入PGO优化。这个“某种形式”可以称为“baseline execution“，可以由解释器或简单的JIT编译器承担。</li></ul><br><br><h2><b>CLR，JIT编译与PGO</b></h2><br><p>针对CLR / RyuJIT的场景稍微展开一下。</p><p>CLR的执行引擎的模型是“纯编译的单层JIT编译器“。所有被执行的有MSIL方法体的方法，要么被NGen事先编译成机器码了（PreJIT），要么在方法第一次被调用前进行JIT编译到机器码；总之就是MSIL要编译成机器码之后才被执行。</p><p>在正常执行时，每个有MSIL方法体的方法只有一次被编译的机会；一旦被编译过了就雷打不动了。对单次执行来说，CLR这种“单层JIT编译、只编译一次“的模型意味着代码被编译的时候还一次都没被执行过，也就无从借助运行时收集的profile信息来做有针对性的优化。</p><p>与之相对，自适应动态编译由于可以等程序执行了一段时间之后才做编译，所以有充分时间收集profile并利用profile来优化，经典例子就是收集分支跳转的次数，看taken分支还是not-taken分支的次数多。这样才可以做到本文开头引用的那段文字所描述的优化。</p><p>从.NET 4.5开始，CLR支持一个新功能叫做<a href="http://blogs.msdn.com/b/davbr/archive/2011/10/12/rejit-a-how-to-guide.aspx" data-editable="true" data-title="ReJIT">ReJIT</a>，用于支持managed profiler通过动态插桩（instrument）来收集性能数据（profile）。动态插桩意味着修改某个已有方法的MSIL方法体，所以在修改过后需要重新JIT编译才可以执行，因而得名ReJIT。注意ReJIT功能自身并不用于收集profile；收集profile的是CLR外部的managed profiler。所以收集到的profile也无法供给CLR的JIT编译器使用。</p><p>这与CLR正常执行时的模型其实仍然一致：每个MSIL方法体仍然只有一次被编译的机会；所谓“重新JIT编译“编译的是新的MSIL方法体。</p><p>.NET 4.5还引入了<a href="http://blogs.msdn.com/b/dotnet/archive/2012/10/18/an-easy-solution-for-improving-app-launch-performance.aspx" data-editable="true" data-title="“Multicore JIT”" class="">“Multicore JIT”</a>：在第一次运行程序时，用recording mode记录下哪些方法被JIT编译过，写入profile文件；以后执行可以用playback mode在后台线程先JIT编译这个列表里的方法，这样等到应用真的第一次调用某个方法时它可能已经被JIT编译好了。这是JIT编译的一种特殊做法，虽然没有脱离JIT编译的范畴但增加了一个自由度。<br></p><p>当前这个Multicore JIT的设计只针对程序启动速度优化，它只观察和记录JIT编译活动，生成的profile粒度太粗，仅是“被JIT编译过的方法的列表“，而不包含任何细粒度的profiling信息（例如说条件分支、虚方法的被调用对象的实际类型等）。所以仍然做不到本文开头所说的PGO优化。</p><p>但基于这个架构，后续开发完全可以添加更多功能，例如在recording mode中让JIT编译器生成收集profile的代码，收集细粒度profile（例如类型信息、分支跳转情况等），并将收集到的profile写入文件；后续执行就可以根据细粒度profile来做高度优化的编译。</p><p>其实.NET 4.5已经有了类似的PGO功能，但不用于JIT编译场景而用于NGen（AOT编译）场景。这就是<a href="https://msdn.microsoft.com/en-us/library/hh873180(v=vs.110).aspx" data-title="MPGO（managed profile-guided optimization）" class="" data-editable="true">MPGO（managed profile-guided optimization）</a>。当使用MPGO来NGen时，要分三步来生成最终的NGen二进制映像：</p><ol><li>使用MPGO，NGen生成带有收集profile功能的代码；</li><li>使用(1)生成的代码运行若干次该程序的“典型场景”，以便收集profile。这叫做training run；</li><li>结合(2)收集到的profile，再次运行MPGO来完成最终的NGen。</li></ol><p>这个过程跟一般的native PGO优化一样，都是要运行多次，依赖training run收集到的profile来引导后续运行的优化。在这种模式下运行的RyuJIT就可以做到类似本文开头所说的优化——但<a href="https://msdn.microsoft.com/en-us/library/e7k32f4k.aspx" data-editable="true" data-title="Visual C++的编译器同样支持PGO">Visual C++的编译器同样支持PGO</a>，同样可以做这种优化（而且可能做得更好）。相信未来的.NET Native在逐渐成熟起来之后也会考虑支持PGO。</p><p>自适应动态编译的思路就是把这种多次运行才能得到的好处压缩在一次运行中完成：执行引擎自动在开始的时候生成收集profile的代码，然后自动收集profile，最后自动利用profile来做优化编译。这样不但用起来方便，而且可以保证收集到的profile能够反映本次运行的特征。Native PGO的多次运行模型非常依赖于training run的代表性，如果其特征与后来实际运行的特征不匹配，那PGO“优化”反而会带来性能损失。</p><p>HotSpot VM是一个典型的自适应动态编译系统，使用解释器或Client Compiler（C1）来实现初始执行和profile的收集，然后把profile信息交给Server Compiler（C2）做优化编译。</p><p>对HotSpot VM的执行模型感兴趣的同学可以参考同事Doug Hawkins做的演讲来了解更多细节：<a href="https://vimeo.com/120533011" data-editable="true" data-title="JVM Mechanics by Douglas Hawkins as Presented at Silicon Valley Java User Group by Azul Systems on Vimeo" class="">JVM Mechanics by Douglas Hawkins as Presented at Silicon Valley Java User Group by Azul Systems on Vimeo</a></p><br><br><h2><b>传统PGO与自适应动态编译的结合</b></h2><br><p>有没有办法结合传统的PGO与自适应动态编译呢？<a href="http://www.azulsystems.com/" data-editable="true" data-title="Azul Systems">Azul Systems</a>的<a href="http://www.azulsystems.com/products/zing/whatisit" data-editable="true" data-title="Zing VM">Zing VM</a>所实现的<a href="http://www.azulsystems.com/solutions/zing/readynow" data-editable="true" data-title="ReadyNow!">ReadyNow!</a>功能是一个思路。</p><p>Zing VM基于HotSpot VM开发，与HotSpot VM的执行模式相似，都是解释器+C1+C2的多层混合模式执行引擎，使用了自适应动态编译。</p><p>能在程序运行一次的过程中就自动进行PGO当然是方便，但收集profile时总有额外开销，不一定适用于所有场景。特别是，收集profile通常发生在程序启动阶段，也就是说启动时会比较慢；如果特别在意程序启动的速度的话，这种做法就不合适了。</p><p>ReadyNow!的思路是让传统PGO与自适应动态编译结合起来：一个程序可以先跑些training run把细粒度profile信息记录下来，后续执行的时候可以跳过原本收集profile的阶段，直接利用之前记录的profile信息来做优化编译。这样就减少了程序启动时收集profile的开销，让程序快速达到稳定的高性能状态。</p><p>在Zing VM中，ReadyNow!不但能通过profile信息来指导优化，还可以指导<b>不做</b>某些过于激进的优化，减少因过度优化而导致的“去优化”（deoptimization）。这样也有利于程序快速达到稳定的性能水平，而不必在过度优化—去优化－再优化－再去优化－⋯的震荡多次后才达到稳定。</p><br><br>==========================================================<br><br><p>* 注1：也有一些场景RyuJIT确实可以做到文中所说优化，例如在JIT编译时把已经初始化好的readonly变量看作编译时常量来做常量传播和折叠的优化。用代码举例的话，可以是：</p><code lang="csharp">static class MyConfig {
  static readonly bool _debug = ConfigFile.GetProperty("debug");
  public static bool IsDebug { get { return _debug; } }
}

// ...
if (MyConfig.IsDebug) {
  Logger.log("...");
}</code><p>此例中 if (MyConfig.IsDebug) 可以先内联IsDebug属性得知它就是_debug，然后发现它是readonly静态变量，直接用它的值来做优化；假如其值是false，那代码就变成 if (false) ，整个if块就可以被优化消除掉了。</p><p>具体逻辑从CoreCLR源码可以看到，在<a href="https://github.com/dotnet/coreclr/blob/93e7d209dc19ddeff0f5ea5e3686b3ec0efef447/src/jit/importer.cpp#L11612" data-editable="true" data-title="Compiler::impImportBlockCode(BasicBlock * block)">Compiler::impImportBlockCode(BasicBlock * block)</a>：</p><code lang="cpp">            case CORINFO_FIELD_STATIC_ADDRESS:
                // Replace static read-only fields with constant if possible
                if ((aflags &amp; CORINFO_ACCESS_GET) &amp;&amp; 
                    (fieldInfo.fieldFlags &amp; CORINFO_FLG_FIELD_FINAL) &amp;&amp;
                    !(fieldInfo.fieldFlags &amp; CORINFO_FLG_FIELD_STATIC_IN_HEAP) &amp;&amp;
                    (varTypeIsIntegral(lclTyp) || varTypeIsFloating(lclTyp)))
                {     
                    CorInfoInitClassResult initClassResult = info.compCompHnd-&gt;initClass(resolvedToken.hField, info.compMethodHnd,
                        impTokenLookupContextHandle);

                    if (initClassResult &amp; CORINFO_INITCLASS_INITIALIZED)
                    {     
                        void **  pFldAddr = NULL; 
                        void * fldAddr = info.compCompHnd-&gt;getFieldAddress(resolvedToken.hField, (void**) &amp;pFldAddr);

                        // We should always be able to access this static's address directly
                        assert(pFldAddr == NULL);

                        op1 = impImportStaticReadOnlyField(fldAddr, lclTyp);
                        goto FIELD_DONE;
                    }     
                }
</code><p>不过这是比较特殊的场景，而PGO能覆盖的是更一般的场景。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
