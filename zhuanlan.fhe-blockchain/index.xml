<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>全同态加密与区块链</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/</link>
<description>区块链与密文计算让数据可以自由的分享 全同态加密具有神奇的功能，在不解密的情况下能够对密文进行任意计算。区块链能够在去中心化的环境下，保证数据的不可篡改、可追溯等。区块链+全同态加密=让我的数据属于我掌控。</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 19 Apr 2019 07:52:05 +0800</lastBuildDate>
<item>
<title>密码学入门与实践-2</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-04-18-62821125.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/62821125&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;公钥加密&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;安全密钥分发由公钥密码系统解决，因为它不需要您和室友之间进行安全的初始密钥协商。公钥密码系统也称为非对称密钥加密 - 与对称密钥相反 - 使用一对密钥（两个独立的密钥）：用于加密的公钥和用于解密的私钥（也称为秘钥）。由公钥无法推导出私钥。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ea2602ef50f275dd83df0193be05d34d_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;370&quot; data-rawheight=&quot;58&quot; class=&quot;content_image&quot; width=&quot;370&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ea2602ef50f275dd83df0193be05d34d_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;370&quot; data-rawheight=&quot;58&quot; class=&quot;content_image lazy&quot; width=&quot;370&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ea2602ef50f275dd83df0193be05d34d_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以将非对称密钥密码系统与电子邮件帐户进行类比。任何人可以访问您的电子邮件地址（例如，任何人都可以通过your@email.com向您发送电子邮件），但您是唯一拥有登录密码的人（这意味着只有您可以阅读电子邮件的内容）。公钥是您的电子邮件地址，私钥是与您的电子邮件地址登录的密码。&lt;br/&gt; &lt;br/&gt; &lt;/p&gt;&lt;p&gt;它是如何运作的：&lt;/p&gt;&lt;p&gt;第1步：创建一对私钥 - 公钥（稍后我们将讨论生成密钥对）。&lt;/p&gt;&lt;p&gt; 第2步：与朋友分享您的公钥。&lt;/p&gt;&lt;p&gt; 第3步：发件人使用您的公钥加密明文（原始邮件+加密=密文）。&lt;/p&gt;&lt;p&gt; 第4步：发件人向您发送密文。&lt;/p&gt;&lt;p&gt; 第5步：使用您的私钥解密密文（密文+解密=原始消息）。&lt;/p&gt;&lt;p&gt; 优点：增加了便利性和安全性。&lt;/p&gt;&lt;p&gt; 缺点：加密速度慢。所有公钥 - 私钥都容易受到暴力攻击（这可以通过选择加大密钥大小来避免）。您无法验证合作伙伴的身份（易受冒充）。&lt;/p&gt;&lt;p&gt;用法：由于增长密钥大小会产生过大的加密消息输出，因此加密和传输消息需要更长的时间。出于实践目的，公共密钥优先用于短消息加密，例如发送私钥或数字证书，而不是加密长消息。不方便的是，较短的密钥长度提供较低的安全性，但是在加密消息长度或传输时间方面，您是赢家。因此，密钥应经常更换。&lt;/p&gt;&lt;h2&gt;RSA&lt;/h2&gt;&lt;p&gt;RSA是以Rivest，Shamir和Adleman3人的首字母命名，是使用前一段中描述的Diffie-Hellman(密钥交换算法)方法，是公钥密码系统的下一步。该算法基于大整数难以分解的事实。&lt;/p&gt;&lt;p&gt; 我会在我假设你喜欢数学之前逐步解释RSA算法:)&lt;/p&gt;&lt;p&gt;首先你应该知道mod（模运算）和互质整数。&lt;/p&gt;&lt;p&gt; 欧拉定理(&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Euler%27s_theorem&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Euler’s theorem&lt;/a&gt;)：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-34e7c6253a5e114e298261bd1c0f0139_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;259&quot; data-rawheight=&quot;44&quot; class=&quot;content_image&quot; width=&quot;259&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-34e7c6253a5e114e298261bd1c0f0139_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;259&quot; data-rawheight=&quot;44&quot; class=&quot;content_image lazy&quot; width=&quot;259&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-34e7c6253a5e114e298261bd1c0f0139_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;其中phi（z）是欧拉函数( Euler&amp;#39;s totient function)，z是正整数。&lt;/p&gt;&lt;p&gt;简而言之，欧拉函数将与z互质的个数记为phi（z）。如果z是素数，那么phi（z）= z-1（*）。&lt;/p&gt;&lt;p&gt;例子:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1cc0d6f59d080455537fb68a08693943_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;381&quot; data-rawheight=&quot;303&quot; class=&quot;content_image&quot; width=&quot;381&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1cc0d6f59d080455537fb68a08693943_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;381&quot; data-rawheight=&quot;303&quot; class=&quot;content_image lazy&quot; width=&quot;381&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1cc0d6f59d080455537fb68a08693943_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;让我们继续欧拉定理:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-74267b9c730653bb3e811ef9a5b807fc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;132&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;580&quot; data-original=&quot;https://pic1.zhimg.com/v2-74267b9c730653bb3e811ef9a5b807fc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-74267b9c730653bb3e811ef9a5b807fc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;132&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;580&quot; data-original=&quot;https://pic1.zhimg.com/v2-74267b9c730653bb3e811ef9a5b807fc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-74267b9c730653bb3e811ef9a5b807fc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;使用数学归纳法我们可以证明：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dca3f3c1cbbd74ca594e54762e7b3d04_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;541&quot; data-rawheight=&quot;94&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;541&quot; data-original=&quot;https://pic1.zhimg.com/v2-dca3f3c1cbbd74ca594e54762e7b3d04_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dca3f3c1cbbd74ca594e54762e7b3d04_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;541&quot; data-rawheight=&quot;94&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;541&quot; data-original=&quot;https://pic1.zhimg.com/v2-dca3f3c1cbbd74ca594e54762e7b3d04_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dca3f3c1cbbd74ca594e54762e7b3d04_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这意味着数字x的指数幂为phi（z）+1时，结果是返回自身。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4b8f2b2d53bd79029404dcee343a4050_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;185&quot; data-rawheight=&quot;64&quot; class=&quot;content_image&quot; width=&quot;185&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4b8f2b2d53bd79029404dcee343a4050_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;185&quot; data-rawheight=&quot;64&quot; class=&quot;content_image lazy&quot; width=&quot;185&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4b8f2b2d53bd79029404dcee343a4050_b.png&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;从（*）方程和欧拉定理，我们得到&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-abed9e0a9179bebe05975b781448a79a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;314&quot; data-rawheight=&quot;81&quot; class=&quot;content_image&quot; width=&quot;314&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-abed9e0a9179bebe05975b781448a79a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;314&quot; data-rawheight=&quot;81&quot; class=&quot;content_image lazy&quot; width=&quot;314&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-abed9e0a9179bebe05975b781448a79a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;到目前为止，我们对RSA一无所知。现在是时候把所有这些方程联系起来了。&lt;/p&gt;&lt;p&gt;我们假设两个素数p，q。用p * q替换z。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-448a4ae9bd59223058f67708d9978c1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;108&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;624&quot; data-original=&quot;https://pic2.zhimg.com/v2-448a4ae9bd59223058f67708d9978c1d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-448a4ae9bd59223058f67708d9978c1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;108&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;624&quot; data-original=&quot;https://pic2.zhimg.com/v2-448a4ae9bd59223058f67708d9978c1d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-448a4ae9bd59223058f67708d9978c1d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;从等式（**）与K = 1和等式（***）我们得到：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a09a8d9a444b975bd04c5a7bbe6d9ed0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;375&quot; data-rawheight=&quot;67&quot; class=&quot;content_image&quot; width=&quot;375&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a09a8d9a444b975bd04c5a7bbe6d9ed0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;375&quot; data-rawheight=&quot;67&quot; class=&quot;content_image lazy&quot; width=&quot;375&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a09a8d9a444b975bd04c5a7bbe6d9ed0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这意味着只有当我们可以分解p * q数时，我们才能找到（p-1）*（q-1）+1。将x视为消息。我们可以选择一个随机素数E（加密密钥），它必须是（p-1）*（q-1）的互质。然后我们计算D（解密密钥）为：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-97d59f57ce7eaba69d101dcb33576894_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;287&quot; data-rawheight=&quot;38&quot; class=&quot;content_image&quot; width=&quot;287&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-97d59f57ce7eaba69d101dcb33576894_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;287&quot; data-rawheight=&quot;38&quot; class=&quot;content_image lazy&quot; width=&quot;287&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-97d59f57ce7eaba69d101dcb33576894_b.png&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;其中D是mod的逆。&lt;br/&gt;现在我们可以使用RSA算法，因为我们有公钥（E）和私钥（D）：&lt;/p&gt;&lt;p&gt;如果结果密文^ E &amp;lt;p * q，则存在针对RSA基于指数E和密文的短的弱点攻击。建议使用更长的密钥加密。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt; &lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-04-18-62821125</guid>
<pubDate>Thu, 18 Apr 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>密码学入门与实践-3</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-04-18-62818408.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/62818408&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;哈希函数&lt;/b&gt;&lt;/h2&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;到目前为止，很高兴我们可以保护“通过不受信任连接”交换的消息内容，但我们从未解决内容完整性问题。如何才能确定邮件内容（甚至是加密的）遭受未经授权的更改？&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt; 哈希函或者称之为“单向函数”或“不可逆函数”或“非双射函数”的函数，它输入可变长度的消息并产生固定长度(消息)的输出。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt; 例如，使用不同的哈希函数计算以下字符串的校验和：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9762c74f573a6a6914d16883f02b2d59_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;163&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;624&quot; data-original=&quot;https://pic2.zhimg.com/v2-9762c74f573a6a6914d16883f02b2d59_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9762c74f573a6a6914d16883f02b2d59_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;163&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;624&quot; data-original=&quot;https://pic2.zhimg.com/v2-9762c74f573a6a6914d16883f02b2d59_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9762c74f573a6a6914d16883f02b2d59_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果我们只修改原始消息中的单个字母怎么办？例如&amp;#39;E&amp;#39;：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d94bbbbd6062b3a7ced1eb52fe133cf6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;161&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;624&quot; data-original=&quot;https://pic3.zhimg.com/v2-d94bbbbd6062b3a7ced1eb52fe133cf6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d94bbbbd6062b3a7ced1eb52fe133cf6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;161&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;624&quot; data-original=&quot;https://pic3.zhimg.com/v2-d94bbbbd6062b3a7ced1eb52fe133cf6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d94bbbbd6062b3a7ced1eb52fe133cf6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;你可以看到，结果完全不同。哈希函数的一个大问题是容易发生碰撞：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-27429b916b6ca7ab47574b48e5b79eac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;443&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;624&quot; data-original=&quot;https://pic1.zhimg.com/v2-27429b916b6ca7ab47574b48e5b79eac_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-27429b916b6ca7ab47574b48e5b79eac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;443&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;624&quot; data-original=&quot;https://pic1.zhimg.com/v2-27429b916b6ca7ab47574b48e5b79eac_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-27429b916b6ca7ab47574b48e5b79eac_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;正如您可以看到两个具有不同内容的文件 - 在这种情况下只更改了6个字节 – 却具有相同的MD5校验和。我们称之为哈希碰撞。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;数字证书&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我们已经谈了很长时间关于加密和解密，尽管我们的密码系统足够安全，但我们却无法确定某人的真实身份。确实，Diffie-Hellman密钥交换算法没有解决“确定真实身份”的问题。信息安全是加密的基本目标，不仅包括机密性和数据完整性，还包括不可否认性或身份验证。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt; 在谈论证书之前，让我们看看数字签名是如何工作的。最后，我们将看到在身份验证和不可否认方面存在很大差异。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt; 在我们讨论非对称密钥和哈希函数时，我们将解释为什么他们对数字签名很重要。模拟数字签名是一种手写签名。虽然后者很容易伪造，但数字签名可以提供更多的安全性（几乎不可能伪造）。让我们看看它是如何工作的：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第1步&lt;/b&gt;：首先，你必须生成一对密钥：公钥和私钥。私钥将保存在安全的地方，公钥可以提供给任何人。假设您要撰写包含消息M的文档。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt; 第2步&lt;/b&gt;：计算摘要。&lt;/p&gt;&lt;p&gt; 您将使用哈希函数为您的消息计算摘要。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第3步&lt;/b&gt;：计算数字签名。&lt;/p&gt;&lt;p&gt; 您将使用密钥签署哈希结果（摘要）。现在，您可以将带有哈希结果签名的消息M发送给您的朋友。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt; 第4步&lt;/b&gt;：验证数字签名。&lt;/p&gt;&lt;p&gt; 您的朋友使用相同的哈希函数来计算消息M的摘要，并将结果与您的签名摘要进行比较。如果它们相同则意味着消息M没有被改变（这称为数据完整性）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;现在，您的朋友还需要来验证消息M确实来自于您。他将使用您的公钥来验证，该摘要是由您的私钥签名的。只有使用您私钥签名的消息，才能被您的公钥验证（这提供了身份验证和不可否认性）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt; 您可能想知道为什么我们首先需要通过哈希函数计算消息M的摘要（步骤2），而不是直接对消息进行签名。如果直接对消息签名，这肯定也是可行的，但原因是因为，使用私钥对消息进行签名并使用公钥验证它的真实性，(它的)速度是非常慢的。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;而且，它产生大量数据。哈希函数可生成固定长度的数据（所以可以缩短需要签名的数据），还可提供数据完整性。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt; 有一个问题：你的朋友怎么能确定你的公钥是哪个？他不能，但数字证书可以！&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt; 数字签名和数字证书之间的唯一区别是公钥由可信赖的国际认证机构（CA）认证。注册CA时，您必须提供真实的身份证明文件（身份证，护照等）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;因此，您的朋友可以使用您的公钥（registered to a CA）验证附加的哈希结果是否使用您的私钥签名。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-43823f241e4ba53e24e94b7aaf35663f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;624&quot; data-original=&quot;https://pic4.zhimg.com/v2-43823f241e4ba53e24e94b7aaf35663f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-43823f241e4ba53e24e94b7aaf35663f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;624&quot; data-original=&quot;https://pic4.zhimg.com/v2-43823f241e4ba53e24e94b7aaf35663f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-43823f241e4ba53e24e94b7aaf35663f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br/&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-04-18-62818408</guid>
<pubDate>Thu, 18 Apr 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>密码学入门与实践-1</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-04-11-62046303.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/62046303&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;术语：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;明文(plaintext or cleartext)&lt;/b&gt;：发送者想要传送给接收者的可理解消息&lt;/p&gt;&lt;p&gt;&lt;b&gt;密码(ciphertext):&lt;/b&gt; 使用密码系统的明文加密生成无法理解的消息&lt;/p&gt;&lt;p&gt;&lt;b&gt;加密(encryption):&lt;/b&gt; 将明文转换为密文的过程&lt;/p&gt;&lt;p&gt;&lt;b&gt;解密(decryption):&lt;/b&gt; 将密文转换为明文的过程（加密反向）&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;传统密码学：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;它也称为对称密钥或共享密钥加密。同一个密钥用于加密和解密消息。将下面这个例子视为传统加密：&lt;/p&gt;&lt;p&gt;你和你的室友都使用相同的钥匙来锁定/解锁你家的门。因此，您共享相同的密钥以保护房间。确实，你的室友可以有你的钥匙副本，这样他就可以在你工作时进入房间，反之亦然。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;使用对称密钥的传统密码系统算法：数据加密标准（DES），高级加密标准（AES）&lt;/p&gt;&lt;p&gt;优点：快速。&lt;/p&gt;&lt;p&gt;缺点：不安全！&lt;br/&gt;发送方和接收方必须就密钥达成一致，并阻止其他人访问密钥。(这样做)有一个大的问题，如果两者不在同一物理位置，该如何发布密钥。你在中国的时候怎么能把你的钥匙给你在美国的室友呢！&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;实用建议：对每条消息加密后都要更改对称密钥，以便在发生灾难时（密码分析，窃取等）只能泄漏一条消息。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;密钥分发&lt;/p&gt;&lt;p&gt;在上一段中，我们讨论的了密码系统使用对称密钥，以及缺乏与室友安全共享密钥的有效方式。密钥分发有助于解决这个缺点。接下来，我们将解释如何通过不受信任的通信通道进行密钥交换。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Diffie-Hellman key exchange (Diffie-Hellman密钥交换)&lt;/p&gt;&lt;p&gt;这种密钥交换基于一种算法，该算法在数学上不能在合理的时间内轻松地计算大数的离散对数。在使用数字和抽象公式直接运行之前，我们将使用颜色概述算法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-844eab87a51441a9efeed6609978a579_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;441&quot; data-rawheight=&quot;660&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;441&quot; data-original=&quot;https://pic2.zhimg.com/v2-844eab87a51441a9efeed6609978a579_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-844eab87a51441a9efeed6609978a579_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;441&quot; data-rawheight=&quot;660&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;441&quot; data-original=&quot;https://pic2.zhimg.com/v2-844eab87a51441a9efeed6609978a579_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-844eab87a51441a9efeed6609978a579_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;11. 第1步：Alice和Bob达成了共同颜色的协议。&lt;/p&gt;&lt;p&gt;2. 第2步：Alice选择她不会告诉Bob的秘密颜色。鲍勃会做同样的事情。&lt;/p&gt;&lt;p&gt;3. 步骤3：Alice将共同颜色与秘密颜色混合，结果是混合物。Bob也将他的秘密颜色与普通颜色混合，并将会得到不同于alice的混合物。&lt;/p&gt;&lt;p&gt;4. 步骤4：Alice和Bob交换混合物。这是沟通中最关键的一步，因为”中间人攻击(man-in-the-middle)”可以访问这两种混合物。如果中间人有双方的混合物，这也将会是一个问题。颜色分解是不可逆的。因此，找到两个秘密颜色的唯一机会是将所有可能的颜色与第一步中的常见颜色混合。此外，请记住，秘密颜色也可以是许多其他颜色的混合。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;更新：Diffie-Hellman不会保护您免受中间人攻击。为了了解原因，想象一下攻击者从Alice接收所有消息并将其重播回Bob。&lt;/p&gt;&lt;p&gt;5. 步骤5：Alice将再次将她的秘密颜色添加到Bob发送给她的混合物中。鲍勃将遵循相同的步骤。&lt;/p&gt;&lt;p&gt;最后Alice和Bob将获得一个共同的秘密颜色。现在，Alice和Bob可以安全地交换我们在前一章中讨论的对称密钥，因为他们可以使用上述秘密颜色加密和解密任何消息（通过通信信道发送）。&lt;/p&gt;&lt;p&gt; 数学来了，当我们没有足够的颜色时，总是关于数学。&lt;/p&gt;&lt;p&gt; 步骤1：Alice和Bob达成了两个大数的协议：一个素数p（推荐至少512位）和一个基数g（p的原始根模量）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-874c2a6afa8ca1bbcec218959d4bbd38_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;234&quot; data-rawheight=&quot;114&quot; class=&quot;content_image&quot; width=&quot;234&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-874c2a6afa8ca1bbcec218959d4bbd38_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;234&quot; data-rawheight=&quot;114&quot; class=&quot;content_image lazy&quot; width=&quot;234&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-874c2a6afa8ca1bbcec218959d4bbd38_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;步骤 2:Alice选择一个秘密的整数 a  。 Bob 选择一个秘密整数 b。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-10e14fbbcaaa7afc388b24e0d402082f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;252&quot; data-rawheight=&quot;120&quot; class=&quot;content_image&quot; width=&quot;252&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-10e14fbbcaaa7afc388b24e0d402082f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;252&quot; data-rawheight=&quot;120&quot; class=&quot;content_image lazy&quot; width=&quot;252&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-10e14fbbcaaa7afc388b24e0d402082f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;步骤3：Alice计算公共值x = g ^ a mod p。 Bob计算公共值y = g ^ b mod p，其中mod是模运算符。&lt;/p&gt;&lt;p&gt;步骤4：Alice和Bob交换x和y。&lt;/p&gt;&lt;p&gt;步骤5：Alice计算她的秘密密钥k_a = y ^ a mod p。Bob计算他的秘密密钥k_b = x ^ b mod p。在数学上可以证明k_a = k_b。 Alice和Bob现在有一个共同的密钥，用于加密和解密他们想要安全交换的明文&lt;/p&gt;&lt;p&gt;例子:&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-56dfb00cc653ecc5661765616bd69ac6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;719&quot; data-rawheight=&quot;377&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;719&quot; data-original=&quot;https://pic3.zhimg.com/v2-56dfb00cc653ecc5661765616bd69ac6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-56dfb00cc653ecc5661765616bd69ac6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;719&quot; data-rawheight=&quot;377&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;719&quot; data-original=&quot;https://pic3.zhimg.com/v2-56dfb00cc653ecc5661765616bd69ac6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-56dfb00cc653ecc5661765616bd69ac6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果中间人知道秘密整数a = 6和b = 15，他可以找到用于通信的秘密密钥。方法如下：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2b8efb059146927dbb073697bc4fb09f_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;688&quot; data-rawheight=&quot;96&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;688&quot; data-original=&quot;https://pic4.zhimg.com/v2-2b8efb059146927dbb073697bc4fb09f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2b8efb059146927dbb073697bc4fb09f_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;688&quot; data-rawheight=&quot;96&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;688&quot; data-original=&quot;https://pic4.zhimg.com/v2-2b8efb059146927dbb073697bc4fb09f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2b8efb059146927dbb073697bc4fb09f_b.png&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;优点：安全。避免中间人攻击。&lt;/p&gt;&lt;p&gt;缺点：您无法确定真正的&amp;#39;Bob&amp;#39;的实际身份。(无法确定’Bob’的真实身份)&lt;/p&gt;&lt;p&gt;也可以使用XOR（异或）运算符来解释Diffie-Hellman:&lt;/p&gt;&lt;p&gt;假设Alice想要将消息 ’M = Hello‘ 发送给Bob。消息M的二进制表示是B（M）= 0100100001100101011011000110110001101111。Alice用秘钥K = 1010101000101110100101010001110010101010加密消息。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e21b40c159473fd44e4a2d4876908b80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;728&quot; data-rawheight=&quot;219&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;728&quot; data-original=&quot;https://pic1.zhimg.com/v2-e21b40c159473fd44e4a2d4876908b80_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e21b40c159473fd44e4a2d4876908b80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;728&quot; data-rawheight=&quot;219&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;728&quot; data-original=&quot;https://pic1.zhimg.com/v2-e21b40c159473fd44e4a2d4876908b80_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e21b40c159473fd44e4a2d4876908b80_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;加密消息L的明文的等效消息是&amp;amp;#226;K&amp;amp;#249;p&amp;amp;#197; 。Bob收到&amp;amp;#226;K&amp;amp;#249;p&amp;amp;#197;，并使用已经与Alice交换的相同的密钥K来解密消息。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bd2f1feddfb974c8fa6a7023cdd630a7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;216&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;732&quot; data-original=&quot;https://pic4.zhimg.com/v2-bd2f1feddfb974c8fa6a7023cdd630a7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bd2f1feddfb974c8fa6a7023cdd630a7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;216&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;732&quot; data-original=&quot;https://pic4.zhimg.com/v2-bd2f1feddfb974c8fa6a7023cdd630a7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bd2f1feddfb974c8fa6a7023cdd630a7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;为什么这个算法很重要？因为像SSL，TLS，SSH，IPSec ,  PKI的协议，都使用Diffie-Hellman。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br/&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-04-11-62046303</guid>
<pubDate>Thu, 11 Apr 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-8</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-31-60936290.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60936290&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;———————————这是一条美丽的分割线————————————&lt;/p&gt;&lt;h2&gt;7.实现步骤&lt;/h2&gt;&lt;p&gt;功能函数f里其实有两样基本东西就够了：AND增强型电路，XOR增强型电路，经过集成电路化后如下现状：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b7434ee3afafc2ecc061e9b16cf775a6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;360&quot; data-rawheight=&quot;180&quot; class=&quot;content_image&quot; width=&quot;360&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b7434ee3afafc2ecc061e9b16cf775a6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;360&quot; data-rawheight=&quot;180&quot; class=&quot;content_image lazy&quot; width=&quot;360&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b7434ee3afafc2ecc061e9b16cf775a6_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;任意功能函数例如f1，都可以应用如上两个增强电路组合来表示，例如：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-db2c5b268bee81ad87b8e09322a56d82_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;383&quot; data-rawheight=&quot;386&quot; class=&quot;content_image&quot; width=&quot;383&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-db2c5b268bee81ad87b8e09322a56d82_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;383&quot; data-rawheight=&quot;386&quot; class=&quot;content_image lazy&quot; width=&quot;383&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-db2c5b268bee81ad87b8e09322a56d82_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;所以每次计算的基本步骤如下：&lt;/p&gt;&lt;p&gt;1) 对输入的明文m进行加密Enc(m),得到密文（c,z）,c是密文，z是向量&amp;lt;z1,z2,……&amp;gt;也称为扩展密文。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2) 对输入的密文进行重加密。输入的密文为（c,z）。在对密文运算之前每次都要对其重加密。因为明文空间是{0,1}，所以加密一定是对密文按位来加密。重加密的过程就是解密的过程，但是对象是对加密的密文以及加密的私钥进行。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以有：c’=Enc(Lsb(c))，得到的c’是一个整数。原本对z的每一位也要进行加密的，但是有一个方法可以提高效率，就是对z不加密，认为z的每一位自己就是自己的加密。另外私钥是s=&amp;lt;s1,s2,……&amp;gt;是0和1的向量，对私钥的每一位的加密记为sk’=&amp;lt;Enc(s1),Enc(s2),……&amp;gt;=&amp;lt;s1’，s2’,……&amp;gt;，得到的si’也是整数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然后运行∑si·zi，运行它的算法如前面所说，把每一个zi的二进制表示写成矩阵的一行，这样就得到一个矩阵：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-30487a2474c7a357fad8d40c6dab0f37_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;369&quot; data-rawheight=&quot;147&quot; class=&quot;content_image&quot; width=&quot;369&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-30487a2474c7a357fad8d40c6dab0f37_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;369&quot; data-rawheight=&quot;147&quot; class=&quot;content_image lazy&quot; width=&quot;369&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-30487a2474c7a357fad8d40c6dab0f37_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;然后用si’乘以上面矩阵第i行的每一位，得到一个整数矩阵(矩阵中每一个元素都是整数):&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9bc5faae8e158a312caf7e0fa53ec3b8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;420&quot; data-rawheight=&quot;358&quot; class=&quot;content_image&quot; width=&quot;420&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9bc5faae8e158a312caf7e0fa53ec3b8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;420&quot; data-rawheight=&quot;358&quot; class=&quot;content_image lazy&quot; width=&quot;420&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9bc5faae8e158a312caf7e0fa53ec3b8_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;​然后对最后一列（最低位）求海明码，根据前面所述定理，海明码的最低位是e20 （b1,-n, b2,-n ……，bt,-n），其余各位e21 （b1,-(n-1), b2,-(n-1) ……，bt,-(n-1)），……，都作为进位进到前面相应的位。依次计算下去，第1列的结果是b-1 = e20 （b1,-1, b2,-1 ……，bt,-1，……），第0列的结果是b0 = e20 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b8b5fbea7c8cc2e9f765e9cc10936605_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;517&quot; data-rawheight=&quot;252&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;517&quot; data-original=&quot;https://pic2.zhimg.com/v2-b8b5fbea7c8cc2e9f765e9cc10936605_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b8b5fbea7c8cc2e9f765e9cc10936605_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;517&quot; data-rawheight=&quot;252&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;517&quot; data-original=&quot;https://pic2.zhimg.com/v2-b8b5fbea7c8cc2e9f765e9cc10936605_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b8b5fbea7c8cc2e9f765e9cc10936605_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;3) 计算b= (b0 + b-1 ) ，b就是对应的Lsb(「∑si* zi 」)密文运算的结果。&lt;/p&gt;&lt;p&gt;4) 根据上面已经得到的c’=Enc(Lsb(c))，最终对密文c的重加密结果为：&lt;/p&gt;&lt;p&gt;c* = c’+ b&lt;/p&gt;&lt;p&gt;       知道此c*和c有什么关系么？c*是c的“重生”，噪音比原来降低了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;5) 然后将c*输入门电路。门电路一般都是二元的，需要两个输入，另外一个输入也用同样的方法计算得到&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;6) 进行门电路运算，例如加或乘，输出得到的结果。接下来有两种情况：第一种：此结果为最终结果，那么再进行重加密一次后，将密文返还给用户，用户解密后得到正确的运算结果。第二种：此结果不是最终结果，那么继续输入到下一级电路，依然是要先进行重加密。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;全文结束&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-31-60936290</guid>
<pubDate>Sun, 31 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-7</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-28-60636329.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60636329&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;———————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;h2&gt;&lt;b&gt;6、&lt;/b&gt; &lt;b&gt;压缩解密电路&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如何把电路变浅呢？一个直观的方法就是替别人承担一些工作，这样原来的任务量就变小了。&lt;/p&gt;&lt;p&gt;还是先来仔细打量一下问题出在的地方：&lt;/p&gt;&lt;h3&gt;&lt;i&gt;c× p-1&lt;/i&gt;&lt;/h3&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这是一个乘积，要想把它变成一个较浅的运算电路，应该如何做呢？最直观的方法就是：把乘积变成和，也就是说把c·p-1 →∑zi。c是密文，我们不可能拿它开刀，唯一可以做处理的地方就是p-1，也就是说应该把p-1 转换成一个和的形式即： p-1 →∑yi，&lt;/p&gt;&lt;p&gt;要知道p是私钥是不能公开的，所以可以把p隐藏在∑yi中，同时这种隐藏要不会泄露p才可行，所以要有一个陷门才可以，这个陷门就是Sparse Subset Sum Prob (SSSP)，就是给一串整数x1,x2,……，xn，存在一个{1,……，n}的子集S，使得∑si * xi=0 (其中i∈S)，让你求这个S是不可行的。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这个问题据说是困难的，好像没有被well studied。有了这个陷门就可以构造出：&lt;/p&gt;&lt;p&gt;取y1,y2,…,yn ∈[0, 2)，存在一个稀疏子集S，使得∑si · yi ≈ 1/p mod 2 (i∈S) (因为是实数所以用近似等于1/p表示，是存在一个误差的，这个误差不影响取整后的结果) 。&lt;/p&gt;&lt;p&gt;令 zi←c· yi  mod 2，zi保留一定的精确度，从而有：∑si · zi ≈ c/p  mod 2。所以解密电路中的「c/p」可以替换成「∑si * zi 」。解密电路变成：&lt;/p&gt;&lt;p&gt;    Lsb(c) XOR Lsb(「∑si·zi 」)。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这个变换后的方案，公钥除了原来的公钥pk之外还多加了一个向量{yi}。密文除了原来的c之外多出了一个向量{zi}。&lt;/p&gt;&lt;p&gt;这个多出来的zi可以看做是提前拿出来计算以减轻解密电路负担的，这个方法叫预处理（post-process）。私钥由原来的sk变成了{si}。可以看到公钥变大，密文也变大，这个代价就是为了换得更浅的电路。那么电路变浅了吗？下面来分析一下：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;主要分析一下∑si·zi的多项式次数，然后和我们前面分析的f所能执行的最大次数比较就OK。&lt;/p&gt;&lt;p&gt;假设zi的精确度为n位（我们考虑的都是二进制表示），整数位只考虑最低位，因为Lsb(「∑si·zi 」)是对和先取整，然后再取最低有效位。如下所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;566&quot; data-rawheight=&quot;182&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;566&quot; data-original=&quot;https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;566&quot; data-rawheight=&quot;182&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;566&quot; data-original=&quot;https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果上述t个数应用“3-for-2 trick”相加，电路深度也不会满足要求。所以得另寻它法。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;有个概念说一下：HammingWeight，海明重量通俗的说就是向量中“1”的个数，由于我们是二进制相加，所以上面每一列相加的结果可以看成是该列的海明重量。那么海明重量怎么求呢？有一个定理非常有用，就是：&lt;/p&gt;&lt;p&gt;对于任意一个二进制向量&amp;lt;a1,a2,……，at&amp;gt;，其海明重量为W，并且其二进制表示为：wn,……w1w0的话，则wi可以表示为关于变元a1,a2,……，at的一个次数是2i多项式。这个多项式很好求，就是对称多项式e2i （a1,a2,……，at），有现成的算法。&lt;/p&gt;&lt;p&gt;好了我们可以对上面的那些列运用此定理。对最低列求海明重量，则海明重量的最低位是e20 （a1,-n, a2,-n ……，at,-n）mod 2，它就是该列的和，这个海明重量的倒数第二位是e21 （a1,-n, a2,-n ……，at,-n）mod 2，就进位到倒数第二列记为Cn,-(n-1)，如此下去;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;233&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;584&quot; data-original=&quot;https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;233&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;584&quot; data-original=&quot;https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后得到：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;424&quot; data-rawheight=&quot;292&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;424&quot; data-original=&quot;https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;424&quot; data-rawheight=&quot;292&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;424&quot; data-original=&quot;https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;则有：&lt;/p&gt;&lt;p&gt;b=「∑si * zi 」= (b0 + b-1 ) mod 2  (因为是取整，所以只关心第0列，取整是要取最近的整数，所以和b-1有关，如果b-1是1则要进上去)&lt;/p&gt;&lt;p&gt;别忘了我们现在的任务：是要计算「∑si * zi 」的电路关于ai,j的多项式次数。开始时可以看成都是一次的：&lt;/p&gt;&lt;p&gt;然后计算完最后一列，有了向前面各列的进位后,变成如下形式：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fefbeb046daabb532a0bfa10491439e9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;147&quot; class=&quot;content_image&quot; width=&quot;346&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fefbeb046daabb532a0bfa10491439e9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;147&quot; class=&quot;content_image lazy&quot; width=&quot;346&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-fefbeb046daabb532a0bfa10491439e9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-02bf69beea057d9bee7406e47871d8ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;327&quot; data-rawheight=&quot;158&quot; class=&quot;content_image&quot; width=&quot;327&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-02bf69beea057d9bee7406e47871d8ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;327&quot; data-rawheight=&quot;158&quot; class=&quot;content_image lazy&quot; width=&quot;327&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-02bf69beea057d9bee7406e47871d8ad_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;每一列关于ai,j的次数都变了，例如倒数第二列次数为4了，依次下去：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-219e11641174db236776d8a2dba6600d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;348&quot; data-rawheight=&quot;177&quot; class=&quot;content_image&quot; width=&quot;348&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-219e11641174db236776d8a2dba6600d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;348&quot; data-rawheight=&quot;177&quot; class=&quot;content_image lazy&quot; width=&quot;348&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-219e11641174db236776d8a2dba6600d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;每一列关于ai,j的次数都变了，例如倒数第二列次数为4了，依次下去：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;422&quot; data-rawheight=&quot;314&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;422&quot; data-original=&quot;https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;422&quot; data-rawheight=&quot;314&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;422&quot; data-original=&quot;https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;因为最后的结果是(b0 + b-1 ) mod 2，所以我们只关心前面两列的次数（即第0列和第一列）。由于每列计算的结果都是e20(……)，它是关于输入项的一个次数为1次的对称多项式。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;对于第0列，由于其最高次数为2n ，所以其结果e20(……)的最高次数为2n。对于第1列，由于其最高次数为2n-1 ，所以其结果e20(……)的最高次数为2n-1。所以，计算「∑si * zi 」的电路关于ai,j的多项式次数为2n（别忘了n是zi的精确度）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;回忆一下我们原来说的f所能计算的最高多项式次数为：log p / log Bn （注意2n中的n和此式的n不是一个n）。如何比较呢，得把参数确定一下，按照DGHV方案中的参数，λ为安全参数，取||p|| ～λ2, ||r||～λ，所以p～2λ2，B～2λ，则log p / log Bn～λ。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;要想让Evaluate能够运行「∑si * zi 」电路，zi的精确度要取logλ才可以。现在你知道DGHV论文中zi精确度为什么要取那个数了吧。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;到此为止我们知道了解密电路经过压缩，可以被Evaluate正确运算了，从而解密电路堂而皇之的进入permitted functions集合里了，所以该方案可以对密文做任意功能的运算了，知道这意味着什么吧，全同态实现了。七拐八歪的才修成正果，确实不容易。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;接下来我们总结一下实现步骤，其实上面已经有了。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br/&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-28-60636329</guid>
<pubDate>Thu, 28 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-6</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-26-60399503.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60399503&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;———————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;5、 解密电路的深度&lt;/h3&gt;&lt;p&gt;上面有一个人说对了一半，其实我们可以把解密电路用AND电路和XOR电路表示出来，计算一下电路的深度（电路的深度是运算次数的对数，例如深度是d，计算次数就是log d），然后再和permitted functions中功能电路所允许的最大深度做个比较，就知道解密电路是否属于permitted functions集合了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先来分析permitted functions集合所允许的电路深度。由于permitted functions集合里的任一功能函数f 都可以用AND电路和XOR电路表出，而AND电路和XOR电路可以看做对输入的二进制位做乘法和加法，所以f电路的深度可以用输入位的对称多项式来衡量（用多项式衡量是因为多项式里恰好是变元的乘法和加法），&lt;b&gt;又由于乘法是噪音的主要来源，所以可以用多项式中乘法次数来做电路深度的主要衡量指标&lt;/b&gt;。有：&lt;/p&gt;&lt;p&gt;c* = f ( c1, c2, …，cn ) = f ( m1+2r1+pq, m2+2r2+pq, …，mn+2rn+pq ) &lt;/p&gt;&lt;p&gt; = f ( m1+2r1, m2+2r2, …，mn+2rn ) +p(……)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;密文c*的噪音为：c* mod p = f ( m1+2r1, m2+2r2, …，mn+2rn ), 要想c*解密正确必须有：f ( m1+2r1, m2+2r2, …，mn+2rn )&amp;lt; p/2, 其中mi+2ri 是密文ci的噪音。不妨令mi+2ri = xi, 且xi &amp;lt; B, B是密文ci噪音的上界，则有：&lt;/p&gt;&lt;p&gt;f ( x1, x2, …，xn ) &amp;lt; p/2。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们的目标是衡量f 的运算次数d，所以可以用初等对称多项式来表达f ，有：&lt;/p&gt;&lt;p&gt;f ( x1, x2, …，xn ) = x1x2…xd + x1x3…xd + ……；其中d&amp;lt;=n&lt;/p&gt;&lt;p&gt;f ( x1, x2, …，xn )的每一项就是从n个变元( x1, x2, …，xn )里选取d个变元，因此有C（n, d）个项（C表示组合运算），由C（n, d）&amp;lt; nd 得：&lt;/p&gt;&lt;p&gt;f ( x1, x2, …，xn ) &amp;lt; Bd nd &amp;lt; p/2 =&amp;gt; d &amp;lt; log p / log Bn , 也就是说f 最多运算次数为 log p / log Bn 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下面再看看解密电路的运算次数：&lt;/p&gt;&lt;p&gt;Dec(c): (c mod p) mod 2=（c – p·「c/p」）mod 2 = Lsb(c) XOR Lsb(「c/p」)&lt;/p&gt;&lt;p&gt;仔细端详解密电路的公式，发觉其复杂性主要来源是c/p，所以我们主要看c/p所需的运算次数。c/p=c·p-1 , p-1是小数，为了保证c· p-1取整之后的的精确度，p-1要取log c 位的。例如 12345678× 0.111111 和 12345678× 0.11111111的结果取整后是不一样的。那么两个数相乘的次数如何衡量呢？有如下结论:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 乘两个t位数相当于加t个数: &lt;b&gt;输出位是关于输入位的一个2次多项式&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5216ef706b4ae4ce77b6146acfd1e8f8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;416&quot; data-rawheight=&quot;204&quot; class=&quot;content_image&quot; width=&quot;416&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5216ef706b4ae4ce77b6146acfd1e8f8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;416&quot; data-rawheight=&quot;204&quot; class=&quot;content_image lazy&quot; width=&quot;416&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5216ef706b4ae4ce77b6146acfd1e8f8_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;加t个数可以应用“3-for-2 trick” : 3个数相加得到两个数相加，输出位是关于输入位的一个次数最多为2次的多项式&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;730&quot; data-rawheight=&quot;210&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;730&quot; data-original=&quot;https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;730&quot; data-rawheight=&quot;210&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;730&quot; data-original=&quot;https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;其中a1b1+a1c1+b1c1是进位，注意它从形式上还是一个对称多项式。&lt;/p&gt;&lt;p&gt;那么t个数应用这个技巧经过log3/2 t 次相加后得到两个数，输出位的次数为2log3/2 t = tlog3/2 2= t1.71。&lt;/p&gt;&lt;p&gt;再看两个t位数相加：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;689&quot; data-rawheight=&quot;190&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;689&quot; data-original=&quot;https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;689&quot; data-rawheight=&quot;190&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;689&quot; data-original=&quot;https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;因此输出位的次数最多为t次，因为上面3位数相加次数最多为3次。&lt;/p&gt;&lt;p&gt;结合起来有：乘两个t位数的次数最多为2t1.71t=2t2.71，而c· p-1里c的位数为log c，p-1要取log c 位的，又因为log c &amp;gt; log p (因为 p&amp;lt;c)，所以c· p-1的次数至少是2(log p)2.71 , 而前面说过f最多运算次数为 log p / log Bn。&lt;/p&gt;&lt;p&gt;所以解密电路的深度要大于Evaluate所允许运行功能电路的深度，因此如果Evaluate运行解密电路的话，将会产生不正确的结果，我们就说Evaluate无法运行解密电路，换句话说解密电路不在permitted functions 集合里。&lt;/p&gt;&lt;p&gt;结论应该知道了吧，是一个坏消息。解密电路不在permitted functions 集合里，其后果就是：无法对密文进行任意功能的运算！与全同态失之交臂。&lt;/p&gt;&lt;p&gt;怎么办呢？古人云：兵来将挡，水来土掩。解密电路深了，把它变浅不就完了。说容易做起来有点难。我觉得有技巧的地方就在于压缩解密电路。&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-26-60399503</guid>
<pubDate>Tue, 26 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-5</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-25-60281238.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60281238&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;———————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4、&lt;/b&gt; &lt;b&gt;电路复杂度&lt;/b&gt;&lt;/p&gt;&lt;p&gt;前面的方案中大家看到了是按“位”来加密的（即m∈ {0,1}），加密后得到的是一个整数，密文膨胀的很厉害，那么为什么明文不取整数来加密呢？例如取明文m∈Z。我想原因是这样的：每个研究全同态的人们都想过了，但是没有找到一个方案可以把明文按照整数来加密。并不是说没有这种方案，估计只是现在还没有找到。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;又有人会问：为什么全同态方案要用电路来描述呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先我们来说说什么叫一个方案是全同态的？如果一个方案能够对密文做任意功能的运算，而且运算结果所得密文是紧凑的，同时Evaluate算法（即运算）是有效地，那么我们就称该方案是全同态的。可以用下式说明：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-68edb3f833edf3bd26d2262eeaab77d7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;722&quot; data-rawheight=&quot;175&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;722&quot; data-original=&quot;https://pic4.zhimg.com/v2-68edb3f833edf3bd26d2262eeaab77d7_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-68edb3f833edf3bd26d2262eeaab77d7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;722&quot; data-rawheight=&quot;175&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;722&quot; data-original=&quot;https://pic4.zhimg.com/v2-68edb3f833edf3bd26d2262eeaab77d7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-68edb3f833edf3bd26d2262eeaab77d7_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;上式太重要了，我觉得只要把上面的式子牢记在心，那么全同态的概念就装在心里了。“紧凑的”在这里就不说了，论文里有解释，而且也很好理解。正确性当然是必须的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么如何衡量Evaluate的有效性呢？最直观的方法可以通过复杂度来衡量。显然Evaluate的复杂度依赖于所运算的函数f。那么f的复杂度如何衡量呢？当然最直接的方法是通过在图灵机上运算f的时间来衡量。但是函数f又是什么呢？我想应该是五花八门的功能函数，如果想用功能去描述它恐怕是一言难尽，但是如果用布尔电路的大小（the size of boolean circuit,即门电路的数量）来衡量，那么f就能够被拆解成一些简单的布尔电路：例如“与”电路、“或”电路、“非”电路。而这些电路是可以组合成任意电路的，也就是说可以表示任意功能的电路。&lt;/p&gt;&lt;p&gt;同样我们也可以选择用AND电路和XOR电路，因为这两个电路是具有完备性质的，也就是说这两个电路的组合也可以表出任意功能的电路（而且用这两个电路来描述更加直观，它们直接对应的算术运算就是乘法和加法）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;显然AND电路和XOR电路是属于permitted functions集合里的（为什么？因为AND电路是对应的是两个二进制位相乘，XOR对应的是两个二进制位相加，上述同态方案肯定能够正确执行这两个运算，因为就是一次乘法或者一次加法，既然能够正确执行，所以它们就属于permitted functions集合）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;又由于AND电路和XOR电路是完备的，所以任意功能都可以用这两个电路组合表出，也就是说该同态方案可以对密文做任意功能的运算，这不就是传说中的全同态定义么！任意功能的问题解决了，但是还缺一点：必须是正确的才行。你对密文一阵蹂躏后，如果结果解密后不是同样对明文蹂躏的结果，你有什么感觉？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么上述同态方案能够保证计算的正确性么？上面我们已经看到由于噪音的存在，该方案只能做有限次的运算，也就是说只能够对permitted functions集合里的功能函数保证是正确的，在此之外保证不了，现在你知道permitted functions集合里有什么东西了吧。那如何能够保证对密文做任意功能的运算还是正确的呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前面说过可以通过重加密技术降低噪音呀！具体如何做呢？很简单：给AND电路上接一个解密电路，给XOR电路上也接一个解密电路，任何密文在进入AND电路或XOR电路之前，先让它进入解密电路进行重加密，之后从解密电路里出来的密文就是一个类似于新鲜密文的密文，噪音比进来前降低了，然后再让这个新的密文进入AND电路或XOR电路，这样我们就可以对密文正确的做任意功能的计算了！而接了解密电路的AND电路或XOR电路就称为增强电路。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;总结一下：任意函数功能拿来，先用增强型AND电路和增强型XOR电路表示出来，这样就可以对密文做任意功能的计算了，由于是增强型的，我们不再害怕噪音的阻碍，可以无限运算下去。OK，全同态的蓝图终于在纸上实现了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是还有一个问题（问题真多，难怪人说科学是由问题产生的，现在我才理解），解密电路是属于permitted functions集合里的么？可能有人会说，方案中不是有解密电路么，Evaluate应该可以运行它吧。另外还有人说，按照上面方法把解密电路表示成增强电路不就行了。别忘了，增强型电路是含有解密电路的，所以这样说等于由果来推因了。AND电路、XOR电路、解密电路都可看成是“原电路”（这个名字是我自己取的），就是说它们是构成任意功能函数的基石，permitted functions集合里含有它们就完全够了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前面我们已经解释了AND电路和XOR电路属于permitted functions集合的原因。唯一缺的就是没有证实解密电路也在permitted functions集合里。下面就来分析分析解密电路。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-25-60281238</guid>
<pubDate>Mon, 25 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-4</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-24-60209894.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60209894&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;——————————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;h2&gt;3 Bootstapping：一个生硬的思路&lt;/h2&gt;&lt;p&gt;然而降低噪音并不是最终目的，降低噪音是为了能够进行下一次运算，所以解密电路加上一个门电路（这个门电路可以是加法门电路或者乘法门电路等等基本电路）称之为“增强电路”。如图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4e018dcaffc557027b54647149662768_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;304&quot; data-rawheight=&quot;337&quot; class=&quot;content_image&quot; width=&quot;304&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4e018dcaffc557027b54647149662768_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;304&quot; data-rawheight=&quot;337&quot; class=&quot;content_image lazy&quot; width=&quot;304&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4e018dcaffc557027b54647149662768_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;由于重加密在每次执行前都需要一个公钥来加密私钥和密文，要进行多次重加密就需要一个公钥序列{pk1,pk2,…,pki}，对应于公钥序列也有一个加密私钥链{sk1*,sk2*,…,sk(i-1)*}（其中ski*是用pk(i+1)加密ski得到的密文）。这个过程是如何进行的呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;运算电路的每一层都对应一对公钥与私钥。第一层对应的是pk1和sk1，第二层对应的是pk2和sk2……。例如:初始公钥为pk1，对应的私钥为sk1，在电路第一层进行重加密时，将用第二层电路的公钥pk2对sk1进行加密得到sk1*（公钥对于所有层都是公开的），以及用pk2对密文进行加密；然后输入解密电路，解密电路运行后将输出一个密文，该密文就是用pk2对明文进行加密的结果。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;同理在电路第二层进行重加密时，将用pk3对该层密钥sk2加密得到sk2*，,以及对来自第一层电路的输出密文进行加密；然后输入解密电路，解密电路将输出一个密文，该密文是对明文用pk3进行加密的结果。如此下去。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这种情况下公钥与私钥的数量与电路的深度成线性的依赖关系。如果将被加密的私钥信息泄露，不会影响密钥本身的安全的话，这称之为circular security。如果全同态的加密方案是circular security的话，就不需要这么多公钥与私钥，所有电路层都共用一个公钥与加密的私钥就可以了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;好处在于我们不需要为了确定密钥的数量，而在运算前确定执行函数功能的电路深度，从而方便许多。要证明前面的方案是circular security的还很困难，但是目前可以认为不会带来攻击的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果解密电路是在Evaluate所执行的permitted functions的集合里，则称该加密方案是Bootstrappable。从上面的解决思路可以看到没有特别绕弯子的地方，就是碰到问题解决问题，解决不了的，创造条件也要解决。通过创造同态执行解密电路的条件，从而降低噪音以达到无限次对密文运算的目的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;好了，到这里似乎全同态实现了（有种共产主义立马实现的感觉）。然而还存在一个问题：Evaluate电路能否能够运行解密电路呢？换句话说：解密电路是否在Evaluate所执行的permitted functions的集合里呢？ 可能有些人会说: 一个算法调用另外一个算法，有什么执行不了的？这就要说说电路的复杂度。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-24-60209894</guid>
<pubDate>Sun, 24 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-3</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-23-60138162.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60138162&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;——————————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;h2&gt;3 Bootstapping：一个生硬的思路&lt;br&gt;&lt;/h2&gt;&lt;p&gt;噪音阻碍了我们的目标，那么如何消除噪音这个敌人呢？一个直观的方法就是对密文解密，密文解密后噪音就没有了，但是要解密必须要知道私钥，要想通过获得私钥来消除噪音是不现实的。那么如果对密钥加密来做可以么？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;让我们先看看Evaluate算法。在Evaluate算法中能够对密文执行函数f的运算，其中f是属于permitted functions 集合的任一function（这里稍微解释一下，permitted functions 集合也称permitted circuit。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;例如有两个函数功能f1和f2，运行Evaluate(pk, f1, c1,c2,…，cn)和Evaluate(pk, f1, c1,c2,…，cn)，就是分别对密文执行f1运算和f2运算，如果f1运算的结果解密后恰好是f1对相应明文运算的结果（同态成立），那么f1就属于permitted functions。而f2运算的结果解密后如果不等于f2对相应明文运算的结果，那么f2就不属于permitted functions。）。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;试想如果Dec解密算法也在permitted functions 集合中，那么Evaluate算法就可以执行Dec解密功能了。如果我们输入的是s*（是用pk2对私钥s加密得到的密文），以及对密文c*（是用pk2对c再加密的密文，原密文c是用pk1进行加密的)，那么执行&lt;/p&gt;&lt;p&gt;Evaluate(pk2, Dec, s*,c*)；&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所得结果为一个新的密文，该密文是明文在pk2下加密的密文，是不是有点像魔术，就像原来一个人穿的是西装，现在你没有看到这个人换衣服的情况下，魔术师只是施了一下魔法，这个人立刻就换了一身运动服，人还是原来那个人，只是包装变了。这也是Gentry思想中一个最重要的特性：同态解密。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;     那么同态解密对于降低噪音又有什么关系呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;     当密文运算后，噪音会被迅速放大，如果我们对运算后的密文做一次同态解密，是不是相当于得到了一个新鲜密文呢，而新鲜密文的噪音是最小的，所以达到了降噪的目的。（事实上同态解密后得到的密文的噪音要比新鲜密文噪音稍微大一些。）这一手法称之为：重加密技术，它为我们提供了降低噪音的一个方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来你肯定会想到：每次密文运算前只要对密文进行重加密来降低噪音，然后再进行密文运算，那么噪音永远都在可控的范围内，运算结果的解密也就不会失败了。运算电路可以反复递归此过程，就可以达到无限次密文运算的目的了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-23-60138162</guid>
<pubDate>Sat, 23 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-2</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-22-59915903.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59915903&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;——————————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2&lt;/b&gt; &lt;b&gt;可怕的噪音&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;由于公钥pq是公开的，所以知道密文c后可以减去公钥得到：&lt;/p&gt;&lt;p&gt;c-pq= m+2r&lt;/p&gt;&lt;p&gt;由于存在r的干扰，所以无法识别明文m。我们就把m+2r称为噪音。另外在解密时只有当c mod p=m+2r &amp;lt;p/2时, 再对它进行模2运算才能正确解密：&lt;/p&gt;&lt;p&gt;（m+2r）mod 2= m。&lt;/p&gt;&lt;p&gt;如果噪音大于p/2时，c mod p就不再等于m+2r，解密就可能无法正确恢复出明文。所以噪音是影响解密的关键。而噪音会在密文计算中增长，下面来看看增长的势头：&lt;/p&gt;&lt;p&gt;假设c1= m1+2r1+pq1; c2= m2+2r2+pq2; 其中c1是对密文m1的加密，c2是对密文m2的加密。&lt;/p&gt;&lt;p&gt;密文加和乘运算：&lt;/p&gt;&lt;p&gt;c1+c2=(m1+m2)+2(r1+r2)+p(q1+q2)&lt;/p&gt;&lt;p&gt;c1*c2=( m1+2r1)(m2+2r2)+p(pq1q2+m1q2+m2q1+2r1q2+2r2q1)&lt;/p&gt;&lt;p&gt;(c1+c2) mod p= (m1+m2)+2(r1+r2)&lt;/p&gt;&lt;p&gt;c1*c2 mod p=( m1+2r1)(m2+2r2)&lt;/p&gt;&lt;p&gt;由上可见：密文之和的噪音是各自密文的噪音之和；而密文乘积的噪音是噪音之积。因此噪音的主要来源还是乘法运算，在乘法运算中噪音被放大的很快。&lt;/p&gt;&lt;p&gt;例如：设p=11, q=5, m1=0, m2=1，然后分别随机选取r1=1和r2= - 4, 有：&lt;/p&gt;&lt;p&gt;c1=Enc(m1)=m1+2r1+pq=0+2*(-1)+11*5=53; c1 mod p= -2, Dec(c1)=0.&lt;/p&gt;&lt;p&gt;c2=Enc(m2)=m2+2r2+pq=1+2*1+11*5=58; c2 mod p= 3, Dec(1)=1.&lt;/p&gt;&lt;p&gt;因为c1 mod p 和c2 mod p 都是在（-p/2，p/2）范围内，所以解密正确。c1和c2称之为新鲜密文,就是直接由明文生成的密文，在新鲜密文中噪音是在一定合理的范围内的。&lt;/p&gt;&lt;p&gt;我们再来看看c1*c2:&lt;/p&gt;&lt;p&gt;c*=c1*c2=53*58=3074; c* mod p=5, Dec(c*)=1≠m1*m2=0, 解密错误，错误的原因是噪音之积（c1 mod p）*（c2 mod p）= -6 不在（-p/2，p/2）范围内。&lt;/p&gt;&lt;p&gt;看来对密文运算会造成噪音的增大，当噪音超出范围，解密就失败，这意味着对密文运算不可能是无限次的（也就是Evaluate运算功能函数的电路深度是有限的，这在后面我们说到电路时会看到）。&lt;/p&gt;&lt;p&gt;到这里我们只得到了一个运算时噪音范围不能超过p/2的同态方案（Somewhat 同态方案），看来似乎用这个方案实现全同态是行不通的。我们需要的是全同态方案即Evaluate可以运行任意功能函数，而不是某一类功能函数（这叫同态方案）。&lt;/p&gt;&lt;p&gt;估计多少英雄好汉到了这里就觉得没戏了，于是另寻他路，于是一个突破就擦肩而过。那么下面让我们分析一下症结所在。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-22-59915903</guid>
<pubDate>Fri, 22 Mar 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
