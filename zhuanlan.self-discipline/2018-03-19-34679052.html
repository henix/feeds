<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>你好，类型（二）：Lambda calculus</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34679052">原文</a></p>
<h2><b>1. 匿名函数</b></h2><img src="https://pic1.zhimg.com/v2-87da900f32e0f115836e7d63a9a89421_r.jpg" data-caption="" data-size="normal" data-rawwidth="395" data-rawheight="376"><p>现在很多种编程语言都支持匿名函数了，<br>例如，<a href="https://msdn.microsoft.com/zh-sg/library/bb397687">C# 3.0</a>，<a href="https://zh.wikipedia.org/wiki/C%2B%2B11">C++ 11</a>和<a href="https://en.wikipedia.org/wiki/Java_version_history#Java_SE_8">Java 8</a>中的lambda表达式，<br>又例如，<a href="https://docs.python.org/release/2.2.2/ref/ref.html">Python 2.2.2</a>中的lambda，<a href="http://www-archive.mozilla.org/js/language/E262-3.pdf">ECMAScript 3</a>的匿名函数，<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">ECMAScript 2015</a>的箭头函数（arrow function）等等。</p><p>更不论，<a href="https://www.haskell.org/">Haskell</a>，<a href="https://en.wikipedia.org/wiki/Lisp">Lisp</a>，<a href="https://en.wikipedia.org/wiki/Standard_ML">Standard ML</a>，这些函数式编程语言了。</p><p>越来越多的语言拥抱匿名函数，是因为在很多场景中，我们无需给函数事先指定一个名字，<br>并且结合<a href="https://zh.wikipedia.org/zh-hans/%E4%BD%9C%E7%94%A8%E5%9F%9F">词法作用域</a>和高阶函数，会使某些问题用更直观的方式得以解决。</p><p>从理论上来讲，匿名函数具有和一般函数同样的计算能力，<br>使用某些技术手段，可以让匿名函数支持递归运算，从而完成任何<a href="https://zh.wikipedia.org/zh-hans/%E5%8F%AF%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0">图灵可计算</a>的任务。</p><p>然而，要想理解这一切，我们首先还得静下心来，从基础的 <equation>\lambda</equation> 演算开始吧。</p><h2><b>2. 自然数</b></h2><img src="https://pic3.zhimg.com/v2-1ad49d6d8ff89cd3eb9d8e93fb8e2aec_r.jpg" data-caption="" data-size="normal" data-rawwidth="495" data-rawheight="316"><p><equation>\lambda</equation> 演算听起来是一个高大上的概念，实际上它只是一套“符号推导系统”。</p><p>人们首先定义某些<b>合法的符号</b>，然后再定义一些符号<b>推导规则</b>，<br>最后就可以计算了，从一堆合法的符号得到另一堆，<br>这种推导过程称之为“<b>演算</b>”。</p><p>为了让 <equation>\lambda</equation> 演算更容易被接受，我们暂时先岔开话题，看看自然数是怎么定义的。</p><p><b>2.1 Peano系统</b></p><p>1889年，皮亚诺（<a href="https://zh.wikipedia.org/wiki/%E6%9C%B1%E5%A1%9E%E4%BD%A9%C2%B7%E7%9A%AE%E4%BA%9E%E8%AB%BE">Peano</a>）为了给出自然数的集合论定义，<br>他建立了一个包含5条公设的<b>公理系统</b>，后人称之为<b>Peano系统</b>。</p><p>Peano系统是满足以下公设的有序三元组 <equation>(M,F,e)</equation> ，<br>其中 <equation>M</equation> 为一个集合， <equation>F</equation> 是 <equation>M</equation> 到 <equation>M</equation> 的函数， <equation>e</equation> 为首元素，<br>（1） <equation>e\in M</equation> <br>（2） <equation>M</equation> 在 <equation>F</equation> 下是封闭的<br>（3） <equation>e</equation> 不在 <equation>F</equation> 的值域中<br>（4） <equation>F</equation> 是单射<br>（5）如果 <equation>M</equation> 的子集 <equation>A</equation> 满足， <equation>e\in A</equation> ，且 <equation>A</equation> 在 <equation>F</equation> 下封闭，则 <equation>A=M</equation> 。</p><p><b>2.2 后继</b></p><p>设 <equation>A</equation> 为一个集合，我们称 <equation>A\cup\{A\}</equation> 为 <equation>A</equation> 的<b>后继</b>，记作 <equation>A^+</equation> ，<br>求集合后继的操作，称为<b>后继运算</b>。</p><p>例如，<br> <equation>\varnothing^+=\varnothing\cup\{\varnothing\}=\{\varnothing\}</equation> ，<br> <equation>\varnothing^{++}=\varnothing^+\cup\{\varnothing^+\}=\{\varnothing\}\cup\{\{\varnothing\}\}=\{\varnothing,\{\varnothing\}\}</equation> ，<br> <equation>\varnothing^{+++}=\{\varnothing,\{\varnothing\},\{\varnothing,\{\varnothing\}\}\}</equation> 。</p><p><b>2.3 归纳集</b></p><p>设 <equation>A</equation> 为一个集合，若 <equation>A</equation> 满足，<br>（1） <equation>\varnothing\in A</equation> <br>（2） <equation>\forall a\in A</equation> ， <equation>a^+\in A</equation> <br>则称 <equation>A</equation> 是<b>归纳集</b>。</p><p>例如， <equation>\{\varnothing,\varnothing^+,\varnothing^{++},\cdots\}</equation> 是一个归纳集。<br>从归纳集的定义可知， <equation>\varnothing,\varnothing^+,\varnothing^{++},\cdots</equation> 是所有归纳集的元素，<br>于是，可以将它们定义为<b>自然数</b>，自然数集记为 <equation>N</equation> 。</p><p>设 <equation>\sigma:N\rightarrow N</equation> ，满足 <equation>\sigma(n)=n^+</equation> ，则称 <equation>\sigma</equation> 为<b>后继函数</b>，<br>则可以证明 <equation>(N,\sigma,\varnothing)</equation> 是一个Peano系统。</p><h2><b>3.</b> <b><i>λ</i>演算</b></h2><img src="https://pic4.zhimg.com/v2-72ffbc783aaa5cdc2ea8cabeae5f415a_r.jpg" data-caption="" data-size="normal" data-rawwidth="496" data-rawheight="213"><p><a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97">λ演算</a>，是1930年由邱奇（<a href="https://zh.wikipedia.org/zh-hans/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87">Alonzo Church</a>）发明的一套<a href="https://zh.wikipedia.org/zh/%E5%BD%A2%E5%BC%8F%E7%B3%BB%E7%B5%B1">形式系统</a>，<br>它是从具体的函数定义，函数调用和函数复合中，抽象出来的数学概念。</p><p><b>3.1 语法</b></p><p>形式上， <equation>\lambda</equation> 演算由3种语法项（term）组成，<br>（1）一个变量 <equation>x</equation> 本身，是一个合法的 <equation>\lambda</equation> 项，<br>（2） <equation>\lambda x.t_1</equation> ，是一个合法的 <equation>\lambda</equation> 项，称为从项 <equation>t_1</equation> 中抽象出 <equation>x</equation> ，<br>（3） <equation>t_1 t_2</equation> ，是一个合法的 <equation>\lambda</equation> 项，称为将 <equation>t_1</equation> 应用于 <equation>t_2</equation> 。</p><p>例如， <equation>(\lambda x.(xy))</equation> ， <equation>(x (\lambda x.(\lambda x.x)))</equation> ， <equation>((\lambda y.y)(\lambda x.(xy)))</equation> ，都是合法的 <equation>\lambda</equation> 项。<br>为了简化描述，我们通常会省略一些括号，以上三个 <equation>\lambda</equation> 项可以写成，<br> <equation>\lambda x.xy</equation> ， <equation>x (\lambda x.\lambda x.x)</equation> ， <equation>(\lambda y.y)(\lambda x.xy)</equation> ，<br>对于形如 <equation>\lambda x.t_1</equation> 的 <equation>\lambda</equation> 项来说，“ <equation>.</equation> ”后面会<b>向右包含尽量多</b>的内容。</p><p>现在我们有了一堆合法的字符串了。<br>可是，在给定<b>推导规则</b>之前，这些字符串之间都是没有关联的。<br>而且，我们也还没有为这些符号指定语义，它们到底代表什么也是不清楚的。</p><p>很显然<b>给这些符号指定不同的推导规则，会得到不同的公理系统</b>，<br>在众多 <equation>\lambda</equation> 演算系统中，最简单的是 <equation>\lambda_\beta</equation> 系统，它指定了 <equation>\alpha</equation> 和 <equation>\beta</equation> 两种变换。</p><p><b>3.2</b> <b><i>α</i>变换</b></p><p>设 <equation>\lambda</equation> 项 <equation>P</equation> 中包含了 <equation>\lambda x.M</equation> ，<br>则我们可以把 <equation>M</equation> 中所有<b>自由出现</b>的 <equation>x</equation> ，全都换成 <equation>y</equation> ，即 <equation>\lambda y.[y/x]M</equation> ，<br>这种更名变换，称为 <equation>\alpha</equation> <b>变换</b>。</p><p>其中，“<b>自由出现</b>”指的是 <equation>x</equation> 不被其他 <equation>\lambda</equation> 抽象所绑定，<br>例如， <equation>\lambda x.xy</equation> 中， <equation>y</equation> 是自由的，<br>而 <equation>x</equation> 就不是自由的，因为它被 <equation>\lambda x.</equation> 绑定了。</p><p>如果 <equation>P</equation> 可以经过有限步 <equation>\alpha</equation> 变换转换为 <equation>Q</equation> ，就写为 <equation>P\equiv_\alpha Q</equation> 。</p><p>例如，<br> <equation>\lambda xy.x(xy)=\lambda x.(\lambda y.x(xy))</equation> <br><equation>\equiv_\alpha\lambda x.(\lambda v.x(xv))</equation> <br><equation>\equiv_\alpha\lambda u.(\lambda v.u(uv))</equation> <br><equation>=\lambda uv.u(uv)</equation> </p><p><b>3.3</b> <b><i>β</i>变换</b></p><p>形如 <equation>(\lambda x.M)N</equation> 的 <equation>\lambda</equation> 项，可以经由<b><equation>\beta</equation> 变换</b>转换为 <equation>[N/x]M</equation> ，<br>指的是，把 <equation>M</equation> 中所有自由出现的 <equation>x</equation> 都换成 <equation>N</equation> 。</p><p>如果 <equation>P</equation> 可以经过有限步 <equation>\beta</equation> 变换转换为 <equation>Q</equation> ，就写为 <equation>P\triangleright_\beta Q</equation> 。</p><p>例如，<br> <equation>(\lambda x.x(xy))N\triangleright_\beta N(Ny)</equation> <equation>(\lambda x.xx)(\lambda x.xx)\triangleright_\beta [(\lambda x.xx)/x](xx)=(\lambda x.xx)(\lambda x.xx)\triangleright_\beta\cdots</equation> </p><p>我们发现，某些 <equation>\lambda</equation> 项，可以无限进行 <equation>\beta</equation> 变换。<br>而那些最终会终止的 <equation>\beta</equation> 变换的结果，称为 <b><equation>\beta</equation> 范式</b>（ <equation>\beta</equation>  normal form）。</p><p><b>3.4 邱奇编码</b></p><p>现在我们有 <equation>\lambda_\beta</equation> 公理系统了，就可以依照 <equation>\alpha</equation> 或 <equation>\beta</equation> 变换，对任意合法的 <equation>\lambda</equation> 项进行变换。</p><p>假设我们有一个 <equation>\lambda</equation> 项， <equation>\lambda f.\lambda x.x</equation> ，<br>还有另外一个 <equation>\lambda</equation> 项， <equation>\lambda n.\lambda f.\lambda x.f(nfx)</equation> ，记为 <equation>succ</equation> ，<br>我们来计算， <equation>succ(\lambda f.\lambda x.x)</equation> ，<br>可得， <equation>(\lambda n.\lambda f.\lambda x.f(nfx))(\lambda f.\lambda x.x)\triangleright_\beta\lambda f.\lambda x.fx</equation> ，<br>我们再运用一次 <equation>succ</equation> ， <equation>succ(\lambda f.\lambda x.fx)\triangleright_\beta\lambda f.\lambda x.f(fx)</equation> 。</p><p>我们发现每次应用 <equation>succ</equation> ，都会给 <equation>\lambda f.\lambda x.x</equation> 中加一个 <equation>f</equation> ，<br>最终我们可以得到以下这些 <equation>\lambda</equation> 项，<br> <equation>\lambda f.\lambda x.x</equation> <br><equation>\lambda f.\lambda x.fx</equation> <br><equation>\lambda f.\lambda x.f(fx)</equation> <br><equation>\lambda f.\lambda x.f(f(fx))</equation> <br><equation>\cdots</equation> <br><equation>\lambda f.\lambda x.f^nx</equation> </p><p>如果我们记 <equation>\lambda f.\lambda x.x\equiv 0</equation> ， <equation>\lambda f.\lambda x.fx\equiv 1</equation> ， <equation>\cdots</equation> ， <equation>\lambda f.\lambda x.f^nx\equiv n</equation> ，<br>我们就得到了<b>自然数的另一种表示方式</b>，称之为<a href="https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%E6%95%B0">邱奇编码</a>。</p><p>可以看到邱奇编码与归纳集之间有异曲同工之妙。</p><p><b>3.5 语义</b></p><p>到目前为止，我们并未谈及 <equation>\lambda</equation> 项到底表示什么<b>含义</b>，<br>虽然 <equation>\lambda x.M</equation> 看起来像是函数定义， <equation>(\lambda x.M)N</equation> 看起来像是函数调用。</p><p>我们谨慎的使用<b>公理化方法</b>，从什么是合法的 <equation>\lambda</equation> 项出发，<br>定义 <equation>\lambda_\beta</equation> 系统中的<b>公理</b>——合法的 <equation>\lambda</equation> 项，<br>然后又指定了该系统中的<b>推导规则</b>—— <equation>\alpha</equation> 和 <equation>\beta</equation> 变换，<br>最终得到了一个形式化的公理系统（公理+推导规则）。</p><p>后文中，我们将谈及 <equation>\lambda</equation> 项的语义，然后再逐渐给它加上类型。</p><hr><h2><b>参考</b></h2><p><a href="https://book.douban.com/subject/1230394/">离散数学教程</a> <br><a href="https://book.douban.com/subject/4323391/">Lambda-Calculus and Combinators，an Introduction</a> <br><a href="https://www.irif.fr/~mellies/mpri/mpri-ens/biblio/Selinger-Lambda-Calculus-Notes.pdf">Lecture Notes on the Lambda Calculus</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
