<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Emacs之魂（五）：变量的“指针”语义</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34106367">原文</a></p>
<h2><b>1. 语义学</b></h2><img src="https://pic3.zhimg.com/v2-25fd52ea0f49c88ca62b145ddf54638d_r.jpg" data-caption="" data-size="normal" data-rawwidth="593" data-rawheight="275"><p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA">计算理论</a>中，<a href="https://zh.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E5%AD%A6">形式语义学</a>是关注计算模式和程序设计语言含义的严格的数学研究领域。<br>语言的形式语义是用数学模型去表达该语言描述的可能计算来给出的。</p><p>提供程序设计语言形式语义的方法很多，其中主要类别有：<br><a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E8%AF%AD%E4%B9%89%E5%AD%A6">操作语义</a>（operational Semantics），<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E7%A7%B0%E8%AF%AD%E4%B9%89">指称语义</a>（denotational semantics），<br><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E7%90%86%E8%AF%AD%E4%B9%89%E5%AD%A6">公理语义</a>（axiomatic semantics），<a href="https://en.wikipedia.org/wiki/Algebraic_semantics_(computer_science">代数语义</a>（algebraic semantics）。</p><p><b>1.1 操作语义</b></p><p>将语言成分所对应的计算机系统的操作，作为该语言成分的语义，这样的建模方式称为操作语义学，<br>语言的操作语义应该是标准的，不应该依附于一个特定的计算机系统，<br>因此，人们使用抽象的机器和抽象的解释程序来定义语言的操作语义。</p><p>操作语义学的基本思想来源于编译器和解释器，编译器或者解释器描述了程序语言的具体实现。<br>操作语义最早被用于定义<a href="https://zh.wikipedia.org/wiki/ALGOL_68">Algol 68</a>的语义，<br>1964年<a href="https://en.wikipedia.org/wiki/Peter_Landin">Peter Landin</a>使用了<a href="https://en.wikipedia.org/wiki/SECD_machine">SECD machine</a>这种抽象机器，定义了表达式的操作语义。<br>1980年，<a href="https://en.wikipedia.org/wiki/Gordon_Plotkin">Gordon Plotkin</a>提出了结构操作语义（structured operational semantics），它在更一般的数学结构上用归约关系（reduction relation）建立了语义的解释系统，<br>这种语义学具有结构化的特征，语言中复合成分的语义是由其子成分的语义复合而成的，<br>结构操作语义，对软件工程中结构化编程具有重要的指导意义。</p><p><b>1.2 指称语义</b></p><img src="https://pic3.zhimg.com/v2-a71fa52194314131e93ae298c2d4e05f_r.jpg" data-caption="" data-size="normal" data-rawwidth="582" data-rawheight="356"><p>人们用程序设计语言编程，计算机系统用于加工数据，<br>不同的计算机系统有不同的结构，因此对同一条命令的执行过程可能不同，但是最终结果应该是相同的。</p><p>指称语义学认为语言成分的含义是语言成分本身固有的，与计算机系统无关，<br>所以，不应该将语言成分的执行过程看做它的语义，语言成分的语义应该是它的执行结果。<br>这种将最终结果看做语言成分语义的建模方式，称为指称语义学，这个最终结果称为该语言成分的指称。</p><p>语言成分的指称一般是一个数学对象，如整数，集合等等。<br>指称语义学是<a href="https://en.wikipedia.org/wiki/Christopher_Strachey">Christopher Strachey</a>于1964年提出的，<br>后来<a href="https://en.wikipedia.org/wiki/Dana_Scott">Dana Scott</a>创建了论域理论（domain theory）为指称语义学奠定了数学基础。</p><p>指称语义学方法在定义语言的语义时，先确定语言成分的指称，然后给出语言成分与其指称之间的映射关系，<br>而且确定复合语言成分指称的过程是语法制导的（syntax-directed），也称为结构化的（structural），<br>即语言成分的指称只依赖于它的子成分的指称。</p><p><b>1.3 公理语义</b></p><img src="https://pic1.zhimg.com/v2-09730cc6f03bcf4b641818a83c0f0339_r.jpg" data-caption="" data-size="normal" data-rawwidth="646" data-rawheight="350"><p>公理语义在定义语义的时候，采用了数学中的公理化方法，<br>语言的公理语义构成了一个由“公理”和“定理”组成的逻辑证明系统，<br>它认为语言的语义，是由这个证明系统所能反映出来的一切性质。<br>操作语义可以看做公理语义的一种有向形式。</p><p>1967年，<a href="https://en.wikipedia.org/wiki/Robert_W._Floyd">Robert W. Floyd</a>提出了论证一个程序是否具有某种性质的数学方法，<br>1969年，<a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a>第一次用公理系统（<a href="https://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a>）定义了一类程序设计语言的语义。<br>Hoare logic使用带有前置条件和后置条件的归纳命题（inductive proposition），作为描述语义的形式化工具。</p><p><b>1.4 代数语义</b></p><img src="https://pic3.zhimg.com/v2-edd13de1c4eea5367e0a6c3457b524f2_r.jpg" data-caption="" data-size="normal" data-rawwidth="398" data-rawheight="228"><p>指称语义的研究方法建立在递归函数论基础之上，公理语义的研究方法建立在谓词逻辑基础之上，<br>代数语义学用代数方法研究计算机语言的语义，它建立在抽象代数的基础之上。</p><p>代数语义学描述了程序中不同种类（sort）的数学对象（object），以及这些对象之间的运算，它们构成了一种代数结构，<br>代数语义学，通过分析这种代数结构的性质，来描述程序的语义。</p><p>代数语义学源于人们对抽象数据类型（<a href="https://en.wikipedia.org/wiki/Abstract_data_type">abstract data type</a>）的研究，<br>泛代数（<a href="https://en.wikipedia.org/wiki/Universal_algebra">universal algebra</a>）是一个用于研究抽象数据类型的数学框架。<br>在泛代数中，抽象数据类型的语法由代数项（algebraic term）描述，公理语义用项之间的等式集（a set of equations）描述，而指称语义对应于一个Σ代数，操作语义通过给等式设定方向来表示。</p><h2><b>2. Lisp的Pointer semantics</b></h2><p><b>2.1 Conceptual pointer</b></p><p>Lisp语言提供了一个简洁的计算模型，是因为它在语义上的简洁性，<br>Lisp语言中所有的值都可以“看做”指针，所有的内存都可以“看做”在堆（heap）中分配。</p><code lang="emacs">(defvar foo 5)</code><p>Lisp会在堆中为<code class="inline">x</code>分配内存，让它包含一个指针，指向另一块初始化为<code class="inline">5</code>的内存，<br>即，Lisp中的值总是可以“看做”指向堆内存的指针。</p><p>我们可以用下图表示：</p><code lang="text">    +-------+ 
foo |   *---+---&gt;5 
    +-------+</code><p>Lisp语言的具体实现中，会采用不同的策略避免频繁分配内存的开销，<br>但是在语言层面对用户是不可见的。</p><p><b>2.2 pointer semantics &amp; value semantics</b></p><p>和C语言不同的是，Lisp用户不用显式的释放内存，这使得心智负担大大降低了，<br>Lisp用户不用对指针解引用（dereference），因为默认每次都会这么做。</p><p>例如，算术加法函数<code class="inline">+</code>，接受两个指针作为参数，<br>它会在进行加法操作之前，自动对参数进行解引用，并且返回一个指向加法结果的指针。</p><code lang="emacs">(+ 1 2)</code><p>当我们对上述表达式求值的时候，加法函数会得到两个指针，分别指向<code class="inline">1</code>和<code class="inline">2</code>，<br>求值结果会返回一个指向<code class="inline">3</code>的指针。</p><p>大部分编程语言除了具有pointer semantics之外，还具有value semantics。<br>例如，它们会把<code class="inline">1</code>，<code class="inline">2</code>看做值，<code class="inline">1</code>和<code class="inline">2</code>的每次出现，都是不同的一份拷贝。<br>Lisp语言只有pointer semantics，<code class="inline">1</code>和<code class="inline">2</code>的每次出现都表示对唯一的数字对象的不同引用。</p><p>由于效率方面的考虑，具体实现可以做出任何调整，只要不影响pointer semantics。<br>人们常说Lisp，Smalltalk，Java等这些语言没有指针，其实不太合理，<br>而是应该说，所有的东西都是指针。（pointer semantics</p><p>把所有东西都实现为一个指针，代价是高昂的，<br>我们必须把所有的指针，以及它指向的对象，全都分配在堆中。<br>还必须使用额外的操作访问这些内存。</p><p>幸运的是，Lisp的具体实现中，并不会这样表示它们，会对多种情况进行优化。<br>例如，变量中会直接保存数字的二进制形式，而不是一个指向堆内存的指针。<br>使用标签（tag）与那些具有相同二进制模式的指针进行区分。</p><p><b>2.3 例子</b></p><p>在Lisp语言中，一个pair（又称为cons cell），是一个在堆中分配的对象，<br>它包含两个字段，每个字段都可以包含任意种类的值，<br>例如，数字，字符，布尔值，或者一个指向其他堆内存的指针。</p><p>由于历史原因，第一个字段称为<code class="inline">car</code>，第二个字段称为<code class="inline">cdr</code>，<br>pair可以通过<code class="inline">cons</code>函数来创建。</p><code lang="emacs">(cons 22 15)</code><p>以上表达式创建了一个pair，它包含了两个字段，<br>其中<code class="inline">car</code>字段为<code class="inline">22</code>，<code class="inline">cdr</code>字段为<code class="inline">15</code>。</p><p>我们可以用下图来表示：</p><code lang="text">      +-----------+ 
header| &lt;PAIR-ID&gt; | 
      +===========+ 
   car|     *-----+-----&gt;22
      +-----------+ 
   cdr|     *-----+-----&gt;15 
      +-----------+</code><p>其中，<code class="inline">header</code>用于保存类型信息，用于表明在堆中分配了什么类型的对象，Lisp用户不必关心<code class="inline">header</code>的值。<br><code class="inline">car</code>字段包含了一个指针，指向了<code class="inline">22</code>，<code class="inline">cdr</code>字段包含了另外一个指针，指向了<code class="inline">15</code>。</p><code lang="emacs">(defvar foo
  (cons 22 15))</code><p>假设我们定义了一个全局变量，让它的值为一个pair，于是我们可以用下图来表示：</p><code lang="text">    +---------+ 
    +---------+        header| &lt;PAIR&gt;  | 
foo |    *----+-------------&gt;+=========+ 
    +---------+           car|    *----+----&gt;22 
                             +---------+ 
                          cdr|    *----+----&gt;15 
                             +---------+</code><p>变量<code class="inline">foo</code>指向了一个pair，pair中的两个字段分别指向了<code class="inline">22</code>和<code class="inline">15</code>。</p><p>使用<code class="inline">car</code>函数和<code class="inline">cdr</code>函数可以得到pair中保存的两个字段的值，</p><code lang="emacs">(car foo)
&gt; 22

(cdr foo)
&gt; 15</code><hr><h2><b>参考</b></h2><p><a href="https://books.google.com/books/about/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E5%AD%A6%E5%BC%95%E8%AE%BA.html?id=wY94OAAACAAJ">形式语义学引论 - 周巢尘</a> <br><a href="https://book.douban.com/subject/1944729/">程序设计语言理论基础</a> <br><a href="http://homepage.divms.uiowa.edu/~slonnegr/plf/Book/">Syntax and Semantics of Programming Languages</a> <br><a href="ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html">An Introduction to Scheme and its Implementation</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
