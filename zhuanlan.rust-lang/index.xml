<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Rust编程</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/</link>
<description>与 Rust 语言相关的方方面面</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 15 Jan 2018 05:11:34 +0800</lastBuildDate>
<item>
<title>[译] Rust - None Lexical Lifetimes (NLL) 使用指南</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-01-12-32884290.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;[译] Rust - None Lexical Lifetimes (NLL) 使用指南&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32884290&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b7bdc8a3a010ad92012199af2750cc72_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;原文地址 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//santiagopastorino.com/how-to-use-rust-non-lexical-lifetimes-on-nightly/&quot;&gt;https://santiagopastorino.com/how-to-use-rust-non-lexical-lifetimes-on-nightly/&lt;/a&gt;&lt;br&gt;原文作者: Santiago Pastorino&lt;/blockquote&gt;&lt;p&gt;Niko Matsakis, Paul Faria 和我在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//internals.rust-lang.org/t/announcing-the-impl-period-sep-18-dec-17/5676&quot;&gt;impl period&lt;/a&gt; 期间致力于开发None Lexical Lifetimes (暂译为非词法作用域生命周期，下文统称为 NLL)。 代码目前已经合并到 master 分支，你现在可以在 nightly 中体验。&lt;/p&gt;&lt;p&gt;本文将通过几个例子简单直观地展现 NLL 的使用方法。这里我不会涉及 NLL 背后的设计逻辑，如果对设计细节感兴趣，我推荐你进一步阅读 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/rfcs/blob/master/text/2094-nll.md&quot;&gt;RFC&lt;/a&gt;，你想知道的都在里面了。我想你还可以尝试在 pull requests 贡献代码。&lt;/p&gt;&lt;p&gt;话不多说，我们直接上代码。&lt;/p&gt;&lt;p&gt;当然在这之前，你要先确保机器上安装了最新的 nightly 版本 —— 打开命令行运行 &lt;code class=&quot;inline&quot;&gt;rustup install nightly&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们先看这个简单的例子，它在目前的作用域生命周期(scope based lifetimes)规则下不能编译。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![allow(unused_variables)]

fn main() {
    let mut x = 22;

    let p = &amp;amp;mut x; // mutable borrow

    println!(&quot;{}&quot;, x); // later used
}
&lt;/code&gt;&lt;p&gt;这是因为 x 被可变借用，并且在作用域结束前再次被使用。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
 --&amp;gt; src/main.rs:8:20
  |
6 |     let p = &amp;amp;mut x; // mutable borrow
  |                  - mutable borrow occurs here
7 | 
8 |     println!(&quot;{}&quot;, x); // later used
  |                    ^ immutable borrow occurs here
9 | }
  | - mutable borrow ends here

error: aborting due to previous error
&lt;/code&gt;&lt;p&gt;现在我们在开头加入 &lt;code class=&quot;inline&quot;&gt;#![feature(nll)]&lt;/code&gt; 代码开启 NLL 特性。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![feature(nll)]
#![allow(unused_variables)]

fn main() {
    let mut x = 22;

    let p = &amp;amp;mut x;

    println!(&quot;{}&quot;, x);
}
&lt;/code&gt;&lt;p&gt;这段代码顺利编译，因为编译器知道 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 的可变借用并没有持续到作用域结尾，而是在 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 被再次使用之前就结束了，所以这里不存在冲突。&lt;/p&gt;&lt;p&gt;我们在看一个稍微复杂些的例子。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::collections::HashMap;

fn get_default(map: &amp;amp;mut HashMap, key: usize) -&amp;gt; &amp;amp;mut String {
    match map.get_mut(&amp;amp;key) {
        Some(value) =&amp;gt; value,
        None =&amp;gt; {
            map.insert(key, &quot;&quot;.to_string());
            map.get_mut(&amp;amp;key).unwrap()
        }
    }
}

fn main() {
    let map = &amp;amp;mut HashMap::new();
    map.insert(22, format!(&quot;Hello, world&quot;));
    map.insert(44, format!(&quot;Goodbye, world&quot;));
    assert_eq!(&amp;amp;*get_default(map, 22), &quot;Hello, world&quot;);
    assert_eq!(&amp;amp;*get_default(map, 66), &quot;&quot;);
}
&lt;/code&gt;&lt;p&gt;如果我们直接编译，这段代码也会报错，因为 &lt;code class=&quot;inline&quot;&gt;get_mut&lt;/code&gt; 在 &lt;code class=&quot;inline&quot;&gt;match&lt;/code&gt; 里借用 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 直到作用域结尾，这段作用域也覆盖到 &lt;code class=&quot;inline&quot;&gt;None&lt;/code&gt; 分支，而我们在 &lt;code class=&quot;inline&quot;&gt;None&lt;/code&gt; 分支里尝试再次可变借用 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;，编译器自然是十分拒绝的。&lt;/p&gt;&lt;p&gt;错误信息是这样的&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;error[E0499]: cannot borrow `*map` as mutable more than once at a time
  --&amp;gt; src/main.rs:7:13
   |
4  |     match map.get_mut(&amp;amp;key) {
   |           --- first mutable borrow occurs here
...
7  |             map.insert(key, &quot;&quot;.to_string());
   |             ^^^ second mutable borrow occurs here
...
11 | }
   | - first borrow ends here

error[E0499]: cannot borrow `*map` as mutable more than once at a time
  --&amp;gt; src/main.rs:8:13
   |
4  |     match map.get_mut(&amp;amp;key) {
   |           --- first mutable borrow occurs here
...
8  |             map.get_mut(&amp;amp;key).unwrap()
   |             ^^^ second mutable borrow occurs here
...
11 | }
   | - first borrow ends here

error: aborting due to 2 previous errors
&lt;/code&gt;&lt;p&gt;不开启 NLL 的情况下，我们有一种丑陋的技巧可以让它通过编译。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn get_default(map: &amp;amp;mut HashMap, key: usize) -&amp;gt; &amp;amp;mut String {
    match map.get_mut(&amp;amp;key) {
        Some(value) =&amp;gt; return value,
        None =&amp;gt; {
        }
    }
    
    map.insert(key, &quot;&quot;.to_string());
    map.get_mut(&amp;amp;key).unwrap()
}
&lt;/code&gt;&lt;p&gt;这段代码虽然能编译，代价是我们必须使用这种令人难受的写法。&lt;/p&gt;&lt;p&gt;如果我们在原先的例子中加入 &lt;code class=&quot;inline&quot;&gt;#![feature(nll)]&lt;/code&gt; 开启 NLL ...&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![feature(nll)]

use std::collections::HashMap;

fn get_default(map: &amp;amp;mut HashMap, key: usize) -&amp;gt; &amp;amp;mut String {
    match map.get_mut(&amp;amp;key) {
        Some(value) =&amp;gt; value,
        None =&amp;gt; {
            map.insert(key, &quot;&quot;.to_string());
            map.get_mut(&amp;amp;key).unwrap()
        }
    }
}

fn main() {
    let map = &amp;amp;mut HashMap::new();
    map.insert(22, format!(&quot;Hello, world&quot;));
    map.insert(44, format!(&quot;Goodbye, world&quot;));
    assert_eq!(&amp;amp;*get_default(map, 22), &quot;Hello, world&quot;);
    assert_eq!(&amp;amp;*get_default(map, 66), &quot;&quot;);
}
&lt;/code&gt;&lt;p&gt;这段代码完美通过编译，并且再也不用写那种令人智熄的代码。&lt;/p&gt;&lt;p&gt;另一个有趣的东西是用来展示借用错误的叫做 &lt;code class=&quot;inline&quot;&gt;three point error&lt;/code&gt; 的机制。目前为了开启它你需要显式地给编译器传入 &lt;code class=&quot;inline&quot;&gt;-Znll-dump-cause&lt;/code&gt; 参数。&lt;/p&gt;&lt;p&gt;先看这个在 NLL 下产生借用错误的例子。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![feature(nll)]
#![allow(unused_assignments)]

fn main() {
    let mut x = 22;

    let p = &amp;amp;x;

    x = 33;
    
    println!(&quot;{}&quot;, p);
}
&lt;/code&gt;&lt;p&gt;编译时传入 &lt;code class=&quot;inline&quot;&gt;nll-dump-cause&lt;/code&gt;，three point errors 会产生下面这样的的错误信息&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ rustc -Znll-dump-cause main.rs
error[E0506]: cannot assign to `x` because it is borrowed
  --&amp;gt; src/main.rs:9:5
   |
7  |     let p = &amp;amp;x;
   |             -- borrow of `x` occurs here
8  | 
9  |     x = 33;
   |     ^^^^^^ assignment to borrowed `x` occurs here
10 |     
11 |     println!(&quot;{}&quot;, p);
   |                    - borrow later used here

error: aborting due to previous error
&lt;/code&gt;&lt;p&gt;错误信息指出了起始借用，借用赋值和使用借用的位置，这应该可以给你提供对于问题清晰的思路。&lt;/p&gt;&lt;p&gt;这个机制目前还有性能上的问题，因此我们暂时需要自己手动开启。我们打算在解决性能问题后就将它设为默认。我和 Niko 已经着手，请拭目以待 :)。&lt;/p&gt;&lt;p&gt;我和你们一样非常兴奋于 NLL 最终落地，去尝试使用 NLL 写些代码，然后反馈你遇到的 bug 吧。虽然 NLL 已知存在一些问题需要修复，但是我们知道这都会慢慢完善起来的。&lt;/p&gt;&lt;p&gt;最后，我想说些无关紧要的话，我想分享一下我在 impl period 中的参与这个项目的体验。&lt;/p&gt;&lt;p&gt;首先，我从未想过我竟然能够有机会直接与 Niko 共事，更别说这还是我的第一个 Rust 项目。&lt;/p&gt;&lt;p&gt;Niko 是个令人敬仰的专家 (professional)，更重要的是他非常友好，容易亲近。我们在 Gitter 上交谈了很久，打过 call，然后我们还一起在 Rust Belt Rust 工作过 3 天。&lt;/p&gt;&lt;p&gt;我还与其他开发者花了不少时间讨论想法，比如说 Paul, 我非常感谢他的支持。&lt;/p&gt;</description>
<author>Andy Lok</author>
<guid isPermaLink="false">2018-01-12-32884290</guid>
<pubDate>Fri, 12 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>为什么我喜欢Rust</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-09-05-29079046.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;为什么我喜欢Rust&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29079046&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天写了一个回答：&lt;a href=&quot;https://www.zhihu.com/question/64563945/answer/225704730&quot;&gt;F001：为什么要使用TypeScript？有哪些情景请简单介绍一下，或者来个例子?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我觉得这个回答也可以用来解释，为什么我喜欢Rust编程语言。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我感觉现在很多程序员并没有彻底接受这样的一个思想：产品设计既需要考虑如何方便好用，也需要考虑如何防止误用。大部分人过于强调方便好用的这一面，而忽略了防止误用的令一面。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不论是设计一个函数、类、框架、还是语言，都不仅要想到用户正常使用的时候是怎样的，还要想到哪些使用方式是有问题的，应该如何设计避免这些可能的误用。哪怕是枪械，也还要加个保险栓呢。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个思想，在绝大部分从业人员的大脑中都是薄弱的，哪怕是C/C++的标准库，都存在很多让人极易用错很难用对的设计，在很多编码规范中都要禁止使用这些功能，更不用说平均水平更低的普通开发者，能写出什么稀奇古怪的代码都不奇怪。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;作为一名源代码静态检查工具的开发者(Coverity)，我见过太多太多奇葩的C/C++用例，但是很遗憾的是编译器并没有阻止它们。Coverity的误报率和漏报率在行业内都算顶尖的，但是对某些问题，我们也无法保证百分百能检查出来。在C/C++里面，有些类别的错误，是没办法被“完整无遗漏”地检查出来的，这是C/C++的本质复杂性决定的，这个任务就是 mission impossible，我们能做的是尽最大可能覆盖尽可能多的用例。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust能够“保证”内存安全、保证线程安全，这是一个非常重要的能力，这不是因为Rust的静态检查用了什么特别的算法技术，而是因为他们作弊了，直接简化了被研究对象。从静态检查器的实现的角度来说，Rust比Coverity简单得多，但效果要更好。C/C++里面很多需要费了老劲检查的问题，在Rust中根本不存在。不存在的问题，当然不需要寻找解决方案。当然，这就是Rust设计组牛逼的地方。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-09-05-29079046</guid>
<pubDate>Tue, 05 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>高阶类型 Higher Kinded Type</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-09-03-29021140.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;高阶类型 Higher Kinded Type&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29021140&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近，又有一份重量级的RFC（&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1598&quot;&gt;https://github.com/rust-lang/rfcs/pull/1598&lt;/a&gt;）被接受。它有多个名字，既可以叫 Generic associated type，也可以叫 associated type constructor，还可以叫 higher kinded type。这就是传说中的“高阶类型”。这个功能一直是学院派开发者一直期望的功能，是类型系统重要的一块拼图。&lt;/p&gt;&lt;p&gt;笔者在这方面经验很少，本文只能做一个简单介绍，当作是写给自己的学习总结。欢迎各位老司机做深入探讨。写完这篇文章，感觉对这个问题的理解更清晰了一些。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;什么是高阶&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们知道，在强类型编程语言中，每一个表达式都有类型。有些类型，在这门语言中是内置的、基本的，我们把它们叫做“基础”类型。比如Rust里面的 i32 bool char 等等。还有一些类型，是通过其它类型一起组合出来的，比如函数，&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn double(arg: i32) -&amp;gt; i32 {
    arg * 2
}&lt;/code&gt;&lt;p&gt;这个函数类型指的是，接受一个 i32 类型参数，生成一个 i32 类型返回值。它们的类型都是可以列出来的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression    |   type
------------------------
true          |   bool
1             |   i32
double        |   i32 -&amp;gt; i32
double(2)     |   i32&lt;/code&gt;&lt;p&gt;如果一个函数，可以接受函数作为参数或者返回值，那么它就是所谓的高阶函数(higher ordered function)。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn twice(f: fn(i32)-&amp;gt;i32) -&amp;gt; Box&amp;lt;Fn(i32)-&amp;gt;i32&amp;gt;
{
    Box::new(move |a| f(f(a)))
}

fn double(arg: i32) -&amp;gt; i32 {
    arg * 2
}

fn main() {
    let g = twice(double);
    println!(&quot;{}&quot;, g(2));
}&lt;/code&gt;&lt;p&gt;上例中，这个 twice 函数，就是高阶函数，它的类型为 (i32-&amp;gt;i32) -&amp;gt; (i32-&amp;gt;i32)。&lt;/p&gt;&lt;p&gt;还有一些更复杂的类型，比如 Vec&amp;lt;i32&amp;gt; 比上面的这些类型更复杂。因为 Vec 本身不是一个合法类型，它必须接受一个类型参数 i32 才能成为一个真正的类型 Vec&amp;lt;i32&amp;gt;。我们可以把 Vec 视为针对类型的“函数”，称作“类型构造器”，给它输入一个类型，它会返回一个类型出来。我们定义一个概念“阶(kind)” 来描述这种现象。比如最基本的类型 i32 bool ，它们的kind就是 type。而 Vec 的kind就是 type -&amp;gt; type。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression |  kind
-------------------
i32        |  type
i32 -&amp;gt; i32 |  type
Vec&amp;lt;i32&amp;gt;   |  type
Vec        |  type -&amp;gt; type&lt;/code&gt;&lt;p&gt;类似的，假如我们有一个类型构造器，它本身可以接受类型构造器作为参数，那它就是“高阶类型”。比如，我们要设计一个容器类型，它里面装的一组 i32 整数，但是我们把内部具体实现方式（可以用 Vec 或者 List）开放出来作为参数由用户指定，伪代码类似这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 类似 scala 的伪代码
struct Collection&amp;lt;C&amp;lt;_&amp;gt;&amp;gt; {
    data: C&amp;lt;i32&amp;gt;
}&lt;/code&gt;&lt;p&gt;使用的时候，我们可以这样指定泛型参数 Collection&amp;lt;Vec&amp;gt; Collection&amp;lt;LinkedList&amp;gt;，那么这个 Collection 就是所谓的“高阶类型”。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression          |  kind
-------------------------------------------
Vec&amp;lt;i32&amp;gt;            |  type
Vec                 |  type -&amp;gt; type
Collection          |  (type-&amp;gt;type) -&amp;gt; type
Collection&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;  |  type -&amp;gt; type&lt;/code&gt;&lt;p&gt;在Rust里面，有个特殊的地方是，泛型参数被分成了两类（两种基本的 kind），分别是 type 以及 lifetime。比如，我们最常见的引用类型，它就是类型构造器，且有生命周期泛型参数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression     | kind
-----------------------
&amp;amp;&#39;a i32        | type
&amp;amp;              | (lifetime, type) -&amp;gt; type&lt;/code&gt;&lt;h2&gt;&lt;b&gt;高阶生命周期&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;实际上，现在的Rust已经支持了某种意义上的“高阶类型”，那就是所谓的“高阶生命周期约束”。参考 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;nomicon&lt;/a&gt;。它的语法如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;for&amp;lt;&#39;a&amp;gt; F: Fn(&amp;amp;&#39;a T) -&amp;gt; &amp;amp;&#39;a T&lt;/code&gt;&lt;p&gt;它代表的意思是，对于任意 &#39;a，F 满足 Fn(&amp;amp;&#39;a T) -&amp;gt; &amp;amp;&#39;a T。比如说，标准库中，就有很多地方用到了这个：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Iterator {
    fn filter&amp;lt;P&amp;gt;(self, predicate: P) -&amp;gt; Filter&amp;lt;Self, P&amp;gt;
        where
            P: FnMut(&amp;amp;Self::Item) -&amp;gt; bool
}&lt;/code&gt;&lt;p&gt;这里的泛型参数 P，就用到了高阶生命周期，源码中的写法是省略写法，如果要写完整，它实际上意思是这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;where P: for&amp;lt;&#39;a&amp;gt; FnMut(&amp;amp;&#39;a Self::Item) -&amp;gt; bool&lt;/code&gt;&lt;p&gt;但是这个语法目前只支持生命周期泛型参数，不能用于普通类型参数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;其它语言中的hkt&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这一部分来自于 niko 的博客，本人完全没有把握是否完整理解了 niko 的文章，欢迎各位提意见。&lt;/p&gt;&lt;p&gt;一个直观的 hkt 设计方案，就是直接为这个功能设计一种高阶类型的语法。举个例子，假如我们想设计一个通用函数，它能把一个容器中的整数类型转换为浮点数类型，容器本身是泛型的，可以是 Vec 或者 LinkedList，可以这么设计:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 假设一种表示高阶类型的语法，类似 scala
fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
//              ^^^^ the notation `I&amp;lt;_&amp;gt;` signals that `I` is
//                   not a complete type&lt;/code&gt;&lt;p&gt;这个例子以及解释是从 Nicholas D. Matsakis 的博客搬运过来的。在这个例子中，I 是一个泛型参数，它是一个类型构造器。假如 I 被实例化为 Vec，那么这个函数的类型就被实例化成了 Vec&amp;lt;i32&amp;gt; -&amp;gt; Vec&amp;lt;f32&amp;gt;，假如 I 被实例化为 LinkedList，那么这个函数的类型就被实例化成了 LinkedList&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;。但是这个设计有许多问题，下面逐一分析。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;高阶trait约束&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Rust泛型的类型检查，是在泛型函数、类型定义的时候当场检查的，而不是等到实例化的时候才检查。所以，对于上面这个泛型函数，我们一定需要对它指定合理的约束条件，否则类型 I&amp;lt;i32&amp;gt; 什么都干不了。&lt;/p&gt;&lt;p&gt;假设我们定义下面这样的一个 trait，来对 Vec 和 LinkedList 做一个统一抽象：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;Item&amp;gt; {
    fn empty() -&amp;gt; Self;
    fn add(&amp;amp;mut self, value: Item);
    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; Self::Iter&amp;lt;&#39;iter&amp;gt;;
    type Iter: Iterable&amp;lt;Item&amp;gt;;
}&lt;/code&gt;&lt;p&gt;然后，对上面那个泛型函数添加高阶类型约束条件：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
    where for&amp;lt;T&amp;gt; I&amp;lt;T&amp;gt;: Collection&amp;lt;T&amp;gt;&lt;/code&gt;&lt;p&gt;看起来这个 higher kinded trait bounds 的设计很合理。但是，我们注意到 Haskell 中是不存在 higher kinded trait bounds 这种东西的，它一定是因为某种原因而没有这样设计。所以 Haskell 里面只能这么写，把各种可能性枚举出来：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
    where I&amp;lt;i32&amp;gt;: Collection&amp;lt;i32&amp;gt;,
          I&amp;lt;f32&amp;gt;: Collection&amp;lt;f32&amp;gt;&lt;/code&gt;&lt;p&gt;如果只能用这样的写法呢，是会有问题的。某些情况下，会造成“抽象泄漏”。比如说，像下面这样一个函数：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn process&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(inputs: &amp;amp;I&amp;lt;Input&amp;gt;) -&amp;gt; I&amp;lt;Output&amp;gt;
    where I&amp;lt;Input&amp;gt;: Collection&amp;lt;Input&amp;gt;, I&amp;lt;Output&amp;gt;: Collection&amp;lt;Output&amp;gt;,
{
    struct MyType { ... }

    ...
}&lt;/code&gt;&lt;p&gt;如果这个函数内部定义了一个类型，这个函数的输出类型是 I&amp;lt;MyType&amp;gt;。那我们的这个泛型约束就很难写出来，除非把 MyType 定义到这个函数外边。本来我们希望封装到内部的类型，被迫暴露出去了，这就是抽象泄漏。&lt;/p&gt;&lt;p&gt;对 Haskell 来说，这好像是一个比较常见的问题。随手搜索了一下，看起来 Haskell 的解决方案是使用 &lt;a href=&quot;https://stackoverflow.com/questions/25422342/arbitrary-class-constraints-when-implementing-type-classes-in-haskell&quot;&gt;TypeFamily&lt;/a&gt;。这也是Rust设计组准备采用的方案。&lt;/p&gt;&lt;p&gt;在 Scala 中，如何表达任意的高阶类型约束不清楚，希望有网友能告知。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;高阶Self类型&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在前面，我们定义了一个trait Collection&amp;lt;T&amp;gt;，它的成员类型是 T。因此我们可以对不同的容器写这样的 impl：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl&amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt; {}
//                        ^^ this is a type&lt;/code&gt;&lt;p&gt;在这个impl块中，我们针对的是 Vec&amp;lt;T&amp;gt; 来实现的，它的kind是 type。如果我们要支持高阶类型，那么我们应该支持针对kind为 type-&amp;gt;type 的类型impl。我们现在更进一步，如果我们想定义一个高阶trait，怎么办？意思是，impl 的时候 for 后面的那个目标如果是“类型构造器”的话，是什么情况。假设我们这么设计：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait HkCollection for Self&amp;lt;_&amp;gt; {
//    ^^               ^^^^^^^ declare that `Self` is a type constructor
//    stands for &quot;higher-kinded&quot;

    fn empty&amp;lt;T&amp;gt;() -&amp;gt; Self&amp;lt;T&amp;gt;;
    fn add&amp;lt;T&amp;gt;(self: &amp;amp;mut Self&amp;lt;T&amp;gt;, value: T);
    //    ^^^ the `T` effectively moved from the trait to the methods
    ...
}

impl HkCollection for Vec&amp;lt;_&amp;gt; {
//                    ^^ this is a type constructor
    fn empty&amp;lt;T&amp;gt;() -&amp;gt; Vec&amp;lt;T&amp;gt; {
        Vec::new()
    }
    ...
}&lt;/code&gt;&lt;p&gt;如果有了这样的东西，那么我们可以针对任何一个类型构造器 I，写这样的约束条件 where I: HkCollection，而不需要写 where for&amp;lt;T&amp;gt; I&amp;lt;T&amp;gt;: Collection&amp;lt;T&amp;gt;，因为我们的 HkCollection 是作用到类型构造器上的。&lt;/p&gt;&lt;p&gt;这个设计看起来很不错，但它有非常巨大的缺陷。比如，它无法针对 BitSet 这样的容器 impl。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl HkCollection for BitSet {}
//                    ^^ not a type constructor&lt;/code&gt;&lt;p&gt;另外一个问题是，有些容器，它对内部元素的类型是有约束条件的。比如 HashSet&amp;lt;T&amp;gt;，它要求 T: Hash 条件。在上面这个设计中，像 Self&amp;lt;_&amp;gt; 这样的设计，实际上没有办法约束 _ 应该满足什么条件：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait HkCollection for HashSet&amp;lt;_&amp;gt;
//                     ^^^^^^^ how can we restrict `_` to `Hash` types?&lt;/code&gt;&lt;p&gt;Haskell 的 HKT 似乎是可以应用到任意类型上的，无法指定约束条件。但是在Rust里面，约束条件无处不在，我们如果选择 Foo&amp;lt;_&amp;gt; 这样的设计，那么一定要想个办法来写清楚 _ 的约束条件。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;类型推断&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注意到前面我们说过的，Rust的一个特殊之处在于，它的泛型参数有两种 kind，分别是 type 和 lifetime。假如我们有这样的一个类型：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct ListIter&amp;lt;&#39;iter, T&amp;gt; { ... }&lt;/code&gt;&lt;p&gt;那么，一个完整的 ListIter&amp;lt;&#39;a, T&amp;gt; 它的 kind 是 type，而 ListIter 它的 kind 可以看作 (lifetime, type)-&amp;gt;type。如果我们定义一个类型 type I&amp;lt;&#39;_&amp;gt; = ListIter&amp;lt;&#39;_, i32&amp;gt;，那么 I 的 kind 就是 lifetime-&amp;gt;type。高阶类型内部还可以嵌套，比如 G&amp;lt;_&amp;lt;_&amp;gt;&amp;gt;，那么这个 G 的 kind 就是 (type-&amp;gt;type)-&amp;gt;type。这种设计可以让你把“类型”当成“函数”来看待，有些类型本身接受类型参数，然后生成新的类型。但是，它还有个缺陷是，影响了类型推断 type inference。我们来看这个例子：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;&lt;/code&gt;&lt;p&gt;这里的类型参数 I 的 kind 是 type-&amp;gt;type。这个函数的目的是，把一个容器内部的元素从 i32 转成 f32（Vec&amp;lt;i32&amp;gt; -&amp;gt; Vec&amp;lt;f32&amp;gt; 或者 LinkedList&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;，而不是 Vec&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;）。那么，现在这个类型推断就会出问题了，即便我们已经知道了具体的实参类型和返回值类型，我们还是解不出来这个 I 是什么。&lt;/p&gt;&lt;p&gt;这个问题实际上是这样的，I 实际上是一个“函数”，它输入一个 type，输出一个 type。现在我们可以从实参类型，得到它的其中一个输入以及对应的输出 I&amp;lt;i32&amp;gt; == Vec&amp;lt;i32&amp;gt;。我们还可以从返回类型，得到它的另外一个输入以及对应的输出 I&amp;lt;f32&amp;gt; == Vec&amp;lt;f32&amp;gt;。请问现在这个 I 是什么。这个问题类似于：假设 f(1) == 2 且 f(2) == 3，求函数 f 是什么。这个问题没有“唯一”解。当然，如果我们假设 f 一定是一阶函数，那么我们可以求出来 f(x) = x + 1，但是没有这个条件的情况下就难说了。&lt;/p&gt;&lt;p&gt;Haskell 是没有这个问题的，这是因为 Haskell 限制了泛型参数的应用顺序，即所谓的 Currying。在Rust中没有 Currying，这意味着 Vec&amp;lt;_&amp;gt; 的kind 是 type-&amp;gt;type，Result&amp;lt;_, i32&amp;gt; 的kind是 type-&amp;gt;type，Result&amp;lt;i32, _&amp;gt; 的kind也是 type-&amp;gt;type。所以，假设我们有下面这样一个方程求解：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;?1&amp;lt;?2&amp;gt; = Result&amp;lt;i32, u32&amp;gt;&lt;/code&gt;&lt;p&gt;那么 ?1 = Result&amp;lt;i32, _&amp;gt;, ?2 = u32 或者 ?1 = Result&amp;lt;_, u32&amp;gt;, ?2 = i32，都是这个方程的解。&lt;/p&gt;&lt;p&gt;Rust是不能采用Currying的设计的。第一个原因是它有两种基本的 kind。比如说我们有个类型 Iterable&amp;lt;&#39;a, T&amp;gt;，按Haskell的观点，它的 kind 可以写成 lifetime -&amp;gt; type -&amp;gt; type（实际上它还要求 T: &#39;a，这个就更复杂了先忽略）。我们希望给它一个指定的 T，那么它的kind就会变成 lifetime -&amp;gt; type。但是Currying是不允许这样的，参数是按顺序的，你必须先指定一个固定的lifetime，让它的kind变成 type-&amp;gt;type。&lt;/p&gt;&lt;p&gt;Rust不采用Currying的第二个原因是，在实际中有些类型不是按顺序应用泛型参数的。比如我们的 HashMap 类型，它有三个泛型参数：pub struct HashMap&amp;lt;K, V, S = RandomState&amp;gt;，我们可能希望有一个类型构造器是这样的 M = HashMap&amp;lt;_, _, S&amp;gt;，但是用 Currying 是得不到的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;ATC&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;前面讲了很多为什么不在Rust中直接支持HKT的理由。接下来我们回到正题，说一说这个RFC究竟是一个什么样的提案。从这个提案的名字上，我们就可以看出一点端倪，它叫做 generic associated types (泛型关联类型)，或者叫做 associated type constructors (关联类型构造器)。它的实质就是，允许trait里面的“关联类型”成为“类型构造器”。比如说：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Iterable {
    type Item&amp;lt;&#39;a&amp;gt;; // 注意它携带泛型参数
    // Item 的 kind 是 lifetime -&amp;gt; type
}

trait Foo {
    type Bar&amp;lt;T&amp;gt;;  // 泛型参数可以是生命周期，可以是类型
    // Bar 的 kind 是 type -&amp;gt; type
}&lt;/code&gt;&lt;p&gt;语法上非常简单，就是这么一个小小的扩展。我们来看看在这个功能基础上，怎么设计本文前面的那个 floatify 函数。首先我们当然需要一个 trait，来统一抽象我们的容器类型：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;T&amp;gt; {
    fn empty() -&amp;gt; Self;
    fn add(&amp;amp;mut self, value: T);
    fn iterate(&amp;amp;self) -&amp;gt; Self::Iter;
    type Iter: Iterator&amp;lt;Item=T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;假设我们有一个具体容器，名字叫做 List&amp;lt;T&amp;gt;，我们针对这个类型，实现这个 trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl&amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; for List&amp;lt;T&amp;gt; {
    fn empty() -&amp;gt; List&amp;lt;T&amp;gt; {
        List::new()
    }

    fn add(&amp;amp;mut self, value: T) {
        self.prepend(value);
    }

    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; ListIter&amp;lt;&#39;iter, T&amp;gt; {
        self.iter()
    }

    type Iter = ListIter&amp;lt;&#39;iter, T&amp;gt;;
    //                   ^^^^^ oh, wait, this is not in scope!
}&lt;/code&gt;&lt;p&gt;从这里我们看到了问题所在，在写最后的关联类型的时候，我们发现，这个生命周期参数没法写。这时候，就该ATC这个功能出场了。我们可以让这个关联类型不是一个具体类型，而是一个“类型构造器”，它的 kind 为 lifetime-&amp;gt;type，这样我们可以让它在各种场合下，针对不同的生命周期，生成合适的类型。修改 trait 的设计如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;T&amp;gt; {
    // as before
    fn empty() -&amp;gt; Self;
    fn add(&amp;amp;mut self, value: T);

    // Here, we use associated type constructors:
    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; Self::Iter&amp;lt;&#39;iter&amp;gt;;
    type Iter&amp;lt;&#39;iter&amp;gt;: Iterator&amp;lt;Item=T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;注意这个语法，有点容易混淆，这个关联类型 Iter 在声明的时候有个参数，就代表它是“类型构造器”，在 iterator 方法返回的时候，我们要给 Iter 一个合适的参数，它才能生成具体的类型。我们对具体类型来impl这个trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;use std::slice;
impl&amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt; {
    fn empty() -&amp;gt; Self { vec![] }
    fn add(&amp;amp;mut self, value: T) { self.push(value); }
    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; slice::Iter&amp;lt;&#39;self, T&amp;gt; { self.iter() }
    type Iter&amp;lt;&#39;iter&amp;gt; = slice::Iter&amp;lt;&#39;iter, T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;那么，用这样的一个 trait，我们就可以实现最开始的那个函数了：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify&amp;lt;I, F&amp;gt;(ints: &amp;amp;I) -&amp;gt; F
    where I: Collection&amp;lt;i32&amp;gt;, F: Collection&amp;lt;f32&amp;gt;
{
    let mut floats = F::empty();
    for &amp;amp;f in c.iterate() {
        floats.add(f as f32);
    }
    floats
}&lt;/code&gt;&lt;p&gt;这个函数是可以工作的。但是，它有一个缺点，那就是，不仅可以支持 Vec&amp;lt;i32&amp;gt; -&amp;gt; Vec&amp;lt;f32&amp;gt; 还可以支持 Vec&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn test(x: &amp;amp;Vec&amp;lt;i32&amp;gt;) {
    let y: Vec&amp;lt;f32&amp;gt; = floatify(x); // 可以通过
    let z: LinkedList&amp;lt;f32&amp;gt; = floatify(x); // 可以通过
    let p = floatify(x); // 编译错误，p 的类型无法推断
}&lt;/code&gt;&lt;p&gt;所以，这个实现依然不是我们想要的东西，我们想要的是类似这样的函数：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 输入和输出是同样的容器类型
fn floatify_hkt&amp;lt;I&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
//                        ^^^^^^ wait up, what is `I` here?&lt;/code&gt;&lt;p&gt;接下来，我们要用一种“设计模式”，叫做 type family（也是从 Haskell 学的）。我们另外定义一个trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait CollectionFamily {
    // Member 也是一个 type constructor
    type Member&amp;lt;T&amp;gt;: Collection&amp;lt;T, Family = Self&amp;gt;;
}&lt;/code&gt;&lt;p&gt;针对具体类型 Vec 和 List 实现这个trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct VecFamily;

impl CollectionFamily for VecFamily {
    type Member&amp;lt;T&amp;gt; = Vec&amp;lt;T&amp;gt;;
}

struct ListFamily;

impl CollectionFamily for ListFamily {
    type Member&amp;lt;T&amp;gt; = List&amp;lt;T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;并且在原先的 Collection 中，再添加一个关联类型，指向 family：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;T&amp;gt; {
    // Backlink to `Family`.
    type Family: CollectionFamily;
    ...&lt;/code&gt;&lt;p&gt;接下来，我们用这个 CollectionFamily 来重新实现 floatify:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_family&amp;lt;C&amp;gt;(ints: &amp;amp;C) -&amp;gt; C::Family::Member&amp;lt;f32&amp;gt;
    where C: Collection&amp;lt;i32&amp;gt;
{
    let mut floats = C::Family::Member&amp;lt;f32&amp;gt;::empty();
    for &amp;amp;f in c.iterate() {
        floats.add(f as f32);
    }
    floats
}&lt;/code&gt;&lt;p&gt;上面这个设计圆满了，它满足了我们所有的需求。注意上面我们用到了针对 ATC 的约束：type Member&amp;lt;T&amp;gt;: Collection&amp;lt;T, Family = Self&amp;gt;;，它代表的真实含义实际上是：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;for&amp;lt;T&amp;gt; Self::Member&amp;lt;T&amp;gt;: Collection&amp;lt;T, Family = Self&amp;gt;;&lt;/code&gt;&lt;p&gt;所以，我们也同时做到了针对高阶类型的约束。ATC 这个设计，语法改动小，基本是现有语法的一个自然延伸，而且可以完成高阶类型的功能，非常契合Rust当前的状态，相比而言，直接支持高阶类型语法不是一个好的选择。&lt;/p&gt;&lt;p&gt;目前，Rust编译器里面关于trait的逻辑很乱，还有一些难以修复的bug。因此，niko开了一个新项目 &lt;a href=&quot;https://github.com/nikomatsakis/chalk&quot;&gt;https://github.com/nikomatsakis/chalk&lt;/a&gt;，重写整个trait系统。在这个新的架构下，ATC功能基本是水到渠成顺手就做了的事情。所以，只要等 chalk 什么时候合并到正式编译器里面，用户就可以使用这个功能了，目测2017年有点悬，2018年肯定能实现。&lt;/p&gt;&lt;p&gt;高阶类型的出现，很可能可以解锁一些以前难以实现的问题，这还需要社区做更多的探索。比如，最近就有人提到，Generator 生成器最好是基于ATC来实现，否则有些场景下会出现编译错误，限制用户的发挥，参考 &lt;a href=&quot;https://internals.rust-lang.org/t/streaming-generators/5850&quot;&gt;https://internals.rust-lang.org/t/streaming-generators/5850&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;很长一段时间以来，编程语言界出现了一大批换汤不换药的新语言，它们基本上都在朝一个方向努力，即降低开发难度。Rust偏偏剑走偏锋，主打底层和安全，是一个非常精明的举措。细看Rust的设计，其实也没有什么是独特的创新的，不论语法、安全、抽象、优化等等各方面，都有前人有过充分的研究和探讨。但是Rust设计组把它们组合起来，却进入了一个全新的境界，这应该是第一个把底层控制力、安全性、高级抽象能力各方面做得最平衡的一门语言。既面向底层，又有高级类型系统，恰好市面上没有竞争对手。&lt;/p&gt;&lt;p&gt;随着接下来 const generic 等 RFC 陆续设计完成，Rust在类型系统上的能力还会大幅提高。既要有高阶抽象能力，又要高性能，看起来并不是不可能完成的任务，不是么？或许在这个领域内，以后还会有其它更优秀的语言出现，但这没关系，方向已经指明，前途已经明朗，基础已经铺就，Rust证明了安全性、高级抽象能力、底层控制力，并非水火不相容。&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-09-03-29021140</guid>
<pubDate>Sun, 03 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>协程 Coroutine</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-07-15-27900879.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;协程 Coroutine&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27900879&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近，Rust语言有一个大进展，即将实现在 nightly 版本中加入了实验性质的协程支持。RFC 参见 https://github.com/rust-lang/rfcs/blob/master/text/2033-experimental-coroutines.md ，与此相关的最重要的 PR 在此 https://github.com/rust-lang/rust/pull/43076 。这个功能一向能吸引大量的关注，相关讨论极其热烈，它受欢迎的程度可见一斑。&lt;/p&gt;&lt;p&gt;协程这个概念在许多编程语言中都已经有了大量实践，Rust在这方面也做过好几次尝试。早在 1.0 之前，就有一个 Green Thread 的实现，但是因为各种原因，在正式稳定版发布之前，还是删除掉了。最近新设计的版本与 Green Thread 不一样，它是一种 stackless coroutine 的实现，对 runtime 的要求更小，更适合Rust的定位。&lt;/p&gt;&lt;p&gt;为了讲清楚协程 Coroutine，就需要先讲 Generator，而讲 Generator 之前，我们先讲迭代器 Iterator。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Iterator&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 Rust 中，迭代器指的是，实现了 std::iter::Iterator trait 的类型：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub trait Iterator {

   type Item;

   fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;;

   ...
}&lt;/code&gt;&lt;p&gt;这个 trait 最主要的一个方法，就是这个 next 方法，每次调用，它就返回下一个元素，迭代完成，就返回 None。使用方法基本类似这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 假设 it 是一个迭代器变量
while let Some(item) = it.next() {
   do_something(item);
}&lt;/code&gt;&lt;p&gt;next 方法接受的参数是 &amp;amp;mut Self 类型，因为它每次调用的时候，一般都要修改内部的状态，如果内部是指针，就需要把指针指向容器的下一个元素；如果内部是索引，就需要更新索引的值。&lt;/p&gt;&lt;p&gt;迭代器也可以不指向任何容器，只要它满足 Iterator trait 这个接口即可，比如 std::ops::Range 这个类型，它代表一个前闭后开的区间，它也可以进行迭代，只是每次调用 next 后它代表的区间就变了，只有这样才能保证下次调用 next 的时候返回的不是同一个值。&lt;/p&gt;&lt;p&gt;现在我们写一个简单的迭代器示例，来源于rust by example，稍做修改，一个能生成 fibonacci 数列的迭代器。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 方案一
struct Fibonacci {
   curr: u64,
   next: u64,
}

impl Iterator for Fibonacci {
   type Item = u64;

   fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;u64&amp;gt; {
       // 判断是否会溢出
       let new_next = self.curr.checked_add(self.next);

       if let Some(new_next) = new_next {
           // 先更新内部状态，再返回
           self.curr = self.next;
           self.next = new_next;
           Some(self.curr)
       } else {
           // 加法溢出，停止迭代
           None
       }
   }
}

fn fibonacci() -&amp;gt; Fibonacci {
   Fibonacci { curr: 1, next: 1 }
}

fn main() {
   let mut it = fibonacci();

   while let Some(i) = it.next() {
       println!(&quot;{}&quot;, i);
   }
}&lt;/code&gt;&lt;p&gt;请读者逐行逐字读一下 next 方法的逻辑，理解清楚它是如何记录状态的，为什么每次调用 next 方法都会返回不同的值。这个示例在后文中还会继续使用。&lt;/p&gt;&lt;p&gt;上面这个例子是个特殊情况，迭代器并没有指向某个容器，它本身就包含了所有生成数据所需要的所有信息。其它情况下，一个迭代器可以跟一个容器相关联，数据是从容器中取出来的，迭代器本身只记录和更新所指向的位置。&lt;/p&gt;&lt;p&gt;迭代器模式是一种典型的“拉”模式，它也经常被称为“惰性求值”(lazy evaluation)。如果你只是创建一个迭代器，这个开销是非常小的，只有在调用 next 方法时，才会真正去处理数据。除了 next 方法之外，迭代器还提供了许多其它有用的方法，这些方法可以分为两个类别：adapter 和 consumer。adapter 类别的方法是，从一个迭代器，生成一个新的迭代器，而不去真正的处理数据；而 consumer 类别的方法会直接或间接调用 next 方法，把数据拉出来消费掉。&lt;/p&gt;&lt;p&gt;比如，map 方法就是一个典型的 adapter：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let v1: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3];
let it = v1.iter().map(|x| x + 1);&lt;/code&gt;&lt;p&gt;如果我们后面不写别的代码，it 这个变量实际上啥事没干，被构造出来之后就被扔掉了，它并没有去遍历容器 v1 的数据，并把每个元素加1。我们要让它起作用，就必须调用 next 方法或者 consumer 方法，比如典型的 collect 以及 for_each。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Generator&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;迭代器这种写法，需要自己管理状态，所以在写之前就要自己理清楚，哪些状态应该放到成员变量里面，哪些状态不需要；在实现 next 方法的时候，要如何读取上次的状态，如何更新状态，等等。而作为对比，生成器(generator)这种新的写法，通过引入一个新的关键字 yield，使得整个逻辑又变成了简洁顺序的执行流程。&lt;/p&gt;&lt;p&gt;下面还是用同样的示例，来演示一下，如何用生成器来写上文中这个 fibonacci 数列：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 方案二
#![feature(generators, generator_trait)]

use std::ops::{Generator, State};

fn main() {
   let mut generator = || {
       let mut curr : u64 = 1;
       let mut next : u64 = 1;
       loop {
           let new_next = curr.checked_add(next);

           if let Some(new_next) = new_next {
               curr = next;
               next = new_next;
               yield curr; // &amp;lt;-- 新的关键字
           } else {
               return;
           }
       }
   };

   loop {
       match generator.resume() {
           State::Yielded(v) =&amp;gt; println!(&quot;{}&quot;, v),
           State::Complete(_) =&amp;gt; return,
       }
   }
}&lt;/code&gt;&lt;p&gt;这个 generator 变量不是一个普通的闭包，它是一个生成器，主要区别在于，它里面用了一个新的关键字 yield。跟closure类似的地方在于，编译器同样会为它生成一个匿名结构体，并实现一些 trait，添加一些成员方法。跟 closure 不同的地方在于，它的成员变量不一样，它实现的 trait 不一样。它的使用方式是，调用 resume 成员方法，这个方法的返回值有两种状态，一个是 Yielded 表示生成器内部 yield 关键字返回出来的东西，此时你还可以继续调用 resume，还有数据可以继续生成出来；另一个是 Complete 状态，表示这个生成器已经调用完了，它的值是内部的 return 关键字返回出来的东西，此时你不能再继续调用 resume，否则会触发 panic。&lt;/p&gt;&lt;p&gt;这个 generator 和上面方案一的迭代器效果是一模一样的，那为什么要专门设计这样的一个语法，还要引入一个新关键字呢？因为这种写法相比迭代器的写法更接近人的思维模型，代码流程是清晰的，中间状态的管理丢给了编译器，而不是人工管理。&lt;/p&gt;&lt;p&gt;实际上，迭代器模式，从代码组织逻辑上，已经是相对高阶一点的写法。对于一个刚刚接触过编程的初学者来说，用下面这种写法才是最常见的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 方案三
fn collector() -&amp;gt; Vec&amp;lt;u64&amp;gt; {
   let mut res = vec![];
   let mut curr : u64 = 1;
   let mut next : u64 = 1;
   loop {
       let new_next = curr.checked_add(next);

       if let Some(new_next) = new_next {
           curr = next;
           next = new_next;
           res.push(curr);
       } else {
           break;
       }
   }
   return res;
}

fn main() {
   let collected = collector();
   let mut it = collected.iter();
   while let Some(i) = it.next() {
       println!(&quot;{}&quot;, i);
   }
}&lt;/code&gt;&lt;p&gt;不考虑“惰性求值”带来的好处，相比迭代器写法，其实方案三这种流程控制方式是更符合普通人的“直觉”的。但它有性能上的缺点，方案三提前把数据收集起来了，缺少了灵活性。如果使用者 main 函数只需要使用前 10 个数据呢？如果是方案一迭代器那种写法，使用者可以选择遍历了 10 个元素后就提前 break；后面的数据既不需要生产，也不需要消费，这就是“惰性求值”的好处，还节省了一个临时的占用很大内存空间的容器。如果我们把方案三改成方案一迭代器的写法，性能和灵活性更佳，但是我们需要人工推理，有哪些数据是需要存储在迭代器成员中的，有哪些是不需要的，进入 next 方法时如何读取上一次的状态，退出 next 方法时如何保存这一次的状态，这些都是“心智负担”。业务逻辑越复杂，这个负担越严重。想象一下，如果我们的需求再增加一点，fibonacci 数列增长到溢出之时，继续让这个序列生成数字，规则变为对前一个数字不断除以2，最终数字降到1时，再按 fibonacci 规则涨上去，循环往复，永不停止。你再试试用上面不同的风格写写看看，哪个简单，哪个复杂。&lt;/p&gt;&lt;p&gt;而方案二生成器这种写法，就结合了方案一和方案三两者的优点。从源码的表现形式上，它的流程控制是简洁的，不需要程序员手工去管理状态的保存和恢复。同时它也具备“惰性求值”的优点，它依然需要用户主动调用 resume 方法往外“拉”数据。main 函数每次调用到 resume 方法，流程就进入到了 generator 内部，每执行到 yield 语句，流程就又跳回到了 main 函数里面。如果我们把 main 函数和 generator 做的事情视为两个“任务”，这两个任务就是在交替执行，yield 关键字和 resume 方法就是在执行任务切换。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Coroutine&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;终于讲到了 Coroutine。Coroutine 主要是设计用来写异步执行的代码的。首先还是看一下如果没有 coroutine，异步执行的代码是如何抽象的，然后再看看 coroutine 是如何简化代码的。&lt;/p&gt;&lt;p&gt;在这方面，目前Rust的准官方的一个库是 futures-rs，类似的东西在其它许多语言中都有，有的取名为 future，有的取名为 promise，都是差不多的东西。这个库里面最核心的部分是这个 trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub trait Future {
   type Item;
   type Error;
   fn poll(&amp;amp;mut self) -&amp;gt; Poll&amp;lt;Self::Item, Self::Error&amp;gt;;
   ......
}&lt;/code&gt;&lt;p&gt;它里面最重要的一个方法是 poll，这个方法的返回类型是这样的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;type Poll&amp;lt;T, E&amp;gt; = Result&amp;lt;Async&amp;lt;T&amp;gt;, E&amp;gt;;

pub enum Async&amp;lt;T&amp;gt; {
   Ready(T),
   NotReady,
}&lt;/code&gt;&lt;p&gt;对于一个实现了 Future Trait 的类型，每次调用这个 poll 方法，其实就是查看一下这个对象当前的状态是什么，可以是错误／正在执行／已经执行完毕。Future trait 里面还有一些其它的方法，其实跟 Iterator / Generator 类似，也可以分为两组，adapter 和 consumer。Adapter(或者叫 combinator) 是从一个 Future 生成一个新的 Future，比如 map, and_then, join 等等都是，consumer 就是最终的结果的消费者，比如 wait 方法。&lt;/p&gt;&lt;p&gt;所以最后代码组织起来，其实是一层层的 Future 类型不断嵌套，外层的 Future 的 poll 方法被调用的时候，它就会调用内层 Future 的 poll 方法。一般来说，用 future 风格写的异步程序，会有一个主事件循环，这个循环就是最外层的 Future 的驱动力。每个新创建的 Future 都会进入到一个事件列表中，主循环不断调用每个 Future 的 poll 方法，就完成了整个程序的构建。&lt;/p&gt;&lt;p&gt;下面我们看一下，如果基于 coroutine 写程序，看起来会是什么样子（源于RFC中的示例）：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;/// 以后 async await 可能会变成关键字，目前还是宏实现，但是没什么大影响
#[async]
fn print_lines() -&amp;gt; io::Result&amp;lt;()&amp;gt; {
   let addr = &quot;127.0.0.1:8080&quot;.parse().unwrap();
   let tcp = await!(TcpStream::connect(&amp;amp;addr))?;
   let io = BufReader::new(tcp);

   #[async]
   for line in io.lines() {
       println!(&quot;{}&quot;, line);
   }

   Ok(())
}&lt;/code&gt;&lt;p&gt;在 Rust 中，attribute 也是一种“宏”，它具备跟宏一样的生成代码的能力。#[async] 这个 attribute 的作用就是把函数签名统一用 Future 类型包起来。比如原先的签名是 fn() -&amp;gt; Result&amp;lt;String, ()&amp;gt;，加上 #[async] 后，函数签名实际上变成了 fn() -&amp;gt; impl Future&amp;lt;Item=String, Error=()&amp;gt;。注意C#的设计不同，async 关键字只有修饰作用，不改签名。而 await! 这个宏，它就是很简单的调用 Future 的 poll 方法，如果还没有执行完毕，就用 yield 关键字返回，让主线程继续尝试其它 Future，如果碰到一个 Future 刚好执行完毕，那么我们可以从上次返回的那个点，继续往下执行。上面这段代码展开后类似这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn print_lines() -&amp;gt; impl Future&amp;lt;Item = (), Error = io::Error&amp;gt; {
   GeneratorToFuture(|| {
       let addr = &quot;127.0.0.1:8080&quot;.parse().unwrap();
       let tcp = {
           let mut future = TcpStream::connect(&amp;amp;addr);
           loop {
               match future.poll() {
                   Ok(Async::Ready(e)) =&amp;gt; break Ok(e),
                   Ok(Async::NotReady) =&amp;gt; yield, // 中断当前代码
                   Err(e) =&amp;gt; break Err(e),
               }
           }
       }?;

       let io = BufReader::new(tcp);

       let mut stream = io.lines();
       loop {
           let line = {
               match stream.poll()? {
                   Async::Ready(Some(e)) =&amp;gt; e,
                   Async::Ready(None) =&amp;gt; break,
                   Async::NotReady =&amp;gt; {
                       yield;                    // 中断当前代码
                       continue
                   }
               }
           };
           println!(&quot;{}&quot;, line);
       }

       Ok(())
   })
}&lt;/code&gt;&lt;p&gt;上面这个 GeneratorToFuture 方法是把一个 Generator 转为一个 Future，这个方法可以很轻松的实现，此处就不详细展开了。&lt;/p&gt;&lt;p&gt;如果不用async/await语法糖，代码很可能像这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn print_lines() -&amp;gt; impl Future&amp;lt;Item = (), Error = io::Error&amp;gt; {
   lazy(|| {
       let addr = &quot;127.0.0.1:8080&quot;.parse().unwrap();
       TcpStream::connect(&amp;amp;addr).and_then(|tcp| {
           let io = BufReader::new(tcp);

           io.lines().for_each(|line| {
               println!(&quot;{}&quot;, line);
               Ok(())
           })
       })
   })
}&lt;/code&gt;&lt;p&gt;Future 可以用各种 adapter 不断组合起来，一样可以实现同样的功能。但是跟上文中的对比一样，这么写跟 async/await 的区别，就跟手写 Iterator 和 Generator 之间的区别一样。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果顺利的话，这个 feature 可能在一两周之内就能在 nightly 版本上让大家试用了，这个功能应该可以大幅提高Rust异步编程的用户友好度，对于Rust在服务器端的推广有重大意义。我们非常期望能看到Rust编写的网络服务与其它竞争对手之间的详细的性能对比。再加上Rust与生俱来的接近C语言的高性能特点，这应该是工业界中无GC的编程语言的coroutine的最佳实现之一。相比之下，C++的 coroutine 早在几年前就有提案，但是进展嘛，一声叹息。另外，coroutine 还有一种 stackful 风格的实现方式(比如Go语言)，stackless vs stackful的对比也相当令人关注。&lt;/p&gt;&lt;p&gt;相信在半年之内就会有相当多的实践数据出现。Rust 设计组也非常希望能推动这个功能在 2018 年初的时候进入稳定版，这个功能为Rust在服务器领域的优质框架打下了坚实基础，对Rust在工业界的实际应用推广有重大意义。&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-07-15-27900879</guid>
<pubDate>Sat, 15 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust真难啊</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-06-17-27438530.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Rust真难啊&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27438530&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近Rust社区又发现了一个隐藏得很深的违反了“内存安全”的bug。Bug描述见此处：&lt;a href=&quot;https://github.com/rust-lang/rust/issues/41622&quot; data-editable=&quot;true&quot; data-title=&quot;MutexGuard&amp;lt;Cell&amp;lt;i32&amp;gt;&amp;gt; must not be Sync · Issue #41622 · rust-lang/rust&quot;&gt;MutexGuard&amp;lt;Cell&amp;lt;i32&amp;gt;&amp;gt; must not be Sync · Issue #41622 · rust-lang/rust&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;这个问题是这样的，观察这样的一段程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::sync::Mutex;
use std::cell::Cell;

extern crate rayon;

fn main()
{
    let m = Mutex::new(Cell::new(0));
    let g = m.lock().unwrap();
    {
        rayon::join(
            || { g.set(g.get() + 1); println!(&quot;Thread 1: {:?}&quot;, g.get()) },
            || { g.set(g.get() + 1); println!(&quot;Thread 2: {:?}&quot;, g.get()) });
    }
}

&lt;/code&gt;&lt;p&gt;这里用到了 &lt;a href=&quot;https://github.com/nikomatsakis/rayon&quot; data-editable=&quot;true&quot; data-title=&quot;rayon&quot;&gt;rayon&lt;/a&gt; 这个库，来实现并行执行的功能。join 函数接受了两个参数，分别是两个闭包，rayon会自动将它们分配到线程池中，选择合适的线程来执行它们。问题是，在这俩闭包访问了共享变量g，而它们俩内部，根本没有做任何线程同步。也就是说，这里有线程不安全的情况。&lt;/p&gt;&lt;p&gt;如果大家还没理解是什么意思，我们再用以前经常使用的一个示例来演示，两个线程修改同一个变量：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;extern crate scoped_threadpool;
use scoped_threadpool::Pool;
use std::sync::Mutex;
use std::cell::Cell;

const COUNT: u32 = 1000000;

fn main() {
    // Create a threadpool holding 4 threads
    let mut pool = Pool::new(4);

    let m = Mutex::new(Cell::new(0_i64));
    let g = m.lock().unwrap();

    pool.scoped(|scoped| {
        let g1 = &amp;amp;g;
        scoped.execute(move ||{
            for _ in 0..COUNT {
                g1.set(g1.get() + 1);
            }
        });
        let g2 = &amp;amp;g;
        scoped.execute(move ||{
            for _ in 0..COUNT {
                g2.set(g2.get() - 1);
            }
        });
    });

    println!(&quot;{}&quot;, g.get());
}

&lt;/code&gt;&lt;p&gt;用目前的稳定版编译，没问题：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;rustc -V
rustc 1.18.0 (03fc9d622 2017-06-06)

&lt;/code&gt;&lt;p&gt;但是，执行起来就会发现，这个变量的值最终没有回到0，每次执行结果都不一样。这说明两个线程之间确实没有做好同步。按照 rust 给我们的保证，只要我们自己不乱用 unsafe，“内存不安全”和“线程不安全”的代码就根本不应该编译通过。可惜的是，我们还是发现了这样的安全漏洞。&lt;/p&gt;&lt;p&gt;用目前最新的 nightly 版本编译，发现编译错误：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;error[E0277]: the trait bound `std::cell::Cell&amp;lt;i64&amp;gt;: std::marker::Sync` is not satisfied

&lt;/code&gt;&lt;p&gt;因为这个 bug 在最新的 nightly 版本上修复了，编译器正确地拒绝了这段代码编译通过。&lt;/p&gt;&lt;h2&gt;原因分析&lt;/h2&gt;&lt;p&gt;join 函数的签名是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub fn join&amp;lt;A, B, RA, RB&amp;gt;(oper_a: A, oper_b: B) -&amp;gt; (RA, RB)
where
    A: FnOnce() -&amp;gt; RA + Send,
    B: FnOnce() -&amp;gt; RB + Send,
    RA: Send,
    RB: Send,

&lt;/code&gt;&lt;p&gt;execute 函数的签名是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn execute&amp;lt;F&amp;gt;(&amp;amp;self, f: F)
where
    F: FnOnce() + Send + &#39;scope,

&lt;/code&gt;&lt;p&gt;它们都要求闭包参数满足 Send 约束。按照 Send 的定义，这是非常合理的条件。如果一个类型满足 Send，那么把它 move 到其它线程中一定是安全的。所以，rayon 或者 scoped_threadpool 这两个库的设计是没什么问题的。那么bug的原因只剩下一种可能性：我们把不该标记为 Send 的类型给错误地标成了 Send。&lt;/p&gt;&lt;p&gt;这个错误出现在 MutexGuard&amp;lt;T&amp;gt; 这个类型上。它是 Mutex&amp;lt;T&amp;gt; 类型调用 lock() 方法后返回的类型，它实现了&lt;/p&gt;&lt;p&gt;impl Deref for MutexGuard&amp;lt;T&amp;gt; { type Target = t; }&lt;/p&gt;&lt;p&gt;所以它可以直接调用 T 类型的方法，而且它有一个析构函数，当它销毁的时候，会自动调用 unlock() 方法。这个类型是一个很方便的工具类，很多时候我们都不需要注意它的存在。&lt;/p&gt;&lt;p&gt;那么，以前的编译器犯了什么错误，导致了这个bug发生呢？&lt;/p&gt;&lt;h2&gt;auto trait&lt;/h2&gt;&lt;p&gt;这里的关键是 auto trait。这个概念以前也叫 OIBIT, 全称&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot; data-editable=&quot;true&quot; data-title=&quot;opt-in builtin traits&quot;&gt;opt-in builtin traits&lt;/a&gt;。 (请不要深究这个概念为毛起了这样一个又臭又长的名字，所有人都不喜欢这个名字，后来大家都改为称作 auto trait )&lt;/p&gt;&lt;p&gt;对于某些特殊的 trait，编译器允许用户不用手写 impl，自动根据这个类型的成员“推理”出来这个类型是否满足这个 trait。所谓的特殊trait，指的是使用了如下特殊语法的trait：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;unsafe impl Send for .. { }
unsafe impl Sync for .. { }

&lt;/code&gt;&lt;p&gt;如果一个 trait 用了这样的语法，那它就是auto trait。Send 和 Sync 都是 auto trait。如果一个类型没用明确的 impl Send/Sync，编译器就会根据它的成员来推理它是否满足 Send/Sync。如果所有成员都是 Send/Sync，那它就满足 Send/Sync，否则就不是。&lt;/p&gt;&lt;p&gt;比如对于闭包类型，每个闭包都是一个单独的匿名结构体类型，这个闭包是否满足 Send/Sync，就要看它捕获的变量是否满足 Send/Sync。&lt;/p&gt;&lt;p&gt;对于最开始的那个例子，编译器的推理过程是这样的：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;join 方法要求参数要满足 Send 约束，那么就需要检查传进来的这两个闭包是否满足 Send 约束。&lt;/li&gt;&lt;li&gt;这俩闭包都只捕获了一个变量 &amp;amp;g (注意这里又用到了闭包捕获规则，因为闭包体内只用到了 g 的共享引用，因此捕获的时候不会发生move，只会借用)。根据 auto trait 规则，因此需要检查成员变量 &amp;amp;g 的类型是否满足 Send。&lt;/li&gt;&lt;li&gt;标准库中有&lt;a href=&quot;https://doc.rust-lang.org/src/core/marker.rs.html#553&quot; data-editable=&quot;true&quot; data-title=&quot;这样一个定义&quot;&gt;这样一个定义&lt;/a&gt;：&lt;code lang=&quot;text&quot;&gt;unsafe impl&amp;lt;&#39;a, T: Sync + ?Sized&amp;gt; Send for &amp;amp;&#39;a T {}

&lt;/code&gt;即，如果 T 满足 Sync，则 &amp;amp;T 满足 Send。所以，编译器需要检查 g 是否满足 Sync。&lt;/li&gt;&lt;li&gt;标准库中只有这么一句话：&lt;code lang=&quot;text&quot;&gt;impl&amp;lt;&#39;a, T: ?Sized&amp;gt; !marker::Send for MutexGuard&amp;lt;&#39;a, T&amp;gt; {}

&lt;/code&gt;这说明 MutexGuard 不是 Send，而没找到关于 Sync 的impl。根据 auto trait 规则，需要继续检查它的每个成员是否满足 Sync。&lt;/li&gt;&lt;li&gt;MutexGuard 的定义如下：&lt;code lang=&quot;text&quot;&gt;pub struct MutexGuard&amp;lt;&#39;a, T: ?Sized + &#39;a&amp;gt; {
    __lock: &amp;amp;&#39;a Mutex&amp;lt;T&amp;gt;,
    __poison: poison::Guard,
}

&lt;/code&gt;继续检查它的每个成员是否满足 Sync。&lt;/li&gt;&lt;li&gt;对于成员 __poison, 这个类型只有一个成员：&lt;code lang=&quot;text&quot;&gt;pub struct Guard {
    panicking: bool,
}

&lt;/code&gt;因为bool类型满足 Sync，所以 Guard 满足 Sync。&lt;/li&gt;&lt;li&gt;对于成员 __lock，根据 Sync 的定义，只要 Mutex&amp;lt;T&amp;gt; 满足 Sync，则 &amp;amp;Mutex&amp;lt;T&amp;gt; 满足Sync。继续检查 Mutex&amp;lt;T&amp;gt; 是否满足 Sync。&lt;/li&gt;&lt;li&gt;根据标准库中 Mutex&amp;lt;T&amp;gt; 的定义：&lt;code lang=&quot;text&quot;&gt;unsafe impl&amp;lt;T: ?Sized + Send&amp;gt; Send for Mutex&amp;lt;T&amp;gt; { }
unsafe impl&amp;lt;T: ?Sized + Send&amp;gt; Sync for Mutex&amp;lt;T&amp;gt; { }

&lt;/code&gt;即只要 T 满足 Send，则 Mutex&amp;lt;T&amp;gt; 满足 Sync。&lt;/li&gt;&lt;li&gt;此处我们的类型T参数实际上是 Cell&amp;lt;i32&amp;gt;，最后判断 Cell&amp;lt;i32&amp;gt; 是否满足 Send：&lt;code lang=&quot;text&quot;&gt;unsafe impl&amp;lt;T&amp;gt; Send for Cell&amp;lt;T&amp;gt; where T: Send {}

&lt;/code&gt;即，只要 T 满足 Send，则 Cell&amp;lt;T&amp;gt; 满足 Send。此处 i32 类型是满足的，推理完毕。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;修复方案&lt;/h2&gt;&lt;p&gt;知道了这个bug产生的原因，修复就很简单了，我们只需要对 MutexGuard 手工实现一下 impl 不要利用 auto trait 的自动推理机制即可：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;unsafe impl&amp;lt;&#39;a, T: ?Sized + Sync&amp;gt; Sync for MutexGuard&amp;lt;&#39;a, T&amp;gt; { }

&lt;/code&gt;&lt;p&gt;除此之外，这个 bug 也提醒我们，auto trait 的设计并不完美，它本该在一开始就不应该对 MutexGuard 这样的类型“自动” impl Sync。关于这方面的进一步的讨论，可以参见： &lt;a href=&quot;https://internals.rust-lang.org/t/unsafe-types-and-auto-traits/5385&quot; data-editable=&quot;true&quot; data-title=&quot;Unsafe types and auto traits&quot;&gt;Unsafe types and auto traits&lt;/a&gt; &lt;a href=&quot;https://internals.rust-lang.org/t/changing-the-impl-trait-for-syntax/3891&quot; data-editable=&quot;true&quot; data-title=&quot;Changing the `impl Trait for .. { }` syntax&quot;&gt;Changing the `impl Trait for .. { }` syntax&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这是一个Rust特有的bug。在C/C++中是不存在这样的问题的。在C/C++中，没有哪个库会给用户提供“内存安全”或者“线程安全”之类的保证，所有这些问题是靠文档来保证的，编译器或者静态检查工具永远只能检查出其中一小部分问题。用户可以轻松触发此类问题，而编译器和标准库的作者不必对此负责。Rust做出了这样的保证，编译器和标准库的作者身上的责任要远大于C/C++中的同等角色。&lt;/p&gt;&lt;p&gt;同时，这也提醒我们，以Rust的代码质量标准，写出完全正确的 unsafe 代码是多么困难的一件事情。&lt;/p&gt;&lt;p&gt;这个bug之所以这么久都没人发现，主要是由于这样的写法在实践中没人真正这么用，因此它的实际影响很小。这个bug的发现者是一个专门研究编程语言的专家，他正在做的一个研究项目是&lt;a href=&quot;https://www.ralfj.de/blog/2015/10/12/formalizing-rust.html&quot; data-editable=&quot;true&quot; data-title=&quot;Rust类型系统形式化&quot;&gt;Rust类型系统形式化&lt;/a&gt;。本文也是参考他的这篇博客写成：&lt;a href=&quot;https://www.ralfj.de/blog/2017/06/09/mutexguard-sync.html&quot; data-editable=&quot;true&quot; data-title=&quot;How MutexGuard was Sync When It Should Not Have Been&quot;&gt;How MutexGuard was Sync When It Should Not Have Been&lt;/a&gt;。&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-06-17-27438530</guid>
<pubDate>Sat, 17 Jun 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust 妙用：（一）增补标准库和统一错误</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-05-26-27102546.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Rust 妙用：（一）增补标准库和统一错误&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27102546&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;Meta&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;  本系列文是 wayslog 我本人的一些关于 Rust 的总结，发上来将这些作为骗赞的资本。想起来就更新，想不起来也不要催更，log 很懒的。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Trait and Generic&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;  初次接触 Rust 的同学可能对其 trait 的概念表示不能理解，其实这个概念在其他 fp 语言里早已被应用的很广泛了，Rust 作为一门 System Programming Language 引入这个概念，自然是想要让它自己的 type system 拥有更好的表达能力。trait 被国内的翻译者翻译成了 特征、特性， 但是我觉得都不能表达其原有意思，干脆在这这里保留原名字。它规定了一个类型能做的一系列 `动作`，可以看做约束，也可以认为是另一种形式上的 `标记`。具体怎么使用呢，我们可以来看一下下面。&lt;/p&gt;&lt;br&gt;&lt;h2&gt;&lt;b&gt;增补标准库&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;  Rust 提供了一个功能不算多的标准库（就这还天天被吐槽标准库太大了），于是很自然的，我们需要的某些功能在标准库里就可能找不到了。但是，有的时候我们又希望对标准库做一些增补。比如，我想对所有所有实现了 `std::io::Read` 的类型增补一个 `read_u8` 功能，想要从一个 `Read` 里直接读出一个 `u8` 类型（对应 C++ 里面的 char, Go 里面的 byte 类型)。&lt;br&gt;&lt;br&gt;  对于其他 OOP 语言，比如 Java 这种，显式继承 interface 的语言，除非我们能拿到 JVM 的源码，修改，并自己编译一版标准库，不然是不行的。但在 Rust 里，我们可以这么做，先上代码：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;use std::io::{Read, Error, ErrorKind, Result};

trait ReadExt: Read {
    fn read_u8(&amp;amp;mut self) -&amp;gt; Result&amp;lt;u8&amp;gt; {
        // 示例代码，效率问题不在考虑之内
        let mut bytes = [0u8; 1];
        let size = try!(self.read(&amp;amp;mut bytes[..]));
        if size != 1 {
            return Err(Error::new(ErrorKind::UnexpectedEof, &quot;read not one bytes&quot;));
        }
        Ok(bytes[0])
    }
}
&lt;/code&gt;&lt;p&gt;这里有些点我们需要解释下：&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;trait inherit&lt;br&gt;&lt;/b&gt;&lt;br&gt;Rust 没有提供 struct 的继承机制，但是，提供了一个被官方称为 `trait inherit` 的机制，具体表现就是上面代码里的 `trait ReadExt: Read {...}` 。这里，`ReadExt` 其实表示了一个类型范围，这个范围会比 `Read` 更广泛。在 Rust 的其他地方，我们可以看到，除非是类型声明，不然 `A: B` 符号总表示一个类型范围: A 的(type Kind)范围里包含 B。此条同样适用于生命周期限制，因为生命周期也是 Rust 的一种 `Kind` 。好了，话题扯远了，回归主题。&lt;br&gt;&lt;br&gt;我们看到，这里我们规定了一个类型，所有实现 `Read` 的类型都可以实现一个 `ReadExt` 来实现 `读取u8` 这么一个操作。但是，仅仅这样就能用了么？答案当然是不能。&lt;br&gt;我们附上上测试代码&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;use std::io::{Read, Error, ErrorKind, Result};
use std::io::Cursor;

trait ReadExt: Read {
    fn read_u8(&amp;amp;mut self) -&amp;gt; Result&amp;lt;u8&amp;gt; {...}
}

fn main() {
    let mut cursor = Cursor::new(vec![0u8, 1, 2]);
    let value = cursor.read_u8().unwrap();
    println!(&quot;read u8: {}&quot;, value);
}
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;尝试运行一下，我们得到了这么个错误：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;error: no method named `read_u8` found for type `std::io::Cursor&amp;lt;std::vec::Vec&amp;lt;u8&amp;gt;&amp;gt;` in the current scope
  --&amp;gt; src/main.rs:21:24
   |
21 |     let value = cursor.read_u8().unwrap();
   |                        ^^^^^^^
   |
   = help: items from traits can only be used if the trait is implemented and in scope; the following trait defines an item `read_u8`, perhaps you need to implement it:
   = help: candidate #1: `ReadExt`&lt;/code&gt;&lt;p&gt;瓦塔？编译信息说的明白：你必须对你使用的类型（这里是`Cursor&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt;`) 实现 ReadExt。 所以，我们需要加上这么一行：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait ReadExt: Read {...}

impl&amp;lt;T: Read&amp;gt; ReadExt for T {}

fn main() {...}&lt;/code&gt;&lt;p&gt;这一行： &lt;b&gt;impl&amp;lt;T: Read&amp;gt; ReadExt for T {}&lt;/b&gt;  的意思再明白不过了，就是对所有实现了 trait Read 的类型 T 去实现 ReadExt。再次运行，成功。而且，这里我们的 ReadExt 其实是没有任何 *需要用户提供的函数* 的。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Error Handle&lt;br&gt;&lt;/h2&gt;&lt;p&gt;异常，在我们目前常见的语言中，几乎都有内建的机制。&lt;br&gt;无论是 C++/Java 的  try/catch, Python 的 try/expect，其实其本质就是一个终止执行并有机会 failover 的过程。与异常对应而生的，还有一个异常安全的问题。这一点，我们不展开。&lt;br&gt;&lt;br&gt;异常，其实是一个非常经典而且直观的错误解决方式。&lt;br&gt;&lt;br&gt;而 Rust 采用了更加函数式而且统一的 Result/Option 来进行错误处理。这里， Result 和 Option 不再是需要 runtime 参与的特殊类型，而是牢牢的嵌入到了其类型系统里。&lt;br&gt;&lt;br&gt;继续以上面的例子来看，我们将完整代码附上：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;use std::io::{Read, Error, ErrorKind, Result};
use std::io::Cursor;

trait ReadExt: Read {
    fn read_u8(&amp;amp;mut self) -&amp;gt; Result&amp;lt;u8&amp;gt; {
        let mut bytes = [0u8; 1];
        let size = try!(self.read(&amp;amp;mut bytes[..]));
        if size != 1 {
            return Err(Error::new(ErrorKind::UnexpectedEof, &quot;read not one bytes&quot;));
        }
        Ok(bytes[0])
    }
}

impl&amp;lt;T: Read&amp;gt; ReadExt for T {}

fn main() {
    let mut cursor = Cursor::new(vec![0u8, 1, 2]);
    let value = cursor.read_u8().unwrap();
    println!(&quot;read u8: {}&quot;, value);
}&lt;/code&gt;&lt;p&gt;对于一个 io 操作，我们认为其在操作的时候很有可能会失败，于是 `std::io` 默认提供了 Result 类型。翻开标准库，我们可以看到：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// in std::io source code
use std::result;

pub type Result&amp;lt;T&amp;gt; = result::Result&amp;lt;T, std::io::Error&amp;gt;;
&lt;/code&gt;&lt;p&gt;好吧，我们知道了 std::io 下的 Result 类型其实是 std::result 类型下的别名，只不过限定死了错误类型是 std::io::Error。&lt;br&gt;&lt;br&gt;对于一个 Result, 我们可以进行 `unwrap`， 这个操作其实和如下操作等效：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;match some_func() {
    Ok(val) =&amp;gt; val,
    Err(err) =&amp;gt; {
        panic!(&quot;reason {:?}&quot;, err);
    }
}&lt;/code&gt;&lt;p&gt;即：取出正确的值，一旦错误，则panic当前线程。&lt;br&gt;&lt;br&gt;这其实是 Rust 的所有错误处理中最不值得推荐的一种处理，但是在程序原型构建期，或者 demo 里还是比较有用的。&lt;br&gt;&lt;br&gt;相对的, 其实我们还可以进行 `match` 操作，这个关键字在 Rust 以及其他函数式语言里被称为 `模式匹配`:&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let value = match cursor.read_u8() {
    Ok(val) =&amp;gt; val,
    Err(err) =&amp;gt; {
        println!(&quot;read faild: {:?}&quot;, err);
        0
    }
};
&lt;/code&gt;&lt;p&gt;关于模式匹配的概念，这里不再赘述，有想要深入了解的可以参见这里 [模式匹配](&lt;a href=&quot;https://rustcc.gitbooks.io/rustprimer/content/match/overview.html&quot; data-editable=&quot;true&quot; data-title=&quot;模式匹配 · RustPrimer&quot; class=&quot;&quot;&gt;模式匹配 · RustPrimer&lt;/a&gt;)。但是，就算有模式匹配，其实对于错误处理来说，也是略繁琐，我不想在每个地方都进行一次模式匹配的，很多时候，其实模式匹配就是想拿出值来，但是遇到错误则将错误返回,比如下面：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let size = match self.read(&amp;amp;mut bytes[..]) {
    Ok(val) =&amp;gt; val,
    Err(err) =&amp;gt; {
        return Err(err);
    }
};
&lt;/code&gt;&lt;p&gt; 为此，Rust 提供了一个简写的写法：`try!` 宏。这个宏提供了如上的功能，于是我们在代码里就看到了 try! 的用法：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let size = try!(self.read(&amp;amp;mut bytes[..]));&lt;/code&gt;&lt;p&gt;相对来说是简洁了一点点，但是，Rust 的 Result 的很多操作是可以串联起来的比如：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let value = try!(try!(try!(call0()).call1()).call2());
&lt;/code&gt;&lt;code lang=&quot;rust&quot;&gt;try!(try(try!(....))) .....
&lt;/code&gt;&lt;p&gt;这么写起来就太麻烦了，于是 Rust 提供了一个名叫 Carrier 的语法糖，在语法上用 `?` 代替，于是我们就可以这么写：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let value = call0()?.call1()?.call2()?;&lt;/code&gt;&lt;p&gt;其作用是和 try! 是一样的。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Uniform Error Type (personal best practice)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;这里我们要说的，是 Rust 的两个 trait : `From` 和 `Into`。 顾名思义，这是一对相反操作，表示 一种类型可以无任何风险的转换成另一种类型变量（这里其实还有一个限制：前后变量都是 ownership 的，但是这个在这里不是重点）。重要的是， try! 和 ? 里，默认都调用了 Into 操作。前面说，From 和 Into 其实是反操作，那么， Rust 库里自然有互相实现他们的反操作的地方：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/// (注：摘自标准库注释)
/// From&amp;lt;T&amp;gt; for U implies Into&amp;lt;U&amp;gt;for T
&lt;/code&gt;&lt;p&gt;预备知识介绍完毕，我们可以开始了。首先，准备一个错误类型和自己的 Result 类型:&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;#[derive(Debug)]
pub enum MyError {
}

pub type MyResult&amp;lt;T&amp;gt; = result::Result&amp;lt;T, MyError&amp;gt;;&lt;/code&gt;&lt;p&gt;然后，我们让这个类型能承包 `std::io::Error`:&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;#[derive(Debug)]
pub enum MyError {
    IoError(Error),
}

impl From&amp;lt;io::Error&amp;gt; for MyError {
    fn from(oe: io::Error) -&amp;gt; MyError {
        MyError::IoError(oe)
    }
}&lt;/code&gt;&lt;p&gt;PS: 我喜欢实现 From，当然你也可以去实现 Into ，一样的。&lt;br&gt;&lt;br&gt;这样，我们实际上得到了一个 `std::io::Error` 的超集。我们最终，整理到的代码就是：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;use std::io::{self, Read, Error, ErrorKind};
use std::io::Cursor;
use std::result;
use std::convert::From;

#[derive(Debug)]
pub enum MyError {
    IoError(Error),
}

impl From&amp;lt;io::Error&amp;gt; for MyError {
    fn from(oe: io::Error) -&amp;gt; MyError {
        MyError::IoError(oe)
    }
}

pub type MyResult&amp;lt;T&amp;gt; = result::Result&amp;lt;T, MyError&amp;gt;;

trait ReadExt: Read {
    fn read_u8(&amp;amp;mut self) -&amp;gt; MyResult&amp;lt;u8&amp;gt; {
        // 示例代码，效率问题不在考虑之内
        let mut bytes = [0u8; 1];
        let size = self.read(&amp;amp;mut bytes[..])?;
        if size != 1 {
            return Err(Error::new(ErrorKind::UnexpectedEof, &quot;read not one bytes&quot;))?;
        }
        Ok(bytes[0])
    }
}

impl&amp;lt;T: Read&amp;gt; ReadExt for T {}

fn main() {
    let mut cursor = Cursor::new(vec![0u8, 1, 2]);
    let value = match cursor.read_u8() {
        Ok(val) =&amp;gt; val,
        Err(err) =&amp;gt; {
            println!(&quot;read faild: {:?}&quot;, err);
            0
        }
    };
    println!(&quot;read u8: {}&quot;, value);
}&lt;/code&gt;&lt;p&gt;基本上对原代码破坏很小就实现了错误类型的统一。&lt;br&gt;&lt;br&gt;&lt;br&gt;以上。&lt;/p&gt;</description>
<author>赵雪松</author>
<guid isPermaLink="false">2017-05-26-27102546</guid>
<pubDate>Fri, 26 May 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust 开发环境指北</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-05-17-26944087.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Rust 开发环境指北&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26944087&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有兴趣入门 Rust 的同学现在不少，一直想写这样一篇文章，但不是我拖延而时机未到，现在今年是社区着力改善工具链和第三方库的年份，相关的成绩挺显著。虽然搭建环境的时候可能会碰到问题，但大致要做的事情已经明了了。&lt;/p&gt;&lt;p&gt;（因为很少在 Windows 上开发，本文暂时不会涉及 Windows。但基本流程是差不多的。）&lt;/p&gt;&lt;h2&gt;安装&lt;/h2&gt;&lt;p&gt;如果仅仅是想尝鲜体验一下 Rust，可以选择用喜爱的软件包管理器安装 rust 或者 rustc，然后选择一个靠谱的编辑器尝试就行了。（更轻度的话可以在线体验： &lt;a href=&quot;https://play.rust-lang.org/&quot; data-editable=&quot;true&quot; data-title=&quot;Rust Playground&quot;&gt;Rust Playground&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;如果尝鲜之后，想系统地学习 Rust，并使用方便的开发工具和各式第三方库，需要用官方推荐的方式来安装，在&lt;a href=&quot;https://www.rust-lang.org/zh-CN/index.html&quot; data-editable=&quot;true&quot; data-title=&quot;网站&quot;&gt;网站&lt;/a&gt;有相关内容，为了避免没注意到这里也贴一下：&lt;/p&gt;&lt;blockquote&gt;&lt;h3&gt;使用 rustup 管理工具链&lt;/h3&gt;&lt;p&gt;Rust 由 &lt;a href=&quot;https://github.com/rust-lang-nursery/rustup.rs&quot; data-editable=&quot;true&quot; data-title=&quot;rustup&quot;&gt;rustup&lt;/a&gt; 工具来安装和管理。 Rust 有一个 6 周的 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0507-release-channels.md&quot; data-editable=&quot;true&quot; data-title=&quot;快速发布过程 &quot;&gt;快速发布过程 &lt;/a&gt;并且支持 &lt;a href=&quot;https://forge.rust-lang.org/platform-support.html&quot; data-editable=&quot;true&quot; data-title=&quot;大量的平台 &quot;&gt;大量的平台 &lt;/a&gt;，所以任何时候都有很多 Rust 构建可用。 rustup 在 Rust 支持的每一个平台上以一致的方式管理这些构建， 并可以从 beta 和 nightly 发布渠道安装 Rust，且支持额外的交叉编译目标平台。&lt;/p&gt;&lt;p&gt;更多信息请查看 &lt;a href=&quot;https://github.com/rust-lang-nursery/rustup.rs/blob/master/README.md&quot; data-editable=&quot;true&quot; data-title=&quot;rustup documentation&quot;&gt;rustup documentation&lt;/a&gt;。&lt;/p&gt;&lt;br&gt;&lt;h3&gt;配置 PATH 环境变量&lt;/h3&gt;&lt;p&gt;在 Rust 开发环境中，所有工具都安装到 ~/.cargo/bin 目录， 并且您能够在这里找到 Rust 工具链，包括 rustc、cargo 及 rustup。&lt;/p&gt;&lt;p&gt;因此，Rust 开发者们通常会将此目录放入 &lt;a href=&quot;https://en.wikipedia.org/wiki/PATH_(variable)&quot; data-editable=&quot;true&quot; data-title=&quot;PATH 环境变量&quot; class=&quot;&quot;&gt;PATH 环境变量&lt;/a&gt;。在安装时，rustup 会尝试配置 PATH， 但是因为不同平台、命令行之间的差异，以及 rustup 的 bug，对于 PATH 的修改将会在重启终端、用户登出之后生效，或者有可能完全不会生效。&lt;/p&gt;&lt;p&gt;当安装完成之后，如果在控制台运行 rustc --version 失败，这是最可能的原因。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;注：配置环境变量的简便方法是将这一行加入你的 .bashrc / .zshrc / .profile etc：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;source $HOME/.cargo/env&lt;/code&gt;&lt;h2&gt;rustup&lt;/h2&gt;&lt;p&gt;Rust 编译器分为三个频道：修复了大多数 bug，但也不能用实验功能的 stable；等待观察成为 stable 的 beta；以及有着最多 bug 和 feature 的 nightly。&lt;/p&gt;&lt;p&gt;Rust 玩家需要在三个版本之间切换是十分痛苦的事情，有人做了切换工具 multirust，之后被官方招安，改名为 &lt;a href=&quot;https://github.com/rust-lang-nursery/rustup.rs&quot; data-editable=&quot;true&quot; data-title=&quot;rustup并成为默认的安装途径&quot;&gt;rustup并成为默认的安装途径&lt;/a&gt;。如果需要帮助可以参考&lt;a href=&quot;https://github.com/rustcc/RustPrimer/blob/master/install/rustup.md&quot; data-editable=&quot;true&quot; data-title=&quot;这篇文章&quot; class=&quot;&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;安装完成后视情况请定期运行 rustup update。不使用 nightly 的话一般不到两个月更新一次。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;源&lt;/h2&gt;&lt;p&gt;这是一片神奇的土地，很多时候全球都能下载下来的在这片土地上就下载不下来。&lt;/p&gt;&lt;p&gt;感谢&lt;a href=&quot;https://lug.ustc.edu.cn/wiki/mirrors/help/rust-static&quot; data-editable=&quot;true&quot; data-title=&quot;中科大镜像有 Rust 源&quot; class=&quot;&quot;&gt;中科大镜像有 Rust 源&lt;/a&gt; 这个源帮助下载 Rust 编译器等静态文件。&lt;/p&gt;&lt;p&gt;Crates.io 是 Rust 包的网站，类似于 NPM，you know，这是&lt;a href=&quot;https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates?s%5B%5D=rust&quot; data-editable=&quot;true&quot; data-title=&quot;另一个镜像&quot;&gt;另一个镜像&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;以前有报告称，因为代码补全插件的 bug，使用这个镜像会导致代码补全不可用，如果出现这种情况请切换回原本的源并且大喊：&lt;strong&gt;fuck GFW&lt;/strong&gt;。然后用文本编辑器打开 ~/.cargo/config&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[http]
proxy = &quot;[socks5://]server:&amp;lt;port&amp;gt;&quot;&lt;/code&gt;&lt;p&gt;refer &lt;a href=&quot;https://github.com/rust-lang/cargo/issues/636&quot; data-editable=&quot;true&quot; data-title=&quot;1&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;https://github.com/rust-lang/cargo/issues/3596&quot; data-editable=&quot;true&quot; data-title=&quot;2&quot;&gt;2&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;RLS&lt;/h2&gt;&lt;p&gt;如果不使用 Visual Studio Code 本节可以跳过。&lt;/p&gt;&lt;p&gt;RLS 是 &lt;i&gt;Rust Language Server &lt;/i&gt;的简写，微软提出&lt;i&gt;编程语言服务器&lt;/i&gt;的概念，将 IDE 的一些编程语言相关的部分由单独的服务器来实现，比如说代码补全、跳转定义、查看文档等等。这样只用给不同编辑器或者 IDE 实现客户端接口就好了。&lt;/p&gt;&lt;p&gt;Rust 就是这个概念最积极的先行者，RLS 是官方的，可预见的未来也是编辑器最主要的帮手。不过现在只有微软自家的 Visual Studio Code 支持，并且需要在系统中安装 nightly 版本的 Rust（不必启用），不想用现在可以不用。&lt;/p&gt;&lt;p&gt;RLS 的安装请查阅&lt;a href=&quot;https://github.com/rust-lang-nursery/rls#setup&quot; data-editable=&quot;true&quot; data-title=&quot;项目README&quot; class=&quot;&quot;&gt;项目README&lt;/a&gt;，也是 rustup 轻松完成。但因为目前部分功能还依赖 &lt;i&gt;racer&lt;/i&gt; 来实现，需要配置 racer 的环境变量（不必安装），所以请参阅下文关于 RUST_SRC_PATH 环境变量的部分。&lt;/p&gt;&lt;h2&gt;Racer 代码补全&lt;/h2&gt;&lt;p&gt;如果使用 Intellij Rust 本节可以跳过。&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/phildawes/racer&quot; data-title=&quot;Racer 代码补全&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;Racer&lt;/a&gt; 是 Rust 代码补全库，被很多编辑器所需要（除了 Interllij Rust），安装：&lt;/p&gt;&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;cargo install racer
&lt;/code&gt;&lt;p&gt;代码补全需要源代码。以前需要下载源代码，手动放到某处并且定期更新，现在有了 rustup 很方便：&lt;/p&gt;&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;rustup component add rust-src
&lt;/code&gt;&lt;p&gt;之后需要&lt;b&gt;配置环境变量&lt;/b&gt;，新版的 racer &lt;a href=&quot;https://github.com/phildawes/racer/pull/598&quot; data-editable=&quot;true&quot; data-title=&quot;似乎能自动探测&quot;&gt;似乎能自动探测&lt;/a&gt;了，不过这里以防万一还是写一下。因为 rustup 使得 rust 编译器的版本可以随时切换，所以环境变量不能写死，从这个 &lt;a href=&quot;https://github.com/phildawes/racer/issues/595&quot; data-editable=&quot;true&quot; data-title=&quot;issue&quot; class=&quot;&quot;&gt;issue&lt;/a&gt; 可以看到很聪明的做法，设置环境变量为：&lt;/p&gt;&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;export RUST_SRC_PATH=&quot;$(rustc --print sysroot)/lib/rustlib/src/rust/src&quot;
&lt;/code&gt;&lt;p&gt;就能根据当前的 Rust 频道自动设置源代码地址了。&lt;/p&gt;&lt;p&gt;（实际上强行设定为 nightly 其实应该也不会有什么问题…）&lt;/p&gt;&lt;h2&gt;rustfmt, cargo-check 和 rust-clippy&lt;/h2&gt;&lt;p&gt;都是很重要的工具，配置起来也没什么麻烦的，就放在一起简单介绍一下。&lt;/p&gt;&lt;p&gt;这些都可以作为 cargo 的子模块，如果要学 Rust 不可能不知道 cargo。作为 Rust 最常用的有力工具，广受好评的 cargo 提供对项目的依赖管理、build、文档生成、发布等等，还可以被插件扩展，下面这几个就是必装的 cargo 插件。&lt;/p&gt;&lt;a href=&quot;https://github.com/Manishearth/rust-clippy&quot; data-editable=&quot;true&quot; data-title=&quot;clippy&quot;&gt;&lt;b&gt;&lt;i&gt;clippy&lt;/i&gt;&lt;/b&gt;&lt;/a&gt;&lt;p&gt;有点 linter 的感觉，分析你的源代码，检查哪些地方写得不地道可以改善。&lt;/p&gt;&lt;p&gt;可以作为项目依赖安装在编译时弹警告，但更好的做法是作为 cargo 的插件，手动或者被编辑器插件调用：&lt;/p&gt;&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;cargo install clippy
&lt;/code&gt;&lt;a href=&quot;https://github.com/rsolomo/cargo-check&quot; data-editable=&quot;true&quot; data-title=&quot;cargo-check&quot; class=&quot;&quot;&gt;&lt;b&gt;&lt;i&gt;cargo-check&lt;/i&gt;&lt;/b&gt;&lt;/a&gt;&lt;p&gt;（评论指出这已经是自带命令，不需要去安装了。）&lt;/p&gt;&lt;p&gt;Rust 编译时间过长目前是一个缺点，写代码的时候不可能为了检查错误动不动编译一下。&lt;/p&gt;&lt;p&gt;但是 Rust 的类型安全做得非常好，90% 的错误在类型检查的时候就会被发现，所以 cargo check 给 cargo 添加了 check 命令，快速地检查程序的类型而不编译。&lt;/p&gt;&lt;a href=&quot;https://github.com/rust-lang-nursery/rustfmt&quot; data-editable=&quot;true&quot; data-title=&quot;rustfmt&quot;&gt;&lt;b&gt;&lt;i&gt;rustfmt&lt;/i&gt;&lt;/b&gt;&lt;/a&gt;&lt;p&gt;顾名思义，格式化整个项目。commit 之前跑一遍吧。&lt;/p&gt;&lt;p&gt;&lt;i&gt;最后附赠一个编译器插件 &lt;a href=&quot;https://github.com/mcarton/rust-herbie-lint&quot; data-editable=&quot;true&quot; data-title=&quot;Herbie lint for Rust&quot; class=&quot;&quot;&gt;Herbie lint for Rust&lt;/a&gt; 检测不稳定的浮点数运算，Haskell 也有。&lt;/i&gt;&lt;/p&gt;&lt;h2&gt;编辑器&lt;/h2&gt;&lt;p&gt;这里有&lt;a href=&quot;https://areweideyet.com/&quot; data-editable=&quot;true&quot; data-title=&quot;一份编辑器对Rust支持的表&quot; class=&quot;&quot;&gt;一份编辑器对 Rust 支持的表&lt;/a&gt;，可以大致看一下，根据自己喜欢的编辑器来挑选。&lt;/p&gt;&lt;p&gt;这里我主要推荐 &lt;a href=&quot;https://code.visualstudio.com/&quot; data-editable=&quot;true&quot; data-title=&quot;Visual Studio Code&quot;&gt;Visual Studio Code&lt;/a&gt; 主要是方便简单开箱即用，而且是目前RLS主要支持的编辑器。&lt;br&gt;&lt;/p&gt;&lt;p&gt;（其次推荐 &lt;a href=&quot;https://github.com/intellij-rust/intellij-rust&quot; data-editable=&quot;true&quot; data-title=&quot;Intellij Rust&quot;&gt;Intellij Rust&lt;/a&gt;，作为 Intellij 插件，他们用自己写的逻辑而不是 racer 补全，如果遇到问题了可以试试这个。）&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8565028a4779ae365ffce542a30358f3_r.png&quot; data-rawwidth=&quot;1564&quot; data-rawheight=&quot;1250&quot;&gt;&lt;br&gt;&lt;p&gt;Visual Studio Code 插件请用 &lt;a href=&quot;https://github.com/editor-rs/vscode-rust&quot; data-editable=&quot;true&quot; data-title=&quot;Rust&quot; class=&quot;&quot;&gt;Rust&lt;/a&gt;，而不是停止维护的 &lt;a href=&quot;https://github.com/saviorisdead/RustyCode&quot; data-editable=&quot;true&quot; data-title=&quot;Rusty Code&quot;&gt;Rusty Code&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;不过其实现在不管是 RLS 还是插件都是不是特别完善的状况，会遇到一些问题，但总体上还是绝对可用的。&lt;/p&gt;&lt;h2&gt;调试&lt;/h2&gt;&lt;p&gt;之前忘了写重要的调试，更新一下。Mac 上调试我遇到了不少问题，没跑通……。&lt;/p&gt;&lt;p&gt;以 Visual Studio Code 为例，有两个插件可供选择：&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=webfreak.debug&quot; data-editable=&quot;true&quot; data-title=&quot;Native Debug - Visual Studio Marketplace&quot; class=&quot;&quot;&gt;Native Debug&lt;/a&gt; &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;LLDB Debugger - Visual Studio Marketplace&quot;&gt;LLDB Debugger&lt;/a&gt;&lt;/p&gt;&lt;p&gt;以后者为例，launch.js 文件如下&lt;/p&gt;&lt;code lang=&quot;json&quot;&gt;{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [

        {
            &quot;type&quot;: &quot;lldb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Debug&quot;,
            &quot;program&quot;: &quot;${workspaceRoot}/target/debug/&amp;lt;BINARY NAME&amp;gt;&quot;,
            &quot;args&quot;: [],
            &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
            &quot;sourceLanguages&quot;: [&quot;rust&quot;]
        }
    ]
}
&lt;/code&gt;</description>
<author>酿泉</author>
<guid isPermaLink="false">2017-05-17-26944087</guid>
<pubDate>Wed, 17 May 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>RFC导读：impl trait</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-04-22-26516100.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;RFC导读：impl trait&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26516100&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天跟大家分享一下最近讨论比较热门的一个 rfc：impl trait。这个话题涉及两个RFC，一个是去年就已经通过了的&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md&quot; data-editable=&quot;true&quot; data-title=&quot;Conservative Impl Trait&quot; class=&quot;&quot;&gt;Conservative Impl Trait&lt;/a&gt;，第二个是最近 aturon 提的最新的 &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1951&quot; data-editable=&quot;true&quot; data-title=&quot;Expand and stablize impl Trait&quot;&gt;Expand and stablize impl Trait&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;首先介绍一下，这是个什么功能。我们注意到，在写泛型函数的时候，参数传递方式可以有两种选择，静态分派或者动态分派：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn consume_iter_static&amp;lt;I: Iterator&amp;lt;Item=u8&amp;gt;&amp;gt;(iter: I)

fn consume_iter_dynamic(iter: Box&amp;lt;Iterator&amp;lt;Item=u8&amp;gt;&amp;gt;)
&lt;/code&gt;&lt;p&gt;不论选哪种方式，都可以写出针对一组类型的抽象代码，而不是针对某一个具体类型。在 _static 版本中，每次调用的时候，编译器都会为不同的实参类型，实例化不同版本的函数。在 _dynamic 版本中，每次调用的时候，实参的具体类型隐藏在了 trait object 的后面，通过虚函数表，在执行阶段选择调用正确的函数版本。&lt;/p&gt;&lt;p&gt;这两种方式都可以在函数参数中正常使用。但是，如果我们考虑函数的返回值，目前只有这样一种方式是合法的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn produce_iter_dynamic() -&amp;gt; Box&amp;lt;Iterator&amp;lt;Item=u8&amp;gt;&amp;gt;
&lt;/code&gt;&lt;p&gt;以下这种方式是不合法的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn produce_iter_static() -&amp;gt; Iterator&amp;lt;Item=u8&amp;gt;
&lt;/code&gt;&lt;p&gt;目前版本中，Rust只支持返回“具体类型”，而不能返回一个 trait。由于缺少了“不装箱的抽象返回类型”这样一种机制，导致了以下这些问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;我们返回一个复杂的迭代器的时候，会让返回类型过于复杂，而且泄漏了具体实现。比如，如果我们需要返回一个栈上的迭代器，可能需要为函数写这么复杂的返回类型：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;rust&quot;&gt;Chain&amp;lt;Map&amp;lt;&#39;a, (int, u8), u16, Enumerate&amp;lt;Filter&amp;lt;&#39;a, u8, vec::MoveItems&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;&amp;gt;, SkipWhile&amp;lt;&#39;a, u16, Map&amp;lt;&#39;a, &amp;amp;u16, u16, slice::Items&amp;lt;u16&amp;gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;p&gt;函数内部的逻辑稍微有点变化，这个返回类型就要跟着改变，远不如泛型函数参数 T: Iterator 的抽象程度好。&lt;/p&gt;&lt;br&gt;&lt;ul&gt;&lt;li&gt;函数无法直接返回一个闭包。因为闭包的类型是编译器自动生成的一个匿名类型，我们没办法在函数的返回类型中手工指定，所以返回一个闭包一定要“装箱”到堆内存中，然后把胖指针返回回去，这样是有性能开销的。fn multiply(m: i32) -&amp;gt; Box&amp;lt;Fn(i32)-&amp;gt;i32&amp;gt; {&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;    Box::new(move |x|x*m)
}

fn main() {
    let f = multiply(5);
    println!(&quot;{}&quot;, f(2));
}
&lt;p&gt;请注意，这种时候，引入一个泛型参数代表这个闭包是行不通的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn multiply&amp;lt;T&amp;gt;(m: i32) -&amp;gt; T where T:Fn(i32)-&amp;gt;i32 {
    move |x|x*m
}

fn main() {
    let f = multiply(5);
    println!(&quot;{}&quot;, f(2));
}
&lt;/code&gt;&lt;p&gt;编译，可见编译错误为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;note: expected type `T`    found type `[closure@test.rs:3:5: 3:16 m:_]`
&lt;/code&gt;&lt;p&gt;因为这种语法，实际的意思是，泛型参数 T 由“调用者”决定的意思。比如 std::iter::Iterator::collect 这个函数就非常适合这么实现。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let a = [1, 2, 3];
let doubled = a.iter()
        .map(|&amp;amp;x| x * 2)
        .collect::&amp;lt;???&amp;gt;::();
&lt;/code&gt;&lt;p&gt;使用者可以在 ??? 这个地方填充不同的类型 Vec&amp;lt;i32&amp;gt; VecDeque&amp;lt;i32&amp;gt; LinkedList&amp;lt;i32&amp;gt; 等，这个 collect 方法的返回类型是一个抽象的类型集合，调用者可以随意选择这个集合中的任意一个具体类型。&lt;/p&gt;&lt;p&gt;这跟我们上面想返回一个内部的闭包情况不同，上面的的程序想表达的是，返回一个“具体类型”，这个类型是由被调用的函数自行决定的，只是调用者不知道它的名字而已。&lt;/p&gt;&lt;p&gt;为了解决上面这个问题，aturon 提出了 impl Trait 这个方案。这就是前面提到的第一个RFC的内容。它引入了一个新的语法，可以让函数返回一个不用装箱的匿名类型，以及它所满足的基本的接口。&lt;/p&gt;&lt;p&gt;示例如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;#![feature(conservative_impl_trait)]

fn multiply(m: i32) -&amp;gt; impl Fn(i32)-&amp;gt;i32 {
    move |x|x*m
}

fn main() {
    let f = multiply(5);
    println!(&quot;{}&quot;, f(2));
}
&lt;/code&gt;&lt;p&gt;这里的 -&amp;gt; impl Fn(i32)-&amp;gt;i32 表示，这个返回类型，满足 Fn(size)-&amp;gt;isize 这个 trait 的约束。因此，它解决了“返回不装箱的抽象类型”这个问题。&lt;/p&gt;&lt;p&gt;它跟泛型函数的主要区别是：泛型函数的类型参数，是函数的调用者指定的；impl Trait 的具体类型，是函数的实现体指定的。&lt;/p&gt;&lt;p&gt;这里 fn func() -&amp;gt; impl Trait，之所以要用一个额外的 impl 关键字的语法，有几个原因：1) 在目前版本中 fn func() -&amp;gt; Trait 其实是一个合理的语法。目前编译不通过，是由于 DST 类型还没有搞完而已。假如将来 DST 类型做完，可能会允许 fn func() -&amp;gt; [i32] 这样的写法，调用方通过 let array = box func(); 这样的方式使用。为了避免和将来的DST冲突，使用一个新的语法更合理。2) 如果将来希望用 fn func() -&amp;gt; Trait 这种语法来表示 impl Trait 这个功能，最好还需要对 trait object 的语法做相应的改动，以便对这两种情况明显区分，而此事是重大的 breaking change，目前是不考虑的。&lt;/p&gt;&lt;p&gt;为什么这个功能名叫 conservative 呢？因为目前为止，它的使用场景非常保守，只允许这个语法用于普通函数的返回类型，不能用于参数类型等其它地方。查看历史，我们可以看到 conservative impl trait 这个RFC是2016年7月通过的。但是到目前为止，它依然没有达到稳定。它的主要争议就在于，大家都希望这个功能能扩展到更多的场景，但是如何扩展这件事情，一直有争议。因此，为了尽快让这个功能稳定，需要讨论一下，是否需要对这个功能做进一步扩展，如果扩展的话需要如何设计。这就是前面说的第二个RFC的内容。比如说，随便想一想，可能的扩展场景可以有以下这些：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;让 impl Trait 可以用在函数参数中：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn test(f: impl Fn(i32)-&amp;gt;i32){}
&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;让 impl Trait 可以用在类型别名中：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;type MyIter = impl Iterator&amp;lt;Item=i32&amp;gt;;
&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;让 impl Trait 可以用在 trait 中的方法参数／返回值中：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Test {
     fn test() -&amp;gt; impl MyTrait; 
}
&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;让 impl Trait 可以用在 trait 中的关联类型中：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt; trait Test {
     type AT = impl MyTrait; 
}
&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;各位是不是觉得这样设计是非常符合直觉的？让同样语法规则在各种地方使用，可以降低学习成本，提高易用性。然而，事情并不像刚开始预计的那么简单。在这场RFC的讨论中，话题迅速扩展，范围越来越广，深度越来越深，难度越来越大，最终只有很少一部分问题上设计者们取得了共识。还有很多问题，都还没得到最终结论。虽说这个RFC最终缩水了很多，但是设计者们在这场讨论中对各种场景的思考，非常值得剖析。作为旁观者，我们很难在这种讨论中做出很大贡献，但我希望尽我所能给大家总结和介绍一下，设计者们都讨论了些什么东西，对自己也是一个锻炼。&lt;/p&gt;&lt;h2&gt;场景一 函数参数&lt;/h2&gt;&lt;p&gt;函数参数是最直观的一种扩展场景。这也是最近这个 RFC 主推的一种扩展。这意味着我们可以写这样的代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn test(arg: impl MyTrait) {}
&lt;/code&gt;&lt;p&gt;它的含义与以下代码相同：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn test&amp;lt;T: MyTrait&amp;gt;(arg: T) {}
&lt;/code&gt;&lt;p&gt;这种写法的最大的争议在于，有很大一部分讨论者，希望使用两个关键字 some/any 来替换当前的 impl 关键字。使用两个关键字的理由是，这个功能在函数参数和返回值的场景，有明确的不同的两种语义：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;在返回值中，这个叫做 existential type，impl Trait表示“存在某一个类型T满足 T:Trait”&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在函数参数中，这个叫做 universal type，impl Trait表示“任意一个T满足 T:Trait”&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;比如说，fn Foo() -&amp;gt; impl Debug 代表的是函数 Foo 返回了一个类型，这个类型满足 Debug 约束。而 fn Foo(arg: impl Debug) 代表的是，函数 Foo 接受任意一种参数类型，只要它满足 Debug 约束即可。对于更复杂的情况，fn func(arg: impl From&amp;lt;impl ToString&amp;gt;)，一句话中的两个 impl 有两种含义，如果不做区分的话，怕是会影响表达能力。&lt;/p&gt;&lt;p&gt;设计组的几位核心成员对此建议的观点是：在函数参数和返回值中，它们表达的含义确实是有所区别，然而这个区别并不需要在语法层面做区分。使用两个关键字会对Rust的易用性有害。主要理由如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;对于新手来说，根本意识不到这里有 existential/universal 的区别，新手想的就是，我希望这个类型满足某个 trait 即可，直接使用这个语法即可，不会出错。统一的 impl Trait 语法可以对应于一个非常直观的思维模型。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于有经验的开发者来说，可能意识到了这个区别，会更近一步的思考，这里究竟是想表达什么具体含义。处于这个阶段的开发者，最支持 some/any 两个关键字分开的写法。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于完全掌握了这个功能的老手而言，心里很清楚使用 impl Trait 的每个场景分别是什么含义，然而并不重要，还是会倾向于统一的语法，我们可以将这个语法视为一种语法糖，知道它在不同场景代表不同含义就足够了。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这就是对这个功能理解的三重境界：看山就是山，看水就是水；看山不是山，看水不是水；看山还是山，看水还是水。从 impl Trait → explicit some／any → impl Trait 的思路历程，非常像使用生命周期标记时候经历过的 lifetime elision → explicit lifetimes → lifetime elision。&lt;/p&gt;&lt;p&gt;经过此番论述之后，基本大家都同意了，在各种不同场景，使用 impl Trait 作为统一语法，不必在每个场景设计单独的语法。&lt;/p&gt;&lt;p&gt;另外，nrc以及一部分设计者，提出另外一个反对理由：我们没有必要将 impl Trait 扩展到函数参数，因为目前的泛型语法已经完全足够表达，再增加一种方式写同样的代码没有必要。&lt;/p&gt;&lt;p&gt;对于这个论点，支持者的意见是，这个设计非常有助于一致性，比如：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn take_iter(t: impl Iterator)

fn give_iter() -&amp;gt; impl Iterator
&lt;/code&gt;&lt;p&gt;这种写法和目前的 trait object 完全一致，用户可以很容易学习和掌握：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn take_iter(t: Box&amp;lt;Iterator&amp;gt;)

fn give_iter() -&amp;gt; Box&amp;lt;Iterator&amp;gt;
&lt;/code&gt;&lt;p&gt;函数签名可以变得更直观流畅，用户可以很容易写这样的代码，非常像 Java/C#：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl&amp;lt;T&amp;gt; Option&amp;lt;T&amp;gt; {
    fn map&amp;lt;U&amp;gt;(self, f: impl FnOnce(T) -&amp;gt; U) -&amp;gt; Option&amp;lt;U&amp;gt;    { ... }
}
&lt;/code&gt;&lt;p&gt;它并没有本质上增加Rust的复杂度，它不过就是一个语法糖，可以让我们在某些情况下更流畅地写代码。Rust里面已经有了很多语法糖，语法糖也并不是坏事。&lt;/p&gt;&lt;h2&gt;场景二 高阶约束(higher ranked bound)&lt;/h2&gt;&lt;p&gt;如果我们允许 impl Trait 同时出现在函数参数和返回值的位置，那么就有人可能会在泛型闭包约束的参数和返回值都使用这种语法：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn foo(f: impl Fn(impl SomeTrait) -&amp;gt; impl OtherTrait){}
&lt;/code&gt;&lt;p&gt;这个场景很复杂，函数 foo 接受一个参数，它是一个闭包满足 Fn 约束，而这个闭包的参数是一个 SomeTrait 类型，返回值是一个 OtherTrait 类型。这种情况，甚至用我们前面提到的 any/some 都已经无法将它的含义完整表达出来，实质上，它想表达的含义是这样的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn foo(f: for&amp;lt;T1:SomeTrait, T2:OtherTrait&amp;gt; Fn(T1) -&amp;gt; T2)
&lt;/code&gt;&lt;p&gt;即类似我们曾经见过的“高阶生命周期”，f的类型，需要的是一种“高阶泛型约束”。而这是 Rust 中暂时还没有的功能。因此，这种场景下的 impl Trait 是不能被支持的。&lt;/p&gt;&lt;h2&gt;场景三 在trait内部使用&lt;/h2&gt;&lt;p&gt;刚开始，aturon以为 trait 内部使用的 impl trait 无非就是一个 associated type 的语法糖。比如这段代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Foo {
   fn baz(&amp;amp;self) -&amp;gt; impl Iterator;
}
&lt;/code&gt;&lt;p&gt;可以当成这样处理：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Foo {
   type __baz: Iterator;
   fn baz(&amp;amp;self) -&amp;gt; __baz;
}
&lt;/code&gt;&lt;p&gt;然而，马上有人指出来了，对于下面的这些情况，目前 Rust 无法处理，比如：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Foo {
    fn f1&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a self) -&amp;gt; impl Trait;
    fn f2&amp;lt;T&amp;gt;(arg: T) -&amp;gt; impl Trait;
}
&lt;/code&gt;&lt;p&gt;因为这个 impl Trait 要捕获对应函数的泛型参数，去掉这个 impl Trait 语法糖之后，它看起来是这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Foo {
    type __Anonymous1&amp;lt;&#39;a&amp;gt;;
    type __Anonymous2&amp;lt;T&amp;gt;;

    fn f1&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a self) -&amp;gt; type __Anonymous1&amp;lt;&#39;a&amp;gt;;
    fn f2&amp;lt;T&amp;gt;(arg: T) -&amp;gt; type __Anonymous2&amp;lt;T&amp;gt;;
}
&lt;/code&gt;&lt;p&gt;这实际上是正在规划中还没实现的 ATC (associated type constructor)。对于 ATC 不了解的朋友可以去读一下 niko 的几篇博客。简而言之，这个功能实质上是高阶类型 HKT (high kinded type) 的等价物。在 ATC 没有准备好的情况下，impl Trait 是没办法用在 trait 里面的。另外，按照 eddyb 的剖析，在 trait 中使用 impl Trait 功能，还需要另外一个功能的支持：从 impl 块里面的函数签名推导 trait 中的关联类型。&lt;/p&gt;&lt;p&gt;因此，在目前的情况下，impl Trait 功能是无法在 trait 里面使用的。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;impl Trait 这个语法，在某些场景下，具有明显优势，可以提高语言的表达能力。但是，要把它推广到各个场景下使用，还需要大量的设计和实现工作。目前的这个RFC将目标缩小为了：先推进这个语法在函数参数和返回值场景下使用，其它的情况，后面再考虑。&lt;/p&gt;&lt;p&gt;最后需要跟各位读者提醒一点的是，不要过于激进地使用这个功能，在每个可以使用 impl Trait 的地方都用它替换原先的具体类型。它更多的倾向于简洁性，而牺牲了一部分表达能力。比如说，拿前面的那个复杂的迭代器类型来说，&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn test() -&amp;gt; Chain&amp;lt;Map&amp;lt;...&amp;gt;&amp;gt;
&lt;/code&gt;&lt;p&gt;我们可能希望将函数返回类型写成这样&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn test() -&amp;gt; impl Iterator&amp;lt;Item=u16&amp;gt;
&lt;/code&gt;&lt;p&gt;但是，这么写，实际上是降低了表达能力。因为，前一种写法，用户可以拿到这个迭代器之后再调用 clone() 方法，而后一种写法，就不可以。如果希望支持 clone，那么需要这么写&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn test() -&amp;gt; impl Iterator&amp;lt;Item=u16&amp;gt; + Clone
&lt;/code&gt;&lt;p&gt;而这两个 trait 依然不是原先那个具体类型的所有对外接口，真实情况可能需要类似这样才能完整替代原先的那种写法：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn test() -&amp;gt; impl Iterator&amp;lt;Item=u16&amp;gt; +
        Clone +
        ExactSizeIterator+
        TrustedLen
&lt;/code&gt;&lt;p&gt;先不论这种写法是否可行，单说这个复杂度，就已经完全失去了这个 impl Trait 功能的意义了。所以，什么时候该用这个功能，什么时候不该用，应该仔细衡量一下。&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-04-22-26516100</guid>
<pubDate>Sat, 22 Apr 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust 错误处理</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-03-03-25506762.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Rust 错误处理&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25506762&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;注: 文章最后添加了问号语法糖的更新说明&lt;/b&gt;&lt;/p&gt;&lt;p&gt;----- 正文 -----&lt;br&gt;&lt;/p&gt;&lt;p&gt;人孰无过，过而能改，善莫大焉。程序运行过程中总是会出现各种各样的问题，导致程序出现异常或错误，这些异常和错误本身不是 bug，但是如果不处理好的话就会成为 bug。不同编程语言提供了不同的机制来处理错误和异常，一般分为两大类：把错误当作值来处理；抛出异常。&lt;/p&gt;&lt;p&gt;Rust 提供以下基础设施做错误处理：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Option, Result&lt;/li&gt;&lt;li&gt;unwrap, expect&lt;/li&gt;&lt;li&gt;combinators&lt;/li&gt;&lt;li&gt;try! macro&lt;/li&gt;&lt;li&gt;Error trait&lt;/li&gt;&lt;li&gt;From trait&lt;/li&gt;&lt;li&gt;Carrier trait&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Rust 并没有提供基于 exception 的错误处理机制，虽然 panic! 宏在让进程挂掉时也抛出堆栈，同时也可以用 std::panic::catch_unwind 捕捉 panic，但是&lt;b&gt;极其&lt;/b&gt;不推荐用来处理常规错误。&lt;/p&gt;&lt;p&gt;catch_unwind 一般是用来在多线程程序里面在将挂掉的线程 catch 住，防止一个线程挂掉导致整个进程崩掉，或者是通过外部函数接口(FFI)与 C 交互时将堆栈信息兜住防止 C 程序看到堆栈不知道如何处理，直接把堆栈信息丢给 C 程序的话属于 C 里的未定义行为(Undefined Behavior)。&lt;/p&gt;&lt;p&gt;另外 catch_unwind 并不保证能 catch 所有 panic，而只对通过 unwind 实现的 panic 有用。因为 unwind 需要额外记录堆栈信息，对程序性能和二进制程序大小有影响，所以在一些嵌入式平台上面的 panic 并没有通过 unwind 实现，而是直接 abort 的，所以 catch_unwind 并不保证能捕捉到所有panic。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::panic;
fn main() {
    let result = panic::catch_unwind(|| {
        println!(&quot;hello!&quot;);
    });
    assert!(result.is_ok());

    let result = panic::catch_unwind(|| {
        panic!(&quot;oh no!&quot;);
    });
    assert!(result.is_err());
}
&lt;/code&gt;&lt;p&gt;Rust 错误处理本质上还是基于返回值的，很多基于返回值做错误处理的语言是将错误直接硬编码到正确值上，或者返回两个值，前者例如 C 在很多时候都是直接把正常情况永远不会出现的值作为错误值，后者例如 Go 同时返回两个值来进行错误处理。而 Rust 则将两个可能的值用 enum 类型表示，enum 在函数式语言里面叫做代数数据类型(algebraic data type)，而且是和类型(sum type)，表示两个可能的值一次只能取一个。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;enum Option&amp;lt;T&amp;gt; {
    None,
    Some(T),
}

enum Result&amp;lt;T, E&amp;gt; {
    Ok(T),
    Err(E),
}
&lt;/code&gt;&lt;p&gt;用 Option&amp;lt;T&amp;gt; 表示错误时一般不关心错误原因，出错时直接返回空值 None 而 Result&amp;lt;T, E&amp;gt; 则将错误的不同原因包括进来了，Option&amp;lt;T&amp;gt; 相当于 Result&amp;lt;T, ()&amp;gt;，如果错误只可能是一种原因造成的，一般就直接用 Option&amp;lt;T&amp;gt; 例如从 HashMap 里面取值或者对 Vector 进行 pop 操作，前者出错了只可能是对应的 key 不存在，后者出错只可能是 Vector 已经是空的了。而如果错误可能是多种原因造成的则用 Result&amp;lt;T, E&amp;gt; 来表示，例如 IO 错误，原因可能是 NotFound, PermissionDenied, AlreadyExists, InvalidData…&lt;/p&gt;&lt;p&gt;新手在看各种文档或读别人的代码时发现 Result&amp;lt;T&amp;gt; 的错误类型时可能会有点小疑惑。这里简单提一下，Result&amp;lt;T&amp;gt; 是用到了类型别名，例如 io::Result 定义如下，因为 io 模块里的错误都是 io::Error，用到 Result&amp;lt;T, Error&amp;gt; 的地方如果都换成 Result&amp;lt;T&amp;gt; 会少敲很多次键盘，同时又不会产生歧义(因为 Result 里面的 E 已经被固定成 io::Error 了)&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;type Result&amp;lt;T&amp;gt; = Result&amp;lt;T, Error&amp;gt;;
&lt;/code&gt;&lt;p&gt;Option 和 Result 作为代数数据类型，可以利用函数式语言里面的组合子(combinator)抽象简化错误处理。Option 和 Result 可以看成是一个包装类型，要对其进行处理的话，一般需要将里面的东西—正确值和错误值取出来，然后根据取出来的值分情况处理，即对 enum 类型常见的操作 match。这种方式是最拿衣服的处理方式，分情况分析，不做任何抽象，与另外两种基于返回值的错误处理方式基本一样。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(file_path: P) -&amp;gt; Result&amp;lt;i32, String&amp;gt; {
    let mut file = match File::open(file_path) {
        Ok(file) =&amp;gt; file,
        Err(err) =&amp;gt; return Err(err.to_string()),
    };
    let mut contents = String::new();
    if let Err(err) = file.read_to_string(&amp;amp;mut contents) {
        return Err(err.to_string());
    }
    let n: i32 = match contents.trim().parse() {
        Ok(n) =&amp;gt; n,
        Err(err) =&amp;gt; return Err(err.to_string()),
    };
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&amp;gt; println!(&quot;{}&quot;, n),
        Err(err) =&amp;gt; println!(&quot;Error: {}&quot;, err),
    }
}
&lt;/code&gt;&lt;p&gt;当然也可以选择不处理错误，用 unwrap 或 expect 直接将正确值取出来，如果出错了就直接让程序挂掉，其中 unwrap 在挂掉时是标准库内置的错误提示，而 expect 则让我们可以自己定义一个字符串在程序挂掉时显示。这两种是最粗暴的处理方式了，程序看起来很简洁，除了每个可能出错的地方有个难看的 unwrap 外(Rust 设计就是让这些不规范的代码看起来丑陋好让你改变一些不规范的写法)。很多动态语言写起来也类似，但是不用写 unwrap，其实可以看成是默认包含了 unwrap。这些看起来很简洁的程序，跑起来一旦有错误程序就直接崩了。&lt;/p&gt;&lt;p&gt;这种错误处理方式一般只适用于原型设计和教程示例，这类程序如果完整的处理错误的话就会分散自己或别人的注意力，而且原型设计之初很多错误该如何处理并不是很明确。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(file_path: P) -&amp;gt; i32 {
    let mut file = File::open(file_path).unwrap();
    let mut contents = String::new();
    file.read_to_string(&amp;amp;mut contents).unwrap();
    let n: i32 = contents.trim().parse().unwrap();
    2 * n
}

fn main() {
    let doubled = file_double(&quot;foobar&quot;);
    println!(&quot;{}&quot;, doubled);
}
&lt;/code&gt;&lt;p&gt;其实很多时候用户并不需要将错误立即返回给上层调用者，而只是希望整个函数给出最后一个计算结果即可，这种情况下可以将出错的结果当作一个普通值继续参与后面的计算，这样从上一步可能出错的结果中取出两种可能的值继续送入下一个可能出错的计算里，一直到最后，计算过程得到的都是可能会出错的结果，即 Option 或 Result，与其从包装类型里面取出值进行计算然后得到一个包装类型再取出来，是否可以把这个过程抽象出来呢。组合子就可以实现这个功能，不用取出计算结果然后参与计算然后再取出。。。标准库里为 Option 和 Result 提供了大量的组合子，map, map_err, and, and_then, or, or_else 等这些组合子将 compute -&amp;gt; unwrap -&amp;gt; case analyze -&amp;gt; compute -&amp;gt; unwrap 的过程抽象出来，从代码上看就使计算本身显得更紧凑，而不是被各种错误处理打断。&lt;/p&gt;&lt;p&gt;map 顾名思义就是把值全部取出来做一个操作，不过 map 只对正确值做处理，而对 None 和 Err 不做任何处理，所以 map 的用处就是不用取出 Option, Result 里面的值然后分情况计算，直接将计算作为闭包放在 map 参数里。map_err 正好相反，只对 Err 进行操作，而不处理 Ok 值。&lt;/p&gt;&lt;p&gt;and 和 or 两个则跟操作符 &amp;amp;&amp;amp; 和  || 一样是短路运算，其中 and 连接的两个 Result(或 Option) 如果第一个就是错误的话就短路直接取第一个 Result(或 Option) 的 Err(或 None) 值，否则就取第二个值，而 or 连接的两个 Result(或 Option) 如果第一个是正确的话就直接短路取第一个正确的值 Ok(或 Some)，否则就取第二个值。还有一点需要注意的是 and 连接的两个 Result 的 Err 类型是一样的，而 or 连接的两个 Result 的 Ok 类型是一样的，具体可以看看下面的几个小例子就能理解了，这里之所以没有用 Option 作例子，是因为前面提到的 Option&amp;lt;T&amp;gt; 其实相当于特殊的 Result 即 Result&amp;lt;T, ()&amp;gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// and
let x: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Ok(2);
let y: Result&amp;lt;&amp;amp;str, &amp;amp;str&amp;gt; = Err(&quot;late error&quot;);
assert_eq!(x.and(y), Err(&quot;late error&quot;));

let x: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Err(&quot;early error&quot;);
let y: Result&amp;lt;&amp;amp;str, &amp;amp;str&amp;gt; = Ok(&quot;foo&quot;);
assert_eq!(x.and(y), Err(&quot;early error&quot;));

let x: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Err(&quot;not a 2&quot;);
let y: Result&amp;lt;&amp;amp;str, &amp;amp;str&amp;gt; = Err(&quot;late error&quot;);
assert_eq!(x.and(y), Err(&quot;not a 2&quot;));

let x: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Ok(2);
let y: Result&amp;lt;&amp;amp;str, &amp;amp;str&amp;gt; = Ok(&quot;different result type&quot;);
assert_eq!(x.and(y), Ok(&quot;different result type&quot;));

// or
let x: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Ok(2);
let y: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Err(&quot;late error&quot;);
assert_eq!(x.or(y), Ok(2));

let x: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Err(&quot;early error&quot;);
let y: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Ok(2);
assert_eq!(x.or(y), Ok(2));

let x: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Err(&quot;not a 2&quot;);
let y: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Err(&quot;late error&quot;);
assert_eq!(x.or(y), Err(&quot;late error&quot;));

let x: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Ok(2);
let y: Result&amp;lt;u32, &amp;amp;str&amp;gt; = Ok(100);
assert_eq!(x.or(y), Ok(2));
&lt;/code&gt;&lt;p&gt;在遇到 Result&amp;lt;Result&amp;lt;T, E1&amp;gt;, E2&amp;gt;&amp;gt; 或 Option&amp;lt;Option&amp;lt;T&amp;gt;&amp;gt; 这种高阶错误类型时就得用 and_then 或 or_else 组合子，高阶错误类型用 match 进行模式匹配的话需要嵌套两层 match，分情况分析的话就有四种可能，而有了 and_then 和 or_else 这两个组合子后，则只用调用这两者中的一个就可以得到普通的一阶错误类型，所以在有些语言里称之为 flatmap。还是跟上面短路运算类似，and_then 如果第一个就是错误的话，就直接取第一个错误值，否则就把 and_then 里面的闭包应用到第一个的正确值上；而 or_else 如果第一个是正确值的话就直接取第一个正确值，否则就把 or_else 里面的闭包应用到第一个错误值上面。可以结合下面的例子辅助理解一下&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn sq(x: u32) -&amp;gt; Result&amp;lt;u32, u32&amp;gt; { Ok(x * x) }
fn err(x: u32) -&amp;gt; Result&amp;lt;u32, u32&amp;gt; { Err(x) }

assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));
assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));
assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));
assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));

assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));
assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));
assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));
assert_eq!(Err(3).or_else(err).or_else(err), Err(3));
&lt;/code&gt;&lt;p&gt;这里只简单介绍下上面这几个 combinator，而标准库里面 Option 和 Result 还有大量的 combinator，建议把标准库里 Option 和 Result 的方法都扫一遍，这样在进行错误处理时可以知道用哪些组合子把错误处理串起来。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(file_path: P) -&amp;gt; Result&amp;lt;i32, String&amp;gt; {
    File::open(file_path)
         .map_err(|err| err.to_string())
         .and_then(|mut file| {
              let mut contents = String::new();
              file.read_to_string(&amp;amp;mut contents)
                  .map_err(|err| err.to_string())
                  .map(|_| contents)
         })
         .and_then(|contents| {
              contents.trim().parse::&amp;lt;i32&amp;gt;()
                      .map_err(|err| err.to_string())
         })
         .map(|n| 2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&amp;gt; println!(&quot;{}&quot;, n),
        Err(err) =&amp;gt; println!(&quot;Error: {}&quot;, err),
    }
}
&lt;/code&gt;&lt;p&gt;由于返回值只有一个类型，在上面示例中可能会出现不同的错误 io::Error, num::ParseIntError，为了让程序通过编译，必须将不同的错误转换成同一个类型。这里采用的是最简单的方式，统一转成字符串，对于程序使用者来说，错误就是所能看到的 error message，所以这种处理也是比较自然的。如果同时出现 Option&amp;lt;T&amp;gt; 和 Result&amp;lt;T, E&amp;gt;，则一般是直接通过 ok_or 或 ok_or_else 将 Option&amp;lt;T&amp;gt; 转换成 Result&amp;lt;T, E&amp;gt; 进行处理的。&lt;/p&gt;&lt;p&gt;但是这里在每个地方都写 map_err 会显得很烦琐，后面会介绍如何进行抽象将重复的 map_err 消除掉。除了这个之外，这里还有一个问题，上层调用者拿到 string 类型的错误后，很难再基于这个错误做进一步处理，基本只能将错误打印出来，因为不同的错误都是字符串，上层调用者没法基于字符串对错误进行区分。&lt;/p&gt;&lt;p&gt;要让 Rust 编译器认为本质上不同的类型在编译器层面是相同的，可以利用 trait object 将真正的类型隐藏在指针后面，只要不同类型实现了某个公共 trait，就可以将所有类型都转换成相同的 trait object。trait object 可以通过运行时动态反射得到指针后的类型信息。&lt;/p&gt;&lt;p&gt;Rust 标准库里 Error 就是被定义成 trait 的，而标准库里所有的错误类型都实现了这个 trait，所以都可以转换成 Box&amp;lt;Error&amp;gt; 类型。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;trait Error: Display {
    fn description(&amp;amp;self) -&amp;gt; &amp;amp;str;

    fn cause(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;Error&amp;gt; { None }
}
&lt;/code&gt;&lt;p&gt;前面的例子中 io::Error 和 num::ParseIntError 都被转换成了 String 类型，利用 trait object 可以用 Box&amp;lt;Error&amp;gt; 替换 String 来表示错误。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::error::Error;
use std::convert::From;

fn file_double&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(file_path: P) -&amp;gt; Result&amp;lt;i32, Box&amp;lt;Error&amp;gt;&amp;gt; {
    File::open(file_path)
        .map_err(|err| From::from(err))
        .and_then(|mut file| {
            let mut contents = String::new();
            file.read_to_string(&amp;amp;mut contents)
                .map_err(|err| From::from(err))
                .map(|_| contents)
        })
        .and_then(|contents| {
            contents.trim()
                .parse::&amp;lt;i32&amp;gt;()
                .map_err(|err| From::from(err))
        })
        .map(|n| 2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&amp;gt; println!(&quot;{}&quot;, n),
        Err(err) =&amp;gt; println!(&quot;Error: {}&quot;, err),
    }
}
&lt;/code&gt;&lt;p&gt;链式调用有个缺点是没法在出错时提前返回，要提前返回的话必须从组合子跳出然后再跳出外层函数，这是普通函数没法做到的。不过 Rust 还提供了比普通函数更原始的抽象—宏，直接操作语法单元作为模板在编译期展开，使得我们可以将 return 塞到宏里面，而宏本身不是函数，所以可以直接提前返回。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;macro_rules! try {
    ($expr:expr) =&amp;gt; (match $expr {
        $crate::result::Result::Ok(val) =&amp;gt; val,
        $crate::result::Result::Err(err) =&amp;gt; {
            return $crate::result::Result::Err($crate::convert::From::from(err))
        }
    })
}
&lt;/code&gt;&lt;p&gt;可以看到 try! 宏里面包括了 convert::From::from 函数调用，所以在 try! 宏调用时只要实现了 From 就可以自动进行类型转换，而不用显式地通过 map_err 进行错误类型的转换。下面的例子就是利用了宏可以提前返回，同时可以自动转换类型的特点，前面提到过 io::Error 和 num::ParseIntError 都实现了 Error trait，而标准库里又有 impl&amp;lt;&#39;a, E: Error + &#39;a&amp;gt; From&amp;lt;E&amp;gt; for Box&amp;lt;Error + &#39;a&amp;gt; 所以最终实现了 io::Error 和 num::ParseIntError 到 Box&amp;lt;Error&amp;gt; 的自动转换。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(file_path: P) -&amp;gt; Result&amp;lt;i32, Box&amp;lt;Error&amp;gt;&amp;gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;amp;mut contents));
    let n = try!(contents.trim().parse::&amp;lt;i32&amp;gt;());
    Ok(2 * n)
}
&lt;/code&gt;&lt;p&gt;但是运行时反射要得到错误详细信息是需要一次间接指针访问的，动态分发(dynamic dispatch)访问 Error 的两个方法。这是不太符合 Rust 零开销抽象原则的，所以 Rust 还提供更好的抽象机制处理错误。&lt;/p&gt;&lt;p&gt;这里需要要利用前面提到的 From trait，首先我们看一下这个 trait 的定义，非常简单，只有一个函数&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub trait From&amp;lt;T&amp;gt; {
    fn from(T) -&amp;gt; Self;
}
&lt;/code&gt;&lt;p&gt;前面提到宏里面包括了调用 convert::From::from 所以如果用户自己定义一个错误，然后实现 From trait 将其它错误转成自定义的错误，就可以利用 try! 实现自动调用，上层调用者得到的就是一个用户自定义的错误类型，不用再通过 trait object 间接得到错误类型。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::fs::File;
use std::io::{self, Read};
use std::num;
use std::path::Path;

#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

impl From&amp;lt;io::Error&amp;gt; for CliError {
    fn from(err: io::Error) -&amp;gt; CliError {
        CliError::Io(err)
    }
}

impl From&amp;lt;num::ParseIntError&amp;gt; for CliError {
    fn from(err: num::ParseIntError) -&amp;gt; CliError {
        CliError::Parse(err)
    }
}

fn file_double&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(file_path: P) -&amp;gt; Result&amp;lt;i32, CliError&amp;gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;amp;mut contents));
    let n: i32 = try!(contents.trim().parse());
    Ok(2 * n)
}
&lt;/code&gt;&lt;p&gt;这里我们自定义了错误类型 CliError，并实现了 From trait 从 io::Error 和 ParseIntError 转换到 CliError。既利用了 try! 宏里面的 from 函数自动转换类型省掉了手写烦琐的 map_err，又可以在遇到错误时提前返回，同时上层调用者又可以不用反射就得到具体错误类型方便分情况做进一步处理。&lt;/p&gt;&lt;p&gt;所以算是 Rust 里面比较完美的错误处理方案了，尤其是对库的作者来说，最终发布出来的代码都应该包括自己定义的错误类型，以方便库的使用者拿到错误后能在错误基础上继续分情况进行处理。另外由于库的作者不知道上层应用如何处理错误，所以除非真的需要否则不要在库里面直接 panic。&lt;/p&gt;&lt;p&gt;不过如果需要多次调用 try! 宏的话，代码写出来可能就不大好看了。比如&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let event : EventInfo = try!(try!(try!(try!(try!(self.request(Method::Post, &amp;amp;dsn.get_submit_url()))
    .with_header(&quot;X-Sentry-Auth&quot;, &amp;amp;dsn.get_auth_header(event.timestamp)))
    .with_json_body(&amp;amp;event))
    .send()).convert());
&lt;/code&gt;&lt;p&gt;这里看一串 try! 宏最里面的，构造了一个 Post 请求，这个可能会失败，所以需要一个 try! 处理一次错误，取出里面的正确值，接着用成功的 request 加上 header 信息，这里又有可能出错，所以得再用一个 try!，再然后用加了 header 的 Post 请求加上 json 数据，又是可能失败的操作，所以再来一个 try!，等总算构造出一个 Post 请求后，真正发送出去又是一个可能失败的操作，接着上 try!，请求发出去后，得到 response convert 成 EventInfo 类型，又是一个可能失败的操作，又得来一个 try! 了，不过经历这么多步可能失败的操作，最终终于完成了一个 Post 请求并把结果转换成了用户要的 EventInfo，简直跟西天取经一样要经历这么多磨难才能拿到想要的信息，这在 IO 操作和网络编程时是非常常见的，与外界打交道总是不能保证一定拿到预期的正确值。这里不仔细数还真不知道有几个 try!，看起来当然就有点恶心了。&lt;/p&gt;&lt;p&gt;官方为响应社区的需求引入了&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md&quot; data-title=&quot;问号语法糖&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;问号语法糖&lt;/a&gt;改善这一点，可以将缩在一坨的 try! 分散开成多个问号。一个返回 Result 的函数或方法后面加一个问号，如果是 Err 的话则提前返回，否则就取出 Ok 里面的值，所以借助这个语法糖，上面那串 try! 就可以改写成&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let event : EventInfo = self.request(Method::Post, &amp;amp;dsn.get_submit_url())?
    .with_header(&quot;X-Sentry-Auth&quot;, &amp;amp;dsn.get_auth_header(event.timestamp))?
    .with_json_body(&amp;amp;event)?
    .send()?.convert()?;
&lt;/code&gt;&lt;p&gt;是不是看起来清爽一些了，错误处理本来是在返回错误之后进行的，所以用问号放在函数或方法调用后面表示处理错误比 try! 放在前面更合符合直觉一点，同时问号也有表示询问前面的调用返回的是正确的还是错误的意味，另外就是问号也被分散到每一个方法调用后面而不是集中到一起，所以增加了代码的可读性。其实问号语法糖在其它语言里面也比较常见的。&lt;br&gt;&lt;/p&gt;&lt;p&gt;当然 Rust 里面问号语法糖并不是编译器的黑魔法，而是通过 Carrier trait 来实现的&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub trait Carrier {
    type Success;
    type Error;
    fn from_success(Self::Success) -&amp;gt; Self;
    fn from_error(Self::Error) -&amp;gt; Self;
    fn translate&amp;lt;T&amp;gt;(self) -&amp;gt; T
where T: Carrier&amp;lt;Success=Self::Success, Error=Self::Error&amp;gt;
;
}
&lt;/code&gt;&lt;p&gt;只要实现了这个 trait 就可以吃上这口糖，虽然问号语法糖已经在 stable 版里可用了，但是用户要想让自定义的类型使用这个语法糖的话还是需要 nightly 版的。而且标准库里只对 Result 类型实现了这个 trait，根据 Rust 语法规定(类型和 trait 至少有一个是用户定义的才能给类型实现 trait)用户是没法在 Option 类型上使用问号语法糖的。这个语法糖从加到 nightly 到进入 stable 只用了一个多月时间，这在 Rust 惯例里面还是很少见的，说明这个语法糖还是很受欢迎的。&lt;/p&gt;&lt;p&gt;借助这个语法糖，前面 file_double 的错误处理代码可以进一步简化成&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn file_double&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(file_path: P) -&amp;gt; Result&amp;lt;i32, CliError&amp;gt; {
    let mut contents = String::new();
    File::open(file_path)?.read_to_string(&amp;amp;mut contents)?;
    let n: i32 = contents.trim().parse()?;
    Ok(2 * n)
}
&lt;/code&gt;&lt;p&gt;其实官方还准备引入 try/throw//catch 语法来处理错误的，不过跟一般语言的 try/throw/catch 机制不同，而仍然是基于 Option/Result 的，要求 Result 在穿越多层时能够 cast 成相同类型的 Result，目前 nightly 里有 try_catch 的特性开关，具体细节这里就不展开讲了，感兴趣的读者可以参考&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md&quot; data-title=&quot;RFC说明&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;RFC说明&lt;/a&gt;&lt;/p&gt;&lt;p&gt;所以总结一下 Rust 错误处理有以下几种情况&lt;/p&gt;&lt;ul&gt;&lt;li&gt;原型设计和一些 quick &amp;amp; dirty work 里面可以用 unwrap 或 expect 忽略错误&lt;/li&gt;&lt;li&gt;在不需要提前返回错误时可以链式调用各种 combinator，一气呵成处理错误&lt;/li&gt;&lt;li&gt;需要提前返回错误并且不是写库的话直接用 try! 宏&lt;/li&gt;&lt;li&gt;作为库的作者，应该自己定义错误类型并实现 From trait，然后借助 try! 宏和各种 combinator 综合灵活处理&lt;/li&gt;&lt;li&gt;至于用 try! 宏还是问号语法糖则就看个人和团队喜好了&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;​&lt;/p&gt;&lt;p&gt;&lt;b&gt;---------------更新说明线---------------- &lt;/b&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 感谢 &lt;a href=&quot;http://www.zhihu.com/people/bf95908efb41f3447704e267c6be7139&quot; data-hash=&quot;bf95908efb41f3447704e267c6be7139&quot; class=&quot;member_mention&quot; data-editable=&quot;true&quot; data-title=&quot;@F001&quot; data-hovercard=&quot;p$b$bf95908efb41f3447704e267c6be7139&quot;&gt;@F001&lt;/a&gt;  的指出，问号语法糖这部分官方已经决定要把底层的 Carrier trait 换成 Try trait 了，相应的 try/throw 也不准备引入了。&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于问号语法糖背后的 Carrier trait 还是 nightly 特性，虽然 RFC 0243 已经合并了，但是 Carrier 实现允许任何实现 Carrier trait 之间的类型相互转换，给类型推断增加了很大的难度，如果要限制语义上同类的类型转换则可能需要借助高阶类型(HKT)，而目前 Rust 尚不支持高阶类型，所以 Carrier 的实现和使用被 block 住了，&lt;a href=&quot;https://github.com/nikomatsakis&quot; data-editable=&quot;true&quot; data-title=&quot;nikomatsakis/rfcs&quot; class=&quot;&quot;&gt;Niko &lt;/a&gt;提出的 &lt;a href=&quot;https://github.com/nikomatsakis/rfcs/blob/try-trait/text/0000-try-trait.md&quot; data-editable=&quot;true&quot; data-title=&quot;Try trait&quot; class=&quot;&quot;&gt;Try trait&lt;/a&gt; 就不存在这个问题，&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Try&amp;lt;E&amp;gt; {
    type Success;
    fn try(self) -&amp;gt; Result&amp;lt;Self::Success, E&amp;gt;;
}
&lt;/code&gt;&lt;p&gt;Try trait 只允许语义上相同的类型通过问号语法糖进行转换，比如 Result&amp;lt;T, E&amp;gt; 和 Result&amp;lt;U, F&amp;gt;，而不允许 Result&amp;lt;T, E&amp;gt; 和 Option&amp;lt;T&amp;gt; 之间转，所以类型推断实现起来相对容易些。&lt;/p&gt;&lt;p&gt;由于这个 RFC 尚未合并，这里就不展开讲了，感兴趣的读者可以自己去读读&lt;a href=&quot;https://github.com/nikomatsakis/rfcs/blob/try-trait/text/0000-try-trait.md&quot; data-editable=&quot;true&quot; data-title=&quot;try-trait RFC&quot; class=&quot;&quot;&gt; try-trait RFC&lt;/a&gt; 和&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1859&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;相关的讨论&quot;&gt;相关的讨论&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外 try/throw 的错误处理机制虽然在 RFC 243 里面提到了，不过官方已经放弃引入了。而上面提到的 catch 实际上只是用来将把问号的返回值在函数内部处理掉，如果外层函数的返回值不是 Result 类型，而函数内部又用到了问号语法糖，就会出现类型不匹配的错误， catch 的作用就是把含有问号的表达式或语句框住并处理掉，从而不让 Result 蔓延。&lt;/p&gt;</description>
<author>tennix</author>
<guid isPermaLink="false">2017-03-03-25506762</guid>
<pubDate>Fri, 03 Mar 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Non Lexical Lifetime</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-02-25-25429005.htm</link>
<description>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Non Lexical Lifetime&lt;/title&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25429005&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Non Lexical Lifetime 是 Rust team 很久很久以前就想做的一个功能，但是因为各种原因，一直拖了好几年。最近，随着 Nicholas Matsakis 的一篇博客，这个问题再度纳入我们的视野中。实现方案已经基本成熟，这个功能可能很快就要跟大家见面了。本文主要是把 Nicholas 关于 Non Lexical Lifetime 的几篇博客做一个梳理，方便大家了解这个功能的来龙去脉。&lt;/p&gt;&lt;p&gt;Lifetime 生命周期，是 Rust 语言的一个重要概念。编译器通过对变量和指针的生命周期分析，来保证内存安全性。事实已经证明，这套设计是有用的，它能够保证，通过了生命周期检查的代码，都是内存安全的代码。但是，在实际使用过程中，大家还是会觉得这个检查规则有点过于严格，以致于某些实质上是安全的代码，也被阻止了。这说明，Rust目前的生命周期检查规则，可能过于保守了，在某些场景下，限制了程序员的发挥。我们来看看 Nicholas 博客中的几个示例。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;use std::ascii::AsciiExt;

fn foo() -&amp;gt; Vec&amp;lt;char&amp;gt; {
    let mut data = vec![&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; // --+ &#39;scope
    capitalize(&amp;amp;mut data[..]);          //   |
//  ^~~~~~~~~~~~~~~~~~~~~~~~~ &#39;lifetime //   |
    data.push(&#39;d&#39;);                     //   |
    data.push(&#39;e&#39;);                     //   |
    data.push(&#39;f&#39;);                     //   |
    data                                //   |
// &amp;lt;-----------------------------------------+
} 

fn capitalize(data: &amp;amp;mut [char]) {
    for c in data {
        c.make_ascii_uppercase();
    }
}

fn main() {
    let v = foo();
    println!(&quot;{:?}&quot;, v);
}
&lt;/code&gt;&lt;p&gt;这段代码是没问题的。我们的关注点是 foo() 这个函数，它在调用 capitalize 函数的时候，创建了一个临时的 &amp;amp;mut 型引用，在它的调用结束后，这个临时的借用就终止了，因此，后面我们就可以再用 data 去修改数据。&lt;/p&gt;&lt;p&gt;但是，如果我们把这段代码稍微改改，问题就出现了：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn foo() -&amp;gt; Vec&amp;lt;char&amp;gt; {
    let mut data = vec![&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; // --+ &#39;scope
    let slice = &amp;amp;mut data[..];// &amp;lt;-----------+ &#39;lifetime
    capitalize(slice);                  //   |
    data.push(&#39;d&#39;);  //ERROR            //   |
    data.push(&#39;e&#39;);  //ERROR            //   |
    data.push(&#39;f&#39;);  //ERROR            //   |
    data             //ERROR            //   |
// &amp;lt;-----------------------------------------+
}
&lt;/code&gt;&lt;p&gt;这段代码中，我们创建了一个临时变量 slice，然后再调用 capitalize 函数，就出问题了。编译器提示为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;error[E0499]: cannot borrow `data` as mutable more than once at a time
&lt;/code&gt;&lt;p&gt;这是因为，Rust规定，“共享不可变，可变不共享”，同时出现两个 &amp;amp;mut 型借用是违反规则的。在编译器报错的地方，编译器认为 slice 依然还存在，然而又使用 data 去调用 fn push(&amp;amp;mut self, value: T) 方法，这里必然又会产生一个 &amp;amp;mut 型借用，这违反了Rust的原则。在目前这个版本中，如果我们要修复这个问题，只能这么做：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn foo() -&amp;gt; Vec&amp;lt;char&amp;gt; {
    let mut data = vec![&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; // --+ &#39;scope
    {
        let slice = &amp;amp;mut data[..];// &amp;lt;-------+ &#39;lifetime
        capitalize(slice);              //   |
    }// &amp;lt;------------------------------------+
    data.push(&#39;d&#39;); 
    data.push(&#39;e&#39;); 
    data.push(&#39;f&#39;); 
    data

}
&lt;/code&gt;&lt;p&gt;我们手动创建一个代码块，让 slice 在这个子代码块中创建，在 slice 存在的期间，data 暂时处于冻结状态。退出这个代码块的时候，slice就会被销毁，后面就不会产生生命周期冲突问题了。&lt;/p&gt;&lt;p&gt;这里的问题的关键就在于：目前的版本中，每个引用的生命周期，是跟代码块（scope）相关联的，它总是从声明的时候被创建，在退出这个代码块的时候被销毁。所谓的 Non-Lexical，意思就是，取消这个关联性，引用的生命周期，我们用另外的，更智能的方式分析。有了这个功能，上例中手动加入的代码块就不需要了，编译器应该能自动分析出来，slice在capitalize函数调用后就再没有被使用过了，它的生命周期完全可以就此终止，不会对程序的正确性有任何影响，后面再用 data 修改数据，也不会有编译错误了。&lt;/p&gt;&lt;p&gt;看了上面这个例子，可能有人还会觉得，显式的用一个代码块来规定局部变量的生命周期是个更好的选择，Non-Lexical-Lifetime 的意义似乎并不大。那我们再继续看看更复杂的例子，我们可以发现，Non-Lexical-Lifetime 可以打开更多的可能性，让用户有机会用更直观的方式写代码。比如下面这样的一个分支结构的程序：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn process_or_default&amp;lt;K,V:Default&amp;gt;
    (map: &amp;amp;mut HashMap&amp;lt;K,V&amp;gt;, key: K) 
{
    match map.get_mut(&amp;amp;key) { // -------------+ &#39;lifetime
        Some(value) =&amp;gt; process(value),     // |
        None =&amp;gt; {                          // |
            map.insert(key, V::default()); // |
            //  ^~~~~~ ERROR.              // |
        }                                  // |
    } // &amp;lt;------------------------------------+
}
&lt;/code&gt;&lt;p&gt;这段代码从一个 HashMap 中查询某个 key 是否存在，如果存在，就继续处理，如果不存在，就插入一个新的值。目前这段代码是编译不过的，因为编译器会认为在调用 get_mut(&amp;amp;key) 的时候，产生了一个指向 map 的 &amp;amp;mut 型引用，而且它的返回值也包含了一个引用，返回值的生命周期是和参数的生命周期是一致的。这个方法的返回值会一直存在于整个 match 语句块中，所以编译器判定，针对 map 的引用也是一直存在于整个 match 语句块中。于是后面调用 insert 方法会发生冲突。如果我们希望让这段代码编译通过，可以试一下做这样的修复：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn get_default1&amp;lt;&#39;m,K,V:Default&amp;gt;(
    map: &amp;amp;&#39;m mut HashMap&amp;lt;K,V&amp;gt;,key: K)
   -&amp;gt; &amp;amp;&#39;m mut V 
{
    match map.get_mut(&amp;amp;key) { // -------------+ &#39;m
        Some(value) =&amp;gt; return value,       // |
        None =&amp;gt; { }                        // |
    }                                      // |
    map.insert(key, V::default());         // |
    //  ^~~~~~ ERROR (still)                  |
    map.get_mut(&amp;amp;key).unwrap()             // |
}                                          // v
&lt;/code&gt;&lt;p&gt;实际上依然会编译失败。原因就在于那个 return 语句，get_mut时候对map的借用，传递给了Some(value)，而我们又把 value 返回出去了，这意味着编译器认为，这个借用从 match 开始一直到退出这个函数都存在。因此后面的 insert 调用依然发生了冲突。接下来我们再做一次修复：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn get_default2&amp;lt;&#39;m,K,V:Default&amp;gt;(
    map: &amp;amp;&#39;m mut HashMap&amp;lt;K,V&amp;gt;,
    key: K)
   -&amp;gt; &amp;amp;&#39;m mut V 
{
    if map.contains(&amp;amp;key) {
    // ^~~~~~~~~~~~~~~~~~ &#39;n
        return match map.get_mut(&amp;amp;key) { // + &#39;m
            Some(value) =&amp;gt; value,        // |
            None =&amp;gt; unreachable!()       // |
        };                               // v
    }

    // At this point, `map.get_mut` was never
    // called! (As opposed to having been called,
    // but its result no longer being in use.)
    map.insert(key, V::default()); // OK now.
    map.get_mut(&amp;amp;key).unwrap()
}
&lt;/code&gt;&lt;p&gt;这次的区别在于，get_mut发生在一个分支结构中，在这种情况下，编译器会认为这个借用跟 if 外面的代码没什么关系。通过这种方式，我们终于绕过了 borrow checker。但是，为了绕过编译器的限制，我们付出了一些代价。这段代码，我们需要执行两次 hash 查找，一次在 contains 方法，一次在 get_mut 方法，因此它有额外的性能开销。这也是为什么标准库中的 HashMap 设计了一个叫做 entry 的 api，如果用 entry 来写这段逻辑，可以这么做：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn get_default3&amp;lt;&#39;m,K,V:Default&amp;gt;(
    map: &amp;amp;&#39;m mut HashMap&amp;lt;K,V&amp;gt;,
    key: K)
   -&amp;gt; &amp;amp;&#39;m mut V 
{
    map.entry(key)
       .or_insert_with(|| V::default())
}
&lt;/code&gt;&lt;p&gt;这个设计既清晰简洁，也没有额外性能开销，而且不需要 Non-Lexical-Lifetime 的支持。这说明，虽然目前的生命周期检查确实有点过于严格，但我们其实还是有办法绕过去的，不一定要在“良好的抽象”和“安全性”之间做妥协。但是它付出了其它的代价，那就是使用难度更高，更不容易被掌握。标准库中的 entry API 也是很多高手经过好长时间才最终设计出来的产物。对于普通用户而言，如果在其它场景下出现了类似的冲突，恐怕大部分人都没有能力想到一个最佳方案，既避过编译器限制，又不损失性能，所以在实践中很多场景下，普通用户做不到“零开销抽象”。&lt;/p&gt;&lt;p&gt;从 &lt;a href=&quot;https://blog.rust-lang.org/2017/02/06/roadmap.html&quot; data-editable=&quot;true&quot; data-title=&quot;Rust 2017年发展规划&quot;&gt;Rust 2017年发展规划&lt;/a&gt; 我们可以看到，今年的重要目标是：This year, the overarching theme is productivity, especially for early-stage Rust users. 为了让学习成本更低，更易于使用，这也是为什么 Non-Lexical-Lifetime 被再次拿出来，成为今年的一个重要目标。&lt;/p&gt;&lt;p&gt;既然这个功能这么有用，那么为什么还拖了这么久呢。一方面是，Rust team 还有更重要更紧急的事情要完成，另一方面，这个功能要依赖编译器重构，要等 &lt;a href=&quot;https://blog.rust-lang.org/2016/04/19/MIR.html&quot; data-editable=&quot;true&quot; data-title=&quot;MIR&quot;&gt;MIR&lt;/a&gt; 完成之后，再来做，事半功倍。新的生命周期分析，不会再基于 AST 中的 scope 来设计，而是会基于 MIR 中的控制流图(Control Flow Graph)来设计。这个功能不能简单的在 AST 中分析一下某个引用最后一次在哪里使用，就让它的生命周期提前结束算了。还是拿博客中的示例来说明：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn baz() {
    let mut data = vec![&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
    let slice = &amp;amp;mut data[..]; // &amp;lt;-+ lifetime if we ignored
    loop {                     //   | variables altogether
        capitalize(slice);     //   |
        // &amp;lt;------------------------+
        data.push(&#39;d&#39;); // Should be error, but would not be.
    }
    data.push(&#39;e&#39;); // OK
    data.push(&#39;f&#39;); // OK
}
&lt;/code&gt;&lt;p&gt;在这个示例中，我们引入了一个循环结构。如果我们只是分析 AST 的结构的话，很可能会觉得 capitalize 函数结束后，slice 的生命周期就结束了，因此 data.push() 方法调用是合理的。但这个结论是错误的。大家想想看，如果执行了 push() 方法后，引发了 Vec 数据结构的扩容，它把以前的空间释放掉了，然后申请了新的空间，进入下一轮循环的时候，slice就会指向一个非法地址，会出现内存不安全。基于控制流图的分析，就可以轻松判断出来，通过两个指针对同一个 Vec 在轮流做修改，这是错误的，新版的生命周期分析，依然会认为 slice 的生命周期应该在 loop 结束之后才会结束。以上这段代码应该出现编译错误。&lt;/p&gt;&lt;p&gt;这个新版的分析器，会允许下面的代码编译成功，比如：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let mut v = vec![1,2,3,4,5];
    v.push(v.len());
    println!(&quot;{:?}&quot;, v);
}
&lt;/code&gt;&lt;p&gt;再比如：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
  let mut data = 100_i32;
  let mut p = &amp;amp;data;// p is live
  println!(&quot;{}&quot;, p);// p is dead

  data = 101;
  p = &amp;amp;data;        // p is live again
  println!(&quot;{}&quot;, p);// p is dead again
}
&lt;/code&gt;&lt;p&gt;另外，需要强调的是，这个改进只会影响“引用”的生命周期，不影响对象的生命周期。也就是说，对于携带有析构函数的对象，析构函数的调用永远是当前 scope 结束的时候调用，同一个 scope 中，先声明的后调用。绝对不能在对象不被继续使用之后，就认为它失去了“活性”，从而提前调用析构函数。如果这么做的话，将会使 RAII 手法彻底失去意义。&lt;/p&gt;&lt;p&gt;当然，这样的改进对于某些初学者来说，可能更加难以理解了。但是不要紧，已经有人在努力提供更好的开发工具，让大家对生命周期的理解更加直观，更加深刻。基本想法就是，在 Rust Language Service 中，把各个对象的生命周期分析结果也暴露出来，让编辑器把生命周期范围显示出来。就像常用的代码自动提示一样，在开发过程中，哪个变量的生命周期在哪个范围内，一目了然。参考 &lt;a href=&quot;https://internals.rust-lang.org/t/borrow-visualizer-for-the-rust-language-service/4187&quot; data-editable=&quot;true&quot; data-title=&quot;Borrow visualizer for the Rust Language Service&quot; class=&quot;&quot;&gt;Borrow visualizer for the Rust Language Service&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0d2e56f6af76582af8fd0680116b69f2_r.png&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;431&quot;&gt;&lt;br&gt;&lt;p&gt;最后，关于 Non Lexical Lifetime 的小结：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;这个功能只影响静态分析结果，不影响程序的执行情况。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;以前能编译通过的程序，以后依然会编译通过，不会影响以前的代码。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;它依然保证了安全性，只是将以前过于保守的检查规则适当放宽。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;它依赖的依然是静态检查规则，不会涉及任何动态检查规则。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;它只影响“引用类型”的生命周期，不影响“对象”的生命周期，即维持现有的析构函数调用时机不变。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-02-25-25429005</guid>
<pubDate>Sat, 25 Feb 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
