<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>MPS教程二：制作一个简易语言（上）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/26239470">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-b348252f31551b3ac444e0df9e6bd0e0_r.png" alt=""></div><p>原文 <a href="http://ice1000.org/2017/04/06/MakeConstantWithMPS/" data-editable="true" data-title="MPS教程二：制作一个简易语言（上）" class="">MPS教程二：制作一个简易语言（上）</a></p><p>知乎的编辑器用的<b>痛彻心扉</b>。</p><p>在上一篇教程中，我们已经简单体验过了MPS的一个工作流程——创建新工程，导入一个<strong>语言</strong>，使用这个语言编写代码。 在这篇教程中，我将向你展示如何创建一门简单的语言。</p><h2>我们要创建的语言的功能</h2><p>出于难度考虑，这次我们构建的语言将只有“向屏幕输出”的功能，也就是一个只能println的语言。</p><p>它没有工业价值，只有教学价值。</p><h3>为什么这么简单</h3><p>因为这篇文章要引入很多关于MPS创建语言的新概念</p><h3>有哪些新概念</h3><ul><li>Concept</li><li>Editor</li><li>Generator</li></ul><h2>本文主要内容</h2><ul><li>Concept的定义</li><li>如何开始破界神编辑</li></ul><h2>依赖</h2><ul><li>MPS 2017.1</li><li>编译原理相关知识（起码你得知道啥是AST，Abstract Syntax Tree）</li><li>阅读<a href="http://ice1000.org/2017/03/18/TryShapeWithMPS/" data-editable="true" data-title="上篇博客">上篇博客</a></li></ul><p>上篇博客里使用的还是 2017.1 RC ， 现在已经出了正式版啦。</p><h2>开始吧</h2><p>首先我们需要打开MPS，并像上次一样创建一个新工程。 这次我们选择创建一个Language工程，并勾选<strong>Create a SandBox Solution</strong>选项。<img src="https://pic2.zhimg.com/v2-00a9dfdc3d3e170ed504c63c31c20780_r.png" data-rawwidth="630" data-rawheight="550"></p><p>这时，你会进入到你自己创建的工程界面。左边有一个不同于其他JB IDE的<strong>logical view</strong>，它是这个工程的逻辑结构。</p><p>打开文件系统中的MPS工程，你会看到一大堆：</p><ul><li>*.class</li><li>*.java</li><li>*.xml</li><li>*.mps</li><li>*.mpl</li><li>*.msd</li></ul><p>将代码托管到Git时，一般不上传java和class文件（这些文件一般都是MPS的Code Generator生成的，不是“源代码”性质的源代码）。</p><p>mpl是整个MPS工程的配置文件（可以理解为： MPs Language的缩写），而mps是MPS工程组件文件，其实就是xml。</p><p>好，我们回到工程界面。<img src="https://pic4.zhimg.com/v2-76211e3f8b843e31816408032b87f3f6_r.png" data-rawwidth="490" data-rawheight="295"></p><p>这时我们来理一下LOP的基本思想。其实LOP和OOP、PP多有几分相似之处，他们都是“为了实现代码复用”而做出的一种“将代码模块化”的方式。</p><p>首先声明：我没有引战，我没有说任何编程范式的好坏！！！！！</p><h2>LOP的基本认识</h2><p>首先我们和另外两种类似的编程范式对比一下：</p><p>（PP = Procedural Programming）</p>模式                           抽象出来复用的代码组织形式<p>PP                             函数（方法，例程）</p><p>OOP                         对象（类，单例，原型）</p><p>LOP                          语言</p><p>注意一下，所谓的“函数式编程（FP）”不属于这个分类范畴，这里不做讨论。PP不是FP，PP是有很多（大部分情况下）函数， 但是</p><blockquote>有函数 != 函数式编程</blockquote><p>请务必注意！</p><p>这是过程式编程，听好了：</p><blockquote><p>Procedural programming is a programming paradigm, derived from structured programming, based upon the concept of the procedure call. Procedures, also known as routines, subroutines, or functions (not to be confused with mathematical functions, but similar to those used in functional programming), simply contain a series of computational steps to be carried out. Any given procedure might be called at any point during a program’s execution, including by other procedures or itself.</p></blockquote><p>上文摘自<a href="https://en.wikipedia.org/wiki/Procedural_programming" data-editable="true" data-title="Wikipedia">Wikipedia</a></p><p>英语不好的看中文：</p><blockquote><p>过程式程序设计（英语：Procedural programming），又称过程式编程、过程化编程，一种编程范型，有时会被视为是命令式编程的同义语。派生自结构化编程（Structured programming），主要采取程序调用（procedure call）或函数调用（function call）的方式来进行流程控制。流程则由包涵一系列运算步骤的程序（Procedures），例程（routines），子程序（subroutines）, 方法（methods），或函数（functions）来控制。在程序运行的任何一个时间点，都可以调用某个特定的程序。任何一个特定的程序，也能被任意一个程序或是它自己本身调用。</p></blockquote><p>上文摘自<a href="https://zh.wikipedia.org/zh-hans/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B" data-editable="true" data-title="Wikipedia中文区">Wikipedia中文区</a></p><p>想想，</p><ul><li>在PP里面，函数可以调用其他函数。</li><li>在OOP里面，对象可以“拥有”其它对象。</li></ul><p>那么在LOP里面，“语言”这个概念也被泛化了——所有的<em>语言</em>都是DSL，所有的<em>语言</em>之间都是可以交互的，你可以把很多门<em>语言</em>混着写。</p><p>一门<em>语言</em>可以是另一门<em>语言</em>的子集，你也可以扩展现有的语言。也就是说，</p>编程范式               编程过程<p>PP                        写函数 -&gt; 写程序</p><p>OOP                     写类/单例/原型 -&gt; 写程序</p><p>LOP                      写语言 -&gt; 写程序</p><p>这里的<em>语言</em>的概念有点不同于以前的语言，因此我使用了斜体标注。如果你没有看到斜体，说明这文章是从我博客原文抄过去的没注意格式，请帮我举报一下。</p><p>下文的<em>语言</em>除非特别注明，都是指LOP中的<em>语言</em>，为了方便，我不再使用斜体标注。</p><h2>MPS中的LOP</h2><p>MPS中，语言是由很多<strong>Concept</strong>组成的，这些<strong>Concept</strong>有各自的属性、限制等，它们相当于是<strong>AST中的节点</strong>。</p><p>由于现在的编程模式大多数都是<em>写代码</em>，于是MPS也把程序编辑的过程弄成了<em>一种类似写代码</em>的形式，叫<strong>破界神编辑</strong>，上文已经说过啦。</p><p>因此，我们需要定义语言的<em>语法</em>。语言的语法，在MPS里面叫做<strong>Editor</strong>。</p><p>我们通过MPS创建的语言所编写的代码，需要通过<strong>Generator</strong>生成目标代码（比如本文使用的Java）。</p><p>因此本文（及后文）介绍的三个概念你应该很清楚了——</p><ul><li>Concept</li><li>Editor</li><li>Generator</li></ul><h2>创造语言</h2><p>说下这个语言的设计：</p><p>每个文件有一个PrintlnSet（类似容器），里面放一堆Println，每个Println对应一个输出。</p><h3>导入一些东西</h3><p>对左边Logical View的<strong>VerboseLang</strong>使用<strong>Alt+Enter</strong>， 然后按Dependency选项卡下的绿色加号的导入JDK这个Dependency：<img src="https://pic3.zhimg.com/v2-c2247ba246ff5dfdff432667f3384617_r.png" data-rawwidth="848" data-rawheight="648"></p><h3>Concept</h3><p>我们首先创建我们需要的Concept——PrintlnSet，和Println。<img src="https://pic3.zhimg.com/v2-bec79264b840e8e5adb621b30b119fdd_r.png" data-rawwidth="886" data-rawheight="248"></p><p>然后我们需要让它们：</p><p>Println:</p><ul><li>不能是AST根节点</li><li>拥有一个String</li><li>键入p就可以出来（这是一个类似Live Template的效果，在语言中不是必须的，但是就顺便讲下）</li></ul><p>PrintlnSet:</p><ul><li>可以是AST根节点</li><li>拥有很多Println</li></ul><p>于是这就是Println了：<img src="https://pic3.zhimg.com/v2-455c6aa3c6d8ce4a31ada664a05a3091_r.png" data-rawwidth="516" data-rawheight="279"></p><p>请注意我红框标注的需要填写的内容，和上面说的几个需求一一对应。</p><p>请注意，编辑完之后请<strong>Ctrl+S</strong>保存，这样MPS才会识别你的编辑结果。</p><p>另外，请时不时记得按下<strong>Ctrl+F9</strong>来<em>编译</em>你的语言。因为语言要编译了才能使用。</p><p>然后这是PrintlnSet：<img src="https://pic4.zhimg.com/v2-70e4a4ff44b3a3bdffb99e8972861690_r.png" data-rawwidth="532" data-rawheight="336"></p><p>然后我们就成功地写好我们的两个<strong>Concept</strong>啦。</p><h3>第一次使用自己的语言</h3><p>请注意这里的语言并不能运行。</p><p>点击你的Generator（我们现在不需要过多接触它）。<img src="https://pic1.zhimg.com/v2-7af0ee82573164f835f2acc89023325d_r.png" data-rawwidth="348" data-rawheight="222"></p><p>在root mapping rules里面添加这么一段：<img src="https://pic2.zhimg.com/v2-f397c5d54f46b9937b88b8be8297987f_r.png" data-rawwidth="712" data-rawheight="167"></p><p>设置它对应的Concept为PrintlnSet。</p><p>然后对那个红色的No Template使用<strong>Alt+Enter</strong>，然后<strong>选择class</strong>， 让它怀疑人生创建一个新的class的Template：<img src="https://pic3.zhimg.com/v2-4b9e202a285937edb48bc1550deb0d9c_r.png" data-rawwidth="585" data-rawheight="167"></p><p>然后你左边的Logical View会多出来一个自动生成的map_PrintlnSet，先不管它。</p><p><strong>编译一下。</strong></p><p>我们右键左边的晾了很久的<strong>sandbox</strong>，创建一个PrintlnSet：<img src="https://pic3.zhimg.com/v2-c4c04fa53ebc3bc70ab8f27b151fa94b_r.png" data-rawwidth="777" data-rawheight="182"></p><br><p>你可以看到已经有一个PrintlnSet出现了！激动吧！<img src="https://pic2.zhimg.com/v2-325d8798c8c7e4d0ee1de60ffe8a69b7_r.png" data-rawwidth="532" data-rawheight="212"></p><br><p>然后你在那个</p><br><code lang="text">&lt;&lt; ... &gt;&gt;
</code><p>处按下p，然后你发现出来了一个Println！<img src="https://pic3.zhimg.com/v2-cbd3f96bbbd1510f3597680d78b6e28f_r.png" data-rawwidth="501" data-rawheight="208"></p><p>你可以在content里面输入一个字符串：<img src="https://pic4.zhimg.com/v2-a087cbfbcad9ef9f31711327d025f15c_r.png" data-rawwidth="557" data-rawheight="250"></p><p>欧耶~ 现在我们的语言的最小组成部分已经完成了一大半了。</p><p>你已经可以像编辑上次介绍的<a href="http://ice1000.org/2017/03/18/TryShapeWithMPS/" data-editable="true" data-title="ShapeLanguage">ShapeLanguage</a>那样进行破界神编辑了。</p><h2>下次讲什么</h2><p>下次我们将让它生成Java代码，运行起来。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
