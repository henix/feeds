<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>zkSNARK零知识证明(未完待续)</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/45038515">原文</a></p>
<p>证明有一个多元多项式的解。</p><h2>同态隐藏Homomorphic Hidings(HH)</h2><p>函数 <equation>E(x)</equation> 如果满足以下条件:</p><ol><li>知道 <equation>E(x)</equation> ,几乎不可能解出 <equation>x</equation> </li><li>如果 <equation>x \neq y</equation> ,则 <equation>E(x)\neq E(y)</equation> </li><li>如果知道 <equation>E(x),E(y)</equation> ，可以推算出 <equation>E(x+y)</equation> 等</li></ol><p>则 <equation>E(x)</equation> 为 <equation>x</equation> 的Homomorphic Hidings(HH)</p><p>例如Alice想向Bob证明自己有 <equation>x+y=7</equation> 的可行解：</p><ol><li>Alice计算 <equation>E(x),E(y)</equation> ,然后发给Bob</li><li>Bob通过 <equation>E(x),E(y)</equation> 计算出 <equation>E(x+y)</equation> </li><li>Bob检查是否满足 <equation>E(x+y)=E(7)</equation> ,如果等式成立，那么Bob接收Alice有 <equation>x+y=7</equation> 的解</li></ol><p>通过这个过程，Alice并没有暴露可行解，但又可以向Bob证明自己有可行解</p><h2>Blind evaluation of a polynomial</h2><p>在 <equation>\mathbb{F}_p</equation> 上的d次多项式 <equation>P</equation> :</p><p><equation>P(X)=a_0+a_1\cdot X +a_2\cdot X^2 + a_3\cdot X^3+...+a_d\cdot X^d, \text{其中}a_0,...a_d\in \mathbb{F}_p</equation> </p><p>我们想用 <equation>s\in \mathbb{F}_p</equation> 隐藏起来，例如这里我们用HH函数 <equation>E(x)=g^x</equation> ，则有:</p><p><equation>E(ax+by)=g^{ax+by}=g^{ax}\cdot g^{by}=E(x)^a\cdot E(y)^b</equation> </p><p><br></p><p>可以看到 <equation>x,y</equation> 线性组合的同态隐藏可以通过 <equation>E(x),E(y)</equation>算出来，那么：</p><p><equation>P(s)=a_0+a_1\cdot s + a_2\cdot s^2+...+a_d\cdot s^d </equation> <equation> 因为P(s)是s^1,...,s^d的线性组合，所以E(P(s))\text{可以通过}E(s),E(s^2),...E(s^d)算出来</equation> </p><p><br></p><p>我们得到以下协议：</p><ol><li>Bob选出 <equation>s\in \mathbb{F}_p</equation> 并计算出 <equation>E(s),E(s^2),...E(s^d)</equation> ，发给Alice</li><li>Alice通过 <equation>E(s),E(s^2),...E(s^d)</equation> 计算出 <equation>E(P(s))</equation> </li></ol><p>这里的多项式盲求值（Blind evaluation of a polynomial），表现在Alice不需要知道 <equation>s</equation> 就可以计算 <equation>P(s)</equation> 的同态隐藏</p><p>但现在出现了一个问题，Alice可以随意发一个并不是 <equation>E(P(s))</equation> 的结果。在这种情况下Bob怎么检查Alice发的确实是 <equation>E(P(s))</equation> 呢？</p><h2>Verifiable blind evaluation of a polynomial</h2><p>先看case1:</p><ol><li>Bob发给Alice, <equation>(a,b)</equation> ,其中 <equation>b=\alpha\cdot a</equation> </li><li>Alice需要计算并发送 <equation>(a',b')</equation> 给Bob，必须满足 <equation>b'=\alpha\cdot a'</equation> </li></ol><p>因为Bob推算不出 <equation>\alpha</equation> ,所以只能取 <equation>a'=\gamma\cdot a, b'=\gamma\cdot b</equation> ,才能满足要求</p><p>再看case2:</p><ol><li>Bob发送 <equation>(a_1, b_1),(a_2, b_2),\ b_1=\alpha\cdot a_1,b_2=\alpha\cdot a_2,</equation> 给Alice</li><li>Alice需要计算并发送 <equation>(a',b')</equation> 给Bob，必须满足 <equation>b'=\alpha\cdot a'</equation></li></ol><p>这种情况下,Alice可以选择 <equation>a'=c_1\cdot a_1 + c_2\cdot a_2,\  b' = c_1\cdot b_1 + c_2\cdot b_2</equation> </p><p>可以看到只要Bob只要检查 <equation>b'=\alpha\cdot a'</equation> 可以保证 <equation>a'</equation> 是 <equation>a</equation> 的线性组合</p><p>case3:</p><p>再回到多项式的情况,</p><ol><li>Bob发送 <equation>(E(s),  E(\alpha\cdot s)), (E(s^2),  E(\alpha\cdot s^2)),...,(E(s^d), E(\alpha\cdot s^d)),  </equation> 给Alice,设 <equation>E(x)=x\cdot g</equation> ,也就是 <equation>(s\cdot g,s^2\cdot g,...,s^d\cdot g), (\alpha s\cdot g,\alpha s^2\cdot g,...,\alpha s^d\cdot g)</equation></li><li>Alice选择 <equation>a'=\sum_{i=0}^{d}{c_i s^i\cdot g}=P(s)\cdot g=\sum_{i=0}^{d}{c_i E(s^i)},</equation><equation> b'=\sum_{i=0}^{d}{c_i \alpha s^i\cdot g}=\alpha P(s)\cdot g=\sum_{i=0}^{d}{c_i \alpha E(s^i)},</equation> 发给bob</li></ol><p>Bob检查 <equation>b'=\alpha\cdot a'</equation> 后，可以认定 <equation>a'=E(P(s)), </equation> 其中 <equation>P(s)=c_0+c_1\cdot s + c_2\cdot s^2+...+c_d\cdot s^d </equation> </p><p>也就是Bob可以验证Alice发过来的是之前Bob发给Alice的同态隐藏的线性组合的同态隐藏</p><h2>Quadratic Arithmetic Program(QAP)</h2><p>设一个QAP为 <equation>Q</equation> ，size为m, degree为d，包含 <equation>L_1,L_2,L_3,...,L_m,\ R_1,R_2,R_3,...,R_m,\ O_1,O_2,O_3,...,O_m,\text{和一个d次目标多项式}T</equation> </p><p><br></p><p>一组 <equation>\{c_0, c_1, c_2,...,c_m\}</equation> 如果满足:</p><p><equation>L=\sum_{i=1}^{m}{c_i\cdot L_i},\  R=\sum_{i=1}^{m}{c_i\cdot R_i},\  O=\sum_{i=1}^{m}{c_i\cdot O_i}, \text{和 }P:=L\cdot R - O, \text{并且有}T\text{ 整除}P   </equation> </p><p>则称这组 <equation>\{c_0, c_1, c_2,...,c_m\}</equation>满足 <equation>Q</equation> </p><h2>Pinocchio协议</h2><p>如果Alice有满足 <equation>Q</equation> 的一组解，那么一定有d次多项式 <equation>H</equation> 满足:</p><p><equation>P = H\cdot T\text{ 等价于：对于}\forall s \in \mathbb{F}_p\text{有}P(s)=H(s)\cdot T(s)</equation> </p><p><br></p><p>我们看一下Alice怎么向Bob证明自己有满足 <equation>Q</equation> 的解</p><ol><li>Alice算出满足 <equation>Q</equation> 的 <equation>L,R,O,H</equation> </li><li>Bob选择 <equation>s \in \mathbb{F}_p</equation> ,计算出 <equation>E(T(s))</equation> </li><li>Alice计算出 <equation>E(L(s)),E(R(s)),E(O(s)),E(H(s))</equation> 发给Bob</li><li>Bob检查 <equation>E(L(s)\cdot R(s)-O(s))=E(H(s)\cdot T(s))</equation> </li></ol><p>这里的<b>第一个问题</b>是:只检查 <equation>s</equation> 一个点，会不会有问题？</p><p>两个不同的 <equation>2d</equation> 次多项式，不可能超过 <equation>2d</equation> 个点相同，所以只要 <equation>\mathbb{F}_p</equation> 的size比 <equation>2d</equation> 大很多就没有问题，取到相同点的概率非常的小</p><p><br></p><p>这里会有<b>第二个个问题</b>: Alice可以随意构造出 <equation>L,R,O,H</equation> 满足 <equation>L\cdot R-O =T\cdot H</equation> ,但是并不能满足 <equation>L=\sum_{i=1}^{m}{c_i\cdot L_i},\  R=\sum_{i=1}^{m}{c_i\cdot R_i},\  O=\sum_{i=1}^{m}{c_i\cdot O_i}</equation> 。我们可以想一个办法把这个限制条件也加进去:</p><p><br></p><p>利用Verifiable blind evaluation of a polynomial，直观的方法是对于 <equation>L_i</equation> ：</p><ol><li>Bob计算并发送 <equation>(E(L_0(s)), \alpha\cdot E(L_0(s))), (E(L_1(s)), \alpha\cdot E(L_1(s))),...,(E(L_m(s)), \alpha\cdot E(L_m(s))),  </equation> </li><li>Alice <equation>a'=\sum_{i=0}^{m}{c_i E(L_i(s))}, b'=\sum_{i=0}^{m}{c_i \alpha E(L_i(s))}</equation> ,其中 <equation>a'=\sum_{i=0}^{m}{c_i\ E(L_i(s))}=E(L(s))</equation> </li><li>Bob接收到之后检查是否满足 <equation>b'=\alpha\cdot a'</equation> ,同时检查 <equation>a'=E(L(s))</equation> </li></ol><p>这样可以确保 <equation>L,</equation> 是 <equation>L_0,L_1,...,L_m</equation> 的线性组合。</p><p>同样对于 <equation>R_i,O_i</equation> 也是一样</p><p><br></p><p>这样弄完之后，还会有问题: <equation>L,R,O</equation> 用的 <equation>c_0,c_1,...,c_m</equation> 不是一组。用下面的方法解决:</p><p>令<equation>F=L+X^{d+1}\cdot R + X^{2(d+1)}\cdot O</equation> </p><p><equation>F_i=L_i+X^{d+1}\cdot R_i + X^{2(d+1)}\cdot O_i</equation> </p><p>证明 <equation>F</equation> 是 <equation>F_i</equation> 的线性组合(这样肯定用的是一组 <equation>c_0,c_1,...,c_m</equation> )，并且 <equation>E(F(s))=E(L(s)+s^{d+1}\cdot R(s) + s^{2(d+1)}\cdot O(s))</equation> ,到此问题二彻底解决</p><h2>Elliptic Curves Pairings(椭圆曲线配对)</h2><p>我看到我们需要处理乘法的情况,例如证明 <equation>E(L(s)\cdot R(s)-O(s))=E(H(s)\cdot T(s))</equation> 和 <equation>E(F(s))=E(L(s)+s^{d+1}\cdot R(s) + s^{2(d+1)}\cdot O(s))</equation> 的时候，需要把 <equation>E(x\cdot y)</equation> 拆成 <equation>E(x),E(y)</equation> ，而我们现在只有 <equation>E(x+ y)</equation> 可以拆成 <equation>E(x),E(y)</equation>。</p><p>这里我们除了借助cyclic group来处理加法的情况，还需要借助Elliptic Curves Pairing来处理乘法的情况。Elliptic Curves Pairings本身涉及比较复杂的数学证明，后面会专门开篇写。这里只需要知道Elliptic Curves Pairing其中的Tate Pairing的一个结论就行了：</p><p><equation> Tate: \mathbb{G}_{1} \times \mathbb{G}_{2} \rightarrow \mathbb{G}_{T}</equation> </p><p><equation>Tate(g,h)=g_{T}</equation> ,其中 <equation>g\in \mathbb{G_1},h\in \mathbb{G_2},g_T \in \mathbb{G}_T</equation> , <equation>g,h,g_T,</equation> 分别是这几个group的生成器</p><p><equation>Tate(a\cdot g, b\cdot h)={g_T}^{ab}</equation> </p><p>有了这个工具之后 <equation>E(xy)={g_T}^{xy}=Tate(x\cdot g,y\cdot h )=Tate(E_1(x),E_2(y))</equation> ,这样我们就找到了乘法的同态隐藏的方法。</p><p><br></p><p>未完待续。。。</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
