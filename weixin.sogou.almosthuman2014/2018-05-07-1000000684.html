<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>一起读懂传说中的经典：受限玻尔兹曼机</title>
</head>
<body>
<p><a href="https://mp.weixin.qq.com/s?timestamp=1526516812&amp;src=3&amp;ver=1&amp;signature=PZgLpIhGMr4qTIcno5ZjDI5jZoP*e9ghCxauAHrMoVFOVAM6UaakgY9tB5gDAZKKyI3JMlIfZGlRWTyMGFTdtXqxy8YLOpt1JFPBStfc3zoTeOoKXkeUy0g5gdXhHq7lpoK232fSCipH2cP08B*9H7Yga06DrKkCqrFgOf0M9GQ=">原文</a></p>
<div class="rich_media_inner">
                        
        
        <div id="page-content" class="rich_media_area_primary">
            
                        <div id="img-content">
                
                <h2 class="rich_media_title" id="activity-name">
                    一起读懂传说中的经典：受限玻尔兹曼机                                    </h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                            <em id="post-date" class="rich_media_meta rich_media_meta_text">2018-05-07</em>

                                        <a class="rich_media_meta rich_media_meta_link rich_media_meta_nickname" href="##" id="post-user">机器之心</a>
                    <span class="rich_media_meta rich_media_meta_text rich_media_meta_nickname">机器之心</span>


                    <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                        <div class="profile_inner">
                            <strong class="profile_nickname">机器之心</strong>
                            <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                            <p class="profile_meta">
                            <label class="profile_meta_label">微信号</label>
                            <span class="profile_meta_value">almosthuman2014</span>
                            </p>

                            <p class="profile_meta">
                            <label class="profile_meta_label">功能介绍</label>
                            <span class="profile_meta_value">专业的人工智能媒体和产业服务平台</span>
                            </p>
                            
                        </div>
                        <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                            <i class="profile_arrow arrow_out"></i>
                            <i class="profile_arrow arrow_in"></i>
                        </span>
                    </div>
                </div>
                                
                
                
                
                                                
                                                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><section style="font-size: 16px;white-space: normal;max-width: 100%;color: rgb(62, 62, 62);background-color: rgb(255, 255, 255);line-height: 28.4444px;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section data-id="85660" data-custom="rgb(117, 117, 118)" data-color="rgb(117, 117, 118)" style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><section data-id="85660" data-custom="rgb(117, 117, 118)" data-color="rgb(117, 117, 118)" style="max-width: 100%;border: 0px currentcolor;font-family: 微软雅黑;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="margin-top: 2em;padding-top: 0.5em;padding-bottom: 0.5em;max-width: 100%;border-style: solid none;font-family: inherit;text-decoration: inherit;border-top-color: rgb(204, 204, 204);border-bottom-color: rgb(204, 204, 204);border-top-width: 1px;border-bottom-width: 1px;box-sizing: border-box !important;word-wrap: break-word !important;"><p style="margin-top: -1.2em;max-width: 100%;min-height: 1em;text-align: center;line-height: 1.75em;border: currentcolor;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(255, 255, 255);background-color: rgb(117, 117, 118);box-sizing: border-box !important;word-wrap: break-word !important;">选自DL4J</span></p><section data-style="white-space: normal; text-align: left;font-size: 14px;line-height: 1.5em; color: rgb(12, 12, 12);" style="padding: 16px 16px 10px;max-width: 100%;font-family: inherit;box-sizing: border-box !important;word-wrap: break-word !important;"><p style="max-width: 100%;min-height: 1em;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;font-family: inherit;text-decoration: inherit;color: rgb(136, 136, 136);font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">机器之心编译</strong></p><p style="text-align: center;"><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">参与：</strong></span><strong><span style="font-size: 12px;color: rgb(136, 136, 136);">Nurhachu Null、思源</span></strong><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></strong></span></p></section></section></section></section></section></section></section></section></section></section></section></section><p style="font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;color: rgb(62, 62, 62);text-align: justify;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p><blockquote style="font-size: 16px;white-space: normal;max-width: 100%;color: rgb(62, 62, 62);box-sizing: border-box !important;word-wrap: break-word !important;"><p style="max-width: 100%;min-height: 1em;text-align: justify;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(136, 136, 136);font-size: 15px;box-sizing: border-box !important;word-wrap: break-word !important;">尽管性能没有流行的生成模型好，但受限玻尔兹曼机还是很多读者都希望了解的内容。这不仅是因为深度学习的复兴很大程度上是以它为前锋，同时它那种逐层训练与重构的思想也非常有意思。本文介绍了什么是受限玻尔兹曼机，以及它的基本原理，并以非常简单的语言描述了它的训练过程。虽然本文不能给出具体的实现，但这些基本概念还是很有意思的。</span></p></blockquote><p style="text-align: justify;line-height: 1.75em;"><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;">定义 &amp; 结构</span></strong></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;"><br></span></strong></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">受限玻尔兹曼机（RBM，Restricted Boltzmann machine）由多伦多大学的 Geoff Hinton 等人提出，它是一种可以用于降维、分类、回归、协同过滤、特征学习以及主题建模的算法。更多关于如何部署诸如 RBM 这样的神经网络的具体例子，请参阅 deeplearning4j 关于深度学习用例的内容。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">本文将从受限玻尔兹曼机的关系和历史重要性出发，首先讨论什么是 RBM。随后，我们会使用图表和浅显的语言来描述它们的运行原理。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">RBM 是两层神经网络，这些浅层神经网络是 DBN（深度信念网络）的构建块。RBM 的第一层被称为可见层或者输入层，它的第二层叫做隐藏层。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.9519832985386222" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50ob0oFB1u09GwKVliamcUb377XRsOj7VKejBTGmfPUlTxliadrk0AMdgwg/640?wx_fmt=png" data-type="png" data-w="479" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">上图中的每个圆圈代表一个类似于神经元的节点，这些节点通常是产生计算的地方。相邻层之间是相连的，但是同层之间的节点是不相连的。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">也就是说，不存在层内通信，这就是 RBM 中的限制所在。每一个节点都是处理输入数据的单元，每个节点通过随机决定是否传递输入。随机意味着「随机判断」，这里修改输入的参数都是随机初始化的。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">每个输入单元以数据集样本中的低级特征作为输入。例如，对于一个由灰度图组成的数据集，每个输入节点都会接收图像中的一个像素值。MNIST 数据集有 784 个像素点，所以处理它们的神经网络必须有 784 个输入节点。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">现在让我们跟随单像素穿过这两层网络。在隐藏层的节点 1，x 和一个权重相乘，然后再加上一个偏置项。这两个运算的结果可作为非线性激活函数的输入，在给定输入 x 时激活函数能给出这个节点的输出，或者信号通过它之后的强度。这里其实和我们常见的神经网络是一样的过程。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><pre style="box-sizing: border-box;margin-top: 0px;margin-bottom: 0px;padding: 0px;font-size: 16px;color: rgb(62, 62, 62);line-height: inherit;font-variant-ligatures: normal;orphans: 2;widows: 2;background-color: rgb(255, 255, 255);"><code class="python language-python hljs" style="box-sizing: border-box;margin-right: 2px;margin-left: 2px;padding: 0.5em;font-size: 14px;color: rgb(169, 183, 198);line-height: 18px;border-top-left-radius: 0px;border-top-right-radius: 0px;border-bottom-right-radius: 0px;border-bottom-left-radius: 0px;background-color: rgb(40, 43, 46);font-family: Consolas, Inconsolata, Courier, monospace;display: block;overflow-x: auto;letter-spacing: 0px;word-wrap: normal !important;word-break: normal !important;overflow-y: auto !important;background-position: initial initial;background-repeat: initial initial;">activation f((weight w * input x) + bias b ) = output a</code></pre><p style="text-align: justify;line-height: 1.75em;"><br></p><p><img class="" data-copyright="0" data-ratio="0.7154213036565977" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50oIW6Dm7e2pltCDHftoVribTtSylhhwo7GF8ajNziazgTnvibTqYHW3VKjw/640?wx_fmt=png" data-type="png" data-w="629" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">接下来，让我们看一下多个输入单元是如何结合在一个隐藏节点的。每个 x 乘以一个独立的权重，然后相加后再加一个偏置项，最后将结果传递到激活函数来产生输出。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.7013996889580093" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50oLJnG16LyZFiatFODzE0T5kOje115Ipvy1v9xRib2u5XAumZMV7cdp4PQ/640?wx_fmt=png" data-type="png" data-w="643" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">因为所有可见（或输入）节点的输入都被传递到所有的隐藏节点了，所以 RBM 可以被定义为对称二分图（symmetrical bipartite graph）。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">对称意味着每个可见节点都与一个隐藏节点相连（如下所示）。二分则意味着它具有两部分，或者两层。图是一个数学术语，指的是由节点和边组成的网络。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">在每一个隐藏节点，每个输入 x 都与对应的权重 w 相乘。也就是说，一个输入 x 会拥有 12 个权重（4 个输入节点×3 个输出节点）。两层之间的权重总会形成一个矩阵，矩阵的行数等于输入节点的个数，列数等于输出节点的个数。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">每个隐藏节点会接收 4 个与对应权重相乘的输入。这些乘积的和再一次与偏置相加，并将结果馈送到激活函数中以作为隐藏单元的输出。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.6508422664624809" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50oYrAm3aiaMZCq1VhkKs5qKR1hnl5rmB6pOXEWZVVCpHics2LMLZbOibu9g/640?wx_fmt=png" data-type="png" data-w="653" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">如果这两层是更深网络的一部分，那么第一个隐藏层的输出会被传递到第二个隐藏层作为输入，从这里开始就可以有很多隐藏层，直到它们增加到最终的分类层。对于简单的前馈网络，RBM 节点起着自编码器的作用，除此之外，别无其它。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.5500667556742324" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50oIZQ54mxbAMqYn8Q9j6paN86ibTTOPInDaLm4kibk0hCy6WHFgrvl0q7g/640?wx_fmt=png" data-type="png" data-w="749" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;">重建（Reconstruction）</span></strong></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;"><br></span></strong></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">但是在本文关于 RBM 的介绍中，我们会集中讨论它们如何以一种无监督的方式通过自身来重建数据，这使得在不涉及更深层网络的情况下，可见层和第一个隐藏层之间会存在数次前向和反向传播。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">在重建阶段，第一个隐藏层的激活状态变成了反向传递过程中的输入。它们与每个连接边相同的权重相乘，就像 x 在前向传递的过程中随着权重调节一样。这些乘积的和在每个可见节点处又与可见层的偏置项相加，这些运算的输出就是一次重建，也就是对原始输入的一个逼近。这可以通过下图表达：</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.5923392612859097" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50oibSjvicUv7IlRciaF1qIcibcQMhW4jJiboeIicjOUfWO9Ct4iczibLpUtAkyJQ/640?wx_fmt=png" data-type="png" data-w="731" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">因为 RBM 的权重是随机初始化的，所以，重建结果和原始输入的差距通常会比较大。你可以将 r 和输入值之间的差值看做重建误差，然后这个误差会沿着 RBM 的权重反向传播，以一个迭代学习的过程不断反向传播，直到达到某个误差最小值。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">关于反向传播的更全面的解释请查看机器之心的文章：<a href="http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650731098&amp;idx=1&amp;sn=c7391caee3a567b4b046406d53f022f2&amp;chksm=871b3624b06cbf320f3725fe452d291e04a4a8c1beda8ee9e00f1d10266847be4736090aade3&amp;scene=21#wechat_redirect" target="_blank">反向传播为何饱受质疑？（附完整的 BP 推导）</a>。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">正如你所看到的，在前向传递过程中，给定权重的情况下 RBM 会使用输入来预测节点的激活值，或者输出的概率 x:p(a|x; w)。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">但是在反向传播的过程中，当激活值作为输入并输出原始数据的重建或者预测时，RBM 尝试在给定激活值 a 的情况下估计输入 x 的概率，它具有与前向传递过程中相同的权重参数。这第二个阶段可以被表达为 p(x|a; w)。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">这两个概率估计将共同得到关于输入 x 和激活值 a 的联合概率分布，或者 p(x, a)。重建与回归有所不同，也不同于分类。回归基于很多输入来估计一个连续值，分类预测出离散的标签以应用在给定的输入样本上，而重建是在预测原始输入的概率分布。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">这种重建被称之为生成学习，它必须跟由分类器执行的判别学习区分开来。判别学习将输入映射到标签上，有效地在数据点与样本之间绘制条件概率。若假设 RBM 的输入数据和重建结果是不同形状的正态曲线，它们只有部分重叠。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">为了衡量输入数据的预测概率分布和真实分布之间的距离，RBM 使用 KL 散度来度量两个分布的相似性。KL 散度测量的是两条曲线的非重叠区域或者说发散区域，RBM 的优化算法尝试最小化这些区域，所以当共享权重与第一个隐藏层的激活值相乘时就可以得出原始输入的近似。图的左边是一组输入的概率分布 p 及其重构分布 q，图的右侧是它们的差的积分。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.3477851083883129" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50ofSyj9FF31T7Nn6b4TlN0U01MoJfjACfhIxPPNMg3tmRtk8jFxWRCmg/640?wx_fmt=png" data-type="png" data-w="1061" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">迭代地根据它们产生的误差来调节权重，RBM 学会了逼近原始数据。你可以说权重在慢慢地反映输入数据的结构，并通过隐藏层的激活值进行编码，学习过程就像两个概率分布在逐步重合。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.6020260492040521" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50oMgh0diblP0XHuQZ19TmeK1KiawFQQKAPEI9qUVNX5WQjM9iaMSU9eicEIA/640?wx_fmt=png" data-type="png" data-w="691" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;">概率分布</span></strong></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;"><br></span></strong></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">让我们来讨论一下概率分布。如果你在掷两个骰子，所有结果的概率分布如下：</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.7157057654075547" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50oCI8KMsNTr2sUMOe86ndBReq4msGJK5COFvfgA2pWHfzklicM2VYaHwQ/640?wx_fmt=png" data-type="png" data-w="1509" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">也就是说，和为 7 的结果是最有可能出现的，因为相比于 2 到 12 等其它结果，有更多的抛掷组合可以得到 7 这个结果（3+4,1+6,2+5）。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">或者举另一个例子：语言是字母的特定概率分布，因为每一种语言会使用一些字母较多，而另一些较少。在英语中，字母 e、t 以及 a 是最常见的，然而在冰岛语中，最常见的字母是 a、t 和 n。因此尝试使用基于英语的权重集合来重建冰岛语将会导致较大的差异。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">同样，图像数据集拥有像素值的唯一概率分布，这取决于数据集中图像的种类。像素值的分布取决于数据集中的图像类别，例如 MNIST：</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.593128390596745" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50ogbP5IkEEXjLYCPl5D3S15SzrHdLGVt8Q1DWKibT7CWFxJWgOEfc1pibQ/640?wx_fmt=png" data-type="png" data-w="553" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">或者 Faces in the Wild 数据集中标记的头像：</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.2414721723518851" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50oibZBxwwEWJ5mq3xTVIcX8aPByBLOCKn8yrHEZF576jRC6KvAlb8tk6A/640?wx_fmt=png" data-type="png" data-w="1114" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">想象一下仅输入狗和大象图片的 RBM，它只有两个输出节点，每个结点对应一种动物。在前向传递的过程中 RBM 会问自己这样的问题：在给定的这些像素下，我应该向哪个节点发送更强的信号呢，大象节点还是狗的节点？在反向传递的过程中 RBM 的问题是：给定一头大象的时候，应该期望那种像素分布？</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">那就是联合概率分布：给定 a 时 x 的概率以及给定 x 时 a 的概率，可以根据 RBM 两层之间的共享权重而确定。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">从某种意义上而言，学习重建的过程就是学习在给定的图像集合下，哪些像素会倾向于同时出现。由深层网络的隐藏层节点所产生的激活状态表现出来的共现现象：例如，「非线性灰色管＋大的、松软的耳朵＋皱纹」可以作为一个分布。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">在上面的两幅图像中，你看到了用 Deeplearning4j 实现的 RBM。这些重建代表着 RBM 的激活值所「认为」输入数据看起来的样子，Geoff Hinton 将其称为机器「做梦」。当被呈现在神经网络在训练过程时，这种可视化是非常有用的启发，它让人确信 RBM 确实在学习。如果不是，那么它的超参数应该被调整。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">最后一点：你会注意到 RBM 有两个偏置项。这是有别于其它自动编码器的一个方面。隐藏层的偏置项有助于 RBM 在前向传递中获得非零激活值，而可见层的偏置有助于 RBM 学习后向传递中的重建。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;">多层受限玻尔兹曼机</span></strong></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;"><br></span></strong></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">一旦 RBM 学到了与第一隐藏层激活值有关的输入数据的结构，那么数据就会沿着网络向下传递一层。你的第一个隐藏层就成为了新的可见层或输入层。这一层的激活值会和第二个隐藏层的权重相乘，以产生另一组的激活。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">这种通过特征分组创建激活值集合序列，并对特征组进行分组的过程是特征层次结构的基础，通过这个过程，神经网络学到了更复杂的、更抽象的数据表征。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">对于每一个新的隐藏层，权重都会通过迭代反复调整，直至该层能够逼近来自于前一层的输入。这是贪婪的、逐层的、无监督的预训练。它不需要使用标签来改善网络的权重，这意味着我们可以在无标签的数据集上进行训练，而这些数据没有经过人工处理，这是现实中绝大多数的数据。通常，拥有更多数据的算法会产生更准确的结果，这也是深层学习算法崛起的原因之一。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">因为这些权重早已接近数据的特征，所以在使用深度信念网络进行图像分类的时候，后续的监督学习阶段可以更简单地学习。尽管 RBM 有很多用途，但合适的权重初始化以方便以后的分类是其主要优点之一。从某种程度而言，它们完成了某种类似于反向传播的功能：它们很好地调整了权重，以对数据进行更好的建模。你可以说预训练和反向传播是达到相同目的的可替代方法。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">为了在一个图中展示受限玻尔兹曼机，我们需要使用对称二分双向图表示：</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p><p><img class="" data-copyright="0" data-ratio="0.6711309523809523" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8dh3Upofh0sm4KejGwQ50oekL0aYknd4M1tcDphTF9K3PVYfcskyJGIFicKSwkoxTl0JuOXL9aIOg/640?wx_fmt=png" data-type="png" data-w="672" style=""></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span><br></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">对于那些对深入研究 RBM 结构感兴趣的人而言，它们是一种无向图模型，也被称作马尔科夫随机场。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;">代码实例：Stacked RBMS</span></strong></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;"><br></span></strong></p><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(123, 12, 0);">GitHub 链接：</span></p><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(123, 12, 0);">https://github.com/deeplearning4j/dl4j-examples/blob/master/dl4j-examples/src/main/java/org/deeplearning4j/examples/unsupervised/deepbelief/DeepAutoEncoderExample.java</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;color: rgb(123, 12, 0);"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;">参数 &amp; K</span></strong></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;"><br></span></strong></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">变量 k 是运行对比散度（Contrastive Divergence）的次数。对比散度是用来计算梯度（该斜率表示网络权重与其误差之间的关系）的方法，没有这种方法，学习就无法进行。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">在上面的例子中，你可以看到如何将 RBM 创建为具有更通用多层配置的层。在每个点处，你会发现一个可以影响深度神经网络结构和性能的额外参数。大多数这些参数都是在这里定义的。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: left;line-height: 1.75em;"><span style="font-size: 15px;">参数初始化（weightInit 或者 weightInitialization）表示放大或者抑制到达每个节点的输入信号的系数的初始值。合适的权重初始化可以节省大量的训练时间，因为训练一个网络只不过是调整系数来传递最佳信号，从而使网络能够准确分类。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">激活函数（activationFunction）是一组函数中的一个，用于确定每个节点处的激活阈值，高于阈值的信号可以通过，低于阈值的信号就被阻止。如果一个节点传递了一个信号，则它被「激活」。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">优化算法（optimizationAlgo）指神经网络最小化误差或者找到最小误差轨迹的方式，它是一步一步调整参数的。LBFGS 是一种优化算法，它利用二阶导数来计算梯度的斜率，系数将沿着梯度的斜率进行调整。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">正则化（regularization）方法（如 L2）有助于防止神经网络中的过拟合。正则化本质上会惩罚较大的系数，因为大系数意味着网络已经学会将结果锁定在几个高权值的输入上了。过强的权重会使网络模型在面对新数据的时候难以泛化。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">显元/隐元（VisibleUnit/HiddenUnit）指神经网络的层。显元或者可见层，是输入到达的层，隐元或者隐藏层，是输入被结合成更复杂特征的层。这两种单元都有各自所谓的变换，在这里，可见层是高斯变换，隐藏层是整流线性单元，它们将来自它们对应层的信号映射到新的空间。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">损失函数（lossFunction）是测量误差的方法，或者测量网络预测和测试集包含的正确的标签之间差距的方法。我们在这里使用的是 SQUARED_ERROR，它使所有的误差都是正值，因此可以被求和并反向传播。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">学习率（learningRate，如 momentum）会影响神经网络在每次迭代中校正误差时调整系数的程度。这两个参数有助于确定网络将梯度降低到局部最优时的步长。较大的学习率会使网络学习得更快，并且可能越过最佳值。较小的学习率可能减慢学习，而且可能是低效的。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;">连续 RBM</span></strong></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;"><br></span></strong></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">连续 RBM 是受限玻尔兹曼机的一种形式，它通过不同类型的对比散度采样接受连续的输入（也就是比整数切割得更细的数字）。这允许 CRBM 处理图像像素或字数向量这类被归一化到 0 到 1 之间的小数的向量。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">应该注意，深度学习网络的每一层都需要四个元素：输入、系数、偏置项以及变换（激活算法）。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">输入是数值数据，是一个来自于前面层（或者原始数据）的向量。系数是通过每个节点层的特征的权重。偏置项确保部分节点无论如何都能够被激活。变换是一种额外的算法，它在数据通过每一层以后以一种使梯度（梯度是网络必须学习的）更容易被计算的方式压缩数据。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">这些额外算法和它们的组合可以逐层变化。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">一种有效的连续 RBM 在可见（或者输入）层上使用高斯变换，在隐藏层上使用整流线性单元（ReLU）变换。这在面部重建中特别有用。对于处理二进制数据的 RBM 而言，只需要进行二进制转换即可。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">高斯变换在 RBM 的隐藏层上的表现不好。相反，使用 ReLU 变换能够表示比二进制变换更多的特征，我们在深度置信网络中使用了它。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;">总结 &amp; 下一步工作</span></strong></p><p style="text-align: justify;line-height: 1.75em;"><strong><span style="font-size: 15px;"><br></span></strong></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">你可以将 RBM 的输出解释为百分比。每次重建的数字不为零，这是 RBM 学习输入的良好指示。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">应当指出的是，RBM 并不能生成所有的浅层前馈网络中最稳定、最一致的结果。在很多情况下，密集层自编码器性能较好。事实上，业界正在转向变分自编码器和 GAN 等工具。</span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"><br></span></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;">下一步，我们将会展示如何实现深度置信网络（https://deeplearning4j.org/deepbeliefnetwork.html），它由许多受限玻尔兹曼机堆叠而成。</span><img class="" data-ratio="0.3287671232876712" src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8Zfpicd40EribGuaFicDBCRH6IOu1Rnc4T3W3J1wE0j6kQ6GorRSgicib0fmNrj3yzlokup2jia9Z0YVeA/640?wx_fmt=png" data-type="png" data-w="73" width="48px" style="font-size: 14px;color: rgb(62, 62, 62);background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;visibility: visible !important;width: 48px !important;"></p><p style="white-space: normal;"><br></p><p style="white-space: normal;"><span style="font-size: 12px;"><em><span style="color: rgb(136, 136, 136);">原文链接：https://deeplearning4j.org/restrictedboltzmannmachine.html#params</span></em></span></p><p style="white-space: normal;"><span style="font-size: 12px;"><em><span style="color: rgb(136, 136, 136);"><br></span></em></span></p><p style="white-space: normal;"><span style="font-size: 12px;"><em><span style="color: rgb(136, 136, 136);"><br></span></em></span></p><p style="white-space: normal;max-width: 100%;min-height: 1em;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;text-align: justify;line-height: 25.6px;font-family: 微软雅黑;font-size: 14px;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(127, 127, 127);box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;color: rgb(62, 62, 62);line-height: 25.6px;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(127, 127, 127);box-sizing: border-box !important;word-wrap: break-word !important;">本文为机器之心编译，<strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;">转载请联系本公众号获得授权</span></strong></span></strong>。</span></strong><br style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"></p><p style="margin-bottom: 5px;white-space: normal;max-width: 100%;min-height: 1em;font-size: 18px;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(127, 127, 127);line-height: 25.6px;font-family: 微软雅黑;text-align: justify;box-sizing: border-box !important;word-wrap: break-word !important;">✄------------------------------------------------</span></p><p style="margin-bottom: 5px;white-space: normal;max-width: 100%;min-height: 1em;font-size: 18px;font-family: 微软雅黑;text-align: center;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(217, 33, 66);font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">加入机器之心（全职记者/实习生）：hr@jiqizhixin.com</span></strong></p><p style="white-space: normal;max-width: 100%;min-height: 1em;font-size: 18px;font-family: 微软雅黑;text-align: center;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(217, 33, 66);line-height: 1.6;font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">投稿或寻求报道：<strong style="max-width: 100%;color: rgb(62, 62, 62);font-family: 微软雅黑;font-size: 18px;text-align: center;white-space: normal;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: rgb(217, 33, 66);line-height: 1.6;font-size: 12px;box-sizing: border-box !important;word-wrap: break-word !important;">content</span></strong>@jiqizhixin.com</span></strong></p><p style="white-space: normal;max-width: 100%;min-height: 1em;font-size: 18px;font-family: 微软雅黑;text-align: center;line-height: 1.75em;box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 12px;color: rgb(217, 33, 66);line-height: 1.6;box-sizing: border-box !important;word-wrap: break-word !important;">广告&amp;商务合作：bd@jiqizhixin.com</span></strong></p><p style="text-align: justify;line-height: 1.75em;"><span style="font-size: 15px;"></span></p>
                </div>
                <script nonce="22609050" type="text/javascript">
                    var first_sceen__time = (+new Date());

                    if ("" == 1 && document.getElementById('js_content')) {
                        document.getElementById('js_content').addEventListener("selectstart",function(e){ e.preventDefault(); });
                    }

                    
                    (function(){
                        if (navigator.userAgent.indexOf("WindowsWechat") != -1){
                            var link = document.createElement('link');
                            var head = document.getElementsByTagName('head')[0];
                            link.rel = 'stylesheet';
                            link.type = 'text/css';
                            link.href = "//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg/page_mp_article_improve_winwx3d171e.css";
                            head.appendChild(link);
                        }
                    })();
                </script>
                
                
                                
                <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display:none;"></div>

                
                                <div class="reward_area tc" id="js_preview_reward" style="display:none;">
                    <p id="js_preview_reward_wording" class="tips_global reward_tips" style="display:none;"></p>
                    <p>
                        <a class="reward_access" id="js_preview_reward_link" href="##"><span class="icon-reward"></span>赞赏</a>

                    </p>
                </div>
                <div class="reward_qrcode_area reward_area tc" id="js_preview_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                    <p id="js_preview_reward_ios_wording" class="reward_tips" style="display:none;"></p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" src="//res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_reward_qrcode.2x3534dd.png"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                            </div>
                        
            <ul id="js_hotspot_area" class="article_extend_area"></ul>


            
                        <div class="rich_media_tool" id="js_toobar3">
                
                                
                                            <div id="js_read_area3" class="media_tool_meta tips_global meta_primary" style="display:none;">阅读 <span id="readNum3"></span></div>

                <span style="display:none;" class="media_tool_meta meta_primary tips_global meta_praise" id="like3">
                    <i class="icon_praise_gray"></i><span class="praise_num" id="likeNum3"></span>
                </span>

                <a id="js_report_article3" style="display:none;" class="media_tool_meta tips_global meta_extra" href="##">投诉</a>

            </div>


                        <div class="rich_media_tool" id="js_sg_bar">
                
                                
                                
            </div>
                    </div>

        <div class="rich_media_area_primary sougou" id="sg_tj" style="display:none"></div>

        
        <div class="rich_media_area_extra">

            
                        <div class="mpda_bottom_container" id="js_bottom_ad_area"></div>
                        
            <div id="js_iframetest" style="display:none;"></div>
                        
                        
            <div class="rich_media_extra rich_media_extra_discuss" id="js_friend_cmt_area" style="display:none">
              
              
              
            </div>

                        <div class="rich_media_extra rich_media_extra_discuss" id="js_cmt_area" style="display:none">
            </div>
                    </div>

        
        <div id="js_pc_qr_code" class="qr_code_pc_outer" style="display:none;">
            <div class="qr_code_pc_inner">
                <div class="qr_code_pc">
                    <img id="js_pc_qr_code_img" class="qr_code_pc_img">
                    <p>微信扫一扫<br>关注该公众号</p>
                </div>
            </div>
        </div>
    </div>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
