<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Recursion Schemes（三）基于上下文的折叠</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/43560128">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg" alt=""></div><h2>前情回顾</h2><p>在上一篇文章中，我们定义了 catamorphism，一种一般性的遍历嵌套数据结构的手段，但是这一方法有它的局限性，本章中我们将讨论这些局限，并介绍更强力的遍历手段 paramorphism</p><p>如前所述，本文的代码可以在<a href="https://github.com/patrickt/recschemes/blob/master/src/Part3.hs">这里</a>找到。</p><p>在过去的两篇文章中，我们定义了 <code class="inline">Term</code> 来表示函子 <code class="inline">f</code> 的不动点，并使用 <code class="inline">In</code> 和 <code class="inline">Out</code> 来作为构造和析构函数，从而使 <code class="inline">Term f</code> 和 <code class="inline">f (Term f)</code> 相互联系了起来：</p><code lang="haskell">newtype Term f = In { out :: f (Term f) }</code><p>接着利用 <code class="inline">fmap</code> 的递归特性，我们定义了可以在 <code class="inline">Term f</code> 上进行变换的 <code class="inline">bottomUp</code>：</p><code lang="haskell">bottomUp :: Functor a =&gt; (Term a -&gt; Term a) -&gt; Term a -&gt; Term a  
bottomUp fn =  
  out                    -- 1) 解析结构
  &gt;&gt;&gt; fmap (bottomUp fn) -- 2) 递归
  &gt;&gt;&gt; In                 -- 3) 构造结构
  &gt;&gt;&gt; fn                 -- 4) 应用</code><p>当我们不考虑重新构造结构的部分以后，我们得到了 <code class="inline">cata</code>，可以使 <code class="inline">Term f</code> 变成某种累加值 <code class="inline">a</code>，使用 <code class="inline">Algebra</code> 将 <code class="inline">f a</code> 与 <code class="inline">a</code> 联系了起来：</p><code lang="haskell">type Algebra f a = f a -&gt; a

cata :: (Functor f) =&gt; Algebra f a -&gt; Term f -&gt; a  
cata fn =  
    out                -- 1) 解析结构
    &gt;&gt;&gt; fmap (cata fn) -- 2) 递归
    &gt;&gt;&gt; fn             -- 3) 应用</code><h2>Paramorphism</h2><p>Catamorphism 相当简单优雅，但往往在现实中并不实用，因为在遍历过程中，它丢失了原有结构与上下文信息，比如在上一章中文档生成的例子里，我们只能对当前节点生成文档，因为其它所有子节点已经变成了文档的一部分。</p><p>这在我们需要上下文信息来进行判断的场景中会变得非常麻烦，比如我希望在函数无参数时，文档以特殊格式显示该函数，那么我必须重新解析文档来获取之前关于函数参数的信息，这显然非常笨拙。</p><p>一个显然更优雅的解法就是在 <code class="inline">Algebra</code> 生成最终结果的时候，我们能同时保留原始的上下文信息，<code class="inline">Algebra</code> 的输入是 <code class="inline">f a</code> 如果我们能保持原有的结构 <code class="inline">Term f</code>，同时也能拿到当前的结果 <code class="inline">a</code>，并以两者一同作为输入：</p><code lang="haskell">f (Term f, a) -&gt; a</code><p>我们把这样的结构定义为 <code class="inline">R-algebra</code>：</p><code lang="haskell">type RAlgebra f a = f (Term f, a) -&gt; a</code><p>与之对应的，使用 <code class="inline">R-algebra</code> 来进行数据结构遍历的机制被称为 <i>paramorphism</i>，同样从词源的角度分析，paramorphism 的词缀 <i>para</i> 实际上与 <i>parallel</i> 的相同——来自于希腊语 παρά，代表“旁边”，“临近”，“一旁”的含义[1]。除去可以看到当前位置的上下文，paramorphism 和 catamorphism 实际上非常相似。</p><p>下面我们来看下 paramorphism 的具体实现，我们不能再直接地使用 <code class="inline">fmap para</code> 我们的函数返回了一个元组，我们需要解析并递归其中的表达式，同时保持原来的结构，为止我们定义了一个附属函数 <code class="inline">fanout</code>，它接受一个 <code class="inline">Term</code> 并且返回递归结果和 <code class="inline">Term</code> 本身。</p><code lang="haskell">para :: (Functor f) =&gt; RAlgebra f a -&gt; Term f -&gt; a  
para rAlg = out &gt;&gt;&gt; fmap fanout &gt;&gt;&gt; rAlg  
    where fanout :: Term f -&gt; (Term f, a)
          fanout t = (t, para rAlg t)</code><p>就这么简单！这就是 paramorphism 的经典定义，我们现在可以在保持原有的信息和结构的同时，获得我们想要的结果。其实 Haskell 甚至可以给出更优雅的实现，使用 <code class="inline">Control.Arrow</code> 提供的 <code class="inline">&amp;&amp;&amp;</code> 组合子，它接收两个函数 <code class="inline">foo</code> 和 <code class="inline">bar</code>[2]，并且返回一个函数，它的输入是 <code class="inline">a</code>，返回是 <code class="inline">(foo a, bar a)</code> 的元组。它将两个函数的输出进行了组合。</p><p>所以我们的 <code class="inline">fanout</code> 可以构造为：</p><code lang="haskell">fanout = id &amp;&amp;&amp; para f</code><p>所以原代码可以改写为：</p><code lang="haskell">para' :: Functor f =&gt; RAlgebra f a -&gt; Term f -&gt; a  
para' f = out &gt;&gt;&gt; fmap (id &amp;&amp;&amp; para' f) &gt;&gt;&gt; f</code><p>是不是简洁了许多？</p><h2>替代 Catamorphism</h2><p>实际上我们之前到 <code class="inline">RAlgebra</code> 中元组的定义也不无改进空间，我们可以将它使用函数重写：</p><code lang="haskell">type RAlgebra' f a = Term f -&gt; f a -&gt; a</code><p>那么随之我们对 <code class="inline">para</code> 的定义也需要随之修改：</p><code lang="haskell">-- &amp; 函数的作用是逆序函数的调用顺序，  
-- 与 $ 操作符类似，不过执行的顺序相反
para'' :: Functor f =&gt; RAlgebra' f a -&gt; Term f -&gt; a  
para'' alg t = out t &amp; fmap (para'' alg) &amp; alg t</code><p>正如 <code class="inline">bottomUp</code> 可以用 <code class="inline">cata</code> 表达，<code class="inline">cata</code> 也可以用 <code class="inline">qara</code> 来表达，我们只需要忽略掉额外传入的 <code class="inline">Term</code> 即可，我们使用 Haskell 提供的 <code class="inline">const</code> 函数即可（即 K-组合子）：</p><code lang="haskell">cata' :: Functor f =&gt; Algebra f a -&gt; Term f -&gt; a  
cata' f = para'' (const f)</code><p>这正是 Recursion Scheme 的优美之处，我们不断引入新的更强大的构造结构，而旧的总能被新的所表达。</p><h2>举个例子</h2><p>对于 <code class="inline">id</code> 函数来说，直接返回它的参数，我们可以等价地用 <code class="inline">x</code> 来替换 <code class="inline">id(x)</code> 我们来考虑一个我们前文提到的的文档生成器，出于某些原因[3]，我们希望在文档中进行这个优化。</p><p>我们需要检查每个函数调用，通过判断函数名是否为 <code class="inline">id</code> 来决定是否直接返回参数，这正是使用 paramorphism 的地方，我们这里使用的语法树与之前的一样：</p><code lang="haskell">fastPretty :: RAlgebra' Expr Doc

-- 除了 Call 节点的定义，其他部分与之前的定义均相同
fastPretty _ (Literal i) = P.int i  
fastPretty _ (Ident s)   = P.text s  

-- Call 节点正是我们感兴趣的部分，我们会检查它的第一个参数是否为 id，如果是的话，我们只返回参数部分

fastPretty (In Call { func = "id" })  
           Call {args = [theArg]} = theArg
fastPretty _ (Call f as)     = f &lt;&gt; P.parens (P.cat (P.punctuate ", " as))  
-- The other cases are the same as `prettyPrint` in the last installment.</code><p>当我们在遍历结构时需要上下文，那么 Paramorphism 就会变成一个不错的选择。</p><h2>Apomorphism</h2><p>在上一篇文章中，我们通过翻转箭头的技巧实现了 <code class="inline">ana</code> 与 <code class="inline">cata</code> 的对偶：</p><code lang="haskell">cata f = out &gt;&gt;&gt; fmap (cata f) &gt;&gt;&gt; f

ana f = In &lt;&lt;&lt; fmap (ana f) &lt;&lt;&lt; f</code><p>而 <code class="inline">ana</code> 的参数就被表示为 <code class="inline">Coalgebra</code>，作为 <code class="inline">Algebra</code> 的对偶：</p><code lang="haskell">type Coalgebra f a = a -&gt; f a

ana f :: (Functor f) =&gt; Coalgebra f a -&gt; a -&gt; Term f</code><p>同理，我们也会看到 paramorphism 的对偶，<i>apomorphism</i>，apo 的词缀来源于希腊语，ἀπο，代表“远离”或“分离”的意思，如在 “apogee” （月球位于远地点）或 “apostasy”（背教，变节），所以我们来看看 R-algebra 的对偶是怎样的。我们先翻转箭头看看：</p><code lang="haskell">type Nope = a -&gt; f (Term f, a)</code><p>不对！我们这里必须将 <code class="inline">RAlgebra</code> 中所有的构造部分都进行翻转，我们确实可以翻转函数的方向，但注意，我们还有元组，那么一个元组的对偶是什么呢？</p><p>元组包含它的所有子元素，什么它的对偶就是只包含其中一个元素亦即：<code class="inline">Either</code>，所以对于一个同时包含 <code class="inline">Term f</code> 和 <code class="inline">a</code> 的元组我们使用 <code class="inline">Either</code> 来表示它的对偶：</p><code lang="haskell">type RCoalgebra f a = a -&gt; f (Either (Term f) a)</code><p>好吧，那么这在实践中的含义是什么呢？这表示我们可以在展开的过程中进行计算，如果我们返回了 <code class="inline">Left</code> 其中包含一个 <code class="inline">Term</code>，那么 apomorphism 会结束并返回一个叶子节点，单如果我们决定返回 <code class="inline">Right</code> 其中包含一个 <code class="inline">a</code>，那么展开就会继续下去，我们可以根据参数的情况来决定之后展开的操作，所以就不需要考虑 <code class="inline">break</code> 或异常处理了。</p><p>同样地使用翻转箭头的技巧，我们来看看 <code class="inline">para</code> 的对偶 <code class="inline">apo</code>：</p><code lang="haskell">para' :: Functor f =&gt; RAlgebra f a -&gt; Term f -&gt; a  
para' f = out &gt;&gt;&gt; fmap fanout &gt;&gt;&gt; f where fanout = id &amp;&amp;&amp; para' f

apo f :: Functor f =&gt; RCoalgebra f a -&gt; a -&gt; Term f  
apo f = In &lt;&lt;&lt; fmap fanin &lt;&lt;&lt; f where fanin = ???</code><p><code class="inline">fanin</code> 的实现并不显然，我们可以先从类型上入手来看看：</p><code lang="haskell">fanin :: Either (Term f) a -&gt; Term f</code><p>对于 <code class="inline">Left</code> 我们使用 <code class="inline">id</code> 函数就好了，而对于 <code class="inline">Right</code> 我们则需要正常的递归下去，那么我们需要 Haskell 的 <code class="inline">either</code> 函数，它接受两个函数，并根据 Either 的左右值应用对应的函数，并返回相应的结果：</p><code lang="haskell">apo :: Functor f =&gt; RCoalgebra f a -&gt; a -&gt; Term f  
apo f = In &lt;&lt;&lt; fmap fanin &lt;&lt;&lt; f where fanin = either id (apo f)</code><p>类似地，我们可以使用 <code class="inline">&amp;&amp;&amp;</code> 的对偶函数 <code class="inline">|||</code> 来重写 <code class="inline">fanin</code>，<code class="inline">&amp;&amp;&amp;</code> 使用所有传入的函数，而 <code class="inline">|||</code> 只使用其中一个。</p><code lang="haskell">apo :: Functor f =&gt; RCoalgebra f a -&gt; a -&gt; Term f  
apo f = In &lt;&lt;&lt; fmap (id ||| apo f) &lt;&lt;&lt; f</code><h2>结语</h2><p>如果读者们坚持读到了这里，那么你对 Recursion Scheme 已经有了相当的了解了，下一章中，我们将会讨论 futumorphism 和 histomorphism，并且展示其中强大的结构（以及一些迷之词缀）</p><p>感谢 Rob Rix, Colin Barrett，和 Manuel Chakravarty 对本文的指导和建议。 </p><h2>译者的话</h2><p>欢迎大家关注我的专栏<a href="https://zhuanlan.zhihu.com/catclaw">猫爪</a>，这个系列的文章我会更新完成（当然是不定期的=w=），之后应该也会发一些看到的有趣的 FP 类知识，基本上会是 Haskell 的，具体方向还没想好，大家有什么想法和建议也可以私信提出来讨论。</p><p>谢谢大家！</p><p>[1]:现代英语中常用 “para” 词缀表示 “虚假的”，“不正常的” 等含义（如 “parapsychology” 或 “paresthesia”）——这是从“旁边”的含义中引申而来的，在 paramorphism 一词中，并没有不正常或是低劣的含义。</p><p>[2]:实际上，这里的函数应该是指 <code class="inline">Category</code>，不过函数 <code class="inline">-&gt;</code> 就是一种 <code class="inline">Category</code>。（译者注：如果读者有 monad 的既视感，那么恭喜你，这种的直觉说是对的，可以阅读 <a href="https://en.wikibooks.org/wiki/Haskell/Arrow_tutorial">Arrows</a> 以了解更多）</p><p>[3]:实际上这样的优化步骤不应该出现在生成文档这样的场景下，而是在编译优化或者其他中间结果生成这样的时候，这里使用文档生成的例子，只是为了方便说明。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
