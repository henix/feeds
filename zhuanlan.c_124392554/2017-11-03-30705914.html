<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>流水线作业调度问题的初等分析</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/30705914">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-59ca3fa18ff577d167a5e5042962b266_r.jpg" alt=""></div><p>这是一个著名的问题，我不想讲得大而全，在此仅仅是针对Johnson不等式谈谈我的理解。</p><p>而尽量用初等的语言（所以会啰嗦），不引入动态规划。</p><p>（虽然我现在感觉这就是个<b>贪婪算法</b>啊，最优性分析和证明都是用的典型的“交换&amp;比较”方法。）</p><hr><p><b>问题：</b> 有<equation>n</equation> 个作业需要在2台机器 <equation>M_1</equation> 和 <equation>M_2</equation> 组成的流水线上完成加工。每个作业都必须先在 <equation>M_1</equation> 上加工，然后在 <equation>M_2</equation> 上加工。 <equation>M_1</equation> 和 <equation>M_2</equation> 加工作业 <equation>i</equation> 所需的时间分别记作 <equation>a_i </equation> 和 <equation>b_i</equation> ，每台机器同一时间最多只能执行一个作业。</p><p>请确定这 <equation>n</equation> 个作业的最优加工顺序（即1~<equation>n</equation> 的一个全排列），使得从第一个作业在机器 <equation>M_1</equation> 上开始加工，到最后一个作业在机器 <equation>M_2</equation> 上加工完成所需的时间最少。</p><p>（首先，我们假定 <equation>M_1</equation> 不停机，而只有 <equation>M_2</equation> 可能发生等待——这一点不影响最优方案，但在此不详细证明了。大意就是对于任意一个方案，先把 <equation>M_1</equation> 上的处理“往前推”，再尽量把 <equation>M_2</equation> 上的处理“往前推”，就一定不会延长总时间，还有可能缩短总时间。）</p><hr><p><b>示例：</b>有3个作业如下图所示</p><img src="https://pic4.zhimg.com/v2-4b88ad3d571c67f1a6121abdc1a60ecc_r.jpg" data-caption="" data-rawwidth="953" data-rawheight="91"><p>于是共有6种调度安排：</p><img src="https://pic2.zhimg.com/v2-afa49b9dffabcd92642179903d5a5f94_r.jpg" data-caption="" data-rawwidth="684" data-rawheight="559"><img src="https://pic3.zhimg.com/v2-7ebd30e2a0bb0a9b859ea638183888cc_r.jpg" data-caption="" data-rawwidth="684" data-rawheight="557"><p>其中方案3总时间最短。</p><hr><p><b>分析：</b>关键思路就是——<b> 如果对换“相邻”的两个作业会不会缩短时间</b>？</p><p>假定 <equation>t_0+\Delta</equation> 后 <equation>M_2</equation> 才开始空闲，但作业2的实际开始时刻则应该是 <equation>t_0+\max(\Delta,a_1)</equation> 。（ <equation>\Delta</equation> 由作业1之前的作业决定）</p><img src="https://pic2.zhimg.com/v2-4fb8851aff288871b4472fc8eb4ae219_r.jpg" data-caption="" data-rawwidth="717" data-rawheight="188"><p>对作业2之后的作业而言，有四种情况</p><img src="https://pic2.zhimg.com/v2-7c8fa3109eee0261e1d34acb26cb9cff_r.jpg" data-caption="" data-rawwidth="918" data-rawheight="436"><ul><li>在 <equation>M_1</equation> 上的最早开始时间是 <equation>t_0+a_1+a_2</equation> ；</li><li>在 <equation>M_2</equation> 上的最早开始时间是 <equation>T_{before}=t_0+\max\{a_1+a_2,a_1+b_1,\Delta+b_1\}+b_2</equation>。</li></ul><p>当作业1和作业2的次序对换时， <equation>\Delta</equation> 不变化，此时对作业2之后的作业而言：</p><ul><li>在 <equation>M_1</equation> 上的最早开始时间是 <equation>t_0+a_1+a_2</equation>  （没有变化）；</li><li>在 <equation>M_2</equation> 上的最早开始时间是 <equation>T_{after}=t_0+\max\{a_2+a_1,a_2+b_2,\Delta+b_2\}+b_1</equation>。</li></ul><p>分四种情况讨论一下交换前和交换后，这两个作业在 <equation>M_2</equation> 上都完成的最早时间：</p><p><b>①</b> <equation>a_1 = \min\{a_1,a_2,b_1,b_2\}</equation> 。此时有 <equation>a_1+a_2\leq b_2+a_2</equation>，于是 </p><p><equation>T_{after}=t_0+\max\{a_2+b_2,\Delta+b_2\}+b_1=t_0+\max\{a_2+b_1,\Delta+b_1\}+b_2</equation> 。</p><p>又 <equation>a_2+a_1\leq a_2+b_1</equation> ， <equation>a_1+b_1\leq a_2+b_1</equation> ，可得</p><p><equation>\max\{a_1+a_2,a_1+b_1,\Delta+b_1\}\leq\max\{b_1+a_2,\Delta+b_1\}</equation> </p><p>因此 <equation>T_{before}\leq T_{after}</equation> ，意即<b>交换次序不会使情况变好</b>。 </p><p><b>②</b> <equation>a_2 = \min\{a_1,a_2,b_1,b_2\}</equation> 。此时，类似①，可知 <equation>T_{before}\geq T_{after}</equation> ，意即<b>交换次序不会使情况变差</b>。</p><p><b>③</b> <equation>b_1 = \min\{a_1,a_2,b_1,b_2\}</equation> 。 此时有 <equation>a_1+a_2\geq a_1+b_1</equation> ，于是</p><p><equation>T_{before}=t_0+\max\{a_1+a_2,\Delta+b_1\}+b_2=t_0+\max\{a_1+a_2+b_2,\Delta+b_1+b_2\}</equation>。</p><p>又 <equation>a_1+a_2+b_2\geq a_1+a_2+b_1</equation> ， <equation>a_1+a_2+b_2\geq b_1+a_2+b_2</equation> ，可得</p><p><equation>\max\{a_1+a_2+b_2,\Delta+b_1+b_2\}\geq\max\{a_2+a_1+b_1,a_2+b_2+b_1,\Delta+b_2+b_1\}</equation> 。</p><p>即 <equation>T_{before}\geq T_{after}</equation>，意即<b>交换次序不会使情况变差</b>。</p><p>④ <equation>b_2 = \min\{a_1,a_2,b_1,b_2\}</equation> 。类似③，可得，意即<b>交换次序不会使情况变好</b>。</p><hr><p>以上分析了什么情况下<b>对换“相邻”的两个作业至少不会使情况变差</b>。</p><p>因此我们可以从局部到整体，分析如何确定加工顺序。</p><p>计算 <equation>\min\{a_1,b_1,a_1,b_1,...a_n,b_n\}</equation> ，有两种情况：</p><p><b>㊀ </b>这个最小值是某个 <equation>a_i</equation> ，那么如果它不是第一个被加工的，就可以根据②将它与前面相邻的任务次序对换，而总时间不会变长（还有可能变短）。不断这样进行下去，直到它成为第一个被加工的。把它放到该放的位置，以后就不用考虑它了。</p><p><b>㊁ </b>这个最小值是某个 <equation>b_j</equation> ，那么如果它不是最后一个被加工的，就可以根据③将它与后面相邻的任务次序对换，而总时间不会变长（还有可能变短）。不断这样进行下去，直到它成为最后一个被加工的。把它放到该放的位置，以后就不用考虑它了。</p><p>之后递归处理，逐个放好任务的位置即可。</p><hr><p>而②和③，就是所称的“<b>Johnson不等式</b>”：如果作业 <equation>i</equation> 和 <equation>j</equation> 满足 <equation>\min\{b_i,a_j\}\geq\min\{b_j,a_i\}</equation> ，则称作业 <equation>i</equation> 和 <equation>j</equation> 满足Johnson不等式，此时作业 <equation>i</equation> 应该排在作业 <equation>j</equation> 之前。</p><hr><p>基于此，可以给出流水线作业调度问题的一个算法（原谅我懒得写严谨了）：</p><ol><li><equation>S\leftarrow\{a_1,b_1,a_1,b_1,...a_n,b_n\}</equation> ；</li><li>数组 <equation>A\leftarrow empty(n)</equation> </li><li><equation>x\leftarrow \min(S)</equation> </li><li>若 <equation>x=a_i</equation> ，则将任务 <equation>i</equation> 放入数组 <equation>A</equation> 从前向后的第一个空位置；若 <equation>x=b_i</equation> 则将任务 <equation>i</equation> 放入数组 <equation>A</equation> 从后向前的第一个空位置。 <equation>S\leftarrow S-\{a_i,b_i\}</equation> 。</li><li>若 <equation>S\ne\emptyset</equation> 则返回步骤4，否则输出 <equation>A</equation> 。</li></ol><p>例如一开始的示例，计算过程如下图所示，得到方案3：</p><img src="https://pic2.zhimg.com/v2-b5f8999a1f0e6fd753ade1486862ce45_r.jpg" data-caption="" data-rawwidth="957" data-rawheight="616"><p>（如果排序时 <equation>a_2</equation> 在 <equation>b_2</equation> 之前，则得到方案1）</p><hr><p>代码实现我就不细说了，简单的很，一个优先级队列，两个flag标记，一个数组，flag1负责从前往后填，flag2负责从后往前填，最后计算时间，作业 <equation>k+1</equation> 在 <equation>M_1</equation> 的开始时间是 <equation>\sum_{i=1}^{k}{a_k}</equation> 、在 <equation>M_2</equation> 的开始时间是 <equation>\max\{\sum_{i=1}^{k+1}{a_k},作业k在M_2的开始时间+b_k\}</equation> 。</p><p></p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
