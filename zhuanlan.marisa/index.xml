<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 02 Mar 2020 14:50:37 +0800</lastBuildDate>
<item>
<title>南京大学静态程序分析课程《软件分析》上线啦！</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2020-03-01-110050716.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/110050716&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-64241b7d80e67f52cae789d4229ad4f5_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;南京大学静态程序分析课程《软件分析》号外！&lt;/p&gt;&lt;p&gt;自2020年2月末，南京大学计算机科学与技术系专业选修课程《软件分析》正式开课啦！受疫情影响，该课程将在线上授课，主讲教师为&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//yuelee.bitbucket.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;李樾&lt;/a&gt;和&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//silverbullettt.bitbucket.io/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;我&lt;/a&gt;，该课程将系统讲解静态程序分析相关知识。&lt;/p&gt;&lt;p&gt;为了让南大的同学们可以回看上课视频，也为了让更多其它学校感兴趣的同学们可以学习静态分析，我们现在每周上课之后会上传直播的录像。目前计划持续更新课程录像直到疫情结束（每周四更新）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;以下是已更新的所有课程录像（目前只有第一节 ~( ˘•ω•˘ )~）：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av91858985&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-66f1f089c70bb49a1daa222b8fabf49b_180x120.jpg&quot; data-image-width=&quot;1280&quot; data-image-height=&quot;720&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;南京大学《软件分析》课程01（Introduction）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili&lt;/a&gt;&lt;p&gt;也可以直接进入课程频道观看所有录像：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//space.bilibili.com/2919428/channel/detail%3Fcid%3D106434&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili&lt;/a&gt;&lt;p&gt;欢迎对PL和静态程序分析感兴趣的小伙伴们前来围观╭(●｀∀´●)╯&lt;/p&gt;</description>
<author>甜品专家</author>
<guid isPermaLink="false">2020-03-01-110050716</guid>
<pubDate>Sun, 01 Mar 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>NuPRL 中的证明{x:N|2&lt;x&lt;3}--virtual evidence</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2020-02-24-108759696.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/108759696&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cfb08ef25758a281a21d224980801ea0_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;上一篇 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/107183874&quot; class=&quot;internal&quot;&gt;LdBeth：NuPRL 中的证明 (二) -- 我从来不写递归的&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这篇的主要內容是 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.nuprl.org/KB/show.php%3FID%3D759&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Virtual Evidence: A Constructive Semantics for Classical Logics&lt;/a&gt; 和 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.nuprl.org/MathLibrary/VirtualEvidence/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Constructive Reading of Classical Logic&lt;/a&gt; 的导读。 也算是第一次展示了下 NuRPL 中的证明，順帯引入 squash type 的概念。&lt;/p&gt;&lt;p&gt;MLTT Agda 中要获得 LEM 得 posutulate （防止你们说 CubicalTT）。众所周知这样 p 出来的 LEM 虽然和 MLTT 相容，但还是沒有 computational meaning 的，这样的 classical logic 是沒有灵魂的。&lt;/p&gt;&lt;p&gt;那 NuPRL 是怎么解決这个的呢？&lt;/p&gt;&lt;p&gt;Recall, refinment type OR subtyping in NuPRL&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bx%3AA%5C+%7C%5C+P%28x%29+%5C%7D&quot; alt=&quot;\{x:A\ |\ P(x) \}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;it is easy to get non dependent form&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7BS%5C+%7C%5C+T%5C%7D&quot; alt=&quot;\{S\ |\ T\}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;Unit type 只有一个 element &lt;img src=&quot;https://www.zhihu.com/equation?tex=%2A&quot; alt=&quot;*&quot; eeimg=&quot;1&quot;/&gt; ，因而当 proposition P 成立时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7BUnit%5C+%7C%5C+P%5C%7D&quot; alt=&quot;\{Unit\ |\ P\}&quot; eeimg=&quot;1&quot;/&gt; 也只有一个 element，而 P 为 False (which is an alias to Void) 时这个类型等于 Void。&lt;/p&gt;&lt;p&gt;在 ITT 中，P 的证明是一个具體的 p : P，而用 refinement type &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7BUnit%5C+%7C%5C+P%5C%7D%5C%3B+abbrev+%5C%3B%5C%7BP%5C%7D&quot; alt=&quot;\{Unit\ |\ P\}\; abbrev \;\{P\}&quot; eeimg=&quot;1&quot;/&gt; 表示 classical logic 的命题就可以把 P 的证明给 squash to trivial。这样显然地，我们有把 constructive proof to classical proof 的 computation procedure &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+x.%2A%5Cin+P+%5Cimplies+%5C%7BP%5C%7D&quot; alt=&quot;\lambda x.*\in P \implies \{P\}&quot; eeimg=&quot;1&quot;/&gt; ，而反之则不一定成立，从而規避了任意用 classical proof 进行 constructive proof。&lt;/p&gt;&lt;p&gt;然后就要有 double negation rule &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+x.%2A+%5Cin+%5Cneg%5Cneg+P+%5Cimplies+%5C%7BP%5C%7D&quot; alt=&quot;\lambda x.* \in \neg\neg P \implies \{P\}&quot; eeimg=&quot;1&quot;/&gt; ： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cneg%5Cneg+P&quot; alt=&quot;\neg\neg P&quot; eeimg=&quot;1&quot;/&gt; 表明 P 不为 False，而由于 refinement type 的定义当 P 不为 False 时，因为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7B+P%5C%7D&quot; alt=&quot;\{ P\}&quot; eeimg=&quot;1&quot;/&gt; 只可能有一个 element，所以很容易就得到它的 computational meaning，也就是 const trivial 这样一个函数。 &lt;/p&gt;&lt;p&gt;这样就可以证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+P+%3A+%5Cmathbb%7BP%7D%5C+.+%5C%7BP%5C%7D%5Cimplies+%5Cneg%5Cneg+P&quot; alt=&quot;\forall P : \mathbb{P}\ . \{P\}\implies \neg\neg P&quot; eeimg=&quot;1&quot;/&gt; ，也就是从 classical proposition 到 intutionistic double negation 的 formation。在 NuPRL 中的证明如下。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a1cfc3d89e0309f265dd0729d5df728c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;598&quot; data-rawheight=&quot;1124&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;598&quot; data-original=&quot;https://pic1.zhimg.com/v2-a1cfc3d89e0309f265dd0729d5df728c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a1cfc3d89e0309f265dd0729d5df728c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;598&quot; data-rawheight=&quot;1124&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;598&quot; data-original=&quot;https://pic1.zhimg.com/v2-a1cfc3d89e0309f265dd0729d5df728c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a1cfc3d89e0309f265dd0729d5df728c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;以及 lem 的 classical proposition 的证明。其实用 Auto tactic 可以直接证出，不过为了方便理解还是贴上有完整思路的版本。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f727d7437743f24c3541855caf978387_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;672&quot; data-rawheight=&quot;1302&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;672&quot; data-original=&quot;https://pic4.zhimg.com/v2-f727d7437743f24c3541855caf978387_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f727d7437743f24c3541855caf978387_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;672&quot; data-rawheight=&quot;1302&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;672&quot; data-original=&quot;https://pic4.zhimg.com/v2-f727d7437743f24c3541855caf978387_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f727d7437743f24c3541855caf978387_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>LdBeth</author>
<guid isPermaLink="false">2020-02-24-108759696</guid>
<pubDate>Mon, 24 Feb 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>NuPRL 中的证明 (二) -- 我从来不写递归的</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2020-02-17-107183874.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/107183874&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e6d675dc8016451cd7f7b49353613e7f_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;图文无关。&lt;/p&gt;&lt;p&gt;上一篇文章 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/105439235&quot; class=&quot;internal&quot;&gt;LdBeth：NuPRL 中的证明--从一到CTT&lt;/a&gt;&lt;/p&gt;&lt;p&gt;上一篇讲了 CTT 中的一些类型。dependent function, dependent product, dependent record, universe 这些因为和 ITT 的沒什么区別，就默认读者已经会了。CTT 特色的 dependent intersection 和 dependent union 因为应用范围超出了基础，就先不讲了。&lt;/p&gt;&lt;h2&gt;General Recursion considered K&lt;/h2&gt;&lt;blockquote&gt;Also, in some other type systems, general recursion is not expressible, and such structural recursion operations must be built in.&lt;/blockquote&gt;&lt;p&gt;在 Agda 中，众所周知是用写程序來证明的，tc 过了相当于证明过了。然而 NuPRL 因为 undecidable type checking 的性质，除了程序以外，证明还包括了 tc。&lt;/p&gt;&lt;p&gt;比如吧，在 Agda 里要证 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%5Cleq+x%21&quot; alt=&quot;x\leq x!&quot; eeimg=&quot;1&quot;/&gt; ，就要先写 ! (factorial) 的定义，写完了以后，在使用 factorial 的定义之前，还要做两件事: 给它一个能过 tc 的类型声明，并且证明 termination。&lt;/p&gt;&lt;p&gt;而在 NuPRL 中，写完一个定义后，类型声明和 termination proof 都是不需要的。我是不是说过 NuPRL 沒有 pattern match？那 factorial 要怎么定义呢&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctextbf%7BRec%7D%5C+x%21+%3D%3D+%5Ctexttt%7Bif%7D%5C+x%3D0+%5Crightarrow+1%5C+%5Ctexttt%7Belse%7D%5C+x%28x-1%29%21%5C+%5Ctexttt%7Bfi%7D&quot; alt=&quot;\textbf{Rec}\ x! == \texttt{if}\ x=0 \rightarrow 1\ \texttt{else}\ x(x-1)!\ \texttt{fi}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;啥玩意，x 为负数的时候岂不是 non termination 了么？沒错，extrinsic type theory 就是可以为所欲为，这样的定义并不会造成什么问題。而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+x+%3A%5Cmathbb%7BN%7D.+x%21+%5Cin+%5Cmathbb%7BN%7D&quot; alt=&quot;\forall x :\mathbb{N}. x! \in \mathbb{N}&quot; eeimg=&quot;1&quot;/&gt; 可以做为一个单独的定理证明。&lt;/p&gt;&lt;p&gt;又比如&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-agda&quot;&gt;mu : (ℕ → Bool) → ℕ -- Kleene&amp;#39;s paradigmatic unbounded search function
mu f with f zero
... | true = 0
... | false = suc (mu (λ x → f (suc x)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样在 Agda 明显不能过 termination check 的定义，也全然大丈夫。&lt;/p&gt;&lt;h2&gt;Recursive Type considered K&lt;/h2&gt;&lt;blockquote&gt;吶，没有 ADT 咋定义 List 吶&lt;/blockquote&gt;&lt;p&gt;那啥，我好像沒提 inl inr 什么的，那就提一下吧。因为 Sum type 是 primitive，所以还有一个对应的的 data destructor 叫 InjCase。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctextbf%7BThm%7D%5C+%5Cforall+z+%3A+A%2BB.z+%3D+InjCase%28z%3Bu.inl%28u%29%3Bv.inr%28v%29%29&quot; alt=&quot;\textbf{Thm}\ \forall z : A+B.z = InjCase(z;u.inl(u);v.inr(v))&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;所以在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathbb%7BB%7D+%3D%3D+Unit%2BUnit%2C%5C+%5Ccdot+%5Cin+Unit&quot; alt=&quot;\mathbb{B} == Unit+Unit,\ \cdot \in Unit&quot; eeimg=&quot;1&quot;/&gt; 下， &lt;img src=&quot;https://www.zhihu.com/equation?tex=true+%3D%3D+inl%28%5Ccdot%29%2C%5C+false+%3D%3D+inr%28%5Ccdot%29%2C%5C+%5Ctexttt%7Bif%7D%5C+b%5C+%5Crightarrow+t%5C+%5Ctexttt%7Belse%7D%5C+f%5C+%5Ctexttt%7Bfi%7D+%3D%3D+InjCase%28b+%3B+t%3B+f%29&quot; alt=&quot;true == inl(\cdot),\ false == inr(\cdot),\ \texttt{if}\ b\ \rightarrow t\ \texttt{else}\ f\ \texttt{fi} == InjCase(b ; t; f)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;借助用来定义 recursive type 的 primitive， &lt;img src=&quot;https://www.zhihu.com/equation?tex=List+%28A%29+%3D%3D+rec%28X.Unit%2B%28A%5Ctimes+X%29%29%2C%5C+nil+%3D+inl%28%5Ccdot%29%2C%5C+Cons%28a%2Cb%29%3D%3Dinr%28%3Ca%2Cb%3E%29&quot; alt=&quot;List (A) == rec(X.Unit+(A\times X)),\ nil = inl(\cdot),\ Cons(a,b)==inr(&amp;lt;a,b&amp;gt;)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;还有个 destructor&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctexttt%7Bcase%7D%5C+s%3A+nil+%5Crightarrow+e%3B+Cons%28x%2Cy%29+%5Crightarrow+f%28x%2Cy%29+%3D%3D+InjCase%28s%3Be%3Bx%2Cy.f%28x%2Cy%29%29&quot; alt=&quot;\texttt{case}\ s: nil \rightarrow e; Cons(x,y) \rightarrow f(x,y) == InjCase(s;e;x,y.f(x,y))&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;忘了提了，不过很显然&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+a+%3A+A%2C+b+%3A+B.+%3Ca%2C+b%3E+%5Cin+A+%5Ctimes+B&quot; alt=&quot;\forall a : A, b : B. &amp;lt;a, b&amp;gt; \in A \times B&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;This is (not) Y Kombinator&lt;/h2&gt;&lt;p&gt;上面的定义用到了 recursion，对于了解 untyped lambda 的读者定然知道 Y combinator。&lt;/p&gt;&lt;p&gt;NuPRL 的 recursion 并非做成了 primitive，而是用 Y 定义的。&lt;/p&gt;&lt;p&gt;上面 factorial 的定义实质上是&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=x%21+%3D%3D+Y%28%5Clambda+fx.+%5Ctexttt%7Bif%7D%5C+x%3D0+%5Crightarrow+1%5C+%5Ctexttt%7Belse%7D%5C+f%28x%28x-1%29%29%5C+%5Ctexttt%7Bfi%7D%2C+x%29&quot; alt=&quot;x! == Y(\lambda fx. \texttt{if}\ x=0 \rightarrow 1\ \texttt{else}\ f(x(x-1))\ \texttt{fi}, x)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>LdBeth</author>
<guid isPermaLink="false">2020-02-17-107183874</guid>
<pubDate>Mon, 17 Feb 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>凉爽的 CuTT 介绍（3）：开着的方形可以盖上</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2020-02-09-105824063.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/105824063&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;回想&lt;a href=&quot;https://zhuanlan.zhihu.com/p/104929162&quot; class=&quot;internal&quot;&gt;上一篇&lt;/a&gt;，我们有了&lt;b&gt;高阶归纳类型（Higher Inductive Type）&lt;/b&gt;和它们的运算和性质，然后大概看了一下 &lt;code&gt;isoToPath&lt;/code&gt; 函数。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-agda&quot;&gt;{-# OPTIONS --cubical --allow-unsolved-metas #-}
module 2019-10-14-Cutt3 where
open import Cubical.Core.Everything
open import Cubical.Foundations.Prelude

open import Agda.Builtin.Nat

variable A : Set&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在文章的最后我给出了另一个 HIT 的整数定义，它是配备了像「&lt;code&gt;a - b&lt;/code&gt; 等于 &lt;code&gt;suc a - suc b&lt;/code&gt;」这样的路径的自然数减法的集合。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;infixl 5 _⊝_
data DeltaInt : Set where
  _⊝_    : Nat -&amp;gt; Nat -&amp;gt; DeltaInt
  cancel : ∀ a b -&amp;gt; a ⊝ b ≡ suc a ⊝ suc b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;问题随之而来：&lt;b&gt;如何证明以下命题？&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;question = ∀ a b i → cancel a b i ≡ cancel (suc a) (suc b) i&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以把它画出来（我们叫它&lt;b&gt;「问题方形」&lt;/b&gt;。记住它，我们很快就会用到！）：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-12de2a75773fbc2b344997fa5427b10f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;441&quot; data-rawheight=&quot;562&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;441&quot; data-original=&quot;https://pic4.zhimg.com/v2-12de2a75773fbc2b344997fa5427b10f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-12de2a75773fbc2b344997fa5427b10f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;441&quot; data-rawheight=&quot;562&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;441&quot; data-original=&quot;https://pic4.zhimg.com/v2-12de2a75773fbc2b344997fa5427b10f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-12de2a75773fbc2b344997fa5427b10f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（注意我们用 &lt;code&gt;ssa&lt;/code&gt; 来表示 &lt;code&gt;suc (suc a)&lt;/code&gt;，用 &lt;code&gt;sa&lt;/code&gt; 表示 &lt;code&gt;suc a&lt;/code&gt; 以节省图中的空间，&lt;code&gt;b&lt;/code&gt; 也是同样的简写）&lt;/p&gt;&lt;p&gt;问题方形中涉及三个不同的端点值，因而无法用我们已知的三种运算（&lt;code&gt;∧&lt;/code&gt;、&lt;code&gt;∨&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt;）把它构造出来，这三种运算基本上只是把一条路径「扩张」成了方形，而我们的新方形是有几条路径组合而成的。&lt;/p&gt;&lt;blockquote&gt;换言之，前面的方形是由一条线扫出来的，而这个没盖子的方形是由三条线首尾相接连出来的。&lt;/blockquote&gt;&lt;p&gt;为此我们需要另一种运算——&lt;code&gt;hcomp&lt;/code&gt;，它是&lt;b&gt;齐次组合（Homogeneous Composition）&lt;/b&gt;的简写。&lt;/p&gt;&lt;h2&gt;齐次组合&lt;/h2&gt;&lt;p&gt;在我读过的立方类型论教程中，&lt;code&gt;hcomp&lt;/code&gt; 运算符是通过「Kan 运算（Kan operation）」 「Kan-填充运算（Kan-filling operation）」这样可怕的术语来描述的。它们也试图将该运算描述为：&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;一个开方形（open square）的组合&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;或：&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;得到开方形的盖子（cap）&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;或类似的东西。我读过这些句子，但从未真正理解 &lt;code&gt;hcomp&lt;/code&gt; 应该传入什么参数。我找到的唯一还算可读的是 Anders 基于 cubicaltt 的教程。cubicaltt 是一个实现了立方类型论的最小依赖类型语言，但它也只是 cubicaltt，并不是 Agda。&lt;/p&gt;&lt;p&gt;下面是我对 &lt;code&gt;hcomp&lt;/code&gt; 的介绍，我希望你们能够理解它。&lt;/p&gt;&lt;h2&gt;方形&lt;/h2&gt;&lt;p&gt;首先，想象三条路径 &lt;code&gt;p&lt;/code&gt;、&lt;code&gt;q&lt;/code&gt; 和 &lt;code&gt;r&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;module SquareHcomp
  (a b c d : A)
  (p : a ≡ b)
  (q : a ≡ c)
  (r : b ≡ d)
where&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 &lt;code&gt;hcomp&lt;/code&gt; 运算，我们可以从给定的三条路径获得路径 &lt;code&gt;c ≡ d&lt;/code&gt;（&lt;code&gt;hcomp&lt;/code&gt; 如此设计的原因超出了本文讨论的范围）。&lt;/p&gt;&lt;p&gt;下面是一个 &lt;code&gt;hcomp&lt;/code&gt; 的具体例子，我会写出它的代码并画出对应的图（你可以看一眼），然后告诉你如何阅读它们（不过现请先&lt;b&gt;不要&lt;/b&gt;深入语法细节）。我们先从它的图像开始，对它有个直观的理解，然后再回到 Agda 具体的语法上来。&lt;/p&gt;&lt;p&gt;代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;newPath : c ≡ d
newPath i = hcomp (λ j -&amp;gt; λ
  { (i = i0) -&amp;gt; q j
  ; (i = i1) -&amp;gt; r j
  }) (p i)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其语法的解释（本文剩下的部分并不依赖本段，是否阅读请自行斟酌）： 我们编写了一个函数，它对形参 &lt;code&gt;i&lt;/code&gt; 进行模式匹配，并返回一个表达式。该表达式以两个参数调用了 &lt;code&gt;hcomp&lt;/code&gt;：第一个参数是一个 λ-表达式，它接受一个参数 &lt;code&gt;j&lt;/code&gt;，返回另一个特殊的 λ-表达式，它看起来像一个模式匹配 λ（我们称之为「系统（system）」），但并不相同；另一个参数则是 &lt;code&gt;p i&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;不要去看 &lt;code&gt;hcomp&lt;/code&gt; 的函数签名，因为目前并无帮助（我知道你很好奇，但请不要看它）。&lt;/p&gt;&lt;p&gt;图像：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9294305e0686173a1831bad1bca744f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;457&quot; data-rawheight=&quot;451&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;457&quot; data-original=&quot;https://pic4.zhimg.com/v2-e9294305e0686173a1831bad1bca744f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9294305e0686173a1831bad1bca744f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;457&quot; data-rawheight=&quot;451&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;457&quot; data-original=&quot;https://pic4.zhimg.com/v2-e9294305e0686173a1831bad1bca744f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e9294305e0686173a1831bad1bca744f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图中的虚线就是我们的 &lt;code&gt;newPath&lt;/code&gt;，它的间点由 &lt;code&gt;hcomp&lt;/code&gt; 构造。注意图中标出了 &lt;code&gt;q j&lt;/code&gt;、&lt;code&gt;r j&lt;/code&gt; 和 &lt;code&gt;p i&lt;/code&gt; 所对应的路径。&lt;/p&gt;&lt;p&gt;现在暂且先忘掉前面的语法吧，我们来看图。&lt;code&gt;hcomp&lt;/code&gt; 运算接受三条路径并返回一条路径。我们把这个由三条给定的路径构成的不完整方形叫做 &lt;b&gt;开图形（open shape）&lt;/b&gt;，在这里它是二维的，因此我们也叫它&lt;b&gt;开方形（open square）&lt;/b&gt;。注意三条路径是首尾相连的（「首尾相连」的意思是有一个公共端点），这样才能构成一个开图形。&lt;code&gt;&lt;b&gt;hcomp&lt;/b&gt;&lt;/code&gt; &lt;b&gt;所做的就是把开图形缺失的部分盖上&lt;/b&gt;，而这里它是一个方形，因此 &lt;code&gt;hcomp&lt;/code&gt; 给出的就是开方形顶部缺失的路径。&lt;/p&gt;&lt;p&gt;这看起来很简单，但之所以简单只是因为我们在处理方形。如果再加一个维度呢？&lt;/p&gt;&lt;p&gt;&lt;code&gt;hcomp&lt;/code&gt; 实际上可用于任意维度。记住 &lt;code&gt;hcomp&lt;/code&gt; 所做的就是把开图形缺失的部分给盖上，而由于它是一个开&lt;b&gt;立方体（cube）&lt;/b&gt;（带有五个给定的方形），因此 &lt;code&gt;hcomp&lt;/code&gt; 可以给出顶部缺失的&lt;b&gt;方形&lt;/b&gt;！因此，如果我们想要一个拥有特定四个端点的方形，那么可以找出一个开立方体，它缺失的盖子刚好拥有这四个端点，然后用 &lt;code&gt;hcomp&lt;/code&gt; 来得到想要的方形！&lt;/p&gt;&lt;p&gt;回忆问题方形，它的四个顶点是已知的，因此我们可以把它想象成一个立方体的方形盖子。该立方体共有 8 个端点和 6 个面，其中：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;顶面的四个端点由问题方形构成&lt;/li&gt;&lt;li&gt;底面的四个端点我们可自由选择&lt;/li&gt;&lt;li&gt;顶部的方形是我们所求的，即 &lt;code&gt;hcomp&lt;/code&gt; 的输出&lt;/li&gt;&lt;li&gt;另外五个方形则是 &lt;code&gt;hcomp&lt;/code&gt; 的输入&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;我们需要选出四个特定的底面的端点，让五个输入方形能足够简单地构造出来。&lt;/b&gt;「足够简单」的意思是「可通过已知路径以及运算 &lt;code&gt;∧&lt;/code&gt;、&lt;code&gt;∨&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 来构造」。&lt;/p&gt;&lt;p&gt;我们先画出一个一般的立方体：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-47e9c39ae69ef83f5b67f980e0434256_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;417&quot; class=&quot;content_image&quot; width=&quot;415&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-47e9c39ae69ef83f5b67f980e0434256_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;417&quot; class=&quot;content_image lazy&quot; width=&quot;415&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-47e9c39ae69ef83f5b67f980e0434256_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;（抱歉这图画得不够好，我已经尽力了。另外 &lt;code&gt;i&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 的方向很重要，记住路径是有方向的）&lt;/p&gt;&lt;p&gt;虚线边的方形是 &lt;code&gt;hcomp&lt;/code&gt; 所求的。我们将 &lt;code&gt;a ⊝ b&lt;/code&gt;、&lt;code&gt;suc a ⊝ suc b&lt;/code&gt;、&lt;code&gt;suc (suc a) ⊝ suc (suc b)&lt;/code&gt; 和 &lt;code&gt;suc a ⊝ suc b&lt;/code&gt; 分别赋予问题方形 &lt;code&gt;question&lt;/code&gt; 的 &lt;code&gt;w&lt;/code&gt;、&lt;code&gt;x&lt;/code&gt;、&lt;code&gt;y&lt;/code&gt;、&lt;code&gt;z&lt;/code&gt;。下面列出了赋予变量的项：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;点             项
w            a ⊝ b
x        suc a ⊝ suc b
y  suc (suc a) ⊝ suc (suc b)
z        suc a ⊝ suc b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可以自己画出替换后的图，我并不会给出所有的中间步骤。&lt;/p&gt;&lt;p&gt;&lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt;、&lt;code&gt;d&lt;/code&gt; 的值有很多可行的选择，不过我在这里选择了以下组合 （为了更好地练习，你也可以选择不同的组合）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;点       项
a      a ⊝ b
b  suc a ⊝ suc b
c  suc a ⊝ suc b
d  suc a ⊝ suc b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（注意列表中左栏中的 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是点，而右栏中的 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是 &lt;code&gt;Int&lt;/code&gt; 的实例）&lt;/p&gt;&lt;p&gt;现在我们把这个立方体补完了，剩下的步骤就是填出这五个方形。我们来观察一下立方体上这五个方形的特点（强烈建议你把这个立方体画出来）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;方形     特点
abcd   max 方形
abxw    refl
bcyx   min 方形
adzw    refl
cdzy   min 方形&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;「max 方形」表示由 &lt;code&gt;cancel&lt;/code&gt; 路径构成的最大方形，「min 方形」与此类型。&lt;/li&gt;&lt;ul&gt;&lt;li&gt;如果你忘记了「max 方形」的定义，请回顾本系列文章的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/103565709&quot; class=&quot;internal&quot;&gt;第二篇&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;「refl」表示 &lt;code&gt;λ i -&amp;gt; some-path&lt;/code&gt;（也可以是 &lt;code&gt;λ i j -&amp;gt; cancel i&lt;/code&gt;），即一个端点也是路径的常量路径，或者是它旋转后的版本。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;有了这五个方形，我们的立方体可以简单地构造而成，可以说是呼之欲出了（只是还缺少顶部的方形）！&lt;/p&gt;&lt;p&gt;下面是最终的方形：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-82818bfa5687acc317b645e90d2b5d4f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;444&quot; data-rawheight=&quot;439&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;444&quot; data-original=&quot;https://pic4.zhimg.com/v2-82818bfa5687acc317b645e90d2b5d4f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-82818bfa5687acc317b645e90d2b5d4f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;444&quot; data-rawheight=&quot;439&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;444&quot; data-original=&quot;https://pic4.zhimg.com/v2-82818bfa5687acc317b645e90d2b5d4f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-82818bfa5687acc317b645e90d2b5d4f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;描述一个开图形&lt;/h2&gt;&lt;p&gt;现在是时候介绍 Agda 中 &lt;code&gt;hcomp&lt;/code&gt; 的具体语法了。&lt;/p&gt;&lt;p&gt;一般来说，当我们调用 &lt;code&gt;hcomp&lt;/code&gt; 去创建一个 n-维的路径时，函数会类似于（以二维路径为例）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;test i j = hcomp blabla&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设上下文中已有两个间点变量。然而，我们描述的开图形还有一个维度 （记住当你需要一个路径时，&lt;code&gt;hcomp&lt;/code&gt; 是一个方形，当你需要一个方形时，&lt;code&gt;hcomp&lt;/code&gt; 是一个立方体，以此类推）。额外的间点变量并不在 &lt;code&gt;hcomp&lt;/code&gt; 所给出的顶部缺失的图形中，但它们可以从侧面的图形中访问到。此开图形的底部与顶部缺失的图形平行，它与额外的维度彼此独立。&lt;/p&gt;&lt;p&gt;总而言之，&lt;code&gt;hcomp&lt;/code&gt; 的参数应该有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个底部&lt;/li&gt;&lt;li&gt;一个函数，它从一个间点（代表额外的维度）映射到该图形所有的侧面&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于一个立方体来说，该函数应该返回四个侧面，每一个都是方形； 对于一个方形来说，它应该返回两个侧边，每一个都是路径。&lt;/p&gt;&lt;p&gt;我们从解释上面的 &lt;code&gt;newPath&lt;/code&gt; 开始，逐步推进到问题方形（你大概需要看一下前面 &lt;code&gt;newPath&lt;/code&gt; 的图片，我不想再复制一份了）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;newPath2 : c ≡ d
 newPath2 i = hcomp
       -- ^ 原始的维度
  (\ j -&amp;gt;
  -- ^ 额外的维度
   \ { (i = i0) -&amp;gt; q j
               --  ^^^ 路径 `a ≡ c`，从 `j = i0` 到 `j = i1`
    --  ^^^^^^ 路径 `a ≡ c` 的起点
     ; (i = i1) -&amp;gt; r j
               --  ^^^ 路径 `b ≡ d`，从 `j = i0` 到 `j = i1`
    --  ^^^^^^ 路径 `b ≡ d` 的起点
     })
   (p i)
 -- ^^^ 底面 `a ≡ b`&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们用模式匹配语法来描述开图形的侧面。以 &lt;code&gt;q j&lt;/code&gt; 为例：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;路径 &lt;code&gt;a ≡ b&lt;/code&gt; 为 &lt;code&gt;p i&lt;/code&gt;&lt;/li&gt;&lt;li&gt;路径 &lt;code&gt;a ≡ c&lt;/code&gt; 为 &lt;code&gt;q j&lt;/code&gt;&lt;/li&gt;&lt;li&gt;当 &lt;code&gt;i = i0&lt;/code&gt; 时，路径 &lt;code&gt;p i&lt;/code&gt; 归约到 &lt;code&gt;a&lt;/code&gt;，我们将 &lt;code&gt;i = i0&lt;/code&gt; 称为 &lt;code&gt;p i&lt;/code&gt; 的 &lt;i&gt;&lt;code&gt;a&lt;/code&gt;-面&lt;/i&gt;&lt;/li&gt;&lt;li&gt;路径 &lt;code&gt;q j&lt;/code&gt; 从路径 &lt;code&gt;p i&lt;/code&gt; 的 &lt;code&gt;a&lt;/code&gt; 面开始（换言之就是「连接到它」）&lt;/li&gt;&lt;li&gt;我们用语法 &lt;code&gt;(i = i0) -&amp;gt; q j&lt;/code&gt; 来描述&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;(i = i1) -&amp;gt; r j&lt;/code&gt; 也与此类似，这就是完整的 &lt;code&gt;newPath&lt;/code&gt; 了。&lt;/p&gt;&lt;p&gt;有趣的事实：你可以对零维进行 &lt;code&gt;hcomp&lt;/code&gt;，它就是恒等函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;id : ∀ {ℓ} {A : Set ℓ} -&amp;gt; A -&amp;gt; A
id a = hcomp {φ = i0} (λ i ()) a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;回到 &lt;code&gt;question&lt;/code&gt; 上来&lt;/h2&gt;&lt;p&gt;我们先准备好 &lt;code&gt;cancel&lt;/code&gt; 给出的 min/max 方形:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;maxSq : (a b : Nat) -&amp;gt; (i j : I) -&amp;gt; DeltaInt
maxSq a b i j = cancel a b (i ∨ j)

minSq : (a b : Nat) -&amp;gt; (i j : I) -&amp;gt; DeltaInt
minSq a b i j = cancel a b (i ∧ j)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着实现 &lt;code&gt;question&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;questionImpl : question
questionImpl a b i j = hcomp
  (λ k -&amp;gt; λ -- the extra dimension
  { (i = i0) -&amp;gt; cancel a b j
  -- ^ 当 `i = i0`，时它是左侧的方形 adzw
  ; (i = i1) -&amp;gt; minSq (suc a) (suc b) j k
  -- ^ 当 `i = i1`，时它是右侧的方形 bcyx
  ; (j = i0) -&amp;gt; cancel a b i
  -- ^ 当 `j = i0`，时它是前面的方形 abxw
  ; (j = i1) -&amp;gt; minSq (suc a) (suc b) i k
  -- ^ 当 `j = i1`，时它是后面的方形 cdzy
  })
  (maxSq a b i j) -- 方形 abcd&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;搞定！&lt;/p&gt;&lt;h2&gt;传递性&lt;/h2&gt;&lt;p&gt;函数 &lt;code&gt;compPath&lt;/code&gt;，即路径具有传递性，也是通过 &lt;code&gt;hcomp&lt;/code&gt; 来证明的。&lt;code&gt;transitivity&lt;/code&gt; 的类型签名为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;transitivity : {a b c : A} -&amp;gt; a ≡ b -&amp;gt; b ≡ c -&amp;gt; a ≡ c&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们从引入变量并从方形的 &lt;code&gt;hcomp&lt;/code&gt; 开始：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;transitivity {a = a} p q i = hcomp&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们构造了这样一个方形：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-144a8479c7fd82f4fc2c950c241ea141_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;444&quot; data-rawheight=&quot;465&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;444&quot; data-original=&quot;https://pic2.zhimg.com/v2-144a8479c7fd82f4fc2c950c241ea141_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-144a8479c7fd82f4fc2c950c241ea141_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;444&quot; data-rawheight=&quot;465&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;444&quot; data-original=&quot;https://pic2.zhimg.com/v2-144a8479c7fd82f4fc2c950c241ea141_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-144a8479c7fd82f4fc2c950c241ea141_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;将此图翻译成 Agda 就是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(λ j -&amp;gt; λ
  { (i = i0) -&amp;gt; a
  ; (i = i1) -&amp;gt; q j
  })
 (p i)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样就证明传递性了！&lt;/p&gt;&lt;h3&gt;后记&lt;/h3&gt;&lt;p&gt;感谢 Anders Mörtberg 在 CMU 的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//hott.github.io/HoTT-2019//summer-school/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HoTT 2019 Summer School&lt;/a&gt; 上教会了我 &lt;code&gt;hcomp&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我从 David Leduc 和 Donnacha Oisín Kidney 那收到了邮件，将他们的建议融合在了 「凉爽的 CuTT 介绍」系列文章中，他们的建议给了我很多帮助。我也非常感谢你们能阅读我的拙作！&lt;/p&gt;&lt;p&gt;此外，如果你正在寻找相关的资料，并且希望让我知道，也可以联系我！&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2020-02-09-105824063</guid>
<pubDate>Sun, 09 Feb 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>凉爽的 CuTT 介绍（2）：带有路径构造子的归纳类型</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2020-02-09-104929162.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/104929162&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;文本译自&lt;a href=&quot;https://www.zhihu.com/people/67ebe1bd8e4a63f17a42572e40afaac7&quot; class=&quot;internal&quot;&gt;@千里冰封 你懂吗&lt;/a&gt;介绍&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ice1000.org/2019/10-01-Cutt2.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;立方类型论&lt;/a&gt;的文章。&lt;/blockquote&gt;&lt;p&gt;回忆&lt;a href=&quot;https://zhuanlan.zhihu.com/p/103565709&quot; class=&quot;internal&quot;&gt;上一章&lt;/a&gt;，我们有了高维的路径（方形），而且可以通过路径应用来归约（降低）它们的维度。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;{-# OPTIONS --cubical --allow-unsolved-metas #-}
module 2019-10-1-Cutt2 where
open import Cubical.Core.Everything
open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Isomorphism
open import Agda.Builtin.Nat

variable A : Set&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;回忆经典的整数定义（点击 &lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ice1000.org/lagda/Cubical.Data.Int.Base.html%23142&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 查看）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import Cubical.Data.Int using (Int)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这玩意儿看着很不爽，因为它不对称——以数字 2 为例，&lt;code&gt;+2&lt;/code&gt; 是 &lt;code&gt;pos 2&lt;/code&gt;，而 &lt;code&gt;-2&lt;/code&gt; 却是 &lt;code&gt;negsuc 1&lt;/code&gt;。证明这种不对称整数的加法交换律很让人蛋疼（瞅一眼&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ice1k/Theorems/blob/master/src/Ints/Add/Assoc.agda&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这儿&lt;/a&gt;） （由于整数的定义不是对称的，因此其上的运算自然也不对称）。&lt;/p&gt;&lt;p&gt;我们想要一种对称的整数定义，它大概是这样的：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;data Int : Set where
  pos : Nat -&amp;gt; Int
  neg : Nat -&amp;gt; Int&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过这样我们就有两个零了：&lt;code&gt;pos 0&lt;/code&gt;和&lt;code&gt;neg 0&lt;/code&gt;。我们&lt;b&gt;之所以&lt;/b&gt;把经典的整数定义成不对称的，是为了避免存在两种零，虽然从数学上讲零既非正数也非负数（从另一个角度上也可以说是只有正零而没有负零）。&lt;/p&gt;&lt;p&gt;于是问题来了：&lt;b&gt;我们能告诉 Agda&lt;/b&gt; &lt;b&gt;&lt;code&gt;pos 0&lt;/code&gt;&lt;/b&gt; &lt;b&gt;等于&lt;/b&gt; &lt;b&gt;&lt;code&gt;neg 0&lt;/code&gt;&lt;/b&gt; &lt;b&gt;吗？&lt;/b&gt; 如果可以，那上面的定义就很有用了！&lt;/p&gt;&lt;p&gt;答案当然是：&lt;b&gt;确定！一定！以及肯定可以！&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;路径构造子&lt;/h2&gt;&lt;p&gt;回忆一下，路径它：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;被定义为一种函数，其定义域为间点，陪域为端点的类型&lt;/li&gt;&lt;li&gt;可以视作一种等价关系&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们可以为数据类型添加&lt;b&gt;路径构造子（Path Constructor）&lt;/b&gt;，比如添加 &lt;code&gt;pos 0 ≡ neg 0&lt;/code&gt;，它是一条映射到 &lt;code&gt;Int&lt;/code&gt; 的路径（并且如果这种路径有定义，那么它就是一个从间点到 &lt;code&gt;Int&lt;/code&gt; 的函数）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;zro : pos 0 ≡ neg 0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们用函数类型重写 &lt;code&gt;zro&lt;/code&gt; 的类型（&lt;code&gt;zro&lt;/code&gt; 本身就有一个路径类型），那么就得到了一个构造子式的类型（它的返回类型就是它所构造的类型）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;zroFn : I -&amp;gt; Int
zroFn i = zro i&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于 &lt;code&gt;zro&lt;/code&gt; 返回一个 &lt;code&gt;Int&lt;/code&gt; 和它的构造子，因此我们称之为&lt;b&gt;路径构造子（Path Constructor）&lt;/b&gt;。在介绍路径构造子的高级属性前，我们已经知道很多有趣的东西了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;posneg : pos 0 ≡ neg 0
posneg = zro

negpos : neg 0 ≡ pos 0
negpos i = zro (~ i)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;路径约束&lt;/h2&gt;&lt;p&gt;路径构造子的特殊之处在于，当带有路径构造子的数据类型出现在模式匹配从句的左侧时， 它们也&lt;b&gt;约束（Constraint）&lt;/b&gt;了你的模式匹配从句。以 &lt;code&gt;succ&lt;/code&gt; 函数为例， 在为 &lt;code&gt;Int&lt;/code&gt; 写出 &lt;code&gt;succ&lt;/code&gt; 函数时，我们需要对路径构造子进行模式匹配：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;succ : Int -&amp;gt; Int
succ (pos x) = pos (suc x)
succ (neg zero) = pos 1
succ (neg (suc x)) = neg x
-- 上面三个从句很平凡

succ (zro i) = -- 这种情况我们要返回什么？&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种情况的路径构造子的规则是，我们可以返回任何满足以下条件的东西（以 &lt;code&gt;Int&lt;/code&gt; 上的 &lt;code&gt;succ&lt;/code&gt; 为例）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;succ (zro i)&lt;/code&gt; 按照定义的等价性应被规约为：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;succ (pos 0)&lt;/code&gt;（&lt;code&gt;pos 0&lt;/code&gt; 来自 &lt;code&gt;zro i0&lt;/code&gt;），当 &lt;code&gt;i0&lt;/code&gt; 被代入 &lt;code&gt;i&lt;/code&gt; 时&lt;/li&gt;&lt;li&gt;&lt;code&gt;succ (neg 0)&lt;/code&gt;（&lt;code&gt;neg 0&lt;/code&gt; 来自 &lt;code&gt;zro i1&lt;/code&gt;），当 &lt;code&gt;i1&lt;/code&gt; 被代入 &lt;code&gt;i&lt;/code&gt; 时&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;我们将此性质简称为「路径的端点需要被遵守」&lt;/p&gt;&lt;p&gt;而由于 &lt;code&gt;succ (pos 0)&lt;/code&gt; 和 &lt;code&gt;succ (neg 0)&lt;/code&gt; 均等于 &lt;code&gt;pos 1&lt;/code&gt;，因此 &lt;code&gt;zro&lt;/code&gt; 情况的唯一可能就是 &lt;code&gt;pos 1&lt;/code&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;succ : Int -&amp;gt; Int
succ (pos x) = pos (suc x)
succ (neg zero) = pos 1
succ (neg (suc x)) = neg x
succ (zro i) = pos 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际上，Agda 的约束求解器可以求出此函数的一些从句。 我们可以将上面的函数写成带&lt;b&gt;洞（Hole）&lt;/b&gt;的形式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;succ′ : Int -&amp;gt; Int
succ′ (pos x) = pos (suc x)
succ′ (neg zero) = {!!}
succ′ (neg (suc x)) = neg x
succ′ (zro i) = {!!}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在你的 Agda 编辑器中加载本文中的代码并对它使用「Auto」。两个洞都可以被解决。&lt;/p&gt;&lt;p&gt;由于这里出现的路径构造子类型为 &lt;code&gt;pos 0 ≡ neg 0&lt;/code&gt;，因此 Agda 知道 &lt;code&gt;succ&amp;#39; (neg zero)&lt;/code&gt; 等于 &lt;code&gt;succ&amp;#39; (pos zero)&lt;/code&gt;，其中 &lt;code&gt;succ&amp;#39; (pos x)&lt;/code&gt; 定义为 &lt;code&gt;pos (suc x)&lt;/code&gt;， 对 &lt;code&gt;pos zero&lt;/code&gt; 应用此模式的结果为 &lt;code&gt;pos (suc zero)&lt;/code&gt;，它等于 &lt;code&gt;pos 1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;同样，我们可以定义 &lt;code&gt;pred&lt;/code&gt; 函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pred : Int -&amp;gt; Int
pred (pos zero) = neg 1
pred (pos (suc x)) = pos x
pred (neg x) = neg (suc x)
pred (zro i) = neg 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;同构&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;module IsoInt where
open Cubical.Data.Int renaming (Int to StdInt)
pattern spos n = StdInt.pos n
pattern nsuc n = StdInt.negsuc n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;给出标准整数的定义，我们可以证明 HIT（高阶归纳类型，Higher-Inductive Type 的缩写， 即带有路径构造子的归纳类型）的整数与它同构。要在类型论下证明同构，我们需要给出两个 （实际上只有我们知道的）互逆的函数，并证明它们的互逆关系（以此来说服 Agda 它们是互逆的）。&lt;/p&gt;&lt;p&gt;从 &lt;code&gt;StdInt&lt;/code&gt; 到 &lt;code&gt;Int&lt;/code&gt;，我们将 &lt;code&gt;pos&lt;/code&gt; 转换为 &lt;code&gt;pos&lt;/code&gt;，将 &lt;code&gt;negsuc&lt;/code&gt; 转换为 &lt;code&gt;neg ∘ suc&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;StdInt-&amp;gt;Int : StdInt -&amp;gt; Int
StdInt-&amp;gt;Int (spos n) = pos n
StdInt-&amp;gt;Int (nsuc n) = neg (suc n)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一方面，由于标准定义中缺少路径构造子，因此我们将 &lt;code&gt;zro i&lt;/code&gt; 映射为 &lt;code&gt;pos 0&lt;/code&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Int-&amp;gt;StdInt : Int -&amp;gt; StdInt
Int-&amp;gt;StdInt (pos x) = spos x
Int-&amp;gt;StdInt (neg zero) = spos 0
Int-&amp;gt;StdInt (neg (suc x)) = nsuc x
Int-&amp;gt;StdInt (zro i) = spos 0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们来试着证明两函数互逆。此同构的一面很平凡：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;StdInt-&amp;gt;Int-&amp;gt;StdInt : (n : StdInt) -&amp;gt; Int-&amp;gt;StdInt (StdInt-&amp;gt;Int n) ≡ n
StdInt-&amp;gt;Int-&amp;gt;StdInt (spos _) = refl
StdInt-&amp;gt;Int-&amp;gt;StdInt (nsuc _) = refl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它可以证明是因为我们的两个模式将 &lt;code&gt;Int-&amp;gt;StdInt (StdInt-&amp;gt;Int n)&lt;/code&gt; 代换成了 &lt;code&gt;Int-&amp;gt;StdInt (StdInt-&amp;gt;Int (spos n))&lt;/code&gt; 和 &lt;code&gt;Int-&amp;gt;StdInt (StdInt-&amp;gt;Int (nsuc n))&lt;/code&gt;， 它们可展开为 &lt;code&gt;spos n&lt;/code&gt; 和 &lt;code&gt;nsuc n&lt;/code&gt;，二者与返回类型中路径的右式一致。&lt;/p&gt;&lt;p&gt;此同构另一面的两种情况则要稍微难一些，我们来逐个讨论。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Int-&amp;gt;StdInt-&amp;gt;Int : (n : Int) -&amp;gt; StdInt-&amp;gt;Int (Int-&amp;gt;StdInt n) ≡ n
Int-&amp;gt;StdInt-&amp;gt;Int (pos x) = refl
Int-&amp;gt;StdInt-&amp;gt;Int (neg zero) =&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此从句是第一个非平凡的情况。如果我们将 &lt;code&gt;neg zero&lt;/code&gt; 代入 &lt;code&gt;Int-&amp;gt;StdInt n&lt;/code&gt;，就会得到 &lt;code&gt;spos 0&lt;/code&gt;，而将 &lt;code&gt;spos 0&lt;/code&gt; 代入 &lt;code&gt;StdInt-&amp;gt;Int n&lt;/code&gt; 则会得到 &lt;code&gt;pos 0&lt;/code&gt;。于是此从句的类型为 &lt;code&gt;pos 0 ≡ neg 0&lt;/code&gt;，它就是 &lt;code&gt;zro&lt;/code&gt; 的类型。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  zro&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着我们填上另一个平凡的情况。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Int-&amp;gt;StdInt-&amp;gt;Int (neg (suc x)) = refl
Int-&amp;gt;StdInt-&amp;gt;Int (zro i) = lemma
  where&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后一种情况也有点复杂，我们为了可读性引入了一条引理。 进行一些简单代换后我们可以得到以下签名：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  lemma : pos 0 ≡ zro i
  lemma j =&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它是上下文中一条带有一个间点变量的路径，它可以看做两个路径间一条的路径， 该路径的两边分别为 &lt;code&gt;pos 0&lt;/code&gt; 和 &lt;code&gt;zro i&lt;/code&gt;。如下图所示，如果把 &lt;code&gt;j = i0&lt;/code&gt; 看做 &lt;code&gt;x = y&lt;/code&gt; 的形式，那么 &lt;code&gt;x&lt;/code&gt; 是间点变量，&lt;code&gt;y&lt;/code&gt; 是 &lt;code&gt;i0&lt;/code&gt; 或 &lt;code&gt;i1&lt;/code&gt; 这样的端点。以 &lt;code&gt;x&lt;/code&gt; 索引的路径的 &lt;code&gt;y&lt;/code&gt; 端，即 &lt;code&gt;j = i0&lt;/code&gt;，也就是 &lt;code&gt;pos 0&lt;/code&gt; 的那条边（图的左边）是一个常量路径，而 &lt;code&gt;zro i&lt;/code&gt;，即 &lt;code&gt;j = i1&lt;/code&gt; 的那条边（图的右边） 有两个不同的边：&lt;code&gt;pos 0&lt;/code&gt;（&lt;code&gt;i = i0&lt;/code&gt; 的那条边，即底边）和 &lt;code&gt;neg 0&lt;/code&gt;（&lt;code&gt;i = i1&lt;/code&gt; 的那条边， 即顶边）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b88ebb8d46a6245b439130a515a55f8e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;427&quot; data-rawheight=&quot;445&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;427&quot; data-original=&quot;https://pic3.zhimg.com/v2-b88ebb8d46a6245b439130a515a55f8e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b88ebb8d46a6245b439130a515a55f8e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;427&quot; data-rawheight=&quot;445&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;427&quot; data-original=&quot;https://pic3.zhimg.com/v2-b88ebb8d46a6245b439130a515a55f8e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b88ebb8d46a6245b439130a515a55f8e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;它刚好就是上一篇文章中引入的 &lt;code&gt;minSq&lt;/code&gt;（将 &lt;code&gt;pos 0&lt;/code&gt; 代入 &lt;code&gt;a&lt;/code&gt;，将 &lt;code&gt;neg 0&lt;/code&gt; 代入 &lt;code&gt;b&lt;/code&gt;）！ 回想 &lt;code&gt;minSq&lt;/code&gt; 是以 &lt;code&gt;min&lt;/code&gt; 运算符定义的，我们这里也可以应用同样的技术：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    zro (i ∧ j)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;搞定！&lt;/p&gt;&lt;h2&gt;同构与路径&lt;/h2&gt;&lt;p&gt;立方类型论可以带给你的一点好处是你可以在同构的类型之间创建一条路径。 其背后的理论超出了本文讨论的范围，但我们可以试一下基于该理论的库函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-agda&quot;&gt;Int≡StdInt : Int ≡ StdInt
Int≡StdInt = isoToPath (iso Int-&amp;gt;StdInt StdInt-&amp;gt;Int StdInt-&amp;gt;Int-&amp;gt;StdInt Int-&amp;gt;StdInt-&amp;gt;Int)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;一个问题&lt;/h2&gt;&lt;p&gt;还有一种定义为 HIT 的整数类型：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;infixl 5 _⊝_
data DeltaInt : Set where
  _⊝_    : Nat -&amp;gt; Nat -&amp;gt; DeltaInt
  cancel : ∀ a b -&amp;gt; a ⊝ b ≡ suc a ⊝ suc b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它是以一个自然数减去另一个来定义的。这是一种全新的 HIT， 因此我建议读者为它定义一些常见的运算并证明它们的性质以熟悉这个 HIT。&lt;/p&gt;&lt;p&gt;我们可以找出一条它的引理：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;cancelDiamond : ∀ a b i → cancel a b i ≡ cancel (suc a) (suc b) i
cancelDiamond a b = {!!}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于 &lt;code&gt;a ⊝ b&lt;/code&gt; 等于 &lt;code&gt;suc a ⊝ suc b&lt;/code&gt;，因此我们可以在一个间点上泛化这种相等关系（它正是 &lt;code&gt;cancelDiamond&lt;/code&gt;）。但我们要如何证明它？试着画出 &lt;code&gt;cancelDiamond&lt;/code&gt;，我们会看到一个方形，但它既不是 min 方形也不是 max 方形。&lt;/p&gt;&lt;p&gt;答案将在下一篇文章中使用新的 CuTT 运算来揭晓。&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2020-02-09-104929162</guid>
<pubDate>Sun, 09 Feb 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>凉爽的 CuTT 介绍（1）：方形与对角线</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2020-02-09-103565709.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/103565709&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;文本译自 &lt;a href=&quot;https://www.zhihu.com/people/67ebe1bd8e4a63f17a42572e40afaac7&quot; class=&quot;internal&quot;&gt;@千里冰封 你懂吗&lt;/a&gt; 介绍&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ice1000.org/2019/08-20-Cutt1.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;立方类型论&lt;/a&gt;的文章。&lt;/blockquote&gt;&lt;p&gt;（注意：本章尽量简短了些）&lt;/p&gt;&lt;p&gt;回忆&lt;a href=&quot;https://zhuanlan.zhihu.com/p/102323224&quot; class=&quot;internal&quot;&gt;上一章&lt;/a&gt;的内容，我们有了 &lt;code&gt;max&lt;/code&gt;、&lt;code&gt;min&lt;/code&gt;和&lt;code&gt;neg&lt;/code&gt;，且构造出了对称（symmetry）的路径。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;{-# OPTIONS --cubical --allow-unsolved-metas #-}
module 2019-8-20-Cutt1 where
open import Cubical.Core.Everything

variable A : Set&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;路径的路径&lt;/h2&gt;&lt;p&gt;现在我们用路径（Path）做些有趣的事情。我们从常量路径（Constant Path）开始：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;reflEx : (a : A) → a ≡ a
reflEx a = λ i → a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们在 &lt;code&gt;reflEx a&lt;/code&gt; 之间构造一个路径：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;reflReflEx : (a : A) → reflEx a ≡ reflEx a
reflReflEx a = λ j i → a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以直观地把 &lt;code&gt;reflReflEx a&lt;/code&gt; 画成一条路径，其端点同样也是路径：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d988f350e5423558d5e0bb916893a7c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;538&quot; data-rawheight=&quot;201&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;538&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d988f350e5423558d5e0bb916893a7c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d988f350e5423558d5e0bb916893a7c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;538&quot; data-rawheight=&quot;201&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;538&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d988f350e5423558d5e0bb916893a7c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9d988f350e5423558d5e0bb916893a7c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以把上图重绘成平面的形式：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-35d84bc1769629fb64bddea3401e4e42_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;430&quot; data-rawheight=&quot;452&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;430&quot; data-original=&quot;https://pic3.zhimg.com/v2-35d84bc1769629fb64bddea3401e4e42_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-35d84bc1769629fb64bddea3401e4e42_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;430&quot; data-rawheight=&quot;452&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;430&quot; data-original=&quot;https://pic3.zhimg.com/v2-35d84bc1769629fb64bddea3401e4e42_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-35d84bc1769629fb64bddea3401e4e42_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;看起来就是个方形（Square）！&lt;/p&gt;&lt;h2&gt;方形&lt;/h2&gt;&lt;p&gt;为了彻底理解方形，我们需要深入研究刚才所做的事情。&lt;/p&gt;&lt;p&gt;路径是接受&lt;b&gt;一个&lt;/b&gt;间点作为参数的 λ-表达式。而方形只不过是接受&lt;b&gt;两个&lt;/b&gt;间点的 λ-表达式。&lt;/p&gt;&lt;p&gt;我们的方形 &lt;code&gt;reflReflEx a = λ j i → a&lt;/code&gt; 之所以能够通过类型检查，是因为它就是个常量方形。 类型检查器可以向 &lt;code&gt;reflReflEx a&lt;/code&gt; 传入任意间点作为参数，而它们都会返回 &lt;code&gt;a&lt;/code&gt;， 正如我们写在类型中写的那样。假设 &lt;code&gt;p = reflReflEx a&lt;/code&gt;，我们可以列出一些编译器可以执行的检查：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;p i0 i0&lt;/code&gt; 是否可转换为 &lt;code&gt;reflEx a i0&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;（这里的 &lt;code&gt;reflEx a&lt;/code&gt; 是类型 &lt;code&gt;reflEx a ≡ reflEx a&lt;/code&gt; 的&lt;b&gt;左式&lt;/b&gt;）&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;code&gt;p i1 i0&lt;/code&gt; 是否可转换为 &lt;code&gt;reflEx a i0&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;（这里的 &lt;code&gt;reflEx a&lt;/code&gt; 是类型 &lt;code&gt;reflEx a ≡ reflEx a&lt;/code&gt; 的&lt;b&gt;右式&lt;/b&gt;）&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;code&gt;p i0 i1&lt;/code&gt; 是否可转换为 &lt;code&gt;reflEx a i1&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;（这里的 &lt;code&gt;reflEx a&lt;/code&gt; 是类型 &lt;code&gt;reflEx a ≡ reflEx a&lt;/code&gt; 的&lt;b&gt;左式&lt;/b&gt;）&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;code&gt;p i1 i1&lt;/code&gt; 是否可转换为 &lt;code&gt;reflEx a i1&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;（这里的 &lt;code&gt;reflEx a&lt;/code&gt; 是类型 &lt;code&gt;reflEx a ≡ reflEx a&lt;/code&gt; 的&lt;b&gt;右式&lt;/b&gt;）&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;code&gt;p i0 j&lt;/code&gt; 是否可转换为 &lt;code&gt;reflEx a j&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;（这里的 &lt;code&gt;reflEx a&lt;/code&gt; 是类型 &lt;code&gt;reflEx a ≡ reflEx a&lt;/code&gt; 的&lt;b&gt;左式&lt;/b&gt;）&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;code&gt;p i1 j&lt;/code&gt; 是否可转换为 &lt;code&gt;reflEx a j&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;（这里的 &lt;code&gt;reflEx a&lt;/code&gt; 是类型 &lt;code&gt;reflEx a ≡ reflEx a&lt;/code&gt; 的&lt;b&gt;右式&lt;/b&gt;）&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;如果我们想要一条两个未知路径之间的路径，事情就会变得有些复杂：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pathPath : (a : A) → (p q : a ≡ a) → p ≡ q
pathPath a p q = λ j i → {!a!}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们无法在目标中填入 &lt;code&gt;a&lt;/code&gt;， 因为即便 &lt;code&gt;p i0&lt;/code&gt; 和 &lt;code&gt;p i1&lt;/code&gt; 明显可以转换为 &lt;code&gt;a&lt;/code&gt;（而 &lt;code&gt;a&lt;/code&gt; 就是我们想要在路径-λ 中返回的东西），我们也不能说对于所有的 &lt;code&gt;i : I&lt;/code&gt;，&lt;code&gt;p i&lt;/code&gt; 都能转换为 &lt;code&gt;a&lt;/code&gt; – 我们不知道两个已知端点 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; &lt;b&gt;之间&lt;/b&gt;的东西是什么。我们无法对于所有的间点参数都简单地返回 &lt;code&gt;a&lt;/code&gt;，因为它并不涉及 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; 的间点。此时我们也可以说 &lt;code&gt;p ≡ q&lt;/code&gt; &lt;b&gt;并不是&lt;/b&gt;一个常量方形。&lt;/p&gt;&lt;p&gt;我们可以对常量方形执行 &lt;code&gt;λ j i → a&lt;/code&gt; 是因为 &lt;code&gt;reflEx a&lt;/code&gt; 的间点已知为 &lt;code&gt;λ i → a&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;方形的性质&lt;/h2&gt;&lt;p&gt;我们首先假设有一个方形，其四个端点为 &lt;code&gt;a b c d : A&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;module UseOfSquares
  (a b c d : A)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着我们需要两条路径 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt;，一条从 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;b&lt;/code&gt;，另一条从 &lt;code&gt;c&lt;/code&gt; 到 &lt;code&gt;d&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  (p : a ≡ b)
  (q : c ≡ d)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，如果我们想要一条从 &lt;code&gt;p&lt;/code&gt; 到 &lt;code&gt;q&lt;/code&gt; 的路径，就不能简单地写成 &lt;code&gt;something : p ≡ q&lt;/code&gt;， 因为 &lt;code&gt;≡&lt;/code&gt; 的定义需要两个端点的类型相同，而 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; 的类型不同。 该方形的另一个名字叫做 &lt;b&gt;异质相等性（Heterogeneous Equality）&lt;/b&gt;。 幸运的是，路径类型的设计考虑到了这种情况：有一种类型叫 &lt;code&gt;PathP&lt;/code&gt;，它首先接受一条类型 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 之间的路径（于是你要证明 &lt;code&gt;A&lt;/code&gt; 等于 &lt;code&gt;B&lt;/code&gt;），然后接受 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的实例各一个。&lt;/p&gt;&lt;p&gt;所以，为了绕过这个定型的问题，我们在 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 之间建立两条不同的路径 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  (p : a ≡ b)
  (q : a ≡ b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后我们就有了这个方形：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  (s : p ≡ q)
  where&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它的图形如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f1693cef33717831d951ddd4237a6087_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;438&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;450&quot; data-original=&quot;https://pic4.zhimg.com/v2-f1693cef33717831d951ddd4237a6087_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f1693cef33717831d951ddd4237a6087_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;438&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;450&quot; data-original=&quot;https://pic4.zhimg.com/v2-f1693cef33717831d951ddd4237a6087_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f1693cef33717831d951ddd4237a6087_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;现在我们来做些有趣的事情。首先，此方形的左侧边和右侧边就是方形的端点， 毕竟方形就是路径的路径：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-agda&quot;&gt;  left : a ≡ b
  left = s i0

  right : a ≡ b
  right = s i1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过顶边和底边是什么？好吧，这次我就不卖关子了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  top : a ≡ a
  top = λ i → s i i0

  bottom : b ≡ b
  bottom = λ i → s i i1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而反柯里化（uncurrying）后的 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 能让 &lt;code&gt;top&lt;/code&gt; 和 &lt;code&gt;bottom&lt;/code&gt; 更加清晰：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  left′ : a ≡ b
  left′ = λ i → s i0 i

  right′ : a ≡ b
  right′ = λ i → s i1 i&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（请图形化地想象上面的四个函数，你应该可以想象出这种简单的图像）&lt;/p&gt;&lt;p&gt;我们也可以将 &lt;code&gt;s&lt;/code&gt; 旋转 180 度，即将它上下翻转后左右翻转（&lt;code&gt;sym&lt;/code&gt; 即对称翻转， 你可以点击&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ice1000.org/lagda/Cubical.Foundations.Prelude.html%23893&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;查看它的定义）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;open import Cubical.Foundations.Prelude

rotate : (sym q) ≡ (sym p)
rotate = λ i j → s (~ i) (~ j)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它的图像如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fe1cbe308b2eabfd721cf63a4bad8d72_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;457&quot; data-rawheight=&quot;444&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;457&quot; data-original=&quot;https://pic3.zhimg.com/v2-fe1cbe308b2eabfd721cf63a4bad8d72_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fe1cbe308b2eabfd721cf63a4bad8d72_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;457&quot; data-rawheight=&quot;444&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;457&quot; data-original=&quot;https://pic3.zhimg.com/v2-fe1cbe308b2eabfd721cf63a4bad8d72_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-fe1cbe308b2eabfd721cf63a4bad8d72_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;对角线&lt;/h2&gt;&lt;p&gt;我们也可以找出 &lt;code&gt;s&lt;/code&gt; 的对角线（Diagonal）。 考虑一条从左下角到右上角的线，这条对角线也是一条路径，它的端点 &lt;code&gt;i0&lt;/code&gt; 是 &lt;code&gt;s&lt;/code&gt; 的左下角，而端点 &lt;code&gt;i1&lt;/code&gt; 是 &lt;code&gt;s&lt;/code&gt; 的右上角：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;diagonal : a ≡ b
diagonal = λ i → s i i&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它的图象是：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bb883ce5d0ccf92e027e50d741ad86f2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;454&quot; data-rawheight=&quot;429&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;454&quot; data-original=&quot;https://pic3.zhimg.com/v2-bb883ce5d0ccf92e027e50d741ad86f2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bb883ce5d0ccf92e027e50d741ad86f2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;454&quot; data-rawheight=&quot;429&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;454&quot; data-original=&quot;https://pic3.zhimg.com/v2-bb883ce5d0ccf92e027e50d741ad86f2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bb883ce5d0ccf92e027e50d741ad86f2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我觉得它很好理解了。&lt;/p&gt;&lt;h2&gt;方形的构造&lt;/h2&gt;&lt;p&gt;玩过一会儿现有的方形后，我们来构造一些新的！这此我们同样假设 &lt;code&gt;p : a ≡ b&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;module ConstructionOfSquares
  (a b : A)
  (p : a ≡ b)
  where&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最简单的方形就是 &lt;code&gt;p&lt;/code&gt; 的常量路径：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  easist : p ≡ p
  easist = reflEx _&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然我们还可以做更多：我们可以把 &lt;code&gt;p&lt;/code&gt; 看作一个未知方形的对角线：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ea87254323599b00d08625b9f4e589b4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;432&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;450&quot; data-original=&quot;https://pic1.zhimg.com/v2-ea87254323599b00d08625b9f4e589b4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ea87254323599b00d08625b9f4e589b4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;432&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;450&quot; data-original=&quot;https://pic1.zhimg.com/v2-ea87254323599b00d08625b9f4e589b4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ea87254323599b00d08625b9f4e589b4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;还有两个端点是未知的。&lt;/p&gt;&lt;p&gt;很容易想到几种构造方形的方式：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 在左上角，&lt;code&gt;b&lt;/code&gt; 在右下角（一个常量路径的路径）&lt;/li&gt;&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 在左上角，&lt;code&gt;a&lt;/code&gt; 在右下角（一个常量路径）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不过，我们还可以让它们都是 &lt;code&gt;a&lt;/code&gt;，或者都是 &lt;code&gt;b&lt;/code&gt;！ 关键在于使用 &lt;code&gt;∧&lt;/code&gt; (min) 和 &lt;code&gt;∨&lt;/code&gt; (max) 运算符。&lt;/p&gt;&lt;p&gt;当二者均为 &lt;code&gt;a&lt;/code&gt; 时，该方形的表达式为 &lt;code&gt;λ i j → p (i ∧ j)&lt;/code&gt; （此方形后面称之为 &lt;code&gt;&lt;b&gt;minSq&lt;/b&gt;&lt;/code&gt;）。然而我们目前还无法确定此方形的类型， 不过我们可以画出它的图像（我们还会在下一章使用此结构）！&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-91e1321169b4a1e185a052a3783811ba_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;454&quot; data-rawheight=&quot;449&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;454&quot; data-original=&quot;https://pic3.zhimg.com/v2-91e1321169b4a1e185a052a3783811ba_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-91e1321169b4a1e185a052a3783811ba_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;454&quot; data-rawheight=&quot;449&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;454&quot; data-original=&quot;https://pic3.zhimg.com/v2-91e1321169b4a1e185a052a3783811ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-91e1321169b4a1e185a052a3783811ba_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我在方形中挑选了两个点 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 来解释为什么此图像表示 &lt;code&gt;p (i ∧ j)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;方形中的每个点都可以看作该方形应用到两个间点后的值，其中一个间点可以看作横坐标， 而另一则是纵坐标。例如，我们可以将 &lt;code&gt;minSq i j&lt;/code&gt; 看作下图中对应的点：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-416087b28a1016e27155a587ffa90007_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;430&quot; data-rawheight=&quot;436&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;430&quot; data-original=&quot;https://pic4.zhimg.com/v2-416087b28a1016e27155a587ffa90007_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-416087b28a1016e27155a587ffa90007_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;430&quot; data-rawheight=&quot;436&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;430&quot; data-original=&quot;https://pic4.zhimg.com/v2-416087b28a1016e27155a587ffa90007_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-416087b28a1016e27155a587ffa90007_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从这个视角来看，&lt;code&gt;x&lt;/code&gt; 在对角线的上方，我们可以说 &lt;code&gt;x&lt;/code&gt; 的纵坐标&lt;b&gt;大于&lt;/b&gt;横坐标。&lt;code&gt;y&lt;/code&gt; 在对角线的下方，因此它与 &lt;code&gt;x&lt;/code&gt; 相反。&lt;/p&gt;&lt;p&gt;如果我们说 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;minSq i j&lt;/code&gt;（它求值为 &lt;code&gt;p (i ∧ j)&lt;/code&gt;），并且我们已知 &lt;code&gt;j &amp;gt; i&lt;/code&gt;，那么我们可以将 &lt;code&gt;i ∧ j&lt;/code&gt; 化简为 &lt;code&gt;i&lt;/code&gt;，于是 &lt;code&gt;x&lt;/code&gt; 就成为了 &lt;code&gt;p i&lt;/code&gt;。&lt;code&gt;y&lt;/code&gt; 则会变成 &lt;code&gt;p j&lt;/code&gt;。 而左上角就是 &lt;code&gt;minSq i0 i1&lt;/code&gt;，它可规约为 &lt;code&gt;p (i0 ∧ i1)&lt;/code&gt;，接着规约为 &lt;code&gt;p i0&lt;/code&gt;，然后规约为 &lt;code&gt;a&lt;/code&gt;。 右下角则是 &lt;code&gt;minSq i1 i0&lt;/code&gt;，它会归约为 &lt;code&gt;a&lt;/code&gt;。 &lt;/p&gt;&lt;p&gt;我们可以将这种映射画成下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f2942ddcbec5ef0490448944e3b05ff1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;467&quot; data-rawheight=&quot;461&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;467&quot; data-original=&quot;https://pic2.zhimg.com/v2-f2942ddcbec5ef0490448944e3b05ff1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f2942ddcbec5ef0490448944e3b05ff1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;467&quot; data-rawheight=&quot;461&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;467&quot; data-original=&quot;https://pic2.zhimg.com/v2-f2942ddcbec5ef0490448944e3b05ff1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f2942ddcbec5ef0490448944e3b05ff1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;练习&lt;/h3&gt;&lt;p&gt;请模仿我的解释过程来解释 &lt;code&gt;λ i j → p (i ∨ j)&lt;/code&gt; 并画出它的图像。我想你可以在脑子里想出来！&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2020-02-09-103565709</guid>
<pubDate>Sun, 09 Feb 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>凉爽的 CuTT 介绍（0）：路径与间点</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2020-02-09-102323224.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/102323224&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;文本译自 &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/67ebe1bd8e4a63f17a42572e40afaac7&quot; data-hash=&quot;67ebe1bd8e4a63f17a42572e40afaac7&quot; data-hovercard=&quot;p$b$67ebe1bd8e4a63f17a42572e40afaac7&quot;&gt;@千里冰封 你懂吗&lt;/a&gt; 介绍&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ice1000.org/2019/08-01-Cutt0.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;立方类型论&lt;/a&gt;的文章。&lt;/blockquote&gt;&lt;h2&gt;动机&lt;/h2&gt;&lt;p&gt;我打算写一系列介绍立方类型论（Cubical Type Theory，简称 CuTT）的文章， 文中会使用 Agda 证明助理。我的动机是现有的立方类型论（以及 Cubical Agda） 的教程都不可避免地需要同伦类型论（Homotopy Type Theory，简称 HoTT）方面的知识。 然而，我始终认为没有 HoTT 的背景也是可以学习 CuTT 的，只是需要一个理解 Cubical 的引路者把教程写出来而已。&lt;/p&gt;&lt;blockquote&gt;注：Cubical 是指 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ncatlab.org/nlab/show/model%2Bstructure%2Bon%2Bcubical%2Bsets&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;立方集合模型（Cubical sets model）&lt;/a&gt;, CuTT 即是建立在该集合模型上的类型论。与此对应的还有 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ncatlab.org/nlab/show/model%2Bstructure%2Bon%2Bsimplicial%2Bsets&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;单纯形集合模型（Simplical sets model）&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;我参加了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//hott.github.io/HoTT-2019/summer-school/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HoTT 2019&lt;/a&gt; 的暑期班，在 Anders Mörtberg 关于 Cubical 模型的演讲中 解决了很多疑惑。我觉得现在是时候成为 Cubical 的传道者，编写一份真正易读的 立方类型论介绍了。&lt;/p&gt;&lt;p&gt;这个介绍一点也不「热（HoTT）」，所以我称之为「凉爽（Cold）」的 CuTT 介绍。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;非 Cubical 的 Agda（即原版 Agda）的经验&lt;/li&gt;&lt;ul&gt;&lt;li&gt;（私货：可参阅《&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//agda-zh.github.io/PLFA-zh/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;编程语言基础：Agda 语言描述&lt;/a&gt;》）&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;λ-演算的基本概念，如柯里化（Currying）等&lt;/li&gt;&lt;li&gt;小学几何（线段、正方形、立方体）&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-agda&quot;&gt;{-# OPTIONS --cubical --omega-in-omega #-}
module 2019-8-1-Cutt0 where
open import Cubical.Core.Everything&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;走起！&lt;/h2&gt;&lt;p&gt;我们先从一个问题入手：&lt;b&gt;如何用编程语言表示证明？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在 Agda 的根基，Martin-Löf 类型论（MLTT）中，相等性关系使用名为 &lt;code&gt;_≡_&lt;/code&gt; 的类型来表示， 它只有一个&lt;b&gt;居留元（Inhabitant）&lt;/b&gt;&lt;code&gt;refl&lt;/code&gt;，被定义为&lt;b&gt;自反性（Reflexivity）&lt;/b&gt;的证明，我们可通过此元素来参数化并索引该类型。而 CuTT 则引入了另一种相等性类型，它比起 MLTT 来说更适合 HoTT。由于这是一个「凉爽」的介绍，所以我们不会在这里解释 「为什么要用 CuTT」。&lt;/p&gt;&lt;blockquote&gt;译注：类型索引（Indexed）和参数化（Parameterized）参见&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//wiki.haskell.org/GHC/Type_families&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;类型族（Type Families）&lt;/a&gt;&lt;/blockquote&gt;&lt;h2&gt;间点&lt;/h2&gt;&lt;p&gt;有种类型在论文中叫做&lt;b&gt;间点（Interval）&lt;/b&gt;，在 Agda 中则被称为 &lt;code&gt;I&lt;/code&gt;。 你可以点击&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ice1000.org/lagda/Agda.Primitive.Cubical.html%2386&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;此处&lt;/a&gt;或原文代码中的 &lt;code&gt;I&lt;/code&gt; 查看它的定义。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;--         ↓
interval = I
--         ↑&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;类型 &lt;code&gt;I&lt;/code&gt; 的最佳解释是，一条&lt;b&gt;路径（Path）&lt;/b&gt;上的点（Point）所属的类型。 想象一下 &lt;code&gt;i : I&lt;/code&gt;，我们可以画图将 &lt;code&gt;i&lt;/code&gt; 表示出来：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a9bed0e1cacb96422c64b32b16b016ff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;458&quot; data-rawheight=&quot;87&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;458&quot; data-original=&quot;https://pic4.zhimg.com/v2-a9bed0e1cacb96422c64b32b16b016ff_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a9bed0e1cacb96422c64b32b16b016ff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;458&quot; data-rawheight=&quot;87&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;458&quot; data-original=&quot;https://pic4.zhimg.com/v2-a9bed0e1cacb96422c64b32b16b016ff_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a9bed0e1cacb96422c64b32b16b016ff_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从几何上来说，我们有一条从 0 到 1 的路径，路径上的每点都是 &lt;code&gt;I&lt;/code&gt; 的一个实例。 当然，0 和 1 也是 &lt;code&gt;I&lt;/code&gt; 的有效实例。间点的性质如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;间点上可以使用量词——例如，&lt;code&gt;∀ (i : I), blabla&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;它们总是大于或等于 0，小于或等于 1。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 Agda 中，我们用 &lt;code&gt;i0&lt;/code&gt; 来表示 0，用 &lt;code&gt;i1&lt;/code&gt; 来表示 1：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;_ : I
_ = i0

_ : I
_ = i1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;间点上没什么原语操作，至少无法对它们下&lt;b&gt;断言（Predicate）&lt;/b&gt;，例如 &lt;code&gt;λ i → if i == 0 then bla else rua&lt;/code&gt; 是不行的（不过我们可以在其它结构上对间点下断言）。不过我们还是有几个基本操作的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;min&lt;/code&gt; 接受两个间点，返回更接近 0 的那个&lt;/li&gt;&lt;li&gt;&lt;code&gt;max&lt;/code&gt; 接受两个间点，返回更接近 1 的那个&lt;/li&gt;&lt;li&gt;&lt;code&gt;neg&lt;/code&gt; 接受一个间点，返回与它对称的点&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 Agda 中，它们用让人有点慌的数学符号来表记：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;min : I → I → I
min = _∧_

max : I → I → I
max = _∨_

neg : I → I
neg = ~_&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它们遵循&lt;b&gt;德摩根定律（De Morgan&amp;#39;s theorem）&lt;/b&gt;，就是说了&lt;code&gt;~ (i ∧ j)&lt;/code&gt;等价于&lt;code&gt;~ i ∨ ~ j&lt;/code&gt; 的那个。端点的行为相当于：&lt;code&gt;i ∧ 0&lt;/code&gt; 等于 &lt;code&gt;0&lt;/code&gt;，&lt;code&gt;i ∨ 0&lt;/code&gt; 等于 &lt;code&gt;i&lt;/code&gt;，诸如此类。 然而，间点并非布尔值，它们是路径上的点，路径上存在无穷多的点， 而布尔值只有两个。&lt;/p&gt;&lt;blockquote&gt;译注：在 C-H 同构中，类型即命题，而该类型若存在&lt;b&gt;居留元（Inhabitant）&lt;/b&gt;，也就意味着其对应的命题得证。在 MLTT 中，由于包含 K 公理，因此&lt;b&gt;相等性（Equality）&lt;/b&gt;类型只有一个居留元 &lt;code&gt;refl&lt;/code&gt;，于是 MLTT 直接放弃了讨论相等性证明本身的内容。然而 HoTT 认为，相等性证明可以被视为 Path，而 Path 和 Path 可以是不同的，于是我们就有了这样一种类型来建立起新的相等性关系：它拥有无穷多的证明， 而每一个证明都是这个相等性关系的居留元。在 CuTT 中，这样的相等性关系叫做&lt;b&gt;路径（Path）&lt;/b&gt;，而其上的居留元就是&lt;b&gt;间点（Interval）&lt;/b&gt;。&lt;/blockquote&gt;&lt;p&gt;我们可以构造一些有趣的东西：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;andNot : I → I → I
andNot i j = ~ (i ∧ j)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它等价于：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;andNot&amp;#39; : I → I → I
andNot&amp;#39; i j = ~ i ∨ ~ j&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们已经对间点有了直观的理解。很好！&lt;/p&gt;&lt;h2&gt;路径类型&lt;/h2&gt;&lt;p&gt;之所以有这样一个奇怪的类型 &lt;code&gt;I&lt;/code&gt; 的原因是我们需要引入&lt;b&gt;路径（Path）&lt;/b&gt;类型。 从几何上来说，每一条路径都由两个值来定义，即它的两个端点。&lt;/p&gt;&lt;p&gt;想象一个类型 &lt;code&gt;A&lt;/code&gt; 和它的两个居留元 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;myImagination
  : (A : Set)
  → (a b : A)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在类型 &lt;code&gt;A&lt;/code&gt; 上的 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 之间，我们可以有一个&lt;b&gt;路径类型&lt;/b&gt;（我把它的参数柯里化了）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  → Set
  myImagination = Path&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 之间&lt;b&gt;路径&lt;/b&gt;的类型写作 &lt;code&gt;Path A a b&lt;/code&gt;，其中 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的类型。 路径的居留元是接受间点作为参数的 λ-表达式。我们称之为&lt;b&gt;路径-λ（Path lambda）&lt;/b&gt;。 通常的函数也可以接受间点作为参数，然而 路径-λ 相对于普通的 λ-表达式 来说有更加特殊的构造。&lt;/p&gt;&lt;h2&gt;自反性&lt;/h2&gt;&lt;p&gt;例如，我们可以有&lt;b&gt;常量路径-λ（Constant Path Lambda）&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-agda&quot;&gt;-- 希望在你的设备上能正常显示

constantPathLam : (A : Set) → (a : A) → Path A a a
constantPathLam    A           a        i = a
--                 ↑           ↑        ↑
--               类型          |       间点
--                       两个端点都是 `a`&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当 Agda 针对类型 &lt;code&gt;Path A a b&lt;/code&gt; 检查你的路径-λ &lt;code&gt;p&lt;/code&gt;（也就是定型判断 &lt;code&gt;Gamma |- p : Path A a b&lt;/code&gt;）时，它会检查 &lt;code&gt;p i0&lt;/code&gt; 的返回值在定义上是否等于 &lt;code&gt;a&lt;/code&gt;， 以及 &lt;code&gt;p i1&lt;/code&gt; 的返回值在定义上是否等于 &lt;code&gt;b&lt;/code&gt;。（这里的 &lt;code&gt;p&lt;/code&gt; 是接受一个间点作为参数的 λ，我们可以把它应用到一个实参上！） 由于 &lt;code&gt;λ i → a&lt;/code&gt; 是 &lt;code&gt;Path A a a&lt;/code&gt; 的一个有效实例，因此 &lt;code&gt;(λ i → a) i0&lt;/code&gt; 本质上就是 &lt;code&gt;a&lt;/code&gt;（同理 &lt;code&gt;(λ i → a) i1&lt;/code&gt; 也是）。&lt;/p&gt;&lt;p&gt;我们可以把 &lt;code&gt;constantPathLam&lt;/code&gt; 路径画成这样：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ea492113221cbc4ab8d93bb13d7f892c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;431&quot; data-rawheight=&quot;68&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;431&quot; data-original=&quot;https://pic1.zhimg.com/v2-ea492113221cbc4ab8d93bb13d7f892c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ea492113221cbc4ab8d93bb13d7f892c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;431&quot; data-rawheight=&quot;68&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;431&quot; data-original=&quot;https://pic1.zhimg.com/v2-ea492113221cbc4ab8d93bb13d7f892c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ea492113221cbc4ab8d93bb13d7f892c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们将 &lt;code&gt;a ≡ b&lt;/code&gt; 作为 &lt;code&gt;Path _ a b&lt;/code&gt; 的简写，因为&lt;b&gt;路径类型就是 CuTT 版的相等性类型&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;使用 &lt;code&gt;≡&lt;/code&gt; 重写以上定义：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;constantPathLam′ : (A : Set) → (a : A) → a ≡ a
constantPathLam′ A a i = a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 &lt;code&gt;constantPathLam′&lt;/code&gt; 就是立方类型论中对自反性的证明。 它已经在 Cubical Agda 的库中了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import Cubical.Foundations.Prelude as Prelude
_ : {A : Set} {a : A} → a ≡ a
_ = Prelude.refl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以把路径当作一个大小无限的只读数组，其索引就是间点，它由数组元素的 getter 来定义。&lt;/p&gt;&lt;h2&gt;对称性&lt;/h2&gt;&lt;p&gt;正如我们可以找到间点的对称点一样，我们也可以反转一条路径 （代码中的参数重新对齐了，以便与类型签名一致）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;invert : (A : Set) (a b : A) (p : a ≡ b) → b ≡ a
invert    A         a b       p = λ i → p (~ i)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为解释此函数，想象一条类型为 &lt;code&gt;a ≡ b&lt;/code&gt; 的路径 &lt;code&gt;p&lt;/code&gt;。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb21a23a83557bb96cfe3055e339aba7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;440&quot; data-rawheight=&quot;101&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;440&quot; data-original=&quot;https://pic4.zhimg.com/v2-eb21a23a83557bb96cfe3055e339aba7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb21a23a83557bb96cfe3055e339aba7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;440&quot; data-rawheight=&quot;101&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;440&quot; data-original=&quot;https://pic4.zhimg.com/v2-eb21a23a83557bb96cfe3055e339aba7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-eb21a23a83557bb96cfe3055e339aba7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们构造了一个新的路径-λ，它将每一个间点都映射到「&lt;code&gt;p&lt;/code&gt; 上对称的间点」上， 因此它的类型就是「与 &lt;code&gt;a ≡ b&lt;/code&gt; 对称的路径」也就是 &lt;code&gt;b ≡ a&lt;/code&gt;。下面是它的图解， 其中一条从 &lt;code&gt;i&lt;/code&gt; 到 &lt;code&gt;~ i&lt;/code&gt; 的映射被显式地画了出来（你需要自己脑补上方路径上所有的间点， 例如 &lt;code&gt;i&lt;/code&gt;，都被映射到了下方路径对应的点上，例如 &lt;code&gt;~ i&lt;/code&gt;）：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-19ac6bc5c36a72d3bec130a98f553f11_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;483&quot; data-rawheight=&quot;423&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;483&quot; data-original=&quot;https://pic2.zhimg.com/v2-19ac6bc5c36a72d3bec130a98f553f11_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-19ac6bc5c36a72d3bec130a98f553f11_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;483&quot; data-rawheight=&quot;423&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;483&quot; data-original=&quot;https://pic2.zhimg.com/v2-19ac6bc5c36a72d3bec130a98f553f11_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-19ac6bc5c36a72d3bec130a98f553f11_b.jpg&quot;/&gt;&lt;figcaption&gt;在此图中，从路径 p 上的间点 i 开始指向某个 a 的箭头表示 「与 i 对应的值（或者说点）为 a 」或「p i 的求值结果为 a」&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们刚才做了什么？我们创建了一个新的路径-λ，它返回某种由一个给定路径和 它接受的间点构成的复合表达式。利用类似的技术和一点函数式编程，我们可以再玩两个魔法。&lt;/p&gt;&lt;h2&gt;合同性&lt;/h2&gt;&lt;p&gt;首先，我们可以在 MLTT 中证明&lt;b&gt;合同性（Congruence）&lt;/b&gt;。我们创建一个函数，&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;congruence
  : {A B : Set}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它接受一个从 &lt;code&gt;A&lt;/code&gt; 到 &lt;code&gt;B&lt;/code&gt; 的函数，&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;→ (f : A → B)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和一条 &lt;code&gt;A&lt;/code&gt; 上两个居留元之间的路径，&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;→ {x y : A}
  → (p : x ≡ y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后返回一条类型为 &lt;code&gt;f x ≡ f y&lt;/code&gt; 的路径。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;→ f x ≡ f y&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们要如何证明它？嗯…通过创建一条路径，然后对它接受的间点和其它提供的变量施一些魔法，就像这样：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;congruence f p = λ i → f (p i)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码做了什么？它：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;创建了一个路径-λ，于是我们有了一个间点 &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;&lt;li&gt;把&lt;code&gt;i&lt;/code&gt; 传给 &lt;code&gt;p&lt;/code&gt; ，注意我们的路径 &lt;code&gt;p&lt;/code&gt; 上全都是类型为 &lt;code&gt;A&lt;/code&gt; 的值，它在 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 之间&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;把从 &lt;code&gt;p&lt;/code&gt; 中提取的值传给函数 &lt;code&gt;f&lt;/code&gt;，该函数接受一个 &lt;code&gt;A&lt;/code&gt; 的实例并返回一个 &lt;code&gt;B&lt;/code&gt; 的实例。&lt;/p&gt;&lt;p&gt;就是这样！我们可以可视化此过程。 首先我们将间点传给 &lt;code&gt;p&lt;/code&gt;：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8ee61c27be761b10003af417ee245bc6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;503&quot; data-rawheight=&quot;437&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;503&quot; data-original=&quot;https://pic3.zhimg.com/v2-8ee61c27be761b10003af417ee245bc6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8ee61c27be761b10003af417ee245bc6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;503&quot; data-rawheight=&quot;437&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;503&quot; data-original=&quot;https://pic3.zhimg.com/v2-8ee61c27be761b10003af417ee245bc6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-8ee61c27be761b10003af417ee245bc6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接着我们在其结果上应用了 &lt;code&gt;f&lt;/code&gt; 后返回来：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-19adbd1b69e65d8eba27e9bcc32d31f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;489&quot; data-rawheight=&quot;426&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;489&quot; data-original=&quot;https://pic1.zhimg.com/v2-19adbd1b69e65d8eba27e9bcc32d31f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-19adbd1b69e65d8eba27e9bcc32d31f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;489&quot; data-rawheight=&quot;426&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;489&quot; data-original=&quot;https://pic1.zhimg.com/v2-19adbd1b69e65d8eba27e9bcc32d31f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-19adbd1b69e65d8eba27e9bcc32d31f4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;搞定！&lt;/p&gt;&lt;h2&gt;函数外延性&lt;/h2&gt;&lt;p&gt;&lt;b&gt;函数外延性（Function Extensionality）&lt;/b&gt;是这样一个命题：若两函数上的每一点都等价， 则两函数等价。以前我们无法结构化地证明它，然而现在有了 CuTT，我们就可以证明它了。 我们可以将函数外延性表示为一个函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;functionExtensionality
  : {A B : Set}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它接受两个从 &lt;code&gt;A&lt;/code&gt; 到 &lt;code&gt;B&lt;/code&gt; 的函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;→ {f g : A → B}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以及一个二者上的每一点都相等的证明 &lt;code&gt;p&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;→ (p : ∀ a → f a ≡ g a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并返回一个两函数等价的证明：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;→ f ≡ g&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以构造一条返回一个函数的路径，其中的函数用 &lt;code&gt;p&lt;/code&gt; 来实现，从而证明函数外延性：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;functionExtensionality p i = λ a → p a i&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这一次，我们：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;创建了一个路径-λ，因此有了一个间点 &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;&lt;li&gt;它返回的另一个 λ 接受一个类型为 &lt;code&gt;A&lt;/code&gt; 的参数 &lt;code&gt;a&lt;/code&gt;，就像 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 那样&lt;/li&gt;&lt;li&gt;在 &lt;code&gt;a&lt;/code&gt; 上应用 &lt;code&gt;p&lt;/code&gt;，我们就得到了一条类型为 &lt;code&gt;f a ≡ g a&lt;/code&gt; 的路径 （注意 &lt;code&gt;f a&lt;/code&gt; 和 &lt;code&gt;g a&lt;/code&gt; 的类型为 &lt;code&gt;B&lt;/code&gt;）&lt;/li&gt;&lt;li&gt;在 &lt;code&gt;i&lt;/code&gt; 上应用该路径，我们就得到了一个 &lt;code&gt;B&lt;/code&gt; 的实例&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;为了图示此证明，我们首先画出 &lt;code&gt;p&lt;/code&gt;，即每一点相等的证明，它是一个返回一条路径的函数：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-200c3c2e6ac6b70cd459c857d5c37c57_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;438&quot; data-rawheight=&quot;271&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;438&quot; data-original=&quot;https://pic4.zhimg.com/v2-200c3c2e6ac6b70cd459c857d5c37c57_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-200c3c2e6ac6b70cd459c857d5c37c57_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;438&quot; data-rawheight=&quot;271&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;438&quot; data-original=&quot;https://pic4.zhimg.com/v2-200c3c2e6ac6b70cd459c857d5c37c57_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-200c3c2e6ac6b70cd459c857d5c37c57_b.jpg&quot;/&gt;&lt;figcaption&gt;图中从路径以外的任意一点开始，到路径上间点的每一根箭头都是一个函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;其中的 &lt;code&gt;p&lt;/code&gt; 是一个从 &lt;code&gt;a&lt;/code&gt; 到一条路径的函数，如果我们用间点来表示它原本会返回的点， 那么我们可以将它特化为一个从 &lt;code&gt;a&lt;/code&gt; 到路径上任意特定的点上的函数。 这样我们就创建了一条新的路径，它将每一个间点 &lt;code&gt;i&lt;/code&gt; 都映射成了一个通过 &lt;code&gt;i&lt;/code&gt; 将 &lt;code&gt;p&lt;/code&gt; 特化后所得到的函数。下面是它的图示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b3168f6dc66397c7b4d91591cb6e817a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;463&quot; data-rawheight=&quot;375&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;463&quot; data-original=&quot;https://pic3.zhimg.com/v2-b3168f6dc66397c7b4d91591cb6e817a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b3168f6dc66397c7b4d91591cb6e817a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;463&quot; data-rawheight=&quot;375&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;463&quot; data-original=&quot;https://pic3.zhimg.com/v2-b3168f6dc66397c7b4d91591cb6e817a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b3168f6dc66397c7b4d91591cb6e817a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;译注：我们可以换一种描述：&lt;code&gt;p&lt;/code&gt; 通过将任意类型为 &lt;code&gt;A&lt;/code&gt; 的值 &lt;code&gt;a&lt;/code&gt; 分别代入 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt;， 为 &lt;code&gt;f a&lt;/code&gt; 和 &lt;code&gt;g a&lt;/code&gt; 建立了一条证明二者等价的路径，而每一个具体的 &lt;code&gt;a&lt;/code&gt; 都可以被映射到 这条路径上的一个间点，把这样的每一个映射本身都看做一个个间点，这些间点连缀而成的路径也就成了 &lt;code&gt;f≡g&lt;/code&gt; 的证明。&lt;/blockquote&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;现在我们相当熟悉简单的路径了（希望如此）。 作为练习，请定义「高阶」路径，它的端点也是路径，这意味着我们的路径-λ 也会返回路径-λ， 例如，&lt;code&gt;λ i j → a&lt;/code&gt; 其中的 &lt;code&gt;a&lt;/code&gt; 包含自由变量 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt;。 请思考一下这样的路径，我们会在下一章中讨论它。&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2020-02-09-102323224</guid>
<pubDate>Sun, 09 Feb 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>NuPRL 中的证明--从一到CTT</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2020-02-07-105439235.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/105439235&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文假设读者已经装了 NuPRL5 的 VM/要到了帳號并照著 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//nuprl.org/html/02cucs-NuprlManual-02overview.pdf&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;nuprl.org/html/02cucs-N&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;uprlManual-02overview.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt; 做基操。&lt;/p&gt;&lt;p&gt;这是向略懂 dependent type 的人的 NuPRL 教程，介紹这一最神/传奇的定理证明器。你不需要会 Haskell，但是至少要能理解 untyped lambda calculus，最好会点 OCaml/SML，最理想是 LCF ML，因为这是 NuPRL 的 Tactic 语言，而且它沒正式的 language report。Lisp 麻，会用 Emacs 程度就可以了，在 NuPRL 里几本用不上。&lt;/p&gt;&lt;p&gt;这文章只能向有 Agda/Coq/HOL/PVS/Metamath 经验的介绍下 NuPRL 了，因为完全 normie 的话像我一样出见 NuPRL 怕是不太可能有过了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Equality in CTT &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们先来看 equivalence。不好意思让你们失望了，NuPRL 里沒有 ADT。所以 NuPRL 的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+b+%5Cin+T&quot; alt=&quot;a = b \in T&quot; eeimg=&quot;1&quot;/&gt;  是个 primitive，如果 a 和 b 不等就是个空集，相等则有唯一成员 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%2A&quot; alt=&quot;*&quot; eeimg=&quot;1&quot;/&gt; ，相当于 unit type。&lt;/p&gt;&lt;p&gt;值得一提的是，在 Agda 用的 ITT 中，一个 value 只能和自己相等，但在 CTT，因为有 quotient type 的概念，你还可以定义一个类型使两个不同的 value 相等。&lt;/p&gt;&lt;p&gt;given equality relation &lt;img src=&quot;https://www.zhihu.com/equation?tex=E&quot; alt=&quot;E&quot; eeimg=&quot;1&quot;/&gt; on type &lt;img src=&quot;https://www.zhihu.com/equation?tex=T&quot; alt=&quot;T&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+b+%5Cin+T%2F%5C%21%2FE+%5Ciff+a+E+b&quot; alt=&quot;a = b \in T/\!/E \iff a E b&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;Number, Subset type(refinement type/subtype by comprehension)&lt;/h2&gt;&lt;p&gt;连 Equality 都 primitive 了，NuPRL 的 Integer 也是 primitive 的。所以就不要想 Peano number 了。&lt;/p&gt;&lt;p&gt;自然数的定义直接上 refinement type。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathbb%7BN%7D+%3D%3D+%5C%7Bi%3A%5Cmathbb%7BZ%7D%5C+%7C%5C+0%5Cleq+i%5C%7D&quot; alt=&quot;\mathbb{N} == \{i:\mathbb{Z}\ |\ 0\leq i\}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;Unit, then to Binary&lt;/h2&gt;&lt;p&gt;equality 已經成了 primitive，別的就不用都重新定义了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%5Cin+T+%3D%3D+a+%3D+a%5Cin+T&quot; alt=&quot;a \in T == a = a\in T&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;Unit 也就这么定义了&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Unit+%3D%3D+0+%5Cin+%5Cmathbb%7BZ%7D&quot; alt=&quot;Unit == 0 \in \mathbb{Z}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;Boolean:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmathbb%7BB%7D+%3D%3D+Unit+%2B+Unit&quot; alt=&quot;\mathbb{B} == Unit + Unit&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;是不是发现了什么？&lt;/p&gt;&lt;p&gt;沒错，NuPRL 沒有用来 pattern match 的 data constructor。毕竟是用 tactic 做证明的啉，case split 有 tactic，要 pattern match 又沒用。&lt;/p&gt;&lt;h2&gt;结语(划掉)&lt;/h2&gt;&lt;p&gt;不好意思，我们还没做证明。那現在就可以来一个了&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%2A%3E%5C%21%3E+0+%3D+0+%5Cin+%5Cmathbb%7BZ%7D%5C+%7Bby%7D%5C+%5Ctexttt%7BAuto%7D&quot; alt=&quot;*&amp;gt;\!&amp;gt; 0 = 0 \in \mathbb{Z}\ {by}\ \texttt{Auto}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;好，证完了。反正用 Auto Tactic 就对了。&lt;/p&gt;&lt;h2&gt;Subtyping&lt;/h2&gt;&lt;p&gt;你们好多人说 Subtyping 难，然而在 NuPRL 里 subtyping 如吃飯喝水一样自然。首先看看这句定义&lt;/p&gt;&lt;blockquote&gt;A is a subtype of B, written A ≤ B, if a value of type A can be supplied wherever a value of type B is demanded.&lt;/blockquote&gt;&lt;p&gt;然后把这给忘了吧，因为 CTT 的 subtyping 是这么定义的&lt;/p&gt;&lt;blockquote&gt;A is a subtype of B ( &lt;img src=&quot;https://www.zhihu.com/equation?tex=A+%5Csqsubseteq+B&quot; alt=&quot;A \sqsubseteq B&quot; eeimg=&quot;1&quot;/&gt; ) iff &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+a%27+%5Cin+A+%5Cimplies+a%3Da%27+%5Cin+B&quot; alt=&quot;a = a&amp;#39; \in A \implies a=a&amp;#39; \in B&quot; eeimg=&quot;1&quot;/&gt; &lt;/blockquote&gt;&lt;p&gt;这是一个外延性定义。&lt;/p&gt;&lt;p&gt;自然地&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bx%3AA%5C+%7C%5C+P%28x%29+%5C%7D+%5Csqsubseteq+A&quot; alt=&quot;\{x:A\ |\ P(x) \} \sqsubseteq A&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;Void, Top, Intersection over a family&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=+u%3Dv+%5Cin+%5Cbigcap%5Climits_%7Bx%3AA%7D%7BB%28x%29%7D+%5Ciff+%5Cforall+x+%5Cin+A.+u%3Dv+%5Cin+B%28x%29&quot; alt=&quot; u=v \in \bigcap\limits_{x:A}{B(x)} \iff \forall x \in A. u=v \in B(x)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;注意不要和 intersection type 搞混了，虽然它们是有关系。&lt;/p&gt;&lt;p&gt;Void 就是 Empty type。它是个 primitive。当然，并不代表你不能用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bx%3A%5Cmathbb%7BZ%7D%5C+%7C%5C+x%3Cx+%5C%7D&quot; alt=&quot;\{x:\mathbb{Z}\ |\ x&amp;lt;x \}&quot; eeimg=&quot;1&quot;/&gt; 这样的 type 表示它。自然地， &lt;img src=&quot;https://www.zhihu.com/equation?tex=Void+%5Csqsubseteq+A&quot; alt=&quot;Void \sqsubseteq A&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;在一个有 subtyping 的 type theory 里，Top 可不能和 Unit 混在一起了 (说的就是你，Agda！)&lt;/p&gt;&lt;p&gt;Intersection over a family 中 A 为 empty 时，B(x) 的 B 就是 a functions from Empty to some type 了，因为从 empty 可以 derive anything，所以这样就是 Top, where &lt;img src=&quot;https://www.zhihu.com/equation?tex=A+++%5Csqsubseteq+Top&quot; alt=&quot;A   \sqsubseteq Top&quot; eeimg=&quot;1&quot;/&gt; 了。当然 Agda 用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctop&quot; alt=&quot;\top&quot; eeimg=&quot;1&quot;/&gt; 表示 Unit 不是沒有道理的，因为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5E0+%5Ccong+1&quot; alt=&quot;A^0 \cong 1&quot; eeimg=&quot;1&quot;/&gt; (即从 empty 到所有类型的 function 只有一个)嚒。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=A%28given%5C+B%29%3D%5Cbigcap%5Climits_%7Bx%3AA%7D%7BB%28x%29%7D&quot; alt=&quot;A(given\ B)=\bigcap\limits_{x:A}{B(x)}&quot; eeimg=&quot;1&quot;/&gt; if x is free in B.&lt;/p&gt;&lt;p&gt;这叫做 Guarded Type，作用放之后讲。不过現在我们可以用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Void%28given%5C+Void%29&quot; alt=&quot;Void(given\ Void)&quot; eeimg=&quot;1&quot;/&gt; 来定义 Top。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>LdBeth</author>
<guid isPermaLink="false">2020-02-07-105439235</guid>
<pubDate>Fri, 07 Feb 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>凉爽的 CuTT 介绍（2）--带有路径构造子的归纳类型</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2020-02-04-104929162.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/104929162&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;文本译自&lt;a href=&quot;https://www.zhihu.com/people/67ebe1bd8e4a63f17a42572e40afaac7&quot; class=&quot;internal&quot;&gt;@千里冰封 你懂吗&lt;/a&gt;介绍&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ice1000.org/2019/10-01-Cutt2.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;立方类型论&lt;/a&gt;的文章。&lt;/blockquote&gt;&lt;p&gt;回忆&lt;a href=&quot;https://zhuanlan.zhihu.com/p/103565709&quot; class=&quot;internal&quot;&gt;上一章&lt;/a&gt;，我们有了高维的路径（方形），而且可以通过路径应用来归约（降低）它们的维度。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;{-# OPTIONS --cubical --allow-unsolved-metas #-}
module 2019-10-1-Cutt2 where
open import Cubical.Core.Everything
open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Isomorphism
open import Agda.Builtin.Nat

variable A : Set&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;回忆经典的整数定义（点击 &lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ice1000.org/lagda/Cubical.Data.Int.Base.html%23142&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 查看）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import Cubical.Data.Int using (Int)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这玩意儿看着很不爽，因为它不对称——以数字 2 为例，&lt;code&gt;+2&lt;/code&gt; 是 &lt;code&gt;pos 2&lt;/code&gt;，而 &lt;code&gt;-2&lt;/code&gt; 却是 &lt;code&gt;negsuc 1&lt;/code&gt;。证明这种不对称整数的加法交换律很让人蛋疼（瞅一眼&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ice1k/Theorems/blob/master/src/Ints/Add/Assoc.agda&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这儿&lt;/a&gt;） （由于整数的定义不是对称的，因此其上的运算自然也不对称）。&lt;/p&gt;&lt;p&gt;我们想要一种对称的整数定义，它大概是这样的：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;data Int : Set where
  pos : Nat -&amp;gt; Int
  neg : Nat -&amp;gt; Int&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过这样我们就有两个零了：&lt;code&gt;pos 0&lt;/code&gt;和&lt;code&gt;neg 0&lt;/code&gt;。我们&lt;b&gt;之所以&lt;/b&gt;把经典的整数定义成不对称的，是为了避免存在两种零，虽然从数学上讲零既非正数也非负数（从另一个角度上也可以说是只有正零而没有负零）。&lt;/p&gt;&lt;p&gt;于是问题来了：&lt;b&gt;我们能告诉 Agda&lt;/b&gt; &lt;b&gt;&lt;code&gt;pos 0&lt;/code&gt;&lt;/b&gt; &lt;b&gt;等于&lt;/b&gt; &lt;b&gt;&lt;code&gt;neg 0&lt;/code&gt;&lt;/b&gt; &lt;b&gt;吗？&lt;/b&gt; 如果可以，那上面的定义就很有用了！&lt;/p&gt;&lt;p&gt;答案当然是：&lt;b&gt;确定！一定！以及肯定可以！&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;路径构造子&lt;/h2&gt;&lt;p&gt;回忆一下，路径它：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;被定义为一种函数，其定义域为间点，陪域为端点的类型&lt;/li&gt;&lt;li&gt;可以视作一种等价关系&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们可以为数据类型添加&lt;b&gt;路径构造子（Path Constructor）&lt;/b&gt;，比如添加 &lt;code&gt;pos 0 ≡ neg 0&lt;/code&gt;，它是一条映射到 &lt;code&gt;Int&lt;/code&gt; 的路径（并且如果这种路径有定义，那么它就是一个从间点到 &lt;code&gt;Int&lt;/code&gt; 的函数）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;zro : pos 0 ≡ neg 0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们用函数类型重写 &lt;code&gt;zro&lt;/code&gt; 的类型（&lt;code&gt;zro&lt;/code&gt; 本身就有一个路径类型），那么就得到了一个构造子式的类型（它的返回类型就是它所构造的类型）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;zroFn : I -&amp;gt; Int
zroFn i = zro i&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于 &lt;code&gt;zro&lt;/code&gt; 返回一个 &lt;code&gt;Int&lt;/code&gt; 和它的构造子，因此我们称之为&lt;b&gt;路径构造子（Path Constructor）&lt;/b&gt;。在介绍路径构造子的高级属性前，我们已经知道很多有趣的东西了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;posneg : pos 0 ≡ neg 0
posneg = zro

negpos : neg 0 ≡ pos 0
negpos i = zro (~ i)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;路径约束&lt;/h2&gt;&lt;p&gt;路径构造子的特殊之处在于，当带有路径构造子的数据类型出现在模式匹配从句的左侧时， 它们也&lt;b&gt;约束（Constraint）&lt;/b&gt;了你的模式匹配从句。以 &lt;code&gt;succ&lt;/code&gt; 函数为例， 在为 &lt;code&gt;Int&lt;/code&gt; 写出 &lt;code&gt;succ&lt;/code&gt; 函数时，我们需要对路径构造子进行模式匹配：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;succ : Int -&amp;gt; Int
succ (pos x) = pos (suc x)
succ (neg zero) = pos 1
succ (neg (suc x)) = neg x
-- 上面三个从句很平凡

succ (zro i) = -- 这种情况我们要返回什么？&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种情况的路径构造子的规则是，我们可以返回任何满足以下条件的东西（以 &lt;code&gt;Int&lt;/code&gt; 上的 &lt;code&gt;succ&lt;/code&gt; 为例）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;succ (zro i)&lt;/code&gt; 按照定义的等价性应被规约为：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;succ (pos 0)&lt;/code&gt;（&lt;code&gt;pos 0&lt;/code&gt; 来自 &lt;code&gt;zro i0&lt;/code&gt;），当 &lt;code&gt;i0&lt;/code&gt; 被代入 &lt;code&gt;i&lt;/code&gt; 时&lt;/li&gt;&lt;li&gt;&lt;code&gt;succ (neg 0)&lt;/code&gt;（&lt;code&gt;neg 0&lt;/code&gt; 来自 &lt;code&gt;zro i1&lt;/code&gt;），当 &lt;code&gt;i1&lt;/code&gt; 被代入 &lt;code&gt;i&lt;/code&gt; 时&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;我们将此性质简称为「路径的端点需要被遵守」&lt;/p&gt;&lt;p&gt;而由于 &lt;code&gt;succ (pos 0)&lt;/code&gt; 和 &lt;code&gt;succ (neg 0)&lt;/code&gt; 均等于 &lt;code&gt;pos 1&lt;/code&gt;，因此 &lt;code&gt;zro&lt;/code&gt; 情况的唯一可能就是 &lt;code&gt;pos 1&lt;/code&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;succ : Int -&amp;gt; Int
succ (pos x) = pos (suc x)
succ (neg zero) = pos 1
succ (neg (suc x)) = neg x
succ (zro i) = pos 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际上，Agda 的约束求解器可以求出此函数的一些从句。 我们可以将上面的函数写成带&lt;b&gt;洞（Hole）&lt;/b&gt;的形式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;succ′ : Int -&amp;gt; Int
succ′ (pos x) = pos (suc x)
succ′ (neg zero) = {!!}
succ′ (neg (suc x)) = neg x
succ′ (zro i) = {!!}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在你的 Agda 编辑器中加载本文中的代码并对它使用「Auto」。两个洞都可以被解决。&lt;/p&gt;&lt;p&gt;由于这里出现的路径构造子类型为 &lt;code&gt;pos 0 ≡ neg 0&lt;/code&gt;，因此 Agda 知道 &lt;code&gt;succ&amp;#39; (neg zero)&lt;/code&gt; 等于 &lt;code&gt;succ&amp;#39; (pos zero)&lt;/code&gt;，其中 &lt;code&gt;succ&amp;#39; (pos x)&lt;/code&gt; 定义为 &lt;code&gt;pos (suc x)&lt;/code&gt;， 对 &lt;code&gt;pos zero&lt;/code&gt; 应用此模式的结果为 &lt;code&gt;pos (suc zero)&lt;/code&gt;，它等于 &lt;code&gt;pos 1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;同样，我们可以定义 &lt;code&gt;pred&lt;/code&gt; 函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pred : Int -&amp;gt; Int
pred (pos zero) = neg 1
pred (pos (suc x)) = pos x
pred (neg x) = neg (suc x)
pred (zro i) = neg 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;同构&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;module IsoInt where
open Cubical.Data.Int renaming (Int to StdInt)
pattern spos n = StdInt.pos n
pattern nsuc n = StdInt.negsuc n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;给出标准整数的定义，我们可以证明 HIT（高阶归纳类型，Higher-Inductive Type 的缩写， 即带有路径构造子的归纳类型）的整数与它同构。要在类型论下证明同构，我们需要给出两个 （实际上只有我们知道的）互逆的函数，并证明它们的互逆关系（以此来说服 Agda 它们是互逆的）。&lt;/p&gt;&lt;p&gt;从 &lt;code&gt;StdInt&lt;/code&gt; 到 &lt;code&gt;Int&lt;/code&gt;，我们将 &lt;code&gt;pos&lt;/code&gt; 转换为 &lt;code&gt;pos&lt;/code&gt;，将 &lt;code&gt;negsuc&lt;/code&gt; 转换为 &lt;code&gt;neg ∘ suc&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;StdInt-&amp;gt;Int : StdInt -&amp;gt; Int
StdInt-&amp;gt;Int (spos n) = pos n
StdInt-&amp;gt;Int (nsuc n) = neg (suc n)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一方面，由于标准定义中缺少路径构造子，因此我们将 &lt;code&gt;zro i&lt;/code&gt; 映射为 &lt;code&gt;pos 0&lt;/code&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Int-&amp;gt;StdInt : Int -&amp;gt; StdInt
Int-&amp;gt;StdInt (pos x) = spos x
Int-&amp;gt;StdInt (neg zero) = spos 0
Int-&amp;gt;StdInt (neg (suc x)) = nsuc x
Int-&amp;gt;StdInt (zro i) = spos 0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们来试着证明两函数互逆。此同构的一面很平凡：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;StdInt-&amp;gt;Int-&amp;gt;StdInt : (n : StdInt) -&amp;gt; Int-&amp;gt;StdInt (StdInt-&amp;gt;Int n) ≡ n
StdInt-&amp;gt;Int-&amp;gt;StdInt (spos _) = refl
StdInt-&amp;gt;Int-&amp;gt;StdInt (nsuc _) = refl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它可以证明是因为我们的两个模式将 &lt;code&gt;Int-&amp;gt;StdInt (StdInt-&amp;gt;Int n)&lt;/code&gt; 代换成了 &lt;code&gt;Int-&amp;gt;StdInt (StdInt-&amp;gt;Int (spos n))&lt;/code&gt; 和 &lt;code&gt;Int-&amp;gt;StdInt (StdInt-&amp;gt;Int (nsuc n))&lt;/code&gt;， 它们可展开为 &lt;code&gt;spos n&lt;/code&gt; 和 &lt;code&gt;nsuc n&lt;/code&gt;，二者与返回类型中路径的右式一致。&lt;/p&gt;&lt;p&gt;此同构另一面的两种情况则要稍微难一些，我们来逐个讨论。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Int-&amp;gt;StdInt-&amp;gt;Int : (n : Int) -&amp;gt; StdInt-&amp;gt;Int (Int-&amp;gt;StdInt n) ≡ n
Int-&amp;gt;StdInt-&amp;gt;Int (pos x) = refl
Int-&amp;gt;StdInt-&amp;gt;Int (neg zero) =&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此从句是第一个非平凡的情况。如果我们将 &lt;code&gt;neg zero&lt;/code&gt; 代入 &lt;code&gt;Int-&amp;gt;StdInt n&lt;/code&gt;，就会得到 &lt;code&gt;spos 0&lt;/code&gt;，而将 &lt;code&gt;spos 0&lt;/code&gt; 代入 &lt;code&gt;StdInt-&amp;gt;Int n&lt;/code&gt; 则会得到 &lt;code&gt;pos 0&lt;/code&gt;。于是此从句的类型为 &lt;code&gt;pos 0 ≡ neg 0&lt;/code&gt;，它就是 &lt;code&gt;zro&lt;/code&gt; 的类型。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  zro&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着我们填上另一个平凡的情况。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Int-&amp;gt;StdInt-&amp;gt;Int (neg (suc x)) = refl
Int-&amp;gt;StdInt-&amp;gt;Int (zro i) = lemma
  where&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后一种情况也有点复杂，我们为了可读性引入了一条引理。 进行一些简单代换后我们可以得到以下签名：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;  lemma : pos 0 ≡ zro i
  lemma j =&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它是上下文中一条带有一个间点变量的路径，它可以看做两个路径间一条的路径， 该路径的两边分别为 &lt;code&gt;pos 0&lt;/code&gt; 和 &lt;code&gt;zro i&lt;/code&gt;。如下图所示，如果把 &lt;code&gt;j = i0&lt;/code&gt; 看做 &lt;code&gt;x = y&lt;/code&gt; 的形式，那么 &lt;code&gt;x&lt;/code&gt; 是间点变量，&lt;code&gt;y&lt;/code&gt; 是 &lt;code&gt;i0&lt;/code&gt; 或 &lt;code&gt;i1&lt;/code&gt; 这样的端点。以 &lt;code&gt;x&lt;/code&gt; 索引的路径的 &lt;code&gt;y&lt;/code&gt; 端，即 &lt;code&gt;j = i0&lt;/code&gt;，也就是 &lt;code&gt;pos 0&lt;/code&gt; 的那条边（图的左边）是一个常量路径，而 &lt;code&gt;zro i&lt;/code&gt;，即 &lt;code&gt;j = i1&lt;/code&gt; 的那条边（图的右边） 有两个不同的边：&lt;code&gt;pos 0&lt;/code&gt;（&lt;code&gt;i = i0&lt;/code&gt; 的那条边，即底边）和 &lt;code&gt;neg 0&lt;/code&gt;（&lt;code&gt;i = i1&lt;/code&gt; 的那条边， 即顶边）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b88ebb8d46a6245b439130a515a55f8e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;427&quot; data-rawheight=&quot;445&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;427&quot; data-original=&quot;https://pic3.zhimg.com/v2-b88ebb8d46a6245b439130a515a55f8e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b88ebb8d46a6245b439130a515a55f8e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;427&quot; data-rawheight=&quot;445&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;427&quot; data-original=&quot;https://pic3.zhimg.com/v2-b88ebb8d46a6245b439130a515a55f8e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b88ebb8d46a6245b439130a515a55f8e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;它刚好就是上一篇文章中引入的 &lt;code&gt;minSq&lt;/code&gt;（将 &lt;code&gt;pos 0&lt;/code&gt; 代入 &lt;code&gt;a&lt;/code&gt;，将 &lt;code&gt;neg 0&lt;/code&gt; 代入 &lt;code&gt;b&lt;/code&gt;）！ 回想 &lt;code&gt;minSq&lt;/code&gt; 是以 &lt;code&gt;min&lt;/code&gt; 运算符定义的，我们这里也可以应用同样的技术：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;    zro (i ∧ j)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;搞定！&lt;/p&gt;&lt;h2&gt;同构与路径&lt;/h2&gt;&lt;p&gt;立方类型论可以带给你的一点好处是你可以在同构的类型之间创建一条路径。 其背后的理论超出了本文讨论的范围，但我们可以试一下基于该理论的库函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-agda&quot;&gt;Int≡StdInt : Int ≡ StdInt
Int≡StdInt = isoToPath (iso Int-&amp;gt;StdInt StdInt-&amp;gt;Int StdInt-&amp;gt;Int-&amp;gt;StdInt Int-&amp;gt;StdInt-&amp;gt;Int)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;一个问题&lt;/h2&gt;&lt;p&gt;还有一种定义为 HIT 的整数类型：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;infixl 5 _⊝_
data DeltaInt : Set where
  _⊝_    : Nat -&amp;gt; Nat -&amp;gt; DeltaInt
  cancel : ∀ a b -&amp;gt; a ⊝ b ≡ suc a ⊝ suc b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它是以一个自然数减去另一个来定义的。这是一种全新的 HIT， 因此我建议读者为它定义一些常见的运算并证明它们的性质以熟悉这个 HIT。&lt;/p&gt;&lt;p&gt;我们可以找出一条它的引理：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;cancelDiamond : ∀ a b i → cancel a b i ≡ cancel (suc a) (suc b) i
cancelDiamond a b = {!!}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于 &lt;code&gt;a ⊝ b&lt;/code&gt; 等于 &lt;code&gt;suc a ⊝ suc b&lt;/code&gt;，因此我们可以在一个间点上泛化这种相等关系（它正是 &lt;code&gt;cancelDiamond&lt;/code&gt;）。但我们要如何证明它？试着画出 &lt;code&gt;cancelDiamond&lt;/code&gt;，我们会看到一个方形，但它既不是 min 方形也不是 max 方形。&lt;/p&gt;&lt;p&gt;答案将在下一篇文章中使用新的 CuTT 运算来揭晓。&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2020-02-04-104929162</guid>
<pubDate>Tue, 04 Feb 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 APL 写 Cellular Automaton (A NEW KIND OF SCIENCE)</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2020-02-02-104622595.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/104622595&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-aea51532371c88be451db5dbd6ca25ea_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-apl&quot;&gt;&lt;span class=&quot;c1&quot;&gt;⍝ CA 的原理很簡單，用 APL 的 primitive ⌺ (Stencil) 就可以表示&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⍪&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍺⍺&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⌺&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;¯1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;↑&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;⍝ two-color ca 的映射&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;rule&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;⎕IO&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;⋄&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⊥&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⌷⌽&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⍴&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⊤&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍺⍺&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;⍝ three-color ca&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;⎕IO&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;⋄&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⌷⌽&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⍴&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⊤&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍺⍺&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;⍝from APL matrics to Netpbm format&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;pgm&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;P2&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⍕⌽⍴&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⍕&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,⍕&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;¨&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;↓&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;⍨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⌈&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;題图(code2040 size:1001×1001)生成方式&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-apl&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⊂&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pgm&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2040&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;⍣&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;initi&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;⎕NPUT&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;a.pgm&amp;#39;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;⍝ from shell $ pnmtopng a.pgm &amp;gt; z.png&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-13dc8eff273d2e7c02250b3f20e788f2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;870&quot; data-rawheight=&quot;212&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;870&quot; data-original=&quot;https://pic3.zhimg.com/v2-13dc8eff273d2e7c02250b3f20e788f2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-13dc8eff273d2e7c02250b3f20e788f2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;870&quot; data-rawheight=&quot;212&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;870&quot; data-original=&quot;https://pic3.zhimg.com/v2-13dc8eff273d2e7c02250b3f20e788f2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-13dc8eff273d2e7c02250b3f20e788f2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;mobile automaton 就相当于两个 two-color ca。&lt;/p&gt;&lt;p&gt;不过我们可以先把 accumulator 给 abstract 出來。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-apl&quot;&gt;&lt;span class=&quot;nv&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍺&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;⋄&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⊢⍪&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍺⍺&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;∘&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;¯1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;↑⊢&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;⍣&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍺&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;⍝ 这样之前的可以写成 (⊂pgm 1000 (2040 cell code acc) initi 500)⎕NPUT&amp;#39;a.pgm&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后是 mobile automaton 的原理&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-apl&quot;&gt;&lt;span class=&quot;nv&quot;&gt;mobile&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍺⍺&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;⍵⍵&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⌷&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;⍨&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⊂&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⊣&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;¯1&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⍸&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和替換规则&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-apl&quot;&gt;&lt;span class=&quot;nv&quot;&gt;ma&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⌽&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;⍣&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⊣&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⊤&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;⍨&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⍴&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rule&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;¨&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;⊂&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;←&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;⍵&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1a599d7da6e88a3dcb082c04116803cd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1210&quot; data-rawheight=&quot;660&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1210&quot; data-original=&quot;https://pic2.zhimg.com/v2-1a599d7da6e88a3dcb082c04116803cd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1a599d7da6e88a3dcb082c04116803cd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1210&quot; data-rawheight=&quot;660&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1210&quot; data-original=&quot;https://pic2.zhimg.com/v2-1a599d7da6e88a3dcb082c04116803cd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-1a599d7da6e88a3dcb082c04116803cd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们就可以把这个 encode 成 14570 ← → 255⊥57 35, 57 ←→ 2⊥0 0 1 1 1 0 0 1, 85 ←→ 2⊥0 0 1 0 0 0 1 1.&lt;/p&gt;&lt;p&gt;于是可以用&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-apl&quot;&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;14570&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;mobile&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ma&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;initi&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;画出&lt;/p&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cc2724161bd9a716d9b39e2029b23588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;608&quot; data-rawheight=&quot;830&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;608&quot; data-original=&quot;https://pic1.zhimg.com/v2-cc2724161bd9a716d9b39e2029b23588_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cc2724161bd9a716d9b39e2029b23588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;608&quot; data-rawheight=&quot;830&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;608&quot; data-original=&quot;https://pic1.zhimg.com/v2-cc2724161bd9a716d9b39e2029b23588_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cc2724161bd9a716d9b39e2029b23588_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7cc06252b678869e89214760e560bada_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1208&quot; data-rawheight=&quot;368&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1208&quot; data-original=&quot;https://pic3.zhimg.com/v2-7cc06252b678869e89214760e560bada_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7cc06252b678869e89214760e560bada_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1208&quot; data-rawheight=&quot;368&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1208&quot; data-original=&quot;https://pic3.zhimg.com/v2-7cc06252b678869e89214760e560bada_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7cc06252b678869e89214760e560bada_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>LdBeth</author>
<guid isPermaLink="false">2020-02-02-104622595</guid>
<pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
