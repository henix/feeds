<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[链接] Java语言规范里关于Java类与接口的卸载的描述</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/25279400">原文</a></p>
这方面的问题时常被提起（又称“月经帖”），所以这边想发个链接来镇楼…<p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.7" data-editable="true" data-title="Chapter 12. Execution" class="">12.7. Unloading of Classes and Interfaces - Chapter 12. Execution - Java Language Specification (Java SE 8)</a></p><p>以下引用规范的内容：</p><blockquote><p>An implementation of the Java programming language may <em>unload</em> classes.</p><p><b>A class or interface may be unloaded if and only if its defining class loader may be reclaimed by the garbage collector as discussed in <a class="" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6" data-editable="true" data-title="§12.6">§12.6</a>.</b></p><p><b>Classes and interfaces loaded by the bootstrap loader may not be unloaded.</b></p><p>Class unloading is an optimization that helps reduce memory use. Obviously, the semantics of a program should not depend on whether and how a system chooses to implement an optimization such as class unloading. To do otherwise would compromise the portability of programs. Consequently, whether a class or interface has been unloaded or not should be transparent to a program.</p><p>However, if a class or interface C was unloaded while its defining loader was potentially reachable, then C might be reloaded. One could never ensure that this would not happen. Even if the class was not referenced by any other currently loaded class, it might be referenced by some class or interface, D, that had not yet been loaded. When D is loaded by C's defining loader, its execution might cause reloading of C.</p><p>Reloading may not be transparent if, for example, the class has static variables (whose state would be lost), static initializers (which may have side effects), or native methods (which may retain static state). Furthermore, the hash value of the Class object is dependent on its identity. Therefore it is, in general, impossible to reload a class or interface in a completely transparent manner.</p><p>Since we can never guarantee that unloading a class or interface whose loader is potentially reachable will not cause reloading, and reloading is never transparent, but unloading must be transparent, it follows that one must not unload a class or interface while its loader is potentially reachable. A similar line of reasoning can be used to deduce that classes and interfaces loaded by the bootstrap loader can never be unloaded.</p><p><b>One must also argue why it is safe to unload a class C if its defining class loader can be reclaimed. If the defining loader can be reclaimed, then there can never be any live references to it (this includes references that are not live, but might be resurrected by finalizers). This, in turn, can only be true if there are can never be any live references to any of the classes defined by that loader, including C, either from their instances or from code.</b></p><p>Class unloading is an optimization that is only significant for applications that load large numbers of classes and that stop using most of those classes after some time. A prime example of such an application is a web browser, but there are others. A characteristic of such applications is that they manage classes through explicit use of class loaders. As a result, the policy outlined above works well for them.</p><p>Strictly speaking, it is not essential that the issue of class unloading be discussed by this specification, as class unloading is merely an optimization. However, the issue is very subtle, and so it is mentioned here by way of clarification.</p></blockquote><p>引用结束。看，规范已经帮我们讨论了类卸载的条件的思路。简单明了。实际的JVM如果选择实现类卸载的话，条件其实也就跟这里加黑的部分所写的是相似的。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
