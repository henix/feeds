<p>最近为了了解PL，开始看 <i>Types and Programming Languages</i> （下称TAPL）。知乎上说最好自己实现一遍解释器才会对λ演算有深入的了解，所以我就实现了一遍。实现过以后好像没有对λ演算醍醐灌顶， de Bruijn index 倒确实比以前明白了。</p><p>首先是Term和Context的（伪）定义：</p><div class="highlight"><pre><code class="language-text">;; Term = (Var index context-size)
;;      | (Abs term bound-var-name)
;;      | (App term term)
;; Context = [(name, nil)]</code></pre></div><p>和书里不同的是去除了info，Context里的Binding用nil代替，其他一样。由于Emacs Lisp没有与Haskell、OCaml类似的类型系统，我就用S表达式代替（所以周围加了括号）这样正好方便类型匹配（pattern matching是这么说么）。类型匹配用的是Stefan Monnier写的pcase库。</p><p>下面是几个方便函数。</p><div class="highlight"><pre><code class="language-emacs"><span class="p">(</span><span class="nb">defun</span> <span class="nv">var-name</span> <span class="p">(</span><span class="nv">context-elm</span><span class="p">)</span>
  <span class="s">&#34;Get name of CONTEXT-ELM.&#34;</span>
  <span class="p">(</span><span class="nf">car</span> <span class="nv">context-elm</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">add-var</span> <span class="p">(</span><span class="nv">var</span> <span class="nv">context</span><span class="p">)</span>
  <span class="s">&#34;Add VAR (string) to CONTEXT&#34;</span>
  <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nf">list</span> <span class="nv">var</span> <span class="no">nil</span><span class="p">)</span> <span class="nv">context</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">valuep</span> <span class="p">(</span><span class="nv">term</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">eq</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">term</span><span class="p">)</span> <span class="ss">&#39;Abs</span><span class="p">))</span></code></pre></div><h2>打印</h2><p>把de Bruijin index转成变量名（x, y, etc）的函数。</p><div class="highlight"><pre><code class="language-emacs"><span class="p">(</span><span class="nb">defun</span> <span class="nv">index2name</span> <span class="p">(</span><span class="nv">context</span> <span class="nv">index</span><span class="p">)</span>
  <span class="s">&#34;Translate INDEX to variable name in CONTEXT.&#34;</span>
  <span class="p">(</span><span class="nv">var-name</span> <span class="p">(</span><span class="nf">nth</span> <span class="nv">index</span> <span class="nv">context</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">unique-name</span> <span class="p">(</span><span class="nv">context</span> <span class="nv">name</span><span class="p">)</span>
  <span class="s">&#34;Return a list (CONTEXT’ NAME’).
</span><span class="s">If NAME is in CONTEXT, generate a unique one (NAME’) and push to
</span><span class="s">CONTEXT (CONTEXT’), otherwise return (CONTEXT NAME).&#34;</span>
  <span class="p">(</span><span class="nb">cl-labels</span> <span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="nv">context-elm</span><span class="p">)</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nv">var-name</span> <span class="nv">context-elm</span><span class="p">)</span> <span class="nv">name</span><span class="p">))</span>
              <span class="c1">;; f returns t if CONTEXT-ELM has the same name as NAME</span>
              <span class="p">(</span><span class="nv">or2</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span> <span class="c1">; or is a special form</span>
    <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">context</span> <span class="p">(</span><span class="nv">cl-reduce</span> <span class="nf">#&#39;</span><span class="nv">or2</span> <span class="p">(</span><span class="nf">mapcar</span> <span class="nf">#&#39;</span><span class="nv">f</span> <span class="nv">context</span><span class="p">)))</span>
        <span class="c1">;; exists another NAME</span>
        <span class="p">(</span><span class="nv">unique-name</span> <span class="nv">context</span> <span class="p">(</span><span class="nf">concat</span> <span class="nv">name</span> <span class="s">&#34;&#39;&#34;</span><span class="p">))</span>
      <span class="c1">;; NAME is unique, push to context</span>
      <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nv">add-var</span> <span class="nv">name</span> <span class="nv">context</span><span class="p">)</span> <span class="nv">name</span><span class="p">))))</span></code></pre></div><p>接下来就是打印函数。用pcase匹配 <code>term</code> 处理三种情况。打印的时候尽量不用括号，除非application里左边是abstraction，或者右边是application。</p><div class="highlight"><pre><code class="language-emacs"><span class="p">(</span><span class="nb">defun</span> <span class="nv">show</span> <span class="p">(</span><span class="nv">term</span> <span class="kp">&amp;optional</span> <span class="nv">context</span> <span class="nv">raw</span><span class="p">)</span>
  <span class="s">&#34;Display TERM in CONTEXT.&#34;</span>
  <span class="p">(</span><span class="nb">pcase</span> <span class="nv">term</span>
    <span class="c1">;; variable</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">Var</span> <span class="o">,</span><span class="nv">index</span> <span class="o">,</span><span class="nv">size</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">context</span><span class="p">)</span> <span class="nv">size</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">if</span> <span class="nv">raw</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">index</span><span class="p">)</span>
           <span class="p">(</span><span class="nv">index2name</span> <span class="nv">context</span> <span class="nv">index</span><span class="p">))</span>
       <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;Bad index: %s, term: %s context: %s&#34;</span> <span class="nv">index</span> <span class="nv">term</span> <span class="nv">context</span><span class="p">)))</span>
    <span class="c1">;; abstraction</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">Abs</span> <span class="o">,</span><span class="nv">body</span> <span class="o">,</span><span class="nv">x</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">pcase-let</span> <span class="p">((</span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">context1</span> <span class="o">,</span><span class="nv">x1</span><span class="p">)</span> <span class="p">(</span><span class="nv">unique-name</span> <span class="nv">context</span> <span class="nv">x</span><span class="p">)))</span>
       <span class="p">(</span><span class="nf">format</span> <span class="s">&#34;λ%s.%s&#34;</span> <span class="p">(</span><span class="nb">if</span> <span class="nv">raw</span> <span class="s">&#34;&#34;</span> <span class="nv">x1</span><span class="p">)</span> <span class="p">(</span><span class="nv">show</span> <span class="nv">body</span> <span class="nv">context1</span> <span class="nv">raw</span><span class="p">))))</span>
    <span class="c1">;; application</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="nv">t1</span> <span class="o">,</span><span class="nv">t2</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">t1t</span> <span class="p">(</span><span class="nv">show</span> <span class="nv">t1</span> <span class="nv">context</span> <span class="nv">raw</span><span class="p">))</span>
           <span class="p">(</span><span class="nv">t2t</span> <span class="p">(</span><span class="nv">show</span> <span class="nv">t2</span> <span class="nv">context</span> <span class="nv">raw</span><span class="p">)))</span>
       <span class="c1">;; add parenthesis for abs and app, but not var</span>
       <span class="p">(</span><span class="nf">format</span> <span class="s">&#34;%s%s&#34;</span>
               <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">t1</span><span class="p">)</span> <span class="ss">&#39;Var</span><span class="p">)</span> <span class="nv">t1t</span> <span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;(&#34;</span> <span class="nv">t1t</span> <span class="s">&#34;)&#34;</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">t2</span><span class="p">)</span> <span class="ss">&#39;App</span><span class="p">)</span> <span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;(&#34;</span> <span class="nv">t2t</span> <span class="s">&#34;)&#34;</span><span class="p">)</span> <span class="nv">t2t</span><span class="p">))))</span>
    <span class="p">(</span><span class="nv">_</span> <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;No matching pattern: %s&#34;</span> <span class="nv">term</span><span class="p">))))</span></code></pre></div><p>在scratch buffer里试试：</p><div class="highlight"><pre><code class="language-emacs"><span class="p">(</span><span class="nv">show</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">Var</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">((</span><span class="s">&#34;x&#34;</span> <span class="no">nil</span><span class="p">)))</span>
<span class="s">&#34;x&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">App</span> <span class="p">(</span><span class="nv">Var</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">Var</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">((</span><span class="s">&#34;x&#34;</span> <span class="no">nil</span><span class="p">)</span> <span class="p">(</span><span class="s">&#34;y&#34;</span> <span class="no">nil</span><span class="p">)))</span>
<span class="s">&#34;xy&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">Abs</span> <span class="p">(</span><span class="nv">App</span> <span class="p">(</span><span class="nv">Var</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">Var</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="s">&#34;x&#34;</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">((</span><span class="s">&#34;y&#34;</span> <span class="no">nil</span><span class="p">)))</span>
<span class="s">&#34;λx.xy&#34;</span></code></pre></div><h2>解析</h2><p>手写内部结构有点痛苦，正好Emacs Lisp有方便的S表达式，写个简单的parser很容易。</p><div class="highlight"><pre><code class="language-emacs"><span class="c1">;; Term := Abs | App | Var | (Term)</span>
<span class="c1">;; Abs  := λ Var Term</span>
<span class="c1">;; App  := Term Term</span>
<span class="c1">;; Var  := Symbol</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">parse</span> <span class="p">(</span><span class="nv">term</span> <span class="kp">&amp;optional</span> <span class="nv">context</span><span class="p">)</span>
  <span class="s">&#34;Parse TERM into internal structure.
</span><span class="s">CONTEXT is current context.&#34;</span>
  <span class="p">(</span><span class="nb">pcase</span> <span class="nv">term</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">λ</span> <span class="o">,</span><span class="nv">var</span> <span class="o">.</span> <span class="o">,</span><span class="nv">body</span><span class="p">)</span>
     <span class="o">`</span><span class="p">(</span><span class="nv">Abs</span> <span class="o">,</span><span class="p">(</span><span class="nv">parse</span> <span class="nv">body</span> <span class="p">(</span><span class="nv">add-var</span> <span class="p">(</span><span class="nf">symbol-name</span> <span class="nv">var</span><span class="p">)</span> <span class="nv">context</span><span class="p">))</span>
           <span class="o">,</span><span class="p">(</span><span class="nf">symbol-name</span> <span class="nv">var</span><span class="p">)))</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">t1</span> <span class="o">,</span><span class="nv">t2</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="p">(</span><span class="nv">parse</span> <span class="nv">t1</span> <span class="nv">context</span><span class="p">)</span>
                      <span class="o">,</span><span class="p">(</span><span class="nv">parse</span> <span class="nv">t2</span> <span class="nv">context</span><span class="p">)))</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">stuff</span><span class="p">)</span> <span class="p">(</span><span class="nv">parse</span> <span class="nv">stuff</span> <span class="nv">context</span><span class="p">))</span>
    <span class="p">((</span><span class="nv">pred</span> <span class="nf">symbolp</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">cl-labels</span> <span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">a</span> <span class="p">(</span><span class="nv">var-name</span> <span class="nv">b</span><span class="p">))))</span>
       <span class="o">`</span><span class="p">(</span><span class="nv">Var</span> <span class="o">,</span><span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">cl-position</span> <span class="p">(</span><span class="nf">symbol-name</span> <span class="nv">term</span><span class="p">)</span> <span class="nv">context</span> <span class="nb">:test</span> <span class="nf">#&#39;</span><span class="nv">f</span><span class="p">)</span>
                  <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;No previous declaration: %s&#34;</span> <span class="nv">term</span><span class="p">))</span>
             <span class="o">,</span><span class="p">(</span><span class="nf">length</span> <span class="nv">context</span><span class="p">))))</span>
    <span class="p">(</span><span class="nv">_</span> <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;No matching pattern: %s&#34;</span> <span class="nv">term</span><span class="p">))))</span></code></pre></div><p>同样，在scratch buffer里试试：</p><div class="highlight"><pre><code class="language-emacs"><span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">λ</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
<span class="s">&#34;λx.x&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">λ</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))))</span>
<span class="s">&#34;λx.λy.xy&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(((</span><span class="nv">λ</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)))))</span>
<span class="s">&#34;(λx.λy.xy)λx.x&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">λ</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))))</span>
<span class="s">&#34;λx.λx&#39;.x&#39;x&#39;&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">λ</span> <span class="nv">x</span> <span class="p">((</span><span class="nv">λ</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span>
<span class="s">&#34;λx.(λx&#39;.x&#39;)x&#34;</span></code></pre></div><p>还可以看看de Bruijin index</p><div class="highlight"><pre><code class="language-emacs"><span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">λ</span> <span class="nv">x</span> <span class="p">((</span><span class="nv">λ</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
<span class="s">&#34;λ.(λ.0)0&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">λ</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
<span class="s">&#34;λ.λ.10&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">λ</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">z</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">z</span><span class="p">))))</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
<span class="s">&#34;λ.λ.λ.(21)0&#34;</span></code></pre></div><h2>Shift &amp; substitution</h2><p>书里用了一个本地的匿名函数（所以省略了 <code>d</code> ），我觉得分开写更清楚。基本上把书里shift和substitution的规则转化成代码就好了。</p><div class="highlight"><pre><code class="language-emacs"><span class="p">(</span><span class="nb">defun</span> <span class="nv">shift</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">term</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">shift1</span> <span class="mi">0</span> <span class="nv">d</span> <span class="nv">term</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">shift1</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span> <span class="nv">term</span><span class="p">)</span>
  <span class="s">&#34;Shift up D for indexes &gt;= C in TERM.&#34;</span>
  <span class="p">(</span><span class="nb">pcase</span> <span class="nv">term</span>
    <span class="c1">;; when we shift up, that always means we are put into another</span>
    <span class="c1">;; layer of abstraction, so size + 1</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">Var</span> <span class="o">,</span><span class="nv">idx</span> <span class="o">,</span><span class="nv">size</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;=</span> <span class="nv">idx</span> <span class="nv">c</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nv">Var</span> <span class="o">,</span><span class="p">(</span><span class="nf">+</span> <span class="nv">idx</span> <span class="nv">d</span><span class="p">)</span> <span class="o">,</span><span class="p">(</span><span class="nf">+</span> <span class="nv">size</span> <span class="nv">d</span><span class="p">))</span>
       <span class="o">`</span><span class="p">(</span><span class="nv">Var</span> <span class="o">,</span><span class="nv">idx</span> <span class="o">,</span><span class="p">(</span><span class="nf">+</span> <span class="nv">size</span> <span class="nv">d</span><span class="p">))))</span>
    <span class="c1">;; go into one more layer of abstraction, c+1</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">Abs</span> <span class="o">,</span><span class="nv">body</span> <span class="o">,</span><span class="nv">var</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nv">Abs</span> <span class="o">,</span><span class="p">(</span><span class="nv">shift1</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span> <span class="nv">body</span><span class="p">)</span> <span class="o">,</span><span class="nv">var</span><span class="p">))</span>
    <span class="c1">;; simply recurs</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="nv">t1</span> <span class="o">,</span><span class="nv">t2</span><span class="p">)</span> <span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="p">(</span><span class="nv">shift1</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">t1</span><span class="p">)</span>
                          <span class="o">,</span><span class="p">(</span><span class="nv">shift1</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">t2</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">_</span> <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;No matching pattern: %s&#34;</span> <span class="nv">term</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">subst</span> <span class="p">(</span><span class="nv">j</span> <span class="nv">s</span> <span class="nv">term</span><span class="p">)</span>
  <span class="s">&#34;Substitute J with S in TERM.
</span><span class="s">I.e. “[j → s] t”.&#34;</span>
  <span class="p">(</span><span class="nb">pcase</span> <span class="nv">term</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">Var</span> <span class="o">,</span><span class="nv">index</span> <span class="o">,</span><span class="nv">size</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">index</span> <span class="nv">j</span><span class="p">)</span> <span class="nv">s</span> <span class="nv">term</span><span class="p">))</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">Abs</span> <span class="o">,</span><span class="nv">body</span> <span class="o">,</span><span class="nv">var</span><span class="p">)</span>
     <span class="o">`</span><span class="p">(</span><span class="nv">Abs</span> <span class="o">,</span><span class="p">(</span><span class="nv">subst</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">j</span><span class="p">)</span> <span class="p">(</span><span class="nv">shift</span> <span class="mi">1</span> <span class="nv">s</span><span class="p">)</span> <span class="nv">body</span><span class="p">)</span> <span class="o">,</span><span class="nv">var</span><span class="p">))</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="nv">t1</span> <span class="o">,</span><span class="nv">t2</span><span class="p">)</span>
     <span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="p">(</span><span class="nv">subst</span> <span class="nv">j</span> <span class="nv">s</span> <span class="nv">t1</span><span class="p">)</span> <span class="o">,</span><span class="p">(</span><span class="nv">subst</span> <span class="nv">j</span> <span class="nv">s</span> <span class="nv">t2</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">_</span> <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;No matching pattern: %s&#34;</span> <span class="nv">term</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">beta</span> <span class="p">(</span><span class="nv">t1</span> <span class="nv">v</span><span class="p">)</span>
  <span class="s">&#34;Perform β-reduction.
</span><span class="s">T1 is body of function, V is argument.&#34;</span>
  <span class="p">(</span><span class="nb">pcase</span> <span class="nv">t1</span>
    <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">Abs</span> <span class="o">,</span><span class="nv">body</span> <span class="o">,</span><span class="nv">_</span><span class="p">)</span> <span class="p">(</span><span class="nv">shift</span> <span class="mi">-1</span> <span class="p">(</span><span class="nv">subst</span> <span class="mi">0</span> <span class="p">(</span><span class="nv">shift</span> <span class="mi">1</span> <span class="nv">v</span><span class="p">)</span> <span class="nv">body</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">_</span> <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;No matching pattern: %s&#34;</span> <span class="nv">t1</span><span class="p">))))</span></code></pre></div><p>TAPL把shift和substitution抽象成一个，不太好理解。所以我就没费劲，还是写成两个。</p><h2>Evaluation</h2><p>同样，基本上是TAPL里三个evaluation规则的直译：</p><div class="highlight"><pre><code class="language-emacs"><span class="p">(</span><span class="nb">defun</span> <span class="nv">eval1</span> <span class="p">(</span><span class="nv">term</span> <span class="kp">&amp;optional</span> <span class="nv">step</span> <span class="nv">context</span><span class="p">)</span>
  <span class="s">&#34;Evaluate TERM in CONTEXT.
</span><span class="s">STEP, if non-nil, is the number of steps to evaluate.&#34;</span>
  <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">step</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">step</span> <span class="nv">1.0e+INF</span><span class="p">)))</span>
    <span class="c1">;; t := var | abs | app</span>
    <span class="c1">;; v := abs</span>
    <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&lt;=</span> <span class="nv">step</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nv">term</span>
      <span class="p">(</span><span class="nb">pcase</span> <span class="nv">term</span>
        <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">Var</span> <span class="o">.</span> <span class="o">,</span><span class="nv">_</span><span class="p">)</span> <span class="nv">term</span><span class="p">)</span>
        <span class="p">(</span><span class="o">`</span><span class="p">(</span><span class="nv">Abs</span> <span class="o">.</span> <span class="o">,</span><span class="nv">_</span><span class="p">)</span> <span class="nv">term</span><span class="p">)</span>
        <span class="c1">;; first reduce t1 to a value</span>
        <span class="p">((</span><span class="nb">and</span> <span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="nv">t1</span> <span class="o">,</span><span class="nv">t2</span><span class="p">)</span> <span class="p">(</span><span class="nv">guard</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nv">valuep</span> <span class="nv">t1</span><span class="p">))))</span>
         <span class="p">(</span><span class="nv">eval1</span> <span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="p">(</span><span class="nv">eval1</span> <span class="nv">t1</span> <span class="nv">step</span> <span class="nv">context</span><span class="p">)</span> <span class="o">,</span><span class="nv">t2</span><span class="p">)</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">step</span><span class="p">)</span> <span class="nv">context</span><span class="p">))</span>
        <span class="c1">;; then reduce t2 to a value</span>
        <span class="p">((</span><span class="nb">and</span> <span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="nv">t1</span> <span class="o">,</span><span class="nv">t2</span><span class="p">)</span> <span class="p">(</span><span class="nv">guard</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nv">valuep</span> <span class="nv">t2</span><span class="p">))))</span>
         <span class="p">(</span><span class="nv">eval1</span> <span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="nv">t1</span> <span class="o">,</span><span class="p">(</span><span class="nv">eval1</span> <span class="nv">t2</span> <span class="nv">step</span> <span class="nv">context</span><span class="p">))</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">step</span><span class="p">)</span> <span class="nv">context</span><span class="p">))</span>
        <span class="c1">;; finally apply</span>
        <span class="p">((</span><span class="nb">and</span> <span class="o">`</span><span class="p">(</span><span class="nv">App</span> <span class="o">,</span><span class="nv">t1</span> <span class="o">,</span><span class="nv">t2</span><span class="p">)</span> <span class="p">(</span><span class="nv">guard</span> <span class="p">(</span><span class="nv">valuep</span> <span class="nv">t1</span><span class="p">))</span> <span class="p">(</span><span class="nv">guard</span> <span class="p">(</span><span class="nv">valuep</span> <span class="nv">t2</span><span class="p">)))</span>
         <span class="p">(</span><span class="nv">eval1</span> <span class="p">(</span><span class="nv">beta</span> <span class="nv">t1</span> <span class="nv">t2</span><span class="p">)</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">step</span><span class="p">)</span> <span class="nv">context</span><span class="p">))</span>
        <span class="c1">;; no more to apply</span>
        <span class="p">(</span><span class="nv">_</span> <span class="nv">term</span><span class="p">)))))</span></code></pre></div><p>如果是Typed lambda calculus，遇到最后没有下一步可走的情况应该报错，但是这里只是停止。来试几个简单的例子：</p><div class="highlight"><pre><code class="language-emacs"><span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">λ</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">))))</span>
<span class="s">&#34;(λx.x)λy.y&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">eval1</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">λ</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">)))))</span>
<span class="s">&#34;λy.y&#34;</span>

<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(((</span><span class="nv">λ</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">n</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">m</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)))</span> <span class="p">((</span><span class="nv">λ</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">z</span> <span class="nv">z</span><span class="p">)))))</span>
<span class="s">&#34;((λx.x)λn.λm.mn)((λy.y)λz.z)&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">eval1</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(((</span><span class="nv">λ</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">n</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">m</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)))</span> <span class="p">((</span><span class="nv">λ</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">z</span> <span class="nv">z</span><span class="p">))))</span> <span class="mi">1</span><span class="p">))</span>
<span class="s">&#34;(λn.λm.mn)((λy.y)λz.z)&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">eval1</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(((</span><span class="nv">λ</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">n</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">m</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)))</span> <span class="p">((</span><span class="nv">λ</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">z</span> <span class="nv">z</span><span class="p">))))</span> <span class="mi">2</span><span class="p">))</span>
<span class="s">&#34;(λn.λm.mn)λz.z&#34;</span>
<span class="p">(</span><span class="nv">show</span> <span class="p">(</span><span class="nv">eval1</span> <span class="p">(</span><span class="nv">parse</span> <span class="o">&#39;</span><span class="p">(((</span><span class="nv">λ</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">n</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">m</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)))</span> <span class="p">((</span><span class="nv">λ</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">λ</span> <span class="nv">z</span> <span class="nv">z</span><span class="p">))))</span> <span class="mi">3</span><span class="p">))</span>
<span class="s">&#34;λm.mλz.z&#34;</span></code></pre></div><p>感觉没问题，如果读者有发现错误，请不吝赐教。</p>