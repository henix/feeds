<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Haskell 中的“定理证明”</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/31567423">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-24cc9824870cdcc4194b2c0ec0097d23_b.jpg" alt=""></div><p>题图：鲸 | 花生( •̀ ω •́ ) [pixiv] <a href="http://link.zhihu.com/?target=https%3A//www.pixiv.net/member_illust.php%3Fmode%3Dmedium%26illust_id%3D66023124" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">pixiv.net/member_illust</span><span class="invisible">.php?mode=medium&amp;illust_id=66023124</span><span class="ellipsis"></span></a></p><h2><b>这篇文章讲了什么</b></h2><p><i>这是一篇休闲向文章</i></p><p>总结了 Codewars 上面的几道证明题的思想并加以延拓，希望读者能在看完这篇文章之前/之后解决练习中的题目。</p><p><br></p><p>下面是正文</p><hr><p>众所周知，Haskell 并没有真正意义上的 dependent type，但通过一些技巧 （利用GADT）可以“模拟”dependent type，并可以通过其证明一些定理。</p><h2><b>利用 GADT 模拟 Dependent Type</b></h2><p>首先我们需要作为<b>值</b>的类型</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Z</span>
 <span class="kr">data</span> <span class="kt">S</span> <span class="n">n</span>
</code></pre></div><p>注意到，这里的 <code>Z</code> 和 <code>S</code>n 都只是单纯的类型，你甚至不能构造出相应类型的值出来。</p><p>所以我们需要把它们与实际存在的值联系起来</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Nat</span> <span class="n">a</span> <span class="kr">where</span>
      <span class="kt">Zero</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="kt">Z</span>
      <span class="kt">Succ</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="p">(</span><span class="kt">S</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>于是我们有</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">))</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))</span>
</code></pre></div><p>这样我们获得了在类型层次上的自然数，并保持了它与实际的值的同构关系。</p><p>光有自然数是没有意义的，我们需要赋予它们运算的能力。</p><p>那么 <code>Nat n</code> 与 <code>Nat m</code> 相加的结果应该是什么呢？</p><p>首先它应该是一个 <code>Nat</code> ，其次它的类型应该对应于两数相加的结果。</p><p>借助于 GHC 的 Type Family 与 Type Operator 扩展，我们可以定义出 合理的 类型层面上的自然数的加法与乘法</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="kr">type</span> <span class="kr">family</span> <span class="p">(</span><span class="kt">:+:</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Z</span>   <span class="kt">:+:</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">S</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">S</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:+:</span> <span class="n">m</span><span class="p">)</span>
  
  <span class="kr">type</span> <span class="kr">family</span> <span class="p">(</span><span class="kt">:*:</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Z</span>   <span class="kt">:*:</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">Z</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">S</span> <span class="n">n</span> <span class="kt">:*:</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="kt">:+:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:*:</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div><p>然后是数据层面的自然数</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="kr">infixl</span> <span class="mi">4</span> <span class="o">+</span>
  <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:+:</span> <span class="n">m</span><span class="p">)</span>
  <span class="kt">Zero</span> <span class="o">+</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span>
  <span class="p">(</span><span class="kt">Succ</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Succ</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span>
  
  <span class="kr">infixl</span> <span class="mi">5</span> <span class="o">*</span>
  <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:*:</span> <span class="n">m</span><span class="p">)</span>
  <span class="kt">Zero</span> <span class="o">*</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Zero</span>
  <span class="p">(</span><span class="kt">Succ</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">m</span>
</code></pre></div><p>有</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">))</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))))</span>
</code></pre></div><p>基于类型上的自然数，我们可以定义 <code>Vec</code> (在类型中包含了长度信息的 <code>List</code>)了</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="kr">data</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="n">n</span> <span class="kr">where</span>
      <span class="kt">VNil</span> <span class="ow">::</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="kt">Z</span>
      <span class="kt">VCons</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div><p>长度为 <code>n</code> 的 <code>Vec</code> 与长度为 <code>m</code> 的 <code>Vec</code> 连接起来之后的长度为 <code>n + m</code></p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:+:</span> <span class="n">m</span><span class="p">)</span>
  <span class="kt">VNil</span> <span class="o">++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">ys</span>
  <span class="kt">VCons</span> <span class="n">x</span> <span class="n">xs</span> <span class="o">++</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">VCons</span> <span class="n">x</span> <span class="p">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div><p>把长度为 <code>m</code> 的 <code>Vec</code> 重复 <code>n</code> 次之后得到的 <code>Vec</code> 的长度为 <code>n * m</code></p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">repeat</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:*:</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">repeat</span> <span class="kt">Zero</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">VNil</span>
  <span class="n">repeat</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">xs</span> <span class="o">++</span> <span class="n">repeat</span> <span class="n">x</span> <span class="n">xs</span>
</code></pre></div><p>有了长度信息，就有类型安全的 <code>head</code> 和 <code>tail</code> 了</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">headV</span> <span class="ow">::</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
  <span class="n">headV</span> <span class="p">(</span><span class="kt">VCons</span> <span class="n">x</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
  
  <span class="n">tailV</span> <span class="ow">::</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="n">n</span>
  <span class="n">tailV</span> <span class="p">(</span><span class="kt">VCons</span> <span class="kr">_</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">xs</span>
</code></pre></div><p>因为 <code>Vec</code> 作为 GADT 的类型在这里受到了第二个类型参数为 <code>S n</code> 的束缚，所以可以保证这里的 <code>Vec</code> 不会是 <code>VNil</code> ，这两个函数都是 <b>完全</b> 的。</p><p>借鉴之前定义类型层面上自然数的加法与乘法的思想，我们可以定义相应的减法、求最大值、最小值等。</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="kr">type</span> <span class="kr">family</span> <span class="p">(</span><span class="kt">:-:</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="n">n</span> <span class="kt">:-:</span> <span class="kt">Z</span> <span class="ow">=</span> <span class="n">n</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Z</span> <span class="kt">:-:</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">Z</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">S</span> <span class="n">n</span> <span class="kt">:-:</span> <span class="kt">S</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">n</span> <span class="kt">:-:</span> <span class="n">m</span>
  
  <span class="kr">type</span> <span class="kr">family</span> <span class="p">(</span><span class="kt">:^:</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Z</span> <span class="kt">:^:</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="n">n</span> <span class="kt">:^:</span> <span class="kt">Z</span> <span class="ow">=</span> <span class="n">n</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">S</span> <span class="n">n</span> <span class="kt">:^:</span> <span class="kt">S</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">S</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:^:</span> <span class="n">m</span><span class="p">)</span>
  
  <span class="kr">type</span> <span class="kr">family</span> <span class="p">(</span><span class="kt">:~:</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Z</span> <span class="kt">:~:</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">Z</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="n">n</span> <span class="kt">:~:</span> <span class="kt">Z</span> <span class="ow">=</span> <span class="kt">Z</span>
  <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">S</span> <span class="n">n</span> <span class="kt">:~:</span> <span class="kt">S</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">S</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:~:</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div><p>(这里使用了 <code>:~:</code> 和 <code>:^:</code> 分别代表求最大值和最小值)</p><p>于是有</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">zip</span> <span class="ow">::</span> <span class="kt">Vec</span> <span class="n">a</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">Vec</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:~:</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">zip</span> <span class="kt">VNil</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">VNil</span>
  <span class="n">zip</span> <span class="kr">_</span> <span class="kt">VNil</span> <span class="ow">=</span> <span class="kt">VNil</span>
  <span class="n">zip</span> <span class="p">(</span><span class="kt">VCons</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="kt">VCons</span> <span class="n">y</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">VCons</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="n">zip</span> <span class="n">xs</span> <span class="n">ys</span><span class="p">)</span>
</code></pre></div><h2><b>进行简单的定理证明</b></h2><p><code>Haskell</code> 中没有 Prop ，所以我们得从头开始描述“相等”这个概念。</p><p>首先定义代表两个类型层面的自然数相等的类型</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Equal</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
      <span class="kt">EqZ</span> <span class="ow">::</span> <span class="kt">Equal</span> <span class="kt">Z</span> <span class="kt">Z</span>
      <span class="kt">EqS</span> <span class="ow">::</span> <span class="kt">Equal</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Equal</span> <span class="p">(</span><span class="kt">S</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">S</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div><p>借助于 Type Operator 我们可以写成</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">type</span> <span class="n">a</span> <span class="o">===</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Equal</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div><p>相等关系具有自反性</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">refl</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="o">===</span> <span class="n">n</span>
  <span class="n">refl</span> <span class="kt">Zero</span> <span class="ow">=</span> <span class="kt">EqZ</span>
  <span class="n">refl</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">EqS</span> <span class="o">$</span> <span class="n">refl</span> <span class="n">x</span>
</code></pre></div><p>相等关系具有对称性</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">symm</span> <span class="ow">::</span> <span class="n">a</span> <span class="o">===</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="o">===</span> <span class="n">a</span>
  <span class="n">symm</span> <span class="kt">EqZ</span> <span class="ow">=</span> <span class="kt">EqZ</span>
  <span class="n">symm</span> <span class="p">(</span><span class="kt">EqS</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">EqS</span> <span class="o">$</span> <span class="n">symm</span> <span class="n">x</span>
</code></pre></div><p>相等关系具有传递性</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="p">(</span><span class="o">&lt;=&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="o">===</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="o">===</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">===</span> <span class="n">c</span>
  <span class="kt">EqZ</span> <span class="o">&lt;=&gt;</span> <span class="kt">EqZ</span> <span class="ow">=</span> <span class="kt">EqZ</span>
  <span class="kt">EqS</span> <span class="n">x</span> <span class="o">&lt;=&gt;</span> <span class="kt">EqS</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">EqS</span> <span class="o">$</span> <span class="n">x</span> <span class="o">&lt;=&gt;</span> <span class="n">y</span>
</code></pre></div><p>因为 Type Operator 也能定义优先级，所以下面给出：</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="kr">infixl</span> <span class="mi">2</span> <span class="o">===</span>
  <span class="kr">infixl</span> <span class="mi">4</span> <span class="kt">:+:</span>
  <span class="kr">infixr</span> <span class="mi">4</span> <span class="kt">:-:</span>
  <span class="kr">infixl</span> <span class="mi">5</span> <span class="kt">:*:</span>
</code></pre></div><p> 来减少括号的个数</p><h2>加法结合律</h2><p>那么我们来试着证明一下加法的结合律</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">plusComb</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">p</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:+:</span> <span class="n">p</span><span class="p">)</span> <span class="o">===</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="n">m</span> <span class="kt">:+:</span> <span class="n">p</span>
</code></pre></div><p>我们对 <code>n</code> 进行归纳：</p><p> 当 <code>n</code> 为 0 的时，在加法中的 0 会直接消除，所以使用 <code>refl (m + p)</code> 就好了；</p><p> 当 <code>n</code> 为 <code>S n1</code> 时，把等式两边的 S 用 <code>EqS</code> 提取出来，再使用归纳假设就可以了：</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">plusComb</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">p</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:+:</span> <span class="n">p</span><span class="p">)</span> <span class="o">===</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="n">m</span> <span class="kt">:+:</span> <span class="n">p</span>
  <span class="n">plusComb</span> <span class="kt">Zero</span> <span class="n">p</span> <span class="n">q</span> <span class="ow">=</span> <span class="n">refl</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">)</span>
  <span class="n">plusComb</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">m</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">EqS</span> <span class="o">$</span> <span class="n">plusComb</span> <span class="n">n</span> <span class="n">m</span> <span class="n">p</span>
</code></pre></div><h2>加法交换律</h2><p>那么再尝试一下稍微困难一点的加法交换律吧</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">plusCommutes</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="n">m</span> <span class="o">===</span> <span class="n">m</span> <span class="kt">:+:</span> <span class="n">n</span>
</code></pre></div><p>当 <code>m</code> 为 0 的时，证明很平凡。我们需要的是这么一个类型：</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="kt">Z</span> <span class="o">===</span> <span class="n">n</span>
</code></pre></div><p>只需要对 n 进行归纳就好了。</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">nPlusZero</span> <span class="ow">::</span> <span class="n">n</span> <span class="o">===</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="o">===</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="kt">Z</span>
  <span class="n">nPlusZero</span> <span class="kt">EqZ</span>        <span class="ow">=</span> <span class="kt">EqZ</span>
  <span class="n">nPlusZero</span> <span class="p">(</span><span class="kt">EqS</span> <span class="n">eq</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">EqS</span> <span class="o">$</span> <span class="n">nPlusZero</span> <span class="n">eq</span>
</code></pre></div><p>当 <code>m</code> 为 <code>S m1</code> 时，我们需要的东西的类型为</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="p">(</span><span class="n">n</span> <span class="kt">:+:</span> <span class="kt">S</span> <span class="n">m1</span><span class="p">)</span> <span class="o">===</span> <span class="kt">S</span> <span class="p">(</span><span class="n">m1</span> <span class="kt">:+:</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div><p>根据归纳法，我们可以得到</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kt">EqS</span> <span class="p">(</span><span class="n">plusCommutes</span> <span class="n">n</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">S</span> <span class="p">(</span><span class="n">m1</span> <span class="kt">:+:</span> <span class="n">n</span><span class="p">)</span> <span class="o">===</span> <span class="kt">S</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:+:</span> <span class="n">m1</span><span class="p">)</span>
</code></pre></div><p>借助于相等关系的传递性，目标变成了</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="p">(</span><span class="n">n</span> <span class="kt">:+:</span> <span class="kt">S</span> <span class="n">m1</span><span class="p">)</span> <span class="o">===</span> <span class="kt">S</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:+:</span> <span class="n">m1</span><span class="p">)</span>
</code></pre></div><p>而这个命题的证明也只需要对 <code>n</code> 进行归纳</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">nPlusSm</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="kt">S</span> <span class="n">m</span> <span class="o">===</span> <span class="kt">S</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:+:</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">nPlusSm</span> <span class="kt">Zero</span>      <span class="n">m</span> <span class="ow">=</span> <span class="kt">EqS</span> <span class="o">$</span> <span class="n">refl</span> <span class="n">m</span>
  <span class="n">nPlusSm</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">EqS</span> <span class="o">$</span> <span class="n">nPlusSm</span> <span class="n">n</span> <span class="n">m</span>
</code></pre></div><p>把这些步骤拼起来，就得到了我们最终的证明</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">plus2</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="n">m</span> <span class="o">===</span> <span class="n">m</span> <span class="kt">:+:</span> <span class="n">n</span>
  <span class="n">plus2</span> <span class="n">n</span> <span class="kt">Zero</span> <span class="ow">=</span> <span class="n">symm</span> <span class="o">$</span> <span class="n">nPlusZero</span> <span class="o">$</span> <span class="n">refl</span> <span class="n">n</span>
  <span class="n">plus2</span> <span class="n">n</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="n">nPlusSm</span> <span class="n">n</span> <span class="n">m</span> <span class="o">&lt;=&gt;</span> <span class="n">symm</span> <span class="p">(</span><span class="kt">EqS</span> <span class="o">$</span> <span class="n">plus2</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div><h2>乘法交换律</h2><p>看了加法我们再来看乘法</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">multCommute</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="kt">:*:</span> <span class="n">m</span> <span class="o">===</span> <span class="n">m</span> <span class="kt">:*:</span> <span class="n">n</span>
</code></pre></div><p>证明的方法和加法几乎一样，仍然从归纳法入手，对 n 进行归纳。中间需要用到一些引理，比如</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">multCommuteS</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">:*:</span> <span class="kt">S</span> <span class="n">n</span> <span class="o">===</span> <span class="n">m</span> <span class="kt">:+:</span> <span class="n">m</span> <span class="kt">:*:</span> <span class="n">n</span>
  <span class="n">plusSwap</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="kt">:+:</span> <span class="p">(</span><span class="n">b</span> <span class="kt">:+:</span> <span class="n">c</span><span class="p">)</span> <span class="o">===</span> <span class="n">b</span> <span class="kt">:+:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:+:</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div><p>等等，这里不再详细说明具体的推导，直接给出实现，有兴趣的同学可以试着自己写一遍</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">equalPlus</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">===</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="kt">:+:</span> <span class="n">c</span> <span class="o">===</span> <span class="n">b</span> <span class="kt">:+:</span> <span class="n">c</span>
 <span class="n">equalPlus</span> <span class="n">a</span> <span class="n">b</span> <span class="n">eq</span> <span class="kt">Zero</span> <span class="ow">=</span> <span class="n">symm</span> <span class="p">(</span><span class="n">nPlusZero</span> <span class="n">a</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="n">eq</span> <span class="o">&lt;=&gt;</span> <span class="n">nPlusZero</span> <span class="n">b</span>
 <span class="n">equalPlus</span> <span class="n">a</span> <span class="n">b</span> <span class="n">eq</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=</span> <span class="n">nPlusSm</span> <span class="n">a</span> <span class="n">c</span> <span class="o">&lt;=&gt;</span> <span class="kt">Fuck</span> <span class="p">(</span><span class="n">equalPlus</span> <span class="n">a</span> <span class="n">b</span> <span class="n">eq</span> <span class="n">c</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="n">symm</span> <span class="p">(</span><span class="n">nPlusSm</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
  
 <span class="n">equalPlus'</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">===</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="kt">:+:</span> <span class="n">a</span> <span class="o">===</span> <span class="n">c</span> <span class="kt">:+:</span> <span class="n">b</span>
 <span class="n">equalPlus'</span> <span class="n">a</span> <span class="n">b</span> <span class="n">eq</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">plusCommutes</span> <span class="n">c</span> <span class="n">a</span> <span class="o">&lt;=&gt;</span> <span class="n">equalPlus</span> <span class="n">a</span> <span class="n">b</span> <span class="n">eq</span> <span class="n">c</span> <span class="o">&lt;=&gt;</span> <span class="n">plusCommutes</span> <span class="n">b</span> <span class="n">c</span>
  
 <span class="n">plusSwap'</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="kt">:+:</span> <span class="n">b</span> <span class="kt">:+:</span> <span class="n">c</span> <span class="o">===</span> <span class="n">b</span> <span class="kt">:+:</span> <span class="n">a</span> <span class="kt">:+:</span> <span class="n">c</span>
 <span class="n">plusSwap'</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">equalPlus</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">plusCommutes</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
  
 <span class="n">plusSwap</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="kt">:+:</span> <span class="p">(</span><span class="n">b</span> <span class="kt">:+:</span> <span class="n">c</span><span class="p">)</span> <span class="o">===</span> <span class="n">b</span> <span class="kt">:+:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:+:</span> <span class="n">c</span><span class="p">)</span>
 <span class="n">plusSwap</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">plusCommute</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">&lt;=&gt;</span> <span class="n">plusSwap'</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">&lt;=&gt;</span> <span class="n">symm</span> <span class="p">(</span><span class="n">plusCommute</span> <span class="n">b</span> <span class="n">a</span> <span class="n">c</span><span class="p">)</span>
  
 <span class="n">multCommuteS_1</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="kt">:+:</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:*:</span> <span class="kt">S</span> <span class="n">n</span><span class="p">)</span> <span class="o">===</span> <span class="n">m</span> <span class="kt">:+:</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:+:</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:*:</span> <span class="n">n</span><span class="p">))</span>
 <span class="n">multCommuteS_1</span> <span class="n">n</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">equalPlus'</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="kt">Succ</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">multCommuteS</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span> <span class="n">n</span> <span class="o">&lt;=&gt;</span> <span class="n">plusSwap</span> <span class="n">n</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
  
 <span class="n">multCommuteS</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">:*:</span> <span class="kt">S</span> <span class="n">n</span> <span class="o">===</span> <span class="n">m</span> <span class="kt">:+:</span> <span class="n">m</span> <span class="kt">:*:</span> <span class="n">n</span>
 <span class="n">multCommuteS</span> <span class="kr">_</span> <span class="kt">Zero</span> <span class="ow">=</span> <span class="kt">Refl</span>
 <span class="n">multCommuteS</span> <span class="n">n</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Fuck</span> <span class="o">$</span> <span class="n">multCommuteS_1</span> <span class="n">n</span> <span class="n">m</span>
  
 <span class="n">multCommutes</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="kt">:*:</span> <span class="n">m</span> <span class="o">===</span> <span class="n">m</span> <span class="kt">:*:</span> <span class="n">n</span>
 <span class="n">multCommutes</span> <span class="kt">Zero</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">symm</span> <span class="o">$</span> <span class="n">multNZero</span> <span class="n">m</span>
 <span class="n">multCommutes</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">symm</span>
      <span class="p">(</span><span class="n">multCommuteS</span> <span class="n">n</span> <span class="n">m</span> <span class="o">&lt;=&gt;</span> <span class="n">equalPlus'</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">multCommutes</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div><h2><b>从自然数说开去</b></h2><p>我们在上面定义的“相等”中，只对自然数进行了规定，那么我们怎么表示任何一种东西相等的概念呢？我们需要对 <code>Equal</code> 进行修改。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Equal</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
      <span class="kt">Refl</span> <span class="ow">::</span> <span class="kt">Equal</span> <span class="n">a</span> <span class="n">a</span>
      <span class="kt">Derive</span> <span class="ow">::</span> <span class="kt">Equal</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Equal</span> <span class="p">(</span><span class="n">p</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div><p><code>Refl</code> 对应之前的 <code>EqZ</code> , <code>Derive</code> 对应 <code>EqS</code> 。从定义上我们就能知道相等关系的自反性。</p><p>重新定义之后，我们就再也不需要 <code>refl</code> 这个函数了，因为直接使用 <code>Refl</code> 就可以了。</p><p><code>symm</code> 的定义和原来类似，<code>trans</code> 则需要一点小小的修改：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="p">(</span><span class="o">&lt;=&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="o">===</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="o">===</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">===</span> <span class="n">c</span>
 <span class="kt">Refl</span>        <span class="o">&lt;=&gt;</span> <span class="kt">Refl</span>        <span class="ow">=</span> <span class="kt">Refl</span>
 <span class="kt">Derive</span> <span class="n">x</span> <span class="o">&lt;=&gt;</span> <span class="kt">Refl</span>        <span class="ow">=</span> <span class="kt">Derive</span> <span class="o">$</span> <span class="n">x</span>      <span class="o">&lt;=&gt;</span> <span class="kt">Refl</span>
 <span class="kt">Refl</span>        <span class="o">&lt;=&gt;</span> <span class="kt">Derive</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Derive</span> <span class="o">$</span> <span class="kt">Refl</span> <span class="o">&lt;=&gt;</span> <span class="n">y</span>
 <span class="kt">Derive</span> <span class="n">x</span> <span class="o">&lt;=&gt;</span> <span class="kt">Derive</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Derive</span> <span class="o">$</span> <span class="n">x</span>      <span class="o">&lt;=&gt;</span> <span class="n">y</span>
</code></pre></div><p>为了证明我们定义的 <code>Equal</code> 不仅仅对自然数有用，我们引入了类型层面的 <code>Bool</code> 来增加多样性。</p><p>首先是类型定义</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">T</span>
<span class="kr">data</span> <span class="kt">F</span>
</code></pre></div><p>然后是对应的数据类型</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Boolean</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="kr">where</span>
      <span class="kt">Tr</span> <span class="ow">::</span> <span class="kt">Boolean</span> <span class="kt">T</span>
      <span class="kt">Fa</span> <span class="ow">::</span> <span class="kt">Boolean</span> <span class="kt">F</span>
</code></pre></div><p>对于每一个需要参与证明的函数，我们需要在类型上实现一遍。</p><p>对于 <code>Boolean</code> 而言，先实现与或非 </p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">type</span> <span class="kr">family</span> <span class="kt">Inv</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Inv</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">F</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Inv</span> <span class="kt">F</span> <span class="ow">=</span> <span class="kt">T</span>
  
 <span class="kr">type</span> <span class="kr">family</span> <span class="p">(</span><span class="o">||</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">T</span> <span class="o">||</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="o">||</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">T</span> <span class="o">||</span> <span class="kt">F</span> <span class="ow">=</span> <span class="kt">T</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="o">||</span> <span class="kt">F</span> <span class="ow">=</span> <span class="kt">F</span>
  
 <span class="kr">type</span> <span class="kr">family</span> <span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">T</span> <span class="o">&amp;&amp;</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">T</span> <span class="o">&amp;&amp;</span> <span class="kt">F</span> <span class="ow">=</span> <span class="kt">F</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="o">&amp;&amp;</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">F</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">F</span> <span class="o">&amp;&amp;</span> <span class="kt">F</span> <span class="ow">=</span> <span class="kt">F</span>
</code></pre></div><p>首先证明双重否定律</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">doubleNeg</span> <span class="ow">::</span> <span class="kt">Boolean</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Inv</span> <span class="p">(</span><span class="kt">Inv</span> <span class="n">b</span><span class="p">)</span> <span class="o">===</span> <span class="n">b</span>
  <span class="n">doubleNeg</span> <span class="kt">Tr</span> <span class="ow">=</span> <span class="kt">Refl</span>
  <span class="n">doubleNeg</span> <span class="kt">Fa</span> <span class="ow">=</span> <span class="kt">Refl</span>
</code></pre></div><p>要注意的是，这里并不能把两个分支合在一起写，因为它并不能直接把 <code>Inv (Inv b)</code> 推导到 <code>b</code></p><p>然后是德摩根律</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">demorgan</span> <span class="ow">::</span> <span class="kt">Boolean</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Boolean</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Inv</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">===</span> <span class="kt">Inv</span> <span class="n">a</span> <span class="o">||</span> <span class="kt">Inv</span> <span class="n">b</span>
 <span class="n">demorgan</span> <span class="kt">Tr</span> <span class="kt">Tr</span> <span class="ow">=</span> <span class="kt">Refl</span>
 <span class="n">demorgan</span> <span class="kt">Tr</span> <span class="kt">Fa</span> <span class="ow">=</span> <span class="kt">Refl</span>
 <span class="n">demorgan</span> <span class="kt">Fa</span> <span class="kt">Tr</span> <span class="ow">=</span> <span class="kt">Refl</span>
 <span class="n">demorgan</span> <span class="kt">Fa</span> <span class="kt">Fa</span> <span class="ow">=</span> <span class="kt">Refl</span>
</code></pre></div><p>仍然要进行详细的分类讨论，理由同上</p><p><br></p><p>同样的，我们还能利用 Type Family 描述一些性质 ，比如自然数的奇偶性</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">type</span> <span class="kr">family</span> <span class="kt">IsOdd</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">IsOdd</span> <span class="kt">Z</span> <span class="ow">=</span> <span class="kt">F</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">IsOdd</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">T</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">IsOdd</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">IsOdd</span> <span class="n">n</span>
  
 <span class="kr">type</span> <span class="kr">family</span> <span class="kt">IsEven</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="o">*</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">IsEven</span> <span class="kt">Z</span> <span class="ow">=</span> <span class="kt">T</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">IsEven</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">F</span>
 <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">IsEven</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">IsEven</span> <span class="n">n</span>
</code></pre></div><p>试着证明一下：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">oddPlus</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">IsOdd</span> <span class="p">(</span><span class="n">n</span> <span class="kt">:+:</span> <span class="n">m</span><span class="p">)</span> <span class="o">===</span> <span class="kt">IsOdd</span> <span class="n">n</span> <span class="o">^</span> <span class="kt">IsOdd</span> <span class="n">m</span>
</code></pre></div><p>因为 <code>IsEven</code> 和 <code>IsOdd</code> 的递归定义中都有两层的预设，所以我们在用归纳法证明时也需要考虑相应的 3 种情况</p><ol><li>当 <code>n</code> 为 <code>Z</code> 时</li></ol><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">oddPlus</span> <span class="kt">Zero</span> <span class="n">m</span> <span class="ow">::</span> <span class="kt">IsOdd</span> <span class="n">m</span> <span class="o">===</span> <span class="p">(</span><span class="kt">F</span> <span class="o">^</span> <span class="kt">IsOdd</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div><p>只需要实现这两个函数（它们的实现都是平凡的）</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">falseXor</span> <span class="ow">::</span> <span class="kt">Boolean</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="o">===</span> <span class="kt">F</span> <span class="o">^</span> <span class="n">b</span>
 <span class="n">isodd</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Boolean</span> <span class="p">(</span><span class="kt">IsOdd</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>就有</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">oddPlus</span> <span class="kt">Zero</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">falseXor</span> <span class="o">$</span> <span class="n">isodd</span> <span class="n">x</span>
</code></pre></div><ol><li>当 <code>n</code> 为 <code>S Z</code> 时</li></ol><p>对 <code>m</code> 进行归纳，当 <code>m</code> 为 <code>Z</code> 和 <code>S Z</code> 时，结果就是 <code>Refl</code> ，而当 <code>m</code> 为 <code>S (S m')</code> 时，我们需要的类型为</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">oddPlus</span> <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">)</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">x</span><span class="p">))</span> <span class="ow">::</span> <span class="kt">IsOdd</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n3</span><span class="p">)</span> <span class="o">===</span> <span class="p">(</span><span class="kt">T</span> <span class="o">^</span> <span class="kt">IsOdd</span> <span class="n">n3</span><span class="p">)</span>
</code></pre></div><p>同样的，只需要把它拎出去，用归纳法再证一遍就好了</p><ol><li>当 <code>n</code> 为 <code>S (S n')</code> 时</li></ol><p>我们需要的类型为：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">oddPlus</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">x</span><span class="p">))</span> <span class="n">y</span> <span class="ow">::</span> <span class="kt">IsOdd</span> <span class="p">(</span><span class="n">n2</span> <span class="kt">:+:</span> <span class="n">m</span><span class="p">)</span> <span class="o">===</span> <span class="p">(</span><span class="kt">IsOdd</span> <span class="n">n2</span> <span class="o">^</span> <span class="kt">IsOdd</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div><p>利用归纳假设就能直接证明了</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">oddPlus</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">x</span><span class="p">))</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">oddPlus</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div><h2><b>还有什么？</b></h2><p>注意到我们的很多证明，实际上都只是在类型层面的变化。比如下面这个</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">oddEvenS</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">IsOdd</span> <span class="n">n</span> <span class="o">===</span> <span class="kt">IsEven</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">)</span>
 <span class="n">oddEvenS</span> <span class="kt">Zero</span> <span class="ow">=</span> <span class="kt">Refl</span>
 <span class="n">oddEvenS</span> <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Refl</span>
 <span class="n">oddEvenS</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">x</span><span class="p">))</span> <span class="ow">=</span> <span class="n">oddEvenS</span> <span class="n">x</span>
</code></pre></div><p>把递归展开的话就能发现它所有情况下的 “值” 都是 <code>Refl</code> ，但我们不能直接对所有的情况赋 <code>Refl</code> ，因为这个递归是对 <code>Refl</code> 上的类型进行修改的过程。类型推导不会对 Type Family 中的递归定义进行展开，所以我们还是得自己动手证明一遍。</p><h2>“性质” 的表示方法</h2><p>我们使用了 <code>Equal</code> 表示两个类型相等的概念，那么同样的，我们还可以用这种方法描述其它的一元/二元/多元关系，比如我们可以换一种方式表示奇偶性：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Even</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="kr">where</span>
      <span class="kt">ZeroEven</span> <span class="ow">::</span> <span class="kt">Even</span> <span class="kt">Z</span>
      <span class="kt">Add2Even</span> <span class="ow">::</span> <span class="kt">Even</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Even</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">))</span>
  
<span class="kr">data</span> <span class="kt">Odd</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="kr">where</span>
      <span class="kt">OneOdd</span> <span class="ow">::</span> <span class="kt">Odd</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span>
      <span class="kt">Add2Odd</span> <span class="ow">::</span> <span class="kt">Odd</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Odd</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">))</span>
</code></pre></div><p>或者描述两个自然数的大小关系：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Greater</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="kr">where</span>
      <span class="kt">GreZ</span> <span class="ow">::</span> <span class="kt">Greater</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span> <span class="kt">Z</span>
      <span class="kt">GreS1</span> <span class="ow">::</span> <span class="kt">Greater</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="kt">Greater</span> <span class="p">(</span><span class="kt">S</span> <span class="n">x</span><span class="p">)</span> <span class="n">y</span>
      <span class="kt">GreS2</span> <span class="ow">::</span> <span class="kt">Greater</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="kt">Greater</span> <span class="p">(</span><span class="kt">S</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">S</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div><h2><code>Derive</code> 的局限</h2><p>事实上，我们在 <code>Equal</code> 中定义的 <code>Derive</code> 并不是万能的，比如我们不能这样</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">deriveOdd</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="o">===</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">IsOdd</span> <span class="n">n</span> <span class="o">===</span> <span class="kt">IsOdd</span> <span class="n">m</span>
 <span class="n">deriveOdd</span> <span class="kr">_</span> <span class="n">eq</span> <span class="ow">=</span> <span class="kt">Derive</span> <span class="n">eq</span> <span class="c1">-- wrong !</span>
</code></pre></div><p>报错信息为</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kt">Couldn't</span> <span class="n">match</span> <span class="kr">type</span> <span class="err">‘</span><span class="kt">IsOdd</span> <span class="n">n</span><span class="err">’</span> <span class="n">with</span> <span class="err">‘</span><span class="n">p0</span> <span class="n">n</span><span class="err">’</span>
      <span class="kt">Expected</span> <span class="kr">type</span> <span class="kt">:</span> <span class="kt">IsOdd</span> <span class="n">n</span> <span class="o">===</span> <span class="kt">IsOdd</span> <span class="n">m</span>
      <span class="kt">Actual</span>   <span class="kr">type</span>    <span class="kt">:</span> <span class="n">p0</span> <span class="n">n</span> <span class="o">===</span> <span class="n">p0</span> <span class="n">m</span>
</code></pre></div><p>它只能对字面量进行推导，比如</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">deriveS</span> <span class="ow">::</span> <span class="n">n</span> <span class="o">===</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">S</span> <span class="n">n</span> <span class="o">===</span> <span class="kt">S</span> <span class="n">m</span>
</code></pre></div><h2><b>练习</b></h2><p>你现在应该可以解决下面几道题目</p><p><a href="http://link.zhihu.com/?target=https%3A//www.codewars.com/kata/singletons" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">codewars.com/kata/singl</span><span class="invisible">etons</span><span class="ellipsis"></span></a></p><p><a href="http://link.zhihu.com/?target=https%3A//www.codewars.com/kata/odd-plus-even-equals-odd-prove-it" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">codewars.com/kata/odd-p</span><span class="invisible">lus-even-equals-odd-prove-it</span><span class="ellipsis"></span></a></p><p><a href="http://link.zhihu.com/?target=https%3A//www.codewars.com/kata/a-plus-b-equals-b-plus-a-prove-it" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">codewars.com/kata/a-plu</span><span class="invisible">s-b-equals-b-plus-a-prove-it</span><span class="ellipsis"></span></a></p><p>最后一道题证明的是加法交换律，除了文中给出的方法，还有一种更精妙的写法，读者可以试着找一找</p><h2>更多练习</h2><p>证明乘法结合律</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">multCommute</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span> <span class="n">p</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="kt">:*:</span> <span class="n">m</span> <span class="kt">:*:</span> <span class="n">p</span> <span class="o">===</span> <span class="n">n</span> <span class="kt">:*:</span> <span class="p">(</span><span class="n">m</span> <span class="kt">:*:</span> <span class="n">p</span><span class="p">)</span>
</code></pre></div><p>以及更多你能想到的东西</p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
