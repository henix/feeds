<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>「续」一场由逻辑漏洞引发的「血案」</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/44639109">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-079774c0ee7a7af80cdf9990aa05ab64_r.jpg" alt=""></div><blockquote><b>真相只有一个 </b><i> ——  名侦探江戶川柯南</i></blockquote><p><b>前因   <a href="https://zhuanlan.zhihu.com/p/44499068">一场由逻辑漏洞引发的「血案」</a></b> </p><hr><p>在前文中，针对CVE-2018-1000657漏洞成因做了详尽的逻辑分析。今天抽时间用lldb对该段代码做了验证，当然，结果诚如我之所说。</p><h2><b>环境配置</b></h2><p>首先，使用 <code class="inline"> rustup install 1.20.0 </code> 命令安装好有漏洞的Rust版本。 别忘记选择该版本为Rust默认版本。</p><p>调试工具，我使用的是VSCode，需要安装CodeLLDB插件（Mac环境，Linux请用GDB相关）。环境安装好之后，使用<code class="inline"> cargo new lldb_demo</code> 命令在 <code class="inline"> src/main.rs</code> 文件中保存前文中示例代码。</p><p>当然，你可以使用lldb命令进行调试，安装rust-lldb，但是不如VSCode方便。</p><p>然后在Debug界面选择好配置，如下图：</p><img src="https://pic3.zhimg.com/v2-a3badee032f2091132efd47fee902e3b_r.jpg" data-caption="" data-size="normal" data-rawwidth="910" data-rawheight="492" data-watermark="watermark" data-original-src="v2-a3badee032f2091132efd47fee902e3b" data-watermark-src="v2-24bc8e90e6c67f60c19e1c91e75683d7" data-private-watermark-src=""><p>可以直接选择 <code class="inline"> Add Configuration...</code> 来添加新的配置。</p><img src="https://pic1.zhimg.com/v2-dcdf4fc565faf0e72a324b79f8ed5b11_r.jpg" data-caption="" data-size="normal" data-rawwidth="778" data-rawheight="586" data-watermark="watermark" data-original-src="v2-dcdf4fc565faf0e72a324b79f8ed5b11" data-watermark-src="v2-caf99e5b363b9a36351ac4204415a733" data-private-watermark-src=""><p>只需要选择 <code class="inline"> LLDB: Debug Cargo Output </code>就可以自动配置。 </p><p>然后，就可以开始进行调试了。</p><h2><b>调试代码</b></h2><p>经过前文的分析，已经知道在哪里设置断点。</p><img src="https://pic2.zhimg.com/v2-ff64c61e2eb95dde82777e5482eb6fa9_r.jpg" data-caption="" data-size="normal" data-rawwidth="928" data-rawheight="414" data-watermark="watermark" data-original-src="v2-ff64c61e2eb95dde82777e5482eb6fa9" data-watermark-src="v2-730a6768693168ca944beb9d54072fd2" data-private-watermark-src=""><p>当然，只有这两个断点是不够的。但是可以开始了。选择Debug界面，点击左上角的绿色三角形按钮，就可以开始调试代码了。</p><img src="https://pic2.zhimg.com/v2-40687b5526778c99570dd8b43e820fa5_r.jpg" data-caption="" data-size="normal" data-rawwidth="658" data-rawheight="368" data-watermark="watermark" data-original-src="v2-40687b5526778c99570dd8b43e820fa5" data-watermark-src="v2-7ece0acf761cc856d7a1d68594ba1226" data-private-watermark-src=""><p>刚开始慢点点击step over按钮。在跳入汇编界面的时候，开始点击step into。</p><img src="https://pic2.zhimg.com/v2-0ec04c91d68673d703bd63e0f5234460_r.jpg" data-caption="" data-size="normal" data-rawwidth="1586" data-rawheight="914" data-watermark="watermark" data-original-src="v2-0ec04c91d68673d703bd63e0f5234460" data-watermark-src="v2-f0cf7ab7a906c54cbfc27bc9cb3cbccd" data-private-watermark-src=""><p>然后在其中搜索drop相关代码，再前面加上断点。就这样一步一步step into，在相应的汇编代码中把drop相关地方都加上断点。与此同时，代码开始执行std::sys_common::cleanup了。这里Get到几个知识点：</p><ol><li> main函数执行的时候，Rust提供了一个很小的运行时std::rt::lang<i>_</i>start，会将main函数作为一个闭包传进去。</li><li>lang_start支持Gloabl Heap和栈回溯支持。main函数中如果出现了panic，则会由它来负责恢复。</li><li>Rust是基于LLVM的，实际上异常处理会分为两个阶段：搜索阶段和清理（cleanup）阶段。在搜索阶段，会检查panic，并决定是否捕获它。 在清理阶段，会决定到底运行哪个（如果有的话）清理代码对当前堆栈进行清理。它会调用析构函数和内存释放等。</li></ol><p>可以看下图的call stack，cleanup已经开始调用drop了。</p><img src="https://pic4.zhimg.com/v2-6c5fc87694e9e3dad1f2609c860b2461_r.jpg" data-caption="" data-size="normal" data-rawwidth="2528" data-rawheight="1164" data-watermark="watermark" data-original-src="v2-6c5fc87694e9e3dad1f2609c860b2461" data-watermark-src="v2-db80f5d1087ed923611f59a8f9b97bd6" data-private-watermark-src=""><img src="https://pic1.zhimg.com/v2-36f08ec7e0dec45af68f0793bd65f6ac_r.jpg" data-caption="" data-size="normal" data-rawwidth="2536" data-rawheight="1442" data-watermark="watermark" data-original-src="v2-36f08ec7e0dec45af68f0793bd65f6ac" data-watermark-src="v2-089eebd870faf2132261fae5172a5f42" data-private-watermark-src=""><p>这样就可以看到析构函数都正常执行了。但此时并未发生段错误。继续step into。</p><img src="https://pic4.zhimg.com/v2-2deaed34c7abf1ca6b411b5db55316cf_r.jpg" data-caption="" data-size="normal" data-rawwidth="2542" data-rawheight="1272" data-watermark="watermark" data-original-src="v2-2deaed34c7abf1ca6b411b5db55316cf" data-watermark-src="v2-ac93b45f55ac024c59d0162c65140ad9" data-private-watermark-src=""><p>直到cleanup完成，也没有发生段错误。继续step into。</p><img src="https://pic3.zhimg.com/v2-a38161eff1d137049930131c953a2118_r.jpg" data-caption="" data-size="normal" data-rawwidth="792" data-rawheight="502" data-watermark="watermark" data-original-src="v2-a38161eff1d137049930131c953a2118" data-watermark-src="v2-505f265e3297584301a3f66dc296ee59" data-private-watermark-src=""><img src="https://pic2.zhimg.com/v2-45941a9b75694feb19faefd52bdb65c6_r.jpg" data-caption="" data-size="normal" data-rawwidth="1626" data-rawheight="318" data-watermark="watermark" data-original-src="v2-45941a9b75694feb19faefd52bdb65c6" data-watermark-src="v2-07f67d1879b9953106ccc8a50452a54a" data-private-watermark-src=""><p>直到，执行到了<code class="inline"> std::syscommon::at_exit_imp::cleanup</code> 的时候，段错误应该是发生了。<code class="inline"> std::syscommon::at_exit_imp</code> 是rt运行时的最后退出阶段，此时代码执行完毕，要将内存归还给操作系统。</p><p>同时，VSCode LLDB Debug工具抛出了<b>EXC_BAD_ACCESS</b> 错误，并且此时代码调用停留在 <code class="inline"> pthread_mutex_lock </code> 调用。 <code class="inline"> pthread_mutex_lock </code> 其实调用libc库中的一个系统API，已经到操作系统底层了。抛出<b>EXC_BAD_ACCESS错误一般是指「调用了已经释放的内存空间，或者说重复释放了某个地址空间」而引起的。</b></p><p>分析到这里，真相已经浮出了水面。</p><h2><b>总结</b></h2><ol><li>前文中分析段错误产生的原因经过了<b>LLDB</b>的实证。</li><li>因为容量使用错误，导致指针混乱。</li><li>在<b>main</b>函数析构函数调用之后，因为指针混乱，将不该释放的内存释放掉了。但是此时并未发生<b>panic</b>。</li><li>在main函数退出运行时的时候，需要将内存归还给操作系统。此时调用了另外的一个<b>cleanup</b>方法，在给操作系统归还内存过程中，通过抛出的错误<b>EXC_BAD_ACCESS</b>分析，应该是调用了本来不该释放但已经释放的内存空间。</li><li>错误发生在操作系统接口pthread_mutex_lock中，Rust根本无法捕捉，所以发生段错误。</li></ol><p>&lt;全文完&gt;</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
