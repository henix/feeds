<div class="title-image"><img src="https://pic1.zhimg.com/v2-3bef0e945fe9f4d285012a77c7ba79a9_b.jpg" alt=""></div><p>作者：WI</p><p>编译：叶别 | 公众号翻译部</p><h2><b>本文亮点</b></h2><p><b>1、可扩展的基础架构，数据获取方便；</b></p><p><b>2、Python编程技术应用；</b></p><p><b>3、编程、计量经济学、强化学习的基础概念；</b></p><p><b>4、超全策略代码；</b></p><p>本推文会介绍如何在利用股票分钟数据，基于强化学习来做配对交易。包括基本概念和具体实现；这里采用的强化学习方法，是类似多臂老虎机（N-armed bandit）问题。</p><p><b>获取全部代码，见文末</b></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-024fa7f871d5103d1e18bdef76d1a9dd_b.jpg" data-caption="" data-size="normal" data-rawwidth="237" data-rawheight="356" class="content_image" width="237"/></noscript><img src="https://pic2.zhimg.com/v2-024fa7f871d5103d1e18bdef76d1a9dd_b.jpg" data-caption="" data-size="normal" data-rawwidth="237" data-rawheight="356" class="content_image lazy" width="237" data-actualsrc="https://pic2.zhimg.com/v2-024fa7f871d5103d1e18bdef76d1a9dd_b.jpg"/></figure><h2><b>数据获取</b></h2><p><b>▍Tiingo 数据源</b></p><p>Tiingo是一个金融研究平台，提供包括新闻、基本面和股票价格在内的数据。我们可以通过其REST IEX API提取日内股票市场数据，该API从IEX交易所检索到TOPS数据（最高价/最低价/开盘/收盘价）。</p><p>举个例子，可以通过访问以下链接来获取苹果公司在2019年1月2号中每5分钟的股价。</p><p><a href="https://link.zhihu.com/?target=https%3A//api.tiingo.com/iex/aapl/prices%3FstartDate%3D2019-01-02%26endDate%3D2019-01-02%26resampleFreq%3D5min%26token%3Def79e455ba9b04c3df719407e34f05e1b051b4d6" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">api.tiingo.com/iex/aapl</span><span class="invisible">/prices?startDate=2019-01-02&amp;endDate=2019-01-02&amp;resampleFreq=5min&amp;token=ef79e455ba9b04c3df719407e34f05e1b051b4d6</span><span class="ellipsis"></span></a></p><p>json返回结果：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-1121256d1640bfe520eae6e4a6a07361_b.jpg" data-caption="" data-size="normal" data-rawwidth="692" data-rawheight="189" class="origin_image zh-lightbox-thumb" width="692" data-original="https://pic2.zhimg.com/v2-1121256d1640bfe520eae6e4a6a07361_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-1121256d1640bfe520eae6e4a6a07361_b.jpg" data-caption="" data-size="normal" data-rawwidth="692" data-rawheight="189" class="origin_image zh-lightbox-thumb lazy" width="692" data-original="https://pic2.zhimg.com/v2-1121256d1640bfe520eae6e4a6a07361_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-1121256d1640bfe520eae6e4a6a07361_b.jpg"/></figure><p>为了使任务自动化，我们提供了一个能够在指定历史窗口内获得股票列表的标准化的日内数据的函数。</p><p><b>不足之处有：</b></p><p>1、最对提供1分钟级别的数据；</p><p>2、不同股票可以查询到的股价的天数不是固定的，即使指定365天的窗口，也可能只获得几天的数据；</p><p>3、不同股票在一天之内可以查询到的时间段也不是固定的（可能某些股票开盘后了才能查到股价）；查询速度不是很快。</p><p><b>解决方案:</b></p><p>1、一次只查询一只股票、只查询一天的数据；</p><p>2、对查询到的多个时间段的数据，用固定窗口去截断（比如限制每天只取391分钟的数据）；</p><p>3、异步IO。</p><p>Pandas提供了相关工具，可以从Tiingo和其它类似数据集中提取数据，但目前只提取天级别的数据。<b>虽然API是免费的，不过使用时也请注意调用方法，避免请求过多超出限制。</b></p><p><b>▍实现</b></p><p>首先注册账号、申请：</p><p><i>token:<a href="https://link.zhihu.com/?target=https%3A//api.tiingo.com/account/api/token" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">api.tiingo.com/account/</span><span class="invisible">api/token</span><span class="ellipsis"></span></a></i></p><p>介绍下Data/API.py下面的几个主要函数：</p><p>1.生成获取股价数据的url，参数有股票名(ticker)，时间(target_date)，请求频次(freq)，token；</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-4466f50a53f28132103f75092f13fac4_b.jpg" data-caption="" data-size="normal" data-rawwidth="744" data-rawheight="197" class="origin_image zh-lightbox-thumb" width="744" data-original="https://pic1.zhimg.com/v2-4466f50a53f28132103f75092f13fac4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-4466f50a53f28132103f75092f13fac4_b.jpg" data-caption="" data-size="normal" data-rawwidth="744" data-rawheight="197" class="origin_image zh-lightbox-thumb lazy" width="744" data-original="https://pic1.zhimg.com/v2-4466f50a53f28132103f75092f13fac4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-4466f50a53f28132103f75092f13fac4_b.jpg"/></figure><p>2. 获取json数据：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-0d676760682e650f30f463f1053c973d_b.jpg" data-caption="" data-size="normal" data-rawwidth="450" data-rawheight="112" class="origin_image zh-lightbox-thumb" width="450" data-original="https://pic2.zhimg.com/v2-0d676760682e650f30f463f1053c973d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-0d676760682e650f30f463f1053c973d_b.jpg" data-caption="" data-size="normal" data-rawwidth="450" data-rawheight="112" class="origin_image zh-lightbox-thumb lazy" width="450" data-original="https://pic2.zhimg.com/v2-0d676760682e650f30f463f1053c973d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-0d676760682e650f30f463f1053c973d_b.jpg"/></figure><p>以上两个函数是放在Data/API.py 文件中的Tiingo 类下面的；可以根据输入不同重复执行。</p><p><b>▍异步IO</b></p><p>上面实现是有局限性的、性能也比较差。 每获取一条数据时，程序会建立API连接、从服务器请求数据、等待响应，重复请求直到完成所有的URL。异步IO的处理方式是不同的，下面这段代码是用异步IO的方式来获取Google和Facebook在20180101到20180131这段时间内的交易数据（每天391分钟数据, 319*24个交易日*2只股票，共约15600条数据）。可以看出，<b>相比于非异步请求，性能提升了17倍（1.38s-&gt;23.58s）。</b></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-f3166de32cd2acee6893211b70663de2_b.jpg" data-caption="" data-size="normal" data-rawwidth="735" data-rawheight="517" class="origin_image zh-lightbox-thumb" width="735" data-original="https://pic3.zhimg.com/v2-f3166de32cd2acee6893211b70663de2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-f3166de32cd2acee6893211b70663de2_b.jpg" data-caption="" data-size="normal" data-rawwidth="735" data-rawheight="517" class="origin_image zh-lightbox-thumb lazy" width="735" data-original="https://pic3.zhimg.com/v2-f3166de32cd2acee6893211b70663de2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-f3166de32cd2acee6893211b70663de2_b.jpg"/></figure><p><b>asyncio是一个使用async / await方式的并发编程的库，asyncio用作多个Python异步框架的基础，这些框架提供高性能的网络和Web服务器、数据库连接库、分布式任务队列等。AsyncIO是单线程的，它使用一个单事件处理器来组织任务分配、以便多个任务可以在其他任务空闲时开始运行。</b></p><p> 下面有个官方示例来展示asyncio的思想。</p><p>程序地址：</p><p><i><a href="https://link.zhihu.com/?target=https%3A//python.readthedocs.io/fr/latest/library/asyncio-task.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">python.readthedocs.io/f</span><span class="invisible">r/latest/library/asyncio-task.html</span><span class="ellipsis"></span></a></i></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-40caa50cbc08a4123404e342a1a61b15_b.jpg" data-caption="" data-size="normal" data-rawwidth="570" data-rawheight="339" class="origin_image zh-lightbox-thumb" width="570" data-original="https://pic2.zhimg.com/v2-40caa50cbc08a4123404e342a1a61b15_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-40caa50cbc08a4123404e342a1a61b15_b.jpg" data-caption="" data-size="normal" data-rawwidth="570" data-rawheight="339" class="origin_image zh-lightbox-thumb lazy" width="570" data-original="https://pic2.zhimg.com/v2-40caa50cbc08a4123404e342a1a61b15_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-40caa50cbc08a4123404e342a1a61b15_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-1e43f366447e70902114459af6fa5385_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="518" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-1e43f366447e70902114459af6fa5385_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-1e43f366447e70902114459af6fa5385_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="518" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-1e43f366447e70902114459af6fa5385_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-1e43f366447e70902114459af6fa5385_b.jpg"/></figure><p><a href="https://link.zhihu.com/?target=https%3A//python.readthedocs.io/fr/latest/library/asyncio-task.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">python.readthedocs.io/f</span><span class="invisible">r/latest/library/asyncio-task.html</span><span class="ellipsis"></span></a></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-ebde98c7581d0ea6b9a423fc27068443_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="562" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-ebde98c7581d0ea6b9a423fc27068443_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-ebde98c7581d0ea6b9a423fc27068443_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="562" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-ebde98c7581d0ea6b9a423fc27068443_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-ebde98c7581d0ea6b9a423fc27068443_b.jpg"/></figure><p>上面程序中的关键字<b>async def</b>将相应的函数定义为可以暂停或恢复执行的协程。 每当任务运行到在关键字<b>await</b>处，将回传一个事件控制器（<b>loop</b>），该事件控制器再唤起另一个任务。 简单来说，这种方式不会浪费等待时间。</p><p>在我们的代码中也有类似的方法， <b>_fetch_hist_async</b>将创建一个事件循环来控制<b>fetch_data_async</b>进程（<b>fetch_data_async</b>是获取日内价格的基础任务）； 遇到await时控制器返回到事件循环，即使前一个请求尚未完成，也会触发另一个请求。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-7db75a333cb79eda26e706db8a9288a5_b.jpg" data-size="normal" data-rawwidth="800" data-rawheight="360" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic2.zhimg.com/v2-7db75a333cb79eda26e706db8a9288a5_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-7db75a333cb79eda26e706db8a9288a5_b.jpg" data-size="normal" data-rawwidth="800" data-rawheight="360" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic2.zhimg.com/v2-7db75a333cb79eda26e706db8a9288a5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-7db75a333cb79eda26e706db8a9288a5_b.jpg"/><figcaption>_fetch_hist_async in class Tiingo</figcaption></figure><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-b05e251f6ae13c8b9713213525ae9cc6_b.jpg" data-size="normal" data-rawwidth="610" data-rawheight="209" class="origin_image zh-lightbox-thumb" width="610" data-original="https://pic3.zhimg.com/v2-b05e251f6ae13c8b9713213525ae9cc6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-b05e251f6ae13c8b9713213525ae9cc6_b.jpg" data-size="normal" data-rawwidth="610" data-rawheight="209" class="origin_image zh-lightbox-thumb lazy" width="610" data-original="https://pic3.zhimg.com/v2-b05e251f6ae13c8b9713213525ae9cc6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-b05e251f6ae13c8b9713213525ae9cc6_b.jpg"/><figcaption>fetch_data_async in class Tiingo</figcaption></figure><p><b>▍数据存储</b></p><p>把数据用.csv格式保存到STATICS/PRICE目录下。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-9e6dbe53072c6c65578dde4653728f31_b.png" data-caption="" data-size="normal" data-rawwidth="692" data-rawheight="78" class="origin_image zh-lightbox-thumb" width="692" data-original="https://pic2.zhimg.com/v2-9e6dbe53072c6c65578dde4653728f31_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-9e6dbe53072c6c65578dde4653728f31_b.png" data-caption="" data-size="normal" data-rawwidth="692" data-rawheight="78" class="origin_image zh-lightbox-thumb lazy" width="692" data-original="https://pic2.zhimg.com/v2-9e6dbe53072c6c65578dde4653728f31_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-9e6dbe53072c6c65578dde4653728f31_b.png"/></figure><h2><b>代码结构</b></h2><p><b>获取全部代码，见文末</b></p><h2><b>配对交易的概念和分析</b></h2><p><b>▍配对交易</b><br/></p><p>配对交易是市场中性策略</p><p>Gatev 等人这样描述：</p><p><b>“配对交易的概念非常简单， 找出价格在历史上一起变化的两只股票， 当它们之间的差距扩大时，做多价低者、做空价高者。如果历史重演，价格差距会收敛，套利者会获利。”</b> </p><p>这里包含两个方阶段：</p><p>1、规则制订阶段：测量股票之间的价格关系,寻找潜在的股票配对。</p><p>2、在交易期间，监控股价变动，并根据预定义的规则进行交易。</p><p>Krauss (2017) 总结了配对交易的5种类型：距离法，协整方法，时间序列法，随机控制法和其他方法如机器学习、主成分分析、copula等。 <b>本文是把经典的Engle和Granger（1987）协整方法和强化学习算法结合起来的应用</b>。</p><p>这里我们会用时间序列分析中的平稳性的概念， 在金融时间序列中通常用的是弱平稳性（或协方差)，并遵从3个准则：</p><p>1、随机变量x的均值E[x(t)]: 该均值和时间t独立； </p><p>2、方差Var(x(t))：大于0且有限的值、且与时间t独立；</p><p>3、协方差Cov(x(t),x(s)):和t-s相关，但与单独的t和s独立。x(t)一般可以是对数股价收益（或差分），而不是价格本身。 如果一个时间序列的一阶差分平稳了，就是所谓的一阶单整I(1)。</p><p>虽然有些交易可以从定向投注中获利，但这不是我们关注的，<b>我们真正想要的是找到一对价格差异或价差始终保持稳定（并且协整）的股票。</b></p><p><b>▍分析（见EXAMPLE/Analysis.py）</b></p><p>我们抽取了20180101-20180731期间的21只美股的1分钟级别的数据，用.csv格式保存在STATICS/PRICE目录下。对时间段前70%的数据，我们来进行一些分析。</p><p><b>▍Pearson 相关系数</b></p><p>先看下代码：</p><b><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-9ec8c2f42ec299a130a514c98bbda4d5_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="673" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic2.zhimg.com/v2-9ec8c2f42ec299a130a514c98bbda4d5_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-9ec8c2f42ec299a130a514c98bbda4d5_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="673" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic2.zhimg.com/v2-9ec8c2f42ec299a130a514c98bbda4d5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-9ec8c2f42ec299a130a514c98bbda4d5_b.jpg"/></figure></b><p>看下结果：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-219e85474eb455d1881571fb8b82a918_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="688" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic1.zhimg.com/v2-219e85474eb455d1881571fb8b82a918_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-219e85474eb455d1881571fb8b82a918_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="688" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic1.zhimg.com/v2-219e85474eb455d1881571fb8b82a918_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-219e85474eb455d1881571fb8b82a918_b.jpg"/></figure><p>上图可以看出，最高相关性位于PEP（百事可乐）/PG（保洁）/JNJ（强生）/KO（可口可乐）这四只股票之间。从经济角度来看，可以形成两组配对：JNJ-PG和KO-PEP。 <b>不过需要注意的是高相关性并不一定意味着协整。</b></p><p><b>▍边缘分布</b></p><p>如果我们画出以上股票对的边缘分布，可以看到线性相关和一些簇的关系。</p><p>代码如下：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-37f5e078ed26013ac8171e93193e6172_b.jpg" data-caption="" data-size="normal" data-rawwidth="688" data-rawheight="125" class="origin_image zh-lightbox-thumb" width="688" data-original="https://pic3.zhimg.com/v2-37f5e078ed26013ac8171e93193e6172_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-37f5e078ed26013ac8171e93193e6172_b.jpg" data-caption="" data-size="normal" data-rawwidth="688" data-rawheight="125" class="origin_image zh-lightbox-thumb lazy" width="688" data-original="https://pic3.zhimg.com/v2-37f5e078ed26013ac8171e93193e6172_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-37f5e078ed26013ac8171e93193e6172_b.jpg"/></figure><p>效果如下：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-2c44e9020cde050d2868406b65a5ca15_b.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="600" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic2.zhimg.com/v2-2c44e9020cde050d2868406b65a5ca15_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-2c44e9020cde050d2868406b65a5ca15_b.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="600" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic2.zhimg.com/v2-2c44e9020cde050d2868406b65a5ca15_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-2c44e9020cde050d2868406b65a5ca15_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-8c8b131f1b96a73ae78fbb42de27f960_b.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="600" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic1.zhimg.com/v2-8c8b131f1b96a73ae78fbb42de27f960_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-8c8b131f1b96a73ae78fbb42de27f960_b.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="600" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic1.zhimg.com/v2-8c8b131f1b96a73ae78fbb42de27f960_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-8c8b131f1b96a73ae78fbb42de27f960_b.jpg"/></figure><p><b>▍价格图表</b></p><p>我们创建一个函数来绘制样本期间的价格和价差， 价格在开始时重新定为1；其中第二个子图中的th是交易阈值（买点和买点），stop_loss是止损点。</p><p>代码如下：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-0a27211c87a3f721382a1aa03fb12a28_b.jpg" data-caption="" data-size="normal" data-rawwidth="1023" data-rawheight="730" class="origin_image zh-lightbox-thumb" width="1023" data-original="https://pic1.zhimg.com/v2-0a27211c87a3f721382a1aa03fb12a28_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-0a27211c87a3f721382a1aa03fb12a28_b.jpg" data-caption="" data-size="normal" data-rawwidth="1023" data-rawheight="730" class="origin_image zh-lightbox-thumb lazy" width="1023" data-original="https://pic1.zhimg.com/v2-0a27211c87a3f721382a1aa03fb12a28_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-0a27211c87a3f721382a1aa03fb12a28_b.jpg"/></figure><p>效果如下：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-5443c4375aa77fee347216f249c1a14e_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="489" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic3.zhimg.com/v2-5443c4375aa77fee347216f249c1a14e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-5443c4375aa77fee347216f249c1a14e_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="489" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic3.zhimg.com/v2-5443c4375aa77fee347216f249c1a14e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-5443c4375aa77fee347216f249c1a14e_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-a801318745e4556f8920ba21f0598a61_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="475" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic2.zhimg.com/v2-a801318745e4556f8920ba21f0598a61_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-a801318745e4556f8920ba21f0598a61_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="475" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic2.zhimg.com/v2-a801318745e4556f8920ba21f0598a61_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-a801318745e4556f8920ba21f0598a61_b.jpg"/></figure><p><b>▍协整检验</b></p><p>以下代码计算协整检验的p值，如果p值很小观察协整关系的概率应该相对较高。</p><p>代码如下：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-e764fee121d5f15ab5ae5cfe476139a2_b.jpg" data-caption="" data-size="normal" data-rawwidth="760" data-rawheight="301" class="origin_image zh-lightbox-thumb" width="760" data-original="https://pic3.zhimg.com/v2-e764fee121d5f15ab5ae5cfe476139a2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-e764fee121d5f15ab5ae5cfe476139a2_b.jpg" data-caption="" data-size="normal" data-rawwidth="760" data-rawheight="301" class="origin_image zh-lightbox-thumb lazy" width="760" data-original="https://pic3.zhimg.com/v2-e764fee121d5f15ab5ae5cfe476139a2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-e764fee121d5f15ab5ae5cfe476139a2_b.jpg"/></figure><p>但是相关性并不等于协整。即使两对股票的相关性是差不多的，但协整关系的概率差别比较大。</p><p>有时我们可以找到相关但不是协整的价格关系。<b>例如如果两种股票价格随着时间一起上涨，则它们是正相关的； 然而如果这两只股票以不同的速度上涨，价差将继续增长而不是在均衡时振荡，因此是非平稳的。</b></p><p>下面给出一个例子，<b>用代码通过几何布朗运动（Geometric Brownian Motion）和Cholesky分解模拟两个相关的股票</b>，每个包含1000个样本。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-71ab1cd75173203f6f833cd7384bf043_b.jpg" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="657" class="origin_image zh-lightbox-thumb" width="900" data-original="https://pic4.zhimg.com/v2-71ab1cd75173203f6f833cd7384bf043_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-71ab1cd75173203f6f833cd7384bf043_b.jpg" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="657" class="origin_image zh-lightbox-thumb lazy" width="900" data-original="https://pic4.zhimg.com/v2-71ab1cd75173203f6f833cd7384bf043_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-71ab1cd75173203f6f833cd7384bf043_b.jpg"/></figure><p>可以看到虽然很相关，但是p值却非常大。</p><p>画出时间序列上的图：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-7db5fc9bfd9094351293f612532f1639_b.jpg" data-caption="" data-size="normal" data-rawwidth="634" data-rawheight="128" class="origin_image zh-lightbox-thumb" width="634" data-original="https://pic2.zhimg.com/v2-7db5fc9bfd9094351293f612532f1639_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-7db5fc9bfd9094351293f612532f1639_b.jpg" data-caption="" data-size="normal" data-rawwidth="634" data-rawheight="128" class="origin_image zh-lightbox-thumb lazy" width="634" data-original="https://pic2.zhimg.com/v2-7db5fc9bfd9094351293f612532f1639_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-7db5fc9bfd9094351293f612532f1639_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-a20cf18359f1af4980ff0a60ead0110d_b.jpg" data-caption="" data-size="normal" data-rawwidth="846" data-rawheight="549" class="origin_image zh-lightbox-thumb" width="846" data-original="https://pic2.zhimg.com/v2-a20cf18359f1af4980ff0a60ead0110d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-a20cf18359f1af4980ff0a60ead0110d_b.jpg" data-caption="" data-size="normal" data-rawwidth="846" data-rawheight="549" class="origin_image zh-lightbox-thumb lazy" width="846" data-original="https://pic2.zhimg.com/v2-a20cf18359f1af4980ff0a60ead0110d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-a20cf18359f1af4980ff0a60ead0110d_b.jpg"/></figure><p>上图中的第2个子图中显示了价差不断变大，而不是均值回归。</p><p><b>▍协整</b></p><p>1987年Engle和Granger提出的协整理论，虽然一些变量的本身是非平稳序列，但是它们的线性组合却有可能是平稳序列。</p><p>这种平稳的线性组合被称为协整方程，且可解释为变量之间的长期稳定的均衡关系。具体地，如果两个I(1)对数股票价格x(1,t)和x(2,t)有协整关系，那么存在一个系数b和一个平稳的时间序列y(t), 使得：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-088575a3a84bdf37a0ccf2c7b7e9b531_b.png" data-caption="" data-size="normal" data-rawwidth="337" data-rawheight="37" class="content_image" width="337"/></noscript><img src="https://pic2.zhimg.com/v2-088575a3a84bdf37a0ccf2c7b7e9b531_b.png" data-caption="" data-size="normal" data-rawwidth="337" data-rawheight="37" class="content_image lazy" width="337" data-actualsrc="https://pic2.zhimg.com/v2-088575a3a84bdf37a0ccf2c7b7e9b531_b.png"/></figure><p>其中a是一个固定常数，y(t)是目标的平稳的价差。 显然，我们可以简单地使用普通最小二乘方法来估计价差y和系数b，通过将x(1,t)来对x(2,t)做回归。 </p><p><b>▍协整检验</b></p><p>测试协整的最常用方法是DF方法(Dickey Fuller)或ADF方法(Augmented Dickey Fuller)。</p><p><b>▍单位根和DF检验</b></p><p>对于一个简单的一阶自回归AR(1)模型</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-f90a7c60395187d6655774a2d854fb43_b.png" data-caption="" data-size="normal" data-rawwidth="334" data-rawheight="30" class="content_image" width="334"/></noscript><img src="https://pic4.zhimg.com/v2-f90a7c60395187d6655774a2d854fb43_b.png" data-caption="" data-size="normal" data-rawwidth="334" data-rawheight="30" class="content_image lazy" width="334" data-actualsrc="https://pic4.zhimg.com/v2-f90a7c60395187d6655774a2d854fb43_b.png"/></figure><p>其中e(t)是白噪声，t是时间, xt是要检验的变量；如果c=1则说明单位根是存在的。</p><p> DF检验是用来测试一个自回归模型是否存在单位根，把上面的回归模型改写为：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-b5444ad56b324a470dafdcddad77260a_b.png" data-caption="" data-size="normal" data-rawwidth="360" data-rawheight="46" class="content_image" width="360"/></noscript><img src="https://pic3.zhimg.com/v2-b5444ad56b324a470dafdcddad77260a_b.png" data-caption="" data-size="normal" data-rawwidth="360" data-rawheight="46" class="content_image lazy" width="360" data-actualsrc="https://pic3.zhimg.com/v2-b5444ad56b324a470dafdcddad77260a_b.png"/></figure><p>c=1也就意味着零假设c-1=0。 我们还可以添加截距或趋势项，并根据假设测试系数等于零的零假设。 </p><p><b>▍ADF检验</b></p><p>把DF检验中用到的AR(1)自回归改为高阶自回归AR(p)，那么就是ADF检验。</p><p>AR(p)：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-3db84ed267ce3c748609ffcd5fe7fca2_b.png" data-caption="" data-size="normal" data-rawwidth="415" data-rawheight="42" class="content_image" width="415"/></noscript><img src="https://pic3.zhimg.com/v2-3db84ed267ce3c748609ffcd5fe7fca2_b.png" data-caption="" data-size="normal" data-rawwidth="415" data-rawheight="42" class="content_image lazy" width="415" data-actualsrc="https://pic3.zhimg.com/v2-3db84ed267ce3c748609ffcd5fe7fca2_b.png"/></figure><p>残差形式：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-921cb125a826f947f3d50161c7b48fb6_b.png" data-caption="" data-size="normal" data-rawwidth="557" data-rawheight="64" class="origin_image zh-lightbox-thumb" width="557" data-original="https://pic3.zhimg.com/v2-921cb125a826f947f3d50161c7b48fb6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-921cb125a826f947f3d50161c7b48fb6_b.png" data-caption="" data-size="normal" data-rawwidth="557" data-rawheight="64" class="origin_image zh-lightbox-thumb lazy" width="557" data-original="https://pic3.zhimg.com/v2-921cb125a826f947f3d50161c7b48fb6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-921cb125a826f947f3d50161c7b48fb6_b.png"/></figure><p>对应的零假设是：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-8eca473e2106b89c77fbaad7c7d95b6c_b.jpg" data-caption="" data-size="normal" data-rawwidth="298" data-rawheight="60" class="content_image" width="298"/></noscript><img src="https://pic1.zhimg.com/v2-8eca473e2106b89c77fbaad7c7d95b6c_b.jpg" data-caption="" data-size="normal" data-rawwidth="298" data-rawheight="60" class="content_image lazy" width="298" data-actualsrc="https://pic1.zhimg.com/v2-8eca473e2106b89c77fbaad7c7d95b6c_b.jpg"/></figure><p><b>▍实现部分</b></p><p>我们在策略类EGCointegration中实现了上面的分析。 请注意，此处的检验是基于statsmodels.tsa.stattools.coint，在同一库中还有另一个函数statsmodels.tsa.stattools.adfuller是用来用于单元根检验的。</p><p>不同之处在于：</p><p>1、<b>coint</b>实际上是Engle-Granger协整检验，有2个时间序列输入，计算残差、对残差做检验；</p><p>2、<b>adfuller</b>是一个时间序列的输入，检验的是单变量的单位根。大部分场景下两个检验得出的结论是一致的，但是coint方法实现起来更直观。</p><h2><b>强化学习的介绍</b></h2><p><b>▍基础概念</b></p><p>强化学习有两个元素: Agent和环境（Environment）。 环境由具有预定义状态空间（State）的不同状态表示，而Agent学习一个策略（Policy）来确定要在动作空间（Action）中执行哪个动作。 Agent的学习周期可归纳为以下几个阶段：</p><p><b>1、观察环境状态</b></p><p><b>2、根据现有Policy相应地采取动作</b></p><p><b>3、收到执行动作的相应奖励(Reward)</b></p><p><b>4、更新Policy</b></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-8bcd9223dd11e609976eab7aba1f8569_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="300" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic2.zhimg.com/v2-8bcd9223dd11e609976eab7aba1f8569_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-8bcd9223dd11e609976eab7aba1f8569_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="300" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic2.zhimg.com/v2-8bcd9223dd11e609976eab7aba1f8569_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-8bcd9223dd11e609976eab7aba1f8569_b.jpg"/></figure><p>举个例子，假设一只小狗（Agent）正在学习如何对他主人的命令（环境）作出反应。 它是一只懒狗，只知道如何执行三个命令：</p><ul><li><b>坐</b></li><li><b>站</b></li><li><b>啥也不做</b></li></ul><p>为了训练小狗，他的主人经常给他一套命令（State），包括“坐”，“站”和“跳”。 如果狗的反应正确，他的主人会给他一些狗粮（Reward）。起初，小狗并不真正了解他的主人想要什么，不知道（Policy）如何将命令“正确地”映射到期望的动作（Action）。 但是，偶尔他可以做正确的动作并得到了奖励（Reward），并逐渐建立他们之间的联系（更新Policy）。</p><p>经过多次试验，这个狗终于知道，只要听到“坐”或“站”这个词，他就应该坐/站立。 但无论他的主人要求他“跳”多少次，他都完全不知道该怎么办。 在这种情况下，他曾多次尝试坐下或站立，但无法获得任何奖励; 小狗最终选择了对“跳跃”命令什么都不做，因为与其他动作相比，这个选项能节约点体力（Reward不为负）。 </p><p>强化学习和监督学习是不同的。在监督学习中，每个样本都有一个预测目标以便计算差值，通过不断迭代减小这个差值来更新算法。然而在强化学习中，Policy是通过评估来学习的，样本中没有直接的标注数据。Agent只能通过持续评估反馈来学习，即不断挑选Action并评估相应的奖励(Reward)以调整策略(Policy)，保留最理想的结果。 强<b>化学习的流程要复杂一些， 如果我们在交易中应用强化学习时，需要仔细定义状态和动作空间这些基础元素。</b></p><p><b>▍几个简单的强化学习实例</b></p><p><b>多臂老虎机</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-ae67e7e9b36312b818410f6ecbe690ac_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="527" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic1.zhimg.com/v2-ae67e7e9b36312b818410f6ecbe690ac_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-ae67e7e9b36312b818410f6ecbe690ac_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="527" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic1.zhimg.com/v2-ae67e7e9b36312b818410f6ecbe690ac_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-ae67e7e9b36312b818410f6ecbe690ac_b.jpg"/></figure><p><b>问题：</b>上面的2臂老虎机，我们应该选择左臂还是右臂来获取最多的奖励。</p><p><b>答案：</b>右臂。</p><p>但是机器如何学到这个策略呢？ 把这个问题转化为强化学习的形式如下:</p><ul><li><b>状态空间：无</b></li><li><b>动作空间: 拉左臂/右臂</b></li><li><b>奖励：1或0</b></li></ul><p>在训练过程中，RL算法将重复上述任务（拉动手臂）并评估获得的奖励、持续更新策略(Policy)。 最后，通它应该能够得出哪个手臂最好拉动的结论。</p><p><b>上下文赌博机</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-88bf4d52cf7bb3a7674082650b491e58_b.jpg" data-caption="" data-size="normal" data-rawwidth="603" data-rawheight="581" class="origin_image zh-lightbox-thumb" width="603" data-original="https://pic1.zhimg.com/v2-88bf4d52cf7bb3a7674082650b491e58_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-88bf4d52cf7bb3a7674082650b491e58_b.jpg" data-caption="" data-size="normal" data-rawwidth="603" data-rawheight="581" class="origin_image zh-lightbox-thumb lazy" width="603" data-original="https://pic1.zhimg.com/v2-88bf4d52cf7bb3a7674082650b491e58_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-88bf4d52cf7bb3a7674082650b491e58_b.jpg"/></figure><p>上下文赌博机是多臂老虎机的扩展，如上图有3个机器、对于每个机器我们要选择不同的手臂。转化为强化学习形式如下:</p><ul><li><b>状态空间: 机器A、机器B、机器C</b></li><li><b>动作空间：拉左臂/右臂</b></li><li><b>奖励：1或0</b></li></ul><p><b>▍ 实现</b></p><p>我们究竟希望机器学会如何执行？对于时间序列中的配对交易，<b>我们需要选择合适的历史窗口、交易窗口、交易阈值和止损这些都是动作（Action）的最佳组合来学习最大化预期交易利润（Reward）</b>。从强化学习的角度来看：</p><ul><li><b>状态空间：</b>无（只有一定的交易成本）</li><li><b>动作空间：</b>历史窗口、交易窗口、交易阈值、止损点、信心水平</li><li><b>奖励：</b>平均收益</li></ul><h2><b>用强化学习实现配对交易</b></h2><p>实施的6个步骤有：</p><p><b>1、加载相关配置和价格数据</b></p><p><b>2、将它们标准化并分成训练和测试集</b></p><p><b>3、创建状态空间和动作空间</b></p><p><b>4、构建网络</b></p><p><b>5、创建学习对象并开始训练</b></p><p><b>6、执行测试分析</b></p><p><b>参数：</b></p><p><b>配对股票</b>：JNJ-PG(强生vs宝洁)</p><p><b>时间范围：</b>20180101-20180730</p><p><b>数据频率：</b>分钟级别的</p><p><b>状态空间：</b> 无</p><p><b>动作空间:</b></p><p>a. 历史窗口： 从60分钟到600分钟，每60分钟一步</p><p>b. 交易窗口: 从120分钟到1200分钟，每60分钟一步</p><p>c. 交易阈值： 增加/减少的访问时1-5， 每步是1</p><p>d. 止损点： 交易阈值基础上加减1-2， 每步是0.5</p><p>e. 信心水平：90%或95%</p><p><b>奖励：</b>平均收益</p><p><b>交易数量：</b>每个买买信号交易1个价差</p><p><b>价格校准：</b> 标准化</p><p><b>交易价格：</b>实际价格</p><p>为了减轻极高回报的影响，平均回报的上限为10。</p><p><b>配置</b></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-72fb8e89bcdab29c7777cdcea2bbb2b6_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="562" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic3.zhimg.com/v2-72fb8e89bcdab29c7777cdcea2bbb2b6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-72fb8e89bcdab29c7777cdcea2bbb2b6_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="562" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic3.zhimg.com/v2-72fb8e89bcdab29c7777cdcea2bbb2b6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-72fb8e89bcdab29c7777cdcea2bbb2b6_b.jpg"/></figure><p><b>第一步和第二步：</b></p><p>加载相关配置和价格数据&amp;&amp; 将它们标准化并分成训练和测试集。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-0a63dfc5d3c3dffcfbe0940d09a34bad_b.jpg" data-caption="" data-size="normal" data-rawwidth="905" data-rawheight="540" class="origin_image zh-lightbox-thumb" width="905" data-original="https://pic2.zhimg.com/v2-0a63dfc5d3c3dffcfbe0940d09a34bad_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-0a63dfc5d3c3dffcfbe0940d09a34bad_b.jpg" data-caption="" data-size="normal" data-rawwidth="905" data-rawheight="540" class="origin_image zh-lightbox-thumb lazy" width="905" data-original="https://pic2.zhimg.com/v2-0a63dfc5d3c3dffcfbe0940d09a34bad_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-0a63dfc5d3c3dffcfbe0940d09a34bad_b.jpg"/></figure><p><b>第三步：</b></p><p>创建状态空间和动作空间</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-33d03a01d207bd034bf6a977a06ade42_b.jpg" data-caption="" data-size="normal" data-rawwidth="773" data-rawheight="487" class="origin_image zh-lightbox-thumb" width="773" data-original="https://pic3.zhimg.com/v2-33d03a01d207bd034bf6a977a06ade42_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-33d03a01d207bd034bf6a977a06ade42_b.jpg" data-caption="" data-size="normal" data-rawwidth="773" data-rawheight="487" class="origin_image zh-lightbox-thumb lazy" width="773" data-original="https://pic3.zhimg.com/v2-33d03a01d207bd034bf6a977a06ade42_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-33d03a01d207bd034bf6a977a06ade42_b.jpg"/></figure><p><b>第四步：</b></p><p>构建网络</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-8424af49826ecd33ec08b6741551648e_b.jpg" data-caption="" data-size="normal" data-rawwidth="920" data-rawheight="427" class="origin_image zh-lightbox-thumb" width="920" data-original="https://pic3.zhimg.com/v2-8424af49826ecd33ec08b6741551648e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-8424af49826ecd33ec08b6741551648e_b.jpg" data-caption="" data-size="normal" data-rawwidth="920" data-rawheight="427" class="origin_image zh-lightbox-thumb lazy" width="920" data-original="https://pic3.zhimg.com/v2-8424af49826ecd33ec08b6741551648e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-8424af49826ecd33ec08b6741551648e_b.jpg"/></figure><p><b>第五步：</b></p><p>创建学习对象并开始训练</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-66d73ccf5cafb78ed02eba9f979cd6ff_b.jpg" data-caption="" data-size="normal" data-rawwidth="675" data-rawheight="113" class="origin_image zh-lightbox-thumb" width="675" data-original="https://pic4.zhimg.com/v2-66d73ccf5cafb78ed02eba9f979cd6ff_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-66d73ccf5cafb78ed02eba9f979cd6ff_b.jpg" data-caption="" data-size="normal" data-rawwidth="675" data-rawheight="113" class="origin_image zh-lightbox-thumb lazy" width="675" data-original="https://pic4.zhimg.com/v2-66d73ccf5cafb78ed02eba9f979cd6ff_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-66d73ccf5cafb78ed02eba9f979cd6ff_b.jpg"/></figure><p><b>第六步：</b></p><p>执行测试分析</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-b434d92ba4bee490ef1ba49a51c6ad72_b.jpg" data-caption="" data-size="normal" data-rawwidth="579" data-rawheight="250" class="origin_image zh-lightbox-thumb" width="579" data-original="https://pic3.zhimg.com/v2-b434d92ba4bee490ef1ba49a51c6ad72_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-b434d92ba4bee490ef1ba49a51c6ad72_b.jpg" data-caption="" data-size="normal" data-rawwidth="579" data-rawheight="250" class="origin_image zh-lightbox-thumb lazy" width="579" data-original="https://pic3.zhimg.com/v2-b434d92ba4bee490ef1ba49a51c6ad72_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-b434d92ba4bee490ef1ba49a51c6ad72_b.jpg"/></figure><p>训练时的预期奖励如下：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-bc87b0e6669f1bfb5270bda04b42f374_b.jpg" data-caption="" data-size="normal" data-rawwidth="522" data-rawheight="131" class="origin_image zh-lightbox-thumb" width="522" data-original="https://pic1.zhimg.com/v2-bc87b0e6669f1bfb5270bda04b42f374_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-bc87b0e6669f1bfb5270bda04b42f374_b.jpg" data-caption="" data-size="normal" data-rawwidth="522" data-rawheight="131" class="origin_image zh-lightbox-thumb lazy" width="522" data-original="https://pic1.zhimg.com/v2-bc87b0e6669f1bfb5270bda04b42f374_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-bc87b0e6669f1bfb5270bda04b42f374_b.jpg"/></figure><p>训练中的奖励的分布：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-937a67940ba652805ee86a13443b0bb0_b.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="480" class="origin_image zh-lightbox-thumb" width="640" data-original="https://pic1.zhimg.com/v2-937a67940ba652805ee86a13443b0bb0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-937a67940ba652805ee86a13443b0bb0_b.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="480" class="origin_image zh-lightbox-thumb lazy" width="640" data-original="https://pic1.zhimg.com/v2-937a67940ba652805ee86a13443b0bb0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-937a67940ba652805ee86a13443b0bb0_b.jpg"/></figure><p>训练好之后，对每分钟数据进行测试交易：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-ae7bbe5ab9cd08bdc022aa7236f5a16d_b.jpg" data-caption="" data-size="normal" data-rawwidth="906" data-rawheight="969" class="origin_image zh-lightbox-thumb" width="906" data-original="https://pic2.zhimg.com/v2-ae7bbe5ab9cd08bdc022aa7236f5a16d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-ae7bbe5ab9cd08bdc022aa7236f5a16d_b.jpg" data-caption="" data-size="normal" data-rawwidth="906" data-rawheight="969" class="origin_image zh-lightbox-thumb lazy" width="906" data-original="https://pic2.zhimg.com/v2-ae7bbe5ab9cd08bdc022aa7236f5a16d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-ae7bbe5ab9cd08bdc022aa7236f5a16d_b.jpg"/></figure><p>效果如下：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-0484eed0890ce77e4ff6f708a0d1572e_b.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="448" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic3.zhimg.com/v2-0484eed0890ce77e4ff6f708a0d1572e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-0484eed0890ce77e4ff6f708a0d1572e_b.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="448" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic3.zhimg.com/v2-0484eed0890ce77e4ff6f708a0d1572e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-0484eed0890ce77e4ff6f708a0d1572e_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-0e440bf46e8686bfd2679e73e8667952_b.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="438" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic3.zhimg.com/v2-0e440bf46e8686bfd2679e73e8667952_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-0e440bf46e8686bfd2679e73e8667952_b.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="438" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic3.zhimg.com/v2-0e440bf46e8686bfd2679e73e8667952_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-0e440bf46e8686bfd2679e73e8667952_b.jpg"/></figure><p>其中上图是每分钟内的交易数量；下图是累计收益(pnl)线。</p><p><b>虽然看起来结果似乎不错，但在现实世界中情况因许多因素而变得复杂，例如买卖差价、执行延迟、保证金、利息、分数股等。但本文的目标是举例说明如何开发一个强化学习交易系统中用到的各种技术，希望对读者有一定借鉴意义。</b></p><h2><b>代码设计逻辑</b></h2><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-d39e644060046a48bd1da543ee6a010a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="553" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic3.zhimg.com/v2-d39e644060046a48bd1da543ee6a010a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-d39e644060046a48bd1da543ee6a010a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="553" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic3.zhimg.com/v2-d39e644060046a48bd1da543ee6a010a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-d39e644060046a48bd1da543ee6a010a_b.jpg"/></figure><h2><b>代码讲解</b></h2><p>代码讲解部分内容涉及较多，大家自行查看。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-0f196c1cbb571e3b9e303cf523d5e2dd_b.jpg" data-caption="" data-size="normal" data-rawwidth="622" data-rawheight="298" class="origin_image zh-lightbox-thumb" width="622" data-original="https://pic2.zhimg.com/v2-0f196c1cbb571e3b9e303cf523d5e2dd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-0f196c1cbb571e3b9e303cf523d5e2dd_b.jpg" data-caption="" data-size="normal" data-rawwidth="622" data-rawheight="298" class="origin_image zh-lightbox-thumb lazy" width="622" data-original="https://pic2.zhimg.com/v2-0f196c1cbb571e3b9e303cf523d5e2dd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-0f196c1cbb571e3b9e303cf523d5e2dd_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-e8b1b377a86525b69a8c36243143761e_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="494" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic3.zhimg.com/v2-e8b1b377a86525b69a8c36243143761e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-e8b1b377a86525b69a8c36243143761e_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="494" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic3.zhimg.com/v2-e8b1b377a86525b69a8c36243143761e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-e8b1b377a86525b69a8c36243143761e_b.jpg"/></figure><h2><b>参考文献</b></h2><p>Dickey, D. A., Fuller, W. A., 1979. Distribution of the estimators for autoregressive time series with a unit root. Journal of the American Statistical Association. 74(366): 427–431.</p><p>Engle, R.F., Granger, C.W.J., 1987, Co-integration and error correction: representation, estimation, and testing. Econometrica 55(2): 251–276</p><p>Gatev, E., Goetzmann, W.N., and Rouwenhorst, K.G., 2006, Pairs trading: performance of a relative-value arbitrage rule. The Review of Financial Studies 19(3): 797–827</p><p>Granger, C.W., 1981, Some properties of time series data and their use in econometric model specification. Journal of Economics 16(1): 121–130</p><p>Johansen, S., 1988, Statistical analysis of cointegration vectors. Journal of Economic Dynamics and Control 12(2–3): 231–254</p><p>Krauss, C., 2017, Statistical arbitrage pairs trading strategies: review and outlook. Journal of Economics Surveys 31(2): 513–545</p><p>Stock, J.H., 1987, Asymptotic properties of least squares estimators of cointegrating<br/>vectors, Econometrica 55: 277–302.</p><p>Sutton, R.S., Barto, A.G., (1998), Reinforcement Learning: An Introduction. The MIT Press, Second Edition</p><h2><b>如何获取代码</b></h2><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/UFKCK3uEFFOWQf7CAgONZA" data-draft-node="block" data-draft-type="link-card" data-image="https://pic1.zhimg.com/v2-b79737b549f721a73d0df9b8abb24d40_180x120.jpg" data-image-width="1024" data-image-height="436" class=" wrap external" target="_blank" rel="nofollow noreferrer">配对交易千千万，强化学习最NB！（附文档+代码讲解）</a><p>量化投资与机器学习微信公众号，是业内垂直于<b>Quant</b>、<b>MFE</b>、<b>CST</b>等专业的主流量化自媒体。公众号拥有来自<b>公募、私募、券商、银行、海外</b>等众多圈内<b>10W+</b>关注者。每日发布行业前沿研究成果和最新资讯。</p>