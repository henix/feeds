<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Visitor Pattern 与 Finally Tagless：解决表达式问题</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/53810286">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-7f1c4dc6025a8c2ff0eaaf7cd33aec1f_b.jpg" alt=""></div><p>原文链接：<a href="http://link.zhihu.com/?target=https%3A//ice1000.org/2019/01/01/FinallyTaglessVisitorPattern/" class=" wrap external" target="_blank" rel="nofollow noreferrer">ice1000.org</a></p><p>说到设计模式，大家一定会想到世界上著名的『面向对象编程语言』（棒读）Java。以及一大群认为动态类型编程语言比静态类型编程语言更『灵活』、设计模式解决的问题在动态类型编程语言里面都不是问题的人在各大娱乐网站发表的谜样の言论。 这篇文章虽然说是讨论设计模式，但是不是讨论这种问题的（2019 年了，同学）。我们站在一个更 PLT 的层次来看其中一个（我觉得还比较巧妙的）设计模式——Visitor 模式，以及它在函数式编程中对应的函数式编程的『设计模式』。</p><h2>Expression Problem</h2><p>最早的时候，我以为 Visitor 只是为了在 Java 里面模拟模式匹配用的。比如，考虑这段幼儿园水平的 Haskell 代码：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Exp</span>
  <span class="ow">=</span> <span class="kt">Lit</span> <span class="kt">Int</span>
  <span class="o">|</span> <span class="kt">Add</span> <span class="kt">Exp</span> <span class="kt">Exp</span>

<span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Exp</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">n</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">a</span> <span class="o">+</span> <span class="n">eval</span> <span class="n">b</span>
</code></pre></div><p>在 Java 里面写起来会很痛苦，因为 Java 没有『代数数据类型』的概念，也没有 <code>sealed class</code>。啊先不说这么多，我们先写一个：</p><div class="highlight"><pre><code class="language-java"><span></span><span class="kd">interface</span> <span class="nc">Exp</span> <span class="o">{</span> <span class="kt">int</span> <span class="nf">eval</span><span class="o">();</span> <span class="o">}</span>

<span class="kd">class</span> <span class="nc">Lit</span> <span class="kd">implements</span> <span class="n">Exp</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">eval</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Add</span> <span class="kd">implements</span> <span class="n">Exp</span> <span class="o">{</span>
  <span class="n">Exp</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">eval</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="na">eval</span><span class="o">()</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="na">eval</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>此处为了代码简洁性，略去了构造函数。可以看出两种实现在可维护性上的区别：</p><ul><li>Haskell 版本</li><ul><li>如果想给 <code>Exp</code> 添加新的操作（比如输出整颗 AST），只需要新写一个函数就是了</li></ul></ul><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">dump</span> <span class="ow">::</span> <span class="kt">Exp</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">dump</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">n</span>
<span class="nf">dump</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="s">"("</span> <span class="o">++</span> <span class="n">dump</span> <span class="n">a</span> <span class="o">++</span> <span class="s">", "</span> <span class="o">++</span> <span class="n">dump</span> <span class="n">b</span> <span class="o">++</span> <span class="s">")"</span>
</code></pre></div><ul><ul><li>如果想给 <code>Exp</code> 添加新的数据构造器（比如加个 <code>Sub</code> 表示减），就得修改所有的函数</li></ul><li>Java 版本</li><ul><li>如果想给 <code>Exp</code> 添加新的数据构造器（比如加个 <code>Sub</code> 表示减），加个 <code>class</code> 去 <code>implements Exp</code> 就是了</li></ul></ul><div class="highlight"><pre><code class="language-java"><span></span><span class="kd">class</span> <span class="nc">Sub</span> <span class="kd">implements</span> <span class="n">Exp</span> <span class="o">{</span>
  <span class="n">Exp</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">eval</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="na">eval</span><span class="o">()</span> <span class="o">-</span> <span class="n">r</span><span class="o">.</span><span class="na">eval</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><ul><ul><li>如果想给 <code>Exp</code> 添加新的操作（比如输出整颗 AST），需要在接口和所有实例中增加新的方法</li></ul></ul><p>看起来这是一个鱼和熊掌的模型，两者互相有不同之处。</p><p>Java 为了解决这个问题，引入了 Visitor 模式：我们换一种方法『引入操作』，即提供 <code>visit</code>（又叫 <code>accept</code>）接口。 我们使用 Visitor 设计模式重写前面的 Java 代码：</p><div class="highlight"><pre><code class="language-java"><span></span><span class="kd">interface</span> <span class="nc">Exp</span> <span class="o">{</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">A</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Visitor</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">vis</span><span class="o">);</span> <span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Visitor</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="n">A</span> <span class="nf">lit</span><span class="o">(</span><span class="n">Lit</span> <span class="n">a</span><span class="o">);</span>
  <span class="n">A</span> <span class="nf">add</span><span class="o">(</span><span class="n">Add</span> <span class="n">a</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Lit</span> <span class="kd">implements</span> <span class="n">Exp</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
  <span class="kd">public</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">A</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Visitor</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">vis</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">vis</span><span class="o">.</span><span class="na">lit</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Add</span> <span class="kd">implements</span> <span class="n">Exp</span> <span class="o">{</span>
  <span class="n">Exp</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>
  <span class="kd">public</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">A</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Visitor</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">vis</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">vis</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="n">vis</span><span class="o">),</span> <span class="n">right</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="n">vis</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Eval</span> <span class="kd">implements</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">lit</span><span class="o">(</span><span class="n">Lit</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">value</span><span class="o">;</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">add</span><span class="o">(</span><span class="n">Add</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>这样的话，我们的代码变得很 Haskell 了——『操作』和 <code>class</code> 互相独立（而不是像 <code>class</code> 和方法一样紧耦合）：</p><ul><li>如果想给 <code>Exp</code> 添加新的操作（比如输出整颗 AST），只需要新写一个 <code>class</code> 去 <code>implements Visitor&lt;&gt;</code> 就是了</li></ul><div class="highlight"><pre><code class="language-java"><span></span><span class="kd">class</span> <span class="nc">Dump</span> <span class="kd">implements</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">lit</span><span class="o">(</span><span class="n">Lit</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">value</span><span class="o">);</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">add</span><span class="o">(</span><span class="n">Add</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"("</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><ul><li>如果想给 <code>Exp</code> 添加新的数据构造器（比如加个 <code>Sub</code> 表示减），就得修改所有的 Visitor</li></ul><p>这就很像 Haskell 那种使用模式匹配的方式定义数据类型了。</p><p>这个双向扩展的问题，叫做<b>Expression Problem</b>（<a href="http://link.zhihu.com/?target=http%3A//okmij.org/ftp/tagless-final/course/lecture.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">出处</a>（9102 了怎么还是 http））。</p><p>后来，在看了<a href="http://link.zhihu.com/?target=https%3A//zju-lambda.tech/introduction-to-object-algebra/" class=" wrap external" target="_blank" rel="nofollow noreferrer">浙江大学一位极为优秀的编程大牛的文章</a>（前面的代码基本是参考的这篇文章的。如果你知道如何使用 Visitor 进行双向扩展，那么就不需要点击这个链接了）后（知乎id <a class="member_mention" href="http://www.zhihu.com/people/dca943c375a8194d28e1c0aa8210d0c3" data-hash="dca943c375a8194d28e1c0aa8210d0c3" data-hovercard="p$b$dca943c375a8194d28e1c0aa8210d0c3">@zjuwyd</a> ），我才知道 Visitor 可以同时支持可扩展地添加新的操作和数据构造器的。 这种做法似乎叫 Object Algebra。</p><p>那么，Java 就同时在保留自己的优点的情况下，借助设计模式，解决了 Haskell 的问题。是不是可以说，Java 大法好，垃圾 Haskell 了？其实不行，人家 Haskell 也有『设计模式』解决这个问题。</p><p>解决方案叫——Finally Tagless。</p><h2>Finally Tagless</h2><p>这是原本的 AST，它长这样。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Exp</span>
  <span class="ow">=</span> <span class="kt">Lit</span> <span class="kt">Int</span>
  <span class="o">|</span> <span class="kt">Add</span> <span class="kt">Exp</span> <span class="kt">Exp</span>
</code></pre></div><p>我们把它写成 GADT 的形式，看起来更顺眼一些（方便思路转换）：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Exp</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">Lit</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Exp</span> <span class="kt">Int</span>
  <span class="kt">Add</span> <span class="ow">::</span> <span class="kt">Exp</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Exp</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Exp</span> <span class="kt">Int</span>
</code></pre></div><p>我们把它变成 typeclass，这个东西的形状和前面 Java 的 Visitor 几乎一模一样（这里没有解释这个转换是怎么想出来的，下面的延伸阅读里面有）。 变化的规则是，我们把 <code>Exp</code> 的每个构造器表示成函数（typeclass 里面的抽象方法），然后把它们的返回类型通过一个 typeclass 的参数（下面代码中的 <code>a</code>）抽象出来：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">class</span> <span class="kt">Visitor</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">int</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span>
  <span class="n">add</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</code></pre></div><p>这和基于 Object Algebra 的 Visitor 是完全一致的——后者提供的 Visitor 可以在外部被扩展，而这正是 typeclass 与生俱来的性质。我们利用 typeclass 的这一天然性质，实现了 Visitor 实现的一切。这种方法就叫 Finally Tagless。</p><p>我们可以添加 type instance，作为『操作』（这是伪代码，我们假设一下平凡的 <code>Applicative</code> 实现）：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">instance</span> <span class="kt">Visitor</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="n">int</span> <span class="ow">=</span> <span class="n">id</span>
  <span class="n">add</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Visitor</span> <span class="kt">String</span> <span class="kr">where</span>
  <span class="n">int</span> <span class="ow">=</span> <span class="n">show</span>
  <span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="s">"("</span> <span class="o">++</span> <span class="n">a</span> <span class="o">++</span> <span class="s">" + "</span> <span class="o">++</span> <span class="n">b</span> <span class="o">++</span> <span class="s">")"</span>
</code></pre></div><p>然后如果要执行『操作』，就先构建 AST，然后显式指定 AST 的类型，编译器就会使用那个特定的 type instance 去真正的把这颗 AST『折叠』起来。比如：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">sampleAst</span> <span class="ow">::</span> <span class="kt">Visitor</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span>
<span class="nf">sampleAst</span> <span class="ow">=</span> <span class="n">add</span>
  <span class="p">(</span><span class="n">add</span> <span class="p">(</span><span class="n">int</span> <span class="mi">114</span><span class="p">)</span> <span class="p">(</span><span class="n">int</span> <span class="mi">514</span><span class="p">))</span>
  <span class="p">(</span><span class="n">add</span> <span class="p">(</span><span class="n">int</span> <span class="mi">1926</span><span class="p">)</span> <span class="p">(</span><span class="n">add</span> <span class="p">(</span><span class="n">int</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="n">int</span> <span class="mi">17</span><span class="p">)))</span>

<span class="nf">evaluatedAst</span> <span class="ow">=</span> <span class="n">sampleAst</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">dumpedAst</span> <span class="ow">=</span> <span class="n">sampleAst</span> <span class="ow">::</span> <span class="kt">String</span>
</code></pre></div><p>下面讲讲两者的对应关系，Visitor 的代码直接抄前面引用的文章的：</p><h2>Visitor</h2><p>原本提供的接口：</p><div class="highlight"><pre><code class="language-java"><span></span><span class="kd">interface</span> <span class="nc">Visitor</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="n">E</span> <span class="nf">lit</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">);</span>
  <span class="n">E</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">a</span><span class="o">,</span> <span class="n">E</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><h2>添加新的操作</h2><p>比如，添加一个打印 AST 的操作：</p><div class="highlight"><pre><code class="language-java"><span></span><span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">Dump</span> <span class="o">{</span> <span class="n">String</span> <span class="nf">dump</span><span class="o">();</span> <span class="o">}</span>

<span class="kd">class</span> <span class="nc">DumpVisitor</span> <span class="kd">implements</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="n">Dump</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Dump</span> <span class="nf">lit</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> <span class="o">}</span>

  <span class="kd">public</span> <span class="n">Dump</span> <span class="nf">add</span><span class="o">(</span><span class="kd">final</span> <span class="n">Dump</span> <span class="n">a</span><span class="o">,</span> <span class="kd">final</span> <span class="n">Dump</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"("</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">dump</span><span class="o">()</span> <span class="o">+</span> <span class="s">" + "</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="na">dump</span><span class="o">()</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>和一个求值的操作：</p><div class="highlight"><pre><code class="language-java"><span></span><span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">Eval</span> <span class="o">{</span> <span class="kt">int</span> <span class="nf">eval</span><span class="o">();</span> <span class="o">}</span>

<span class="kd">class</span> <span class="nc">EvalVisitor</span> <span class="kd">implements</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="n">Eval</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Eval</span> <span class="nf">lit</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>

  <span class="kd">public</span> <span class="n">Eval</span> <span class="nf">add</span><span class="o">(</span><span class="kd">final</span> <span class="n">Eval</span> <span class="n">a</span><span class="o">,</span> <span class="kd">final</span> <span class="n">Eval</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">eval</span><span class="o">()</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="na">eval</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2>添加新的数据类型</h2><p>比如，添加一个表达减法的数据类型：</p><div class="highlight"><pre><code class="language-java"><span></span><span class="kd">interface</span> <span class="nc">SubVisitor</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span> <span class="n">E</span> <span class="nf">sub</span><span class="o">(</span><span class="n">E</span> <span class="n">a</span><span class="o">,</span> <span class="n">E</span> <span class="n">b</span><span class="o">);</span> <span class="o">}</span>
</code></pre></div><p>由于前面已经扩展了 <code>Eval</code> 和 <code>Dump</code>，我们分别再<b>不修改已有代码的情况下</b>把前面的功能扩展出来：</p><div class="highlight"><pre><code class="language-java"><span></span><span class="kd">class</span> <span class="nc">EvalSubVisitor</span> <span class="kd">extends</span> <span class="n">EvalVisitor</span> <span class="kd">implements</span> <span class="n">SubVisitor</span><span class="o">&lt;</span><span class="n">Eval</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Eval</span> <span class="nf">sub</span><span class="o">(</span><span class="kd">final</span> <span class="n">Eval</span> <span class="n">a</span><span class="o">,</span> <span class="kd">final</span> <span class="n">Eval</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">eval</span><span class="o">()</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">eval</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">DumpSubVisitor</span> <span class="kd">extends</span> <span class="n">DumpVisitor</span> <span class="kd">implements</span> <span class="n">SubVisitor</span><span class="o">&lt;</span><span class="n">Dump</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Dump</span> <span class="nf">sub</span><span class="o">(</span><span class="kd">final</span> <span class="n">Dump</span> <span class="n">a</span><span class="o">,</span> <span class="kd">final</span> <span class="n">Dump</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"("</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">print</span><span class="o">()</span> <span class="o">+</span> <span class="s">" - "</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="na">print</span><span class="o">()</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><blockquote> 注意到整个过程中都没有冗余代码出现，Object Algebra 成功地解决了它们之间的耦合问题！</blockquote><h2>Finally Tagless</h2><p>原本提供的接口：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">class</span> <span class="kt">Visitor</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span>
  <span class="n">add</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</code></pre></div><p>这里好像没说怎么构建 AST，那么我构建一个：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">constructAst</span> <span class="ow">::</span> <span class="kt">Visitor</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span>
<span class="nf">constructAst</span> <span class="ow">=</span> <span class="n">add</span> <span class="p">(</span><span class="n">lit</span> <span class="mi">114</span><span class="p">)</span> <span class="p">(</span><span class="n">lit</span> <span class="mi">514</span><span class="p">)</span>
</code></pre></div><p>（好像没什么必要说，太 trivial）</p><h2>添加新的操作</h2><p>比如，添加一个打印 AST 的操作：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">instance</span> <span class="kt">Visitor</span> <span class="kt">String</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="ow">=</span> <span class="n">show</span>
  <span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="s">"("</span> <span class="o">++</span> <span class="n">a</span> <span class="o">++</span> <span class="s">" + "</span> <span class="o">++</span> <span class="n">b</span> <span class="o">++</span> <span class="s">")"</span>
</code></pre></div><p>和一个求值的操作：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">instance</span> <span class="kt">Visitor</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="n">lit</span> <span class="ow">=</span> <span class="n">id</span>
  <span class="n">add</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
</code></pre></div><h2>添加新的数据类型</h2><p>比如，添加一个表达减法的数据类型：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">class</span> <span class="kt">Visitor</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">SubVisitor</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">sub</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</code></pre></div><p>由于前面已经扩展了 <code>Visitor String</code> 和 <code>Visitor Int</code>，我们分别再<b>不修改已有代码的情况下</b>把前面的功能扩展出来：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">instance</span> <span class="kt">SubVisitor</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="n">sub</span> <span class="ow">=</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">SubVisitor</span> <span class="kt">String</span> <span class="kr">where</span>
  <span class="n">sub</span> <span class="n">l</span> <span class="n">r</span> <span class="ow">=</span> <span class="s">"("</span> <span class="o">++</span> <span class="n">l</span> <span class="o">++</span> <span class="s">" - "</span> <span class="o">++</span> <span class="n">r</span> <span class="o">++</span> <span class="s">")"</span>
</code></pre></div><p>注意到整个过程中都没有冗余代码出现，Finally Tagless 成功地解决了它们之间的耦合问题！</p><h2>总结</h2><p>Haskell 的版本很明显要比 Java 版本简洁很多，而且不需要想很多名字（Java 那边起了一堆名字，什么 <code>Eval</code> 什么 <code>Dump</code>，Haskell 那边都是平凡的 <code>instance</code>）。但是反过来，Java 版本拥有同时存在多种类型相同的操作的可能性，而 Haskell 就没那么方便了，因为直接拿类型对应的。</p><p>这个问题，如果使用<a href="http://link.zhihu.com/?target=https%3A//ice1000.org/lagda/Typeclassopedia.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">first class module（aka dependent record）实现的 typeclass</a>，就可以变得和 Java 一样给这些不同的 <code>instance</code> 起名字，同时保留 Haskell 的简洁性。</p><h2>延伸阅读</h2><p>本文并不是讲解 Finally Tagless 的，只是讲解它和 Visitor 这种设计模式之间的对应关系的。 对于 Finally Tagless 本身的讲解和推导，可以看下面的文章。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/22598462" class="internal">一个语文极好的人写的『一不小心发明 de Bruijn Indices, SKI 组合子和 Finally Tagless』</a></li><li><a href="https://zhuanlan.zhihu.com/p/22231273" class="internal">一个语文极差的人写的『解决 HOAS 无法 look into 的问题，同时一不小心发明 SKI 组合子』</a></li></ul><h2>练习</h2><p><a href="http://link.zhihu.com/?target=https%3A//www.codewars.com/kata/finally-tagless-interpreter/discuss/haskell" class=" wrap external" target="_blank" rel="nofollow noreferrer">CodeWars Kata: Finally Tagless Interpreter</a></p><p>我时隔多年又回到了 CodeWars 做题了……真是一种怀念的感觉。</p><h2>我说完了</h2><p>祝大家新年快乐，2019 心想事成。</p><p>明天就要离开中国了……</p><p><br> <br> <br> <br> <br> <br> <br> <br> <br></p><p>啊，东方幕华祭真好玩啊，搞得我都想搞斗金 STG 了……还有点想学作曲。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
