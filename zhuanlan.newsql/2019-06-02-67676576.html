<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>DM 源码阅读系列文章（六）relay log 的实现</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/67676576">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-c5c8d118d1c8b68ea6be0dac38d5e229_b.jpg" alt=""></div><p>作者：张学程</p><p>本文为 DM 源码阅读系列文章的第六篇，在 <a href="https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/dm-source-code-reading-5/" class=" wrap external" target="_blank" rel="nofollow noreferrer">上篇文章</a> 中我们介绍了 binlog replication 处理单元的实现，对在增量复制过程中 binlog event 的读取、过滤、路由、转换以及执行等逻辑进行了分析。</p><p>本篇文章我们将会对 relay 数据处理单元的实现进行详细的讲解。这个单元的作用是从上游 MySQL/MariaDB 读取 binlog event 并写入到本地的 relay log file 中；当执行增量复制任务时，binlog replication 处理单元将读取 relay log file 中的 event 并在进行解析后复制到下游的 TiDB 中。本篇文章的内容包括 relay log 目录结构定义、relay log 数据的处理流程、主从切换支持、relay log 的读取等逻辑。</p><p>值得注意的是，由于我们近期正在对 relay 处理单元进行重构，因此源码中会同时包含重构前后的相关代码实现。</p><h2>relay log 目录结构</h2><p>一个已经进行过一次主从切换的 relay log 目录结构大致如下：</p><div class="highlight"><pre><code class="language-text">&lt;deploy_dir&gt;/relay_log/
|-- 7e427cc0-091c-11e9-9e45-72b7c59d52d7.000001
|   |-- mysql-bin.000001
|   |-- mysql-bin.000002
|   |-- mysql-bin.000003
|   |-- mysql-bin.000004
|   `-- relay.meta
|-- 842965eb-091c-11e9-9e45-9a3bff03fa39.000002
|   |-- mysql-bin.000001
|   `-- relay.meta
`--  server-uuid.index</code></pre></div><p>在 relay log 目录下，主要包含以下几类文件或文件夹数据：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-812dde2bb4a61248818006071d8496f6_b.jpg" data-caption="" data-size="normal" data-rawwidth="1776" data-rawheight="684" class="origin_image zh-lightbox-thumb" width="1776" data-original="https://pic3.zhimg.com/v2-812dde2bb4a61248818006071d8496f6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-812dde2bb4a61248818006071d8496f6_b.jpg" data-caption="" data-size="normal" data-rawwidth="1776" data-rawheight="684" class="origin_image zh-lightbox-thumb lazy" width="1776" data-original="https://pic3.zhimg.com/v2-812dde2bb4a61248818006071d8496f6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-812dde2bb4a61248818006071d8496f6_b.jpg"/></figure><h2>relay log 处理流程</h2><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-e73e07d2abf8f3475d90c31d728d385a_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="322" class="origin_image zh-lightbox-thumb" width="939" data-original="https://pic3.zhimg.com/v2-e73e07d2abf8f3475d90c31d728d385a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-e73e07d2abf8f3475d90c31d728d385a_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="322" class="origin_image zh-lightbox-thumb lazy" width="939" data-original="https://pic3.zhimg.com/v2-e73e07d2abf8f3475d90c31d728d385a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-e73e07d2abf8f3475d90c31d728d385a_b.jpg"/></figure><p>从上图大致可以了解 relay log 的逻辑处理流程，对应的入口代码为 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/relay.go%23L168" class=" wrap external" target="_blank" rel="nofollow noreferrer">Relay.Process</a></code>，主要步骤包括：</p><ol><li>使用 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L30" class=" wrap external" target="_blank" rel="nofollow noreferrer">binlog reader</a> 从上游 MySQL/MariaDB 读取 binlog event。</li><li>将读取到的 binlog event 使用 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/transformer/transformer.go%23L37" class=" wrap external" target="_blank" rel="nofollow noreferrer">binlog transformer</a> 进行转换。</li><li>将转换后的 binlog event 使用 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/writer.go%23L39" class=" wrap external" target="_blank" rel="nofollow noreferrer">binlog writer</a> 以 relay log file 的形式存储在本地。</li><li>当需要将数据以增量的方式同步到下游 TiDB 时，binlog replication 通过使用 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L55" class=" wrap external" target="_blank" rel="nofollow noreferrer">relay reader</a></code> 从 relay log file 中读取 binlog event。</li></ol><h2>读取 binlog event</h2><p>relay 处理单元通过 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L30" class=" wrap external" target="_blank" rel="nofollow noreferrer">Reader interface</a> 从上游读取 binlog event，其中最重要的方法为读取 binlog event 对象的 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L43" class=" wrap external" target="_blank" rel="nofollow noreferrer">GetEvent</a></code>。</p><p>当前对 Reader interface 的实现为 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L57" class=" wrap external" target="_blank" rel="nofollow noreferrer">reader</a></code>，它最终通过 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L64" class=" wrap external" target="_blank" rel="nofollow noreferrer">in</a></code> 这个 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/binlog/reader/reader.go%23L25" class=" wrap external" target="_blank" rel="nofollow noreferrer">br.Reader interface</a></code> 从上游读取 binlog event。reader 的使用流程为：</p><ol><li>调用 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L77" class=" wrap external" target="_blank" rel="nofollow noreferrer">Start</a></code> 启动读取流程，并根据配置中是否启用了 GTID 模式分别调用 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L94" class=" wrap external" target="_blank" rel="nofollow noreferrer">setUpReaderByGTID</a></code> 或 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L96" class=" wrap external" target="_blank" rel="nofollow noreferrer">setUpReaderByPos</a></code> 来启动下层的 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/binlog/reader/reader.go%23L25" class=" wrap external" target="_blank" rel="nofollow noreferrer">br.Reader</a></code> 对象。</li><li>调用 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L116" class=" wrap external" target="_blank" rel="nofollow noreferrer">GetEvent</a></code> 读取 binlog event，具体为 f=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L128" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/dm/b</span><span class="invisible">lob/f6f0566424/relay/reader/reader.go#L128</span><span class="ellipsis"></span></a>&#34;&gt;调用下层的 GetEvent 方法 获取 binlog event。</li><li>当不再需要读取 binlog event 时，调用 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L102" class=" wrap external" target="_blank" rel="nofollow noreferrer">Close</a></code> 关闭读取操作。</li></ol><p>从上面的流程可以看出，具体的 binlog event 读取操作使用的是另一个下层的 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/binlog/reader/reader.go%23L25" class=" wrap external" target="_blank" rel="nofollow noreferrer">br.Reader interface</a></code>，<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L72" class=" wrap external" target="_blank" rel="nofollow noreferrer">当前选择的具体实现</a> 为通过 TCP 连接进行读取的 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/binlog/reader/tcp.go%23L33" class=" wrap external" target="_blank" rel="nofollow noreferrer">TCPReader</a></code>。在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/binlog/reader/tcp.go%23L33" class=" wrap external" target="_blank" rel="nofollow noreferrer">TCPReader</a></code> 中，使用了 <a href="https://link.zhihu.com/?target=https%3A//github.com/siddontang/go-mysql" class=" wrap external" target="_blank" rel="nofollow noreferrer">go-mysql</a> 提供的 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/binlog/reader/tcp.go%23L76" class=" wrap external" target="_blank" rel="nofollow noreferrer">BinglogSyncer.StartSync</a></code> 和 <code><u><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/binlog/reader/tcp.go%23L99" class=" wrap external" target="_blank" rel="nofollow noreferrer">BinlogSyncer.StartSyncGTID</a></u></code> 来启动以 binlog position 模式或 GTID sets 模式读取 binlog event，并通过 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/binlog/reader/tcp.go%23L147" class=" wrap external" target="_blank" rel="nofollow noreferrer">BinlogStreamer.GetEvent</a></code> 读取来自 TCP 的 binlog event。</p><h2>转换 binlog event</h2><p>在 relay 处理单元中，对于从上游读取到的 binlog event，我们需要判断是否需要写进 relay log file 及是否需要更新对应的 <code>relay.meta</code> 内的断点信息。因此在通过 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/reader/reader.go%23L30" class=" wrap external" target="_blank" rel="nofollow noreferrer">Reader interface</a> 读取到 binlog event 后，通过调用 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/transformer/transformer.go%23L37" class=" wrap external" target="_blank" rel="nofollow noreferrer">Transformer interface</a> 来对 binlog event 进行相关的转换处理。</p><p>当前对 Transformer interface 的实现为 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/transformer/transformer.go%23L49" class=" wrap external" target="_blank" rel="nofollow noreferrer">transformer</a>，其主要通过在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/transformer/transformer.go%23L61" class=" wrap external" target="_blank" rel="nofollow noreferrer">Transform</a></code> 方法中 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/transformer/transformer.go%23L67" class=" wrap external" target="_blank" rel="nofollow noreferrer">对 binlog event 的类型进行判断</a>后再进行相应处理，包括：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-e861c0821a854b9989e1260802994c76_b.jpg" data-caption="" data-size="normal" data-rawwidth="1298" data-rawheight="510" class="origin_image zh-lightbox-thumb" width="1298" data-original="https://pic3.zhimg.com/v2-e861c0821a854b9989e1260802994c76_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-e861c0821a854b9989e1260802994c76_b.jpg" data-caption="" data-size="normal" data-rawwidth="1298" data-rawheight="510" class="origin_image zh-lightbox-thumb lazy" width="1298" data-original="https://pic3.zhimg.com/v2-e861c0821a854b9989e1260802994c76_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-e861c0821a854b9989e1260802994c76_b.jpg"/></figure><p>在 Transformer 中，我们期望能达到以下目标：</p><ol><li>过滤上游 master server 上的 binlog file 中不存在的 binlog event，即期望 relay log file 中最终保存的 binlog event 与上游 master server 上的 binlog file 一致。</li><li>仅在 DDL QueryEvent 时或 DML 事务完成时更新 <code>relay.meta</code> 以确保中断恢复时能避免从 DML 事务进行中的 binlog event 处开始从上游请求 binlog event（对于 DML 相关的 binlog event，如果希望解析 <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> 等操作，则需要先获取到对应的 TableMap event）。</li></ol><h2>写入 relay log</h2><p>在从上游读取到 binlog event 并对其进行了相关转换后，我们就可以尝试将其写入到本地的 relay log file 中。在 relay 处理单元中，用于将 binlog event 写入 relay log file 的是 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/writer.go%23L39" class=" wrap external" target="_blank" rel="nofollow noreferrer">Writer interface</a>，当前对应的实现为 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L41" class=" wrap external" target="_blank" rel="nofollow noreferrer">FileWriter</a></code>，其内部会使用 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L48" class=" wrap external" target="_blank" rel="nofollow noreferrer">out</a></code> 这个 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/binlog/writer/file.go%23L29" class=" wrap external" target="_blank" rel="nofollow noreferrer">bw.FileWriter</a></code> 来执行文件写入操作，具体对 binlog event 执行写入操作的是 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L111" class=" wrap external" target="_blank" rel="nofollow noreferrer">WriteEvent</a></code> 方法。</p><h3>1. 各类型 binlog event 的判断处理</h3><p>在尝试对 binlog event 进行写入时，对于不同类型的 binlog event，需要 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L120" class=" wrap external" target="_blank" rel="nofollow noreferrer">进行不同的判断处理</a>。</p><h3>RotateEvent</h3><p>在从上游读取 binlog event 时，主要在以下情况下可能会读取到 <code>RotateEvent</code>：</p><ol><li>连接到上游 master server 开始读取 binlog event 时，master 会发送一个 fake RotateEvent 告知 slave 后续 binlog event 对应的起始 binlog position。</li><li>一个 master server 上的 binlog file 将要被读取完成时，可能会包含一个 RotateEvent 以指示下一个 binlog file 的 filename 与起始 position。</li></ol><p>因此，在处理 <code>RotateEvent</code> 写入的 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L216" class=" wrap external" target="_blank" rel="nofollow noreferrer">handleRotateEvent</a></code> 方法中，主要包含以下操作：</p><ol><li>ef=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/</span><span class="invisible"></span></a><code>dm/blob/f6f</code>0566424/relay/writer/file.go#L240&#34;&gt;尝试更新 FileWriter 内部记录的当前 binlog 文件名为 RotateEvent 内包含的文件名。</li><li>f=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L246" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/dm/b</span><span class="invisible">lob/f6f0566424/relay/writer/file.go#L246</span><span class="ellipsis"></span></a>&#34;&gt;判断是否是 fake RotateEvent，如果是则跳过后续处理。</li><li>与当前 relay log file 的 size 及内部 event 进行比较，<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L256" class=" wrap external" target="_blank" rel="nofollow noreferrer">判断如果将当前 event 写入到文件后是否会造成文件存在 hole 及该 event 是否在 relay log file 中已经存在</a>，如果会造成 hole 则需要填充该 hole，如果已经存在则跳过后续的处理。</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L263" class=" wrap external" target="_blank" rel="nofollow noreferrer">将 event 写入到 relay log file 中</a>。</li></ol><p>需要注意的是，我们不能确保 master server 会将其 binlog file 中的所有 event 都发送给 slave（如当 MariaDB 未设置 <code><a href="https://link.zhihu.com/?target=https%3A//mariadb.com/kb/en/library/com_binlog_dump/" class=" wrap external" target="_blank" rel="nofollow noreferrer">BINLOG_SEND_ANNOTATE_ROWS_EVENT</a></code> flag 时，master 就不会向 slave 发送 <code><a href="https://link.zhihu.com/?target=https%3A//mariadb.com/kb/en/library/annotate_rows_event/" class=" wrap external" target="_blank" rel="nofollow noreferrer">ANNOTATE_ROWS_EVENT</a></code>），因此在写入 event 到文件前，需要通过 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L319" class=" wrap external" target="_blank" rel="nofollow noreferrer">handleFileHoleExist</a></code> 判断如果将 event 写入到文件是否会存在 hole。如果存在 hode，则通过 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L347" class=" wrap external" target="_blank" rel="nofollow noreferrer">event.GenDummyEvent</a></code> 生成相应 size 的 dummy event <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L353" class=" wrap external" target="_blank" rel="nofollow noreferrer">对 hole 进行填充</a>。</p><p>另外需要注意的是，我们不能确保 master server 不会将其已经发送给 slave 并写入到了 relay log file 的 event 再次发送给 slave（如 master 在开始发送 slave 请求的 binlog event 前，会先发送 <code>FormatDescriptionEvent</code> 与 <code>PreviousGTIDsEvent</code> 等给 slave），因此在写入 event 到文件前，需要通过 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L357" class=" wrap external" target="_blank" rel="nofollow noreferrer">handleDuplicateEventsExist</a></code> 判断该 event 是否已经存在于 relay log file 中。</p><h3>FormatDescriptionEvent</h3><p>在从上游读取 binlog event 时，主要在以下情况下可能会读取到 <code>FormatDescriptionEvent</code>：</p><ol><li>上游 master server 在发送除 RotateEvent 外的其他 binlog event 之前，会发送一个 <code>FormatDescriptionEvent</code> 以使 slave 能正确 decode 后续的 binlog event。</li><li>上游 master server 会将自身 binlog file 中存在的 <code>FormatDescriptionEvent</code> 发送给 slave，且这个 <code>FormatDescriptionEvent</code> 总是 binlog file 中的第 1 个 event。</li></ol><p>因此，在处理 <code>FormatDescriptionEvent</code> 的 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L155" class=" wrap external" target="_blank" rel="nofollow noreferrer">handleFormatDescriptionEvent</a></code> 方法中，主要包含以下操作：</p><ol><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L164" class=" wrap external" target="_blank" rel="nofollow noreferrer">关闭之前可能已经打开的 relay log file</a>。</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L182" class=" wrap external" target="_blank" rel="nofollow noreferrer">打开该 event 需要写入到的 relay log file</a> 作为当前活跃的 relay log file。</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L190" class=" wrap external" target="_blank" rel="nofollow noreferrer">检查当前 relay log file 中是否存在 binlog file header</a>（<code>fe `bin`</code>），如果不存在则为其 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L194" class=" wrap external" target="_blank" rel="nofollow noreferrer">写入 binlog file header</a>。</li><li><a href="https://link.zhihu.com/?target=https%3A//github.co%253Ccode%253Em/pingcap/dm/blob/f6f0%253C/code%253E566424/relay/writer/file.go%23L201" class=" wrap external" target="_blank" rel="nofollow noreferrer">检查当前 relay log file 中是否存在 FormatDescriptionEvent</a>，如果不存在则为其 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L205" class=" wrap external" target="_blank" rel="nofollow noreferrer">写入该 FormatDescriptionEvent</a>。</li></ol><h3>其他类型 event</h3><p>对于其他类型的 binlog event，写入操作由 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L273" class=" wrap external" target="_blank" rel="nofollow noreferrer">handleEventDefault</a></code> 进行处理，主要包含以下操作：</p><ol><li>与当前 relay log file 的 size 及内部 event 进行比较，<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L278" class=" wrap external" target="_blank" rel="nofollow noreferrer">判断如果将当前 event 写入到文件后是否会造成文件存在 hole 及该 event 是否在 relay log file 中已经存在</a>，如果会造成 hole 则需要填充该 hole，如果已经存在则跳过后续的处理。</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L286" class=" wrap external" target="_blank" rel="nofollow noreferrer">将 event 写入到 relay log file 中</a>。</li></ol><h3>2. Recover relay log file</h3><p>在写入 binlog event 到 relay log file 时，尽管可以通过 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L130" class=" wrap external" target="_blank" rel="nofollow noreferrer">Flush</a></code> 方法强制将缓冲中的数据刷新到磁盘文件中，但仍然可能出现 DM-worker 进程异常退出时部分数据未能刷新到磁盘文件中的情况，造成 relay log file 内部分 event 数据缺失。</p><p>另外，对于一个事务对应的多个 binlog event，可能出现仅写入了其中一部分 event 时 DM-worker 发生退出的情况，造成 relay log file 中部分事务缺失部分 event。</p><p>因此，在 relay 处理单元中，我们引入了对 relay log file 执行 Recover 的机制，用于将 relay log file 尾部不完整的 event 及事务进行踢除，对应的方法为 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L99" class=" wrap external" target="_blank" rel="nofollow noreferrer">FileWrite.Recover</a></code>，具体实现在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L372" class=" wrap external" target="_blank" rel="nofollow noreferrer">doRecovering</a></code> 方法中，主要操作包括：</p><ol><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L383" class=" wrap external" target="_blank" rel="nofollow noreferrer">获取 relay log file 中直到最后一个完整事务对应的 binlog position 与 GTID sets</a>。</li><li>比较 relay log file 的 size 与获取到的 binlog position，<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L393" class=" wrap external" target="_blank" rel="nofollow noreferrer">如果相等则说明这个 relay log file 中包含的事务都是完整的</a>，跳过后续的处理。</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L399" class=" wrap external" target="_blank" rel="nofollow noreferrer">如果 relay log file 的 size 比 binlog position 更小</a>，则向外部报告错误并跳过后续的处理。</li><li>如果 relay log file 的 size 比 binlog position 大，则 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/writer/file.go%23L409" class=" wrap external" target="_blank" rel="nofollow noreferrer">将 relay log file 中超出 binlog position 的部分执行 Truncate 进行截断</a>。</li></ol><h2>主从切换支持</h2><p>为支持将 relay 处理单元连接的上游 master server 在 replica group 内的不同 server 间进行切换（也包括 relay 处理单元连接的上游 VIP 指向的实际 server 发生了改变），relay 处理单元会尝试将从不同上游 server 读取到的 binlog event 保存到不同的 relay log 子目录中，目录与文件结构可以参考前文的 <a href="https://link.zhihu.com/?target=https%3A//docs.google.com/document/d/14Aj9IwsaWcMgYmdaqYSzeChdM6MxbuT3npWZZ4gAJis/edit%23heading%3Dh.fkyotsq7d5sh" class=" wrap external" target="_blank" rel="nofollow noreferrer">relay log 目录结构</a>。</p><p>为支持上述功能，relay 处理单元在读取 binlog event 前主要执行以下操作：</p><ol><li><a href="https://link.zhihu.com/?target=https%3A//github.c%253Ccode%253Eom/pingcap%253C/code%253E/dm/blob/f6f0566424/relay/relay.go%23L220" class=" wrap external" target="_blank" rel="nofollow noreferrer">比较当前上游 server 的 UUID 信息与 relay.meta 信息，判断当前连接到的是否是前一次连接过的 server</a>。</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/relay/relay.go%23L226" class=" wrap external" target="_blank" rel="nofollow noreferrer">如果不是前一次连接过的 server，则说明切换到了新的 server，因此创建新的 relay log 子目录并更新对应的 meta 信息</a>。</li></ol><h2>读取 relay log</h2><p>relay 处理单元用于从上游读取 binlog event 并将其写入到本地的 relay log file 中。当执行增量数据复制时，binlog replication 处理单元需要通过 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/" class=" wrap external" target="_blank" rel="nofollow noreferrer">streamer pkg</a></code> 读取 relay log file 并从中解析获取需要同步的数据，其中执行读取的对象为 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L55" class=" wrap external" target="_blank" rel="nofollow noreferrer">BinlogReader</a></code>。</p><p>由前文介绍过的主从切换支持可知我们会将具体的 relay log 数据存储在可能的多个子目录中，因此在读取 relay log 时，我们也 需要考虑按序依次读取，主要操作包括：</p><ol><li>href=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L114" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/dm/b</span><span class="invisible">lob/f6f0566424/pkg/streamer/reader.go#L114</span><span class="ellipsis"></span></a>&#34;&gt;调用 parseRelay 开始从 relay log 的根目录执行解析读取。</li><li>href=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L141" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/dm/b</span><span class="invisible">lob/f6f0566424/pkg/streamer/reader.go#L141</span><span class="ellipsis"></span></a>&#34;&gt;调用 parseDirAsPossible 开始从外部指定的或上一次调用返回的子目录、文件及 offset 处开始读取，并返回下一次调用时需要的子目录、文件及 offset（即可实现切换到新的 relay log 子目录）。</li><li>对于当前需要读取的子目录，href=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L184" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/dm/b</span><span class="invisible">lob/f6f0566424/pkg/streamer/reader.go#L184</span><span class="ellipsis"></span></a>&#34;&gt;调用 CollectBinlogFilesCmp 收集该目录内指定 relay log 文件及其之后的所有 relay log 文件。</li><li>对于每一个收集到的 relay log 文件，href=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L212" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/dm/b</span><span class="invisible">lob/f6f0566424/pkg/streamer/reader.go#L212</span><span class="ellipsis"></span></a>&#34;&gt;调用 parseFileAsPossible 尝试对其进行解析读取。</li><li>在 <code>parseFileAsPossible</code> 中，反复返回 href=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L244" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/dm/b</span><span class="invisible">lob/f6f0566424/pkg/streamer/reader.go#L244</span><span class="ellipsis"></span></a>&#34;&gt;调用 parseFile 进行 binlog event 的读取，直到 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L246" class=" wrap external" target="_blank" rel="nofollow noreferrer">发生错误</a> 或 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L253" class=" wrap external" target="_blank" rel="nofollow noreferrer">检测到需要切换到新的 relay log 文件或子目录</a>。</li><li>对于是否需要切换到新的 relay log 文件或子目录的检测通过在 parseFile 内 href=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L345" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/dm/b</span><span class="invisible">lob/f6f0566424/pkg/streamer/reader.go#L345</span><span class="ellipsis"></span></a>&#34;&gt;调用 needSwitchSubDir 与 href=&#34;<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/f6f0566424/pkg/streamer/reader.go%23L356" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/pingcap/dm/b</span><span class="invisible">lob/f6f0566424/pkg/streamer/reader.go#L356</span><span class="ellipsis"></span></a>&#34;&gt;调用 relaySubDirUpdated 实现。</li></ol><h2>小结</h2><p>本篇文章详细地介绍了 relay 处理单元的实现，内容包括了 relay log 的目录结构、如何从上游 server 读取 binlog event 并写入到本地的 relay log file 中，以及 binlog replication 处理单元将如何读取本地的 relay log file。到本篇文章为止，我们完成了对 DM 中的数据处理单元的介绍。从下一篇文章开始，我们将开始详细介绍 DM 内部主要功能的设计与实现原理。</p><p><i><b>更多阅读：</b></i></p><a href="https://link.zhihu.com/?target=https%3A//www.pingcap.com/blog-cn/%23DM-%25E6%25BA%2590%25E7%25A0%2581%25E9%2598%2585%25E8%25AF%25BB" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg" data-image-width="1200" data-image-height="1200" class=" wrap external" target="_blank" rel="nofollow noreferrer">博客 | PingCAP</a><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
