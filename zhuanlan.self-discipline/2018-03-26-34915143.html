<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>你好，类型（九）：Let polymorphism</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34915143">原文</a></p>
<p></p><img src="https://pic3.zhimg.com/v2-d8893deacbd14601cc4881797561323d_r.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="500"><h2><b>类型变量</b></h2><p>到目前为止，我们遇到的每一个 <equation>\lambda</equation> 项都有唯一确定的类型，<br>因为，项的类型都被显式的注释在了它的后面。<br>例如，我们可以定义一个恒等函数 <equation>id=\lambda x:Nat.~x:Nat\to Nat</equation> ，<br>则 <equation>id</equation> 的类型就是固定的， <equation>Nat\to Nat</equation> ，而 <equation>id~true</equation> 就不是良类型的。</p><p>为每一个类型的恒等函数都定义各自的版本，是非常繁琐的，<br>因此，一个自然的想法是，我们能否让 <equation>id</equation> 的类型<b>参数化</b>，<br>让它在不同的上下文中，实例化为不同的具体类型。<br>例如， <equation>id=\lambda x:X.~x:X\to X</equation> ，其中 <equation>X</equation> 是<b>类型参量</b>。</p><h2><b>类型代换</b></h2><p><b>类型代换</b> <equation>\sigma</equation> ，指的是一个从类型变量到类型的有限映射。<br>例如， <equation>\sigma=[X\mapsto T,Y\mapsto U]</equation> ，会将类型变量 <equation>X,Y</equation> 分别代换为 <equation>T,U</equation> 。<br>其中， <equation>X,Y</equation> 称为代换 <equation>\sigma</equation> 的<b>定义域</b>，记为 <equation>dom(\sigma)</equation> ，<br>而 <equation>T,U</equation> 称为代换 <equation>\sigma</equation> 的<b>值域</b>，记为 <equation>range(\sigma)</equation> 。</p><p>值得一提的是，所有的代换都是同时进行的， <equation>\sigma=[X\mapsto Bool,Y\mapsto X\to X]</equation> ，<br>是将 <equation>X</equation> 映射成 <equation>Bool</equation> ，将 <equation>Y</equation> 映射成 <equation>X\to X</equation> ，而不是 <equation>Bool\to Bool</equation> 。</p><p><b>代换</b>可以用下面的方式来定义，<br>（1） <equation>\sigma(X)=X</equation> ，如果 <equation>X\notin dom(\sigma)</equation> <br>（2） <equation>\sigma(X)=T</equation> ，如果 <equation>(X\mapsto T)\in\sigma</equation> <br>（3） <equation>\sigma(Nat)=Nat</equation> ， <equation>\sigma(Bool)=Bool</equation> <br>（4） <equation>\sigma(T_1\to T_2)=\sigma T_1\to\sigma T_2</equation> </p><p>对于类型上下文 <equation>\Gamma=\{x_1:T_1,\cdots,x_n:T_n\}</equation> 来说， <equation>\sigma\Gamma=\{x_1:\sigma T_1,\cdots,x_n:\sigma T_n\}</equation> 。</p><p>类型代换的一个重要特性是它保留了类型声明的有效性，<br>如果包含类型变量的项是良类型的，那么它的所有代换实例也都是良类型的。</p><h2><b>类型推断</b></h2><img src="https://pic3.zhimg.com/v2-691c692ba80fac2d4b7d02741c0a3da2_r.jpg" data-caption="" data-size="normal" data-rawwidth="753" data-rawheight="496"><p>在类型上下文 <equation>\Gamma</equation> 中，对于包含类型变量的项 <equation>t</equation> ，我们通常会提出两个问题，</p><p>（1）它的所有代换实例，是否都是良类型的？<br>即，是否 <equation>\forall\sigma\exists T,\sigma\Gamma\vdash\sigma t:T</equation> 。</p><p>（2）是否存在良类型的代换实例？<br>即，是否 <equation>\exists\sigma\exists T,\sigma\Gamma\vdash\sigma t:T</equation> 。</p><p>对于第一个问题，将引出<b>参数化多态</b>（<a href="https://en.wikipedia.org/wiki/Parametric_polymorphism">parametric polymorphism</a>），<br>例如， <equation>\lambda f:X\to X.\lambda a:X.f(f(a))</equation> ，它的类型为 <equation>(X\to X)\to X\to X</equation> ，<br>无论用什么具体类型 <equation>T</equation> 来代换 <equation>X</equation> ，代换实例都是良类型的。</p><p>对于第二个问题，原始的项可能不是良类型的，<br>但是可以选择合适的类型代换使之实例化为良类型的项。</p><p>例如， <equation>\lambda f:Y.\lambda a:X.f(f(a))</equation> ，是不可类型化的，<br>但是如果用 <equation>Nat\to Nat</equation> 代换 <equation>Y</equation> ，用 <equation>Nat</equation> 代换 <equation>X</equation> ，<br> <equation>\sigma=[X\mapsto Nat,Y\mapsto Nat\to Nat]</equation> ，<br>就可以得到， <equation>\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))</equation> ，<br>可类型化为 <equation>(Nat\to Nat)\to Nat\to Nat</equation> 。</p><p>或者，取 <equation>\sigma'=[Y\mapsto X\to X]</equation> ，结果也能得到一个良类型的项，尽管仍包含变量。</p><p>在寻找类型变量有效实例的过程中，出现了<b>类型推断</b>（<a href="https://en.wikipedia.org/wiki/Type_inference">type inference</a>）的概念。<br>意味着由编译器来帮助推断 <equation>\lambda</equation> 项的具体类型，<br>在<a href="https://en.wikipedia.org/wiki/ML_(programming_language)">ML</a>语言中，程序员可以忽略所有的类型注释——隐式类型（<a href="http://wiki.c2.com/?ImplicitTyping">implicit typing</a>）。</p><p>在进行推断的时候，对每一个原始的 <equation>\lambda</equation> 抽象 <equation>\lambda x.t</equation> ，<br>都用新的类型变量进行注释，写成 <equation>\lambda x:X.t</equation> ，<br>然后采取特定的类型推导算法，找到使项通过类型检查的一个最一般化的解。</p><p>设 <equation>\Gamma</equation> 为类型上下文， <equation>t</equation> 为项，<br> <equation>(\Gamma,t)</equation> 的<b>解</b>，是指这样的一个序对 <equation>(\sigma,T)</equation> ，使得 <equation>\sigma\Gamma\vdash\sigma t:T</equation> 成立。</p><p>例如，设 <equation>\Gamma=f:X,a:Y</equation> ， <equation>t=f~a</equation> ，则<br> <equation>(\sigma=[X\mapsto Y\to Nat],Nat)</equation> ， <equation>(\sigma=[X\mapsto Y\to Z],Z)</equation> ，都是 <equation>(\Gamma,t)</equation> 的解。</p><h2><b>基于约束的类型化</b></h2><img src="https://pic3.zhimg.com/v2-281fd8e3781690168c07b31e22bc9325_r.jpg" data-caption="" data-size="normal" data-rawwidth="333" data-rawheight="109"><p><b>（1）约束集</b></p><p>在实际情况中， <equation>(\Gamma,t)</equation> 的解，并不一定满足其他类型表达式的约束条件，<br>所以，我们寻找的是满足这些约束条件的特解。</p><p>所谓<b>约束条件</b>，实际上指的是约束集 <equation>C</equation> ，<br>它由一些包含类型参量的项的等式构成， <equation>\{S_i=T_i|i\in l..n\}</equation> 。</p><p>如果一个代换 <equation>\sigma</equation> 的代换实例， <equation>\sigma S</equation> 和 <equation>\sigma T</equation> 相同，则称该代换<b>合一</b>（unify）了等式 <equation>S=T</equation> 。<br>如果 <equation>\sigma</equation> 能合一 <equation>C</equation> 中的所有等式，则称 <equation>\sigma</equation> 能<b>合一</b>（unify）或满足（satisfy） <equation>C</equation> 。</p><p>我们用 <equation>\Gamma\vdash t:T|_\chi C</equation> ，来表示约束集 <equation>C</equation> 满足时，项 <equation>t</equation> 在 <equation>\Gamma</equation> 下的类型为 <equation>T</equation> ，<br>其中 <equation>\chi</equation> 为约束集中，所有类型变量的集合，有时为了讨论方便可以省略它。</p><p>例如，对于项 <equation>t=\lambda x:X\to Y.x~0</equation> ，<br>约束集可以写为 <equation>\{Nat\to Z=X\to Y\}</equation> ，则 <equation>t</equation> 类型为 <equation>(X\to Y)\to Z</equation> 。（算法略）<br>而代换 <equation>\sigma=[X\mapsto Nat,Z\mapsto Bool,Y\mapsto Bool]</equation> ，使得等式 <equation>Nat\to Z=X\to Y</equation> 成立，<br>所以，我们推断出了 <equation>(Nat\to Bool)\to Bool</equation> 是项 <equation>t</equation> 的一个可能类型。</p><p><b>（2）约束集的解</b></p><p>约束集的解一般不是唯一的，所以一个关键问题是如何确定一个“最好”的解。</p><p>我们称代换 <equation>\sigma</equation> 比 <equation>\sigma'</equation> <b>更具一般性</b>（more general），如果 <equation>\sigma'=\gamma\circ\sigma</equation> ，记为 <equation>\sigma\sqsubseteq\sigma'</equation> ，<br>其中， <equation>\gamma</equation> 为一个代换， <equation>\gamma\circ\sigma</equation> 表示代换的复合， <equation>(\gamma\circ\sigma)S=\gamma(\sigma S)</equation> 。</p><p>约束集 <equation>C</equation> 的<b>主合一子</b>（principal unifier）指的是代换 <equation>\sigma</equation> ，<br>它能满足 <equation>C</equation> ，且对于所有满足 <equation>C</equation> 的代换 <equation>\sigma'</equation> ，都有 <equation>\sigma\sqsubseteq\sigma'</equation> 。</p><p>如果 <equation>(\Gamma,t,S,C)</equation> 的解 <equation>(\sigma,T)</equation> ，对于任何其他解 <equation>(\sigma',T')</equation> ，都有 <equation>\sigma\sqsubseteq\sigma'</equation> ，<br>则称 <equation>(\sigma,T)</equation> 是一个<b>主解</b>（principal solution），称 <equation>T</equation>  为 <equation>t</equation> 的<b>主类型</b>（principal type）。<br>可以证明，如果 <equation>(\Gamma,t,S,C)</equation> 有解，则它必有一个主解。</p><h2><b>let多态</b></h2><img src="https://pic2.zhimg.com/v2-98db611b8facd70dd4be4eebdc7e1212_r.jpg" data-caption="" data-size="normal" data-rawwidth="633" data-rawheight="357"><p><b>多态</b>（polymorphism）指的是单独一段程序能在不同的上下文中实例化为不同的类型。<br>其中let多态，是由let表达式引入的多态性。</p><p><b>（1）单态性</b></p><p>假设我们定义了一个 <equation>double</equation> 函数，它能将一个函数对参数应用两次，<br> <equation>let~double=\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))~in</equation> <br><equation>~~~~double~(\lambda x:Nat.succ~x)~1</equation> <br>此时， <equation>double</equation> 的类型为 <equation>(Nat\to Nat)\to Nat\to Nat</equation> 。</p><p>如果我们想将 <equation>double</equation> 应用于其他类型，就必须重写一个新的 <equation>double'</equation> ，<br> <equation>let~double'=\lambda f:Bool\to Bool.\lambda a:Bool.f(f(a))~in</equation> <br><equation>~~~~double'~(\lambda x:Bool.x)~true</equation> <br>此时 <equation>double'</equation> 的类型为 <equation>(Bool\to Bool)\to Bool\to Bool</equation> 。</p><p>我们不能让一个 <equation>double</equation> 函数，既能用于 <equation>Nat</equation> 类型，又能用于 <equation>Bool</equation> 类型。<br>即使在 <equation>double</equation> 中用类型变量也没有用，<br> <equation>let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in~\cdots</equation> </p><p>例如，如果写，<br> <equation>let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in</equation> <br><equation>~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in</equation> <br><equation>~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots</equation> <br>则在 <equation>a</equation> 定义中使用 <equation>double</equation> ，会产生一个约束 <equation>X\to X=Nat\to Nat</equation> ，<br>而在 <equation>b</equation> 定义中使用 <equation>double</equation> ，则会产生约束 <equation>X\to X=Bool\to Bool</equation> ，<br>这样会使类型变量 <equation>X</equation> 的求解发生矛盾，导致整个程序不可类型化。</p><p><b>（2）多态性</b></p><p>let多态所做的事情，就是打破这个限制，<br>让类型参量 <equation>X</equation> 在上述不同的上下文中，可以分别实例化为 <equation>Nat</equation> 和 <equation>Bool</equation> 。</p><p>这需要改变与let表达式相关的类型推导规则，在第七篇中，我们提到过，<br> <equation>\frac{\Gamma\vdash t_1:T_1~~~~\Gamma,x:T_1\vdash t_2:T_2}{\Gamma\vdash let~x:T_1=t_1~in~t_2:T_2}</equation> <br>它会首先计算 <equation>T_1</equation> 作为 <equation>x</equation> 的类型，然后再用 <equation>x</equation> 来确定 <equation>T_2</equation> 的类型。<br>此时，let表达式 <equation>let~x=t_1:T_1~in~t_2</equation> ，可以看做 <equation>(\lambda x:T_1.t_2)t_1</equation> 的简写。</p><p>为了引入多态性，我们需要对上述类型推导规则进行修改，<br> <equation>\frac{\Gamma\vdash[x\mapsto t_1]t_2:T_2}{\Gamma\vdash let~x=t_1~in~t_2:T_2}</equation> <br>它表示，先将 <equation>t_2</equation> 中的 <equation>x</equation> 用 <equation>t_1</equation> 代换掉，然后再确定 <equation>t_2</equation> 的类型。</p><p>这样的话，<br> <equation>let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in</equation> <br><equation>~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in</equation> <br><equation>~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots</equation> </p><p>就相当于，<br> <equation>let~a=\lambda f:X\to X.\lambda a:X.f(f(a))~(\lambda x:Nat.succ~x)~1~in</equation> <br><equation>~~~~let~b=\lambda f:Y\to Y.\lambda a:Y.f(f(a))~(\lambda x:Bool.x)~true~in~\cdots</equation> <br>通过let多态，产生了 <equation>double</equation> 的两个<b>副本</b>，并为之分配了不同的类型参量。</p><p>此时，let表达式 <equation>let~x=t_1~in~t_2</equation> ，可以看做 <equation>[x\mapsto t_1]t_2</equation> 的简写。</p><hr><h2><b>参考</b></h2><p><a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Let-polymorphism">Hindley–Milner type system</a><br><a href="https://book.douban.com/subject/1761910/">Types and programming languages</a><br><a href="https://www.haskell.org/definition/haskell2010.pdf">Haskell 2010 Language Report</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
