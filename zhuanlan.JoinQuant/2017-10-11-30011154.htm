<div class="title-image"><img src="https://pic4.zhimg.com/v2-68d99dd5296c937c7d2638789e8b1c1f_b.jpg" alt=""></div><p>SciPy库提供了大量有用的函数和类，用来解决各种专业领域的问题。本文翻译自Jupyter nbviewer中的第三讲。首先，介绍了一些特殊函数，如贝塞尔函数，这对物理学问题的计算提供了方便；之后是各种数值积分问题，常微分方程求解问题以及傅里叶变换，这些也可以描述并求解一些诸如复摆运动、阻尼震荡等复杂的物理过程；同时，该库还可以高效处理线性代数问题，如矩阵的运算、特征值和特征向量以及稀疏矩阵的存储和运算；最优化问题，即寻找函数极值和零点的问题，和插值问题，即用多项式拟合曲线的问题，在SciPy库中也可以找到相应的函数；最后介绍了统计上的应用，包括各种分布的密度函数、分布函数及其图像绘制，以及一些统计检验问题。</p><p>作者：J.R. Johansson (邮箱：jrjohansson@gmail.com)</p><p>译者：一路向上</p><p>最新版本的用法介绍见网站<a href="https://link.zhihu.com/?target=http%3A//github.com/jrjohansson/scientific-python-lectures" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://github.com/jrjohansson/scientific-python-lectures.</a>其他相关介绍见<a href="https://link.zhihu.com/?target=http%3A//jrjohansson.github.io" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://jrjohansson.github.io.</a></p><figure><noscript><img src="https://pic3.zhimg.com/v2-232e1cc0daf154da5043f9aebb72dd5a_b.jpg" data-caption="" data-rawwidth="714" data-rawheight="90" class="origin_image zh-lightbox-thumb" width="714" data-original="https://pic3.zhimg.com/v2-232e1cc0daf154da5043f9aebb72dd5a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-232e1cc0daf154da5043f9aebb72dd5a_b.jpg" data-caption="" data-rawwidth="714" data-rawheight="90" class="origin_image zh-lightbox-thumb lazy" width="714" data-original="https://pic3.zhimg.com/v2-232e1cc0daf154da5043f9aebb72dd5a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-232e1cc0daf154da5043f9aebb72dd5a_b.jpg"/></figure><h2><b>简介</b></h2><p>SciPy框架建立于低一级的NumPy框架的多维数组之上，并且提供了大量的高级的科学算法。一些SciPy的应用如下：</p><ol><li>特殊函数 (scipy.special)</li><li>积分 (scipy.integrate)</li><li>优化 (scipy.optimize)</li><li>插值 (scipy.interpolate)</li><li>傅里叶变换 (scipy.fftpack)</li><li>信号处理 (scipy.signal)</li><li>线型代数 (scipy.linalg)</li><li>稀疏特征值问题 (scipy.sparse)</li><li>统计 (scipy.stats)</li><li>多维图像处理 (scipy.ndimage)</li><li>文件输入输出 (<a href="https://link.zhihu.com/?target=http%3A//scipy.io" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">scipy.io</span><span class="invisible"></span></a>)</li></ol><p>这些模块提供了大量的函数和类，可以用来解决各自领域的问题。 在本节中我们将看到如何使用这些子函数包。 我们首先导入scipy程序包：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-f0d6784ff8dc049ffa2c95b7274bda75_b.jpg" data-caption="" data-rawwidth="709" data-rawheight="37" class="origin_image zh-lightbox-thumb" width="709" data-original="https://pic2.zhimg.com/v2-f0d6784ff8dc049ffa2c95b7274bda75_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-f0d6784ff8dc049ffa2c95b7274bda75_b.jpg" data-caption="" data-rawwidth="709" data-rawheight="37" class="origin_image zh-lightbox-thumb lazy" width="709" data-original="https://pic2.zhimg.com/v2-f0d6784ff8dc049ffa2c95b7274bda75_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-f0d6784ff8dc049ffa2c95b7274bda75_b.jpg"/></figure><p>如果我们只需要用scipy框架中的一部分，我们也可以选择性的导入。例如，只导入线性代数函数包la，我们可以：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-02635e47319cf1bb7be96b704203e8bd_b.jpg" data-caption="" data-rawwidth="708" data-rawheight="37" class="origin_image zh-lightbox-thumb" width="708" data-original="https://pic2.zhimg.com/v2-02635e47319cf1bb7be96b704203e8bd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-02635e47319cf1bb7be96b704203e8bd_b.jpg" data-caption="" data-rawwidth="708" data-rawheight="37" class="origin_image zh-lightbox-thumb lazy" width="708" data-original="https://pic2.zhimg.com/v2-02635e47319cf1bb7be96b704203e8bd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-02635e47319cf1bb7be96b704203e8bd_b.jpg"/></figure><h2><b>特殊函数</b></h2><p>大量的数学函数对许多物理问题的计算是非常重要的。SciPy提供了一系列非常广泛的特殊函数。详见<a href="https://link.zhihu.com/?target=http%3A//docs.scipy.org/doc/scipy/reference/special.html%23module-scipy.special" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://docs.scipy.org/doc/scipy/reference/special.html#module-scipy.special.</a></p><p>为了说明指定的特殊函数的用法，我们先看一下贝塞尔函数的使用细节：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-b32a20bd9cdbd785bd34eea877108a15_b.jpg" data-caption="" data-rawwidth="711" data-rawheight="458" class="origin_image zh-lightbox-thumb" width="711" data-original="https://pic2.zhimg.com/v2-b32a20bd9cdbd785bd34eea877108a15_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-b32a20bd9cdbd785bd34eea877108a15_b.jpg" data-caption="" data-rawwidth="711" data-rawheight="458" class="origin_image zh-lightbox-thumb lazy" width="711" data-original="https://pic2.zhimg.com/v2-b32a20bd9cdbd785bd34eea877108a15_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-b32a20bd9cdbd785bd34eea877108a15_b.jpg"/></figure><figure><noscript><img src="https://pic3.zhimg.com/v2-fcee138035257a2ce6c98b0400534846_b.jpg" data-caption="" data-rawwidth="706" data-rawheight="370" class="origin_image zh-lightbox-thumb" width="706" data-original="https://pic3.zhimg.com/v2-fcee138035257a2ce6c98b0400534846_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-fcee138035257a2ce6c98b0400534846_b.jpg" data-caption="" data-rawwidth="706" data-rawheight="370" class="origin_image zh-lightbox-thumb lazy" width="706" data-original="https://pic3.zhimg.com/v2-fcee138035257a2ce6c98b0400534846_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-fcee138035257a2ce6c98b0400534846_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><h2><b>积分</b></h2><p><b>数值积分：求积公式</b></p><p>对f(x)从a到b的积分叫做数值积分，也叫简单积分。SciPy提供了一系列计算不同数值积分的函数，包括quad,dblquad和tplquad，分别包含二重和三重积分。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-88c7f14cc9267cf5bf2cdbde0f63c199_b.jpg" data-caption="" data-rawwidth="712" data-rawheight="37" class="origin_image zh-lightbox-thumb" width="712" data-original="https://pic2.zhimg.com/v2-88c7f14cc9267cf5bf2cdbde0f63c199_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-88c7f14cc9267cf5bf2cdbde0f63c199_b.jpg" data-caption="" data-rawwidth="712" data-rawheight="37" class="origin_image zh-lightbox-thumb lazy" width="712" data-original="https://pic2.zhimg.com/v2-88c7f14cc9267cf5bf2cdbde0f63c199_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-88c7f14cc9267cf5bf2cdbde0f63c199_b.jpg"/></figure><p>quad有一系列的可供选择的参数，可以用来调节函数的各种行为（输入help(quad)获取更多信息）。</p><p>其基本用途如下：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-7987624115bf66cef708e48767bcedc7_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="216" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic4.zhimg.com/v2-7987624115bf66cef708e48767bcedc7_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-7987624115bf66cef708e48767bcedc7_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="216" class="origin_image zh-lightbox-thumb lazy" width="718" data-original="https://pic4.zhimg.com/v2-7987624115bf66cef708e48767bcedc7_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-7987624115bf66cef708e48767bcedc7_b.jpg"/></figure><p>如果我们需要添加更多对于被积函数的参数，可以使用args关键字参数：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-2afcf43acd177c38e1cb25a3f1c0f693_b.jpg" data-caption="" data-rawwidth="719" data-rawheight="261" class="origin_image zh-lightbox-thumb" width="719" data-original="https://pic4.zhimg.com/v2-2afcf43acd177c38e1cb25a3f1c0f693_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-2afcf43acd177c38e1cb25a3f1c0f693_b.jpg" data-caption="" data-rawwidth="719" data-rawheight="261" class="origin_image zh-lightbox-thumb lazy" width="719" data-original="https://pic4.zhimg.com/v2-2afcf43acd177c38e1cb25a3f1c0f693_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-2afcf43acd177c38e1cb25a3f1c0f693_b.jpg"/></figure><p>对于简单函数而言，对于被积函数，我们可以用λ函数（无名称的函数）来代替清晰定义的函数：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-2d2120d775eeb02ac39f0c0c6dc032b2_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="156" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic3.zhimg.com/v2-2d2120d775eeb02ac39f0c0c6dc032b2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-2d2120d775eeb02ac39f0c0c6dc032b2_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="156" class="origin_image zh-lightbox-thumb lazy" width="718" data-original="https://pic3.zhimg.com/v2-2d2120d775eeb02ac39f0c0c6dc032b2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-2d2120d775eeb02ac39f0c0c6dc032b2_b.jpg"/></figure><p>如上所示，我们可以用&#39;Inf&#39;或者&#39;-Inf&#39;作为积分上下限。高维积分用法相同：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-4be218fba41cfeea0130767380c97c76_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="241" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic3.zhimg.com/v2-4be218fba41cfeea0130767380c97c76_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-4be218fba41cfeea0130767380c97c76_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="241" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic3.zhimg.com/v2-4be218fba41cfeea0130767380c97c76_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-4be218fba41cfeea0130767380c97c76_b.jpg"/></figure><p>注意，我们需要用λ函数对于y积分的极限，因为它们可以看做是x的函数。</p><p class="ztext-empty-paragraph"><br/></p><h2><b>常微分方程（ODE）</b></h2><p>SciPy提供了两种不同的方法来解决常微分方程：函数odeint的API，和函数类ode面向对象的API。通常odeint比较容易上手，但是ode函数类能够更好的控制函数。</p><p>这里我们使用odeint函数，如需了解更多ode函数类的信息，请输入help(ode)。它和odeint很像，但却是面向对象的函数。</p><p>使用odeint之前，首先从scipy.integrate中调用它：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-60db40f9a55a0f5d74f61de5f36bf77e_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="37" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic3.zhimg.com/v2-60db40f9a55a0f5d74f61de5f36bf77e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-60db40f9a55a0f5d74f61de5f36bf77e_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="37" class="origin_image zh-lightbox-thumb lazy" width="718" data-original="https://pic3.zhimg.com/v2-60db40f9a55a0f5d74f61de5f36bf77e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-60db40f9a55a0f5d74f61de5f36bf77e_b.jpg"/></figure><p>常微分方程系通常写作其一般形式：</p><p>    y&#39; = f(y, t)</p><p>其中</p><p>    y = [y1(t), y2(t), ..., yn(t)]</p><p>f的微分是<i>yi(t)</i>。为了解决常微分方程，我们需要知道函数<i>f</i>和初始条件<i>y(0)</i>.</p><p>高阶微分方程可以通过引进新的变量作为中间变量。</p><p>当我们定义了Python函数<i>f</i>和数组<i>y_0</i>(<i>f</i>和<i>y(0)</i>都是数学函数），我们调用odeint函数：</p><p>    y_t = odeint(f, y_0, t)</p><p>t是解决ODE问题需要的时间坐标数组，y_t是对于给定点在时间t的一行数组，每一列代表在给定时间t所对应的一个解y_i(t)。我们下面将会看到如何设置f和y_0.</p><p><b>例：复摆</b></p><p>我们考虑一个物理问题：复摆。定义详见<a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Double_pendulum" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://en.wikipedia.org/wiki/Double_pendulum.</a></p><figure><noscript><img src="https://pic2.zhimg.com/v2-3d5bccf9547d0ea5a5847a383430f711_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="246" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic2.zhimg.com/v2-3d5bccf9547d0ea5a5847a383430f711_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-3d5bccf9547d0ea5a5847a383430f711_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="246" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic2.zhimg.com/v2-3d5bccf9547d0ea5a5847a383430f711_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-3d5bccf9547d0ea5a5847a383430f711_b.jpg"/></figure><figure><noscript><img src="https://pic1.zhimg.com/v2-208fa3eef477169d8a0425381d942cac_b.jpg" data-caption="" data-rawwidth="527" data-rawheight="198" class="origin_image zh-lightbox-thumb" width="527" data-original="https://pic1.zhimg.com/v2-208fa3eef477169d8a0425381d942cac_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-208fa3eef477169d8a0425381d942cac_b.jpg" data-caption="" data-rawwidth="527" data-rawheight="198" class="origin_image zh-lightbox-thumb lazy" width="527" data-original="https://pic1.zhimg.com/v2-208fa3eef477169d8a0425381d942cac_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-208fa3eef477169d8a0425381d942cac_b.jpg"/></figure><p>为了让Python代码看起来更简洁，我们引进新的变量，并规定：</p><figure><noscript><img src="https://pic1.zhimg.com/v2-a48778bb30513d882e9fba17a45b1bc0_b.jpg" data-caption="" data-rawwidth="521" data-rawheight="261" class="origin_image zh-lightbox-thumb" width="521" data-original="https://pic1.zhimg.com/v2-a48778bb30513d882e9fba17a45b1bc0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-a48778bb30513d882e9fba17a45b1bc0_b.jpg" data-caption="" data-rawwidth="521" data-rawheight="261" class="origin_image zh-lightbox-thumb lazy" width="521" data-original="https://pic1.zhimg.com/v2-a48778bb30513d882e9fba17a45b1bc0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-a48778bb30513d882e9fba17a45b1bc0_b.jpg"/></figure><figure><noscript><img src="https://pic1.zhimg.com/v2-32b381a5099483bd1180c65d701e7960_b.jpg" data-caption="" data-rawwidth="720" data-rawheight="356" class="origin_image zh-lightbox-thumb" width="720" data-original="https://pic1.zhimg.com/v2-32b381a5099483bd1180c65d701e7960_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-32b381a5099483bd1180c65d701e7960_b.jpg" data-caption="" data-rawwidth="720" data-rawheight="356" class="origin_image zh-lightbox-thumb lazy" width="720" data-original="https://pic1.zhimg.com/v2-32b381a5099483bd1180c65d701e7960_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-32b381a5099483bd1180c65d701e7960_b.jpg"/></figure><figure><noscript><img src="https://pic3.zhimg.com/v2-1f8ea4c7860a0f4cbd4101921b8da07e_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="425" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic3.zhimg.com/v2-1f8ea4c7860a0f4cbd4101921b8da07e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-1f8ea4c7860a0f4cbd4101921b8da07e_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="425" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic3.zhimg.com/v2-1f8ea4c7860a0f4cbd4101921b8da07e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-1f8ea4c7860a0f4cbd4101921b8da07e_b.jpg"/></figure><figure><noscript><img src="https://pic3.zhimg.com/v2-bb5304a1fb7d19df16804decfaacc74e_b.jpg" data-caption="" data-rawwidth="602" data-rawheight="239" class="origin_image zh-lightbox-thumb" width="602" data-original="https://pic3.zhimg.com/v2-bb5304a1fb7d19df16804decfaacc74e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-bb5304a1fb7d19df16804decfaacc74e_b.jpg" data-caption="" data-rawwidth="602" data-rawheight="239" class="origin_image zh-lightbox-thumb lazy" width="602" data-original="https://pic3.zhimg.com/v2-bb5304a1fb7d19df16804decfaacc74e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-bb5304a1fb7d19df16804decfaacc74e_b.jpg"/></figure><p>在matplotlib函数的应用中，会介绍如何绘制复摆运动的动图。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-caa045775d69ad681f1e205e28e1b8b1_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="419" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic2.zhimg.com/v2-caa045775d69ad681f1e205e28e1b8b1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-caa045775d69ad681f1e205e28e1b8b1_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="419" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic2.zhimg.com/v2-caa045775d69ad681f1e205e28e1b8b1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-caa045775d69ad681f1e205e28e1b8b1_b.jpg"/></figure><figure><noscript><img src="https://pic3.zhimg.com/v2-bb5304a1fb7d19df16804decfaacc74e_b.jpg" data-caption="" data-rawwidth="602" data-rawheight="239" class="origin_image zh-lightbox-thumb" width="602" data-original="https://pic3.zhimg.com/v2-bb5304a1fb7d19df16804decfaacc74e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-bb5304a1fb7d19df16804decfaacc74e_b.jpg" data-caption="" data-rawwidth="602" data-rawheight="239" class="origin_image zh-lightbox-thumb lazy" width="602" data-original="https://pic3.zhimg.com/v2-bb5304a1fb7d19df16804decfaacc74e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-bb5304a1fb7d19df16804decfaacc74e_b.jpg"/></figure><p>在matplotlib函数的应用中，会介绍如何绘制复摆运动的动图。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-caa045775d69ad681f1e205e28e1b8b1_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="419" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic2.zhimg.com/v2-caa045775d69ad681f1e205e28e1b8b1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-caa045775d69ad681f1e205e28e1b8b1_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="419" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic2.zhimg.com/v2-caa045775d69ad681f1e205e28e1b8b1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-caa045775d69ad681f1e205e28e1b8b1_b.jpg"/></figure><figure><noscript><img src="https://pic3.zhimg.com/v2-9b7236f9a48badfcec80a1065cfa5b92_b.jpg" data-caption="" data-rawwidth="550" data-rawheight="374" class="origin_image zh-lightbox-thumb" width="550" data-original="https://pic3.zhimg.com/v2-9b7236f9a48badfcec80a1065cfa5b92_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-9b7236f9a48badfcec80a1065cfa5b92_b.jpg" data-caption="" data-rawwidth="550" data-rawheight="374" class="origin_image zh-lightbox-thumb lazy" width="550" data-original="https://pic3.zhimg.com/v2-9b7236f9a48badfcec80a1065cfa5b92_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-9b7236f9a48badfcec80a1065cfa5b92_b.jpg"/></figure><figure><noscript><img src="https://pic1.zhimg.com/v2-5cbdca5bd0ce0b1acb27536638900254_b.jpg" data-caption="" data-rawwidth="528" data-rawheight="289" class="origin_image zh-lightbox-thumb" width="528" data-original="https://pic1.zhimg.com/v2-5cbdca5bd0ce0b1acb27536638900254_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-5cbdca5bd0ce0b1acb27536638900254_b.jpg" data-caption="" data-rawwidth="528" data-rawheight="289" class="origin_image zh-lightbox-thumb lazy" width="528" data-original="https://pic1.zhimg.com/v2-5cbdca5bd0ce0b1acb27536638900254_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-5cbdca5bd0ce0b1acb27536638900254_b.jpg"/></figure><p>ps:这里的结果不是报错，是因为最后一行代码是每0.1s更新一次状态，为了后面的函数能够正常运行，我把它停掉了。</p><p><b>例： 阻尼谐波振荡器</b></p><p>常微分方程问题对计算物理非常重要，下面我们来看另一个例子：阻尼谐波振荡器。关于概念的解释详见 <a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Damping" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://en.wikipedia.org/wiki/Damping.</a></p><p>阻尼谐波振荡器的方程为：</p><figure><noscript><img src="https://pic1.zhimg.com/v2-bfc9119d208749b25b654e92eead8a4c_b.jpg" data-caption="" data-rawwidth="450" data-rawheight="67" class="origin_image zh-lightbox-thumb" width="450" data-original="https://pic1.zhimg.com/v2-bfc9119d208749b25b654e92eead8a4c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-bfc9119d208749b25b654e92eead8a4c_b.jpg" data-caption="" data-rawwidth="450" data-rawheight="67" class="origin_image zh-lightbox-thumb lazy" width="450" data-original="https://pic1.zhimg.com/v2-bfc9119d208749b25b654e92eead8a4c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-bfc9119d208749b25b654e92eead8a4c_b.jpg"/></figure><p>x是振荡器的位置， <img src="https://www.zhihu.com/equation?tex=%5Comega_%7B0%7D" alt="\omega_{0}" eeimg="1"/> 是频率， <img src="https://www.zhihu.com/equation?tex=%5Czeta" alt="\zeta" eeimg="1"/> 是阻尼比。为了写出标准形式的二阶常微分方程，我们引入 <img src="https://www.zhihu.com/equation?tex=p%3D%5Cfrac%7Bdx%7D%7Bdt%7D" alt="p=\frac{dx}{dt}" eeimg="1"/> ：</p><figure><noscript><img src="https://pic1.zhimg.com/v2-8f7bc4b8dd51e2e24aa49b58f810e1ec_b.jpg" data-caption="" data-rawwidth="364" data-rawheight="95" class="content_image" width="364"/></noscript><img src="https://pic1.zhimg.com/v2-8f7bc4b8dd51e2e24aa49b58f810e1ec_b.jpg" data-caption="" data-rawwidth="364" data-rawheight="95" class="content_image lazy" width="364" data-actualsrc="https://pic1.zhimg.com/v2-8f7bc4b8dd51e2e24aa49b58f810e1ec_b.jpg"/></figure><p>在这个例子中，我们将为常微分方程等号右边的函数添加额外的参数，而不是像前面的例子那样使用全局变量。作为等号右边函数的额外参数的结果，我们需要将一个关键字参数args传递给odeint函数：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-2c0b32ed44016213e9cc1e2f27d29cbd_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="251" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic2.zhimg.com/v2-2c0b32ed44016213e9cc1e2f27d29cbd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-2c0b32ed44016213e9cc1e2f27d29cbd_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="251" class="origin_image zh-lightbox-thumb lazy" width="718" data-original="https://pic2.zhimg.com/v2-2c0b32ed44016213e9cc1e2f27d29cbd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-2c0b32ed44016213e9cc1e2f27d29cbd_b.jpg"/></figure><figure><noscript><img src="https://pic1.zhimg.com/v2-e4df1ad33d80b7348ca78fa508d9bca4_b.jpg" data-caption="" data-rawwidth="716" data-rawheight="323" class="origin_image zh-lightbox-thumb" width="716" data-original="https://pic1.zhimg.com/v2-e4df1ad33d80b7348ca78fa508d9bca4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-e4df1ad33d80b7348ca78fa508d9bca4_b.jpg" data-caption="" data-rawwidth="716" data-rawheight="323" class="origin_image zh-lightbox-thumb lazy" width="716" data-original="https://pic1.zhimg.com/v2-e4df1ad33d80b7348ca78fa508d9bca4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-e4df1ad33d80b7348ca78fa508d9bca4_b.jpg"/></figure><figure><noscript><img src="https://pic4.zhimg.com/v2-01a17dc6910c97b2e6e6fb9dab7099c3_b.jpg" data-caption="" data-rawwidth="614" data-rawheight="250" class="origin_image zh-lightbox-thumb" width="614" data-original="https://pic4.zhimg.com/v2-01a17dc6910c97b2e6e6fb9dab7099c3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-01a17dc6910c97b2e6e6fb9dab7099c3_b.jpg" data-caption="" data-rawwidth="614" data-rawheight="250" class="origin_image zh-lightbox-thumb lazy" width="614" data-original="https://pic4.zhimg.com/v2-01a17dc6910c97b2e6e6fb9dab7099c3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-01a17dc6910c97b2e6e6fb9dab7099c3_b.jpg"/></figure><h2><b>傅里叶变换</b></h2><p>傅里叶变换是计算物理中的一种通用工具，它在不同文章中都会反复出现。SciPy提供能够从NetLib中接入经典FFTPACK库的函数，它是由FORTRAN语言编写的一个行之有效的FFT库。SciPy API有一些额外的便利功能，但总的来说，API和原来的FORTRAN库密切相关。</p><p>为了调用fftpack，请输入：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-a413adacd205c27f6749ed814fc4e12f_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="55" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic4.zhimg.com/v2-a413adacd205c27f6749ed814fc4e12f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-a413adacd205c27f6749ed814fc4e12f_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="55" class="origin_image zh-lightbox-thumb lazy" width="718" data-original="https://pic4.zhimg.com/v2-a413adacd205c27f6749ed814fc4e12f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-a413adacd205c27f6749ed814fc4e12f_b.jpg"/></figure><p>为演示如何用SciPy做一个快速傅里叶变换，让我们来看看用FFT如何解决之前讨论的阻尼震荡问题：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-b8857eff49fbc4d8df53e6b7187a7f2a_b.jpg" data-caption="" data-rawwidth="719" data-rawheight="434" class="origin_image zh-lightbox-thumb" width="719" data-original="https://pic3.zhimg.com/v2-b8857eff49fbc4d8df53e6b7187a7f2a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-b8857eff49fbc4d8df53e6b7187a7f2a_b.jpg" data-caption="" data-rawwidth="719" data-rawheight="434" class="origin_image zh-lightbox-thumb lazy" width="719" data-original="https://pic3.zhimg.com/v2-b8857eff49fbc4d8df53e6b7187a7f2a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-b8857eff49fbc4d8df53e6b7187a7f2a_b.jpg"/></figure><p>由于信号是实数，所以谱线图是对称的。我们因此只需要画出对应正频率的部分。为了提取w和F的部分，我们可以运用NumPy库：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-ac68676f08afe5c06b530e4f2d76c333_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="352" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic4.zhimg.com/v2-ac68676f08afe5c06b530e4f2d76c333_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-ac68676f08afe5c06b530e4f2d76c333_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="352" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic4.zhimg.com/v2-ac68676f08afe5c06b530e4f2d76c333_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-ac68676f08afe5c06b530e4f2d76c333_b.jpg"/></figure><p>和预期一样，我们看到谱线图在1处达到最高点，这正是在阻尼震荡这个例子中所采用的频率。</p><h2><b>线性代数 </b></h2><p>线性代数部分包含了许多矩阵函数，包括线性方程的解，特征值的解，矩阵函数（例如矩阵指数函数），许多不同的分解（SVD，LU，cholesky）等等。详见：<a href="https://link.zhihu.com/?target=http%3A//docs.scipy.org/doc/scipy/reference/linalg.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://docs.scipy.org/doc/scipy/reference/linalg.html.</a></p><p>下面我们看看如何使用这些函数：</p><p><b>1、线性方程组</b></p><p>线性方程组的矩阵形式： </p><figure><noscript><img src="https://pic3.zhimg.com/v2-caf0169358a9dd0708df794dbff86266_b.jpg" data-caption="" data-rawwidth="309" data-rawheight="26" class="content_image" width="309"/></noscript><img src="https://pic3.zhimg.com/v2-caf0169358a9dd0708df794dbff86266_b.jpg" data-caption="" data-rawwidth="309" data-rawheight="26" class="content_image lazy" width="309" data-actualsrc="https://pic3.zhimg.com/v2-caf0169358a9dd0708df794dbff86266_b.jpg"/></figure><p>A是矩阵，x,b是向量。可以求解如下：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-a5cf664137cacc234adadb82a04c78e5_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="267" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic2.zhimg.com/v2-a5cf664137cacc234adadb82a04c78e5_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-a5cf664137cacc234adadb82a04c78e5_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="267" class="origin_image zh-lightbox-thumb lazy" width="718" data-original="https://pic2.zhimg.com/v2-a5cf664137cacc234adadb82a04c78e5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-a5cf664137cacc234adadb82a04c78e5_b.jpg"/></figure><p>我们也可以：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-68b97b75436ef6be574ea4280eb5235f_b.jpg" data-caption="" data-rawwidth="253" data-rawheight="28" class="content_image" width="253"/></noscript><img src="https://pic4.zhimg.com/v2-68b97b75436ef6be574ea4280eb5235f_b.jpg" data-caption="" data-rawwidth="253" data-rawheight="28" class="content_image lazy" width="253" data-actualsrc="https://pic4.zhimg.com/v2-68b97b75436ef6be574ea4280eb5235f_b.jpg"/></figure><p>这里A,B,X都是矩阵：</p><figure><noscript><img src="https://pic1.zhimg.com/v2-53f29dce6be78ae1e9bc8fcfa9a3c20c_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="280" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic1.zhimg.com/v2-53f29dce6be78ae1e9bc8fcfa9a3c20c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-53f29dce6be78ae1e9bc8fcfa9a3c20c_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="280" class="origin_image zh-lightbox-thumb lazy" width="718" data-original="https://pic1.zhimg.com/v2-53f29dce6be78ae1e9bc8fcfa9a3c20c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-53f29dce6be78ae1e9bc8fcfa9a3c20c_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p><b>2、特征值和特征向量</b></p><p>矩阵A的特征值问题是：</p><figure><noscript><img src="https://pic3.zhimg.com/v2-9087969272f6fcc59a543c44993567d2_b.jpg" data-caption="" data-rawwidth="312" data-rawheight="26" class="content_image" width="312"/></noscript><img src="https://pic3.zhimg.com/v2-9087969272f6fcc59a543c44993567d2_b.jpg" data-caption="" data-rawwidth="312" data-rawheight="26" class="content_image lazy" width="312" data-actualsrc="https://pic3.zhimg.com/v2-9087969272f6fcc59a543c44993567d2_b.jpg"/></figure><p>这里 <img src="https://www.zhihu.com/equation?tex=v_%7Bn%7D" alt="v_{n}" eeimg="1"/> 是第n个特征向量， <img src="https://www.zhihu.com/equation?tex=%5Clambda_%7Bn%7D" alt="\lambda_{n}" eeimg="1"/> 是第n个特征值：</p><p>用eigvals计算矩阵的特征值，用eig计算特征值和特征向量：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-ef1708d2138e127e0f96628bc7176d61_b.jpg" data-caption="" data-rawwidth="720" data-rawheight="323" class="origin_image zh-lightbox-thumb" width="720" data-original="https://pic2.zhimg.com/v2-ef1708d2138e127e0f96628bc7176d61_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-ef1708d2138e127e0f96628bc7176d61_b.jpg" data-caption="" data-rawwidth="720" data-rawheight="323" class="origin_image zh-lightbox-thumb lazy" width="720" data-original="https://pic2.zhimg.com/v2-ef1708d2138e127e0f96628bc7176d61_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-ef1708d2138e127e0f96628bc7176d61_b.jpg"/></figure><p>第n个特征值（储存在evals[n]中）对应的特征向量是evecs的第n列，也就是evecs[:,n]. 为了验证它，我们尝试把矩阵和特征向量相乘，并与特征向量和特征值的乘积做比较：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-ba2517da530541182dfd782bd1d34755_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="92" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic2.zhimg.com/v2-ba2517da530541182dfd782bd1d34755_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-ba2517da530541182dfd782bd1d34755_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="92" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic2.zhimg.com/v2-ba2517da530541182dfd782bd1d34755_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-ba2517da530541182dfd782bd1d34755_b.jpg"/></figure><p>还有许多其他的特殊的本征解，如埃尔米特矩阵（用eigh实现）</p><p class="ztext-empty-paragraph"><br/></p><p><b>3、矩阵运算</b></p><figure><noscript><img src="https://pic4.zhimg.com/v2-3898e0bdf5acc260ccd0e4edb929b807_b.jpg" data-caption="" data-rawwidth="716" data-rawheight="281" class="origin_image zh-lightbox-thumb" width="716" data-original="https://pic4.zhimg.com/v2-3898e0bdf5acc260ccd0e4edb929b807_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-3898e0bdf5acc260ccd0e4edb929b807_b.jpg" data-caption="" data-rawwidth="716" data-rawheight="281" class="origin_image zh-lightbox-thumb lazy" width="716" data-original="https://pic4.zhimg.com/v2-3898e0bdf5acc260ccd0e4edb929b807_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-3898e0bdf5acc260ccd0e4edb929b807_b.jpg"/></figure><p><b>4、稀疏矩阵</b></p><p>稀疏矩阵在处理巨型系统的数值模拟时非常有用，如果描述该问题的矩阵或向量大部分的元素为0。Scipy对于稀疏矩阵有很多处理方法，包括基础的线性代数处理（包括解方程，计算特征值等等）</p><p>许多方法都能有效存储稀疏矩阵，一些常用的方法包括坐标形式（COO）,列表的列表形式（LIL），压缩稀疏列（CSC）和压缩稀疏行（CSR）。每种方法都有优势和不足。大多数的计算算法（解方程，矩阵和矩阵相乘等等）都能用CSR或者CSC形式处理，但是它们并不直观，也不太容易进行初始化。所以通常来说，稀疏矩阵采用COO或者LIL进行初始化（我们可以在稀疏矩阵中有效添加元素），然后再转换为CSC或者CSR并进行计算。</p><p>更多关于稀疏矩阵的信息，详见： <a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Sparse_matrix" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://en.wikipedia.org/wiki/Sparse_matrix.</a></p><p>当我们创建了一个稀疏矩阵，我们要选择其存储形式，如：</p><figure><noscript><img src="https://pic1.zhimg.com/v2-eff35f32ea89d363a28ab0bddc9a3a5c_b.jpg" data-caption="" data-rawwidth="719" data-rawheight="410" class="origin_image zh-lightbox-thumb" width="719" data-original="https://pic1.zhimg.com/v2-eff35f32ea89d363a28ab0bddc9a3a5c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-eff35f32ea89d363a28ab0bddc9a3a5c_b.jpg" data-caption="" data-rawwidth="719" data-rawheight="410" class="origin_image zh-lightbox-thumb lazy" width="719" data-original="https://pic1.zhimg.com/v2-eff35f32ea89d363a28ab0bddc9a3a5c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-eff35f32ea89d363a28ab0bddc9a3a5c_b.jpg"/></figure><p>创建稀疏矩阵更有效的方法是，建立一个空矩阵，并用所在矩阵的位置填充（避免创建大的稠密矩阵）：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-a1598a69516a861d9204ef790c5dd8bd_b.jpg" data-caption="" data-rawwidth="716" data-rawheight="380" class="origin_image zh-lightbox-thumb" width="716" data-original="https://pic2.zhimg.com/v2-a1598a69516a861d9204ef790c5dd8bd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-a1598a69516a861d9204ef790c5dd8bd_b.jpg" data-caption="" data-rawwidth="716" data-rawheight="380" class="origin_image zh-lightbox-thumb lazy" width="716" data-original="https://pic2.zhimg.com/v2-a1598a69516a861d9204ef790c5dd8bd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-a1598a69516a861d9204ef790c5dd8bd_b.jpg"/></figure><figure><noscript><img src="https://pic2.zhimg.com/v2-6780e75cd19d559cc28b677a7ded82d1_b.jpg" data-caption="" data-rawwidth="722" data-rawheight="451" class="origin_image zh-lightbox-thumb" width="722" data-original="https://pic2.zhimg.com/v2-6780e75cd19d559cc28b677a7ded82d1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-6780e75cd19d559cc28b677a7ded82d1_b.jpg" data-caption="" data-rawwidth="722" data-rawheight="451" class="origin_image zh-lightbox-thumb lazy" width="722" data-original="https://pic2.zhimg.com/v2-6780e75cd19d559cc28b677a7ded82d1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-6780e75cd19d559cc28b677a7ded82d1_b.jpg"/></figure><figure><noscript><img src="https://pic2.zhimg.com/v2-8e81f0922c71f82474a80c8b0fd38011_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="489" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic2.zhimg.com/v2-8e81f0922c71f82474a80c8b0fd38011_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-8e81f0922c71f82474a80c8b0fd38011_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="489" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic2.zhimg.com/v2-8e81f0922c71f82474a80c8b0fd38011_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-8e81f0922c71f82474a80c8b0fd38011_b.jpg"/></figure><figure><noscript><img src="https://pic1.zhimg.com/v2-e16203696814945b8dc2d72109b40c30_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="128" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic1.zhimg.com/v2-e16203696814945b8dc2d72109b40c30_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-e16203696814945b8dc2d72109b40c30_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="128" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic1.zhimg.com/v2-e16203696814945b8dc2d72109b40c30_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-e16203696814945b8dc2d72109b40c30_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><h2><b>最优化</b></h2><p>最优化问题（寻找函数的最大值或者最小值）是数学的一大领域，复杂函数的最优化问题，或者多变量的最优化问题可能会非常复杂。下面我们看一些很简单的例子，更多详细的对于使用SciPy处理最优化问题的介绍，请见：<a href="https://link.zhihu.com/?target=http%3A//scipy-lectures.github.com/advanced/mathematical_optimization/index.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://scipy-lectures.github.com/advanced/mathematical_optimization/index.html.</a></p><p>首先调用optimize：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-b46c56ece470610a2b80507eb98723d5_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="35" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic2.zhimg.com/v2-b46c56ece470610a2b80507eb98723d5_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-b46c56ece470610a2b80507eb98723d5_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="35" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic2.zhimg.com/v2-b46c56ece470610a2b80507eb98723d5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-b46c56ece470610a2b80507eb98723d5_b.jpg"/></figure><p><b>寻找最小值</b></p><p>首先我们看如何寻找单变量的简单函数的最小值：</p><figure><noscript><img src="https://pic1.zhimg.com/v2-77fcc968f77f628d9d25edf1292cf444_b.jpg" data-caption="" data-rawwidth="722" data-rawheight="382" class="origin_image zh-lightbox-thumb" width="722" data-original="https://pic1.zhimg.com/v2-77fcc968f77f628d9d25edf1292cf444_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-77fcc968f77f628d9d25edf1292cf444_b.jpg" data-caption="" data-rawwidth="722" data-rawheight="382" class="origin_image zh-lightbox-thumb lazy" width="722" data-original="https://pic1.zhimg.com/v2-77fcc968f77f628d9d25edf1292cf444_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-77fcc968f77f628d9d25edf1292cf444_b.jpg"/></figure><p>我们可以用fmin_bfgs寻找函数的最小值：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-66dc1cf59d8c938315ece7c4d8764e35_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="340" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic2.zhimg.com/v2-66dc1cf59d8c938315ece7c4d8764e35_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-66dc1cf59d8c938315ece7c4d8764e35_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="340" class="origin_image zh-lightbox-thumb lazy" width="718" data-original="https://pic2.zhimg.com/v2-66dc1cf59d8c938315ece7c4d8764e35_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-66dc1cf59d8c938315ece7c4d8764e35_b.jpg"/></figure><p>我们还可以用brent或者fminbound函数，它们采用了不太一样的语法和算法。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-e6f164ccd2c3d09c47e49a4f9ab64d91_b.jpg" data-caption="" data-rawwidth="715" data-rawheight="127" class="origin_image zh-lightbox-thumb" width="715" data-original="https://pic2.zhimg.com/v2-e6f164ccd2c3d09c47e49a4f9ab64d91_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-e6f164ccd2c3d09c47e49a4f9ab64d91_b.jpg" data-caption="" data-rawwidth="715" data-rawheight="127" class="origin_image zh-lightbox-thumb lazy" width="715" data-original="https://pic2.zhimg.com/v2-e6f164ccd2c3d09c47e49a4f9ab64d91_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-e6f164ccd2c3d09c47e49a4f9ab64d91_b.jpg"/></figure><p><b>寻找函数的解</b></p><p>为了寻找函数f(x) = 0 的解，我们可以用fsolve函数，它需要一个初始的猜测值：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-7160cbbed937d21a8d3c8e2c8c8cfb07_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="284" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic4.zhimg.com/v2-7160cbbed937d21a8d3c8e2c8c8cfb07_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-7160cbbed937d21a8d3c8e2c8c8cfb07_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="284" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic4.zhimg.com/v2-7160cbbed937d21a8d3c8e2c8c8cfb07_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-7160cbbed937d21a8d3c8e2c8c8cfb07_b.jpg"/></figure><figure><noscript><img src="https://pic1.zhimg.com/v2-e9df3b2320754112e504e607cc543154_b.jpg" data-caption="" data-rawwidth="716" data-rawheight="458" class="origin_image zh-lightbox-thumb" width="716" data-original="https://pic1.zhimg.com/v2-e9df3b2320754112e504e607cc543154_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-e9df3b2320754112e504e607cc543154_b.jpg" data-caption="" data-rawwidth="716" data-rawheight="458" class="origin_image zh-lightbox-thumb lazy" width="716" data-original="https://pic1.zhimg.com/v2-e9df3b2320754112e504e607cc543154_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-e9df3b2320754112e504e607cc543154_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><h2><b>插值</b></h2><p>插值在SciPy中能够很容易和方便的实现：interpid函数，当描述X和Y的数据时，返回值是被称之为x的任意值（X的范围）的函数，同时返回相应的插值y：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-5f37a26104599f8ae58803863bd58d4d_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="437" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic2.zhimg.com/v2-5f37a26104599f8ae58803863bd58d4d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-5f37a26104599f8ae58803863bd58d4d_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="437" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic2.zhimg.com/v2-5f37a26104599f8ae58803863bd58d4d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-5f37a26104599f8ae58803863bd58d4d_b.jpg"/></figure><figure><noscript><img src="https://pic3.zhimg.com/v2-924595995e95c39a1ef9a7665f1a9fa2_b.jpg" data-caption="" data-rawwidth="593" data-rawheight="292" class="origin_image zh-lightbox-thumb" width="593" data-original="https://pic3.zhimg.com/v2-924595995e95c39a1ef9a7665f1a9fa2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-924595995e95c39a1ef9a7665f1a9fa2_b.jpg" data-caption="" data-rawwidth="593" data-rawheight="292" class="origin_image zh-lightbox-thumb lazy" width="593" data-original="https://pic3.zhimg.com/v2-924595995e95c39a1ef9a7665f1a9fa2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-924595995e95c39a1ef9a7665f1a9fa2_b.jpg"/></figure><h2><b>统计</b></h2><p>scipy.stats包含了许多统计分布，统计函数和检验。完整的功能请见：<a href="https://link.zhihu.com/?target=http%3A//docs.scipy.org/doc/scipy/reference/stats.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://docs.scipy.org/doc/scipy/reference/stats.html.</a></p><p>还有一个非常强大的统计模型的包叫做statsmodels，详见：<a href="https://link.zhihu.com/?target=http%3A//statsmodels.sourceforge.net" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://statsmodels.sourceforge.net.</a></p><figure><noscript><img src="https://pic4.zhimg.com/v2-c7e82cfda4f875d874d11ac5e85d7fb7_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="343" class="origin_image zh-lightbox-thumb" width="718" data-original="https://pic4.zhimg.com/v2-c7e82cfda4f875d874d11ac5e85d7fb7_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-c7e82cfda4f875d874d11ac5e85d7fb7_b.jpg" data-caption="" data-rawwidth="718" data-rawheight="343" class="origin_image zh-lightbox-thumb lazy" width="718" data-original="https://pic4.zhimg.com/v2-c7e82cfda4f875d874d11ac5e85d7fb7_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-c7e82cfda4f875d874d11ac5e85d7fb7_b.jpg"/></figure><figure><noscript><img src="https://pic2.zhimg.com/v2-4679700caa9242f781a83a07152998d5_b.jpg" data-caption="" data-rawwidth="623" data-rawheight="249" class="origin_image zh-lightbox-thumb" width="623" data-original="https://pic2.zhimg.com/v2-4679700caa9242f781a83a07152998d5_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-4679700caa9242f781a83a07152998d5_b.jpg" data-caption="" data-rawwidth="623" data-rawheight="249" class="origin_image zh-lightbox-thumb lazy" width="623" data-original="https://pic2.zhimg.com/v2-4679700caa9242f781a83a07152998d5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-4679700caa9242f781a83a07152998d5_b.jpg"/></figure><figure><noscript><img src="https://pic1.zhimg.com/v2-4d983662d271057455c72af713d31bd4_b.jpg" data-caption="" data-rawwidth="719" data-rawheight="532" class="origin_image zh-lightbox-thumb" width="719" data-original="https://pic1.zhimg.com/v2-4d983662d271057455c72af713d31bd4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-4d983662d271057455c72af713d31bd4_b.jpg" data-caption="" data-rawwidth="719" data-rawheight="532" class="origin_image zh-lightbox-thumb lazy" width="719" data-original="https://pic1.zhimg.com/v2-4d983662d271057455c72af713d31bd4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-4d983662d271057455c72af713d31bd4_b.jpg"/></figure><p>统计结果：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-2645a0c635c568a6c0831e4070182947_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="127" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic4.zhimg.com/v2-2645a0c635c568a6c0831e4070182947_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-2645a0c635c568a6c0831e4070182947_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="127" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic4.zhimg.com/v2-2645a0c635c568a6c0831e4070182947_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-2645a0c635c568a6c0831e4070182947_b.jpg"/></figure><p><b>统计检验</b></p><p>检验两组（独立）随机数据是否来自同一个分布：</p><figure><noscript><img src="https://pic4.zhimg.com/v2-cb37809e23c68ee0edd3895b95ed4f1f_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="124" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic4.zhimg.com/v2-cb37809e23c68ee0edd3895b95ed4f1f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-cb37809e23c68ee0edd3895b95ed4f1f_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="124" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic4.zhimg.com/v2-cb37809e23c68ee0edd3895b95ed4f1f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-cb37809e23c68ee0edd3895b95ed4f1f_b.jpg"/></figure><p>因为p值很大，我们不能拒绝原假设（两组随机数据有相同的均值）。</p><p>为了检验单个样本的数据是否均值为0.1（实际均值为0.0）：</p><figure><noscript><img src="https://pic2.zhimg.com/v2-eea10c946fa32c162b6676c5e455d319_b.jpg" data-caption="" data-rawwidth="716" data-rawheight="55" class="origin_image zh-lightbox-thumb" width="716" data-original="https://pic2.zhimg.com/v2-eea10c946fa32c162b6676c5e455d319_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-eea10c946fa32c162b6676c5e455d319_b.jpg" data-caption="" data-rawwidth="716" data-rawheight="55" class="origin_image zh-lightbox-thumb lazy" width="716" data-original="https://pic2.zhimg.com/v2-eea10c946fa32c162b6676c5e455d319_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-eea10c946fa32c162b6676c5e455d319_b.jpg"/></figure><p>p值很小，意味着我们可以拒绝原假设（Y的均值为0.1）。</p><figure><noscript><img src="https://pic4.zhimg.com/v2-a4ab1dde9976629780e9b32a49553d4b_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="124" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic4.zhimg.com/v2-a4ab1dde9976629780e9b32a49553d4b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-a4ab1dde9976629780e9b32a49553d4b_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="124" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic4.zhimg.com/v2-a4ab1dde9976629780e9b32a49553d4b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-a4ab1dde9976629780e9b32a49553d4b_b.jpg"/></figure><h2><b>延伸阅读</b></h2><p><a href="https://link.zhihu.com/?target=http%3A//www.scipy.org" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://www.</span><span class="visible">scipy.org</span><span class="invisible"></span></a> - SciPy的官方网页</p><p><a href="https://link.zhihu.com/?target=http%3A//docs.scipy.org/doc/scipy/reference/tutorial/index.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">docs.scipy.org/doc/scip</span><span class="invisible">y/reference/tutorial/index.html</span><span class="ellipsis"></span></a> - SciPy的一个教程</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/scipy/scipy/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/scipy/scipy/</span><span class="invisible"></span></a> - SciPy源代码.</p><p class="ztext-empty-paragraph"><br/></p><h2><b>版本</b></h2><figure><noscript><img src="https://pic3.zhimg.com/v2-429b6f5c7599f89e9618d272dd0c8cd6_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="73" class="origin_image zh-lightbox-thumb" width="717" data-original="https://pic3.zhimg.com/v2-429b6f5c7599f89e9618d272dd0c8cd6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-429b6f5c7599f89e9618d272dd0c8cd6_b.jpg" data-caption="" data-rawwidth="717" data-rawheight="73" class="origin_image zh-lightbox-thumb lazy" width="717" data-original="https://pic3.zhimg.com/v2-429b6f5c7599f89e9618d272dd0c8cd6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-429b6f5c7599f89e9618d272dd0c8cd6_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p><b>到JoinQuant查看原文并参与讨论：</b><a href="https://link.zhihu.com/?target=https%3A//www.joinquant.com/post/9210%3Ftag%3Dalgorithm" class=" wrap external" target="_blank" rel="nofollow noreferrer">【翻译搬运】SciPy-Python科学算法库</a></p>