<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>rust 异步 IO：从 mio 到 coroutine</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/52538218">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-81634f185a08dc132259dfdf274fd64b_r.jpg" alt=""></div><p>辣鸡知乎连目录都不能打。推荐阅读原文</p><a href="https://hexilee.me/2018/12/17/rust-async-io/" data-draft-node="block" data-draft-type="link-card" data-image="v2-fe574b11d1229ca57d0a0760236316b6" data-image-width="640" data-image-height="640" data-image-size="ipico">rust asynchronous io - 李晨曦的博客 | Hexi Blog</a><h2>引言</h2><p>2018 年接近尾声，<code class="inline">rust</code> 团队勉强立住了异步 <code class="inline">IO</code> 的 flag，<code class="inline">async</code> 成为了关键字，<code class="inline">Pin</code>, <code class="inline">Future</code>, <code class="inline">Poll</code> 和 <code class="inline">await!</code> 也进入了标准库。不过一直以来实际项目中用不到这套东西，所以也没有主动去了解过。</p><p>最近心血来潮想用 <code class="inline">rust</code> 写点东西，但并找不到比较能看的文档（可能是因为 <code class="inline">rust</code> 发展太快了，很多都过时了），最后参考<a href="https://cafbit.com/post/tokio_internals/">这篇文章</a>和 <code class="inline">"new tokio"</code>( <a href="https://github.com/Hexilee/async-io-demo">romio</a> ) 写了几个 <code class="inline">demo</code>，并基于 <code class="inline">mio</code> 在 <code class="inline">coroutine</code> 中实现了简陋的异步 <code class="inline">IO</code>。</p><p>最终效果如下：</p><code lang="rust">// examples/async-echo.rs

#![feature(async_await)]
#![feature(await_macro)]

#[macro_use]
extern crate log;

use asyncio::executor::{block_on, spawn, TcpListener};
use failure::Error;

fn main() -&gt; Result&lt;(), Error&gt; {
    env_logger::init();
    block_on(
        async {
            let mut listener = TcpListener::bind(&amp;"127.0.0.1:7878".parse().unwrap())
                .expect("TcpListener bind fail");
            info!("Listening on 127.0.0.1:7878");
            while let Ok((mut stream, addr)) = await!(listener.accept()) {
                info!("connection from {}", addr);
                spawn(
                    async move {
                        let client_hello = await!(stream.read()).expect("read from stream fail");
                        let read_length = client_hello.len();
                        let write_length =
                            await!(stream.write(client_hello)).expect("write to stream fail");
                        assert_eq!(read_length, write_length);
                        stream.close();
                    },
                )
                .expect("spawn stream fail");
            }
        },
    )
}</code><p>写这篇文章的主要目的是梳理和总结，同时也希望能给对这方面有兴趣的 <code class="inline">Rustacean</code> 作为参考。本文代码以易于理解为主要编码原则，某些地方并没有太考虑性能，还请见谅；但如果文章和代码中有明显错误，欢迎指正。</p><p>本文代码仓库在 <a href="https://github.com/Hexilee/async-io-demo">Github</a> （部分代码较长，建议 <code class="inline">clone</code> 下来用编辑器看），所有 <code class="inline">examples</code> 在 <code class="inline">nightly-x86_64-apple-darwin 2018 Edition</code> 上均能正常运行。运行 <code class="inline">example/async-echo</code>  时设置 <code class="inline">RUST_LOG</code> 为 <code class="inline">info</code> 可以在 terminal 看到基本的运行信息，<code class="inline">debug</code> 则可见事件循环中的事件触发顺序。</p><h2>异步 <code class="inline">IO</code> 的基石 - <code class="inline">mio</code></h2><p><code class="inline">mio</code> 是一个极简的底层异步 <code class="inline">IO</code> 库，如今 <code class="inline">rust</code> 生态中几乎所有的异步 <code class="inline">IO</code> 程序都基于它。</p><p>随着 <code class="inline">channel</code>, <code class="inline">timer</code> 等 <code class="inline">sub module</code> 在 <code class="inline">0.6.5</code> 版本被标为 <code class="inline">deprecated</code>，如今的 mio 提供的唯二两个核心功能分别是：</p><ul><li>对操作系统异步网络 <code class="inline">IO</code> 的封装</li><li>用户自定义事件队列</li></ul><p>第一个核心功能对应到不同操作系统分别是</p><ul><li><code class="inline">Linux(Android) =&gt; epoll</code></li><li><code class="inline">Windows =&gt; iocp</code></li><li><code class="inline">MacOS(iOS), FreeBSD =&gt; kqueue</code> </li><li><code class="inline">Fuchsia =&gt; &lt;unknown&gt;</code></li></ul><p>mio 把这些不同平台上的 API 封装出了一套 <code class="inline">epoll like</code> 的异步网络 API，支持 <code class="inline">udp 和 tcp</code>。</p><blockquote> 除此之外还封装了一些不同平台的拓展 API，比如 <code class="inline">uds</code>，本文不对这些 API 做介绍。<br> </blockquote><h2>异步网络 IO</h2><p>下面是一个 <code class="inline">tcp</code> 的 <code class="inline">demo</code></p><code lang="rust">// examples/tcp.rs

use mio::*;
use mio::net::{TcpListener, TcpStream};
use std::io::{Read, Write, self};
use failure::Error;
use std::time::{Duration, Instant};

const SERVER_ACCEPT: Token = Token(0);
const SERVER: Token = Token(1);
const CLIENT: Token = Token(2);
const SERVER_HELLO: &amp;[u8] = b"PING";
const CLIENT_HELLO: &amp;[u8] = b"PONG";

fn main() -&gt; Result&lt;(), Error&gt; {
    let addr = "127.0.0.1:13265".parse()?;

// Setup the server socket
    let server = TcpListener::bind(&amp;addr)?;

// Create a poll instance
    let poll = Poll::new()?;

// Start listening for incoming connections
    poll.register(&amp;server, SERVER_ACCEPT, Ready::readable(),
                  PollOpt::edge())?;

// Setup the client socket
    let mut client = TcpStream::connect(&amp;addr)?;

    let mut server_handler = None;

// Register the client
    poll.register(&amp;client, CLIENT, Ready::readable() | Ready::writable(),
                  PollOpt::edge())?;

// Create storage for events
    let mut events = Events::with_capacity(1024);

    let start = Instant::now();
    let timeout = Duration::from_millis(10);
    'top: loop {
        poll.poll(&amp;mut events, None)?;
        for event in events.iter() {
            if start.elapsed() &gt;= timeout {
                break 'top
            }
            match event.token() {
                SERVER_ACCEPT =&gt; {
                    let (handler, addr) = server.accept()?;
                    println!("accept from addr: {}", &amp;addr);
                    poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge())?;
                    server_handler = Some(handler);
                }

                SERVER =&gt; {
                    if event.readiness().is_writable() {
                        if let Some(ref mut handler) = &amp;mut server_handler {
                            match handler.write(SERVER_HELLO) {
                                Ok(_) =&gt; {
                                    println!("server wrote");
                                }
                                Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                                err =&gt; {
                                    err?;
                                }
                            }
                        }
                    }
                    if event.readiness().is_readable() {
                        let mut hello = [0; 4];
                        if let Some(ref mut handler) = &amp;mut server_handler {
                            match handler.read_exact(&amp;mut hello) {
                                Ok(_) =&gt; {
                                    assert_eq!(CLIENT_HELLO, &amp;hello);
                                    println!("server received");
                                }
                                Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                                err =&gt; {
                                    err?;
                                }
                            }
                        }
                    }
                }
                CLIENT =&gt; {
                    if event.readiness().is_writable() {
                        match client.write(CLIENT_HELLO) {
                            Ok(_) =&gt; {
                                println!("client wrote");
                            }
                            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                            err =&gt; {
                                err?;
                            }
                        }
                    }
                    if event.readiness().is_readable() {
                        let mut hello = [0; 4];
                        match client.read_exact(&amp;mut hello) {
                            Ok(_) =&gt; {
                                assert_eq!(SERVER_HELLO, &amp;hello);
                                println!("client received");
                            }
                            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                            err =&gt; {
                                err?;
                            }
                        }
                    }
                }
                _ =&gt; unreachable!(),
            }
        }
    };
    Ok(())
}</code><p>这个 <code class="inline">demo</code> 稍微有点长，接下来我们把它一步步分解。</p><p>直接看主循环</p><code lang="rust">fn main() {
    // ...
    loop {
        poll.poll(&amp;mut events, None).unwrap();
        // ...
    }
}</code><p>每次循环都得执行 <code class="inline">poll.poll</code>，第一个参数是用来存 <code class="inline">events</code> 的 <code class="inline">Events</code>， 容量是 <code class="inline">1024</code>；</p><code lang="rust">let mut events = Events::with_capacity(1024);</code><p>第二个参数是 <code class="inline">timeout</code>，即一个 <code class="inline">Option&lt;Duration&gt;</code>，超时会直接返回。返回类型是 <code class="inline">io::Result&lt;usize&gt;</code>。</p><blockquote> 其中的 <code class="inline">usize</code> 代表 <code class="inline">events</code> 的数量，这个返回值是 <code class="inline">deprecated</code> 并且会在之后的版本移除，仅供参考<br> </blockquote><p>这里我们设置了 <code class="inline">timeout = None</code>，所以当这个函数返回时，必然是某些事件被触发了。让我们遍历 <code class="inline">events</code>：</p><code lang="rust">match event.token() {
      SERVER_ACCEPT =&gt; {
          let (handler, addr) = server.accept()?;
          println!("accept from addr: {}", &amp;addr);
          poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge())?;
          server_handler = Some(handler);
      }

      SERVER =&gt; {
          if event.readiness().is_writable() {
              if let Some(ref mut handler) = &amp;mut server_handler {
                  match handler.write(SERVER_HELLO) {
                      Ok(_) =&gt; {
                          println!("server wrote");
                      }
                      Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                      err =&gt; {
                          err?;
                      }
                  }
              }
          }
          if event.readiness().is_readable() {
              let mut hello = [0; 4];
              if let Some(ref mut handler) = &amp;mut server_handler {
                  match handler.read_exact(&amp;mut hello) {
                      Ok(_) =&gt; {
                          assert_eq!(CLIENT_HELLO, &amp;hello);
                          println!("server received");
                      }
                      Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                      err =&gt; {
                          err?;
                      }
                  }
              }
          }
      }
      CLIENT =&gt; {
          if event.readiness().is_writable() {
              match client.write(CLIENT_HELLO) {
                  Ok(_) =&gt; {
                      println!("client wrote");
                  }
                  Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                  err =&gt; {
                      err?;
                  }
              }
          }
          if event.readiness().is_readable() {
              let mut hello = [0; 4];
              match client.read_exact(&amp;mut hello) {
                  Ok(_) =&gt; {
                      assert_eq!(SERVER_HELLO, &amp;hello);
                      println!("client received");
                  }
                  Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
                  err =&gt; {
                      err?;
                  }
              }
          }
      }
      _ =&gt; unreachable!(),
  }</code><p>我们匹配每一个 <code class="inline">event</code> 的 <code class="inline">token</code>，这里的 <code class="inline">token</code> 就是我用来注册的那些 <code class="inline">token</code>。比如我在上面注册了 <code class="inline">server</code></p><code lang="rust">// Start listening for incoming connections
poll.register(&amp;server, SERVER_ACCEPT, Ready::readable(),
                  PollOpt::edge()).unwrap();</code><p>第二个参数就是 <code class="inline">token</code></p><code lang="rust">const SERVER_ACCEPT: Token = Token(0);</code><p>这样当 <code class="inline">event.token() == SERVER_ACCEPT</code> 时，就说明这个事件跟我们注册的 <code class="inline">server</code> 有关，于是我们试图 <code class="inline">accept</code> 一个新的连接并把它注册进 <code class="inline">poll</code>，使用的 <code class="inline">token</code> 是 <code class="inline">SERVER</code>。</p><code lang="rust">let (handler, addr) = server.accept().unwrap();
println!("accept from addr: {}", &amp;addr);
poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge()).unwrap();
server_handler = Some(handler);</code><p>这样我们之后如果发现 <code class="inline">event.token() == SERVER</code>，我们就认为它和注册的 <code class="inline">handler</code> 有关：</p><code lang="rust">if event.readiness().is_writable() {
    if let Some(ref mut handler) = &amp;mut server_handler {
        match handler.write(SERVER_HELLO) {
            Ok(_) =&gt; {
                println!("server wrote");
            }
            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
            err =&gt; {
                err?;
            }
        }
    }
}
if event.readiness().is_readable() {
    let mut hello = [0; 4];
    if let Some(ref mut handler) = &amp;mut server_handler {
        match handler.read_exact(&amp;mut hello) {
            Ok(_) =&gt; {
                assert_eq!(CLIENT_HELLO, &amp;hello);
                println!("server received");
            }
            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
            err =&gt; {
                err?;
            }
        }
    }
}</code><p>这时候我们还需要判断 <code class="inline">event.readiness()</code>，这就是 <code class="inline">register</code> 函数的第三个参数，叫做 <code class="inline">interest</code>，顾名思义，就是“感兴趣的事”。它的类型是 <code class="inline">Ready</code>，一共四种，<code class="inline">readable, writable, error 和 hup</code>，可进行并运算。</p><p>在上面我们给 <code class="inline">handler</code> 注册了 <code class="inline">Ready::readable() | Ready::writable()</code>，所以 <code class="inline">event</code> 可能是 <code class="inline">readable</code> 也可能是 <code class="inline">writable</code>，所以我们要经过判断来执行相应的逻辑。注意这里的判断是</p><code lang="rust">if ... {
    ...
}

if ... {
    ...
}</code><p>而非</p><code lang="rust">if ... {
    ...
} else if ... {
    ...
}</code><p>因为一个事件可能同时是 <code class="inline">readable</code> 和 <code class="inline">writable</code>。</p><h2>容错性原则</h2><p>大概逻辑先讲到这儿，这里先讲一下 <code class="inline">mio</code> 的“容错性原则”，即不能完全相信 <code class="inline">event</code>。</p><p>可以看到我上面有一段代码是这么写的 </p><code lang="rust">match event.token() {
     SERVER_ACCEPT =&gt; {
         let (handler, addr) = server.accept().unwrap();
         println!("accept from addr: {}", &amp;addr);
         poll.register(&amp;handler, SERVER, Ready::readable() | Ready::writable(), PollOpt::edge()).unwrap();
         server_handler = Some(handler);
     }</code><p><code class="inline">server.accept()</code> 返回的是 <code class="inline">io::Result&lt;(TcpStream, SocketAddr)&gt;</code>。如果我们选择完全相信 <code class="inline">event</code> 的话，在这里 <code class="inline">unwrap()</code> 并没有太大问题 —— 如果真的有一个新的连接就绪，<code class="inline">accept()</code> 产生的 <code class="inline">io::Result</code> 是我们无法预料且无法处理的，我们应该抛给调用者或者直接 <code class="inline">panic</code>。</p><p>但问题就是，我们可以认为 <code class="inline">event</code> 的伪消息是可预料的，可能并没有一个新的连接准备就绪，这时候我们 <code class="inline">accept()</code> 会引发 <code class="inline">WouldBlock Error</code>。但我们不应该认为 <code class="inline">WouldBlock</code> 是一种错误 —— 这是一种友善的提醒。<code class="inline">server</code> 告诉我们：“并没有新的连接，请下次再来吧。”，所以在这里我们应该忽略（可以打个 <code class="inline">log</code>）它并重新进入循环。</p><p>像我后面写的那样：</p><code lang="rust">match client.write(CLIENT_HELLO) {
   Ok(_) =&gt; {
       println!("client wrote");
   }
   Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
   err =&gt; {
       err?;
   }
}</code><h2>Poll Option</h2><p>好了，现在我们可以运行：</p><code lang="bash">[async-io-demo] cargo run --example tcp</code><p>terminal 里打印出了</p><code lang="bash">client wrote
accept from addr: 127.0.0.1:53205
client wrote
server wrote
server received
...</code><p>我们可以发现，在短短的 <code class="inline">10 millis</code> 内（<code class="inline">let timeout = Duration::from_millis(10);</code>），<code class="inline">server</code> 和 <code class="inline">client</code> 分别进行了数十次的读写！</p><p>如果我们不想进行这么多次读写呢？比如，我们只想让 <code class="inline">server</code> 写一次。在网络比较通畅的情况下，<code class="inline">client</code> 和 <code class="inline">server</code> 几乎一直是可写的，所以 <code class="inline">Poll::poll</code> 在数微秒内就返回了。</p><p>这时候就要看 <code class="inline">register</code> 的第四个参数了。</p><code lang="rust">poll.register(&amp;server, SERVER_ACCEPT, Ready::readable(),
                  PollOpt::edge()).unwrap();</code><p><code class="inline">PollOpt::edge()</code> 的类型是 <code class="inline">PollOpt</code>，一共有 <code class="inline">level, edge, oneshot</code> 三种，他们有什么区别呢？</p><p>比如在我上面的代码里，</p><code lang="rust">if event.readiness().is_readable() {
    let mut hello = [0; 4];
    match client.read_exact(&amp;mut hello) {
        Ok(_) =&gt; {
            assert_eq!(SERVER_HELLO, &amp;hello);
            println!("client received");
        }
        Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; continue,
        err =&gt; {
            err?;
        }
    }
}</code><p>我在收到一个 <code class="inline">readable readiness</code> 时，只读了四个字节。如果这时候缓冲区里有八字节的数据，那么：</p><ul><li>如果我注册时使用 <code class="inline">PollOpt::level()</code>，我在下次 <code class="inline">poll</code> 时 <b>一定</b> 还能收到一次 <code class="inline">readable readiness event</code> （只要我没有主动执行 <code class="inline">set_readiness(Read::empty())</code>）；</li><li>如果我注册时使用 <code class="inline">PollOpt::edge()</code>，我在下次 <code class="inline">poll</code> 时 <b>不一定</b> 还能收到一次 <code class="inline">readable readiness event</code>；</li></ul><p>所以，使用 <code class="inline">PollOpt::edge()</code> 时有一个“排尽原则（<code class="inline">Draining readiness</code>）”，即每次触发 <code class="inline">event</code> 时一定要操作到资源耗尽返回 <code class="inline">WouldBlock</code>，即上面的代码要改成：</p><code lang="rust">if event.readiness().is_readable() {
    let mut hello = [0; 4];
    loop {
        match client.read_exact(&amp;mut hello) {
            Ok(_) =&gt; {
                assert_eq!(SERVER_HELLO, &amp;hello);
                println!("client received");
            }
            Err(ref err) if err.kind() == io::ErrorKind::WouldBlock =&gt; break,
            err =&gt; {
                err?;
            }
        }
    }
}</code><p>那么，<code class="inline">oneshot</code> 又是怎样的行为呢？让我们回到上面的问题，如果我们只想让 <code class="inline">handler</code> 写一次，怎么办 —— 注册时使用 <code class="inline">PollOpt::oneshot()</code>，即</p><code lang="rust">let (handler, addr) = server.accept().unwrap();
println!("accept from addr: {}", &amp;addr);
poll.register(&amp;handler, SERVER, Ready::readable(), PollOpt::edge()).unwrap();
poll.register(&amp;handler, SERVER_WRITE, Ready::writable(), PollOpt::oneshot()).unwrap();
server_handler = Some(handler);</code><p>这样的话，你只能收到一次 <code class="inline">SERVER_WRITE</code> 事件，除非你使用 <code class="inline">Poll::reregister</code> 重新注册 <code class="inline">handler</code>。</p><blockquote><code class="inline">Poll::reregister</code> 可以更改 <code class="inline">PollOpt</code> 和 <code class="inline">interest</code><br> </blockquote><h2>Still Block</h2><p>其实上面这个 <code class="inline">demo</code> 还存在一个问题，即我们在回调代码块中使用了同步的 <code class="inline">IO</code> 操作 <code class="inline">println!</code>。我们要尽可能避免在回调的代码块里使用耗时的 <code class="inline">IO</code> 操作。</p><p>考虑到文件 <code class="inline">IO</code> (包括 <code class="inline">Stdin, Stdout, Stderr</code>) 速度很慢，我们只需要把所有的文件 <code class="inline">IO</code> 交给一个线程进行即可。</p><code lang="rust">use std::sync::mpsc::{Sender, Receiver, channel, SendError};

#[derive(Clone)]
pub struct Fs {
    task_sender: Sender&lt;Task&gt;,
}

impl Fs {
    pub fn new() -&gt; Self {
        let (sender, receiver) = channel();
        std::thread::spawn(move || {
            loop {
                match receiver.recv() {
                    Ok(task) =&gt; {
                        match task {
                            Task::Println(ref string) =&gt; println!("{}", string),
                            Task::Exit =&gt; return
                        }
                    },
                    Err(_) =&gt; {
                        return;
                    }
                }
            }
        });
        Fs { task_sender: sender }
    }

    pub fn println(&amp;self, string: String) {
        self.task_sender.send(Task::Println(string)).unwrap()
    }
}

pub enum Task {
    Exit,
    Println(String),
}</code><p>之后，可以使用 <code class="inline">Fs::println</code> 替换所有的 <code class="inline">println!</code>。</p><h2>自定义事件</h2><p>上面我们实现异步 <code class="inline">println</code> 比较简单，这是因为 <code class="inline">println</code> 并没有返回值，不需要进行后续操作。设想一下，如果要我们实现 <code class="inline">open</code> 和 <code class="inline">ready_to_string</code>，先异步地 <code class="inline">open</code> 一个文件，然后异步地 <code class="inline">read_to_string</code>，最后再异步地 <code class="inline">println</code>, 我们要怎么做？</p><p>最简单的写法是回调，像这样：</p><code lang="rust">// src/fs.rs

use crossbeam_channel::{unbounded, Sender};
use std::fs::File;
use std::io::Read;
use std::boxed::FnBox;
use std::thread;
use failure::Error;

#[derive(Clone)]
pub struct Fs {
    task_sender: Sender&lt;Task&gt;,
}

pub struct FsHandler {
    io_worker: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
    executor: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
}

pub fn fs_async() -&gt; (Fs, FsHandler) {
    let (task_sender, task_receiver) = unbounded();
    let (result_sender, result_receiver) = unbounded();
    let io_worker = std::thread::spawn(move || {
        loop {
            match task_receiver.recv() {
                Ok(task) =&gt; {
                    match task {
                        Task::Println(ref string) =&gt; println!("{}", string),
                        Task::Open(path, callback, fs) =&gt; {
                            result_sender
                                .send(TaskResult::Open(File::open(path)?, callback, fs))?
                        }
                        Task::ReadToString(mut file, callback, fs) =&gt; {
                            let mut value = String::new();
                            file.read_to_string(&amp;mut value)?;
                            result_sender
                                .send(TaskResult::ReadToString(value, callback, fs))?
                        }
                        Task::Exit =&gt; {
                            result_sender
                                .send(TaskResult::Exit)?;
                            break;
                        }
                    }
                }
                Err(_) =&gt; {
                    break;
                }
            }
        }
        Ok(())
    });
    let executor = std::thread::spawn(move || {
        loop {
            let result = result_receiver.recv()?;
            match result {
                TaskResult::ReadToString(value, callback, fs) =&gt; callback.call_box((value, fs))?,
                TaskResult::Open(file, callback, fs) =&gt; callback.call_box((file, fs))?,
                TaskResult::Exit =&gt; break
            };
        };
        Ok(())
    });

    (Fs { task_sender }, FsHandler { io_worker, executor })
}

impl Fs {
    pub fn println(&amp;self, string: String) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Println(string))?)
    }

    pub fn open&lt;F&gt;(&amp;self, path: &amp;str, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::Open(path.to_string(), Box::new(callback), self.clone()))?)
    }

    pub fn read_to_string&lt;F&gt;(&amp;self, file: File, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::ReadToString(file, Box::new(callback), self.clone()))?)
    }

    pub fn close(&amp;self) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Exit)?)
    }
}

impl FsHandler {
    pub fn join(self) -&gt; Result&lt;(), Error&gt; {
        self.io_worker.join().unwrap()?;
        self.executor.join().unwrap()
    }
}

type FileCallback = Box&lt;FnBox(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;
type StringCallback = Box&lt;FnBox(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;

pub enum Task {
    Exit,
    Println(String),
    Open(String, FileCallback, Fs),
    ReadToString(File, StringCallback, Fs),
}

pub enum TaskResult {
    Exit,
    Open(File, FileCallback, Fs),
    ReadToString(String, StringCallback, Fs),
}
// examples/fs.rs

use asyncio::fs::fs_async;
use failure::Error;

const TEST_FILE_VALUE: &amp;str = "Hello, World!";

fn main() -&gt; Result&lt;(), Error&gt; {
    let (fs, fs_handler) = fs_async();
    fs.open("./examples/test.txt", |file, fs| {
        fs.read_to_string(file, |value, fs| {
            assert_eq!(TEST_FILE_VALUE, &amp;value);
            fs.println(value)?;
            fs.close()
        })
    })?;
    fs_handler.join()?;
    Ok(())
}</code><p>测试</p><code lang="bash">[async-io-demo] cargo run --example fs</code><p>这样写在逻辑上的确是对的，但是负责跑 <code class="inline">callback</code> 的 <code class="inline">executor</code> 线程其实被负责 <code class="inline">io</code> 的线程阻塞住了（<code class="inline">result_receiver.recv()</code>）。那我们能不能在 <code class="inline">executor</code> 线程里跑一个事件循环，以达到不被 <code class="inline">io</code> 线程阻塞的目的呢？（即确定 <code class="inline">result_receiver</code> 中有 <code class="inline">result</code> 时，<code class="inline">executor</code> 才会进行 <code class="inline">result_receiver.recv()</code>）.</p><p>这就到了体现 <code class="inline">mio</code> 强大可拓展性的时候：注册用户态的事件队列。</p><p>把上面的代码稍加修改，就成了这样：</p><code lang="rust">// src/fs_mio.rs

use crossbeam_channel::{unbounded, Sender, TryRecvError};
use std::fs::File;
use std::io::{Read};
use std::boxed::FnBox;
use std::thread;
use failure::Error;
use std::time::Duration;
use mio::*;

#[derive(Clone)]
pub struct Fs {
    task_sender: Sender&lt;Task&gt;,
}

pub struct FsHandler {
    io_worker: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
    executor: thread::JoinHandle&lt;Result&lt;(), Error&gt;&gt;,
}

const FS_TOKEN: Token = Token(0);

pub fn fs_async() -&gt; (Fs, FsHandler) {
    let (task_sender, task_receiver) = unbounded();
    let (result_sender, result_receiver) = unbounded();
    let poll = Poll::new().unwrap();
    let (registration, set_readiness) = Registration::new2();
    poll.register(&amp;registration, FS_TOKEN, Ready::readable(), PollOpt::oneshot()).unwrap();
    let io_worker = std::thread::spawn(move || {
        loop {
            match task_receiver.recv() {
                Ok(task) =&gt; {
                    match task {
                        Task::Println(ref string) =&gt; println!("{}", string),
                        Task::Open(path, callback, fs) =&gt; {
                            result_sender
                                .send(TaskResult::Open(File::open(path)?, callback, fs))?;
                            set_readiness.set_readiness(Ready::readable())?;
                        }
                        Task::ReadToString(mut file, callback, fs) =&gt; {
                            let mut value = String::new();
                            file.read_to_string(&amp;mut value)?;
                            result_sender
                                .send(TaskResult::ReadToString(value, callback, fs))?;
                            set_readiness.set_readiness(Ready::readable())?;
                        }
                        Task::Exit =&gt; {
                            result_sender
                                .send(TaskResult::Exit)?;
                            set_readiness.set_readiness(Ready::readable())?;
                            break;
                        }
                    }
                }
                Err(_) =&gt; {
                    break;
                }
            }
        }
        Ok(())
    });

    let executor = thread::spawn(move || {
        let mut events = Events::with_capacity(1024);
        'outer: loop {
            poll.poll(&amp;mut events, Some(Duration::from_secs(1)))?;
            for event in events.iter() {
                match event.token() {
                    FS_TOKEN =&gt; {
                        loop {
                            match result_receiver.try_recv() {
                                Ok(result) =&gt; {
                                    match result {
                                        TaskResult::ReadToString(value, callback, fs) =&gt; callback.call_box((value, fs))?,
                                        TaskResult::Open(file, callback, fs) =&gt; callback.call_box((file, fs))?,
                                        TaskResult::Exit =&gt; break 'outer
                                    }
                                }
                                Err(e) =&gt; {
                                    match e {
                                        TryRecvError::Empty =&gt; break,
                                        TryRecvError::Disconnected =&gt; Err(e)?
                                    }
                                }
                            }
                        }
                        poll.reregister(&amp;registration, FS_TOKEN, Ready::readable(), PollOpt::oneshot())?;
                    }
                    _ =&gt; unreachable!()
                }
            }
        };
        Ok(())
    });
    (Fs { task_sender }, FsHandler { io_worker, executor })
}

impl Fs {
    pub fn println(&amp;self, string: String) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Println(string))?)
    }

    pub fn open&lt;F&gt;(&amp;self, path: &amp;str, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::Open(path.to_string(), Box::new(callback), self.clone()))?)
    }

    pub fn read_to_string&lt;F&gt;(&amp;self, file: File, callback: F) -&gt; Result&lt;(), Error&gt;
        where F: FnOnce(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send + 'static {
        Ok(self.task_sender.send(Task::ReadToString(file, Box::new(callback), self.clone()))?)
    }

    pub fn close(&amp;self) -&gt; Result&lt;(), Error&gt; {
        Ok(self.task_sender.send(Task::Exit)?)
    }
}

impl FsHandler {
    pub fn join(self) -&gt; Result&lt;(), Error&gt; {
        self.io_worker.join().unwrap()?;
        self.executor.join().unwrap()
    }
}

type FileCallback = Box&lt;FnBox(File, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;
type StringCallback = Box&lt;FnBox(String, Fs) -&gt; Result&lt;(), Error&gt; + Sync + Send&gt;;

pub enum Task {
    Exit,
    Println(String),
    Open(String, FileCallback, Fs),
    ReadToString(File, StringCallback, Fs),
}

pub enum TaskResult {
    Exit,
    Open(File, FileCallback, Fs),
    ReadToString(String, StringCallback, Fs),
}
// examples/fs-mio.rs

use asyncio::fs_mio::fs_async;
use failure::Error;

const TEST_FILE_VALUE: &amp;str = "Hello, World!";

fn main() -&gt; Result&lt;(), Error&gt; {
    let (fs, fs_handler) = fs_async();
    fs.open("./examples/test.txt", |file, fs| {
        fs.read_to_string(file, |value, fs| {
            assert_eq!(TEST_FILE_VALUE, &amp;value);
            fs.println(value)?;
            fs.close()
        })
    })?;
    fs_handler.join()?;
    Ok(())
}</code><p>可以注意到，上面的代码发生的改变就是，<code class="inline">executor</code> 不再被 <code class="inline">result_receiver.recv</code> 阻塞，而变成了注册事件（<code class="inline">registration</code>）后等待 <code class="inline">Poll::poll</code> 返回事件；只有等到了新的事件，才会进行 <code class="inline">result_receiver.try_recv</code>。同时，<code class="inline">io_worker</code> 线程在 <code class="inline">send result</code> 之后会执行 <code class="inline">set_readiness.set_readiness(Ready::readable())?;</code>，以通知 <code class="inline">executor</code> 线程对相应结果做处理。</p><p>这样的话，<code class="inline">executor</code> 就不会被 <code class="inline">io worker</code> 阻塞了，因为我们可以把所有的事件都注册到 <code class="inline">executor</code> 上，<code class="inline">mio::Poll</code> 会同时监听多个事件（比如把 <code class="inline">fs</code> 和 <code class="inline">tcp</code> 结合起来）。</p><p>测试</p><code lang="bash">[async-io-demo] cargo run --example fs-mio</code><h2>Callback is evil</h2><p>既然文件 <code class="inline">IO</code> 的 <code class="inline">executor</code> 不再会被 <code class="inline">io worker</code> 线程阻塞了，那我们来试试让 <code class="inline">fs</code> 和 <code class="inline">tcp</code>  共用一个 <code class="inline">poll</code> 然后建立一个简单的文件服务器吧。</p><p>但可以先等等，因为我已经开始觉得写 <code class="inline">callback</code> 有点难受了 —— 如果我们还想处理错误的话，会觉得更难受，像这样</p><code lang="rust">use asyncio::fs_mio::fs_async;
use failure::Error;

const TEST_FILE_VALUE: &amp;str = "Hello, World!";

fn main() -&gt; Result&lt;(), Error&gt; {
    let (fs, fs_handler) = fs_async();
    fs.open("./examples/test.txt", 
        |file, fs| {
            fs.read_to_string(file, 
                |value, fs| {
                    assert_eq!(TEST_FILE_VALUE, &amp;value);
                    fs.println(value, 
                        |err| {
                            ...
                        }
                    );
                    fs.close()
                },
                |err| {
                    ...
                }
            )
        },
        |err| {
            ...
        }
    )?;
    fs_handler.join()?;
    Ok(())
}</code><p>而且对 <code class="inline">rust</code> 来说，更加艰难的是闭包中的生命周期问题（闭包几乎不能通过捕获来借用环境变量）。这就意味着，如果我要借用环境中的某个变量，我要么 <code class="inline">clone</code> 它（如果它实现了 <code class="inline">Clone</code> 的话），要么把它作为闭包参数传入（意味着你要根据需要改每一层回调函数的签名，这太屎了）。</p><p>考虑到各种原因，<code class="inline">rust</code> 最终选择用 <code class="inline">coroutine</code> 作为异步 <code class="inline">IO</code> 的 <code class="inline">API</code> 抽象。</p><h2>coroutine</h2><p>这里所说的 <code class="inline">coroutine</code> 是指基于 <code class="inline">rust generator</code> 的 <code class="inline">stackless coroutine</code> 而非早期被 <code class="inline">rust</code> 抛弃的 <code class="inline">green thread(stackful coroutine)</code>。</p><h2>generator</h2><p><code class="inline">rust</code> 大概在今年五月份引入了 <code class="inline">generator</code>，但到现在还是 unstable 的 —— 虽说也没多少人用 stable（误</p><p>一个典型的斐波那契 <code class="inline">generator</code> 如下</p><code lang="rust">// examples/fab.rs

#![feature(generators, generator_trait)]

use std::ops::{Generator, GeneratorState};

fn main() {
    let mut gen = fab(5);
    loop {
        match unsafe { gen.resume() } {
            GeneratorState::Yielded(value) =&gt; println!("yield {}", value),
            GeneratorState::Complete(ret) =&gt; {
                println!("return {}", ret);
                break;
            }
        }
    }
}

fn fab(mut n: u64) -&gt; impl Generator&lt;Yield=u64, Return=u64&gt; {
    move || {
        let mut last = 0u64;
        let mut current = 1;
        yield last;
        while n &gt; 0 {
            yield current;
            let tmp = last;
            last = current;
            current = tmp + last;
            n -= 1;
        }
        return last;
    }
}</code><p>由于 <code class="inline">generator</code> 的“中断特性”，我们很自然的可以想到，如果用 <code class="inline">generator</code> 搭配 <code class="inline">mio</code>，给每个 <code class="inline">generator</code> 分配一个 <code class="inline">token</code>，然后 <code class="inline">poll mio</code> 的事件循环，收到一个唤醒事件就 <code class="inline">resume</code> 相应的 <code class="inline">generator</code>；每个 <code class="inline">generator</code> 在要阻塞的时候拿自己的 <code class="inline">token</code> 注册一个唤醒事件然后 <code class="inline">yield</code>，不就实现了“同步代码”的异步 <code class="inline">IO</code> 吗？</p><p>这样看来原理上来说已经稳了，但 <code class="inline">rust</code> 异步 <code class="inline">IO</code> 的天空依旧漂浮着两朵乌云。</p><h2>自引用</h2><p>第一朵乌云和 <code class="inline">rust</code> 自身的内存管理机制有关。</p><p>如果你写出这样的 <code class="inline">generator</code></p><code lang="rust">fn self_ref_generator() -&gt; impl Generator&lt;Yield=u64, Return=()&gt; {
    || {
        let x: u64 = 1;
        let ref_x: &amp;u64 = &amp;x;
        yield 0;
        yield *ref_x;
    }
}</code><p><code class="inline">rust</code> 一定会给你抛个错然后告诉你 "borrow may still be in use when generator yields"。编译器没有教你怎么修正可能会让你有些恐慌，去不存在的搜索引擎上查了查，你发现这和 <code class="inline">generator</code> 的实现有关。</p><p>前文中提到，<code class="inline">rust generator</code> 是 <code class="inline">stackless</code> 的，即它并不会保留一个完整的栈，而是根据不同的状态保留需要的变量。如果你把上面的代码改成</p><code lang="rust">fn no_ref_generator() -&gt; impl Generator&lt;Yield=u64, Return=()&gt; {
    || {
        let x: u64 = 1;
        let ref_x: &amp;u64 = &amp;x;
        yield *ref_x;
        yield 0;
    }
}</code><p>在第一次 <code class="inline">yield</code> 结束之后，编译器会发现 <code class="inline">generator</code> 唯一需要保留的是字面量 <code class="inline">0</code>，所以这段代码可以顺利编译通过。但是，对于前面的 <code class="inline">generator</code>，第一次 <code class="inline">yield</code> 过后，编译器发现你需要同时保留 <code class="inline">x</code> 和它的引用 <code class="inline">ref_x</code>，这样的话 <code class="inline">generator</code> 就会变成类似这样的结构（仅供参考）：</p><code lang="rust">enum SomeGenerator&lt;'a&gt; {
    ...
    SomeState {
        _yield: u64,
        x: u64
        ref_x: &amp;'a u64
    }
    ...
}</code><p>这就是 <code class="inline">rust</code> 中“臭名昭著” 的自引用，下面这段代码会发生什么呢</p><code lang="rust">struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn new() -&gt; Self {
        let mut a = A{b: 1, ref_b: None};
        a.ref_b = Some(&amp;a.b);
        a
    }
}</code><p>你会发现它编译不过，当然这是很合理的，栈上的 a 变量拷贝出去之后其成员 b 的引用会失效，<code class="inline">rust</code>的生命周期机制帮你规避了这个问题。但即使你改成这样</p><code lang="rust">use std::borrow::{BorrowMut};

struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn boxed() -&gt; Box&lt;Self&gt; {
        let mut a = Box::new(A{b: 1, ref_b: None});
        let mut_ref: &amp;mut A = a.borrow_mut();
        mut_ref.ref_b = Some(&amp;mut_ref.b);
        a
    }
}</code><p>这样按道理来说是没问题的，因为 a 的实体已经在堆上了，即使你拷贝它在栈上的引用，也不会改变其成员 b 的地址，引用一直是有效的 —— 但问题是，你没法跟编译器解释这事，编译器认为函数里面的 <code class="inline">&amp;mut_ref.b</code>只能活到函数结束，这样含有这个引用的 a 自然也不能 move 出来。</p><p>那你可能会想，那我就在外面再取引用就好了</p><code lang="rust">struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn new() -&gt; Self {
        A{b: 1, ref_b: None}
    }
}

fn main() {
    let mut a = A::new();
    a.ref_b = Some(&amp;a.b);
}</code><p>这样的确没啥毛病，但是，你会发现自引用不仅阻止了 move，还阻止了你对 A 可变引用。。比如这样就编译不过</p><code lang="rust">struct A&lt;'a&gt; {
    b: u64,
    ref_b: Option&lt;&amp;'a u64&gt;
}

impl&lt;'a&gt; A&lt;'a&gt; {
    fn new() -&gt; Self {
        A{b: 1, ref_b: None}
    }

    fn mute(&amp;mut self) {

    }
}

fn main() {
    let mut a = A::new();
    a.ref_b = Some(&amp;a.b);
    a.mute();
}</code><p>但远古的 <code class="inline">Future::poll</code> 签名就长这样</p><code lang="rust">fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt;;</code><p>而直到现在 <code class="inline">Generator::resume</code> 的签名还是这样</p><code lang="rust">unsafe fn resume(&amp;mut self) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;</code><p>这样的话自引用会导致 <code class="inline">generator</code> 无法实现 <code class="inline">Generator</code> 和 <code class="inline">Future</code> </p><p>在这种情况下，我们可以使用 <code class="inline">NonNull</code>来避过编译器的检查</p><code lang="rust">use std::ptr::NonNull;

struct A {
    b: u64,
    ref_b: NonNull&lt;u64&gt;
}

impl A {
    fn new() -&gt; Self {
        A{b: 1, ref_b: NonNull::dangling()}
    }
}

fn main() {
    let mut a = A::new();
    a.ref_b = NonNull::from(&amp;a.b);
}</code><p>这样的确没有了烦人的生命周期约束，但也意味着你要自己保证内存安全 —— 绝对不能 move，也不能对其可变引用使用 <code class="inline">mem::replace</code> 或 <code class="inline">mem::swap</code> ，这样非常不妙。</p><h2>Pin</h2><p>那有没有办法通过其它方式来保证能保证它不能被 move 或者取可变引用呢？这就是 <code class="inline">pin</code>的应用场景了。<code class="inline">pin</code>具体的内容可以看这篇 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md">RFC</a>，本文只是简要说明一下。</p><p><code class="inline">rust</code> 默认给大部分类型实现了 <code class="inline">trait std::marker::Unpin</code>，这只是一个标记，表示这个类型 move 是安全的，这时候，<code class="inline">Pin&lt;'a, T&gt;</code> 跟 <code class="inline">&amp;'a mut T</code> 没有区别，你也可以安全地通过 <code class="inline">Pin::new(&amp;mut T)</code> 和 <code class="inline">Pin::as_mut(self: &amp;mut Pin&lt;T&gt;)</code>相互转换。</p><p>但对于不能安全 move 的类型，比如上面的 <code class="inline">A</code>，我们得先把它标记为 <code class="inline">!Unpin</code>，安全的标记方法是给它一个 <code class="inline">!Unpin</code>的成员，比如 <code class="inline">Pinned</code>。</p><code lang="rust">#![feature(pin)]
use std::marker::{Pinned};

use std::ptr::NonNull;

struct A {
    b: u64,
    ref_b: NonNull&lt;u64&gt;,
    _pin: Pinned,
}

impl A {
    fn new() -&gt; Self {
        A {
            b: 1,
            ref_b: NonNull::dangling(),
            _pin: Pinned,
        }
    }
}

fn main() {
    let mut a = A::new();
    let mut pinned = unsafe { Pin::new_unchecked(&amp;mut a) };
    let ref_b = NonNull::from(&amp;pinned.b);
    let mut_ref: Pin&lt;&amp;mut A&gt; = pinned.as_mut();
    unsafe {Pin::get_mut_unchecked(mut_ref).ref_b = ref_b};
    let unmoved = pinned;
    assert_eq!(unmoved.ref_b, NonNull::from(&amp;unmoved.b));
}</code><p>从 <code class="inline">!Unpin</code> 的类型构建 <code class="inline">Pin</code> 总是 <code class="inline">unsafe</code> 的，它们通过 <code class="inline">Pin::new_unchecked</code> 和 <code class="inline">Pin::get_mut_unchecked</code> 相互转换。当然，我们在构建时是可以保证它是 <code class="inline">safe</code> ，我们只要完成这两个 <code class="inline">unsafe</code>的操作，就可以保证：</p><ul><li>永远不能 <code class="inline">safe</code> 地获得可变引用： <code class="inline">Pin::get_mut_unchecked</code> 是 <code class="inline">unsafe</code> 的</li><li>永远不能 <code class="inline">safe</code> 地 move：因为 <code class="inline">Pin</code> 只拥有可变引用，且由于<code class="inline">Pin::get_mut_unchecked</code> 是 <code class="inline">unsafe</code> 的，你不能 <code class="inline">safe</code> 地对其可变引用使用 <code class="inline">mem::replace</code> 或 <code class="inline">mem::swap</code></li></ul><p>当然，如果你不想在构建时使用 <code class="inline">unsafe</code>或者想获得 <code class="inline">a</code> 的所有权以便在函数间传递，你可以使用 <code class="inline">Box::pinned</code>从而把它分配在堆上</p><code lang="rust">struct A {
    b: u64,
    ref_b: NonNull&lt;u64&gt;,
    _pin: Pinned,
}

impl A {
    fn boxed() -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let mut boxed = Box::pinned(A {
            b: 1,
            ref_b: NonNull::dangling(),
            _pin: Pinned,
        });
        let ref_b = NonNull::from(&amp;boxed.b);
        let mut_ref: Pin&lt;&amp;mut A&gt; = boxed.as_mut();
        unsafe { Pin::get_mut_unchecked(mut_ref).ref_b = ref_b };
        boxed
    }
}

fn main() {
    let boxed = A::boxed();
    let unmoved = boxed;
    assert_eq!(unmoved.ref_b, NonNull::from(&amp;unmoved.b));
}</code><p>有了 <code class="inline">Pin</code> 之后，新版 <code class="inline">Future</code> 的定义就是这样的了</p><code lang="rust">pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, lw: &amp;LocalWaker) -&gt; Poll&lt;Self::Output&gt;;
}</code><h2>合理的抽象</h2><p>既然已经打算钦定了 <code class="inline">coroutine</code> 作为异步 <code class="inline">IO</code> 的 <code class="inline">API</code> 抽象，那应该把哪些东西加入标准库、哪些东西加入语法支持、哪些东西交给第三方实现呢？让开发者手动调用 <code class="inline">unsafe</code> 的 <code class="inline">Generator::resume</code> 终归不是很妙，也不好把 <code class="inline">mio</code> 作为唯一的底层异步 <code class="inline">IO</code> 实现（如果这样的话不如把 <code class="inline">mio</code> 也并入标准库）。</p><p>现在的 <code class="inline">rust</code> 提供了 <code class="inline">async</code> 的语法支持（以前是用过程宏的实现的）、<code class="inline">await!</code>的标准库宏支持，标准库 <code class="inline">std::future</code> 的 <code class="inline">trait Future</code> 和 <code class="inline">struct GenFuture</code> ， 标准库 <code class="inline">std::task</code> 的  <code class="inline">enum Poll&lt;T&gt;, struct LocalWaker, struct Waker</code> 和 <code class="inline">trait UnsafeWaker</code>。</p><p>你需要给你的 <code class="inline">MyWaker</code> 实现 <code class="inline">trait UnsafeWaker</code>，用 <code class="inline">mio</code> 的话就用 <code class="inline">SetReadiness</code>，<code class="inline">unsafe fn wake(&amp;self)</code> 用 <code class="inline">SetReadiness::set_readiness</code> 实现。然后把 <code class="inline">MyWaker</code> 包在 <code class="inline">Waker, LocalWaker</code> 里面。</p><h2>Poll&lt;T&gt;</h2><p><code class="inline">Poll&lt;T&gt;</code> 的定义为</p><code lang="rust">pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}</code><h2>await!</h2><p><code class="inline">await!</code> 宏只能在 <code class="inline">async</code> 函数或者块里面用，传入一个 <code class="inline">Future</code></p><p><code class="inline">await!(future)</code>会被展开成</p><code lang="rust">loop {
    if let Poll::Ready(x) = ::future::poll_with_tls(unsafe{
        Pin::new_unchecked(&amp;mut future)
    }) {
        break x;
    }
    yield
}</code><p><code class="inline">::future::poll_with_tls</code> 即 <code class="inline">thread-local waker</code>，就是你传给这个 <code class="inline">GenFuture::poll</code> 的 <code class="inline">LocalWaker</code>，</p><h2>async</h2><p><code class="inline">async</code>则会把 <code class="inline">Generator</code> 包装成 <code class="inline">Future(GenFuture)</code> 。</p><p><code class="inline">GenFuture</code> 的相关定义如下</p><code lang="rust">struct GenFuture&lt;T: Generator&lt;Yield = ()&gt;&gt;(T);

impl&lt;T: Generator&lt;Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}

impl&lt;T: Generator&lt;Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; {
    type Output = T::Return;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, lw: &amp;LocalWaker) -&gt; Poll&lt;Self::Output&gt; {
        set_task_waker(lw, || match unsafe { Pin::get_mut_unchecked(self).0.resume() } {
            GeneratorState::Yielded(()) =&gt; Poll::Pending,
            GeneratorState::Complete(x) =&gt; Poll::Ready(x),
        })
    }
}

pub fn from_generator&lt;T: Generator&lt;Yield = ()&gt;&gt;(x: T) -&gt; impl Future&lt;Output = T::Return&gt; {
    GenFuture(x)
}</code><p>这里可以看到，<code class="inline">GenFuture</code> 在每次调用 <code class="inline">self.0.resume</code> 之前会 <code class="inline">set_task_waker</code>，通过一个 <code class="inline">thread_local</code> 的变量中转，从而 <code class="inline">generator</code> 里面的 <code class="inline">future::poll</code> 能通过 <code class="inline">poll_with_tls</code> 拿到这个 <code class="inline">LocalWaker</code>。</p><p>所以，下面的代码</p><code lang="rust">async fn async_recv(string_channel: Receiver&lt;String&gt;) -&gt; String {
    await!(string_channel.recv_future())
}</code><p>会被类似地展开为这样</p><code lang="rust">fn async_recv(string_channel: Receiver&lt;String&gt;) -&gt; impl Future&lt;Output = T::Return&gt; {
    from_generator(move || {
        let recv_future = string_channel.recv_future();
        loop {
            if let Poll::Ready(x) = ::future::poll_with_tls(unsafe{
                Pin::new_unchecked(&amp;mut recv_future)
            }) {
                break x;
            }
            yield
        }
    })
}</code><h2>asynchronous coroutine</h2><p>掌握了上文的基础知识后，我们就可以开始实践了。</p><p>coroutine 本身并不意味着“异步”，你完全可以在两次 <code class="inline">yield</code> 之间调用同步 <code class="inline">IO</code> 的 <code class="inline">API</code> 从而导致 <code class="inline">IO</code> 阻塞。 异步的关键在于，在将要阻塞的时候（比如某个 <code class="inline">API</code> 返回了 <code class="inline">io::ErrorKind::WouldBlock</code>），<code class="inline">GenFuture::poll</code>中 用底层异步接口注册一个事件和唤醒回调（<code class="inline">waker</code>）然后自身休眠（<code class="inline">yield</code>），底层异步调度在特定事件发生的时候回调唤醒这个 <code class="inline">Future</code>。</p><p>下面我参照 <code class="inline">romio</code> 的异步调度实现了 <code class="inline">Executor</code> <code class="inline">block_on, spawn, TcpListener</code> 和 <code class="inline">TcpStream</code>，代码较长，建议 <code class="inline">clone</code> 后用编辑器看。（请注意区分 <code class="inline">Poll(mio::Poll)</code> 与 <code class="inline">task::Poll</code> 以及 <code class="inline">net::{TcpListener, TcpStream}(mio::net::{TcpListener, TcpStream})</code> 与 <code class="inline">TcpListener, TcpStream</code>）</p><p><a href="https://github.com/Hexilee/async-io-demo/blob/master/src/executor.rs">src/executor.rs</a></p><h2>Executor</h2><p><code class="inline">Executor</code> 中包含 <code class="inline">mio::Poll</code>，<code class="inline">main task waker</code> 及用来管理 <code class="inline">task</code> 和 <code class="inline">source</code> 的 <code class="inline">Slab</code> 各一个。其本身并没有实现什么特别的方法，主要是初始化为 <code class="inline">thread_local</code> 的 <code class="inline">EXECUTOR</code> 供其它函数借用。</p><h2>block_on</h2><p><code class="inline">block_on</code> 函数会阻塞当前线程，传入参数是一个 <code class="inline">future: Future&lt;Output=T&gt;</code>，被称为 <code class="inline">main task</code>；返回值类型是 <code class="inline">T</code>。该函数一般在最外层被调用。</p><p><code class="inline">block_on</code> 会引用 <code class="inline">thread_local EXECUTOR</code>，主要逻辑是调用 <code class="inline">mio::Poll::poll</code> 来响应事件。<code class="inline">block_on</code> 把 <code class="inline">0 - MAX_RESOURCE_NUM(1 &lt;&lt; 31)</code> 个 <code class="inline">Token</code> 分为三类。</p><ul><li><code class="inline">main task token</code></li></ul><p>收到 <code class="inline">Token</code> 为 <code class="inline">MAIN_TASK_TOKEN</code> 的事件即表示需要唤醒 <code class="inline">main task</code>，执行 <code class="inline">main_task.poll</code>，返回 <code class="inline">task::Poll::Ready(T)</code> 则 <code class="inline">block_on</code> 函数返回。</p><ul><li><code class="inline">task token</code></li></ul><p>奇数 <code class="inline">token</code> 表示由 <code class="inline">spawn</code> 函数分发的其它任务需要被唤醒，执行相应的 <code class="inline">task.poll</code>，<code class="inline">token</code> 和该事件在 <code class="inline">EXECUTOR.tasks</code> 中的 <code class="inline">index</code> 一一映射。</p><ul><li><code class="inline">source token</code></li></ul><p>偶数 <code class="inline">token</code> 表示由 <code class="inline">register_source</code> 函数注册的 <code class="inline">source</code>需要被分发，执行相应 <code class="inline">source</code> 的 <code class="inline">waker()</code> 以唤醒分发它们的 <code class="inline">task</code>。</p><h2>spawn</h2><p>分发任务</p><h2>TcpListener</h2><p>包装了 <code class="inline">mio::net::TcpListener</code>，<code class="inline">accept</code> 方法返回一个 <code class="inline">Future</code>。</p><h2>TcpStream</h2><p>包装了 <code class="inline">mio::net::TcpStream</code>, <code class="inline">read</code>和 <code class="inline">write</code> 方法均返回 <code class="inline">Future</code>。</p><h2>后记</h2><p>实现了 <code class="inline">executor</code> 之后，我们就可以运行文章开头给的 <code class="inline">example</code>    了，</p><code lang="bash">RUST_LOG=info cargo run --example async-echo</code><p>可以用 <code class="inline">telnet</code> 连连试试看。</p><p>当然最后还留了一个问题，就是把文件 <code class="inline">IO</code> 也封装为 <code class="inline">coroutine</code> 的异步 <code class="inline">IO</code>，当然我还没有写，读者有兴趣可以试着实现一下，我们接下来再谈谈现在 <code class="inline">coroutine API</code> 的不足。</p><p>我目前发现的主要问题就是不能在 <code class="inline">Future::poll</code> 或者 <code class="inline">async</code> 中使用 <code class="inline">try</code>，导致出现 <code class="inline">Result</code> 的地方只能 <code class="inline">match</code>，希望之后会有比较好的解决方案。</p><p>第二个问题是 <code class="inline">Waker</code> 最里面装的是 <code class="inline">UnsafeWaker</code>的 <code class="inline">NonNull</code> 指针，当然我能理解 <code class="inline">rust</code> 团队有性能等其它方面的考虑，但如果用 <code class="inline">mio</code> 的 <code class="inline">set_readiness</code> 封装出 <code class="inline">MyWaker</code> 的话，<code class="inline">clone</code> 完全不需要 <code class="inline">NonNull</code>，而且我在实际编码时因为这个出过空指针错误。。希望以后能提供一个更安全的选择。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
