<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>你好，类型（十）：Parametric polymorphism</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34936637">原文</a></p>
<p></p><img src="https://pic1.zhimg.com/v2-6b54d583eb6b73ad8566ca881cf020a0_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="698"><h2><b>回顾</b></h2><p>上文我们介绍了<b>let多态</b>，<br>将let表达式 <equation>let~x=t_1~in~t_2</equation> ，看做了 <equation>[x\mapsto t_1]t_2</equation> 的简写，<br>即，把 <equation>t_2</equation> 中出现的所有 <equation>x</equation> ，都用 <equation>t_1</equation> 替换掉，因此这些副本可以具有不同的类型。</p><p>本文将介绍另外一种多态形式，称为<b>参数化多态</b>（<a href="https://en.wikipedia.org/wiki/Parametric_polymorphism">parametric polymorphism</a>），例如，</p><code lang="haskell">data Maybe a = Nothing | Just a</code><p>以上Haskell代码，定义了一个<code class="inline">Maybe a</code>类型，<br>其中<code class="inline">Maybe</code>称为类型构造器（type constructor），<code class="inline">a</code>是它的参数。</p><p><code class="inline">Maybe</code>不是一个合法的类型，它只有和某个具体的<code class="inline">a</code>放在一起，才是一个合法的类型，<br>例如，<code class="inline">Maybe Int</code>，<code class="inline">Maybe Char</code>。</p><h2><b>System F</b></h2><img src="https://pic4.zhimg.com/v2-2599a0bf18815b88e00dbfd51c04a385_r.jpg" data-caption="" data-size="normal" data-rawwidth="270" data-rawheight="270"><p>为了实现参数化多态，我们需要对简单类型化 <equation>\lambda</equation> 演算（ <equation>\lambda^\to</equation> 系统）进行扩展，<br>在 <equation>\lambda^\to</equation> 中，我们用 <equation>\lambda x.t</equation> 来表示 <equation>\lambda</equation> 抽象（lambda abstraction），<br>而使用 <equation>t_1~t_2</equation> 来表示 <equation>\lambda</equation> 应用（lambda application）。</p><p>现在我们引入一种新的抽象形式， <equation>\lambda X.t</equation> ，它的参数 <equation>X</equation> 是一个类型，称为<b>类型抽象</b>，<br>再引入一种新的应用形式， <equation>t[T]</equation> ，称为<b>类型实例化</b>，其中 <equation>T</equation> 是一个类型表达式。</p><p><b>求值规则</b>如下，<br> <equation>(\lambda X.t)[T]\to[X\mapsto T]</equation> </p><p>例如，我们可以这样定义一个多态函数， <equation>id=\lambda X.\lambda x:X.x</equation> ，<br>当把它应用于类型 <equation>Nat</equation> 时，<br> <equation>id[Nat]\to[X\mapsto Nat](\lambda x:X.x)=\lambda x:Nat.x</equation> ，它为 <equation>Nat</equation> 类型上的恒等函数。<br>而把它应用于类型 <equation>Bool</equation> 时，<br> <equation>id[Bool]\to[X\mapsto Bool](\lambda x:X.x)=\lambda x:Bool.x</equation> ，它为 <equation>Bool</equation> 类型上的恒等函数，</p><p>可见， <equation>id</equation> 的具体类型，依赖于它的<b>类型参数</b>。<br>它应用于任意一个类型 <equation>T</equation> ， <equation>id[T]</equation> 都会得到一个类型为 <equation>T\to T</equation> 的函数，<br>因此，人们通常将 <equation>id</equation> 的类型记为 <equation>\forall X.X\to X</equation> 。</p><p><b>类型规则</b>如下，</p><p>（1） <equation>\frac{\Gamma,X\vdash t:T}{\Gamma\vdash\lambda X.t:\forall X.T}</equation> <br>（2） <equation>\frac{\Gamma\vdash t_1:\forall X.T_1}{\Gamma\vdash t[T_2]:[X\mapsto T_2]T_1}</equation> </p><p>其中，类型 <equation>\forall X.T</equation> ，叫做<b>全称类型</b>（universal type），<br> <equation>\forall</equation> 称为<b>全称量词</b>（universal quantifier），引入了全称类型之后得到的系统，称为<b>System F</b>。</p><h2><b>Rank-N Types</b></h2><img src="https://pic4.zhimg.com/v2-e7d0c235c510c23fd00f4261f94e4eb6_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="698"><p>有了全称类型之后，函数的参数类型和返回值类型，都有可能具有全称类型。<br>不难看出，函数返回值类型的全称量词，总是可以提取出来，放到最外面，<br>但是参数类型的全称量词，不能提取出来。</p><p>例如， <equation>\forall X.X\to (\forall Y.Y\to X)</equation> ，相当于 <equation>\forall X.\forall Y.X\to Y\to X</equation> ，<br>而 <equation>(\forall X.X\to X)\to Nat</equation> ，与 <equation>\forall X.(X\to X)\to Nat</equation> 则不同。</p><p>不包含全称量词的类型表达式，具有<b>rank-0类型</b>，也称为<b>单态类型</b>（monotype），<br>全称量词都可以提取出来类型表达式，具有<b>rank-1类型</b>（rank-1 type），<br>一个函数类型，它的入参具有<b>rank-n类型</b>，那么该函数就具有<b>rank-(n+1)类型</b>。</p><p>例如，<br> <equation>((\forall X.X\to X)\to Nat)\to Bool\to Bool</equation> ，具有rank-3类型，<br> <equation>Nat\to (\forall X.X\to X)</equation> ，具有rank-1类型。</p><p>System F的功能是很强大的，但是<a href="https://en.wikipedia.org/wiki/System_F#Use_in_programming_languages">不幸的是</a>，<br>人们发现，该系统中的类型推导算法是<a href="https://en.wikipedia.org/wiki/Undecidable_problem">不可判定的</a>。<br>例如，一般而言，一个rank-3及其以上rank-N类型的表达式，其类型是不可确定的，<br>为了确定它的类型，人们不得不手工加上必要的类型信息。</p><p>Haskell采用了<a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley–Milner类型系统</a>，<br>它是System F的一个子集，其中包含了可判定的类型推导算法。<br>在Haskell中，类型参量（type variable）<b>默认</b>具有全称类型（universally quantified），<br>例如，<code class="inline">a -&gt; a</code>，实际上表示类型 <equation>\forall a.a\to a</equation> ，<br><code class="inline">a -&gt; a</code>可看做<code class="inline">(-&gt;) a a</code>类型，其中<code class="inline">-&gt;</code>为函数类型构造器。</p><h2><b>非直谓性</b></h2><img src="https://pic3.zhimg.com/v2-b687486615e31ac710fae4f635cc5817_r.jpg" data-caption="" data-size="normal" data-rawwidth="200" data-rawheight="257"><p>在数学和逻辑学中，一个定义称为<b>非直谓的</b>（<a href="https://en.wikipedia.org/wiki/Impredicativity">impredicative</a>），<br>指的是它包含了自引用（self-reference）。</p><p>例如，在定义一个集合的时候，用到了正在定义的这个集合。</p><p><a href="https://en.wikipedia.org/wiki/Russell%27s_paradox">罗素悖论</a>就是用非直谓的方式构造出来的，<br>如果我们定义 <equation>R=\{x|x\notin x\}</equation> ，那么 <equation>R\in R\Leftrightarrow R\notin R</equation> 。</p><p>非直谓定义并不一定导致矛盾，有些情况下还是有用的，例如，我们可以非直谓的定义，<br>集合中的最小元素为， <equation>A_{min}=x</equation> ， <equation>\forall y.x\leqslant y</equation> 。</p><p>具有参数化多态的类型表达式，也有直谓（predicative）和非直谓（impredicative）之分。</p><p>如果它可以用一个多态类型实例化，例如用它自己来实例化，<br>就称为<b>非直谓多态类型</b>（<a href="https://en.wikipedia.org/wiki/Parametric_polymorphism#Impredicative_polymorphism">impredicative polymorphism</a>）。</p><p>反之，如果一个多态类型表达式，只能用单态类型实例化，<br>就称它具有<b>直谓多态类型</b>（<a href="https://en.wikipedia.org/wiki/Parametric_polymorphism#Predicative_polymorphism">predicative_polymorphism</a>）。</p><h2><b>单态限制</b></h2><img src="https://pic1.zhimg.com/v2-9f700c8427d7653a97af35c5fa56445d_r.jpg" data-caption="" data-size="normal" data-rawwidth="503" data-rawheight="337"><code lang="haskell">f x = let g y z = ([x,y], z) 
      in ...</code><p>假设<code class="inline">x</code>的类型为<code class="inline">a</code>，那么<code class="inline">g</code>的类型只能为<code class="inline">a -&gt; b -&gt; ([a], b)</code>，<br>其中，由于列表类型的限制，<code class="inline">x</code>和<code class="inline">y</code>必须具有相同的类型。</p><p>此时，只有<code class="inline">b</code>可以具有全称量词，即 <equation>\forall b.a\to b\to ([a],b)</equation> ，<br>因为<code class="inline">a</code>在类型上下文中，已经出现了，不能再被实例化为其他的类型了。<br>我们称，<code class="inline">g</code>的第一个参数<code class="inline">a</code>具有<b>单态性</b>（monomorphism）。</p><p>例如，<code class="inline">(g True, g 'c')</code>不是良类型的，而<code class="inline">(g True, g False)</code>是良类型的。</p><p>值得一提的是，显式的给<code class="inline">g</code>注明类型，也不能阻止<code class="inline">a</code>的单态行为，</p><code lang="haskell">f x = let 
         g :: a -&gt; b -&gt; ([a],b) 
         g y z = ([x,y], z) 
      in ...</code><p>此时，<code class="inline">a</code>仍然是单态的。</p><p>在<a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley–Milner类型系统</a>中，<br>如果一个类型变量，不在类型上下文中出现，它就可以被<b>全称化</b>（generalize）。<br>但是Haskell考虑到性能和模块间的类型推导，<br>还增加了特殊的<b>单态限制</b>（monomorphism restriction）避免全称化。</p><p><b>Rule 1</b></p><p>在一组相互依赖的声明中，满足以下两个条件，其中的类型变量才会被全称化，<br>（1）每一个变量，都被函数或模式匹配所绑定，<br>（2）被模式匹配绑定的变量，都有显式的类型签名。</p><p><b>Rule 2</b></p><p>导入到其他模块（module）的单态类型变量，被认为是有歧义的（ambiguous），<br>类型通过其来源模块内的<code class="inline">default</code>声明来决定。</p><code lang="haskell">module M1(len1) where 
  default( Int, Double ) 
  len1 = genericLength "Hello"

module M2 where 
  import M1(len1) 
  len2 = (2 * len1) :: Rational</code><p>当模块<code class="inline">M1</code>的类型推导结束后，根据Rule 1，<code class="inline">len1</code>具有单态类型，<br><code class="inline">len1 :: Num a =&gt; a</code>，<br>Rule 2表明，类型变量<code class="inline">a</code>具有歧义性，必须使用<code class="inline">default</code>声明来解决歧义。</p><p>因此，根据<code class="inline">default( Int, Double )</code>，<code class="inline">len1</code>得到了类型<code class="inline">Int</code>，<br>不过，<code class="inline">M2</code>中对<code class="inline">len1 :: Int</code>的使用导致了类型错误。</p><hr><h2><b>参考</b></h2><p><a href="https://book.douban.com/subject/1761910/">Types and programming languages</a><br><a href="https://www.haskell.org/definition/haskell2010.pdf">Haskell 2010 Language Report</a><br><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arbitrary-rank-polymorphism">Glasgow Haskell Compiler User’s Guide</a><br><a href="https://en.wikipedia.org/wiki/Parametric_polymorphism">Parametric polymorphism</a><br><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf">Practical type inference for arbitrary-rank types</a><br><a href="https://en.wikipedia.org/wiki/System_F">System F</a><br><a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley–Milner type system</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
