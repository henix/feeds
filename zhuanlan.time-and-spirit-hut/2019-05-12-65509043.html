<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>「Rust日报」2019每周精选 • 第十五期</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/65509043">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-23599072636a1820bba7b49b9d586092_b.jpg" alt=""></div><blockquote>前言：<br/>从2018年开始，我每天会花1个小时关注Rust社区动态，并且分享我每天的见闻，偶尔也夹杂了一些个人的观点。新的一年过去了，Rust日报已经成为了Rust社区群大家每天必看的内容。<br/>从2019年开始，日报小组成立，目前的动态由：@Chaos、 @Mike、 @Damody(台湾)轮番为大家播报。也欢迎感兴趣的朋友加入小组。<br/>每周也会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。<br/>独立日报订阅地址： - <a href="https://link.zhihu.com/?target=https%3A//t.me/rust_daily_news" class=" wrap external" target="_blank" rel="nofollow noreferrer">Telgram Channel</a> - <a href="https://link.zhihu.com/?target=https%3A//www.yuque.com/chaosbot/rustnews" class=" wrap external" target="_blank" rel="nofollow noreferrer">阿里云语雀订阅</a> - <a href="https://link.zhihu.com/?target=https%3A//steemit.com/%40blackanger" class=" wrap external" target="_blank" rel="nofollow noreferrer">Steemit</a> - <a href="https://link.zhihu.com/?target=https%3A//github.com/RustStudy/rust_daily_news" class=" wrap external" target="_blank" rel="nofollow noreferrer">GitHub</a><br/>社区学习交流平台订阅： - <a href="https://link.zhihu.com/?target=https%3A//rust.cc/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Rust.cc论坛</a> - <a href="https://link.zhihu.com/?target=https%3A//rustforce.net/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Rust Force</a> - <a href="https://link.zhihu.com/?target=https%3A//rust.cc/article%3Fid%3Ded7c9379-d681-47cb-9532-0db97d883f62" class=" wrap external" target="_blank" rel="nofollow noreferrer">微信公众号：Rust语言学习交流</a><br/>2019-05-12 </blockquote><hr/><h2>官方新闻</h2><h3>Await 语法预告</h3><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-2d1e5c7e407e5735abd3f888c81fac43_b.jpg" data-caption="" data-size="normal" class="content_image"/></noscript><img src="https://pic4.zhimg.com/v2-2d1e5c7e407e5735abd3f888c81fac43_b.jpg" data-caption="" data-size="normal" class="content_image lazy" data-actualsrc="https://pic4.zhimg.com/v2-2d1e5c7e407e5735abd3f888c81fac43_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p><a href="https://zhuanlan.zhihu.com/p/64916694" class="internal">Read More</a></p><p>await语法，官方代码里已经安排上了</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-3516815c6b0b84b1ec359ae06fbd33e8_b.jpg" data-caption="" data-size="normal" data-rawwidth="1708" data-rawheight="1082" class="origin_image zh-lightbox-thumb" width="1708" data-original="https://pic1.zhimg.com/v2-3516815c6b0b84b1ec359ae06fbd33e8_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-3516815c6b0b84b1ec359ae06fbd33e8_b.jpg" data-caption="" data-size="normal" data-rawwidth="1708" data-rawheight="1082" class="origin_image zh-lightbox-thumb lazy" width="1708" data-original="https://pic1.zhimg.com/v2-3516815c6b0b84b1ec359ae06fbd33e8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-3516815c6b0b84b1ec359ae06fbd33e8_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>这里，还有一个工具 <a href="https://link.zhihu.com/?target=https%3A//github.com/taiki-e/replace-await" class=" wrap external" target="_blank" rel="nofollow noreferrer">replace-await</a> 用于把之前的 await!(xxx) 这种宏代码迁移到 xxx.await 的写法。</p><h3>Cargo Vender 子命令即将登陆Cargo</h3><p>cargo vender支持将<a href="https://link.zhihu.com/?target=http%3A//crates.io" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">crates.io</span><span class="invisible"></span></a>中的依赖项保存到你本地目录下。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/rust-lang/cargo/pull/6869" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></p><h3>「嵌入式工作组」μAMP: 微控制器上的非对称多处理</h3><p>microamp（就是μAMP）是用于构建针对AMP系统的裸机应用程序，它是Real Time For the Masses（RTFM）多核版本的核心基础。</p><p>从历史上看，微控制器被设计为单核系统（SoC），但较新的设计越来越多地选择异构多核架构。例如，恩智浦的LPC43xx系列将Cortex-M4处理器与一个（或多个）Cortex-M0协处理器配对在一个封装中。这些设计的目标通常是优化功耗：例如，较低功率M0可以处理所有I/O，而M4内核仅被激活以执行昂贵的浮点/ DSP计算。</p><p>μAMP模型让我们可以针对这类系统，但也可以应用于同类多核系统，如Zynq UltraScale+EG或LPC55S69（2 ARM Cortex）上的双核实时处理器（2个ARM Cortex-R5内核）微控制器。</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//blog.japaric.io/microamp/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read more</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/japaric/microamp" class=" wrap external" target="_blank" rel="nofollow noreferrer">microamp</a></li></ul><h3>「Rust Wasm工作组」：wasm-tracing-allocator</h3><p>一個全局的分配器追踨器，可以追到wasm内存分配的情況</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/rustwasm/wasm-tracing-allocator" class=" wrap external" target="_blank" rel="nofollow noreferrer">wasm-tracing-allocator</a></p><h3>「官方文档」Rust API 指南(api-guidelines)</h3><p>今天有个Reddit讨论贴，有人指出每个发布到<a href="https://link.zhihu.com/?target=http%3A//crates.io" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">crates.io</span><span class="invisible"></span></a>的crate都应该加上Readme说明和Repository地址（GitHub、GitLab等），以方便用户。</p><div class="highlight"><pre><code class="language-rust"><span class="err">#</span><span class="w"> </span><span class="n">Cargo</span><span class="p">.</span><span class="n">toml</span><span class="w">
</span><span class="w"></span><span class="n">readme</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;README.md&#34;</span><span class="w">
</span><span class="w"></span><span class="n">repository</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;https://github.com/user/my_awesome_crate&#34;</span><span class="w">
</span></code></pre></div><p>评论中有人提到Rust官方出品的「Rust API 指南(api-guidelines)」， Rust crate作者应该将它们视为开发Rust库时的一组重要参考因素（非必须遵守）。该指南还在完善中。该指南包含两部分：</p><ul><li>Checklist，用于发布crate时快速检查</li><li> 详细说明，对checklist中的内容做详细的说明<br/> </li><li><a href="https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bngvml/psa_please_put_readme_and_repository_links_in/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a><br/> </li><li><a href="https://link.zhihu.com/?target=https%3A//rust-lang-nursery.github.io/api-guidelines/about.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">api-guidelines</a></li></ul><h3>「Cli工作组」新工具：paw</h3><p>为了使Rust开发Cli应用的体验更加一流，更方便地解析命令行参数，官方Cli工作组开发了这个Paw库，目前还是WIP状态。</p><div class="highlight"><pre><code class="language-rust"><span class="cp">#[paw::main]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span>: <span class="nc">paw</span>::<span class="n">Args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>paw::main</code>宏允许<code>fn main</code>接受任何实现<code>paw::ParseArgs trait</code>的参数，所以，支持将<code>std::env::Args</code>传递给<code>main</code>，还允许传递<code>structopt</code>实例。</p><p>假如paw的反响比较好，官方还将走RFC流程，将它引入标准库中。</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//blog.yoshuawuyts.com/paw/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/rust-cli/paw" class=" wrap external" target="_blank" rel="nofollow noreferrer">paw</a></li></ul><hr/><h2>社区新闻</h2><h3>Snip开源神经网络推理引擎Tract</h3><p>tract是Snips.ai公司嵌入式自然语言语音处理系统SnipFlow中的重要组件。该公司两年前在TensorFlow Lite出现之前打算将TensorFlow嵌入到库中方便他们执行模型，但是后来因为TensorFlow太过庞大复杂，不得不更改了计划。</p><p>新的计划就是使用Rust作为SnipFlow的主要语言，两年过去了，团队已经非常享受现代化软件环境带来的舒适感，而且比TensorFlow更容易交叉编译。</p><p>(其实tract上个月就开源了，只是这篇文章最近几天才发布)</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//medium.com/snips-ai/snips-open-sources-tract-cdc50f437ef2" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/snipsco/tract" class=" wrap external" target="_blank" rel="nofollow noreferrer">tract</a></li><li><a href="https://link.zhihu.com/?target=https%3A//snips.ai/" class=" wrap external" target="_blank" rel="nofollow noreferrer">snips.ai</a></li></ul><h3>JavaScript二进制AST格式的参考实现</h3><p>关于JavaScript二进制AST</p><p>随着网站变得越来越复杂，JavaScript源代码的数量不断增加。依赖于大型JavaScript代码库会导致网站启动缓慢 - 通常速度慢得令人无法接受。这是因为存在两个瓶颈：解析和字节码编译JavaScript。不幸的是，浏览器几乎达到了两种操作的效率峰值。</p><p>我们（Mozilla，Bloomberg，Facebook，CloudFlare）目前正致力于针对JavaScript的特定领域编码，称为“BinAST”（“JavaScript二进制AST”的缩写）。 JavaScript二进制AST旨在打破瓶颈。当前的高级原型已经在所有最常见的框架上显示了JS解析改进了30％-50％，只需更改格式，我们相信我们可以进一步提高这一改进。编码可以构建为webdev工具链的一部分，或者由代理或CDN注入，因此可以在不更改原始网站的情况下自动提高最终用户的性能。</p><p>此编码目前在JavaScript TC39标准化过程中。它可以与现有的压缩技术（gzip，brotli等）一起使用</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/binast/binjs-ref" class=" wrap external" target="_blank" rel="nofollow noreferrer">binjs-ref</a></p><h3>柏林都举行了 100 场 Rust 碰面聚会了</h3><p>欧洲人很爱 Rust？大家都爱嘛。他们从 2014 年起就开始进行Rust聚会了。国内要更多点才好。不仅是大会，各个城市的小会也搞起来。</p><p><a href="https://link.zhihu.com/?target=https%3A//berline.rs/2019/05/15/rust-hack-and-learn.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a> </p><h3>RubyGems将支持带有Rust内置扩展的gem</h3><p>将添加一个新的构建器CargoBuilder，它将检测Cargo.toml文件并使用Cargo构建gem原生扩展。这减轻了为Ruby用户开发和发布Rust扩展的负担。现在希望找寻贡献者来落实这项计划。</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//github.com/rubygems/rubygems/issues/2726%23issuecomment-491482467" class=" wrap external" target="_blank" rel="nofollow noreferrer">rubygems/issues/2726</a></li></ul><h3>尝试在Cloudsmith上发布你的crate</h3><p>Cloudsmith是Puppet Labs旗下的DevOps平台，目前支持Cargo。你可以把Cloudsmith作为<a href="https://link.zhihu.com/?target=http%3A//crates.io" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">crates.io</span><span class="invisible"></span></a>之外的私人registry。</p><p>本文介绍了如何使用cloudsmith-cli工具将你的crate发布到它的平台上。</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//blog.cloudsmith.io/2019/05/01/worlds-first-private-cargo-registry/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></li><li><a href="https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/cargo/reference/registries.html%23using-an-alternate-registry" class=" wrap external" target="_blank" rel="nofollow noreferrer">cargo registry 相关文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/64917441" class="internal">通过此文了解下Cargo Registry： 乱谈Cargo Registry </a></li></ul><h3>「论文」Rust并发的实践研究</h3><p>该论文通过实现一个并发无锁HashMap来研究Rust类型系统如何影响并发数据结构的开发和改进。他们的代码库concache在GitHub上公开，是Rust语言中最快的并发HashMap之一，可以帮助降低并发程序中的瓶颈。</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1904.12210" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></li><li><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1904.12210" class=" wrap external" target="_blank" rel="nofollow noreferrer">Paper pdf</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/saligrama/concache" class=" wrap external" target="_blank" rel="nofollow noreferrer">concache</a></li></ul><h3>combine-4.0.0-alpha.1 发布</h3><p>combine和nom的功能类似，但它的特点是建立在Rust的trait和类型系统之上，而不是宏。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/Marwes/combine/blob/master/CHANGELOG.md%23400-alpha1-2019-05-07" class=" wrap external" target="_blank" rel="nofollow noreferrer">完整的更新列表</a></p><h3>Xi-Editor作者新博文：现代GPU上的2D图形</h3><p>该作者花了一周的时间对「传统2D成像模型在现代图形世界中的未来」做了深入思考。2D图形建立在GPU之上是否是未来？作者认为是可行的，并且阐述了他的研究。感兴趣可以看看。</p><p><a href="https://link.zhihu.com/?target=https%3A//raphlinus.github.io/rust/graphics/gpu/2019/05/08/modern-2d.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></p><h3>「社区讨论」命名异步函数的返回类型</h3><p>该贴的作者认为，在async趋于稳定之前，还有个重要的讨论，就是支持异步函数的返回类型的自定义命名。</p><div class="highlight"><pre><code class="language-rust"><span class="n">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/**/</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="c1">// or even to make the return type nameable
</span><span class="c1"></span><span class="k">type</span> <span class="nc">FooReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="p">;</span><span class="w"> 
</span><span class="w"></span><span class="n">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">FooReturn</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/**/</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></div><p><a href="https://link.zhihu.com/?target=https%3A//internals.rust-lang.org/t/naming-the-return-type-of-an-async-function/10085" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read more</a></p><hr/><h2>学习资源</h2><h3>使用Chrome对Rust进行全自动单元测试</h3><p>stretch的作者写的一篇博客。stretch是一个跨平台的FlexBox引擎。在Visly公司，该作者正参与一个为前端工程师构建的设计工具，其中用到FlexBox，需要在不使用WebView的情况下保持Web、iOS和Android三端保持相同的布局。意味着在移动设备上复制Web的布局。</p><p>这篇文章里，作者介绍了使用stretch的单元测试方案，是一套自动编写自动化测试的方案，他们称其为gentest系统。大概原理如下图：</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-5fceb421ee21786bf3df64c00edfe45b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1184" data-rawheight="954" class="origin_image zh-lightbox-thumb" width="1184" data-original="https://pic4.zhimg.com/v2-5fceb421ee21786bf3df64c00edfe45b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-5fceb421ee21786bf3df64c00edfe45b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1184" data-rawheight="954" class="origin_image zh-lightbox-thumb lazy" width="1184" data-original="https://pic4.zhimg.com/v2-5fceb421ee21786bf3df64c00edfe45b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-5fceb421ee21786bf3df64c00edfe45b_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>所有的测试用例都用html文件来描述，并且包含<code>id =“test-root”</code>的布局。然后gentest使用WebDriver将此文件加载到Chrome head-less浏览器中。加载后，gentest将通过WebDriver向浏览器询问每个DOM节点的样式，大小和位置等信息，然后利用此信息，gentest再生成Rust单元测试，用于构建三端等效的FlexBox树给stretch api使用。最后可以统一通过<code>cargo test</code>来完成测试。</p><p>gentest的另一个好处是，因为每个测试只是一个html文件，只需打开文件就可以在浏览器中显示它。并且他们还利用gentest生成一套基准测试，确保性能不会退化。</p><p>gentest有什么黑科技吗？</p><p>它也是开源的，我翻了一下源码，主要是三步：</p><ol><li>使用quote!来构建待生成测试代码的模板（TokenSteam）</li><li>将这些模板填充以后从TokenSteam转称字符串。</li><li> 使用<code>fs::write</code>写到指定的目录文件中。<br/> </li><li><a href="https://link.zhihu.com/?target=https%3A//medium.com/visly/unit-testing-rust-using-chrome-b8b93572a91d" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a><br/> </li><li><a href="https://link.zhihu.com/?target=https%3A//vislyhq.github.io/stretch/" class=" wrap external" target="_blank" rel="nofollow noreferrer">stretch</a></li><li><a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/webdriver/" class=" wrap external" target="_blank" rel="nofollow noreferrer">webdriver</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/vislyhq/stretch/blob/master/scripts/gentest" class=" wrap external" target="_blank" rel="nofollow noreferrer">gentest</a></li></ol><h3>使用sccache在CircleCI上进行Rust缓存</h3><p>如果你的crates有很多依赖项，你可能已经注意到Rust编译阶段与实际运行测试相比需要花费很多时间。</p><p>缓解该问题的一种方法是缓存Rust编译的中间对象：大多数博客文章建议缓存Rust目标文件夹以减少编译时间。这种方法有一个主要问题，这个缓存文件会越来越大。</p><p>因此你需要定时清理这个缓存目录。该文推荐Mozilla的这个库sccache。该库的一个优点是可以配置文件夹的最大大小，当大小超过该限制时，会启动LRU清除算法（和Redis的差不多），清理掉部分缓存。</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//github.com/mozilla/sccache" class=" wrap external" target="_blank" rel="nofollow noreferrer">sccache</a></li><li><a href="https://link.zhihu.com/?target=https%3A//medium.com/%40edouard.oger/rust-caching-on-circleci-using-sccache-c996344f0115" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></li></ul><h3>「Handmade Rust系列」Part 4 : 创建Vulkan绑定</h3><p>该系列将以Rust手工制作方式开发Vulkan渲染引擎，这是第四篇博文。该项目的特点是，不使用标准库，只使用核心库。</p><ul><li><a href="https://link.zhihu.com/?target=http%3A//stevenlr.com/posts/handmade-rust-4-vulkan-bindings/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/stevenlr/HandmadeRust" class=" wrap external" target="_blank" rel="nofollow noreferrer">HandmadeRust</a></li></ul><h3>Graphlib v0.3.0已经发布！</h3><p>Graphlib，用于Rust编程语言的简单而强大的图库。提供了图数据结构的一些API。比如BFS/DFS等迭代器。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/purpleprotocol/graphlib" class=" wrap external" target="_blank" rel="nofollow noreferrer">graphlib</a></p><h3>Rust并发模式：通过共享sender通信</h3><p><a href="https://link.zhihu.com/?target=https%3A//medium.com/%40polyglot_factotum/rust-concurrency-patterns-communicate-by-sharing-your-sender-re-visited-9d42e6dfecfa" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></p><h3>使用Usher和Hyper构建简单的API</h3><p>Usher是在基于Hyper实现的一个简单的库，用于开发简单的HTTP API服务。Usher的特色是提供了一些方便从URL中提取参数的方法，类似于actix的提取器，但是它更加轻量。</p><p><a href="https://link.zhihu.com/?target=https%3A//whitfin.io/building-simple-apis-with-hyper-and-usher/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></p><h3>「系列文章：WebAssembly」Part II： 开始Rust</h3><p>该系列文章旨在使用Rust和WASM构建一个生产级的Web应用。</p><p><a href="https://link.zhihu.com/?target=https%3A//medium.com/tech-lah/webassembly-part-ii-a-wasm-with-rust-2356dbc6526e" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></p><h3>使用自定义工具链解决Rust和Glibc的问题</h3><p>Rust和Glibc在动态链接的时候可能会失效，该文作者建议使用自定义工具链来解决此问题。</p><p><a href="https://link.zhihu.com/?target=http%3A//redbeardlab.com/2019/05/07/rust-and-glibc-version/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></p><h3>「视频」用Rust实现TCP Part3</h3><p>我们的老朋友Jon Gjengset，他的视频通常都是5小时左右。</p><p><a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3D8GE6ltLRJA4" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></p><h3>「系列」使用Rust创建静态HTTP服务 Part I</h3><p>该教程没有使用http等基础crate，而是从零开始构建http 1.0服务，可供学习使用。</p><p><a href="https://link.zhihu.com/?target=http%3A//concisecoder.io/2019/05/11/creating-a-static-http-server-with-rust-part-1/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></p><hr/><h2>项目、工具与库</h2><h3>swirlr-wasm：Swirlr的wasm版本</h3><h2>wasm</h2><p>日报Chaos君向你问好：</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-880d0af74be099813075df60c752150c_b.jpg" data-caption="" data-size="normal" data-rawwidth="996" data-rawheight="944" class="origin_image zh-lightbox-thumb" width="996" data-original="https://pic1.zhimg.com/v2-880d0af74be099813075df60c752150c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-880d0af74be099813075df60c752150c_b.jpg" data-caption="" data-size="normal" data-rawwidth="996" data-rawheight="944" class="origin_image zh-lightbox-thumb lazy" width="996" data-original="https://pic1.zhimg.com/v2-880d0af74be099813075df60c752150c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-880d0af74be099813075df60c752150c_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>(很有意思，小图可以展示的比较清晰，但是放大以后就模糊了，感觉可以用来保护头像隐私)</p><p>swirlr可以将采集的图像沿阿基米德螺线路径的采样点渲染SVG。</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//willdady.github.io/swirlr-wasm/" class=" wrap external" target="_blank" rel="nofollow noreferrer">demo</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/willdady/swirlr-wasm" class=" wrap external" target="_blank" rel="nofollow noreferrer">swirlr-wasm</a></li></ul><h3>muscli ： 基于Pandora和音乐播放器实现的Tui</h3><p>音乐数据来自于Pandora流媒体平台</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/CMatri/muscli" class=" wrap external" target="_blank" rel="nofollow noreferrer">muscli</a></p><h3>stevenarella: 用Rust编写的多协议兼容Minecraft客户端</h3><p>作者声明：just doing this for fun。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/iceiix/stevenarella" class=" wrap external" target="_blank" rel="nofollow noreferrer">stevenarella</a></p><h3>ifmt - 插值式格式化宏库</h3><p>其实其它语言很多都有了。Rust一直显得比较生硬，格式化一个带变量值的字符串，要这样写：</p><div class="highlight"><pre><code class="language-text">println!(&#34;x: {x}, y: {y}, x + y: {sum}&#34;, x=x, y=y, sum=x+y);</code></pre></div><p>使用这个库，可以这么写了。</p><div class="highlight"><pre><code class="language-text">let four = 4;
iprintln!(&#34;four plus four is: {four + 4}&#34;);
// four plus four is: 8
iprintln!(&#34;here&#39;s a hex number: 0x{0xb0bi64 * 1321517i64 :x}&#34;);
// here&#39;s a hex number: 0xdeadbeef
iprintln!(&#34;here&#39;s a debugging value: {Some(four):?}&#34;);
// here&#39;s a debugging value: Some(4)</code></pre></div><p>作者把一套宏全部“升级”了。</p><div class="highlight"><pre><code class="language-text">format!      -&gt; iformat!
print!       -&gt; iprint!
println!     -&gt; iprintln!
eprint!      -&gt; ieprint!
eprintln!    -&gt; ieprintln!
write!       -&gt; iwrite!
writeln!     -&gt; iwriteln!
format_args! -&gt; iformat_args!</code></pre></div><p><a href="https://link.zhihu.com/?target=https%3A//github.com/ct-austin/ifmt" class=" wrap external" target="_blank" rel="nofollow noreferrer">ifmt</a></p><h3>ansi-parser - ANSI转义序列解析库</h3><p><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/ANSI%25E8%25BD%25AC%25E4%25B9%2589%25E5%25BA%258F%25E5%2588%2597" class=" wrap external" target="_blank" rel="nofollow noreferrer">ANSI转义序列</a> 就是这种 &#34;This is \u{1b}[3Asome text!&#34;，我们平时在终端下看到的文字的色彩啊，一些特效格式啊什么的，都是按这个标准来做的。</p><p>相似的库还有 <a href="https://link.zhihu.com/?target=https%3A//github.com/jwilm/vte" class=" wrap external" target="_blank" rel="nofollow noreferrer">vte</a></p><p><a href="https://link.zhihu.com/?target=https%3A//gitlab.com/davidbittner/ansi-parser" class=" wrap external" target="_blank" rel="nofollow noreferrer">Repo</a></p><h3>test-exec - 用于测试命令行工具的库</h3><p>作者也是写命令行工具的时候，觉得测试很不舒服，于是写了这个方便测试的工具。很不错。</p><p>比如：</p><div class="highlight"><pre><code class="language-text">let output = exec!{
    &#34;my_bin&#34;,
    args: [&#34;-p&#34;, &#34;/&#34;],
    cwd: &#34;/tmp&#34;,
    env: {
        THREADS: &#34;4&#34;
    },
    stdin: b&#34;show-hidden&#34;,
    timeout: 60000,
    log: true,

    code: 0,
    stdout: b&#34;Started program... Done.&#34;,
    stderr: []
};

// output can be used here like a normal process::Output</code></pre></div><p><a href="https://link.zhihu.com/?target=https%3A//github.com/Draphar/test-exec" class=" wrap external" target="_blank" rel="nofollow noreferrer">Repo</a></p><h3>dystopia - 匿名防追踪的网络代理</h3><p>用了Tor技术，其貌似是要提供一种匿名服务。比如要访问<a href="https://link.zhihu.com/?target=http%3A//google.com" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">google.com</span><span class="invisible"></span></a></p><div class="highlight"><pre><code class="language-text">curl https://google.com -x 54.95.171.65:2888 -L</code></pre></div><p>项目还在早期阶段，值得关注。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/tbrand/dystopia" class=" wrap external" target="_blank" rel="nofollow noreferrer">Repo</a></p><h3>Rust与sed命令不得不说的故事</h3><p>x12pp是用Rust实现的可以漂亮地打印X12 EDI格式的Cli工具。作者写了一篇博文，阐述了他使用sed命令处理X12的问题，这些问题促使他使用Rust来写x12pp。并且写出来的工具性能上可以轻松击败sed这样的通用工具。</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//github.com/clarkema/x12pp" class=" wrap external" target="_blank" rel="nofollow noreferrer">x12pp</a></li><li><a href="https://link.zhihu.com/?target=https%3A//www.lambdafunctions.com/articles/racing-sed-with-rust" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></li></ul><h3>finshir - 一种 Low&amp;Slow 流量产生器</h3><p><a href="https://link.zhihu.com/?target=https%3A//www.cloudflare.com/learning/ddos/ddos-low-and-slow-attack/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Low&amp;Slow</a> 是一种DDos攻击方法，利用产生大量的慢请求来保持住对服务器资源的消耗，从而影响正常请求的访问。finshir 就是这样一种用Rust写的工具。有两点高光：</p><ol><li>使用了 <a href="https://link.zhihu.com/?target=https%3A//github.com/Xudong-Huang/may" class=" wrap external" target="_blank" rel="nofollow noreferrer">may</a>，对，就是黄旭东大佬的May协程库</li><li>可以配合 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Tor_%2528anonymity_network%2529" class=" wrap external" target="_blank" rel="nofollow noreferrer">Tor</a> 使用，实现匿名性</li></ol><p><a href="https://link.zhihu.com/?target=https%3A//github.com/Gymmasssorla/finshir" class=" wrap external" target="_blank" rel="nofollow noreferrer">Repo</a></p><h3>riv - 图片查看工具</h3><p>这是一个命令行工具。其使用 SDL2 来渲染图片显示。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/davejkane/riv" class=" wrap external" target="_blank" rel="nofollow noreferrer">Repo</a></p><h3>「系列」使用 Rust 实现一种新语言 Part I</h3><p>作者正在练习实现一种语言 <a href="https://link.zhihu.com/?target=https%3A//github.com/epellis/esta" class=" wrap external" target="_blank" rel="nofollow noreferrer">esta</a>。第一步就是生成 AST（Abstract Syntax Tree 抽象语法树）。作者详尽地记录了怎样从头开始撸一门语言，这个文章是一个系列文章，想要自己设计语言和学习编译原理的同学强烈推荐阅读。</p><p><a href="https://link.zhihu.com/?target=http%3A//nedellis.com/2019/05/08/esta_1/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read More</a></p><h3>rust-hypervisor-firmware: 一個簡單的 kvm firmware</h3><p>intel出品，代码不多，看上去确实简单，可以学习如何用rust实现一个kvm。</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bn1b47/simple_kvm_firmware_written_in_rust_from_intel/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Read more</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/intel/rust-hypervisor-firmware" class=" wrap external" target="_blank" rel="nofollow noreferrer">intel/rust-hypervisor-firmware</a></li></ul><h3>wasm-flate: 使用WASM对客户端文件进行超快压缩的工具</h3><p>支持GZIP，ZLIB和DEFLATE压缩和解压缩</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/drbh/wasm-flate" class=" wrap external" target="_blank" rel="nofollow noreferrer">wasm-flate</a></p><h3>hors: howdoi的Rust实现</h3><p>Howdoi是Go实现的通过命令行获取即时的编程问题解答的工具，hors是它的Rust实现版本。</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-22373089579b211685fc3a38517d289e_b.jpg" data-caption="" data-size="normal" data-rawwidth="680" data-rawheight="426" class="origin_image zh-lightbox-thumb" width="680" data-original="https://pic3.zhimg.com/v2-22373089579b211685fc3a38517d289e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-22373089579b211685fc3a38517d289e_b.jpg" data-caption="" data-size="normal" data-rawwidth="680" data-rawheight="426" class="origin_image zh-lightbox-thumb lazy" width="680" data-original="https://pic3.zhimg.com/v2-22373089579b211685fc3a38517d289e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-22373089579b211685fc3a38517d289e_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/WindSoilder/hors" class=" wrap external" target="_blank" rel="nofollow noreferrer">hors</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
