<div class="title-image"><img src="https://pic2.zhimg.com/v2-b03b0a83307d67f9378e3d60f6d3a59d_b.jpg" alt=""></div><p>作者：lan</p><p>本文为 DM 源码阅读系列文章的第三篇，<a href="https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/dm-source-code-reading-2/" class=" wrap external" target="_blank" rel="nofollow noreferrer">上篇文章</a> 介绍了 DM 的整体架构，DM 组件 DM-master 和 DM-worker 的入口代码，以及两者之间的数据交互模型。本篇文章详细地介绍 DM 数据同步处理单元（DM-worker 内部用来同步数据的逻辑单元），包括数据同步处理单元实现了什么功能，数据同步流程、运行逻辑，以及数据同步处理单元的 interface 设计。</p><h2>数据同步处理单元</h2><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-e41c0a9e9850e25c12a8c26a72030b39_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="499" class="origin_image zh-lightbox-thumb" width="939" data-original="https://pic2.zhimg.com/v2-e41c0a9e9850e25c12a8c26a72030b39_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-e41c0a9e9850e25c12a8c26a72030b39_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="499" class="origin_image zh-lightbox-thumb lazy" width="939" data-original="https://pic2.zhimg.com/v2-e41c0a9e9850e25c12a8c26a72030b39_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-e41c0a9e9850e25c12a8c26a72030b39_b.jpg"/></figure><p>从上图可以了解到目前 DM 包含 relay log、dump、load、binlog replication（sync） 4 个数据同步处理单元，涵盖了以下数据同步处理的功能：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-efb00a7e9cb3445a8eeaf272c7fd4788_b.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="506" class="origin_image zh-lightbox-thumb" width="1240" data-original="https://pic1.zhimg.com/v2-efb00a7e9cb3445a8eeaf272c7fd4788_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-efb00a7e9cb3445a8eeaf272c7fd4788_b.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="506" class="origin_image zh-lightbox-thumb lazy" width="1240" data-original="https://pic1.zhimg.com/v2-efb00a7e9cb3445a8eeaf272c7fd4788_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-efb00a7e9cb3445a8eeaf272c7fd4788_b.jpg"/></figure><h2>数据同步流程</h2><p>Task 数据同步流程初始化操作步骤：</p><ol><li>DM-master 接收到 task，<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/master/server.go%23L190" class=" wrap external" target="_blank" rel="nofollow noreferrer">将 task 拆分成 subtask</a> 后 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/master/server.go%23L248" class=" wrap external" target="_blank" rel="nofollow noreferrer">分发给对应的各个 DM-worker</a>；</li><li>DM-worker 接收到 subtask 后 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/server.go%23L160" class=" wrap external" target="_blank" rel="nofollow noreferrer">创建一个 subtask 对象</a>，然后 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/subtask.go%23L84" class=" wrap external" target="_blank" rel="nofollow noreferrer">初始化数据同步流程</a>。</li></ol><p>从 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/subtask.go%23L84" class=" wrap external" target="_blank" rel="nofollow noreferrer">初始化数据同步流程</a> 的代码中我们可以看到，根据 task 配置项 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/config/task.go%23L220" class=" wrap external" target="_blank" rel="nofollow noreferrer">task-mode</a> 的不同，DM-worker 会初始化不同的数据同步流程：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-aae56ec5e24de4ca6d048a5c19c1b5b1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1232" data-rawheight="468" class="origin_image zh-lightbox-thumb" width="1232" data-original="https://pic2.zhimg.com/v2-aae56ec5e24de4ca6d048a5c19c1b5b1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-aae56ec5e24de4ca6d048a5c19c1b5b1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1232" data-rawheight="468" class="origin_image zh-lightbox-thumb lazy" width="1232" data-original="https://pic2.zhimg.com/v2-aae56ec5e24de4ca6d048a5c19c1b5b1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-aae56ec5e24de4ca6d048a5c19c1b5b1_b.jpg"/></figure><h2>运行逻辑</h2><p>DM 数据同步处理单元 interface 定义在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/unit/unit.go" class=" wrap external" target="_blank" rel="nofollow noreferrer">dm/unit</a></code>，relay log、dump、load、binlog replication（sync）都实现了该 interface（<a href="https://link.zhihu.com/?target=https%3A//golang.org/doc/effective_go.html%23interfaces" class=" wrap external" target="_blank" rel="nofollow noreferrer">golang interface 介绍</a>）。</p><p>实际上 DM-worker 中的数据同步处理单元分为两类：</p><ul><li>全局共享单例。dm-worker 启动的时候只初始化一次这类数据同步处理单元，所有的 subtask 都可以使用这类数据同步处理单元的服务；relay log 属于这种类型。</li><li>subtask 独享。dm-worker 会为每个 subtask 初始化一系列的数据同步处理单元；dump、load、binlog replication（sync）属于这种类型。</li></ul><p>两类数据同步处理单元的使用逻辑不同，这篇文档会着重讲一下 subtask 独享的数据同步处理单元的使用逻辑，不会囊括更多的 relay log 相关的内容，后面会有单独一篇文章详细介绍它。</p><p>relay log 相关使用代码在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/relay.go" class=" wrap external" target="_blank" rel="nofollow noreferrer">dm/worker/relay.go</a></code> 、具体功能实现代码在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/relay/relay.go" class=" wrap external" target="_blank" rel="nofollow noreferrer">relay/relay.go</a></code>，有兴趣的同学也可以先行阅读一下相关代码，relay log 的代码注释也是比较丰富，并且简单易懂。</p><p>subtask 独享数据同步处理单元使用逻辑相关代码在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/subtask.go" class=" wrap external" target="_blank" rel="nofollow noreferrer">dm/worker/subtask.go</a></code>。subtask 对象包含的主要属性有：</p><ul><li>units：初始化后要运行的数据同步处理单元。</li><li>currUnit：当前正在运行的数据同步处理单元。</li><li>prevUnit：上一个运行的数据同步处理单元。</li><li>stage：subtask 的运行阶段状态， 包含 <code>New</code>、<code>Running</code>、<code>Paused</code>，<code>Stopped</code>，<code>Finished</code>，具体定义的代码在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/proto/dmworker.proto%23L129" class=" wrap external" target="_blank" rel="nofollow noreferrer">dm/proto/dmworker.proto</a></code>。</li><li>result：subtask 当前数据同步处理单元的运行结果，对应着 stage = <code>Paused/Stopped/Finished</code> 的详细信息。</li></ul><p>主要的逻辑有：</p><ul><li>初始化 subtask 对象实例的时候会 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/subtask.go%23L39" class=" wrap external" target="_blank" rel="nofollow noreferrer">编排数据同步处理单元的运行先后顺序</a>。所有的数据同步处理单元都实现了 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/unit/unit.go" class=" wrap external" target="_blank" rel="nofollow noreferrer">dm/unit</a></code> interface，所以接下来的运行中就不需要关心具体的数据同步处理单元的类型，可以按照统一的 interface 方法来运行数据同步处理单元，以及对其进行状态监控。</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/subtask.go%23L93" class=" wrap external" target="_blank" rel="nofollow noreferrer">初始化各个数据同步处理单元</a>。subtask 在运行前集中地初始化所有的数据同步处理单元，我们计划之后优化成在各个数据同步处理单元运行前再进行初始化，这样子减少资源的提前或者无效的占用。</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/subtask.go%23L167" class=" wrap external" target="_blank" rel="nofollow noreferrer">数据同步处理单元运行状态监控</a>。通过监控当前运行的数据同步处理单元的结果，将 subtask 的 stage 设置为 <code>Paused/Stopped/Finished</code>。</li><ul><li>如果 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/subtask.go%23L190" class=" wrap external" target="_blank" rel="nofollow noreferrer">当前的数据同步处理单元工作已经完成</a>，则会根据 units 来 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/subtask.go%23L216" class=" wrap external" target="_blank" rel="nofollow noreferrer">选取下一个需要运行的数据同步处理单元</a>，如果没有需要的数据同步处理单元，那么会将 subtask 的 stage 设置为 <code>Finished</code>。这里有个注意点，因为 binlog replication 单元永远不会结束，所以不会进入 <code>Finished</code> 的状态。</li><li>如果 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/subtask.go%23L192" class=" wrap external" target="_blank" rel="nofollow noreferrer">返回的 result 里面包含有错误信息</a>，则会将 subtask 的 stage 设置为 <code>Paused</code>，并且打印具体的错误信息。</li><li>如果是用户手动暂停或者停止，则会将 subtask 的 stage 设置为 <code>Paused/Stopped</code>。这里有个注意点，这个时候 stage=<code>Paused</code> 是没有错误信息的。</li></ul><li><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/6855ea4e40bb5e3775709054a59a55c628a0922f/dm/worker/subtask.go%23L606" class=" wrap external" target="_blank" rel="nofollow noreferrer">数据同步处理单元之间的运行交接处理逻辑</a>。部分数据同步处理单元在开始工作的时候需要满足一些前置条件，例如 binlog replication（sync）的运行需要等待 relay log 处理单元已经储存下来其开始同步需要的 binlog 文件，否则 subtask 将处于 stage=<code>Paused</code> 的暂停等待状态。</li></ul><h2>小结</h2><p>本篇文章主要介绍了数据同步处理单元实现了什么功能，数据同步流程、运行逻辑，以及数据同步处理单元的 interface 设计。后续会分三篇文章详细地介绍数据同步处理单元的实现，包括：</p><ul><li>dump/load 全量同步实现</li><li>binlog replication 增量同步实现</li><li>relay log 实现</li></ul><p><b>更多阅读：</b></p><a href="https://link.zhihu.com/?target=https%3A//www.pingcap.com/blog-cn/%23DM-%25E6%25BA%2590%25E7%25A0%2581%25E9%2598%2585%25E8%25AF%25BB" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg" data-image-width="1200" data-image-height="1200" class=" wrap external" target="_blank" rel="nofollow noreferrer">博客</a><p></p>