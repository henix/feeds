<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>创业及管理：构建利于探索的工作环境</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20400750">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/04412b43f79d5847777c9c7683a12e0a_r.jpg" alt=""></div><p><strong>本文为InfoQ中文站特供稿件，首发地址 <a href="http://www.infoq.com/cn/articles/experimental-friendly" data-editable="true" data-title="戳这里" class="">戳这里</a>。</strong></p><br><p>敏捷（Agile），如今是个让每个科技公司恨不得天天挂在嘴边的词语。在这个 CMM (Capability Maturity Model) 已褪去光环，敏捷大行其道的时代，如果一家科技公司不搞些敏捷的实践，仿佛就成了旧时代的破落户一般。然而，很多公司搞敏捷，只不过是在流程上引入了一些敏捷的实践，却未曾从工作环境和文化上注入敏捷的原力。我见过有公司从 waterfall 转向 scrum，培养了 scrum master，培训了员工，投资了各种新生工具，daily standup 做得有声有色，甚至真的通过 planning poker 的方式过家家般来做软件工程里面最难搞定的决策：estimation。</p><img src="https://pic3.zhimg.com/17b607f23b522f95af7bcf500f5833b6_r.jpg" data-rawwidth="506" data-rawheight="333"><br><p>可是，工程文化层面上的反敏捷，导致这一切徒劳无功，敏捷的实施往往就这样虎头蛇尾、无疾而终了。</p><p><b>公司文化的反敏捷</b></p><p>那么，究竟什么是公司文化层面的敏捷呢？我认为是以一个对团队而言最合适的迭代速度持续地探索、学习和改进。其实很多敏捷的实践都是围绕着这个目标而努力的，只是使用者在使用的过程中迷失了方向，比如说每日例（晨）会。本文从探索这个主题讲起，讨论我们该如何构建一个友好的工作环境，让工程师能够最大可能地不断摸索，解决各种各样的工程问题。</p><p>有人看到这里会不禁莞尔：作为工程师，我们工作的目的就是不断摸索出解决各种问题的方案，难道真会有公司愚蠢到压制工程师的探索欲望么？</p><p>我们先看一些反例：</p><ol><li><p>改两行代码，却要花费几十分钟编译链接。</p></li><li><p>测试一个新想法（新功能），没有 sandbox 或模拟器，只能在实体硬件上完成（想象一下 iPhone 开发没有模拟器，每次都要将编译好的 ipa 安装到手机上）。</p></li><li><p>修复了一个 bug，只有几十行代码，code review 却要花上数周和无尽的催促才能被 approve。</p></li><li><p>做好了一个 feature，半年后甚至更久才能跟客户（用户）见面。</p></li><li><p>使用了某开源 MIT 协议的第三方库或者某个新的技术（如 AWS lambda）做了个 feature，虽然解决方案大大简化，却被告知我们不希望引入更多的依赖，徒增加团队学习的负担。</p></li><li><p>辛辛苦苦做出来的成果，demo 时得到的都是负面的评价（而非建设性的意见，更别说赞许）。</p></li><li><p>想尝试 AWS 上的某个新的功能，却因为权限不足被阻挡在门外（申请权限又需要一个极其漫长的审批流程）。</p></li><li><p>手工部署上线一份新的代码，出了纰漏，造成了无法挽回的损失和影响，于是，当事的「实习生」被裁。</p></li><li><p>公司把你禁锢在某个工作岗位上，于此不相关的非机密项目的技术讨论不希望你参加（美其名曰不浪费你的时间），甚至，文档代码连读都读不到。</p></li></ol><p>这些例子都是真实的例子，想必很多读者，尤其在各种大公司打工的读者，也都会遭遇到类似的场景。它们就像某种慢性的毒药，一点点把员工的激情和探索欲望消磨殆尽，而这些消逝的激情和欲望，纵使用豪华的办公环境、米其林大厨精心烹饪的午餐，也很难挽回。</p><p>我们看上述例子，有些是在工程上有解的问题，比如 1，2，8；有些是流程上有解的问题，比如 3，4，7；还有一些是文化上需要改变才能得到改观的问题，比如 5，6，9。然而，工程上有解而不去解决，流程上有解却没能解决，归根结底还是公司文化层面的问题。公司在文化上不重视打造利于探索的工作环境（experiment-friendly environment），反映在日常的工作中，便是掣肘丛生，前进三步却要付出倒退两步的代价。就好比在玩三国杀，满腔热血的忠臣，拿着一副好手牌，意图大展拳脚，忠君报国，绞杀反贼，却不料前有主公冷嘲热讽，后有小内暗箭伤人，只能堪堪自保。</p><p>讲了这么些反例，想必大家对 experiment-friendly 有一个更好的理解了。公司需要为员工的高效产出扫清组织上，流程上，沟通上和工具上的障碍，让工作变得更有成就感，让探索和创新随时随处可达。</p><p>这事说起来容易做起来难，每个公司都有各自不同的「国情」，很难找到一种“放之四海而皆准”的文化。我们可以学习一些公认的敏捷的公司，如 Facebook，但很难将其文化直接照搬。依我看，如果做好下面的一些事情，那么，公司文化会离 experiment-friendly 更近一步。</p><p><b>敏捷文化之工具流</b></p><p>我们先说工具。工具上的问题是最容易看到收获的，效果也比较好量化。比如说引入各种自动化工具。凡是有过软件项目经历的人都知道 —— 任何严丝合缝的流程，其中最薄弱的一环肯定是人。对于重复性的机械劳动，人是最容易犯错的。这时候要尽可能地把流程工具化。比如说：</p><ul><li><p>git commit 时设置 commit hook 对代码做 lint 和 static analysis。有多少公司的 codereview 把时间和精力浪费在了 code style 这样本可以用工具来完成的事情之上？</p></li><li><p>使用 CI 工具自动化构建。有多少团队在产出 iOS / Android 的版本时还在本地构建？</p></li><li><p>使用更合适的测试工具来测试你的系统。有多少 android app 的开发者还在吭哧吭哧完全依赖手工对各个机型进行 acceptance test，而非借助 AWS device farm，以及 calabash 等测试工具的力量？</p></li><li><p>使用可反复执行的脚本来部署一个软件系统（如 ansible，cloudformation）。有多少 ops 还在纯手工地上线系统，然后惴惴不安地期待没有问题？</p></li></ul><p>当然，并非所有的工具都能取代人工处理，但我们需要尽可能地借助工具的力量，减少重复性地手工劳动。只有如此，才能节省出更多的时间和减少各种愚蠢的问题，从疲于奔命到处救火中解脱出来，把精力集中到其他更值得解决的问题上。</p><p>工具的完善不是一蹴而就的，而是在每个研发周期里不断改进的。一开始，很多事情不得不靠手工完成，可同样重复的事情做了几次之后，就该考虑将其工具化。</p><p><b>流程的敏捷之道</b></p><p>前面提到的 codereview 反馈周期长的问题，就是一个典型的流程问题。当团队或者个人处在自顾不暇的地步，哪有功夫去读别人的 diff？于是就放在一边，能拖多久就拖多久。</p><p>这样还会形成一个恶性循环：code review 的作者（reviewee）得不到 reviewer 的快速响应，只好减少发送 review 的频次，导致 code review 的代码量变大，进而导致 reviewer 更不愿意在短时间内做出决策。就这样，本来一个个小的 pull request、代码量控制在三五个文件、几十或者顶多几百行代码内、一到几个 reviewers 应该每日完成的 review 工作，最后变成了跨越若干个模块、几十个文件、成千上万行代码、需要几个 team 联合 review 才能完成的工作，这样不拖到好几周才怪！</p><p>所以第一步是稍稍减轻每个人的负担，使其每周有 4～5 个小时时间（可根据情况增减）用于 code review。code review 可以分成两个部分：pre-review 和 post-review。对于一个 pull request，在 pass CI 之后（CI 应该做了 lint，static analysis 和 test），reviewee 要求和 reviewer 坐在一起花个 10～30 分钟走读代码，然后当场决定是否允许 merge，这就是 pre-review。pre-review 不花费 reviewer 过多时间，也不过多阻碍 reviewee 后续的工作，还可以能够扫除大部分潜在的问题。</p><p>在 pre-review 中，坐在一起（或者通过 google hangout 等视频方式）共同走读代码很重要。很大一部分 code review 的时间花费在 reviewer 领会理解 reviewee 的代码的意图上面，一起走读对双方而言是时间最优的方式。走读还有一个好处是：reviewee 在讲解的过程中自己就能意识到一些错误。不知道大家是否有这样的经历：自己写的代码，自己反复 review 的时候都没有感到有任何问题，但当把这个代码讲给别人听时，即便别人还将懂未懂，尚在斟酌思度，你自己已经发现了各种问题。这是因为自己读时，思维还是撰写时候的思维，而读给别人时，切换到了想方设法让对方理解的思维上，换了个角度，也就更容易发现问题。</p><p>post-review 更多地用于从宏观上发现隐患。一周下来，或者一个 sprint 下来，代码积攒了不少，feature 虽说可以正常工作，但难保没有全局的问题。这时候，多个工程师坐在起，花 1～3 小时（可根据情况增减）把这段时间里团队的所有 diff 过一下，查漏补缺既是一种好的事后补救也是一个相互学习的过程。</p><p>简言之，pre-review 工作量小，易于快速完成，为后续工作扫清障碍；post-review 虽然工作量很大，但能够查漏补缺，弥补 pre-review 的缺陷，同时还能促进团队内的相互学习。</p><p>一个公司没有合适的流程注定只能小打小闹，上不得台面；但如果把流程抠得太死，明明已经不适应工作的需要，还强行使用，只会降低公司的效率。我们知道，流程其实是在不断解决问题的过程中发现的模式（pattern）。当这些模式固化成流程后，下次遇到类似的问题便可以快速处理。这就好比软件中的 fast path 和 slow path 一样。然而，流程不能一成不变，必须随着公司/文化/人员的变化而变化。上述的 code review 的流程，如果放在一个跨时区的 distributed team 中，就会遇到很多问题。所以，流程一定要随需而变、不断调整，找到对团队而言最合适的点。</p><p>同时，我们还需要很聪明地设置流程。比如上述的问题 7（想尝试 AWS 的新功能却权限不足），流程制定者的目的是为了安全性而牺牲了易用性。那么，有什么方式能够兼顾安全性和易用性呢？我们可以使用沙箱（sandbox），把安全等级高的行为和安全等级低的行为区别开来。对于 AWS 而言，multiple accounts + consilidation billing 就是对此最佳的解决之道，公司可以开设不同的 account 对应不同的使用场景，比如说：production, development &amp; backoffice。production 和 backoffice 只授予 devops / IT 高级权限，而 development 可以授予任何工程师高级权限。这样，即兼顾了流程对于安全性的需要，又使得工程师可以在一个安全的沙箱内随意尝试，一石二鸟。</p><p>在构建 experiment-friendly 的工作环境的过程中，只要肯扩大眼界，用心思考，工具和流程会是比较容易实施且很好看到效果的方法。</p><p><b>一些思考</b></p><p>最后是文化层面的考虑。也就是对于人的管理，授权和培养。对于本文而言，我觉得三点很重要：</p><ul><li><p>信任优于控制（Trust over control）</p></li><li><p>承诺优于服从（Commitment over Compliance）</p></li><li><p>数据优于权威（Data over authority）</p></li></ul><p>拿「数据优于权威」来说，它其实解决这样一个问题：究竟是上级（权威）的个人品味重要，还是真实的、有说服力的数据重要？相信没有人会认为权威比数据重要，然后在实际工作中，往往是「官大一级压死人」，领导的喜恶常常决定了产品的方向，很多产品是大佬一抓就死其实就是「数据优于权威」的反例。这个只能靠自上而下推行的文化层面的努力来消弭了。</p><p>文化是一个很大的主题，且很难找到又具体又放之四海而皆准的经验。在这里就不展开讲了。</p><p>如果您觉得这篇文章不错，请点赞。多谢！</p><p>欢迎订阅公众号『程序人生』（搜索微信号 <strong>programmer_life</strong>）。每篇文章都力求原汁原味，北京时间中午12点左右，美西时间下午8点左右与您相会。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
