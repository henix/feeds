<div class="title-image"><img src="https://pic4.zhimg.com/v2-afdf2f96257fd7725ea091c786d4dcbb_b.jpg" alt=""></div><p>本人有个小小的习惯，就是在学习一门语言的开始，为了熟悉这门语言的基础设施，我都会写一个最最简单的parserc（当然那些9012年都没有支持泛型的语言，就不写了）。</p><p>这次就试着用Rust来写一个。</p><h2>从Iterator中来</h2><p>用过Rust的Iterator的人，一定会觉得这用起来十分的愉悦，这说明Iterator设计得很不错。而parserc的使用方式其实和使用Rust的Iterator的方式十分相似的——先将小的组合子构造成大的组合子，然后再使用，parserc是<code>.parse()</code>，Iterator是<code>.next()</code>。</p><p>所以借鉴一下Iterator的思路，Rust版parserc也试着由这几部分构成：</p><ol><li>parser的trait</li><li>一些adapter</li><li>自定义一些combinator</li><li>组合出来的一些combinator</li></ol><p>用起来大概是这样：</p><div class="highlight"><pre><code class="language-rust"><span class="c1">// a+(b|c)
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">aaab_c</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Target</span><span class="o">=</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">char</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">).</span><span class="n">some</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">and</span><span class="p">(</span><span class="n">char</span><span class="p">(</span><span class="sc">&#39;b&#39;</span><span class="p">).</span><span class="n">or</span><span class="p">(</span><span class="n">char</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)))</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseState</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;aaab&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aaab_c</span><span class="p">().</span><span class="n">parse</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">src</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(()));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2>Parser trait</h2><p>先定义parser的一般行为<code>parse</code>，“照搬”Iterator的结构。</p><div class="highlight"><pre><code class="language-rust"><span class="cp">#[derive(Clone, Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">ParseState</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">src</span>: <span class="nc">Chars</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">col</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">row</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Parser</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ParseState</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在Haskell中，最简单的parse function的类型是<code>String -&gt; Maybe (a, String)</code>：吞进去一个String，得到解析结果a，还有未匹配的字符串，或者没有结果，也就是匹配失败。这里也采用了类似的结构，有所不同的是，因为Rust是有mut的，可以直接改变状态，于是可以去掉用返回值表示的状态，改为可变引用；然后，parse的状态加上了行和列，为了方便，用字符迭代器表示要解析的字符串。</p><h2>从零开始的Parser</h2><p>有了parser trait，我们可以来定义一个简单的combinator：<code>char</code>用来匹配一个字符。</p><div class="highlight"><pre><code class="language-rust"><span class="sd">/// char
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Char</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ch</span>: <span class="nc">char</span><span class="p">,</span><span class="w"> </span><span class="c1">// 要判断的字符
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Parser</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Char</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">char</span><span class="p">;</span><span class="w"> </span><span class="c1">// 解析结果的类型是字符型
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ParseState</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">state</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">ch</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">ch</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ch</span><span class="p">)</span><span class="w"> </span><span class="c1">// 判断字符是否相等
</span><span class="c1"></span><span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">ch</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">state</span><span class="p">.</span><span class="n">update_pos</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span><span class="w"> </span><span class="c1">// 更新位置
</span><span class="c1"></span><span class="w">                </span><span class="n">ch</span><span class="w">
</span><span class="w">            </span><span class="p">}).</span><span class="n">or_else</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old</span><span class="p">;</span><span class="w"> </span><span class="c1">// 错误恢复
</span><span class="c1"></span><span class="w">                </span><span class="nb">None</span><span class="w">
</span><span class="w">            </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">char</span><span class="p">(</span><span class="n">ch</span>: <span class="nc">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Char</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Char</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>现在就可以使用char这个combinator了</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseState</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;aaab&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">char</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">).</span><span class="n">parse</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">src</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p class="ztext-empty-paragraph"><br/></p><p>复杂一点点：<code>satisfy</code>组合子，用来判断字符是否满足某个表达式：</p><div class="highlight"><pre><code class="language-rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Satisfy</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">satisfy</span>: <span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="c1">// 表达式
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parser</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Satisfy</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">char</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ParseState</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">state</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">satisfy</span><span class="p">)</span><span class="w"> </span><span class="c1">// 判断下个字符是否满足表达式
</span><span class="c1"></span><span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">ch</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">state</span><span class="p">.</span><span class="n">update_pos</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span><span class="w"> </span><span class="c1">// 更新位置
</span><span class="c1"></span><span class="w">                </span><span class="n">ch</span><span class="w">
</span><span class="w">            </span><span class="p">}).</span><span class="n">or_else</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old</span><span class="p">;</span><span class="w"> </span><span class="c1">// 错误恢复
</span><span class="c1"></span><span class="w">                </span><span class="nb">None</span><span class="w">
</span><span class="w">            </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">satisfy</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Satisfy</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Satisfy</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">satisfy</span>: <span class="nc">f</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>使用起来：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseState</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;aaab&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">satisfy</span><span class="p">(</span><span class="o">|</span><span class="n">ch</span><span class="o">|</span><span class="w"> </span><span class="n">ch</span><span class="p">.</span><span class="n">is_uppercase</span><span class="p">())</span><span class="w"> </span><span class="c1">// 匹配大写字符
</span><span class="c1"></span><span class="w">        </span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">src</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>接下来可以用类似的方法定义很多很多的combinator了，比如匹配一段字符的，匹配数字的，甚至匹配正则表达式的。（然而我没写）</p><p>还有，错误恢复的逻辑是需要的，这单独抽出来：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">recover</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">old</span>: <span class="nc">S</span><span class="p">,</span><span class="w"> </span><span class="n">opt</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">opt</span><span class="p">.</span><span class="n">or_else</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w">
</span><span class="w">    </span><span class="p">})</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2>一些adapter</h2><p>有了我们自己定义的一个个combinator之后，我们当然可以“裸着”调用，先parse a再parse b，但这样非常不composable。需要定义一些像Iterator中Map，Chain，Zip这些adapter，用来组合parser combinator。</p><p>那对于一个parser来说，顺序匹配<code>and</code>，和选择<code>or</code>是比较常用的combinator，我们先来看看怎么定义他们。</p><p><code>and</code>，顺序匹配两个combinator，取第二个combinator的结果：</p><div class="highlight"><pre><code class="language-rust"><span class="sd">/// and
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">And</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span>: <span class="nc">A</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">b</span>: <span class="nc">B</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">Parser</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="nc">Parser</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parser</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">And</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ParseState</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">state</span><span class="p">).</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">state</span><span class="p">));</span><span class="c1">// lazy
</span><span class="c1"></span><span class="w">        </span><span class="n">recover</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">old</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然后在Parser trait里加上：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">and</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">And</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Self</span>: <span class="nb">Sized</span>
<span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">And</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span>: <span class="nc">self</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">other</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>十分简单。</p><p class="ztext-empty-paragraph"><br/></p><p><code>or</code>，选择匹配两个组合子，若第一个失败则重新匹配第二个：</p><div class="highlight"><pre><code class="language-rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Or</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span>: <span class="nc">A</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">b</span>: <span class="nc">B</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parser</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Or</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">A</span>: <span class="nc">Parser</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">B</span>: <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">Target</span><span class="o">=</span><span class="n">A</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="c1">// 为了保证两个组合子得到的结果具有一样的类型
</span><span class="c1"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ParseState</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">state</span><span class="p">).</span><span class="n">or_else</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">state</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然后同时在Parser trait里加上：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">or</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Or</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">P</span>: <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">Target</span><span class="o">=</span><span class="n">Self</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Or</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span>: <span class="nc">self</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">other</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p class="ztext-empty-paragraph"><br/></p><p><code>map</code>组合子，不进行匹配，给里面的值做变换：</p><div class="highlight"><pre><code class="language-rust"><span class="sd">/// map
</span><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">parser</span>: <span class="nc">P</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f</span>: <span class="nc">F</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">P</span>: <span class="nc">Parser</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parser</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">   </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">Fn</span><span class="p">(</span><span class="n">P</span>::<span class="n">Target</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ParseState</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">parser</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">state</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">f</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p class="ztext-empty-paragraph"><br/></p><p><code>and_then</code>组合子（就是<code>&gt;&gt;=</code>，实现上下文相关的匹配）</p><div class="highlight"><pre><code class="language-rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">AndThen</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">parser</span>: <span class="nc">P</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f</span>: <span class="nc">F</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parser</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">AndThen</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">A</span>: <span class="nc">Parser</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">B</span>: <span class="nc">Parser</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">F</span>: <span class="nb">Fn</span><span class="p">(</span><span class="n">A</span>::<span class="n">Target</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">,</span><span class="w"> </span><span class="c1">// 注意：这里返回的类型只有一个
</span><span class="c1"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ParseState</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">parser</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">a</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">f</span><span class="p">)(</span><span class="n">a</span><span class="p">).</span><span class="n">parse</span><span class="p">(</span><span class="n">state</span><span class="p">));</span><span class="w"> </span><span class="c1">// 根据第一个匹配的结果选择parser继续匹配。
</span><span class="c1"></span><span class="w">        </span><span class="n">recover</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">old</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">)</span><span class="w">      
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p class="ztext-empty-paragraph"><br/></p><p>还可以实现<code>many</code>和<code>some</code>组合子（匹配多次）等。</p><p>其实，这都是将平时使用parser function的一些普遍的pattern抽象成出来作为一些adapter而已。值的注意的是，将他们组合起来的时候，其实并没有发生parse的计算，做的仅仅是将一个个结构体包在一起而已。</p><h2>堆起来</h2><p>总之，我们可以将parser组合起来了，名副其实的combinator：</p><div class="highlight"><pre><code class="language-rust"><span class="c1">// a+(b|c)
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">aaab_c</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Target</span><span class="o">=</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">char</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">).</span><span class="n">some</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">and</span><span class="p">(</span><span class="n">char</span><span class="p">(</span><span class="sc">&#39;b&#39;</span><span class="p">).</span><span class="n">or</span><span class="p">(</span><span class="n">char</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">)))</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不过其实到目前为止还是“暗含危机”的：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">demo</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Target</span><span class="o">=</span><span class="n">char</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">num</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 匹配数字
</span><span class="c1"></span><span class="w">        </span><span class="n">satisfy</span><span class="p">(</span><span class="o">|</span><span class="n">ch</span><span class="o">|</span><span class="w"> </span><span class="n">ch</span><span class="p">.</span><span class="n">is_uppercase</span><span class="p">())</span><span class="w"> </span><span class="c1">// 数字是偶数，则接下来匹配大写字母
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">satisfy</span><span class="p">(</span><span class="o">|</span><span class="n">ch</span><span class="o">|</span><span class="w"> </span><span class="n">ch</span><span class="p">.</span><span class="n">is_lowercase</span><span class="p">())</span><span class="w"> </span><span class="c1">// 数字是奇数，则接下来匹配小写字母
</span><span class="c1"></span><span class="w">    </span><span class="p">})</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这段代码逻辑是很简单，也是很常见的需求。但是这段代码是无法通过编译的。</p><p>为什么呢？给读者思考2秒钟……</p><p>1……</p><p>2……</p><p>ok！揭晓：<b>是因为两个satisfy返回的组合子类型不一样！</b>（别忘了在Rust里，每一个闭包的类型都是不一样的）</p><p>这的确是个棘手的问题呢！如果<code>and_then</code>里不能放不同的parserc，这个功能不就是残废的吗？</p><h2>静中生动</h2><p>到目前为止，咱们的parserc都是静态派分的，还并没有用到动态派分的功能。事实上上面遇到的问题，闭包就常常会有，这时候就要用到<b>trait object</b>了。</p><p>所谓trait object一般指的是一个指向类型为<code>dyn trait</code>的对象的胖指针。比如说实现了<code>Fn()</code>的闭包都可以被装到<code>Box&lt;dyn Fn()&gt;</code>的指针中。而因为<code>Box&lt;dyn Fn()&gt;</code>也实现了<code>Fn()</code>，所以也可以当做函数被调用。在这里trait object就做了「类型擦除」的工作。</p><p>同样的，我希望parserc也可以被包在Box或者其它指针中成为trait object，消除上面遇到的问题：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">demo</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Target</span><span class="o">=</span><span class="n">char</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">num</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">satisfy</span><span class="p">(</span><span class="o">|</span><span class="n">ch</span><span class="o">|</span><span class="w"> </span><span class="n">ch</span><span class="p">.</span><span class="n">is_uppercase</span><span class="p">()))</span><span class="w"> 
</span><span class="w">            </span><span class="k">as</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Target</span><span class="o">=</span><span class="n">char</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="c1">// 别忘了要型转
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">satisfy</span><span class="p">(</span><span class="o">|</span><span class="n">ch</span><span class="o">|</span><span class="w"> </span><span class="n">ch</span><span class="p">.</span><span class="n">is_lowercase</span><span class="p">()))</span><span class="w">
</span><span class="w">    </span><span class="p">})</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当然，现在是不行的，因为<code>Box&lt;dyn Parser&gt;</code>还没实现Parser，现在加上：</p><div class="highlight"><pre><code class="language-rust"><span class="c1">// 别忘了加?Sized，因为dyn trait是DST，是不确定大小的类型
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">Parser</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parser</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ParseState</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="p">).</span><span class="n">parse</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="c1">// deref一次&amp;，一次Box，不然就会递归调用
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>其它指针的也可以加上（</p><p class="ztext-empty-paragraph"><br/></p><p>2019/8/29更新：</p><h3>不动点</h3><p>之前一直没有发现的的一个大bug，就是这个parserc无法处理递归的文法。因为safe Rust无法手动（难）创建循环引用的结构，闭包也无法“自动”实现递归，于是现在的parserc是无法递归定义的。所以要为parserc加一个<i>不动点组合子</i>实现这个功能。</p><div class="highlight"><pre><code class="language-rust"><span class="c1">// (Fix f).parse() = (f (Fix f)).parse()
</span><span class="c1"></span><span class="cp">#[derive(Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Fix</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">fix</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="n">Fix</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Target</span><span class="o">=</span><span class="n">A</span><span class="o">&gt;&gt;&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Parser</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Fix</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">ParseState</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">fix</span><span class="p">)(</span><span class="n">Fix</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">fix</span>: <span class="nc">self</span><span class="p">.</span><span class="n">fix</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}).</span><span class="n">parse</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">fix</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fix</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="n">Fix</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Parser</span><span class="o">&lt;</span><span class="n">Target</span><span class="o">=</span><span class="n">A</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fix</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Fix</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fix</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>大概是这样用的：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseState</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;...^&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// example = &#39;.&#39; example | &#39;^&#39;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fix</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="o">|</span><span class="n">it</span><span class="o">|</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="n">char</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">).</span><span class="n">and</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">or</span><span class="p">(</span><span class="n">char</span><span class="p">(</span><span class="sc">&#39;^&#39;</span><span class="p">)))));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">src</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="sc">&#39;^&#39;</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这里还是用上了Rc了，被rustc吊打真是对不起了。。。我一直想不到更好的定义了，如果有什么想法一定要告诉我……</p><h2>总结</h2><p>到目前为止，就得到了一个很简单地Rust版parserc。写Rust，脑子里还是少带点monad，写起来还是十分愉悦的。想起知乎上也有篇文章是Rust版parsec，好像是很复杂很复杂的，各种Rc什么的，不知道这里要实现类似的功能要不要变得如此复杂呢……？</p><p>不过就算写了个parserc，我觉得我还是没有入门rust，毕竟前面还有啥Send/Sync，async/await，unsafe等着我。（诶，你说async/await还是没有稳定？）</p><h2>后记</h2><p>其实在我大半年前刚接触Rust的时候，我就干过这样的事。想0基础，硬撸parserc，结果被rustc打得鼻青脸肿，直接导致了我后来一直都没有再碰Rust，直至到上个学期末试着用Rust写操作系统的作业。。</p><p>为了再现当时的惨像，我又写了过去的代码：</p><p>当时的想法就是直接将Haskell的代码搬过去（java和scala的parserc我也是这样做的），直接包一个Parser的类型<code>String -&gt; Maybe (a, String)</code>：</p><div class="highlight"><pre><code class="language-rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">F</span>: <span class="nc">for</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">p</span>: <span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="c1">// 不过当时不是这样的，是用Box将里面的parse function包起来
</span><span class="c1"></span><span class="w">    </span><span class="n">_a</span>: <span class="nc">PhantomData</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>嗯，第一个组合子就碰壁了：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">pure</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="nc">A</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="k">for</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Parser</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">p</span>: <span class="nc">move</span><span class="w"> </span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">_a</span>: <span class="nc">PhantomData</span><span class="w"> </span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>报错是<code>cannot move out of captured outer variable in an  Fn closure</code>。嘛，现在明白原因了，因为Fn是“可以多次调用的闭包”，但是当调用parser的时候，x就被move出来了，就不能调用第二次了。为了方便就给A加上了Clone的约束。</p><p>接下来是<code>and_then</code> (<code>&gt;&gt;=</code>)，记得当时死活写不出来的：</p><div class="highlight"><pre><code class="language-rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">and_then</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Map</span><span class="p">,</span><span class="w"> </span><span class="n">G</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">Map</span><span class="p">)</span><span class="w">
</span><span class="w">                               </span>-&gt; <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="k">for</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Map</span>: <span class="nb">Fn</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">G</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">G</span>: <span class="nc">for</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Parser</span>::<span class="n">new</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">chs</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chs</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">chs</span><span class="p">)</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">a</span><span class="o">|</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">parse</span><span class="p">(</span><span class="n">chs</span><span class="p">));</span><span class="w">
</span><span class="w">            </span><span class="n">recover</span><span class="p">(</span><span class="n">chs</span><span class="p">,</span><span class="w"> </span><span class="n">old</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></div><p>……？写出来了？<code>or</code>(<code>&lt;|&gt;</code>)呢？</p><div class="highlight"><pre><code class="language-rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">or</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">G</span><span class="o">&gt;</span><span class="p">)</span><span class="w">
</span><span class="w">                 </span>-&gt; <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="k">for</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">G</span>: <span class="nc">for</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Parser</span>::<span class="n">new</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">chs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Chars</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chs</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">chs</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="n">recover</span><span class="p">(</span><span class="n">chs</span><span class="p">,</span><span class="w"> </span><span class="n">old</span><span class="p">,</span><span class="w"> </span><span class="n">first</span><span class="p">).</span><span class="n">or_else</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">chs</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>satisfy</code>组合子</p><div class="highlight"><pre><code class="language-rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">satisfy</span><span class="o">&lt;</span><span class="n">F</span>: <span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">char</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w">
</span><span class="w">    </span>-&gt; <span class="nc">Parser</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="k">for</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Parser</span>::<span class="n">new</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">chs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Chars</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chs</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chs</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">recover</span><span class="p">(</span><span class="n">chs</span><span class="p">,</span><span class="w"> </span><span class="n">old</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">})</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>……………………瞬间有一种之前的代码白给了的感觉。死活想不起来，为什么之前写不出来。不过，按照设计模式上说，还是前面的设计比较好一点，在usage也不需要写后面impl一串东西。</p><hr/><p>后后记：又尝试将parse function用Box包起来之后，生命期就变得复杂了，我当时没搞懂的估计也就是这个……现在折腾一下也ok：</p><div class="highlight"><pre><code class="language-rust"><span class="c1">// parse function生命期为&#39;f，A活的至少比parse function久
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="na">&#39;f</span><span class="p">,</span><span class="w"> </span><span class="n">A</span>: <span class="na">&#39;f</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">p</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="k">for</span><span class="o">&lt;</span><span class="na">&#39;str</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;str</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">&#39;f</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><hr/><p>后后后记：</p><p>写了个通用点的版本：<a href="https://link.zhihu.com/?target=https%3A//github.com/TOETOE55/psc" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/TOETOE55/psc</span><span class="invisible"></span></a></p>