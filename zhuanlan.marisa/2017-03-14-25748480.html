<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>愉悦的scheme之旅（1）--动态作用域</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/25748480">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-7d3c5ec23556d1f9edbf837ef9f5d303_r.jpg" alt=""></div><h2><b>前言</b></h2><p>这篇文章原来发布于简书，我（原作者）应<a href="http://www.zhihu.com/people/0251012c87c2d3f56ac34de7d71cdcbc" data-hash="0251012c87c2d3f56ac34de7d71cdcbc" class="member_mention" data-title="@雾雨魔理沙" data-hovercard="p$b$0251012c87c2d3f56ac34de7d71cdcbc">@雾雨魔理沙</a>的要求转载到知乎。</p><p>感谢魔理沙等人对本文的部分地方的修正。</p><p>本系列1,2是以前的内容，3以后是更新的内容。</p><br><h2><b>词法作用域 vs 动态作用域</b></h2><p>scheme是一门采用词法作用域（lexical scoping）的lisp方言，这个设计是从algol语言里借鉴过来的。现在，词法作用域已经被许多lisp方言所吸收，实践表明，这的确是一项正确的设计，避免了很多奇怪的错误，比较符合人类的思维习惯。</p><p>但是，在某些场合下，动态作用域又是很有用的特性，比如emacs lisp里面就默认采用动态作用域。</p><p>下面的程序演示了词法作用域与动态作用域的不同</p><p>(define x 1)<br>(define y (lambda () x))<br>(let ([x 2]) (y))</p><p>如果是词法作用域，返回1，如果是动态作用域，返回2。</p><h2><b>在scheme中模拟动态作用域</b></h2><p>从一个简单的例子出发，演示如何在scheme里面实现动态作用域，我们想要写一个try catch宏来处理程序中的异常。其中一个函数叫做current-exception-handler，我们希望它是动态的，随代码运行位置而变化，永远指向当前的异常处理器，下面是我们写的第一个版本<br></p><blockquote><p>(define current-exception-handler<br>  (lambda (msg) (error "No Top Level Try")))<br>(define-syntax try<br>  (syntax-rules (catch)<br>    [(_ expr ... (catch msg expr* ...))<br>        (call/cc (lambda (k)<br>                (let ([msg (call/cc (lambda (k1)<br>                                      (set! current-exception-handler k1)<br>                                      (let ([result (begin expr ...)])<br>                                      (k result)<br>                                      )))])<br>                  expr* ...)))]))<br>(define (throw msg) (current-exception-handler msg))<br></p></blockquote><p>其中，涉及throw的代码必须被包含在try里面，否则会导致错误。先来测试一下</p><blockquote><p>(try 1<br>     (throw 'foo)<br>     (catch msg (display "catch ") (display msg)))</p></blockquote><p>但是如果我们在后面再加上一行代码</p><blockquote><p>(throw 'test)</p></blockquote><p>这里就出现问题了，按照我们上面的要求throw应该在try catch块里面使用，而这里却不会报错，说明我们上面的代码错了。</p><p>进入try catch块时，我们把current-exception-handler设置为当前try catch块的exception-handler，但当运行出try catch块的时候，exception-handler并没有发生变化，我们希望恢复原来的exception-handler，使得不论是正常退出或者是发生错误退出都能恢复原有的exception-handler，所以修改一下代码，就是：</p><blockquote><p>(define current-exception-handler<br>  (lambda (msg) (error "No Top Level Try")))<br>(define-syntax try<br>  (syntax-rules (catch)<br>    [(_ expr ... (catch msg expr* ...))<br>        (call/cc (lambda (k)<br>                (let ([msg (call/cc (let ([preserved current-exception-handler])<br>                                        (lambda (k1)<br>                                      (set! current-exception-handler (lambda (msg)<br>                                                                      (set! current-exception-handler preserved)  <br>                                                                        (k1 msg)))<br>                                      (let ([result (begin expr ...)])<br>                                        (set! current-exception-handler preserved)<br>                                      (k result)<br>                                      ))))])<br>                  expr* ...)))]))<br>(define (throw msg) (current-exception-handler msg))</p></blockquote><p>这样，只要代码出了try catch块，current-exception-handler就会恢复成原来的，从而实现了动态作用域的效果。</p><h2><b>fluid-let语句</b></h2><p>如果你记得fluid-let语句（或者dynamic-wind）的话，你就会发现上面的代码效果和fluid-let语句很类似，没错，fluid-let语句（或者dynamic-wind）就是被设计用来实现dynamic scoping效果的，fluid-let语句的定义如下（摘自chez scheme user guide 8）：</p><blockquote><p>(define-syntax fluid-let<br>   (lambda (x)<br>     (syntax-case x ()<br>       [(_ () b1 b2 ...) #'(let () b1 b2 ...)]<br>       [(_ ((x e) ...) b1 b2 ...)<br>        (andmap identifier? #'(x ...))<br>        (with-syntax ([(y ...) (generate-temporaries #'(x ...))])<br>          #'(let ([y e] ...)<br>              (let ([swap (lambda ()<br>                            (let ([t x]) (set! x y) (set! y t))<br>                            ...)])<br>                (dynamic-wind swap (lambda () b1 b2 ...) swap))))])))</p></blockquote><p>具体的实现细节就不说了，给一个例子：</p><blockquote><p>(define x 1)<br>(define y (lambda () x))<br>(fluid-let ([x 2]) (y))</p></blockquote><p>这和第一段代码一模一样，只不过用了fluid-let（也可以使用dynamic-wind）语句，就在scheme里面模拟出了dynamic scoping的效果。</p><p>这样，try catch宏就可以写的很简单了：</p><blockquote><p>(define-syntax try<br>  (syntax-rules (catch)<br>    [(_ expr ... (catch msg expr* ...))<br>        (call/cc (lambda (k)<br>                (let ([msg (call/cc (lambda (k1)<br>                                      (fluid-let ([current-exception-handler k1])<br>                                      (let ([result (begin expr ...)])<br>                                      (k result)<br>                                      ))))])<br>                  expr* ...)))]))</p></blockquote><p>更新：建议使用dynamic-wind而不是fluid-let。</p><h2><b>parameterize语句-更好的选择</b></h2><p>但是出于某些原因（效率，赋值，标准库里面没有提供。。），我们并不想用fluid-let语句来解决问题，恰好rnrs标准库里面就提供了一个类似的，parameterize语句,同样可以完成任务。</p><blockquote><p>(define x (make-parameter 1))<br>(define y (lambda () (x)))<br>(parameterize ([x 2]) (y))</p></blockquote><p>如果我们在parameterize块外面尝试调用y函数，就会得到1，这说明parameterize只对块内生效，一旦出了parameterize块（不论是通过何种方式），就会恢复成原来的样子。</p><p>另外，parameterize只影响线程内，不对全局起作用。</p><p>scheme与其他lisp方言在作用域方面还有一个不同点，它的宏也是采用了词法作用域，而其他lisp方言的宏几乎都是动态作用域。如果你想了解scheme的宏如何实现动态作用域的效果，请看这里：<a href="http://schemeworkshop.org/2011/slides/Barzilay2011.pdf" data-editable="true" data-title="schemeworkshop.org 的页面" class="">http://schemeworkshop.org/2011/slides/Barzilay2011.pdf</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
