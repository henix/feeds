<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>「连载1」为什么Rust适合区块链开发</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/46123567">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-a5f6098a4de3f6d93cc68355deac21f6_r.jpg" alt=""></div><blockquote>本周开始「每日新闻」增加了一项试验内容，选择翻译一些文章，时间有限，选择连载的方式。<br><br>[原文](<a href="https://medium.com/solana-labs/solana-at-portland-dev-meetup-72e4dc7ad32c">https://medium.com/solana-labs/solana-at-portland-dev-meetup-72e4dc7ad32c</a>)<br><br>本篇是「Solana 、Zcash 和Parity 三家会面讨论为什么Rust适合区块链开发 」，因为是视频转录的文字，加上视频本身在有些地方录制的效果问题，所以经常有口齿不清的情况，所以翻译主要是意译，并且可能跳过一些无意义的文字。<br><br>- [Solana](<a href="https://github.com/solana-labs">Solana</a>)是一种高性能区块链<br>- [Zcash](<a href="https://github.com/zcash/">Zcash</a>)是一种加密货币<br>- [Parity](<a href="https://github.com/paritytech/">Parity Technologies</a>)是一个核心的区块链基础公司，以太坊相关<br><br>内容里涉及的人物我不清楚他们具体谁是对应哪家公司，但可能通过聊天内容猜的出来。</blockquote><p><br></p><p>Anatoly:  我的Rust经历实际上是来自于上一份工作，在Dropbox的时候，用Rust编写压缩相关的工作。当时，没有使用标准库的内存分配器，自己实现了一个类型安全的沙箱。非常酷。但是在开始这个项目之前，Rust并没有吸引我。</p><p>我用了两周时间使用C语言，但是当用到一些外部库的时候，还得写makefile，手动下载这些库，比较麻烦。所以，我决定尝试一下Rust。就在那一刻，“Holy shit, this is amazing.”。我才觉醒到，这是一个和C语言一样快的语言，并且还给了我Haskell般的类型安全。Rust击中了我，这真的很酷。</p><p>Jack： Rust击中我并不是因为速度或者其他因素。那是很久以后的事了，就像我现在才非常关心编写正式的Rust代码，才发现Rust中真正有趣的东西。（慢热）</p><p>但是最初的时候是因为我之前写C#，总是碰到运行时错误。因为这种动态类型，完全没有经过类型检查。我都无法列出遇到过的运行时错误数量了，感觉随便一个简单的操作都能碰到错误。给我的感觉是，这根本不像是编程，因为我还得处理这些运行时的错误（代码里感觉像多了很多“废话”，不精炼）。但是Rust就没有这种感觉。我喜欢Rust的人体工程学，比如包管理、类型安全和Null指针安全等。</p><p>Anatoly： Sean呢？</p><p>Sean： 是的，对我来说也是一样的。速度，可以说是一个我为什么用Rust工作的合理的解释。我可以说，“哦，好吧，它非常快，而且很容易合作，而且非常容易审核”等等。</p><p>但实际上，当我第一次学习Rust的时候，我的感觉是，“我再次爱上了编程”。因为我不太想再次求助于Haskell了（在某些情况下）。当然，Haskell很棒。</p><p>Jack：Haskell有太多的return废话了。</p><p>Sean： Rust将我的编程心智模型和程序思维恰到好处的结合了起来，我太喜欢这些概念了。当我第一次使用Rust的时候，它和现在有很大不同，还有垃圾回收之类的内容。但是过去这几年发生了变化，随着时间的推移它会更加优雅。我想这就是为什么我非常喜欢它的原因之一，就是我看到它的改进比原来越来越好。</p><p>Greg： 这些年我涉足了很多不同的编程语言。C、C++、Haskell、Python等。而且每一次，我都尽力在每个项目上只选择两种语言。我会说，“好吧，如果我想做这些高级的东西，我会选择Python，如果我想选函数式类型的东西，我会选Haskell，当我想做一些底层的东西，我会选C++”。我在这些跨语言交互过渡中被折磨了多次。这真的非常艰难，尤其是涉及垃圾回收的时候，实际上不可组合。</p><p>然后，C++那里没有垃圾回收也没有安全性可言。如果你用C++给Python写个插件，突然间你的程序就崩溃了。它不应该崩溃，对吗？但它就是崩溃了。因此，Rust对我来说，就是一股新鲜空气。我现在使用Rust这一种语言就可以完成整个软件堆栈的绝大部分功能，而不必切换语言了。</p><p>Jack： 我认为C++其实也不是完全不安全的。它还是安全的，但它的安全只存在于简单的情况下，但是当处理复杂的情况，就不安全了。表现就像安全性是一个谎言一样。</p><p>Greg： 你是指未定义行为吧？</p><p>Jack： 是的。</p><p>Greg： 所以，假设你的程序有一个整数溢出，它只是在你正在使用的编译器中出现，但是在语言定义中并没有定义整数溢出的情况，这就是未定义行为。你的编译器允许是允许做任何事情的，任何事情。</p><p>当然，它也许不会出现在你正使用的编译器中。然后你升级编译器，它就崩溃了。或者它在其他人的库中发生崩溃，因为它们有整数溢出，这就很烦。</p><p>Jack： 我的意思是，像Linux内核禁用了空指针检查优化（-fno-delete-null-pointer-checks ， GCC会默认把空指针检查优化掉）。这是因为曾经有一个错误，是编译器将空指针检查优化掉了，也就是说，把空指针检查给删除了。这就导致Linux内核的安全性大大降低，所以Linux内核要禁止这种优化。</p><p>当我想到Rust，只要Rust的不安全规则是正确的，那么建立在这些不安全上面的一切也是正确的。（就像Linux禁止空指针检查优化那样，建立不安全规则，在这个规则之上构建安全）</p><p>Sean：是的，所以说Rust实际上是有一层抽象的屏障，将安全作为第一等概念，因为在语言层面unsafe是第一等概念。</p><p>Jack： 我基本上也认为那是我喜欢的Rust概念。因为即便是Haskell，它具有惊人的抽象能力，也不得不分离安全和不安全的东西。在函数名称上加unsafe，比如“unsafe_perform_io”，这有点像是「在我的脑子里创造了一个鼻子恶魔（Nasal demons，未定义行为的幽默同义词）」。</p><blockquote>「鼻子恶魔一词的来源考证：在Usenet组comp.std.c上识别C编译器遇到未定义构造时的任何意外行为的简写。 在1992年初关于该组的讨论中，经常评论“当编译器遇到给定的未定义构造时，让恶魔飞出你的鼻子是合法的”（暗示编译器可以选择任意奇怪的方式来 在不违反ANSI C标准的情况下解释代码。 其他人后来提到了“鼻子恶魔”，很快就成立了。 」</blockquote><p>Greg：确实如此，那是Prelude中的函数，所以你几乎无法避免，甚至是一个一无所知的Haskell新手。如果你尝试读取文件，那么意味着你就会做一个不安全的操作，几年之后肯定会咬你一口。</p><p>Anatoly：是的Greg和我一起做过一个Haskell项目。</p><p>Jack：我认为，Haskell有很多好的东西，但也存在很多搬起石头砸自己的脚的东西。现在有很多语言都在尝试寻找更好的方法来避免自讨苦吃。Rust就是其中之一。不要乱用其他语言，不要把它变成一个崇拜的东西。只有Rust，Rust是唯一的好语言。 （没看原视频，估计这段是在调侃，其他人也在附和：yeah 、yeah…）</p><p>Anatoly: 你们写过一篇博客叫「why Rust」？</p><p>Sean &amp; Jack： 是的，没错。</p><p>Greg：是的。</p><p>Jack： 是Greg写的？我还以为是Dmitri。</p><p>Anatoly： 所以，现在Rust改进了很多编程人体工程学，你认为它会做的更好吗？你现在还有机会嘲讽Rust。</p><p>Jack： 有一点得提。比如，你没有理由说Rust不支持在栈上做事，但是当前，你还必须得在堆上进行操作。比如我们做WebAssembly相关工作的时候，就必须在运行时处理一些东西。比如我有很多静态字符串，想要在栈上将它们串成一个长的静态字符串，这就无法做到，只能在堆上。因为，Rust应该能做到支持将静态的字符串在编译期创建关联组合为长的字符串，而不是在运行时。所以现在必须有一个分配器，最好在编译期就执行该操作。并且就安全性而言，Rust没有任何理由做不到这一点。</p><p>当然，另一个问题是不能在trait中定义一个可以返回trait的函数（「trait in trait」），这就为Rust损失了一个利好。</p><p>Anatoly： 就像Haskell里的存在类型？</p><p>Jack：是的。</p><p>Greg：trait里的存在类型？意味着trait能实现可以返回不同类型的方法？</p><blockquote>（此处口齿不清，记录的也咋地，大概猜测说的是Rust不能在trait中定义一个可以返回trait的函数）</blockquote><p>Jack： 心智模型大概是，你应该有一个关联类型，并且该关联类型不同的实现。</p><p>Greg：所以你不得不指定一个trait？</p><p>Jack：没错。所以有两种不同的设计。一种，你明确的关联类型，然后就输入 『等于某个trait』（type = trait），另一种就是隐式的，自动为你创建一个相关类型。但无论哪种方式，都是属于心智模型。你会经常碰到这种情况，Rust中的大部分方法都是trait方法。</p><p>Sean：是的。</p><p>Jack：所以，你不能返回一个「trait in trait」，这实际上是一个非常普遍的问题。如果你想在栈上做一些事情就会碰到这个问题。</p><p>Sean：我同意这两点。就语言特性而言，我们真的碰到了从没遇到过的波折。碰巧这两个特性也正在开发中。</p><p>Grag：是的，Amen。Rust开发者一定会爱你们，「他在抱怨一个月前就发布的东西」。 （大笑）</p><p>（省略 一段和听众探讨的环节）</p><p>Sean：我有点想知道，Parity有多少Unsafe代码？</p><p>Jack： 实际上Parity里并没有那么多unsafe代码。事实上，在我加入之前，到处都是unsafe，你知道，我们必须要压榨出最大的性能。因为C++开发者喜欢这种「安慰剂」般的优化。</p><p>Sean： “我不需要对它进行运行时检查”</p><p>Jack: 没错。</p><p>Sean: “我不想恐慌”</p><p>Jack: 恐慌或缓慢，你都不想要。我的意思是，未定义行为是非常不可琢磨。但是在某一个同事加入之后，他开始删除这些unsafe代码，从那时起，我们就开始越来越多地删除unsafe代码。现在就变得安全多了。</p><p>当然也有一些unsafe hack，比如底层有些内容是需要性能，实际上现在无法对其优化。比如我们有个hash算法，必须将两个数组连接在一起。我们将两个数组放到一个结构里，然后将其替换为C，然后在C中将两个数组连接，再转回Rust的一个数组。因为这样，明显更快。但这样的代码也没有太多。</p><p>Anatoly： 没错，但是，谁能在一天内完成所有代码呢？（ 表达罗马并非一天建成的意思）</p><p>Jack： 我希望是一天。</p><p>Anatoly： 我的下一个问题是和安全相关的。比如，C和Haskell。我发现现代类型系统实际上也没有增加太多的东西，就像是多了很多简单标签的C。在使用这些高级抽象类型的时候，怎么样证明这些代码的意义？比如这些类型的抽象目的是为了给你提供一些保证和确定性，你从哪里看到这些效果？</p><p>Greg： 我认为它们会更加方便你编写代码。比如刚开始需求简单的时候，并不知道要用到哪些类型，那么就可以编写一个泛型的数组，这可以帮助我们跳出困境。但是，随着需求越来越多，我只需要简单的包装类型，就可以改造泛型数组。再加上类型检查，我认为这是一个有用的保障。</p><p>Jack：我认为你这是一种类型驱动开发的做法。</p><p>Greg：是的。</p><p><br></p><p>「未完待续」</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
