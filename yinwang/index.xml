<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>当然我在扯淡</title>
<link>https://henix.github.io/feeds/yinwang/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Fri, 02 Aug 2019 01:11:04 +0800</lastBuildDate>
<item>
<title>也说人的素质</title>
<link>https://henix.github.io/feeds/yinwang/2019-07-31-human-quality.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/07/31/human-quality&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;也说人的素质&lt;/h2&gt;
            &lt;p&gt;最近上海开始搞垃圾分类，有些人就开始把“能否准确分类垃圾”跟“素质”这个词挂钩，从道德高度鄙视那些不认真分类垃圾，或者不按规定投放垃圾的人。有些小区门口每周都要张榜，公开表扬和批评各楼层的垃圾分类情况。某些人很是有种给人发小红花的快感。&lt;/p&gt;

&lt;p&gt;且不说上海的垃圾分类方法和执行方式是否合理（比如湿垃圾破袋扔之类的奇葩做法）…… 这些战战兢兢指手画脚，使我想起一些关于“素质”一词的事情来……&lt;/p&gt;

&lt;p&gt;很多中国人喜欢提“素质”这个词，总觉得自己是素质高尚的，喜欢指责别人素质低。然而真的如此吗？实际上，我发现爱提“素质”这个词的人，在心理上都是有一定问题的。&lt;/p&gt;

&lt;p&gt;在这些人心里，素质只是一个口号，一个标牌，一个可以把自己放到别人之上，获得优越感的心理手段。总觉得自己高人一等，说别人素质低，好像自己素质就无可挑剔，是圣人。&lt;/p&gt;

&lt;p&gt;我排队，所以我素质高，所以我可以鄙视其他人。别人只是走到前面看了看，就觉得别人要插队…… 喂喂喂，你干嘛？到后面排队去！什么素质…… 小区公告说可回收垃圾要自己拿到挺远地方扔，你把可回收垃圾洗的干干净净码的整整齐齐，但你觉得搬运可回收物应该是垃圾处理人员的本职工作，你就像以往一样放在垃圾桶旁边，所以你素质低，不讲公德，你就是村炮，我就高你一等！&lt;/p&gt;

&lt;p&gt;这其实体现了他们内心对待其他人的不平等，或者叫做“歧视”。喜欢歧视其他人的人往往也有另外一种性质，叫做“势利”。满口“素质”的人往往是势利的。他们自以为是圣人，而其实呢，他们缺少最重要的一种品质——平等对待和尊重他人。&lt;/p&gt;

&lt;p&gt;还有另外一些人，他们因为恐惧而做出显示“高素质”的举动。这些人很在意别人的眼光，生怕在外人眼里素质不高了，所以事事谨小慎微。这种人在早期是因为被前一种人鄙视，所以因为恐惧而显示“高素质”。久而久之，他们也开始鄙视其他人，总喜欢说别人素质低。这也许就是所谓“斯德哥尔摩综合征”。&lt;/p&gt;

&lt;p&gt;可惜的是，以上这些人都没有明白真正的素质是什么。他们避免某种行为，是因为他们怕别人觉得自己“素质低”，所以不再高人一等，或者怕被人看不起。他们的行为是出于恐惧或者其它卑劣的心态，而不是因为从内心尊重其他人。&lt;/p&gt;

&lt;p&gt;有位古人说得好，“己所不欲，勿施于人”。能够从内心尊重他人，体会到某种行为对他人造成的影响，从而自动调整自己的行为，这就叫做“共情”，compassion。从这种美好的感情出发，调整自己的行为，而不引以为豪。一旦有了共情，良好的行为将成为自动的，而不需要调动恐惧，或者高人一等的心理。&lt;/p&gt;

&lt;p&gt;没有这种共情感觉的人，就只能按照条条款款规矩办事。书上说这个是“素质低”的表现，所以我不这样，但是从来没理解为什么。如果你理解了，就会发现你不用记住这些规矩了。因为你能切身体会到这些行为所造成的烦恼，所以你就能像对待自己一样去照顾其他人的感受。&lt;/p&gt;

&lt;p&gt;一旦你从内心体会到这些，你就不会再提“素质”这个词了。你的行为不再是为了显得自己素质高，高人一等，而是自动的，发自内心的。你也会发现有些所谓“素质高”的做法其实是多此一举，承担不必要的责任。然后你就学会了灵活行事，让自己和其他人的生活都更加美好。不是名义上的“美好”，而是实质意义上的。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-07-31-human-quality</guid>
<pubDate>Wed, 31 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>再谈“P vs NP”问题</title>
<link>https://henix.github.io/feeds/yinwang/2019-07-16-pnp2.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/07/16/pnp2&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;&lt;![CDATA[
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        ]]&gt;&lt;/script&gt;
&lt;div class=&quot;inner&quot;&gt;&amp;#13;
            &lt;h2&gt;再谈“P vs NP”问题&lt;/h2&gt;&amp;#13;
            &lt;p&gt;曾经写过一篇文章，表达对计算机科学里著名的 “&lt;a href=&quot;https://en.wikipedia.org/wiki/P_versus_NP_problem&quot;&gt;P vs NP&lt;/a&gt;” 问题的看法。当时正在研究那些东西，由于看透了却不在乎，所以写得特别简略。没想到有人看到那篇文章后，还误以为我没仔细学过复杂度理论，认为我是武断的信口开河。我一般懒得谈论这种太理论的问题，身边很少有人关心，所以后来干脆把文章撤了。&lt;/p&gt;

&lt;p&gt;没想到最近又遇到有人抓住我删掉的文章，跟我辩论这事。跟上课似的头头是道滔滔不绝，几乎把他本科算法课本上的内容给我背了一遍，却没有显示出任何他自己的思想。所以我决定事后把这个问题再详细讲一下，免得以后还要为它费口舌。&lt;/p&gt;

&lt;p&gt;计算理论（Theory of Computation）我系统的学过很多遍了，理解得比绝大部分人都要透彻，我看破了这里面的很多事情。计算理论的书籍和文献，几乎全都基于图灵机模型。而研究编程语言和逻辑的学者，很多都不认同图灵的理论。他们从图灵的导师（&lt;a href=&quot;https://en.wikipedia.org/wiki/Alonzo_Church&quot;&gt;Alonzo Church&lt;/a&gt;）和他的师兄们（比如 &lt;a href=&quot;https://en.wikipedia.org/wiki/Stephen_Cole_Kleene&quot;&gt;Stephen Kleene&lt;/a&gt;）那里学东西。这些人的理论往往比图灵的要清晰简单，并且具有同等的建模价值。&lt;/p&gt;

&lt;p&gt;受到这些人的启发，摸透了图灵机，lambda calculus，combinatory logic，…… 经过周密的思考，我才对 P vs NP 的重要性提出了质疑。这是我多年积累的看法，感觉自然到了不需要辩论的地步，却没想到说出来之后遭到如此的抗议。&lt;/p&gt;

&lt;p&gt;起初为此苦恼，但逐渐的我理解了，这是深刻的见解表达出来的时候必须面对的现实。我应该对人们的不理解感到同情，而不是懊恼。很多人对 P vs NP 的理解停留于本科算法课学到的内容。他们不知道 lambda calculus 是什么，没有切实的理解图灵机与 lambda calculus 的等价性，不能像我一样从更清晰的角度看看待计算理论问题。&lt;/p&gt;

&lt;p&gt;如果你没有系统的学习过复杂度理论，我建议你仔细研读一下经典的计算理论教材，比如 Michael Sipser 的『&lt;a href=&quot;https://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X&quot;&gt;Introduction to the Theory of Computation&lt;/a&gt;』。我觉得 Sipser 的书写的不够清晰透彻，但很多学校拿它做教材，好像也没有更好的替代品，所以将就着看吧。&lt;/p&gt;

&lt;h3 id=&quot;p-vs-np-真的是重要问题&quot;&gt;“P vs NP” 真的是重要问题？&lt;/h3&gt;

&lt;p&gt;“P vs NP” 这个问题有它的理论价值，它是有趣的问题，值得花些时间来了解。但计算机科学界长久以来都在严重夸大它的重要性，把一个很普通的问题捧上了天，吹得神乎其神。&lt;/p&gt;

&lt;p&gt;很多人认为“P vs NP”是计算机科学最重要的问题。Clay 数学研究所甚至悬赏一百万美元解决这个问题，把它叫做数学界的 7 个千年难题之一，跟黎曼猜想并列其中。&lt;/p&gt;

&lt;p&gt;好几次有人声称解决了“P vs NP”，上了新闻，闹得舆论沸沸扬扬，小编们吹得好像世界要天翻地覆了一样，把他们追捧为天才苦行僧，后来却又发现他们的结果是错的……&lt;/p&gt;

&lt;p&gt;如果你真的理解了“P vs NP”的内涵，就会发现这一切都是闹剧。这个问题即使得到解决，也不能给世界带来很大变化。实际上，解决这个问题对于现实的计算，作用是微乎其微的。不管 P 是否等价于 NP，我们遇到的计算问题的难度不会因此有任何改变。&lt;/p&gt;

&lt;p&gt;在我看来，“P vs NP” 根本没有资格跟黎曼猜想一起并列于“千禧年问题”。我倒是希望有人真的解决了它，这样我们就可以切实的看到这有什么意义。&lt;/p&gt;

&lt;p&gt;“P vs NP” 不是愚蠢的问题，但计算机科学界夸大它的重要性的做法，是非常愚蠢的。&lt;/p&gt;

&lt;h3 id=&quot;什么是多项式时间&quot;&gt;什么是多项式时间？&lt;/h3&gt;

&lt;p&gt;真正重要的数学问题被解决，应该对现实世界具有强大的作用。这种作用可以是“潜在的”，它的应用可以发生在很久以后的将来，但这必须能够被预见到。数学家们把这叫做“applicable result”。否则这个数学问题就只能被叫做“有理论价值”，“有趣”，而不能叫做“重要”。即使所谓“纯数学”，也应该有可以预见的效果。&lt;/p&gt;

&lt;p&gt;很多数学家都明白黎曼猜想（Riemann hypothesis）的重要性。大数学家希尔伯特说过：“如果我沉睡了三千年醒过来，我的第一句话会是‘黎曼猜想被解决了吗？’” 如果希尔伯特还在世，他会对解决“P vs NP”有同样的渴望吗？我觉得不会。实际上，很多数学家都觉得“P vs NP”的重要性根本没法和黎曼猜想相提并论，因为我们预见不到它会产生任何重要的效果。&lt;/p&gt;

&lt;p&gt;很多人提到“P vs NP”总是跟你吹嘘，P 如果等于 NP，世界将有天翻地覆的变化：许许多多我们以前没法办到的事情，都将成为现实。非对称加密技术会被破解，生物化学将得到飞跃……&lt;/p&gt;

&lt;p&gt;这些人都忽略了一个重要的问题：什么是多项式时间。盲目的把“多项式”等同于“容易”和“高效”，导致了对 “P vs NP” 重要性的严重夸大。&lt;/p&gt;

&lt;p&gt;n^100 是不是多项式？是的。n^(100^100) 也是多项式。时间复杂度为 n^(100^100) 的算法，能用吗？所以即使 P=NP，你需要的计算时间仍然可以是直到宇宙毁灭。&lt;/p&gt;

&lt;p&gt;说到这里，又会有人跟我说你不懂，当 n 趋近于无穷的时候，非多项式总会在某个时候超越多项式，所以当 n “足够大”的时候，多项式时间的算法总是会更好。很可惜，“无穷”对于现实的问题是没有意义的。任何被叫做“重要”的问题，都应该在合理的时间内得到结果。&lt;/p&gt;

&lt;p&gt;我们关心的要点不应该是“足够大”，而是“具体要多大”。精确的量化，找到实际可以用的区间，这才是一个合格的科学家应该具有的思路。计算机科学里，大 O 表示法泛滥成灾，只看最高次幂，忽略系数和常数项，也是常见的误区。我也曾经沉迷于如何把 O(n^3) 的算法降低到 O(n^2.9)，现在回头才发现当年是多么的幼稚。&lt;/p&gt;

&lt;p&gt;“多项式时间”这个概念太宽泛太笼统。以如此笼统的概念为基础的理论，不可能对现实的计算问题产生意义。我们关心的不应该仅仅是“是否多项式”，而是“具体是什么样的多项式”。多项式的幂，系数，常数项，它们的不同都会产生重大的差异。&lt;/p&gt;

&lt;p&gt;这就是为什么“P vs NP”没有很大意义，因为 P 本身太笼统，其内部的差异可以是天壤之别。研究“P vs NP”就像研究“男人 vs 大猪蹄子”一样笼统而不严谨。与其试图笼统的证明 P 是否等价于 NP，还不如为具体的问题想出高效的算法。&lt;/p&gt;

&lt;h3 id=&quot;其它质疑-p-vs-np-价值的人&quot;&gt;其它质疑 P vs NP 价值的人&lt;/h3&gt;

&lt;p&gt;很多人认为我质疑 P vs NP 的价值是狂妄和信口开河，然而我并不是第一个质疑它的人。很多人对 P vs NP 都有类似的疑惑，但因为这个问题的地位如此之高，没人敢站出来。只要你开口，一群人就会居高临下指责你基础课程没学好，说你眼界太窄…… 再加上那一堆纷繁复杂基于图灵机的证明，让你有苦说不出。&lt;/p&gt;

&lt;p&gt;由于这个原因，我从来没敢公开表达我的观点，直到我发现 Doron Zeilberger 的这篇&lt;a href=&quot;http://sites.math.rutgers.edu/~zeilberg/Opinion98.html&quot;&gt;文章&lt;/a&gt;。Zeilberger 是个数学家，Rutgers 大学的数学系教授。在那之前他开了个玩笑，戏称自己证明了 P=NP，还写了篇像模像样的论文。在文章里他告诫大家：不要爱上你的模型（Don’t Fall In Love With Your Model）。他这句话说到了我心里。&lt;/p&gt;

&lt;p&gt;你还能在网络上找到其它学者对“P vs NP”的质疑，比如这篇来自于一位专业研究计算理论的学者：&lt;/p&gt;

&lt;p&gt;​    &lt;a href=&quot;https://rjlipton.wordpress.com/2009/07/03/is-pnp-an-ill-posed-problem&quot;&gt;Is P=NP an Ill Posed Problem?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我觉得他讲的也很在理。正是在这些人的鼓舞之下，我冒着砖头写出了之前对 P vs NP 的质疑。只言片语里面，融入了我多年的深入学习，研究和思考。&lt;/p&gt;

&lt;p&gt;我希望理性的计算机科学工作者能够理解我在说什么，反思一下对 P vs NP 的理解。我希望计算机专业的学生能够理解 P vs NP 理论，但不要沉迷其中。这并不是一个值得付出毕生精力去解决的问题。&lt;/p&gt;

&lt;p&gt;当然所有这些都是我个人的观点，我没有强求任何人接受它们。没人想抢走你们的玩具，但不要忘了，它只是玩具。&lt;/p&gt;

&amp;#13;
        &lt;/div&gt;
</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-07-16-pnp2</guid>
<pubDate>Tue, 16 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>学习的智慧</title>
<link>https://henix.github.io/feeds/yinwang/2019-07-12-learning-philosophy.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/07/12/learning-philosophy&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;学习的智慧&lt;/h2&gt;
            &lt;p&gt;有些人很爱学习，兢兢业业的把书一个字一个字从头看到尾，还拿笔把重点画上。好不容易学完一本书，结果完全不知道自己学到了什么。&lt;/p&gt;

&lt;p&gt;另外一些人聪明一点，他们的嘴里总是冒出一连串高深莫测的术语，滔滔不绝听得我头都冒汗。等遇到实际问题的时候，你就发现他们虽然口若悬河，做事动作快，加班加点，却总是走错方向。&lt;/p&gt;

&lt;p&gt;而垠神呢，更奇葩。跟垠神合作的人，常会发现他问一些很傻的“初学者”问题，简直让人不屑。遇到术语名词总是丈二和尚张冠李戴，好像不知道那些是什么。人们很惊奇的发现，垠神居然什么都不会！&lt;/p&gt;

&lt;p&gt;每次到了需要作出关键决策的时候，听大家正儿八经滔滔不绝之后，垠神慢条斯理不经意的抖出一句话：“那不就是 xx 吗？那样那样弄一下，不就可以了？” 你起初不信他，跟他争论，说这样不能满足我们的宏伟目标。他又轻描淡写跟你说一些，然后回头玩他的去了。因为垠神平时好像什么都不会，所以他的话被你当耳边风，你坚信自己是对的。&lt;/p&gt;

&lt;p&gt;几个月之后，经过实现 N 种方案，各种惨痛教训之后，你发现自己最后选择了垠神最初指出的方向。如果你开头就试图理解他在说什么，你可能几天就完工了。&lt;/p&gt;

&lt;p&gt;在 Indiana 的时候垠神经常享受的一件事情，就是静静看着同学们用各种术语装逼，眼睁睁看着他们误入歧途，重蹈自己几年前犯过的错误。甚至有些人弄了一两年都没发现走错了。不是垠神自私啊，而是很多人根本没有在意过他的看法。如果你如此的坚信自己是对的，垠神是懒得主动告诉你他在同一地点同一路线失败的经历的 ;)&lt;/p&gt;

&lt;h3 id=&quot;死知识活知识&quot;&gt;死知识，活知识&lt;/h3&gt;

&lt;p&gt;很多人坚信“知识就是力量”，可是他们不知道，知识和知识是不一样的。&lt;/p&gt;

&lt;p&gt;大部分人从学校，从书籍，从文献学知识，结果学到一堆“死知识”。要检验知识是不是死的，很简单。如果你遇到前所未见的问题，却不能把这些知识运用出来解决问题，那么这些知识就很可能是死的。&lt;/p&gt;

&lt;p&gt;死知识来源于其他人。追根溯源之后，你会发现这知识最初的创造者经过了成百上千的错误。这就像爱迪生发明灯泡，经过了几千次失败的实验。知识的创造者把最后的成功记录在文献里发表，然后你去读它。你以为得到了最宝贵的财富，然而最宝贵的财富却是看不见的。作者从那成百上千的失败中得到的经验教训，才是最宝贵的。而从来没有人把失败写下来发表。&lt;/p&gt;

&lt;p&gt;没有这些失败的经验，你就少了所谓“思路”，那你是不大可能从一个知识发展出新的知识的。就像你读了别人的重要 paper，你是不大可能由此发展出重大想法的。你的 paper 会比别人低一个档次，往往只能修修补补，弄出一个小点的想法。而原来的作者以及他的学生们，却可以很容易的变出新的花样，因为他们知道这些路是怎么走过来的，知道许许多多没有写下来的东西。“失败是成功之母”，在我脑子里就是这个意思。&lt;/p&gt;

&lt;p&gt;垠神从很早的时候就知道了这个道理，所以他很多时候不看书，不看 paper。或者只看个开头，知道问题是什么。他看到一个问题，喜欢自己想出解决方案。他不是每次都成功，实际上他为此经历了许许多多的失败。运气好的时候，他得到跟已有成果一样的结果。运气再好一点的时候，他得到更好的结果。但他关心的不只是成功，中间的许多失败对他也是价值重大的。&lt;/p&gt;

&lt;p&gt;然后他会去找有经验的人讨论，这些人也许很厉害，早就做过深入的研究。也许是初学者，刚刚接触到同样的问题。但很奇特的是，不管跟什么样的人交流，垠神几乎总是能得到启发。即使这个人什么都不懂，现教给他也一样。通过向不懂的人解释这个问题，他经常意外的发现问题的答案。&lt;/p&gt;

&lt;p&gt;为死知识引以为豪的人往往满口的术语，对“初级问题”不屑一顾。懂得活知识的人，却知道每一个初级甚至傻问题的价值。世界上最重大的发现，往往产生于对非常基础的问题的思考，比如“时间是什么？” 如果你觉得理所当然每个人都该知道这个问题的答案，只有白痴才会问出这种问题，那你就失去了很多产生活知识的机会。这就是为什么垠神经常问一些基础问题，因为他想知道它们背后还隐藏着什么他不知道的内涵。&lt;/p&gt;

&lt;p&gt;这就是垠神获取活知识的秘密。活知识必须靠自己创造出来，要经过许许多多的失败。如果没有经过失败，是不可能得到活知识的。&lt;/p&gt;

&lt;p&gt;由于活知识是自己创造的，其中包含的概念，垠神是不知道它们在文献中的术语的——垠神平时都懒得看文献。这就是为什么很多人跟垠神交流，发现他连基本的术语都不知道是什么。经过进一步交流，你也许会发现虽然垠神不知道一个东西的名字，他却知道这个东西是什么——以他自己的理解方式 ;)&lt;/p&gt;

&lt;h3 id=&quot;知识的来源&quot;&gt;知识的来源&lt;/h3&gt;

&lt;p&gt;所以呢，知识的来源最好是自己的头脑，但也不尽然。有些东西成本太高，比如一些医学，生物学，物理的东西，没条件做实验就没法得到，所以还是得先获取现成的死知识。&lt;/p&gt;

&lt;p&gt;有些人说到“学习”，总是喜欢认认真真上课，抄笔记，看书。有些人喜欢勾书，把书上整整齐齐画满了横杠。兢兢业业不辞辛苦，最后却发现没学会什么。&lt;/p&gt;

&lt;p&gt;为什么会这样呢？首先因为他们没有理智的选择知识的来源。他们没有意识到，对于同一个问题有很多不同的书，不同的作者对于问题的见解深度是不一样的。如果你拿着一本书从头看到尾，而不参考其他人的，往往会误入歧途。你手上的书的作者，也许自己没看很透这个问题，只是他发表的早，占了先机，所以这书成了学校指定的，大家推崇的“经典教材”。&lt;/p&gt;

&lt;p&gt;在学校的时候，我不止一次的发现经典教材很难懂。经过不懈的努力，让自己的思维爬到一定高度之后我才发现，原来这经典教材作者很多地方没有看透彻。写书的时候他也把一些可有可无的内容写进去，引经据典的罗列出各种 paper，却忽视了最重要的思想和直觉。看这种书，你当然头痛了。&lt;/p&gt;

&lt;p&gt;我为什么能突破这道壁垒呢？第一是因为我自己动手创造了知识，第二是因为我从其他人那里学到了东西。我喜欢在网上搜索对应一个主题的内容，往往能发现一些名不见经传的人的作品，反而比著名的大牛来的深刻。当然网上内容鱼龙混杂，你也不要死钻进去出不来了。&lt;/p&gt;

&lt;p&gt;看书的时候不要老想从头看到尾。如果一个主题你看得头大，最好的办法是放下这书，去寻找对同一主题的更简单的解释。这些东西可以来源于网络，也可以来自其它书籍，也可以来自身边的人。同时保留多个这样的资源，你就可以对任何主题采用同样的“广度优先”搜索，获得深入理解的机会就会增加。&lt;/p&gt;

&lt;p&gt;都说书籍是人类的朋友，我却发现看书是很闷的事情，我很不喜欢看技术方面的书。我最喜欢的是直接跟人学东西。找到懂一点的人，跟他聊。别管他懂多少，懂多深，我发现真人几乎总是比书好。至少，你聊天的时候不会打瞌睡 ;) 而且很多时候他没告诉你答案，但通过聊天，你自己把它给想出来了。&lt;/p&gt;

&lt;p&gt;参加学术会议的时候，我会事先把会议的 paper 浏览一下，然后发现根本看不进去。带着好奇心来到会议，听了演讲还是不懂。接下来我使出绝招…… 等演讲者下台之后的休息时间，我会走到他面前说：“你好，我比较笨看不懂你的 paper。请问你能在三句话之内把里面的要点概括一下吗？” 接下来奇迹发生了，作者说出了他从未发表的直觉，仔仔细细教会了我，甚至跟我成了朋友。当然对于这样的人，我也会告诉他一些我知道的东西作为回报。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-07-12-learning-philosophy</guid>
<pubDate>Fri, 12 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>机器学习与逻辑编程</title>
<link>https://henix.github.io/feeds/yinwang/2019-01-30-machine-learning.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2019/01/30/machine-learning&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;机器学习与逻辑编程&lt;/h2&gt;
            &lt;p&gt;（声明：本文内容纯属个人的技术兴趣，与本人在职公司的立场无关）&lt;/p&gt;

&lt;p&gt;你可能没有想到，机器学习（machine learning）和逻辑编程（logic programming）有着一种美妙的关系，在我眼里她们就像一对亲姐妹。&lt;/p&gt;

&lt;p&gt;很多人都了解机器学习，可是很少有人理解逻辑编程。在这篇短文里，我试图告诉你逻辑编程是什么，以及它与机器学习的相似之处。&lt;/p&gt;

&lt;h3 id=&quot;逻辑编程是什么&quot;&gt;逻辑编程是什么&lt;/h3&gt;

&lt;p&gt;说到逻辑编程（logic programming），人们不禁想到 Prolog 之类晦涩的逻辑式编程语言。很多人上本科的时候被迫学过 Prolog，但从来不知道它有何意义。毕业之后再听到 logic programming 这个词，就只剩下敬畏和茫然，或者觉得是没用的老古董。&lt;/p&gt;

&lt;p&gt;其实逻辑编程是很美的东西，并不过时。它的有些思想已经悄悄被应用到了最先进的编程语言之中。逻辑编程的原理可以被很轻松的解释清楚，而不需要理解 Prolog。&lt;/p&gt;

&lt;p&gt;最近研究机器学习，我发现逻辑编程与机器学习之间有着有趣而隐秘的关系。我希望这可以调动起你的胃口来。&lt;/p&gt;

&lt;p&gt;要理解逻辑编程是什么，你只需要看一个很简单的例子：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有一个未知数 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;，我们不知道它是多少，但我们知道：&lt;/p&gt;

  &lt;p&gt;​     X + 2 = 5&lt;/p&gt;

  &lt;p&gt;请问 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 是几？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上求解 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 的问题就是一个逻辑程序。像 Prolog 这样的逻辑语言系统，会给你结果：&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 等于 3。可是这个问题却不能用其它几乎所有编程语言来表达（C, C++, Python, Java, Go, Scala, Haskell, Rust, Swift…）。原因在于，使用普通的编程语言，你不能把“未知数”当成一个值来进行演算。&lt;/p&gt;

&lt;p&gt;在我们的例子里面，&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 的值是未知数，所以当普通语言看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;X + 2&lt;/code&gt; 这样的表达式，它就无法运行。它会报错：使用未初始化的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;。也就是说，你必须先知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 的值，你才能说 &lt;code class=&quot;highlighter-rouge&quot;&gt;X + 2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但在像 Prolog 这样的逻辑式语言里面，“未知数”是可以被作为一个正常的值来进行计算的。它们可以被传递到其它函数里，可以被放进数据结构，可以进行复杂的逻辑组合操作，就像你在操作一个普通的数字或者字符串一样。&lt;/p&gt;

&lt;p&gt;逻辑式程序中一般会有一个（或者多个）“目标”（goal）。目标一般是一个判断表达式，也就是说它的值是布尔类型（boolean）。这里我们的例子里只有一个目标，就是“X + 2 = 5”。也就是说，我们想要 X 加上 2 等于 5。&lt;/p&gt;

&lt;p&gt;当逻辑式语言看到了目标，就把目标记下来。最后程序员开始提问：&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 是几？这时候，逻辑语言的运行系统开始进行“反向计算”，找到未知数的值，使得目标的值为“真”（true）。在我们的例子里，系统会告诉你：&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 等于 3。&lt;/p&gt;

&lt;p&gt;为什么叫做“反向计算”呢？因为&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我们先声明了未知变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;，&lt;/li&gt;
  &lt;li&gt;然后我们提出目标 &lt;code class=&quot;highlighter-rouge&quot;&gt;X + 2 = 5&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于复杂一点的程序，1 和 2 之间可能还有其它的代码。我们最后的问题，却是问最开头声明的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 等于几，所以系统从最后面的目标 &lt;code class=&quot;highlighter-rouge&quot;&gt;X + 2 = 5&lt;/code&gt; 出发，“反向”推导出 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 的值。&lt;/p&gt;

&lt;p&gt;这就是为什么研究逻辑式编程的人把这种操作叫做“反向计算”。你可能注意到了，我们的代码里面只写了加法（&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;）操作，而系统实质上为我们做了减法：5 - 2 得到  3。&lt;/p&gt;

&lt;p&gt;如果你想深入理解逻辑式编程，我建议你看看 Dan Friedman 的书『&lt;a href=&quot;https://mitpress.mit.edu/books/reasoned-schemer&quot;&gt;The Reasoned Schemer&lt;/a&gt;』。但目前你了解到的这些，应该足以读完这篇文章。&lt;/p&gt;

&lt;h3 id=&quot;机器学习与逻辑编程的相似点&quot;&gt;机器学习与逻辑编程的相似点&lt;/h3&gt;

&lt;p&gt;你可能已经明白了逻辑编程是什么。下面我们来看看它跟机器学习有什么关系。&lt;/p&gt;

&lt;p&gt;首先我们看到逻辑编程有“目标”（goal），比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;X + 2 = 5&lt;/code&gt;。在机器学习中有一个对应的东西，那就是误差函数（loss function）。只不过逻辑编程的 goal 是个等式，而机器学习的 loss function 是个函数。&lt;/p&gt;

&lt;p&gt;逻辑编程系统会为你选择未知数的值，从而精确地“满足”这个 goal。而机器学习的目标呢，是要为你选择未知数的值，最小化这个 loss function，使得误差最小。看到相似之处了吗？所以，机器学习可以被看成是“在连续空间中的近似的逻辑编程”，而逻辑编程可以被看成是“在离散空间中的精确的机器学习”。&lt;/p&gt;

&lt;p&gt;逻辑编程有“反向计算”，机器学习有“反向传递”(back propagation)，而它们的工作方式，有着惊人的相似之处。只不过机器学习因为是连续空间的，所以需要使用微积分的原理，而不只是简单的逻辑组合。&lt;/p&gt;

&lt;p&gt;实际上逻辑编程必须先进行正向计算，构造出含有未知数的结构，然后进行所谓“resolution“，求出未知数的值。而机器学习也类似，你必须进行一遍正向计算（forward pass），然后才能进行 back propagation，求出导数，并且更新“weight”的值。&lt;/p&gt;

&lt;p&gt;逻辑编程的“未知数”（比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;），对应了机器学习的 weight。实际上，机器学习的 weight 本质就是“未知数”。你需要得到它们的值，使得 loss function 最小，但一开头你不知道它们是什么，所以你给它们一些随机的初始值，让系统开始正向计算。机器学习的 weight 和逻辑编程的未知数如此的相似，它们可以被作为普通的值，与输入进行计算操作（Conv 等操作），直至你遇到 goal 或者 loss function，然后你掉头回去调整未知数的值……&lt;/p&gt;

&lt;h3 id=&quot;机器学习框架是程序语言&quot;&gt;机器学习框架是程序语言&lt;/h3&gt;

&lt;p&gt;所以呢，你现在明白了我为什么对机器学习感兴趣了吧。我看到了它与编程语言的优雅知识之间的联系，看到了它是对于“计算”概念的一种扩展。机器学习把“计算”和“微积分”有趣地融合在了一起。&lt;/p&gt;

&lt;p&gt;实际上，你可以把机器学习的各种框架（framework）看成是新的编程语言，它们的工作原理类似于 Prolog 语言的运行时系统。如果要起一个名字，你也许可以把它们叫做“可求导编程语言”（differentiable programming language）。&lt;/p&gt;

&lt;p&gt;写 framework 的工作，实质上是设计编程语言或者解释器，编译器。而有些 framework 所谓的“计算图”，实质就是编译器中的 data-flow graph 或者 control-flow graph 一类的东西。&lt;/p&gt;

&lt;p&gt;目前这些语言还处于初级阶段，表达力比较弱，有各种不完善的地方。由于机器学习解决的是连续的数值问题，机器学习的“模型”一般要很简单才行，否则很可能出现学习不收敛的情况。所以我还不知道编程语言的很多概念能否顺利的迁移到机器学习上面。&lt;/p&gt;

&lt;p&gt;但目前看来有一些很明显的对应关系和发展趋势：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Feed-forward 网络，比如 CNN 一类的，对应了编程语言中最简单的表达式，或者叫“纯函数”。其中没有递归，也没有副作用。它只能处理图像一类具有固定长度的数据。&lt;/li&gt;
  &lt;li&gt;RNN 对应的是程序语言里含有递归（循环）的函数。由于递归函数对应的是“递归数据结构”，这就是为什么 RNN 可以处理文本一类没有固定长度的“链表”数据。&lt;/li&gt;
  &lt;li&gt;Neural Turing Machine 及其后续的研究 &lt;a href=&quot;https://deepmind.com/blog/differentiable-neural-computers/&quot;&gt;Differentiable Neural Computer&lt;/a&gt;，试图把更广阔的编程概念引入到机器学习里面，实现任意复杂的数据结构和计算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于数值计算特有的误差问题和机器学习带来的巨大计算量，我不知道这个趋势最终可以发展到什么地步。但编程语言和机器学习的这个联系，是优雅而让人回味的。&lt;/p&gt;

&lt;p&gt;（如果你觉得这篇文章有启发，可以点击这里&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付费&lt;/a&gt;）&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2019-01-30-machine-learning</guid>
<pubDate>Wed, 30 Jan 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>解谜英语语法（1）</title>
<link>https://henix.github.io/feeds/yinwang/2018-11-24-grammar-chapter1.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/11/24/grammar-chapter1&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;解谜英语语法（1）&lt;/h2&gt;
            &lt;h3 id=&quot;第一章初识句子&quot;&gt;第一章：初识句子&lt;/h3&gt;

&lt;p&gt;直到几百年前，各个不同大陆上的人还从来没见过面，可是他们的语言里却不约而同出现了同样的结构：句子。这难道不是很奇妙的事情吗？这说明句子的出现似乎是一种自然规律。&lt;/p&gt;

&lt;h3 id=&quot;句子的核心地位&quot;&gt;句子的核心地位&lt;/h3&gt;

&lt;p&gt;句子是人类语言最核心的构造。为什么呢？因为人和人说话终究是为了一个目的：描述一件事。&lt;/p&gt;

&lt;p&gt;这件事也许只有一个字：吃！&lt;/p&gt;

&lt;p&gt;也许可以很长：昨天晚上在上海某路边餐厅吃的&lt;strong&gt;鹅肝&lt;/strong&gt;，&lt;strong&gt;是&lt;/strong&gt;我吃遍全世界&lt;strong&gt;最好的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一个句子表达的就是一件事，或者叫做一个“事件”。人与人交流，无非就是讲述一个个的事件。&lt;/p&gt;

&lt;h3 id=&quot;你需要的能力&quot;&gt;你需要的能力&lt;/h3&gt;

&lt;p&gt;所以要掌握一种语言，你只要掌握句子就行了。有了句子就有了一切。&lt;/p&gt;

&lt;p&gt;掌握句子包括两件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;能够迅速地造出正确的句子，准确地表达自己的意思。&lt;/li&gt;
  &lt;li&gt;能够迅速地理解别人的句子，准确地接收别人的意思。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两件事，一个是“发送”，一个是“接收”。因为语言是沟通（或者叫“通讯”）的工具，所以它就只包含这两件事。&lt;/p&gt;

&lt;h3 id=&quot;句子的本质&quot;&gt;句子的本质&lt;/h3&gt;

&lt;p&gt;假设我们是原始人，还没有语言。我想告诉同伴“我吃苹果”这件事，该怎么表达呢？没有语言，那我可以先画个图嘛：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/i-eat-apple.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;到后来，部落里的人聪明了一点，发明了“符号”这种东西。他们给事物起了简单的符号名字，不再需要画图了，所以我们有了 I, apple 这样的词用来指代事物。有了 eat 这样的词，用来代表动作。所以画面变成这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/i-eat-apple-symbol.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;后来干脆连框也不画了。直接写出这些符号来：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I eat apples.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么，你觉得“我吃苹果”这个事，里面最关键的部分是什么呢？是“我”，“苹果”，还是“吃”呢？&lt;/p&gt;

&lt;p&gt;稍微想一下，你也许会发现，关键在于“吃”这个动作。因为那是我和苹果之间发生的&lt;strong&gt;事件&lt;/strong&gt;。这句话是说“吃”这件事，而“我”或者“苹果”，只是“吃”的一部分。&lt;/p&gt;

&lt;p&gt;用 eat 这个词，你不但可以表达“我吃苹果”，还可以表达“他吃面条”，“猫吃老鼠”之类的很多事情。于是，聪明一点的人就把 eat 这个词提取出来，做成一个“模板”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/eat-verb.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个模板就是所谓“动词”。eat 这个动词给你留下两个空，填进去之后，左边的东西吃右边的。&lt;/p&gt;

&lt;h3 id=&quot;动词是句子的核心&quot;&gt;动词是句子的核心&lt;/h3&gt;

&lt;p&gt;就像我说的，句子是语言的核心，而动词就是句子的核心。动词是事件的关键，比如 eat。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A eat B.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以选择空格里的 A 或者 B 是什么。但不管怎么换，事情仍然是“吃”。为了描述方便，我们把 A 和 B 这两个空格叫做&lt;strong&gt;参数&lt;/strong&gt;（parameter）。&lt;/p&gt;

&lt;p&gt;这跟数学函数的参数（f(x) 里面那个 x）类似，也跟程序函数的参数类似。用数学或者程序的方式来表示这个句子，就是这样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;eat(A, B)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中 A 和 B，是动作 eat 的参数。我只是打个比方帮助你理解，当然我们不会这样写英语。如果你完全不懂数学或者编程，可以忽略这个比方。&lt;/p&gt;

&lt;p&gt;动词决定了它的参数在什么位置，它们可以是什么种类的成分。比如 eat，它的两个参数只能是某种“物”。你不能放另一个动词（比如 walk）进去，也不能放 red 这样的形容词进去。这种动词对参数的约束，我们把它叫做“参数类型”。&lt;/p&gt;

&lt;p&gt;你可能发现了，一个句子除了动词，就只剩下动词的参数了。动词对它的参数具有决定性的作用，动词就是句子的核心。准确理解一个动词“想要什么参数”，什么样的构造可以出现在那个参数位置，就是造出正确句子的关键。&lt;/p&gt;

&lt;p&gt;使用不同的动词可以造出不同的句子。所以要理解语法，你在初期应该把大部分精力放在各种各样的动词身上，而不是花几个月时间去背名词和形容词。我并不是说名词和形容词不重要，只是它们并不是核心或者骨架。&lt;/p&gt;

&lt;p&gt;没有人会怪你不认识某种恐龙的名字，但如果你不能理解“I am not used to eating garbage food.” 是什么意思，那你可能就有麻烦了。&lt;/p&gt;

&lt;h3 id=&quot;如何造出正确的句子&quot;&gt;如何造出正确的句子&lt;/h3&gt;

&lt;p&gt;我已经提到，对于人的语言能力，“造句”能力占了一半。很多人不知道复杂的长句是怎么造出来的，所以他们也很难看懂别人写的长句。&lt;/p&gt;

&lt;p&gt;我并不是说一味追求长句是好事，正好相反。如果你能用短句表达出你的意思，就最好不要用长句。虽说如此，拥有造长句的“能力”是很重要的。这就像拥有制造核武器的能力是重要的，虽然我们可能永远不会用到核武器。&lt;/p&gt;

&lt;p&gt;当然，制造长句不可能有核武器那种难度。造长句其实挺容易。你只需要先造出一个正确的短句，然后按照规则，一步步往上面添加成分，或者把其中某一部分“扩大”，就可以逐渐“生成”一个长句。&lt;/p&gt;

&lt;p&gt;这就像造一个房子，你首先打稳地基，用钢板造一个架子，然后往上面添砖加瓦。你可以自由地选择你想要的窗户的样式，瓦片的颜色，墙壁的材质，浴缸的形状…… 好像有点抽象了，我举个例子吧。&lt;/p&gt;

&lt;p&gt;首先，我造一个最简单的句子。最简单的句子是什么呢？我们已经知道动词是句子的核心，有些动词自己就可以是一个句子。所以我们的第一个句子就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;eat.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它适用于这样的场景：你在碗里放上狗粮，然后对狗儿说：“吃。” 当然，你体会到了，这句话缺乏一些爱意，或者你只是早上起来还比较迷糊，不想多说一个字，但它至少是一个正确的句子。&lt;/p&gt;

&lt;p&gt;接下来，我们知道 eat 可以加上两个参数，所以我就给它两个参数：I, apples。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;I&lt;/strong&gt; eat &lt;strong&gt;apples&lt;/strong&gt;. （我吃苹果）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个句子适用于这样的场景：别人问我：“你一般吃什么水果呢？” 我说：“我吃苹果。”&lt;/p&gt;

&lt;p&gt;有点单调，所以我再加点东西上去。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I eat &lt;strong&gt;Fuji apples&lt;/strong&gt;. （我吃富士苹果）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Fuji 被我加在了 apples 前面，它给 apples 增加了一个“修饰”或者“限定”。它只能是富士苹果，而不是其它种类的苹果。&lt;/p&gt;

&lt;p&gt;但我并不总是吃富士苹果，我有时不吃苹果。我想表达我只是“有时”吃富士苹果，所以句子又被我扩充了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Sometimes&lt;/strong&gt; I eat Fuji apples. （我有时吃富士苹果）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你觉得这个 sometimes 是在修饰（限制）句子的哪个部分呢？它在修饰“我”，“苹果”，还是“吃”？实际上，它是在限制“吃”这个动作发生的频率，所以它跟 eat 的关系紧密一些，也就是说它是在修饰 eat，而不是 I 或者 apples。&lt;/p&gt;

&lt;p&gt;以此类推，我们可以把它发展得很长：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sometimes &lt;strong&gt;I&lt;/strong&gt; &lt;strong&gt;eat&lt;/strong&gt; fresh Fuji &lt;strong&gt;apples&lt;/strong&gt; bought from a local grocery store.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我有时候吃从一个本地杂货店买来的新鲜富士苹果。注意，虽然这句子挺长，但它的“骨架”仍然是 I eat apples.&lt;/p&gt;

&lt;p&gt;我已经演示了，一个长句是怎么“生成”的。先造一个短句，然后往上面添砖加瓦，是写出长句的关键。正确的短句，按照规则加上一些成分，就成为正确的长句。这样你的语法就会一直是正确的。&lt;/p&gt;

&lt;p&gt;当然，扩展句子的时候，你不能随意往上加东西，它们必须满足一定的规则才能正确的衔接。比如，你只能把 Fuji 放在 apple 前面，而不是后面。这就像造房子的时候，你不能在该放窗户的地方放一道门，你不能用错配件和胶水。所谓语法，很多时候就是在告诉你这些部件要怎么样才能接的上。&lt;/p&gt;

&lt;p&gt;在后面的章节，我们会逐渐接触到这些细节的规则。&lt;/p&gt;

&lt;h3 id=&quot;如何理解长句&quot;&gt;如何理解长句&lt;/h3&gt;

&lt;p&gt;人与人交流的另一个部分就是“接收”。如果书上有很长一句话，你要怎么才能理解它呢？许多人看到长句就头痛，不知道该怎么办。这是因为他们不明白长句都是从短句扩展出来的，所以产生了恐惧感。&lt;/p&gt;

&lt;p&gt;其实理解长句的方法，都隐含在了上一节介绍的造出长句的方法里面。造句的时候我们先勾画出一个框架，然后往里面填修饰的东西。理解的时候如果有困难，我们可以用类似的办法。我们首先分析出句子的主干，把它理解了，然后再往上面添加其它的成分，逐步理解到整个句子的含义。&lt;/p&gt;

&lt;p&gt;比如之前的那个例子：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sometimes &lt;strong&gt;I eat&lt;/strong&gt; fresh Fuji &lt;strong&gt;apples&lt;/strong&gt; bought from a local grocery store.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你需要“反向思考”，分析出句子的主干是短句“I eat apples”。如果你觉得一下子找不到主干，那么你可以试试挨个的找到“修饰成分”，把它们逐个删掉，最后留下来的就是主干了。&lt;/p&gt;

&lt;p&gt;注意，主干“I eat apples” 本身就是一个语法正确的句子，它满足所有的语法规则。于是你理解了它在说“我吃苹果”。然后你逐渐加上细节，知道是什么样的苹果，从哪里买来的，什么时候吃。&lt;/p&gt;

&lt;p&gt;漏掉或者误解了细节，你可能会误解一部分意思，但抓住了主干，你就不会完全不理解这个句子在说什么。&lt;/p&gt;

&lt;p&gt;再次强调，每一个复杂的长句，里面都藏着一个非常短的，语法正确的短句。理解长句的关键，就在于找到这个短句。&lt;/p&gt;

&lt;p&gt;如何获得识别修饰成分，找到主干短句的能力，也在于你对具体的语法规则的理解。这些我们在稍后的章节介绍。&lt;/p&gt;

&lt;h3 id=&quot;如何培养真正的能力&quot;&gt;如何培养真正的能力&lt;/h3&gt;

&lt;p&gt;这一章我只是介绍了你需要的两种能力，可是如何培养这两种能力呢？其实它们两者是相辅相成的。造句的能力可以帮助你理解别人的句子，而阅读别人的句子，分析其结构，可以帮助你获得造出类似句子的能力。&lt;/p&gt;

&lt;p&gt;所以我给你开的处方是这样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;练习造句。每学一个动词，要用它造出多个句子来。这样你就获得对它的灵活运用的能力。&lt;/li&gt;
  &lt;li&gt;分析句子。看到一个复杂的句子，觉得理解有难度，你就把它抄下来。按照我介绍的“造句方法”，把它分解成主干和修饰成分。不久，你就会发现你的理解能力和造句能力都提高了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要注意的是，分析句子的时候，没有必要去纠结一个成分“叫什么”，对应什么术语。比如它是表语还是宾语，还是宾补…… 这没有意义。&lt;/p&gt;

&lt;p&gt;你可以理解任何英语句子，你可以成为很好的记者或者作家，却仍然不知道什么叫做“宾补”。你只需要造句的能力和理解句子的能力，而你不需要术语就能做到这两点。&lt;/p&gt;

&lt;p&gt;最后可能有人问，你这是提高实际的英语能力，可是我需要应付的是标准化的考试。这样做能行吗？当然行，而且你做语法题的速度会非常快。没有考试题目会要求你“找出句子里的宾补成分来”。实际上，题目里不可能出现“宾补”这个词。他们只会在那个成分的位置留一个空，让你选择合适的内容填进去。也就是说，你不需要知道那个位置叫“宾补”，就能做对题。&lt;/p&gt;

&lt;p&gt;实际上，做题的时候，你的头脑里根本不应该出现“宾补”这样的术语。具有了真正的英语能力，做语法选择题的时候，你会一眼就选对正确的答案，却说不出这道题在考你哪方面的能力。是时态呢，还是某种句子成分？我不知道，因为那毫无意义，关键是我做对了题目！我就是感觉其它答案都不“顺口”，我根本不会写那样的句子，而正确的选项一眼看起来就是“通的”。&lt;/p&gt;

&lt;p&gt;所以不管是实际的交流还是做题，死抠语法术语都没有什么意义。你去问问每一个英国人，美国人，他们是怎么做对语法题的，你会得到同样的答案。这本书就是要帮助你得到这种母语级别的能力，而不是一些纸上谈兵的术语。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-11-24-grammar-chapter1</guid>
<pubDate>Sat, 24 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>解谜英语语法</title>
<link>https://henix.github.io/feeds/yinwang/2018-11-23-grammar.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/11/23/grammar&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;王垠英语语法（前言）&lt;/h2&gt;
            &lt;h3 id=&quot;封二&quot;&gt;封二&lt;/h3&gt;

&lt;div style=&quot;text-align: right&quot;&gt;—献给 Daisy&lt;/div&gt;

&lt;h3 id=&quot;起因&quot;&gt;起因&lt;/h3&gt;

&lt;p&gt;这是一本独特的语法书。它的作者既不是专业英语教师，也不是语言学家，而是一个程序语言研究者。&lt;/p&gt;

&lt;p&gt;师从世界顶尖的程序语言专家，他钻研过世界上最美最强大的程序语言，他洞察过艰深古怪的逻辑学。现在，他认为程序语言和逻辑是已攻克的目标，山下的风景。&lt;/p&gt;

&lt;p&gt;对程序语言和逻辑的深刻理解，不但让他成为了更好的程序员，而且加深了他对自然语言（特别是英语）的理解。许多年来，他一直利用自己独到的方式来理解和使用英语。英语在他的头脑里有着跟常人很不一样的画面。对他而言，英语语法是如此的简单，琢磨起来趣味盎然。&lt;/p&gt;

&lt;p&gt;可是回国之后，他发现身边的朋友仍然在为语法的枯燥繁复而头痛，所以他萌生了写这样一本书的念头。他想把自己的英语如此流畅的秘密告诉世人，帮助那些正在为学习语法而痛苦挣扎的人们。&lt;/p&gt;

&lt;h3 id=&quot;语法书为什么枯燥难懂&quot;&gt;语法书为什么枯燥难懂&lt;/h3&gt;

&lt;p&gt;在我看来，普通语法书难懂的原因很简单：世代相传的照本宣科。语法书往往是包罗万象，“系统”地列出各种概念：名词，代词，动词，形容词，副词，句子成分，各种从句…… 洋洋洒洒上千页纸。不仅中国人写的语法书是这样，外国人写的语法书也这样。&lt;/p&gt;

&lt;p&gt;只见树木不见森林。这样的书缺乏“活知识”，到用的时候就想不起来，只能作为字典，需要的时候来查。所以很多人学了这些大部头语法书，照样写不出像样的句子来。时间充裕的写作都没法写好，面对外国人的时候进行快速的对话，就更加困难。&lt;/p&gt;

&lt;p&gt;看普通的语法书，学生被各种术语淹没：及物动词，不及物动词，表语，宾语补足语…… 想学会这些术语，却发现头脑在不断地碰壁。&lt;/p&gt;

&lt;p&gt;这就好像几百年前，人们认为地是一个平面，而天是一个穹顶，于是他们无法解释自己观察到的很多现象。过了好久才有人意识到问题的根源：地球是圆的。&lt;/p&gt;

&lt;p&gt;从现代程序语言理论的角度看来，英语语法里的很多术语和概念，其实是子虚乌有的，或者非常不准确的，就像当年的“地平说”一样。这些概念来源于早期语言学家对于人类语言能力的不成熟理解。可惜，很多古老的概念被英语老师们一代传一代，成为了必修的教条。&lt;/p&gt;

&lt;p&gt;这些术语都是祖辈传下来的东西，普通英语老师也不知道它们是怎么产生的。如果离开了这些术语，他们就不知道如何讲述语法，于是只好照原样传下去。所以他们也就没办法接触到本质，不可能把事情变得简单。&lt;/p&gt;

&lt;p&gt;科学的发展史告诉我们，正确的理论往往是最简单的，有毛病的理论才会复杂不堪。从程序语言和逻辑学的观点看来，传统语言学留下的这些概念，很多都是有问题的。这就是为什么学语法那么复杂，那么头痛，那么枯燥。&lt;/p&gt;

&lt;h3 id=&quot;本书的方法&quot;&gt;本书的方法&lt;/h3&gt;

&lt;p&gt;跟几乎所有的语法书不同，这本书不只是传授给你现成的知识，它引导你从人本源的交流需求出发，从无到有把语法“重新发明”出来。如果只是把知识传授给你，你就成为知识的奴隶。但如果你自己发明了知识，你就成为了知识的主宰。所以“重新发明”会贯穿这本书的主线。&lt;/p&gt;

&lt;p&gt;要想重新发明语法，我们当然不能继续沿用现有的语法术语，否则我们就只有步前人的后尘。但如果碰巧遇到可以借用的，真正有用的术语，我们还是继续使用它们。&lt;/p&gt;

&lt;p&gt;因为这个原因，请不要对本书的“术语准确性”吹毛求疵。因为就像物理学家费曼的父亲告诉他的，最重要的不是一个东西“叫什么”，而是它“是什么”。&lt;/p&gt;

&lt;p&gt;这本书就是要告诉你语法是什么。你会成为语法的主人。&lt;/p&gt;

&lt;p&gt;另外，因为这本书不会试图做一本包罗万象的字典，所以你不能指望在里面找到所有你需要的内容。这本书会包含“精华”和“通用”的思想，还有一些常见的例子，但某些具体的情况，比如某个特定动词的用法，你可能还需要看看字典。&lt;/p&gt;

&lt;p&gt;本书的作用是，它让你翻开字典就能找到你需要的东西，并且理解如何使用它。一般的语法书自己就是字典，可惜很少有人能够理解和运用。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-11-23-grammar</guid>
<pubDate>Fri, 23 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>更新一下</title>
<link>https://henix.github.io/feeds/yinwang/2018-10-14-update.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/10/14/update&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;更新一下&lt;/h2&gt;
            &lt;p&gt;我好像正好半年没有写东西了。哦不，我其实写了一些。仔细看我的书的人可能发现，那第一章其实悄悄更新了很多次。但我意识到了问题，我似乎没有动力完成这本书。嗯，我似乎是一个以半途而废著称的人。我从来不觉得必须从头到尾做完什么，除非我一直认为那是正确的方向。&lt;/p&gt;

&lt;p&gt;首先的问题是，写作这本书起初并没有良好的动机。我的意思是，当初想写这本书是出于对现状的“不满”，或者说是：恨。相对于爱，恨不是一个好的动机。&lt;/p&gt;

&lt;p&gt;我的老师 Dan Friedman 写了那么多本“小人书”，每一本都精辟而深刻，专注于一个他当时热爱的主题：函数式编程，逻辑式编程，自动定理证明……&lt;/p&gt;

&lt;p&gt;跟他相比，我自愧不如，因为我的动机不是出于爱。心中的恨，让我很像 Anakin Skywalker。不管恨是如何产生的，如果任其发展，它将把我变成 Darth Vader。我不想成为 Darth Vader。&lt;/p&gt;

&lt;p&gt;动机错了，也就导致了写作这本书的各种困难：设定的目标太高太远，太过注重“精华”，太早的解释过于深刻的原理，语言也啰嗦不流畅，充满了带刺或者负面的字眼…… 我开始担心看了我的书的人会变成什么样子。&lt;/p&gt;

&lt;p&gt;我意识到理解一件事和教会别人这件事，是完全不同的难度。如果我不理解人的心理，我就不会成为一个好的老师。如果我的心灵不够清澈，我就写不出纯美的作品。&lt;/p&gt;

&lt;p&gt;更要命的是，我的生活里有各种似乎更加有趣而有益的事情。所以每次想要写书，马上就会有有趣的事情来打断我……&lt;/p&gt;

&lt;p&gt;因此，写书这个事就被我一拖再拖。我想先研究一下人的心理，我想成为更好的人。只有当我成为一个很好的人，看我的书的人才会成为更好的人。&lt;/p&gt;

&lt;p&gt;但我还不够好。&lt;/p&gt;

&lt;p&gt;*  *  *&lt;/p&gt;

&lt;p&gt;过去的几年我都太关心“教”别人什么东西，以老师自居。可是我最近发现，我最爱的事情其实是从别人那里“学”东西。我喜欢跟人聊天讨论，大大的多过自己看书。经常能体会到“听君一席话，胜读十年书”的道理。&lt;/p&gt;

&lt;p&gt;总之，这半年我就是在学各种新东西。从专家那里学，也从很普通的人那里学。从小说里，电影里，音乐里学。学技术，也学人文。学习和领悟让我快乐。比起把自己封闭在自己的领域和圈子里，写一本旨在“改变现状”的书，学习让我更加快乐。我有了新的朋友和同事，我这才感觉我不再是孤军奋战，感觉新的生活开始了。&lt;/p&gt;

&lt;p&gt;如果只是想教会别人东西，我仍然是原来的我。而从别人那里学东西，我就成为“升级版”的我。学习让我有了朋友，朋友让我心里充满了爱，只有爱才是我前进的动力。&lt;/p&gt;

&lt;p&gt;*  *  *&lt;/p&gt;

&lt;p&gt;过去的王垠，心中充满了批判，然而世界上有远比批判有效而有益的事情。批判难以达到改进世界的效果，我的价值不可能通过批判而得到实现，而且它会让我失去潜在的朋友。价值的实现只能通过把我的技能，通过友好而快乐的途径作用到现实世界，让世界变得更好。不好的方面应该被忘记，而不是花大力气去批判它们。&lt;/p&gt;

&lt;p&gt;过去的王垠，以“天才”自居，天天谈论技术，各种评判；而现在的王垠，更加重视友谊和人性，比较少评判事物。比起冰冷的技术，真心的朋友更加能让我快乐。我希望有更多的朋友，更少的敌人。&lt;/p&gt;

&lt;p&gt;有个朋友引用一句林徽因的诗来赞美我：“你是爱，是暖，是希望，你是人间的四月天。” 目前感觉言过其实，不过我会努力达到这个境界，嗯。&lt;/p&gt;

&lt;p&gt;除了技术，世界上还有那么多有趣而重要的东西：艺术，文学，音乐，美食…… 它们也越来越多的走进我的生活，让我成为一个更加丰富的人。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/les-miserables.jpg&quot; width=&quot;600&quot;&gt;&lt;/p&gt;

&lt;p&gt;我要感谢我的朋友们。真的朋友就像一面镜子，从你们我认识到了自己的问题，拓展了自己的视野。我会不断改进自己。&lt;/p&gt;

&lt;p&gt;我不想再做一个不接地气的神，我的心里对自己的能力没有 pride。我不再是“垠神”，也不要叫我“大神”了。与其让人们崇拜我，畏惧我，恭维我，我更愿意让他们发自内心地喜欢我。我欢迎各种形式的互相学习和交流合作。&lt;/p&gt;

&lt;p&gt;虽然不再继续写那本书，我肯定会写技术方面的博文，而且更新会比书频繁很多。写书让我犯困，几个月写不出来一章，还不如写点短的文章分享一下。所以不用为书遗憾，因为专注于一个主题的短文是更加有效而有价值的东西。&lt;/p&gt;

&lt;p&gt;上海是一个神奇的城市。这里有很多我喜欢的故事，是一个人杰地灵的地方。自从民国年代，许许多多的传奇故事发生在上海。我希望我在上海也有美好的故事。&lt;/p&gt;

&lt;p&gt;最后再次感谢大家的支持。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-10-14-update</guid>
<pubDate>Sun, 14 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>改变</title>
<link>https://henix.github.io/feeds/yinwang/2018-05-28-change.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/05/28/change&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;改变&lt;/h2&gt;
            &lt;p&gt;我最近对博客和微博作了一些调整，也有一段时间没有更新我的书。博客少了一些文章。我会继续写我的书，但我也有很多其它事情做，我需要限制使用电脑的时间。微博用户群的质量值得怀疑，所以微博不会再有“个人稀里糊涂式”的更新，而只用于发布“冠冕堂皇式”的新闻，新闻联播那种。&lt;/p&gt;

&lt;p&gt;由于在美国的工作给了我一些遗留的伤口，这一段时间最重要的用途，应该是用来修复和放松我的身心，而不是用来实现什么伟大目标或者拯救世界。我在中国的着陆并不是平稳的——实际上我着陆在沼泽里。经过了一年，我仍然在试图建立对国内环境和人的信任。我感觉自己像一个穿着宇宙服的外星人，有时候打开面罩透口气。还好，我终于遇到了一些可爱的人。&lt;/p&gt;

&lt;p&gt;名义上是天才，我的生活也跟真正的天才（比如梵高）一样，可以说是破碎的。不管怎样，这与我本来的价值是极不相称的。为了所谓的“真知”，我错过了许多普通人都有的幸福。我需要重新开始体验生活的美好，我不想和历史上的悲剧天才们一样。如果说我有一件有价值的东西，那就是我得到了心的自由。&lt;/p&gt;

&lt;p&gt;在过去的几年，我花费了太多精力来“关心人类”，这使我疲惫。社会有许多的问题，我所在的 IT 领域惨不忍睹，然而批判人性的丑恶不应该是我的职责。生活中总是有丑陋，猥琐，虚伪的人，然而他们应该被忽略，我应该关注那些美好的。把注意力放在批判上，让我白白浪费人生中最美好的时光。&lt;/p&gt;

&lt;p&gt;我不是超人。我没有精力来关心中东的战火，非洲的饥荒，欧洲和美国的恐袭…… 同样的，我没有精力来为 IT 业界的很多丑恶现象忧心。应该有人去帮助他们，但我大概不是那个人。我曾以为那是我应该做的事，我告诉 Dan Friedman 我在做一件拯救 IT 业的事情。他回复说：“我刚写了一本新书，绝妙无比！你把地址给我，我给你寄过去！We are family！” 我喜欢这样鸡同鸭讲的对话。&lt;/p&gt;

&lt;p&gt;当今社会并不是以前那样脆弱。很多事情我指出了也不会起作用，不说它也糟不到哪里去。大街上的小混混知道谁是王垠吗？不知道。同理，技术界的低等生物也不会在乎王垠说什么，虽然他们吸收的一些养料是王垠不知道什么时候排出去的…… 每个人有自己的圈子，我没必要也不可能去跟他们较量。&lt;/p&gt;

&lt;p&gt;我看到的只是一个领域的人，甚至不是他们的全部。稍微往外面一跳，就发现自己以为很重要的事情，在外人看来其实不知所谓，无关紧要。什么 AI，区块链，黑科技…… 出了它们的圈子，真没多少人在乎。吹嘘它们以及批判它们的人，都像傻子一样。&lt;/p&gt;

&lt;p&gt;很多人，不管他们是什么冠冕堂皇的头衔，应该像街头小混混一样被抛在脑后，被忽略，而不是被仔仔细细记录下来，进行深入的批判。这不是一个顶级人才应该做的事。所以停止批判他们，不是妥协，而是彻底的无视，一种井水不犯河水的“和睦相处”关系。虽然被它们咬过，但痛过之后，我不再关心海底有什么丑陋的虫子，我有自己的风景……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/orca1.jpg&quot; width=&quot;450&quot;&gt;&lt;/p&gt;

&lt;p&gt;“拯救人类”不是我的任务。上天赋予我的才华，应该被用到更有意义的地方。我的目标不是跟完全不在一个层次的人较真，而是发现跟我在一个层次的人。当然这里所谓的“层次”，不是通常意义上的社会等级，而是本质上的“人的质量”。就像 Emily Post 所谓的“Best Society”，它无关出身，财富，社会头衔，技术能力……&lt;/p&gt;

&lt;p&gt;世界是多元化的，每个人都有自己的角落，我会找到本来属于我的角落。从今天开始，不再关心人类，做一个幸福的人。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-05-28-change</guid>
<pubDate>Mon, 28 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>解谜计算机科学（1）</title>
<link>https://henix.github.io/feeds/yinwang/2018-04-13-csbook-chapter1.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/04/13/csbook-chapter1&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;解谜计算机科学（1）&lt;/h2&gt;
            &lt;h1 id=&quot;第一章---初识计算&quot;&gt;第一章 - 初识计算&lt;/h1&gt;

&lt;p&gt;（本书版权归王垠所有，禁止转载。请认准 yinwang.org 为唯一的阅读地址，以获得最近更新。）&lt;/p&gt;

&lt;p&gt;要掌握一个学科的精髓，不能从细枝末节开始。人脑的能力很大程度上受限于信念。一个人不相信自己的时候，他就做不到本来可能的事。信心是很重要的，信心却容易被挫败。如果只见树木不见森林，人会失去信心，以为要到猴年马月才能掌握一个学科。&lt;/p&gt;

&lt;p&gt;所以这本书不从“树木”开始，而是引导读者一起来探索这背后的“森林”。本书把计算机科学最根本的概念用浅显的例子解释，让读者领会到它们的本质。把这些概念稍作发展，你就得到逐渐完整的把握。你一开头就掌握着整个学科，而且一直掌握着它，只不过增添更多细节而已。这就像画画，先勾勒出轮廓，一遍遍的增加细节，日臻完善，却不失去对大局的把握。&lt;/p&gt;

&lt;p&gt;一般计算机专业的学生学了很多课程，可是直到毕业都没能回答一个基础问题：什么是计算？这一章会引导你去发现这个问题的答案。不要小看这基础的问题，它经常是解决现实问题的重要线索。世界上有太多不理解它的人，他们走了很多的弯路，掉进很多的坑，制造出过度复杂或者有漏洞的理论和技术。&lt;/p&gt;

&lt;p&gt;接下来，我们就来理解几个关键的概念，由此接触到计算的本质。&lt;/p&gt;

&lt;h3 id=&quot;自觉付费&quot;&gt;自觉付费&lt;/h3&gt;

&lt;p&gt;跟本书的前言不同，这一章的内容不是免费的。你如果想继续读下去，请自觉进行付费。你的付款将会支持这本书的继续写作和更新。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/csbook1-wechat-pay.jpg&quot; width=&quot;200&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/csbook1-alipay.jpg&quot; width=&quot;200&quot;&gt;&lt;/p&gt;

&lt;h3 id=&quot;手指算术&quot;&gt;手指算术&lt;/h3&gt;

&lt;p&gt;每个人都做过计算，只是大部分人都没有理解自己在做什么。回想一下幼儿园（大概四岁）的时候，妈妈问你：“帮我算一下，4+3 等于几？” 你掰了一会手指，回答：7。当你掰手指的时候，你自己就是一台简单的计算机。&lt;/p&gt;

&lt;p&gt;不要小看了这手指算术，它蕴含着深刻的原理。计算机科学植根于这类非常简单的过程，而不是复杂的高等数学。&lt;/p&gt;

&lt;p&gt;现在我们来回忆一下这个过程。这里应该有一段动画，但现阶段还没有。请你对每一步发挥一下想象力，增加点“画面感”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当妈妈问你“4+3 等于几”的时候，她是一个程序员，你是一台计算机。计算机得到程序员的输入：4，+，3。&lt;/li&gt;
  &lt;li&gt;听到妈妈的问题之后，你拿出两只手，左手伸出四个指头，右手伸出三个指头。&lt;/li&gt;
  &lt;li&gt;接着你开始自己的计算过程。一根根地数那些竖起来的手指，每数一根你就把它弯下去，表示它已经被数过了。你念道：“1，2，3，4，5，6，7。”&lt;/li&gt;
  &lt;li&gt;现在已经没有手指伸着，所以你把最后数到的那个数作为答案：7！整个计算过程就结束了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;符号和模型&quot;&gt;符号和模型&lt;/h3&gt;

&lt;p&gt;（这个概念太过深入，好像不适合出现在第一章，考虑去掉）&lt;/p&gt;

&lt;p&gt;这里的幼儿园手指算术包含着深刻的哲学问题，现在我们来初步体会一下这个问题。&lt;/p&gt;

&lt;p&gt;当妈妈说“帮我算 4+3”的时候，4，+，3，三个字符传到你耳朵里，它们都是符号（symbol）。符号是“表面”的东西：光是盯着“4”和“3”这两个阿拉伯数字的曲线，一个像旗子，一个像耳朵，你是不能做什么的。你需要先用脑子把它们转换成对应的“模型”（model）。这就是为什么你伸出两只手，一只手表示 4，另一只表示 3。&lt;/p&gt;

&lt;p&gt;这两只手的手势是“可操作”的。比如，你把左手再多弯曲一个手指，它就变成“3”。你再伸开一根手指，它就变成“5”。所以手指是一个相当好的机械模型，它是可以动，可操作的。把符号“4”和“3”转换成手指模型之后，你就可以开始计算了。&lt;/p&gt;

&lt;p&gt;你怎么知道“4”和“3”对应什么样的手指模型呢？因为妈妈以前教过你。十根手指，对应着 1 到 10 十个数。这就是为什么人都用十进制数做算术。&lt;/p&gt;

&lt;p&gt;我们现在没必要深究这个问题。我只是提示你，分清“符号”和“模型”是重要的。&lt;/p&gt;

&lt;h3 id=&quot;计算图&quot;&gt;计算图&lt;/h3&gt;

&lt;p&gt;在计算机领域，我们经常用一些抽象的图示来表达计算的过程，这样就能直观地看到信息的流动和转换。这种图示看起来是一些形状用箭头连接起来。我在这里把它叫做“计算图”。&lt;/p&gt;

&lt;p&gt;对于以上的手指算术 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，我们可以用下图来表示它：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/adder.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中的箭头表示信息的流动方向。说到“流动”，你可以想象一下水的流动。首先我们看到数字 4 和 3 流进了一个圆圈，圆圈里有一个“+”号。这个圆圈就是你，一个会做手指加法的小孩。妈妈给你两个数 4 和 3，你现在把它们加起来，得到 7 作为结果。&lt;/p&gt;

&lt;p&gt;注意圆圈的输入和输出方向是由箭头决定的，我们可以根据需要调整那些箭头的位置，只要箭头的连接关系和方向不变就行。它们不一定都是从左到右，也可能从右到左或者从上到下，但“出入关系”都一样：4 和 3 进去，结果 7 出来。比如它还可以是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/adder-topdown.png&quot; width=&quot;180&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们用带加号的圆圈表示一个“加法器”。顾名思义，加法器可以帮我们完成加法。在上个例子里，你就是一个加法器。我们也可以用其他装置作为加法器，比如一堆石头，一个算盘，某种电子线路…… 只要它能做加法就行。&lt;/p&gt;

&lt;p&gt;具体要怎么做加法，就像你具体如何掰手指，很多时候我们是不关心的，我们只需要知道这个东西能做加法就行。圆圈把具体的加法操作给“抽象化”了，这个蓝色的圆圈可以代表很多种东西。抽象（abstraction）是计算机科学至关重要的思维方法，它帮助我们进行高层面的思考，而不为细节所累。&lt;/p&gt;

&lt;h3 id=&quot;表达式&quot;&gt;表达式&lt;/h3&gt;

&lt;p&gt;计算机科学当然不止 4 + 3 这么简单，但它的基本元素确实是如此简单。我们可以创造出很复杂的系统，然而归根结底，它们只是在按某种顺序计算像 4 + 3 这样的东西。&lt;/p&gt;

&lt;p&gt;4 + 3 是一个很简单的表达式（expression）。你也许没听说过“表达式”这个词，但我们先不去定义它。我们先来看一个稍微复杂一些的表达式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个表达式比 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 多了一个运算，我们把它叫做“复合表达式”。这个表达式也可以用计算图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/add-mult.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;你知道它为什么是这个样子吗？它表示的意思是，先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，然后把结果（7）传送到一个“乘法器”，跟 2 相乘，得到最后的结果。那正好就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 这个表达式的含义，它的结果应该是 14。&lt;/p&gt;

&lt;p&gt;为什么要先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 呢？因为当我们看到乘法器 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * ...&lt;/code&gt; 的时候，其中一个输入（2）是已知的，而另外一个输入必须通过加法器的输出得到。加法器的结果是由 4 和 3 相加得到的，所以我们必须先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，然后才能与 2 相乘。&lt;/p&gt;

&lt;p&gt;小学的时候，你也许学过：“括号内的内容要先计算”。其实括号只是“符号层”的东西，它并不存在于计算图里面。我这里讲的“计算图”，其实才是本质的东西。数学的括号一类的东西，都只是表象，它们是符号或者叫“语法”。从某种意义上讲，计算图才是表达式的本质或者“模型”，而“2 * (4 + 3)”这串符号，只是对计算图的一种表示或者“编码”（coding）。&lt;/p&gt;

&lt;p&gt;这里我们再次体会到了“符号”和“模型”的差别。符号是对模型的“表示”或者“编码”。我们必须从符号得到模型，才能进行操作。这种从符号到模型的转换过程，在计算机科学里叫做“语法分析”（parsing）。我们会在后面的章节理解这个过程。&lt;/p&gt;

&lt;p&gt;我们现在来给表达式做一个初步的定义。这并不是完整的定义，但你应该试着理解这种定义的方式。稍后我们会逐渐补充这个定义，逐渐完善。&lt;/p&gt;

&lt;p&gt;定义（表达式）：&lt;strong&gt;表达式&lt;/strong&gt;可以是如下几种东西。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数字是一个表达式。比如 1，2，4，15，……&lt;/li&gt;
  &lt;li&gt;表达式 + 表达式。两个表达式相加，也是表达式。&lt;/li&gt;
  &lt;li&gt;表达式 - 表达式。两个表达式相减，也是表达式。&lt;/li&gt;
  &lt;li&gt;表达式 * 表达式。两个表达式相乘，也是表达式。&lt;/li&gt;
  &lt;li&gt;表达式 / 表达式。两个表达式相除，也是表达式。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意，由于我们之前讲过的符号和模型的差别，为了完全忠于我们的本质认识，这里的“表达式 + 表达式”虽然看起来是一串符号，它必须被想象成它所对应的模型。当你看到“表达式”的时候，你的脑子里应该浮现出它对应的计算图，而不是一串符号。这个计算图的画面大概是这个样子，其中左边的大方框里可以是任意两个表达式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/expression-graph.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;是不是感觉这个定义有点奇怪？因为在“表达式”的定义里，我们用到了“表达式”自己。这种定义叫做“递归定义”。所谓&lt;strong&gt;递归&lt;/strong&gt;（recursion），就是在一个东西的定义里引用这个东西自己。看上去很奇怪，好像绕回去了一样。递归是一个重要的概念，我们会在将来深入理解它。&lt;/p&gt;

&lt;p&gt;现在我们可以来验证一下，根据我们的定义，&lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 确实是一个表达式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先根据第一种形式，我们知道 4 是表达式，因为它是一个数字。3 也是表达式，因为它是一个数字。&lt;/li&gt;
  &lt;li&gt;所以  &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 是表达式，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 的左右都是表达式，它满足表达式定义的第二种形式。&lt;/li&gt;
  &lt;li&gt;所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 是表达式，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 的左右都是表达式，它满足表达式定义的第四种形式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;并行计算&quot;&gt;并行计算&lt;/h3&gt;

&lt;p&gt;考虑这样一个表达式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它对应一个什么样的计算图呢？大概是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/parallel.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果妈妈只有你一个小孩，你应该如何用手指算出它的结果呢？你大概有两种办法。&lt;/p&gt;

&lt;p&gt;第一种办法：先算出 4+3，结果是 7。然后算出 1+2，结果是 3。然后算 7*3，结果是 21。&lt;/p&gt;

&lt;p&gt;第二种办法：先算出 1+2，结果是 3。然后算出 4+3，结果是 7。然后算 7*3，结果是 21。&lt;/p&gt;

&lt;p&gt;注意到没有，你要么先算 4+3，要么先算 1+2，你不能同时算 4+3 和 1+2。为什么呢？因为你只有两只手，所以算 4+3 的时候你就没法算 1+2，反之也是这样。总之，你妈妈只有你一个加法器，所以一次只能做一个加法。&lt;/p&gt;

&lt;p&gt;现在假设你还有一个妹妹，她跟你差不多年纪，她也会手指算术。妈妈现在就多了一些办法来计算这个表达式。她可以这样做：让你算 4+3，不等你算完，马上让妹妹算 1+2。等到你们的结果（7 和 3）都出来之后，让你或者妹妹算 7*3。&lt;/p&gt;

&lt;p&gt;发现没有，在某一段时间之内，你和妹妹&lt;em&gt;同时&lt;/em&gt;在做加法计算。这种时间上重叠的计算，叫做&lt;strong&gt;并行计算&lt;/strong&gt;（parallel computing）。&lt;/p&gt;

&lt;p&gt;你和妹妹同时计算，得到结果的速度可能会比你一个人算更快。如果你妈妈还有其它几个孩子，计算复杂的式子就可能快很多，这就是并行计算潜在的好处。所谓“潜在”的意思是，这种好处不一定会实现。比如，如果你的妹妹做手指算数的速度比你慢很多，你做完了 4+3，只好等着她慢慢的算 1+2。这也许比你自己依次算 4+3 和 1+2 还要慢。&lt;/p&gt;

&lt;p&gt;即使妹妹做算术跟你一样快，这里还有个问题。你和妹妹算出结果 7 和 3 之后，得把结果传递给下一个计算 7*3 的那个人（也许是你，也许是你妹妹）。这种“通信”会带来时间的延迟，叫做“通信开销”。如果你们其中一个说话慢，这比起一个人来做计算可能还要慢。&lt;/p&gt;

&lt;p&gt;如何根据计算单元能力的不同和通信开销的差异，来最大化计算的效率，降低需要的时间，就成为了并行计算领域研究的内容。并行计算虽然看起来是一个“博大精深”的领域，可是你如果理解了我这里说的那点东西，就很容易理解其余的内容。&lt;/p&gt;

&lt;h3 id=&quot;变量和赋值&quot;&gt;变量和赋值&lt;/h3&gt;

&lt;p&gt;如果你有一个复杂的表达式，比如&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于它有比较多的嵌套，人的眼睛是难以看清楚的，它要表达的意义也会难懂。这时候，你希望可以用一些“名字”来代表中间结果，这样表达式就更容易理解。&lt;/p&gt;

&lt;p&gt;打个比方，这就像你有一个亲戚，他是你妈妈的表姐的女儿的丈夫。你不想每次都称他“我妈妈的表姐的女儿的丈夫”，所以你就用他的名字“叮当”来指代他，一下子就简单了。&lt;/p&gt;

&lt;p&gt;我们来看一个例子。之前的复合表达式&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实可以被转换为等价的，含有变量的代码：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 变量 a 得到 4+3 的值
&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// 代码块的值
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 是一个名字。&lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt; 是一个“赋值语句”，它的意思是：用 a 来代表 4 + 3 的值。这种名字，计算机术语叫做&lt;strong&gt;变量&lt;/strong&gt;（variable）。&lt;/p&gt;

&lt;p&gt;这段代码的意思可以简单地描述为：计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，把它的结果表示为 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，然后计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; 作为最后的结果。&lt;/p&gt;

&lt;p&gt;有些东西可能扰乱了你的视线。两根斜杠 &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt; 后面一直到行末的文字叫做“注释”，是给人看的说明文字。它们对代码的逻辑不产生作用，执行的时候可以忽略。许多语言都有类似这种注释，它们可以帮助阅读的人，但是会被机器忽略。&lt;/p&gt;

&lt;p&gt;这段代码执行过程会是这样：先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 得到 7，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 记住这个中间结果 7。接着计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; ，也就是计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * 7&lt;/code&gt;，所以最后结果是 14。很显然，这跟 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 的结果是一样的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 叫做一个变量，它是一个符号，可以用来代表任意的值。除了 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，你还有许多的选择，比如 b, c, d, x, y, foo, bar, u21… 只要它不会被误解成其它东西就行。&lt;/p&gt;

&lt;p&gt;如果你觉得这里面的“神奇”成分太多，那我们现在来做更深一层的理解……&lt;/p&gt;

&lt;p&gt;再看一遍上面的代码。这整片代码叫做一个“代码块”（block），或者叫一个“序列”（sequence）。这个代码块包括两条语句，分别是 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt;。代码块里的语句会从上到下依次执行。所以我们先执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt;，然后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最后一条语句 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; 比较特别，它是这个代码块的“值”，也就是最后结果。之前的语句都是在为生成这个最后的值做准备。换句话说，这整个代码块的值就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; 的值。不光这个例子是这样，这是一个通用的原理：代码块的最后一条语句，总是这个代码块的值。&lt;/p&gt;

&lt;p&gt;我们在代码块的前后加上花括号 &lt;code class=&quot;highlighter-rouge&quot;&gt;{...}&lt;/code&gt; 进行标注，这样里面的语句就不会跟外面的代码混在一起。这两个花括号叫做“边界符”。我们今后会经常遇到代码块，它存在于几乎所有的程序语言里，只是语法稍有不同。比如有些语言可能用括号 &lt;code class=&quot;highlighter-rouge&quot;&gt;(...)&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;BEGIN...END&lt;/code&gt; 来表示边界，而不是用花括号。&lt;/p&gt;

&lt;p&gt;这片代码已经有点像常用的编程语言了，但我们暂时不把它具体化到某一种语言。我不想固化你的思维方式。在稍后的章节，我们会把这种抽象的表达法对应到几种常见的语言，这样一来你就能理解几乎所有的程序语言。&lt;/p&gt;

&lt;p&gt;另外还有一点需要注意，同一个变量可以被多次赋值。它的值会随着赋值语句而改变。举个例子：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码执行之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 的值是 7，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 的值是 10。你知道为什么吗？因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt; 之后，a 的值是 7。&lt;code class=&quot;highlighter-rouge&quot;&gt;b = a&lt;/code&gt; 使得 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 得到值 7。然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 2 * 5&lt;/code&gt; 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的值改变了，它现在是 10。所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;c = a&lt;/code&gt; 使得 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 得到 10。&lt;/p&gt;

&lt;p&gt;对同一个变量多次赋值虽然是可以的，但通常来说这不是一种好的写法，它可能引起程序的混淆，应该尽量避免。只有当变量表示的“意义”相同的时候，你才应该对它重复赋值。&lt;/p&gt;

&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;

&lt;p&gt;一旦引入了变量，我们就可以不用复合表达式。因为你可以把任意复杂的复合表达式拆开成“单操作算术表达式”（像 4 + 3 这样的），使用一些变量记住中间结果，一步一步算下去，得到最后的结果。&lt;/p&gt;

&lt;p&gt;举一个复杂点的例子，也就是这一节最开头的那个表达式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它可以被转化为一串语句：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后的表达式 &lt;code class=&quot;highlighter-rouge&quot;&gt;e * d&lt;/code&gt;，算出来就是原来的表达式的值。你观察一下，是不是每个操作都非常简单，不包含嵌套的复合表达式？你可以自己验算一下，它确实算出跟原表达式一样的结果。&lt;/p&gt;

&lt;p&gt;在这里，我们自己动手做了“编译器”（compiler）的工作。通常来说，编译器是一种程序，它的任务是把一片代码“翻译”成另外一种等价形式。这里我们没有写编译器，可是我们自己做了编译器的工作。我们手动地把一个嵌套的复合表达式，编译成了一系列的简单算术语句。&lt;/p&gt;

&lt;p&gt;这些语句的结果与原来的表达式完全一致。这种保留原来语义的翻译过程，叫做&lt;strong&gt;编译&lt;/strong&gt;（compile）。&lt;/p&gt;

&lt;p&gt;我们为什么需要编译呢？原因有好几种。我不想在这里做完整的解释，但从这个例子我们可以看到，编译之后我们就不再需要复杂的嵌套表达式了。我们只需要设计很简单的，只会做单操作算术的机器，就可以算出复杂的嵌套的表达式。实际上最后这段代码已经非常接近现代处理器（CPU）的汇编代码（assembly）。我们只需要多加一些转换，它就可以变成机器指令。&lt;/p&gt;

&lt;p&gt;我们暂时不写编译器，因为你还缺少一些必要的知识。这当然也不是编译技术的所有内容，它还包含另外一些东西。但从这一开头，你就已经初步理解了编译器是什么，你只需要在将来加深这种理解。&lt;/p&gt;

&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;

&lt;p&gt;到目前为止，我们做的计算都是在已知的数字之上，而在现实的计算中我们往往有一些未知数。比如我们想要表达一个“风扇控制器”，有了它之后，风扇的转速总是当前气温的两倍。这个“当前气温”就是一个未知数。&lt;/p&gt;

&lt;p&gt;我们的“风扇控制器”必须要有一个“输入”（input），用于得到当前的温度 t，它是一个温度传感器的读数。它还要有一个输出，就是温度的两倍。&lt;/p&gt;

&lt;p&gt;那么我们可以用这样的方式来表达我们的风扇控制器：&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不要把这想成任何一种程序语言，这只是我们自己的表达法。箭头 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; 的左边表示输入，右边表示输出，够简单吧。&lt;/p&gt;

&lt;p&gt;你可以把 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 想象成从温度传感器出来的一根电线，它连接到风扇控制器上，风扇控制器会把它的输入（t）乘以 2。这个画面像这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/function1.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们谈论风扇控制器的时候，其实不关心它的输入是哪里来的，输出到哪里去。如果我们把温度传感器和风扇从画面里拿掉，就变成这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/function2.jpg&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;这幅图才是你需要认真理解的函数的计算图。你发现了吗，这幅图画正好对应了之前的风扇控制器的符号表示：&lt;code class=&quot;highlighter-rouge&quot;&gt;t -&amp;gt; t*2&lt;/code&gt;。看到符号就想象出画面，你就得到了符号背后的模型。&lt;/p&gt;

&lt;p&gt;像 &lt;code class=&quot;highlighter-rouge&quot;&gt;t -&amp;gt; t*2&lt;/code&gt; 这样具有未知数作为输入的构造，我们把它叫做函数（function）。其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 这个符号，叫做这个函数的参数。&lt;/p&gt;

&lt;h3 id=&quot;参数变量和电线&quot;&gt;参数，变量和电线&lt;/h3&gt;

&lt;p&gt;你可能发现了，函数的参数和我们之前了解的“变量”是很类似的，它们都是一个符号。之前我们用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b, c, d, e&lt;/code&gt; 现在我们有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;，这些名字我们都是随便起的，只要它们不要重复就好。如果名字重复的话，可能会带来混淆和干扰。&lt;/p&gt;

&lt;p&gt;其实参数和变量这两种概念不只是相似，它们的本质就是一样的。如果你深刻理解它们的相同本质，你的脑子就可以少记忆很多东西，而且它可能帮助你对代码做出一些有趣而有益的转化。在上一节你已经看到，我用“电线”作为比方来帮助你理解参数。你也可以用同样的方法来理解变量。&lt;/p&gt;

&lt;p&gt;比如我们之前的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它可以被想象成什么样的画面呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/wire.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;我故意把箭头方向画成从右往左，这样它就更像上面的代码。从这个图画里，你也许可以看到变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 和风扇控制器图里的参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;，其实没有任何本质差别。它们都表示一根电线，那根电线进入乘法器，将会被乘以 2，然后输出。如果你把这些都看成是电路，那么变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 和参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 都代表一根电线而已。&lt;/p&gt;

&lt;p&gt;然后你还发现一个现象，那就是你可以把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 这个名字换成任何其它名字（比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;），而这幅图不会产生实质的改变。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/rename.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;这说明什么问题呢？这说明以下的代码（把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 换成了 &lt;code class=&quot;highlighter-rouge&quot;&gt;b）&lt;/code&gt;跟之前的是等价的：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据几乎一样的电线命名变化，你也可以对之前的函数得到一样的结论：&lt;code class=&quot;highlighter-rouge&quot;&gt;t -&amp;gt; t*2&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;u -&amp;gt; u*2&lt;/code&gt;，和 &lt;code class=&quot;highlighter-rouge&quot;&gt;x -&amp;gt; x*2&lt;/code&gt; 都是一回事。&lt;/p&gt;

&lt;p&gt;名字是很重要的东西，但它们具体叫什么，对于机器并没有实质的意义，只要它们不要相互混淆就可以。但名字对于人是很重要的，因为人脑没有机器那么精确。不好的变量和参数名会导致代码难以理解，引起程序员的混乱和错误。所以通常说来，你需要给变量和参数起好的名字。&lt;/p&gt;

&lt;p&gt;什么样的名字好呢？我会在后面集中讲解。&lt;/p&gt;

&lt;h3 id=&quot;有名字的函数&quot;&gt;有名字的函数&lt;/h3&gt;

&lt;p&gt;既然变量可以代表“值”，那么一个自然的想法，就是让变量代表函数。所以就像我们可以写&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们似乎也应该可以写&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对的，你可以这么做。&lt;code class=&quot;highlighter-rouge&quot;&gt;f = t-&amp;gt;t*2&lt;/code&gt; 还有一个更加传统的写法，就像数学里的函数写法：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请仔细观察 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 的位置变化。我们在函数名字的右边写一对括号，在里面放上参数的名字。&lt;/p&gt;

&lt;p&gt;注意，你不可以只写&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你必须明确的指出函数的参数是什么，否则你就不会明白函数定义里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 是什么东西。明确指出 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 是一个“输入”，你才会知道它是函数的输入，是一个未知数，&lt;strong&gt;而不是在函数外面定义的其它变量&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这个看似简单的道理，很多数学家都不明白，所以他们经常这样写书：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有一个函数 y = x*2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是错误的，因为他没有明确指出“&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; 是函数 y 的参数”。如果这句话之前他们又定义过 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;，你就会疑惑这是不是之前那个 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;。很多人就是因为这些糊里糊涂的写法而看不懂数学书。这不怪他们，只怪数学家自己对于语言不严谨。&lt;/p&gt;

&lt;h3 id=&quot;函数调用&quot;&gt;函数调用&lt;/h3&gt;

&lt;p&gt;有了函数，我们可以给它起名字，可是我们怎么使用它的值呢？&lt;/p&gt;

&lt;p&gt;由于函数里面有未知数（参数），所以你必须告诉它这些未知数，它里面的代码才会执行，给你结果。比如之前的风扇控制器函数&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它需要一个温度作为输入，才会给你一个输出。于是你就这样给它一个输入：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你把输入写在函数名字后面的括号里。那么你就会得到输出：4。也就是说 &lt;code class=&quot;highlighter-rouge&quot;&gt;f(2)&lt;/code&gt; 的值是 4。&lt;/p&gt;

&lt;p&gt;如果你没有调用一个函数，函数体是不会被执行的。因为它不知道未知数是什么，所以什么事也做不了。那么我们定义函数的时候，比如&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当看到这个定义的时候，机器应该做什么呢？它只是记录下：有这么一个函数，它的参数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;，它需要计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;t*2&lt;/code&gt;，它的名字叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;。但是机器不会立即计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;t*2&lt;/code&gt;，因为它不知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 是多少。&lt;/p&gt;

&lt;h3 id=&quot;分支&quot;&gt;分支&lt;/h3&gt;

&lt;p&gt;直到现在，我们的代码都是从头到尾，闷头闷脑地执行，不问任何问题。我们缺少一种“问问题”的方法。比如，如果我想表达这样一个“食物选择器”：如果气温低于 22 度，就返回 “hotpot” 表示今天吃火锅，否则返回 “ice cream” 表示今天吃冰激凌。&lt;/p&gt;

&lt;p&gt;我们可以把它图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/branch.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;中间这种判断结构叫做“分支”（branching），它一般用菱形表示。为什么叫分支呢？你想象一下，代码就像一条小溪，平时它沿着一条路线流淌。当它遇到一个棱角分明的大石头，就分成两个支流，分开流淌。&lt;/p&gt;

&lt;p&gt;我们的判断条件 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 就像一块大石头，我们的“代码流”碰到它就会分开成两支，分别做不同的事情。跟溪流不同的是，这种分支不是随机的，而是根据条件来决定，而且分支之后只有一支继续执行，而另外一边不会被执行。&lt;/p&gt;

&lt;p&gt;我们现在看到的都是图形化表示的模型，为了书写方便，现在我们要从符号的层面来表示这个模型。我们需要一种符号表示法来表达分支，我们把它叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;（如果）。我们的饮料选择器代码可以这样写：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;&quot;hotpot&quot;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; 
     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;&quot;ice cream&quot;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它是一个函数，输入是一个温度。&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 后面的括号里放我们的判断条件。后面接着条件成立时执行的代码块，然后是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;，然后是条件不成立时执行的代码。它说：如果温度低于 22 度，我们就吃火锅，否则就吃冰激凌。&lt;/p&gt;

&lt;p&gt;其中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 是一个特殊的符号，它表示“否则”。看起来不知道为什么 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 要在那里？对的，它只是一个装饰品。我们已经有足够的表达力来分辨两个分支，不过有了 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 似乎更加好看一些。很多语言里面都有 else 这个标记词在那里，所以我也把它放在那里。&lt;/p&gt;

&lt;p&gt;这只是一个最简单的例子，其实那两个代码块里面不止可以写一条语句。你可以有任意多的语句，就像这样：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;hotpot&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ice cream&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码和之前是等价的，你知道为什么吗？&lt;/p&gt;

&lt;h3 id=&quot;字符串&quot;&gt;字符串&lt;/h3&gt;

&lt;p&gt;上面一节出现了一种我们之前没见过的东西，我为了简洁而没有介绍它。这两个分支的结果，也就是加上引号的 “hotpot” 和 “ice cream”，它们并不是数字，也不是其它语言构造，而是一种跟数字处于几乎同等地位的“数据类型”，叫做&lt;strong&gt;字符串&lt;/strong&gt;（string）。字符串是我们在计算机里面表示人类语言的基本数据类型。&lt;/p&gt;

&lt;p&gt;关于字符串，在这里我不想讲述更加细节的内容，我把对它的各种操作留到以后再讲，因为虽然字符串对于应用程序很重要，它却并不是计算机科学最关键最本质的内容。&lt;/p&gt;

&lt;p&gt;很多计算机书籍一开头就讲很多对字符串的操作，导致初学者费很大功夫去做很多打印字符串的练习，结果几个星期之后还没学到“函数”之类最根本的概念。这是非常可惜的。&lt;/p&gt;

&lt;h3 id=&quot;布尔值&quot;&gt;布尔值&lt;/h3&gt;

&lt;p&gt;我们之前的 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 语句的条件 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 其实也是一个表达式，它叫做“布尔表达式”。你可以把小于号 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 看成是跟加法一类的“操作符”。它的输入是两个数值，输出是一个“布尔值”。什么是布尔值呢？布尔值只有两个：true 和 false，也就是“真”和“假”。&lt;/p&gt;

&lt;p&gt;举个例子，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 的值是 15，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 是成立的，那么它的值就是 true。如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 的值是 23，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 就不成立，那么它的值就是 false。是不是很好理解呢？&lt;/p&gt;

&lt;p&gt;我们为什么需要“布尔值”这种东西呢？因为它的存在可以简化我们的思维。对于布尔值也有一些操作，这个我也不在这一章赘述，放到以后细讲。&lt;/p&gt;

&lt;h3 id=&quot;计算的要素&quot;&gt;计算的要素&lt;/h3&gt;

&lt;p&gt;好了，现在你已经掌握了计算机科学的几乎所有基本要素。每一个编程语言都包括这些构造：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基础的数值。比如整数，字符串，布尔值等。&lt;/li&gt;
  &lt;li&gt;表达式。包括基本的算术表达式，嵌套的表达式。&lt;/li&gt;
  &lt;li&gt;变量和赋值语句。&lt;/li&gt;
  &lt;li&gt;分支语句。&lt;/li&gt;
  &lt;li&gt;函数和函数调用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你也许可以感觉到，我是把这些构造按照“从小到大”的顺序排列的。这也许可以帮助你的理解。&lt;/p&gt;

&lt;p&gt;现在你可以回想一下你对它们的印象。每当学习一种新的语言或者系统，你只需要在里面找到对应的构造，而不需要从头学习。这就是掌握所有程序语言的秘诀。这就像学开车一样，一旦你掌握了油门，刹车，换挡器，方向盘，速度表的功能和用法，你就学会了开所有的汽车，不管它是什么型号的汽车。&lt;/p&gt;

&lt;p&gt;我们在这一章不仅理解了这些要素，而且为它们定义了一种我们自己的“语言”。显然这个语言只能在我们的头脑里运行，因为我们没有实现这个语言的系统。在后面的章节，我会逐渐的把我们这种语言映射到现有的多种语言里面，然后你就能掌握这些语言了。&lt;/p&gt;

&lt;p&gt;但是请不要以为掌握了语言就学会了编程或者学会了计算机科学。掌握语言就像学会了各种汽车部件的工作原理。几分钟之内，初学者就能让车子移动，转弯，停止。可是完了之后你还需要学习交通规则，你需要许许多多的实战练习和经验，掌握各种复杂情况下的策略，才能成为一个合格的驾驶员。如果你想成为赛车手，那就还需要很多倍的努力。&lt;/p&gt;

&lt;p&gt;但是请不要被我这些话吓到了，你没有那么多的竞争者。现在的情况是，世界上就没有很多合格的计算机科学驾驶员，更不要说把车开得流畅的赛车手。绝大部分的“程序员”连最基本的引擎，油门，刹车，方向盘的工作原理都不明白，思维方式就不对，所以根本没法独自上路，一上路就出车祸。很多人把过错归结在自己的车身上，以为换一辆车马上就能成为好的驾驶员。这是一种世界范围的计算机教育的失败。&lt;/p&gt;

&lt;p&gt;在后面的章节，我会引导你成为一个合格的驾驶员，随便拿一辆车就能开好。&lt;/p&gt;

&lt;h3 id=&quot;什么是计算&quot;&gt;什么是计算&lt;/h3&gt;

&lt;p&gt;现在你掌握了计算所需要的基本元素，可是什么是计算呢？我好像仍然没有告诉你。这是一个很哲学的问题，不同的人可能会告诉你不同的结果。我试图从最广义的角度来告诉你这个问题的答案。&lt;/p&gt;

&lt;p&gt;当你小时候用手指算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4+3&lt;/code&gt;，那是计算。如果后来你学会了打算盘，你用算盘算 4+3，那也是计算。后来你从我这里学到了表达式，变量，函数，调用，分支语句…… 在每一新的构造加入的过程中，你都在了解不同的计算。&lt;/p&gt;

&lt;p&gt;所以从最广义来讲，计算就是“机械化的信息处理”。所谓机械化，你可以用手指算，可以用算盘，可以用计算器，或者计算机。这些机器里面可以有代码，也可以没有代码，全是电子线路，甚至可以是生物活动或者化学反应。不同的机器也可以有不同的计算功能，不同的速度和性能……&lt;/p&gt;

&lt;p&gt;有这么多种计算的事实不免让人困惑，总害怕少了点什么，其实你可以安心。如果你掌握了上一节的“计算要素”，那么你就掌握了几乎所有类型的计算系统所需要的东西。你在后面所需要做的只是加深这种理解，并且把它“对应”到现实世界遇到的各种计算机器里面。&lt;/p&gt;

&lt;p&gt;为什么你可以相信计算机科学的精华就只有这些呢？因为计算就是处理信息，信息有它诞生的位置（输入设备，固定数值），它传输的方式（赋值，函数调用，返回值），它被查看的地方（分支）。你想不出对于信息还有什么其它的操作，所以你就很安心的相信了，这就是计算机科学这种“棋类游戏”的全部规则。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-04-13-csbook-chapter1</guid>
<pubDate>Fri, 13 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>解谜计算机科学</title>
<link>https://henix.github.io/feeds/yinwang/2018-04-13-computer-science.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/04/13/computer-science&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;解谜计算机科学&lt;/h2&gt;
            &lt;p&gt;要掌握一个学科的精髓，不能从细枝末节开始。人脑的能力很大程度上受限于信念。一个人不相信自己的时候，他就做不到本来可能的事。信心是很重要的，信心却容易被挫败。如果只见树木不见森林，人会失去信心，以为要到猴年马月才能掌握一个学科。&lt;/p&gt;

&lt;p&gt;所以我们不从“树木”开始，而是引导读者一起来探索这背后的“森林”，把计算机科学最根本的概念用浅显的例子解释，让读者领会到它们的本质。把这些概念稍作发展，你就得到逐渐完整的把握。你一开头就掌握着整个学科，而且一直掌握着它，只不过增添更多细节而已。这就像画画，先勾勒出轮廓，一遍遍的增加细节，日臻完善，却不失去对大局的把握。&lt;/p&gt;

&lt;p&gt;一般计算机专业的学生学了很多课程，可是直到毕业都没能回答一个基础问题：什么是计算？这一章会引导你去发现这个问题的答案。不要小看这基础的问题，它经常是解决现实问题的重要线索。世界上有太多不理解它的人，他们走了很多的弯路，掉进很多的坑，制造出过度复杂或者有漏洞的理论和技术。&lt;/p&gt;

&lt;p&gt;接下来，我们就来理解几个关键的概念，由此接触到计算的本质。&lt;/p&gt;

&lt;h3 id=&quot;手指算术&quot;&gt;手指算术&lt;/h3&gt;

&lt;p&gt;每个人都做过计算，只是大部分人都没有理解自己在做什么。回想一下幼儿园（大概四岁）的时候，妈妈问你：“帮我算一下，4+3 等于几？” 你掰了一会手指，回答：7。当你掰手指的时候，你自己就是一台简单的计算机。&lt;/p&gt;

&lt;p&gt;不要小看了这手指算术，它蕴含着深刻的原理。计算机科学植根于这类非常简单的过程，而不是复杂的高等数学。&lt;/p&gt;

&lt;p&gt;现在我们来回忆一下这个过程。这里应该有一段动画，但现阶段还没有。请你对每一步发挥一下想象力，增加点“画面感”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当妈妈问你“4+3 等于几”的时候，她是一个程序员，你是一台计算机。计算机得到程序员的输入：4，+，3。&lt;/li&gt;
  &lt;li&gt;听到妈妈的问题之后，你拿出两只手，左手伸出四个指头，右手伸出三个指头。&lt;/li&gt;
  &lt;li&gt;接着你开始自己的计算过程。一根根地数那些竖起来的手指，每数一根你就把它弯下去，表示它已经被数过了。你念道：“1，2，3，4，5，6，7。”&lt;/li&gt;
  &lt;li&gt;现在已经没有手指伸着，所以你把最后数到的那个数作为答案：7！整个计算过程就结束了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;符号和模型&quot;&gt;符号和模型&lt;/h3&gt;

&lt;p&gt;（这个概念太过深入，好像不适合出现在第一章，考虑去掉）&lt;/p&gt;

&lt;p&gt;这里的幼儿园手指算术包含着深刻的哲学问题，现在我们来初步体会一下这个问题。&lt;/p&gt;

&lt;p&gt;当妈妈说“帮我算 4+3”的时候，4，+，3，三个字符传到你耳朵里，它们都是符号（symbol）。符号是“表面”的东西：光是盯着“4”和“3”这两个阿拉伯数字的曲线，一个像旗子，一个像耳朵，你是不能做什么的。你需要先用脑子把它们转换成对应的“模型”（model）。这就是为什么你伸出两只手，一只手表示 4，另一只表示 3。&lt;/p&gt;

&lt;p&gt;这两只手的手势是“可操作”的。比如，你把左手再多弯曲一个手指，它就变成“3”。你再伸开一根手指，它就变成“5”。所以手指是一个相当好的机械模型，它是可以动，可操作的。把符号“4”和“3”转换成手指模型之后，你就可以开始计算了。&lt;/p&gt;

&lt;p&gt;你怎么知道“4”和“3”对应什么样的手指模型呢？因为妈妈以前教过你。十根手指，对应着 1 到 10 十个数。这就是为什么人都用十进制数做算术。&lt;/p&gt;

&lt;p&gt;我们现在没必要深究这个问题。我只是提示你，分清“符号”和“模型”是重要的。&lt;/p&gt;

&lt;h3 id=&quot;计算图&quot;&gt;计算图&lt;/h3&gt;

&lt;p&gt;在计算机领域，我们经常用一些抽象的图示来表达计算的过程，这样就能直观地看到信息的流动和转换。这种图示看起来是一些形状用箭头连接起来。我在这里把它叫做“计算图”。&lt;/p&gt;

&lt;p&gt;对于以上的手指算术 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，我们可以用下图来表示它：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/adder.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中的箭头表示信息的流动方向。说到“流动”，你可以想象一下水的流动。首先我们看到数字 4 和 3 流进了一个圆圈，圆圈里有一个“+”号。这个圆圈就是你，一个会做手指加法的小孩。妈妈给你两个数 4 和 3，你现在把它们加起来，得到 7 作为结果。&lt;/p&gt;

&lt;p&gt;注意圆圈的输入和输出方向是由箭头决定的，我们可以根据需要调整那些箭头的位置，只要箭头的连接关系和方向不变就行。它们不一定都是从左到右，也可能从右到左或者从上到下，但“出入关系”都一样：4 和 3 进去，结果 7 出来。比如它还可以是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/adder-topdown.png&quot; width=&quot;180&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们用带加号的圆圈表示一个“加法器”。顾名思义，加法器可以帮我们完成加法。在上个例子里，你就是一个加法器。我们也可以用其他装置作为加法器，比如一堆石头，一个算盘，某种电子线路…… 只要它能做加法就行。&lt;/p&gt;

&lt;p&gt;具体要怎么做加法，就像你具体如何掰手指，很多时候我们是不关心的，我们只需要知道这个东西能做加法就行。圆圈把具体的加法操作给“抽象化”了，这个蓝色的圆圈可以代表很多种东西。抽象（abstraction）是计算机科学至关重要的思维方法，它帮助我们进行高层面的思考，而不为细节所累。&lt;/p&gt;

&lt;h3 id=&quot;表达式&quot;&gt;表达式&lt;/h3&gt;

&lt;p&gt;计算机科学当然不止 4 + 3 这么简单，但它的基本元素确实是如此简单。我们可以创造出很复杂的系统，然而归根结底，它们只是在按某种顺序计算像 4 + 3 这样的东西。&lt;/p&gt;

&lt;p&gt;4 + 3 是一个很简单的表达式（expression）。你也许没听说过“表达式”这个词，但我们先不去定义它。我们先来看一个稍微复杂一些的表达式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个表达式比 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 多了一个运算，我们把它叫做“复合表达式”。这个表达式也可以用计算图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/add-mult.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;你知道它为什么是这个样子吗？它表示的意思是，先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，然后把结果（7）传送到一个“乘法器”，跟 2 相乘，得到最后的结果。那正好就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 这个表达式的含义，它的结果应该是 14。&lt;/p&gt;

&lt;p&gt;为什么要先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 呢？因为当我们看到乘法器 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * ...&lt;/code&gt; 的时候，其中一个输入（2）是已知的，而另外一个输入必须通过加法器的输出得到。加法器的结果是由 4 和 3 相加得到的，所以我们必须先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，然后才能与 2 相乘。&lt;/p&gt;

&lt;p&gt;小学的时候，你也许学过：“括号内的内容要先计算”。其实括号只是“符号层”的东西，它并不存在于计算图里面。我这里讲的“计算图”，其实才是本质的东西。数学的括号一类的东西，都只是表象，它们是符号或者叫“语法”。从某种意义上讲，计算图才是表达式的本质或者“模型”，而“2 * (4 + 3)”这串符号，只是对计算图的一种表示或者“编码”（coding）。&lt;/p&gt;

&lt;p&gt;这里我们再次体会到了“符号”和“模型”的差别。符号是对模型的“表示”或者“编码”。我们必须从符号得到模型，才能进行操作。这种从符号到模型的转换过程，在计算机科学里叫做“语法分析”（parsing）。我们会在后面的章节理解这个过程。&lt;/p&gt;

&lt;p&gt;我们现在来给表达式做一个初步的定义。这并不是完整的定义，但你应该试着理解这种定义的方式。稍后我们会逐渐补充这个定义，逐渐完善。&lt;/p&gt;

&lt;p&gt;定义（表达式）：&lt;strong&gt;表达式&lt;/strong&gt;可以是如下几种东西。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数字是一个表达式。比如 1，2，4，15，……&lt;/li&gt;
  &lt;li&gt;表达式 + 表达式。两个表达式相加，也是表达式。&lt;/li&gt;
  &lt;li&gt;表达式 - 表达式。两个表达式相减，也是表达式。&lt;/li&gt;
  &lt;li&gt;表达式 * 表达式。两个表达式相乘，也是表达式。&lt;/li&gt;
  &lt;li&gt;表达式 / 表达式。两个表达式相除，也是表达式。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意，由于我们之前讲过的符号和模型的差别，为了完全忠于我们的本质认识，这里的“表达式 + 表达式”虽然看起来是一串符号，它必须被想象成它所对应的模型。当你看到“表达式”的时候，你的脑子里应该浮现出它对应的计算图，而不是一串符号。这个计算图的画面大概是这个样子，其中左边的大方框里可以是任意两个表达式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/expression-graph.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;是不是感觉这个定义有点奇怪？因为在“表达式”的定义里，我们用到了“表达式”自己。这种定义叫做“递归定义”。所谓&lt;strong&gt;递归&lt;/strong&gt;（recursion），就是在一个东西的定义里引用这个东西自己。看上去很奇怪，好像绕回去了一样。递归是一个重要的概念，我们会在将来深入理解它。&lt;/p&gt;

&lt;p&gt;现在我们可以来验证一下，根据我们的定义，&lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 确实是一个表达式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先根据第一种形式，我们知道 4 是表达式，因为它是一个数字。3 也是表达式，因为它是一个数字。&lt;/li&gt;
  &lt;li&gt;所以  &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 是表达式，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 的左右都是表达式，它满足表达式定义的第二种形式。&lt;/li&gt;
  &lt;li&gt;所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 是表达式，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 的左右都是表达式，它满足表达式定义的第四种形式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;并行计算&quot;&gt;并行计算&lt;/h3&gt;

&lt;p&gt;考虑这样一个表达式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它对应一个什么样的计算图呢？大概是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/parallel.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果妈妈只有你一个小孩，你应该如何用手指算出它的结果呢？你大概有两种办法。&lt;/p&gt;

&lt;p&gt;第一种办法：先算出 4+3，结果是 7。然后算出 1+2，结果是 3。然后算 7*3，结果是 21。&lt;/p&gt;

&lt;p&gt;第二种办法：先算出 1+2，结果是 3。然后算出 4+3，结果是 7。然后算 7*3，结果是 21。&lt;/p&gt;

&lt;p&gt;注意到没有，你要么先算 4+3，要么先算 1+2，你不能同时算 4+3 和 1+2。为什么呢？因为你只有两只手，所以算 4+3 的时候你就没法算 1+2，反之也是这样。总之，你妈妈只有你一个加法器，所以一次只能做一个加法。&lt;/p&gt;

&lt;p&gt;现在假设你还有一个妹妹，她跟你差不多年纪，她也会手指算术。妈妈现在就多了一些办法来计算这个表达式。她可以这样做：让你算 4+3，不等你算完，马上让妹妹算 1+2。等到你们的结果（7 和 3）都出来之后，让你或者妹妹算 7*3。&lt;/p&gt;

&lt;p&gt;发现没有，在某一段时间之内，你和妹妹&lt;em&gt;同时&lt;/em&gt;在做加法计算。这种时间上重叠的计算，叫做&lt;strong&gt;并行计算&lt;/strong&gt;（parallel computing）。&lt;/p&gt;

&lt;p&gt;你和妹妹同时计算，得到结果的速度可能会比你一个人算更快。如果你妈妈还有其它几个孩子，计算复杂的式子就可能快很多，这就是并行计算潜在的好处。所谓“潜在”的意思是，这种好处不一定会实现。比如，如果你的妹妹做手指算数的速度比你慢很多，你做完了 4+3，只好等着她慢慢的算 1+2。这也许比你自己依次算 4+3 和 1+2 还要慢。&lt;/p&gt;

&lt;p&gt;即使妹妹做算术跟你一样快，这里还有个问题。你和妹妹算出结果 7 和 3 之后，得把结果传递给下一个计算 7*3 的那个人（也许是你，也许是你妹妹）。这种“通信”会带来时间的延迟，叫做“通信开销”。如果你们其中一个说话慢，这比起一个人来做计算可能还要慢。&lt;/p&gt;

&lt;p&gt;如何根据计算单元能力的不同和通信开销的差异，来最大化计算的效率，降低需要的时间，就成为了并行计算领域研究的内容。并行计算虽然看起来是一个“博大精深”的领域，可是你如果理解了我这里说的那点东西，就很容易理解其余的内容。&lt;/p&gt;

&lt;h3 id=&quot;变量和赋值&quot;&gt;变量和赋值&lt;/h3&gt;

&lt;p&gt;如果你有一个复杂的表达式，比如&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于它有比较多的嵌套，人的眼睛是难以看清楚的，它要表达的意义也会难懂。这时候，你希望可以用一些“名字”来代表中间结果，这样表达式就更容易理解。&lt;/p&gt;

&lt;p&gt;打个比方，这就像你有一个亲戚，他是你妈妈的表姐的女儿的丈夫。你不想每次都称他“我妈妈的表姐的女儿的丈夫”，所以你就用他的名字“叮当”来指代他，一下子就简单了。&lt;/p&gt;

&lt;p&gt;我们来看一个例子。之前的复合表达式&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实可以被转换为等价的，含有变量的代码：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 变量 a 得到 4+3 的值
&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// 代码块的值
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 是一个名字。&lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt; 是一个“赋值语句”，它的意思是：用 a 来代表 4 + 3 的值。这种名字，计算机术语叫做&lt;strong&gt;变量&lt;/strong&gt;（variable）。&lt;/p&gt;

&lt;p&gt;这段代码的意思可以简单地描述为：计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，把它的结果表示为 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，然后计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; 作为最后的结果。&lt;/p&gt;

&lt;p&gt;有些东西可能扰乱了你的视线。两根斜杠 &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt; 后面一直到行末的文字叫做“注释”，是给人看的说明文字。它们对代码的逻辑不产生作用，执行的时候可以忽略。许多语言都有类似这种注释，它们可以帮助阅读的人，但是会被机器忽略。&lt;/p&gt;

&lt;p&gt;这段代码执行过程会是这样：先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 得到 7，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 记住这个中间结果 7。接着计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; ，也就是计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * 7&lt;/code&gt;，所以最后结果是 14。很显然，这跟 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 的结果是一样的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 叫做一个变量，它是一个符号，可以用来代表任意的值。除了 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，你还有许多的选择，比如 b, c, d, x, y, foo, bar, u21… 只要它不会被误解成其它东西就行。&lt;/p&gt;

&lt;p&gt;如果你觉得这里面的“神奇”成分太多，那我们现在来做更深一层的理解……&lt;/p&gt;

&lt;p&gt;再看一遍上面的代码。这整片代码叫做一个“代码块”（block），或者叫一个“序列”（sequence）。这个代码块包括两条语句，分别是 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt;。代码块里的语句会从上到下依次执行。所以我们先执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt;，然后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最后一条语句 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; 比较特别，它是这个代码块的“值”，也就是最后结果。之前的语句都是在为生成这个最后的值做准备。换句话说，这整个代码块的值就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; 的值。不光这个例子是这样，这是一个通用的原理：代码块的最后一条语句，总是这个代码块的值。&lt;/p&gt;

&lt;p&gt;我们在代码块的前后加上花括号 &lt;code class=&quot;highlighter-rouge&quot;&gt;{...}&lt;/code&gt; 进行标注，这样里面的语句就不会跟外面的代码混在一起。这两个花括号叫做“边界符”。我们今后会经常遇到代码块，它存在于几乎所有的程序语言里，只是语法稍有不同。比如有些语言可能用括号 &lt;code class=&quot;highlighter-rouge&quot;&gt;(...)&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;BEGIN...END&lt;/code&gt; 来表示边界，而不是用花括号。&lt;/p&gt;

&lt;p&gt;这片代码已经有点像常用的编程语言了，但我们暂时不把它具体化到某一种语言。我不想固化你的思维方式。在稍后的章节，我们会把这种抽象的表达法对应到几种常见的语言，这样一来你就能理解几乎所有的程序语言。&lt;/p&gt;

&lt;p&gt;另外还有一点需要注意，同一个变量可以被多次赋值。它的值会随着赋值语句而改变。举个例子：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码执行之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 的值是 7，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 的值是 10。你知道为什么吗？因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt; 之后，a 的值是 7。&lt;code class=&quot;highlighter-rouge&quot;&gt;b = a&lt;/code&gt; 使得 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 得到值 7。然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 2 * 5&lt;/code&gt; 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的值改变了，它现在是 10。所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;c = a&lt;/code&gt; 使得 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 得到 10。&lt;/p&gt;

&lt;p&gt;对同一个变量多次赋值虽然是可以的，但通常来说这不是一种好的写法，它可能引起程序的混淆，应该尽量避免。只有当变量表示的“意义”相同的时候，你才应该对它重复赋值。&lt;/p&gt;

&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;

&lt;p&gt;一旦引入了变量，我们就可以不用复合表达式。因为你可以把任意复杂的复合表达式拆开成“单操作算术表达式”（像 4 + 3 这样的），使用一些变量记住中间结果，一步一步算下去，得到最后的结果。&lt;/p&gt;

&lt;p&gt;举一个复杂点的例子，也就是这一节最开头的那个表达式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它可以被转化为一串语句：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后的表达式 &lt;code class=&quot;highlighter-rouge&quot;&gt;e * d&lt;/code&gt;，算出来就是原来的表达式的值。你观察一下，是不是每个操作都非常简单，不包含嵌套的复合表达式？你可以自己验算一下，它确实算出跟原表达式一样的结果。&lt;/p&gt;

&lt;p&gt;在这里，我们自己动手做了“编译器”（compiler）的工作。通常来说，编译器是一种程序，它的任务是把一片代码“翻译”成另外一种等价形式。这里我们没有写编译器，可是我们自己做了编译器的工作。我们手动地把一个嵌套的复合表达式，编译成了一系列的简单算术语句。&lt;/p&gt;

&lt;p&gt;这些语句的结果与原来的表达式完全一致。这种保留原来语义的翻译过程，叫做&lt;strong&gt;编译&lt;/strong&gt;（compile）。&lt;/p&gt;

&lt;p&gt;我们为什么需要编译呢？原因有好几种。我不想在这里做完整的解释，但从这个例子我们可以看到，编译之后我们就不再需要复杂的嵌套表达式了。我们只需要设计很简单的，只会做单操作算术的机器，就可以算出复杂的嵌套的表达式。实际上最后这段代码已经非常接近现代处理器（CPU）的汇编代码（assembly）。我们只需要多加一些转换，它就可以变成机器指令。&lt;/p&gt;

&lt;p&gt;我们暂时不写编译器，因为你还缺少一些必要的知识。这当然也不是编译技术的所有内容，它还包含另外一些东西。但从这一开头，你就已经初步理解了编译器是什么，你只需要在将来加深这种理解。&lt;/p&gt;

&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;

&lt;p&gt;到目前为止，我们做的计算都是在已知的数字之上，而在现实的计算中我们往往有一些未知数。比如我们想要表达一个“风扇控制器”，有了它之后，风扇的转速总是当前气温的两倍。这个“当前气温”就是一个未知数。&lt;/p&gt;

&lt;p&gt;我们的“风扇控制器”必须要有一个“输入”（input），用于得到当前的温度 t，它是一个温度传感器的读数。它还要有一个输出，就是温度的两倍。&lt;/p&gt;

&lt;p&gt;那么我们可以用这样的方式来表达我们的风扇控制器：&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不要把这想成任何一种程序语言，这只是我们自己的表达法。箭头 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; 的左边表示输入，右边表示输出，够简单吧。&lt;/p&gt;

&lt;p&gt;你可以把 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 想象成从温度传感器出来的一根电线，它连接到风扇控制器上，风扇控制器会把它的输入（t）乘以 2。这个画面像这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/function1.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们谈论风扇控制器的时候，其实不关心它的输入是哪里来的，输出到哪里去。如果我们把温度传感器和风扇从画面里拿掉，就变成这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/function2.jpg&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;这幅图才是你需要认真理解的函数的计算图。你发现了吗，这幅图画正好对应了之前的风扇控制器的符号表示：&lt;code class=&quot;highlighter-rouge&quot;&gt;t -&amp;gt; t*2&lt;/code&gt;。看到符号就想象出画面，你就得到了符号背后的模型。&lt;/p&gt;

&lt;p&gt;像 &lt;code class=&quot;highlighter-rouge&quot;&gt;t -&amp;gt; t*2&lt;/code&gt; 这样具有未知数作为输入的构造，我们把它叫做函数（function）。其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 这个符号，叫做这个函数的参数。&lt;/p&gt;

&lt;h3 id=&quot;参数变量和电线&quot;&gt;参数，变量和电线&lt;/h3&gt;

&lt;p&gt;你可能发现了，函数的参数和我们之前了解的“变量”是很类似的，它们都是一个符号。之前我们用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b, c, d, e&lt;/code&gt; 现在我们有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;，这些名字我们都是随便起的，只要它们不要重复就好。如果名字重复的话，可能会带来混淆和干扰。&lt;/p&gt;

&lt;p&gt;其实参数和变量这两种概念不只是相似，它们的本质就是一样的。如果你深刻理解它们的相同本质，你的脑子就可以少记忆很多东西，而且它可能帮助你对代码做出一些有趣而有益的转化。在上一节你已经看到，我用“电线”作为比方来帮助你理解参数。你也可以用同样的方法来理解变量。&lt;/p&gt;

&lt;p&gt;比如我们之前的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它可以被想象成什么样的画面呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/wire.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;我故意把箭头方向画成从右往左，这样它就更像上面的代码。从这个图画里，你也许可以看到变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 和风扇控制器图里的参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;，其实没有任何本质差别。它们都表示一根电线，那根电线进入乘法器，将会被乘以 2，然后输出。如果你把这些都看成是电路，那么变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 和参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 都代表一根电线而已。&lt;/p&gt;

&lt;p&gt;然后你还发现一个现象，那就是你可以把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 这个名字换成任何其它名字（比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;），而这幅图不会产生实质的改变。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/rename.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;这说明什么问题呢？这说明以下的代码（把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 换成了 &lt;code class=&quot;highlighter-rouge&quot;&gt;b）&lt;/code&gt;跟之前的是等价的：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据几乎一样的电线命名变化，你也可以对之前的函数得到一样的结论：&lt;code class=&quot;highlighter-rouge&quot;&gt;t -&amp;gt; t*2&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;u -&amp;gt; u*2&lt;/code&gt;，和 &lt;code class=&quot;highlighter-rouge&quot;&gt;x -&amp;gt; x*2&lt;/code&gt; 都是一回事。&lt;/p&gt;

&lt;p&gt;名字是很重要的东西，但它们具体叫什么，对于机器并没有实质的意义，只要它们不要相互混淆就可以。但名字对于人是很重要的，因为人脑没有机器那么精确。不好的变量和参数名会导致代码难以理解，引起程序员的混乱和错误。所以通常说来，你需要给变量和参数起好的名字。&lt;/p&gt;

&lt;p&gt;什么样的名字好呢？我会在后面集中讲解。&lt;/p&gt;

&lt;h3 id=&quot;有名字的函数&quot;&gt;有名字的函数&lt;/h3&gt;

&lt;p&gt;既然变量可以代表“值”，那么一个自然的想法，就是让变量代表函数。所以就像我们可以写&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们似乎也应该可以写&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对的，你可以这么做。&lt;code class=&quot;highlighter-rouge&quot;&gt;f = t-&amp;gt;t*2&lt;/code&gt; 还有一个更加传统的写法，就像数学里的函数写法：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请仔细观察 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 的位置变化。我们在函数名字的右边写一对括号，在里面放上参数的名字。&lt;/p&gt;

&lt;p&gt;注意，你不可以只写&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你必须明确的指出函数的参数是什么，否则你就不会明白函数定义里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 是什么东西。明确指出 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 是一个“输入”，你才会知道它是函数的输入，是一个未知数，&lt;strong&gt;而不是在函数外面定义的其它变量&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这个看似简单的道理，很多数学家都不明白，所以他们经常这样写书：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有一个函数 y = x*2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是错误的，因为他没有明确指出“&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; 是函数 y 的参数”。如果这句话之前他们又定义过 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;，你就会疑惑这是不是之前那个 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;。很多人就是因为这些糊里糊涂的写法而看不懂数学书。这不怪他们，只怪数学家自己对于语言不严谨。&lt;/p&gt;

&lt;h3 id=&quot;函数调用&quot;&gt;函数调用&lt;/h3&gt;

&lt;p&gt;有了函数，我们可以给它起名字，可是我们怎么使用它的值呢？&lt;/p&gt;

&lt;p&gt;由于函数里面有未知数（参数），所以你必须告诉它这些未知数，它里面的代码才会执行，给你结果。比如之前的风扇控制器函数&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它需要一个温度作为输入，才会给你一个输出。于是你就这样给它一个输入：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你把输入写在函数名字后面的括号里。那么你就会得到输出：4。也就是说 &lt;code class=&quot;highlighter-rouge&quot;&gt;f(2)&lt;/code&gt; 的值是 4。&lt;/p&gt;

&lt;p&gt;如果你没有调用一个函数，函数体是不会被执行的。因为它不知道未知数是什么，所以什么事也做不了。那么我们定义函数的时候，比如&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当看到这个定义的时候，机器应该做什么呢？它只是记录下：有这么一个函数，它的参数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;，它需要计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;t*2&lt;/code&gt;，它的名字叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;。但是机器不会立即计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;t*2&lt;/code&gt;，因为它不知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 是多少。&lt;/p&gt;

&lt;h3 id=&quot;分支&quot;&gt;分支&lt;/h3&gt;

&lt;p&gt;直到现在，我们的代码都是从头到尾，闷头闷脑地执行，不问任何问题。我们缺少一种“问问题”的方法。比如，如果我想表达这样一个“食物选择器”：如果气温低于 22 度，就返回 “hotpot” 表示今天吃火锅，否则返回 “ice cream” 表示今天吃冰激凌。&lt;/p&gt;

&lt;p&gt;我们可以把它图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/branch.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;中间这种判断结构叫做“分支”（branching），它一般用菱形表示。为什么叫分支呢？你想象一下，代码就像一条小溪，平时它沿着一条路线流淌。当它遇到一个棱角分明的大石头，就分成两个支流，分开流淌。&lt;/p&gt;

&lt;p&gt;我们的判断条件 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 就像一块大石头，我们的“代码流”碰到它就会分开成两支，分别做不同的事情。跟溪流不同的是，这种分支不是随机的，而是根据条件来决定，而且分支之后只有一支继续执行，而另外一边不会被执行。&lt;/p&gt;

&lt;p&gt;我们现在看到的都是图形化表示的模型，为了书写方便，现在我们要从符号的层面来表示这个模型。我们需要一种符号表示法来表达分支，我们把它叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;（如果）。我们的饮料选择器代码可以这样写：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;&quot;hotpot&quot;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; 
     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;&quot;ice cream&quot;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它是一个函数，输入是一个温度。&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 后面的括号里放我们的判断条件。后面接着条件成立时执行的代码块，然后是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;，然后是条件不成立时执行的代码。它说：如果温度低于 22 度，我们就吃火锅，否则就吃冰激凌。&lt;/p&gt;

&lt;p&gt;其中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 是一个特殊的符号，它表示“否则”。看起来不知道为什么 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 要在那里？对的，它只是一个装饰品。我们已经有足够的表达力来分辨两个分支，不过有了 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 似乎更加好看一些。很多语言里面都有 else 这个标记词在那里，所以我也把它放在那里。&lt;/p&gt;

&lt;p&gt;这只是一个最简单的例子，其实那两个代码块里面不止可以写一条语句。你可以有任意多的语句，就像这样：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;hotpot&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ice cream&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码和之前是等价的，你知道为什么吗？&lt;/p&gt;

&lt;h3 id=&quot;字符串&quot;&gt;字符串&lt;/h3&gt;

&lt;p&gt;上面一节出现了一种我们之前没见过的东西，我为了简洁而没有介绍它。这两个分支的结果，也就是加上引号的 “hotpot” 和 “ice cream”，它们并不是数字，也不是其它语言构造，而是一种跟数字处于几乎同等地位的“数据类型”，叫做&lt;strong&gt;字符串&lt;/strong&gt;（string）。字符串是我们在计算机里面表示人类语言的基本数据类型。&lt;/p&gt;

&lt;p&gt;关于字符串，在这里我不想讲述更加细节的内容，我把对它的各种操作留到以后再讲，因为虽然字符串对于应用程序很重要，它却并不是计算机科学最关键最本质的内容。&lt;/p&gt;

&lt;p&gt;很多计算机书籍一开头就讲很多对字符串的操作，导致初学者费很大功夫去做很多打印字符串的练习，结果几个星期之后还没学到“函数”之类最根本的概念。这是非常可惜的。&lt;/p&gt;

&lt;h3 id=&quot;布尔值&quot;&gt;布尔值&lt;/h3&gt;

&lt;p&gt;我们之前的 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 语句的条件 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 其实也是一个表达式，它叫做“布尔表达式”。你可以把小于号 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 看成是跟加法一类的“操作符”。它的输入是两个数值，输出是一个“布尔值”。什么是布尔值呢？布尔值只有两个：true 和 false，也就是“真”和“假”。&lt;/p&gt;

&lt;p&gt;举个例子，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 的值是 15，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 是成立的，那么它的值就是 true。如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 的值是 23，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 就不成立，那么它的值就是 false。是不是很好理解呢？&lt;/p&gt;

&lt;p&gt;我们为什么需要“布尔值”这种东西呢？因为它的存在可以简化我们的思维。对于布尔值也有一些操作，这个我也不在这一章赘述，放到以后细讲。&lt;/p&gt;

&lt;h3 id=&quot;计算的要素&quot;&gt;计算的要素&lt;/h3&gt;

&lt;p&gt;好了，现在你已经掌握了计算机科学的几乎所有基本要素。每一个编程语言都包括这些构造：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基础的数值。比如整数，字符串，布尔值等。&lt;/li&gt;
  &lt;li&gt;表达式。包括基本的算术表达式，嵌套的表达式。&lt;/li&gt;
  &lt;li&gt;变量和赋值语句。&lt;/li&gt;
  &lt;li&gt;分支语句。&lt;/li&gt;
  &lt;li&gt;函数和函数调用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你也许可以感觉到，我是把这些构造按照“从小到大”的顺序排列的。这也许可以帮助你的理解。&lt;/p&gt;

&lt;p&gt;现在你可以回想一下你对它们的印象。每当学习一种新的语言或者系统，你只需要在里面找到对应的构造，而不需要从头学习。这就是掌握所有程序语言的秘诀。这就像学开车一样，一旦你掌握了油门，刹车，换挡器，方向盘，速度表的功能和用法，你就学会了开所有的汽车，不管它是什么型号的汽车。&lt;/p&gt;

&lt;p&gt;我们在这一章不仅理解了这些要素，而且为它们定义了一种我们自己的“语言”。显然这个语言只能在我们的头脑里运行，因为我们没有实现这个语言的系统。在后面的章节，我会逐渐的把我们这种语言映射到现有的多种语言里面，然后你就能掌握这些语言了。&lt;/p&gt;

&lt;p&gt;但是请不要以为掌握了语言就学会了编程或者学会了计算机科学。掌握语言就像学会了各种汽车部件的工作原理。几分钟之内，初学者就能让车子移动，转弯，停止。可是完了之后你还需要学习交通规则，你需要许许多多的实战练习和经验，掌握各种复杂情况下的策略，才能成为一个合格的驾驶员。如果你想成为赛车手，那就还需要很多倍的努力。&lt;/p&gt;

&lt;p&gt;但是请不要被我这些话吓到了，你没有那么多的竞争者。现在的情况是，世界上就没有很多合格的计算机科学驾驶员，更不要说把车开得流畅的赛车手。绝大部分的“程序员”连最基本的引擎，油门，刹车，方向盘的工作原理都不明白，思维方式就不对，所以根本没法独自上路，一上路就出车祸。很多人把过错归结在自己的车身上，以为换一辆车马上就能成为好的驾驶员。这是一种世界范围的计算机教育的失败。&lt;/p&gt;

&lt;p&gt;在后面的章节，我会引导你成为一个合格的驾驶员，随便拿一辆车就能开好。&lt;/p&gt;

&lt;h3 id=&quot;什么是计算&quot;&gt;什么是计算&lt;/h3&gt;

&lt;p&gt;现在你掌握了计算所需要的基本元素，可是什么是计算呢？我好像仍然没有告诉你。这是一个很哲学的问题，不同的人可能会告诉你不同的结果。我试图从最广义的角度来告诉你这个问题的答案。&lt;/p&gt;

&lt;p&gt;当你小时候用手指算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4+3&lt;/code&gt;，那是计算。如果后来你学会了打算盘，你用算盘算 4+3，那也是计算。后来你从我这里学到了表达式，变量，函数，调用，分支语句…… 在每一新的构造加入的过程中，你都在了解不同的计算。&lt;/p&gt;

&lt;p&gt;所以从最广义来讲，计算就是“机械化的信息处理”。所谓机械化，你可以用手指算，可以用算盘，可以用计算器，或者计算机。这些机器里面可以有代码，也可以没有代码，全是电子线路，甚至可以是生物活动或者化学反应。不同的机器也可以有不同的计算功能，不同的速度和性能……&lt;/p&gt;

&lt;p&gt;有这么多种计算的事实不免让人困惑，总害怕少了点什么，其实你可以安心。如果你掌握了上一节的“计算要素”，那么你就掌握了几乎所有类型的计算系统所需要的东西。你在后面所需要做的只是加深这种理解，并且把它“对应”到现实世界遇到的各种计算机器里面。&lt;/p&gt;

&lt;p&gt;为什么你可以相信计算机科学的精华就只有这些呢？因为计算就是处理信息，信息有它诞生的位置（输入设备，固定数值），它传输的方式（赋值，函数调用，返回值），它被查看的地方（分支）。你想不出对于信息还有什么其它的操作，所以你就很安心的相信了，这就是计算机科学这种“棋类游戏”的全部规则。&lt;/p&gt;

&lt;p&gt;（如果你觉得这篇文章有启发，可以点击这里&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付费&lt;/a&gt;）&lt;/p&gt;

        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-04-13-computer-science</guid>
<pubDate>Fri, 13 Apr 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
