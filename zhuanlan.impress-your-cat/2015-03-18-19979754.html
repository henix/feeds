<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Pouring Water证明</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/19979754">原文</a></p>
<a data-title="10L 瓶装水通过一个7L 瓶和3L 瓶平分成两瓶5L 水，有什么数学方法计算此类问题？ - 知乎用户的回答" data-editable="true" class="" href="http://www.zhihu.com/question/28830426/answer/42239930">10L 瓶装水通过一个7L 瓶和3L 瓶平分成两瓶5L 水，有什么数学方法计算此类问题？ - 知乎用户的回答</a><p>这个问题证明写起来太麻烦了，放弃了。还是把上次那个简化的问题的证明贴上来。总体思路是一样的，就是分情况讨论，排除不可能的操作，最后证明，只有按一种方向倒水才是最优解或者最优解之一。 </p><p><a class="" data-title="Pouring Water - impress your cat - 知乎专栏" data-editable="true" href="http://zhuanlan.zhihu.com/impress-your-cat/19954774">Pouring Water - impress your cat - 知乎专栏</a><br></p><p>以下是证明思路，具体证明自己看着办吧</p><p>首先看简单的情形</p><p><br>若 c &gt; a 且 c &gt; b,没有一个容器装得下 c 升的水,所以无解。<br>若 c = a 或 c = b,那么直接把 a 或 b 倒满就可以了。</p><p><br>因为有 a,b 两个容器,可以看成有六种操作<br>1. empty(a) 倒空 a<br>2. empty(b) 倒空 b<br>3. fill(a) 倒满 a<br>4. fill(b) 倒满 b<br>5. pour(a,b) a 倒向 b<br>6. pour(b,a) b 倒向 a</p><p><br>不妨设 a,b 内实际水量分别为 A,B。<br>一开始 A = 0, B = 0<br>所以, a * x1 + b * y1 = A 和 a * x2 + b * y2 = B 都有整数解。<br>即 x1 = 0, y1 = 0, x2 = 0, y2 = 0<br></p><p> 若操作前,a * x1 + b * y1 = A 和 a * x2 + b * y2 = B 都有整数解。<br>若进行的是操作 1,完成后,B 不变,A 变成 0,所以两者仍然都有整数解。<br>若进行的是操作 2,完成后,A 不变,B 变成 0,所以两者仍然都有整数解。<br>若进行的是操作 3,完成后,B 不变,A 变成 a,所以两者仍然都有整数解。<br>若进行的是操作 4,完成后,A 不变,B 变成 b,所以两者仍然都有整数解。<br>若进行的是操作 5,完成后,总水量不变,仍然是 a(x1 + x2 ) + b(y1 + y2 )<br>分情况讨论<br>若把 B 倒满了,那么此时 A = a(x1 + x2) + b(y1 + y2 − 1),所以两者仍然都有<br>整数解。<br>若没把 B 倒满,则 A 必然被倒空了,所以两者仍然都有整数解。<br>若进行的是操作 6,完成后,类似操作 5,分情况讨论<br>若把 A 倒满了,那么此时 B = a(x1 + x2 − 1) + b(y1 + y2 ),所以两者仍然都有<br>整数解。<br>若没把 A 倒满,则 B 必然被倒空了,所以两者仍然都有整数解。</p><p>所以,只要操作前有整数解,操作后仍然会有整数解。<br>即, c = a*x + b*y 也一定有整数解。<br>根据 Bezout’s identity,当且仅当 c 是 gcd(a, b) 的整数倍时,c = a*x + b*y 才有<br>整数解。<br>所以,若 c 不能被 gcd(a, b) 整除,那么本题无解。</p><p><br>不妨设,c = a*x + b*y,分情况讨论<br>若 a &gt; b,则根据上面的讨论,若本题有解,必有 c &lt; a。那么 x 和 y 必一正一<br>负。若两者同时为负,则 c &lt; 0,与 c &gt; 0 矛盾。若两者同时为正,则 c &gt; a,<br>与 c &lt; a 矛盾。<br>若 a &lt; b,类似的,x 和 y 必一正一负。<br>若 a = b,则根据上面的讨论,c = a = b,这种情况在前面就讨论过了。</p><p>假设最少的操作序列的第 n 步为 pour(a,b)。分情况讨论</p><p>若第 n + 1 步为 pour(b,a)。因为 pour 操作不影响总水量,而 pour 的最终结果<br>要么是 a 满,要么是 b 空,所以和直接在第 n 步 pour(b,a) 没有区别,和操作<br>最少矛盾。</p><p><br>若第 n 步操作后,a 为空,则第 n + 1 步,empty(a), pour(a,b) 没有意义。<br>此时若 empty(b),则和初始状态没有区别。若 fill(b),就和一开始直接 fill(b)<br>没有区别。都和操作最少矛盾。<br>因此,第 n + 1 步必为 fill(a)。此时第 n + 2 步,fill(a), pour(b,a) 没有意义。<br>此时若 empty(a),则和 fill(a) 前状态没有区别。若 empty(b),就和一开始直接<br>fill(a) 没有区别。若 fill(b),则和一开始直接 fill(a),fill(b) 没有区别。都和操作<br>最少矛盾。<br>因此,fill(a) 的下一步必为 pour(a,b)。</p><p>若第 n 步操作后,b 满了,则第 n + 1 步,pour(a,b), fill(b) 没有意义。<br>此时若 fill(a),则和一开始直接 fill(a),fill(b) 没有区别。若 empty(a),就和一开<br>始直接 fill(b) 没有区别,都和操作最少矛盾。<br>因此,第 n + 1 步必为 empty(b)。此时第 n + 2 步,empty(b), pour(b,a) 没有<br>意义。<br>若 empty(a),则和初始状态没有区别。若 fill(b),就和 empty(b) 前状态没有区<br>别。若 fill(a),则和一开始直接 fill(a) 没有区别。都和操作最少矛盾。<br>因此,empty(b) 的下一步必是 pour(a,b)<br>类似的,交换 a,b,也可以得到最少的操作序列的第 n 步为 pour(b,a) 对应的结<br>论。</p><p>所以,步数最少的操作方式,必是以下两种之一。</p><p><br>1. fill(a)<br>2. pour(a,b)<br>3. 若 a 为空,回到 1<br>4. empty(b)<br>5. 回到 2</p><p><br>1. fill(b)<br>2. pour(b,a)<br>3. 若 b 为空,回到 1<br>4. empty(a)<br>5. 回到 2</p><p><br>交换 a,b,第一种就变成了第二种。现在就只讨论第一种。<br></p><p>若 a &gt; b,每一次 fill(a) 后,都会不断地 pour(a,b),empty(b),直到 pour(a,b)<br>不足以倒满 b。假如把倒满 b 的 pour(a,b) 和 empty(b) 看作一组操作,把 fill(a)<br>和没倒满 b 的 pour(a,b) 看作一组操作,总操作次数就是 fill(a) 和 empty(b) 次<br>数之和的两倍。不过,若 a 是 b 的整数倍,不会出现,pour(a,b) 不足以倒满<br>b 的情况,实际上,此时只需要在 fill(a) 后,倒出 a-c 升水即可,因此,只要<br>2 (a−c)/b 次操作就可以了。<br>在非整数倍的情况,最后一次 pour(a,b) 后,并不需要 empty(b),且最后一次<br>fill(a),没有对应的没倒满 b 的 pour(a,b),所以总操作次数要减去 2<br></p><p>若 a &lt; b,会不断地 fill(a),pour(a,b),直到把 b 倒满。假如把 fill(a) 和向 b 倒<br>入 a 升水的 pour(a,b) 看成一组操作,把 empty(b),和向 b 倒入不足 a 升水<br>的 pour(a,b) 看成一组操作,总操作次数就是 fill(a) 和 empty(b) 次数之和的两<br>倍。不过,若 b 是 a 的整数倍,不会出现向 b 倒入不足 a 升水的 pour(a,b) 的<br>情况,因为此时 c 也是 a 的整数倍,只需要 2c/a 次操作就可以了。<br>在非整数倍的情况,若 a &gt; c,则 a 不为空也不满时,必然是刚好把 b 倒满。和<br>上一种情况类似,最后一次 pour(a,b) 后,并不需要 empty(b),也没有对应的<br>向 b 倒入不足 a 升水的 pour(a,b),所以总操作次数要减去 2<br>若 a &lt; c,所以最后必然是 b 中装 c 升水。所以总操作数不需要减。</p><p><br>现在就要找出最少的 fill(a) 和 empty(b) 次数之和<br>根据前面的讨论,a*x + b*y = c 的整数解,x,y 必一正一负。<br>不妨设其中一种情况为,a*k1 − b*k2 = c,且 k1 &gt; 0, k2 &gt; 0<br>因为 a * k1 = c + b * k2 ,所以 k1 越大,k2 就越大。<br>所以只要求出最小的 k1 ,就能求出最少的 fill(a) 和 empty(b) 次数之和<br>另一种情况,−a * k1 + b * k2 = c,且 k1 &gt; 0, k2 &gt; 0,也是类似的。</p><p>使用扩展欧几里德算法,可以分别求出两种情况下的解,取小的就可以了。<br>总结,<br>1. 若 c &gt; a 且 c &gt; b,无解<br>2. 若 c = a 或 c = b,最少需要 1 步操作<br>3. 若 a = b 且 c &lt;&gt; a 且 c &lt;&gt; b,无解<br>4. 若 gcd(a, b) 能整除 c,有解</p><p>gcd(a, b) 能整除 c 的情况<br>1. 若 a 是 b 的整数倍,那么取 2(a−c)/b 和 2c/b 中的最小值<br>2. 若 b 是 a 的整数倍,那么取 2(b−c)/a 和 2c/a 中的最小值<br>3. 其他情况,取分别以 a,b 代入 a,b,以 b,a 代入 a,b,按以下方法求出操<br>作步数的最小值</p><p>用扩展欧几里德算法求出 k 使得 k * a ≡ gcd(a, b) (mod b)<br>令 k1 为 k  * c / gcd(a,b) (mod b),有 k1 * a ≡ c (mod b)<br>令 k2 为 k1 * a−c/b<br>所以有 a * k1 − b * k2 = c<br>1. 若 a &lt; b 且 a &lt; c,操作步数为 2 (k1 + k2 )<br>2. 其他情况,操作步数为 2 (k1 + k2 − 1)</p><p>简化分类<br>因为只需要步数,而不需要具体步骤,交换 a,b 不影响结论。假如 a 是 a,b 中<br>小的那个,b 是 a,b 中大的那个。<br>那么一开始只要判断 c 是否比 b 大就可以了,同时后面也不需要判断 a 是否是<br>b 的整数倍了。<br>而 a = b 时,若 c &lt; b,gcd(a, b) 必然不能整除 c,所以没必要单独判断。<br>这样,就可以合并为<br>1. 若 c &gt; b,无解<br>2. 若 c = a 或 c = b,最少需要 1 步操作。<br>3. 若 b 是 a 的整数倍,取 2 (b−c)/a 和 2 c/a 中的最小值<br>4. 若 gcd(a, b) 能整除 c,有解。</p><p>因为扩展欧几里德算法可以同时计算两种情况以及 gcd(a, b)。所以没必要做三<br>次辗转相除,一次就可以完成计算了。</p><p>扩展欧几里德算法<br>为了求 k 使得 ka ≡ gcd(a, b) (mod b)<br>令 k1 = 1, k2 = 0, r1 = a, r2 = b<br>每一步,替换 k1 = k2 − k1 * floor(r2/r1) , k2 = k1 , r1 = r2 − r1 * floor(r2/r1) , r2 = r1<br>迭代过程中始终满足<br>k1 * a = r1 (mod b)<br>k2 * a = r2 (mod b)<br>因为 (k2−k1*floor(r2/r1) )a = k2*a−k1*a*floor(r2/r1) = r2−r1*floor(r2/r1) (mod b)<br>所以最终,当 r1 = 0 时,r2 = gcd(a, b),此时的 k2 就是要求的 k<br>而求 k 使得 k * b ≡ gcd(a, b) (mod a) 时,<br>一开始 k1 = 1, k2 = 0, r1 = b, r2 = a 计算一步后,k1 = 0, k2 = 1, r1 = a,<br>r2 = b<br>所以,两种情况可以同时计算。</p><p>另外,还可以改变初值。</p><p>令 k1 = c, k2 = 0, r1 = a, r2 = b<br>一开始<br>k1 * a = c * a = c * r1 = c * r1 (mod b)<br>k2 * a = 0 * a = 0 =  c*b = c * r2 (mod b)<br>而 (k2−k1*floor(r2/r1))a = k2*a−k1*a*floor(r2/r1) = c(r2−r1*floor(r2/r1)) (mod b)<br>所以迭代过程中始终满足<br>k1 * a = c * r1 (mod b)<br>k2 * a = c * r2 (mod b)<br>因此,最后当 r1 = 0 时,r2 = gcd(a, b),k2 * a = c * gcd(a, b) (mod b)<br>一开始 k1 , k2 都是 gcd(a, b) 的倍数,迭代过程中,始终减去的都是整数倍的 k1 ,所以,最终 k1 , k2 一直是 gcd(a, b) 的倍数。所以,最终 k2 * a / gcd(a,b) = c (mod b)<br>再回到 b 是 a 的整数倍的情况。假如也使用上述方法求解,一步就计算结束<br>了,得到 c/a 和 0。 c/a满足要求。而 0 不满足要求,改成 1 即可满足要求。</p><p>这样就得到了<a data-title="Pouring Water解答 - impress your cat - 知乎专栏" data-editable="true" href="http://zhuanlan.zhihu.com/impress-your-cat/19957381">Pouring Water解答 - impress your cat - 知乎专栏</a>里的代码 </p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
