<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>你好，类型（六）：Simply typed lambda calculus</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34815896">原文</a></p>
<p></p><img src="https://pic1.zhimg.com/v2-36c3e68ae0c501adae575be51013b97e_r.jpg" data-caption="" data-size="normal" data-rawwidth="1024" data-rawheight="683"><p>简单类型化 <equation>\lambda</equation> 演算（simply typed lambda calculus） <equation>\lambda^\to</equation> ，是无类型 <equation>\lambda</equation> 演算的类型化版本，<br>它是众多类型化 <equation>\lambda</equation> 演算中最简单的一个。</p><p>它只包含一个类型构造器（type constructor） <equation>\to</equation> ，<br>即，接受两个类型 <equation>T_1,T_2</equation> 作为参数，返回一个函数类型 <equation>T_1\to T_2</equation> 。</p><p>下文中，我们首先从最基础的概念说起，详细的区分<b>项</b>（term）和<b>值</b>（value）的概念，<br>然后介绍简单类型化 <equation>\lambda</equation> 演算系统的求值规则和类型规则。</p><h2><b>1. 项和值</b></h2><img src="https://pic4.zhimg.com/v2-d545f73a2ab9958178ad019e84cc6162_r.jpg" data-caption="" data-size="normal" data-rawwidth="620" data-rawheight="330"><p><b>1.1 项</b></p><p><b>项</b>（term）是一个语法概念，一个合法的项，指的是一段<b>符合语法</b>的字符串。<br>例如，在 <equation>\lambda_\beta</equation> 系统中，项的定义如下，<br> <equation>t::=x|\lambda x.t|t~t</equation> </p><p>它表明，一个合法的 <equation>\lambda_\beta</equation> 项，要么是一个变量 <equation>x</equation> ，<br>要么是一个 <equation>\lambda</equation> <b>抽象</b>（abstraction） <equation>\lambda x.t</equation> ，要么是一个 <equation>\lambda</equation> <b>应用</b>（application） <equation>t~t</equation> 。</p><p><b>1.2 值</b></p><p><b>值</b>（value）是一个和<b>语义</b>相关的概念，有三种常用的方法为项指定语义。<br>（1）操作语义，通过定义一个简单的抽象机器，来说明一个程序语言的行为。<br>（2）指称语义，一个项的语义是一个数学对象。<br>（3）公理语义，不是首先定义程序的行为，而是用项所满足的规则限定它的语义。</p><p>下面我们采用操作语义的方法，来定义求值的概念。<br>首先，我们<b>人为指定项的一个子集</b>，将其中的元素称为<b>值</b>。</p><p>假如项的定义如下， <equation>t::=true|false|if~t~then~t~else~t</equation> ，<br>我们可以定义值， <equation>v::=true|false</equation> 。<br>值可能是项被求值的最终结果，但也<b>不全是</b>，因为对某些项的求值过程可能不会终止。</p><p><b>1.3 求值规则</b></p><p>求值规则，是定义在项上的推导规则，例如，<br>（1） <equation>if~true~then~t_1~else~t_2\to t_1</equation> ，<br>（2） <equation>if~false~then~t_1~else~t_2\to t_2</equation> ，<br>（3） <equation>\frac{t_1\to t'_1}{if~t_1~then~t_2~else~t_3\to if~t'_1~then~t_2~else~t_3}</equation> <br>其中， <equation>x\to y</equation> 表示，项 <equation>x</equation> 可以一步求值为项 <equation>y</equation> 。</p><p><b>1.4 范式</b></p><p>一个不含自由变量的项，称为<b>封闭项</b>，封闭项也称为<b>组合子</b>。<br>例如，恒等函数 <equation>id=\lambda x.x</equation> 就是一个封闭项。</p><p>如果没有求值规则可用于项 <equation>t</equation> ，就称该项是一个<b>范式</b>。<br>范式可能是一个值，也可能不是，但每一个值都应该是范式。</p><p>如果一个封闭项是一个范式，但不是一个值，就称该项<b>受阻</b>。<br>不是值的范式，在运行时间错误分析中起着极其重要的作用。</p><h2><b>2. 类型</b></h2><img src="https://pic4.zhimg.com/v2-e58cfc7a10ec61f71b2d4cc93530652e_r.jpg" data-caption="" data-size="normal" data-rawwidth="480" data-rawheight="280"><p><b>2.1 类型上下文</b></p><p>一个<b>类型上下文</b>（也称<b>类型环境</b>） <equation>\Gamma</equation> ，是一个变量和类型之间绑定关系的集合。<br>空上下文，可以记为 <equation>\varnothing</equation> ，但是我们经常省略它。</p><p>用逗号可以在 <equation>\Gamma</equation> 右边加入一个新的<b>绑定</b>，例如， <equation>\Gamma,x:T</equation> 。<br> <equation>\vdash t:T</equation> ，表示项 <equation>t</equation> 在空的类型上下文中，有类型 <equation>T</equation> 。</p><p><b>2.1 类型规则</b></p><p><equation>\lambda^\to</equation> 是一个新的系统，比起 <equation>\lambda_\beta</equation> 而言，增加了一些基于类型的推导规则。</p><p>其中， <equation>\lambda^\to</equation> 中 <equation>\lambda</equation> 项的语法如下：<br>（1） <equation>t::=x|\lambda x:T.t|t~t</equation> <br>（2） <equation>T::=T\to T</equation> <br>（3） <equation>\Gamma::=\varnothing|\Gamma,x:T</equation> </p><p>推导规则：<br>（1） <equation>\frac{x:T\in\Gamma}{\Gamma\vdash x:T}</equation> <br>（2） <equation>\frac{\Gamma,x:T_1\vdash t:T_2}{\Gamma\vdash\lambda x:T_1.t:T_1\to T_2}</equation> <br>（3） <equation>\frac{\Gamma\vdash t_1:T_1\to T_2~~~~\Gamma\vdash t_2:T_1}{\Gamma\vdash t_1~t_2:T_2}</equation> </p><p>根据以上的推导规则，我们可以证明， <equation>\vdash(\lambda x:Bool.x)~true:Bool</equation> </p><p><b>2.3 求值规则</b></p><p><equation>\lambda^\to</equation> 系统中，值的定义如下：<br>（1） <equation>v::=\lambda x:T.t</equation> </p><p>求值规则，定义如下：<br>（1） <equation>\frac{t_1\to t'_1}{t_1~t_2\to t'_1~t_2}</equation> <br>（2） <equation>\frac{t_2\to t'_2}{t_1~t_2\to t_1~t'_2}</equation> <br>（3） <equation>(\lambda x:T.t)~v\to [x\mapsto v]t</equation> </p><p>其中（2），相当于 <equation>\beta</equation> 变换，<br> <equation>[x\mapsto v]t</equation> ，表示将 <equation>t</equation> 中所有自由出现的 <equation>x</equation> 换为 <equation>v</equation> 。</p><p><b>2.4 Curry-style and Church-style</b></p><p>对于 <equation>\lambda^\to</equation> 系统来说，通常有两种不同风格的解释方式，<br>如果我们首先定义项，然后定义项的求值规则——语义，<br>最后再定义一个类型系统，用以排除掉我们不需要的项，<br>这种语义先于类型的定义方式，称为<b>Curry-style</b>。</p><p>另一方面，如果我们定义项，然后再给出良类型的定义，<br>最后再给出这些良类型项的语义，就称为<b>Church-style</b>，类型先于语义，<br>在Church-style的系统中，我们不关心不良类型项的语义。</p><p>历史上，隐式类型的 <equation>\lambda</equation> 演算系统，通常是Curry-style的，<br>而显式类型的 <equation>\lambda</equation> 演算系统，通常是Church-style的。</p><h2><b>3. 关于单位类型</b></h2><p>简单类型化 <equation>\lambda</equation> 演算，直接用起来可能并不好用，<br>人们会再为它扩充一些类型，例如，添加一些基本类型 <equation>Bool</equation> ， <equation>Nat</equation> 或者 <equation>String</equation> ，<br>定义单位类型，列表类型，元组类型，和类型，等等。</p><p>下面我们选择<b>单位类型</b>进行介绍。</p><p>满足单位类型的项只有一个，为此我们新增一个项的定义，<br> <equation>t::=...|unit</equation> </p><p>再新增一个类型的定义，<br> <equation>T::=Unit</equation> </p><p>以及一个推导规则，<br> <equation>\Gamma\vdash unit:Unit</equation> </p><p><equation>Unit</equation> 的作用类似于C和Java中的 <equation>void</equation> 类型，主要用于表示副作用，<br>在这样的语言中，我们往往并不关心表达式的结果，而只关心它的副作用，<br>因此，用 <equation>Unit</equation> 来表示结果的类型，是一个合适的选择。</p><p>这里提到单位类型，是为以后Top类型和Bot类型做铺垫。</p><hr><h2><b>参考</b></h2><p><a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">Wikipedia: Simply typed lambda calculus</a><br><a href="https://book.douban.com/subject/1318672/">类型和程序设计语言</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
