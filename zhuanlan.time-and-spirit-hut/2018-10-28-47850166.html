<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>「研究项目」Shifgrethor：Rust实现的垃圾收集库</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/47850166">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-9f8ff107e165396f714b9eef872e386f_r.jpg" alt=""></div><blockquote>这是来自Rust每日新闻中的三篇系列文章的合集，并非翻译，只是梳理。<br>原文地址：<a href="https://boats.gitlab.io/blog/post/shifgrethor-i">Shifgrethor I: Garbage collection as a Rust library</a> </blockquote><p><b>重要的事情说三遍：</b></p><p>不要认为Rust要加GC了！</p><p>不要认为Rust要加GC了！</p><p>不要认为Rust要加GC了！</p><p>Rust官方核心人员withoutboats开发了一个内存安全的垃圾收集库。它只是一个研究项目，并不能实际使用。当然也可以用于学习目的，了解Rust的语言能力如何用于编码安全API中的复杂内存管理要求。</p><p>从长远来看，shifgrethor很可能会成为可用的高性能的垃圾回收器。当然，该项目不太可能成为Rust项目的常用功能。也就是说，请不要理解为「Rust要加GC了」。</p><p>shifgrethor的存在，只是为了要寻找一个实用的场景，用户可以使用GC来处理复杂的内存管理。比如涉及共享所有权的时候，可以使用动态的方式来管理内存。</p><hr><h2><b>shifgrethor是一个精准的跟踪GC</b></h2><ul><li>允许循环引用。不同于引用计数，这种GC不会导致内存泄漏。</li><li>精准的GC。它可以确切地知道哪些数据是活跃的，哪些不是。</li></ul><p>Shifgrethor允许完全自由引用</p><ul><li>可以解引用GC指针，可正常获得堆中的对象</li><li>GC堆中的对象可以持有不在GC堆中对象的借用/引用，不管它们是在栈上还是在非托管堆中</li><li>GC堆中的对象可以拥有非托管堆中的对象。</li><li>可以讲GC指针从栈上移动到堆上。</li></ul><p>GC是一种共享所有权，因此还需要内部可变性。</p><h2><b>Shifgrethor 的工作方式</b></h2><p>将带有垃圾回收的Rust程序的内存分成了三个部分： 栈、托管堆（managed heap）和非托管堆（unmanaged heap）。</p><p>（让我想到了.net的CLR，看来上一篇的新闻内容我理解有点问题，不过没关系，看这篇纠正就可以了）</p><p><b>非托管堆</b>： 是程序存储器的一部分，Rust程序员通常认为它就是堆，由内存分配器来分配内存，开发者可以自由调用，Rust里的`Box&lt;T&gt;`分配的就是非托管堆的内存。</p><p><b>托管堆</b>： 提供了分配内存的API，但没有提供释放内存的API，由垃圾回收器来负责回收内存。这就是为什么它被成为「托管堆」</p><p>其实托管堆和非托管堆也不是完全独立的内存，其实可以在非托管堆的基础上实现托管堆。比如，可以实现一个库，将内存分配到非托管堆，然后该库实现一个自动的垃圾回收器，然后这个GC维护一个托管堆。这也正是Shifgrethor 要做的。</p><p>托管堆中的所有数据，实际上是存储在非托管堆的链表中，基本上是一堆Box。垃圾回收器依赖于这个链表，对数据进行标记，这就形成了一个保守的标记-清除的GC。</p><p><b>标记阶段有两个重要的部分</b>：</p><ul><li>生根（rooted）：非托管部分（包括非托管堆和栈）对托管堆的引用必须是rooted，这样GC才能知道从哪里去找actived 对象。有不同的生根策略，Shifgrethor 的比较独特。</li><li>发芽（Tracing）：从根的部分，跟踪和其关联的所有对象。也就是说，从根开始，标记和其关联的所有引用。可以将其看作是一种图形跟踪算法。</li></ul><p><b>关于此GC的效率问题</b>：</p><ul><li>使用链表存在着一些问题，比如内存位置不连续，会导致内存缓存访问不佳且成本更高。</li><li>引入复制垃圾回收算法来解决这个问题。但是复制垃圾回收又为Rust引入了新的问题，将在后面的文章中介绍它。</li></ul><p><b>精确跟踪GC一般有两种rooting策略</b>：</p><ul><li>栈映射。编译器生成栈的元数据，来记录栈帧中GC指针的位置。GC按此元数据通过遍历栈来标识所有活动对象的根。</li><li>运行时收集。运行时维护所有活动对象的root集合。遵循此模式的大多数Rust实现都使用了侵入式双向链表。</li></ul><p>栈映射通常被认为是最一流的办法，但是Rust遇到了一些问题。首先，栈映射需要语言自身支持，用库无法实现。其次，栈映射只能映射到栈，而不是堆。</p><p>所以shifgrethor最初的实现是利用了<b>Pin</b> API实现了一个侵入式双向链表。因为root指针不能被移动。本文主要描述了该设计遇到Rust借用检查器，产生的一些问题，以及他如何解决。将来也许可能增加新的语法来支持这个。后面会写文章专门讨论这个想法。</p><h2><b>Shifgrethor如何跟踪对象，识别该对象是否存活</b></h2><p><b>定义Trace trait</b></p><p>跟踪算法原理：从根（root）开始，访问它引用的每个GC对象，并标记该对象为活跃对象，这样垃圾收集器就不会回收它。</p><p>该算法基于访问者模式。这是Rust社区普遍使用的模式，比如serde就是访问者模式。（插一句，《Rust编程之道》里也专门介绍了该模式）</p><code lang="rust">pub unsafe trait Trace {
    fn mark(&amp;self);
    // ...
}</code><p>所以，GC如果想跟踪某些对象，这些对象就必须实现Trace。实现Trace问题不大，但是证明GC对象是否被正确的追踪才是问题。</p><p><b>Proving rootedness</b></p><p>将这种保证跟踪是否正确的验证称为Proving rootedness。Shifgrethor的解决方案是引入新的类型GcStore。GcStore是一种没有实现Deref的gc指针。</p><code lang="rust">#[derive(GC)]
struct Foo&lt;'root&gt; {
    #[gc] bar: GcStore&lt;'root, Bar&gt;,
}</code><p>上面代码会生成一个名为bar的方法，其函数签名为 `Gc&lt;'root, Foo&lt;'_&gt;&gt; -&gt; Gc&lt;'root, Bar&gt; `，这是为了获得GC中某些内容的引用，必须始终证明是在该引用的生命周期内对其生根（rooted）</p><p><br></p><p>&lt;未完待续&gt;</p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
