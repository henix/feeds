<div class="title-image"><img src="https://pic2.zhimg.com/v2-e26c835cf649f6012efd4f8dc0f394ae_b.jpg" alt=""></div><p>作者：Breezewish</p><blockquote>本文为 TiKV 源码解析系列的第三篇，继续为大家介绍 TiKV 依赖的周边库 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus</a>，本篇主要介绍基础知识以及最基本的几个指标的内部工作机制，下篇会介绍一些高级功能的实现原理。</blockquote><p><a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus</a> 是监控系统 <a href="http://link.zhihu.com/?target=https%3A//prometheus.io/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Prometheus</a> 的 Rust 客户端库，由 TiKV 团队实现。TiKV 使用 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus</a> 收集各种指标（metric）到 Prometheus 中，从而后续能再利用 <a href="http://link.zhihu.com/?target=https%3A//grafana.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Grafana</a> 等可视化工具将其展示出来作为仪表盘监控面板。这些监控指标对于了解 TiKV 当前或历史的状态具有非常关键的作用。TiKV 提供了丰富的监控指标数据，并且代码中也到处穿插了监控指标的收集片段，因此了解 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus</a> 很有必要。</p><p>感兴趣的小伙伴还可以观看我司同学在 <a href="http://link.zhihu.com/?target=https%3A//fosdem.org/2019/" class=" wrap external" target="_blank" rel="nofollow noreferrer">FOSDEM 2019</a> 会议上关于 rust-prometheus 的<a href="http://link.zhihu.com/?target=https%3A//fosdem.org/2019/schedule/event/rust_prometheus/" class=" wrap external" target="_blank" rel="nofollow noreferrer">技术分享</a>。</p><h2><b>基础知识</b></h2><p><b>指标类别</b></p><p><a href="http://link.zhihu.com/?target=https%3A//prometheus.io/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Prometheus</a> 支持四种指标：Counter、Gauge、Histogram、Summary。<a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus</a> 库目前还只实现了前三种。TiKV 大部分指标都是 Counter 和 Histogram，少部分是 Gauge。</p><p>1.Counter</p><p><a href="http://link.zhihu.com/?target=https%3A//prometheus.io/docs/concepts/metric_types/%23counter" class=" wrap external" target="_blank" rel="nofollow noreferrer">Counter</a> 是最简单、常用的指标，适用于各种计数、累计的指标，要求单调递增。Counter 指标提供基本的 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericCounter.html%23method.inc" class=" wrap external" target="_blank" rel="nofollow noreferrer">inc()</a></code> 或 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericCounter.html%23method.inc_by" class=" wrap external" target="_blank" rel="nofollow noreferrer">inc_by(x)</a></code> 接口，代表增加计数值。</p><p>在可视化的时候，此类指标一般会展示为各个时间内增加了多少，而不是各个时间计数器值是多少。例如 TiKV 收到的请求数量就是一种 Counter 指标，在监控上展示为 TiKV 每时每刻收到的请求数量图表（QPS）。</p><p>2. Gauge</p><p><a href="http://link.zhihu.com/?target=https%3A//prometheus.io/docs/concepts/metric_types/%23gauge" class=" wrap external" target="_blank" rel="nofollow noreferrer">Gauge</a> 适用于上下波动的指标。Gauge 指标提供 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericGauge.html%23method.inc" class=" wrap external" target="_blank" rel="nofollow noreferrer">inc()</a></code>、<code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericGauge.html%23method.dec" class=" wrap external" target="_blank" rel="nofollow noreferrer">dec()</a></code>、<code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericGauge.html%23method.add" class=" wrap external" target="_blank" rel="nofollow noreferrer">add(x)</a></code>、<code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericGauge.html%23method.sub" class=" wrap external" target="_blank" rel="nofollow noreferrer">sub(x)</a></code> 和 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericGauge.html%23method.set" class=" wrap external" target="_blank" rel="nofollow noreferrer">set(x)</a></code> 接口，都是用于更新指标值。</p><p>这类指标可视化的时候，一般就是直接按照时间展示它的值，从而展示出这个指标按时间是如何变化的。例如 TiKV 占用的 CPU 率是一种 Gauge 指标，在监控上所展示的直接就是 CPU 率的上下波动图表。</p><p>3. Histogram</p><p><a href="http://link.zhihu.com/?target=https%3A//prometheus.io/docs/concepts/metric_types/%23histogram" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram</a> 即直方图，是一种相对复杂但同时也很强大的指标。Histogram 除了基本的计数以外，还能计算分位数。Histogram 指标提供 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html%23method.observe" class=" wrap external" target="_blank" rel="nofollow noreferrer">observe(x)</a></code> 接口，代表观测到了某个值。<br>举例来说，TiKV 收到请求后处理的耗时就是一种 Histogram 指标，通过 Histogram 类型指标，监控上可以观察 99%、99.9%、平均请求耗时等。这里显然不能用一个 Counter 存储耗时指标，否则展示出来的只是每时每刻中 TiKV 一共花了多久处理，而非单个请求处理的耗时情况。当然，机智的你可能想到了可以另外开一个 Counter 存储请求数量指标，这样累计请求处理时间除以请求数量就是各个时刻平均请求耗时了。</p><p>实际上，这也正是 Prometheus 中 Histogram 的内部工作原理。Histogram 指标实际上最终会提供一系列时序数据：</p><ul><li>观测值落在各个桶（bucket）上的累计数量，如落在 <code>(-∞, 0.1]</code>、<code>(-∞, 0.2]</code>、<code>(-∞, 0.4]</code>、<code>(-∞, 0.8]</code>、<code>(-∞, 1.6]</code>、<code>(-∞, +∞)</code> 各个区间上的数量。</li><li>观测值的累积和。</li><li>观测值的个数。</li></ul><p>bucket 是 Prometheus 对于 Histogram 观测值的一种简化处理方式。Prometheus 并不会具体记录下每个观测值，而是只记录落在配置的各个 bucket 区间上的观测值的数量，这样以牺牲一部分精度的代价大大提高了效率。</p><p>4. Summary</p><p><a href="http://link.zhihu.com/?target=https%3A//prometheus.io/docs/concepts/metric_types/%23summary" class=" wrap external" target="_blank" rel="nofollow noreferrer">Summary</a> 与 <a href="http://link.zhihu.com/?target=https%3A//prometheus.io/docs/concepts/metric_types/%23histogram" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram</a> 类似，针对观测值进行采样，但分位数是在客户端进行计算。该类型的指标目前在 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus</a> 中没有实现，因此这里不作进一步详细介绍。大家可以阅读 Prometheus 官方文档中的<a href="http://link.zhihu.com/?target=https%3A//prometheus.io/docs/concepts/metric_types/%23summary" class=" wrap external" target="_blank" rel="nofollow noreferrer">介绍</a>了解详细情况。感兴趣的同学也可以参考其他语言 Client Library 的实现为 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus</a> 贡献代码。</p><p><b>标签</b></p><p>Prometheus 的每个指标支持定义和指定若干组标签（<a href="http://link.zhihu.com/?target=https%3A//prometheus.io/docs/concepts/data_model/%23metric-names-and-labels" class=" wrap external" target="_blank" rel="nofollow noreferrer">Label</a>），指标的每个标签值独立计数，表现了指标的不同维度。例如，对于一个统计 HTTP 服务请求耗时的 Histogram 指标来说，可以定义并指定诸如 HTTP Method（GET / POST / PUT / …）、服务 URL、客户端 IP 等标签。这样可以轻易满足以下类型的查询：</p><ul><li>查询 Method 分别为 POST、PUT、GET 的 99.9% 耗时（利用单一 Label）</li><li>查询 POST /api 的平均耗时（利用多个 Label 组合）</li></ul><p>普通的查询诸如所有请求 99.9% 耗时也能正常工作。</p><p>需要注意的是，不同标签值都是一个独立计数的时间序列，因此应当避免标签值或标签数量过多，否则实际上客户端会向 Prometheus 服务端传递大量指标，影响效率。</p><p>与 Prometheus <a href="http://link.zhihu.com/?target=https%3A//github.com/prometheus/client_golang" class=" wrap external" target="_blank" rel="nofollow noreferrer">Golang client</a> 类似，在 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus</a> 中，具有标签的指标被称为 Metric Vector。例如 Histogram 指标对应的数据类型是 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram</a></code>，而具有标签的 Histogram 指标对应的数据类型是 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/type.HistogramVec.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">HistogramVec</a></code>。对于一个 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/type.HistogramVec.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">HistogramVec</a></code>，提供它的各个标签取值后，可获得一个 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram</a></code> 实例。不同标签取值会获得不同的 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram</a></code>实例，各个 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram</a></code> 实例独立计数。</p><h2><b>基本用法</b></h2><p>本节主要介绍如何在项目中使用 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus</a> 进行各种指标收集。使用基本分为三步：</p><ol><li>定义想要收集的指标。</li><li>在代码特定位置调用指标提供的接口收集记录指标值。</li><li>实现 HTTP Pull Service 使得 Prometheus 可以定期访问收集到的指标，或使用 rust-prometheus 提供的 Push 功能定期将收集到的指标上传到 <a href="http://link.zhihu.com/?target=https%3A//github.com/prometheus/pushgateway" class=" wrap external" target="_blank" rel="nofollow noreferrer">Pushgateway</a>。</li></ol><p>注意，以下样例代码都是基于本文发布时最新的 rust-prometheus 0.5 版本 API。我们目前正在设计并实现 1.0 版本，使用上会进一步简化，但以下样例代码可能在 1.0 版本发布后过时、不再工作，届时请读者参考最新的文档。</p><p><b>定义指标</b></p><p>为了简化使用，一般将指标声明为一个全局可访问的变量，从而能在代码各处自由地操纵它。rust-prometheus 提供的各个指标（包括 Metric Vector）都满足 <code>Send + Sync</code>，可以被安全地全局共享。</p><p>以下样例代码借助 <a href="http://link.zhihu.com/?target=https%3A//docs.rs/lazy_static" class=" wrap external" target="_blank" rel="nofollow noreferrer">lazy_static</a> 库定义了一个全局的 Histogram 指标，该指标代表 HTTP 请求耗时，并且具有一个标签名为 <code>method</code>：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="cp">#[macro_use]</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">prometheus</span><span class="p">;</span><span class="w"></span>

<span class="n">lazy_static</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">static</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">REQUEST_DURATION</span>: <span class="nc">HistogramVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">register_histogram_vec</span><span class="o">!</span><span class="p">(</span><span class="w"></span>
<span class="w">       </span><span class="s">"http_requests_duration"</span><span class="p">,</span><span class="w"></span>
<span class="w">       </span><span class="s">"Histogram of HTTP request duration in seconds"</span><span class="p">,</span><span class="w"></span>
<span class="w">       </span><span class="o">&amp;</span><span class="p">[</span><span class="s">"method"</span><span class="p">],</span><span class="w"></span>
<span class="w">       </span><span class="n">exponential_buckets</span><span class="p">(</span><span class="mf">0.005</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">).</span><span class="n">unwrap</span><span class="p">()</span><span class="w"></span>
<span class="w">   </span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><b>记录指标值</b></p><p>有了一个全局可访问的指标变量后，就可以在代码中通过它提供的接口记录指标值了。在“基础知识”中介绍过，<code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram</a></code> 最主要的接口是 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html%23method.observe" class=" wrap external" target="_blank" rel="nofollow noreferrer">observe(x)</a></code>，可以记录一个观测值。若想了解 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram</a></code> 其他接口或其他类型指标提供的接口，可以参阅 <a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus 文档</a>。</p><p>以下样例在上段代码基础上展示了如何记录指标值。代码模拟了一些随机值用作指标，装作是用户产生的。在实际程序中，这些当然得改成真实数据 :)</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">fn</span> <span class="nf">thread_simulate_requests</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span>::<span class="n">thread_rng</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="c1">// Simulate duration 0s ~ 2s</span>
<span class="w">       </span><span class="kd">let</span><span class="w"> </span><span class="n">duration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rng</span><span class="p">.</span><span class="n">gen_range</span><span class="p">(</span><span class="mi">0</span><span class="k">f64</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="k">f64</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="c1">// Simulate HTTP method</span>
<span class="w">       </span><span class="kd">let</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">"GET"</span><span class="p">,</span><span class="w"> </span><span class="s">"POST"</span><span class="p">,</span><span class="w"> </span><span class="s">"PUT"</span><span class="p">,</span><span class="w"> </span><span class="s">"DELETE"</span><span class="p">].</span><span class="n">choose</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">rng</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">       </span><span class="c1">// Record metrics</span>
<span class="w">       </span><span class="n">REQUEST_DURATION</span><span class="p">.</span><span class="n">with_label_values</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">method</span><span class="p">]).</span><span class="n">observe</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="c1">// One request per second</span>
<span class="w">       </span><span class="n">std</span>::<span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">std</span>::<span class="n">time</span>::<span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><b>Push / Pull</b></p><p>到目前为止，代码还仅仅是将指标记录了下来。最后还需要让 Prometheus 服务端能获取到记录下来的指标数据。这里一般有两种方式，分别是 Push 和 Pull。</p><ul><li>Pull 是 Prometheus 标准的获取指标方式，Prometheus Server 通过定期访问应用程序提供的 HTTP 接口获取指标数据。</li><li>Push 是基于 Prometheus <a href="http://link.zhihu.com/?target=https%3A//github.com/prometheus/pushgateway" class=" wrap external" target="_blank" rel="nofollow noreferrer">Pushgateway</a> 服务提供的另一种获取指标方式，指标数据由应用程序主动定期推送给 <a href="http://link.zhihu.com/?target=https%3A//github.com/prometheus/pushgateway" class=" wrap external" target="_blank" rel="nofollow noreferrer">Pushgateway</a>，然后 Prometheus 再定期从 Pushgateway 获取。这种方式主要适用于应用程序不方便开端口或应用程序生命周期比较短的场景。</li></ul><p>以下样例代码基于 <a href="http://link.zhihu.com/?target=https%3A//docs.rs/hyper/0.12.23/hyper/" class=" wrap external" target="_blank" rel="nofollow noreferrer">hyper</a> HTTP 库实现了一个可以供 Prometheus Server pull 指标数据的接口，核心是使用 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust-prometheus</a> 提供的 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.TextEncoder.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">TextEncoder</a></code> 将所有指标数据序列化供 Prometheus 解析：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">fn</span> <span class="nf">metric_service</span><span class="p">(</span><span class="n">_req</span>: <span class="nc">Request</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Response</span><span class="o">&lt;</span><span class="n">Body</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kd">let</span><span class="w"> </span><span class="n">encoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TextEncoder</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[];</span><span class="w"></span>
<span class="w">   </span><span class="kd">let</span><span class="w"> </span><span class="n">mf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prometheus</span>::<span class="n">gather</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">encoder</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">Response</span>::<span class="n">builder</span><span class="p">()</span><span class="w"></span>
<span class="w">       </span><span class="p">.</span><span class="n">header</span><span class="p">(</span><span class="n">hyper</span>::<span class="n">header</span>::<span class="n">CONTENT_TYPE</span><span class="p">,</span><span class="w"> </span><span class="n">encoder</span><span class="p">.</span><span class="n">format_type</span><span class="p">())</span><span class="w"></span>
<span class="w">       </span><span class="p">.</span><span class="n">body</span><span class="p">(</span><span class="n">Body</span>::<span class="n">from</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span><span class="w"></span>
<span class="w">       </span><span class="p">.</span><span class="n">unwrap</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>对于如何使用 Push 感兴趣的同学可以自行参考 rust-prometheus 代码内提供的 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus/blob/89ca69913691d9d1609c78cc043fca9c3faa1a78/examples/example_push.rs%23L1" class=" wrap external" target="_blank" rel="nofollow noreferrer">Push 示例</a>，这里限于篇幅就不详细介绍了。<br>上述三段样例的完整代码可参见<a href="http://link.zhihu.com/?target=https%3A//gist.github.com/breeswish/bb10bccd13a7fe332ef534ff0306ceb5" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a>。</p><h2><b>内部实现</b></h2><p>以下内部实现都基于本文发布时最新的 rust-prometheus 0.5 版本代码，该版本主干 API 的设计和实现 port 自 Prometheus <a href="http://link.zhihu.com/?target=https%3A//github.com/prometheus/client_golang" class=" wrap external" target="_blank" rel="nofollow noreferrer">Golang client</a>，但为 Rust 的使用习惯进行了一些修改，因此接口上与 Golang client 比较接近。</p><p>目前我们正在开发 1.0 版本，API 设计上不再主要参考 Golang client，而是力求提供对 Rust 使用者最友好、简洁的 API。实现上为了效率考虑也会和这里讲解的略微有一些出入，且会去除一些目前已被抛弃的特性支持，简化实现，因此请读者注意甄别。</p><p><b>Counter / Gauge</b></p><p>Counter 与 Gauge 是非常简单的指标，只要支持线程安全的数值更新即可。读者可以简单地认为 Counter 和 Gauge 的核心实现都是 <code>Arc&lt;Atomic&gt;</code>。但由于 Prometheus 官方规定指标数值需要支持浮点数，因此我们基于 <code><a href="http://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/sync/atomic/struct.AtomicU64.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">std::sync::atomic::AtomicU64</a></code> 和 CAS 操作实现了 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/core/type.AtomicF64.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">AtomicF64</a></code>，其具体实现位于 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus/blob/89ca69913691d9d1609c78cc043fca9c3faa1a78/src/atomic64/nightly.rs" class=" wrap external" target="_blank" rel="nofollow noreferrer">src/atomic64/nightly.rs</a>。核心片段如下：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">impl</span><span class="w"> </span><span class="n">Atomic</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">AtomicF64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">type</span> <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Some functions are omitted.</span>

<span class="w">   </span><span class="k">fn</span> <span class="nf">inc_by</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">delta</span>: <span class="nc">Self</span>::<span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="kd">let</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Acquire</span><span class="p">);</span><span class="w"></span>
<span class="w">           </span><span class="kd">let</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u64_to_f64</span><span class="p">(</span><span class="n">current</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">delta</span><span class="p">;</span><span class="w"></span>
<span class="w">           </span><span class="kd">let</span><span class="w"> </span><span class="n">swapped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="w"></span>
<span class="w">               </span><span class="p">.</span><span class="n">inner</span><span class="w"></span>
<span class="w">               </span><span class="p">.</span><span class="n">compare_and_swap</span><span class="p">(</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">f64_to_u64</span><span class="p">(</span><span class="n">new</span><span class="p">),</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Release</span><span class="p">);</span><span class="w"></span>
<span class="w">           </span><span class="k">if</span><span class="w"> </span><span class="n">swapped</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">               </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">           </span><span class="p">}</span><span class="w"></span>
<span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>另外由于 0.5 版本发布时 <code><a href="http://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/sync/atomic/struct.AtomicU64.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">AtomicU64</a></code> 仍然是一个 nightly 特性，因此为了支持 Stable Rust，我们还基于自旋锁提供了 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/core/type.AtomicF64.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">AtomicF64</a></code> 的 fallback，位于 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus/blob/89ca69913691d9d1609c78cc043fca9c3faa1a78/src/atomic64/fallback.rs" class=" wrap external" target="_blank" rel="nofollow noreferrer">src/atomic64/fallback.rs</a>。<br>注：<code><a href="http://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/sync/atomic/struct.AtomicU64.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">AtomicU64</a></code> 所需的 <a href="http://link.zhihu.com/?target=https%3A//github.com/rust-lang/rust/issues/32976" class=" wrap external" target="_blank" rel="nofollow noreferrer">integer_atomics</a> 特性最近已在 rustc 1.34.0 stabilize。我们将在 rustc 1.34.0 发布后为 Stable Rust 也使用上原生的原子操作从而提高效率。</p><p><b>Histogram</b></p><p>根据 Prometheus 的要求，Histogram 需要进行的操作是在获得一个观测值以后，为观测值处在的桶增加计数值。另外还有总观测值、观测值数量需要累加。</p><p>注意，Prometheus 中的 Histogram 是<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Histogram%23Cumulative_histogram" class=" wrap external" target="_blank" rel="nofollow noreferrer">累积直方图</a>，其每个桶的含义是 <code>(-∞, x]</code>，因此对于每个观测值都可能要更新多个连续的桶。例如，假设用户定义了 5 个桶边界，分别是 0.1、0.2、0.4、0.8、1.6，则每个桶对应的数值范围是 <code>(-∞, 0.1]</code>、<code>(-∞, 0.2]</code>、<code>(-∞, 0.4]</code>、<code>(-∞, 0.8]</code>、<code>(-∞, 1.6]</code>、<code>(-∞, +∞)</code>，对于观测值 0.4 来说需要更新<code>(-∞, 0.4]</code>、<code>(-∞, 0.8]</code>、<code>(-∞, 1.6]</code>、<code>(-∞, +∞)</code> 四个桶。</p><p>一般来说 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html%23method.observe" class=" wrap external" target="_blank" rel="nofollow noreferrer">observe(x)</a></code> 会被频繁地调用，而将收集到的数据反馈给 Prometheus 则是个相对很低频率的操作，因此用数组实现“桶”的时候，我们并不将各个桶与数组元素直接对应，而将数组元素定义为非累积的桶，如 <code>(-∞, 0.1)</code>、<code>[0.1, 0.2)</code>、<code>[0.2, 0.4)</code>、<code>[0.4, 0.8)</code>、<code>[0.8, 1.6)</code>、<code>[1.6, +∞)</code>，这样就大大减少了需要频繁更新的数据量；最后在上报数据给 Prometheus 的时候将数组元素累积，得到累积直方图，这样就得到了 Prometheus 所需要的桶的数据。</p><p>当然，由此可见，如果给定的观测值超出了桶的范围，则最终记录下的最大值只有桶的上界了，然而这并不是实际的最大值，因此使用的时候需要多加注意。</p><p><code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram</a></code> 的核心实现见 <a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/rust-prometheus/blob/89ca69913691d9d1609c78cc043fca9c3faa1a78/src/histogram.rs" class=" wrap external" target="_blank" rel="nofollow noreferrer">src/histogram.rs</a>：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HistogramCore</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Some fields are omitted.</span>
<span class="w">   </span><span class="n">sum</span>: <span class="nc">AtomicF64</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">count</span>: <span class="nc">AtomicU64</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">upper_bounds</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">counts</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AtomicU64</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">HistogramCore</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Some functions are omitted.</span>

<span class="w">   </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">observe</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">v</span>: <span class="kt">f64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="c1">// Try find the bucket.</span>
<span class="w">       </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="w"></span>
<span class="w">           </span><span class="p">.</span><span class="n">upper_bounds</span><span class="w"></span>
<span class="w">           </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">           </span><span class="p">.</span><span class="n">enumerate</span><span class="p">()</span><span class="w"></span>
<span class="w">           </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="bp">self</span><span class="p">.</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">inc_by</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="p">}</span><span class="w"></span>

<span class="w">       </span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="p">.</span><span class="n">inc_by</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="bp">self</span><span class="p">.</span><span class="n">sum</span><span class="p">.</span><span class="n">inc_by</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(Clone)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Histogram</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">core</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">HistogramCore</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram</a></code> 还提供了一个辅助结构 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.HistogramTimer.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">HistogramTimer</a></code>，它会记录从它创建直到被 Drop 的时候的耗时，将这个耗时作为 <code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html%23method.observe" class=" wrap external" target="_blank" rel="nofollow noreferrer">Histogram::observe()</a></code> 接口的观测值记录下来，这样很多时候在想要记录 Duration / Elapsed Time 的场景中，就可以使用这个简便的结构来记录时间：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="cp">#[must_use]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HistogramTimer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">histogram</span>: <span class="nc">Histogram</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">start</span>: <span class="nc">Instant</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">HistogramTimer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Some functions are omitted.</span>

<span class="w">   </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">observe_duration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="k">fn</span> <span class="nf">observe</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">duration_to_seconds</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">elapsed</span><span class="p">());</span><span class="w"></span>
<span class="w">       </span><span class="bp">self</span><span class="p">.</span><span class="n">histogram</span><span class="p">.</span><span class="n">observe</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">HistogramTimer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="bp">self</span><span class="p">.</span><span class="n">observe</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><code><a href="http://link.zhihu.com/?target=https%3A//docs.rs/prometheus/0.5.0/prometheus/struct.HistogramTimer.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">HistogramTimer</a></code> 被标记为了 <code><a href="http://link.zhihu.com/?target=https%3A//doc.rust-lang.org/reference/attributes.html%23must_use" class=" wrap external" target="_blank" rel="nofollow noreferrer">must_use</a></code>，原因很简单，作为一个记录流逝时间的结构，它应该被存在某个变量里，从而记录这个变量所处作用域的耗时（或稍后直接调用相关函数提前记录耗时），而不应该作为一个未使用的临时变量被立即 Drop。标记为 <code>must_use</code> 可以在编译期杜绝这种明显的使用错误。</p>