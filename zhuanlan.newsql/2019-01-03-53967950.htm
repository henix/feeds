<div class="title-image"><img src="https://pic4.zhimg.com/v2-44348f6cb008b2c6fef5670d96cda457_b.jpg" alt=""></div><p>作者：苏立</p><blockquote>在之前的一篇文章<a href="http://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-source-code-reading-3/" class=" wrap external" target="_blank" rel="nofollow noreferrer">《TiDB 源码阅读系列文章（三）SQL 的一生》</a>中，我们介绍了 TiDB 在收到客户端请求包时，最常见的<code>Command --- COM_QUERY</code>的请求处理流程。本文我们将介绍另外一种大家经常使用的<code>Command --- Prepare/Execute</code>请求在 TiDB 中的处理过程。</blockquote><h2><b>Prepare/Execute Statement 简介</b></h2><p>首先我们先简单回顾下客户端使用 Prepare 请求过程：</p><ol><li>客户端发起 Prepare 命令将带 “?” 参数占位符的 SQL 语句发送到数据库，成功后返回 <code>stmtID</code>。</li><li>具体执行 SQL 时，客户端使用之前返回的 <code>stmtID</code>，并带上请求参数发起 Execute 命令来执行 SQL。</li><li>不再需要 Prepare 的语句时，关闭 <code>stmtID</code> 对应的 Prepare 语句。</li></ol><p>相比普通请求，Prepare 带来的好处是：</p><ul><li>减少每次执行经过 Parser 带来的负担，因为很多场景，线上运行的 SQL 多是相同的内容，仅是参数部分不同，通过 Prepare 可以通过首次准备好带占位符的 SQL，后续只需要填充参数执行就好，可以做到“一次 Parse，多次使用”。</li><li>在开启 PreparePlanCache 后可以达到“一次优化，多次使用”，不用进行重复的逻辑和物理优化过程。</li><li>更少的网络传输，因为多次执行只用传输参数部分，并且返回结果 Binary 协议。</li><li>因为是在执行的同时填充参数，可以防止 SQL 注入风险。</li><li>某些特性比如 serverSideCursor 需要是通过 Prepare statement 才能使用。</li></ul><p>TiDB 和 <a href="http://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/refman/5.7/en/sql-syntax-prepared-statements.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">MySQL 协议</a> 一样，对于发起 Prepare/Execute 这种使用访问模式提供两种方式：</p><ul><li>Binary 协议：即上述的使用 <code>COM_STMT_PREPARE</code>，<code>COM_STMT_EXECUTE</code>，<code>COM_STMT_CLOSE</code> 命令并且通过 Binary 协议获取返回结果，这是目前各种应用开发常使用的方式。</li><li>文本协议：使用 <code>COM_QUERY</code>，并且用 <code>PREPARE</code>，<code>EXECUTE</code>，<code>DEALLOCATE PREPARE</code> 使用文本协议获取结果，这个效率不如上一种，多用于非程序调用场景，比如在 MySQL 客户端中手工执行。</li></ul><p>下面我们主要以 Binary 协议来看下 TiDB 的处理过程。文本协议的处理与 Binary 协议处理过程比较类似，我们会在后面简要介绍一下它们的差异点。</p><h2><code><b>COM_STMT_PREPARE</b></code></h2><p>首先，客户端发起 <code>COM_STMT_PREPARE</code>，在 TiDB 收到后会进入 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/conn_stmt.go%23L51" class=" wrap external" target="_blank" rel="nofollow noreferrer">clientConn#handleStmtPrepare</a></code>，这个函数会通过调用 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/driver_tidb.go%23L305" class=" wrap external" target="_blank" rel="nofollow noreferrer">TiDBContext#Prepare</a></code> 来进行实际 Prepare 操作并返回 <a href="http://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/internals/en/com-stmt-prepare-response.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">结果</a> 给客户端，实际的 Prepare 处理主要在 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/session/session.go%23L924" class=" wrap external" target="_blank" rel="nofollow noreferrer">session#PrepareStmt</a></code>和 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/executor/prepared.go%23L73" class=" wrap external" target="_blank" rel="nofollow noreferrer">PrepareExec</a></code> 中完成：</p><ol><li>调用 Parser 完成文本到 AST 的转换，这部分可以参考<a href="http://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-source-code-reading-5/" class=" wrap external" target="_blank" rel="nofollow noreferrer">《TiDB 源码阅读系列文章（五）TiDB SQL Parser 的实现》</a>。</li><li>使用名为 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/executor/prepared.go%23L57" class=" wrap external" target="_blank" rel="nofollow noreferrer">paramMarkerExtractor</a></code> 的 visitor 从 AST 中提取 “?” 表达式，并根据出现位置（offset）构建排序 Slice，后面我们会看到在 Execute 时会通过这个 Slice 值来快速定位并替换 “?” 占位符。</li><li>检查参数个数是否超过 Uint16 最大值（这个是 <a href="http://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/internals/en/com-stmt-prepare-response.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">协议限制</a>，对于参数只提供 2 个 Byte）。</li><li>进行 Preprocess， 并且创建 LogicPlan， 这部分实现可以参考之前关于 <a href="http://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-source-code-reading-7/" class=" wrap external" target="_blank" rel="nofollow noreferrer">逻辑优化的介绍</a>，这里生成 LogicPlan 主要为了获取并检查组成 Prepare 响应中需要的列信息。</li><li>生成 <code>stmtID</code>，生成的方式是当前会话中的递增 int。</li><li>保存 <code>stmtID</code> 到 <code>ast.Prepared</code> (由 AST，参数类型信息，schema 版本，是否使用 <code>PreparedPlanCache</code> 标记组成) 的映射信息到 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/sessionctx/variable/session.go%23L185" class=" wrap external" target="_blank" rel="nofollow noreferrer">SessionVars#PreparedStmts</a></code> 中供 Execute 部分使用。</li><li>保存 <code>stmtID</code> 到 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/driver_tidb.go%23L57" class=" wrap external" target="_blank" rel="nofollow noreferrer">TiDBStatement</a></code> （由 <code>stmtID</code>，参数个数，SQL 返回列类型信息，<code>sendLongData</code> 预 <code>BoundParams</code> 组成）的映射信息保存到 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/driver_tidb.go%23L53" class=" wrap external" target="_blank" rel="nofollow noreferrer">TiDBContext#stmts</a></code>。</li></ol><p>在处理完成之后客户端会收到并持有 <code>stmtID</code> 和参数类型信息，返回列类型信息，后续即可通过 <code>stmtID</code> 进行执行时，server 可以通过 6、7 步保存映射找到已经 Prepare 的信息。</p><h2><code><b>COM_STMT_EXECUTE</b></code></h2><p> Prepare 成功之后，客户端会通过 <code>COM_STMT_EXECUTE</code> 命令请求执行，TiDB 会进入 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/conn_stmt.go%23L108" class=" wrap external" target="_blank" rel="nofollow noreferrer">clientConn#handleStmtExecute</a></code>，首先会通过 stmtID 在上节介绍中保存的 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/driver_tidb.go%23L53" class=" wrap external" target="_blank" rel="nofollow noreferrer">TiDBContext#stmts</a></code> 中获取前面保存的 <code>TiDBStatement</code>，并解析出是否使用 <code>userCursor</code> 和请求参数信息，并且调用对应 <code>TiDBStatement</code> 的 Execute 进行实际的 Execute 逻辑：</p><ol><li>生成 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/pingcap/parser/blob/732efe993f70da99fdc18acb380737be33f2333a/ast/misc.go%23L218" class=" wrap external" target="_blank" rel="nofollow noreferrer">ast.ExecuteStmt</a></code> 并调用 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/planner/optimize.go%23L28" class=" wrap external" target="_blank" rel="nofollow noreferrer">planer.Optimize</a></code> 生成 <code>plancore.Execute</code>，和普通优化过程不同的是会执行 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/planner/optimize.go%23L53" class=" wrap external" target="_blank" rel="nofollow noreferrer">Exeucte#OptimizePreparedPlan</a></code>。</li><li>使用 <code>stmtID</code> 通过 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/sessionctx/variable/session.go%23L190" class=" wrap external" target="_blank" rel="nofollow noreferrer">SessionVars#PreparedStmts</a></code> 获取到到 Prepare 阶段的 <code>ast.Prepared</code> 信息。</li><li>使用上一节第 2 步中准备的 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/planner/core/common_plans.go%23L167" class=" wrap external" target="_blank" rel="nofollow noreferrer">prepared.Params</a></code> 来快速查找并填充参数值；同时会保存一份参数到 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/sessionctx/variable/session.go%23L190" class=" wrap external" target="_blank" rel="nofollow noreferrer">sessionVars.PreparedParams</a></code> 中，这个主要用于支持 <code>PreparePlanCache</code> 延迟获取参数。</li><li>判断对比判断 Prepare 和 Execute 之间 schema 是否有变化，如果有变化则重新 Preprocess。</li><li>之后调用 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/planner/core/common_plans.go%23L188" class=" wrap external" target="_blank" rel="nofollow noreferrer">Execute#getPhysicalPlan</a></code> 获取物理计划，实现中首先会根据是否启用 PreparedPlanCache 来查找已缓存的 Plan，本文后面我们也会专门介绍这个。</li><li>在没有开启 PreparedPlanCache 或者开启了但没命中 cache 时，会对 AST 进行一次正常的 Optimize。</li></ol><p>在获取到 PhysicalPlan 后就是正常的 <a href="https://zhuanlan.zhihu.com/p/35134962" class="internal">Executing 执行</a>。</p><h2><code><b>COM_STMT_CLOSE</b></code></h2><p> 在客户不再需要执行之前的 Prepared 的语句时，可以通过<code>COM_STMT_CLOSE</code>来释放服务器资源，TiDB 收到后会进入<code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/conn_stmt.go%23L501" class=" wrap external" target="_blank" rel="nofollow noreferrer">clientConn#handleStmtClose</a></code>，会通过<code>stmtID</code>在<code>TiDBContext#stmts</code>中找到对应的<code>TiDBStatement</code>，并且执行<a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/driver_tidb.go%23L152" class=" wrap external" target="_blank" rel="nofollow noreferrer">Close</a>清理之前的保存的<code>TiDBContext#stmts</code>和<code>SessionVars#PrepareStmts</code>，不过通过代码我们看到，对于前者的确直接进行了清理，对于后者不会删除而是加入到<code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/session/session.go%23L1020" class=" wrap external" target="_blank" rel="nofollow noreferrer">RetryInfo#DroppedPreparedStmtIDs</a></code>中，等待当前事务提交或回滚才会从<code>SessionVars#PrepareStmts</code>中清理，之所以延迟删除是由于 TiDB 在事务提交阶段遇到冲突会根据配置决定是否重试事务，参与重试的语句可能只有 Execute 和 Deallocate，为了保证重试还能通过<code>stmtID</code>找到 prepared 的语句 TiDB 目前使用延迟到事务执行完成后才做清理。</p><h2><b>其他 <code>COM_STMT</code></b></h2><p><br>除了上面介绍的 3 个 <code>COM_STMT</code>，还有另外几个 <code>COM_STMT_SEND_LONG_DATA</code>，<code>COM_STMT_FETCH</code>，<code>COM_STMT_RESET</code> 也会在 Prepare 中使用到。</p><ul><li><code><b>COM_STMT_SEND_LONG_DATA</b></code></li></ul><p>某些场景我们 SQL 中的参数是 <code>TEXT</code>，<code>TINYTEXT</code>，<code>MEDIUMTEXT</code>，<code>LONGTEXT</code> and <code>BLOB</code>，<code>TINYBLOB</code>，<code>MEDIUMBLOB</code>，<code>LONGBLOB</code> 列时，客户端通常不会在一次 Execute 中带大量的参数，而是单独通过 <code><a href="http://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/internals/en/com-stmt-send-long-data.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">COM_SEND_LONG_DATA</a></code> 预先发到 TiDB，最后再进行 Execute。</p><p>TiDB 的处理在 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/conn_stmt.go%23L514" class=" wrap external" target="_blank" rel="nofollow noreferrer">client#handleStmtSendLongData</a></code>，通过 <code>stmtID</code> 在 <code>TiDBContext#stmts</code> 中找到 <code>TiDBStatement</code> 并提前放置 <code>paramID</code> 对应的参数信息，进行追加参数到 <code>boundParams</code>（所以客户端其实可以多次 send 数据并追加到一个参数上），Execute 时会通过 <code>stmt.BoundParams()</code> 获取到提前传过来的参数并和 Execute 命令带的参数 <a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/conn_stmt.go%23L176" class=" wrap external" target="_blank" rel="nofollow noreferrer">一起执行</a>，在每次执行完成后会重置 <code>boundParams</code>。</p><ul><li><code><b>COM_STMT_FETCH</b></code></li></ul><p>通常的 Execute 执行后，TiDB 会向客户端持续返回结果，返回速率受 <code>max_chunk_size</code> 控制（见《<a href="http://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-source-code-reading-10/" class=" wrap external" target="_blank" rel="nofollow noreferrer">TiDB 源码阅读系列文章（十）Chunk 和执行框架简介</a>》）， 但实际中返回的结果集可能非常大。客户端受限于资源（一般是内存）无法一次处理那么多数据，就希望服务端一批批返回，<code><a href="http://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/internals/en/com-stmt-fetch.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">COM_STMT_FETCH</a></code> 正好解决这个问题。</p><p>它的使用首先要和 <code>COM_STMT_EXECUTE</code> 配合（也就是必须使用 Prepared 语句执行）， <code>handleStmtExeucte</code> 请求协议 flag 中有标记要使用 cursor，execute 在完成 plan 拿到结果集后并不立即执行而是把它缓存到 <code>TiDBStatement</code> 中，并立刻向客户端回包中带上列信息并标记 <code><a href="http://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/internals/en/status-flags.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">ServerStatusCursorExists</a></code>，这部分逻辑可以参看 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/conn_stmt.go%23L193" class=" wrap external" target="_blank" rel="nofollow noreferrer">handleStmtExecute</a></code>。</p><p>客户端看到 <code>ServerStatusCursorExists</code> 后，会用 <code>COM_STMT_FETCH</code> 向 TiDB 拉去指定 fetchSize 大小的结果集，在 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/conn_stmt.go%23L210" class=" wrap external" target="_blank" rel="nofollow noreferrer">connClient#handleStmtFetch</a></code> 中，会通过 session 找到 <code>TiDBStatement</code> 进而找到之前缓存的结果集，开始实际调用执行器的 Next 获取满足 fetchSize 的数据并返回客户端，如果执行器一次 Next 超过了 fetchSize 会只返回 fetchSize 大小的数据并把剩下的数据留着下次再给客户端，最后对于结果集最后一次返回会标记 <code><a href="http://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/internals/en/status-flags.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">ServerStatusLastRowSend</a></code> 的 flag 通知客户端没有后续数据。</p><ul><li><code><b>COM_STMT_RESET</b></code></li></ul><p>主要用于客户端主动重置 <code>COM_SEND_LONG_DATA</code> 发来的数据，正常 <code>COM_STMT_EXECUTE</code> 后会自动重置，主要针对客户端希望主动废弃之前数据的情况，因为 <code>COM_STMT_SEND_LONG_DATA</code> 是一直追加的操作，客户端某些场景需要主动放弃之前预存的参数，这部分逻辑主要位于 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/server/conn_stmt.go%23L531" class=" wrap external" target="_blank" rel="nofollow noreferrer">connClient#handleStmtReset</a></code> 中。</p><h2><b>Prepared Plan Cache</b></h2><p>通过前面的解析过程我们看到在 Prepare 时完成了 AST 转换，在之后的 Execute 会通过 <code>stmtID</code> 找之前的 AST 来进行 Plan 跳过每次都进行 Parse SQL 的开销。如果开启了 Prepare Plan Cache，可进一步在 Execute 处理中重用上次的 PhysicalPlan 结果，省掉查询优化过程的开销。</p><p>TiDB 可以通过 <a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/config/config.toml.example%23L167" class=" wrap external" target="_blank" rel="nofollow noreferrer">修改配置文件</a> 开启 Prepare Plan Cache， 开启后每个新 Session 创建时会初始化一个 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/util/kvcache/simple_lru.go%23L38" class=" wrap external" target="_blank" rel="nofollow noreferrer">SimpleLRUCache</a></code> 类型的 <code>preparedPlanCache</code> 用于保存用于缓存 Plan 结果，缓存的 key 是 <code>pstmtPlanCacheKey</code>（由当前 DB，连接 ID，<code>statementID</code>，<code>schemaVersion</code>， <code>snapshotTs</code>，<code>sqlMode</code>，<code>timezone</code> 组成，所以要命中 plan cache 这以上元素必须都和上次缓存的一致），并根据配置的缓存大小和内存大小做 LRU。</p><p>在 Execute 的处理逻辑 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/executor/prepared.go%23L161" class=" wrap external" target="_blank" rel="nofollow noreferrer">PrepareExec</a></code> 中除了检查 <code>PreparePlanCache</code> 是否开启外，还会判断当前的语句是否能使用 <code>PreparePlanCache</code>。</p><ol><li>只有 <code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code> 有可能可以使用 <code>PreparedPlanCache</code>	。</li><li>并进一步通过 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/planner/core/cacheable_checker.go%23L43" class=" wrap external" target="_blank" rel="nofollow noreferrer">cacheableChecker</a></code> visitor 检查 AST 中是否有变量表达式，子查询，"order by ?"，"limit ?，?" 和 UnCacheableFunctions 的函数调用等不可以使用 PlanCache 的情况。</li></ol><p>如果检查都通过则在 <code>Execute#getPhysicalPlan</code> 中会用当前环境构建 cache key 查找 <code>preparePlanCache</code>。</p><ul><li><b>未命中 Cache</b></li></ul><p>我们首先来看下没有命中 Cache 的情况。发现没有命中后会用 <code>stmtID</code> 找到的 AST 执行 <a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/executor/prepared.go%23L161" class=" wrap external" target="_blank" rel="nofollow noreferrer">Optimize</a>，但和正常执行 Optimize 不同对于 Cache 的 Plan， 我需要对 “?” 做延迟求值处理， 即将占位符转换为一个 function 做 Plan 并 Cache， 后续从 Cache 获取后 function 在执行时再从具体执行上下文中实际获取执行参数。</p><p>回顾下构建 LogicPlan 的过程中会通过 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/planner/core/expression_rewriter.go%23L151" class=" wrap external" target="_blank" rel="nofollow noreferrer">expressionRewriter</a></code> 将 AST 转换为各类 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/expression/expression.go%23L42" class=" wrap external" target="_blank" rel="nofollow noreferrer">expression.Expression</a></code>，通常对于 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/types/parser_driver/value_expr.go%23L167" class=" wrap external" target="_blank" rel="nofollow noreferrer">ParamMarkerExpr</a></code> 会重写为 Constant 类型的 expression，但如果该条 stmt 支持 Cache 的话会重写为 Constant 并带上一个特殊的 <code>DeferredExpr</code> 指向一个 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/expression/builtin_other.go%23L787" class=" wrap external" target="_blank" rel="nofollow noreferrer">GetParam</a></code> 的函数表达式，而这个函数会在执行时实际从前面 Execute 保存到 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/sessionctx/variable/session.go%23L190" class=" wrap external" target="_blank" rel="nofollow noreferrer">sessionVars.PreparedParams</a></code> 中获取，这样就做到了 Plan 并 Cache 一个参数无关的 Plan，然后实际执行的时填充参数。</p><p>新获取 Plan 后会保存到 <code>preparedPlanCache</code> 供后续使用。</p><ul><li><b>命中 Cache</b></li></ul><p>让我们回到 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/planner/core/common_plans.go%23L188" class=" wrap external" target="_blank" rel="nofollow noreferrer">getPhysicalPlan</a></code>，如果 Cache 命中在获取 Plan 后我们需要重新 build plan 的 range，因为前面我们保存的 Plan 是一个带 <code>GetParam</code> 的函数表达式，而再次获取后，当前参数值已经变化，我们需要根据当前 Execute 的参数来重新修正 range，这部分逻辑代码位于 <code><a href="http://link.zhihu.com/?target=https%3A//github.com/lysu/tidb/blob/source-read-prepare/planner/core/common_plans.go%23L214" class=" wrap external" target="_blank" rel="nofollow noreferrer">Execute#rebuildRange</a></code> 中，之后就是正常的执行过程了。</p><h2><b>文本协议的 Prepared</b></h2><p>前面主要介绍了二进制协议的 Prepared 执行流程，还有一种执行方式是通过二进制协议来执行。</p><p>客户端可以通过 <code>COM_QUREY</code> 发送：</p><div class="highlight"><pre><code class="language-text"><span></span>PREPARE stmt_name FROM prepareable_stmt;
EXECUTE stmt_name USING @var_name1, @var_name2,...
DEALLOCTE PREPARE stmt_name
</code></pre></div><p>来进行 Prepared，TiDB 会走正常 <a href="https://zhuanlan.zhihu.com/p/35134962" class="internal">文本 Query 处理流程</a>，将 SQL 转换 Prepare，Execute，Deallocate 的 Plan， 并最终转换为和二进制协议一样的 <code>PrepareExec</code>，<code>ExecuteExec</code>，<code>DealocateExec</code> 的执行器进行执行。</p><h2><b>写在最后</b></h2><p>Prepared 是提高程序 SQL 执行效率的有效手段之一。熟悉 TiDB 的 Prepared 实现，可以帮助各位读者在将来使用 Prepared 时更加得心应手。另外，如果有兴趣向 TiDB 贡献代码的读者，也可以通过本文更快的理解这部分的实现。</p><p><br></p><p><i><b>更多 TiDB 源码阅读系列文章：</b></i><br></p><a href="http://link.zhihu.com/?target=https%3A//www.pingcap.com/blog-cn/%23%25E6%25BA%2590%25E7%25A0%2581%25E9%2598%2585%25E8%25AF%25BB" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg" data-image-width="1200" data-image-height="1200" class=" wrap external" target="_blank" rel="nofollow noreferrer">博客</a><p></p><p></p>