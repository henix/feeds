<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>深度 | 强化学习应用金融投资组合优化（附代码）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/56506983">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-ed49018275f9981b143f5e2039186379_b.jpg" alt=""></div><p></p><figure><noscript><img src="https://pic2.zhimg.com/v2-e96895b3f9d106aef40902f9660c108d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1000" data-rawheight="400" class="origin_image zh-lightbox-thumb" width="1000" data-original="https://pic2.zhimg.com/v2-e96895b3f9d106aef40902f9660c108d_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-e96895b3f9d106aef40902f9660c108d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1000" data-rawheight="400" class="origin_image zh-lightbox-thumb lazy" width="1000" data-original="https://pic2.zhimg.com/v2-e96895b3f9d106aef40902f9660c108d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-e96895b3f9d106aef40902f9660c108d_b.jpg"></figure><p>本期作者：Tal Perry</p><p>译者：Nevermore</p><p><b>代码与论文全部打包，请在文末下载</b></p><h2><b>前言</b></h2><p>首先我们要声明。我们本着分享的精神把所有内容进行分享，并希望大家能从中学习。<br></p><blockquote><i>Everything here is probably wrong, and you should trust none of it</i></blockquote><h2><b>我想要Agent做什么</b></h2><p>我们建立一个观察N只股票的Agent，并在每一阶段根据决策分配给每只股票一定比例的资金。我们希望Agent能够在符合股票市场真实场景假设下做到这一点，例如：有（实质性的）交易成本，股票不遵循标准正态分布等。我们不知道其他的市场参与者所拥有信息的多少等（换句话说，Agent可以处理POMDP模型中尽可能多的PO）。</p><p><b>互联网上很难找到有关金融方面强化学习的资料。很多资料都是非常琐碎的。更好的材料来自于学术界</b>，（我们被很多论文的启发，但是这一篇我觉得比其他的都要好）。</p><p><i><a href="http://link.zhihu.com/?target=http%3A//citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.1.7210%26rep%3Drep1%26type%3Dpdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">citeseerx.ist.psu.edu/v</span><span class="invisible">iewdoc/download?doi=10.1.1.1.7210&amp;rep=rep1&amp;type=pdf</span><span class="ellipsis"></span></a></i></p><figure><noscript><img src="https://pic2.zhimg.com/v2-6786090eb0de17d290372d4215ad34fd_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="762" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-6786090eb0de17d290372d4215ad34fd_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-6786090eb0de17d290372d4215ad34fd_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="762" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-6786090eb0de17d290372d4215ad34fd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-6786090eb0de17d290372d4215ad34fd_b.jpg"></figure><p>为了理解一篇关于应用强化学习构建最优投资组合的论文，<b>你需要有足够的知识来知道什么是最优投资组合和全面的强化学习知识</b>，用来理解作者是如何使用这种技术的。<b>最好是试图将这两个不同领域（金融和计算机）的知识结合起来。</b></p><p>我们希望很通俗的去解释这些问题，但是如果你有一些RL和金融的概念，可能会更容易理解。我们会试用通俗的语言解释高大上的问题，但是<b>强化学习是核心</b>。</p><h2><b>数据</b></h2><p>金融数据是需要花钱购买的。为了满足我们的好奇心，我们先决定自己生成模拟数据。这样可以更好地控制问题的难易程度，然后从简单的情况入手，最后慢慢深入问题。<br></p><p>我们写了一个能够模拟股票市场的magic函数。生成10只股票数据。</p><p><b>获取全部代码，见文末</b></p><div class="highlight"><pre><code class="language-python"><span></span><span class="o">%</span><span class="n">load_ext</span> <span class="n">autoreload</span>
<span class="o">%</span><span class="n">autoreload</span> <span class="mi">2</span>
<span class="n">cd</span> <span class="o">../</span><span class="n">acfl</span><span class="o">/</span>

<span class="kn">from</span> <span class="nn">env.Env</span> <span class="kn">import</span> <span class="n">Env</span>
<span class="kn">from</span> <span class="nn">env.priceGenerator</span> <span class="kn">import</span> <span class="n">make_stock</span>
<span class="kn">from</span> <span class="nn">learners.a2c</span> <span class="kn">import</span> <span class="n">PolicyEstimator</span><span class="p">,</span><span class="n">ValueEstimator</span><span class="p">,</span> <span class="n">reinforce</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="kn">as</span> <span class="nn">tf</span>

<span class="k">def</span> <span class="nf">sin_func</span><span class="p">(</span><span class="n">num_stocks</span><span class="p">,</span><span class="n">length</span><span class="p">):</span>
   <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
   <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span> <span class="p">[</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
   <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
   <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="mf">5.0001</span>

<span class="n">D</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">make_stock</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xkcd</span><span class="p">()</span>
<span class="n">D</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span><span class="n">title</span><span class="o">=</span><span class="s1">'My make beleive market for 10 stocks'</span><span class="p">)</span>
</code></pre></div><figure><noscript><img src="https://pic1.zhimg.com/v2-a073d5c1a7b48d0d04ca54aa72e1f9b4_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="545" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-a073d5c1a7b48d0d04ca54aa72e1f9b4_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-a073d5c1a7b48d0d04ca54aa72e1f9b4_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="545" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-a073d5c1a7b48d0d04ca54aa72e1f9b4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-a073d5c1a7b48d0d04ca54aa72e1f9b4_b.jpg"></figure><p>我们认为这个市场比实际市场更容易设计，一些股票显然是相关的，并且有足够强的自相关性。这是经过设计的，最终将模拟更加复杂的市场，但最好先看看算法，可以先学到一些基本的思路，以便让你相信和理解这样一个magic函数，下面是模拟生成的另一个市场。</p><figure><noscript><img src="https://pic1.zhimg.com/v2-2f0ac0b571159a3a46af5a3e3209c2bc_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="545" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-2f0ac0b571159a3a46af5a3e3209c2bc_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-2f0ac0b571159a3a46af5a3e3209c2bc_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="545" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-2f0ac0b571159a3a46af5a3e3209c2bc_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-2f0ac0b571159a3a46af5a3e3209c2bc_b.jpg"></figure><p>这是生成这些模拟股票的代码： </p><p><b>获取全部代码，见文末</b></p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="k">def</span> <span class="nf">make_stock</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">num_stocks</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
   <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.9</span>
   <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
   <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="n">num_stocks</span><span class="p">,</span> <span class="n">num_stocks</span><span class="p">])</span>
   <span class="n">cov</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cov</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># This is a positive semidefinite matrix, e.g. a covariance matrix</span>
   <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_stocks</span><span class="p">),</span> <span class="n">cov</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="n">length</span><span class="p">])</span> <span class="c1"># sample noise, with covariance </span>
   <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_stocks</span><span class="p">),</span> <span class="n">cov</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="n">length</span><span class="p">])</span> <span class="c1"># sample another noise, with covariance</span>
   <span class="n">bs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">num_stocks</span><span class="p">)]</span> <span class="c1"># </span>
   <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">num_stocks</span><span class="p">)]</span> <span class="c1"># The prices</span>

   <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
       <span class="n">bv</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">bs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span> <span class="c1"># calculate some trend</span>
       <span class="n">bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bv</span><span class="p">)</span>
       <span class="n">pv</span> <span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">a</span> <span class="c1"># Previosu price + previous trend factor, plus some noise</span>
       <span class="n">ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>

   <span class="c1">#     ps = [0]</span>
   <span class="c1">#     for a,b,common in zip(A,BB,commonNoise):</span>
   <span class="c1">#         ps.append(ps[-1]+b+k*a+2*common)</span>
   <span class="c1">#     P = np.array(ps)</span>
   <span class="c1">#     P = np.exp(P/(P.max()-P.min()))</span>
   <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># reshape it so that its [length,stocks] </span>
   <span class="n">R</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ps</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Scale factor</span>
   <span class="n">prices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="n">R</span><span class="p">))</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">250</span><span class="p">,</span><span class="n">num_stocks</span><span class="p">)</span> <span class="c1"># Normalize, exponantiate then make the prices more varied</span>
   <span class="k">return</span> <span class="n">prices</span>
</code></pre></div><p><b>我们最开始只使用了正弦波来看看否可以让模型进行强化学习。</b>一旦程序能够运行了，就会继续注入一点噪音。这个思想是非常有价值的，<b>这样操作会更容易在一个简单确定的环境中找到bug，然后再从更复杂的加上随机数学的代码寻找类似的bug。</b></p><h2><b>建立RL环境</b></h2><p>强化学习是关于一个Agent与环境之间进行的互动，就像詹姆斯邦德加入绿色和平组织一样。这是一种奇特的说法，即环境告诉Agent外部世界现在的状态是什么，Agent说要做什么，然后Agent获得一份奖励，并利用它来改进。</p><p>建立环境可以让你扮演上帝的角色，从而让你意识到这个世界为什么如此混乱。要把一切都弄好是很难的，很容易在这种环境中犯下小错误从而毁掉一切的，并且这种小错误一般很难找到。</p><p>总之，在我们扮演上帝的角色中，模拟了如下的世界：环境告诉Agent每种股票的当前价格价格、一定回测期的历史价格和当前的投资组合。Agent反馈它想要加入更新的新投资组合。</p><p>然后环境在时间上进入下一节点，通过买卖构造出Agent所提出的投资组合，并考虑交易成本。这其中有些人为操作的思想，因为Agent总是处理帐户的百分比，而环境必须将其转换为美元和股票，并需要调整四舍五入、承担交易成本，并由于舍入错误而返还资金（否则我们将得到负的奖励）。</p><p>下面的代码，用于构造上述的环境：</p><p><b>获取全部代码，见文末</b></p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span>  <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">env.priceGenerator</span> <span class="kn">import</span> <span class="n">make_stock</span>

<span class="n">costPerShare</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 0.01</span>
<span class="k">class</span> <span class="nc">Env</span><span class="p">:</span>
   <span class="sd">'''</span>
<span class="sd">   A simple environemnt for our agent,</span>
<span class="sd">   the action our agent gives is  weighting over the stocks + cash</span>
<span class="sd">   the env calcutes that into stock and figures out the returns</span>
<span class="sd">   '''</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">price_fn</span><span class="p">,</span><span class="n">num_stocks</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">starting_value</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">lookback</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
       <span class="sd">'''</span>
<span class="sd">       :param price_fn:  A function that returns a numpy array of prices</span>
<span class="sd">       :param num_stocks: How many stocks in our univerese</span>
<span class="sd">       :param length: The length of an episode</span>
<span class="sd">       '''</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">num_stocks</span> <span class="o">=</span> <span class="n">num_stocks</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">lookback</span> <span class="o">=</span> <span class="n">lookback</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">oprices</span><span class="o">=</span> <span class="n">price_fn</span><span class="p">(</span><span class="n">num_stocks</span><span class="o">=</span><span class="n">num_stocks</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">prices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">oprices</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#attach the value of cash</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">portfolio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_stocks</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#2k and 2k+1 are te long and short of a stock. portfolio[-1] is cash</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">portfolio</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span><span class="mi">0</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">__account_value</span> <span class="o">=</span> <span class="n">starting_value</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">__shares</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">num_stocks</span> <span class="o">+</span><span class="p">[</span><span class="n">starting_value</span><span class="p">])</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
   <span class="nd">@property</span>
   <span class="k">def</span> <span class="nf">shares</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shares</span>
   <span class="nd">@property</span>
   <span class="k">def</span> <span class="nf">account_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__account_value</span>
   <span class="nd">@shares.setter</span>
   <span class="k">def</span> <span class="nf">shares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_shares</span><span class="p">):</span>

       <span class="bp">self</span><span class="o">.</span><span class="n">__shares</span> <span class="o">=</span> <span class="n">new_shares</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">'shares'</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shares</span><span class="p">)</span>
   <span class="nd">@account_value.setter</span>
   <span class="k">def</span> <span class="nf">account_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_act_val</span><span class="p">):</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">__account_value</span> <span class="o">=</span> <span class="n">new_act_val</span>
       <span class="k">try</span><span class="p">:</span>
           <span class="n">act_returns</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">account_value</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">'act_val'</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
       <span class="k">except</span><span class="p">:</span>
           <span class="n">act_returns</span> <span class="o">=</span><span class="mi">1</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">'act_val'</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">account_value</span><span class="p">)</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">'act_returns'</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">act_returns</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_portfolio</span><span class="p">):</span>
       <span class="sd">'''</span>
<span class="sd">       Get the next prices. Then transition the value of the account into the desired portfolio</span>
<span class="sd">       :param new_portfolio:</span>
<span class="sd">       :return:</span>
<span class="sd">       '''</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span><span class="mi">1</span>

       <span class="bp">self</span><span class="o">.</span><span class="n">update_acount_value</span><span class="p">(</span><span class="n">new_portfolio</span><span class="p">)</span>
       <span class="n">reward</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">'act_returns'</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#already includes transaction costs</span>
       <span class="n">state</span> <span class="o">=</span> <span class="p">{</span>
           <span class="s2">"prices"</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">prices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lookback</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">+</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="c1"># All prices upto now inclusive but no cash</span>
           <span class="s2">"portfolio"</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">portfolio</span><span class="p">,</span>

       <span class="p">}</span>
       <span class="n">done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prices</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span>
       <span class="k">return</span> <span class="n">state</span><span class="p">,</span><span class="n">reward</span><span class="p">,</span><span class="n">done</span>

   <span class="k">def</span> <span class="nf">update_acount_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_portfolio</span><span class="p">):</span>
       <span class="n">currentShareValues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">]</span>
       <span class="n">currentAccountValue</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">currentShareValues</span><span class="p">)</span>

       <span class="n">currentPortfolioProportions</span> <span class="o">=</span> <span class="n">currentShareValues</span> <span class="o">/</span> <span class="n">currentAccountValue</span>
       <span class="n">desiredCashChange</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_portfolio</span> <span class="o">-</span><span class="n">currentPortfolioProportions</span> <span class="p">)</span><span class="o">*</span> <span class="n">currentAccountValue</span>

       <span class="n">desiredChangeInShares</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">desiredCashChange</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">prices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">])</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shares</span> <span class="o">+</span> <span class="n">desiredChangeInShares</span>
       <span class="n">newAccountValue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shares</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">])</span>
       <span class="c1">#becuse we take the floor, sometimes we lose cash for no reason. This is a fix</span>
       <span class="n">missingCash</span>  <span class="o">=</span> <span class="n">currentAccountValue</span> <span class="o">-</span> <span class="n">newAccountValue</span>
       <span class="n">transactionCost</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">desiredChangeInShares</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">costPerShare</span><span class="p">)</span>

       <span class="bp">self</span><span class="o">.</span><span class="n">shares</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">missingCash</span> <span class="o">-</span> <span class="n">transactionCost</span>

       <span class="n">transactionCost</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">desiredChangeInShares</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">costPerShare</span><span class="p">)</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s2">"changeInShares"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">desiredChangeInShares</span><span class="p">)</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s2">"transactionCosts"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transactionCost</span><span class="p">)</span>

       <span class="bp">self</span><span class="o">.</span><span class="n">account_value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shares</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">prices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">])</span>
</code></pre></div><h2><b>实际学习的东西</b></h2><p>强化学习能分成两种主流的方法，Policy方法和Value方法。其中，Policy方法决定模型下一步应该做什么，Value方法确定最好的决策是什么。通常比较流行并且效果较好的方法是将这两者混合起来，并且加上现代的Actor批判方法。</p><p>我们认为Value的估计在金融上的应用是有问题的，除非你设置一个非常聪明的模型来定义收益回报。但是如果你没有深入研究透彻，使用收益或风险调整后的收益作为奖励，那么这是一个非常嘈杂的信号。这就是为什么我们怀疑在这种情况下的Value函数。（感兴趣的读者可以阅读QLBS论文，该论文用一种Value函数进行了完美的实现）</p><p><i><a href="http://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1712.04609.pdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">arxiv.org/pdf/1712.0460</span><span class="invisible">9.pdf</span><span class="ellipsis"></span></a></i></p><figure><noscript><img src="https://pic4.zhimg.com/v2-8dba16ddfffd7f011cb945faba720467_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="1216" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-8dba16ddfffd7f011cb945faba720467_r.jpg"></noscript><img src="https://pic4.zhimg.com/v2-8dba16ddfffd7f011cb945faba720467_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="1216" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-8dba16ddfffd7f011cb945faba720467_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-8dba16ddfffd7f011cb945faba720467_b.jpg"></figure><p>有趣的是，当我们研究由正弦波产生的价格时，Actor-Critic方法（近似于状态值）比pure policy好得多，但是一旦加入噪音更大的数据，它们似乎只会让事情变得更糟而不是更好。</p><p>互联网有很多关于强化学习算法的资料，而github上拥有很多算法实现。实际上，这里讨论的代码是在github从Denny Britz的repo中复制的。</p><p><i><a href="http://link.zhihu.com/?target=https%3A//github.com/dennybritz/reinforcement-learning" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/dennybritz/r</span><span class="invisible">einforcement-learning</span><span class="ellipsis"></span></a></i></p><figure><noscript><img src="https://pic2.zhimg.com/v2-9dd98afd7ab6e3f07b15ce4d472b376d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="809" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-9dd98afd7ab6e3f07b15ce4d472b376d_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-9dd98afd7ab6e3f07b15ce4d472b376d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="809" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-9dd98afd7ab6e3f07b15ce4d472b376d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-9dd98afd7ab6e3f07b15ce4d472b376d_b.jpg"></figure><p>此外，虽然RL背后的想法非常深刻，但他们的应用主要是关于良好的工程设计和使问题的现实适应它们。因此，由于这些原因，本节仍然很短。</p><h2><b>投资组合操作</b></h2><p>我们希望Agent的行为是投资组合在n只股票和现金上的权重（一共n+1个权重）。</p><p>互联网上的大多数RL资料上都说，当你想要连续动作时需要从高斯分布中采样；如果你想要多重连续动作时（投资组合的权重），那么你需要从多元高斯分布中采样。</p><p>高斯分布函数有着各种不满意的属性，他们就像概率分布中的Kardashians。我们希望为每个股票分配一个权重，介于0和1之间，且所有权重总和恰好为1。此时多元高斯分布只能给出- inf和inf之间的数字，没有约束，这是不令人满意的。事实上，更糟糕的是，高斯分布下softmaxing的输出将是的Agent几乎无法训练。</p><p>除此之外，多元高斯分布一般通过各变量及其协方差矩阵的均值进行拟合。要计算这么多的参数，还要编写一些复杂的程序以使深层的输出成为半正定对称矩阵。所以在这两个问题之间，我们宁愿使用一些更具体的方法来解决这个问题。</p><h2><b>讨厌Dirichlet函数，喜欢Dirichlet分布</b></h2><p>这是因为我么恩在一个关于Dirichlet函数的cal 1中失败了。</p><p><i><a href="http://link.zhihu.com/?target=http%3A//mathworld.wolfram.com/DirichletFunction.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">mathworld.wolfram.com/D</span><span class="invisible">irichletFunction.html</span><span class="ellipsis"></span></a></i></p><figure><noscript><img src="https://pic1.zhimg.com/v2-59b014ffc6cbb60804af69fe601246d0_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="641" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-59b014ffc6cbb60804af69fe601246d0_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-59b014ffc6cbb60804af69fe601246d0_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="641" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-59b014ffc6cbb60804af69fe601246d0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-59b014ffc6cbb60804af69fe601246d0_b.jpg"></figure><p>幸运的是，有一个更加合适的分布供我们抽样。Dirichlet(K) distribution是K-单纯形上的一个分布。N只股票和现金的投资组合是N + 1 维空间上的一个点，因此从Dirichlet（N + 1）分布中抽样就可以得到一个投资组合。</p><p>虽然这个函数不是内置于Tensorflow中，但它内置于Tensorflow Propability中，因此整个实现过程非常简单：</p><p><i><a href="http://link.zhihu.com/?target=https%3A//www.tensorflow.org/probability/api_docs/python/tfp/distributions/Dirichlet" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">tensorflow.org/probabil</span><span class="invisible">ity/api_docs/python/tfp/distributions/Dirichlet</span><span class="ellipsis"></span></a></i></p><div class="highlight"><pre><code class="language-python"><span></span><span class="bp">self</span><span class="o">.</span><span class="n">alphas</span><span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">contrib</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fully_connected</span><span class="p">(</span>
         <span class="n">inputs</span><span class="o">=</span><span class="n">l2</span><span class="p">,</span>
         <span class="n">num_outputs</span><span class="o">=</span><span class="n">num_stocks</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">activation_fn</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">,</span>
         <span class="n">weights_initializer</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">glorot_uniform</span><span class="p">)</span>

     <span class="bp">self</span><span class="o">.</span><span class="n">alphas</span> <span class="o">+=</span><span class="mi">1</span>

     <span class="bp">self</span><span class="o">.</span><span class="n">dirichlet</span>  <span class="o">=</span> <span class="n">tfp</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">Dirichlet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alphas</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirichlet</span><span class="o">.</span><span class="n">_sample_n</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">action</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">action</span><span class="p">)</span>
</code></pre></div><p>就这么简单。</p><h2><b>反思</b></h2><p>我们从Dirichlet分布中抽样的想法在理论上是非常棒的，但是在实践中则被证明是一无是处的。有两种现象不很很好。</p><p>首先，我们在每一步都采样一个新的分布，这意味着我们正在改变位置。这是低效的，但是当你从分布中进行采样时这是不可避免的。更糟糕的是，我们因为调整投资组合获得了负的收益回报（交易成本），但没有机制维持原有的投资组合权重不变。</p><p>其次，在每一步采样新的投资组合看起来是愚蠢的。我们认为应该对改变投资组合的决策进行抽样，然后在必要时对投资组合进行抽样。这样可以使用分布的方差（或方差向量的范数）来做出这个决策。</p><p>这是我们目前最感兴趣的问题。总之，它在数学上做到了我想要的，但是在实践上却做得一塌糊涂。</p><h2><b>其他问题</b></h2><p>另一个问题是赋予模型的奖励。目前Reward只是账户的对数收益（股票价值的变化 - 交易成本）。我们认为在多股票环境中这一方式噪声过多了，但即使在单只股票正弦波的环境中也是一个不好的收益定义。Agent了解到最简单的赚钱方法是购买市场上涨最大的股票。</p><p>同样，可能有很多bug。我们纯粹是为了好玩而编写了这段代码且没有编写测试，讲真，RL是一个极其需要测试的领域。每个bug都可能很糟糕，因为通常你不知道它是一个错误还是要求比你预期更复杂的系统。它会暴露你每个工程上的坏习惯和不正确的假设。</p><h2><b>未来</b></h2><p>讲真，如果这是一台印钞机，我们就不会把它放在互联网上了。我们认为交易员确实可以寻找合适的应用RL取赚钱的途径，但是这一过程中还有很多工作要做，如果你能够执行它，你可能有更好的选择。</p><p>然而，我们发现这是非常有趣的。金融领域有很多问题，深度强化学习能让你从有趣的角度看待它们。</p><h2><b>如何获取代码</b></h2><a href="http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/Rvc5fXnbDPMJftp13xF4hg" data-draft-node="block" data-draft-type="link-card" data-image="https://pic1.zhimg.com/v2-c92412f47db0e66cf6a1e4e005caa8f0_180x120.jpg" data-image-width="910" data-image-height="387" class=" wrap external" target="_blank" rel="nofollow noreferrer">深度 | 强化学习应用金融投资组合优化（附代码）</a><p></p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
