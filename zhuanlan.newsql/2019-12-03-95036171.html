<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TiDB Binlog 源码阅读系列文章（六）Pump Storage 介绍（下）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/95036171">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-cf68ef645aebb053bc01b25e81db5071_b.jpg" alt=""></div><p>作者：Chunzhu Li</p><p>在 <a href="https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-binlog-source-code-reading-5/" class=" wrap external" target="_blank" rel="nofollow noreferrer">上篇文章</a> 中，我们主要介绍了 Pump Storage 是如何对 binlog 进行持久化存储、排序、配对的。在文中我们提到 binlog 的持久化键值存储主要是由 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/vlog.go" class=" wrap external" target="_blank" rel="nofollow noreferrer">valueLog</a></code> 组件完成的。同时，大家如果在上文点开 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/storage.go%23L889" class=" wrap external" target="_blank" rel="nofollow noreferrer">writeToValueLog</a></code> 代码阅读的话会发现在其中还会使用一个 <code>slowChaser</code> 组件。<code>slowChaser</code> 组件主要用于避免在写 kv 环节中 GoLevelDB 写入太慢甚至出现 write paused 时影响 Pump Storage 的执行效率的问题。</p><p>接下来，本篇文章重点介绍 <code>valueLog</code> 与 <code>slowChaser</code> 这两个组件。</p><h2>valueLog</h2><p><code>valueLog</code> 组件的代码位于 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/vlog.go%23L156" class=" wrap external" target="_blank" rel="nofollow noreferrer">pump/storage/vlog.go</a> 中，主要作用是管理磁盘中的所有存放 Binlog Event 的 logFile 文件。Pump 本地 GoLevelDB 中存储的 key value 中，key 用 Binlog 的 <code>StartTs/CommitTs</code> 拼成，value 则只是一个索引，指向 <code>valueLog</code> 中的一条 Binlog 记录。<code>valueLog</code> 的结构体定义如下所示：</p><div class="highlight"><pre><code class="language-text">type valueLog struct {
	buf *bytes.Buffer // buf to write to the current log file

	dirPath   string
	sync      bool
	maxFid    uint32
	filesLock sync.RWMutex
	filesMap  map[uint32]*logFile

	opt *Options
}</code></pre></div><p>logFile 文件在 Pump 指定数据目录下会以类似 “000001.log” 的命名保存，其中的 “000001” 即为表示 logFile 文件编号的 Fid。<code>valueLog</code> 中的 <code>maxFid</code> 为文件中最大的 Fid，<code>valueLog</code> 也只会把 binlog 写到 maxFid 的 logFile。 filesMap 中会保存所有的 Fid 编号所对应的 logFile 对象。logFile 包含了单个 logFile 的一些属性和方法，主要包含在 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/log.go%23L51" class=" wrap external" target="_blank" rel="nofollow noreferrer">pump/storage/log.go</a> 中。</p><p>valueLog 作为持久化 Binlog Event 到 logFiles 的组件，包含了一系列对 logFiles 进行的操作。下面我们来看看其中几个比较重要的方法。</p><h3>1. <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/vlog.go%23L297" class=" wrap external" target="_blank" rel="nofollow noreferrer">readValue</a></code></h3><p>该函数的作用是使用上一篇文章中提到的 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/vlog.go%23L123" class=" wrap external" target="_blank" rel="nofollow noreferrer">valuePointer</a></code> 在磁盘的 logFiles 中定位到对应的 Binlog Event。该函数会在 Pump 向 Drainer 发 Binlogs 和向 TiKV 查询 Binlog 的提交状态时被用到。</p><h3>2. <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/vlog.go%23L314" class=" wrap external" target="_blank" rel="nofollow noreferrer">write</a></code></h3><p>顾名思义，主要作用是处理 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/vlog.go%23L100" class=" wrap external" target="_blank" rel="nofollow noreferrer">写 binlog 请求</a>，在上一篇文章中提到的 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/storage.go%23L889" class=" wrap external" target="_blank" rel="nofollow noreferrer">writeToValueLog</a> 被用到，不是并发安全的。为了提高写入效率，<code>write</code> 函数在处理一组写 binlog request 时，会先使用 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/log.go%23L83" class=" wrap external" target="_blank" rel="nofollow noreferrer">encodeRecord</a> 函数把将要写入的 binlog event 编码后存入 <code>bufReqs</code> 数组，随后再通过 <code>toDisk</code> 函数写入 logFile 文件。如果要写入的目标 logFile 文件已经很大，则新建并切换到新的 log 文件，同时增大 maxFid。</p><p>一个完整的 binlog 文件的编码格式在 log.go <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/log.go%23L33" class=" wrap external" target="_blank" rel="nofollow noreferrer">开头注释</a> 中：</p><div class="highlight"><pre><code class="language-text">/*
log file := records + log file footer
record :=
  magic: uint32   // magic number of a record start
  length: uint64  // payload 长度
  checksum: uint32   // checksum of payload
  payload:  uint8[length]    // binlog 数据
footer :=
  maxTS: uint64     // the max ts of all binlog in this log file, so we can check if we can safe delete the file when gc according to ts
  fileEndMagic: uint32  // check if the file has a footer
*/</code></pre></div><p>一个 binlog 文件中往往包含了多条 record。一条 record 中开头的 16 个字节为 record 头：其中前 4 个字节为表示 record 数据开始的 magic 码；中间 8 个字节保存了该条 record 的长度；最后 4 个字节为 checksum，用于校验。record 头后面紧跟的是单个 binlog event 的二进制编码。这样编码的一大好处是 <code>valueLog</code> 只需要 Offset 参数就能得到 binlog 编码段。</p><p>完整的 log 文件尾部还有一个 footer。valueLog 不会向已经有 footer 的 log 文件写入新的 binlog event。footer 的前 8 个字节为该 logFile 中所有 Binlog 的 maxTS，该值可用于后面介绍到的 GC 操作。后 4 个字节为表示文件已结束的 magic 码。</p><h3>3. <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/vlog.go%23L202" class=" wrap external" target="_blank" rel="nofollow noreferrer">openOrCreateFiles</a></code></h3><p>在 Pump Storage 启动时会使用该函数启动 <code>valueLog</code> 组件，初始化 <code>valueLog</code> 的配置信息，读取磁盘的 log 文件并将文档信息导入到 <code>filesMap</code> 中。</p><p>在 <code>valueLog</code> 启动时，如果要写入的 logFile 没有 footer，则该函数会使用 <code>scan</code> 方法扫描该 logFile 的所有 binlog，求出 <code>maxTS</code> 更新至内存。因此在关闭 <code>valueLog</code> 时，如果当前文件已经较大，则将文件加上 footer，将内存中的 <code>maxTS</code> 持久化到 footer 以节省下次启动 <code>valueLog</code> 时进行 <code>scan</code> 查询的时间。</p><h3>4. <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/vlog.go%23L415" class=" wrap external" target="_blank" rel="nofollow noreferrer">scan</a></code> 与 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/vlog.go%23L386" class=" wrap external" target="_blank" rel="nofollow noreferrer">scanRequests</a></code></h3><p>扫描某个 <code>valuePointer</code> 之后的所有在 logFiles 中的 binlog event，并将读到的 binlog event 通过 <code>fn</code> 函数进行对应的处理。Pump Storage 在重启时会使用该函数读取持久化到 vlog 但还没将索引写到 kv 的 binlog event 并 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/storage.go%23L229" class=" wrap external" target="_blank" rel="nofollow noreferrer">交给 kv 组件处理</a>。为提高效率，scan 只在读取文件列表时加文件锁，读取完毕开始扫描后如果有并发写入的 logFile 则不会被 scan 扫到。</p><h3>5. <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/vlog.go%23L442" class=" wrap external" target="_blank" rel="nofollow noreferrer">gcTS</a></code></h3><p>在 Storage 进行 GC 时使用，前面 write 中提到的 <code>maxTS</code> 即在这里使用。该函数会直接删掉磁盘目录下所有 <code>maxTS</code> 小于 <code>gcTS</code> 的 logFile 以节约磁盘空间。</p><h2>slowChaser</h2><p><code>slowChaser</code> 组件的代码主要位于 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/chaser.go" class=" wrap external" target="_blank" rel="nofollow noreferrer">pump/storage/chaser.go</a> 中。其结构体定义如下所示：</p><div class="highlight"><pre><code class="language-text">type slowChaser struct {
	on                 int32
	vlog               valLogScanner
	lastUnreadPtr      *valuePointer
	recoveryTimeout    time.Duration
	lastRecoverAttempt time.Time
	output             chan *request
	WriteLock          sync.Mutex
}</code></pre></div><p><b>看到这里，相信大家也一定有个疑问：既然 Pump 已经有了正常写 binlogs 的链路，为什么我们还要再引入</b> <b><code>slowChaser</code></b> <b>组件呢？</b></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-60eaf7c835ab40acf184f4d5cd2a99c2_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="287" class="origin_image zh-lightbox-thumb" width="939" data-original="https://pic3.zhimg.com/v2-60eaf7c835ab40acf184f4d5cd2a99c2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-60eaf7c835ab40acf184f4d5cd2a99c2_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="287" class="origin_image zh-lightbox-thumb lazy" width="939" data-original="https://pic3.zhimg.com/v2-60eaf7c835ab40acf184f4d5cd2a99c2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-60eaf7c835ab40acf184f4d5cd2a99c2_b.jpg"/></figure><p>在上篇文章中我们提到，当 Pump Server 收到 binlog 后，会按照 vlog -&gt; kv -&gt;  sorter 的顺序传递 binlog，每一条 binlog 都会在上一步写入完成后发送给下一步组件的输入 channel。在 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/storage.go%23L1367" class=" wrap external" target="_blank" rel="nofollow noreferrer">写 kv 时</a>，GoLevelDB 可能会因为执行 compaction 导致写入变慢甚至出现 write paused 现象。此时，当 vlog -&gt; kv channel 装满后，则需要 <code>slowChaser</code> 来处理后续的 binlog 到 kv。</p><h3>slowChaser 的初始化与启动</h3><p><code>slowChaser</code> 会在调用 <code>writeValueLog</code> 函数的一开始就被实例化，并同时开启线程运行 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/chaser.go%23L72" class=" wrap external" target="_blank" rel="nofollow noreferrer">slowChaser.Run()</a></code>。但此时 <code>slowChaser</code> 并未开始扫描，只是开始监视 Pump 写 kv 的速度。</p><p>开启 <code>slowChaser</code> 的代码位于 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/storage.go%23L946" class=" wrap external" target="_blank" rel="nofollow noreferrer">writeValueLog</a></code>。当我们发现向 buffer channel 中写入 request <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/storage.go%23L945" class=" wrap external" target="_blank" rel="nofollow noreferrer">等待的时间超过 1 秒</a>，<code>slowChaser</code> 便会被开启。同时从该 binlog 开始之后在 <code>writeValueLog</code> 中写入磁盘的 binlog 均不会再再传递进 vlog -&gt; kv 之间的 buffer channel，直到 <code>slowChaser</code> 被关闭为止。</p><p>因为 <code>slowChaser</code> 是可能被多次启停的，因此在 <code>slowChaser</code> 的 <code>Run</code> 函数中我们使用 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/chaser.go%23L150" class=" wrap external" target="_blank" rel="nofollow noreferrer">waitUntilTurnedOn</a></code> 函数每隔 0.5 秒就检查 <code>slowChaser</code> 的启动状态。</p><h3>slowChaser 的扫描操作：catchUp</h3><p><code>slowChaser</code> 在被启动后会使用 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/chaser.go%23L130" class=" wrap external" target="_blank" rel="nofollow noreferrer">catchUp</a></code> 函数去扫描磁盘目录，从 <code>lastUnreadPtr</code> 即第一个没有被写 kv 的 binlog 的 <code>valuePointer</code> 开始。该值会在启动 <code>slowChaser</code> 时设置为当时的 binlog 对应的 <code>valuePointer</code>，之后会在每次成功写入 kv 后就更新。</p><p>有了起始 <code>valuePointer</code> 以后，<code>slowChaser</code> 会使用前文提到的 <code>valueLog</code> 的 <code>scanRequests</code> 方法进行一次扫描。扫描时 chaser 会把扫出的每条 binlog 逐一发给 toKV channel。</p><h3>slowChaser 的运行与关闭</h3><p>在前面介绍了 <code>slowChaser</code> 的作用，但我们应当注意的是 <code>slowChaser</code> 毕竟是一个 “slow” 的组件，是针对写 kv 缓慢的无奈之举，从硬盘中扫描读取 binlog 再写 kv 的操作是必然慢于直接从内存写 kv 的。因此 <code>slowChaser</code> 启动扫描后，我们就应该观察写 kv 的速度是否已经恢复正常，以及在磁盘中的 binlog 是否已经全部写到 kv，从而适时关掉 <code>slowChaser</code> 以提高运行速度。基于此，下面我们将介绍 <code>slowChaser</code> 的 <code>catchUp</code> 与关闭操作，主要涉及 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/chaser.go%23L72" class=" wrap external" target="_blank" rel="nofollow noreferrer">slowChaser.Run()</a></code> 的 for 循环里的代码。</p><p><code>slowChaser</code> 在每轮运行时会进行至多两次 <code>catchUp</code> 操作：</p><ul><li>第一次 <code>catchUp</code> 操作不会使用写锁禁止 <code>valueLog</code> 组件写 logFile 到磁盘。在正常扫描完磁盘中的 binlog 后，chaser 会同时计算本次 <code>catchUp</code> 所花费的时间，如果花费时间较短，说明这可能是个恢复正常运转的好时机。这时 <code>slowChaser</code> 会进入第二次 <code>catchUp</code> 操作，尝试扫完所有 binlog 并关闭 <code>slowChaser</code>。如果本次 <code>catchUp</code> 花费时间过长或者在 1 分钟内进行过第二次的 <code>catchUp</code> 操作则会跳过第二次 <code>catchUp</code> 直接进入下一轮。</li><li>第二次 <code>catchUp</code> 会在操作开始前记录本次恢复开始的时间，同时上锁阻止 vlog 写 binlog 到磁盘。如果 <code>catchUp</code> 在 1 秒内完成，此时磁盘中所有 binlog 都已经写到 kv ， 则 <code>slowChaser</code> 可以安全地被关闭。如果 <code>catchUp</code> 超时，为避免长时间持锁阻止 vlog 写 binlog 影响性能，<code>slowChaser</code> 将继续进行下一轮的 <code>catchUp</code>。第二次 catchUp 操作结束时不论成败互斥锁都将被释放。</li></ul><p><code>slowChaser</code> 在成功 catch up 之后会被关闭，但不会完全停止运行，只是进入了 “睡眠” 状态，继续不断监视 Pump 写 kv 的速度。一旦 <code>writeValueLog</code> 中再次出现了写 kv 慢的现象，<code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-binlog/blob/9f3c81683bb3428c4940611a6203288474d4aff0/pump/storage/chaser.go%23L58" class=" wrap external" target="_blank" rel="nofollow noreferrer">slowChaser.TurnOn</a></code> 被调用，<code>slowChaser</code> 又会重新启动，开始新的轮次的 <code>catchUp</code> 操作。只有当 <code>writeValueLog</code> 函数退出时，<code>slowChaser</code> 才会真正随之退出并完全停止运行。</p><h2>小结</h2><p>本文介绍了 Pump Storage 的两个重要组件 <code>valueLog</code>，<code>slowChaser</code> 的主要功能与具体实现，希望能帮助大家更好地理解 Pump 部分的源码。</p><p>至此 TiDB Binlog 源码的 Pump 部分的代码已基本介绍完毕，在下一篇文章中我们将开始介绍 Drainer Server 模块，帮助大家理解 Drainer 是如何启动，维护状态与获取全局 binlog 数据与 Schema 信息的。</p><p><b>原文阅读：</b></p><a href="https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-binlog-source-code-reading-6/" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg" data-image-width="1200" data-image-height="1200" class=" wrap external" target="_blank" rel="nofollow noreferrer">TiDB Binlog 源码阅读系列文章（六）Pump Storage 介绍（下） | PingCAP</a><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
