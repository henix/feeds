<blockquote>文本译自 <a href="https://www.zhihu.com/people/67ebe1bd8e4a63f17a42572e40afaac7" class="internal">@千里冰封 你懂吗</a> 介绍<a href="https://link.zhihu.com/?target=https%3A//ice1000.org/2019/08-20-Cutt1.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">立方类型论</a>的文章。</blockquote><p>（注意：本章尽量简短了些）</p><p>回忆<a href="https://zhuanlan.zhihu.com/p/102323224" class="internal">上一章</a>的内容，我们有了 <code>max</code>、<code>min</code>和<code>neg</code>，且构造出了对称（symmetry）的路径。</p><div class="highlight"><pre><code class="language-text">{-# OPTIONS --cubical --allow-unsolved-metas #-}
module 2019-8-20-Cutt1 where
open import Cubical.Core.Everything

variable A : Set</code></pre></div><h2>路径的路径</h2><p>现在我们用路径（Path）做些有趣的事情。我们从常量路径（Constant Path）开始：</p><div class="highlight"><pre><code class="language-text">reflEx : (a : A) → a ≡ a
reflEx a = λ i → a</code></pre></div><p>我们在 <code>reflEx a</code> 之间构造一个路径：</p><div class="highlight"><pre><code class="language-text">reflReflEx : (a : A) → reflEx a ≡ reflEx a
reflReflEx a = λ j i → a</code></pre></div><p>我们可以直观地把 <code>reflReflEx a</code> 画成一条路径，其端点同样也是路径：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-9d988f350e5423558d5e0bb916893a7c_b.jpg" data-caption="" data-size="normal" data-rawwidth="538" data-rawheight="201" class="origin_image zh-lightbox-thumb" width="538" data-original="https://pic1.zhimg.com/v2-9d988f350e5423558d5e0bb916893a7c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-9d988f350e5423558d5e0bb916893a7c_b.jpg" data-caption="" data-size="normal" data-rawwidth="538" data-rawheight="201" class="origin_image zh-lightbox-thumb lazy" width="538" data-original="https://pic1.zhimg.com/v2-9d988f350e5423558d5e0bb916893a7c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-9d988f350e5423558d5e0bb916893a7c_b.jpg"/></figure><p>我们可以把上图重绘成平面的形式：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-35d84bc1769629fb64bddea3401e4e42_b.jpg" data-caption="" data-size="normal" data-rawwidth="430" data-rawheight="452" class="origin_image zh-lightbox-thumb" width="430" data-original="https://pic3.zhimg.com/v2-35d84bc1769629fb64bddea3401e4e42_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-35d84bc1769629fb64bddea3401e4e42_b.jpg" data-caption="" data-size="normal" data-rawwidth="430" data-rawheight="452" class="origin_image zh-lightbox-thumb lazy" width="430" data-original="https://pic3.zhimg.com/v2-35d84bc1769629fb64bddea3401e4e42_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-35d84bc1769629fb64bddea3401e4e42_b.jpg"/></figure><p>看起来就是个方形（Square）！</p><h2>方形</h2><p>为了彻底理解方形，我们需要深入研究刚才所做的事情。</p><p>路径是接受<b>一个</b>间点作为参数的 λ-表达式。而方形只不过是接受<b>两个</b>间点的 λ-表达式。</p><p>我们的方形 <code>reflReflEx a = λ j i → a</code> 之所以能够通过类型检查，是因为它就是个常量方形。 类型检查器可以向 <code>reflReflEx a</code> 传入任意间点作为参数，而它们都会返回 <code>a</code>， 正如我们写在类型中写的那样。假设 <code>p = reflReflEx a</code>，我们可以列出一些编译器可以执行的检查：</p><ul><li><code>p i0 i0</code> 是否可转换为 <code>reflEx a i0</code></li><ul><li>（这里的 <code>reflEx a</code> 是类型 <code>reflEx a ≡ reflEx a</code> 的<b>左式</b>）</li></ul><li><code>p i1 i0</code> 是否可转换为 <code>reflEx a i0</code></li><ul><li>（这里的 <code>reflEx a</code> 是类型 <code>reflEx a ≡ reflEx a</code> 的<b>右式</b>）</li></ul><li><code>p i0 i1</code> 是否可转换为 <code>reflEx a i1</code></li><ul><li>（这里的 <code>reflEx a</code> 是类型 <code>reflEx a ≡ reflEx a</code> 的<b>左式</b>）</li></ul><li><code>p i1 i1</code> 是否可转换为 <code>reflEx a i1</code></li><ul><li>（这里的 <code>reflEx a</code> 是类型 <code>reflEx a ≡ reflEx a</code> 的<b>右式</b>）</li></ul><li><code>p i0 j</code> 是否可转换为 <code>reflEx a j</code></li><ul><li>（这里的 <code>reflEx a</code> 是类型 <code>reflEx a ≡ reflEx a</code> 的<b>左式</b>）</li></ul><li><code>p i1 j</code> 是否可转换为 <code>reflEx a j</code></li><ul><li>（这里的 <code>reflEx a</code> 是类型 <code>reflEx a ≡ reflEx a</code> 的<b>右式</b>）</li></ul></ul><p>如果我们想要一条两个未知路径之间的路径，事情就会变得有些复杂：</p><div class="highlight"><pre><code class="language-text">pathPath : (a : A) → (p q : a ≡ a) → p ≡ q
pathPath a p q = λ j i → {!a!}</code></pre></div><p>我们无法在目标中填入 <code>a</code>， 因为即便 <code>p i0</code> 和 <code>p i1</code> 明显可以转换为 <code>a</code>（而 <code>a</code> 就是我们想要在路径-λ 中返回的东西），我们也不能说对于所有的 <code>i : I</code>，<code>p i</code> 都能转换为 <code>a</code> – 我们不知道两个已知端点 <code>p</code> 和 <code>q</code> <b>之间</b>的东西是什么。我们无法对于所有的间点参数都简单地返回 <code>a</code>，因为它并不涉及 <code>p</code> 和 <code>q</code> 的间点。此时我们也可以说 <code>p ≡ q</code> <b>并不是</b>一个常量方形。</p><p>我们可以对常量方形执行 <code>λ j i → a</code> 是因为 <code>reflEx a</code> 的间点已知为 <code>λ i → a</code>。</p><h2>方形的性质</h2><p>我们首先假设有一个方形，其四个端点为 <code>a b c d : A</code>：</p><div class="highlight"><pre><code class="language-text">module UseOfSquares
  (a b c d : A)</code></pre></div><p>接着我们需要两条路径 <code>p</code> 和 <code>q</code>，一条从 <code>a</code> 到 <code>b</code>，另一条从 <code>c</code> 到 <code>d</code>：</p><div class="highlight"><pre><code class="language-text">  (p : a ≡ b)
  (q : c ≡ d)</code></pre></div><p>此时，如果我们想要一条从 <code>p</code> 到 <code>q</code> 的路径，就不能简单地写成 <code>something : p ≡ q</code>， 因为 <code>≡</code> 的定义需要两个端点的类型相同，而 <code>p</code> 和 <code>q</code> 的类型不同。 该方形的另一个名字叫做 <b>异质相等性（Heterogeneous Equality）</b>。 幸运的是，路径类型的设计考虑到了这种情况：有一种类型叫 <code>PathP</code>，它首先接受一条类型 <code>A</code> 和 <code>B</code> 之间的路径（于是你要证明 <code>A</code> 等于 <code>B</code>），然后接受 <code>A</code> 和 <code>B</code> 的实例各一个。</p><p>所以，为了绕过这个定型的问题，我们在 <code>a</code> 和 <code>b</code> 之间建立两条不同的路径 <code>p</code> 和 <code>q</code>：</p><div class="highlight"><pre><code class="language-text">  (p : a ≡ b)
  (q : a ≡ b)</code></pre></div><p>最后我们就有了这个方形：</p><div class="highlight"><pre><code class="language-text">  (s : p ≡ q)
  where</code></pre></div><p>它的图形如下：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-f1693cef33717831d951ddd4237a6087_b.jpg" data-caption="" data-size="normal" data-rawwidth="450" data-rawheight="438" class="origin_image zh-lightbox-thumb" width="450" data-original="https://pic4.zhimg.com/v2-f1693cef33717831d951ddd4237a6087_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-f1693cef33717831d951ddd4237a6087_b.jpg" data-caption="" data-size="normal" data-rawwidth="450" data-rawheight="438" class="origin_image zh-lightbox-thumb lazy" width="450" data-original="https://pic4.zhimg.com/v2-f1693cef33717831d951ddd4237a6087_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-f1693cef33717831d951ddd4237a6087_b.jpg"/></figure><p>现在我们来做些有趣的事情。首先，此方形的左侧边和右侧边就是方形的端点， 毕竟方形就是路径的路径：</p><div class="highlight"><pre><code class="language-agda">  left : a ≡ b
  left = s i0

  right : a ≡ b
  right = s i1</code></pre></div><p>不过顶边和底边是什么？好吧，这次我就不卖关子了：</p><div class="highlight"><pre><code class="language-text">  top : a ≡ a
  top = λ i → s i i0

  bottom : b ≡ b
  bottom = λ i → s i i1</code></pre></div><p>而反柯里化（uncurrying）后的 <code>left</code> 和 <code>right</code> 能让 <code>top</code> 和 <code>bottom</code> 更加清晰：</p><div class="highlight"><pre><code class="language-text">  left′ : a ≡ b
  left′ = λ i → s i0 i

  right′ : a ≡ b
  right′ = λ i → s i1 i</code></pre></div><p>（请图形化地想象上面的四个函数，你应该可以想象出这种简单的图像）</p><p>我们也可以将 <code>s</code> 旋转 180 度，即将它上下翻转后左右翻转（<code>sym</code> 即对称翻转， 你可以点击<a href="https://link.zhihu.com/?target=https%3A//ice1000.org/lagda/Cubical.Foundations.Prelude.html%23893" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a>查看它的定义）：</p><div class="highlight"><pre><code class="language-text">open import Cubical.Foundations.Prelude

rotate : (sym q) ≡ (sym p)
rotate = λ i j → s (~ i) (~ j)</code></pre></div><p>它的图像如下：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-fe1cbe308b2eabfd721cf63a4bad8d72_b.jpg" data-caption="" data-size="normal" data-rawwidth="457" data-rawheight="444" class="origin_image zh-lightbox-thumb" width="457" data-original="https://pic3.zhimg.com/v2-fe1cbe308b2eabfd721cf63a4bad8d72_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-fe1cbe308b2eabfd721cf63a4bad8d72_b.jpg" data-caption="" data-size="normal" data-rawwidth="457" data-rawheight="444" class="origin_image zh-lightbox-thumb lazy" width="457" data-original="https://pic3.zhimg.com/v2-fe1cbe308b2eabfd721cf63a4bad8d72_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-fe1cbe308b2eabfd721cf63a4bad8d72_b.jpg"/></figure><h2>对角线</h2><p>我们也可以找出 <code>s</code> 的对角线（Diagonal）。 考虑一条从左下角到右上角的线，这条对角线也是一条路径，它的端点 <code>i0</code> 是 <code>s</code> 的左下角，而端点 <code>i1</code> 是 <code>s</code> 的右上角：</p><div class="highlight"><pre><code class="language-text">diagonal : a ≡ b
diagonal = λ i → s i i</code></pre></div><p>它的图象是：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-bb883ce5d0ccf92e027e50d741ad86f2_b.jpg" data-caption="" data-size="normal" data-rawwidth="454" data-rawheight="429" class="origin_image zh-lightbox-thumb" width="454" data-original="https://pic3.zhimg.com/v2-bb883ce5d0ccf92e027e50d741ad86f2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-bb883ce5d0ccf92e027e50d741ad86f2_b.jpg" data-caption="" data-size="normal" data-rawwidth="454" data-rawheight="429" class="origin_image zh-lightbox-thumb lazy" width="454" data-original="https://pic3.zhimg.com/v2-bb883ce5d0ccf92e027e50d741ad86f2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-bb883ce5d0ccf92e027e50d741ad86f2_b.jpg"/></figure><p>我觉得它很好理解了。</p><h2>方形的构造</h2><p>玩过一会儿现有的方形后，我们来构造一些新的！这此我们同样假设 <code>p : a ≡ b</code>：</p><div class="highlight"><pre><code class="language-text">module ConstructionOfSquares
  (a b : A)
  (p : a ≡ b)
  where</code></pre></div><p>最简单的方形就是 <code>p</code> 的常量路径：</p><div class="highlight"><pre><code class="language-text">  easist : p ≡ p
  easist = reflEx _</code></pre></div><p>当然我们还可以做更多：我们可以把 <code>p</code> 看作一个未知方形的对角线：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-ea87254323599b00d08625b9f4e589b4_b.jpg" data-caption="" data-size="normal" data-rawwidth="450" data-rawheight="432" class="origin_image zh-lightbox-thumb" width="450" data-original="https://pic1.zhimg.com/v2-ea87254323599b00d08625b9f4e589b4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-ea87254323599b00d08625b9f4e589b4_b.jpg" data-caption="" data-size="normal" data-rawwidth="450" data-rawheight="432" class="origin_image zh-lightbox-thumb lazy" width="450" data-original="https://pic1.zhimg.com/v2-ea87254323599b00d08625b9f4e589b4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-ea87254323599b00d08625b9f4e589b4_b.jpg"/></figure><p>还有两个端点是未知的。</p><p>很容易想到几种构造方形的方式：</p><ul><li><code>a</code> 在左上角，<code>b</code> 在右下角（一个常量路径的路径）</li><li><code>b</code> 在左上角，<code>a</code> 在右下角（一个常量路径）</li></ul><p>不过，我们还可以让它们都是 <code>a</code>，或者都是 <code>b</code>！ 关键在于使用 <code>∧</code> (min) 和 <code>∨</code> (max) 运算符。</p><p>当二者均为 <code>a</code> 时，该方形的表达式为 <code>λ i j → p (i ∧ j)</code> （此方形后面称之为 <code><b>minSq</b></code>）。然而我们目前还无法确定此方形的类型， 不过我们可以画出它的图像（我们还会在下一章使用此结构）！</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-91e1321169b4a1e185a052a3783811ba_b.jpg" data-caption="" data-size="normal" data-rawwidth="454" data-rawheight="449" class="origin_image zh-lightbox-thumb" width="454" data-original="https://pic3.zhimg.com/v2-91e1321169b4a1e185a052a3783811ba_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-91e1321169b4a1e185a052a3783811ba_b.jpg" data-caption="" data-size="normal" data-rawwidth="454" data-rawheight="449" class="origin_image zh-lightbox-thumb lazy" width="454" data-original="https://pic3.zhimg.com/v2-91e1321169b4a1e185a052a3783811ba_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-91e1321169b4a1e185a052a3783811ba_b.jpg"/></figure><p>我在方形中挑选了两个点 <code>x</code> 和 <code>y</code> 来解释为什么此图像表示 <code>p (i ∧ j)</code>。</p><p>方形中的每个点都可以看作该方形应用到两个间点后的值，其中一个间点可以看作横坐标， 而另一则是纵坐标。例如，我们可以将 <code>minSq i j</code> 看作下图中对应的点：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-416087b28a1016e27155a587ffa90007_b.jpg" data-caption="" data-size="normal" data-rawwidth="430" data-rawheight="436" class="origin_image zh-lightbox-thumb" width="430" data-original="https://pic4.zhimg.com/v2-416087b28a1016e27155a587ffa90007_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-416087b28a1016e27155a587ffa90007_b.jpg" data-caption="" data-size="normal" data-rawwidth="430" data-rawheight="436" class="origin_image zh-lightbox-thumb lazy" width="430" data-original="https://pic4.zhimg.com/v2-416087b28a1016e27155a587ffa90007_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-416087b28a1016e27155a587ffa90007_b.jpg"/></figure><p>从这个视角来看，<code>x</code> 在对角线的上方，我们可以说 <code>x</code> 的纵坐标<b>大于</b>横坐标。<code>y</code> 在对角线的下方，因此它与 <code>x</code> 相反。</p><p>如果我们说 <code>x</code> 是 <code>minSq i j</code>（它求值为 <code>p (i ∧ j)</code>），并且我们已知 <code>j &gt; i</code>，那么我们可以将 <code>i ∧ j</code> 化简为 <code>i</code>，于是 <code>x</code> 就成为了 <code>p i</code>。<code>y</code> 则会变成 <code>p j</code>。 而左上角就是 <code>minSq i0 i1</code>，它可规约为 <code>p (i0 ∧ i1)</code>，接着规约为 <code>p i0</code>，然后规约为 <code>a</code>。 右下角则是 <code>minSq i1 i0</code>，它会归约为 <code>a</code>。 </p><p>我们可以将这种映射画成下图：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-f2942ddcbec5ef0490448944e3b05ff1_b.jpg" data-caption="" data-size="normal" data-rawwidth="467" data-rawheight="461" class="origin_image zh-lightbox-thumb" width="467" data-original="https://pic2.zhimg.com/v2-f2942ddcbec5ef0490448944e3b05ff1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-f2942ddcbec5ef0490448944e3b05ff1_b.jpg" data-caption="" data-size="normal" data-rawwidth="467" data-rawheight="461" class="origin_image zh-lightbox-thumb lazy" width="467" data-original="https://pic2.zhimg.com/v2-f2942ddcbec5ef0490448944e3b05ff1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-f2942ddcbec5ef0490448944e3b05ff1_b.jpg"/></figure><h3>练习</h3><p>请模仿我的解释过程来解释 <code>λ i j → p (i ∨ j)</code> 并画出它的图像。我想你可以在脑子里想出来！</p>