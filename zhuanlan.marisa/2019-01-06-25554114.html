<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Haskell中的范畴之积与和</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/25554114">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-924d4313803502a678947a3a87a51d29_b.jpg" alt=""></div><p>在上一篇<a href="https://zhuanlan.zhihu.com/p/25565309" class="internal">Haskell中的范畴之函子和自然变换 - 知乎专栏</a>文章中，介绍了函子和自然变换。于是我们可以接下来使用对象0和对象1、函子和自然变换来构造一些常用的代数结构，比如两个范畴的积、范畴内的对象的积与和、指数类型。</p><p>从现在开始，要精确的用Haskell代码来描述范畴论的概念就比较难了，而且也没有那么直观了，我在这之后的这一系列文章将会使用更直观但不够精确的方式来用Haskell代码来描述范畴论的概念。有兴趣的可以参考Edward kmett写的Hask（<a href="http://link.zhihu.com/?target=https%3A//github.com/ekmett/hask" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/ekmett/hask</span><span class="invisible"></span></a>）</p><p>这个package，这是一个严谨而精确的用Haskell代码来描述范畴论概念的库，不过理解这个库有一定的门槛。</p><ul><li><b>积范畴</b></li></ul><p>把两个范畴拼在一起，我们就得到了积范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1"> ，其对象是一对对象&lt; a1, a2 &gt;，其中a1是第一个范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 的对象，a2是第二个范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 的对象。积范畴的态射是一对态射&lt; f1, f2 &gt; ，其中f1: a1 -&gt; b1是第一个范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 中的态射，f2: a2 -&gt; b2是第二个范畴 <img src="https://www.zhihu.com/equation?tex=+%5Cmathcal%7BC%7D" alt=" \mathcal{C}" eeimg="1"> 中的态射。</p><p>积范畴的单位元是 id = &lt;id, id&gt;，态射的组合是 &lt;g1, g2&gt; . &lt;f1, f2&gt; = &lt;g1 . f1, g2 . f 2&gt;。</p><p>积范畴的Hom-Set，记为 <img src="https://www.zhihu.com/equation?tex=Hom_%7B%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D%7D+%28%3Ca1%2C+b1%3E%2C+%3Ca2%2C+b2%3E%29" alt="Hom_{\mathcal{C} \times \mathcal{C}} (&lt;a1, b1&gt;, &lt;a2, b2&gt;)" eeimg="1">  。</p><p>由于无法在Haskell中表示积范畴，只好以如下的伪代码形式表示： </p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="c1">-- 下面是Haskell的伪代码，不能编译运行，只用来表述积范畴 Hask × Hask</span>
<span class="kr">instance</span> <span class="kt">Category</span> <span class="o">&lt;</span><span class="kt">Hask</span><span class="p">,</span> <span class="kt">Hask</span><span class="o">&gt;</span> <span class="kr">where</span>
  <span class="n">id</span> <span class="ow">=</span> <span class="o">&lt;</span><span class="n">id</span><span class="p">,</span> <span class="n">id</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="o">&gt;</span> <span class="o">.</span> <span class="o">&lt;</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="o">&gt;</span> <span class="ow">=</span> <span class="o">&lt;</span><span class="n">g1</span> <span class="o">.</span> <span class="n">f1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">.</span> <span class="n">f2</span><span class="o">&gt;</span>
</code></pre></div><p>范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1"> 和范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 之间是存在态射的，也即函子。</p><p>范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1"> 到范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 的函子中有两个简单的函子 OutL : <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D+%5Cto+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C} \to \mathcal{C}" eeimg="1"> 和  OutR : <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D+%5Cto+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C} \to \mathcal{C}" eeimg="1"> ，其实现如下</p><p>                                     OutL &lt;a1, a2&gt; = a1           OutL &lt;f1, f2&gt; = f1</p><p>                                     OutR &lt;a1, a2&gt; = a2          OutR &lt;f1, f2&gt; = f2</p><p>范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 到范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1"> 的函子中有一个简单的函子 ∆ : <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Cto+%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \to \mathcal{C} \times \mathcal{C}" eeimg="1"> ，称为对角函子，其实现如下</p><p>                                     ∆ a = &lt;a, a&gt;                       ∆ f = &lt;f, f&gt;</p><ul><li><b>二函子</b></li></ul><p>范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1"> 到范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 的函子称为二函子(Bifunctor)。二函子的一般形式是 <img src="https://www.zhihu.com/equation?tex=%28+-+%5Cotimes+-+%29+%3A+%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BD%7D+%5Cto+%5Cmathcal%7BE%7D" alt="( - \otimes - ) : \mathcal{C} \times \mathcal{D} \to \mathcal{E}" eeimg="1"> ，当我们固定住左边，则得到了部分应用函子<img src="https://www.zhihu.com/equation?tex=%28+a+%5Cotimes+-+%29+%3A+%5Cmathcal%7BD%7D+%5Cto+%5Cmathcal%7BE%7D" alt="( a \otimes - ) : \mathcal{D} \to \mathcal{E}" eeimg="1"> 。当我们固定住右边，则得到了部分应用函子 <img src="https://www.zhihu.com/equation?tex=%28+-+%5Cotimes+b+%29+%3A+%5Cmathcal%7BC%7D+%5Cto+%5Cmathcal%7BE%7D" alt="( - \otimes b ) : \mathcal{C} \to \mathcal{E}" eeimg="1"> 。这两个部分应用函子对任意的态射 f : a1 -&gt; a2 和态射 g : b1 -&gt; b2 满足如下的性质：</p><p><img src="https://www.zhihu.com/equation?tex=%28f+%5Cotimes+g%29+%3D+%28a2+%5Cotimes+g%29+%5Ccdot+%28f+%5Cotimes+b1%29%3D%28f+%5Cotimes+b2%29+%5Ccdot+%28a1+%5Cotimes+g%29+%5C%5C" alt="(f \otimes g) = (a2 \otimes g) \cdot (f \otimes b1)=(f \otimes b2) \cdot (a1 \otimes g) \\" eeimg="1"> </p><p>这个性质同时也说明若我们有两个部分应用函子，只有满足上述性质的两个部分应用函子才可以组合成一个二函子。</p><p>我们前面提到的范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 上的Hom函子<img src="https://www.zhihu.com/equation?tex=Hom_%5Cmathcal%7BC%7D%28-%2C%5C+-%29" alt="Hom_\mathcal{C}(-,\ -)" eeimg="1">，简记为 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D%28-%2C%5C+-%29" alt="\mathcal{C}(-,\ -)" eeimg="1"> ，也是一个二函子，只是这个二函子相对第一个变量是反变的，因此也叫反变二函子（Profunctor）。同样的，Hom函子也可以得到两个部分应用函子，分别是协变Hom函子<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D%28a%2C%5C+-%29" alt="\mathcal{C}(a,\ -)" eeimg="1"> 和 反变Hom函子<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D%28-%2C%5C+b%29" alt="\mathcal{C}(-,\ b)" eeimg="1">。</p><p>若我们有态射 h : a1 -&gt; b1，由于协变Hom函子<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D%28a%2C%5C+-%29" alt="\mathcal{C}(a,\ -)" eeimg="1"> 对态射 g : b1 -&gt; b2 是协变的，因此 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D%28a1%2C%5C+g%29+%5C+h+%3D+g+%5Ccdot+h" alt="\mathcal{C}(a1,\ g) \ h = g \cdot h" eeimg="1">。</p><p>同样的，由于反变Hom函子<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D%28-%2C%5C+b%29" alt="\mathcal{C}(-,\ b)" eeimg="1"> 对态射 f : a1 -&gt; a2 是反变的，因此 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D%28f%5E%7Bop%7D%2C%5C+b1%29+%5C+h+%3D+h+%5Ccdot+f" alt="\mathcal{C}(f^{op},\ b1) \ h = h \cdot f" eeimg="1">。这里态射<img src="https://www.zhihu.com/equation?tex=f%5E%7Bop%7D" alt="f^{op}" eeimg="1"> : a2 -&gt; a1 是态射 f 的对偶。</p><p>根据二函子需要满足的部分应用函子的性质，并注意对第一个变量是反变的，我们可以得到：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D%28f%5E%7Bop%7D%2C%5C+g%29+%3D+%5Cmathcal%7BC%7D%28a2%2C%5C+g%29+%5Ccdot+%5Cmathcal%7BC%7D%28f%5E%7Bop%7D%2C%5C+b1%29+%3D+%5Cmathcal%7BC%7D%28f%5E%7Bop%7D%2C%5C+b2%29+%5Ccdot+%5Cmathcal%7BC%7D%28a1%2C%5C+g%29+%5C%5C" alt="\mathcal{C}(f^{op},\ g) = \mathcal{C}(a2,\ g) \cdot \mathcal{C}(f^{op},\ b1) = \mathcal{C}(f^{op},\ b2) \cdot \mathcal{C}(a1,\ g) \\" eeimg="1"> </p><p>从协变Hom函子和反变Hom函子的特性，我们有</p><p><img src="https://www.zhihu.com/equation?tex=%28%5Cmathcal%7BC%7D%28a2%2C%5C+g%29+%5Ccdot+%5Cmathcal%7BC%7D%28f%5E%7Bop%7D%2C%5C+b1%29%29+%5C+h+%3D+g+%5Ccdot+%28h+%5Ccdot+f%29+%5C%5C" alt="(\mathcal{C}(a2,\ g) \cdot \mathcal{C}(f^{op},\ b1)) \ h = g \cdot (h \cdot f) \\" eeimg="1"> </p><p>和</p><p><img src="https://www.zhihu.com/equation?tex=%28%5Cmathcal%7BC%7D%28f%5E%7Bop%7D%2C%5C+b2%29+%5Ccdot+%5Cmathcal%7BC%7D%28a1%2C%5C+g%29%29+%5C+h+%3D+%28g+%5Ccdot+h%29+%5Ccdot+f+%5C%5C" alt="(\mathcal{C}(f^{op},\ b2) \cdot \mathcal{C}(a1,\ g)) \ h = (g \cdot h) \cdot f \\" eeimg="1"> </p><p>于是我们从<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D%28-%2C%5C+-%29" alt="\mathcal{C}(-,\ -)" eeimg="1">这个二函子的部分应用函子的性质，得到了态射的结合律</p><p><img src="https://www.zhihu.com/equation?tex=g+%5Ccdot+%28h+%5Ccdot+f%29+%3D+%28g+%5Ccdot+h%29+%5Ccdot+f+%5C%5C" alt="g \cdot (h \cdot f) = (g \cdot h) \cdot f \\" eeimg="1"> </p><p>在Haskell的Hask范畴中，同样可以得到如上的性质</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="p">(</span><span class="n">fmap</span> <span class="n">g</span> <span class="o">.</span> <span class="n">contramap</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">f</span><span class="p">))</span> <span class="n">h</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">g</span> <span class="p">(</span><span class="n">contramap</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">f</span><span class="p">)</span> <span class="n">h</span><span class="p">)</span>
                                          <span class="ow">=</span> <span class="n">fmap</span> <span class="n">g</span> <span class="p">(</span><span class="kt">Op</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">f</span> <span class="o">.</span> <span class="n">getOp</span> <span class="n">h</span><span class="p">))</span>
                                          <span class="c1">-- Op f . Op h = Op (h . f)</span>
                                          <span class="ow">=</span> <span class="n">fmap</span> <span class="n">g</span> <span class="p">(</span><span class="n">h</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
                                          <span class="ow">=</span> <span class="n">g</span> <span class="o">.</span> <span class="p">(</span><span class="n">h</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
<span class="p">(</span><span class="n">contramap</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">f</span><span class="p">)</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">g</span><span class="p">)</span> <span class="n">h</span> <span class="ow">=</span> <span class="n">contramap</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">f</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">g</span> <span class="n">h</span><span class="p">)</span>
                                          <span class="ow">=</span> <span class="n">contramap</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">f</span><span class="p">)</span> <span class="p">(</span><span class="n">g</span> <span class="o">.</span> <span class="n">h</span><span class="p">)</span>
                                          <span class="ow">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">f</span> <span class="o">.</span> <span class="n">getOp</span> <span class="p">(</span><span class="n">g</span> <span class="o">.</span> <span class="n">h</span><span class="p">))</span>
                                          <span class="ow">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">.</span> <span class="n">h</span><span class="p">)</span> <span class="o">.</span> <span class="n">f</span>
<span class="nf">g</span> <span class="o">.</span> <span class="p">(</span><span class="n">h</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">.</span> <span class="n">h</span><span class="p">)</span> <span class="o">.</span> <span class="n">f</span>
</code></pre></div><p>将一个函子<img src="https://www.zhihu.com/equation?tex=F%3A+%5Cmathcal%7BC%7D+%5Cto+%5Cmathcal%7BD%7D" alt="F: \mathcal{C} \to \mathcal{D}" eeimg="1"> 应用到范畴<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的对象a，我们就得到了范畴<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BD%7D" alt="\mathcal{D}" eeimg="1">中的对象F a，这个函子的应用操作也是一个二函子 <img src="https://www.zhihu.com/equation?tex=%28-%5C+%5C+-%29+%3A+%5Cmathcal%7BD%7D%5E%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D+%5Cto+%5Cmathcal%7BD%7D" alt="(-\ \ -) : \mathcal{D}^\mathcal{C} \times \mathcal{C} \to \mathcal{D}" eeimg="1"> 。是一个从函子范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BD%7D%5E%5Cmathcal%7BC%7D" alt="\mathcal{D}^\mathcal{C}" eeimg="1"> 与范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 的积范畴到范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BD%7D" alt="\mathcal{D}" eeimg="1"> 的二函子。其两个部分应用函子分别是 <img src="https://www.zhihu.com/equation?tex=%28F%5C+%5C+-%29+%3A+%5Cmathcal%7BC%7D+%5Cto+%5Cmathcal%7BD%7D" alt="(F\ \ -) : \mathcal{C} \to \mathcal{D}" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=%28-%5C+%5C+a%29+%3A+%5Cmathcal%7BD%7D%5E%5Cmathcal%7BC%7D+%5Cto+%5Cmathcal%7BD%7D" alt="(-\ \ a) : \mathcal{D}^\mathcal{C} \to \mathcal{D}" eeimg="1"> ，这里 <img src="https://www.zhihu.com/equation?tex=%28F+%5C+%5C+-%29" alt="(F \ \ -)" eeimg="1"> 就是函子 F ，而 <img src="https://www.zhihu.com/equation?tex=%28-+%5C+%5C+a%29" alt="(- \ \ a)" eeimg="1"> 则和自然变换有关。</p><p>由二函子需要满足的部分应用函子的性质，和函子<img src="https://www.zhihu.com/equation?tex=G%3A+%5Cmathcal%7BC%7D+%5Cto+%5Cmathcal%7BD%7D" alt="G: \mathcal{C} \to \mathcal{D}" eeimg="1"> ，以及自然变换 <img src="https://www.zhihu.com/equation?tex=t+%3A+F+%5CRightarrow+G" alt="t : F \Rightarrow G" eeimg="1"> ，我们可以得到</p><p><img src="https://www.zhihu.com/equation?tex=t+%5C+f+%3D+%28G+%5C+f%29+%5Ccdot+t_%7Ba1%7D+%3D+t_%7Ba2%7D+%5Ccdot+%28F+%5C+f%29+%5C%5C" alt="t \ f = (G \ f) \cdot t_{a1} = t_{a2} \cdot (F \ f) \\" eeimg="1"> </p><p>这就是自然变换的交换关系。</p><p>二函子和对角函子都是重要的函子，在后续的章节中会陆续有相应的介绍。</p><ul><li><b>范畴上的积</b></li></ul><p>若我们可以在范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 中找到一个对象 <img src="https://www.zhihu.com/equation?tex=b1+%5Ctimes+b2" alt="b1 \times b2" eeimg="1"> 来表示积范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1">中的一对对象&lt;b1, b2&gt;，且这个对象具有如下的性质，那我们就称范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的对象<img src="https://www.zhihu.com/equation?tex=b1+%5Ctimes+b2" alt="b1 \times b2" eeimg="1"> 是范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的对象b1和对象b2的积。</p><p><b>积对象的泛性质：</b>范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的积对象<img src="https://www.zhihu.com/equation?tex=b1+%5Ctimes+b2" alt="b1 \times b2" eeimg="1"> 和一对态射outl : b1 x b2 -&gt; b1 和outr : b1 x b2 -&gt; b2，对任意一个对象a 和一对态射 f1 : a -&gt; b1 和 f2 : a -&gt; b2，存在唯一的态射g : a -&gt; b1 x b2，满足如下等式：</p><p>                 f1 = outl . g   和    f2 = outr . g</p><p>态射 g 也可表示为 f1 △ f2，于是有</p><p>                    g = f1 △ f2</p><p>当 f1 和 f2 分别是 outl 和 outr时，态射 g 就是积对象<img src="https://www.zhihu.com/equation?tex=b1+%5Ctimes+b2" alt="b1 \times b2" eeimg="1"> 上的 id 态射了，于是有</p><p>                   id = outl △ outr</p><p>在Hask范畴中，用(b1, b2)来表示积对象<img src="https://www.zhihu.com/equation?tex=b1+%5Ctimes+b2" alt="b1 \times b2" eeimg="1">，用Haskell代码表示如下</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="cm">{-# LANGUAGE TypeOperators #-}</span>

<span class="c1">-- Hask范畴中用 (b1, b2) 表示积对象 b1 x b2</span>
<span class="kr">type</span> <span class="n">b1</span> <span class="o">*</span> <span class="n">b2</span> <span class="ow">=</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>

<span class="nf">outl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b1</span> <span class="o">*</span> <span class="n">b2</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b1</span>
<span class="nf">outl</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>        <span class="c1">-- outl = fst</span>
<span class="nf">outr</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b1</span> <span class="o">*</span> <span class="n">b2</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b2</span>
<span class="nf">outr</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">y</span>        <span class="c1">-- outr = snd</span>

<span class="c1">-- g = f1 △ f2, 用 /\来表示 △算子</span>
<span class="p">(</span><span class="o">/\</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b1</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b2</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">))</span>
<span class="nf">f1</span> <span class="o">/\</span> <span class="n">f2</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f1</span> <span class="n">x</span><span class="p">,</span> <span class="n">f2</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div><p>积对象的泛性质 f1 = outl . g 和 f2 = outr . g 的证明如下</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="p">(</span><span class="n">outl</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="n">f1</span> <span class="n">f2</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f1</span> <span class="n">x</span><span class="p">,</span> <span class="n">f2</span> <span class="n">x</span><span class="p">))</span>
                    <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">f1</span> <span class="n">x</span><span class="p">,</span> <span class="n">f2</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f1</span> <span class="n">x</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f1</span> <span class="n">x</span><span class="p">,</span> <span class="n">f2</span> <span class="n">x</span><span class="p">))</span>
                    <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f1</span> <span class="n">x</span>
                    <span class="ow">=</span> <span class="n">f1</span>

<span class="p">(</span><span class="n">outr</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="n">f1</span> <span class="n">f2</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f1</span> <span class="n">x</span><span class="p">,</span> <span class="n">f2</span> <span class="n">x</span><span class="p">))</span>
                    <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">f1</span> <span class="n">x</span><span class="p">,</span> <span class="n">f2</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f2</span> <span class="n">x</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f1</span> <span class="n">x</span><span class="p">,</span> <span class="n">f2</span> <span class="n">x</span><span class="p">))</span>
                    <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f2</span> <span class="n">x</span>
                    <span class="ow">=</span> <span class="n">f2</span>
</code></pre></div><p>如果对积范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1">中的任意一对对象&lt;b1, b2&gt; 都可以在范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中找到积对象 <img src="https://www.zhihu.com/equation?tex=b1+%5Ctimes+b2" alt="b1 \times b2" eeimg="1"> ，那积运算就是范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1"> 到范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 的二函子 × 。其将积范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1">中的对象&lt;b1, b2&gt;变换为范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的积对象 <img src="https://www.zhihu.com/equation?tex=b1+%5Ctimes+b2" alt="b1 \times b2" eeimg="1"> 。将积范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1">中的态射&lt;f1, f2&gt; 变换为范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的态射f1 × f2，其定义如下：</p><p>             f1 × f2 = (f1 . outl) △ (f2 . outr)</p><p>容易证明二函子 × 满足函子定律，即满足如下等式：</p><p>              id = id × id</p><p>              g1 . f1 × g2 . f2 = (g1 × g2) . (f1 × f2)</p><p><br></p><ul><li><b>范畴上的和</b></li></ul><p>若我们可以在范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 中找到一个对象 <img src="https://www.zhihu.com/equation?tex=a1+%2B+a2" alt="a1 + a2" eeimg="1"> 来表示积范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1">中的一对对象&lt;a1, a2&gt;，且这个对象具有如下的性质，那我们就称范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的对象<img src="https://www.zhihu.com/equation?tex=a1+%2B+a2" alt="a1 + a2" eeimg="1"> 是范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的对象a1和对象a2的和。</p><p><b>积对象的泛性质：</b>范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的和对象<img src="https://www.zhihu.com/equation?tex=a1+%2B+a2" alt="a1 + a2" eeimg="1"> 和一对态射inl : a1 -&gt; a1 + a2 和inr : a2 -&gt; a1 + a2，对任意一个对象b 和一对态射 g1 : a1 -&gt; b 和g2 : a2 -&gt; b，存在唯一的态射 f : a1 + a2 -&gt; b，满足如下等式：</p><p>                 g1 = f . inl   和    g2 = f . inr</p><p>态射 f 也可表示为 g1 ▽ g2，于是有</p><p>                    f = g1 ▽ g2</p><p>当 g1 和 g2 分别是 inl 和 inr时，态射 f 就是和对象<img src="https://www.zhihu.com/equation?tex=a1+%2B+a2" alt="a1 + a2" eeimg="1"> 上的 id 态射了，于是有</p><p>                   id = inl ▽ inr</p><p>在Hask范畴中，用Either a1 a2来表示和对象<img src="https://www.zhihu.com/equation?tex=a1+%2B+a2" alt="a1 + a2" eeimg="1">，用Haskell代码表示如下</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="cm">{-# LANGUAGE TypeOperators #-}</span>

<span class="c1">-- Hask范畴中用 Either a1 a2 表示积对象 a1 + a2</span>
<span class="kr">type</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">a2</span> <span class="ow">=</span> <span class="kt">Either</span> <span class="n">a1</span> <span class="n">a2</span>

<span class="nf">inl</span> <span class="ow">::</span> <span class="n">a1</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a1</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span>
<span class="nf">inl</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">x</span>        <span class="c1">-- inl = Left</span>
<span class="nf">inr</span> <span class="ow">::</span> <span class="n">a2</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a1</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span>
<span class="nf">inr</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="n">y</span>        <span class="c1">-- inr = Right</span>

<span class="c1">-- f = g1 ▽ g2, 用 \/来表示 ▽算子</span>
<span class="p">(</span><span class="o">\/</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a1</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a2</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">((</span><span class="n">a1</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">(</span><span class="n">g1</span> <span class="o">\/</span> <span class="n">g2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">x</span><span class="p">)</span>   <span class="ow">=</span> <span class="n">g1</span> <span class="n">x</span>
<span class="p">(</span><span class="n">g1</span> <span class="o">\/</span> <span class="n">g2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">g2</span> <span class="n">y</span>
</code></pre></div><p>和对象的泛性质 g1 = f . inl 和 g2 = f . inr 的证明如下</p><div class="highlight"><pre><code class="language-text"><span></span>(f . inl) g1 g2   = (\(Left x) -&gt; b) . (\a1 -&gt; Left a1)
                    = \a1 -&gt; b
                    = g1

(f . inr) g1 g2 = (\(Right y) -&gt; b) . (\a2 -&gt; Right a2)
                    = \a2 -&gt; b
                    = g2
</code></pre></div><p>如果对积范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1">中的任意一对对象&lt;a1, a2&gt; 都可以在范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中找到和对象 <img src="https://www.zhihu.com/equation?tex=a1+%2B+a2" alt="a1 + a2" eeimg="1"> ，那和运算就是范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1"> 到范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1"> 的二函子 + 。其将积范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1">中的对象&lt;b1, b2&gt;变换为范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的和对象 <img src="https://www.zhihu.com/equation?tex=a1+%2B+a2" alt="a1 + a2" eeimg="1"> 。将积范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D+%5Ctimes+%5Cmathcal%7BC%7D" alt="\mathcal{C} \times \mathcal{C}" eeimg="1">中的态射&lt;g1, g2&gt; 变换为范畴 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BC%7D" alt="\mathcal{C}" eeimg="1">中的态射 g1 + g2，其定义如下：</p><p>             g1 + g2 = (inl . g1) ▽ (inr . g2)</p><p>容易证明二函子 + 满足函子定律，即满足如下等式：</p><p>              id = id + id</p><p>              g1 . f1 + g2 . f2 = (g1 + g2) . (f1 + f2)</p><p><br></p><p>在这一章中我们知道了什么是积范畴和二函子，以及如何构造范畴上的积与和，我们接下来就可以来介绍范畴论中很基本又很重要的米田引理了。有兴趣的读者可以期待下一章 Haskell中的范畴之米田引理。</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
