<p>前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。</p><p>———————————这是一条美丽的分割线——————————————</p><p><br></p><h3>5、 解密电路的深度</h3><p>上面有一个人说对了一半，其实我们可以把解密电路用AND电路和XOR电路表示出来，计算一下电路的深度（电路的深度是运算次数的对数，例如深度是d，计算次数就是log d），然后再和permitted functions中功能电路所允许的最大深度做个比较，就知道解密电路是否属于permitted functions集合了。</p><p><br></p><p>首先来分析permitted functions集合所允许的电路深度。由于permitted functions集合里的任一功能函数f 都可以用AND电路和XOR电路表出，而AND电路和XOR电路可以看做对输入的二进制位做乘法和加法，所以f电路的深度可以用输入位的对称多项式来衡量（用多项式衡量是因为多项式里恰好是变元的乘法和加法），<b>又由于乘法是噪音的主要来源，所以可以用多项式中乘法次数来做电路深度的主要衡量指标</b>。有：</p><p>c* = f ( c1, c2, …，cn ) = f ( m1+2r1+pq, m2+2r2+pq, …，mn+2rn+pq ) </p><p> = f ( m1+2r1, m2+2r2, …，mn+2rn ) +p(……)</p><p><br></p><p>密文c*的噪音为：c* mod p = f ( m1+2r1, m2+2r2, …，mn+2rn ), 要想c*解密正确必须有：f ( m1+2r1, m2+2r2, …，mn+2rn )&lt; p/2, 其中mi+2ri 是密文ci的噪音。不妨令mi+2ri = xi, 且xi &lt; B, B是密文ci噪音的上界，则有：</p><p>f ( x1, x2, …，xn ) &lt; p/2。</p><p><br></p><p>我们的目标是衡量f 的运算次数d，所以可以用初等对称多项式来表达f ，有：</p><p>f ( x1, x2, …，xn ) = x1x2…xd + x1x3…xd + ……；其中d&lt;=n</p><p>f ( x1, x2, …，xn )的每一项就是从n个变元( x1, x2, …，xn )里选取d个变元，因此有C（n, d）个项（C表示组合运算），由C（n, d）&lt; nd 得：</p><p>f ( x1, x2, …，xn ) &lt; Bd nd &lt; p/2 =&gt; d &lt; log p / log Bn , 也就是说f 最多运算次数为 log p / log Bn 。</p><p><br></p><p>下面再看看解密电路的运算次数：</p><p>Dec(c): (c mod p) mod 2=（c – p·「c/p」）mod 2 = Lsb(c) XOR Lsb(「c/p」)</p><p>仔细端详解密电路的公式，发觉其复杂性主要来源是c/p，所以我们主要看c/p所需的运算次数。c/p=c·p-1 , p-1是小数，为了保证c· p-1取整之后的的精确度，p-1要取log c 位的。例如 12345678× 0.111111 和 12345678× 0.11111111的结果取整后是不一样的。那么两个数相乘的次数如何衡量呢？有如下结论:</p><p><br></p><p> 乘两个t位数相当于加t个数: <b>输出位是关于输入位的一个2次多项式</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-5216ef706b4ae4ce77b6146acfd1e8f8_b.jpg" data-caption="" data-size="normal" data-rawwidth="416" data-rawheight="204" class="content_image" width="416"></noscript><img src="https://pic1.zhimg.com/v2-5216ef706b4ae4ce77b6146acfd1e8f8_b.jpg" data-caption="" data-size="normal" data-rawwidth="416" data-rawheight="204" class="content_image lazy" width="416" data-actualsrc="https://pic1.zhimg.com/v2-5216ef706b4ae4ce77b6146acfd1e8f8_b.jpg"></figure><p>加t个数可以应用“3-for-2 trick” : 3个数相加得到两个数相加，输出位是关于输入位的一个次数最多为2次的多项式</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_b.jpg" data-caption="" data-size="normal" data-rawwidth="730" data-rawheight="210" class="origin_image zh-lightbox-thumb" width="730" data-original="https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_b.jpg" data-caption="" data-size="normal" data-rawwidth="730" data-rawheight="210" class="origin_image zh-lightbox-thumb lazy" width="730" data-original="https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_b.jpg"></figure><p>其中a1b1+a1c1+b1c1是进位，注意它从形式上还是一个对称多项式。</p><p>那么t个数应用这个技巧经过log3/2 t 次相加后得到两个数，输出位的次数为2log3/2 t = tlog3/2 2= t1.71。</p><p>再看两个t位数相加：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_b.jpg" data-caption="" data-size="normal" data-rawwidth="689" data-rawheight="190" class="origin_image zh-lightbox-thumb" width="689" data-original="https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_r.jpg"></noscript><img src="https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_b.jpg" data-caption="" data-size="normal" data-rawwidth="689" data-rawheight="190" class="origin_image zh-lightbox-thumb lazy" width="689" data-original="https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_b.jpg"></figure><p>因此输出位的次数最多为t次，因为上面3位数相加次数最多为3次。</p><p>结合起来有：乘两个t位数的次数最多为2t1.71t=2t2.71，而c· p-1里c的位数为log c，p-1要取log c 位的，又因为log c &gt; log p (因为 p&lt;c)，所以c· p-1的次数至少是2(log p)2.71 , 而前面说过f最多运算次数为 log p / log Bn。</p><p>所以解密电路的深度要大于Evaluate所允许运行功能电路的深度，因此如果Evaluate运行解密电路的话，将会产生不正确的结果，我们就说Evaluate无法运行解密电路，换句话说解密电路不在permitted functions 集合里。</p><p>结论应该知道了吧，是一个坏消息。解密电路不在permitted functions 集合里，其后果就是：无法对密文进行任意功能的运算！与全同态失之交臂。</p><p>怎么办呢？古人云：兵来将挡，水来土掩。解密电路深了，把它变浅不就完了。说容易做起来有点难。我觉得有技巧的地方就在于压缩解密电路。</p><p>==========================================================================</p><p><b>文章首发在微信公众号：btc201800</b><br><b>知识星球ID：28018093</b></p><p><br><b>音频发布在喜马拉雅上“区块链杂谈 (第2季)”</b> <b><u><a href="http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">xima.tv/Bjq4se</span><span class="invisible"></span></a></u></b></p><p><b>解读区块链白皮书</b> <u><a href="http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">xima.tv/RNU1Q8</span><span class="invisible"></span></a></u></p><p><br><b>宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。</b></p>