<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Promise: 给我一个承诺，我还你一个承诺</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20209175">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/12f8d62eed8a079eea5c80f830184007_r.jpg" alt=""></div><p>处理concurrent programming，除了threading/multi-processing外，各家语言都有自己的绝活：erlang/elixir是actor model，golang/clojure（core.async）是CSP，haskell/clojure是STM，而javascript是event loop/callback。</p><br><p>callback可能是这几种并发模型里面最好懂的一种方式，就像好莱坞经纪人惯常的做法：don’t call me, I’ll call you back。比如打开数据库，打开要访问的表，写入一列新的数据这样一系列IO密集型的操作，如果同步去做，等待的时间要远大于运算的时间，而使用callback异步处理则消除了等待，大大增强了软件的并行性。然而，callback理解起来很直观，写起代码来很费劲，稍微复杂一些的处理，很容易搞成下图这样的pyramid of doom，也就是俗称的callback hell：</p><br><img src="https://pic4.zhimg.com/56a76815766d6fb718863c6bec43896c_r.jpg" data-rawwidth="972" data-rawheight="380"><br><p>当然，你可以通过重构，把严重嵌套，影响阅读的pyramid拆分成若干个小的pyramid，减少眼睛出血（eye-bleeding）的概率，但毕竟治标不治本。于是，在各种版本的第三方javascript类库里，大家都实现了各自的Promise/A+对象，来减少对callback的依赖。</p><br><p>Promise是这样一个对象，对于任意的异步操作，它提供了一组固定的API，才操作这个结果。我们先看一段代码：</p><br><img src="https://pic2.zhimg.com/a9a519c234fec1f29452525fec9a1ff8_r.jpg" data-rawwidth="2158" data-rawheight="796"><br><p>我们看到，如果要把一个异步操作封装成Promise，我们需要首先创建一个Promise对象，并提供一个包含两个参数 resolve，reject的函数，在这个函数里调用你的异步方法（这里用setTimeout模拟）。如果异步方法成功，则在其callback里面调用 resolve，提供成功后获得的数据；如果失败，则调用 reject，提供错误数据。这一般是类库提供者（producer）要做的事情。</p><br><p>对于类库调用者（consumer），拿到一个Promise对象，他可以调用 then 方法来获取异步后的数据，也可以调用 catch 来处理错误。Promise提供了如下机制来简化consumer的代码：</p><br><ul><li><p>then 依旧返回一个Promise，这样，代码的撰写由视觉上的横向延伸（callback hell）变成纵向扩展（chained operation），可读性增强</p></li><li><p>error propagation，在若干个Promise间不断chain的过程中，期间发生的任何error都会被一路传递到最后的Promise的 reject，方便程序员用一个 catch 捕获一条链上的错误，同样的，可读性大大增强</p></li></ul><p>我们看之前那个callback-hell使用Promise撰写后的代码：</p><br><img src="https://pic3.zhimg.com/6a62117784e2f1df1f9160f1a15bc3ae_r.jpg" data-rawwidth="1014" data-rawheight="352"><p>代码清晰了不少。下面是Promise处理的状态机：<br></p><br><img src="https://pic2.zhimg.com/835119a5c72db92a1ae89730a7af1251_r.jpg" data-rawwidth="801" data-rawheight="297"><br><p>在ES5，Promise并非原生支持，但有很多第三方的类库支持；在ES6中，Promise形成了一个标准，并且在语言层面原生支持。</p><br><p>Promise在实际使用中除了解决callback hell，让代码可读性增强外，还可以做很多事情。因为Promise实际上可以被视作一个Monad，所以你可以将其用在很多本来难以做composition的场合。比如你有一个处理，需要依赖多个数据源，他们或同步（数据已经在内存中直接可读），或异步（数据需要从数据库或者文件系统读取，甚至来自第三方API），正常来说似乎很难被抽象成一个数据结构。然而，你可以将这些数据源统统封装成Promise（同步的数据可以被视作一个状态立即走到resolved的Promise），这样，可以统一处理。比如说 Promise.all(iterable)（resolve所有结果，返回新的Promise），或者 Promise.race(iterable)（只要有一个结果resolve出来，就立即返回新的Promise，典型的anycast使用场景）。</p><br><p>目前nodejs的库函数还是callback方式，虽说手工转换成Promise非常简单，但毕竟不那么方便。在nodejs app里，你可以使用bluebird（或者es6-promisify）来批量转化nodejs的标准库。比如：</p><br><img src="https://pic2.zhimg.com/b0a540ea7bd8ed2fbdf6864de08a06ab_r.jpg" data-rawwidth="1140" data-rawheight="584">转化之后可以这么使用：<br><img src="https://pic2.zhimg.com/7af571d859d71c531cfceecd3e1f7be1_r.jpg" data-rawwidth="1290" data-rawheight="376"><p>最后，说说Promise的缺点。</p><br><p>第一，一个Promise只能resolve单个数据，对应于同步处理里的单值数据；如果要处理异步场景下的 "array"，那么，Observable是更好的方式。</p><br><img src="https://pic3.zhimg.com/dc1e36aa1bdf4fd178e949b9ab813475_r.jpg" data-rawwidth="1172" data-rawheight="656"><br><p>第二，Promise的API设计有些缺陷，并非lazy（可能是历史原因，也可能考虑到API友好程度），一旦启动，不可终止。如果你需要处理可终止的异步操作，那么，也需要使用Observable。下面是Promise和Observable的代码的对比，可以看到，一旦创建，Promise会立刻执行对象体内的代码（不管你有没有调用 then），而Observable直到subscriber真正要读取时（forEach）才会求值，而且，Observable提供了cancel的API：</p><br><img src="https://pic4.zhimg.com/8dd77be1e90e97afb50fd1748c7b4b29_r.jpg" data-rawwidth="2162" data-rawheight="1100">即便Oberservable已经开始运行，只要还未完成，调用者都有机会终止它。<br><p>OK，今天就先讲到这里，以后我们再讲Observable。</p><br><p>延伸阅读：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" data-title="MDN上的Promise介绍" class="" data-editable="true">MDN上的Promise介绍</a>。</p><br><p>如果您觉得这篇文章不错，请点赞。多谢！</p><br><p>欢迎订阅公众号『程序人生』（搜索微信号 programmer_life）。每篇文章都力求原汁原味，北京时间中午12点左右，美西时间下午8点左右与您相会。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
