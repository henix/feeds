<div class="title-image"><img src="https://pic2.zhimg.com/v2-976e6d0607f0dcb2d37e4e334e10ef32_b.jpg" alt=""></div><p>▎作者：Roman Paolucci</p><p><b>▎</b>编译：yana | 公众号翻译部</p><h2><b>量化开发</b></h2><p>通常量化研究员会用Python或R开发交易模型。然后把这些模型交给量化开发人员，用java或C++在交易系统中使用。量化交易员通常在这些系统的帮助下执行交易。作为一个研究员、开发人员和交易员，多年与Interactive Broker 的 Java API打交道。在这篇文章中，我们会建立一个算法交易系统，用于基于模型的自动交易执行。在开发交易系统时，在概念上有无限的设计模式可以遵循。但是，<b>本文的目的是为最常见的开发阶段提供简单的解决方案</b>。这篇文章分成三个部分：</p><p><b>• 连接Interactive Broker交易站（TWS）</b></p><p><b>• 创建实时市场数据流</b></p><p><b>• 实现自动交易执行模型</b></p><p>安装Interactive Brokers TWS：</p><p><i><a href="https://link.zhihu.com/?target=https%3A//www.interactivebrokers.com.hk/en/index.php%3Ff%3D16040" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">interactivebrokers.com.hk</span><span class="invisible">/en/index.php?f=16040</span><span class="ellipsis"></span></a></i></p><p>安装API：</p><p><i><a href="https://link.zhihu.com/?target=https%3A//www.interactivebrokers.com.hk/en/index.php%3Ff%3D5041" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">interactivebrokers.com.hk</span><span class="invisible">/en/index.php?f=5041</span><span class="ellipsis"></span></a></i></p><p>查看API文档：</p><p><i><a href="https://link.zhihu.com/?target=https%3A//interactivebrokers.github.io/tws-api/index.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">interactivebrokers.github.io</span><span class="invisible">/tws-api/index.html</span><span class="ellipsis"></span></a></i></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-c75d324e47267297f56d0480b41b139b_b.jpg" data-caption="" data-size="normal" data-rawwidth="764" data-rawheight="700" class="origin_image zh-lightbox-thumb" width="764" data-original="https://pic4.zhimg.com/v2-c75d324e47267297f56d0480b41b139b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-c75d324e47267297f56d0480b41b139b_b.jpg" data-caption="" data-size="normal" data-rawwidth="764" data-rawheight="700" class="origin_image zh-lightbox-thumb lazy" width="764" data-original="https://pic4.zhimg.com/v2-c75d324e47267297f56d0480b41b139b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-c75d324e47267297f56d0480b41b139b_b.jpg"/></figure><p><b>重点</b><br/></p><p>• <b>项目代码可以在文末下载。</b></p><p>• 如果您没有Interactive Brokers的账户，你可以使用模拟账户【用户名：edemo，密码：demouser】来跟随并免费建立一个交易系统。</p><p>• 假设你有中级Java编程经验。</p><p>• 假设你具有使用API的一些知识，并且能够在IDE中进行安装过程和设置。</p><p>• 在真实账户进行交易时，某些证券的实时市场数据流需要一级市场数据订阅，更多信息可在此处找到：</p><p><i><a href="https://link.zhihu.com/?target=https%3A//www.interactivebrokers.com/en/software/am3/am/settings/marketdatasubscriptions.htm" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">interactivebrokers.com/</span><span class="invisible">en/software/am3/am/settings/marketdatasubscriptions.htm</span><span class="ellipsis"></span></a></i><br/></p><h2><b>连接</b></h2><p>本节介绍用Java连接TWS以及该过程的几个特性。</p><h3><b>配置TWS</b></h3><p>第一步是配置您TWS。首先使用上面的模拟帐户或个人帐户登录，然后执行以下操作：</p><p class="ztext-empty-paragraph"><br/></p><p><b>选择 “Classic TWS” → 选择 “Conbgure” </b></p><p><b>选择 “API” → 启用 ActiveX 和 Client Sockets </b></p><p><b>禁用只读API → Apply → Ok</b></p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-8e7159b1bea196b75ae1f1b22be7a0fd_b.jpg" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="458" class="origin_image zh-lightbox-thumb" width="900" data-original="https://pic2.zhimg.com/v2-8e7159b1bea196b75ae1f1b22be7a0fd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-8e7159b1bea196b75ae1f1b22be7a0fd_b.jpg" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="458" class="origin_image zh-lightbox-thumb lazy" width="900" data-original="https://pic2.zhimg.com/v2-8e7159b1bea196b75ae1f1b22be7a0fd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-8e7159b1bea196b75ae1f1b22be7a0fd_b.jpg"/></figure><p>我们现在允许从127.0.0.1:7497进行API连接。</p><p>我们还允许Java通过禁用只读API来执行交易。</p><p>如果连接不成功，则可能需要转发端口。有关端口的更多信息，请参阅：主机和端口文档。<i><a href="https://link.zhihu.com/?target=https%3A//ibkr.info/node/2816" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">ibkr.info/node/2816</span><span class="invisible"></span></a></i></p><h2><b>连接处理</b></h2><p>到目前为止，假设您已经从Interactive Brokers安装了API，并在首选IDE中设置它的工作空间。我们将创建IConnectionHandler接口，来处理服务器和客户端之间的连接事件，从而实现Java和TWS之间建立连接：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-4c99c7a0034fd3ccbcbdb1050c012fad_b.jpg" data-caption="" data-size="normal" data-rawwidth="1056" data-rawheight="1244" class="origin_image zh-lightbox-thumb" width="1056" data-original="https://pic2.zhimg.com/v2-4c99c7a0034fd3ccbcbdb1050c012fad_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-4c99c7a0034fd3ccbcbdb1050c012fad_b.jpg" data-caption="" data-size="normal" data-rawwidth="1056" data-rawheight="1244" class="origin_image zh-lightbox-thumb lazy" width="1056" data-original="https://pic2.zhimg.com/v2-4c99c7a0034fd3ccbcbdb1050c012fad_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-4c99c7a0034fd3ccbcbdb1050c012fad_b.jpg"/></figure><p>接下来，需要创建ILogger接口的实现：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-b08026b1125cb1ba27fdf8f9673ebf2d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="402" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-b08026b1125cb1ba27fdf8f9673ebf2d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-b08026b1125cb1ba27fdf8f9673ebf2d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="402" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-b08026b1125cb1ba27fdf8f9673ebf2d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-b08026b1125cb1ba27fdf8f9673ebf2d_b.jpg"/></figure><p>既然我们知道如何处理连接和记录信息（使用我们的接口实现），就可以建立与TWS的连接。在项目的主要类Demo中连接到TWS：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-9e5a0b8864f136a6f3a639d56ae0c1b3_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="652" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-9e5a0b8864f136a6f3a639d56ae0c1b3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-9e5a0b8864f136a6f3a639d56ae0c1b3_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="652" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-9e5a0b8864f136a6f3a639d56ae0c1b3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-9e5a0b8864f136a6f3a639d56ae0c1b3_b.jpg"/></figure><p>主控制器是<b>ApiController</b>，通过它发送请求并从TWS接收响应。</p><p>连接成功，可以在终端中看到：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-c01f3713732a0630031c8021bc341daa_b.jpg" data-caption="" data-size="normal" data-rawwidth="987" data-rawheight="439" class="origin_image zh-lightbox-thumb" width="987" data-original="https://pic3.zhimg.com/v2-c01f3713732a0630031c8021bc341daa_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-c01f3713732a0630031c8021bc341daa_b.jpg" data-caption="" data-size="normal" data-rawwidth="987" data-rawheight="439" class="origin_image zh-lightbox-thumb lazy" width="987" data-original="https://pic3.zhimg.com/v2-c01f3713732a0630031c8021bc341daa_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-c01f3713732a0630031c8021bc341daa_b.jpg"/></figure><p>现在已成功连接到TWS，我们可以创建实时市场数据流来处理实时数据。</p><h2><b>实时数据流</b></h2><p>本节介绍设置市场数据流的过程。</p><h3><b>市场数据句柄</b></h3><p>与连接处理程序类似，必须创建ITopMktDataHandler接口的实例，以便处理服务器响应的数据。通过给实例方法传递参数的方式，从服务器接收数据。在数据发生变化时服务器对其进行响应，因此Price, Volume，Bid_Size，Ask_Size等功能的更改会发送给ITopMktDataHandler的实例方法。要在下一节中实现任何类型的交易模型，我们需要一种方法来捕获这些数据。现在把最新修改价格存储在ArrayList顶部：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-45137435e5514747a287216794755abd_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="1067" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-45137435e5514747a287216794755abd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-45137435e5514747a287216794755abd_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="1067" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-45137435e5514747a287216794755abd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-45137435e5514747a287216794755abd_b.jpg"/></figure><p>简而言之，在TopMktDataHandlerImplementation的新类中实现ITopMktDataHandler接口，处理服务器响应的数据。 tickPrice方法会在服务器更改时从服务器接收数据。当服务器响应最新价格的变化时，我们将其添加到ArrayList价格。</p><h2><b>可视化 Price ArrayList 的行为</b></h2><p>我们正在改变将新项添加到ArrayList的方式。以下是其工作原理的图形表示：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-b82d2c930e925fcda01182265cc44aa9_b.jpg" data-caption="" data-size="normal" data-rawwidth="695" data-rawheight="439" class="origin_image zh-lightbox-thumb" width="695" data-original="https://pic2.zhimg.com/v2-b82d2c930e925fcda01182265cc44aa9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-b82d2c930e925fcda01182265cc44aa9_b.jpg" data-caption="" data-size="normal" data-rawwidth="695" data-rawheight="439" class="origin_image zh-lightbox-thumb lazy" width="695" data-original="https://pic2.zhimg.com/v2-b82d2c930e925fcda01182265cc44aa9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-b82d2c930e925fcda01182265cc44aa9_b.jpg"/></figure><p>新价格到达时，我们将其插入到ArrayList的顶部，可以通过语句 <b>price.get（0）</b>获得最新价格。在建模和交易执行部分会更具相关性。</p><h2><b>创建合约对象</b></h2><p>这个过程最重要的部分是建立一个NewContract对象作为参数传递给请求。为此，我们使用流式传输的安全性的参数初始化NewContract对象。我将使用期货合约作为例子：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-334ab6954b9a00c63d397ac70da141ed_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="387" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-334ab6954b9a00c63d397ac70da141ed_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-334ab6954b9a00c63d397ac70da141ed_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="387" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-334ab6954b9a00c63d397ac70da141ed_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-334ab6954b9a00c63d397ac70da141ed_b.jpg"/></figure><p><b>请求实时市场数据流</b></p><p>现在有办法处理数据流，并定义了流的安全性，接下来看下并细分请求方法：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-8d19bf270ed36b87814e0c496fcef6b3_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="72" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-8d19bf270ed36b87814e0c496fcef6b3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-8d19bf270ed36b87814e0c496fcef6b3_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="72" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-8d19bf270ed36b87814e0c496fcef6b3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-8d19bf270ed36b87814e0c496fcef6b3_b.jpg"/></figure><p>第一个参数是合约，简单地传递初始化契约的方法。</p><p>第二个参数可以保留为空字符串。</p><p>第三个参数确定是否正在请求快照，我们显然希望将此请求建立为流。</p><p>最后一个参数是ITopMktDataHandler。这允许我们使用服务器的响应数据来处理事务。</p><p>以下是主类Demo建立数据流的更新：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-6016714c5bcd96cf77f224d6890b6286_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="808" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic3.zhimg.com/v2-6016714c5bcd96cf77f224d6890b6286_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-6016714c5bcd96cf77f224d6890b6286_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="808" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic3.zhimg.com/v2-6016714c5bcd96cf77f224d6890b6286_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-6016714c5bcd96cf77f224d6890b6286_b.jpg"/></figure><p>运行此操作后，可以在终端中获得以下输出：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-8543942366ec1de9a03a0622d642d3d6_b.gif" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="402" data-thumbnail="https://pic3.zhimg.com/v2-8543942366ec1de9a03a0622d642d3d6_b.jpg" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic3.zhimg.com/v2-8543942366ec1de9a03a0622d642d3d6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-8543942366ec1de9a03a0622d642d3d6_b.gif" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="402" data-thumbnail="https://pic3.zhimg.com/v2-8543942366ec1de9a03a0622d642d3d6_b.jpg" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic3.zhimg.com/v2-8543942366ec1de9a03a0622d642d3d6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-8543942366ec1de9a03a0622d642d3d6_b.gif"/></figure><p>我们已成功为特定合约创建了市场数据流。<br/></p><h2><b>自动交易执行模型</b></h2><p><b>可能是算法交易系统开发中最迷人的部分</b>。本节是关于实现模型和自动订单执行的全部内容。</p><h3><b>模型开发</b></h3><p><b>这是我们交易系统中最重要的部分</b>。如果模型没有盈利，就不会赚钱。虽然我们在本文中不会过多谈论模型开发过程，但想稍微谈谈它。 </p><p>正如我在介绍中简要提到的，<b>通常模型开发是一个不同的角色，属于定量研究员的职责。研究人员用Python或R开发模型，开发人员用Java或C ++实现它，交易者负责交易执行。大多数研究人员使用某种形式的机器学习来协助开发他们的模型。就是掌握Python中的数据科学库，如Pandas，ScikitLearn，Numpy和R中的包，如quantmod。如果您希望在模型开发中了解有关机器学习应用程序的更多信息。</b></p><p>虽然有几种方法可以开发交易模型，但显然它绝不是一门精确的科学。<b>一些模型设计具有遗传能力，以不断适应市场条件，而其他模型设置有损失限制，因此当它们停止执行时，它们会被废弃。</b>对于定量研究，高级金融，数学和统计知识是必不可少的。这些技能与创造力和坚持不懈相媲美，从而推动了建模过程。</p><p>一般模型设计过程可以看作如下：</p><p class="ztext-empty-paragraph"><br/></p><p><b>阅读博士论文或其他相关信息 → 草拟模型创意 → 回测模型（评估绩效的一些关键指标）→ 废弃不良模型（通常约为所有模型创意的70％-90％）→ 继续开发和审查剩余模型 → 查看生产潜力 → 重复过程。</b><br/></p><p><b>任意实施模式</b></p><p>我们将使用<b>基于价格变化阈值的简单策略来构建期货合约</b>。以下是进入策略的直观表示：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-5dd3c6dabf185f06eb75c2313e12c040_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="439" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic1.zhimg.com/v2-5dd3c6dabf185f06eb75c2313e12c040_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-5dd3c6dabf185f06eb75c2313e12c040_b.jpg" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="439" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic1.zhimg.com/v2-5dd3c6dabf185f06eb75c2313e12c040_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-5dd3c6dabf185f06eb75c2313e12c040_b.jpg"/></figure><p>下一步是制定退场策略。为简单起见，我们的退场策略只是一个限制，并分别停止1点和0.5点（费用后保持相同的费用）</p><p>此模型的目的是展示基于模型的自动订单执行的简单解决方案。不建议在真实账户上实施此策略。<br/></p><h3><b>模型开发</b></h3><p>我们将从TopMktDataHandlerImplementation中的价格ArrayList获取信息。在获得价格之后，我们将要开发一个类来处理（基于模型的）进入信号，然后开发一个类来处理发送订单。我将使用EntrySignalA类作为我的主要信号：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-86aab41eb4535d0d06bb37918df64bfb_b.jpg" data-caption="" data-size="normal" data-rawwidth="962" data-rawheight="560" class="origin_image zh-lightbox-thumb" width="962" data-original="https://pic4.zhimg.com/v2-86aab41eb4535d0d06bb37918df64bfb_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-86aab41eb4535d0d06bb37918df64bfb_b.jpg" data-caption="" data-size="normal" data-rawwidth="962" data-rawheight="560" class="origin_image zh-lightbox-thumb lazy" width="962" data-original="https://pic4.zhimg.com/v2-86aab41eb4535d0d06bb37918df64bfb_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-86aab41eb4535d0d06bb37918df64bfb_b.jpg"/></figure><p>既然我们有办法让价格符合我们的信号，以确定买入或卖出，我们需要创建一个类来处理订单。我们将创建一个类来实现自定义订单和处理活动订单。</p><p>现在我们可以在信号类中使用placeBracketOrder方法：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-924b0e5407c3582930147736d75ef324_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="938" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-924b0e5407c3582930147736d75ef324_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-924b0e5407c3582930147736d75ef324_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="938" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-924b0e5407c3582930147736d75ef324_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-924b0e5407c3582930147736d75ef324_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-6b0687eca910a1f3782d47ff386c8dd3_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="959" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-6b0687eca910a1f3782d47ff386c8dd3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-6b0687eca910a1f3782d47ff386c8dd3_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="959" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-6b0687eca910a1f3782d47ff386c8dd3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-6b0687eca910a1f3782d47ff386c8dd3_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-c2e375e7573cb4ee430ddcd7f488cae2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="960" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic3.zhimg.com/v2-c2e375e7573cb4ee430ddcd7f488cae2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-c2e375e7573cb4ee430ddcd7f488cae2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="960" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic3.zhimg.com/v2-c2e375e7573cb4ee430ddcd7f488cae2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-c2e375e7573cb4ee430ddcd7f488cae2_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-3450b940122ee9cebded4f6a85bc1ed3_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="61" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-3450b940122ee9cebded4f6a85bc1ed3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-3450b940122ee9cebded4f6a85bc1ed3_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="61" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-3450b940122ee9cebded4f6a85bc1ed3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-3450b940122ee9cebded4f6a85bc1ed3_b.png"/></figure><h3><b>要点</b></h3><p>在此例中，使用1000和2000作为parentOrderId。如果交易没有唯一的订单ID，则不会发送交易。但是，如果在TWS中重置订单ID API序列，则将重置所有现有订单ID，并且可以重复使用。有许多方法可以生成唯一的订单ID，例如将当前日期/时间转换为整数。</p><h2><b>全放在一起</b></h2><p>如果我们从逻辑上考虑这个问题，有一个非常简单的方法可以将它实现。只需在服务器响应的方法底部添加信号类的实例，以获得价格的每次变化：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-5ea5882d758d2b6ab1a0f792c9a9c71d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="977" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-5ea5882d758d2b6ab1a0f792c9a9c71d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-5ea5882d758d2b6ab1a0f792c9a9c71d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="977" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-5ea5882d758d2b6ab1a0f792c9a9c71d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-5ea5882d758d2b6ab1a0f792c9a9c71d_b.jpg"/></figure><p>我们现在有一个简单的系统，可以根据我们的模型自动执行交易。这是我们的模型执行买入订单时的样子：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-74cfdf00fa00f825c7d39c61fe3c9d13_b.gif" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="276" data-thumbnail="https://pic4.zhimg.com/v2-74cfdf00fa00f825c7d39c61fe3c9d13_b.jpg" class="origin_image zh-lightbox-thumb" width="600" data-original="https://pic4.zhimg.com/v2-74cfdf00fa00f825c7d39c61fe3c9d13_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-74cfdf00fa00f825c7d39c61fe3c9d13_b.gif" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="276" data-thumbnail="https://pic4.zhimg.com/v2-74cfdf00fa00f825c7d39c61fe3c9d13_b.jpg" class="origin_image zh-lightbox-thumb lazy" width="600" data-original="https://pic4.zhimg.com/v2-74cfdf00fa00f825c7d39c61fe3c9d13_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-74cfdf00fa00f825c7d39c61fe3c9d13_b.gif"/></figure><h2><b>量化开发人员 - 系统开发</b></h2><p><b>作为量化开发人员，你的工作通常是创建基于经过严格测试的oi模型的交易系统。</b>在这个例子中，我们引导你完成算法交易系统的开发，并为关键的开发阶段提供了简单的解决方案。有很多方法来改进这个系统（显然是模型），例如：</p><p><b>• 在交易执行系统中添加安全标志</b></p><p><b>• 未能以非最优价格执行订单</b></p><p><b>• 当前模型性能的分析库</b></p><p><b>• 等等</b></p><h2><b>如何获取代码</b></h2><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/Vy2jKfUKumfCo0xYUUu0RA" data-draft-node="block" data-draft-type="link-card" data-image="https://pic4.zhimg.com/v2-86c99c2ff42d04bccf01bee78aa6ed83_180x120.jpg" data-image-width="1280" data-image-height="545" class=" wrap external" target="_blank" rel="nofollow noreferrer">算法交易系统开发，揭开Developer的神秘面纱（代码+核心思路）</a><p><i>—End—</i></p><p>量化投资与机器学习微信公众号，是业内垂直于<b>Quant</b>、<b>MFE</b>、<b>CST</b>等专业的主流自媒体。公众号拥有来自<b>公募、私募、券商、银行、海外</b>等众多圈内<b>10W+</b>关注者。每日发布行业前沿研究成果和最新资讯。</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-781e4b70c99e97eb46045eefdd07923a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="1080" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic3.zhimg.com/v2-781e4b70c99e97eb46045eefdd07923a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-781e4b70c99e97eb46045eefdd07923a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="1080" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic3.zhimg.com/v2-781e4b70c99e97eb46045eefdd07923a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-781e4b70c99e97eb46045eefdd07923a_b.jpg"/></figure><p></p>