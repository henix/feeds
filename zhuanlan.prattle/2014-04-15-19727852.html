<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[产品与技术] Flight data recorder</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/19727852">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/7fff89def70ff9db17fbc55e536d9215_r.jpg" alt=""></div><p>谢谢这么多人的关心，程序君现在已经感觉好多了。^_^</p><p>有人留言问为什么不讲讲OpenSSL的漏洞，一方面我的身份不好讲，公司有统一的口径；另一方面这个话题已经被吵烂了，是个人都在里面插一脚，程序君就只好退后了。</p><p>至于世界邦和途客圈的新闻，请大家不要在公众号里追问了，我不方便置评，一切以途客圈官方微信和微博的回复为准。</p><p>言归正传。</p><p>很多人看到这个标题的第一印象可能是 —— 这是要讲飞机上的黑匣子么？有点关系，但主要讲软件中的flight data recorder。不过我们先从黑匣子讲起。</p><p>Flight Data Recorder（FDR）用于记录飞机行驶过程中的各种关键数据，其规格如下：</p><ul><li>电源：115V AC 或 28V DC</li><li>电源能力：30天不间断</li><li>使用期限：至多6年</li><li>包含水下定位装置</li><li>能记录25小时不间断数据</li><li>能经受1100度高温</li></ul><p>FDR的硬件架构：</p><ul><li>CPU card</li><li>Analog card</li><li>Discrete card</li><li>Frequency card</li><li>Audio card</li><li>Power supply card</li></ul><p>水下定位装置能在深达12000ft的水域正常工作，发送37.5khz的声音信号。</p><p>FDR会记录些什么？</p><ul><li>time</li><li>pressure</li><li>altitude</li><li>airspeed</li><li>vertical acceleration</li><li>magnetic heading</li><li>control-column position</li><li>rudder-pedal position</li><li>control-wheel position</li><li>horizontal stablizer</li><li>fuel flow</li></ul><p>FDR（以及CVR, Cockpit Voice Recorder，记录机组人员及空乘的对话）对于定位航班失事的原因非常重要，因为它是进行RCA（Root Cause Analysis）的第一手资料。没有FDR，或者找不到FDR，基本上客机失事就会成为一个永远的谜团。</p><p>下图展示了FDR在飞机上的位置，以及数据的收集：</p><img src="https://pic1.zhimg.com/5cb8952ec2eb07291f97b2aedffdf8ac_r.jpg" data-rawwidth="400" data-rawheight="300"><p>而越来越复杂的软件系统也有这样的问题。运行在客户端的软件，运行的过程中突然崩溃，很多时候单凭崩溃时产生的core很难找到问题的原因（请类比飞机碎片）。这时候，我们就要求助于软件系统中的FDR了。</p><p>最典型，也是最原始的FDR是log。几乎所有的软件都有log。通过分析系统崩溃前的log，我们可以找到一些问题的原因，但很多问题依旧无法靠log来进行RCA，这是因为，log的定位是记录系统的关键路径，关键路径有时候并不一定等同于关键数据。</p><p>打开debug开关，提供调试版本？很多问题是特定情况的突发事件，需要很隐晦条件才能触发，debug开关，调试版本这样的事后诸葛亮，只要问题不能复现，就没有用武之地。</p><p>这就是软件系统中的黑匣子FDR存在的价值和意义了。</p><p>网上关于软件系统中的FDR的信息还很少，除了我了解的systemtap的flight record mode（FRM）外，就是Java中对FDR的支持了。我们先看Java FDR。</p><p>Java FDR是建立在JVM中的，所以只要JVM使能了FDR，所有运行在其上的application都将受益（这又是indirection好处的一大佐证）。它提供几大功能：</p><p>(1) Tracer：tracer捕捉JVM和application中的runtime数据，包括GC，synchronization，compiler (JIT)，CPU usage，exceptions，I/O等等信息。</p><p>(2) Profiler：定期对系统采样（追踪系统的性能），或者on-demand profiling，当且仅当需要时可以打开进行全数据采集（对性能有较大影响，但仅在特定事件下或者特定配置下触发）。</p><p>(3) after-the-fact analysis：即事后分析。捕获的运行时数据会放在一片循环的缓存中（kernel memory或文件）。当意外事件发生时（比如崩溃），这片缓存中的数据被输出，用于定位问题。</p><p>我对Java和JVM几乎没有涉猎，所以以上理解都是皮毛，希望Java大牛来拍砖。</p><p>systemtap的飞行模式（FRM）是另外一种FDR。</p><p>如果你在linux下进行系统开发而没有涉猎systemtap，建议研究一下。systemtap给予你写段脚本runtime注入到目标软件中，从软件中获取信息的能力。这功能如此凶悍，所以你需要"sudo"的权限来运行systemtap。简单讲一下systemtap的原理：</p><p>(1) 首先用户可以撰写stap脚本，选择要注入的进程和函数</p><p>(2) stap脚本被编译成c文件，然后编译成kernel module，通过insmod加载进内存。</p><p>(3) kernel module初始化时会使用do_brk()为目标进程分配新的内存，把要注入的代码写入新的内存区域。</p><p>(4) 如果要probe的是某条指令，则将该指令替换成跳转到注入区执行；如果probe的是系统调用，则在系统调用中完成代码的注入。</p><p>(5) 当注入代码执行完毕后，恢复注入点的代码，并执行，对于目标进程而言就像正常执行一样。</p><p>下图是对系统调用 write 进行probe的一个示例：</p><img src="https://pic2.zhimg.com/1e612edda4a71ac7e61d0b486f550e03_r.jpg" data-rawwidth="568" data-rawheight="382"><p>这个原理和病毒基本一样。只不过，它的目的是在不用修改目标程序源代码的情况下，从目标中获取统计信息，达到runtime debugging / profiling的功效。</p><p>如果打开systemtap的飞行模式，则其会不断往1MB（可配置）的一个Kernel缓冲区中写监控数据，并且在需要的时候输出进行分析。</p><p>对于FDR而言，有了称手的工具是远远不够的。最关键的是：究竟什么样的数据才是关键数据，值得记录，用以崩溃后的分析？如果采样太多的系统数据，会给系统本身的性能带来冲击，而且过多的数据杂音很大，反而不便于分析；如果采样的数据不够，无法进行RCA，那么FDR就失去了应有的作用。</p><p>此外，对数据合理的visualization也非常重要，因为它能帮助人更好地理解数据间的关系，从而为RCA提供线索。</p><p>如果你对本文感兴趣，欢迎订阅公众号『<b>程序人生</b>』（搜索微信号 <b>programmer_life</b>）。每天一篇原汁原味的文章，早8点与您相会。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
