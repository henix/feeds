<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>全同态加密与区块链</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/</link>
<description>区块链与密文计算让数据可以自由的分享 全同态加密具有神奇的功能，在不解密的情况下能够对密文进行任意计算。区块链能够在去中心化的环境下，保证数据的不可篡改、可追溯等。区块链+全同态加密=让我的数据属于我掌控。</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 12 Apr 2019 15:44:07 +0800</lastBuildDate>
<item>
<title>密码学入门与实践-1</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-04-11-62046303.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/62046303&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;术语：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;明文(plaintext or cleartext)&lt;/b&gt;：发送者想要传送给接收者的可理解消息&lt;/p&gt;&lt;p&gt;&lt;b&gt;密码(ciphertext):&lt;/b&gt; 使用密码系统的明文加密生成无法理解的消息&lt;/p&gt;&lt;p&gt;&lt;b&gt;加密(encryption):&lt;/b&gt; 将明文转换为密文的过程&lt;/p&gt;&lt;p&gt;&lt;b&gt;解密(decryption):&lt;/b&gt; 将密文转换为明文的过程（加密反向）&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;传统密码学：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;它也称为对称密钥或共享密钥加密。同一个密钥用于加密和解密消息。将下面这个例子视为传统加密：&lt;/p&gt;&lt;p&gt;你和你的室友都使用相同的钥匙来锁定/解锁你家的门。因此，您共享相同的密钥以保护房间。确实，你的室友可以有你的钥匙副本，这样他就可以在你工作时进入房间，反之亦然。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;使用对称密钥的传统密码系统算法：数据加密标准（DES），高级加密标准（AES）&lt;/p&gt;&lt;p&gt;优点：快速。&lt;/p&gt;&lt;p&gt;缺点：不安全！&lt;br/&gt;发送方和接收方必须就密钥达成一致，并阻止其他人访问密钥。(这样做)有一个大的问题，如果两者不在同一物理位置，该如何发布密钥。你在中国的时候怎么能把你的钥匙给你在美国的室友呢！&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;实用建议：对每条消息加密后都要更改对称密钥，以便在发生灾难时（密码分析，窃取等）只能泄漏一条消息。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;密钥分发&lt;/p&gt;&lt;p&gt;在上一段中，我们讨论的了密码系统使用对称密钥，以及缺乏与室友安全共享密钥的有效方式。密钥分发有助于解决这个缺点。接下来，我们将解释如何通过不受信任的通信通道进行密钥交换。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Diffie-Hellman key exchange (Diffie-Hellman密钥交换)&lt;/p&gt;&lt;p&gt;这种密钥交换基于一种算法，该算法在数学上不能在合理的时间内轻松地计算大数的离散对数。在使用数字和抽象公式直接运行之前，我们将使用颜色概述算法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-844eab87a51441a9efeed6609978a579_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;441&quot; data-rawheight=&quot;660&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;441&quot; data-original=&quot;https://pic2.zhimg.com/v2-844eab87a51441a9efeed6609978a579_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-844eab87a51441a9efeed6609978a579_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;441&quot; data-rawheight=&quot;660&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;441&quot; data-original=&quot;https://pic2.zhimg.com/v2-844eab87a51441a9efeed6609978a579_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-844eab87a51441a9efeed6609978a579_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;11. 第1步：Alice和Bob达成了共同颜色的协议。&lt;/p&gt;&lt;p&gt;2. 第2步：Alice选择她不会告诉Bob的秘密颜色。鲍勃会做同样的事情。&lt;/p&gt;&lt;p&gt;3. 步骤3：Alice将共同颜色与秘密颜色混合，结果是混合物。Bob也将他的秘密颜色与普通颜色混合，并将会得到不同于alice的混合物。&lt;/p&gt;&lt;p&gt;4. 步骤4：Alice和Bob交换混合物。这是沟通中最关键的一步，因为”中间人攻击(man-in-the-middle)”可以访问这两种混合物。如果中间人有双方的混合物，这也将会是一个问题。颜色分解是不可逆的。因此，找到两个秘密颜色的唯一机会是将所有可能的颜色与第一步中的常见颜色混合。此外，请记住，秘密颜色也可以是许多其他颜色的混合。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;更新：Diffie-Hellman不会保护您免受中间人攻击。为了了解原因，想象一下攻击者从Alice接收所有消息并将其重播回Bob。&lt;/p&gt;&lt;p&gt;5. 步骤5：Alice将再次将她的秘密颜色添加到Bob发送给她的混合物中。鲍勃将遵循相同的步骤。&lt;/p&gt;&lt;p&gt;最后Alice和Bob将获得一个共同的秘密颜色。现在，Alice和Bob可以安全地交换我们在前一章中讨论的对称密钥，因为他们可以使用上述秘密颜色加密和解密任何消息（通过通信信道发送）。&lt;/p&gt;&lt;p&gt; 数学来了，当我们没有足够的颜色时，总是关于数学。&lt;/p&gt;&lt;p&gt; 步骤1：Alice和Bob达成了两个大数的协议：一个素数p（推荐至少512位）和一个基数g（p的原始根模量）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-874c2a6afa8ca1bbcec218959d4bbd38_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;234&quot; data-rawheight=&quot;114&quot; class=&quot;content_image&quot; width=&quot;234&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-874c2a6afa8ca1bbcec218959d4bbd38_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;234&quot; data-rawheight=&quot;114&quot; class=&quot;content_image lazy&quot; width=&quot;234&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-874c2a6afa8ca1bbcec218959d4bbd38_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;步骤 2:Alice选择一个秘密的整数 a  。 Bob 选择一个秘密整数 b。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-10e14fbbcaaa7afc388b24e0d402082f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;252&quot; data-rawheight=&quot;120&quot; class=&quot;content_image&quot; width=&quot;252&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-10e14fbbcaaa7afc388b24e0d402082f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;252&quot; data-rawheight=&quot;120&quot; class=&quot;content_image lazy&quot; width=&quot;252&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-10e14fbbcaaa7afc388b24e0d402082f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;步骤3：Alice计算公共值x = g ^ a mod p。 Bob计算公共值y = g ^ b mod p，其中mod是模运算符。&lt;/p&gt;&lt;p&gt;步骤4：Alice和Bob交换x和y。&lt;/p&gt;&lt;p&gt;步骤5：Alice计算她的秘密密钥k_a = y ^ a mod p。Bob计算他的秘密密钥k_b = x ^ b mod p。在数学上可以证明k_a = k_b。 Alice和Bob现在有一个共同的密钥，用于加密和解密他们想要安全交换的明文&lt;/p&gt;&lt;p&gt;例子:&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-56dfb00cc653ecc5661765616bd69ac6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;719&quot; data-rawheight=&quot;377&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;719&quot; data-original=&quot;https://pic3.zhimg.com/v2-56dfb00cc653ecc5661765616bd69ac6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-56dfb00cc653ecc5661765616bd69ac6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;719&quot; data-rawheight=&quot;377&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;719&quot; data-original=&quot;https://pic3.zhimg.com/v2-56dfb00cc653ecc5661765616bd69ac6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-56dfb00cc653ecc5661765616bd69ac6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果中间人知道秘密整数a = 6和b = 15，他可以找到用于通信的秘密密钥。方法如下：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2b8efb059146927dbb073697bc4fb09f_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;688&quot; data-rawheight=&quot;96&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;688&quot; data-original=&quot;https://pic4.zhimg.com/v2-2b8efb059146927dbb073697bc4fb09f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2b8efb059146927dbb073697bc4fb09f_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;688&quot; data-rawheight=&quot;96&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;688&quot; data-original=&quot;https://pic4.zhimg.com/v2-2b8efb059146927dbb073697bc4fb09f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2b8efb059146927dbb073697bc4fb09f_b.png&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;优点：安全。避免中间人攻击。&lt;/p&gt;&lt;p&gt;缺点：您无法确定真正的&amp;#39;Bob&amp;#39;的实际身份。(无法确定’Bob’的真实身份)&lt;/p&gt;&lt;p&gt;也可以使用XOR（异或）运算符来解释Diffie-Hellman:&lt;/p&gt;&lt;p&gt;假设Alice想要将消息 ’M = Hello‘ 发送给Bob。消息M的二进制表示是B（M）= 0100100001100101011011000110110001101111。Alice用秘钥K = 1010101000101110100101010001110010101010加密消息。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e21b40c159473fd44e4a2d4876908b80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;728&quot; data-rawheight=&quot;219&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;728&quot; data-original=&quot;https://pic1.zhimg.com/v2-e21b40c159473fd44e4a2d4876908b80_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e21b40c159473fd44e4a2d4876908b80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;728&quot; data-rawheight=&quot;219&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;728&quot; data-original=&quot;https://pic1.zhimg.com/v2-e21b40c159473fd44e4a2d4876908b80_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e21b40c159473fd44e4a2d4876908b80_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;加密消息L的明文的等效消息是&amp;amp;#226;K&amp;amp;#249;p&amp;amp;#197; 。Bob收到&amp;amp;#226;K&amp;amp;#249;p&amp;amp;#197;，并使用已经与Alice交换的相同的密钥K来解密消息。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bd2f1feddfb974c8fa6a7023cdd630a7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;216&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;732&quot; data-original=&quot;https://pic4.zhimg.com/v2-bd2f1feddfb974c8fa6a7023cdd630a7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bd2f1feddfb974c8fa6a7023cdd630a7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;216&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;732&quot; data-original=&quot;https://pic4.zhimg.com/v2-bd2f1feddfb974c8fa6a7023cdd630a7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bd2f1feddfb974c8fa6a7023cdd630a7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;为什么这个算法很重要？因为像SSL，TLS，SSH，IPSec ,  PKI的协议，都使用Diffie-Hellman。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br/&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-04-11-62046303</guid>
<pubDate>Thu, 11 Apr 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-8</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-31-60936290.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60936290&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;———————————这是一条美丽的分割线————————————&lt;/p&gt;&lt;h2&gt;7.实现步骤&lt;/h2&gt;&lt;p&gt;功能函数f里其实有两样基本东西就够了：AND增强型电路，XOR增强型电路，经过集成电路化后如下现状：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b7434ee3afafc2ecc061e9b16cf775a6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;360&quot; data-rawheight=&quot;180&quot; class=&quot;content_image&quot; width=&quot;360&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b7434ee3afafc2ecc061e9b16cf775a6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;360&quot; data-rawheight=&quot;180&quot; class=&quot;content_image lazy&quot; width=&quot;360&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b7434ee3afafc2ecc061e9b16cf775a6_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;任意功能函数例如f1，都可以应用如上两个增强电路组合来表示，例如：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-db2c5b268bee81ad87b8e09322a56d82_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;383&quot; data-rawheight=&quot;386&quot; class=&quot;content_image&quot; width=&quot;383&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-db2c5b268bee81ad87b8e09322a56d82_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;383&quot; data-rawheight=&quot;386&quot; class=&quot;content_image lazy&quot; width=&quot;383&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-db2c5b268bee81ad87b8e09322a56d82_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;所以每次计算的基本步骤如下：&lt;/p&gt;&lt;p&gt;1) 对输入的明文m进行加密Enc(m),得到密文（c,z）,c是密文，z是向量&amp;lt;z1,z2,……&amp;gt;也称为扩展密文。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2) 对输入的密文进行重加密。输入的密文为（c,z）。在对密文运算之前每次都要对其重加密。因为明文空间是{0,1}，所以加密一定是对密文按位来加密。重加密的过程就是解密的过程，但是对象是对加密的密文以及加密的私钥进行。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以有：c’=Enc(Lsb(c))，得到的c’是一个整数。原本对z的每一位也要进行加密的，但是有一个方法可以提高效率，就是对z不加密，认为z的每一位自己就是自己的加密。另外私钥是s=&amp;lt;s1,s2,……&amp;gt;是0和1的向量，对私钥的每一位的加密记为sk’=&amp;lt;Enc(s1),Enc(s2),……&amp;gt;=&amp;lt;s1’，s2’,……&amp;gt;，得到的si’也是整数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然后运行∑si·zi，运行它的算法如前面所说，把每一个zi的二进制表示写成矩阵的一行，这样就得到一个矩阵：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-30487a2474c7a357fad8d40c6dab0f37_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;369&quot; data-rawheight=&quot;147&quot; class=&quot;content_image&quot; width=&quot;369&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-30487a2474c7a357fad8d40c6dab0f37_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;369&quot; data-rawheight=&quot;147&quot; class=&quot;content_image lazy&quot; width=&quot;369&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-30487a2474c7a357fad8d40c6dab0f37_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;然后用si’乘以上面矩阵第i行的每一位，得到一个整数矩阵(矩阵中每一个元素都是整数):&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9bc5faae8e158a312caf7e0fa53ec3b8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;420&quot; data-rawheight=&quot;358&quot; class=&quot;content_image&quot; width=&quot;420&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9bc5faae8e158a312caf7e0fa53ec3b8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;420&quot; data-rawheight=&quot;358&quot; class=&quot;content_image lazy&quot; width=&quot;420&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9bc5faae8e158a312caf7e0fa53ec3b8_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;​然后对最后一列（最低位）求海明码，根据前面所述定理，海明码的最低位是e20 （b1,-n, b2,-n ……，bt,-n），其余各位e21 （b1,-(n-1), b2,-(n-1) ……，bt,-(n-1)），……，都作为进位进到前面相应的位。依次计算下去，第1列的结果是b-1 = e20 （b1,-1, b2,-1 ……，bt,-1，……），第0列的结果是b0 = e20 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b8b5fbea7c8cc2e9f765e9cc10936605_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;517&quot; data-rawheight=&quot;252&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;517&quot; data-original=&quot;https://pic2.zhimg.com/v2-b8b5fbea7c8cc2e9f765e9cc10936605_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b8b5fbea7c8cc2e9f765e9cc10936605_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;517&quot; data-rawheight=&quot;252&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;517&quot; data-original=&quot;https://pic2.zhimg.com/v2-b8b5fbea7c8cc2e9f765e9cc10936605_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b8b5fbea7c8cc2e9f765e9cc10936605_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;3) 计算b= (b0 + b-1 ) ，b就是对应的Lsb(「∑si* zi 」)密文运算的结果。&lt;/p&gt;&lt;p&gt;4) 根据上面已经得到的c’=Enc(Lsb(c))，最终对密文c的重加密结果为：&lt;/p&gt;&lt;p&gt;c* = c’+ b&lt;/p&gt;&lt;p&gt;       知道此c*和c有什么关系么？c*是c的“重生”，噪音比原来降低了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;5) 然后将c*输入门电路。门电路一般都是二元的，需要两个输入，另外一个输入也用同样的方法计算得到&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;6) 进行门电路运算，例如加或乘，输出得到的结果。接下来有两种情况：第一种：此结果为最终结果，那么再进行重加密一次后，将密文返还给用户，用户解密后得到正确的运算结果。第二种：此结果不是最终结果，那么继续输入到下一级电路，依然是要先进行重加密。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;全文结束&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-31-60936290</guid>
<pubDate>Sun, 31 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-7</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-28-60636329.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60636329&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;———————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;h2&gt;&lt;b&gt;6、&lt;/b&gt; &lt;b&gt;压缩解密电路&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如何把电路变浅呢？一个直观的方法就是替别人承担一些工作，这样原来的任务量就变小了。&lt;/p&gt;&lt;p&gt;还是先来仔细打量一下问题出在的地方：&lt;/p&gt;&lt;h3&gt;&lt;i&gt;c× p-1&lt;/i&gt;&lt;/h3&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这是一个乘积，要想把它变成一个较浅的运算电路，应该如何做呢？最直观的方法就是：把乘积变成和，也就是说把c·p-1 →∑zi。c是密文，我们不可能拿它开刀，唯一可以做处理的地方就是p-1，也就是说应该把p-1 转换成一个和的形式即： p-1 →∑yi，&lt;/p&gt;&lt;p&gt;要知道p是私钥是不能公开的，所以可以把p隐藏在∑yi中，同时这种隐藏要不会泄露p才可行，所以要有一个陷门才可以，这个陷门就是Sparse Subset Sum Prob (SSSP)，就是给一串整数x1,x2,……，xn，存在一个{1,……，n}的子集S，使得∑si * xi=0 (其中i∈S)，让你求这个S是不可行的。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这个问题据说是困难的，好像没有被well studied。有了这个陷门就可以构造出：&lt;/p&gt;&lt;p&gt;取y1,y2,…,yn ∈[0, 2)，存在一个稀疏子集S，使得∑si · yi ≈ 1/p mod 2 (i∈S) (因为是实数所以用近似等于1/p表示，是存在一个误差的，这个误差不影响取整后的结果) 。&lt;/p&gt;&lt;p&gt;令 zi←c· yi  mod 2，zi保留一定的精确度，从而有：∑si · zi ≈ c/p  mod 2。所以解密电路中的「c/p」可以替换成「∑si * zi 」。解密电路变成：&lt;/p&gt;&lt;p&gt;    Lsb(c) XOR Lsb(「∑si·zi 」)。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这个变换后的方案，公钥除了原来的公钥pk之外还多加了一个向量{yi}。密文除了原来的c之外多出了一个向量{zi}。&lt;/p&gt;&lt;p&gt;这个多出来的zi可以看做是提前拿出来计算以减轻解密电路负担的，这个方法叫预处理（post-process）。私钥由原来的sk变成了{si}。可以看到公钥变大，密文也变大，这个代价就是为了换得更浅的电路。那么电路变浅了吗？下面来分析一下：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;主要分析一下∑si·zi的多项式次数，然后和我们前面分析的f所能执行的最大次数比较就OK。&lt;/p&gt;&lt;p&gt;假设zi的精确度为n位（我们考虑的都是二进制表示），整数位只考虑最低位，因为Lsb(「∑si·zi 」)是对和先取整，然后再取最低有效位。如下所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;566&quot; data-rawheight=&quot;182&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;566&quot; data-original=&quot;https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;566&quot; data-rawheight=&quot;182&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;566&quot; data-original=&quot;https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果上述t个数应用“3-for-2 trick”相加，电路深度也不会满足要求。所以得另寻它法。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;有个概念说一下：HammingWeight，海明重量通俗的说就是向量中“1”的个数，由于我们是二进制相加，所以上面每一列相加的结果可以看成是该列的海明重量。那么海明重量怎么求呢？有一个定理非常有用，就是：&lt;/p&gt;&lt;p&gt;对于任意一个二进制向量&amp;lt;a1,a2,……，at&amp;gt;，其海明重量为W，并且其二进制表示为：wn,……w1w0的话，则wi可以表示为关于变元a1,a2,……，at的一个次数是2i多项式。这个多项式很好求，就是对称多项式e2i （a1,a2,……，at），有现成的算法。&lt;/p&gt;&lt;p&gt;好了我们可以对上面的那些列运用此定理。对最低列求海明重量，则海明重量的最低位是e20 （a1,-n, a2,-n ……，at,-n）mod 2，它就是该列的和，这个海明重量的倒数第二位是e21 （a1,-n, a2,-n ……，at,-n）mod 2，就进位到倒数第二列记为Cn,-(n-1)，如此下去;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;233&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;584&quot; data-original=&quot;https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;233&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;584&quot; data-original=&quot;https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后得到：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;424&quot; data-rawheight=&quot;292&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;424&quot; data-original=&quot;https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;424&quot; data-rawheight=&quot;292&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;424&quot; data-original=&quot;https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;则有：&lt;/p&gt;&lt;p&gt;b=「∑si * zi 」= (b0 + b-1 ) mod 2  (因为是取整，所以只关心第0列，取整是要取最近的整数，所以和b-1有关，如果b-1是1则要进上去)&lt;/p&gt;&lt;p&gt;别忘了我们现在的任务：是要计算「∑si * zi 」的电路关于ai,j的多项式次数。开始时可以看成都是一次的：&lt;/p&gt;&lt;p&gt;然后计算完最后一列，有了向前面各列的进位后,变成如下形式：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fefbeb046daabb532a0bfa10491439e9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;147&quot; class=&quot;content_image&quot; width=&quot;346&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fefbeb046daabb532a0bfa10491439e9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;147&quot; class=&quot;content_image lazy&quot; width=&quot;346&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-fefbeb046daabb532a0bfa10491439e9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-02bf69beea057d9bee7406e47871d8ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;327&quot; data-rawheight=&quot;158&quot; class=&quot;content_image&quot; width=&quot;327&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-02bf69beea057d9bee7406e47871d8ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;327&quot; data-rawheight=&quot;158&quot; class=&quot;content_image lazy&quot; width=&quot;327&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-02bf69beea057d9bee7406e47871d8ad_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;每一列关于ai,j的次数都变了，例如倒数第二列次数为4了，依次下去：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-219e11641174db236776d8a2dba6600d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;348&quot; data-rawheight=&quot;177&quot; class=&quot;content_image&quot; width=&quot;348&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-219e11641174db236776d8a2dba6600d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;348&quot; data-rawheight=&quot;177&quot; class=&quot;content_image lazy&quot; width=&quot;348&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-219e11641174db236776d8a2dba6600d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;每一列关于ai,j的次数都变了，例如倒数第二列次数为4了，依次下去：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;422&quot; data-rawheight=&quot;314&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;422&quot; data-original=&quot;https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;422&quot; data-rawheight=&quot;314&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;422&quot; data-original=&quot;https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;因为最后的结果是(b0 + b-1 ) mod 2，所以我们只关心前面两列的次数（即第0列和第一列）。由于每列计算的结果都是e20(……)，它是关于输入项的一个次数为1次的对称多项式。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;对于第0列，由于其最高次数为2n ，所以其结果e20(……)的最高次数为2n。对于第1列，由于其最高次数为2n-1 ，所以其结果e20(……)的最高次数为2n-1。所以，计算「∑si * zi 」的电路关于ai,j的多项式次数为2n（别忘了n是zi的精确度）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;回忆一下我们原来说的f所能计算的最高多项式次数为：log p / log Bn （注意2n中的n和此式的n不是一个n）。如何比较呢，得把参数确定一下，按照DGHV方案中的参数，λ为安全参数，取||p|| ～λ2, ||r||～λ，所以p～2λ2，B～2λ，则log p / log Bn～λ。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;要想让Evaluate能够运行「∑si * zi 」电路，zi的精确度要取logλ才可以。现在你知道DGHV论文中zi精确度为什么要取那个数了吧。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;到此为止我们知道了解密电路经过压缩，可以被Evaluate正确运算了，从而解密电路堂而皇之的进入permitted functions集合里了，所以该方案可以对密文做任意功能的运算了，知道这意味着什么吧，全同态实现了。七拐八歪的才修成正果，确实不容易。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;接下来我们总结一下实现步骤，其实上面已经有了。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br/&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-28-60636329</guid>
<pubDate>Thu, 28 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-6</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-26-60399503.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60399503&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;———————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;5、 解密电路的深度&lt;/h3&gt;&lt;p&gt;上面有一个人说对了一半，其实我们可以把解密电路用AND电路和XOR电路表示出来，计算一下电路的深度（电路的深度是运算次数的对数，例如深度是d，计算次数就是log d），然后再和permitted functions中功能电路所允许的最大深度做个比较，就知道解密电路是否属于permitted functions集合了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先来分析permitted functions集合所允许的电路深度。由于permitted functions集合里的任一功能函数f 都可以用AND电路和XOR电路表出，而AND电路和XOR电路可以看做对输入的二进制位做乘法和加法，所以f电路的深度可以用输入位的对称多项式来衡量（用多项式衡量是因为多项式里恰好是变元的乘法和加法），&lt;b&gt;又由于乘法是噪音的主要来源，所以可以用多项式中乘法次数来做电路深度的主要衡量指标&lt;/b&gt;。有：&lt;/p&gt;&lt;p&gt;c* = f ( c1, c2, …，cn ) = f ( m1+2r1+pq, m2+2r2+pq, …，mn+2rn+pq ) &lt;/p&gt;&lt;p&gt; = f ( m1+2r1, m2+2r2, …，mn+2rn ) +p(……)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;密文c*的噪音为：c* mod p = f ( m1+2r1, m2+2r2, …，mn+2rn ), 要想c*解密正确必须有：f ( m1+2r1, m2+2r2, …，mn+2rn )&amp;lt; p/2, 其中mi+2ri 是密文ci的噪音。不妨令mi+2ri = xi, 且xi &amp;lt; B, B是密文ci噪音的上界，则有：&lt;/p&gt;&lt;p&gt;f ( x1, x2, …，xn ) &amp;lt; p/2。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们的目标是衡量f 的运算次数d，所以可以用初等对称多项式来表达f ，有：&lt;/p&gt;&lt;p&gt;f ( x1, x2, …，xn ) = x1x2…xd + x1x3…xd + ……；其中d&amp;lt;=n&lt;/p&gt;&lt;p&gt;f ( x1, x2, …，xn )的每一项就是从n个变元( x1, x2, …，xn )里选取d个变元，因此有C（n, d）个项（C表示组合运算），由C（n, d）&amp;lt; nd 得：&lt;/p&gt;&lt;p&gt;f ( x1, x2, …，xn ) &amp;lt; Bd nd &amp;lt; p/2 =&amp;gt; d &amp;lt; log p / log Bn , 也就是说f 最多运算次数为 log p / log Bn 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下面再看看解密电路的运算次数：&lt;/p&gt;&lt;p&gt;Dec(c): (c mod p) mod 2=（c – p·「c/p」）mod 2 = Lsb(c) XOR Lsb(「c/p」)&lt;/p&gt;&lt;p&gt;仔细端详解密电路的公式，发觉其复杂性主要来源是c/p，所以我们主要看c/p所需的运算次数。c/p=c·p-1 , p-1是小数，为了保证c· p-1取整之后的的精确度，p-1要取log c 位的。例如 12345678× 0.111111 和 12345678× 0.11111111的结果取整后是不一样的。那么两个数相乘的次数如何衡量呢？有如下结论:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 乘两个t位数相当于加t个数: &lt;b&gt;输出位是关于输入位的一个2次多项式&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5216ef706b4ae4ce77b6146acfd1e8f8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;416&quot; data-rawheight=&quot;204&quot; class=&quot;content_image&quot; width=&quot;416&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5216ef706b4ae4ce77b6146acfd1e8f8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;416&quot; data-rawheight=&quot;204&quot; class=&quot;content_image lazy&quot; width=&quot;416&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5216ef706b4ae4ce77b6146acfd1e8f8_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;加t个数可以应用“3-for-2 trick” : 3个数相加得到两个数相加，输出位是关于输入位的一个次数最多为2次的多项式&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;730&quot; data-rawheight=&quot;210&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;730&quot; data-original=&quot;https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;730&quot; data-rawheight=&quot;210&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;730&quot; data-original=&quot;https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-23964762451708d764ad9cbb221c94d5_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;其中a1b1+a1c1+b1c1是进位，注意它从形式上还是一个对称多项式。&lt;/p&gt;&lt;p&gt;那么t个数应用这个技巧经过log3/2 t 次相加后得到两个数，输出位的次数为2log3/2 t = tlog3/2 2= t1.71。&lt;/p&gt;&lt;p&gt;再看两个t位数相加：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;689&quot; data-rawheight=&quot;190&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;689&quot; data-original=&quot;https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;689&quot; data-rawheight=&quot;190&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;689&quot; data-original=&quot;https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-86a780eaeb39cc62e2dfccddb1f411c6_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;因此输出位的次数最多为t次，因为上面3位数相加次数最多为3次。&lt;/p&gt;&lt;p&gt;结合起来有：乘两个t位数的次数最多为2t1.71t=2t2.71，而c· p-1里c的位数为log c，p-1要取log c 位的，又因为log c &amp;gt; log p (因为 p&amp;lt;c)，所以c· p-1的次数至少是2(log p)2.71 , 而前面说过f最多运算次数为 log p / log Bn。&lt;/p&gt;&lt;p&gt;所以解密电路的深度要大于Evaluate所允许运行功能电路的深度，因此如果Evaluate运行解密电路的话，将会产生不正确的结果，我们就说Evaluate无法运行解密电路，换句话说解密电路不在permitted functions 集合里。&lt;/p&gt;&lt;p&gt;结论应该知道了吧，是一个坏消息。解密电路不在permitted functions 集合里，其后果就是：无法对密文进行任意功能的运算！与全同态失之交臂。&lt;/p&gt;&lt;p&gt;怎么办呢？古人云：兵来将挡，水来土掩。解密电路深了，把它变浅不就完了。说容易做起来有点难。我觉得有技巧的地方就在于压缩解密电路。&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-26-60399503</guid>
<pubDate>Tue, 26 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-5</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-25-60281238.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60281238&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;———————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4、&lt;/b&gt; &lt;b&gt;电路复杂度&lt;/b&gt;&lt;/p&gt;&lt;p&gt;前面的方案中大家看到了是按“位”来加密的（即m∈ {0,1}），加密后得到的是一个整数，密文膨胀的很厉害，那么为什么明文不取整数来加密呢？例如取明文m∈Z。我想原因是这样的：每个研究全同态的人们都想过了，但是没有找到一个方案可以把明文按照整数来加密。并不是说没有这种方案，估计只是现在还没有找到。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;又有人会问：为什么全同态方案要用电路来描述呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先我们来说说什么叫一个方案是全同态的？如果一个方案能够对密文做任意功能的运算，而且运算结果所得密文是紧凑的，同时Evaluate算法（即运算）是有效地，那么我们就称该方案是全同态的。可以用下式说明：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-68edb3f833edf3bd26d2262eeaab77d7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;722&quot; data-rawheight=&quot;175&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;722&quot; data-original=&quot;https://pic4.zhimg.com/v2-68edb3f833edf3bd26d2262eeaab77d7_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-68edb3f833edf3bd26d2262eeaab77d7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;722&quot; data-rawheight=&quot;175&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;722&quot; data-original=&quot;https://pic4.zhimg.com/v2-68edb3f833edf3bd26d2262eeaab77d7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-68edb3f833edf3bd26d2262eeaab77d7_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;上式太重要了，我觉得只要把上面的式子牢记在心，那么全同态的概念就装在心里了。“紧凑的”在这里就不说了，论文里有解释，而且也很好理解。正确性当然是必须的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么如何衡量Evaluate的有效性呢？最直观的方法可以通过复杂度来衡量。显然Evaluate的复杂度依赖于所运算的函数f。那么f的复杂度如何衡量呢？当然最直接的方法是通过在图灵机上运算f的时间来衡量。但是函数f又是什么呢？我想应该是五花八门的功能函数，如果想用功能去描述它恐怕是一言难尽，但是如果用布尔电路的大小（the size of boolean circuit,即门电路的数量）来衡量，那么f就能够被拆解成一些简单的布尔电路：例如“与”电路、“或”电路、“非”电路。而这些电路是可以组合成任意电路的，也就是说可以表示任意功能的电路。&lt;/p&gt;&lt;p&gt;同样我们也可以选择用AND电路和XOR电路，因为这两个电路是具有完备性质的，也就是说这两个电路的组合也可以表出任意功能的电路（而且用这两个电路来描述更加直观，它们直接对应的算术运算就是乘法和加法）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;显然AND电路和XOR电路是属于permitted functions集合里的（为什么？因为AND电路是对应的是两个二进制位相乘，XOR对应的是两个二进制位相加，上述同态方案肯定能够正确执行这两个运算，因为就是一次乘法或者一次加法，既然能够正确执行，所以它们就属于permitted functions集合）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;又由于AND电路和XOR电路是完备的，所以任意功能都可以用这两个电路组合表出，也就是说该同态方案可以对密文做任意功能的运算，这不就是传说中的全同态定义么！任意功能的问题解决了，但是还缺一点：必须是正确的才行。你对密文一阵蹂躏后，如果结果解密后不是同样对明文蹂躏的结果，你有什么感觉？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么上述同态方案能够保证计算的正确性么？上面我们已经看到由于噪音的存在，该方案只能做有限次的运算，也就是说只能够对permitted functions集合里的功能函数保证是正确的，在此之外保证不了，现在你知道permitted functions集合里有什么东西了吧。那如何能够保证对密文做任意功能的运算还是正确的呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前面说过可以通过重加密技术降低噪音呀！具体如何做呢？很简单：给AND电路上接一个解密电路，给XOR电路上也接一个解密电路，任何密文在进入AND电路或XOR电路之前，先让它进入解密电路进行重加密，之后从解密电路里出来的密文就是一个类似于新鲜密文的密文，噪音比进来前降低了，然后再让这个新的密文进入AND电路或XOR电路，这样我们就可以对密文正确的做任意功能的计算了！而接了解密电路的AND电路或XOR电路就称为增强电路。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;总结一下：任意函数功能拿来，先用增强型AND电路和增强型XOR电路表示出来，这样就可以对密文做任意功能的计算了，由于是增强型的，我们不再害怕噪音的阻碍，可以无限运算下去。OK，全同态的蓝图终于在纸上实现了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是还有一个问题（问题真多，难怪人说科学是由问题产生的，现在我才理解），解密电路是属于permitted functions集合里的么？可能有人会说，方案中不是有解密电路么，Evaluate应该可以运行它吧。另外还有人说，按照上面方法把解密电路表示成增强电路不就行了。别忘了，增强型电路是含有解密电路的，所以这样说等于由果来推因了。AND电路、XOR电路、解密电路都可看成是“原电路”（这个名字是我自己取的），就是说它们是构成任意功能函数的基石，permitted functions集合里含有它们就完全够了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前面我们已经解释了AND电路和XOR电路属于permitted functions集合的原因。唯一缺的就是没有证实解密电路也在permitted functions集合里。下面就来分析分析解密电路。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-25-60281238</guid>
<pubDate>Mon, 25 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-4</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-24-60209894.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60209894&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;——————————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;h2&gt;3 Bootstapping：一个生硬的思路&lt;/h2&gt;&lt;p&gt;然而降低噪音并不是最终目的，降低噪音是为了能够进行下一次运算，所以解密电路加上一个门电路（这个门电路可以是加法门电路或者乘法门电路等等基本电路）称之为“增强电路”。如图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4e018dcaffc557027b54647149662768_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;304&quot; data-rawheight=&quot;337&quot; class=&quot;content_image&quot; width=&quot;304&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4e018dcaffc557027b54647149662768_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;304&quot; data-rawheight=&quot;337&quot; class=&quot;content_image lazy&quot; width=&quot;304&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4e018dcaffc557027b54647149662768_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;由于重加密在每次执行前都需要一个公钥来加密私钥和密文，要进行多次重加密就需要一个公钥序列{pk1,pk2,…,pki}，对应于公钥序列也有一个加密私钥链{sk1*,sk2*,…,sk(i-1)*}（其中ski*是用pk(i+1)加密ski得到的密文）。这个过程是如何进行的呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;运算电路的每一层都对应一对公钥与私钥。第一层对应的是pk1和sk1，第二层对应的是pk2和sk2……。例如:初始公钥为pk1，对应的私钥为sk1，在电路第一层进行重加密时，将用第二层电路的公钥pk2对sk1进行加密得到sk1*（公钥对于所有层都是公开的），以及用pk2对密文进行加密；然后输入解密电路，解密电路运行后将输出一个密文，该密文就是用pk2对明文进行加密的结果。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;同理在电路第二层进行重加密时，将用pk3对该层密钥sk2加密得到sk2*，,以及对来自第一层电路的输出密文进行加密；然后输入解密电路，解密电路将输出一个密文，该密文是对明文用pk3进行加密的结果。如此下去。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这种情况下公钥与私钥的数量与电路的深度成线性的依赖关系。如果将被加密的私钥信息泄露，不会影响密钥本身的安全的话，这称之为circular security。如果全同态的加密方案是circular security的话，就不需要这么多公钥与私钥，所有电路层都共用一个公钥与加密的私钥就可以了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;好处在于我们不需要为了确定密钥的数量，而在运算前确定执行函数功能的电路深度，从而方便许多。要证明前面的方案是circular security的还很困难，但是目前可以认为不会带来攻击的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果解密电路是在Evaluate所执行的permitted functions的集合里，则称该加密方案是Bootstrappable。从上面的解决思路可以看到没有特别绕弯子的地方，就是碰到问题解决问题，解决不了的，创造条件也要解决。通过创造同态执行解密电路的条件，从而降低噪音以达到无限次对密文运算的目的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;好了，到这里似乎全同态实现了（有种共产主义立马实现的感觉）。然而还存在一个问题：Evaluate电路能否能够运行解密电路呢？换句话说：解密电路是否在Evaluate所执行的permitted functions的集合里呢？ 可能有些人会说: 一个算法调用另外一个算法，有什么执行不了的？这就要说说电路的复杂度。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-24-60209894</guid>
<pubDate>Sun, 24 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-3</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-23-60138162.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60138162&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;——————————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;h2&gt;3 Bootstapping：一个生硬的思路&lt;br&gt;&lt;/h2&gt;&lt;p&gt;噪音阻碍了我们的目标，那么如何消除噪音这个敌人呢？一个直观的方法就是对密文解密，密文解密后噪音就没有了，但是要解密必须要知道私钥，要想通过获得私钥来消除噪音是不现实的。那么如果对密钥加密来做可以么？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;让我们先看看Evaluate算法。在Evaluate算法中能够对密文执行函数f的运算，其中f是属于permitted functions 集合的任一function（这里稍微解释一下，permitted functions 集合也称permitted circuit。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;例如有两个函数功能f1和f2，运行Evaluate(pk, f1, c1,c2,…，cn)和Evaluate(pk, f1, c1,c2,…，cn)，就是分别对密文执行f1运算和f2运算，如果f1运算的结果解密后恰好是f1对相应明文运算的结果（同态成立），那么f1就属于permitted functions。而f2运算的结果解密后如果不等于f2对相应明文运算的结果，那么f2就不属于permitted functions。）。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;试想如果Dec解密算法也在permitted functions 集合中，那么Evaluate算法就可以执行Dec解密功能了。如果我们输入的是s*（是用pk2对私钥s加密得到的密文），以及对密文c*（是用pk2对c再加密的密文，原密文c是用pk1进行加密的)，那么执行&lt;/p&gt;&lt;p&gt;Evaluate(pk2, Dec, s*,c*)；&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所得结果为一个新的密文，该密文是明文在pk2下加密的密文，是不是有点像魔术，就像原来一个人穿的是西装，现在你没有看到这个人换衣服的情况下，魔术师只是施了一下魔法，这个人立刻就换了一身运动服，人还是原来那个人，只是包装变了。这也是Gentry思想中一个最重要的特性：同态解密。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;     那么同态解密对于降低噪音又有什么关系呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;     当密文运算后，噪音会被迅速放大，如果我们对运算后的密文做一次同态解密，是不是相当于得到了一个新鲜密文呢，而新鲜密文的噪音是最小的，所以达到了降噪的目的。（事实上同态解密后得到的密文的噪音要比新鲜密文噪音稍微大一些。）这一手法称之为：重加密技术，它为我们提供了降低噪音的一个方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来你肯定会想到：每次密文运算前只要对密文进行重加密来降低噪音，然后再进行密文运算，那么噪音永远都在可控的范围内，运算结果的解密也就不会失败了。运算电路可以反复递归此过程，就可以达到无限次密文运算的目的了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-23-60138162</guid>
<pubDate>Sat, 23 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-2</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-22-59915903.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59915903&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;——————————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2&lt;/b&gt; &lt;b&gt;可怕的噪音&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;由于公钥pq是公开的，所以知道密文c后可以减去公钥得到：&lt;/p&gt;&lt;p&gt;c-pq= m+2r&lt;/p&gt;&lt;p&gt;由于存在r的干扰，所以无法识别明文m。我们就把m+2r称为噪音。另外在解密时只有当c mod p=m+2r &amp;lt;p/2时, 再对它进行模2运算才能正确解密：&lt;/p&gt;&lt;p&gt;（m+2r）mod 2= m。&lt;/p&gt;&lt;p&gt;如果噪音大于p/2时，c mod p就不再等于m+2r，解密就可能无法正确恢复出明文。所以噪音是影响解密的关键。而噪音会在密文计算中增长，下面来看看增长的势头：&lt;/p&gt;&lt;p&gt;假设c1= m1+2r1+pq1; c2= m2+2r2+pq2; 其中c1是对密文m1的加密，c2是对密文m2的加密。&lt;/p&gt;&lt;p&gt;密文加和乘运算：&lt;/p&gt;&lt;p&gt;c1+c2=(m1+m2)+2(r1+r2)+p(q1+q2)&lt;/p&gt;&lt;p&gt;c1*c2=( m1+2r1)(m2+2r2)+p(pq1q2+m1q2+m2q1+2r1q2+2r2q1)&lt;/p&gt;&lt;p&gt;(c1+c2) mod p= (m1+m2)+2(r1+r2)&lt;/p&gt;&lt;p&gt;c1*c2 mod p=( m1+2r1)(m2+2r2)&lt;/p&gt;&lt;p&gt;由上可见：密文之和的噪音是各自密文的噪音之和；而密文乘积的噪音是噪音之积。因此噪音的主要来源还是乘法运算，在乘法运算中噪音被放大的很快。&lt;/p&gt;&lt;p&gt;例如：设p=11, q=5, m1=0, m2=1，然后分别随机选取r1=1和r2= - 4, 有：&lt;/p&gt;&lt;p&gt;c1=Enc(m1)=m1+2r1+pq=0+2*(-1)+11*5=53; c1 mod p= -2, Dec(c1)=0.&lt;/p&gt;&lt;p&gt;c2=Enc(m2)=m2+2r2+pq=1+2*1+11*5=58; c2 mod p= 3, Dec(1)=1.&lt;/p&gt;&lt;p&gt;因为c1 mod p 和c2 mod p 都是在（-p/2，p/2）范围内，所以解密正确。c1和c2称之为新鲜密文,就是直接由明文生成的密文，在新鲜密文中噪音是在一定合理的范围内的。&lt;/p&gt;&lt;p&gt;我们再来看看c1*c2:&lt;/p&gt;&lt;p&gt;c*=c1*c2=53*58=3074; c* mod p=5, Dec(c*)=1≠m1*m2=0, 解密错误，错误的原因是噪音之积（c1 mod p）*（c2 mod p）= -6 不在（-p/2，p/2）范围内。&lt;/p&gt;&lt;p&gt;看来对密文运算会造成噪音的增大，当噪音超出范围，解密就失败，这意味着对密文运算不可能是无限次的（也就是Evaluate运算功能函数的电路深度是有限的，这在后面我们说到电路时会看到）。&lt;/p&gt;&lt;p&gt;到这里我们只得到了一个运算时噪音范围不能超过p/2的同态方案（Somewhat 同态方案），看来似乎用这个方案实现全同态是行不通的。我们需要的是全同态方案即Evaluate可以运行任意功能函数，而不是某一类功能函数（这叫同态方案）。&lt;/p&gt;&lt;p&gt;估计多少英雄好汉到了这里就觉得没戏了，于是另寻他路，于是一个突破就擦肩而过。那么下面让我们分析一下症结所在。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-22-59915903</guid>
<pubDate>Fri, 22 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密是如何被解决的-1</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-22-59915142.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59915142&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。&lt;/p&gt;&lt;p&gt;——————————————这是一条美丽的分割线——————————————&lt;/p&gt;&lt;p&gt;整数上全同态加密方案有两篇非常经典的论文，一篇是《Fully Homomorphic Encryption over the Integers》以下简称DGHV方案，还有一篇是Gentry写的《Computing Arbitrary Functions of Encrypted Data》简称 CAFED论文。&lt;/p&gt;&lt;p&gt;入门者适合先阅读CAFED论文，这并不是说这篇论文简单，只是因为这篇文章的写法很通俗（严格意义上这篇文章并不是一篇真正的论文，是给杂志写的文章，有点科普性质），有一个很好的比喻的例子“Glovebox”贯穿于整个论文中，Gentry的文笔很好写的也很生动，对有些地方进行了背景解释，而这些解释恰好是DGHV论文中没有说的，当然一开始要想把CAFED论文彻底读懂也不是那么容易的。这个时候可以开始阅读DGHV这篇论文。&lt;/p&gt;&lt;p&gt;这篇论文对于我来说是百读不厌，因为有些地方就算读了一百篇也不见得可以理解，而且这篇文章很适合深挖，有些很有趣的地方，例如噪声参数的设置等等。还有一篇论文就是全同态的经典论文《Fully homomorphic encryption using ideal lattices》，如果对格不熟悉的话，可以读这篇文章的前面三分之一，因为有详细的全同态的定义、层级全同态、允许电路、增强解密电路、bootstrable、重加密原理，以及如何通过递归实现全同态的，尤其是递归实现全同态的过程，在论文中还是值得反复理解的。剩下的当然还有Gentry的博士论文，也可以分阶段阅读。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1、&lt;/b&gt; &lt;b&gt;全同态加密方案&lt;/b&gt;&lt;/p&gt;&lt;p&gt;至于什么是全同态等等形式化定义我就不说了，请参阅论文。&lt;/p&gt;&lt;p&gt;全同态加密用一句话来说就是：可以对加密数据做任意功能的运算，运算的结果解密后是相应于对明文做同样运算的结果。有点穿越的意思，从密文空间穿越到明文空间，但是穿越的时候是要被蒙上眼睛的。另外上面的那句话是不能说反的，例如：运算的结果加密后是相应于对明文做同样运算结果的加密，这样说是不对的，因为加密不是确定性的，每次加密由于引入了随机数，每次加密的结果都是不一样的，同一条明文对应的是好几条密文。而解密是确定的。&lt;/p&gt;&lt;p&gt;全同态具有这么好的性质，什么样的加密方案可以符合要求呢？往下看：&lt;/p&gt;&lt;p&gt;Enc(m): m+2r+pq&lt;/p&gt;&lt;p&gt;Dec(c): (c mod p) mod 2=（c – p×「c/p」）mod 2 = Lsb(c) XOR Lsb(「c/p」)&lt;/p&gt;&lt;p&gt;上面这个加密方案显然是正确的，模p运算把pq消去，模2运算把2r消去，最后剩下明文m 。这个公式看上去很简单，但是却很耐看，需要多看看。&lt;/p&gt;&lt;p&gt;公式中的p是一个正的奇数，q是一个大的正整数（没有要求是奇数，它比p要大的多），p 和q在密钥生成阶段确定，p看成是密钥。而r是加密时随机选择的一个小的整数（可以为负数）。明文m∈ {0,1}，是对“位”进行加密的，所得密文是整数。&lt;/p&gt;&lt;p&gt;上面方案的明文空间是{0,1}，密文空间是整数集。&lt;/p&gt;&lt;p&gt;全同态加密方案中除了加密、解密还有一个非常重要的算法就是：Evaluate，它的作用就是对于给定的功能函数f以及密文c1,c2,…,ct等做运算f (c1,c2,…,ct)。在这里就是对密文做相应的整数加、减、乘运算。&lt;/p&gt;&lt;p&gt;以上方案可以看成是对称加密方案。下面来考虑公钥加密方案。其实把pq看成公钥就OK。由于q是公开的，所以如果把pq看成公钥，私钥p立刻就被知道了（p=pq/q）。怎么办呢？看上面加密算法中，当对明文0进行加密时，密文为2r+pq, 所以我们可以做一个集合{xi；xi=2ri+pqi}，公钥pk就是这个集合{xi}，加密时随机的从{xi}中选取一个子集S，按如下公式进行加密：&lt;/p&gt;&lt;p&gt;Enc(m): m+2r+sum(S); 其中sum(S)表示对S中的xi进行求和。&lt;/p&gt;&lt;p&gt;由于sum(S)是一些0的加密密文之和，所以对解密并不影响，整个解密过程不变。&lt;/p&gt;&lt;p&gt;这个方案是安全的，就是我们所说的DGHV方案。其安全性依赖于一个困难问题“近似GCD问题”。就是给你一些xi，你求不出p来（由于整数上全同态研究热了，近似GCD也成了研究的一个点）。&lt;/p&gt;&lt;p&gt;为了说明方便，我们还是采取pq为公钥的方案（尽管不安全，但是不影响说明过程）。所以加密和解密还是按照一开始的公式，现在pq为公钥，p还是私钥，q是公开参数。再重复一遍我们的加密解密算法：&lt;/p&gt;&lt;p&gt;Enc(m): m+2r+pq&lt;/p&gt;&lt;p&gt;Dec(c): (c mod p) mod 2=（c – p×「c/p」）mod 2 = Lsb(c) XOR Lsb(「c/p」)&lt;/p&gt;&lt;p&gt;另外在这里约定：一个实数模p为：a mod p = a -「a/p」*p, 「a」表示最近整数, 即有唯一整数在（a-1/2, a+1/2]中。所以a mod p的范围也就变成了（-p/2，p/2 ]（这个牢记）。这个和我们平时说的模p范围是不一样的，平时模p范围是[0, p-1]，那是因为模公式中取得是向下取整：a mod p = a –floor（a/p）*p。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Lsb是最低有效位，因为是模2运算，所以结果就是这个二进制数的最低位&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-22-59915142</guid>
<pubDate>Fri, 22 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>MONEY &amp; CENTRAL BANKING 央行与货币</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2019-03-22-59913334.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59913334&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载一篇论文&lt;/p&gt;&lt;p&gt;作者：姚前&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本文探讨了数字货币与银行账户的关系，提出了基于银行账户与数字货币钱包分层并用的设计思路，并借助专项补贴款发放的案例展示了应用场景，同时还提出了进一步研究可聚焦的领域。&lt;/p&gt;&lt;p&gt;&lt;b&gt;基于账户和不基于账户&lt;/b&gt;&lt;/p&gt;&lt;p&gt;数字货币能否发挥其成效，技术路线、风险防控手段及安全保障措施固然是基础，但应用是关键。只有被公众和市场接受的、好用的法定数字货币才有生命力，才能真正实现对传统货币的补充甚至是替代。虽然纯数字货币系统可以不与银行账户关联，但由于我国的货币发行遵循中央银行到商业银行的二元体系，而且当前社会经济活动主要基于商业银行&lt;/p&gt;&lt;p&gt;账户体系开展，如可以借助银行账户体系，充分利用银行现有成熟的IT基础设施以及应用和服务体系，将大大降低数字货币推广门槛，提高使用便捷性和灵活性，有助于最广大的客户群体使用数字货币。数字货币在融入现有的应用基础之上将拓展出更加丰富和多元化的场景，数字货币的自身服务能力和竞争力也将进一步增强。&lt;/p&gt;&lt;p&gt;借助账户体系，最直截了当的办法是扩展中央银行资产负债表的接入范围。事实上，商业银行和一些其他金融机构以央行存款形式持有的中央银行求偿权已经数字化。但中央银行是否应该向更广泛的对手方提供此类服务？包括居民家庭在内的非金融部门是否可以在中央银行持有账户？这个问题引起了广泛的讨论。英格兰银行、欧洲央行和瑞典央行已经&lt;/p&gt;&lt;p&gt;就此问题做了相关的研究。英格兰银行副行长本·布劳德本特道出了商业银行的担忧：“那会引发存款从商业银行转移到央行，导致整个银行体系缩窄，成为&#39;狭义银行&#39;。”实际上，这种担忧目前在监管层面具有一定的代表性。&lt;/p&gt;&lt;p&gt;对此，人民银行行长周小川也早就发表了自己的观点：“数字货币的技术路线可分为基于账户和不基于账户两种，也可分层并用而设法共存。”这是非常原则而又精辟的表述，分层并用的思想显然要比直接在央行开户的方式考虑得更深。但在如何实现的具体手段上，这段话似有不同解读，本文试图谈谈个人的一点理解。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e565506cde73a98d6a18eea53f6ce46d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;603&quot; data-rawheight=&quot;429&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;603&quot; data-original=&quot;https://pic2.zhimg.com/v2-e565506cde73a98d6a18eea53f6ce46d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e565506cde73a98d6a18eea53f6ce46d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;603&quot; data-rawheight=&quot;429&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;603&quot; data-original=&quot;https://pic2.zhimg.com/v2-e565506cde73a98d6a18eea53f6ce46d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e565506cde73a98d6a18eea53f6ce46d_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;商业银行传统账户体系+数字货币钱包属性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为缓冲单独设立数字货币体系给现有银行体系带来的冲击，也为了最大限度地保护商业银行现有的系统投资，在具体设计上，可考虑在商业银行传统账户体系上，引入数字货币钱包属性，实现一个账户下既可以管理现有电子货币，也可以管理数字货币。&lt;/p&gt;&lt;p&gt;电子货币与数字货币管理上有其共性，如账号使用、身份认证、资金转移等，但也存在差异。数字货币管理应符合央行有关钱包设计标准，类似保管箱的概念，银行将根据与客户的约定权限管理保管箱（比如必须有客户和银行两把钥匙才能打开等约定），保留数字货币作为加密货币的所有属性，将来利用这些属性可以灵活订制应用。 &lt;/p&gt;&lt;p&gt;这样做的好处是沿用了货币发行二元体系的做法，数字货币属于M0范畴，是发钞行的负债，在账户行的资产负债表之外。由于账户行依然还在实质性管理客户与账户，不会导致商业银行被通道化或者边缘化。不同于以往的存现金，数字货币不完全依赖银行账户，可以通过发钞行直接确权，利用客户端的数字货币钱包实现点对点的现金交易。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2e8bc80c8f32d35d7b534e33d58702a5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;655&quot; data-rawheight=&quot;430&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;655&quot; data-original=&quot;https://pic2.zhimg.com/v2-2e8bc80c8f32d35d7b534e33d58702a5_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2e8bc80c8f32d35d7b534e33d58702a5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;655&quot; data-rawheight=&quot;430&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;655&quot; data-original=&quot;https://pic2.zhimg.com/v2-2e8bc80c8f32d35d7b534e33d58702a5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2e8bc80c8f32d35d7b534e33d58702a5_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;央行自主发行与授权发行&lt;/b&gt;&lt;/p&gt;&lt;p&gt;发钞行可以是央行，也可以是央行授权的发钞机构（例如港币发行模式）。具体选择哪种发行方式得根据实际情况来定，本文仅作学术探讨。在中央银行集中统一发行数字货币的环境下，商业银行银行库中的数字货币属于商业银行的资产，中央银行的负债；商业银行客户账户中的数字货币则属于客户的资产，中央银行的负债。客户之间点对点交易数字货币，由央行数字货币发行系统进行交易确认与管理，央行承担交易责任；交易电子货币，则和现有流程一致，通过央行跨行支付系统、商业银行核心业务系统完成。&lt;/p&gt;&lt;p&gt;在央行授权发行法定数字货币的环境下，商业银行银行库中的数字货币属于商业银行的资产，发钞行的负债；商业银行客户账户中的数字货币则属于客户的资产，发钞行的负债（发钞行不见得就是账户行）。客户之间点对点交易数字货币，由法定数字货币发钞行进行交易确认与管理（谁发行谁管理），央行承担监管责任；交易电子货币，则和现有流程一致，通过央行跨行支付系统、商业银行核心业务系统完成。需要说明的是，发钞行和中央银行以及发钞行之间的互联互通，将由央行来做顶层设计，该顶层是否可以迁移至分布式账本的架构之下，将是业界面临的重大课题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-16e665b68705b464616487090fe1a503_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;693&quot; data-rawheight=&quot;383&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;693&quot; data-original=&quot;https://pic4.zhimg.com/v2-16e665b68705b464616487090fe1a503_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-16e665b68705b464616487090fe1a503_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;693&quot; data-rawheight=&quot;383&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;693&quot; data-original=&quot;https://pic4.zhimg.com/v2-16e665b68705b464616487090fe1a503_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-16e665b68705b464616487090fe1a503_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;数字货币钱包的设计思路&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在分层并用的具体实现手段上，延续商业银行以客户为中心的思路，在银行基本账户增加数字货币钱包ID字段。钱包起到保管箱功能，不参与日终计提等业务，最小化影响现有银行核心业务系统。数字货币的确权依托发钞行，传统账户与数字货币结合，可以极大地增 数字货币钱包与银行基本账户体系强银行KYC与AML的能力。在钱包设计上，所有的数字货币钱包需符合央行提供的规范。银行端的数字货币钱包较轻，仅提供安全管控以及账户层相关的必要属性，侧重于数字货币的管理；应用服务商提供的客户端的钱包较重，其功能会延伸至展示层与应用层。在客户端，智能合约的应用可以尽情施展，这也是应用服务商的核心竞争力之一。&lt;/p&gt;&lt;p&gt;&lt;b&gt;应用场景示例：专项补贴款发放&lt;/b&gt;&lt;/p&gt;&lt;p&gt;某部委发放专项补贴款，逐级下发至获取补贴款的企业或个人。如果要跟踪补贴发放的实际到位情况，传统模式下难以实现，往往需要逐级汇总报送上来，信息流和资金流不能做到完全匹配，执行中各地存在落实不到位、以拨列支等现象。依托数字货币的可跟踪的特性，辅助一定的智能合约权限管理，部委将可以不依赖其他业务参与方，直通式掌握各级补贴发放情况，避免下级机构挪用补贴的风险，实现专款专用。&lt;/p&gt;&lt;p&gt;如果不在银行账户体系中植入数字货币钱包属性，势必要各级机构、各补贴受益人开通和使用数字钱包，不仅需要考虑数字钱包物理载体的选择，而且还涉及众多参与方，央行将直接面对终端用户，推广难度大。而基于商业银行账户体系，应用部分在商业银行后台即可改造解决。对各级终端用户来说，利用现有账户，操作上和之前日常习惯一致，通过银行柜面、网上银行、手机银行等现有渠道就可以完成该项服务。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7eebbca8443bdf643e441b526d782147_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;568&quot; data-rawheight=&quot;283&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;568&quot; data-original=&quot;https://pic4.zhimg.com/v2-7eebbca8443bdf643e441b526d782147_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7eebbca8443bdf643e441b526d782147_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;568&quot; data-rawheight=&quot;283&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;568&quot; data-original=&quot;https://pic4.zhimg.com/v2-7eebbca8443bdf643e441b526d782147_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-7eebbca8443bdf643e441b526d782147_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;结语&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在全面数字化的世界里，不能因为表面上、形式上都是数，就混淆数字背后的经济金融内涵。此数字与彼数字尽管都是数，但它们有可能代表不同类型的资产，这是在考虑数字货币设计的时候必须牢记在心的。实物货币转化为M1或M2，天然就有实物和数字的区隔，但数字M0极易让人忽略这种区隔。普遍的观点是数字资产之间的转换速度加快了，但这意味着不同类型的数字资产间的差异消失了吗？&lt;/p&gt;&lt;p&gt;人民银行副行长范一飞曾撰文指出：“法定数字货币必然受到现有支付体系、信息技术的影响，但也需要与现有支付体系适当区分，以专注于自身服务领域，发挥其替代传统货币的功能。理论上说，支付体系主要处理的是广义货币中的活期存款部分，而数字货币则主要属于现金（M0）范畴。&lt;/p&gt;&lt;p&gt;”通过在商业银行账户体系中新增数字货币属性的方法，法定数字货币不仅可以有机融入“中央银行—商业银行”二元体系，复用现有的成熟的金融基础设施，更重要的是，此一处理，因特殊考虑了数字M0在商业银行体系中的“安身立命”问题，既可使之独立开来，又可分层并用，发钞行只需对数字货币本身负责，账户行承担实际的业务，应用开发商落实具体的实现，各司其职，边界清晰，若辅之以其他手段（比如可以酌情收取保管费，实质上等同于负利率），或可降低狭义银行出现的可能性。&lt;/p&gt;&lt;p&gt;增加数字货币属性也是对商业银行账户体系的创新，商业银行不仅可以利用现有账户系统继续为本行客户提供数字货币服务，还可以利用数字货币的新特性积极拓展新型业务，进一步加强自身的服务能力与竞争力。本文的探讨只是一个开始，进一步的研究可聚焦钱包的设计规范，更进一步考察的问题还有：1. 如何设计差异化的货币使用成本和资产价格政策来保证转轨期的纸币、法定数字货币和商业银行存款之间的动态平衡。2. 如何在此设计之上构建良性的中央银行、（发钞行）、商业银行、钱包服务提供商、支付服务提供商、数字货币使用方之间的应用生态。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;==========================================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;知识星球ID：28018093&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)”&lt;/b&gt; &lt;b&gt;&lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/Bjq4se&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解读区块链白皮书&lt;/b&gt; &lt;u&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;xima.tv/RNU1Q8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2019-03-22-59913334</guid>
<pubDate>Fri, 22 Mar 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
