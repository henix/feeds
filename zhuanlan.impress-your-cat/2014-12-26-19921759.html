<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>也谈作用域</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/19921759">原文</a></p>
<p>姚培森最近在Continuation专栏里的发了<a class="" data-title="闭包" data-editable="true" href="http://zhuanlan.zhihu.com/forallplt/19918834">闭包</a>一文。我认为写的很烂，比“Monad不就是个自函子范畴上的幺半群”还烂。特别写一篇来喷。</p><p>假如一门语言允许你自己定义函数，那么就会出现作用域的问题。作用域的问题就是怎么找变量定义的问题。</p><p>假如不允许自定义函数，只需要一个变量名到变量值的映射就可以了。不妨把这种映射关系称为Environment。</p><code lang="text">%% 赋值前 {print: &lt;fun&gt;}
var a = 1
%% 赋值后 {print: &lt;fun&gt;, a: 1}
print(a)</code><p>现在来定义一个函数</p><code lang="text">var a = 1
fun f(a)
    print(a)
end fun
f(2)
print(a)</code>此时我们期望的结果是<code lang="text">2
1
</code><p>要是在执行 f(2) 时，我们直接把a指向2，那么结果就是<br></p><code lang="text">2
2
</code><p>所以，函数f需要一个独立的Environment。在执行f(2)先把当前Environment保存下来（比如存在一个栈里，因为f函数里也可以去调用别的函数），建一个新的Environment，把a指向2，之后才开始执行f函数。</p><code lang="text">+------------------------------+
| {a:2}                        |
+------------------------------+
| {print: &lt;fun&gt;, a:1, f:&lt;fun&gt;} |
+------------------------------+
</code><p>不过这样就找不到print了。不过你一定想到了，只要沿着栈往下找总能找到的。</p><p>定义作用域规则，假如变量在当前Environment里，找不到就到外层Environment里找，直到找到为止，假如找到最外面也没有，那就是根本就没定义。</p><p>现在问题来了，看下面这个程序</p><code lang="text">var a = 1

fun f()
    print(a)
end

fun g(a)
    f()
end

g(2)</code><p>假如使用上述规则，那么结果就是</p><code lang="text">2</code><p>原因很简单，因为当前栈是像下面这样的</p><code lang="text">+-----------------------------------------+
| {}                                      |
+-----------------------------------------+
| {a:2}                                   |
+-----------------------------------------+
| {print: &lt;fun&gt;, a:1, f: &lt;fun&gt;, g: &lt;fun&gt;} |
+-----------------------------------------+
</code><p>这意味着，在定义函数时，除了当前Environment里定义的，我们不知道其他变量到底是在哪里定义的。</p><p>我们把程序改一改 <br></p><code lang="text">var a = 1

fun f()
    print(a)
end

fun g(print)
    f()
end

g(2)
</code><p>现在栈是像下面这样的</p><code lang="text">+-----------------------------------------+
| {}                                      |
+-----------------------------------------+
| {print:2}                               |
+-----------------------------------------+
| {print: &lt;fun&gt;, a:1, f: &lt;fun&gt;, g: &lt;fun&gt;} |
+-----------------------------------------+
</code><p>运行到 print(a) 那行就出错了。那该咋办？我们可以把这叫做动态作用域，宣称这是最powerful的作用域，假如你不会用，那是因为你笨。这样问题就解决了。</p><p>可是我是弱智啊。我只能在定义时，就把所有会用到的变量都先存起来。找变量时，只在当前Environment里找。</p><code lang="text">+-------------------------------------------------+
| {print: &lt;fun&gt;, a:1}                             |
+-------------------------------------------------+
| {print:2,                                       |
|  f: {&lt;fun&gt;,{print: &lt;fun&gt;,a:1}}}                 |
+-------------------------------------------------+
| {print: &lt;fun&gt;, a:1,                             |
|  f: {&lt;fun&gt;,{print:&lt;fun&gt;, a:1}},                 |
|  g: {&lt;fun&gt;,{a:1, f: {&lt;fun&gt;,{print:&lt;fun&gt;,a:1}}}} |
+-------------------------------------------------+
</code><p>这样就没问题了。这就是所谓的lexical scope<br></p><p>看下面这个程序 <br></p><code lang="text">var a = 1

fun f()
    var a = a + 1
    print(a)
end

f()
</code><p>在函数 f 里，a既是在外部定义的，又是在内部定义的。这样就有矛盾了。<br></p><p>有些语言的应对方式是在函数内部可以有多个Environment，规则类似动态作用域。</p><code lang="text">+---------------------------------+
| +-----------------------------+ |
| | {a: 2}                      | |
| +-----------------------------+ |
| | {print: &lt;fun&gt;, a:1}         | |
| +-----------------------------+ |
+---------------------------------+
| {print: &lt;fun&gt;, a:1,             |
|  f: {&lt;fun&gt;,{print:&lt;fun&gt;, a:1}}} |
+---------------------------------+
</code><p>这样上面这段程序就能运行了。</p><p>有些语言不喜欢你这么定义，直接就不让你运行这样的程序。这似乎没啥问题。</p><p>有的语言的规则是local by default的，赋值就相当于定义了一个本地的变量。也就是</p><code lang="text">a = 1
</code><p> 相当于</p><code lang="text">var a = 1
</code><p>这看上去也没什么问题。可是要是这语言变量的值是可以改的，那就糟了。内层函数就没法改外层函数变量的值了。这就需要引入 nonlocal 关键字了。</p><p>就是这样</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
