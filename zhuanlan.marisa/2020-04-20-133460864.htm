<div class="title-image"><img src="https://pic1.zhimg.com/v2-c7aede1bfc4f7a1f7eff872777d69783_b.jpg" alt=""></div><p>前几天我回答了一个关于comonad的问题<a href="https://www.zhihu.com/question/31642688/answer/1147007286" class="internal">Monad和Comonad到底是什么东西？</a>。其中有讲到comonad的应用例子，但都还不够直观和实用。后来找到一个Comonad在图像处理中的应用的例子，觉得不错，在这里重新整理一下写出来。与大家分享一下这个例子。</p><p>我们已经知道，Comonad最通常的用法是作为一个无穷的stream，可以源源不断的通过扩展复制生成新的无穷的stream。只要提供从stream中计算得到值的cokleisli函数，我们就可以得到新的stream，或者新的有限的列表，或者一个累加的值。</p><p>例如下面就是生成无穷的自然数的stream，和对自然数的stream进行滑动窗口求和的Comonad的应用例子。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Stream</span> <span class="nf">a</span> <span class="ow">=</span> <span class="nf">a</span> <span class="kt">:&lt;</span> <span class="kt">Stream</span> <span class="nf">a</span> <span class="kr">deriving</span> <span class="kt">Show</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Stream</span> <span class="kr">where</span>
  <span class="nf">fmap</span> <span class="nf">f</span> <span class="p">(</span><span class="nf">x</span> <span class="kt">:&lt;</span> <span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">x</span> <span class="kt">:&lt;</span> <span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">xs</span>
<span class="kr">instance</span> <span class="kt">Comonad</span> <span class="kt">Stream</span> <span class="kr">where</span>
  <span class="nf">extract</span> <span class="p">(</span><span class="nf">x</span> <span class="kt">:&lt;</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">x</span>
  <span class="nf">duplicate</span> <span class="nf">s</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span><span class="kt">:&lt;</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">s</span> <span class="kt">:&lt;</span> <span class="nf">duplicate</span> <span class="nf">xs</span>

<span class="nf">generate</span> <span class="ow">::</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="nf">a</span>
<span class="nf">generate</span> <span class="nf">f</span> <span class="nf">x</span> <span class="ow">=</span> <span class="nf">x</span> <span class="kt">:&lt;</span> <span class="nf">generate</span> <span class="nf">f</span> <span class="nf">x</span> <span class="o">=&gt;&gt;</span> <span class="p">(</span><span class="nf">f</span> <span class="o">.</span> <span class="nf">extract</span><span class="p">)</span>

<span class="nf">nats</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="kt">Integer</span>
<span class="nf">nats</span> <span class="ow">=</span> <span class="nf">generate</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="mi">0</span>

<span class="nf">getWindowSum</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">getWindowSum</span> <span class="nf">n</span> <span class="p">(</span><span class="nf">x</span> <span class="kt">:&lt;</span> <span class="nf">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="nf">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">=</span> <span class="nf">x</span>
  <span class="o">|</span> <span class="nf">n</span> <span class="o">&gt;</span>  <span class="mi">1</span> <span class="ow">=</span> <span class="nf">x</span> <span class="o">+</span> <span class="nf">getWindowSum</span> <span class="p">(</span><span class="nf">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="nf">xs</span>
  <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="nf">undefined</span>

<span class="nf">tensWindows</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="kt">Integer</span>
<span class="nf">tensWindows</span> <span class="ow">=</span> <span class="nf">nats</span> <span class="o">=&gt;&gt;</span> <span class="nf">getWindowSum</span> <span class="mi">10</span></code></pre></div><p>这里nats调用generate生成了一个有无穷多个自然数的stream，其类型是Stream Integer。</p><p>nats生成自然数的stream的计算步骤效果如下所示，逐行累加起来就得到了自然数的stream：</p><div class="highlight"><pre><code class="language-text">0 0 0 0 0 0 0 0 ...
  1 1 1 1 1 1 1 1 ...
    1 1 1 1 1 1 1 1 ...
      1 1 1 1 1 1 1 1 ...
        1 1 1 1 1 1 1 1 ...
          1 1 1 1 1 1 1 1 ...
            1 1 1 1 1 1 1 1 ...</code></pre></div><p>nats的值如下所示：</p><div class="highlight"><pre><code class="language-haskell"><span class="o">&gt;</span> <span class="nf">nats</span>
<span class="mi">0</span> <span class="kt">:&lt;</span> <span class="mi">1</span> <span class="kt">:&lt;</span> <span class="mi">2</span> <span class="kt">:&lt;</span> <span class="mi">3</span> <span class="kt">:&lt;</span> <span class="mi">4</span> <span class="kt">:&lt;</span> <span class="mi">5</span> <span class="kt">:&lt;</span> <span class="mi">6</span> <span class="kt">:&lt;</span> <span class="mi">7</span> <span class="kt">:&lt;</span> <span class="o">...</span></code></pre></div><p>而getWindowSum函数则是取出自然数的stream的前10个自然数，求这10个自然数的和，得到一个新的无穷的stream。这和信号处理中的滑动滤波的窗口计算是一样的，其值如下所示：</p><div class="highlight"><pre><code class="language-haskell"><span class="o">&gt;</span> <span class="nf">tensWindows</span>
<span class="mi">45</span> <span class="kt">:&lt;</span> <span class="mi">55</span> <span class="kt">:&lt;</span> <span class="mi">65</span> <span class="kt">:&lt;</span> <span class="mi">75</span> <span class="kt">:&lt;</span> <span class="mi">85</span> <span class="kt">:&lt;</span> <span class="mi">95</span> <span class="kt">:&lt;</span> <span class="mi">105</span> <span class="kt">:&lt;</span> <span class="o">...</span></code></pre></div><p>我们现在来看图像处理，图像可以看成一个有限的二维阵列的数据结构，如下面的图所示，并不是一个无穷的stream。图像处理中用的最多的一种场景是图像滤波，根据当前图像的一个点的邻域像素的值计算出新图像上该点的值，这种场景是可以应用Comonad来计算的。</p><p>在图像滤波的计算中，我们关心的是图像上的一个点及其邻域的点，因此有一个焦点，如下图所示：</p><figure data-size="small"><noscript><img src="https://pic1.zhimg.com/v2-65883e7c5308ffbd3acaeea78d376388_b.jpg" data-caption="" data-size="small" data-rawwidth="676" data-rawheight="676" class="origin_image zh-lightbox-thumb" width="676" data-original="https://pic1.zhimg.com/v2-65883e7c5308ffbd3acaeea78d376388_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-65883e7c5308ffbd3acaeea78d376388_b.jpg" data-caption="" data-size="small" data-rawwidth="676" data-rawheight="676" class="origin_image zh-lightbox-thumb lazy" width="676" data-original="https://pic1.zhimg.com/v2-65883e7c5308ffbd3acaeea78d376388_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-65883e7c5308ffbd3acaeea78d376388_b.jpg"/></figure><p>于是，我们可以把图像看成一个带焦点的二维阵列的数据结构。其中二维阵列可以用带宽和高参数的一维向量来表示，再加上焦点坐标就得到了我们要的图像数据结构定义。如下所示：</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- | 用一维向量表示的图像二维阵列</span>
<span class="kr">data</span> <span class="kt">BoxedImage</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">BoxedImage</span>
  <span class="p">{</span> <span class="nf">biWidth</span>  <span class="ow">::</span> <span class="o">!</span><span class="kt">Int</span>
  <span class="p">,</span> <span class="nf">biHeight</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Int</span>
  <span class="p">,</span> <span class="nf">biData</span>   <span class="ow">::</span> <span class="o">!</span><span class="p">(</span><span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="nf">a</span><span class="p">)</span>
  <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">BoxedImage</span> <span class="kr">where</span>
  <span class="nf">fmap</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">BoxedImage</span> <span class="nf">w</span> <span class="nf">h</span> <span class="nf">d</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">BoxedImage</span> <span class="nf">w</span> <span class="nf">h</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">d</span><span class="p">)</span>

<span class="c1">-- | 带焦点的图像数据结构</span>
<span class="kr">data</span> <span class="kt">FocusedImage</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">FocusedImage</span> 
  <span class="p">{</span> <span class="nf">boxedImage</span> <span class="ow">::</span> <span class="o">!</span><span class="p">(</span><span class="kt">BoxedImage</span> <span class="nf">a</span><span class="p">)</span>
  <span class="p">,</span> <span class="nf">cx</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">Int</span>
  <span class="p">,</span> <span class="nf">cy</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">Int</span>
  <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">FocusedImage</span> <span class="kr">where</span>
  <span class="nf">fmap</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">FocusedImage</span> <span class="nf">bi</span> <span class="nf">x</span> <span class="nf">y</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FocusedImage</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">bi</span><span class="p">)</span> <span class="nf">x</span> <span class="nf">y</span>

<span class="c1">-- | 带焦点的图像和一般图像的转换函数</span>
<span class="nf">focus</span> <span class="ow">::</span> <span class="kt">BoxedImage</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">FocusedImage</span> <span class="nf">a</span>
<span class="nf">focus</span> <span class="nf">bi</span>
  <span class="o">|</span> <span class="nf">biWidth</span> <span class="nf">bi</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">biHeight</span> <span class="nf">bi</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">FocusedImage</span> <span class="nf">bi</span> <span class="mi">0</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="nf">otherwise</span>                         <span class="ow">=</span> <span class="ne">error</span> <span class="s">&#34;Can not focus on empty image&#34;</span>

<span class="nf">unfocus</span> <span class="ow">::</span> <span class="kt">FocusedImage</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">BoxedImage</span> <span class="nf">a</span>
<span class="nf">unfocus</span> <span class="p">(</span><span class="kt">FocusedImage</span> <span class="nf">bi</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">bi</span></code></pre></div><p>带焦点的图像数据结构FocusedImage  a 我们可以将其看成一个Comonad。其extract函数就是直接把焦点处的值取出来。duplicate函数就是把这个图像的二维阵列中的每一个点的值都扩展为一个以该点为焦点的带焦点的图像数据结构，这个新的图像数据结构的二维阵列和原来的是一样的，保持了相似性。extend函数的参数f 是个函数，这个函数f 将新的带焦点的图像数据结构reduce为一个图像的像素值。这里我们回顾一下 extend f = fmap f . duplicate。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">instance</span> <span class="kt">Comonad</span> <span class="kt">FocusedImage</span> <span class="kr">where</span>
  <span class="nf">extract</span> <span class="p">(</span><span class="kt">FocusedImage</span> <span class="nf">bi</span> <span class="nf">x</span> <span class="nf">y</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">biData</span> <span class="nf">bi</span><span class="p">)</span> <span class="kt">V</span><span class="o">.!</span> <span class="p">(</span><span class="nf">biWidth</span> <span class="nf">bi</span> <span class="o">*</span> <span class="nf">y</span> <span class="o">+</span> <span class="nf">x</span><span class="p">)</span>
  <span class="nf">duplicate</span> <span class="p">(</span><span class="kt">FocusedImage</span> <span class="nf">bi</span><span class="o">@</span><span class="p">(</span><span class="kt">BoxedImage</span> <span class="nf">w</span> <span class="nf">h</span> <span class="kr">_</span><span class="p">)</span> <span class="nf">x</span> <span class="nf">y</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FocusedImage</span>
      <span class="p">(</span><span class="kt">BoxedImage</span> <span class="nf">w</span> <span class="nf">h</span> <span class="o">$</span> <span class="kt">V</span><span class="o">.</span><span class="nf">generate</span> <span class="p">(</span><span class="nf">w</span> <span class="o">*</span> <span class="nf">h</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\i</span> <span class="ow">-&gt;</span>
          <span class="kr">let</span> <span class="p">(</span><span class="nf">y&#39;</span><span class="p">,</span> <span class="nf">x&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">i</span> <span class="p">`</span><span class="nf">quotRem</span><span class="p">`</span> <span class="nf">w</span>
          <span class="kr">in</span>  <span class="kt">FocusedImage</span> <span class="nf">bi</span> <span class="nf">x&#39;</span> <span class="nf">y&#39;</span><span class="p">)</span>
      <span class="nf">x</span> <span class="nf">y</span>
</code></pre></div><p>如果extend函数的参数f 这个函数只关心图像中的焦点及其邻域的点的值（一般邻域是3 x 3，5 x 5），则extend f就是这个带焦点的图像数据结构的滤波处理函数，得到一个新的带焦点的图像数据结构，这个新的图像就是滤波处理后的图像。</p><p>例如一个常见的gauss模糊滤波的处理，其计算核大小是3 x 3的，如下所示：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-04c65e7f4c23a56df068596be4032f9d_b.png" data-caption="" data-size="normal" data-rawwidth="171" data-rawheight="95" class="content_image" width="171"/></noscript><img src="https://pic2.zhimg.com/v2-04c65e7f4c23a56df068596be4032f9d_b.png" data-caption="" data-size="normal" data-rawwidth="171" data-rawheight="95" class="content_image lazy" width="171" data-actualsrc="https://pic2.zhimg.com/v2-04c65e7f4c23a56df068596be4032f9d_b.png"/></figure><p>我们就可以定义如下的计算核函数，可以看到其只关心3 x 3 大小的邻域的点的值：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">blur</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="nf">blur</span> <span class="nf">v</span> <span class="ow">=</span> <span class="nf">fromIntegral</span>
       <span class="o">$</span> <span class="p">(`</span><span class="nf">quot</span><span class="p">`</span> <span class="mi">16</span><span class="p">)</span>
       <span class="o">$</span> <span class="p">(</span> <span class="nf">nbi</span> <span class="mi">0</span>     <span class="o">+</span> <span class="nf">nbi</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nf">nbi</span> <span class="mi">2</span>
         <span class="o">+</span> <span class="nf">nbi</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nf">nbi</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="nf">nbi</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">2</span>
         <span class="o">+</span> <span class="nf">nbi</span> <span class="mi">6</span>     <span class="o">+</span> <span class="nf">nbi</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nf">nbi</span> <span class="mi">8</span>
         <span class="p">)</span>
  <span class="kr">where</span> <span class="cm">{-# INLINE nbi #-}</span>
        <span class="nf">nbi</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
        <span class="nf">nbi</span> <span class="nf">i</span> <span class="ow">=</span> <span class="nf">fromIntegral</span> <span class="o">$</span> <span class="nf">v</span> <span class="kt">V</span><span class="o">.!</span> <span class="nf">i</span>
</code></pre></div><p>然后定义如下的获取邻域点的值的函数，注意这个neighbour函数对超出图像边界的邻域点做了特殊处理，使用了回绕的处理方式，这是一种效果较好的处理方式：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">neighbour</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">FocusedImage</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="nf">neighbour</span> <span class="nf">dx</span> <span class="nf">dy</span> <span class="p">(</span><span class="kt">FocusedImage</span> <span class="nf">bi</span> <span class="nf">x</span> <span class="nf">y</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">biData</span> <span class="nf">bi</span><span class="p">)</span> <span class="kt">V</span><span class="o">.!</span> <span class="p">(</span><span class="nf">biWidth</span> <span class="nf">bi</span> <span class="o">*</span> <span class="nf">y&#39;</span> <span class="o">+</span> <span class="nf">x&#39;</span><span class="p">)</span>
  <span class="kr">where</span> <span class="nf">x&#39;</span> <span class="ow">=</span> <span class="nf">wrap</span> <span class="p">(</span><span class="nf">x</span> <span class="o">+</span> <span class="nf">dx</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">biWidth</span> <span class="nf">bi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">y&#39;</span> <span class="ow">=</span> <span class="nf">wrap</span> <span class="p">(</span><span class="nf">y</span> <span class="o">+</span> <span class="nf">dy</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">biHeight</span> <span class="nf">bi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="cm">{-# INLINE wrap #-}</span>
        <span class="nf">wrap</span> <span class="nf">i</span> <span class="nf">lo</span> <span class="nf">hi</span>
          <span class="o">|</span> <span class="nf">i</span> <span class="o">&lt;</span> <span class="nf">lo</span> <span class="ow">=</span> <span class="nf">lo</span> <span class="o">-</span> <span class="nf">i</span>            <span class="c1">-- 坐标回绕处理</span>
          <span class="o">|</span> <span class="nf">i</span> <span class="o">&gt;</span> <span class="nf">hi</span> <span class="ow">=</span> <span class="nf">hi</span> <span class="o">-</span> <span class="p">(</span><span class="nf">i</span> <span class="o">-</span> <span class="nf">hi</span><span class="p">)</span>     <span class="c1">-- 坐标回绕处理</span>
          <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="nf">i</span></code></pre></div><p>再定义一个取遍焦点的邻域的所有点的值的函数，把这几个函数组合起来，就得到了带焦点的图像数据结构的高斯滤波处理函数blurImage：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">filterImage</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">FocusedImage</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="nf">filterImage</span> <span class="nf">filter</span> <span class="nf">kernelW</span> <span class="nf">fimg</span><span class="o">@</span><span class="p">(</span><span class="kt">FocusedImage</span> <span class="nf">bi</span> <span class="nf">x</span> <span class="nf">y</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">filter</span> <span class="o">$</span>
    <span class="kt">V</span><span class="o">.</span><span class="nf">generate</span> <span class="nf">kernelSize</span> <span class="o">$</span> <span class="nf">\i</span> <span class="ow">-&gt;</span> <span class="nf">neighbour</span> <span class="p">(</span><span class="nf">nbx</span> <span class="nf">i</span><span class="p">)</span> <span class="p">(</span><span class="nf">nby</span> <span class="nf">i</span><span class="p">)</span> <span class="nf">fimg</span>
  <span class="kr">where</span> <span class="nf">nbx</span> <span class="nf">i</span> <span class="ow">=</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="nf">kernelW</span> <span class="p">`</span><span class="nf">quot</span><span class="p">`</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="nf">i</span> <span class="p">`</span><span class="nf">rem</span><span class="p">`</span>  <span class="nf">kernelW</span><span class="p">);</span>
        <span class="nf">nby</span> <span class="nf">i</span> <span class="ow">=</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="nf">kernelW</span> <span class="p">`</span><span class="nf">quot</span><span class="p">`</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="nf">i</span> <span class="p">`</span><span class="nf">quot</span><span class="p">`</span> <span class="nf">kernelW</span><span class="p">);</span>
        <span class="cm">{-# INLINE kernelSize #-}</span>
        <span class="nf">kernelSize</span> <span class="ow">=</span> <span class="nf">kernelW</span> <span class="o">*</span> <span class="nf">kernelW</span>

<span class="cm">{-# INLINE blurImage #-}</span>
<span class="nf">blurImage</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">FocusedImage</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="nf">blurImage</span> <span class="ow">=</span> <span class="nf">filterImage</span> <span class="nf">blur</span> <span class="mi">3</span></code></pre></div><p>然后在main函数中调用blurImage函数，就可以对图像进行高斯模糊处理了，这里的readImage读取jpg 文件并将其转换为灰度图的带焦点的图像数据结构FocusedImage  a，writePng则将带焦点的图像数据结构FocusedImage  a 写入到png 文件中。这两个函数用了JuicyPixels包中提供的readImage和writePng两个函数，JuicyPixels是非常优秀的加载、保存、转换图像的的Haskell实现。使用它，减少了自己写加载和保存图像的函数的麻烦。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="nf">putStrLn</span> <span class="s">&#34;Hello, Haskell!&#34;</span>
  <span class="nf">img</span> <span class="ow">&lt;-</span> <span class="nf">readImage</span> <span class="s">&#34;data/yingwuhua.jpg&#34;</span>
  <span class="c1">-- writePng &#34;output.png&#34; . unfocus . (=&gt;&gt; ebossImage) . focus $ img</span>
  <span class="nf">writePng</span> <span class="s">&#34;output.png&#34;</span> <span class="o">.</span> <span class="nf">unfocus</span> <span class="o">.</span> <span class="p">(</span><span class="o">=&gt;&gt;</span> <span class="nf">blurImage</span><span class="p">)</span> <span class="o">.</span> <span class="nf">focus</span> <span class="o">$</span> <span class="nf">img</span></code></pre></div><p>文章的题图经过这个高斯模糊滤波处理后的灰度图效果如下：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-e1dec3542cd5385eab0f8893c4b48154_b.jpg" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="1080" class="origin_image zh-lightbox-thumb" width="1920" data-original="https://pic1.zhimg.com/v2-e1dec3542cd5385eab0f8893c4b48154_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-e1dec3542cd5385eab0f8893c4b48154_b.jpg" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="1080" class="origin_image zh-lightbox-thumb lazy" width="1920" data-original="https://pic1.zhimg.com/v2-e1dec3542cd5385eab0f8893c4b48154_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-e1dec3542cd5385eab0f8893c4b48154_b.jpg"/></figure><p>我们还可以定义其他滤波处理函数，比如浮雕效果的滤波处理。我们先定义计算核函数，计算核大小同样是3 x 3的：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">eboss</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="nf">eboss</span> <span class="nf">v</span> <span class="ow">=</span> <span class="nf">fromIntegral</span>
       <span class="o">$</span> <span class="p">(</span><span class="o">+</span> <span class="mi">127</span><span class="p">)</span>
       <span class="o">$</span> <span class="p">(</span> <span class="nf">nbi</span> <span class="mi">0</span> <span class="o">*</span> <span class="mi">3</span> <span class="p">`</span><span class="nf">quot</span><span class="p">`</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">0</span>  <span class="o">+</span> <span class="mi">0</span>
         <span class="o">+</span> <span class="mi">0</span>                  <span class="o">+</span> <span class="mi">0</span>  <span class="o">+</span> <span class="mi">0</span>
         <span class="o">+</span> <span class="mi">0</span>                  <span class="o">+</span> <span class="mi">0</span>  <span class="o">+</span> <span class="nf">nbi</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="p">`</span><span class="nf">div</span><span class="p">`</span> <span class="mi">2</span>
         <span class="p">)</span>
  <span class="kr">where</span> <span class="cm">{-# INLINE nbi #-}</span>
        <span class="nf">nbi</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
        <span class="nf">nbi</span> <span class="nf">i</span> <span class="ow">=</span> <span class="nf">fromIntegral</span> <span class="o">$</span> <span class="nf">v</span> <span class="kt">V</span><span class="o">.!</span> <span class="nf">i</span></code></pre></div><p>重复利用前面定义的取遍焦点的邻域的所有点的函数，就得到了浮雕效果的滤波处理函数：</p><div class="highlight"><pre><code class="language-haskell"><span class="cm">{-# INLINE ebossImage #-}</span>
<span class="nf">ebossImage</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">FocusedImage</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="nf">ebossImage</span> <span class="ow">=</span> <span class="nf">filterImage</span> <span class="nf">eboss</span> <span class="mi">3</span></code></pre></div><p>这里由于Haskell的惰性计算特性，eboss计算核函数中的0 项不参与计算，计算速度比高斯模糊滤波处理快了60%左右，其灰度图的效果图如下：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-f1bdaf85457cd55510345fb5cdf8b10b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="1080" class="origin_image zh-lightbox-thumb" width="1920" data-original="https://pic4.zhimg.com/v2-f1bdaf85457cd55510345fb5cdf8b10b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-f1bdaf85457cd55510345fb5cdf8b10b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="1080" class="origin_image zh-lightbox-thumb lazy" width="1920" data-original="https://pic4.zhimg.com/v2-f1bdaf85457cd55510345fb5cdf8b10b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-f1bdaf85457cd55510345fb5cdf8b10b_b.jpg"/></figure><p>Comonad的cokleisli函数是可以组合的，因此我们也可以把这些带焦点的图像的滤波处理函数组合起来，得到一个多种滤波组合的功能更丰富的滤波处理函数：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">reduceNoise</span> <span class="ow">::</span> <span class="kt">Integral</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">FocusedImage</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="nf">reduceNoise</span> <span class="nf">fimg</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="o">!</span><span class="nf">original</span>   <span class="ow">=</span> <span class="nf">extract</span> <span class="nf">fimg</span>
      <span class="o">!</span><span class="nf">blurred</span>    <span class="ow">=</span> <span class="nf">blurImage</span> <span class="nf">fimg</span>
      <span class="o">!</span><span class="nf">edged</span>       <span class="ow">=</span> <span class="nf">fromIntegral</span> <span class="nf">original</span> <span class="o">-</span> <span class="nf">fromIntegral</span> <span class="nf">blurred</span> <span class="ow">::</span> <span class="kt">Int</span>
      <span class="o">!</span><span class="nf">threshold</span>  <span class="ow">=</span> <span class="kr">if</span> <span class="nf">edged</span> <span class="o">&lt;</span> <span class="mi">7</span> <span class="o">&amp;&amp;</span> <span class="nf">edged</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="nf">edged</span>
  <span class="kr">in</span> <span class="nf">fromIntegral</span> <span class="o">$</span> <span class="nf">fromIntegral</span> <span class="nf">blurred</span> <span class="o">+</span> <span class="nf">threshold</span></code></pre></div><p>由于上面的滤波处理函数的计算核是一样大小的，其组合起来所耗费的滤波处理时间比单个的滤波处理时间差别很小。</p><p>这是Comonad的一个很有意思的应用例子，大家可以在此基础上做些进一步的尝试。</p><p>参考和引用：</p><a href="https://link.zhihu.com/?target=https%3A//jaspervdj.be/posts/2014-11-27-comonads-image-processing.html" data-draft-node="block" data-draft-type="link-card" data-image="https://pic1.zhimg.com/v2-ff1aac31e29b03c075ed47f827d9d298_180x120.jpg" data-image-width="600" data-image-height="400" class=" wrap external" target="_blank" rel="nofollow noreferrer">Image Processing with Comonads</a><p></p>