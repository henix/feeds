<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>MLsub大概是个什么鬼.四</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/71767830">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-3af51a30d83fa9ef4677cd19ee72b83d_b.jpg" alt=""></div><p>终于我们可以给<b>MLsub</b>添加一个类型界面了<b>Type Interface</b>自从我们上次重新整理了类型规则之后我们现在的主要问题是找到<i>主要类型方案</i> <img src="https://www.zhihu.com/equation?tex=%5B%5CDelta_p%5D%5Ctau_p" alt="[\Delta_p]\tau_p" eeimg="1"/> 再有 <img src="https://www.zhihu.com/equation?tex=%5CPi%2Ce" alt="\Pi,e" eeimg="1"/> 并有以下关系</p><p><img src="https://www.zhihu.com/equation?tex=%5CPi+%5CVdash+e%3A%5B%5CDelta%5D%5Ctau%5C+iff%5C+%5B%5CDelta_p%5D%5Ctau_p%5Cleq%5E%5Cforall%5B%5CDelta%5D%5Ctau" alt="\Pi \Vdash e:[\Delta]\tau\ iff\ [\Delta_p]\tau_p\leq^\forall[\Delta]\tau" eeimg="1"/> </p><p>我们知道<b>AlgoW(Algorithm W)</b>使用 <img src="https://www.zhihu.com/equation?tex=%5CGamma%2Ce" alt="\Gamma,e" eeimg="1"/>使用替换规则去更改 <img src="https://www.zhihu.com/equation?tex=%5CGamma%2C%5Ctau" alt="\Gamma,\tau" eeimg="1"/> , 假如<b>e</b>他是关闭的(closed)然后我们有个主要类型方案 <img src="https://www.zhihu.com/equation?tex=%5B%5D%5Ctau_p+" alt="[]\tau_p " eeimg="1"/> , 所以他就会满足(上回讲的那个定理6)</p><p><img src="https://www.zhihu.com/equation?tex=%5Cvdash+e%3A+%5Ctau%5C+iff%5C+%5Crho%28%5Ctau_p%29%5Cleq%5Ctau%5C+for%5C+some%5C+subtitution%5C+%5Crho" alt="\vdash e: \tau\ iff\ \rho(\tau_p)\leq\tau\ for\ some\ subtitution\ \rho" eeimg="1"/> </p><p>所以我们必须创建一个函数 <img src="https://www.zhihu.com/equation?tex=P%28%5CPi%3Be%29" alt="P(\Pi;e)" eeimg="1"/>, 这个函数会接受所有的极类型环境 <img src="https://www.zhihu.com/equation?tex=%5CPi" alt="\Pi" eeimg="1"/> 和一个语句<b>e</b>然后构造一个主要类型方案(我们只好假设用户没瞎写 ,<b>e</b>有类型) </p><p><img src="https://www.zhihu.com/equation?tex=P%28%5CPi%3B%5Chat%7Bx%7D%29+%3D+%5CPi%28%5Chat%7Bx%7D%29%5C%5C+P%28%5CPi%3Bx%29+%3D+%5Bx%3Aa%5Da%5C%5C+P%28%5CPi%3Blet%5C+%5Chat%7Bx%7D%3De_1%5C+in%5C+e_2%29+%3D+%5B%5CDelta_1%5Csqcap%5CDelta_2%5D%5Ctau_2%5C%5Cwhere%5B%5CDelta_1%5D%5Ctau_1+%3D+P%28%5CPi%3Be_1%29%5C%5C+and%5B%5CDelta_2%5D%5Ctau_2%3DP%28%5CPi+%2C+%5Chat%7Bx%7D%3A%5B%5CDelta_1%5D%5Ctau_1%29" alt="P(\Pi;\hat{x}) = \Pi(\hat{x})\\ P(\Pi;x) = [x:a]a\\ P(\Pi;let\ \hat{x}=e_1\ in\ e_2) = [\Delta_1\sqcap\Delta_2]\tau_2\\where[\Delta_1]\tau_1 = P(\Pi;e_1)\\ and[\Delta_2]\tau_2=P(\Pi , \hat{x}:[\Delta_1]\tau_1)" eeimg="1"/> </p><p>我们为了实现 <img src="https://www.zhihu.com/equation?tex=%5Clambda+" alt="\lambda " eeimg="1"/> 类型推导 , 我们不得不使用一种很简单的技巧 <img src="https://www.zhihu.com/equation?tex=%5CDelta_x" alt="\Delta_x" eeimg="1"/>表示 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> 被拿出 <img src="https://www.zhihu.com/equation?tex=%5CDelta" alt="\Delta" eeimg="1"/>, 同时添加规则 <img src="https://www.zhihu.com/equation?tex=%5CDelta%28x%29" alt="\Delta(x)" eeimg="1"/> , <img src="https://www.zhihu.com/equation?tex=%5CDelta%28x%29%3D%5Ctop" alt="\Delta(x)=\top" eeimg="1"/> 用于 <img src="https://www.zhihu.com/equation?tex=x+%5Cnotin+dom%5C+%5CDelta" alt="x \notin dom\ \Delta" eeimg="1"/> 所以不使用任何传入的参数的函数类型就会成为 <img src="https://www.zhihu.com/equation?tex=%5Ctop%5Crightarrow%5Ctau" alt="\top\rightarrow\tau" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=P%28%5CPi%3B%5Clambda+x.e%29%3D%5B%5CDelta_x%5D%28%5CDelta%28x%29%5Crightarrow%5Ctau%29%5C%5Cwhere%5B%5CDelta%5D%5Ctau+%3D+P%28%5CPi%3Be%29%5C%5C+P%28%5CPi%3B%5C%7Bl_1%3De_1+%2C+...+%2C+l_n%3De_n%5C%7D%29%3D%5B%5Cprod_%7Bi%7D%5CDelta_i%5D%5C%7Bl_1%3A%5Ctau_1+%2C+...+%2C+l_n%3A%5Ctau_n%5C%7D%5C%5Cwhere+%5B%5CDelta_i%5D%5Ctau_i+%3D+%5CPi%28%5CPi%3Be_i%29" alt="P(\Pi;\lambda x.e)=[\Delta_x](\Delta(x)\rightarrow\tau)\\where[\Delta]\tau = P(\Pi;e)\\ P(\Pi;\{l_1=e_1 , ... , l_n=e_n\})=[\prod_{i}\Delta_i]\{l_1:\tau_1 , ... , l_n:\tau_n\}\\where [\Delta_i]\tau_i = \Pi(\Pi;e_i)" eeimg="1"/> </p><p>根据 <img src="https://www.zhihu.com/equation?tex=%5Cleq%5E%5Cforall" alt="\leq^\forall" eeimg="1"/>的定义 , <img src="https://www.zhihu.com/equation?tex=%5B%5CDelta%5D%5Ctau" alt="[\Delta]\tau" eeimg="1"/> 的实例符合下列规矩</p><p><img src="https://www.zhihu.com/equation?tex=%5Cuparrow%5C%7B%5Crho%28%5B%5CDelta%5D%5Ctau%7C%5Crho%5C+a%5C+substitution%5C%7D" alt="\uparrow\{\rho([\Delta]\tau|\rho\ a\ substitution\}" eeimg="1"/> </p><p>这里的 <img src="https://www.zhihu.com/equation?tex=%5Cuparrow" alt="\uparrow" eeimg="1"/>指的是子类型规则下的一个上闭包 , 假如有实例 <img src="https://www.zhihu.com/equation?tex=%5B%5CDelta%5D%5Ctau%7C%5Ctau_1+%5Cleq+%5Ctau_2" alt="[\Delta]\tau|\tau_1 \leq \tau_2" eeimg="1"/>那么我们就有限制</p><p><img src="https://www.zhihu.com/equation?tex=%5Cuparrow%5C%7B%5Crho%28%5B%5CDelta%5D%5Ctau%29%7C%5Crho%28%5Ctau_1%29%5Cleq%5Crho%28%5Ctau_2%29%5C%7D" alt="\uparrow\{\rho([\Delta]\tau)|\rho(\tau_1)\leq\rho(\tau_2)\}" eeimg="1"/> </p><p>然后根据上面的规则假如我们有一个函数的应用 <img src="https://www.zhihu.com/equation?tex=e_1%5C+e_2" alt="e_1\ e_2" eeimg="1"/> 我们就有以下规则</p><p><img src="https://www.zhihu.com/equation?tex=%5Cuparrow%5C%7B%5Crho%28%5B%5CDelta_1+%5Csqcap+%5CDelta_2%5D%5Calpha%29%7C%5Crho%28%5Ctau_1%29%5Cleq%5Crho%28%5Ctau_2%29%5Crightarrow+%5Crho%28%5Calpha%29%5C%7D" alt="\uparrow\{\rho([\Delta_1 \sqcap \Delta_2]\alpha)|\rho(\tau_1)\leq\rho(\tau_2)\rightarrow \rho(\alpha)\}" eeimg="1"/> </p><p>为了推导这个类型 , 我们就必须找到 <img src="https://www.zhihu.com/equation?tex=%5B%5CDelta%5D%5Ctau" alt="[\Delta]\tau" eeimg="1"/> 我们就可以定义 <img src="https://www.zhihu.com/equation?tex=P%28%5CPi%3Be_1%5C+e_2%29" alt="P(\Pi;e_1\ e_2)" eeimg="1"/> 符合以下规则</p><p class="ztext-empty-paragraph"><br/></p><p><img src="https://www.zhihu.com/equation?tex=P%28%5CPi%3Be_1%5C+e_2%29%3D%5B%5CDelta%5D%5Ctau%5C%5C+%5Cquad+where%5C+inst%28%E5%AE%9E%E4%BE%8B%29%28%5B%5CDelta%5D%5Ctau%29%3Dinst%28%5B%5CDelta_1%5Csqcap%5CDelta_2%5D%5Calpha%7C%5Ctau_1+%5Cleq%5Ctau_2%5Crightarrow%5Calpha0%29%5C%5C+%5Cqquad+and%5C+%5B%5CDelta_1%5D%5Ctau_1+%3D+P%28%5CPi%3Be_1%29+%2C+%5B%5CDelta_2%5D%5Ctau_2+%3D+P%28%5CPi%3Be_2%29" alt="P(\Pi;e_1\ e_2)=[\Delta]\tau\\ \quad where\ inst(实例)([\Delta]\tau)=inst([\Delta_1\sqcap\Delta_2]\alpha|\tau_1 \leq\tau_2\rightarrow\alpha0)\\ \qquad and\ [\Delta_1]\tau_1 = P(\Pi;e_1) , [\Delta_2]\tau_2 = P(\Pi;e_2)" eeimg="1"/> </p><p>那么投射就可以被定义为</p><p><img src="https://www.zhihu.com/equation?tex=P%28%5CPi%3Be.l%29%3D%5B%5CDelta%5D%5Ctau%5C%5C+where%5C+inst%28%5B%5CDelta%5D%5Ctau%29%3Dinst%28%5B%5CDelta_1%5D%5Calpha%7C%5Ctau_1%5Cleq%5C%7Bl%3A%5Calpha%5C%7D%29%5C%5C+and%5C+%5B%5CDelta_1%5D%5Ctau_1+%3D+P%28%5CPi%3Be%29" alt="P(\Pi;e.l)=[\Delta]\tau\\ where\ inst([\Delta]\tau)=inst([\Delta_1]\alpha|\tau_1\leq\{l:\alpha\})\\ and\ [\Delta_1]\tau_1 = P(\Pi;e)" eeimg="1"/> </p><p>所以我们想要定义一个基类型我们就必须找到某种方法使得</p><p><img src="https://www.zhihu.com/equation?tex=inst%28%5B%5CDelta%5D%5Ctau%29%3Dinst%28%5B%5CDelta%27%5D%5Ctau%27%7CC%29" alt="inst([\Delta]\tau)=inst([\Delta&#39;]\tau&#39;|C)" eeimg="1"/><b>C</b>是一个限制的集合. </p><h2>归一化</h2><p>前置知识</p><p><img src="https://www.zhihu.com/equation?tex=fv%28x%29%3Dx%5C%5C+fv%28%5Clambda+x.e%29%3Dfv%28e%29-%5C%7Bx%5C%7D%5C%5C+fv%28e_1e_2%29%3Dfv%28e_1%29%5Ccup+fv%28e_2%29%5C%5C+ftv%28%5Calpha%29+%3D+%5C%7B+%5Calpha+%5C%7D+%5C%5C+ftv%28%5Ctau_1+%5Crightarrow+%5Ctau_2%29%3D+ftv%28%5Ctau_1%29+%5Ccup+ftv%28%5Ctau_2%29+%5C%5C+ftv%28%5Cforall+x.+t%29+%3D+ftv%28t%29+-+%5C%7B+x+%5C%7D+%5C%5C+" alt="fv(x)=x\\ fv(\lambda x.e)=fv(e)-\{x\}\\ fv(e_1e_2)=fv(e_1)\cup fv(e_2)\\ ftv(\alpha) = \{ \alpha \} \\ ftv(\tau_1 \rightarrow \tau_2)= ftv(\tau_1) \cup ftv(\tau_2) \\ ftv(\forall x. t) = ftv(t) - \{ x \} \\ " eeimg="1"/> </p><p>下面是最经典的归一化(<b>Unification</b>)算法的数学表示</p><p><img src="https://www.zhihu.com/equation?tex=sub_u%28%5Ctau_1%5Crightarrow%5Ctau_2%3D%5Ctau_3%5Crightarrow%5Ctau_4%29%3D%5C%7B%5Ctau_1+%3D+%5Ctau_3+%2C+%5Ctau_2+%3D+%5Ctau_4%5C%7D%5C%5C+sub_u%28%5C%7Bf%5C%7D%3D%5C%7Bg%5C%7D%29%3D%5C%7Bf%28l%29%3Dg%28l%29%7Cl%5Cin+D%5C%7D%5C%5C+%5Cqquad+where%5C+D%3Ddom%5C+f%3Ddom%5C+g%5C%5C+U%28%5Coslash%29%3D%5B%5D%5C%5C+U%28%5Calpha%3D%5Calpha+%2C+C%29+%3D+U%28C%29%5C%5C+U%28%5Calpha%3D%5Ctau+%2C+C%29%3DU%28%5Ctheta_%7B%5Calpha%3D%5Ctau%7DC%5Ccirc%5Ctheta_%7B%5Calpha%3D%5Ctau%7D%5Cquad%5Calpha%5Cnotin+ftv%28%5Ctau%29%29%5C%5C+U%28%5Ctau%3D%5Calpha+%2C+C%29%3DU%28%5Ctheta_%7B%5Calpha%3D%5Ctau%7DC%5Ccirc%5Ctheta_%7B%5Calpha%3D%5Ctau%7D%5Cquad%5Calpha%5Cnotin+ftv%28%5Ctau%29%29%5C%5C+U%28c+%2C+C%29%3DU%28sub_u%28c%29+%2C+C%29" alt="sub_u(\tau_1\rightarrow\tau_2=\tau_3\rightarrow\tau_4)=\{\tau_1 = \tau_3 , \tau_2 = \tau_4\}\\ sub_u(\{f\}=\{g\})=\{f(l)=g(l)|l\in D\}\\ \qquad where\ D=dom\ f=dom\ g\\ U(\oslash)=[]\\ U(\alpha=\alpha , C) = U(C)\\ U(\alpha=\tau , C)=U(\theta_{\alpha=\tau}C\circ\theta_{\alpha=\tau}\quad\alpha\notin ftv(\tau))\\ U(\tau=\alpha , C)=U(\theta_{\alpha=\tau}C\circ\theta_{\alpha=\tau}\quad\alpha\notin ftv(\tau))\\ U(c , C)=U(sub_u(c) , C)" eeimg="1"/> </p><p>(垃圾知乎没\empty艹(日语))</p><p>好的 , 又有不少人被这些数学蒙住了双眼 , 一会儿我写个<b>Haskell</b>的伪码好了</p><p>添加上递归类型就是</p><p><img src="https://www.zhihu.com/equation?tex=sub_%7Bu%5E%5Cmu%7D%28%5Cmu.%5Calpha%5Ctau_1+%3D+%5Ctau_2%29%3D%5C%7B%5Ctau_1%5B%5Cmu%5Calpha.%5Ctau_1%5D%3D%5Ctau_2%5C%7D%5C%5C+sub_%7Bu%5E%5Cmu%7D%28%5Ctau_1+%3D+%5Cmu.%5Calpha%5Ctau_2%29%3D%5C%7B%5Ctau_1%5B%3D%5Ctau_2%5B%5Cmu%5Calpha.%5Ctau_2%5D%5C%7D%5C%5C++U%5E%5Cmu%28H%3B%5Coslash%29%3D%5B%5D%5C%5C+U%5E%5Cmu%28H%3B%5Calpha%3D%5Calpha+%2C+C%29+%3D+U%5E%5Cmu%28H%3BC%29%5C%5C+U%5E%5Cmu%28H%3B%5Ctau_1%3D%5Ctau_2+%2C+C%29+%3D+U%5E%5Cmu%28C%29%5Cquad%5Ctau_1%3D%5Ctau_2%5Cin+H%5C%5C+U%5E%5Cmu%28%5Calpha%3D%5Ctau+%2C+C%29%3DU%5E%5Cmu%28%5Ctheta_%7B%5Calpha%3D%5Ctau%7DC%3B%5Ctheta_%7B%5Calpha%3D%5Ctau%7DH%29%5Ccirc%5Ctheta_%7B%5Calpha%3D%5Ctau%7D%5C%5C+U%5E%5Cmu%28%5Ctau%3D%5Calpha+%2C+C%29%3DU%5E%5Cmu%28%5Ctheta_%7B%5Calpha%3D%5Ctau%7DC%3B%5Ctheta_%7B%5Calpha%3D%5Ctau%7DH%29%5Ccirc%5Ctheta_%7B%5Calpha%3D%5Ctau%7D%5C%5C+U%5E%5Cmu%28H%3Bc+%2C+C%29%3DU%5E%5Cmu%28H+%2C+c%3Bsub_%7Bu%5E%5Cmu%7D%28c%29+%2C+C%29" alt="sub_{u^\mu}(\mu.\alpha\tau_1 = \tau_2)=\{\tau_1[\mu\alpha.\tau_1]=\tau_2\}\\ sub_{u^\mu}(\tau_1 = \mu.\alpha\tau_2)=\{\tau_1[=\tau_2[\mu\alpha.\tau_2]\}\\  U^\mu(H;\oslash)=[]\\ U^\mu(H;\alpha=\alpha , C) = U^\mu(H;C)\\ U^\mu(H;\tau_1=\tau_2 , C) = U^\mu(C)\quad\tau_1=\tau_2\in H\\ U^\mu(\alpha=\tau , C)=U^\mu(\theta_{\alpha=\tau}C;\theta_{\alpha=\tau}H)\circ\theta_{\alpha=\tau}\\ U^\mu(\tau=\alpha , C)=U^\mu(\theta_{\alpha=\tau}C;\theta_{\alpha=\tau}H)\circ\theta_{\alpha=\tau}\\ U^\mu(H;c , C)=U^\mu(H , c;sub_{u^\mu}(c) , C)" eeimg="1"/></p><p> 有缺陷! 我们有 <img src="https://www.zhihu.com/equation?tex=%5Calpha%3D%5Ctau" alt="\alpha=\tau" eeimg="1"/>这个限制在使用替换规则 <img src="https://www.zhihu.com/equation?tex=%5Ctheta_%7B%5Calpha%3D%5Ctau%7D" alt="\theta_{\alpha=\tau}" eeimg="1"/>的时候会被淘汰</p><p>因为 <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="\alpha" eeimg="1"/>全部都被干掉了QWQ , 这个是由<b>解决方案</b>的但是我们由于篇幅的原因先讲到这儿吧 !</p><hr/><p>这一章我鸽了很长时间因为第一我刚回国需要和同学吃吃饭什么的 , 第二是先要差不多写出来伪码的程度理解这个是在干什么之后再胡乱分析一波...<br/>这一章将是噩梦</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
