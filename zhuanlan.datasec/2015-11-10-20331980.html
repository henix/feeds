<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>利用机器学习实施攻击：Probabilistic Spying on Encrypted Tunnels</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20331980">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/926f6e23f01d08cefe7f74189568b1e7_r.jpg" alt=""></div>0 前言<p>在本篇专栏之前，首先要为各位知乎er们以及颜老致歉！颜老只希望面对面交流，因此我整理出的有关RSA发展的专栏只留我个人使用，不再公开给大家。在此也想颜老公开致歉！</p><p>虽然RSA发展的专栏已经删除，但我原本还是想撰写一篇有关RSA发展和攻击的文章。然而，既然是RSA的攻击，攻击代码当然是必不可少的啦。不过写代码可是有点小繁琐… 因此，我将把攻击算法实现完毕后，再为大家推出那一篇有关RSA的专栏。</p><p>这次给大家带来的专栏是我为i春秋听译Black Hat 2014中的第二个视频。视频题目为：《Probabilistic Spying on Encrypted Tunnels》，中文翻译为《依概率侦查加密通路》。大家如果想看中英双语版的话，需要在i春秋网站注册，然后就可以观看了。在i春秋上，公开的会议视频是免费的，所以大家只需要注册就可以看喽。对于我来说，因为是为别人制作视频，所以我不能放出视频下载链接，还请大家见谅。</p><ul><li>Youtube链接：<a href="https://www.youtube.com/watch?v=j3CB5ICqemA" data-editable="true" data-title="youtube.com 的页面" class="">https://www.youtube.com/watch?v=j3CB5ICqemA</a>；<br></li><li>中英双语链接：<a href="http://www.ichunqiu.com/section/949" data-editable="true" data-title="Black Hat USA 2014安全大会演讲课程详情" class="">Black Hat USA 2014安全大会演讲课程详情</a>（第12节）；</li></ul><p>本专栏的宗旨就在于用尽可能简单的语言介绍与信息安全相关的各种概念或攻击算法的思路。因此，我会尽可能不用数学符号，而是用描述性语言为大家介绍，并且给出专有名词。如果各位知乎er们希望了解更多的相关内容，可以以我给出的专有名词为关键词进行搜索和学习。</p><p>本文已授权i春秋转载（<a href="http://www.ichunqiu.com" data-editable="true" data-title="i春秋学院-信息安全体验中心">i春秋学院-信息安全体验中心</a>，微信号：i春秋）。转载请注明出处。</p><p>==========================</p><p>1 加密算法的安全性</p><p>密码学中的加解密算法已经发展了将近5000年的时间了。从古典密码学中的凯撒密码（Caesar Cipher）、单表代换密码（MonoAlphabetic Cipher）、多表代换密码（PolyAlphabetic Cipher）、一直到第二次世界大战时期德军使用的恩格玛（Engima），都被认为是不安全的。而且不安全到可以通过加密密文（也就是加密后的结果）中完全恢复出明文（也就是被加密的内容）。</p><ul><li>如果诸位对古典密码学感兴趣，可以观看视频：<a href="http://www.bilibili.com/video/av2918521/" data-editable="true" data-title="【中字】让科教君细缕密码学，加密及解密——密码学cryptography@阿尔法小分队" class="">【中字】让科教君细缕密码学，加密及解密——密码学cryptography@阿尔法小分队</a>；<br></li><li>如果诸位对Engima加密机感兴趣，可以观看视频：<a href="http://www.bilibili.com/video/av2883992/" data-editable="true" data-title="【中字】二战间谍战——英格玛密码机上（加密）@阿尔法小分队科教组" class="">【中字】二战间谍战——英格玛密码机上（加密）@阿尔法小分队科教组</a>、<a href="http://www.bilibili.com/video/av2884019/" data-editable="true" data-title="【中字】二战间谍战——英格玛密码机下（解密）@阿尔法小分队科教组" class="">【中字】二战间谍战——英格玛密码机下（解密）@阿尔法小分队科教组</a>；<br></li></ul><p>时间来到了现代，按照信息论创始人香农（<a href="https://en.wikipedia.org/wiki/Claude_Shannon" data-editable="true" data-title="Claude Shannon" class="">Claude Shannon</a>）的定义，一个加密算法是安全的，只有当从密文中无法恢复出明文哪怕一点点的消息才可以。这种定义称为加密算法的语义安全性（Semantic Security）。按照密码学大牛Dan Boneh在其Coursera公开课《Cryptography I》的介绍，语义安全性可以按照下图表述：</p><p><img src="https://pic3.zhimg.com/eba2069e40e360585cb21bfa8920394f_r.png" data-rawwidth="600" data-rawheight="89">看起来有点复杂啊… 没关系，针对知乎上的一个相关的问题，我进行过相对来说比较接地气的回答，链接为：<a href="http://www.zhihu.com/question/37203836/answer/70932036" data-editable="true" data-title='如何理解"语义安全(semantic security)"? - 刘巍然-学酥的回答' class="">如何理解"语义安全(semantic security)"? - 刘巍然-学酥的回答</a>。而我们实际上能达到的安全性是多项式时间语义安全性，也就是下图表述的安全性：</p><p><img src="https://pic1.zhimg.com/d858eed32494fbc19b26ff5ca27054a3_r.png" data-rawwidth="600" data-rawheight="87">简单地说，如果利用现在计算能力最厉害的计算机，也无法从密文中得到哪怕一点点跟明文有关的信息，我们就认为这个加密算法是实际上安全的。</p><p>存在这样的加密算法吗？至少到现在为止， 满足这种条件的加密算法还是存在的。其中一种满足条件的加密算法叫做高级加密标准（Advanced Encryption Standard），简称AES（2015.11.11更新：感谢<a href="http://www.zhihu.com/people/qian-chen-42-72" data-hash="871ce326f127d5dc7ce228d84956b517" class="member_mention" data-title="@Qian Chen" data-editable="true">@Qian Chen</a>同学的指正。的确，AES算法目前为止只是假设满足“实际上安全”，并没有很有说服力的证明方法可以证明到底是不是满足这个条件。）。不过，AES是一种分组加密算法（Block Cipher），如果单独使用的话，只有消息长度小于分组长度的条件下才能满足上述的安全条件。不过呢，通过使用密码学家们提出的一些加密模式来应用AES（也就是所谓的CFB模式、OFB模式、CTR模式等），组合出来的加密算法完全可以达到上述定义的安全条件。</p><br><p>满足这类安全条件的加密算法已经在实际中被广泛使用，最经典的应用就是SSH（Secure Shell）了。他是创建在应用层和传输层基础上的安全协议，为计算机上的Shell提供安全的传输和使用环境。简单地说，通过这个协议，一个知道密钥的远程用户可以通过软件安全地连接到服务器，并对其进行操作。如果某个攻击者不知道密钥的话，他就没办法连接到服务器，对其进行操作了。这个协议还可以进行扩展。使用SSH协议，我们还可以用浏览器安全地访问网站（比如Fackbook、Google什么的）、安全地使用应用软件（比如Skype、LinkedIn什么的）。</p><p>==========================</p><p>2 攻击原理</p><p>既然我们可以得到一个香农给出的定义下都安全的加密算法，那我们如果正确使用这种加密算法，岂不是一劳永逸了。世界和平向我们招手啊！不过遗憾的是，事情往往不是我们想象的那么简单… 我们再仔细看看这个定义：<img src="https://pic1.zhimg.com/d858eed32494fbc19b26ff5ca27054a3_r.png" data-rawwidth="600" data-rawheight="87"></p><br><p>在前提条件中出现了个|m0|，|m1|的要求。这是个什么要求呢？这个要求的意思是，我们必须让明文的长度都一样才可以。想想其实也挺合理的，要是明文长度不一样，加密结果出来的长度肯定也不一样，那我们就可以进行区分了嘛。不过再仔细想想，这种要求好像也没什么不可以。这种区分只是从密文长度上进行区分，而密文本身是从那个明文中加密得到的，对于攻击算法来说还是不知道… 似乎也挺合理的。</p><p>不过，就是这个看似合理的假设，引出了这个Black Hat 2014演讲的工作：我就是利用密文长度不一样的特性，在具体应用场景下进行攻击。而他们的攻击目的，就是通过检测SSH传输的数据包，在不知道传输内容的条件下，得知用户在通过SSH使用哪个应用程序、或者通过哪个浏览器访问哪个网站。</p><img src="https://pic3.zhimg.com/6c0aa79ede09dde7f320331068a5a3da_r.jpg" data-rawwidth="1280" data-rawheight="720"><p>==========================</p><p>3 攻击方法</p><p>在计算机网络中，所有的数据都是通过数据包的形式发送的。数据包有大有小，小的数据包可以只有几个字节，大的数据包可以有KB以上的字节。再大的数据量怎么办呢？数据发送的时候把数据拆成小数据包，编好号后发送；接收的时候把收到的小数据包按照编号排好，再还原成原始数据就可以啦。</p><p>应用程序呢，就是通过发送和接收大大小小的数据包，从而允许用户和服务器通信，实现各种各样的功能，造就了我们五彩缤纷的网络世界。不过，为了能让应用程序更好用，在软件实现的过程中还需要增加一些辅助的数据包。</p><p>我们用一个例子来解释一下会比较好，就用微信来举例吧。</p><ul><li>微信发送文字消息的时候，先检查文字消息的长度，如果长度没有超过最大值，就打成一个数据包，在数据包上标注“这个是发送给XXX的文字消息”，就发送出去了。所以在以前的微信版本，或者QQ中，有时候会提示大家：文字长度超过最大长度，这就是因为一个数据包装不下那么多的文字了。不过，现在版本好像没有这个限制了，感谢微信团队！如果文字消息长度超了，微信会自动把文字拆成几小段，分别打成数据包发送。<br></li><li>微信发送语音消息的时候也有同样的问题。解决方法和文字消息相类似，只不过现在发送的数据不是文字信息了，而是语音信息。</li><li>微信在视频聊天、语音聊天的时候呢，是不间断地发送和接收消息。由于微信不知道用户什么时候结束视频或者语音聊天，它会造一个最大尺寸的数据包，然后把视频语音信息往里面放，放满了就发出去，并且清空这个数据包，继续往里放。这样一来，从用户的角度就会觉得视频语音是很流畅的，其实是填满了数据包自动发，在接收端自动合并。</li><li>基本功能大家都明白了，我们还会发现微信知道我们什么时候断网了什么时候没断网，这是怎么做到的呢？这里就有心跳包（Heart Beat Package）的概念。我们的微信每隔一段时间会自动给服务器发送一个小数据包，告诉服务器“我在线啦”。服务器那边如果隔了很长时间都没收到用户微信客户端发来的这个小数据包，就会觉得“没准你已经掉线了”，这样就能判断出用户的在线情况。</li></ul><p>好了，现在我们知道我们的微信在不停的发送、接收各种数据包，而且心跳包是有规律发送的。同时，各种数据包的长度都不太一样。我们的Black Hat们就利用这个特点进行攻击。怎么攻击呢？分为两步：</p><p>——————————————</p><p>（1） 学习步骤</p><p>Black Hat们首先让攻击软件适应适应，看看微信在很长一段时间内观察微信客户端上传和接收数据的数据包长度分布情况，试着去发现里面有什么规律没有。要做到这一点，Black Hat们首先开着微信，采集一段时间微信的数据。</p><p><img src="https://pic2.zhimg.com/03b943c6d9175c6ea5e74deb43392f38_r.jpg" data-rawwidth="1280" data-rawheight="720">随后，让攻击软件看看这段采集的数据，通过算法去找找各个数据包长度之间有没有什么规律。具体来说，攻击算法观察每10秒的数据，看看是不是有如下规律：<br></p><ul><li>每10秒的数据包长度是不是大部分都比较短？是不是大部分都比较长？还是说有的短有的长？也就是找各个数据包长度本身的分布规律。</li><li>是不是几个短的数据包后面一定会跟着几个长的数据包？还是反过来？也就是找各个数据包长度之间的规律。</li><li>是不是某些长度的数据包一段时间就会出现一次？也就是找特定长度数据包的出现规律</li><li>等等等等。总之会有一些规律的。</li></ul><p>潮豆麻袋！这找规律的过程怎么有点似曾相识？对啦，这个找规律的过程就是机器学习的过程。攻击算法的第一步就是学习步骤，利用机器学习算法对数据包长度规律进行分析。</p><img src="https://pic4.zhimg.com/45b3e3897f792aa5e3057017dbd5f773_r.jpg" data-rawwidth="1280" data-rawheight="720"><ul><li>——————————————<br></li></ul><br><p>（2） 攻击步骤</p><p>经过一段时间，攻击软件差不多找到了里面的规律。现在，我们就可以用这个攻击软件去看看未知的一段数据了。如果这段数据各个数据包长度满足攻击软件所发现的规律，就认为这段未知数据中很可能正在传输微信的数据。<br></p><img src="https://pic3.zhimg.com/c206b8d9a430cc88155aaf4a3e222ded_r.jpg" data-rawwidth="1280" data-rawheight="720"><p>——————————————</p><p>（3） 攻击效果</p><p>在演讲过程中，Black Hat们在现场进行了演示。在演示过程中，Black Hat们让攻击软件学习了事先采集好的Skype的数据；随后，Black Hat们让攻击软件分别观察Skype、LinkedIn、Gmail等等的数据，看看攻击软件能不能判断哪些真正是Skype的，哪些不是。</p><p>演示结果呢？对于Skype的数据，确定里面是Skype数据的概率是99.999%！</p><p><img src="https://pic4.zhimg.com/04675991f6018133235a57d5a3eeb04c_r.jpg" data-rawwidth="1280" data-rawheight="720">对于LinkedIn的数据，攻击软件认为这里面有35%的可能性是Skype的数据。</p><p><img src="https://pic4.zhimg.com/19cf7045aa884d988a876de57d9f753b_r.jpg" data-rawwidth="1280" data-rawheight="720">为什么呢？Black Hat们给出了解释：</p><p><img src="https://pic2.zhimg.com/4649f82a8504baf3e24bb1b3f982f744_r.jpg" data-rawwidth="1280" data-rawheight="720">对于其他一些应用程序，比如Twitter什么的，攻击软件给出的概率不到0.1%。</p><img src="https://pic4.zhimg.com/68a3c9a6c67c66d0222417a5bfc99322_r.jpg" data-rawwidth="1280" data-rawheight="720"><p>==========================</p><p>4 评价与抵御方法</p><p>这个攻击真是让我大开眼界… 竟然还有这种攻击方法，而且还是信息安全与机器学习的完美结合啊有木有！那么，如何抵御这类攻击呢？可能有如下方法：</p><ul><li>修改SSH等协议，使其对于任意发送的数据，加密后的数据包长度都相同。这是抵御攻击的最好方法，也就是上密文长度都相同，这样SSH的安全性就可以完全依赖加密算法的安全性了。不过，这个攻击算法是2014年发布的，好像到现在为止SSH社区也没有进行这方面的更新。</li><li>开发软件的时候，让数据包分布不呈现规律。好吧… 这种方法有点难… 比如你这软件没规律，别人的有，那攻击算法还是可以通过“没规律”判断出里面有你应用程序的数据。这需要应用软件开发商联合起来一起搞了…</li></ul><p>这个攻击算法告诉我们这么几个道理：</p><ul><li>Black Hat们脑洞真的很大…</li><li>交叉学科大法好！仅仅是计算机科学中的两个小领域的结合，都可以产生如此漂亮的结果。</li><li>加密算法即使是可证明安全的，如果不恰当的使用，还会引发一定的安全问题。在后面的专栏中，我会讲解到另一个Black Hat视频，内容是让各位知乎er们看看，只是在密码学算法的实现过程中，就有多少个坑。而每一个坑，都可能引发严重的安全问题。</li></ul>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
