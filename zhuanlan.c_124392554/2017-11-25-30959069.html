<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>0-1背包问题的动态规划算法</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/30959069">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-fcd185d5039f8c910ab749462267b9d0_r.jpg" alt=""></div><p>题图是想致敬乱马1/2八宝斋。</p><hr><h2>首先得知道什么是0-1背包问题（knapsack problem）</h2><p>🔵 贼，夜入豪宅，可偷之物甚多，而负重能力有限，偷哪些才更加不枉此行？</p><p>🔵 抽象的话，就是：</p><p>给定一组多个（<equation>n</equation>）物品，每种物品都有自己的重量（<equation>w_i</equation>）和价值（<equation>v_i</equation>），在限定的总重量/总容量（<equation>C</equation>）内，选择其中若干个（也即每种物品可以选0个或1个），设计选择方案使得物品的总价值最高。</p><p>🔵 更加抽象的话： </p><p>给定正整数<equation>\{(w_i,v_i)\}_{1\leq i\leq n}</equation>、给定正整数<equation>C</equation>，求解0-1规划问题：</p><p><equation>\max \sum_{i=1}^{n}{x_iv_i}</equation> ， s.t. <equation>\sum_{i=1}^{n}{x_iw_i}\leq C</equation> ， <equation>x_i\in\{0,1\}</equation> 。</p><p>🔵 示例应用：处理器能力有限时间受限，任务很多，如何选择使得总效用最大？</p><p>🔵 数值例子：如下图。</p><img src="https://pic2.zhimg.com/v2-85236598e4e35b7efa3ea3f69a5ca8ec_r.jpg" data-caption="" data-size="normal" data-rawwidth="277" data-rawheight="291"><hr><h2>0-1背包问题的定性</h2><p>🔵 对于一般性的0-1背包，</p><p><b>贪婪算法无法</b>得到最优解。</p><p>反例，不多解释——</p><img src="https://pic2.zhimg.com/v2-a5b61fdcb98cf9653effba39ba9a4ccc_r.jpg" data-caption="" data-size="normal" data-rawwidth="901" data-rawheight="309"><p>事实上它可能<b>想多差有多差</b>（以 <equation>v/w</equation> 作为“贪婪”的标准，也不多解释了）——</p><img src="https://pic3.zhimg.com/v2-beea66292c2d7cb5d6112964fb2454a4_r.jpg" data-caption="" data-size="normal" data-rawwidth="631" data-rawheight="347"><p>🔵 确定性问题版本的背包问题是NP的，</p><p>“<equation>w_i=v_i</equation>，求<equation>x_i\in\{0,1\}</equation>使得<equation>\sum_{i=1}^{n}{x_iw_i}= C</equation> ”是<a href="https://people.eecs.berkeley.edu/~luca/cs172/karp.pdf">Karp的21个NPC问题</a>之一（实际上Karp的表述是现在所称的子集和（subset sum）问题）。 </p><hr><h2>0-1背包问题的递推关系</h2><p>定义子问题 <equation>\mathbf{\text{P(i, W)}}</equation> 为：在前 <equation>i</equation> 个物品中挑选总重量不超过 <equation>W</equation> 的物品，每种物品至多只能挑选1个，使得总价值最大；这时的最优值记作 <equation>m(i,W)</equation> ，其中 <equation>1\leq i\leq n</equation> ， <equation>1\leq W\leq C</equation> 。</p><p>考虑第 <equation>i</equation> 个物品，无外乎两种可能：选，或者不选。</p><ul><li>不选的话，背包的容量不变，改变为问题 <equation>\mathbf{{P(i-1, W)}}</equation> ；</li><li>选的话，背包的容量变小，改变为问题 <equation>\mathbf{{P(i-1, W-w_i)}}</equation> 。</li></ul><p>最优方案就是比较这两种方案，哪个会更好些：</p><p><equation>m(i,W)=\max\{m(i-1,W),m(i-1,W-w_i)+v_i\}</equation> 。</p><img src="https://pic1.zhimg.com/v2-1d8090c991ca13cee3cb43c027b72304_r.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="364"><p>得到</p><p><equation>\[m(i,W)=\left\{ \begin{array}{*{55}{l}} 0 &amp; \text{if } i=\text{0} \\ 0 &amp; \text{if } W=\text{0} \\ m(i-1,W) &amp; \text{if }{w_i&gt;W} \\ \max \left\{ m(i-1,W),{{v}_{i}}+m(i-1,W-{{w}_{i}}) \right\} &amp; \text{otherwise} \\ \end{array} \right.\] </equation> 。</p><hr><h2>“填二维表”的动态规划方法</h2><p>算法就很自然了：</p><img src="https://pic1.zhimg.com/v2-c320774be1bf28521ea7577bbb528fac_r.jpg" data-caption="" data-size="normal" data-rawwidth="765" data-rawheight="561"><p>之前的例子填表的结果是——</p><img src="https://pic4.zhimg.com/v2-b24e97b8043a02c12313c3143e4dca20_r.jpg" data-caption="" data-size="normal" data-rawwidth="913" data-rawheight="337"><p>（蓝色格子表示本行值发生变化的格子）</p><p>然后发生 <equation>m(i,W)=m(i-1,W-w_i)+v_i</equation> 时才会有“取第 <equation>i</equation> 件物品”发生。</p><p>所以从表格右下角“往回看”如果是“垂直下降”就是发生了 <equation>m(i,W)=m(i-1,W)</equation> ，而只有“走斜线”才是“取了”物品。</p><img src="https://pic3.zhimg.com/v2-7bd4c72ec3b5f104e4db3c4aad98cc66_r.jpg" data-caption="" data-size="normal" data-rawwidth="823" data-rawheight="413"><p>这个算法的复杂度就很容易算了——每一个格子都要填写数字，所以时间复杂度和空间复杂度都是 <equation>\Omega(nC)</equation> 。当" <equation>C&gt;2^n</equation> "时（就不严谨地使用渐近分析的语言了），复杂度是 <equation>\Omega(n2^n)</equation> 。</p><hr><h2>所谓“填一维表”的动态规划方法</h2><p>🔴 其实呢，上面那个二维表，也可以用一行来存储啊！对不啦？</p><p>🔴 所以，根本的区别在于思想，而不是具体存储方式。</p><p>那么这个算法的<b>思想</b>又是什么呢？——其实就是：</p><ul><li>每行都<b>有些数值相同</b>的哦，所以</li><li><b>只记录</b>每行里那些<b>不同的</b>数值就好了啊。</li></ul><p>🔴 例如上面的表格中，只记录蓝色的部分，</p><p>格式是<equation>(i,W,m(i,W))</equation>（为了方便阅读，再贴一次图）：</p><img src="https://pic3.zhimg.com/v2-e8ea14ece97ba2f5716a912cf1d79335_r.jpg" data-caption="" data-size="normal" data-rawwidth="1099" data-rawheight="291"><p><equation>(0,0,0)</equation> 、</p><p><equation>(1,0,0)</equation> 、 <equation>(1,1,1)</equation> 、</p><p><equation>(2,0,0)</equation> 、 <equation>(2,1,1)</equation> 、 <equation>(2,2,6)</equation> 、 <equation>(2,3,7)</equation> 、</p><p><equation>(3,0,0)</equation> 、 <equation>(3,1,1)</equation> 、 <equation>(3,2,6)</equation> 、 <equation>(3,3,7)</equation> 、 <equation>(3,5,18)</equation> 、 <equation>(3,6,19)</equation> 、 <equation>(3,7,24)</equation> 、 <equation>(3,8,25)</equation> 、</p><p>……（不写了，累）</p><p>🔴 你会说，这也没省什么地方啊？！</p><p>的确，对于这个例子来说是这样的——要不然数值太大我画不下。</p><p>你假设每个 <equation>w_i</equation> 都扩大<b>1000倍</b>，那样的话，表格也扩大到<b>1000倍</b>，填表时间也增加到<b>1000倍</b>，然而蓝色的格子<b>还是那么多</b>。</p><p>🔴 好了，继续，下面有三个问题：</p><ol><li><equation>m(i,W)\geq m(i-1,W)</equation> ， <equation>m(i,W)\geq m(i,W-1)</equation> ；（这比较显然）</li><li>什么时候会发生“ <equation>m(i,W)&gt; m(i,W-1)</equation> ”的情况？</li><li>什么时候会发生“ <equation>m(i,W)&gt; m(i-1,W)</equation> ”的情况？</li></ol><p>�<b>� 下面来看</b>问题2，一定是发生了“容量扩大后有个新的东西可以放下了”！</p><p>所以固定 <equation>i</equation> ，让 <equation>W</equation> 变化， <equation>m(i,W)</equation> 一定是“阶梯状”的：</p><ul><li>有的 <equation>w</equation> 使得 <equation>m(i,w)&gt; m(i,w-1)</equation> ；</li><li>有的 <equation>w</equation> 使得 <equation>m(i,w)= m(i,w-1)</equation> 。</li></ul><p>例如，前面例子中 <equation>m(1,w)</equation> 如下图所示：</p><img src="https://pic2.zhimg.com/v2-8bfecb19860bc5c347b21af3cd38d4d1_r.jpg" data-caption="" data-size="normal" data-rawwidth="435" data-rawheight="93"><p>看下<equation>m(2,W)=\max\{m(1,W),m(1,W-w_2)+v_2\}</equation>，<equation>m(1,W-w_2)+v_2</equation>是<equation>m(1,W)</equation>右移<equation>w_2</equation>上移<equation>v_2</equation> 。</p><p>所以 <equation>m(2,W)</equation> （ <equation>w_2=2，v_2=6</equation> ）就是下述两条“阶梯”</p><img src="https://pic3.zhimg.com/v2-ce95442ed4d99f81c8cd70515033fc0c_r.jpg" data-caption="" data-size="normal" data-rawwidth="306" data-rawheight="212"><p>在max意义下的“叠加”。</p><img src="https://pic4.zhimg.com/v2-11775738bca337142ab1f2c1a14c2d35_r.jpg" data-caption="" data-size="normal" data-rawwidth="320" data-rawheight="190"><p>比较<equation>m(1,W)</equation>和<equation>m(2,W)</equation> 的“转折点”：</p><img src="https://pic1.zhimg.com/v2-adf07804dc9c6839c543ccfa4b36432a_r.jpg" data-caption="" data-size="normal" data-rawwidth="431" data-rawheight="88"><img src="https://pic1.zhimg.com/v2-20323a4e2a8c31899011e396caf3f109_r.jpg" data-caption="" data-size="normal" data-rawwidth="320" data-rawheight="192"><p><equation>m(1,W)</equation> 的是 <equation>S^1=\{(1,0,0),(1,1,1)\}</equation> ； <equation>m(2,W)</equation> 的是 <equation>S^2=\{(2,0,0),(2,1,1),(2,2,6),(2,3,7)\}</equation> 。</p><p>于是： </p><ul><li>对于每一个 <equation>i</equation> ， <equation>m(i ,W)</equation> 最多只有 <equation>2^i</equation> 个“转折点”——因为 <equation>i</equation> 个物品，最多只有 <equation>2^i</equation> 个“选”、“不选”的组合；</li><li><equation>m(2,W)</equation> 中 <equation>m(1,W-w_2)+v_2</equation> 那部分的所有<b>可能的</b>“转折点”就是由 <equation>m(1,W)</equation> 的每个转折点 <equation>(1,w,v)</equation> 变为 <equation>(2,w+w_2,v+v_2)</equation>；（“可能”这个词后面再解释）</li><li>推而广之， <equation>m(i+1,W)</equation> 中 <equation>m(i,W-w_{i+1})+v_{i+1}</equation> 那部分的所有<b>可能的</b>“转折点”就是由 <equation>m(i,W)</equation> 的每个转折点 <equation>(i,w,v)</equation> 变为 <equation>(i+1,w+w_{i+1},v+v_{i+1})</equation> 。</li></ul><p>设置<equation>S^0=\{(0,0,0)\}</equation>，则由<equation>S^i</equation>得到<equation>S^{i+1}</equation>的所有可能的“转折点”为<equation>\{(i+1,w+w_{i+1},v+v_{i+1})\}:(i,w,v)\in S^i</equation> 。</p><p>例如<equation>m(3,W)</equation> ：</p><img src="https://pic4.zhimg.com/v2-39c0b9b05e7b3c85a9738a957828164e_r.jpg" data-caption="" data-size="normal" data-rawwidth="867" data-rawheight="590"><p>例如<equation>m(4,W)</equation> ， <equation>w_4=6,v_4=22</equation> ：</p><img src="https://pic2.zhimg.com/v2-70459bdaff8bd5390a28763be9ddf406_r.jpg" data-caption="" data-size="normal" data-rawwidth="1088" data-rawheight="1039"><p>这时有些问题：</p><ol><li>超过 <equation>C=11</equation> 的部分可以不用考虑；</li><li>绿色的圆形里有些“转折点”被湮没了——这就是之前说的“可能”的意思。</li></ol><p>来看哦， <equation>S^3=\{(3,0,0),(3,1,1),(3,2,6),(3,3,7),(3,5,18),(3,6,19),(3,7,24),(3,8,25)\}</equation> 。</p><p>于是 <equation>S^4</equation> 的所有<b>可能</b>应该是</p><p><equation>\{(4,0,0),(4,1,1),(4,2,6),(4,3,7),(4,5,18),(4,6,19),(4,7,24),(4,8,25)\}</equation> </p><p><equation>\cup</equation> </p><p><equation>\{(4,0+6,0+22),(4,1+6,1+22),(4,2+6,6+22),(4,3+6,7+22), </equation> </p><p><equation>(4,5+6,18+22),(4,6+6,19+22),(4,7+6,24+22),(4,8+6,25+22)\}</equation> </p><img src="https://pic4.zhimg.com/v2-1ab836b2b0d8d38dd25e133944d87b8d_r.jpg" data-caption="" data-size="normal" data-rawwidth="755" data-rawheight="215"><p>Ok，首先删除掉第二分量大于 <equation>C=11</equation> 的（上图红框里）（称作<b>第一类抛弃</b>），得到</p><p><equation>\{(4,0,0),(4,1,1),(4,2,6),(4,3,7),(4,5,18),(4,6,19),(4,7,24),(4,8,25)\}\cup</equation> </p><p><equation>\{(4,6,22),(4,7,23),(4,8,28),(4,9,29),(4,11,40)\}</equation> 。</p><p>然后按第二分量递增排序，得到：</p><img src="https://pic3.zhimg.com/v2-708028aee2b2516f8c7a6e06790dcf0b_r.jpg" data-caption="" data-size="normal" data-rawwidth="638" data-rawheight="112"><p>按道理说，对于阶梯函数来说，如果第二分量是递增的，那么第三分量<b>也应该是递增</b>的。但是上图中红框里不是哦——事实上它们是“被湮没”的“转折点”（上图的黄色圆形）。</p><p>所以哦，弃掉他们（称作<b>第二类抛弃</b>），得到 <equation>\{(4,0,0),(4,1,1),(4,2,6),(4,3,7),(4,5,18),(4,6,22),(4,7,24),(4,8,28),(4,9,29),(4,11,40)\}</equation>，就是下图 。</p><img src="https://pic1.zhimg.com/v2-eb0fee49b5dfd9a6f1863ccd3ddf32ba_r.jpg" data-caption="" data-size="normal" data-rawwidth="301" data-rawheight="943"><p>而最终结果就是<b><equation>S^n</equation> 的最后一项的第三个分量</b>。</p><p>由<equation>S^i</equation>得到<equation>S^{i+1}</equation> 的过程是（例如）：</p><p><equation>S^3=\{(3,0,0),(3,1,1),(3,2,6),(3,3,7),(3,5,18),(3,6,19),(3,7,24),(3,8,25)\}</equation> </p><p>已经按照第二分量递增排序好，</p><p>之后先写成</p><p><equation>\{(4,0,0),(4,1,1),(4,2,6),(4,3,7),(4,5,18),(4,6,19),(4,7,24),(4,8,25)\}</equation> </p><p>然后对第一个三元组，</p><img src="https://pic4.zhimg.com/v2-dfcedc7a67dff312ca1ca9c032428f95_r.jpg" data-caption="" data-size="normal" data-rawwidth="772" data-rawheight="192"><p>删除当前位置之后被“湮没”的</p><img src="https://pic2.zhimg.com/v2-27abfadc39012a8bf9e9562761dca087_r.jpg" data-caption="" data-size="normal" data-rawwidth="815" data-rawheight="57"><p>对第二个三元组，一定是插入<b>当前位置之后</b>，并被立即“湮没”，</p><img src="https://pic1.zhimg.com/v2-b0e85c0ebd3689a0c740a4a0b9af7bf2_r.jpg" data-caption="" data-size="normal" data-rawwidth="745" data-rawheight="184"><p>不断这样进行下去，并注意第一类抛弃即可得到 <equation>S^4</equation> 。</p><p>令<equation>S^0=\{(0,0,0)\}</equation>，则可以得到（由于分行了，就不在乎三元组的第一分量了）：</p><img src="https://pic1.zhimg.com/v2-29d1a004c395ebe53e4161dad64a785c_r.jpg" data-caption="" data-size="normal" data-rawwidth="749" data-rawheight="233"><p>然后所谓“一维”存储，其实就是把它“存储成了”一维，例如使用两个一维数组和一个start数组做“分割”：</p><img src="https://pic1.zhimg.com/v2-3018ce4c8746a1d6f365beb6918e1525_r.jpg" data-caption="" data-size="normal" data-rawwidth="1043" data-rawheight="257"><p>🔴  然后就是如何得到方案——</p><p>看 <equation>S^5</equation> 的最后一个是不是与 <equation>S^4</equation> 的最后一个相同，相同的话就直接看 <equation>S^4</equation> ；</p><p><equation>S^4</equation> 的最后一个与 <equation>S^3</equation> 的最后一个不同，所以一定拿了物品4，然后看 <equation>S^3</equation> 第二分量不超过5（= <equation>C-w_4</equation> ）的最后一个，是 <equation>(5,18)</equation> ；</p><p><equation>(5,18)</equation> 与 <equation>S^2</equation> 的最后一个不同，所以一定拿了物品3；</p><p>……然后类推。</p><p>🔴  最后是分析复杂度：</p><p>路线是计算 <equation>S^i</equation> 的元素个数，然后对 <equation>i</equation> 求和，就得到了所有“蓝色格子”的数量。</p><p>然后，</p><ul><li>首先，由于 <equation>S^{i+1}</equation> 在不考虑两类抛弃的情况下（最差情况就是不发生这两类抛弃），元素个数恰好等于 <equation>S^i</equation> 元素数的两倍；也可以这样来看——对于每一个 <equation>i</equation> ， <equation>m(i,W)</equation> 最多只有 <equation>2^i</equation> 个“转折点”；</li><li>由 <equation>S^i</equation> 得到 <equation>S^{i+1}</equation> 时， <equation>S^i</equation> 中各组的第二分量、第三分量一定彼此不同，那么每个 <equation>(i,w,m(i,w))</equation> 中的 <equation>w</equation> 的取值范围是 <equation>0\leq w\leq C</equation> ，第三分量的取值范围是 <equation>0\sim\sum_{k=1}^{i}{v_i}</equation> 。所以这样的三元组最多有 <equation>\min\{C+1,\sum_{k=1}^{i}{v_k}+1\}</equation> 个。</li></ul><p>对 <equation>i=1\sim n</equation> 求和，得到</p><ul><li><equation>“蓝色格子”数目\leq (1+2^1+2^2+...+2^n)=O(2^n)</equation> ;</li><li><equation>“蓝色格子”数目\leq n(C+1)=O(nC)</equation> ；</li><li><equation>“蓝色格子”数目\leq \sum_{i=1}^{n}{\sum_{k=1}^{i}({v_i}+1)}\leq \sum_{i=1}^{n}{\sum_{k=1}^{n}({v_k}+1)}=n+n\sum_{k=1}^{n}{v_k}=O(n\sum_{k=1}^{n}{v_k})</equation> </li></ul><p>而由 <equation>S^i</equation> 产生 <equation>S^{i+1}</equation> 的计算过程主要就是产生一个新的对、插入、删除（抛弃），所以这个过程的计算量是和 <equation>S^i</equation> 元素数成正比的。</p><p>所以得到，无论空间复杂度还是时间复杂度，都是 <equation>O(\min\{2^n,nC,n\sum_{k=1}^{n}{v_k}\})</equation> 的。</p><p>即使 <equation>C&gt;2^n</equation> ，这时的算法复杂度也控制在 <equation>O(2^n)</equation> 之内。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
