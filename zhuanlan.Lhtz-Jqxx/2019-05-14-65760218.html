<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>作为Python中级程序员，有句话不知当讲不当讲 (￣へ￣)</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/65760218">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-e5136a5edc560c49344c142d41fd5c3a_b.jpg" alt=""></div><p>作者：Pulkit Agrawa</p><p>编译：公众号编辑部</p><p><b>祝妈妈们节日快乐！</b></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-74e14056e0234516b8035cb98eb6f4d2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="1848" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic3.zhimg.com/v2-74e14056e0234516b8035cb98eb6f4d2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-74e14056e0234516b8035cb98eb6f4d2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="1848" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic3.zhimg.com/v2-74e14056e0234516b8035cb98eb6f4d2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-74e14056e0234516b8035cb98eb6f4d2_b.jpg"/></figure><blockquote><i><b>这句话里有10个问题</b></i></blockquote><h2><b>Python中都是对象吗?</b></h2><p>字符串是对象。列表对象。函数对象。甚至模块也是对象。任何东西都是一个对象，因为它可以赋值给一个变量或作为参数传递给一个函数。</p><p>任何可以（合法地）放在等号右边的东西都是（或创建）Python中的对象。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-8e5530b63d5fda3d621d817644fe1ad6_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="402" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic3.zhimg.com/v2-8e5530b63d5fda3d621d817644fe1ad6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-8e5530b63d5fda3d621d817644fe1ad6_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="402" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic3.zhimg.com/v2-8e5530b63d5fda3d621d817644fe1ad6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-8e5530b63d5fda3d621d817644fe1ad6_b.jpg"/></figure><p><b>对象：</b></p><p>1、ID</p><p>2、值（可变的或不可变的）</p><p><b>可变的：</b>当更改项目时，ID仍然是相同的。比如：字典、列表。</p><p><b>不可变的：</b>字符串、整数、元组。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-f5ef008aa3c55166ae4b80fecfa1e34c_b.jpg" data-caption="" data-size="normal" data-rawwidth="908" data-rawheight="631" class="origin_image zh-lightbox-thumb" width="908" data-original="https://pic1.zhimg.com/v2-f5ef008aa3c55166ae4b80fecfa1e34c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-f5ef008aa3c55166ae4b80fecfa1e34c_b.jpg" data-caption="" data-size="normal" data-rawwidth="908" data-rawheight="631" class="origin_image zh-lightbox-thumb lazy" width="908" data-original="https://pic1.zhimg.com/v2-f5ef008aa3c55166ae4b80fecfa1e34c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-f5ef008aa3c55166ae4b80fecfa1e34c_b.jpg"/></figure><h2><b>推导式</b></h2><p>Comprehension——用于创建集合和可迭代对象的简写语法。</p><p><b>▍列表推导式</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-0d626102178cd3237a4585587c012bf0_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="90" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-0d626102178cd3237a4585587c012bf0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-0d626102178cd3237a4585587c012bf0_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="90" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-0d626102178cd3237a4585587c012bf0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-0d626102178cd3237a4585587c012bf0_b.png"/></figure><p><b>▍集合推导式</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-c26ab5c2fff01c33395fdc929ea3286c_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="97" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-c26ab5c2fff01c33395fdc929ea3286c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-c26ab5c2fff01c33395fdc929ea3286c_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="97" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-c26ab5c2fff01c33395fdc929ea3286c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-c26ab5c2fff01c33395fdc929ea3286c_b.png"/></figure><p><b>▍字典推导式</b></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-c3fef1fd28b07d419c178a425b478251_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="93" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-c3fef1fd28b07d419c178a425b478251_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-c3fef1fd28b07d419c178a425b478251_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="93" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-c3fef1fd28b07d419c178a425b478251_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-c3fef1fd28b07d419c178a425b478251_b.png"/></figure><p><b>▍Generator 推导式</b></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-8e48c5de0c17d29ed2927d235990298f_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="91" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-8e48c5de0c17d29ed2927d235990298f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-8e48c5de0c17d29ed2927d235990298f_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="91" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-8e48c5de0c17d29ed2927d235990298f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-8e48c5de0c17d29ed2927d235990298f_b.png"/></figure><p><b>▍ If-clause 推导式</b></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-4b0f35b0602679326ee2c4430dcabdab_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="95" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-4b0f35b0602679326ee2c4430dcabdab_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-4b0f35b0602679326ee2c4430dcabdab_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="95" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-4b0f35b0602679326ee2c4430dcabdab_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-4b0f35b0602679326ee2c4430dcabdab_b.png"/></figure><p><b>▍多重推导式</b></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-d9e663a397ba40c00a830c516abec123_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="211" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-d9e663a397ba40c00a830c516abec123_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-d9e663a397ba40c00a830c516abec123_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="211" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-d9e663a397ba40c00a830c516abec123_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-d9e663a397ba40c00a830c516abec123_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-c538d25cebbc8f44db6142c2414cd1ac_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="88" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-c538d25cebbc8f44db6142c2414cd1ac_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-c538d25cebbc8f44db6142c2414cd1ac_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="88" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-c538d25cebbc8f44db6142c2414cd1ac_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-c538d25cebbc8f44db6142c2414cd1ac_b.png"/></figure><p><b>▍嵌套推导式</b></p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-bfa346700c9c4afaf98cacef30e638c2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="282" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic3.zhimg.com/v2-bfa346700c9c4afaf98cacef30e638c2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-bfa346700c9c4afaf98cacef30e638c2_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="282" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic3.zhimg.com/v2-bfa346700c9c4afaf98cacef30e638c2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-bfa346700c9c4afaf98cacef30e638c2_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-e4a3fecd79db97814b029c60b34940df_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="93" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-e4a3fecd79db97814b029c60b34940df_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-e4a3fecd79db97814b029c60b34940df_b.png" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="93" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-e4a3fecd79db97814b029c60b34940df_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-e4a3fecd79db97814b029c60b34940df_b.png"/></figure><h2><b>扩展关键字参数</b></h2><p>在Python中调用函数时，通常必须在使用关键字参数和位置参数之间进行选择。 关键字参数通常可用于使函数调用更加明确。当我们使用关键字参数时：我们通常可以省略具有默认值的参数。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-964e5666cd5c7e6b03636437ed49dda4_b.jpg" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="175" class="origin_image zh-lightbox-thumb" width="697" data-original="https://pic1.zhimg.com/v2-964e5666cd5c7e6b03636437ed49dda4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-964e5666cd5c7e6b03636437ed49dda4_b.jpg" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="175" class="origin_image zh-lightbox-thumb lazy" width="697" data-original="https://pic1.zhimg.com/v2-964e5666cd5c7e6b03636437ed49dda4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-964e5666cd5c7e6b03636437ed49dda4_b.jpg"/></figure><p><b>扩展形式参数语法：</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-d677c2416a96b525e8c48a7c7c927768_b.jpg" data-caption="" data-size="normal" data-rawwidth="587" data-rawheight="168" class="origin_image zh-lightbox-thumb" width="587" data-original="https://pic1.zhimg.com/v2-d677c2416a96b525e8c48a7c7c927768_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-d677c2416a96b525e8c48a7c7c927768_b.jpg" data-caption="" data-size="normal" data-rawwidth="587" data-rawheight="168" class="origin_image zh-lightbox-thumb lazy" width="587" data-original="https://pic1.zhimg.com/v2-d677c2416a96b525e8c48a7c7c927768_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-d677c2416a96b525e8c48a7c7c927768_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-a372686fe00174b998578eee120e3db1_b.jpg" data-caption="" data-size="normal" data-rawwidth="698" data-rawheight="218" class="origin_image zh-lightbox-thumb" width="698" data-original="https://pic2.zhimg.com/v2-a372686fe00174b998578eee120e3db1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-a372686fe00174b998578eee120e3db1_b.jpg" data-caption="" data-size="normal" data-rawwidth="698" data-rawheight="218" class="origin_image zh-lightbox-thumb lazy" width="698" data-original="https://pic2.zhimg.com/v2-a372686fe00174b998578eee120e3db1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-a372686fe00174b998578eee120e3db1_b.jpg"/></figure><p><b>扩展参数的数据类型：</b></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-aad24f081a00fcfbda4c1d25f1e064c1_b.jpg" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="261" class="origin_image zh-lightbox-thumb" width="697" data-original="https://pic2.zhimg.com/v2-aad24f081a00fcfbda4c1d25f1e064c1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-aad24f081a00fcfbda4c1d25f1e064c1_b.jpg" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="261" class="origin_image zh-lightbox-thumb lazy" width="697" data-original="https://pic2.zhimg.com/v2-aad24f081a00fcfbda4c1d25f1e064c1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-aad24f081a00fcfbda4c1d25f1e064c1_b.jpg"/></figure><p><b>扩展实参语法：</b></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-7d35dda9a9352dbbeddad937537b7473_b.jpg" data-caption="" data-size="normal" data-rawwidth="621" data-rawheight="171" class="origin_image zh-lightbox-thumb" width="621" data-original="https://pic4.zhimg.com/v2-7d35dda9a9352dbbeddad937537b7473_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-7d35dda9a9352dbbeddad937537b7473_b.jpg" data-caption="" data-size="normal" data-rawwidth="621" data-rawheight="171" class="origin_image zh-lightbox-thumb lazy" width="621" data-original="https://pic4.zhimg.com/v2-7d35dda9a9352dbbeddad937537b7473_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-7d35dda9a9352dbbeddad937537b7473_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-0a3bb3d1843ae023c198040ea8130329_b.jpg" data-caption="" data-size="normal" data-rawwidth="698" data-rawheight="126" class="origin_image zh-lightbox-thumb" width="698" data-original="https://pic2.zhimg.com/v2-0a3bb3d1843ae023c198040ea8130329_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-0a3bb3d1843ae023c198040ea8130329_b.jpg" data-caption="" data-size="normal" data-rawwidth="698" data-rawheight="126" class="origin_image zh-lightbox-thumb lazy" width="698" data-original="https://pic2.zhimg.com/v2-0a3bb3d1843ae023c198040ea8130329_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-0a3bb3d1843ae023c198040ea8130329_b.jpg"/></figure><h2><b>闭包和装饰器</b></h2><p>在开始闭包之前，我们先了解一下local 函数：</p><ul><li>适用于特殊的、一次性的功能</li><li>使得代码具有组织性和可读性</li><li>类似于lambdas，但更为一般</li><li>可能包含多个表达式</li><li>可能包含statements</li></ul><p><b>▍LEGB含义解释</b></p><ul><li>L-Local(function)：函数内的名字空间</li><li>E-Enclosing function locals：外部嵌套函数的名字空间(例如closure)</li><li>G-Global(module)：函数定义所在模块（文件）的名字空间</li><li>B-Builtin(Python)：Python内置模块的名字空间</li></ul><p>Python的命名空间是一个字典，字典内保存了变量名称与对象之间的映射关系，因此，查找变量名就是在命名空间字典中查找键-值对。</p><p>Python有多个命名空间，因此，需要有规则来规定，按照怎样的顺序来查找命名空间，LEGB就是用来规定命名空间查找顺序的规则。</p><blockquote>LEGB规定了查找一个名称的顺序为<b>：local--&gt;enclosing function locals--&gt;global--&gt;builtin</b>（局部变量———闭包空间———全局变量———内建模块内置）</blockquote><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-b5def3a6b77e3bc351c7f051c44a18ca_b.jpg" data-caption="" data-size="normal" data-rawwidth="696" data-rawheight="219" class="origin_image zh-lightbox-thumb" width="696" data-original="https://pic3.zhimg.com/v2-b5def3a6b77e3bc351c7f051c44a18ca_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-b5def3a6b77e3bc351c7f051c44a18ca_b.jpg" data-caption="" data-size="normal" data-rawwidth="696" data-rawheight="219" class="origin_image zh-lightbox-thumb lazy" width="696" data-original="https://pic3.zhimg.com/v2-b5def3a6b77e3bc351c7f051c44a18ca_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-b5def3a6b77e3bc351c7f051c44a18ca_b.jpg"/></figure><p><b>▍Returning Function </b></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-6bf956de397a09be552c3647e2df49b9_b.jpg" data-caption="" data-size="normal" data-rawwidth="699" data-rawheight="218" class="origin_image zh-lightbox-thumb" width="699" data-original="https://pic2.zhimg.com/v2-6bf956de397a09be552c3647e2df49b9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-6bf956de397a09be552c3647e2df49b9_b.jpg" data-caption="" data-size="normal" data-rawwidth="699" data-rawheight="218" class="origin_image zh-lightbox-thumb lazy" width="699" data-original="https://pic2.zhimg.com/v2-6bf956de397a09be552c3647e2df49b9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-6bf956de397a09be552c3647e2df49b9_b.jpg"/></figure><p><b>▍闭包</b></p><p>维持对早期范围对象的引用。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-2512ee1b6a8b477633d0abe7659aa0c2_b.jpg" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="192" class="origin_image zh-lightbox-thumb" width="697" data-original="https://pic3.zhimg.com/v2-2512ee1b6a8b477633d0abe7659aa0c2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-2512ee1b6a8b477633d0abe7659aa0c2_b.jpg" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="192" class="origin_image zh-lightbox-thumb lazy" width="697" data-original="https://pic3.zhimg.com/v2-2512ee1b6a8b477633d0abe7659aa0c2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-2512ee1b6a8b477633d0abe7659aa0c2_b.jpg"/></figure><p>我们可以使用_closure__来验证函数是否为闭包。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-e2bf5df043450d9c0f51612ea327e295_b.png" data-caption="" data-size="normal" data-rawwidth="695" data-rawheight="83" class="origin_image zh-lightbox-thumb" width="695" data-original="https://pic2.zhimg.com/v2-e2bf5df043450d9c0f51612ea327e295_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-e2bf5df043450d9c0f51612ea327e295_b.png" data-caption="" data-size="normal" data-rawwidth="695" data-rawheight="83" class="origin_image zh-lightbox-thumb lazy" width="695" data-original="https://pic2.zhimg.com/v2-e2bf5df043450d9c0f51612ea327e295_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-e2bf5df043450d9c0f51612ea327e295_b.png"/></figure><p><b>一个函数和它的环境变量合在一起，就构成了一个闭包（closure）</b>。在Python中，所谓的闭包是一个包含有环境变量取值的函数对象。环境变量取值被保存在函数对象的 __closure__ 属性中。比如下面的代码：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-71e96898ec4d00ec85bb368ae22b0007_b.jpg" data-caption="" data-size="normal" data-rawwidth="549" data-rawheight="189" class="origin_image zh-lightbox-thumb" width="549" data-original="https://pic4.zhimg.com/v2-71e96898ec4d00ec85bb368ae22b0007_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-71e96898ec4d00ec85bb368ae22b0007_b.jpg" data-caption="" data-size="normal" data-rawwidth="549" data-rawheight="189" class="origin_image zh-lightbox-thumb lazy" width="549" data-original="https://pic4.zhimg.com/v2-71e96898ec4d00ec85bb368ae22b0007_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-71e96898ec4d00ec85bb368ae22b0007_b.jpg"/></figure><p>__closure__ 里包含了一个元组。这个元组中的每个元素是cell类型的对象。我们看到第一个cell包含的就是整数15，也就是我们创建闭包时的环境变量b的取值。</p><p>下面看一个闭包的实际例子：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-fb56bf55018fbfff6e75991d367b91d0_b.jpg" data-caption="" data-size="normal" data-rawwidth="660" data-rawheight="148" class="origin_image zh-lightbox-thumb" width="660" data-original="https://pic1.zhimg.com/v2-fb56bf55018fbfff6e75991d367b91d0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-fb56bf55018fbfff6e75991d367b91d0_b.jpg" data-caption="" data-size="normal" data-rawwidth="660" data-rawheight="148" class="origin_image zh-lightbox-thumb lazy" width="660" data-original="https://pic1.zhimg.com/v2-fb56bf55018fbfff6e75991d367b91d0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-fb56bf55018fbfff6e75991d367b91d0_b.jpg"/></figure><p>这个例子中，函数line与环境变量a,b构成闭包。在创建闭包的时候，我们通过line_conf的参数a,b说明了这两个环境变量的取值，这样，我们就确定了函数的最终形式(y = x + 1和y = 4x + 5)。我们只需要变换参数a,b，就可以获得不同的直线表达函数。由此，我们可以看到，闭包也具有提高代码可复用性的作用。</p><p>如果没有闭包，我们需要每次创建直线函数的时候同时说明a,b,x。这样，我们就需要更多的参数传递，也减少了代码的可移植性。利用闭包，我们实际上创建了泛函。line函数定义一种广泛意义的函数。这个函数的一些方面已经确定(必须是直线)，但另一些方面(比如a和b参数待定)。随后，我们根据line_conf传递来的参数，通过闭包的形式，将最终函数确定下来。</p><p><b>一个函数闭包</b>是一个函数和一个引用集合的组合，这个引用集合指向这个函数被定义的作用域的变量。后者通常指向一个引用环境（referencing environment），这使得函数能够在它被定义的区域之外执行。在Python中，这个引用环境被存储在一个cell的tuple中。你能够通过func_closure或Python 3中的__closure__属性访问它。要铭记的一点是引用及是引用，而不是对象的深度拷贝。当然了，对于不可变对象而言，这并不是问题，然而对可变对象(list)这点就必须注意。请注意函数在定义的地方也有__globals__字段来存储全局引用环境。<br/></p><p><b>▍装饰器</b></p><p>装饰器是这样一种设计模式：如果一个类希望添加其他类的一些功能，而不希望通过继承或是直接修改源代码实现，那么可以使用装饰器模式。简单来说Python中的装饰器就是指某些函数或其他可调用对象，以函数或类作为可选输入参数，然后返回函数或类的形式。</p><p>简单地说，decorator就像一个wrapper一样，在函数执行之前或者之后修改该函数的行为，而无需修改函数本身的代码，这也是修饰器名称的来由。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-2af75238f557dc06748e45dc08a63f9d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1009" data-rawheight="641" class="origin_image zh-lightbox-thumb" width="1009" data-original="https://pic2.zhimg.com/v2-2af75238f557dc06748e45dc08a63f9d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-2af75238f557dc06748e45dc08a63f9d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1009" data-rawheight="641" class="origin_image zh-lightbox-thumb lazy" width="1009" data-original="https://pic2.zhimg.com/v2-2af75238f557dc06748e45dc08a63f9d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-2af75238f557dc06748e45dc08a63f9d_b.jpg"/></figure><h2><b>生成器和迭代协议</b></h2><p><b>▍Iterable</b>：可以将对象传递给内置的iter()函数来获得迭代器。</p><p><b>▍Iterator</b>：可以将对象传递给内置的next()函数来获取下一项。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-8f2f21d64485789006e070e0ecd371c0_b.png" data-caption="" data-size="normal" data-rawwidth="694" data-rawheight="106" class="origin_image zh-lightbox-thumb" width="694" data-original="https://pic1.zhimg.com/v2-8f2f21d64485789006e070e0ecd371c0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-8f2f21d64485789006e070e0ecd371c0_b.png" data-caption="" data-size="normal" data-rawwidth="694" data-rawheight="106" class="origin_image zh-lightbox-thumb lazy" width="694" data-original="https://pic1.zhimg.com/v2-8f2f21d64485789006e070e0ecd371c0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-8f2f21d64485789006e070e0ecd371c0_b.png"/></figure><p><br/><b>▍生成器</b></p><p>Python生成器是创建迭代器的一种简单方法。上面提到的都由Python中的生成器自动处理的。</p><p>生成器是一个函数，它返回一个对象（迭代器），我们可以遍历该对象（每次一个值）。</p><p>如果一个函数包含至少一个<b>yield</b>语句，则它将成为生成器函数。</p><p>不同之处在于，虽然return语句完全终止了一个函数，但是yield语句暂停保存函数的所有状态，然后在后续调用时继续执行。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-92ae9ac840386d2e40862524b2c267f2_b.jpg" data-caption="" data-size="normal" data-rawwidth="601" data-rawheight="386" class="origin_image zh-lightbox-thumb" width="601" data-original="https://pic3.zhimg.com/v2-92ae9ac840386d2e40862524b2c267f2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-92ae9ac840386d2e40862524b2c267f2_b.jpg" data-caption="" data-size="normal" data-rawwidth="601" data-rawheight="386" class="origin_image zh-lightbox-thumb lazy" width="601" data-original="https://pic3.zhimg.com/v2-92ae9ac840386d2e40862524b2c267f2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-92ae9ac840386d2e40862524b2c267f2_b.jpg"/></figure><p>为什么在Python中使用生成器？</p><ul><li>Easy to Implement</li><li>Memory Efficient</li><li>Represent Infinite Stream</li><li>Pipelining Generators</li></ul><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-2a15740c135847a066ad7a2a9f961cbf_b.jpg" data-caption="" data-size="normal" data-rawwidth="696" data-rawheight="146" class="origin_image zh-lightbox-thumb" width="696" data-original="https://pic4.zhimg.com/v2-2a15740c135847a066ad7a2a9f961cbf_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-2a15740c135847a066ad7a2a9f961cbf_b.jpg" data-caption="" data-size="normal" data-rawwidth="696" data-rawheight="146" class="origin_image zh-lightbox-thumb lazy" width="696" data-original="https://pic4.zhimg.com/v2-2a15740c135847a066ad7a2a9f961cbf_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-2a15740c135847a066ad7a2a9f961cbf_b.jpg"/></figure><h2><b>上下文管理器</b></h2><p><b>▍ContextManager</b>：上下文管理器就是实现了上下文管理协议的对象。主要用于保存和恢复各种全局状态，关闭文件等，上下文管理器本身就是一种装饰器。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-11f18c75cc18b03a093b451cdbd65e6f_b.jpg" data-caption="" data-size="normal" data-rawwidth="698" data-rawheight="129" class="origin_image zh-lightbox-thumb" width="698" data-original="https://pic4.zhimg.com/v2-11f18c75cc18b03a093b451cdbd65e6f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-11f18c75cc18b03a093b451cdbd65e6f_b.jpg" data-caption="" data-size="normal" data-rawwidth="698" data-rawheight="129" class="origin_image zh-lightbox-thumb lazy" width="698" data-original="https://pic4.zhimg.com/v2-11f18c75cc18b03a093b451cdbd65e6f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-11f18c75cc18b03a093b451cdbd65e6f_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-3de720ef48db251feb66ea5e1c76c303_b.jpg" data-caption="" data-size="normal" data-rawwidth="938" data-rawheight="623" class="origin_image zh-lightbox-thumb" width="938" data-original="https://pic4.zhimg.com/v2-3de720ef48db251feb66ea5e1c76c303_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-3de720ef48db251feb66ea5e1c76c303_b.jpg" data-caption="" data-size="normal" data-rawwidth="938" data-rawheight="623" class="origin_image zh-lightbox-thumb lazy" width="938" data-original="https://pic4.zhimg.com/v2-3de720ef48db251feb66ea5e1c76c303_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-3de720ef48db251feb66ea5e1c76c303_b.jpg"/></figure><p><b>▍__enter__ ()</b></p><ul><li>在进入with-statement主体之前调用</li><li>返回绑定到变量的值</li><li>可以返回任何类型的值</li><li>通常返回上下文管理器本身</li></ul><p><b>▍__exit__()</b></p><p>当语句体退出时调用</p><p>__exit__(self, exc_type, exc_val, exc_tb)</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-d8beb39a964ae410527a37688e562569_b.jpg" data-caption="" data-size="normal" data-rawwidth="582" data-rawheight="230" class="origin_image zh-lightbox-thumb" width="582" data-original="https://pic2.zhimg.com/v2-d8beb39a964ae410527a37688e562569_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-d8beb39a964ae410527a37688e562569_b.jpg" data-caption="" data-size="normal" data-rawwidth="582" data-rawheight="230" class="origin_image zh-lightbox-thumb lazy" width="582" data-original="https://pic2.zhimg.com/v2-d8beb39a964ae410527a37688e562569_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-d8beb39a964ae410527a37688e562569_b.jpg"/></figure><h2><b>@staticmethod、 @classmethod</b></h2><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-e2aebe7f1b1685317adeca5222ea3d57_b.jpg" data-caption="" data-size="normal" data-rawwidth="695" data-rawheight="169" class="origin_image zh-lightbox-thumb" width="695" data-original="https://pic4.zhimg.com/v2-e2aebe7f1b1685317adeca5222ea3d57_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-e2aebe7f1b1685317adeca5222ea3d57_b.jpg" data-caption="" data-size="normal" data-rawwidth="695" data-rawheight="169" class="origin_image zh-lightbox-thumb lazy" width="695" data-original="https://pic4.zhimg.com/v2-e2aebe7f1b1685317adeca5222ea3d57_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-e2aebe7f1b1685317adeca5222ea3d57_b.jpg"/></figure><p>如果需要访问函数中的类属性，请使用@classmethod。</p><p>如果不需要使用cls对象，则使用@static method。</p><p>与其他语言不同，Python中的静态方法可以在子类中重写。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-f80cc480fad50f9568dce559cd19b24d_b.jpg" data-caption="" data-size="normal" data-rawwidth="892" data-rawheight="415" class="origin_image zh-lightbox-thumb" width="892" data-original="https://pic2.zhimg.com/v2-f80cc480fad50f9568dce559cd19b24d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-f80cc480fad50f9568dce559cd19b24d_b.jpg" data-caption="" data-size="normal" data-rawwidth="892" data-rawheight="415" class="origin_image zh-lightbox-thumb lazy" width="892" data-original="https://pic2.zhimg.com/v2-f80cc480fad50f9568dce559cd19b24d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-f80cc480fad50f9568dce559cd19b24d_b.jpg"/></figure><h2><b>继承和封装</b></h2><p><b>▍继承</b></p><p>继承是一个类获取另一个类的属性的机制。例如，一个孩子继承了他/她父母的特点。通过继承，我们可以重用现有类的字段和方法。因此，继承促进了可重用性，并且是OOPs的一个重要概念。</p><p><b>▍单继承</b></p><p>子类将具有基类的所有功能，还可以修改和增强。</p><p>子类初始化器希望调用基类初始化器，以使整个对象被初始化。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-0fb709713734c40eb652ca3e6c8d60ce_b.png" data-caption="" data-size="normal" data-rawwidth="698" data-rawheight="61" class="origin_image zh-lightbox-thumb" width="698" data-original="https://pic3.zhimg.com/v2-0fb709713734c40eb652ca3e6c8d60ce_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-0fb709713734c40eb652ca3e6c8d60ce_b.png" data-caption="" data-size="normal" data-rawwidth="698" data-rawheight="61" class="origin_image zh-lightbox-thumb lazy" width="698" data-original="https://pic3.zhimg.com/v2-0fb709713734c40eb652ca3e6c8d60ce_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-0fb709713734c40eb652ca3e6c8d60ce_b.png"/></figure><p>调用其他类初始化器：</p><p>1、其他语言自动调用base class初始化器</p><p>2、Python像对待其他方法一样处理 _init__()</p><p>3、base class _init__()在被覆盖时不会被调用</p><p>4、使用super()调用 base class _init__()</p><p>isinstance(instance, class)：确定对象是否具有指定的类型。</p><p><b>Issubclass</b>(subclass，base class)：确定一个类型是否是其他类型的子类。</p><p><b>▍多继承</b></p><p>即子类有多个父类，并且具有它们的特征：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-47f1a8458d92d0286f8650606c5f3962_b.png" data-caption="" data-size="normal" data-rawwidth="699" data-rawheight="62" class="origin_image zh-lightbox-thumb" width="699" data-original="https://pic3.zhimg.com/v2-47f1a8458d92d0286f8650606c5f3962_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-47f1a8458d92d0286f8650606c5f3962_b.png" data-caption="" data-size="normal" data-rawwidth="699" data-rawheight="62" class="origin_image zh-lightbox-thumb lazy" width="699" data-original="https://pic3.zhimg.com/v2-47f1a8458d92d0286f8650606c5f3962_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-47f1a8458d92d0286f8650606c5f3962_b.png"/></figure><p>Python如何知道应该调用哪个base class函数？</p><p>Python使用方法解析Order和super来做到这一点。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-e487ab25b469679ae2dd7d91def4955f_b.png" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="78" class="origin_image zh-lightbox-thumb" width="697" data-original="https://pic4.zhimg.com/v2-e487ab25b469679ae2dd7d91def4955f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-e487ab25b469679ae2dd7d91def4955f_b.png" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="78" class="origin_image zh-lightbox-thumb lazy" width="697" data-original="https://pic4.zhimg.com/v2-e487ab25b469679ae2dd7d91def4955f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-e487ab25b469679ae2dd7d91def4955f_b.png"/></figure><h2><b>方法解析顺序</b></h2><p>确定方法名称查找的顺序</p><p>1、通常称为“MRO”</p><p>2、方法可以在多个地方定义</p><p>3、MRO是继承图的排序</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-a5218ced20de17600776c005c3c11e1f_b.jpg" data-caption="" data-size="normal" data-rawwidth="992" data-rawheight="632" class="origin_image zh-lightbox-thumb" width="992" data-original="https://pic4.zhimg.com/v2-a5218ced20de17600776c005c3c11e1f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-a5218ced20de17600776c005c3c11e1f_b.jpg" data-caption="" data-size="normal" data-rawwidth="992" data-rawheight="632" class="origin_image zh-lightbox-thumb lazy" width="992" data-original="https://pic4.zhimg.com/v2-a5218ced20de17600776c005c3c11e1f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-a5218ced20de17600776c005c3c11e1f_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-9e7e23739c9b5d511b9d81d09150aa72_b.jpg" data-caption="" data-size="normal" data-rawwidth="1030" data-rawheight="696" class="origin_image zh-lightbox-thumb" width="1030" data-original="https://pic3.zhimg.com/v2-9e7e23739c9b5d511b9d81d09150aa72_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-9e7e23739c9b5d511b9d81d09150aa72_b.jpg" data-caption="" data-size="normal" data-rawwidth="1030" data-rawheight="696" class="origin_image zh-lightbox-thumb lazy" width="1030" data-original="https://pic3.zhimg.com/v2-9e7e23739c9b5d511b9d81d09150aa72_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-9e7e23739c9b5d511b9d81d09150aa72_b.jpg"/></figure><p><b>▍封装</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-2d8427036a1151db08576844ecc88738_b.jpg" data-caption="" data-size="normal" data-rawwidth="949" data-rawheight="550" class="origin_image zh-lightbox-thumb" width="949" data-original="https://pic1.zhimg.com/v2-2d8427036a1151db08576844ecc88738_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-2d8427036a1151db08576844ecc88738_b.jpg" data-caption="" data-size="normal" data-rawwidth="949" data-rawheight="550" class="origin_image zh-lightbox-thumb lazy" width="949" data-original="https://pic1.zhimg.com/v2-2d8427036a1151db08576844ecc88738_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-2d8427036a1151db08576844ecc88738_b.jpg"/></figure><h2><b>Python包和程序设计</b></h2><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-11805c5ff2b520c4178e04ecb5083086_b.jpg" data-caption="" data-size="normal" data-rawwidth="834" data-rawheight="452" class="origin_image zh-lightbox-thumb" width="834" data-original="https://pic3.zhimg.com/v2-11805c5ff2b520c4178e04ecb5083086_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-11805c5ff2b520c4178e04ecb5083086_b.jpg" data-caption="" data-size="normal" data-rawwidth="834" data-rawheight="452" class="origin_image zh-lightbox-thumb lazy" width="834" data-original="https://pic3.zhimg.com/v2-11805c5ff2b520c4178e04ecb5083086_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-11805c5ff2b520c4178e04ecb5083086_b.jpg"/></figure><p><b>Sys.path</b> Python搜索模块的目录列表。</p><p><b>PYTHONPATH</b> 添加到sys.path的环境变量列表路径。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-38be983ef3d95349f3adb34c4767431b_b.jpg" data-caption="" data-size="normal" data-rawwidth="820" data-rawheight="506" class="origin_image zh-lightbox-thumb" width="820" data-original="https://pic4.zhimg.com/v2-38be983ef3d95349f3adb34c4767431b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-38be983ef3d95349f3adb34c4767431b_b.jpg" data-caption="" data-size="normal" data-rawwidth="820" data-rawheight="506" class="origin_image zh-lightbox-thumb lazy" width="820" data-original="https://pic4.zhimg.com/v2-38be983ef3d95349f3adb34c4767431b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-38be983ef3d95349f3adb34c4767431b_b.jpg"/></figure><p>1、包是包含其他模块的模块。</p><p>2、包通常实现为包含特殊 _init__.py 文件的目录。</p><p>3、导入包时执行 __init__.py 文件。</p><p>4. 包可以包含自己实现的子包。这些子包本身是用目录中的 __init__.py 文件实现的。</p><p>5、包的模块对象具有__path__属性。</p><p><b>绝对导入</b>：使用模块完整路径的导入。比如 import a，Python 会在 sys.path 里寻找所有名为 a 的顶层模块。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-00ef64a78d6286adb56b878b1801c6b9_b.png" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="58" class="origin_image zh-lightbox-thumb" width="697" data-original="https://pic2.zhimg.com/v2-00ef64a78d6286adb56b878b1801c6b9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-00ef64a78d6286adb56b878b1801c6b9_b.png" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="58" class="origin_image zh-lightbox-thumb lazy" width="697" data-original="https://pic2.zhimg.com/v2-00ef64a78d6286adb56b878b1801c6b9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-00ef64a78d6286adb56b878b1801c6b9_b.png"/></figure><p><b>相对导入</b>：使用相同包中模块的相对路径的导入。比如一个 package 下有 a.py 和 b.py 两个文件，在 a.py 里 from . import b 即是相对导入 b.py。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-3ea6880a93ae91aeecd9b2de7816e98a_b.png" data-caption="" data-size="normal" data-rawwidth="699" data-rawheight="62" class="origin_image zh-lightbox-thumb" width="699" data-original="https://pic3.zhimg.com/v2-3ea6880a93ae91aeecd9b2de7816e98a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-3ea6880a93ae91aeecd9b2de7816e98a_b.png" data-caption="" data-size="normal" data-rawwidth="699" data-rawheight="62" class="origin_image zh-lightbox-thumb lazy" width="699" data-original="https://pic3.zhimg.com/v2-3ea6880a93ae91aeecd9b2de7816e98a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-3ea6880a93ae91aeecd9b2de7816e98a_b.png"/></figure><p><b>__all__</b>：是一个字符串list，用来定义模块中对于from XXX import *时要对外导出的符号，即要暴露的借口，但它只对import *起作用，对from XXX import XXX不起作用。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-22a1800a0c8a05b46487c9c7bbc1d810_b.jpg" data-caption="" data-size="normal" data-rawwidth="746" data-rawheight="579" class="origin_image zh-lightbox-thumb" width="746" data-original="https://pic1.zhimg.com/v2-22a1800a0c8a05b46487c9c7bbc1d810_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-22a1800a0c8a05b46487c9c7bbc1d810_b.jpg" data-caption="" data-size="normal" data-rawwidth="746" data-rawheight="579" class="origin_image zh-lightbox-thumb lazy" width="746" data-original="https://pic1.zhimg.com/v2-22a1800a0c8a05b46487c9c7bbc1d810_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-22a1800a0c8a05b46487c9c7bbc1d810_b.jpg"/></figure><p><i>来自：</i><a href="https://link.zhihu.com/?target=https%3A//medium.com/%40agrawal.pulkit1994" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">medium.com/@agrawal.pul</span><span class="invisible">kit1994</span><span class="ellipsis"></span></a></p><h2><b>MATLAB EXPO 2019 微信直播</b></h2><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-95d3176fbcfcca0bb263ce1303f8d559_b.jpg" data-caption="" data-size="normal" data-rawwidth="1012" data-rawheight="378" class="origin_image zh-lightbox-thumb" width="1012" data-original="https://pic2.zhimg.com/v2-95d3176fbcfcca0bb263ce1303f8d559_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-95d3176fbcfcca0bb263ce1303f8d559_b.jpg" data-caption="" data-size="normal" data-rawwidth="1012" data-rawheight="378" class="origin_image zh-lightbox-thumb lazy" width="1012" data-original="https://pic2.zhimg.com/v2-95d3176fbcfcca0bb263ce1303f8d559_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-95d3176fbcfcca0bb263ce1303f8d559_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-d54dd388960c02812506542888068ed4_b.jpg" data-size="normal" data-rawwidth="1080" data-rawheight="608" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-d54dd388960c02812506542888068ed4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-d54dd388960c02812506542888068ed4_b.jpg" data-size="normal" data-rawwidth="1080" data-rawheight="608" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-d54dd388960c02812506542888068ed4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-d54dd388960c02812506542888068ed4_b.jpg"/><figcaption>免费报名参加</figcaption></figure><p><i>—End—</i></p><p>量化投资与机器学习微信公众号，是业内垂直于<b>Quant</b>、<b>MFE</b>、<b>CST</b>等专业的主流自媒体。公众号拥有来自<b>公募、私募、券商、银行、海外</b>等众多圈内<b>10W+</b>关注者。每日发布行业前沿研究成果和最新资讯。</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
