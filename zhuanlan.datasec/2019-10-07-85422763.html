<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>高效批处理不经意伪随机数生成器及其在隐私集合求交中的应用</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/85422763">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-6ee6f7a27953600edc94f1cc797f68fc_b.jpg" alt=""></div><h2>写在前面</h2><p>随着涉及领域的不断增多，想听译的视频、想读的论文也变得越来越多。不过，这也意味着各个知识点之间变得更松散了。还是要抽出时间批量阅读一些论文，学习一些技术。</p><p>格密码学的视频还在整理当中。回看这些视频，不由得惊叹：当时自己哪里来的那么多时间把视频都听译完的。还是那句话：积少成多，我也在重新整理之前发布过的演讲视频相关专栏文章。部分有缺陷的文章和视频也重新进行了整理和发布。感兴趣的知友们可以翻看一下我之前发布的文章，会有一些新的变化。</p><h2>演讲视频简介</h2><p>本次为知友们带来的视频是信息安全顶级会议CCS 2016上的演讲视频《Efficient Batched Oblivious PRF with Applications to Private Set Intersection》。隐私集合求交（Private Set Intersection，PSI）愈发得到了学术界和企业界的关注。</p><p>近期，各个顶级会议上也推出了一系列高效PSI的构造与实现。自从Pinkas等人在2015年将不经意传输（Oblivious Transfer，OT）引入到PSI以来，PSI的效率已经从百万集合分钟级执行效率降低到百万集合秒级执行效率。这是一个相当巨大的飞跃。随着人们对隐私保护的愈发关注，相信以PSI为代表的安全多方计算（Secure Multi-Party Computation，SMPC）技术，以及以Intel SGX为代表的可信执行环境（Trusted Execution Environment，TEE）技术会逐步从理论走向落地、从落地走向大规模落地。期待未来能出现里程碑级别的应用杀手锏。</p><p>CCS 2016上的这篇文章可以说是非常有代表性的PSI方案构造。方案综合使用了不经意传输、不经意传输扩展（Oblivious Transfer Extension，OTE）、Cuckoo哈希、不经意伪随机数生成器（Oblivious Pseudo-Random Generator），同时还引入了编码理论相关的知识，可以说是多种密码学技术和安全多方计算技术的集合体。对此领域感兴趣的知友们可以认真阅读论文和开源代码，相信会有很大的收获。</p><h2>演讲视频信息</h2><ul><li>论文链接：<a href="https://link.zhihu.com/?target=https%3A//eprint.iacr.org/2016/799.pdf" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">eprint.iacr.org/2016/79</span><span class="invisible">9.pdf</span><span class="ellipsis"></span></a></li><li>视频链接：<a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3Di0kGwz_52Wg%26t%3D394s" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">youtube.com/watch?</span><span class="invisible">v=i0kGwz_52Wg&amp;t=394s</span><span class="ellipsis"></span></a></li><li>中文视频：<a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av70403972/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">bilibili.com/video/av70</span><span class="invisible">403972/</span><span class="ellipsis"></span></a></li><li>双语字幕：<a href="https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/CCS/CCS%25202016" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/liuweiran900</span><span class="invisible">217/SecurityConferenceLectures/tree/master/CCS/CCS%202016</span><span class="ellipsis"></span></a></li></ul><h2>中文字幕视频</h2><a class="video-box" href="https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1164465814702125056" target="_blank" data-video-id="" data-video-playable="true" data-name="" data-poster="https://pic1.zhimg.com/v2-4e1b18cf2e0de9c258e6c1bff0610dc3.png" data-lens-id="1164465814702125056"><img class="thumbnail" src="https://pic1.zhimg.com/v2-4e1b18cf2e0de9c258e6c1bff0610dc3.png"/><span class="content"><span class="title"><span class="z-ico-extern-gray"></span><span class="z-ico-extern-blue"></span></span><span class="url"><span class="z-ico-video"></span>https://www.zhihu.com/video/1164465814702125056</span></span></a><h2>演讲视频字幕</h2><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-5d859be1f0e2ebcb58f9918a7fa96b25_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-5d859be1f0e2ebcb58f9918a7fa96b25_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-5d859be1f0e2ebcb58f9918a7fa96b25_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-5d859be1f0e2ebcb58f9918a7fa96b25_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-5d859be1f0e2ebcb58f9918a7fa96b25_b.jpg"/></figure><p>大家好，感谢Stefan的介绍。我的名字是Ni，我是俄勒冈州立大学的博士研究生，很高兴能来到这里介绍我们的工作。我们的论文题目是：高效批处理不经意伪随机函数及其在隐私集合求交中的应用。此工作是由我和Kalashnikov、Kumaresan、以及Rosulek共同完成的。在论文中，我们提出了一个高效的隐私集合求交协议。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-7eebe69afe5d0c3ff4d6471caf08b0c0_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-7eebe69afe5d0c3ff4d6471caf08b0c0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-7eebe69afe5d0c3ff4d6471caf08b0c0_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-7eebe69afe5d0c3ff4d6471caf08b0c0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-7eebe69afe5d0c3ff4d6471caf08b0c0_b.jpg"/></figure><p>隐私集合求交是密码学中一个非常有趣的问题。我们以一个简单的场景为例，来看看什么是隐私集合求交。例如，幻灯片上有两个参与方：Alice和Bob。每个参与方都有一个集合，这里分别是 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=Y" alt="Y" eeimg="1"/> 。他们想计算两个集合的交集，但不想泄露其它额外的信息。例如，Alice不能知道Bob集合中非交集的元素。Bob也是类似的，他不能知道Alice集合中非交集的元素。这就是隐私集合求交问题的定义。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-9d15212522ca8ec5c0aaa2d4fe298528_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-9d15212522ca8ec5c0aaa2d4fe298528_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-9d15212522ca8ec5c0aaa2d4fe298528_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-9d15212522ca8ec5c0aaa2d4fe298528_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-9d15212522ca8ec5c0aaa2d4fe298528_b.jpg"/></figure><p>隐私集合求交的应用场景非常广泛，我这里给出的例子是通讯录匹配场景。例如，Alice有一个手机，里面存储着Alice的通讯录，Alice想要使用Skype。另一边，Bob是一个Skype服务器，里面存储着客户数据。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-ef5dc61cf3ade5c6c49a9ae4d0144f55_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-ef5dc61cf3ade5c6c49a9ae4d0144f55_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-ef5dc61cf3ade5c6c49a9ae4d0144f55_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-ef5dc61cf3ade5c6c49a9ae4d0144f55_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-ef5dc61cf3ade5c6c49a9ae4d0144f55_b.jpg"/></figure><p>现在，Alice希望知道她的哪些朋友使用Skype，她希望使用Skype与朋友们聊天。很明显，两方希望计算集合的交集。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-884fb36ab797ff0ddf8a0216ff469452_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-884fb36ab797ff0ddf8a0216ff469452_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-884fb36ab797ff0ddf8a0216ff469452_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-884fb36ab797ff0ddf8a0216ff469452_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-884fb36ab797ff0ddf8a0216ff469452_b.jpg"/></figure><p>然而，Alice不想泄露自己的通讯录，因为这是她的个人信息。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-b35f802fdcada72044a5ba9394c6cb18_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-b35f802fdcada72044a5ba9394c6cb18_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-b35f802fdcada72044a5ba9394c6cb18_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-b35f802fdcada72044a5ba9394c6cb18_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-b35f802fdcada72044a5ba9394c6cb18_b.jpg"/></figure><p>Bob也面临类似的问题，他不能泄露自己的客户数据，因为这是客户的隐私。这个场景就需要使用隐私集合求交功能。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-132e3934fc9a4fd347de93151b4a3330_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-132e3934fc9a4fd347de93151b4a3330_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-132e3934fc9a4fd347de93151b4a3330_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-132e3934fc9a4fd347de93151b4a3330_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-132e3934fc9a4fd347de93151b4a3330_b.jpg"/></figure><p>当考虑隐私集合求交这个问题时，我们可能会提出下述解决方案。Alice拥有集合 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"/> ，Bob拥有集合 <img src="https://www.zhihu.com/equation?tex=Y" alt="Y" eeimg="1"/> 。他们分别对 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"/> 中的元素求哈希，对 <img src="https://www.zhihu.com/equation?tex=Y" alt="Y" eeimg="1"/> 中的元素求哈希。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-054d6359e8ed91c3cbfb8e1d7279cbe5_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-054d6359e8ed91c3cbfb8e1d7279cbe5_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-054d6359e8ed91c3cbfb8e1d7279cbe5_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-054d6359e8ed91c3cbfb8e1d7279cbe5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-054d6359e8ed91c3cbfb8e1d7279cbe5_b.jpg"/></figure><p>Bob随后将哈希值发送给Alice。Alice对比两个集合的哈希值，并输出哈希值相等的元素，即交集元素。</p><p>这个协议效率非常高，因为协议只涉及到哈希值的计算。协议涉及的通信量也很小。但不幸的是，这个方案是不安全的，因为这个方案会泄露Bob输入集合的隐私。为什么呢？如果 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"/> 属于比较小的域，例如 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"/> 为电话号码，只包含大约10个数字，Alice直接计算上亿个电话号码的哈希值，并将结果与从Bob收到的结果对比。这样，Alice就可以知道Bob的输入了。这也是此协议被称为朴素哈希的根本原因。因此，这是一个不安全的PSI协议。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-16391b0398831c1e9a90ed605050a8c3_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-16391b0398831c1e9a90ed605050a8c3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-16391b0398831c1e9a90ed605050a8c3_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-16391b0398831c1e9a90ed605050a8c3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-16391b0398831c1e9a90ed605050a8c3_b.jpg"/></figure><p>为了解决这个问题，学者们提出了很多PSI协议。当前最先进的PSI协议由Pinkas、Schneider、Segev和Zohner在2015年提出。隐私集合求交场景下的特殊情况为隐私相等性检测，即两个参与方希望知道两个字符串是否相等。他们的PSI协议通过不经意传输扩展实现隐私相等检测。他们还提出了一个高效的哈希技术，可以将隐私相等检测高效转换为隐私集合求交。我们的核心技术贡献是提高隐私相等检测的效率。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-aa5a1449ce3467a041d368acd50e9c49_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-aa5a1449ce3467a041d368acd50e9c49_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-aa5a1449ce3467a041d368acd50e9c49_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-aa5a1449ce3467a041d368acd50e9c49_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-aa5a1449ce3467a041d368acd50e9c49_b.jpg"/></figure><p>我们来看看Pinkas、Schneider、Segev、Zohner提出的隐私相等检测协议。Alice拥有 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> ，而Bob拥有 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"/> 。我们想知道 <img src="https://www.zhihu.com/equation?tex=x%3Dy" alt="x=y" eeimg="1"/> 是否成立。幻灯片上给出了一个例子： <img src="https://www.zhihu.com/equation?tex=x%3D001" alt="x=001" eeimg="1"/> 、 <img src="https://www.zhihu.com/equation?tex=y%3D011" alt="y=011" eeimg="1"/> 。他们协议的核心思想是对 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"/> 进行逐比特对比。如何做到这一点呢？他们使用了一个安全的黑盒工具，此工具叫不经意传输。</p><p>Bob分别为0和1随机采样两个 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 比特长的字符串。随后，Bob和Alice执行不经意传输协议，Alice的输入是她的第一个比特0。协议执行完毕后，Alice收到她第一个比特0所对应的字符串0。然而，Bob无法得知Alice在不经意传输中的输入是什么，此性质由不经意传输协议的定义所保证。他们继续对第二个比特、第三个比特执行此种操作。现在，Bob从OT协议中取得自己输入所对应的字符串。他的输入比特是011，因此他分别取得0、1、1所对应的三个字符串。他对几个字符串求异或，将结果发送给Alice。Alice也取得OT执行完毕后的结果，即0、0、1所对应的三个字符串。她对几个字符串求异或，并对比Bob发送过来的异或值。这样Alice就知道双方的输入是否相等了。这就是当前PSI协议的隐私相等检测过程。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-7b339bebaaeb8e456baadc73602ef4e8_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-7b339bebaaeb8e456baadc73602ef4e8_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-7b339bebaaeb8e456baadc73602ef4e8_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-7b339bebaaeb8e456baadc73602ef4e8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-7b339bebaaeb8e456baadc73602ef4e8_b.jpg"/></figure><p>协议执行过程中，双方逐比特对比 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"/> ，而协议的基本思想是将多个2选1-OT协议替换为一个N选1-OT协议。当前PSI协议使用了Kolesnikov和Kumaresan于2013年提出的OT扩展协议，这意味着每轮协议只能同时对比8比特长的 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"/> ，我后面会讲解为什么会这样。因此，他们的PSI协议中 <img src="https://www.zhihu.com/equation?tex=N%3D2%5E8" alt="N=2^8" eeimg="1"/> 。这意味着他们协议的OT执行次数依赖于 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"/> 的比特长度。他们的协议还需要通过多个OT实现完整的隐私相等检测。</p><p>在我们的工作中，我们提出了一个OT扩展协议。此协议中的N可以任意大。在我们的协议中，N可以为无穷大。这样，我们只需要使用一次OT即可实现隐私相等检测过程。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-da5afbfee11f260056f6d6a2bd798d34_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-da5afbfee11f260056f6d6a2bd798d34_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-da5afbfee11f260056f6d6a2bd798d34_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-da5afbfee11f260056f6d6a2bd798d34_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-da5afbfee11f260056f6d6a2bd798d34_b.jpg"/></figure><p>这是当前PSI协议的另一个观察结论。我们将此协议看成一个黑盒。如果Alice的输入是 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> ，而Bob的输入是 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> ，这里 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 包含右侧的6个数据块，在PSI协议执行完毕后，Alice收到字符串0、0、1的异或值，我们可以将此异或值看成 <img src="https://www.zhihu.com/equation?tex=F_k%28x%29" alt="F_k(x)" eeimg="1"/> 。这意味着协议执行完毕后，Alice只能知道 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> 所对应的 <img src="https://www.zhihu.com/equation?tex=F_k%28x%29" alt="F_k(x)" eeimg="1"/> 。而Bob已知全部的6个数据块，因此Bob可以对任意 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"/> 计算得到 <img src="https://www.zhihu.com/equation?tex=F_k%28y%29" alt="F_k(y)" eeimg="1"/> 。</p><p>这里一个非常重要的性质是，如果 <img src="https://www.zhihu.com/equation?tex=x%5Cneq+y" alt="x\neq y" eeimg="1"/> ，则对Alice来说 <img src="https://www.zhihu.com/equation?tex=F_k%28y%29" alt="F_k(y)" eeimg="1"/> 看起来是个随机数。这么看来，此协议本质上就是一个不经意伪随机函数。不经意伪随机函数是Freedman、Ishai、Pinkas和Reingold在2005年提出的概念。进一步，如果Bob将异或值，也就是 <img src="https://www.zhihu.com/equation?tex=F_k%28y%29" alt="F_k(y)" eeimg="1"/> 发送给Alice，则Alice可以简单地比较 <img src="https://www.zhihu.com/equation?tex=F_k%28x%29" alt="F_k(x)" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=F_k%28y%29" alt="F_k(y)" eeimg="1"/> ，得知这两个值是否相等。这就是隐私相等检测协议的原理。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-f604659c9460d5a42b22b477ca4868f0_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-f604659c9460d5a42b22b477ca4868f0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-f604659c9460d5a42b22b477ca4868f0_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-f604659c9460d5a42b22b477ca4868f0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-f604659c9460d5a42b22b477ca4868f0_b.jpg"/></figure><p>在接下来的讲座中，我会聚焦于OT扩展协议本身。我们将首先介绍原始的2选1-OT扩展协议，再介绍N选1-OT扩展协议，最后介绍我们构造出的∞选1-OT扩展协议。随后，我们会介绍∞选1-OT扩展协议和我们提出的OPRF实例之间的关系。这里的OPRF对原始OPRF的定义进行了弱化。我后面会详细讲解定义具体的弱化点。我们将我们的OPRF应用在PSI上，从而构造了一个半诚实安全的PSI协议，比当前PSI协议的执行效率高3倍。正如我前面所说，当前PSI协议中，OT的执行次数依赖于集合元素的比特长度。我们的协议移除了OT执行次数与集合元素比特长度的依赖关系。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-74f435091213142ef238370b4b4c7129_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-74f435091213142ef238370b4b4c7129_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-74f435091213142ef238370b4b4c7129_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-74f435091213142ef238370b4b4c7129_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-74f435091213142ef238370b4b4c7129_b.jpg"/></figure><p>我们先来简单介绍Beaver的OT扩展协议。OT扩展协议的基本思想是，可以用少量OT和对称密码学操作构造大量的OT实例。Beaver在数十年前首次提出了这个想法。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-d39be6b5cc59b272462618e7c2050d78_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-d39be6b5cc59b272462618e7c2050d78_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-d39be6b5cc59b272462618e7c2050d78_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-d39be6b5cc59b272462618e7c2050d78_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-d39be6b5cc59b272462618e7c2050d78_b.jpg"/></figure><p>现在，我要向大家介绍一个非常著名、非常高效的OT扩展协议。此协议由Ishai、Kilian、Nissim和Petrank于2003年提出。此协议的基本思想是，在基础OT协议中，Alice选择一个随机的 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 比特长字符串 <img src="https://www.zhihu.com/equation?tex=t%5E1" alt="t^1" eeimg="1"/> 。她计算得到另一个字符串 <img src="https://www.zhihu.com/equation?tex=t%5E1+%5Coplus+r" alt="t^1 \oplus r" eeimg="1"/> 。在另一端还有个参与方Bob，他有一个单比特字符串 <img src="https://www.zhihu.com/equation?tex=s_1" alt="s_1" eeimg="1"/> 。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-767f61c0422e3223efa47b2f65795166_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-767f61c0422e3223efa47b2f65795166_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-767f61c0422e3223efa47b2f65795166_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-767f61c0422e3223efa47b2f65795166_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-767f61c0422e3223efa47b2f65795166_b.jpg"/></figure><p>如果 <img src="https://www.zhihu.com/equation?tex=s_1%3D0" alt="s_1=0" eeimg="1"/> ，则Bob接收到第一列字符串 <img src="https://www.zhihu.com/equation?tex=t%5E1" alt="t^1" eeimg="1"/> 。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-b8f3fe1bba21cc376f727cc893c36e08_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-b8f3fe1bba21cc376f727cc893c36e08_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-b8f3fe1bba21cc376f727cc893c36e08_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-b8f3fe1bba21cc376f727cc893c36e08_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-b8f3fe1bba21cc376f727cc893c36e08_b.jpg"/></figure><p>如果 <img src="https://www.zhihu.com/equation?tex=s_1%3D1" alt="s_1=1" eeimg="1"/> ，则Bob接收到第二列字符串 <img src="https://www.zhihu.com/equation?tex=t%5E1+%5Coplus+r" alt="t^1 \oplus r" eeimg="1"/> 。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-6776a265b116ad4ed2e7c696e234619b_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-6776a265b116ad4ed2e7c696e234619b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-6776a265b116ad4ed2e7c696e234619b_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-6776a265b116ad4ed2e7c696e234619b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-6776a265b116ad4ed2e7c696e234619b_b.jpg"/></figure><p>也就是说，Bob可以根据自己的选择比特 <img src="https://www.zhihu.com/equation?tex=s_1" alt="s_1" eeimg="1"/> 接收到字符串 <img src="https://www.zhihu.com/equation?tex=q_1" alt="q_1" eeimg="1"/> 。OT协议定义的功能就是这样的。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-3f2191d593ae7a7639cb11c59e58deb6_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-3f2191d593ae7a7639cb11c59e58deb6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-3f2191d593ae7a7639cb11c59e58deb6_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-3f2191d593ae7a7639cb11c59e58deb6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-3f2191d593ae7a7639cb11c59e58deb6_b.jpg"/></figure><p>现在，他们重复上述过程 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 次，每次都使用相同的 <img src="https://www.zhihu.com/equation?tex=r" alt="r" eeimg="1"/> 。最后，Bob收到包含 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 列的矩阵 <img src="https://www.zhihu.com/equation?tex=q" alt="q" eeimg="1"/> ，每列 <img src="https://www.zhihu.com/equation?tex=q_i" alt="q_i" eeimg="1"/> 的值都由比特 <img src="https://www.zhihu.com/equation?tex=s_i" alt="s_i" eeimg="1"/> 所决定。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-55eb4b8a17103c94edf8b1e777d86877_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-55eb4b8a17103c94edf8b1e777d86877_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-55eb4b8a17103c94edf8b1e777d86877_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-55eb4b8a17103c94edf8b1e777d86877_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-55eb4b8a17103c94edf8b1e777d86877_b.jpg"/></figure><p>现在，他们使用轻量级的密码学技术伪随机数生成器将 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 个OT扩展为 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"/> 个OT。这里 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"/> 要远远大于 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 。 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"/> 大约等于 <img src="https://www.zhihu.com/equation?tex=2%5E%7B20%7D" alt="2^{20}" eeimg="1"/> 。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-c09b4049ee64d6c8916a61212c7bf594_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-c09b4049ee64d6c8916a61212c7bf594_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-c09b4049ee64d6c8916a61212c7bf594_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-c09b4049ee64d6c8916a61212c7bf594_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-c09b4049ee64d6c8916a61212c7bf594_b.jpg"/></figure><p>在整个协议执行过程中，Alice得到了矩阵 <img src="https://www.zhihu.com/equation?tex=T" alt="T" eeimg="1"/> 和矩阵 <img src="https://www.zhihu.com/equation?tex=T+%5Coplus+r" alt="T \oplus r" eeimg="1"/> 。我们将这组矩阵称为OT矩阵。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-4cdcec2b521a63ca46614bf4e8b3314e_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-4cdcec2b521a63ca46614bf4e8b3314e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-4cdcec2b521a63ca46614bf4e8b3314e_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-4cdcec2b521a63ca46614bf4e8b3314e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-4cdcec2b521a63ca46614bf4e8b3314e_b.jpg"/></figure><p>如果我们从行的角度观察这个矩阵，并且令 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> 表示第一个矩阵的第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 行。如果令 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 表示 <img src="https://www.zhihu.com/equation?tex=r" alt="r" eeimg="1"/> 的第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 个比特值，则第二个矩阵的第i行就等于 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> ，则此时 <img src="https://www.zhihu.com/equation?tex=q_i%3Dt_i" alt="q_i=t_i" eeimg="1"/> 。左右两行下标相同，取值也相同。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-4df3023230ea40b5a3827b57cf793e64_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-4df3023230ea40b5a3827b57cf793e64_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-4df3023230ea40b5a3827b57cf793e64_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-4df3023230ea40b5a3827b57cf793e64_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-4df3023230ea40b5a3827b57cf793e64_b.jpg"/></figure><p>如果 <img src="https://www.zhihu.com/equation?tex=r_i%3D1" alt="r_i=1" eeimg="1"/> ，则第二个矩阵的第i行等于 <img src="https://www.zhihu.com/equation?tex=t_i+%5Coplus+1%5E%7B%5Ckappa%7D" alt="t_i \oplus 1^{\kappa}" eeimg="1"/> 。此时 <img src="https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+s" alt="q_i=t_i \oplus s" eeimg="1"/> 。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-f376b3de2a0c94b0ba4565134c7d4455_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-f376b3de2a0c94b0ba4565134c7d4455_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-f376b3de2a0c94b0ba4565134c7d4455_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-f376b3de2a0c94b0ba4565134c7d4455_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-f376b3de2a0c94b0ba4565134c7d4455_b.jpg"/></figure><p>也就是说， <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 或者等于0，或者等于1，长度为1比特。而 <img src="https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+%28r_i%29%5E%7B%5Ckappa%7D+%5Codot+s" alt="q_i=t_i \oplus (r_i)^{\kappa} \odot s" eeimg="1"/> 。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-0890b2bd355c044d64438181e3a231ad_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-0890b2bd355c044d64438181e3a231ad_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-0890b2bd355c044d64438181e3a231ad_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-0890b2bd355c044d64438181e3a231ad_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-0890b2bd355c044d64438181e3a231ad_b.jpg"/></figure><p>现在，我们把目标聚焦于OT矩阵本身。如果Alice的输入是 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> ，Bob的输入是 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"/> ，则Alice已知 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> ，她可以计算 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> 的哈希值。Bob收到 <img src="https://www.zhihu.com/equation?tex=q_i" alt="q_i" eeimg="1"/> 后，可以计算 <img src="https://www.zhihu.com/equation?tex=q_i" alt="q_i" eeimg="1"/> 的哈希值，以及 <img src="https://www.zhihu.com/equation?tex=q_i+%5Coplus+s" alt="q_i \oplus s" eeimg="1"/> 的哈希值。这里一个非常重要的性质是， <img src="https://www.zhihu.com/equation?tex=t_i%3Dq_i" alt="t_i=q_i" eeimg="1"/> ，或者 <img src="https://www.zhihu.com/equation?tex=t_i%3Dq_i+%5Coplus+s" alt="t_i=q_i \oplus s" eeimg="1"/> ，具体等于什么取决于 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 。也就是说， <img src="https://www.zhihu.com/equation?tex=H%28q_i%29" alt="H(q_i)" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=H%28q_i+%5Coplus+s%29" alt="H(q_i \oplus s)" eeimg="1"/> 有且仅有一个值等于 <img src="https://www.zhihu.com/equation?tex=H%28t_i%29" alt="H(t_i)" eeimg="1"/> ，而另一个值对Alice来说看起来像随机数。换句话说，Bob有两个值，Alice只知道其中的一个值。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-c26c26f69bdbb769c67e680e58f3a8a9_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-c26c26f69bdbb769c67e680e58f3a8a9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-c26c26f69bdbb769c67e680e58f3a8a9_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-c26c26f69bdbb769c67e680e58f3a8a9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-c26c26f69bdbb769c67e680e58f3a8a9_b.jpg"/></figure><p>在2013年，Kolesnikov和Kumaresan指出，IKNP协议中包含重复编码。如果称 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 是一个 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 个比特值重复编码 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 次的编码过程，我们再来研究一下IKNP协议。第二个矩阵的第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 行等于 <img src="https://www.zhihu.com/equation?tex=t_i+%5Coplus+C%28r_i%29" alt="t_i \oplus C(r_i)" eeimg="1"/> ，而 <img src="https://www.zhihu.com/equation?tex=q_i+%3D+t_i+%5Coplus+C%28r_i%29+%5Codot+s" alt="q_i = t_i \oplus C(r_i) \odot s" eeimg="1"/> 。Bob计算的是幻灯片上这两个值的哈希值。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-7db446c8d9fc0f3d191fa664d689ae74_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-7db446c8d9fc0f3d191fa664d689ae74_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-7db446c8d9fc0f3d191fa664d689ae74_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-7db446c8d9fc0f3d191fa664d689ae74_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-7db446c8d9fc0f3d191fa664d689ae74_b.jpg"/></figure><p>现在，如果把随机编码移除，将 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 替换为纠错编码，则此协议可以支持长度最大为8比特的选择比特值 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 。这也是为什么当前PSI协议只能对比8比特长的 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"/> 和8比特长的 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"/> 。举例来说，我们令 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 的输入为3比特长，此时Bob需要根据幻灯片上的公式计算8个哈希值。我们得到了一个非常重要的性质： <img src="https://www.zhihu.com/equation?tex=H%28q_i+%5Coplus+C%28r%27%29+%5Codot+s%29%3DH%28t_i+%5Coplus+%5BC%28r%27%29+%5Coplus+C%28r_i%29%5D+%5Codot+s%29" alt="H(q_i \oplus C(r&#39;) \odot s)=H(t_i \oplus [C(r&#39;) \oplus C(r_i)] \odot s)" eeimg="1"/> 。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-bfb7daf88c32482ceaebf1080d7e9715_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-bfb7daf88c32482ceaebf1080d7e9715_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-bfb7daf88c32482ceaebf1080d7e9715_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-bfb7daf88c32482ceaebf1080d7e9715_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-bfb7daf88c32482ceaebf1080d7e9715_b.jpg"/></figure><p>现在，我们观察等式中的绿色部分。如果 <img src="https://www.zhihu.com/equation?tex=r_i%3Dr%27" alt="r_i=r&#39;" eeimg="1"/> ，则绿色部分等于0。绿色部分与 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"/> 逐比特与，计算结果还是0，这意味着我们得到的是 <img src="https://www.zhihu.com/equation?tex=H%28t_i%29" alt="H(t_i)" eeimg="1"/> 。换句话说，Bob可以计算 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"/> 个哈希值，而Alice只能得到其中一个哈希值，这也是为什么此协议被称为N选1-OT的原因。从安全角度看，他们的协议要求 <img src="https://www.zhihu.com/equation?tex=C%28r%E2%80%99%29+%5Coplus+C%28r_i%29" alt="C(r’) \oplus C(r_i)" eeimg="1"/> 的汉明重量要大于 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 。我们翻到下一页幻灯片，讲解其中的原因。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-2aca4dc5c286d56d16e63e606c325193_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-2aca4dc5c286d56d16e63e606c325193_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-2aca4dc5c286d56d16e63e606c325193_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-2aca4dc5c286d56d16e63e606c325193_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-2aca4dc5c286d56d16e63e606c325193_b.jpg"/></figure><p>Bob能得到什么？他计算得到 <img src="https://www.zhihu.com/equation?tex=H%28q_i+%5Coplus+C%28r%27%29+%5Codot+s%29" alt="H(q_i \oplus C(r&#39;) \odot s)" eeimg="1"/> ，这个值等于 <img src="https://www.zhihu.com/equation?tex=H%28t_i+%5Coplus+%5BC%28r%27%29+%5Coplus+C%28r_i%29%5D+%5Codot+s%29" alt="H(t_i \oplus [C(r&#39;) \oplus C(r_i)] \odot s)" eeimg="1"/> 。如果 <img src="https://www.zhihu.com/equation?tex=r_i+%5Cneq+r%27" alt="r_i \neq r&#39;" eeimg="1"/> ，则此表达式计算得到的值对Alice来说是个随机数。然而，如果Alice可以通过某种方式猜测 <img src="https://www.zhihu.com/equation?tex=r%27" alt="r&#39;" eeimg="1"/> 的值，如果Alice知道了 <img src="https://www.zhihu.com/equation?tex=r%27" alt="r&#39;" eeimg="1"/> ，她就知道了 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> ，她也就知道了 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> ，这实际上意味着Alice知道此表达式所有红色部分的取值，但不知道蓝色部分 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"/> 的值。如果 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 的最小汉明距离为 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> ，则 <img src="https://www.zhihu.com/equation?tex=C%28r%27%29+%5Coplus+C%28r_i%29" alt="C(r&#39;) \oplus C(r_i)" eeimg="1"/> 的汉明重量大于 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 。这意味着，Alice必须正确猜测 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"/> 中的 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 个比特。这样一来，此协议就满足安全性要求了。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-8507f3e31a805db7e0aaa83c4bbc96fd_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-8507f3e31a805db7e0aaa83c4bbc96fd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-8507f3e31a805db7e0aaa83c4bbc96fd_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-8507f3e31a805db7e0aaa83c4bbc96fd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-8507f3e31a805db7e0aaa83c4bbc96fd_b.jpg"/></figure><p>下面是我们的观察结论，我们发现，我们不需要使用编码算法。我们将 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 替换为输出 <img src="https://www.zhihu.com/equation?tex=%5Ckappa" alt="\kappa" eeimg="1"/> 比特长随机字符串的随机函数。这是一个非常小的技巧，但这个技巧让我们的协议变得非常厉害。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-0b975f2d9fc113b5267b9d1d254b9dff_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-0b975f2d9fc113b5267b9d1d254b9dff_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-0b975f2d9fc113b5267b9d1d254b9dff_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-0b975f2d9fc113b5267b9d1d254b9dff_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-0b975f2d9fc113b5267b9d1d254b9dff_b.jpg"/></figure><p>如果我们将 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 替换为随机函数，则我们的协议可以支持任意长度的 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 。也就是说，这里的 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 可以为任意比特长。从Bob的角度看，他可以计算得到 <img src="https://www.zhihu.com/equation?tex=H%28q_i+%5Coplus+C%28r%27%29+%5Codot+s%29" alt="H(q_i \oplus C(r&#39;) \odot s)" eeimg="1"/> 。这意味着从正确性角度看，我们所得到的协议与之前的协议功能完全相同。在我们的协议中，Bob可以计算任意哈希值，而Alice只能知道其中一个哈希值。这就是为什么我们称我们的协议是∞选1-OT扩展的原因。从安全性看，我们要计算 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 的最优输出比特长度，让此长度等于 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="\lambda" eeimg="1"/> ，从而得到安全性。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-ed050c10304c9da0c68701b7697c9e27_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-ed050c10304c9da0c68701b7697c9e27_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-ed050c10304c9da0c68701b7697c9e27_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-ed050c10304c9da0c68701b7697c9e27_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-ed050c10304c9da0c68701b7697c9e27_b.jpg"/></figure><p>从前面两页幻灯片中，我们可以得到幻灯片上的这一行结论。现在，我们将 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 设置成了伪随机函数。从安全性角度看，我们只需让 <img src="https://www.zhihu.com/equation?tex=C%28r%27%29+%5Coplus+C%28r_i%29" alt="C(r&#39;) \oplus C(r_i)" eeimg="1"/> 的最小汉明重量是可忽略函数即可。为此，我们让伪随机函数 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 的输出比特长度为 <img src="https://www.zhihu.com/equation?tex=3.5+%5Ckappa" alt="3.5 \kappa" eeimg="1"/> 。这就是为满足协议的安全性，我们需要设置的算法参数。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-c8235d584f5a1bb7dc818779425c65b7_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-c8235d584f5a1bb7dc818779425c65b7_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-c8235d584f5a1bb7dc818779425c65b7_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-c8235d584f5a1bb7dc818779425c65b7_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-c8235d584f5a1bb7dc818779425c65b7_b.jpg"/></figure><p>这也意味着我们需要把基础OT矩阵宽度扩展到 <img src="https://www.zhihu.com/equation?tex=3.5+%5Ckappa" alt="3.5 \kappa" eeimg="1"/> 比特。不过，我们没必要使用更多的基础OT来扩展OT矩阵宽度。我们使用了一个小技巧。应用伪随机数生成器将OT矩阵的高度扩展到 <img src="https://www.zhihu.com/equation?tex=3.5+%5Ckappa" alt="3.5 \kappa" eeimg="1"/> 比特。随后，我们对矩阵转置，得到宽度为 <img src="https://www.zhihu.com/equation?tex=3.5+%5Ckappa" alt="3.5 \kappa" eeimg="1"/> 比特的基础OT矩阵。这样，我们的协议就满足了安全性要求。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-597edb8e873b0e1e339b15ecb8333879_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-597edb8e873b0e1e339b15ecb8333879_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-597edb8e873b0e1e339b15ecb8333879_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-597edb8e873b0e1e339b15ecb8333879_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-597edb8e873b0e1e339b15ecb8333879_b.jpg"/></figure><p>这是协议的完整执行流程。再次强调，如果 <img src="https://www.zhihu.com/equation?tex=r_i+%5Cneq+r%27" alt="r_i \neq r&#39;" eeimg="1"/> ，则 <img src="https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%27%29" alt="F_{s,q_i}(r&#39;)" eeimg="1"/> 看起来像是随机数。而 <img src="https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%29%3DH%28q_i+%5Coplus+C%28r%29+%5Codot+s%29" alt="F_{s,q_i}(r)=H(q_i \oplus C(r) \odot s)" eeimg="1"/> ，这就是不经意伪随机函数 <img src="https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%29" alt="F_{s,q_i}(r)" eeimg="1"/> 的定义。OT矩阵的每一行都定义了一个OPRF实例，这也是为什么我们将我们的协议命名为批处理OPRF的原因。每一行对应的第二个密钥 <img src="https://www.zhihu.com/equation?tex=q_i" alt="q_i" eeimg="1"/> 均不相同，但第一个密钥 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"/> 是相同的。因此，我们得到的是批处理密钥相关OPRF。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-0d84c35c672f8a09508842e3063a5076_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-0d84c35c672f8a09508842e3063a5076_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-0d84c35c672f8a09508842e3063a5076_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-0d84c35c672f8a09508842e3063a5076_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-0d84c35c672f8a09508842e3063a5076_b.jpg"/></figure><p>这也是为什么我们将我们的协议最终命名为批处理密钥相关OPRF的原因。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-9526fb17c645faf040543bda1c36f2bb_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-9526fb17c645faf040543bda1c36f2bb_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-9526fb17c645faf040543bda1c36f2bb_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-9526fb17c645faf040543bda1c36f2bb_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-9526fb17c645faf040543bda1c36f2bb_b.jpg"/></figure><p>很容易在PSI上应用此OPRF。Bob将 <img src="https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%27%29" alt="F_{s,q_i}(r&#39;)" eeimg="1"/> 发送给Alice，Alice简单比较 <img src="https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r_i%29" alt="F_{s,q_i}(r_i)" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%27%29" alt="F_{s,q_i}(r&#39;)" eeimg="1"/> ，并告知这两个值是否相等。如果 <img src="https://www.zhihu.com/equation?tex=r_i+%5Cneq+r%27" alt="r_i \neq r&#39;" eeimg="1"/> ，则对Alice来说 <img src="https://www.zhihu.com/equation?tex=F_%7Bs%2Cq_i%7D%28r%27%29" alt="F_{s,q_i}(r&#39;)" eeimg="1"/> 像是个随机数。这意味着Alice无法猜测得到有关r&#39;的任何信息。这就是隐私相等检测协议的执行过程。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-3855e24cab7a3f5b17f5fa0bb9d7760a_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-3855e24cab7a3f5b17f5fa0bb9d7760a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-3855e24cab7a3f5b17f5fa0bb9d7760a_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-3855e24cab7a3f5b17f5fa0bb9d7760a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-3855e24cab7a3f5b17f5fa0bb9d7760a_b.jpg"/></figure><p>最终，我们协议的OT执行次数不依赖于输入比特长度 <img src="https://www.zhihu.com/equation?tex=%7Cr%27%7C" alt="|r&#39;|" eeimg="1"/> 、也不依赖于 <img src="https://www.zhihu.com/equation?tex=%7Cr_i%7C" alt="|r_i|" eeimg="1"/> 。我们的协议比当前PSI协议执行效率快3倍。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-74a76255ad0fef9d88385886a4de4d86_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-74a76255ad0fef9d88385886a4de4d86_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-74a76255ad0fef9d88385886a4de4d86_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-74a76255ad0fef9d88385886a4de4d86_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-74a76255ad0fef9d88385886a4de4d86_b.jpg"/></figure><p>幻灯片上给出了半诚实PSI协议的执行效率对比。基于电路的PSI协议的意思是使用通用安全计算协议实现PSI，此类协议的执行效率较低。如果我们使用公钥密码学构造PSI协议，协议的通信效率很高，但计算效率较低。基于OT构造PSI的协议效率较高，计算复杂度和通信复杂度都比较低。我们也对比了最近提出的两个协议，我们的协议比当前PSI协议执行效率快3倍。X轴用10为底的对数进行了放缩。我们协议的执行效率进一步向朴素哈希算法的执行效率迈进。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-4f12efab5ad98fe53ea5434844b90abd_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-4f12efab5ad98fe53ea5434844b90abd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-4f12efab5ad98fe53ea5434844b90abd_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-4f12efab5ad98fe53ea5434844b90abd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-4f12efab5ad98fe53ea5434844b90abd_b.jpg"/></figure><p>感谢大家的聆听。</p><p>主持人：感谢主讲人的演讲，我们还有一些提问的时间。</p><p>提问者：你好，有个地方我没有想明白。如果我们用盲签名等公钥密码学方案构建OPRF，则此类方案只需要一轮交互，但你提到公钥密码学方案的执行效率很低。</p><p>主讲人：你能再描述一遍问题吗？</p><p>提问者：应用OPRF实现PSI的最直接方法是，Alice要求Bob对双方的字符串签名。Bob对字符串签名，并将结果返回给Alice。Alice检查签名结果是否相等，只要签名结果是唯一的，这个协议就是正确的。当然这里还有很多限制条件，比如不能直接使用RSA。但是，这个方案效率很高，可以实现PSI。你前面提到，参与方A要对参与方B所有的字符串签名。</p><p>主讲人：是的。</p><p>提问者：参与方A同时要对它自己的字符串签名，随后取两组签名的交集。但你前面提到这个过程效率很低，因为…</p><p>主讲人：我明白了，感谢你提出的问题。我们的OPRF只需要使用少量的公钥密码学方案 但需要使用大量的对称密码学方案，这就是我们的协议要比公钥密码学方案的协议高效的原因。</p><p>提问者：因为你只需要执行128次公钥密码学操作吗？</p><p>主讲人：是的，我们只需要执行128次，你可以看这页幻灯片。这里的技巧在于，我们在OPRF协议中使用了OT扩展协议，这意味着我们只需要执行128次公钥密码学操作，或者说κ次公钥密码学操作。</p><p>提问者：明白了。</p><p>主讲人：是的，我们还使用了对称密码学。很显然，对称密码学的执行效率比公钥密码学高得多，所以… </p><p>提问者：明白了。</p><p>主讲人：好的。</p><p>提问者：谢谢，所以这个方案才能这样高效地完成计算，明白了。</p><p>主讲人：是的。</p><p>提问者：谢谢。</p><p>主持人：听众还有什么其它问题吗？没有其它问题了，我们再次感谢主讲人。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
