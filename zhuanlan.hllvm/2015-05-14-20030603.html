<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>六离合释：指针的 Hoare Logic——Separation Logic</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20030603">原文</a></p>
Hoare Logic 是证明程序正确性的法宝，具体而言，它给出了逐步推理程序正确性的方法。Hoare Logic 使用符号 {<i>P</i>} <b>e</b> {<i>R</i>} 表示程序步骤 <b>e</b> 执行前后的行为：若断言 <i>P</i> 在执行前成立，则 <b>e</b> 执行后断言 <i>R</i> 成立。一些推理规则是很显而易见的：比如<p><equation>\frac {\{P\}\ \mathbf{e}\ \{Q\}\ , \ \{Q\}\ \mathbf{f}\ \{R\} } {\{P\}\ \mathbf{e;f}\ \{R\}}</equation>(sequent)<br></p><p>Hoare Logic 推出后在程序正确性证明方面成为了利器，然而它有一点没有包含，就是没有处理指针，于是 John C. Reynolds 等扩展的 Separation Logic 很好地处理了指针相关的内容。</p><p>Separation Logic 中的程序状态分为两个部分：栈区 <i>s</i> 和堆区 <i>h</i>，堆 <i>h</i> 定义为地址到值的函数。两个堆<b>正交</b>若且唯若其定义域不交，记作<equation>h_1 \bot h_2</equation>。Separation Logic 定义了四个附加的断言符号来声明堆的性质：</p><ol><li>断言 <b>emp </b>表示堆的定义域是空的</li><li>算符<equation>\mapsto</equation>表示指针指向，即若<equation>s,h \models e\mapsto f</equation>当且仅当<equation>\mathrm{dom}\ h=\{e\}</equation>且<equation>h(e)=f</equation></li><li>算符 * 叫做<b>分离合取</b>，若状态 (<i>s</i>, <i>h</i>) 满足 <i>P</i> * <i>Q</i>，则 <i>h</i> 一定可以拆分成正交的两个部分 <i>j</i><i>k</i> 使得 (<i>s</i>, <i>j</i>) 满足 <i>P</i>，(<i>s</i>, <i>k</i>) 满足 <i>Q</i></li><li>算符 <equation>-\!\!\ast</equation> 称为「法杖」或者<b>分离蕴含</b>，若状态<equation>s,h\models P-\!\!\ast Q</equation>，那么就表示对所有和 <i>h</i> 正交且满足 <i>P</i> 的堆 <i>j</i>，有<equation>s,(h\cup j)\models  Q</equation>。</li></ol><br>分离合取和分离蕴含与逻辑学中的合取蕴含极其相似（例如，分离蕴含的前件为假时也成立），Separation Logic 也可以定义一条肯定前件：<equation>\frac{s, h \models P \ast (P -\!\!\ast\, Q)}{s, h \models Q}</equation>。<p>在这四个算符的基础上 Reynolds 等还定义了其他的符号，如对定义域没有要求的箭头<equation>\hookrightarrow</equation>（表示「内存中有一项……」而非「只有一项」）和指向连续内存的记号<equation>e\mapsto f_1, f_2, ..., f_n</equation>等。下图表示了<equation>x\mapsto 3,y\ast y\mapsto 3,x</equation>对应的内存情形：<img src="https://pic4.zhimg.com/4ac79f5c3e5318d9422fe2c336b7cbe0_r.jpg" data-rawwidth="592" data-rawheight="261"></p><p>而 <equation>x\mapsto 3,y\wedge y\mapsto 3,x</equation>则是：<img src="https://pic3.zhimg.com/7f0e84fb98b6e876ac909a360cf1540f_r.jpg" data-rawwidth="299" data-rawheight="254">因为被<equation>\wedge</equation>连接的两条子断言描述的是同一片内存。</p><p>Separation Logic 用于证明程序正确性的方式和 Hoare Logic 相似，但是有额外的 5 条推理规则。</p><p>首先是「框法则」，一个「好」程序不应该干涉和它不相关的内容，换言之如果程序满足 {<i>P</i>} <b>e</b> {<i>Q</i>}，那么对于任意的内存断言 <i>R</i>，若 <i>R</i> 中没有被 <b>e</b> 指向的目标，则一定有 {<i>P</i> * <i>R</i>} <b>e</b> {<i>Q</i> * <i>R</i>}。</p><p>对指针赋值 <b>*e = f</b> 而言，Separation Logic 定义了公理<equation>\{e\mapsto x\}\ \mathbf{*e=f}\ \{e\mapsto f\}</equation>，这个公理实际上明确了很多东西：除了被指向的目标外，还要求指针 <b>e</b> 已经被分配了内存，野指针就是被这么消灭的。</p><p>解分配 <b>dispose e</b> 的规则也很明确：<equation>\{e\mapsto x\}\ \mathbf{dispose\ e}\ \{\mathbf{emp}\}</equation>，一个（只有 e 的）堆被释放内存之后，它就空啦！</p><p>分配内存 <b>e = new(v)</b> 的规则稍有些复杂：<equation>\{e = v' \wedge\mathbf{emp} \}\ \mathbf{e=new(v) } \ \{e\mapsto v\}</equation>（<i>v'</i> 和 <i>e</i> 彼此不同），Separation Logic 不允许分配内存后不初始化，所以 <b>new</b> 都是带初始值的。</p><p>最后一条推理规则是针对解引用 <b>e = *f</b> 的：<equation>\{e=v'\wedge f\mapsto v\}\ \mathbf{e=*f}\ \{e=v\wedge f\mapsto v\}</equation>（<i>v</i>, <i>v'</i>, <i>e</i> 彼此不同）</p><p>在 Separation Logic 推出之后许多人（包括发明者 Reynolds 等在内）都对其进行了各种扩展，比如针对并行的（各位可想想互相独立的并行进程<equation>p\ ||\ q</equation>的推理规则怎么写），处理垃圾收集的，等等。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
