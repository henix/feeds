<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>一个滑块游戏的计算复杂性分析初步</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/29835678">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-e034b3b006eac91666343c4c3594d679_r.png" alt=""></div><p>前段时间波恩大学的Norbert Blum宣称证明了 <equation>\text{P} \ne \text{NP}</equation> ，并将文章挂在了arXiv上。PvsNP问题是计算理论领域最重要的未解决难题，它也是Clay数学研究所悬赏的千禧年七大数学难题之一，成功解决它的人有很大概率能获得数学界的最高荣誉Fields奖。PvsNP问题是如此的重要，而且它理解起来不算困难。因此，多年来全世界挑战PvsNP问题的人趋之若鹜，其中很大一部分是来搞笑的但也不乏专业的研究人员。然而，至今为止NP是否等于P依旧悬而未决。大家也最好不要轻易去挑战PvsNP问题，它很有可能消耗掉你大量的人生和信用。</p><p>我在这不打算、也没能力讨论Norbert Blum的证明是不是对的。我只是想找一个游戏中的有趣问题，尝试证明该问题是NP完全的（或NP-hard），以此来测试一下自己的计算理论基础。我选择了经典益智游戏“华容道”，我想看看它到底有多“难”。“华容道”游戏是一个经典益智小游戏，它通常是木制的，由若干个小方块摆放在一个矩形的框中，如下图</p><img src="https://pic4.zhimg.com/v2-7e4a9c32afdd0bf1396f11443721fa33_r.jpg" data-caption="" data-rawwidth="386" data-rawheight="400"><p>玩家需要做的是通过移动小方块，帮助“曹操”方块从初始位置移到最下方中部的出口逃走。当然在移动过程中，不允许其他方块移出到框外，也不能用“飞跃”大法。“华容道”游戏虽然取名自三国轶事，但它其实应该是一个比较现代的玩具，而它最早的出处比较难考证了，具体可以参考wiki百科<a href="https://en.wikipedia.org/wiki/Klotski">Klotski</a>词条。</p><p>原始“华容道”游戏的解法能够被计算机穷举，但是我没有找到关于它的推广问题的计算复杂性分析的材料。因此，我想自行尝试看看能不能证明它的推广问题是NP-hard的，经过几天的思考，还真“凑”出了一个简单的归约方法...</p><h2><b>0.计算复杂性理论基础</b></h2><p>我们先来粗糙地介绍一些计算理论的基础知识。<b>计算复杂性理论</b>（computational complexity theory）研究的是计算机求解计算问题所需要计算资源的量。将存在多项式时间算法的问题的集合记为<b>P</b>，通常认为这个集合中的问题能被计算机有效解决。因为随着问题输入规模n的增长，算法的运行时间是n的多项式，相比于指数时间算法，多项式算法的运行时间增长速度要慢很多。将存在多项式检验算法的问题的集合记为<b>NP</b>，检验算法指的是对于问题的某个解，算法能够检验该解是否符合要求。其实集合NP包含了集合P，这不难理解，因为如果一个问题都能被直接解决了，那验证它的解不是更容易嘛。PvsNP问题是指是否存在属于NP而不属于P的问题，即NP是否等于P。</p><p>容易发现，PvsNP取决于NP中最“难”的问题是不是属于P。那么怎么判断问题的难度呢，这就需要介绍“归约”了。对于问题a的每个实例，若可以构造问题b的实例，并且能够证明这两个实例的判定结果一致，就认为问题a可以归约到问题b。当这种归约能够在多项式时间内完成的话，则称为<b>多项式时间归约</b>（polynomial-time reduction）。其意义在于，如果b属于P，那么存在b的多项式时间算法，而多项式时间归约的存在保证了该算法也可以用于求解a，从而可以说明a也属于P。a可以多项式时间归约到b可以形象地理解为b不会比a简单。多项式时间归约的一个重要性质是具有传递性，a可以归约到b，而b又可以归约到c，就意味着a可以归约到c。在证明某个问题可以多项式时间归约到另一问题时，利用传递性有时可以使得归约的难度大大降低。</p><p>接着可以定义一个问题集合<b>NP-hard</b>，对于NP-hard中的任意一个问题a，所有NP中的问题都可以多项式时间归约到问题a。也就是说NP-hard中的任意一个问题都要比NP中的所有问题都“难”（或者说不简单）。这就很厉害了，NP-hard问题看起来很难啊，比所有NP问题都要难解决。然而，令人震惊的是NP中有些问题是NP-hard的！所有其他NP问题可以多项式时间归约到这些NP问题，他们是“最难”的NP问题。 20世纪60年代末至70年代初，Stephen Cook和Leonid Levin分别独立地意识到这些问题的存在。后来这些问题被称为NP完全（NP-Complete）问题，简记为<b>NPC</b>，其定义直接就是NP和NP-hard的交集。由于NPC是NP中最难的问题集合，NPC中的任意一个问题有多项式时间算法就等价于P=NP了！</p><p>有了初始的NPC问题后，人们可以容易地寻找新的NPC问题。需要做的是先说明新问题是属于NP的（这一步通常比较简单），然后再从NP-hard中找一个问题，将它多项式时间归约到新问题，再加上NP-hard的定义和归约的传递性就能说明NP中的所有问题可以多项式时间归约到新问题了。自NP完全性理论提出以来，数以千计的问题被证明属于NPC。然而至今未能寻找到任意一个NPC问题的多项式时间算法，也未能证明NPC问题不存在多项式时间算法。</p><h2><b>1.问题定义</b></h2><p>这里我们想考察一下“华容道”游戏的一个推广问题是否属于NP-hard（或者NPC）。</p><p>显然，我们的问题是在平面方格上考虑的。我们将平面方格上不可移动的方格称为墙方格，将若干个相邻的可以整体移动的方格称为滑块，滑块只能水平或垂直滑动，每次滑动只能移动一个方块的距离。另外，滑块在移动时需要考虑“碰撞”，即一个滑块的任意部分不能和墙方块或其他滑块重叠。我们将<b>滑块游戏问题</b>定义为：给定平面上若干墙方格和若干滑块，问是否能通过有限次移动滑块，使得指定的滑块到达指定的位置。</p><p>举个例子，下图是就是一个滑块游戏的实例，灰色方块是墙，白色方块是空方块，其他颜色的方块是滑块，现在问题是能否通过滑动滑块使得红色滑块向右移动一格。</p><img src="https://pic1.zhimg.com/v2-3d5c150cce105329440447754df4e822_r.jpg" data-caption="" data-rawwidth="266" data-rawheight="276"><p>这是可以做到的，先将中间一列上的黄、蓝、黄三个滑块上移一格，下方绿色滑块就能左移了，然后右侧的黄滑块可以下移，最后中间一横行上的绿、蓝、红三个滑块就能一起右移了。</p><p>需要注意的是，这里我们没有对墙和滑块的形状作限制，他们可以是矩形也可以是曲折的甚至是镂空的，所以这个滑块问题是一个很困难的问题，它属于NP-hard的可能性是很高的。为了说明这个问题属于NP-hard，我们需要先找一个NP-hard（或者NPC）问题，然后将它在多项式时间内归约到滑块问题。</p><p>3-SAT问题就是一个经典的NPC问题，其形式简单又较为灵活，经常被作为归约问题用来证明其他问题属于NPC或NP-hard。一个3-合取范式是由若干个子句的合取（可以理解为“与”运算）构成的布尔公式，其中每个子句由3个项的析取（可以理解为“或”运算）构成。例如，<equation>(x_1 \vee x_2 \vee \neg x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)</equation> 是一个含有两个子句的3-合取范式，该公式用到了变量x1~x3。<b>3-SAT</b>（3-conjunctive normal form satisfiability，3-合取范式可满足问题）问题指的是给定一个3-合取范式，判断是否存在对变量的赋值（True或False）使得该公式可满足（真值为True）。</p><h2><b>2.归约基本思路</b></h2><p>我们现在来尝试说明对于3-SAT的任意实例S，可以构造相应滑块游戏的实例T，使得S可满足等价于T有解。</p><p>对于合取范式S我们设置一个滑块来表示，该滑块可以移动到指定位置对应于S可满足，比如像下面这样</p><img src="https://pic1.zhimg.com/v2-aad59582e6905392a63eea2d2f13bdc9_r.jpg" data-caption="" data-rawwidth="169" data-rawheight="206"><p>黑色滑块能够右移一格表示S可满足。但是黑色滑块不能随便右移，它应该被限制在S可满足时才能右移，因此设置一个深紫色滑块予以限制。根据合取范式的结构容易明白深紫色滑块应当在S中的每个子句都满足时才能右移，这说明深紫色滑块代表一个与门，因此我们设置如下结构来模拟与运算</p><img src="https://pic2.zhimg.com/v2-b3acdcded9deeb4c66e5697a768f821e_r.jpg" data-caption="" data-rawwidth="190" data-rawheight="243"><p>上图中，如果我们能限制浅紫色滑块最多只能向右滑动一格的话，深紫色滑块想要右移必须让2个橙色滑块分别移动到浅紫色滑块右移后空出的空间中。当然，上图的与门可以简单地扩展到多个子句的情况上。接着，每个浅紫色滑块自然就应该代表着各个子句啦，它应该是一个或门</p><img src="https://pic3.zhimg.com/v2-9ce5e462153e91facc78255dc1a958a6_r.jpg" data-caption="" data-rawwidth="168" data-rawheight="287"><p>类似地，浅紫色滑块想要右移须让橙滑块移动到任意红色滑块右移后空出的空间中。浅紫色滑块相当于一个或门，对应于S中的3个项的析取构成的子句，而3个红滑块应该分别代表着子句中的3个项。</p><p>另外，对于S涉及到的每个变量xi，我们设置一个滑块与之对应，滑块的位置对应于变量的赋值情况。</p><img src="https://pic4.zhimg.com/v2-0fc9a9fa682faa6fe6217536f18b87ff_r.jpg" data-caption="" data-rawwidth="508" data-rawheight="134"><p>上图中每个绿色滑块对应于一个变量，我们设定滑块在左侧对应于赋值False，在右侧则对应于Ture。容易看出，无论绿滑块的位置如何，每对黄滑块中只有一个滑块可以上移，这对应于变量的赋值只能是Ture和False中的一个。而每个黄滑块也正好对应于一个项xi或┐xi。</p><p>现在表示项xi和┐xi的滑块有了，表示子句中的项的滑块也有了，接下来的问题是如何把它们关联起来。因为简单地延长红滑块和黄滑块的长度来关联的话会出现一个问题，滑块可能会重叠相交。所以，我们<b>需要一个滑块结构来使得“信号”可以同时在垂直和水平两个方向上互不干扰地传递</b>。其实，能完成这个任务的结构已经在第一个滑块问题例子中出现了，在一个3*3的空间中放上一个2*2的滑块便可以使“信号”在垂直和水平两个方向上传递。不过2*2的滑块只能传递一格的“信号”，若想传递更多的信号我们需要放大一下滑块。有了这样的“枢纽”结构，我们将所有黄滑块和红滑块重叠相交的地方都用这个结构来替代就能完成归约了。</p><h2><b>3.归约实例</b></h2><p>我们用一个例子来说明具体的归约构造。对于3-合取范式 <equation>(x_1 \vee x_2 \vee \neg x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)</equation> ，我们构造对应的滑块问题实例T如下图</p><img src="https://pic2.zhimg.com/v2-0df59a9cd697bb63a490abb43d33c99f_r.jpg" data-caption="" data-rawwidth="692" data-rawheight="553"><p>其中，灰色方格为墙方格，白色方格为空方格，其他颜色的方格是滑块，现在问题是黑色滑块能否向右移动一格。需要说明的是：每个子句中的项对应于一个横向的红滑块，与其关联的是对应项的黄滑块（例如第一个子句中的第二个项是x2，因此第二行红色滑块与第三列黄滑块关联，其中由于与第二列黄滑块交叉，因而加入了一个“枢纽”结构）；由于S由两个子句构成，每个子句都可能包含某个项xi或┐xi，因此我们在每个绿色变量滑块的两边预留了2格的空间；这造成垂直方向上需要传递的“信号”数量可能达到2，所以我们将蓝色的“枢纽”滑块放大到2*3；右侧中间的1*1橙色滑块用于“信号”的部分传递。</p><p>显然，这个归约可以在多项式时间内完成。而为了说明归约成立，我们还需要证明S可满足等价于图中的滑块问题有解，这其实也比较容易。</p><p><b>必要性</b>（S可满足→T有解）。那么存在对xi的赋值使得S满足，比如x1=False, x2=True, x3=False。我们根据赋值将绿色滑块移动到对应的位置，然后让所有的黄色滑块尽量的上移，腾出空间让红色滑块尽量的右移。由于S满足，根据我们的构造，每个浅紫色子句滑块对应的3个红滑块中至少有一个可以右移，因此每个子句滑块也能右移，从而深紫色滑块和黑色滑块可以右移，因而滑块问题有解。具体形状见下图</p><img src="https://pic3.zhimg.com/v2-5ccd56a24da2a51eba57509ec30a332e_r.jpg" data-caption="" data-rawwidth="686" data-rawheight="548"><p><b>充分性</b>（T有解→S可满足）。类似地，滑块问题有解说明黑色和深紫色滑块可以右移，说明每个浅紫色子句滑块可以<b>同时</b>右移，说明每个子句滑块对应的3个红滑块至少有一个可以右移，说明与红滑块关联的黄色滑块可以上移，上移的黄滑块决定了绿色变量滑块的位置，这就给出了一组使得S满足的变量赋值。</p><h2><b>4.更多的限制</b></h2><p>之前我们讨论的滑块问题没什么限制，现在我们来对滑块的形状做一些限制，看看它是否仍然属于NP-hard。我们将滑块的形状限制为和“华容道”游戏中一样，只允许有1*1、1*2和2*2的滑块。我们试图在上一节归约方法的基础上做一些改动，使得滑块的形状只有上述3种而归约依然有效。</p><p>我们先来处理比较简单的结构，将之前归约中的绿色变量滑块替换成1*2的形状，这并不会产生滑块功能的改变。其次红色和黄色这两类“长”滑块可以替换成若干个1*1的滑块，而在末端使用1*2的滑块来限制其移动距离。而蓝色“枢纽”滑块不太好处理，在新的限制下，我们只能使用2*2形状的滑块作为枢纽滑块，这将无法处理多个子句包含同一个项的情况。因此，我们尝试着增加每个项在滑块游戏实例中的“列数”来解决这一问题。</p><p>我们用下面这个只使用1*2滑块的结构来扩展“列数”</p><img src="https://pic2.zhimg.com/v2-1d4f3fde5416d36e93eafb498eace0d8_r.jpg" data-caption="" data-rawwidth="377" data-rawheight="141"><p>本来绿色变量滑块只能提供一个“信号”，而通过上面的<b>“复制”结构</b>，使得“信号”数量可以增加到两个。当然重复使用这个结构可以使项的“列数”扩展到任意数量。另外凑巧的是，这个<b>结构逆向使用的话相当于一个与门</b>！如果从右向左看，只有两个黄色滑块同时下移后，绿色滑块才能右移，这不就是一个与运算嘛。好了，之前归约中的与门也可以用限制型滑块替代了，那么只剩下或门了。幸运的是，1*1滑块天然就是或门。</p><p>我们将这些方法整合起来就可以将3-SAT多项式时间归约到有限制的滑块问题。 还是先前的那个例子，公式<equation>(x_1 \vee x_2 \vee \neg x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3)</equation> 对应的有限制的滑块问题T'如下图</p><img src="https://pic2.zhimg.com/v2-fcb22d537168e27b2421e0f801a58a2c_r.jpg" data-caption="" data-rawwidth="590" data-rawheight="370"><p>注意，这里所有的<b>橙色滑块全是1*1的滑块</b>。公式可满足等价于有限制的滑块问题有解的证明与之前是完全类似的，不再重复了。</p><h2><b>5.总结</b></h2><p>我们初步分析了“华容道”游戏的一个推广的滑块游戏问题的计算复杂性。构造了一个从3-SAT问题到滑块游戏问题的多项式时间归约，说明了滑块游戏问题属于NP-hard。对于限制滑块形状只能为1*1、1*2和2*2的滑块游戏问题，我们对归约作了一些改动使得归约依然成立。然而，对于墙方块有所限制（比如墙必须是矩形框不能镂空等）的问题，没想到构造归约的方法。</p><p><br></p><p>PS. 1. 一开始我想直接从SAT即布尔公式可满足问题进行归约的，但是发现非门不好构造，后来就尝试了3-SAT，果然3-SAT不愧为“第一起点归约问题”；2. 我觉得那个“枢纽”结构是规约的关键，其他结构比较方便的，这个结构还有点像机械里面的星型发动机的构造；3. 其实我总觉得这种经典问题的计算复杂性分析应该有人做过了，但是搜了一下没找到，那个寻找N-puzzle问题最优解是NP-hard的，但是感觉N-puzzle和这里的滑块问题不太一样。</p><p><br></p><p><br></p><p>2017.10.7</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
