<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Elementary Monad Become Freer</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/110585547">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-9eb8fec960660da88a7ae6bbabf0bb63_b.jpg" alt=""></div><h2>废话</h2><p>（这篇文章不是monad getting started tutorial）</p><p>自从Haskell作为第一个编程语言，将monad引入软件工程后，各种基于monad实现的库开始纷纷出现。实现一些通常来说需要hack或向语言添加新特性，来做到良好支持的功能变得能通过提供monadic DSL的方法来实现。monad同时也带来了很多争议，不被理解，甚至导致其被整日拿来批判，为什么我实现一个简单的mutable variable还需要用monad？从软件工程上来说，monad并不是一个很高深的东西。很多源于cat theory的复杂性并不是monad在软件工程上使用所必须理解的，虽然懂cat theory确实会对monad有更深入的理解和看法。学会了使用monad后甚至可以在一些完全没有考虑过monad的语言上使用它，而不是局限于Haskell中。所以，如果要解决简单的问题，当然是使用合适的方法，当需要解决的问题使用monad能更容易解决的时候使用monad，而不是一味的批判使用monad孰优孰劣，使用适合的工具解决适合的问题。</p><h2>Elementary Monad</h2><p>一般来说实现一个monadic DSL首先需要定义一个datatype，其具体的定义根据实际的DSL来决定，例如对于如果要实现简单的mutable state的话：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">State</span> <span class="nf">s</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="nf">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">s</span><span class="p">,</span> <span class="nf">a</span><span class="p">))</span></code></pre></div><p>然后分别实现需要的typeclass：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">State</span> <span class="nf">s</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="kt">State</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="nf">t</span><span class="p">,</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">g</span> <span class="nf">s</span> <span class="kr">in</span> <span class="p">(</span><span class="nf">t</span><span class="p">,</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">State</span> <span class="nf">s</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">s</span><span class="p">,</span> <span class="nf">a</span><span class="p">))</span>

  <span class="kt">State</span> <span class="nf">f</span> <span class="o">&lt;*&gt;</span> <span class="kt">State</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span>
    <span class="kr">let</span> <span class="p">(</span><span class="nf">t</span><span class="p">,</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">s</span>
        <span class="p">(</span><span class="nf">u</span><span class="p">,</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">g</span> <span class="nf">t</span>
    <span class="kr">in</span> <span class="p">(</span><span class="nf">u</span><span class="p">,</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">State</span> <span class="nf">s</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">State</span> <span class="nf">g</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span>
    <span class="kr">let</span> <span class="p">(</span><span class="nf">t</span><span class="p">,</span> <span class="nf">a</span><span class="p">)</span>  <span class="ow">=</span> <span class="nf">g</span> <span class="nf">s</span>
        <span class="kt">State</span> <span class="nf">h</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span>
    <span class="kr">in</span> <span class="nf">h</span> <span class="nf">t</span><span class="p">)</span></code></pre></div><p>也许之后还需要进行equational reasoning来保证其符合monad laws，虽然一般来说就直接YOLO了，从工程角度上来说没什么必要www。定义了datatype之后就可以写各种DSL需要用到的function了，这个就完全是自由发挥了。</p><p>但是也存在一些问题，例如对于特定的monadic DSL，其对应的datatype应该如何下手定义？当然如果要运行一个monadic DSL，例如对于mutable state，就需要提供初始的状态，并返回其结果：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">evalState</span> <span class="ow">::</span> <span class="kt">State</span> <span class="nf">s</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">s</span> <span class="ow">-&gt;</span> <span class="nf">a</span></code></pre></div><p>当然也许还需要state monad运行完毕后的最终状态：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">runState</span> <span class="ow">::</span> <span class="kt">State</span> <span class="nf">s</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">s</span><span class="p">,</span> <span class="nf">a</span><span class="p">)</span></code></pre></div><p>就得到了state monad的datatype需要的定义。因为monad只不过是让其可以compose而已。</p><p>但是有时候事情并不是这么简单。例如对于复杂的monad，也许存在一些中间状态，并不需要暴露在外部，就像evalState一样，也许并不需要返回最终状态。又或许写到一半发现需要给monadic DSL添加新的功能，修改datatype的定义的话又会影响到已经写好的DSL function。再或许monadic DSL本身的设计还没有完全确定，那么就会陷入先有鸡还是先有蛋的问题，没有datatype的定义，写不了DSL function，确定不了具体的monadic DSL，写不了datatype的定义，最后需要要一步到位才能解决。另外就是还存在不必要的boilerplate等。</p><h2>Feeling Free</h2><p>这种情况下就可以使用free monad来解决问题，其基本思想是对于任意的functor，自动给出一个monad，monad compose时将其原封不动的构造成一个树形的结构，最后再对其进行解释运行。</p><p>例如对于常用于实现generator、coroutine的yield monad，其要么返回一个值x，要么输出一个o，然后输入一个i，然后继续执行。其基本实现如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">x</span>
  <span class="ow">=</span> <span class="kt">Done</span> <span class="nf">x</span>
  <span class="o">|</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="p">(</span><span class="nf">i</span> <span class="ow">-&gt;</span> <span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">x</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="kt">Done</span> <span class="nf">x</span>  <span class="ow">=</span> <span class="kt">Done</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">f</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">Done</span>

  <span class="kt">Done</span> <span class="nf">f</span> <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">fa</span>
  <span class="kt">Run</span> <span class="nf">o</span> <span class="nf">f</span> <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="p">((</span><span class="o">&lt;*&gt;</span> <span class="nf">fa</span><span class="p">)</span> <span class="o">.</span> <span class="nf">f</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Done</span> <span class="nf">a</span>  <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="kt">Run</span> <span class="nf">o</span> <span class="nf">g</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="nf">f</span><span class="p">)</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span>

<span class="nf">yield</span> <span class="ow">::</span> <span class="nf">o</span> <span class="ow">-&gt;</span> <span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">i</span>
<span class="nf">yield</span> <span class="nf">o</span> <span class="ow">=</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="p">(</span><span class="nf">\i</span> <span class="ow">-&gt;</span> <span class="kt">Done</span> <span class="nf">i</span><span class="p">)</span></code></pre></div><p>这里其实就已经用到了free monad的思想，只不过没有将其写出来，而是inline了进去。</p><p>考虑如下更简单的情况，输出一个o，然后输入一个i，之后直接返回x：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">YieldF</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">x</span> <span class="ow">=</span> <span class="kt">YieldF</span> <span class="nf">o</span> <span class="p">(</span><span class="nf">i</span> <span class="ow">-&gt;</span> <span class="nf">x</span><span class="p">)</span></code></pre></div><p>其本身是一个functor，但并不是monad：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">YieldF</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="p">(</span><span class="kt">YieldF</span> <span class="nf">o</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">YieldF</span> <span class="nf">o</span> <span class="p">(</span><span class="nf">f</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span></code></pre></div><p>先给出free monad的定义：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Free</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="ow">=</span> <span class="kt">Pure</span> <span class="nf">a</span>
  <span class="o">|</span> <span class="kt">Impure</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Free</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="kt">Pure</span> <span class="nf">a</span>   <span class="ow">=</span> <span class="kt">Pure</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="kt">Impure</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kt">Impure</span> <span class="p">(</span><span class="nf">fmap</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">f</span><span class="p">)</span> <span class="nf">g</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Free</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">Pure</span>

  <span class="kt">Pure</span> <span class="nf">f</span>   <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">fa</span>
  <span class="kt">Impure</span> <span class="nf">f</span> <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="kt">Impure</span> <span class="p">(</span><span class="nf">fmap</span> <span class="p">(</span><span class="o">&lt;*&gt;</span> <span class="nf">fa</span><span class="p">)</span> <span class="nf">f</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Free</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Pure</span> <span class="nf">a</span>   <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="kt">Impure</span> <span class="nf">g</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Impure</span> <span class="p">(</span><span class="nf">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="nf">f</span><span class="p">)</span> <span class="nf">g</span><span class="p">)</span></code></pre></div><p>然后可以使用free monad从<code>YieldF</code>重新定义yield monad：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="ow">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">YieldF</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span></code></pre></div><p>如果仔细看free monad的定义可以发现其实free monad就是给特定的functor加上<code>Pure</code>作为tree的leaf，并使用<code>Impure</code>作为tree的branch，使得functor可以嵌套。简单来说<code>pure</code> 、<code>return</code>返回一个新的leaf， <code>&gt;&gt;=</code>对原来的tree通过<code>fmap</code>对其内部branch所有的leaf都进行扩展，来返回一个新的tree。要运行的话就对这个tree进行解释就可以了。</p><p>free monad解决了boilerplate的问题，并让任意的functor都可以变成monad。或许还额外让不进行equational reasoning更有理由了www，毕竟只要满足functor laws就自动满足monad laws了。而大部分情况下的functor都是可以直接deriving出来的。</p><p>但是free monad也存在一些问题，例如每次compose都需要对整个tree进行fmap www</p><h2>Become Freer</h2><p>freer monad是升级版的free monad。如果说free monad对于任意的functor，能自动给出一个monad的话，freer monad就能对任意的type constructor，给出一个monad。</p><p>当然，freer monad也许还有更好的解释，那就是对任意type constructor，首先给出一个free functor，然后再将这个functor通过free monad变成monad，free functor的定义如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">FreerF</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="nf">forall</span> <span class="nf">x</span><span class="o">.</span> <span class="kt">FreerF</span> <span class="p">(</span><span class="nf">x</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">FreerF</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="p">(</span><span class="kt">FreerF</span> <span class="nf">g</span> <span class="nf">fa</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FreerF</span> <span class="p">(</span><span class="nf">f</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span> <span class="nf">fa</span></code></pre></div><p>free functor对任意的<code>f x</code>，每<code>fmap</code>一次，就将对应的<code>f</code>compose到之前的<code>g</code>最后。</p><p>然后再将free functor变得更加freer：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">FreerF</span> <span class="nf">f</span><span class="p">)</span></code></pre></div><p>当然标准做法是直接丢掉<code>Free</code>，将其inline：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="ow">=</span> <span class="kt">FPure</span> <span class="nf">a</span>
  <span class="o">|</span> <span class="nf">forall</span> <span class="nf">x</span><span class="o">.</span> <span class="kt">FImpure</span> <span class="p">(</span><span class="nf">x</span> <span class="ow">-&gt;</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Freer</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="p">(</span><span class="kt">FPure</span> <span class="nf">a</span><span class="p">)</span>      <span class="ow">=</span> <span class="kt">FPure</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="p">(</span><span class="kt">FImpure</span> <span class="nf">g</span> <span class="nf">fx</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">f</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span> <span class="nf">fx</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Freer</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">FPure</span>

  <span class="kt">FPure</span> <span class="nf">f</span>      <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">fa</span>
  <span class="kt">FImpure</span> <span class="nf">f</span> <span class="nf">fx</span> <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">((</span><span class="o">&lt;*&gt;</span> <span class="nf">fa</span><span class="p">)</span> <span class="o">.</span> <span class="nf">f</span><span class="p">)</span> <span class="nf">fx</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Freer</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">FPure</span> <span class="nf">a</span>      <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="kt">FImpure</span> <span class="nf">g</span> <span class="nf">fx</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="nf">f</span><span class="p">)</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span> <span class="nf">fx</span> </code></pre></div><p>到这里就可以用freer monad玩一些很fancy的东西，可以将monadic DSL和对DSL的解释完全分开，解决chicken or egg problem：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">lift</span> <span class="ow">::</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">a</span>
<span class="nf">lift</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="kt">FPure</span> <span class="nf">fa</span>

<span class="kr">data</span> <span class="kt">YieldEff</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">x</span> <span class="kr">where</span>
  <span class="kt">Yield</span> <span class="ow">::</span> <span class="nf">o</span> <span class="ow">-&gt;</span> <span class="kt">YieldEff</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">i</span>

<span class="kr">type</span> <span class="kt">EffYield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="ow">=</span> <span class="kt">Freer</span> <span class="p">(</span><span class="kt">YieldEff</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span>

<span class="nf">yield</span> <span class="ow">::</span> <span class="nf">o</span> <span class="ow">-&gt;</span> <span class="kt">EffYield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">i</span>
<span class="nf">yield</span> <span class="nf">o</span> <span class="ow">=</span> <span class="nf">lift</span> <span class="p">(</span><span class="kt">Yield</span> <span class="nf">o</span><span class="p">)</span></code></pre></div><p>甚至还可以在freer monad上继续扩展，进化为extensible effect，只不过这就超纲不是这篇文章的内容了www</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
