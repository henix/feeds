<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>数学、英语对程序员来说重要吗？记线性秘密分享方案（Linear Secret Sharing Scheme，LSSS）的实现</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/21664741">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/495989616cfd91da906072ad3934d76f_r.jpg" alt=""></div><h2>前言</h2>昨天晚上我终于完成了公钥密码学基于属性加密（Attribute-Based Encryption，ABE）中的一个核心模块：线性秘密分享方案（Linear Secret Sharing Scheme，LSSS）的实现。这个模块的实现是困扰我将近1年的一个问题，我相信也是国内（以及国外）众多公钥密码学研究者一直困扰的问题。所以，我相信此代码会给ABE的研究人员，特别是国内ABE的研究人员提供帮助。不过，由于我代码注释能力不太过关，并且这个程序的调用方法确实需要一些背景知识，因此我准备撰写一个专栏或者博客，和朋友们分享LSSS的概念，理论问题和实现问题。<p>相关源代码已在GitHub上发布：<a href="https://github.com/liuweiran900217/CloudCrypto" class="">https://github.com/liuweiran900217/CloudCrypto</a>。这实际上是我维护的一个密码学函数库，其中已经包含了IBE、HIBE、Revocable Encryption，以及我部分发表论文的代码实现了。如果有类似需求的朋友们，也可以参考这个代码，进行修改或者直接调用。有关本模块得使用方法参见<a href="https://github.com/liuweiran900217/CloudCrypto/tree/master/src/test/java/com/example/access" class="">https://github.com/liuweiran900217/CloudCrypto/tree/master/src/test/java/com/example/access</a>中的测试代码。对应的具体代码和解析见下文。这个代码也用了很多设计模式，我想实现的目的是：只要稍微知道原理，就可以在不知道具体实现的前提下，直接调用各种方法实现LSSS或者相关方案。这里也希望知乎的大V们批评指导，是否此源代码达到了这个目的呢？</p><p>源代码也参考了下面两个开源的实现。我这里想说明的是，代码的使用虽然是免费的，但如果觉得代码好用，恳求朋友们给个Star或者给个Watch，这也是对我继续完善CloudCrypto库的鼓励嘛…</p><br><ul><li>源代码参考了其它开源的代码和程序。有关访问控制政策（Access Policy）解析器的代码，参考了北京大学的李聪同学及其师兄的代码：<a href="https://github.com/cleverli2008/ABE" class="">https://github.com/cleverli2008/ABE</a>。<br></li><li>源代码参考了来自Raytheon BBN Technologis上P3S项目中有关LSSS的部分代码。不过，这个代码中有很多Bug，基本判断是不能使用的。我参考了其代码结构，特别是访问控制树（Access Tree）的输入方法：<a href="https://dsl-external.bbn.com/tracsvr/openP3S/browser/trunk/jmiracl-crypto/src/main/java/com/bbn/projects/spar/p3s/jmiracl/crypto" class="">https://dsl-external.bbn.com/tracsvr/openP3S/browser/trunk/jmiracl-crypto/src/main/java/com/bbn/projects/spar/p3s/jmiracl/crypto</a>。</li></ul><br><p>我开始时在犹豫这篇文章应该发表在知乎专栏上，还是应该发表在CSDN上。要说这种比较技术，比较偏重于实现的文章应该发表到CSDN上的。但是，这几天我在知乎一直看到这样的问题：<a href="https://www.zhihu.com/question/48617074" class="" data-editable="true" data-title="程序员不需要知道太多数学，你认同吗？">程序员不需要知道太多数学，你认同吗？</a>，或者这种问题：<a href="https://www.zhihu.com/question/26630519" class="" data-title="英语对程序员来讲有多重要？会英语的程序员和不会英语的程序员有什么差距？" data-editable="true">英语对程序员来讲有多重要？会英语的程序员和不会英语的程序员有什么差距？</a>因此，我不再犹豫，决定把这个文章发表在知乎专栏上。</p><p>我对上面这两个问题的看法随时间的推移而发生了巨大的改变。回想起我本科的时候，对上面这两个问题的答案是：<b>程序员不需要知道太多数学，程序员不需要学习太多的英语。</b>然而，随着时间的推移，我发现本科时我对这两个问题的理解完全是错误的。现今，我看到以互联网企业为代表的科技类企业，越来越注重招收数学、计算机基础相关的硕士、博士生，我对此种现象表示强烈的认同。如果现在让我回答这两个问题的话，我会毫不犹豫地回答：<b>程序员需要扎实的数学基础，需要过硬的英语阅读能力</b>。当然，口说无凭，我想借助LSSS的实现，向朋友们说明为什么程序员需要数学、英语技能。另外，程序员实际上还需要过硬的计算机基础知识。我作为非科班出身，这方面同样比较薄弱，因此LSSS的实现还有一个问题我没有解决。希望毕业前最后不到1年的时间，我能好好补一补计算机基础知识，把这个问题解决。我同样把问题抛给知友们，如果你有能力解决这个问题，欢迎和我联系~</p><p>如果朋友们认为此专栏中我的一些理解并不准确，也欢迎和我讨论。</p><h2>ABE、访问控制政策、访问控制树的概念</h2><p>在讲此模块的实现之前，就不得不要讲解一下ABE、访问控制政策、访问控制树、LSSS的概念了。别急，我们一个一个来。</p><p>基于属性加密（Attribute-Based Encryption，ABE）是基于身份加密（Identity-Based Encryption）的扩展。有关IBE的介绍，请参考知乎问题：<a href="https://www.zhihu.com/question/26533817" class="" data-title="基于身份的密码体制是什么？" data-editable="true">基于身份的密码体制是什么？</a>我的答案基本上可以看作截止到2013年的IBE小综述。<a href="https://www.zhihu.com/people/li-fei-42-50" class="" data-editable="true" data-title="@李飞">@李飞</a>同学在后面补充了的答案中，就提到了ABE的开山之作[1]。Sahai和Waters首先定义了ABE[1]，他们指出在ABE中：</p><ul><li>加密的文件被一个属性集合所标识，里面包含n个属性，每个属性用一个有意义的字符串来描述（如：某个大学或机构的名称、文档等级等）；</li><li>用户的私钥也被一个属性集合所标识，里面包含m个属性，每个属性同样用有意义的字符串来描述；<br></li></ul><p>解密时，方案会自动对私钥属性集合和密文属性集合作交集，如果属性交集的个数大于等于某个阈值t，则可以解密成功。举个例子，加密文件对应的属性集合为<equation>S=\{\text{Computer}, \text{Professor}, \text{High-level}\}</equation>，阈值t设置为2。</p><ol><li>某个老师拥有的属性集合为<equation>S_1 = \{\text{Computer},\text{Professor}\}</equation>，我们有<equation>|S_1 \cap S| = |\{\text{Computer},\text{Professor}\}|=2</equation>，则这个老师就可以用其私钥解密文档。<br></li><li>某个学生拥有的属性集合为<equation>S_2=\{\text{Computer},\text{Student},\text{High-level}\}</equation>，我们有<equation>|S_2 \cap S| = |\{\text{Computer},\text{High-level}\}|=2</equation>，则这个学生也可以用其私钥解密文档。</li><li>某个学生拥有的属性集合为<equation>S_3 = \{\text{Software},\text{Professor},\text{Low-level}\}</equation>，我们有<equation>|S_3 \cap S| = |\{\text{Professor}\}|=1</equation>，则这个老师就不能用其私钥解密文档。</li></ol><p>我们可以看到，这种方法已经可以实现比较灵活的访问控制了，不过还没达到特别灵活，毕竟加密文件和私钥所对应的都是属性集合，还没有实现真正意义上的访问控制政策（Access Policy），或者称访问控制结构（Access Structure）。那么，什么叫作访问控制政策呢？早在1996年，Beimel在其博士毕业论文中就定义了访问控制政策，以及单调访问控制政策（Monotone Access Policy）[2]，我们来看一看定义[2,3]，英文的定义最为精确和严谨：</p><blockquote>Let <equation>\mathcal{P} = \{P_1, P_2, \cdots, P_n\}</equation> be a set of parties. A collection <equation>\mathbb{A} \subseteq 2^{\{P_1, P_2, \cdots, P_n\}}</equation> is monotone if for any <equation>B</equation> and <equation>C</equation>: if <equation>B \in \mathbb{A}</equation> and <equation>B \subseteq C</equation> then <equation>C \in \mathbb{A}</equation>. An access structure (respectively, monotone access structure) is a collection (respectively, monotone collection) <equation>\mathbb{A}</equation> of non-empty subsets of <equation>\{P_1, P_2, \cdots, P_n\}</equation>, i.e., <equation>\mathbb{A} \subseteq 2^{\{P_1, P_2, \cdots, P_n\}} \backslash \{\emptyset\}</equation>. The sets in <equation>\mathbb{A}</equation> are called the authorized sets, and the sets not in <equation>\mathbb{A}</equation> are called the unauthorized sets.</blockquote><p>上述描述非常的清楚，请理解上文后继续往后看...</p><p>在Sahai和Waters提出ABE概念的下一年，Goyal，Pandey，Sahai和Waters真正实现了支持访问控制政策的ABE方案[4]。他们将访问控制政策描述为树（Access Tree）的形式，如下图：</p><p><img src="https://pic4.zhimg.com/f8e78e95653f138d37a89c0511e2c138_r.jpg" data-rawwidth="520" data-rawheight="170">上图中，每个叶子节点都是一个属性，非叶子节点为一个门限节点（Threshold Gate/Node），里面的数据形式为(n, t)，表示：此节点一共有n个子节点，只要有t个子节点满足条件，那么此节点也满足条件。解密时，只要属性集合使得访问控制树的根节点满足条件，就可以正确解密。</p><p>访问控制树带来了极为方便的访问控制描述形式，其直接覆盖了所谓单调布尔代数访问控制政策（Montone Boolean Formula）的描述形式：对于AND，其门限节点形式为(n, n)；对于OR，其门限节点形式为(n, 1)。举个例子，对于访问控制政策</p><equation>\text{(A and B and C) and (D or E or F) and (G and H and (I or J or K or L))}</equation><br><p>其对应的访问控制树为：</p><img src="https://pic4.zhimg.com/b7973042122e2ea6c84e48db95247e36_r.jpg" data-rawwidth="520" data-rawheight="170"><p>对于这个访问控制树，下述属性集合满足条件（所列举的并未覆盖所有满足的属性集合）：</p><ul><li>{A, B, C, E, G, H, K}</li><li>{A, B, C, E, F, G, H, I, J, K, L}</li></ul><p>下述属性集合不满足条件：</p><ul><li>{A, B, C, G, H, K}</li><li>{A, B, C, E, G, K}</li><li>{A, B, C, D, G, H}</li></ul><p>那么，访问控制树应该放在哪里呢？Goyal等人指出，如果私钥用访问控制树标识，加密文件用属性集合标识，此种ABE称为私钥策略ABE（Key-Policy ABE，KP-ABE）；反之，如果私钥用属性集合标识，加密文件用访问控制树标识，此种ABE称为密文策略ABE（Ciphertext-Policy ABE，CP-ABE）。Goyal等人构造了第一个KP-ABE[4]。再往后一年，Bethencourt，Sahai和Waters构造了第一个CP-ABE[5]。同时，Bethencourt等人公开了其CP-ABE的实现代码，这使得ABE的研究前进了一大步，毕竟人们有代码参考了嘛。<br></p><br><p>说到这里，就要讲点黑历史了。虽然Bethencourt等人给出了CP-ABE的实现，但是那个实现实在是太<b>脏</b>了！那个代码使用C语言编写的，代码结构非常凌乱，程序的撰写思路特别的面向过程，基本上只能用来测测时间… 不过，那个代码几乎解决了所有ABE的实现问题，具体哪些问题我们后面来讲。</p><p>在访问控制树的实现中，最为核心的是门限节点（非叶子节点）的实现。在2007年以前的ABE论文，以及2008年以后非密码学会议/期刊上的ABE论文中，都使用了同样的方法进行实现，这就是密码学中非常著名的Shamir秘密分享方案。Shamir就是RSA算法中的“S”，他实际上为密码学做出了很多突出的贡献。比如前文最先提到的IBE概念也是他提出来的[6]。第一个秘密分享方案也是它提出来的[7]。</p><p>我这里需要稍微介绍一下Shamir秘密分享方案的基本思路。Shamir秘密分享方案的目的是，给n个人分享秘密，只要n个人中的t个人（t &lt;= n）在一起，就能够把秘密恢复出来。这就好像一个保险柜有n把钥匙，只要t个人在场，就能够把保险柜打开。Shamir秘密分享方案利用了拉格朗日多项式差值方法，其基本思想是：如果预先定义了一个t-1阶的多项式，那么如果知道这个多项式上的t个点，则一定能完整恢复出这个多项式。假设所要分享的秘密是s，我们任取t-1个随机数<equation>a_1, a_2, \cdots, a_{t-1}</equation>，构造一个t-1阶多项式<equation>f(x)=a_{t-1}x^{t-1}+a_{t-2}x^{t-2}+\cdots+a_1x+s</equation>。对于每个用户<equation>i,1 \leq i \leq n</equation>，其分享结果为<equation>(i,f(i))</equation>。这样，当t个用户在场时，就可以使用拉格朗日插值公式恢复出多项式<equation>f(x)</equation>，从而得到秘密s了。</p><p>在访问控制树中，我们就采取类似的方法，加密的密钥s放置在根节点上，对于每一个门限节点（非叶子节点），我们都构造一个多项式。利用Shamir秘密分享方案，将密钥s一层一层地分享下去，最后给到叶子节点。解密时，满足解密条件的用户手上拥有恢复s的足够信息，就可以把密钥s恢复出来了。</p><p>对于布尔代数描述的访问控制政策来说，AND意味着构造一个n-1阶多项式；OR意味着构造一个0阶多项式，实际上就是把秘密直接传给孩子节点。对于上述给定的访问控制政策：</p><equation>\text{(A and B and C) and (D or E or F) and (G and H and (I or J or K or L))}</equation><br><p>一共有3个AND，根据门限节点中门限值的不同，分别构造3个多项式为：</p><equation>f_0(x)=a_{0,2}x^2 + a_{0,1}x + s</equation><br><equation>f_1(x)=a_{1,2}x^2+a_{1,1}x+f_0(1)</equation><br><equation>f_2(x)=a_{2,2}x^2+a_{2,1}x+f_0(3)</equation><br><p>对应的分享结果如下图所示：</p><img src="https://pic4.zhimg.com/c56bc02b8ad06adc6c1ae6508bff9d12_r.jpg" data-rawwidth="529" data-rawheight="180"><p>访问控制树的实现相对比较简单，我就不过多介绍了。拉格朗日差值的实现位于<a href="https://github.com/liuweiran900217/CloudCrypto/blob/master/src/main/java/cn/edu/buaa/crypto/access/tree/LagrangePolynomial.java" class="">https://github.com/liuweiran900217/CloudCrypto/blob/master/src/main/java/cn/edu/buaa/crypto/access/tree/LagrangePolynomial.java</a>。访问控制树的实现位于<a href="https://github.com/liuweiran900217/CloudCrypto/blob/master/src/main/java/cn/edu/buaa/crypto/access/tree/AccessTreeEngine.java" class="">https://github.com/liuweiran900217/CloudCrypto/blob/master/src/main/java/cn/edu/buaa/crypto/access/tree/AccessTreeEngine.java</a>。</p><h2>线性秘密分享方案（Linear Secret Sharing Scheme，LSSS）</h2><p>既然已经实现了ABE方案，为什么又来了个LSSS呢？实际上，LSSS是Shamir秘密分享方案的一般性推广。密码学界已经提出了很多秘密分享方案，具有更好的效率和更佳的安全性。然而，无论所提出的秘密分享方案是什么，只要是线性的，我们都可以用同一个模型来描述[2]，这就是线性秘密分享方案了。我们来看看定义[2,3]：</p><blockquote>A secret sharing scheme <equation>\Pi</equation> over a set of parties <equation>\mathcal{P}</equation> is called linear (over <equation>\mathbb{Z}_p</equation>) if:<br>(1) the sares for each party form a vector over <equation>\mathbb{Z}_p</equation>.<br>(2) there exists a matrix <equation>M</equation> called the share-generating matrix for <equation>\Pi</equation>. The matrix <equation>M</equation> has m rows and d columns. For <equation>i=1,\ldots,m</equation>, the <equation>i^{\text{th}}</equation> row <equation>M_i</equation> of <equation>M</equation> is labeled by a party <equation>\rho(i)</equation> where <equation>\rho</equation> is a function from <equation>\{1, 2, \ldots, m\}</equation> to <equation>\mathcal{P}</equation>. Given a column vector <equation>\vec v = (s, r_2, \ldots, r_d)</equation>, where <equation>s \in \mathbb{Z}_p</equation> is the secret to be shared and <equation>r_2, \ldots, r_d \in \mathbb{Z}_p</equation> are randomly chosen, <equation>M \vec v</equation> is the vector of m shares of the secret s according to <equation>\Pi</equation>. The share <equation>\lambda_i = \left(M \vec v\right)_i</equation>, i.e., the inner product <equation>M_i \cdot \vec v</equation> belongs to party <equation>\rho(i)</equation>.</blockquote><p>一看定义，懵逼了… 虽然给出了s的分享方法（一个矩阵相乘就结束了，非常方便快捷），但是完全没给出LSSS的具体构造啊。实际上，Beimel本人是个学数学的，它只是证明了类似的方案都可以转换成这种形式，但是没给出具体怎么转换。更为严重的是，它确实证明了存在方法，当满足LSSS分享条件时，就一定可以恢复出秘密s，但是其没给出具体算法，来看看定义[2,3]：</p><blockquote>Any LSSS defined as above enjoys the linear reconstruction property defined as follows. Suppose that <equation>\Pi</equation> is an LSSS for access structure <equation>\mathbb{A}</equation>. Let <equation>S \in \mathbb{A}</equation> be an authorized set, and <equation>I \subset \{1, \ldots, m\}</equation> be defined as <equation>I = \{i: \rho(i) \in S\}</equation>. There exist constants <equation>\{\omega_i \in \mathbb{Z}_p\}_{i \in I}</equation> satisfying <equation>\sum_{i \in I}{\omega_i M_i} = (1, 0, \ldots, 0) </equation>, so that if <equation>\{\lambda_i\}</equation> are valid shares of any secret s according to <equation>\Pi</equation>, then <equation>\sum_{i \in I}{\omega_i \lambda_i} = s </equation>. Furthermore, these constants <equation>\{\omega_i\}</equation> can be found in time polynomial in the size of the share-generating matrix M. For any unauthorized set, no such constants exists. The LSSS is denoted by <equation>(M, \rho)</equation>.</blockquote><p>读完了上述段落，是不是有一种想摔键盘的冲动… 我靠，这不是数学中大法：存在性吗！</p><ol><li>数学上证明了一定存在<equation>\{\omega_i\}</equation>，但没说怎么求。</li><li>Beimel根本没给出如何给定一个访问控制政策，将其转换成LSSS中矩阵M的方法。<br></li></ol><br><p>这，就是我们要解决的两个问题（其实还有第三个问题）。试问，如果在互联网公司中，老大给了这么一个类似的任务（比如根据论文实现这个算法，Machine Learning和Deep Learning相关的工作中经常会遇到吧？），没有数学和英语的功底，如何去解决呢？</p><h2>理论分析：如何求解常数omega</h2><p>我们先来解决第2个问题，如果我们知道给定属性集合一定可以恢复秘密的话，如何求每个属性对应的<equation>\omega_i</equation>。我们来试着推导一下。</p><p>Step 1：我们知道，<equation>\vec \lambda = M \cdot \vec v</equation>，而我们的目的是恢复出<equation>\vec v</equation>的第一个项，也就是我们的秘密s，那么最直观的方法就是对M求逆嘛~ 但这会遇到一个问题，M并不是方阵，没办法求逆。不过，反过来想，既然我们想恢复s，是不是只要对M的某个子阵求逆呢？换句话说，如果给定的属性集合一定可以恢复秘密的话，我们是否一定能把M化简为一个满秩矩阵呢？答案是肯定的，否则属性集合无法提供足够的信息来恢复s。</p><p>Step 2：矩阵M的行数是<equation>\rho</equation>的总个数，列数代表什么呢？实际上就代表了这个秘密至少需要多少方参与才能恢复。但是，从访问控制政策上考虑，即使满足列的数量，也不一定能够恢复出秘密，比如{A or B) and (C or D}，如果属性集合是{A, B}的话也不可以。实际上，这种情况映射到M上，意味着A和B对应的行是重复的，即互相之间可以线性表示。因此，只要我们在给定属性集合中找到一个子集，使得子集对应的M行所组成的子阵满足满秩就可以了。</p><p>Step 3：然而，我们如何找到这个子阵呢？我们要用到单调性这个特性了。单调性意味着，如果属性集合中有更多的属性，则其满足访问控制政策的能力也就更强。反过来也就意味着，如果一个属性是冗余的，那么即使去掉这个属性，所对应的子属性集合也一定能满足访问控制政策。既然如此，最简单的方法就是一个一个试：先看给定的属性集合是否满足访问控制政策，如果满足，依次去除各个属性，再看是否满足：</p><ul><li>如果子属性集合依然满足访问控制政策，则删掉M中对应的行；</li><li>如果子属性集合不能满足访问控制政策，则M中对应的行要保留；</li></ul><p>通过这种方法，我们就能在线性时间内找到一个M的子矩阵M‘，其对应的分享为<equation>\vec \lambda'</equation>，M'满足可逆性，则我们就能恢复出秘密向量<equation>\vec v</equation>。</p><p>Step 4：实际上我们能拿到秘密s就可以了，因此，我们有：</p><equation>s = (1, 0, \ldots, 0) \cdot \vec v = (1, 0, \ldots, 0) \cdot M'^{-1} \vec \lambda'</equation><br><p>因此，我们可以先计算左边的相乘结果，所得到的结果是什么呢？就是我们要求的<equation>\{\omega_i\}</equation>嘛：</p><equation>\vec \omega = (1, 0, \ldots, 0) \cdot \vec M'^{-1}</equation><br><p>这还意味着，在求<equation>\{\omega_i\}</equation>时，我们完全不需要知道<equation>\vec \lambda</equation>，只要知道LSSS的矩阵M，以及知道能够满足恢复s条件的属性集合就可以了。</p><p>源代码中的抽象类LSSSPolicyEngine给出了LSSS秘密分享，以及求解<equation>\omega</equation>的具体实现，链接为：<a href="https://github.com/liuweiran900217/CloudCrypto/blob/master/src/main/java/cn/edu/buaa/crypto/access/lsss/LSSSPolicyEngine.java" class="">https://github.com/liuweiran900217/CloudCrypto/blob/master/src/main/java/cn/edu/buaa/crypto/access/lsss/LSSSPolicyEngine.java</a>。</p><h2>理论分析：如何构造LSSS矩阵</h2>下一个问题是，如何构造LSSS矩阵呢？这个还真不是程序员能解决的问题，还得靠学者呀！2010年，Lewko和Waters在其论文中[8]给出了一个LSSS的构造方法：给定一个访问控制树，只要是AND和OR描述的，都能转换为LSSS方案。这篇论文还有个完整版本，发表在EUROCRYPT 2011上[9]，只不过由于篇幅限制，会议版本的论文把这段删掉了…<p>Lewko和Waters给出的方案非常“简单”，用了两段话就描述完了，我们来看看[8]：</p><blockquote>We now describe a general algorithm for converting a boolean formula into an equivalent LSSS matrix. We consider the boolean formula as an access tree, where interior nodes are AND and OR gates and the leaf nodes correspond to attributes. We will use <equation>(1,0,\ldots,0)</equation> as the sharing vector for the LSSS matrix. We begin by labeling the root node of the tree with the vector (1)(a vector of length 1). We then go down the levels of the tree, labeling each node with a vector determined by the vector assigned to its parent node. We maintain a global counter variable c which is initialized to 1.<br><br>If the parent node is an OR gate labeled by the vector v, then we also label its children by v (and the value of c stays the same). If the parent node is an AND gate labeled by the vector v, we pad v with 0’s at the end (if necessary) to make it of length c. Then we label one of its children with the vector <equation>(v|1)</equation> (where | denotes concatenation) and the other with the vector <equation>(0,\dots, 0 | -1)</equation>, where <equation>(0, \ldots, 0)</equation> denotes the zero vector of length c. Note that these two vectors sum to <equation>(v|0)</equation>. We now increment the value of c by 1. Once we have finished labeling the entire tree, the vectors labeling the leaf nodes form the rows of the LSSS matrix. If these vectors have different lengths, we pad the shorter ones with 0’s at the end to arrive at vectors of the same length.</blockquote><p>好了，如果我们给定一个访问控制树，就可以用上述方法进行转换了，读起来很简单的样子。不过，如何描述一个访问控制树呢？在搜索过程中，我发现了Raytheon BBN Technologis上P3S项目中的LSSS源代码。不过，这个代码虽然声称实现了LSSS，但里面有两个问题：</p><ul><li>没有解决我们前面提到的M矩阵变方阵的问题，在代码的utils/LSSS.java中的164行和171行注释也提到了：</li></ul><code lang="text">TODO: reduce attribtues to min authorized set</code><ul><li>他们的LSSS实现基于Liu等人的方案[3]，但是不知是实现问题还是原始方案问题，这个方法在有些情况下并不能实现正确的转换。</li></ul><p>不过，这个代码提供了一个很好的描述访问控制树的方法，具体方法在utils/LSSS.java的注释中写明了：</p><blockquote><code lang="text"> * An access structure is represented using as an int[][] array
 * with row indexes being the node ids and each row describes a node (k of n )threshold and list of children nodes or leafs).
 * A leaf node has a negative index &lt;br&gt; 
 * Example: from the paper See http://eprint.iacr.org/2010/374&lt;br&gt;
 * int access[][]={
 *      {2,2,1,2}, //the root node 0 is a 2of2 threshold and its children are nodes 1 and 2 (at rows 1 and 2) &lt;br&gt;
 *      {2,1,3,4}, //node 1 is a 1of2 threshold and its children are nodes 3 and 4 &lt;br&gt;
 *      {4,3,-5,-6,-7,-8}, //node 2 note that -5 here correponds to index of attribute E in the alphabet&lt;br&gt;
 *      {2,2,-2,5}, //node 3 &lt;br&gt;
 *      {3,2,-3,-4,-5}, //node 4 &lt;br&gt;
 *      {2,1,-1,-3} //node 5 &lt;br&gt;
 *      }; &lt;br&gt;
 * The number of rows in the LSSS matrix equal to the number of leaves &lt;br&gt;
 * The number of cols is 1+sum_i(t_i -1) where t_i is the threshold of non leaf nodes i
 *
 * Notice that it is easy to retrieve the children of a node in order.
 * We use this structure to avoid having to construct/traverse trees especially
 * since the parent relation is not needed in the LSSS construction algorithm &lt;br&gt;
 *
 * Objects are immutable
 * @author jkhoury
 *
 */</code></blockquote><p>根据这个注释，我们前面的访问控制政策：</p><equation>\text{(A and B and C) and (D or E or F) and (G and H and (I or J or K or L))}</equation><br><p>就可以写为：</p><code lang="text">int[][] accessPolicy = new int[][] {
{  3,  3,  1,  2,  3,}
{  3,  3, -1, -2, -3,}
{  3,  1, -4, -5, -6,}
{  3,  3, -7, -8,  4,}
{  4,  1, -9,-10,-11,-12,}
};</code><p>更棒的是，这种描述方式还可以描述任意带有门限节点的访问控制政策。这为后面我们代码的扩展带来了便利。</p><p>最终，以李聪同学给出的代码作为参考，Lewko和Waters的LSSS方案实现放置在了<a href="https://github.com/liuweiran900217/CloudCrypto/blob/master/src/main/java/cn/edu/buaa/crypto/access/lsss/lsw10/LSSSLW10Engine.java" class="">https://github.com/liuweiran900217/CloudCrypto/blob/master/src/main/java/cn/edu/buaa/crypto/access/lsss/lsw10/LSSSLW10Engine.java</a>中。</p><h2>实现分析：如何解析访问控制政策</h2><p>在实际中，我们总不能让用户输入一个int[][]吧，这也太不方便了… 我们更希望用户能够直接输入一个用字符串表示的访问控制政策，比如直接输入：</p><equation>\text{(A and B and C) and (D or E or F) and (G and H and (I or J or K or L))}</equation><br><p>我们应该提供一个工具，把这个访问控制政策直接转换成树的形式，这才方便嘛~</p><p>这是我们实现中遇到的第3个问题。这个问题在Bethencourt等人给出的CP-ABE中已经实现了，其方法就是用yacc自己写了个Parser...更为关键的是，他们进一步实现了数值属性，如年龄、发布时间等的解析方法，从而实现了属性的比较功能。具体代码参见：<a href="http://acsc.cs.utexas.edu/cpabe/">http://acsc.cs.utexas.edu/cpabe/</a>。我自己还没有学过Parser，如果有朋友可以对这个C代码中的Parser进行分析，并用Java实现的话，欢迎联系我。</p><p>不过，我们还是能做一些事情的，如果访问控制政策中包含AND、OR，不包含数值属性的话，我们实现了一个简化版的Parser。其代码参见了李聪同学提供的Parser。对应代码为<a href="https://github.com/liuweiran900217/CloudCrypto/tree/master/src/main/java/cn/edu/buaa/crypto/access/parser">https://github.com/liuweiran900217/CloudCrypto/tree/master/src/main/java/cn/edu/buaa/crypto/access/parser</a>。使用时，只要调用ParserUtils里面的GenerateAccessPolicy方法，就可以将一个字符串描述的访问控制政策转换为访问控制树的形式了。</p><h2>总结与未来展望</h2><p>LSSS的实现只是ABE实现的基础。因为秘密分享方案无法解决共谋攻击的问题：假设用户1拥有属性A，用户B拥有属性B，加密文件对应的访问控制政策为A and B，我们应该要求用户1和用户2合谋后仍然不能解密文件。然而，只使用秘密分享方案或者LSSS是无法解决这个问题的。这就需要借助双线性映射和密码学的思路了。有关ABE的实现，我会逐渐测试后更新到GitHub中，敬请期待。</p><p>不知朋友们看完这篇专栏的感受是什么？我相信，这个问题，或者类似问题的解决，肯定不是会写程序就能完成的，还需要一定的数学、英语积累，以及信息检索的能力。<b>我数学并不好（没有专心系统学习过数学），英语也一般般（六级450分在此，知道我其它背景的朋友们求匿，别打我…）</b>，因此功能实现花费了接近1年的时间才最终找到了方法。同时，<b>我完全没有计算机基础（特指编译原理）</b>，因此有关Parser的实现只能借助其他人的成果。相信在未来的工作中，我一定会为这些知识的缺失而付出代价。</p><p>所以，朋友们，如果还有人说：程序员不需要知道太多数学，英语不需要很好，你还信吗？计算机语言只是一门工具，科学问题的解决更多考察的是数学、计算机基础、英语。<b>如果不是这样，我们拿什么和培训机构训练出的程序员竞争呢？我们如何比它们代码写得好，写的快呢</b>？我还没有说明的是，我现在才理解面向对象编程实际上是考察抽象思维的能力：总结规律，总结共通的方法和属性，通过面向对象实现代码之间的内在关系，这是面向对象的根本吧…？</p><br><h2>参考文献</h2><ol><li>Sahai A., Waters B.: Fuzzy identity-based encryption. EUROCRYPT 2005. Springer Berlin Heidelberg, (2005) 568-588.<br></li><li>Beimel, A.: Secure schemes for secret sharing and key distribution. Ph.D. dissertation. Israel Institute of Technology, Technion, Haifa, Israel, 1996.</li><li>Liu, Z., Cao, Z., Duncan S.W.: Efficient generation of linear secret sharing scheme matrices from threshold access trees. IACR ePrint Achieve, (2010) 374.</li><li>Goyal, V., Pandey, A., Sahai, A., Waters, B.: Attribute-based encryption for fine-grained access control of encrypted data. CCS 2006. ACM, (2006) 89-98.</li><li>Bethencourt, J., Sahai, A., Waters, B.: Ciphertext-policy attribute-based encryption. S and P 2007. IEEE (2007) 321-334.</li><li>Shamir, A.: Identity-based cryptosystems and signature schemes. CRYPTO 1984. Springer, Berlin, Heidelberg (1985) 47-53. <br></li><li>Shamir, A.: How to share a secret. Communications of the ACM, 1979, 22(11): 612-613.</li><li>Lewko, A., Waters, B.: Decentralizing attribute-based encryption. IACR Cryptology ePrint Archive, (2010) 351. <a href="https://eprint.iacr.org/2010/351" class="">https://eprint.iacr.org/2010/351</a>.</li><li>Lewko, A., Waters, B.: Decentralizing attribute-based encryption. EUROCRYPT 2011. Springer Berlin Heidelberg, (2011) 568-588.</li></ol>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
