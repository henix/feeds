<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>分层风险平价：基于图论和机器学习的新资产配置方法（附代码）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/110904571">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-1ed9c18f7ebb706199c9d5263f79edfb_b.jpg" alt=""></div><p>编辑：1+1=6</p><h2><b><u><i>1、</i></u>前言</b></h2><p>​风险平价是构建多样化和均衡投资组合十分流行选择。众所周知，大多数资产类别的未来表现很难预测。 通过仅使用资产的风险特征和相关矩阵构建投资组合，风险平价方法克服了这一缺点。Lohre、Rother和Schafer三位作者在经典风险平价基础上，提出了分层风险平价。他们的方法是：</p><p><b>利用图论和机器学习来构建投资领域的层次结构。这种结构可以更好地将资产/因子划分为具有相似特征的集群，无需依赖经典的相关性分析。</b></p><p>这些投资组合提供了更好的尾部风险管理，特别是对skewed资产和风格因子策略。</p><p>下面我们就来看看这篇论文的主要内容。</p><h2><b><u><i>2、</i></u>正文解读</b></h2><p><b>Hierarchical risk parity: Accounting for tail dependencies in multi-asset multi-factor allocations</b></p><p>摘要：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-8e791016ae00944f55a666afd3c8306d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="330" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-8e791016ae00944f55a666afd3c8306d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-8e791016ae00944f55a666afd3c8306d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="330" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-8e791016ae00944f55a666afd3c8306d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-8e791016ae00944f55a666afd3c8306d_b.jpg"/></figure><p>我们应该关注的内容：</p><p>最近的文献提出了分层聚类下的风险平价分配模式，促使Lopez de Prado将该方法称为分层风险平价（HRP）：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-429cff4a313b80f4c1119c33395ce816_b.jpg" data-caption="" data-size="normal" data-rawwidth="657" data-rawheight="571" class="origin_image zh-lightbox-thumb" width="657" data-original="https://pic3.zhimg.com/v2-429cff4a313b80f4c1119c33395ce816_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-429cff4a313b80f4c1119c33395ce816_b.jpg" data-caption="" data-size="normal" data-rawwidth="657" data-rawheight="571" class="origin_image zh-lightbox-thumb lazy" width="657" data-original="https://pic3.zhimg.com/v2-429cff4a313b80f4c1119c33395ce816_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-429cff4a313b80f4c1119c33395ce816_b.jpg"/></figure><p>给定一组资产类别和风格因子收益，相应的算法将根据一定的距离度量对这些资产类别和风格因子进行聚类，然后沿着这些聚类分配相等的风险预算。  这种集群可能被认为是比聚合风险因子更自然的组成部分，因为它们自动选择依赖结构，并形成有意义的成分，以帮助投资组合的差异化。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-cfbd70343ac0d9d9b70190a51fe501e6_b.jpg" data-caption="" data-size="normal" data-rawwidth="893" data-rawheight="662" class="origin_image zh-lightbox-thumb" width="893" data-original="https://pic3.zhimg.com/v2-cfbd70343ac0d9d9b70190a51fe501e6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-cfbd70343ac0d9d9b70190a51fe501e6_b.jpg" data-caption="" data-size="normal" data-rawwidth="893" data-rawheight="662" class="origin_image zh-lightbox-thumb lazy" width="893" data-original="https://pic3.zhimg.com/v2-cfbd70343ac0d9d9b70190a51fe501e6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-cfbd70343ac0d9d9b70190a51fe501e6_b.jpg"/></figure><p>论文的贡献在于深入研究了分层聚类在多资产多因子投资环境中的应用和优点。特别是，它将把此方法与其他方法进行对比，比如1=N、最小方差、标准风险平价和多样化风险平价。一个主要的创新是研究基于尾部相关聚类的 HRP 策略，而不是标准的基于相关性聚类。考虑到某些样式因子的尾部风险升高，这种方法可能特别相关。分层风险平价策略通常基于两个步骤：首先，分层聚类算法揭示了所考虑的投资领域的层次结构，从而得到基于树的表示。其次，投资组合权重是通过沿着层次结构应用分配策略得出的。</p><p>下面，公众号给大家举个HRP的小例子，然后再回到我们的论文解读中。</p><h2><b><u><i>3、</i></u>分层风险平价案例</b></h2><p>我们再一次回顾一下分层风险平价：<b>它是一种执行资产配置的方法，不需要反协方差矩阵。它本质上是采用标准的层次聚类算法，计算出一个层次树，然后对不同的聚类进行多样化处理。</b></p><p>我们将按如下方式进行：</p><p>1、建立了一个人工相关矩阵C与几个层次集群；</p><p>2、把C转换成协方差矩阵；</p><p>3、从正态分布N(0, Sigma)中抽样时间序列；</p><p>4、对这些时间序列应用分层风险平价。</p><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">block_diag</span>
<span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="kn">import</span> <span class="n">linkage</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">squareform</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>


<span class="n">nb_alphas</span> <span class="o">=</span> <span class="mi">250</span>
<span class="n">nb_observations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="mi">252</span><span class="p">)</span>

<span class="n">quality</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nb_alphas</span> <span class="o">//</span> <span class="mi">6</span><span class="p">,</span> <span class="n">nb_alphas</span> <span class="o">//</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">value</span> <span class="o">=</span> <span class="mf">2.4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nb_alphas</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nb_alphas</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">momentum</span> <span class="o">=</span> <span class="mf">2.6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">nb_alphas</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                          <span class="nb">int</span><span class="p">(</span><span class="n">nb_alphas</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

<span class="n">correl_mom_value</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">nb_alphas</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="n">nb_alphas</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


<span class="n">correl</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_diag</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="n">correl_mom_value</span><span class="p">)</span> <span class="o">+</span>
          <span class="n">block_diag</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span> <span class="o">/</span> <span class="mi">3</span>
<span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">correl</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>



<span class="n">mean_returns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_alphas</span><span class="p">)</span>
<span class="n">volatilities</span> <span class="o">=</span> <span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">))]</span> <span class="o">*</span> <span class="p">(</span><span class="n">nb_alphas</span> <span class="o">//</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">))]</span> <span class="o">*</span> <span class="p">(</span><span class="n">nb_alphas</span> <span class="o">-</span> <span class="n">nb_alphas</span> <span class="o">//</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">nb_alphas</span> <span class="o">//</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">))]</span> <span class="o">*</span> <span class="p">(</span><span class="n">nb_alphas</span> <span class="o">//</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">correl</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">volatilities</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">volatilities</span><span class="p">)))</span>
<span class="n">covar</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">covar</span><span class="p">)</span>
<span class="n">correl</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">1.</span> <span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">],</span>
       <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">1.</span> <span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">],</span>
       <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">1.</span> <span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">],</span>
       <span class="o">...</span><span class="p">,</span>
       <span class="p">[</span><span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">1.</span> <span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">1.</span> <span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="mf">0.</span> <span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">1.</span> <span class="p">]])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">correl</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Correlation matrix&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">covar</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Covariance matrix&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-9ceded8a330be4fb3ac6497782b53295_b.jpg" data-caption="" data-size="normal" data-rawwidth="548" data-rawheight="389" class="origin_image zh-lightbox-thumb" width="548" data-original="https://pic2.zhimg.com/v2-9ceded8a330be4fb3ac6497782b53295_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-9ceded8a330be4fb3ac6497782b53295_b.jpg" data-caption="" data-size="normal" data-rawwidth="548" data-rawheight="389" class="origin_image zh-lightbox-thumb lazy" width="548" data-original="https://pic2.zhimg.com/v2-9ceded8a330be4fb3ac6497782b53295_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-9ceded8a330be4fb3ac6497782b53295_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-029e02e22d96c6dec93fee1a0173ba69_b.jpg" data-caption="" data-size="normal" data-rawwidth="549" data-rawheight="385" class="origin_image zh-lightbox-thumb" width="549" data-original="https://pic2.zhimg.com/v2-029e02e22d96c6dec93fee1a0173ba69_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-029e02e22d96c6dec93fee1a0173ba69_b.jpg" data-caption="" data-size="normal" data-rawwidth="549" data-rawheight="385" class="origin_image zh-lightbox-thumb lazy" width="549" data-original="https://pic2.zhimg.com/v2-029e02e22d96c6dec93fee1a0173ba69_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-029e02e22d96c6dec93fee1a0173ba69_b.jpg"/></figure><div class="highlight"><pre><code class="language-python"><span class="n">alphas_returns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
    <span class="n">mean_returns</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">covar</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nb_observations</span><span class="p">)</span>

<span class="n">alphas_returns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">alphas_returns</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">alphas_returns</span><span class="o">.</span><span class="n">cumsum</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Performance of the different alphas&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-74fb108d92a47036b07dfa13dc147777_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="560" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-74fb108d92a47036b07dfa13dc147777_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-74fb108d92a47036b07dfa13dc147777_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="560" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-74fb108d92a47036b07dfa13dc147777_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-74fb108d92a47036b07dfa13dc147777_b.jpg"/></figure><p>在实际情况下，这些时间序列是给定的，它们是一系列资产（如股票）的收益。</p><h3><b>第一步：估计相关矩阵</b></h3><div class="highlight"><pre><code class="language-python"><span class="n">estimate_correl</span> <span class="o">=</span> <span class="n">alphas_returns</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;pearson&#39;</span><span class="p">)</span>
<span class="n">estimate_covar</span> <span class="o">=</span> <span class="n">alphas_returns</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">estimate_correl</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Estimated correlation matrix&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">estimate_covar</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Estimated covariance matrix&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-0a30dd02a1559531e78d13d47532e704_b.jpg" data-caption="" data-size="normal" data-rawwidth="631" data-rawheight="451" class="origin_image zh-lightbox-thumb" width="631" data-original="https://pic1.zhimg.com/v2-0a30dd02a1559531e78d13d47532e704_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-0a30dd02a1559531e78d13d47532e704_b.jpg" data-caption="" data-size="normal" data-rawwidth="631" data-rawheight="451" class="origin_image zh-lightbox-thumb lazy" width="631" data-original="https://pic1.zhimg.com/v2-0a30dd02a1559531e78d13d47532e704_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-0a30dd02a1559531e78d13d47532e704_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-a2f6f2063a50d87eaaec3c9a8e1678c6_b.jpg" data-caption="" data-size="normal" data-rawwidth="632" data-rawheight="452" class="origin_image zh-lightbox-thumb" width="632" data-original="https://pic3.zhimg.com/v2-a2f6f2063a50d87eaaec3c9a8e1678c6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-a2f6f2063a50d87eaaec3c9a8e1678c6_b.jpg" data-caption="" data-size="normal" data-rawwidth="632" data-rawheight="452" class="origin_image zh-lightbox-thumb lazy" width="632" data-original="https://pic3.zhimg.com/v2-a2f6f2063a50d87eaaec3c9a8e1678c6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-a2f6f2063a50d87eaaec3c9a8e1678c6_b.jpg"/></figure><p>将相关性转化为距离，如下所示：</p><div class="highlight"><pre><code class="language-python"><span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">estimate_correl</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span></code></pre></div><p><b>第二步：准对角化</b></p><p>Lopez de Prado 应用了他所谓的quasi-diagonalization，这个过程通常被称为矩阵序列化，可以通过层次聚类来完成。</p><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">seriation</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">cur_index</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;Returns the order implied by a hierarchical tree (dendrogram).
</span><span class="s2">    
</span><span class="s2">       :param Z: A hierarchical tree (dendrogram).
</span><span class="s2">       :param N: The number of points given to the clustering process.
</span><span class="s2">       :param cur_index: The position in the tree for the recursive traversal.
</span><span class="s2">       
</span><span class="s2">       :return: The order implied by the hierarchical tree Z.
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">if</span> <span class="n">cur_index</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">cur_index</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">cur_index</span> <span class="o">-</span> <span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">cur_index</span> <span class="o">-</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">seriation</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">seriation</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>

    
<span class="k">def</span> <span class="nf">compute_serial_matrix</span><span class="p">(</span><span class="n">dist_mat</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&#34;ward&#34;</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;Returns a sorted distance matrix.
</span><span class="s2">    
</span><span class="s2">       :param dist_mat: A distance matrix.
</span><span class="s2">       :param method: A string in [&#34;ward&#34;, &#34;single&#34;, &#34;average&#34;, &#34;complete&#34;].
</span><span class="s2">        
</span><span class="s2">        output:
</span><span class="s2">            - seriated_dist is the input dist_mat,
</span><span class="s2">              but with re-ordered rows and columns
</span><span class="s2">              according to the seriation, i.e. the
</span><span class="s2">              order implied by the hierarchical tree
</span><span class="s2">            - res_order is the order implied by
</span><span class="s2">              the hierarhical tree
</span><span class="s2">            - res_linkage is the hierarhical tree (dendrogram)
</span><span class="s2">        
</span><span class="s2">        compute_serial_matrix transforms a distance matrix into
</span><span class="s2">        a sorted distance matrix according to the order implied
</span><span class="s2">        by the hierarchical tree (dendrogram)
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_mat</span><span class="p">)</span>
    <span class="n">flat_dist_mat</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">dist_mat</span><span class="p">)</span>
    <span class="n">res_linkage</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">flat_dist_mat</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="n">res_order</span> <span class="o">=</span> <span class="n">seriation</span><span class="p">(</span><span class="n">res_linkage</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">seriated_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">seriated_dist</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_mat</span><span class="p">[[</span><span class="n">res_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">res_order</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]]</span>
    <span class="n">seriated_dist</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">seriated_dist</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">seriated_dist</span><span class="p">,</span> <span class="n">res_order</span><span class="p">,</span> <span class="n">res_linkage</span>

 
<span class="n">ordered_dist_mat</span><span class="p">,</span> <span class="n">res_order</span><span class="p">,</span> <span class="n">res_linkage</span> <span class="o">=</span> <span class="n">compute_serial_matrix</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Original order distance matrix&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">ordered_dist_mat</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Re-ordered distance matrix&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-9fdb743f60cc8d4a6d850cf238853b82_b.jpg" data-caption="" data-size="normal" data-rawwidth="609" data-rawheight="447" class="origin_image zh-lightbox-thumb" width="609" data-original="https://pic3.zhimg.com/v2-9fdb743f60cc8d4a6d850cf238853b82_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-9fdb743f60cc8d4a6d850cf238853b82_b.jpg" data-caption="" data-size="normal" data-rawwidth="609" data-rawheight="447" class="origin_image zh-lightbox-thumb lazy" width="609" data-original="https://pic3.zhimg.com/v2-9fdb743f60cc8d4a6d850cf238853b82_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-9fdb743f60cc8d4a6d850cf238853b82_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-3bc598e1d1159c3d9dd2cc0df9ac9f6b_b.jpg" data-caption="" data-size="normal" data-rawwidth="612" data-rawheight="459" class="origin_image zh-lightbox-thumb" width="612" data-original="https://pic4.zhimg.com/v2-3bc598e1d1159c3d9dd2cc0df9ac9f6b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-3bc598e1d1159c3d9dd2cc0df9ac9f6b_b.jpg" data-caption="" data-size="normal" data-rawwidth="612" data-rawheight="459" class="origin_image zh-lightbox-thumb lazy" width="612" data-original="https://pic4.zhimg.com/v2-3bc598e1d1159c3d9dd2cc0df9ac9f6b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-3bc598e1d1159c3d9dd2cc0df9ac9f6b_b.jpg"/></figure><h3><b>第三步：递归二分法</b></h3><div class="highlight"><pre><code class="language-python"><span class="k">def</span> <span class="nf">compute_HRP_weights</span><span class="p">(</span><span class="n">covariances</span><span class="p">,</span> <span class="n">res_order</span><span class="p">):</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">res_order</span><span class="p">)</span>
    <span class="n">clustered_alphas</span> <span class="o">=</span> <span class="p">[</span><span class="n">res_order</span><span class="p">]</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">clustered_alphas</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">clustered_alphas</span> <span class="o">=</span> <span class="p">[</span><span class="n">cluster</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clustered_alphas</span>
                            <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span>
                                               <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)))</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">subcluster</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">clustered_alphas</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">left_cluster</span> <span class="o">=</span> <span class="n">clustered_alphas</span><span class="p">[</span><span class="n">subcluster</span><span class="p">]</span>
            <span class="n">right_cluster</span> <span class="o">=</span> <span class="n">clustered_alphas</span><span class="p">[</span><span class="n">subcluster</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">left_subcovar</span> <span class="o">=</span> <span class="n">covariances</span><span class="p">[</span><span class="n">left_cluster</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">left_cluster</span><span class="p">]</span>
            <span class="n">inv_diag</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">left_subcovar</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">parity_w</span> <span class="o">=</span> <span class="n">inv_diag</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">inv_diag</span><span class="p">))</span>
            <span class="n">left_cluster_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">parity_w</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">left_subcovar</span><span class="p">,</span> <span class="n">parity_w</span><span class="p">))</span>

            <span class="n">right_subcovar</span> <span class="o">=</span> <span class="n">covariances</span><span class="p">[</span><span class="n">right_cluster</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">right_cluster</span><span class="p">]</span>
            <span class="n">inv_diag</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">right_subcovar</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">parity_w</span> <span class="o">=</span> <span class="n">inv_diag</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">inv_diag</span><span class="p">))</span>
            <span class="n">right_cluster_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">parity_w</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">right_subcovar</span><span class="p">,</span> <span class="n">parity_w</span><span class="p">))</span>

            <span class="n">alloc_factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">left_cluster_var</span> <span class="o">/</span> <span class="p">(</span><span class="n">left_cluster_var</span> <span class="o">+</span> <span class="n">right_cluster_var</span><span class="p">)</span>

            <span class="n">weights</span><span class="p">[</span><span class="n">left_cluster</span><span class="p">]</span> <span class="o">*=</span> <span class="n">alloc_factor</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">right_cluster</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">alloc_factor</span>
            
    <span class="k">return</span> <span class="n">weights</span>


<span class="k">def</span> <span class="nf">compute_MV_weights</span><span class="p">(</span><span class="n">covariances</span><span class="p">):</span>
    <span class="n">inv_covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">covariances</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">covariances</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_covar</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_covar</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">compute_RP_weights</span><span class="p">(</span><span class="n">covariances</span><span class="p">):</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">covariances</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">weights</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">compute_unif_weights</span><span class="p">(</span><span class="n">covariances</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">covariances</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">covariances</span><span class="p">))]</span></code></pre></div><p>出于好奇，我们展示了使用估计的协方差矩阵和使用原始的协方差矩阵时间序列样本计算的结果，希望结果有点类似。</p><div class="highlight"><pre><code class="language-python"><span class="c1">### Hierarchical Risk Parity</span>

<span class="n">HRP_weights</span> <span class="o">=</span> <span class="n">compute_HRP_weights</span><span class="p">(</span><span class="n">estimate_covar</span><span class="p">,</span> <span class="n">res_order</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">HRP_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">))</span>
<span class="mf">0.38</span>


<span class="n">HRP_weights</span> <span class="o">=</span> <span class="n">compute_HRP_weights</span><span class="p">(</span><span class="n">covar</span><span class="p">,</span> <span class="n">res_order</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">HRP_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">))</span>
<span class="mf">0.34</span>
<span class="c1">### 1 / N uniform weighting</span>

<span class="n">unif_weights</span> <span class="o">=</span> <span class="n">compute_unif_weights</span><span class="p">(</span><span class="n">estimate_covar</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">unif_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">))</span>
<span class="mf">0.43</span>
<span class="c1">### Naive Risk Parity 1 / volatility</span>

<span class="n">RP_weights</span> <span class="o">=</span> <span class="n">compute_RP_weights</span><span class="p">(</span><span class="n">estimate_covar</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">RP_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
      <span class="mi">2</span><span class="p">))</span>
<span class="mf">0.29</span>

<span class="n">RP_weights</span> <span class="o">=</span> <span class="n">compute_RP_weights</span><span class="p">(</span><span class="n">covar</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">RP_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">))</span>
<span class="mf">0.29</span>
<span class="c1">### Minimum Variance</span>

<span class="n">MV_weights</span> <span class="o">=</span> <span class="n">compute_MV_weights</span><span class="p">(</span><span class="n">estimate_covar</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">MV_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">))</span>
<span class="mf">0.0</span>

<span class="n">MV_weights</span> <span class="o">=</span> <span class="n">compute_MV_weights</span><span class="p">(</span><span class="n">covar</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">MV_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">))</span>
<span class="mf">0.22</span></code></pre></div><p>我们可以看到最小方差在某种程度上超过了样本内数据，因为获得的两个波动率非常不同，而使用样本内估计的波动率«使用真实协方差矩阵的波动率。我们将用样本外验证测试来验证这些观察结果。</p><h2><b>第四步：样本外验证</b></h2><p>我们产生另一个样本，即两年期收益的时间序列。</p><div class="highlight"><pre><code class="language-python"><span class="n">nb_observations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">252</span><span class="p">)</span>

<span class="n">alphas_returns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
    <span class="n">mean_returns</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">covar</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nb_observations</span><span class="p">)</span>

<span class="n">alphas_returns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">alphas_returns</span><span class="p">)</span>
<span class="c1">### Hierarchical Risk Parity</span>

<span class="n">HRP_weights</span> <span class="o">=</span> <span class="n">compute_HRP_weights</span><span class="p">(</span><span class="n">estimate_covar</span><span class="p">,</span> <span class="n">res_order</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">HRP_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">))</span>
<span class="mf">0.43</span>

<span class="c1">### 1 / N uniform weighting</span>

<span class="n">unif_weights</span> <span class="o">=</span> <span class="n">compute_unif_weights</span><span class="p">(</span><span class="n">estimate_covar</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">unif_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">))</span>
<span class="mf">0.45</span>

<span class="c1">### Naive Risk Parity 1 / volatility</span>

<span class="n">RP_weights</span> <span class="o">=</span> <span class="n">compute_RP_weights</span><span class="p">(</span><span class="n">estimate_covar</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">RP_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">))</span>
<span class="mf">0.32</span>

<span class="n">MV_weights</span> <span class="o">=</span> <span class="n">compute_MV_weights</span><span class="p">(</span><span class="n">estimate_covar</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">MV_weights</span> <span class="o">*</span> <span class="n">alphas_returns</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">252</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">))</span>
<span class="mf">7.71</span>
</code></pre></div><p>我们注意到，最小方差产量过度解决方案，不产生样本外表现的投资组合。</p><p class="ztext-empty-paragraph"><br/></p><p>在这个例子中，分层风险平价并没有击败naive 风险平价，它完全忽略了资产之间的相关结构。然而，这个例子对于HRP来说太简单了。<b>明天的推文我们会继续更深入的介绍。</b></p><p><b>好了，回到正文：</b></p><p>传统基于风险的配置策略首先直接应用于单个资产和因子，其次应用于由强加风险模型产生的八个综合因子。这八个因子为统计层次结构提供了一个基准集群。至于HRP，在集群内部或跨集群使用的分配策略是基于逆波动率（IVP）或等风险贡献（ERC）的风险平价。对于层次聚类，我们使用了Ward方法和相异矩阵，或者基于相关矩阵，或者基于LTDCs。为了便于比较，坐着考虑了Lopez De Prado的HRP策略的两个版本，它们都基于递归二分法：首先，复制原始策略，使用算法1中描述的单连接和逆方差分配。其次，我们考虑算法2中描述的一种变体，使用Ward的方法和IVP，与Lopez de Prado的原始HRP策略进行比较。所考虑的策略概述见下表：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-a89717e2ce38cf16733d9404f8c08a73_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="509" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-a89717e2ce38cf16733d9404f8c08a73_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-a89717e2ce38cf16733d9404f8c08a73_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="509" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic4.zhimg.com/v2-a89717e2ce38cf16733d9404f8c08a73_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-a89717e2ce38cf16733d9404f8c08a73_b.jpg"/></figure><p>作者在2012年1月至2017年12月的六年时间里对投资策略进行了回测：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-5bcb423735df1d1fd67397d4d22629d9_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="742" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-5bcb423735df1d1fd67397d4d22629d9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-5bcb423735df1d1fd67397d4d22629d9_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="742" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-5bcb423735df1d1fd67397d4d22629d9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-5bcb423735df1d1fd67397d4d22629d9_b.jpg"/></figure><p>上表显示了绩效和风险统计以及平均策略周转率。首先，首先，我们注意到跨单一资产和因子的1=N策略在所有策略中具有最高的收益率。与此同时，1=N承受着最高的波动性和最大的资产缩减，使其风险调整后的业绩低于平均水平。值得注意的是，当考虑经济因子而不是单一资产和因子时，潜在的不确定性并没有得到缓解；两个变量的平均值都在3.5左右徘徊。有趣的是，最小方差优化使这个数字已经翻倍到7.2。不出所料，这两个投资组合在样本周期内的投资组合波动最小（分别为0.84%和0.90%)）。当然，与同等权重相比，最大回撤和风险调整收益率也有所提高。</p><p>更多内容大家可以下载论文进行阅读！下载地址：</p><p><i><a href="https://link.zhihu.com/?target=https%3A//papers.ssrn.com/sol3/papers.cfm%3Fabstract_id%3D3513399" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">papers.ssrn.com/sol3/pa</span><span class="invisible">pers.cfm?abstract_id=3513399</span><span class="ellipsis"></span></a></i></p><p>量化投资与机器学习微信公众号，是业内垂直于<b>Quant、MFE、Fintech、AI、ML</b>等领域的<b>量化类主流自媒体。</b>公众号拥有来自<b>公募、私募、券商、期货、银行、保险资管、海外</b>等众多圈内<b>18W+</b>关注者。每日发布行业前沿研究成果和最新量化资讯。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
