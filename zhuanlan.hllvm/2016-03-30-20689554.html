<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>lisp0</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20689554">原文</a></p>
<p>代码没写完，广告先打起来<a class="" data-title="GitHub - bhuztez/lisp0: a bare minimum remake of origin LISP" data-editable="true" href="https://github.com/bhuztez/lisp0"> GitHub - bhuztez/lisp0: a bare minimum remake of origin LISP</a></p><br><p>学习高级语言Runtime最好的办法，当然是自己动手写一个啦。毫无疑问假如你不是特别喜欢走弯路的轮子哥，肯定选从容易的开始。那么就选最最原始的LISP好了(Brainfuck之类的过于简单，这里先忽略他们的存在)。lisp0不会像Lisp Machine是一台单独的机器，lisp0就是一个普通的运行在Linux的程序。</p><p>既然是把Runtime实现一遍，那么在操作系统之上全都自己来实现，连CRT和libc也不要用。因为Lisp语言自己就又栈了，所以C程序没事别递归，用的栈是非常有限的，于是用bss段里的一段内存当C语言的栈，而操作系统在启动时，分配来的栈，给Lisp用。这样虽然奇葩了点，非常省事啊。</p><p>因为(假装)lisp0是immutable的，所以只要简单的引用计数就可以了。不过这写起来麻烦，用一次就要增减一次。还不如先用个简单的Mark sweep GC。因为immutable，所以新的不能被旧的引用，在allocate后把他们串成一个栈，只要从新往旧扫一遍，在扫到时还没被标记，那就一定不会被标记到，可以放心的free。至于memory allocator，就用简陋的TLSF算法就好了，这算法看上去就像个增强版的Buddy allocator。<br></p><p>既然Lisp霸占了原本给C用的栈，使用方式也就和C保持一致好了。因为GCC支持Labels as Values，所以只要在CALL之后放一个label，那个label的值就是返回地址了。同时，因为symbol只接受[_0-9A-Za-z]+，所以长度小于等于8的symbol，经过base64解码之后长度就只有6字节了，而64位机器上去掉3位tag，还有61位，完全放的下。</p><p>接下来，lisp0应该改用HAMT来实现environment，换一个更好的GC。本文到此就结束了。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
