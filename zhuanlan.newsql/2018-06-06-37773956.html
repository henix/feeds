<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TiDB 源码阅读系列文章（九）Hash Join</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/37773956">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-11402cca6b9863dc806402042e81a78c_r.jpg" alt=""></div><blockquote>TiDB 目前获得了广泛的关注，特别是一些技术爱好者希望能够参与这个项目。由于整个系统的复杂性，很多人并不能很好的理解整个项目。我们希望通过 TiDB 源码阅读系列文章自顶向下，由浅入深，讲述 TiDB 的技术原理以及实现细节，帮助大家掌握这个项目。<br><br>本文是 TiDB 源码阅读系列文章的第九篇。内文详细介绍了 TiDB Hash Join 的实现以及几种常见的问题，enjoy～</blockquote><h2><b>什么是 Hash Join</b></h2><p>Hash Join 的基本定义可以参考维基百科：<a href="https://en.wikipedia.org/wiki/Hash_join">Hash join</a>。简单来说，A 表和 B 表的 Hash Join 需要我们选择一个 Inner 表来构造哈希表，然后对 Outer 表的每一行数据都去这个哈希表中查找是否有匹配的数据。</p><p>我们不用 “小表” 和 “大表” 这两个术语是因为：对于类似 Left Outer Join 这种 Outer Join 来说，如果我们使用 Hash Join，不管 Left 表相对于 Right 表而言是大表还是小表，我们都只能使用 Right 表充当 Inner 表并在之上建哈希表，使用 Left 表来当 Outer 表，也就是我们的驱动表。使用 Inner 和 Outer 更准确，没有迷惑性。在 Build 阶段，对 Inner 表建哈希表，在 Probe 阶段，对由 Outer 表驱动执行 Join 过程。</p><h2><b>TiDB Hash Join 实现</b></h2><p>TiDB 的 Hash Join 是一个多线程版本的实现，主要任务有：</p><ul><li>Main Thread，一个，执行下列任务：</li><ul><li>读取所有的 Inner 表数据；</li><li>根据 Inner 表数据构造哈希表；</li><li>启动 Outer Fetcher 和 Join Worker 开始后台工作，生成 Join 结果，各个 goroutine 的启动过程由 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L1003">fetchOuterAndProbeHashTable</a> 这个函数完成；</li><li>将 Join Worker 计算出的 Join 结果返回给 <code class="inline">NextChunk</code> 接口的调用方法。</li></ul><li>Outer Fetcher，一个，负责读取 Outer 表的数据并分发给各个 Join Worker；</li><li>Join Worker，多个，负责查哈希表、Join 匹配的 Inner 和 Outer 表的数据，并把结果传递给 Main Thread。</li></ul><p>接下来我们细致的介绍 Hash Join 的各个阶段。</p><ol><li><b>Main Thread 读 Inner 表数据</b></li></ol><p>读 Inner 表数据的过程由 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L329">fetchInnerRows</a> 这个函数完成。这个过程会不断调用 Child 的 <code class="inline">NextChunk</code> 接口，把每次函数调用所获取的 Chunk 存储到 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L348">innerResult</a> 这个 List 中供接下来的计算使用。</p><p><b>2. Main Thread 构造哈希表</b></p><p>构造哈希表的过程由 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L1003">buildHashTableForList</a> 这个函数完成。</p><p>我们这里使用的哈希表（存储在变量 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L52">hashTable</a> 中）本质上是一个 <a href="https://github.com/pingcap/tidb/blob/source-code/util/mvmap/mvmap.go#L118">MVMap</a>。MVMap 的 Key 和 Value 都是 <code class="inline">[]byte</code> 类型的数据，和普通 map 不同的是，MVMap 允许一个 Key 拥有多个 Value。这个特性对于 Hash Join 来说非常方便和实用，因为表中同一个 Join Key 可能对应多行数据。</p><p>构造哈希表的过程中，我们会遍历 Inner 表的每行数据（上文提到，此时所有的数据都已经存储在了 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L348">innerResult</a> 中），对每行数据做如下操作：</p><ul><li>计算该行数据的 Join Key，得到一个 <code class="inline">[]byte</code>，它将作为 MVMap 的 Key；</li><li>计算该行数据的位置信息，得到另一个 <code class="inline">[]byte</code>，它将作为 MVMap 的 Value；</li><li>将这个 <code class="inline">(Key, Value)</code> 放入 MVMap 中。</li></ul><p><b>3. Outer Fetcher</b></p><p>Outer Fetcher 是一个后台 goroutine，他的主要计算逻辑在 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L291">fetchOuterChunks</a> 这个函数中。</p><p>它会不断的读大表的数据，并将获得的 Outer 表的数据分发给各个 Join Worker。这里多线程之间的资源交互可以用下图表示：</p><img src="https://pic4.zhimg.com/v2-a609ee70a5370629e9a35dd2dd110558_r.jpg" data-caption="" data-size="normal" data-rawwidth="941" data-rawheight="494" data-watermark="watermark" data-original-src="v2-a609ee70a5370629e9a35dd2dd110558" data-watermark-src="v2-5a6e2d50f070eab71ce2314ddbfff5f2" data-private-watermark-src=""><p><br></p><p>上图中涉及到了两个 channel：</p><ul><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L74">outerResultChs[i]</a>：每个 Join Worker 一个，Outer Fetcher 将获取到的 Outer Chunk 写入到这个 channel 中供相应的 Join Worker 使用；</li><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L73">outerChkResourceCh</a>：当 Join Worker 用完了当前的 Outer Chunk 后，它需要把这个 Chunk 以及自己对应的 outerResultChs[i] 的地址一起写入到 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L73">outerChkResourceCh</a> 这个 channel 中，告诉 Outer Fetcher 两个信息：<br></li><ul><li>我提供了一个 Chunk 给你，你直接用这个 Chunk 去拉 Outer 数据吧，不用再重新申请内存了；</li><li>我的 Outer Chunk 已经用完了，你需要把拉取到的 Outer 数据直接传给我，不要给别人了。</li></ul></ul><p><b>所以，整体上 Outer Fetcher 的计算逻辑是：</b></p><p>i. 从 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L73">outerChkResourceCh</a> 中获取一个 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L84">outerChkResource</a>，存储在变量 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L307">outerResource</a> 中；</p><p>ii. 从 Child 拉取数据，将数据写入到 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L307">outerResource</a> 的 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L85">chk</a> 字段中；</p><p>iii. 将这个 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L85">chk</a> 发给需要 Outer 表的数据的 Join Worker 的 <code class="inline">outerResultChs[i]</code> 中去，这个信息记录在了 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L307">outerResource</a> 的 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L86">dest</a> 字段中。</p><p><b>4. Join Worker</b></p><p>每个 Join Worker 都是一个后台 goroutine，主要计算逻辑在 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L562">runJoinWorker4Chunk</a> 这个函数中。Join Worker 的数量由 <code class="inline">tidb_hash_join_concurrency</code>这个 session 变量来控制，默认是 5 个。</p><img src="https://pic1.zhimg.com/v2-1dc6fa88ff141bce8c9ee5bbdcac5204_r.jpg" data-caption="" data-size="normal" data-rawwidth="941" data-rawheight="454" data-watermark="watermark" data-original-src="v2-1dc6fa88ff141bce8c9ee5bbdcac5204" data-watermark-src="v2-35b95e5b599d161d30c941957a01fffb" data-private-watermark-src=""><p>上图中涉及到两个 channel：</p><ul><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L75">joinChkResourceCh[i]</a>：每个 Join Worker 一个，用来存 Join 的结果；</li><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L76">joinResultCh</a>：Join Worker 将 Join 的结果 Chunk 以及它的 joinChkResourceCh 地址写入到这个 channel 中，告诉 Main Thread 两件事：</li><ul><li>我计算出了一个 Join 的结果 Chunk 给你，你读到这个数据后可以直接返回给你 Next 函数的调用方；</li><li>你用完这个 Chunk 后赶紧还给我，不要给别人，我好继续干活。</li></ul></ul><p><b>所以，整体上 Join Worker 的计算逻辑是：</b></p><p>i. 获取一个 Outer Chunk；</p><p>ii. 获取一个 Join Chunk Resource；</p><p>iii. 查哈希表，将匹配的 Outer Row 和 Inner Rows 写到 Join Chunk 中；</p><p>iv. 将写满了的 Join Chunk 发送给 Main Thread。</p><p><b>5. Main Thread</b></p><p>主线程的计算逻辑由 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L776">NextChunk</a> 这个函数完成。主线程的计算逻辑非常简单：</p><p>i. 从 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L76">joinResultCh</a> 中获取一个 Join Chunk；</p><p>ii. 将调用方传下来的 chk 和 Join Chunk 中的数据交换；</p><p>iii. 把 Join Chunk 还给对应的 Join Worker。</p><h2><b>Hash Join FAQ</b></h2><p><b>1. 如何确定 Inner 和 Outer 表？</b></p><ul><li>Left Outer Join：左表是 Outer 表，右表是 Inner 表；</li><li>Right Outer Join：跟 Left Outer Join 相反，右表是 Outer 表，左表是 Inner 表；</li><li>Inner Join：优化器估算出的较大表是 Outer 表，较小的表是 Inner 表；</li><li>Semi Join、Anti Semi Join、Left Outer Semi Join 或 Anti Left Outer Semi Join：左表是 Outer 表，右表是 Inner 表。</li></ul><p><b>2. Join Key 中 NULL 值的问题</b></p><p><code class="inline">NULL</code> 和 <code class="inline">NULL</code> 不等，所以：</p><ul><li>在用 Inner 表建 <code class="inline">NULL</code> 值的时候会忽略掉 Join Key 中有 <code class="inline">NULL</code> 的数据（代码在 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L1022">这里</a>）；</li><li>当 Outer 表中某行数据的 Join Key 中有 <code class="inline">NULL</code> 值的时候我们不会去查哈希表（代码在 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L655">这里</a>）。</li></ul><p><b>3. Join 中的 4 种 Filter</b></p><ul><li><b>Inner 表上的 Filter</b>：这种 Filter 目前被优化器推到了 Hash Join Inner 表上面，在 Hash Join 实现的过程中不用考虑这种 Filter 了。推下去的原因是能够尽早的在 coprocessor 上就把不能匹配到的 Inner 表数据给过滤掉，给上层计算减压。</li><li><b>Outer 表上的 Filter</b>：这种 Filter 的计算目前在 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join.go#L711">join2Chunk</a> 中，由 Join Worker 进行。当 Join Worker 拿到一个 Outer Chunk 以后需要先计算 Outer Filter，如果通过了 Outer Filter 再去查哈希表。</li><li><b>两个表上的等值条件</b>：这就是我们说的 Join Key。比如 A 表和 B 表的等值条件是：<code class="inline">A.col1=B.col2 and A.col3=B.col4</code>，那么 A 表和 B 表上的 Join Key 分别是 <code class="inline">(col1, col3)</code> 和 <code class="inline">(col2, col4)</code>。</li><li><b>两个表上的非等值条件</b>：这种 Filter 需要在 Join 的结果集上计算，如果能够过这个 Filter 才认为两行数据能够匹配。这个 Filter 的计算过程交给了 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join_result_generators.go#L36">joinResultGenerator</a>。</li></ul><p><b>4. Join 方式的实现</b></p><p>目前 TiDB 支持的 Join 方式有 7 种，我们使用 <a href="https://github.com/pingcap/tidb/blob/source-code/executor/join_result_generators.go#L36">joinResultGenerator</a> 这个接口来定义两行数据的 Join 方式，实现一种具体的 Join 方式需要特殊的去实现 <code class="inline">joinResultGenerator</code> 这个接口，目前有 7 种实现：</p><ul><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join_result_generators.go#L212">semiJoinResultGenerator</a>：实现了 Semi Join 的链接方式，当一个 Outer Row 和至少一个 Inner Row 匹配时，输出这个 Outer Row。</li><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join_result_generators.go#L278">antiSemiJoinResultGenerator</a>：实现了 Anti Semi Join 的链接方式，当 Outer Row 和所有的 Inner Row 都不能匹配时才输出这个 Outer Row。</li><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join_result_generators.go#L342">leftOuterSemiJoinResultGenerator</a>：实现了 Left Outer Semi Join 的链接方式，Join 的结果是 Outer Row + 一个布尔值，如果该 Outer Row 能和至少一个 Inner Row 匹配，则输出该 Outer Row + True，否则输出 Outer Row + False。</li><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join_result_generators.go#L415">antiLeftOuterSemiJoinResultGenerator</a>：实现了 Anti Left Outer Semi Join 的链接方式，Join 的结果也是 Outer Row + 一个布尔值，不同的是，如果该 Outer Row 不能和任何 Inner Row 匹配上，则输出 Outer Row + True，否则输出 Outer Row + False。</li><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join_result_generators.go#L490">leftOuterJoinResultGenerator</a>：实现了 Left Outer Join 的链接方式，如果 Outer Row 不能和任何 Inner Row 匹配，则输出 Outer Row + NULL 填充的 Inner Row，否则输出每个匹配的 Outer Row + Inner Row。</li><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join_result_generators.go#L555">rightOuterJoinResultGenerator</a>：实现了 Right Outer Join 的链接方式，如果 Outer Row 不能和 Inner Row 匹配，则输出 NULL 填充的 Inner Row + Outer Row，否则输出每个匹配的 Inner Row + Outer Row。</li><li><a href="https://github.com/pingcap/tidb/blob/source-code/executor/join_result_generators.go#L619">innerJoinResultGenerator</a>：实现了 Inner Join 的链接方式，如果 Outer Row 不能和 Inner Row 匹配，不输出任何数据，否则根据 Outer Row 是左表还是右表选择性的输出每个匹配的 Inner Row + Outer Row 或者 Outer Row + Inner Row。</li></ul><p><br></p><blockquote>作者：张建</blockquote><p><br></p><a href="https://zhuanlan.zhihu.com/p/36420449" data-draft-node="block" data-draft-type="link-card" data-image="v2-c57f34d03b8c3bebf2c377a99031e125" data-image-width="3072" data-image-height="2048" data-image-size="180x120">ZoeyZhai：TiDB 源码阅读系列文章（八）基于代价的优化</a><a href="https://zhuanlan.zhihu.com/p/35511864" data-draft-node="block" data-draft-type="link-card" data-image="v2-dd77ba57ce8a5c40abb710bfafd997ad" data-image-width="3072" data-image-height="2048" data-image-size="180x120">ZoeyZhai：TiDB 源码阅读系列文章（七）基于规则的优化</a><a href="https://zhuanlan.zhihu.com/p/35134962" data-draft-node="block" data-draft-type="link-card" data-image="v2-bbeb258c92e952e8b8d3e3459df80b9e" data-image-width="620" data-image-height="414" data-image-size="180x120">ZoeyZhai：TiDB 源码阅读系列文章（六）Select 语句概览</a><a href="https://zhuanlan.zhihu.com/p/34770765" data-draft-node="block" data-draft-type="link-card" data-image="v2-aff61c8861faa58cf2b7308dfbdac1ac" data-image-width="1920" data-image-height="1235" data-image-size="180x120">ZoeyZhai：TiDB 源码阅读系列文章（五）TiDB SQL Parser 的实现</a><a href="https://zhuanlan.zhihu.com/p/34512827" data-draft-node="block" data-draft-type="link-card" data-image="v2-9fbb6c63057d03b0febd343f2fcb6bc7" data-image-width="720" data-image-height="480" data-image-size="180x120">ZoeyZhai：TiDB 源码阅读系列文章（四）Insert 语句概览</a><a href="https://zhuanlan.zhihu.com/p/34369624" data-draft-node="block" data-draft-type="link-card" data-image="v2-4b4bb31438e3462c116811d78a1fb3a9" data-image-width="900" data-image-height="620" data-image-size="180x120">ZoeyZhai：TiDB 源码阅读系列文章（三）SQL 的一生</a><a href="https://zhuanlan.zhihu.com/p/34176614" data-draft-node="block" data-draft-type="link-card" data-image="v2-22fa6ca9240bb8f54dea4d7eaa0f50f1" data-image-width="5116" data-image-height="3411" data-image-size="180x120">ZoeyZhai：TiDB 源码阅读系列文章（二）初识 TiDB 源码</a><a href="https://zhuanlan.zhihu.com/p/34109413" data-draft-node="block" data-draft-type="link-card" data-image="v2-248d9e972a06be2d4632a7bfecf3302a" data-image-width="1400" data-image-height="940" data-image-size="180x120">ZoeyZhai：TiDB 源码阅读系列文章（一）序</a><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
