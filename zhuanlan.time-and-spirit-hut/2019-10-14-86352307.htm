<div class="title-image"><img src="https://pic2.zhimg.com/v2-1899a8ccbe3f918f6324a2082dcbd7af_b.jpg" alt=""></div><p><b><i>今天做了一个Substrate相关的小分享，公开出来。</i></b></p><p><b><i>因为我平时也比较忙，昨天才选定了本次分享的主题，准备比较仓促，细节可能不是很充足，但分享的目的也是给大家提供一个学习的思路，更多的细节大家可以在平时学习中自行探索。</i></b></p><p>以下正文，阅读时间10分钟左右。</p><hr/><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-d06e29975446c05851dc1aa61c7a6e16_b.jpg" data-caption="" data-size="normal" data-rawwidth="846" data-rawheight="628" class="origin_image zh-lightbox-thumb" width="846" data-original="https://pic3.zhimg.com/v2-d06e29975446c05851dc1aa61c7a6e16_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-d06e29975446c05851dc1aa61c7a6e16_b.jpg" data-caption="" data-size="normal" data-rawwidth="846" data-rawheight="628" class="origin_image zh-lightbox-thumb lazy" width="846" data-original="https://pic3.zhimg.com/v2-d06e29975446c05851dc1aa61c7a6e16_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-d06e29975446c05851dc1aa61c7a6e16_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>今天我要分享的内容呢，是《如何在阅读Rust项目源码中学习》，一共分成两大部分内容。 </p><p>想要在阅读源码中学习，首先得学会如何阅读源码。然后才是在源码中学习。</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-d9c252192eba22f38d38e005bc68efff_b.jpg" data-caption="" data-size="normal" data-rawwidth="851" data-rawheight="626" class="origin_image zh-lightbox-thumb" width="851" data-original="https://pic4.zhimg.com/v2-d9c252192eba22f38d38e005bc68efff_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-d9c252192eba22f38d38e005bc68efff_b.jpg" data-caption="" data-size="normal" data-rawwidth="851" data-rawheight="626" class="origin_image zh-lightbox-thumb lazy" width="851" data-original="https://pic4.zhimg.com/v2-d9c252192eba22f38d38e005bc68efff_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-d9c252192eba22f38d38e005bc68efff_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>那么如何阅读Rust项目源码呢？</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-3712c5b528788e22187c07f4da082a29_b.jpg" data-caption="" data-size="normal" data-rawwidth="840" data-rawheight="532" class="origin_image zh-lightbox-thumb" width="840" data-original="https://pic2.zhimg.com/v2-3712c5b528788e22187c07f4da082a29_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-3712c5b528788e22187c07f4da082a29_b.jpg" data-caption="" data-size="normal" data-rawwidth="840" data-rawheight="532" class="origin_image zh-lightbox-thumb lazy" width="840" data-original="https://pic2.zhimg.com/v2-3712c5b528788e22187c07f4da082a29_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-3712c5b528788e22187c07f4da082a29_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>其实阅读源码和读一本书是一样的。我们是如何阅读一本书的呢？</p><p>第一步，是找书。你选择一本书去学习，是因为你有一个学习目标。</p><p>所以，阅读源码也是一样的，先确定自己的学习小目标。</p><p>确定一个小目标，非常关键。 如果没有目标，就会迷失在纷繁复杂的代码里，只有确定了目标，你才能从源码中发现线索。</p><p>但确定了目标之后，我们还不能马上就陷入到细节中。我们在选择好一本书之后，第一眼要看它的目录和文前。 这样有助于我们从整体上来把握整本书的内容。</p><p>所以，第二步就是要从整体出发。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-4572b4077ea97f4eee54865b623b34e6_b.jpg" data-caption="" data-size="normal" data-rawwidth="821" data-rawheight="619" class="origin_image zh-lightbox-thumb" width="821" data-original="https://pic3.zhimg.com/v2-4572b4077ea97f4eee54865b623b34e6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-4572b4077ea97f4eee54865b623b34e6_b.jpg" data-caption="" data-size="normal" data-rawwidth="821" data-rawheight="619" class="origin_image zh-lightbox-thumb lazy" width="821" data-original="https://pic3.zhimg.com/v2-4572b4077ea97f4eee54865b623b34e6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-4572b4077ea97f4eee54865b623b34e6_b.jpg"/></figure><p>那Rust项目源码的结构是什么呢？</p><p>首先肯定是它的包组织结构。</p><p>现代化的编程语言，要考虑到协作和开发效率，良好的包管理和模块化是必不可少的。Rust语言作为现代化的编程语言，自然全都包含了。但它最突出的其实就是包管理工具，Cargo。</p><p>Cargo其实已经突破了包管理工具，它其实已经算是一个工作流工具了。而Cargo管理的包，在rust里就叫crate，它是编译的最小单元。</p><p>要确定一个Rust开源项目代码写的好不好，首先要看它的组织结构，是不是按crate来划分的。像Substrate源码就划分的非常好，这样细粒度的划分也极大地提升了可读性。</p><p>所以，阅读一个Rust项目之前，先要了解Rust包管理、模块化等相关概念。关于Cargo的资料可以在<a href="https://link.zhihu.com/?target=http%3A//crates.io" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">crates.io</span><span class="invisible"></span></a>中找到详细的文档。</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-a255a0cf24472f102e4b4564d7d54abb_b.jpg" data-caption="" data-size="normal" data-rawwidth="832" data-rawheight="574" class="origin_image zh-lightbox-thumb" width="832" data-original="https://pic4.zhimg.com/v2-a255a0cf24472f102e4b4564d7d54abb_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-a255a0cf24472f102e4b4564d7d54abb_b.jpg" data-caption="" data-size="normal" data-rawwidth="832" data-rawheight="574" class="origin_image zh-lightbox-thumb lazy" width="832" data-original="https://pic4.zhimg.com/v2-a255a0cf24472f102e4b4564d7d54abb_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-a255a0cf24472f102e4b4564d7d54abb_b.jpg"/></figure><p>一个项目的结构，除了最直观的模块组织结构之外，还有一个内在的结构，那就是抽象架构。</p><p>抽象架构是和程序想表达的业务思想相关联的。要分析一个项目的抽象架构，必须从两个方面着手：</p><p>1. 业务/领域知识</p><p>2. 所用语言的抽象工具。在Rust里呢，就是trait、泛型和结构体、枚举</p><p>所以，在阅读源码之前，先得对这两方面的知识有所了解。</p><p class="ztext-empty-paragraph"><br/></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-d8e8d2427e4ba0681d1018db2dab17b4_b.jpg" data-caption="" data-size="normal" data-rawwidth="821" data-rawheight="543" class="origin_image zh-lightbox-thumb" width="821" data-original="https://pic1.zhimg.com/v2-d8e8d2427e4ba0681d1018db2dab17b4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-d8e8d2427e4ba0681d1018db2dab17b4_b.jpg" data-caption="" data-size="normal" data-rawwidth="821" data-rawheight="543" class="origin_image zh-lightbox-thumb lazy" width="821" data-original="https://pic1.zhimg.com/v2-d8e8d2427e4ba0681d1018db2dab17b4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-d8e8d2427e4ba0681d1018db2dab17b4_b.jpg"/></figure><p>那么接下来，我们以substrate-network为例来实践一下上面的方法。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-97907bba515dae56a5080673106cec4e_b.jpg" data-caption="" data-size="normal" data-rawwidth="810" data-rawheight="506" class="origin_image zh-lightbox-thumb" width="810" data-original="https://pic3.zhimg.com/v2-97907bba515dae56a5080673106cec4e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-97907bba515dae56a5080673106cec4e_b.jpg" data-caption="" data-size="normal" data-rawwidth="810" data-rawheight="506" class="origin_image zh-lightbox-thumb lazy" width="810" data-original="https://pic3.zhimg.com/v2-97907bba515dae56a5080673106cec4e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-97907bba515dae56a5080673106cec4e_b.jpg"/></figure><p>首先，我们来确定一个小目标。 </p><p>需要了解如何使用substrate框架写上层的应用，有很多资料，包括一块链习这个课程。但是如果要写更复杂的项目，就需要往深入探索。</p><p>拿我自己来说，我对libp2p就比较好奇。有人说，libp2p是未来的web协议，虽然这话有点夸张，但也说明了一个趋势。十多年前，我刚开始学习网络相关内容的时候，接触的是C/S结构，但是现在，网络已经开始向去中心化迁移，分布式对等网络很难说不会成为主流。所以我对libp2p比较感兴趣。</p><p>但是在深入libp2p之前，我想知道它是如何使用的，所以，substrate的network crate正好是一个起点。</p><p>那么就定了这个小目标：想要通过阅读network crate来了解libp2p。 </p><p>正好趁这次分享的机会，来了解下libp2p。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-ae85bc4e2d15fe6f4bc7a073ef843c62_b.jpg" data-caption="" data-size="normal" data-rawwidth="835" data-rawheight="594" class="origin_image zh-lightbox-thumb" width="835" data-original="https://pic3.zhimg.com/v2-ae85bc4e2d15fe6f4bc7a073ef843c62_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-ae85bc4e2d15fe6f4bc7a073ef843c62_b.jpg" data-caption="" data-size="normal" data-rawwidth="835" data-rawheight="594" class="origin_image zh-lightbox-thumb lazy" width="835" data-original="https://pic3.zhimg.com/v2-ae85bc4e2d15fe6f4bc7a073ef843c62_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-ae85bc4e2d15fe6f4bc7a073ef843c62_b.jpg"/></figure><p>在确定了小目标之后，我们就来观察一下具体的代码组织结构了。先来看看substrate整个项目的组织结构。</p><p>首先它是一个大的workspace，也就是说，它包含了很多的子crate。这是非常好的代码组织习惯，不愧是substrate。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-c056d6ceb89e94154746136871f1f700_b.jpg" data-caption="" data-size="normal" data-rawwidth="841" data-rawheight="634" class="origin_image zh-lightbox-thumb" width="841" data-original="https://pic1.zhimg.com/v2-c056d6ceb89e94154746136871f1f700_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-c056d6ceb89e94154746136871f1f700_b.jpg" data-caption="" data-size="normal" data-rawwidth="841" data-rawheight="634" class="origin_image zh-lightbox-thumb lazy" width="841" data-original="https://pic1.zhimg.com/v2-c056d6ceb89e94154746136871f1f700_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-c056d6ceb89e94154746136871f1f700_b.jpg"/></figure><p>接下来打开 core/network 的目录，可以看到，代码量其实不是很多。这就是划分为子crate的好处，让阅读代码的人，不会感到有太大压力。</p><p>通过Cargo.toml可以看得出来，这个库里依赖了哪些重要的库。libp2p是最基本的，最常用的serde序列化反序列化库，还有futures库，表示其代码里用到了异步功能，看版本是0.3，说明使用了Rust最新的异步语法。</p><p>通过这些初步的信息可以给我们留下一个整体的印象。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-264f4cfbf9614de5925dc1c7bc2a3366_b.jpg" data-caption="" data-size="normal" data-rawwidth="804" data-rawheight="532" class="origin_image zh-lightbox-thumb" width="804" data-original="https://pic3.zhimg.com/v2-264f4cfbf9614de5925dc1c7bc2a3366_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-264f4cfbf9614de5925dc1c7bc2a3366_b.jpg" data-caption="" data-size="normal" data-rawwidth="804" data-rawheight="532" class="origin_image zh-lightbox-thumb lazy" width="804" data-original="https://pic3.zhimg.com/v2-264f4cfbf9614de5925dc1c7bc2a3366_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-264f4cfbf9614de5925dc1c7bc2a3366_b.jpg"/></figure><p>接下来我们需要了解这个库的抽象架构。</p><p>抽象架构离不开业务领域知识。所以我们需要先去了解业务相关的知识，这里就不多说了，我们已经知道network库是substrate的底层网络组件，区块节点之间的通信和交易都将由它来提供底层的网络服务，包括交易池。</p><p>network是严重依赖于libp2p实现的。当然，这也是我选择这个库的原因，正好学习一下libp2p的用法。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-cb2fef90232a05cc6d24f5ec96e5c773_b.jpg" data-caption="" data-size="normal" data-rawwidth="832" data-rawheight="545" class="origin_image zh-lightbox-thumb" width="832" data-original="https://pic4.zhimg.com/v2-cb2fef90232a05cc6d24f5ec96e5c773_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-cb2fef90232a05cc6d24f5ec96e5c773_b.jpg" data-caption="" data-size="normal" data-rawwidth="832" data-rawheight="545" class="origin_image zh-lightbox-thumb lazy" width="832" data-original="https://pic4.zhimg.com/v2-cb2fef90232a05cc6d24f5ec96e5c773_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-cb2fef90232a05cc6d24f5ec96e5c773_b.jpg"/></figure><p>接下来要看看trait和结构体。</p><p>在Rust里，trait可以说是灵魂般的存在，它是抽象的基石。trait可以作为接口，也可以作为类型的限定，但我把它统一看作是一种「行为的抽象」。</p><p>而结构体，则是实体的抽象。</p><p>实体和行为，构成了这个世界。以这种视角来看待源码，理解起来更容易一些。</p><p>然后我们可以直接打开这个包的文档来看具体的结构体和trait。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-1bf70209a9d15985f7c1ca155958d035_b.jpg" data-caption="" data-size="normal" data-rawwidth="853" data-rawheight="610" class="origin_image zh-lightbox-thumb" width="853" data-original="https://pic2.zhimg.com/v2-1bf70209a9d15985f7c1ca155958d035_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-1bf70209a9d15985f7c1ca155958d035_b.jpg" data-caption="" data-size="normal" data-rawwidth="853" data-rawheight="610" class="origin_image zh-lightbox-thumb lazy" width="853" data-original="https://pic2.zhimg.com/v2-1bf70209a9d15985f7c1ca155958d035_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-1bf70209a9d15985f7c1ca155958d035_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>首先看一下这个trait，这只是公开的trait，但从这些trait中可以发现一些蛛丝马迹。</p><p>首先，这个包里包含了client的本地抽象，以及网络相关的上下文信息。</p><p>其次，还有用于节点发现的网络行为 DiscoveryBehaviour </p><p>还有交易池接口等等。</p><p>看到这里，你可以结合业务来思考一下，为什么要这么抽象。比如交易池为什么是个接口，为什么是个trait呢？这样的思考就可以帮助你学习如何用Rust来思考和抽象业务。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-a2ae8276e5de58c697bfbb2804b9962c_b.jpg" data-caption="" data-size="normal" data-rawwidth="844" data-rawheight="609" class="origin_image zh-lightbox-thumb" width="844" data-original="https://pic1.zhimg.com/v2-a2ae8276e5de58c697bfbb2804b9962c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-a2ae8276e5de58c697bfbb2804b9962c_b.jpg" data-caption="" data-size="normal" data-rawwidth="844" data-rawheight="609" class="origin_image zh-lightbox-thumb lazy" width="844" data-original="https://pic1.zhimg.com/v2-a2ae8276e5de58c697bfbb2804b9962c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-a2ae8276e5de58c697bfbb2804b9962c_b.jpg"/></figure><p>再来看结构体</p><p>你会发现很多和网络 networker相关的实体，包括Peerid，看到Peerid我很自然地想到了操作系统里的进程，每个进程都有进程ID，这样类比的话，理解起来就比较具象化，尤其是初次接触分布式网络的人。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-2766d50f67c49759584a1d74ba8d4a1d_b.jpg" data-caption="" data-size="normal" data-rawwidth="837" data-rawheight="604" class="origin_image zh-lightbox-thumb" width="837" data-original="https://pic2.zhimg.com/v2-2766d50f67c49759584a1d74ba8d4a1d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-2766d50f67c49759584a1d74ba8d4a1d_b.jpg" data-caption="" data-size="normal" data-rawwidth="837" data-rawheight="604" class="origin_image zh-lightbox-thumb lazy" width="837" data-original="https://pic2.zhimg.com/v2-2766d50f67c49759584a1d74ba8d4a1d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-2766d50f67c49759584a1d74ba8d4a1d_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>经过上面的探索，我们基本了解了network的一些抽象架构。但是对于libp2p的知识还是有些朦胧。</p><p>但是好在网上还有很多资料，可以让我们从libp2p有一个整体认知。</p><p>做分布式网络，要面对复杂的异构的网络环境。有句话怎么说来着，「计算机科学中的任何问题，都可以通过加上一层逻辑层来解决」。那么libp2p就是在传统的网络协议上，重新做了统一的抽象层。</p><p>就像右边这个图，在传统的tcp协议上，又加了secio加密层，yamux多路复用层等等。 重点在于多路复用，同一个端口就把所有的事干了。开发者再也不用去为了兼容复杂的网络环境去干那些脏活累活了，可以专心专注于业务。</p><p>这就是分层的好处。当然，libp2p还有很多功能，这里就不列了。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-a64b13684bb98500c584119ab05599ed_b.jpg" data-caption="" data-size="normal" data-rawwidth="825" data-rawheight="628" class="origin_image zh-lightbox-thumb" width="825" data-original="https://pic2.zhimg.com/v2-a64b13684bb98500c584119ab05599ed_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-a64b13684bb98500c584119ab05599ed_b.jpg" data-caption="" data-size="normal" data-rawwidth="825" data-rawheight="628" class="origin_image zh-lightbox-thumb lazy" width="825" data-original="https://pic2.zhimg.com/v2-a64b13684bb98500c584119ab05599ed_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-a64b13684bb98500c584119ab05599ed_b.jpg"/></figure><p>经过这些梳理，然后再去看代码，线索就非常清晰了。</p><p>这份简单的脑图是我做PPT的时候同时整理出来的，大家可以根据这个思路自己去看看源码，自己去整理一下。</p><p>简单来说明一下这个结构。</p><p>network crate源码主要可以分成这么6个结构。</p><ol><li>service主要用于处理网络I/O和管理连接，也包括交易池的管理，广播交易什么的。</li><li>而discorery部分，主要定义了通用的网络行为，这里整合了所有的网络协议。用于发现节点。</li><li>protocol部分，是用于处理请求，主要是协议升级，比如从tcp按需给请求升级到相应的协议。这里面有一个substream 子流的概念，子流才是真正的请求。具体这里处理的时候使用了Rust的异步。</li><li>transpot是底层的公共传输基础，相当于是对libp2p底层的网络初始配置，比如配置yamux的多路复用之类。</li><li>chains是对本地客户端的抽象</li><li>config是网络初始化的一些配置。</li></ol><p>总的来说，这个库内容并不多。</p><p>但是看的过程中，发现了很多还不太懂的知识点，比如我罗列的这些问题列表。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-513cebff03f5f1eea9b8f7079759deca_b.jpg" data-caption="" data-size="normal" data-rawwidth="830" data-rawheight="589" class="origin_image zh-lightbox-thumb" width="830" data-original="https://pic3.zhimg.com/v2-513cebff03f5f1eea9b8f7079759deca_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-513cebff03f5f1eea9b8f7079759deca_b.jpg" data-caption="" data-size="normal" data-rawwidth="830" data-rawheight="589" class="origin_image zh-lightbox-thumb lazy" width="830" data-original="https://pic3.zhimg.com/v2-513cebff03f5f1eea9b8f7079759deca_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-513cebff03f5f1eea9b8f7079759deca_b.jpg"/></figure><p>交易池的具体细节是什么？优先级啊，还有什么双花交易啊，标准交易啊，这些如何体现？</p><p>yamux多路复用的细节，cossip协议和共识、kademlia算法和结构化网络、以及如何自定义网络协议等。</p><p>这些知识点，是从看源码过程中挖掘出来的，如果没有看这些源码，我根本不知道我不懂这些，甚至不知道这些知识点的存在。</p><p>这些问题也可以成为我后面深入学习的方向。</p><h3>小结</h3><p>希望这篇分享，能给大家带来一些启迪。</p><p></p>