<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>基于模运算的校验码（们）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34592759">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-d6d2c98e18208f7e38c046147c2d202f_r.jpg" alt=""></div><h2>内容</h2><ul><li>“条形码”</li><li>国际标准书号ISBN</li><li>第二代身份证</li></ul><hr><h2>“条形码”</h2><p>通常讲的“条形码”，源头是<b>UPC（universal product code，商品统一代码）</b>。这是由美国的乔·伍德兰德（Joe Woodland）和贝尼·西尔佛（Beny Silver）两位工程师研究出来的，最初他们用条形码表示食品项目并研制相应的识别系统设备。1949年获得了美国的专利。UPC码共有A、B、C、D、E等五种版本（就不详细列出了）。</p><p>我国目前常用的条形码实际上是<b>EAN（European Article Number）</b>条码。</p><p>EAN条码是欧洲的国际物品编码协会（International Article<br>Numbering Association）制定的一种条码，在UPC-A标准的基础上建立。EAN条码符号有标准版和缩短版两种，标准版由13位数字构成，又称为EAN-13码，缩短版表示8位数字构成，又称为EAN-8码。两种条码的最后一位为校验位，由前面的12位或7位数字计算得出。我国于1991年加入EAN组织。</p><p>（题图就是一种食品的EAN-13码）</p><p>EAN-13码由前缀码、生产厂商代码（厂商识别码）、商品项目代码和校验码组成。</p><ul><li>前缀码是国际EAN组织标识各会员组织的代码，我国为690-695；</li><li>变长的生产厂商代码是EAN编码组织分配给厂商的代码；</li><li>商品项目代码由厂商自行编码；</li><li>校验码，只有一位，取值范围从0到9，目的是校验代码的正确性。计算方法是用1分别乘以EAN-13的前12位(位数从左到右为1到12）中的奇数位，用3乘以偶数位，二者求和得到结果<i>S</i>，然后校验码为 <equation>(10-S)(\mod 10)</equation> 。</li></ul><p>换言之用1分别乘以EAN-13的所有奇数位(位数从左到右为1到13），用3乘以全部偶数位，二者的和是10的倍数。</p><p>例如：某产品的条形码的前12位是694 021189000，那么按照下图可以计算出来最后一位为4。</p><img src="https://pic1.zhimg.com/v2-7028868d5c141d7bd6622fab464616b6_r.jpg" data-caption="" data-size="normal" data-rawwidth="853" data-rawheight="110"><hr><h2>新版国际标准书号ISBN-13</h2><p>为什么叫做“新版”呢？是因为ISO于1972年颁布了ISBN国际标准，2007年1月1日前，ISBN由10位数字组成。而2007年1月1日起，实行新版ISBN。</p><p>新版国际标准书号（International Standard Book<br>Number）号码由13位数字组成，并以四个连接号或四个空格加以分割，每组（共5组）数字都有固定的含义。</p><ul><li>第一组：978或979；</li><li>第二组：国家、语言或区位代码（例如中国大陆为“978-7”表示汉语）；</li><li>第三组：表示出版社代码，由各国家或地区的国际标准书号分配中心，分配给各个出版社；</li><li>第四组：书序码，是该出版物的代码，由出版社具体给出；</li><li>第五组：校验码，只有一位，计算方法与EAN-13相同。</li></ul><p>例如：我觉得有一本很好的书，ISBN是978-7-302-32015-？。其中，</p><ul><li>978-7表示汉语；</li><li>302表示出版社为“清华大学出版社”；</li><li>32015为图书的代码；</li><li>9+8+3+2+2+1=25，3(7+7+0+3+0+5)=66，于是校验码为(10-(25+66))(mod 10)=9。</li></ul><p>所以这本写得很好的书的完整的ISBN是：978-7-302-32015-9。</p><p><br></p><hr><h2>第二代居民身份证</h2><p>1984年4月6日国务院发布《中华人民共和国居民身份证试行条例》，并且开始颁发第一代居民身份证。2004年3月29日起，中国大陆正式开始为居民换发第二代居民身份证。</p><p>第二代居民身份证的编码方法是：</p><img src="https://pic3.zhimg.com/v2-fb4b13a3ea93f61171ab54297adccc47_r.jpg" data-caption="" data-size="normal" data-rawwidth="768" data-rawheight="137"><ul><li>前1、2位数字表示所在省（直辖市、自治区）的代码（例如北京市为11）</li><li>第3、4位数字表示所在地级市（自治州）的代码</li><li>第5、6位数字表示所在区（县、自治县、县级市）的代码</li><li>第7-14位数字表示出生年月日</li><li>第15、16位数字表示所在地的派出所的代码</li><li>第17位数字表示性别，奇数表示男性，偶数表示女性</li><li>第18位数字是校检码（由前17位计算得来）</li></ul><p>校检码的计算方法符合ISO/IEC 7064:2003：</p><p>为表述的方便性，将身份证的18位数自左而右记作 <equation>K_{17}, K_{16},…, K_1, K_0</equation> 。</p><p><b>1.</b> 将前17位数分别乘以不同的系数。从左至右前17位的系数（ <equation>W_{17}, W_{16},…, W_1, W_0</equation> ）分别为：7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2。</p><p>——可以看出 <equation>W_i = 2^i (\mod 11)</equation> </p><p><b>2.</b> 将这17个数字和系数相乘的结果累加后模11求余；</p><p><b>3.</b> 余数0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10分别对应（相当于下述公式中的函数 <equation>f</equation> ）的校验码为1, 0, X, 9, 8, 7, 6, 5, 4, 3, 2。</p><p>——即校验码与余数的和模11余1，X代表10。（这是因为10在罗马数字中表示作X）。</p><p>这个计算方法使用公式表示就是： <equation>K_0=f\left( \sum_{i=1}^{17}{K_i\times W_i\mod 11} \right)=\left(12- \sum_{i=1}^{17}{K_i\times W_i} \right)\mod 11</equation> 。</p><p>于是， <equation> \sum_{i=0}^{17}{K_i\times W_i} \equiv 1(\mod 11)</equation> ，即 <equation> \sum_{i=0}^{17}{K_i\times 2^i} \equiv 1(\mod 11)</equation> 。</p><p>例如：一个（虚拟）的身份证号的前17位为11010420180915195，最后一位校验码的计算过程是：</p><img src="https://pic4.zhimg.com/v2-259411bd0473937b28a8ed6e1bf46583_r.jpg" data-caption="" data-size="normal" data-rawwidth="831" data-rawheight="161"><p><equation>\left( \sum_{i=1}^{17}{K_i\times W_i\mod 11} \right)=\left( 241 \mod 11 \right)=10</equation> </p><p>再通过查表即得校验码是2：</p><img src="https://pic2.zhimg.com/v2-67a85c93d4be2c67c9f1f6e6dab40c08_r.jpg" data-caption="" data-size="normal" data-rawwidth="814" data-rawheight="92"><hr><p><b>（一）</b>第二代身份证的验证码可以<b>发现1个字符的错误</b>——</p><p>假设某个 <equation>K_j</equation> 被错抄成 <equation>K'_j </equation> ，那么计算错误的身份证的 <equation>\left( \sum_{i=0,i\ne j}^{17}{K_i\times 2^i+K'_j\times 2^j} \right)\mod 11</equation> 。它和正确的校验和 <equation>\left( \sum_{i=0}^{17}{K_i\times 2^i\mod 11} \right)=1</equation> 相比，差异为 <equation>\left( K'_j-K_j \right)\times 2^j</equation> 。由于2和 <equation>\left( K'_j-K_j \right)</equation> 都与素数11矛盾，因此 <equation>\left( K'_j-K_j \right)\times 2^j\mod 11\ne 0</equation> ，于是 <equation>\left( \sum_{i=1,i\ne j}^{17}{K_i\times 2^i+K'_j\times 2^j} \right)\mod 11\ne 0</equation> ，不能通过校验。</p><p><b>（二）</b>第二代身份证的验证码可以<b>纠正1个已知位置的错误</b>——</p><p>假设某个 <equation>K_j</equation> 被错抄成 <equation>K'_j </equation> ，那么计算错误的身份证的校验和为 <equation>\left( \sum_{i=1,i\ne j}^{17}{K_i\times 2^i+K'_j\times 2^j} \right)\mod 11\ne 1</equation>  。可以通过 <equation>K_j=\left( K'_j-\left( \sum_{i=0,i\ne j}^{17}{K_i\times 2^i+K'_j\times 2^j-1} \right)\times 6^j \right)\mod 11</equation> 计算恢复出正确的 <equation>K_j</equation> 。</p><p><b>（三）</b>第二代身份证的验证码可以<b>发现2个相邻字符的颠倒错误</b>——</p><p>假设某个 <equation>K_j</equation> 和被 <equation>K_{j+1}</equation> 抄颠倒，那么错误的身份证的校验和 <equation>\left( \sum_{i=0,i\ne j,i\ne j+1}^{17}{K_i\times 2^i+K_{j+1}\times 2^j+K_j\times 2^{j+1}} \right)\mod 11</equation> 。它和正确的校验和 <equation>\left( \sum_{i=0}^{17}{K_i\times 2^i\mod 11} \right)=1</equation> 相比，差异为 <equation>\left( K_j-K_{j+1} \right)\times \left( 2^{j+1}-2^j \right)\mod 11=\left( K_j-K_{j+1} \right)\times 2^j\mod 11</equation> 。由于2和 <equation>\left( K_j-K_{j+1} \right)</equation> 都与素数11矛盾，因此 <equation>\left( K_j-K_{j+1} \right)\times 2^j\mod 11\ne 0</equation> ，于是 <equation>\left( \sum_{i=0,i\ne j,i\ne j+1}^{17}{K_i\times 2^i+K_{j+1}\times 2^j+K_j\times 2^{j+1}} \right)\mod 11\ne 0</equation> ，不能通过校验。</p><hr><p>最后，提一句，二维码的纠错能力很强，所以可以牺牲一些信息做出特型二维码，那是因为它使用了更复杂的纠错码——通常是<b>Reed–Solomon codes</b>，而它，就复杂得多了。</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
