<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>200行代码编写自己的区块链</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/47289171">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-efd514c0c42c2fbd0a7de77a9427c205_r.jpg" alt=""></div><p></p><p> 世界上几乎每个开发人员都听说过区块链，但大多数仍然不知道它是如何工作的。他们可能仅仅是因为比特币才知道它，因为他们听说过智能合约之类的东西。这篇文章试图帮助你用Go语言来写一个简单的区块链来弄清楚区块链，而这只需要不到200行代码。在这篇教程结束时，你将能够在本地运行和写入区块链并且用Web浏览器查看它。</p><p>有什么能比开发一个自己的区块更好学习了解区块链的方法？</p><p>你将可以做到</p><p> 建造你自己的区块链</p><p> 了解hash如何在保持区块完整性</p><p> 了解如何添加新区快</p><p>了解多个节点如何竞争生成块</p><p>用web浏览器查看你的区块链</p><p>写新的区块</p><p>了解区块链的基本知识，以便你可以从这里决定你的旅程</p><p>你将无法做到的</p><p>为了使这篇文章变得简单，我们将不会处理更高级的共识概念，例如工作证明与权益证明。将模拟网络交互，以便您可以查看区块链并查看添加的块，但网络广播将保留用于下一篇的文章里。</p><p>让我们开始吧</p><p>设置</p><p>由于我们将在Go中编写代码，因此我们假设您已经拥有Go的一些开发经验。经过安装和配置Go语言，我们还想获取以下软件包：</p><p><code class="inline">go get github.com/davecgh/go-spew/spew</code></p><p>Spew允许我们在console中清楚地查看structs和slices地格式，这很好。</p><p>go get github.com/gorilla/mux</p><p>Gorilla / mux是一个流行的用于编写Web处理器的程序包，我们需要这个。</p><p>go get github.com/joho/godotenv</p><p>Godotenv允许我们读取保存在根目录中的.env文件，这样我们就不必硬编码如http端口之类的东西。我们也需要这个。</p><p>让我们在根目录中创建一个.env文件，定义了将为HTTP请求服务的端口。就只要在这个文件中加一行：</p><p>  ADDR=8080</p><p>创建一个main.go文件。从现在开始，所有内容都将写入此文件，并且将少于200行代码。让我们来编码吧！</p><p>输入</p><p>以下是我们需要的输入以及我们的程序包说明。让我们把这些写进main.go里。</p><p>package main</p><p>import (</p><p>"crypto/sha256"</p><p>"encoding/hex"</p><p>"encoding/json"</p><p>"io"</p><p>"log"</p><p>"net/http"</p><p>"os"</p><p>"time"</p><p>"github.com/davecgh/go-spew/spew"</p><p>"github.com/gorilla/mux"</p><p>"github.com/joho/godotenv"</p><p>)</p><p><b><a href="https://gist.github.com/nosequeldeebee/31eb4dea07973985c05ab61860ba11c8/raw/3244b4ec43fd7d4fd7b5e133a4aa86ade3329de1/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/31eb4dea07973985c05ab61860ba11c8#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>数据模型</p><p>让我们定义要组成区块链的每一个块的struct。别担心，我们将在一分钟内解释所有这些字段的含义。</p><p>type Block struct {</p><p>Index int</p><p>Timestamp string</p><p>BPM int</p><p>Hash string</p><p>PrevHash string</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/6319c092b8a8c49a101318158d50efb6/raw/bc4054c8caa363f8a16a94d2b4461d77418864ec/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/6319c092b8a8c49a101318158d50efb6#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>每个区块都包含将要被写入区块链的数据并且代表了当你采用脉搏速率时的每一种情况（还记得你在文章开头时做的吗？）</p><p>Index 是这个块在区块链中的位置</p><p>Timestamp 是自动确定的，也是数据写入的时间</p><p>BPM 或每分钟心脏跳动，是你的脉搏速率</p><p>Hash 是表示此数据记录的SHA256标识符</p><p>PrevHash 是链中先前记录的SHA256标识符</p><p>让我们来模拟区块链本身，这是一个简单区块的slice</p><p>var Blockchain []Block</p><p><b><a href="https://gist.github.com/nosequeldeebee/9668956ac40a7098cf2bab6379ec9266/raw/1d0b30ebe665ebc8f9ea419ec455580552057c3c/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/9668956ac40a7098cf2bab6379ec9266#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>那么散列值如何适应区块和区块链？我们用hash来确认和保持区块在一个正确的顺序当中。通过确定每个区块的父区块哈希值与之前一个区块的哈希值是完全相同的，我们就知道区块以正确的顺序组成了块链。</p><img src="https://pic2.zhimg.com/v2-db3f6e5982ce6e4b565fdb689ffa0a27_r.jpg" data-caption="" data-size="normal" data-rawwidth="429" data-rawheight="130" data-watermark="watermark" data-original-src="v2-db3f6e5982ce6e4b565fdb689ffa0a27" data-watermark-src="v2-5f98ff640c4464429c153c41a3916317" data-private-watermark-src=""><img src="https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_r.jpg" data-caption="" data-size="normal"><p><br></p><p>散列和生成新的区块</p><p>那么为什么我们需要哈希？我们哈希数据有两个主要原因：</p><p>为了节省空间。哈希值来自区块上的所有数据。在我们的例子中，我们只有几个数据点，但想象若我们有数百，数千或数百万个先前块的数据。将数据散列到单个SHA256字符串或散列哈希将比一遍又一遍地复制前面块中的所有数据要高效得多。</p><p>保持区块链的完整性。通过像我们在上图中那样存储先前的哈希值，我们能够确保区块链中的块的顺序正确。如果恶意的一方进入并试图操纵数据（例如，改变我们的心率来修复人寿保险价格），哈希会迅速变化，链条会“破裂”，每个人都会知道不信任恶意链。</p><p>让我们编写一个函数来获取我们的区块数据并创建它的SHA256哈希值。</p><p>func calculateHash(block Block) string {</p><p>record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash</p><p>h := sha256.New()</p><p>h.Write([]byte(record))</p><p>hashed := h.Sum(nil)</p><p>return hex.EncodeToString(hashed)</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/a4953a59257c21fc706319fadc6b9ac1/raw/976a0d992a0f8bac7ddc57a743a15ce1bf1ce377/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/a4953a59257c21fc706319fadc6b9ac1#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>这个calculateHash函数连接了我们提供的Index，Timestamp，BPM，和区块的PrevHash作为参数，并计算出SHA256哈希值。现在我们可以用一个新的generateBlock函数生成一个包含我们所有需要元素的区块。我们需要提供一个以前的区块以便我们可以在BPM里得到它的哈希值和我们的脉搏速率。不用担心 BPM int 参数的传入。我们将在之后处理它。</p><p>func generateBlock(oldBlock Block, BPM int) (Block, error) {</p><p>var newBlock Block</p><p>t := time.Now()</p><p>newBlock.Index = oldBlock.Index + 1</p><p>newBlock.Timestamp = t.String()</p><p>newBlock.BPM = BPM</p><p>newBlock.PrevHash = oldBlock.Hash</p><p>newBlock.Hash = calculateHash(newBlock)</p><p>return newBlock, nil</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/962b6150bd204c5c9ed83d8b58912256/raw/7e238484bf7e4431671ea06653c04bce9f5627db/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/962b6150bd204c5c9ed83d8b58912256#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p> 请注意，当前时间会自动写入区块中的time.Now()。还要注意我们之前的calculateHash函数被调用了。PrevHash从前一个块的哈希值中复制而来。Index则是从前一个块的索引递增而得出。</p><p>块验证</p><p>现在我们需要编写一些函数来确保块没有被篡改。我们通过检查Index来确保它们按预期增加。我们还检查以确保我们的PrevHash确实与前一个块的Hash相同。最后，我们想通过在当前块上再次运行calculateHash函数来仔细检查当前块的哈希值。让我们编写一个isBlockValid函数来完成所有这些事情并返回一个bool。如果通过我们的所有检查，它将返回一个真值：</p><p>func isBlockValid(newBlock, oldBlock Block) bool {</p><p>if oldBlock.Index+1 !=   newBlock.Index {</p><p>return false</p><p>}</p><p>if oldBlock.Hash !=   newBlock.PrevHash {</p><p>return false</p><p>}</p><p>if calculateHash(newBlock) !=   newBlock.Hash {</p><p>如果我们遇到一个问题，即我们的区块链生态系统的两个节点都在其链条中添加了块，而我们都收到了它们。我们选择哪一个作为真相的来源？我们选择最长的链条。这是一个经典的区块链问题，与恶意的人员没有任何关系。</p><p>两个具有良好意义的节点可能只是具有不同的链长，因此自然地，较长的节点将是最新的并且具有最新的块。因此，让我们确保我们所采用的新链比我们现有的链更长。如果是，我们可以使用具有新块的新链覆盖我们的链。</p><img src="https://pic3.zhimg.com/v2-c20f20251bdcd0d81cfaa706bfa981ec_r.jpg" data-caption="" data-size="normal" data-rawwidth="416" data-rawheight="198" data-watermark="watermark" data-original-src="v2-c20f20251bdcd0d81cfaa706bfa981ec" data-watermark-src="v2-724bf40782611eec79e88913f6213561" data-private-watermark-src=""><p><br></p><p>我们只需比较链的slice的长度即可：</p><p>func replaceChain（newBlocks [] Block）{</p><p>if len（newBlocks）&gt; len（Blockchain）{</p><p>Blockchain = newBlocks</p><p>}</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/1b440f7c2be24140c45a9bf0ed8a9520/raw/f96ee91c97141f495ae2fade1b658e6df961ec19/main.go">查看</a></b>由<b><a href="https://github.com/">GitHub</a></b>用❤托管的<b><a href="https://gist.github.com/nosequeldeebee/1b440f7c2be24140c45a9bf0ed8a9520/raw/f96ee91c97141f495ae2fade1b658e6df961ec19/main.go">raw</a><a href="https://gist.github.com/nosequeldeebee/1b440f7c2be24140c45a9bf0ed8a9520#file-main-go">main.go</a></b></p><p>如果你已经做到了这一步，那就赞扬一下自己吧！我们已经基本上写出了区块链的精髓和我们需要的各种函数。</p><p>现在我们想要一种方便的方式来查看我们的区块链并写入它，理想情况是在web浏览器中，这样我们就可以向朋友展示！</p><p> web服务器</p><p> 我们假设你已经熟悉web服务器是如何运作的，并且在Go语言中有一些经验。我们现在讲给你解释整个过程。</p><p>我们将使用您之前下载的Gorilla / mux软件包来为我们做些繁重的工作。</p><p>让我们在稍后调用的run函数中创造我们的服务器。</p><p>func run() error {</p><p>mux := makeMuxRouter()</p><p>httpAddr := os.Getenv("ADDR")</p><p>log.Println("Listening on ", os.Getenv("ADDR"))</p><p>s := &amp;http.Server{</p><p>Addr: ":" + httpAddr,</p><p>Handler: mux,</p><p>ReadTimeout: 10 * time.Second,</p><p>WriteTimeout: 10 * time.Second,</p><p>MaxHeaderBytes: 1 &lt;&lt; 20,</p><p>}</p><p>if err := s.ListenAndServe(); err != nil {</p><p>return err</p><p>}</p><p>return nil</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/7b179dce15f0a78e72e23f53341eaab0/raw/b98250ba7068827e9ef6294834fb8726e5cd9600/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/7b179dce15f0a78e72e23f53341eaab0#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>要注意的是我们选的这个端口是来自于我们之前创建的.env文件。我们用log.Println给我们一个快速的console消息让我们知道服务器已经启动并运行。我们稍微配置服务器ListenAndServe。这是个很标准的Go语言。</p><p>现在我们需要编写makeMuxRouter函数定义所有的handler程序。要在浏览器中查看和写入我们的区块链，我们只需要2条路线并且保证他们足够简单。如果我们发送GET请求给localhost，我们将可以查看我们的区块链。如果我们发送一个POST请求给它，我们可以对它写入。</p><p>func makeMuxRouter() http.Handler {</p><p>muxRouter := mux.NewRouter()</p><p>muxRouter.HandleFunc("/", handleGetBlockchain).Methods("GET")</p><p>muxRouter.HandleFunc("/", handleWriteBlock).Methods("POST")</p><p>return muxRouter</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/2215e094e80d0e988fb6852010c7658a/raw/339e9e5354b681cf491b5e87c2a6686ed2180f88/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/2215e094e80d0e988fb6852010c7658a#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>这是我们GET请求的handler</p><p>func handleGetBlockchain(w http.ResponseWriter, r *http.Request) {</p><p>bytes, err := json.MarshalIndent(Blockchain, "", "   ")</p><p>if err != nil {</p><p>http.Error(w, err.Error(), http.StatusInternalServerError)</p><p>return</p><p>}</p><p>io.WriteString(w, string(bytes))</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/d8a4b5e705d1c5fe14531ad1c89ee12a/raw/9bf26d6bc92d8c605d74283a716b303cb258f2e2/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/d8a4b5e705d1c5fe14531ad1c89ee12a#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>我们简单地以JSON格式回写完整的区块链，我们可以通过在任何浏览器中访问localhost:8080查看。我们将在.env文件中的ADDR变量设置为8080，因此如果您更改它，请确保访问正确的端口。</p><p>我们的POST要求有点复杂，但也不是很复杂。首先，我们需要一个新的Messagestruct。我们将在很短时间内解释为什么需要它。</p><p>type Message struct {</p><p>BPM int</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/1cede3e517cfb3c37c21e602571ff327/raw/6e792b378b0f037312a685a839e30f567e4cf3bb/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/1cede3e517cfb3c37c21e602571ff327#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>这是编写新块的处理程序的代码。在您阅读完毕后我们会给你解释这个过程。</p><p>func handleWriteBlock(w http.ResponseWriter, r *http.Request) {</p><p>var m Message</p><p>decoder := json.NewDecoder(r.Body)</p><p>if err := decoder.Decode(&amp;m); err != nil {</p><p>respondWithJSON(w, r,   http.StatusBadRequest, r.Body)</p><p>return</p><p>}</p><p>defer r.Body.Close()</p><p>newBlock, err := generateBlock(Blockchain[len(Blockchain)-1], m.BPM)</p><p>if err != nil {</p><p>respondWithJSON(w, r,   http.StatusInternalServerError, m)</p><p>return</p><p>}</p><p>if isBlockValid(newBlock,   Blockchain[len(Blockchain)-1]) {</p><p>newBlockchain := append(Blockchain, newBlock)</p><p>replaceChain(newBlockchain)</p><p>spew.Dump(Blockchain)</p><p>}</p><p>respondWithJSON(w, r,   http.StatusCreated, newBlock)</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/c5bc5adb5c879fa56226c6b1e697b4fd/raw/a29c70be9b6bc92e0a056bb787f47a5240ec4b2d/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/c5bc5adb5c879fa56226c6b1e697b4fd#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>我们使用单独Message结构的原因是接受了将用于编写新块的JSON POST请求的请求体。这允许我们简单地发送一个带有以下主体的POST请求并且我们的handler将为我们填写块的其余部分：</p><p>{"BPM":50}</p><p>这50是以每分钟心脏跳动为单位的脉搏速率示例。通过改变这个整数来使用自己的脉搏速率为这个整数。</p><p>在我们将请求主体解码到我们的var m Message结构中之后，我们通过将前一个块和我们的新脉冲速率传入我们之前编写的generateBlock函数来创建一个新块。这是创建新块所需的功能。我们做了一个快速检查来确定新块是合适使用我们之前创建的isBlockValid函数的。</p><p>几个注解：</p><p>spew.Dump是一个很便利的函数，可以将我们的结构打印到console中，它对调试很有用。</p><p>测试POST请求时，我们喜欢使用Postman。如果你不能远离终端，curl也很有效。</p><p>当我们的POST请求成功或不成功时，我们都希望得到相应的警报。我们使用一些打包函数respondWithJSON让我们知道发生了什么。请记住，在Go中，永远不要忽略错误。优雅地处理它们。</p><p>func respondWithJSON(w http.ResponseWriter, r *http.Request, code int, payload interface{}) {</p><p>response, err := json.MarshalIndent(payload, "", "   ")</p><p>if err != nil {</p><p>w.WriteHeader(http.StatusInternalServerError)</p><p>w.Write([]byte("HTTP 500: Internal Server   Error"))</p><p>return</p><p>}</p><p>w.WriteHeader(code)</p><p>w.Write(response)</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/1ef1a7b9f139250fc0f9bad6d741d582/raw/1220fc1c36bde46f6b8dea293ded29f3fe5f9e01/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/1ef1a7b9f139250fc0f9bad6d741d582#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>几乎要完成了！</p><p>让我们将所有这些不同的区块链函数，网络处理程序和Web服务器连接到一个简短，干净的main函数中：</p><p>func main() {</p><p>err := godotenv.Load()</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>go func() {</p><p>t := time.Now()</p><p>genesisBlock := Block{0, t.String(), 0, "", ""}</p><p>spew.Dump(genesisBlock)</p><p>Blockchain = append(Blockchain, genesisBlock)</p><p>}()</p><p>log.Fatal(run())</p><p>}</p><p><b><a href="https://gist.github.com/nosequeldeebee/b6e5c021c123225d77d84ff778790c11/raw/e706b87ee93283c238c51033c41302c3232646db/main.go">view raw</a><a href="https://gist.github.com/nosequeldeebee/b6e5c021c123225d77d84ff778790c11#file-main-go">main.go</a></b> hosted with ❤ by <b><a href="https://github.com/">GitHub</a></b></p><p>那这里发生了什么</p><p>godotenv.Load()允许我们从我们放置在根目录中的.env文件中读取像端口号之类的变量，这样我们就不必在整个应用程序中对它们进行硬编码。</p><p>genesisBlock是main函数中最重要的部分。我们需要为区块链提供一个初始块，否则新块将无法将其先前的哈希与任何内容进行比较，因为先前的哈希值并不存在。</p><p>我们将创世区块隔离到它自己的goroutine中，这样我们有一个从区块链逻辑和Web服务器逻辑分开的关注。这将在没有go routine的情况下工作，但这使这种方式更清爽。</p><p>耶！ 我们完成了</p><p>这里有完整的代码</p><p>为了一些有趣的东西，让我们试试吧。</p><p>在终端用go run main.go启动你的应用程序。</p><p>在终端中，我们看到Web服务器已启动并正在运行，我们将获得一个创世块的打印输出。</p><img src="https://pic1.zhimg.com/v2-9a7810c558afa6c97fbd0b7922406319_r.jpg" data-caption="" data-size="normal" data-rawwidth="415" data-rawheight="96" data-watermark="watermark" data-original-src="v2-9a7810c558afa6c97fbd0b7922406319" data-watermark-src="v2-25ef4eefce718377fd7700b15cd4ca7a" data-private-watermark-src=""><p><br></p><p>现在用你的端口号访问localhost，对于我们来说这个号是8080。正如我们所预料的，我们见到了相同的创世区块。</p><p>现在，让我们发送一些POST请求来添加块。使用Postman，我们将可以添加一些带有各种BPM的新块。</p><p>让我们刷新我们的浏览器。你看，我们在链中看到的新区块的PrevHash与老区块里的Hash是匹配的，就像我们预期的那样！</p><p>下一步</p><p>恭喜！！您刚刚使用适当的哈希和块验证编写了自己的区块链。您现在应该能够控制自己的区块链之旅，并探索更复杂的主题，如工作证明，股权证明，智能合约，Dapps，侧链等。</p><p>本教程未解决的问题是如何使用工作量证明挖掘新块。这将是一个单独的教程，但大量的区块链的存在没有工作证明机制。此外，当前通过在网络服务器中编写和查看区块链来模拟网络广播。本教程中没有P2P的部分。</p><p><br></p><p>===============================================================<br><b>文章首发在微信公众号：btc201800</b><br><b><a href="https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK">http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK</a></b> <b>(二维码自动识别)</b><br><b>音频发布在喜马拉雅上“区块链杂谈 (第2季)“</b></p><p><b>宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。</b></p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
