<p>给出n个线段的起始点，这n条线段自然可以覆盖已知的线段，那么能否用更少的线段覆盖它们但同一条线段内的线段没有重叠呢？</p><p>比如[0,5],[6,10]这样的，显然可以用1条线段覆盖，因为它们之间没有重叠；但[0,5],[1,6]就只能用两条线段覆盖了。</p><p>问至少需要多少条线段覆盖它们，每条线段内都没有重叠？</p><p>--------------------------我是罪恶的分线---------------------------</p><p>这类无重复区间覆盖、线段覆盖的题目在leetcode上有很多，但似乎都不大一样：</p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/bigtree_3721/article/details/89911532" data-draft-node="block" data-draft-type="link-card" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">blog.csdn.net/bigtree_3</span><span class="invisible">721/article/details/89911532</span><span class="ellipsis"></span></a><p>比如之前信息学有线段树的题目，问一大串这样的线段，问覆盖的总长度是多少；二维就是总面积，三维就是总体积，在现在信息学竞赛高度内卷化的今天，未来4维覆盖问题可以期待。</p><p>当然，其实我自己信息学水平也一般啊，又搜不到答案，就强答一波吧，答案未必正确。</p><p>本来我想用动态规划的，但似乎很难划分状态，似乎过去的分法都会影响未来。</p><p>当然，搜索是肯定可以的，但似乎太没节操，时间复杂度太大。</p><p>于是我看看能否用贪心算法。首先举几个反例：</p><p><b>1.比如按右边界排序，然后找没有重复的线段中右边界最小的。</b></p><p>说实话，这样做是不行的，反例如下：</p><p>[0,5], [1,7], [6,15]，[8,10],</p><p>已经按右边界排序了，然后看[0,5]，右边界最小的跟它没重复的是[8,10]，它俩一组；</p><p>但后面的[6,15],[1,7]是不能一组的，而且它俩都不能插进原来的，</p><p>1：—————</p><p>2：    ——————</p><p>3：                      —————————</p><p>4：                            ——</p><p>如图：如果1、4一组，那么2、3不可能一组，这样需要3组；</p><p>但换个角度，如果1、3一组，2、4是可以一组的，这样只需要2组。</p><p>因此，这个算法不大行。</p><p><b>2.按右边界排序，每次选取右端点最大的放一组。</b></p><p>其实也是有反例的，比如：</p><p>[0,5],[4,10],[6,12],[11,15]</p><p>1：—————</p><p>2：               ——————</p><p>3：                    ——————</p><p>4：                                        ————</p><p>比如第一次[0,5]，右边界最大又与之没有交集的是[11,15]，但[4,10]和[6,12]是不能放一组的，因此需要3组。</p><p>不过其实[0,5]，[6,12]一组，[4,10]，[6,12]一组是可以的，一共两组就行。</p><p>因此，似乎上述两种方法都不大行。那么按左边界排序呢？</p><p><b>3.按左边界排序，每次合并左边段点最小的不重复线段：</b></p><p>比如第一个：</p><p>[0,5], [1,7], [6,15]，[8,10],</p><p>就会有[0,5]，[6,15]一组，因为6比8小；然后[1,7]，[8,10]一组；</p><p>对于第二个：</p><p>[0,5],[4,10],[6,12],[11,15]</p><p>也有[0,5]，[6,12]一组，然后[4,10],[11,15]一组，似乎是可以的。</p><p>其实我们最担心的是这种情况：</p><p>1、2段可以合并，1、3段可以合并，2、4段可以合并，但3、4段不能合并，且1、2、4不能合并；使用贪心算法，会让1、2段合并，这样3、4段单独，需要3段；但如果1、3段和2、4段分别合并，只需要两端。</p><p>下面证明一下这种情况不会出现。</p><p>假设端点是： <img src="https://www.zhihu.com/equation?tex=x_i%2Cy_i" alt="x_i,y_i" eeimg="1"/> ，按照之前的排序， <img src="https://www.zhihu.com/equation?tex=x_1%3Cx_2%3Cx_3%3Cx_4" alt="x_1&lt;x_2&lt;x_3&lt;x_4" eeimg="1"/> ，则有：</p><p>如果1、2段可以合并，则有:  <img src="https://www.zhihu.com/equation?tex=x_1%3Cy_1%3Cx_2%3Cy_2" alt="x_1&lt;y_1&lt;x_2&lt;y_2" eeimg="1"/> ，</p><p>如果1、3段可以合并，则有：<img src="https://www.zhihu.com/equation?tex=x_1%3Cy_1%3Cx_3%3Cy_3" alt="x_1&lt;y_1&lt;x_3&lt;y_3" eeimg="1"/> ，</p><p>如果2、4段可以合并，且1、2、4不能合并，则4只能在2的左边，则有：</p><p><img src="https://www.zhihu.com/equation?tex=x_4%3Cy_4%3Cx_2%3Cy_2%5C%5C" alt="x_4&lt;y_4&lt;x_2&lt;y_2\\" eeimg="1"/> ，好了，此时，3、4是可以合并的，因为 <img src="https://www.zhihu.com/equation?tex=x_4%3Cy_4%3Cx_2%3Cx_3" alt="x_4&lt;y_4&lt;x_2&lt;x_3" eeimg="1"/> ，这与题目中的3、4段不能合并矛盾。</p><p>因此，对于4个线段，这样的算法可以得到最优解，不会出现贪心过度的情况。</p><p>其实不失一般性，对于任意数目的线段，如果贪心导致出错，其实都可以归结为上述的情况，就是前面合并多了导致后面被动了，因此其实已经证明了贪心算法可以得到最优解。</p><p>然后我们知道，按这种算法如果两段线段合并了，是不会存在另外一条线段中间插缝合并进来的，因为中间插缝的线段y点小于被合并线段的x点，那么中间插缝的左端点更小了，理应是合并它才对。</p><p>所以说，按这个算法合并的话，如果同一条线段要继续合并，只能往右扩展。因此合并后的线段可以看成一整条，从最左到最右。这样就可以套用算法不断迭代了。</p><p>大概两重循环，算法复杂度 <img src="https://www.zhihu.com/equation?tex=O%28n%5E2%29" alt="O(n^2)" eeimg="1"/> ，假设x已经排好序的。</p><div class="highlight"><pre><code class="language-text">set.seed(100)
n &lt;- 10000
x &lt;- runif(n,0,10)
y &lt;- x+(runif(n,1,10))
p &lt;- 1:n
ix &lt;- sort.int(x, decreasing = FALSE, index.return = TRUE)$ix
xx &lt;- x[ix]
yy &lt;- y[ix]
for (i in 1:(n-1))
  if (p[i]) {
    for (j in (i+1):n) {
      if (p[j]==j &amp;&amp; xx[j]&gt;=yy[i]) {
          yy[i] &lt;- yy[j]
          p[j] &lt;- i
      }
    }
  }
total &lt;- length(table(p))</code></pre></div><p>假设已经按x排好序了，然后两层循环，第一层是每个线段开始的那条，然后一直往右扩张，直到无法扩张为止，然后再寻找下一个。然后如果被合并了，则记录它对应的初始线段编号p[j]=i，最终结果就是p的不重复元素。</p><p>水平有限，不知道对不对，也不知道能否继续优化。</p><p></p><p></p><p></p><p></p>