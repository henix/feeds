<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>TiDB 的后花园</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Fri, 27 Sep 2019 16:11:47 +0800</lastBuildDate>
<item>
<title>TiKV Rust Client 迁移记 - Futures 0.1 至 0.3</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-27-84396856.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/84396856&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3720eff25c56733a55c449121fa18c93_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;作者介绍：Nick Cameron，PingCAP 研发工程师，Rust core team 成员，专注于分布式系统、数据库领域和 Rust 语言的进展。&lt;/blockquote&gt;&lt;p&gt;最近我将一个中小型的 crate 从 futures 库的 0.1 迁移至了 0.3 版本。过程本身不是特别麻烦，但还是有些地方或是微妙棘手，或是没有很好的文档说明。这篇文章里，我会把迁移经验总结分享给大家。&lt;/p&gt;&lt;p&gt;我所迁移的 crate 是 TiKV 的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Ftikv%252Fclient-rust&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust Client&lt;/a&gt;。该 crate 的规模约为 5500 行左右代码，通过 gRPC 与 TiKV 交互，采用异步接口实现。因此，对于 futures 库的使用颇为重度。&lt;/p&gt;&lt;p&gt;异步编程是 Rust 语言中影响广泛的一块领域，已有几年发展时间，其核心部分就是 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Frust-lang-nursery%252Ffutures-rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;futures&lt;/a&gt; 库。作为一个标准 Rust 库，futures 库为使用 futures 编程提供所需数据类型以及功能。虽然它是异步编程的关键，但并非你所需要的一切 - 你仍然需要可以推进事件循环 (event loop) 以及与操作系统交互的其他库。&lt;/p&gt;&lt;p&gt;&lt;code&gt;futures&lt;/code&gt; 库在这几年中变化很大。最新的版本为 0.3（crates.io 发布的 &lt;code&gt;futures&lt;/code&gt; 预览版）。然而，有许多早期代码是 futures 0.1 系列版本，且一直没有更新。这样的分裂事出有因 - 0.1 和 0.3 版本之间变化太大。0.1 版本相对稳定，而 0.3 版本一直处于快速变化中。长远来看，0.3 版本最终会演进为 1.0。有一部分代码会进入 Rust 标准库，其中的第一部分已在最近发布了稳定版，也就是 &lt;code&gt;Future&lt;/code&gt; trait。&lt;/p&gt;&lt;p&gt;为了让 Rust Client 跑在稳定的编译器上，我们将核心库限制为仅使用稳定或即将稳定的特性。我们在文档和示例中确实使用了 async/await，因为 async/await 更符合工程学要求，而且将来也一定会成为使用 Rust 进行异步编程的推荐方法。除了在核心库中避免使用 async/await，我们对使用 futures 0.1 的 crate 也有依赖，这也意味着我们需要经常用到兼容层。从这个角度说，我们这次迁移其实并不够典型。&lt;/p&gt;&lt;p&gt;我不是异步编程领域的专家，或许有其他方法能让我们这次迁移（以及所涉及的代码）更符合大家的使用习惯。如果您有好的建议，可以在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Ftwitter.com%252Fnick_r_cameron&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Twitter&lt;/a&gt; 上联系我。如果您想要贡献 PR 就更赞了，我们期待越来越多的力量加入到 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Ftikv%252Fclient-rust&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiKV Client&lt;/a&gt; 项目里。&lt;/p&gt;&lt;h2&gt;机械性变化&lt;/h2&gt;&lt;p&gt;此类变化是指那些 “查询替换类” ，或其他无需复杂思考的变化。&lt;/p&gt;&lt;p&gt;这一类别中最大的变化莫过于 0.1 版本的 &lt;code&gt;Future&lt;/code&gt; 签名中包含了一个 &lt;code&gt;Error&lt;/code&gt; 关联类型，而且 &lt;code&gt;poll&lt;/code&gt; 总是会返回一个 &lt;code&gt;Result&lt;/code&gt;。0.3 版本里该错误类型已被移除，对于错误需要显式处理。为了保持行为上的一致性，我们需要将代码里所有 &lt;code&gt;Future&amp;lt;Item=Foo, Error=Bar&amp;gt;&lt;/code&gt; 替换为 &lt;code&gt;Future&amp;lt;Output=Result&amp;lt;Foo, Bar&amp;gt;&amp;gt;&lt;/code&gt;（留意 &lt;code&gt;Item&lt;/code&gt; 到 &lt;code&gt;Output&lt;/code&gt; 的名称变化）。替换后， &lt;code&gt;poll&lt;/code&gt; 就可以返回和以前一样的类型，这样在使用 futures 的时候无需任何变化。&lt;/p&gt;&lt;p&gt;如果你定义了自己的 futures，那就需要根据是否需要处理错误的需求更新 futures 的定义。&lt;/p&gt;&lt;p&gt;futures 0.3 中支持 &lt;code&gt;TryFuture&lt;/code&gt; 类型，基本上可以看作 &lt;code&gt;Future&amp;lt;Output=Result&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; 的替代。使用这个类型，意味着你需要在 &lt;code&gt;Future&lt;/code&gt; 与 &lt;code&gt;TryFuture&lt;/code&gt; 之间转换，因此最好还是尽量避免吧。&lt;code&gt;TryFuture&lt;/code&gt; 类型包含了一个 blanket implementation，这使它可以通过 &lt;code&gt;TryFutureEx&lt;/code&gt; trait 轻松将某些函数应用于此类 futures。&lt;/p&gt;&lt;p&gt;futures 0.3 中，&lt;code&gt;Future::poll&lt;/code&gt; 方法会接受一个新的上下文参数。这基本上只需要调用 &lt;code&gt;poll&lt;/code&gt; 方法即可完成传递（偶尔也会忽略）。&lt;/p&gt;&lt;p&gt;我们的依赖包依然使用了 futures 0.1，所以我们必须在两个版本的库之间转换。0.3 版本包含了一些兼容层以及其他实用工具（例如 &lt;code&gt;Compat01As03&lt;/code&gt;）。我们在调用依赖关系时会用到这些。&lt;/p&gt;&lt;p&gt;&lt;code&gt;wait&lt;/code&gt; 方法已被从 &lt;code&gt;Future&lt;/code&gt; trait 中移除。这是让人拍手称快的变化，因为该方法确实够反人性，而且本身可以用 &lt;code&gt;.await&lt;/code&gt; 或 &lt;code&gt;executor::block_on&lt;/code&gt; 代替（需要注意的是后者可能会阻断整个进程，而并不只是当前执行的 future）。&lt;/p&gt;&lt;h2&gt;Pin&lt;/h2&gt;&lt;p&gt;futures 0.3 中， &lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fdoc.rust-lang.org%252Fnightly%252Fstd%252Fpin%252Findex.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pin&lt;/a&gt;&lt;/code&gt; 是一个频繁使用的类型， &lt;code&gt;Future::poll&lt;/code&gt; 方法签名的 &lt;code&gt;self&lt;/code&gt; 类型对其尤为青睐。除了对这些签名进行一些机械性的处理之外，我还得借助于 &lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt; 与 &lt;code&gt;Pin::new_unchecked&lt;/code&gt; 这两种方法（均为不安全方法）对 futures 的项目字段做一些变更。&lt;/p&gt;&lt;p&gt;指针定位（pinning）是一个微妙又复杂的概念，我至今也不敢说自己已经掌握了多少。我能提供的最好的参考是 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fdoc.rust-lang.org%252Fnightly%252Fstd%252Fpin%252Findex.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;std::pin docs&lt;/a&gt;。下面是我整理的一些要点（有一些重要的细节此处不会涉及，这里本意也并非提供一个关于指针定位的教程）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Pin&lt;/code&gt; 作为一个类型构造，只有用于指针类型（如 &lt;code&gt;Pin&amp;lt;Box&amp;lt;_&amp;gt;&amp;gt;&lt;/code&gt;）时才会生效。&lt;/li&gt;&lt;li&gt;Pin 本身是一种“标识/封装”类型（有一点像 &lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fdoc.rust-lang.org%252Fnightly%252Fstd%252Fptr%252Fstruct.NonNull.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;NonNull&lt;/a&gt;&lt;/code&gt;），并不是指针类型。&lt;/li&gt;&lt;li&gt;如果一个指针类型被“定位”了，意味着指针指向的值不可移动（当一个非拷贝对象通过数值传入，或者调用 &lt;code&gt;mem::swap&lt;/code&gt; 时会发生移动）。需要注意的移动只能发生在指针被定位之前，而非之后。&lt;/li&gt;&lt;li&gt;如果某个类型使用了 &lt;code&gt;Unpin&lt;/code&gt; trait，这意味着无论此类型移动与否都不会有任何影响。换句话说，即使指向该类型的指针没有被定位，我们也可以放心把它当作被定位的。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Pin&lt;/code&gt; 与 &lt;code&gt;Unpin&lt;/code&gt; 并没有置入 Rust 语言，虽然某些特性会对指针定位有间接依赖。指针定位由编译器强制执行，但编译器本身却不自知（这点非常酷，也体现了 Rust 特性系统对此类处理的强大之处）。它是这样工作的：&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 只允许对于 &lt;code&gt;P&lt;/code&gt; 的安全访问，禁止移动 &lt;code&gt;P&lt;/code&gt; 指向的任何数值，除非 &lt;code&gt;T&lt;/code&gt; 应用了 &lt;code&gt;Unpin&lt;/code&gt;（代码编写者已宣称 &lt;code&gt;T&lt;/code&gt; 并不在意是否被移动）。任何允许删除没有执行 &lt;code&gt;Unpin&lt;/code&gt; 数值的操作（可变访问）都是 &lt;code&gt;unsafe&lt;/code&gt; 的，且应该由程序编写者决定是否要移动任何数值，并保证之后的安全代码中不可删除任何数值。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;让我们回到 futures 迁移的话题上。如果你对 &lt;code&gt;Pin&lt;/code&gt; 使用了不安全的方法，你就需要考虑上面的要点，以保证指针定位的稳定。&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fdoc.rust-lang.org%252Fnightly%252Fstd%252Fpin%252Findex.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;std::pin docs&lt;/a&gt; 提供了更多的解释。我在许多地方通过字段投射的方式为另外一个 future 调用 &lt;code&gt;poll&lt;/code&gt; 方法（有时是间接的），为了达到这个目的，你需要一个已定位的指针，这也意味着能你需要结构性指针定位。如，你可以将 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; 字段投射至 &lt;code&gt;Pin&amp;lt;&amp;amp;mut FieldType&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;函数&lt;/h2&gt;&lt;p&gt;迁移中比较让人不爽的一点是 futures 库里有许多函数（与类型）的名称改变了。有的名称和标准库里的通用名重复，这让用自动化的手段处理变更的难度变大。比如，&lt;code&gt;Async&lt;/code&gt; 变成了 &lt;code&gt;Poll&lt;/code&gt;，&lt;code&gt;Ok&lt;/code&gt; 变成了 &lt;code&gt;ready&lt;/code&gt;，&lt;code&gt;for_each&lt;/code&gt; 变成 &lt;code&gt;then&lt;/code&gt;，&lt;code&gt;then&lt;/code&gt; 变成 &lt;code&gt;map&lt;/code&gt;，&lt;code&gt;Either::A&lt;/code&gt; 变成 &lt;code&gt;Either::Left&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;有时名称没有变化，但其代表的功能语义变了（或者两方面都变了）。一个较为普遍的变化就是 closure 函数现在会返回可以使用 &lt;code&gt;T&lt;/code&gt; 类型生成数值的 future，而不会直接返回数值本身。&lt;/p&gt;&lt;p&gt;有许多组合子函数从 &lt;code&gt;Future&lt;/code&gt; trait 移至扩展 crate 里。这个问题本身不难修复，只是有时候不容易从错误信息中判定。&lt;/p&gt;&lt;h2&gt;LoopFn&lt;/h2&gt;&lt;p&gt;0.1 版本的 futures 库包含了 &lt;code&gt;LoopFn&lt;/code&gt; 这个 future 构造，用于处理多次执行某动作的 futures。&lt;code&gt;LoopFn&lt;/code&gt; 在 0.3 版本中被移除，这样做的原因个人认为可能是 &lt;code&gt;for&lt;/code&gt; 循环本身是 &lt;code&gt;async&lt;/code&gt; 的函数，或者 streams 才是长远看来的更佳解决方案。为了让我们的迁移过程简单化，我为 futures 0.3 写了我们自己版本的 &lt;code&gt;LoopFn&lt;/code&gt; future，其实大部分也都是复制粘贴的工作，加上一些调整（如处理指针定位投射）：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Ftikv%252Fclient-rust%252Fpull%252F41%252Fcommits%252F6353dbcfe391d66714686aafab9a49e593259dfb%2523diff-eeffc045326f81d4c46c22f225d3df90R28&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;code&lt;/a&gt;。后来我将几处 &lt;code&gt;LoopFn&lt;/code&gt; 用法转换为 streams，对代码似乎有一定改进。&lt;/p&gt;&lt;h2&gt;Sink::send_all&lt;/h2&gt;&lt;p&gt;我们在项目中几个地方使用了 sink。我发现对于它们对迁移和 futures 相比要有难度不少，其中最麻烦的问题就是 &lt;code&gt;Sink::send_all&lt;/code&gt; 结构变了。0.1 版本里，&lt;code&gt;Sink::send_all&lt;/code&gt; 会获取 stream 的所有权，并在确定所有 future 都完成后返回 sink 以及 stream。0.3 版本里， &lt;code&gt;Sink::send_all&lt;/code&gt; 会接受一个对 stream 的可变引用，不返回任何值。我自己写了一个 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Ftikv%252Fclient-rust%252Fpull%252F41%252Fcommits%252F6353dbcfe391d66714686aafab9a49e593259dfb%2523diff-eeffc045326f81d4c46c22f225d3df90R68&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;兼容层&lt;/a&gt; 在 futures 0.3 里模拟 0.1 版本的 sink。这不是很难，但也许有更好的方式来做这件事。&lt;/p&gt;&lt;p&gt;大家可以在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Ftikv%252Fclient-rust%252Fpull%252F41&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这个 PR&lt;/a&gt; 里看到整个迁移的细节。本文最初发表在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fwww.ncameron.org%252Fblog%252Fmigrating-a-crate-from-futures-0-1-to-0-3%252F&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;www.ncameron.org&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;阅读英文版原文：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.ncameron.org/blog/migrating-a-crate-from-futures-0-1-to-0-3/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-12cee5ba5a2a0a60b146d43606cc0b8c_ipico.jpg&quot; data-image-width=&quot;250&quot; data-image-height=&quot;250&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Migrating a crate from futures 0.1 to 0.3&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-27-84396856</guid>
<pubDate>Fri, 27 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>十一假期别“宅”啦，一起备战黑客马拉松吧！</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-26-84216401.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/84216401&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ad40d3800f3eadef6587e4052390e5ab_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;i&gt;&lt;b&gt;十一长假倒计时 6 天！如果你「没安排、只能宅」，这里有件好玩又 Hack 的事情，你来不来？&lt;/b&gt;&lt;/i&gt;&lt;br/&gt;&lt;u&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82263579&quot; class=&quot;internal&quot;&gt;TiDB Hackathon 2019&lt;/a&gt;&lt;/u&gt; 将在 10 月 26 - 27 日举办，比赛主题为「Improve」，参赛选手可以为 TiDB 性能、易用性、稳定性、功能等各方面做出提升，当然也可以围绕 TiDB 生态做一些周边工具提升效率。不仅有大咖导师现场带教，奖金也非常丰厚哦～&lt;br/&gt;&lt;i&gt;&lt;b&gt;7 天长假备战一场黑客马拉松绰绰有余呀，在家睡觉不如 Hack，约起来吧盆友们！&lt;/b&gt;&lt;/i&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;学习资料&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;前序阅读：&lt;/b&gt;深入学习之前，大家需要对 TiDB 的架构和基本原理有一定的了解，请先阅读以下几篇文章：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247484474%26idx%3D1%26sn%3D0d9a5ab3beb2783cfca3d3b22a567dfc%26chksm%3Deb162350dc61aa46dfc8156b5b92d404d0785b5dff60bd1e6bca42a60109cf1dc30857f1e811%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 架构&lt;/a&gt;&lt;/u&gt;&lt;/li&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-internal-1/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;说存储&lt;/a&gt;&lt;/u&gt;&lt;/li&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-internal-2/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;说计算&lt;/a&gt;&lt;/u&gt;&lt;/li&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-internal-3/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;谈调度&lt;/a&gt;&lt;/u&gt;&lt;/li&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-source-code-reading-2/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 源码阅读系列文章（二）初识 TiDB 源码&lt;/a&gt;&lt;/u&gt;&lt;/li&gt;&lt;li&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-source-code-reading-3/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 源码阅读系列文章（三）SQL 的一生&lt;/a&gt;&lt;/u&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;TiDB&lt;/b&gt; 是集群的 SQL 层，承担了与客户端通讯（协议层）、语法解析（SQL Parser）、查询优化（Optimizer）、执行查询计划等工作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;TiKV&lt;/b&gt; 是分布式存储层，内部结构可分为多层，每层有各自的功能，从底向上分别为：RocksDB、Raft、Raft KV、MVCC、TXN KV、Coprocessor。&lt;/p&gt;&lt;p&gt;&lt;b&gt;PD&lt;/b&gt; 在集群中的地位是一个逻辑上的单点，类似于很多系统中都有的 master server 或者 meta server 之类的组件，PD 的内部结构是多种不同功能的复合体。&lt;/p&gt;&lt;p&gt;&lt;b&gt;深入阅读：&lt;/b&gt;大家可以在《Hackathon 专项学习文档》中，找到自己感兴趣、匹配自己选题的模块深入钻研。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;专项学习文档链接：&lt;br/&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/presentations/blob/master/hackathon-2019/reference-document-of-hackathon-2019.md&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/pingcap/pres&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;entations/blob/master/hackathon-2019/reference-document-of-hackathon-2019.md&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;另外还有线上视频课程可以观看哦，PingCAP University 网站链接：&lt;br/&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//university.pingcap.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;university.pingcap.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;过来人都这么说……&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;spongedu&lt;/b&gt;：“TiDB Hackathon 2019 要来了。去年 Hackathon 上各种让人拍案称奇的 Idea、酷炫的 Demo （以及 Pizza 和啤酒）让我对今年的 Hackathon 充满期待。今年的主题是“Improve”，我觉得这不仅仅是从选题层面，对 TiDB 的“Improve”，更是从技术和执行力层面对自己的挑战和升华。 &lt;/p&gt;&lt;p&gt;去年 Hackathon 上，我和小伙伴们做了一个 Demo，在 TiDB 里实现了一个 Batch - Streaming 一体的处理引擎。这个主题比较硬核，在最后提交代码前，我都一直不敢相信真的能够在短短的一个周末时间内把这个 Idea 从脑海中落地，所以当最后 Demo 做出来的时候，真有一种梦想成真的感觉，也许这就是 Hackathon 的魅力吧。今年，我们也会带来一些比较有意思的 Idea，这里就不剧透了，期待小伙伴们在 Hackathon 现场交流，不见不散！”&lt;/p&gt;&lt;p&gt;&lt;i&gt;* spongedu 和他的队友去年凭借参赛项目 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247487656%26idx%3D1%26sn%3Dc4ee830b5174ac062de2404ddffe821f%26chksm%3Deb1637c2dc61bed4fc52b9c30d2751f7c1a4f68290f15d17461dbf89dc3b9ae0522b83ce0983%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TBSSQL&lt;/a&gt;&lt;/u&gt; 获得一等奖 &amp;amp; 最佳贡献奖，TiDB Batch and Streaming SQL（简称 TBSSQL）扩展了 TiDB 的 SQL 引擎，支持用户以类似 StreamSQL 的语法将 Kafka, Pulsar 等外部数据源以流式表的方式接入 TiDB。通过简单的 SQL 语句，用户可以实现对流式数据的过滤，流式表与普通表的 Join（比如流式事实表与多个普通维度表），甚至通过 CREATE TABLE AS SELECT 语法将处理过的流式数据写入普通表中。此外，针对流式数据的时间属性，我们实现了基于时间窗口的聚合 / 排序算子，使得我们可以对流式数据进行时间维度的聚合 / 排序。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;breeswish&lt;/b&gt;：在 TiDB Hackathon 上真的可以结交到各路大佬，说不定还能拿个奖，对分布式数据库感兴趣的同学不容错过！&lt;/p&gt;&lt;p&gt;&lt;i&gt;* breeswish 和他的队友去年凭借参赛项目 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247487479%26idx%3D2%26sn%3D3a601b2ff9100a9797605a825e478c01%26chksm%3Deb16289ddc61a18b49051feb9faf7e00b2093e83e723417ea4bab90808464eb6278bc9f979ed%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB laboratory&lt;/a&gt;&lt;/u&gt; 获得二等奖。TiDB laboratory 为 TiDB 培训体系增加了一个可以动态观测 TiDB/TiKV/PD 细节的动画教学 Lab，让用户可以一边进行真实操作一边观察组件之间的变化，例如 SQL 的解析，Region 的变更等等。让用户可以生动地理解 TiDB 的工作原理。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;disksing &lt;/b&gt;：“超喜欢参加 Hackathon 的，里面个个都是人才，说话又好听。打工是不可能打工的，这辈子不可能打工，只有参加 Hackathon 拿奖金才能维持得了生活这样子。”&lt;/p&gt;&lt;p&gt;&lt;i&gt;* disksing 和他的队友去年凭借参赛项目 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247487451%26idx%3D2%26sn%3D5f1ee6e838c3a86556fcd556662112c5%26chksm%3Deb1628b1dc61a1a7e8f4cb82e2bfaab40cbfb27e986f9705f9166d629ff31a812f7ae45b1d73%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiQuery&lt;/a&gt;&lt;/u&gt; 获得三等奖。TiQuery 会搜集诊断集群问题所需要的信息，包括集群拓扑，Region 分布，配置，各种系统信息，整理成结构化的数据，并在 TiDB 中支持直接使用 SQL 语言进行查询。开发和运维人员可以在 SQL 环境方便高效地进行问题诊断。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;haoxiang47&lt;/b&gt;：“去年玩耍得很开心，顺便捞了几件衣服和杯子。当时搞了个 Lua UDF 的项目，改动 TiDB/TiKV/PD 的代码有点多，比较头疼，于是就各种找场地内的导师求教，辛苦 PingCAP 的同学一起熬夜帮忙 Debug，大概眯了一会，PingCAP 同学就解决了，啊～还有早餐的味道很好。今年必须再来一次，玩过好多个 Hackathon 了，PingCAP 的 Hackathon 是我见过的最 tech 最硬核的，丝毫不水，各位喜欢技术的小伙伴们来一起玩吧！”&lt;/p&gt;&lt;p&gt;&lt;i&gt;* haoxiang47 和他的队友去年完成了“基于 Lua 的 TiDB 自定义 UDF 实现”项目，这是一个基于 TiKV 的 coprocessor，内嵌了 Lua，实现了简单的自定义 UDF 功能。&lt;/i&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;你可能还想问……&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;1. 对参赛者本身有什么门槛吗？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：没有门槛，不限年龄，不限职业，唯一的要求是&lt;b&gt;来现场参赛&lt;/b&gt;（是的，Hakcathon 注重现场的团队配合和团队间的疯狂竞技，不接受线上参与哦）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 我想参赛，可是没有合适的组队小伙伴怎么办？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：建议先找身边的同学同事组队，临近比赛日期还没有队友的话官方会建立选手群让大家自由配对。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 一个人也可以成队报名吗？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：当然可以，我们非常欢迎技能值满点的优秀个人参赛者，也欢迎暂时没有选题或队友的个人参赛者报名，主办方会协调大家进行赛前组队。&lt;/p&gt;&lt;p&gt;&lt;b&gt;4. 报名时间好长，我还没想好做什么项目，可以观望一下最后“踩点报名”吗？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：不建议“踩点报名”。可以先报名，然后从学习资料中挑选适合自己基础的模块开始学习，提前准备总没有坏处～说不定在备赛群里和大家交流讨论之后，就能获得选题启发（点击 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489710%26idx%3D1%26sn%3D6cd0480cd7d134de44b0f743684a5289%26chksm%3Deb163fc4dc61b6d2dc1ed81599d8e3c84b9efdf6cc5516ee2e3f08e158da9e2fae1eefd50920%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;&lt;/u&gt; 查看选题方向参考）。今年报名开启时间提前了很多，就是为了让大家有充裕的时间学习&amp;amp;交流，做好前期准备。临近报名截止日期可能不好组队，而且前期准备不充分，现场会慌乱哟。&lt;/p&gt;&lt;p&gt;&lt;b&gt;5. 可以与 PingCAP 的成员共同组队吗？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：当然可以，欢迎在社区内在线勾搭 PingCAP 成员。如果有组队意向，但没有合适人选，也可以联系 TiDB Robot（微信 ID: tidbai）尝试分配组队呦。原则上，任一队伍中，PingCAP 内部人数不可超过队伍总人数的 50%。&lt;/p&gt;&lt;p&gt;&lt;b&gt;6. 可以异地组队吗？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：为保证团队效率，原则上建议团队成员集中在同一城市，如果特殊需求，可以在线沟通 TiDB Robot（微信 ID: tidbai）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;7. 大咖导师们赛前会进行辅导嘛？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：会。&lt;b&gt;导师会在赛前两周在线答疑&lt;/b&gt;，大家可以抓住机会“尽情套路（套知识点）”！&lt;/p&gt;&lt;p&gt;&lt;b&gt;8. 主办方提供餐饮和住宿吗？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：我们提供参赛者和志愿者比赛期间的餐饮（两份午餐、一份早餐、一份晚餐），参赛选手可留在比赛场地过夜，如需在场地附近租住宾馆需要自己解决哟～&lt;/p&gt;&lt;p&gt;&lt;b&gt;9. 比赛两天都需要呆在活动场地吗？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：如果没有特殊需求请不要离开场地，需要回自己住处过夜的小伙伴请和志愿者或主办方登记信息，并请于第二天早晨 8 点前返回场地。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参赛重要信息&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;比赛时间：2019 年 10 月 26 ～ 27 日&lt;/p&gt;&lt;p&gt;比赛地点：PingCAP 北京、上海、广州 Office&lt;/p&gt;&lt;p&gt;组队规则：1～4 人成队，选择一地参赛&lt;/p&gt;&lt;p&gt;奖项设置：&lt;/p&gt;&lt;p&gt;🏅一等奖（1 支队伍）： ¥ 60,000 现金奖励&lt;/p&gt;&lt;p&gt;🥈二等奖（2 支队伍）：每队 ¥ 30,000 现金奖励&lt;/p&gt;&lt;p&gt;🥉三等奖（3 支队伍）：每队 ¥ 10,000 现金奖励&lt;/p&gt;&lt;p&gt;另设最佳贡献奖、最佳创意奖、最具潜力奖，将有 TiDB 周边礼品奖励。&lt;/p&gt;&lt;p&gt;&lt;b&gt;报名时间：即日起至 10 月 23 日&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;报名审核：5 个工作日内反馈审核结果&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;报名地址：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//nc9hsk15y2xczuor.mikecrm.com/PiwBPaL&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Hackathon 重磅回归！&lt;/a&gt;&lt;p&gt;* 本次大赛诚招志愿者参与活动现场支持。如果你想近距离接触技术大咖，体验大赛氛围，那就联系 TiDB Robot（微信号：tidbai）报名吧～志愿者也可以获得活动定制纪念品哦！&lt;/p&gt;&lt;p&gt;&lt;b&gt;更多活动信息：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/hackathon2019/%3Futm_source%3Dwechat%26utm_medium%3Dpingcap%26utm_campaign%3Dpingcap%2520190925&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt; | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-26-84216401</guid>
<pubDate>Thu, 26 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>TiKV 在京东云对象存储元数据管理的实践</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-26-83781540.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83781540&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-611f8b95212de7861cc8076f3de9fd0a_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;作者介绍：崔灿，京东云产品研发部专家架构师，目前主要负责京东云对象存储产品的工作。&lt;/blockquote&gt;&lt;p&gt;京东云对象存储是在 2016 年作为公有云对外公开的，主要特点是可靠、安全、海量、低成本，应用于包括一些常用的业务场景，比如京东内部的京东商城视频/图片云存储，面向京东云公有云外部的开发者的服务，和面向政府、企业的私有云服务，甚至混合云服务。&lt;/p&gt;&lt;p&gt;本文将介绍京东云对象存储服务的架构演进，以及迁移到 TiKV 的经验。&lt;/p&gt;&lt;h2&gt;一、对象存储简介&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cd1debbfd10e02c01d1975c5c47e7fd5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2442&quot; data-rawheight=&quot;1368&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2442&quot; data-original=&quot;https://pic2.zhimg.com/v2-cd1debbfd10e02c01d1975c5c47e7fd5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cd1debbfd10e02c01d1975c5c47e7fd5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2442&quot; data-rawheight=&quot;1368&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2442&quot; data-original=&quot;https://pic2.zhimg.com/v2-cd1debbfd10e02c01d1975c5c47e7fd5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-cd1debbfd10e02c01d1975c5c47e7fd5_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 什么是“对象”&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先举例说明一下这里的“对象 (Object)”概念。比如我们把一张照片当作一个“对象”，除了照片本身的二进制数据，它还应该包含一些元信息（照片数据长度、上次修改时间等）、涉及用户的数据（拍摄者、拍摄设备数据等）。对象存储的特点是这些数据不会频繁地修改。&lt;/p&gt;&lt;p&gt;如果是数量比较少的图片存储，我们可能会用类似 LVM 之类的东西，把一个节点上的多个磁盘使用起来，这种方法一般适用于数量级在 1M ~ 10M 的图片。随着业务的增长，图片会越来越多甚至有视频存储，因此我们采用分布式文件系统来存储，这种方法是基于 DFS 的架构（如下图所示）。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-55c9642b50983f4cc914cdc015f59e7f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2448&quot; data-rawheight=&quot;1366&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2448&quot; data-original=&quot;https://pic4.zhimg.com/v2-55c9642b50983f4cc914cdc015f59e7f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-55c9642b50983f4cc914cdc015f59e7f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2448&quot; data-rawheight=&quot;1366&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2448&quot; data-original=&quot;https://pic4.zhimg.com/v2-55c9642b50983f4cc914cdc015f59e7f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-55c9642b50983f4cc914cdc015f59e7f_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2 如何存储对象（数据量 1B）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这种方法的前提是单机容量受限，必须把数据放在多台机器上存储，并且用一个或多个独立的 node 存储元数据，并且元数据会维持树状目录的结构，拆分比较困难。但是这个架构一般适合存储到 10 亿级别的对象，同时存在两个比较大的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据分布式存储在不同的节点上，如果存在一个中心的 master 节点的数据是相对有限的，那么这个机器就不太可能无限扩张下去。&lt;/li&gt;&lt;li&gt;元数据管理是树状结构，它本身并不适合做分布式存储，并且目录结构需要多次访问，不适合把它放到 SSD 上，而更适合放在内存里，然后一般授权一个 master 节点 list。HDFS 基本也是这样。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b6cfa413fabb2df1ec19263773e46663_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2450&quot; data-rawheight=&quot;1368&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2450&quot; data-original=&quot;https://pic4.zhimg.com/v2-b6cfa413fabb2df1ec19263773e46663_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b6cfa413fabb2df1ec19263773e46663_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2450&quot; data-rawheight=&quot;1368&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2450&quot; data-original=&quot;https://pic4.zhimg.com/v2-b6cfa413fabb2df1ec19263773e46663_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b6cfa413fabb2df1ec19263773e46663_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3 如何存储对象（数据量 100B）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;那么如果要求做千亿级的对象存储，如何实现呢？最容易想到的办法是将元数据分布式存储，不再像文件系统中那样存储在单独的机器上，是一个树状结构，而是变成一个平坦结构。&lt;/p&gt;&lt;h2&gt;二、对象存储元数据管理系统&lt;/h2&gt;&lt;p&gt;回到上面的举例，针对一个图片对象我们主要有四类操作：上传（Put）、下载（Get）、删除（Delete），Scan。Scan 操作相对比较传统 ，比如查看当前有多少图片对象，获取所有图片名称。&lt;/p&gt;&lt;h3&gt;1. 元数据管理系统 v1.0&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6f3168c38b1ad8b88e89cd3000ebffa7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2450&quot; data-rawheight=&quot;1368&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2450&quot; data-original=&quot;https://pic4.zhimg.com/v2-6f3168c38b1ad8b88e89cd3000ebffa7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6f3168c38b1ad8b88e89cd3000ebffa7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2450&quot; data-rawheight=&quot;1368&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2450&quot; data-original=&quot;https://pic4.zhimg.com/v2-6f3168c38b1ad8b88e89cd3000ebffa7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6f3168c38b1ad8b88e89cd3000ebffa7_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4 元数据管理系统 v1.0（1/4）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;上面是一个最简单、原始的方案，这里 Bucket 相当于名字空间（Namespace）。很多人最开始设计的结构也就是这样的，但后期数据量增长很快的时候会遇到一些问题，如下图。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7a019b2780eda46759382ec71ce025d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2452&quot; data-rawheight=&quot;1370&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2452&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7a019b2780eda46759382ec71ce025d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7a019b2780eda46759382ec71ce025d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2452&quot; data-rawheight=&quot;1370&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2452&quot; data-original=&quot;https://pic2.zhimg.com/v2-c7a019b2780eda46759382ec71ce025d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c7a019b2780eda46759382ec71ce025d_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5 元数据管理系统 v1.0（2/4）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第一个问题是，在初期数据量比较小的时候，可能只分了 4 个 Bucket 存储，随着业务增长，需要重新拆分到 400 个 Bucket 中，数据迁移是一个 Rehash 过程，这是一件非常复杂且麻烦的事情。所以，我们在思考对象存储连续的、跨数量级的无限扩展要怎么做呢？下图是一个相对复杂的解决方案，核心思想是把绝大部分数据做静态处理，因为静态的存储，无论是做迁移还是做拆分，都比较简单。比如每天都把前一天写入的数据静态化，合到历史数据中去。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a4bb2f1fdfe42f1cee2c2fd90c0395d1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2444&quot; data-rawheight=&quot;1366&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2444&quot; data-original=&quot;https://pic2.zhimg.com/v2-a4bb2f1fdfe42f1cee2c2fd90c0395d1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a4bb2f1fdfe42f1cee2c2fd90c0395d1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2444&quot; data-rawheight=&quot;1366&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2444&quot; data-original=&quot;https://pic2.zhimg.com/v2-a4bb2f1fdfe42f1cee2c2fd90c0395d1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a4bb2f1fdfe42f1cee2c2fd90c0395d1_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6 元数据管理系统 v1.0（3/4）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;针对第二个问题，如果单个 Bucket 数据量很大，那么在往 Stable Meta（上图中黄色部分）做静态化迁移时需要做深度拆分，单个 Bucket 的对象的数量非常多，在一个数据库里面存储不下来，需要存储在多个数据库里面，再建立一层索引，存储每个数据库里面存储那个区间的数据。同时，我们在运行的时候其实也会出现一个 Bucket 数量变多的情况，这种是属于非预期的变多，这种情况下我们的做法是弄了一大堆外部的监控程序，监控 Bucket 的量，在 Bucket 量过大的时候，会主动去触发表分裂、迁移等一系列流程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-688b9fc326ba9bc577bf06b80d51bd43_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2444&quot; data-rawheight=&quot;1368&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2444&quot; data-original=&quot;https://pic4.zhimg.com/v2-688b9fc326ba9bc577bf06b80d51bd43_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-688b9fc326ba9bc577bf06b80d51bd43_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2444&quot; data-rawheight=&quot;1368&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2444&quot; data-original=&quot;https://pic4.zhimg.com/v2-688b9fc326ba9bc577bf06b80d51bd43_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-688b9fc326ba9bc577bf06b80d51bd43_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7 元数据管理系统 v1.0（4/4）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;这个解决方案有两个明显的问题，第一数据分布复杂，管理困难；第二，调度不灵活，给后期维护带来很大的困难。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-be78c6aa68be4379851aca4dc67a2a35_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2448&quot; data-rawheight=&quot;1360&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2448&quot; data-original=&quot;https://pic2.zhimg.com/v2-be78c6aa68be4379851aca4dc67a2a35_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-be78c6aa68be4379851aca4dc67a2a35_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2448&quot; data-rawheight=&quot;1360&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2448&quot; data-original=&quot;https://pic2.zhimg.com/v2-be78c6aa68be4379851aca4dc67a2a35_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-be78c6aa68be4379851aca4dc67a2a35_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8 元数据管理系统改进目标&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;所以，我们思考了这个事情本质其实是做一个全局有序 KV，并且需要“足够大”，能够弹性扩张。这样系统架构就会变得非常简单（如上图所示）。当然最终我们找到了分布式 KV 数据库—— TiKV。&lt;/b&gt;&lt;/p&gt;&lt;h3&gt;2. 基于 TiKV 的元数据管理系统&lt;/h3&gt;&lt;p&gt;我们前期调研了很多产品，最终选择 TiKV 主要原因有以下四点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;全局有序 KV，可轻松⽔平扩展，功能上完全能够满⾜对象存储元数据管理的需求。&lt;/li&gt;&lt;li&gt;经过一些测试，性能上很好，能够满足要求。&lt;/li&gt;&lt;li&gt;社区活跃，文档和工具相对比较完善。这一点也很重要，TiKV 目前已经是 CNCF（云原生计算基金会）的孵化项目，很多功能可以快速开发，产品迭代也很迅速。&lt;/li&gt;&lt;li&gt;相对于 TiDB Server 而言，TiKV 的代码更加简单，而且我们后续可以在 TiKV 的基础上做更多开发工作。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在上线之前，我们主要进行了以下几方面的测试：                       &lt;/p&gt;&lt;ul&gt;&lt;li&gt;功能测试：测试 TiKV 的基本功能是否满足业务需求。&lt;/li&gt;&lt;li&gt;性能测试：测试了常规的 QPS、Latency (Avg, TP90, TP99) 等指标。&lt;/li&gt;&lt;li&gt;异常测试：其实我们做数据存储的同学往往最关注的是各种异常故障的情况，性能倒是其次，而且分布式存储相比单机存储更为复杂。所以我们测试了各种机器/磁盘/网络故障，业务异常情况。更进一步的，我们将这些异常情况随机组合，并在系统内触发，再验证系统的正确性。  &lt;/li&gt;&lt;li&gt;预发布环境验证：在大规模上线之前，我们会在相对不太重要的、实际业务上跑一段时间，收集一些问题和可优化的部分，包括运维上的调优等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过上面的测试我们认为 TiKV 无论是从性能还是系统安全性的角度，都能很好的满足要求，于是我们在 TiKV 基础之上，实现了对象元数据管理系统 v2.0，如下图所示。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f2e5831915882268643b08d4cde9d62c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2446&quot; data-rawheight=&quot;1364&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2446&quot; data-original=&quot;https://pic1.zhimg.com/v2-f2e5831915882268643b08d4cde9d62c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f2e5831915882268643b08d4cde9d62c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2446&quot; data-rawheight=&quot;1364&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2446&quot; data-original=&quot;https://pic1.zhimg.com/v2-f2e5831915882268643b08d4cde9d62c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f2e5831915882268643b08d4cde9d62c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9 元数据管理系统 v2.0&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;将 v1.0 中一堆复杂的数据库和逻辑结构用 TiKV 替代之后，整个系统变得非常简洁。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;三、业务迁移&lt;/h2&gt;&lt;p&gt;很多用户可能直接将 MySQL 迁移到 TiDB 上，这个迁移过程已经非常成熟，但是由于迁移到 TiKV 前人的经验比较少，所以我们在迁移过程中也做了很多探索性的工作。&lt;/p&gt;&lt;h3&gt;1. 迁移方案&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-99eb464bb977f5a054bc9eea8ca74209_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2446&quot; data-rawheight=&quot;1370&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2446&quot; data-original=&quot;https://pic2.zhimg.com/v2-99eb464bb977f5a054bc9eea8ca74209_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-99eb464bb977f5a054bc9eea8ca74209_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2446&quot; data-rawheight=&quot;1370&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2446&quot; data-original=&quot;https://pic2.zhimg.com/v2-99eb464bb977f5a054bc9eea8ca74209_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-99eb464bb977f5a054bc9eea8ca74209_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10 迁移方案&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;上图是我们设计的迁移方案，首先线上的数据都必须双写，保证数据安全。第二，我们将存量数据设置为只读之后迁移到 TiKV 中，同时迁移过程中的增量数据直接写入 TiKV，每天将前一日的增量数据做静态化处理，然后与 MySQL 中的数据对比，验证数据正确性。另外，如果双写失败，会启用 MySQL backup。&lt;/p&gt;&lt;p&gt;下面详细介绍实际操作过程中的相关细节。&lt;/p&gt;&lt;h3&gt;2. 切换&lt;/h3&gt;&lt;p&gt;在存量数据切换方面，我们首先将存量数据静态化，简化迁移、数据对比、回滚的流程；在增量数据切换方面，首先将增量数据双写 TiKV &amp;amp; MySQL，并且保证出现异常情况时快速回滚至 MySQL，不影响线上的业务。值得一提的是，由于 TiKV 在测试环境下的验证结果非常好，所以我们采用 TiKV 作为双写的 Primary。&lt;/p&gt;&lt;p&gt;整个切换 过程分为三个步骤：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;存量数据切换到 TiKV，验证读。&lt;/li&gt;&lt;li&gt;增量数据切换到 TiKV，验证读写。&lt;/li&gt;&lt;li&gt;验证 TiKV 中的数据正确性之后，就下线 MySQL。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;3. 验证&lt;/h3&gt;&lt;p&gt;数据验证过程最大的困难在于增量数据的验证，因为增量数据是每天变化的，所以我们双写了 MySQL 和 TiKV，并且每天将增量数据进行静态化处理，用 MySQL 中的记录来验证 TiKV 的数据是否可靠（没有出现数据丢失和错误），如下图所示。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dbbf769bfb0f2a066ed1f43ac686c8a4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;822&quot; data-rawheight=&quot;888&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;822&quot; data-original=&quot;https://pic1.zhimg.com/v2-dbbf769bfb0f2a066ed1f43ac686c8a4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dbbf769bfb0f2a066ed1f43ac686c8a4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;822&quot; data-rawheight=&quot;888&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;822&quot; data-original=&quot;https://pic1.zhimg.com/v2-dbbf769bfb0f2a066ed1f43ac686c8a4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-dbbf769bfb0f2a066ed1f43ac686c8a4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 11 双写验证&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因为同时双写 MySQL 和 TiKV 可能会出现一种情况是，写入 TiKV 就成功了，但是写入 MySQL 失败了，这两个写入不在同一个事务中，所以不能保证一定同时成功或者失败，尤其是在业务量比较大的情况下。对于这种不一致的情况，我们会通过业务层的操作记录，来判断是由于业务层的问题导致的，还是由 TiKV 导致的。&lt;/p&gt;&lt;h2&gt;四、业务现状及后续优化工作&lt;/h2&gt;&lt;p&gt;&lt;b&gt;目前 TiKV 在京东云对象存储业务上是 Primary 数据库，计划 2019 年年底会把原数据库下线。总共部署的集群数量为 10+，生产环境单集群 QPS 峰值 4 万（读写 1:1），最大的单集群数据量 200+亿，共有 50 余万个 Region，我们元数据管理业务对 Latency 要求比较高，目前 Latency 能保证在 10ms 左右。另外，我们正在测试 TiKV 3.0，预计 2019 年第四季度能够上线。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;针对目前的业务运行情况，我们后续还将做一些优化工作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一点是灾备&lt;/b&gt;，目前我们是在业务层做灾备，后续可能会直接在 TiKV 层做灾备，也很期待 TiKV 之后的版本中能够有这方面的功能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二点是集群规模优化&lt;/b&gt;，因为对象存储是存储密集型的业务，我们希望压缩硬件成本，比如可以用到 8T 、10T 的磁盘，或者用更廉价的磁盘，这点我们后续可能 PingCAP 研发同学们一起考虑怎么优化提升。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三点是 Region 调度优化&lt;/b&gt;，目前 TiKV 的调度整体比较复杂，这对于存储密集型的业务来说就比较麻烦，尤其是数据量特别大的情况下，我们并不希望有一丝的波动就把数据迁移到其他机器上。&lt;/p&gt;&lt;blockquote&gt;本文整理自崔灿老师在 TiDB TechDay 2019 杭州站上的演讲。&lt;/blockquote&gt;&lt;p&gt;原文阅读：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/cases-cn/user-case-jingdongyun/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;pingcap.com/cases-cn/us&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;er-case-jingdongyun/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;更多用户实践：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/cases-cn/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;案例 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-26-83781540</guid>
<pubDate>Thu, 26 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>TiKV 在京东云对象存储元数据管理的实践</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-24-83781540.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83781540&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-611f8b95212de7861cc8076f3de9fd0a_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;作者介绍&lt;/b&gt;&lt;br/&gt;崔灿，京东云产品研发部专家架构师，目前主要负责京东云对象存储产品的工作。&lt;/blockquote&gt;&lt;p&gt;京东云对象存储是在 2016 年作为公有云对外公开的，主要特点是可靠、安全、海量、低成本，应用于包括一些常用的业务场景，比如京东内部的京东商城视频/图片云存储，面向京东云公有云外部的开发者的服务，和面向政府、企业的私有云服务，甚至混合云服务。&lt;/p&gt;&lt;p&gt;本文将介绍京东云对象存储服务的架构演进，以及迁移到 TiKV 的经验。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;一、对象存储简介&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-386d4ebbb5bcb05e82eb11ee7498abed_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-386d4ebbb5bcb05e82eb11ee7498abed_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-386d4ebbb5bcb05e82eb11ee7498abed_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-386d4ebbb5bcb05e82eb11ee7498abed_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-386d4ebbb5bcb05e82eb11ee7498abed_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 &lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先举例说明一下这里的“对象 (Object)”概念。比如我们把一张照片当作一个“对象”，除了照片本身的二进制数据，它还应该包含一些元信息（照片数据长度、上次修改时间等）、涉及用户的数据（拍摄者、拍摄设备数据等）。对象存储的特点是这些数据不会频繁地修改。&lt;/p&gt;&lt;p&gt;如果是数量比较少的图片存储，我们可能会用类似 LVM 之类的东西，把一个节点上的多个磁盘使用起来，这种方法一般适用于数量级在 1M ~ 10M 的图片。随着业务的增长，图片会越来越多甚至有视频存储，因此我们采用分布式文件系统来存储，这种方法是基于 DFS 的架构（如下图所示）。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-29a0a3106ce903a22a9a8c01e81ae899_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-29a0a3106ce903a22a9a8c01e81ae899_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-29a0a3106ce903a22a9a8c01e81ae899_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-29a0a3106ce903a22a9a8c01e81ae899_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-29a0a3106ce903a22a9a8c01e81ae899_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这种方法的前提是单机容量受限，必须把数据放在多台机器上存储，并且用一个或多个独立的 node 存储元数据，并且元数据会维持树状目录的结构，拆分比较困难。但是这个架构一般适合存储到 10 亿级别的对象，同时存在两个比较大的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据分布式存储在不同的节点上，如果存在一个中心的 master 节点的数据是相对有限的，那么这个机器就不太可能无限扩张下去。&lt;/li&gt;&lt;li&gt;元数据管理是树状结构，它本身并不适合做分布式存储，并且目录结构需要多次访问，不适合把它放到 SSD 上，而更适合放在内存里，然后一般授权一个 master 节点 list。HDFS 基本也是这样。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么如果要求做千亿级的对象存储，如何实现呢？最容易想到的办法是将元数据分布式存储，不再像文件系统中那样存储在单独的机器上，是一个树状结构，而是变成一个平坦结构。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;二、对象存储元数据管理系统&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;回到上面的举例，针对一个图片对象我们主要有四类操作：上传（Put）、下载（Get）、删除（Delete），Scan。Scan 操作相对比较传统 ，比如查看当前有多少图片对象，获取所有图片名称。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 元数据管理系统 v1.0&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b252ad52ac734505bb46cedc5f6de6de_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-b252ad52ac734505bb46cedc5f6de6de_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b252ad52ac734505bb46cedc5f6de6de_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-b252ad52ac734505bb46cedc5f6de6de_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b252ad52ac734505bb46cedc5f6de6de_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;上面是一个最简单、原始的方案，这里 Bucket 相当于名字空间（Namespace）。很多人最开始设计的结构也就是这样的，但后期数据量增长很快的时候会遇到一些问题，如下图。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5db9fd80613f4e2c162a6e715518aaf4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-5db9fd80613f4e2c162a6e715518aaf4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5db9fd80613f4e2c162a6e715518aaf4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-5db9fd80613f4e2c162a6e715518aaf4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5db9fd80613f4e2c162a6e715518aaf4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第一个问题是，在初期数据量比较小的时候，可能只分了 4 个 Bucket 存储，随着业务增长，需要重新拆分到 400 个 Bucket 中，数据迁移是一个 Rehash 过程，这是一件非常复杂且麻烦的事情。所以，我们在思考对象存储连续的、跨数量级的无限扩展要怎么做呢？下图是一个相对复杂的解决方案，核心思想是把绝大部分数据做静态处理，因为静态的存储，无论是做迁移还是做拆分，都比较简单。比如每天都把前一天写入的数据静态化，合到历史数据中去。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fcf1dd399c6dba258988dbd3564e5e65_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-fcf1dd399c6dba258988dbd3564e5e65_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fcf1dd399c6dba258988dbd3564e5e65_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-fcf1dd399c6dba258988dbd3564e5e65_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-fcf1dd399c6dba258988dbd3564e5e65_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;针对第二个问题，如果单个 Bucket 数据量很大，那么在往 Stable Meta（上图中黄色部分）做静态化迁移时需要做深度拆分，单个 Bucket 的对象的数量非常多，在一个数据库里面存储不下来，需要存储在多个数据库里面，再建立一层索引，存储每个数据库里面存储那个区间的数据。同时，我们在运行的时候其实也会出现一个 Bucket 数量变多的情况，这种是属于非预期的变多，这种情况下我们的做法是弄了一大堆外部的监控程序，监控 Bucket 的量，在 Bucket 量过大的时候，会主动去触发表分裂、迁移等一系列流程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ce0bf8904a94acc5ec501d265412f0c1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-ce0bf8904a94acc5ec501d265412f0c1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ce0bf8904a94acc5ec501d265412f0c1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-ce0bf8904a94acc5ec501d265412f0c1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ce0bf8904a94acc5ec501d265412f0c1_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;这个解决方案有两个明显的问题，第一数据分布复杂，管理困难；第二，调度不灵活，给后期维护带来很大的困难。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-94d42c3fb18b15496a0ce8995975d446_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-94d42c3fb18b15496a0ce8995975d446_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-94d42c3fb18b15496a0ce8995975d446_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-94d42c3fb18b15496a0ce8995975d446_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-94d42c3fb18b15496a0ce8995975d446_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;所以，我们思考了这个事情本质其实是做一个全局有序 KV，并且需要“足够大”，能够弹性扩张。这样系统架构就会变得非常简单（如上图所示）。当然最终我们找到了分布式 KV 数据库—— TiKV。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 基于 TiKV 的元数据管理系统&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们前期调研了很多产品，最终选择 TiKV 主要原因有以下四点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;全局有序 KV，可轻松⽔平扩展，功能上完全能够满⾜对象存储元数据管理的需求。&lt;/li&gt;&lt;li&gt;经过一些测试，性能上很好，能够满足要求。&lt;/li&gt;&lt;li&gt;社区活跃，文档和工具相对比较完善。这一点也很重要，TiKV 目前已经是 CNCF（云原生计算基金会）的孵化项目，很多功能可以快速开发，产品迭代也很迅速。&lt;/li&gt;&lt;li&gt;相对于 TiDB Server 而言，TiKV 的代码更加简单，而且我们后续可以在 TiKV 的基础上做更多开发工作。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在上线之前，我们主要进行了以下几方面的测试：                       &lt;/p&gt;&lt;ul&gt;&lt;li&gt;功能测试：测试 TiKV 的基本功能是否满足业务需求。&lt;/li&gt;&lt;li&gt;性能测试：测试了常规的 QPS、Latency (Avg, TP90, TP99) 等指标。&lt;/li&gt;&lt;li&gt;异常测试：其实我们做数据存储的同学往往最关注的是各种异常故障的情况，性能倒是其次，而且分布式存储相比单机存储更为复杂。所以我们测试了各种机器/磁盘/网络故障，业务异常情况。更进一步的，我们将这些异常情况随机组合，并在系统内触发，再验证系统的正确性。  &lt;/li&gt;&lt;li&gt;预发布环境验证：在大规模上线之前，我们会在相对不太重要的、实际业务上跑一段时间，收集一些问题和可优化的部分，包括运维上的调优等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过上面的测试我们认为 TiKV 无论是从性能还是系统安全性的角度，都能很好的满足要求，于是我们在 TiKV 基础之上，实现了对象元数据管理系统 v2.0，如下图所示。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9812c4f0fd4afb8d1b32dd50735c0dfb_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-9812c4f0fd4afb8d1b32dd50735c0dfb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9812c4f0fd4afb8d1b32dd50735c0dfb_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-9812c4f0fd4afb8d1b32dd50735c0dfb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9812c4f0fd4afb8d1b32dd50735c0dfb_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;将 v1.0 中一堆复杂的数据库和逻辑结构用 TiKV 替代之后，整个系统变得非常简洁。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;三、业务迁移&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;很多用户可能直接将 MySQL 迁移到 TiDB 上，这个迁移过程已经非常成熟，但是由于迁移到 TiKV 前人的经验比较少，所以我们在迁移过程中也做了很多探索性的工作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 迁移方案&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-62df5af84e668a3839f9031b8ad617c4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-62df5af84e668a3839f9031b8ad617c4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-62df5af84e668a3839f9031b8ad617c4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-62df5af84e668a3839f9031b8ad617c4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-62df5af84e668a3839f9031b8ad617c4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;上图是我们设计的迁移方案，首先线上的数据都必须双写，保证数据安全。第二，我们将存量数据设置为只读之后迁移到 TiKV 中，同时迁移过程中的增量数据直接写入 TiKV，每天将前一日的增量数据做静态化处理，然后与 MySQL 中的数据对比，验证数据正确性。另外，如果双写失败，会启用 MySQL backup。&lt;/p&gt;&lt;p&gt;下面详细介绍实际操作过程中的相关细节。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 切换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在存量数据切换方面，我们首先将存量数据静态化，简化迁移、数据对比、回滚的流程；在增量数据切换方面，首先将增量数据双写 TiKV &amp;amp; MySQL，并且保证出现异常情况时快速回滚至 MySQL，不影响线上的业务。值得一提的是，由于 TiKV 在测试环境下的验证结果非常好，所以我们采用 TiKV 作为双写的 Primary。&lt;/p&gt;&lt;p&gt;整个切换 过程分为三个步骤：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;存量数据切换到 TiKV，验证读。&lt;/li&gt;&lt;li&gt;增量数据切换到 TiKV，验证读写。&lt;/li&gt;&lt;li&gt;验证 TiKV 中的数据正确性之后，就下线 MySQL。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;3. 验证&lt;/b&gt;&lt;/p&gt;&lt;p&gt;数据验证过程最大的困难在于增量数据的验证，因为增量数据是每天变化的，所以我们双写了 MySQL 和 TiKV，并且每天将增量数据进行静态化处理，用 MySQL 中的记录来验证 TiKV 的数据是否可靠（没有出现数据丢失和错误），如下图所示。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fd796a16ecc5dd055ae3a00c359d5c93_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;466&quot; data-rawheight=&quot;504&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;466&quot; data-original=&quot;https://pic4.zhimg.com/v2-fd796a16ecc5dd055ae3a00c359d5c93_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fd796a16ecc5dd055ae3a00c359d5c93_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;466&quot; data-rawheight=&quot;504&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;466&quot; data-original=&quot;https://pic4.zhimg.com/v2-fd796a16ecc5dd055ae3a00c359d5c93_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-fd796a16ecc5dd055ae3a00c359d5c93_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因为同时双写 MySQL 和 TiKV 可能会出现一种情况是，写入 TiKV 就成功了，但是写入 MySQL 失败了，这两个写入不在同一个事务中，所以不能保证一定同时成功或者失败，尤其是在业务量比较大的情况下。对于这种不一致的情况，我们会通过业务层的操作记录，来判断是由于业务层的问题导致的，还是由 TiKV 导致的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;四、业务现状及后续优化工作&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;目前 TiKV 在京东云对象存储业务上是 Primary 数据库，计划 2019 年年底会把原数据库下线。总共部署的集群数量为 10+，生产环境单集群 QPS 峰值 4 万（读写 1:1），最大的单集群数据量 200+亿，共有 50 余万个 Region，我们元数据管理业务对 Latency 要求比较高，目前 Latency 能保证在 10ms 左右。另外，我们正在测试 TiKV 3.0，预计 2019 年第四季度能够上线。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;针对目前的业务运行情况，我们后续还将做一些优化工作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一点是灾备&lt;/b&gt;，目前我们是在业务层做灾备，后续可能会直接在 TiKV 层做灾备，也很期待 TiKV 之后的版本中能够有这方面的功能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二点是集群规模优化&lt;/b&gt;，因为对象存储是存储密集型的业务，我们希望压缩硬件成本，比如可以用到 8T 、10T 的磁盘，或者用更廉价的磁盘，这点我们后续可能 PingCAP 研发同学们一起考虑怎么优化提升。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三点是 Region 调度优化&lt;/b&gt;，目前 TiKV 的调度整体比较复杂，这对于存储密集型的业务来说就比较麻烦，尤其是数据量特别大的情况下，我们并不希望有一丝的波动就把数据迁移到其他机器上。&lt;/p&gt;&lt;p&gt;&lt;i&gt;本文整理自崔灿老师在 TiDB TechDay 2019 杭州站上的演讲。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;&lt;b&gt;更多精彩案例：&lt;/b&gt;&lt;/i&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/cases-cn/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;案例 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-24-83781540</guid>
<pubDate>Tue, 24 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>广州见！PingCAP Talent Plan 第四期即将开启</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-19-83232114.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83232114&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bf19b99a508a22402bb89d40dc1adc02_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;大家期待已久的第四期 PingCAP Talent Plan 线下培训课程，将在 10 月 14 日于 PingCAP 广州 Office 开启！这可能是今年最后一波分布式数据库「从入门到实战开发」的系统培训哦，错过只能等明年啦～ &lt;/blockquote&gt;&lt;p&gt;众所周知，PingCAP Talent Plan 是我们为 TiDB 开源社区小伙伴提供的学习通道，&lt;b&gt;课程围绕着 SQL 引擎 &amp;amp; 分布式存储的基础知识和前沿技术（包括 Go、Rust 两门编程语言）设计&lt;/b&gt;，线下课程培训更注重通过实战练习，帮助学员提升实操能力，甚至有能力参与工业级分布式数据库项目 TiDB 的开发。&lt;/p&gt;&lt;p&gt;自 2018 年启动至今，已知的参与线上课程学习的人数已突破 200 人，而线下课程培训也已成功举办 3 期，共 30 余名学员通过线下考核顺利结业，其中有 8 名学员更是以实习生/校招生的身份加入了 PingCAP。当然也有不少学员继续活跃在 TiDB 开源社区的其他活动中，并开启了 Contributor 的进阶之路。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;自第三期线下培训落幕，就有小伙伴来问第四期将有哪些“新玩法”，现在这就一并透露啦～请往下看！&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;第四期线下课程安排&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4fa03844208905242cf7a754a3d00e25_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;551&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-4fa03844208905242cf7a754a3d00e25_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4fa03844208905242cf7a754a3d00e25_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;551&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-4fa03844208905242cf7a754a3d00e25_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4fa03844208905242cf7a754a3d00e25_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;* 注：线上课程详见文末【阅读原文】链接，通过线上课程考核且成绩优异的同学就有机会参与线下培训哦～&lt;/p&gt;&lt;h2&gt;&lt;b&gt;本期 Talent Plan “新玩法”&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;1. 增加在线视频教学内容，突破学习时间和地点的限制&lt;/b&gt;有不少参加线下课程的学员反馈说，除了现场授课之外，也希望课下能够提供更多视频资源方便进行知识巩固。所以，&lt;b&gt;本期线下课程中将增加在线视频教学的内容，视频可以课后回放，反复温习。&lt;/b&gt;后续我们也会定期选取部分优质的课程视频，开放给没有参与线下培训的社区小伙伴，让更多人有机会体验 Talent Plan 的干货课程。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 与 TiDB Hackathon 2019 相结合，实现从理论到工程的蜕变&lt;/b&gt;10 月 26 ～ 27日，恰逢我们举办 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489710%26idx%3D1%26sn%3D6cd0480cd7d134de44b0f743684a5289%26chksm%3Deb163fc4dc61b6d2dc1ed81599d8e3c84b9efdf6cc5516ee2e3f08e158da9e2fae1eefd50920%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Hackathon 2019&lt;/a&gt;&lt;/u&gt;，所以我们将线下实战题目与 Hackathon 的主题相结合，&lt;b&gt;学员们可以使用线下实战题目直接参与 Hackathon 比赛&lt;/b&gt;。学员们不仅能够阶段性检验自己学习成果，还可以与众多大咖导师零距离交流，获得新的启发，在代码世界中实现自我蜕变（可能还会拿个大奖回家 ^ ^），戳 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489710%26idx%3D1%26sn%3D6cd0480cd7d134de44b0f743684a5289%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;&lt;/u&gt; 了解更多关于 TiDB Hackathon 2019 的信息。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 授课地点在毗邻珠江的广州 Office，带你体验分布式办公的独特魅力&lt;/b&gt;前三期学员们大部分时间都在 PingCAP 北京 Office 集中学习。不过，当北京的十月已经红叶满地，并裹挟着一丝秋冬交接的寒意时，广州则刚刚敛去夏日的炎热，舒适宜人，于是我们将本期授课地点选在了广州 Office，学员们还可以趁此机会，体验一下“PingCAP 分布式办公 Style”（想要更进一步了解广州 Office，可以戳今日推送第二条）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d09fff27a6712c972a535a9705e2bd48_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;810&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-d09fff27a6712c972a535a9705e2bd48_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d09fff27a6712c972a535a9705e2bd48_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;810&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-d09fff27a6712c972a535a9705e2bd48_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d09fff27a6712c972a535a9705e2bd48_b.jpg&quot;/&gt;&lt;figcaption&gt;广州 Office 实景⬆️&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;FAQ&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;Q：线上课程是否必须严格遵循学习周计划，在一个月之内完成？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：一个月的学习时长是我们根据学习资料以及题目难易程度给出的建议。考虑到社区小伙伴学习时间比较分散，&lt;b&gt;我们并未对线上课程学习时间做强制要求，大家可以结合自己的时间自由安排&lt;/b&gt;。如果时间充裕能够在一个月内完成那当然再好不过咯~&lt;/p&gt;&lt;p&gt;&lt;b&gt;Q：线上作业完成后如何提交？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：线上作业提交通道（ts-team@pingcap.com）每周六 0:00 开启，至周日 24:00 关闭，持续 48h 开放。大家可选择分批次提交，完成一个 Section 就提交一个 Section，也可以选择完成所有 Section 后集中提交。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Q：能否同时学习 TiDB 和 TiKV 两个方向的线上课程？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：由于线上课程学习时间不做限制，所以如果你的时间和精力充足，我们当然欢迎你多多学习线上课程。但需要特别提醒的是：&lt;b&gt;通过了线上课程考核之后，由于两个方向的线下课程并行授课，所以同一时间段只能选择参与一个方向的线下课程。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Q：如何参与 Talent Plan 线下课程？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：&lt;b&gt;线下课程采用邀请制&lt;/b&gt;，每年会开设 2-3 期，除 7-8 月份的暑期特别企划外，每年的 4-5 月份或 11-12 月份会开设 1-2 期。&lt;b&gt;在线下课程开始前 1 周，完成所有线上作业且成绩优秀的同学将会被邀请参与线下课程。所以在 10 月 8 日前完成线上课程学习的小伙伴将有机会参与第四期的线下课程哦&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;查看线上课程：&lt;/b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//university.pingcap.com/6ee8482c05034a81ba380d40a1570034.shtml%3Fdiliater%3D6YvzZjyL97Z5c4G09GRzLQ%3D%3D&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;university.pingcap.com/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;6ee8482c05034a81ba380d40a1570034.shtml?diliater=6YvzZjyL97Z5c4G09GRzLQ==&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Q：从 Talent Plan 结业之后，我还可以通过哪些方式更进一步了解 TiDB？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：TiDB 开源社区还有很多有意思的事情等着你去发现。你可以参加社区的其他活动提升技术能力，比如 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489381%26idx%3D1%26sn%3D77bd5b27048bd14a35a8a5e63ba669ca%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;提升 TiDB Parser 对 MySQL 8.0 语法的兼容性&lt;/a&gt;&lt;/u&gt; 或 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489720%26idx%3D1%26sn%3D814c9bb328d00c5ba8443c46c19ff925%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;助力 TiDB 表达式计算性能提升 10 倍&lt;/a&gt;&lt;/u&gt; 等等；如果你喜欢分享，线上 Paper Reading、&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//asktug.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;asktug.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;、Infra Meetup 等都可以成为你进行技术布道的平台。除此之外，你甚至可以选择加入 PingCAP，与 PingCAP 小伙伴一起专注地打造一款应用广泛的、工业级开源数据库产品。总之，我们非常期待着小伙伴们通过 Talent Plan 提升个人技术能力之外，能够持续活跃在 TiDB 开源社区，与 TiDB 一起共同成长～&lt;/p&gt;&lt;p&gt;&lt;b&gt;延展阅读：PingCAP Talent Plan 背后的故事 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489352%26idx%3D1%26sn%3D7fafdf71f32caedea317044fe76e13ad%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;我们是如何设计 Golang &amp;amp; SQL 引擎课程的？&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489198%26idx%3D1%26sn%3D982b72f123f27b8463275345adecd21a%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;我们是如何设计 Rust &amp;amp; 分布式存储教程的？&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489451%26idx%3D2%26sn%3D019d4e74677020c2f1f4a1b6f9a352c9%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这门分布式 KV 存储系统课程教会了我什么？&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;blockquote&gt;PingCAP Talent Plan 是 PingCAP 为 TiDB 开源社区小伙伴提供的进阶式学习计划。课程设置上分为两个方向，分别是面向 SQL 引擎的 TiDB 方向和面向大规模、一致性的分布式存储的 TiKV 方向。每个方向的课程都包含线上和线下两部分，线上课程侧重于对基础知识的讲解，对社区所有小伙伴们开放，时间上比较灵活。线下课程在夯实基础知识的基础上，注重实操能力的培养。&lt;br/&gt;完成线上课程并通过线上考核的小伙伴可以获得线上课程结业证书，表现优秀的还将有机会拿到 PingCAP 校招/实习免笔试绿色通道，而且有机会参与半年内 PingCAP 组织的任意一期线下课程；完成线下课程的小伙伴可以获得专属 PingCAP Talent Plan 结业证书，表现优秀的还将有机会拿到 PingCAP 校招/实习免面试绿色通道/Special Offer、 PingCAP/TiDB 全球 Meetup 的邀请函等。&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-19-83232114</guid>
<pubDate>Thu, 19 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>十分钟成为 Contributor 系列 | 助力 TiDB 表达式计算性能提升 10 倍</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-17-82815389.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82815389&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-582f31db4cda79465dc1c28b3dfbd7d7_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;最近我们扩展了 TiDB 表达式计算框架，增加了向量化计算接口，初期的性能测试显示，多数表达式计算性能可大幅提升，部分甚至可提升 1~2 个数量级。为了让所有的表达式都能受益，我们需要为所有内建函数实现向量化计算。&lt;/p&gt;&lt;p&gt;TiDB 的向量化计算是在经典 Volcano 模型上的进行改进，尽可能利用 CPU Cache，SIMD Instructions，Pipeline，Branch Predicatation 等硬件特性提升计算性能，同时降低执行框架的迭代开销，这里提供一些参考文献，供感兴趣的同学阅读和研究：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cidrdb.org/cidr2005/papers/P19.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MonetDB/X100: Hyper-Pipelining Query Execution&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//dare.uva.nl/search%3Fidentifier%3D5ccbb60a-38b8-4eeb-858a-e7735dd37487&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Balancing Vectorized Query Execution with Bandwidth-Optimized Storage&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.nowpublishers.com/article/DownloadSummary/DBS-024&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Design and Implementation of Modern Column-Oriented Database Systems&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在这篇文章中，我们将描述：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;如何在计算框架下实现某个函数的向量化计算；&lt;/li&gt;&lt;li&gt;如何在测试框架下做正确性和性能测试；&lt;/li&gt;&lt;li&gt;如何参与进来成为 TiDB Contributor。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;表达式向量化&lt;/h2&gt;&lt;h3&gt;1. 如何访问和修改一个向量&lt;/h3&gt;&lt;p&gt;在 TiDB 中，数据按列在内存中连续存在 Column 内，Column 详细介绍请看：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-source-code-reading-10/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 源码阅读系列文章（十）Chunk 和执行框架简介&lt;/a&gt;。本文所指的向量，其数据正是存储在 Column 中。&lt;/p&gt;&lt;p&gt;我们把数据类型分为两种：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;定长类型：&lt;code&gt;Int64&lt;/code&gt;、&lt;code&gt;Uint64&lt;/code&gt;、&lt;code&gt;Float32&lt;/code&gt;、&lt;code&gt;Float64&lt;/code&gt;、&lt;code&gt;Decimal&lt;/code&gt;、&lt;code&gt;Time&lt;/code&gt;、&lt;code&gt;Duration&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;变长类型：&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Bytes&lt;/code&gt;、&lt;code&gt;JSON&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;Enum&lt;/code&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;定长类型和变长类型数据在 Column 中有不同的组织方式，这使得他们有如下的特点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;定长类型的 Column 可以随机读写任意元素；&lt;/li&gt;&lt;li&gt;变长类型的 Column 可以随机读，但更改中间某元素后，可能需要移动该元素后续所有元素，导致随机写性能很差。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对于定长类型（如 &lt;code&gt;int64&lt;/code&gt;），我们在计算时会将其转成 Golang Slice（如 &lt;code&gt;[]int64&lt;/code&gt;），然后直接读写这个 Slice。相比于调用 Column 的接口，需要的 CPU 指令更少，性能更好。同时，转换后的 Slice 仍然引用着 Column 中的内存，修改后不用将数据从 Slice 拷贝到 Column 中，开销降到了最低。&lt;/p&gt;&lt;p&gt;对于变长类型，元素长度不固定，且为了保证元素在内存中连续存放，所以不能直接用 Slice 的方式随机读写。我们规定变长类型数据以追加写（&lt;code&gt;append&lt;/code&gt;）的方式更新，用 Column 的 &lt;code&gt;Get()&lt;/code&gt; 接口进行读取。&lt;/p&gt;&lt;p&gt;总的来说，变长和定长类型的读写方式如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;定长类型（以 &lt;code&gt;int64&lt;/code&gt; 为例)&lt;br/&gt;a. &lt;code&gt;ResizeInt64s(size, isNull)&lt;/code&gt;：预分配 size 个元素的空间，并把所有位置的 &lt;code&gt;null&lt;/code&gt; 标记都设置为 &lt;code&gt;isNull&lt;/code&gt;；&lt;br/&gt;b. &lt;code&gt;Int64s()&lt;/code&gt;：返回一个 &lt;code&gt;[]int64&lt;/code&gt; 的 Slice，用于直接读写数据；&lt;br/&gt;c. &lt;code&gt;SetNull(rowID, isNull)&lt;/code&gt;：标记第 &lt;code&gt;rowID&lt;/code&gt; 行为 &lt;code&gt;isNull&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;变长类型（以 &lt;code&gt;string&lt;/code&gt; 为例）&lt;br/&gt;a. &lt;code&gt;ReserveString(size)&lt;/code&gt;：预估 size 个元素的空间，并预先分配内存；&lt;br/&gt;b. &lt;code&gt;AppendString(string)&lt;/code&gt;: 追加一个 string 到向量末尾；&lt;br/&gt;c. &lt;code&gt;AppendNull()&lt;/code&gt;：追加一个 &lt;code&gt;null&lt;/code&gt; 到向量末尾；&lt;br/&gt;d. &lt;code&gt;GetString(rowID)&lt;/code&gt;：读取下标为 &lt;code&gt;rowID&lt;/code&gt; 的 string 数据。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当然还有些其他的方法如 &lt;code&gt;IsNull(rowID)&lt;/code&gt;，&lt;code&gt;MergeNulls(cols)&lt;/code&gt; 等，就交给大家自己去探索了，后面会有这些方法的使用例子。&lt;/p&gt;&lt;h3&gt;2. 表达式向量化计算框架&lt;/h3&gt;&lt;p&gt;向量化的计算接口大概如下（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/blob/master/expression/builtin.go%23L340&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;完整的定义在这里&lt;/a&gt;）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;vectorized() bool
vecEvalXType(input *Chunk, result *Column) error&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;XType&lt;/code&gt; 可能表示 &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt; 等，不同的函数需要实现不同的接口；&lt;/li&gt;&lt;li&gt;&lt;code&gt;input&lt;/code&gt; 表示输入数据，类型为 &lt;code&gt;*Chunk&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;&lt;code&gt;result&lt;/code&gt; 用来存放结果数据。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;外部执行算子（如 Projection，Selection 等算子），在调用表达式接口进行计算前，会通过 &lt;code&gt;vectorized()&lt;/code&gt; 来判断此表达式是否支持向量化计算，如果支持，则调用向量化接口，否则就走行式接口。&lt;/p&gt;&lt;p&gt;对于任意表达式，只有当其中所有函数都支持向量化后，才认为这个表达式是支持向量化的。&lt;/p&gt;&lt;p&gt;比如 &lt;code&gt;(2+6)*3&lt;/code&gt;，只有当 &lt;code&gt;MultiplyInt&lt;/code&gt; 和 &lt;code&gt;PlusInt&lt;/code&gt; 函数都向量化后，它才能被向量化执行。&lt;/p&gt;&lt;h2&gt;为函数实现向量化接口&lt;/h2&gt;&lt;p&gt;要实现函数向量化，还需要为其实现 &lt;code&gt;vecEvalXType()&lt;/code&gt; 和 &lt;code&gt;vectorized()&lt;/code&gt; 接口。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;vectorized()&lt;/code&gt; 接口中返回 &lt;code&gt;true&lt;/code&gt; ，表示该函数已经实现向量化计算；&lt;/li&gt;&lt;li&gt;在 &lt;code&gt;vecEvalXType()&lt;/code&gt; 实现此函数的计算逻辑。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;尚未向量化的函数在&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/issues/12058&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;issue/12058&lt;/a&gt;&lt;/b&gt; &lt;b&gt;中，欢迎感兴趣的同学加入我们一起完成这项宏大的工程。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;向量化代码需放到以 &lt;code&gt;_vec.go&lt;/code&gt; 结尾的文件中，如果还没有这样的文件，欢迎新建一个，注意在文件头部加上 licence 说明。&lt;/p&gt;&lt;p&gt;这里是一个简单的例子 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12012&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR/12012&lt;/a&gt;，以 &lt;code&gt;builtinLog10Sig&lt;/code&gt; 为例：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;这个函数在 &lt;code&gt;expression/builtin_math.go&lt;/code&gt; 文件中，则向量化实现需放到文件 &lt;code&gt;expression/builtin_math_vec.go&lt;/code&gt; 中；&lt;/li&gt;&lt;li&gt;&lt;code&gt;builtinLog10Sig&lt;/code&gt; 原始的非向量化计算接口为 &lt;code&gt;evalReal()&lt;/code&gt;，那么我们需要为其实现对应的向量化接口为 &lt;code&gt;vecEvalReal()&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;实现完成后请根据后续的说明添加测试。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下面为大家介绍在实现向量化计算过程中需要注意的问题。&lt;/p&gt;&lt;h3&gt;1. 如何获取和释放中间结果向量&lt;/h3&gt;&lt;p&gt;存储表达式计算中间结果的向量可通过表达式内部对象 &lt;code&gt;bufAllocator&lt;/code&gt; 的 &lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;put()&lt;/code&gt; 来获取和释放，参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12014&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR/12014&lt;/a&gt;，以 &lt;code&gt;builtinRepeatSig&lt;/code&gt; 的向量化实现为例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;buf2, err := b.bufAllocator.get(types.ETInt, n)
if err != nil {
    return err
}
defer b.bufAllocator.put(buf2) // 注意释放之前申请的内存&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;2. 如何更新定长类型的结果&lt;/h3&gt;&lt;p&gt;如前文所说，我们需要使用 &lt;code&gt;ResizeXType()&lt;/code&gt; 和 &lt;code&gt;XTypes()&lt;/code&gt; 来初始化和获取用于存储定长类型数据的 Golang Slice，直接读写这个 Slice 来完成数据操作，另外也可以使用 &lt;code&gt;SetNull()&lt;/code&gt; 来设置某个元素为 &lt;code&gt;NULL&lt;/code&gt;。代码参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12012&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR/12012&lt;/a&gt;，以 &lt;code&gt;builtinLog10Sig&lt;/code&gt; 的向量化实现为例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;f64s := result.Float64s()
for i := 0; i &amp;lt; n; i++ {
    if isNull {
        result.SetNull(i, true)
    } else {
        f64s[i] = math.Log10(f64s[i])
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;3. 如何更新变长类型的结果&lt;/h3&gt;&lt;p&gt;如前文所说，我们需要使用 &lt;code&gt;ReserveXType()&lt;/code&gt; 来为变长类型预分配一段内存（降低 Golang runtime.growslice() 的开销），使用 &lt;code&gt;AppendXType()&lt;/code&gt; 来追加一个变长类型的元素，使用 &lt;code&gt;GetXType()&lt;/code&gt; 来读取一个变长类型的元素。代码参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12014&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR/12014&lt;/a&gt;，以 &lt;code&gt;builtinRepeatSig&lt;/code&gt; 的向量化实现为例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;result.ReserveString(n)
...
for i := 0; i &amp;lt; n; i++ {
    str := buf.GetString(i)
    if isNull {
        result.AppendNull()
    } else {
    result.AppendString(strings.Repeat(str, int(num)))
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;4. 如何处理 Error&lt;/h3&gt;&lt;p&gt;所有受 SQL Mode 控制的 Error，都利用对应的错误处理函数在函数内就地处理。部分 Error 可能会被转换成 Warn 而不需要立即抛出。&lt;/p&gt;&lt;p&gt;这个比较杂，需要查看对应的非向量化接口了解具体行为。代码参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12042&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR/12042&lt;/a&gt;，以 &lt;code&gt;builtinCastIntAsDurationSig&lt;/code&gt; 的向量化实现为例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;for i := 0; i &amp;lt; n; i++ {
    ...
    dur, err := types.NumberToDuration(i64s[i], int8(b.tp.Decimal))
    if err != nil {
       if types.ErrOverflow.Equal(err) {
          err = b.ctx.GetSessionVars().StmtCtx.HandleOverflow(err, err) // 就地利用对应处理函数处理错误
       }
       if err != nil { // 如果处理不掉就抛出
          return err
       }
       result.SetNull(i, true)
       continue
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;5. 如何添加测试&lt;/h3&gt;&lt;p&gt;我们做了一个简易的测试框架，可避免大家测试时做一些重复工作。&lt;/p&gt;&lt;p&gt;该测试框架的代码在 &lt;code&gt;expression/bench_test.go&lt;/code&gt; 文件中，被实现在 &lt;code&gt;testVectorizedBuiltinFunc&lt;/code&gt; 和 &lt;code&gt;benchmarkVectorizedBuiltinFunc&lt;/code&gt; 两个函数中。&lt;/p&gt;&lt;p&gt;我们为每一个 &lt;code&gt;builtin_XX_vec.go&lt;/code&gt; 文件增加了 &lt;code&gt;builtin_XX_vec_test.go&lt;/code&gt; 测试文件。当我们为一个函数实现向量化后，需要在对应测试文件内的 &lt;code&gt;vecBuiltinXXCases&lt;/code&gt; 变量中，增加一个或多个测试 case。下面我们为 log10 添加一个测试 case：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;var vecBuiltinMathCases = map[string][]vecExprBenchCase {
    ast.Log10: {
        {types.ETReal, []types.EvalType{types.ETReal}, nil},
    },
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体来说，上面结构体中的三个字段分别表示:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;该函数的返回值类型；&lt;/li&gt;&lt;li&gt;该函数所有参数的类型；&lt;/li&gt;&lt;li&gt;是否使用自定义的数据生成方法（dataGener），&lt;code&gt;nil&lt;/code&gt; 表示使用默认的随机生成方法。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对于某些复杂的函数，你可自己实现 dataGener 来生成数据。目前我们已经实现了几个简单的 dataGener，代码在 &lt;code&gt;expression/bench_test.go&lt;/code&gt; 中，可直接使用。&lt;/p&gt;&lt;p&gt;添加好 case 后，在 expression 目录下运行测试指令：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;# 功能测试
GO111MODULE=on go test -check.f TestVectorizedBuiltinMathFunc

# 性能测试
go test -v -benchmem -bench=BenchmarkVectorizedBuiltinMathFunc -run=BenchmarkVectorizedBuiltinMathFunc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在你的 PR Description 中，请把性能测试结果附上。不同配置的机器，性能测试结果可能不同，我们对机器配置无任何要求，你只需在 PR 中带上你本地机器的测试结果，让我们对向量化前后的性能有一个对比即可。&lt;/p&gt;&lt;h2&gt;如何成为 Contributor&lt;/h2&gt;&lt;p&gt;&lt;b&gt;为了推进表达式向量化计算，我们正式成立 Vectorized Expression Working Group，其具体的目标和制度详见&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/community/blob/master/working-groups/wg-vec-expr.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;。与此对应，我们在&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/tidbslack/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Community Slack&lt;/a&gt;&lt;/b&gt; &lt;b&gt;中创建了&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//app.slack.com/client/TH91JCS4W/CMRD79DRR&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;wg-vec-expr channel&lt;/a&gt;&lt;/b&gt; &lt;b&gt;供大家交流讨论，不设门槛，欢迎感兴趣的同学加入。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如何成为 Contributor：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在此 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/issues/12058&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;issue&lt;/a&gt; 内选择感兴趣的函数并告诉大家你会完成它；&lt;/li&gt;&lt;li&gt;为该函数实现 &lt;code&gt;vecEvalXType()&lt;/code&gt; 和 &lt;code&gt;vectorized()&lt;/code&gt; 的方法；&lt;/li&gt;&lt;li&gt;在向量化测试框架内添加对该函数的测试；&lt;/li&gt;&lt;li&gt;运行 &lt;code&gt;make dev&lt;/code&gt;，保证所有 test 都能通过；&lt;/li&gt;&lt;li&gt;发起 Pull Request 并完成 merge 到主分支。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果贡献突出，可能被提名为 reviewer，reviewer 的介绍请看 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/community/blob/master/CONTRIBUTING.md%23reviewer&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;如果你有任何疑问，也欢迎到 wg-vec-expr channel 中提问和讨论。&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-17-82815389</guid>
<pubDate>Tue, 17 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>跨越、爆发，所见「可提升」之处，皆是你的竞技场 | TiDB Hackathon 2019 启动</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-15-82263579.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82263579&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ac90f82e4787e10516ecf46ae044fedc_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;TiDB 社区有一个信念是：我们从不给自己设限，突破&amp;amp;提升才是一直追求的常态。在 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/hackathon2018/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;去年举办的 TiDB 黑客马拉松&lt;/a&gt;&lt;/u&gt; 上，诞生了很多兼具想象力和实用性的 TiDB 生态工具，我们当然也并不满足于此，&lt;b&gt;10 月 26 - 27 日，TiDB  Hackathon 2019 重磅回归！本届主题较去年更加广泛&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;&lt;b&gt;IMPROVE · 跃 界&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;本届比赛将弱化地域限制&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;北京、上海、广州三地联动&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;奖金依然丰厚&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;但好点子无价&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;大咖导师巡场带教&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;10 分钟零距离交流可能胜过埋头苦思 1 个月&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;啤酒 Pizza 不眠夜&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;期待各路大神集结，享受代码世界中的极致自由&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;冲撞 跨越 爆发&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;让 TiDB 来一次简单粗暴、突破常规的「跃界」吧！&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;选题方向&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;参赛选手可以为 TiDB 性能、易用性、稳定性、功能等各方面做出提升，当然也可以围绕 TiDB 生态做一些周边工具提升效率，比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Key Visualizer for TiKV&lt;/b&gt;&lt;br/&gt;可视化的 KV 的诊断工具，做到对集群的热点，访问模式一目了然。&lt;/li&gt;&lt;li&gt;&lt;b&gt;基于历史的查询优化&lt;/b&gt;&lt;br/&gt;让 TiDB 的 SQL 优化器能通过稳态的查询历史生成稳定的执行计划，防止执行计划跳变。&lt;/li&gt;&lt;li&gt;&lt;b&gt;Follower Read 与 MVCC 的结合&lt;/b&gt;&lt;br/&gt;让 TiDB 的多副本能够承担读流量， 提升整体的吞吐。&lt;/li&gt;&lt;li&gt;&lt;b&gt;TiDB Playground&lt;/b&gt;&lt;br/&gt;类似 Go Playground (&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//play.golang.org&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;play.golang.org&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;) 的所见即所得的交互式 TiDB Web 体验工具。&lt;/li&gt;&lt;li&gt;&lt;b&gt;更期待你能够提出新点子&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;奖项设置&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本届 Hackathon 的奖金依然非常「实在」：&lt;/p&gt;&lt;p&gt;🏅&lt;b&gt;一等奖（1 支队伍）： ¥ 60,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;🥈&lt;b&gt;二等奖（2 支队伍）：每队 ¥ 30,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;🥉&lt;b&gt;三等奖（3 支队伍）：每队 ¥ 10,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;另设最佳贡献奖、最佳创意奖、最具潜力奖，将有 TiDB 周边礼品奖励。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;学习资料&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;由于大家普遍反映 TiDB 源码上手难度有点高，所以我们列出了一些「学习资料」，大家可以根据个人基础和选题方向灵活选择。&lt;/p&gt;&lt;p&gt;Hackathon 专项学习文档汇总了 TiDB 核心团队出品的数十篇精选技术详解文章，帮助大家轻松掌握 TiDB 各核心组件的原理及功能，文档链接：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/presentations/blob/master/hackathon-2019/reference-document-of-hackathon-2019.md&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-2e73d3d3251663decc70dfbbe5be5f6a_ipico.jpg&quot; data-image-width=&quot;283&quot; data-image-height=&quot;283&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;pingcap/presentations&lt;/a&gt;&lt;p&gt;另外，大家也可以参考 PingCAP University 丰富的视频教程，网站链接：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//university.pingcap.com/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-0f1b58d10b1c02e158081b6141adfb4d_ipico.jpg&quot; data-image-width=&quot;217&quot; data-image-height=&quot;264&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PingCAP University&lt;/a&gt;&lt;h2&gt;&lt;b&gt;报名参赛&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;比赛时间：2019 年 10 月 26 ～ 27 日&lt;/li&gt;&lt;li&gt;比赛地点：PingCAP 北京、上海、广州 Office&lt;/li&gt;&lt;li&gt;组队规则：1～4 人成队，选择一地参赛&lt;/li&gt;&lt;li&gt;报名时间：即日起至 10 月 23 日&lt;/li&gt;&lt;li&gt;报名审核：5 个工作日内反馈审核结果&lt;/li&gt;&lt;li&gt;报名地址：&lt;/li&gt;&lt;/ul&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//nc9hsk15y2xczuor.mikecrm.com/PiwBPaL&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Hackathon 重磅回归！&lt;/a&gt;&lt;p&gt;* 本次大赛诚招志愿者参与活动现场支持。如果你想近距离接触技术大咖，体验大赛氛围，那就联系 TiDB Robot（微信号：tidbai）报名吧～志愿者也可以获得活动定制纪念品哦！&lt;/p&gt;&lt;p&gt;&lt;b&gt;合作伙伴&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;云计算基础设施支持：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;132&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;132&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;社区支持：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;246&quot; data-rawheight=&quot;80&quot; class=&quot;content_image&quot; width=&quot;246&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;246&quot; data-rawheight=&quot;80&quot; class=&quot;content_image lazy&quot; width=&quot;246&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;338&quot; data-rawheight=&quot;80&quot; class=&quot;content_image&quot; width=&quot;338&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;338&quot; data-rawheight=&quot;80&quot; class=&quot;content_image lazy&quot; width=&quot;338&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;进入活动官网了解更多信息：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/hackathon2019/%3Futm_source%3Dwechat%26utm_medium%3Dpingcap%26utm_campaign%3Dpingcap%2520190911&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt; | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-15-82263579</guid>
<pubDate>Sun, 15 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>从使用者到开发者，知乎参与 TiDB 社区背后的故事</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-12-82318701.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82318701&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0d2f4bfe8a576e111a55da7e3a0a816_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;作者介绍&lt;/b&gt;：孙晓光，知乎技术平台团队负责人，负责建设知乎在线和离线的基础设施平台，为业务开发提供统一的基础设施。曾多年从事私有云相关产品开发工作，关注云原生技术，TiKV 项目 Committer。&lt;/blockquote&gt;&lt;p&gt;关注 TiDB 的朋友们可能发现继 Follower Read 在 TiKV 端的 PR 合并后，TiDB 端相关的 PR 也于近期完成了到主干的合并工作。如果后期的稳定性测试一切正常，相关功能应该会随 TiDB 3.1 发布。Follower Read 功能本身从代码量上看并不大，但这个功能的意义尤其是对互联网类型业务来说是非常大的。&lt;/p&gt;&lt;p&gt;前段时间 PingCAP CTO 黄东旭已经写了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/follower-read-the-new-features-of-tidb/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;一篇文章&lt;/a&gt;，从原理角度对 Follower Read 做了非常透彻的介绍和分析。今天我想从非技术的角度介绍 Follower Read 功能的落地过程，并从 Contributor 的视角跟大家聊一聊个人参与 TiDB 开发过程中的体验和感受。最后站在知乎技术平台团队的角度，聊一下我们未来在积极参与开源项目，共同建设社区的愿望和决心。&lt;/p&gt;&lt;h2&gt;Follower Read 背后的故事&lt;/h2&gt;&lt;p&gt;Follower Read 的实现思路在 PingCAP 工程师大脑里应该已经存在很久了，但出于各种原因这个特性的优先级一直不够高，并没有能排到开发计划中。年中的时候我们开始尝试在知乎更广泛的业务中引入 TiDB，在灰度过程中我们遇到了某些特定工作负载下 TiDB 表现不够理想的问题。目前看来 TiDB 读写操作都交给 Leader 完成，是我们目前在特定负载下遇到吞吐问题的瓶颈点。&lt;/p&gt;&lt;p&gt;在理清思路后，我们同 PingCAP 的工程师做了几次交流并达成一致，决定通过 Follower Read 的方式来解决我们业务场景中极端热点数据访问的吞吐问题。在实际需求的驱动下， PingCAP 同学将 Follower Read 相关特性的优先级提高，快速确定了相关功能的技术方案并启动了 TiKV 端的开发工作。作为 Follower Read 功能的需求方，知乎负责这个需求在 TiDB 上的落地工作。&lt;/p&gt;&lt;p&gt;PingCAP 工程师用了大约两周的时间完成了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/pull/5051&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiKV 层 Follower Read 整个功能的开发测试&lt;/a&gt;，并将其合并到 master 分支中，随后我们开始了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/11347&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 侧相应功能的开发&lt;/a&gt;，在 PingCAP 小伙伴们的帮助下最终完成了相应功能到 master 分支的合并。作为知乎和 PingCAP 两家公司第一次联合开发的成果，这个功能的落地对双方都有着重大的意义。&lt;/p&gt;&lt;h2&gt;从 Contributor 到 Committer&lt;/h2&gt;&lt;p&gt;在以知乎技术平台团队成员的身份参与 TiDB 贡献之前，个人曾经在过去的一年里以用户的身份为 TiKV &amp;amp; TiDB 做过一些小型的贡献。接下来我就从个人角度聊一下从 Contributor 到 Committer 的成长过程和其中的体验。&lt;/p&gt;&lt;p&gt;第一次为 PingCAP 旗下项目提交 PR 并成为 Contributor 发生在大约一年前，我在为内部开发的业务系统选择合适的存储后端时，尝试给 TiKV 增加了一些批量操作接口。PR 提出后，PingCAP 首席架构师唐刘很快就跟我建立了联系，在随后的交流中帮助我快速完善 PR 并最终合并到 TiKV 的主干中。&lt;/p&gt;&lt;p&gt;虽然以往以零散的方式给很多开源项目提交过 Patch，但这次的体验是完全不同的，PingCAP 和社区伙伴们热心的帮助和鼓励让我切身感受到了活跃的开源社区所具有的独特魅力。随后出于个人兴趣，我在 TiDB 相关的项目中又陆陆续续做了一些简单的贡献，最终得到大家的认可成为 TiKV 项目的 Committer 之一。&lt;/p&gt;&lt;h2&gt;拥抱开源&lt;/h2&gt;&lt;p&gt;回过头来看这段时间的成长和收获都是巨大的，不但学习到了如何同开源社区众多优秀的贡献者更加高效的交流，并且对开源的价值理念和开源在基础软件领域的重大意义有了更加深入的理解。&lt;/p&gt;&lt;p&gt;近期随着在公司所在团队的转换，我个人开始更多的关注在线和离线的基础设施在知乎的演进。知乎一直以来都鼓励拥抱开源，并基于大量开源组件搭建了知乎的技术架构，得益于开源的力量，知乎的内部平台一直都紧随着行业技术发展的潮流。从前我们更多是站在使用者的角度从开源社区汲取养分，随着知乎技术架构和内部工程能力的成长，未来我们希望能够以更加积极主动的状态参与开源项目，回馈社区。Follower Read 是知乎第一次以 Contributor 身份参与 TiDB 社区建设，未来我们会参与更多的技术社区的建设为开源社区的发展贡献我们的力量。&lt;/p&gt;&lt;p&gt;&lt;b&gt;原文阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/zhihu-the-story-of-contributing-to-tidb-community/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;从使用者到开发者，知乎参与 TiDB 社区背后的故事 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-12-82318701</guid>
<pubDate>Thu, 12 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>跨越、爆发，所见「可提升」之处，皆是你的竞技场 | TiDB Hackathon 2019 启动</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-12-82263579.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82263579&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ac90f82e4787e10516ecf46ae044fedc_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;TiDB 社区有一个信念是：我们从不给自己设限，突破&amp;amp;提升才是一直追求的常态。在 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/hackathon2018/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;去年举办的 TiDB 黑客马拉松&lt;/a&gt;&lt;/u&gt; 上，诞生了很多兼具想象力和实用性的 TiDB 生态工具，我们当然也并不满足于此，&lt;b&gt;10 月 26 - 27 日，TiDB  Hackathon 2019 重磅回归！本届主题较去年更加广泛&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;&lt;b&gt;IMPROVE · 跃 界&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;本届比赛将弱化地域限制&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;北京、上海、广州三地联动&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;奖金依然丰厚&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;但好点子无价&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;大咖导师巡场带教&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;10 分钟零距离交流可能胜过埋头苦思 1 个月&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;啤酒 Pizza 不眠夜&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;期待各路大神集结，享受代码世界中的极致自由&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;冲撞 跨越 爆发&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;让 TiDB 来一次简单粗暴、突破常规的「跃界」吧！&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;选题方向&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;参赛选手可以为 TiDB 性能、易用性、稳定性、功能等各方面做出提升，当然也可以围绕 TiDB 生态做一些周边工具提升效率，比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Key Visualizer for TiKV&lt;/b&gt;&lt;br/&gt;可视化的 KV 的诊断工具，做到对集群的热点，访问模式一目了然。&lt;/li&gt;&lt;li&gt;&lt;b&gt;基于历史的查询优化&lt;/b&gt;&lt;br/&gt;让 TiDB 的 SQL 优化器能通过稳态的查询历史生成稳定的执行计划，防止执行计划跳变。&lt;/li&gt;&lt;li&gt;&lt;b&gt;Follower Read 与 MVCC 的结合&lt;/b&gt;&lt;br/&gt;让 TiDB 的多副本能够承担读流量， 提升整体的吞吐。&lt;/li&gt;&lt;li&gt;&lt;b&gt;TiDB Playground&lt;/b&gt;&lt;br/&gt;类似 Go Playground (&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//play.golang.org&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;play.golang.org&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;) 的所见即所得的交互式 TiDB Web 体验工具。&lt;/li&gt;&lt;li&gt;&lt;b&gt;更期待你能够提出新点子&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;奖项设置&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本届 Hackathon 的奖金依然非常「实在」：&lt;/p&gt;&lt;p&gt;🏅&lt;b&gt;一等奖（1 支队伍）： ¥ 60,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;🥈&lt;b&gt;二等奖（2 支队伍）：每队 ¥ 30,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;🥉&lt;b&gt;三等奖（3 支队伍）：每队 ¥ 10,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;另设最佳贡献奖、最佳创意奖、最具潜力奖，将有 TiDB 周边礼品奖励。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;学习资料&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;由于大家普遍反映 TiDB 源码上手难度有点高，所以我们列出了一些「学习资料」，大家可以根据个人基础和选题方向灵活选择。&lt;/p&gt;&lt;p&gt;Hackathon 专项学习文档汇总了 TiDB 核心团队出品的数十篇精选技术详解文章，帮助大家轻松掌握 TiDB 各核心组件的原理及功能，文档链接：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/presentations/blob/master/hackathon-2019/reference-document-of-hackathon-2019.md&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-2e73d3d3251663decc70dfbbe5be5f6a_ipico.jpg&quot; data-image-width=&quot;283&quot; data-image-height=&quot;283&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;pingcap/presentations&lt;/a&gt;&lt;p&gt;另外，大家也可以参考 PingCAP University 丰富的视频教程，网站链接：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//university.pingcap.com/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-0f1b58d10b1c02e158081b6141adfb4d_ipico.jpg&quot; data-image-width=&quot;217&quot; data-image-height=&quot;264&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PingCAP University&lt;/a&gt;&lt;h2&gt;&lt;b&gt;报名参赛&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;比赛时间：2019 年 10 月 26 ～ 27 日&lt;/li&gt;&lt;li&gt;比赛地点：PingCAP 北京、上海、广州 Office&lt;/li&gt;&lt;li&gt;组队规则：1～4 人成队，选择一地参赛&lt;/li&gt;&lt;li&gt;报名时间：即日起至 10 月 23 日&lt;/li&gt;&lt;li&gt;报名审核：5 个工作日内反馈审核结果&lt;/li&gt;&lt;li&gt;报名地址：&lt;/li&gt;&lt;/ul&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//nc9hsk15y2xczuor.mikecrm.com/PiwBPaL&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Hackathon 重磅回归！&lt;/a&gt;&lt;p&gt;* 本次大赛诚招志愿者参与活动现场支持。如果你想近距离接触技术大咖，体验大赛氛围，那就联系 TiDB Robot（微信号：tidbai）报名吧～志愿者也可以获得活动定制纪念品哦！&lt;/p&gt;&lt;p&gt;&lt;b&gt;合作伙伴&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;云计算基础设施支持：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;132&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;132&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;社区支持：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;246&quot; data-rawheight=&quot;80&quot; class=&quot;content_image&quot; width=&quot;246&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;246&quot; data-rawheight=&quot;80&quot; class=&quot;content_image lazy&quot; width=&quot;246&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;338&quot; data-rawheight=&quot;80&quot; class=&quot;content_image&quot; width=&quot;338&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;338&quot; data-rawheight=&quot;80&quot; class=&quot;content_image lazy&quot; width=&quot;338&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;进入活动官网了解更多信息：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/hackathon2019/%3Futm_source%3Dwechat%26utm_medium%3Dpingcap%26utm_campaign%3Dpingcap%2520190911&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt; | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-12-82263579</guid>
<pubDate>Thu, 12 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何高效利用 Grafana 监控分析 TiDB 指标</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-10-81926744.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/81926744&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e4100a49788fc94b31574d46f7d52994_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;作者介绍&lt;/b&gt;：李坤，PingCAP 互联网架构师，TUG Ambassador，前美团、去哪儿数据库专家。&lt;/blockquote&gt;&lt;h2&gt;一、概述&lt;/h2&gt;&lt;p&gt;使用 TiDB Ansible 部署 TiDB 集群，会同时部署一套 Grafana + Prometheus 的监控平台，这套监控用来收集和展示 TiDB 集群各个组件和机器的 metric 信息，这些 metric 信息非常丰富，可以帮助使用者分析 TiDB 集群的状态以及 Trouble shooting。随着使用经验的增多，我们积累了一些监控使用上的技巧，在这里分享给大家。&lt;/p&gt;&lt;h2&gt;二、监控架构&lt;/h2&gt;&lt;p&gt;Prometheus 是一个拥有多维度数据模型的、灵活的查询语句的时序数据库。Grafana 是一个开源的 metric 分析及可视化系统。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-616f81b79759b78472302897dc5496d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;477&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-616f81b79759b78472302897dc5496d5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-616f81b79759b78472302897dc5496d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;477&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-616f81b79759b78472302897dc5496d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-616f81b79759b78472302897dc5496d5_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 TiDB 监控整体架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;从 TiDB 2.1.3 版本开始，监控采用 pull 的方式，而之前采用的是 push 的方式，这是一个非常好的调整，它解决了几个问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;之前如果 Prometheus 需要迁移，需要重启整个集群，因为组件要调整 push 的目标地址。&lt;/li&gt;&lt;li&gt;现在可以部署 2 套 Prometheus，防止监控的单点，因为 pull 的 source 端是可以多个。&lt;/li&gt;&lt;li&gt;去掉了 &lt;code&gt;PushGateWay&lt;/code&gt; 这个单点组件。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;三、监控数据的来源与展示&lt;/h2&gt;&lt;p&gt;TiDB 的 3 个核心组件（TiDB，TiKV，PD）可以通过 http 接口来获取 metric 数据，这些指标都是从程序代码中统计上传的，端口如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-37e946a6aec6e8b28d1c3e282fc9e24b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;404&quot; data-rawheight=&quot;278&quot; class=&quot;content_image&quot; width=&quot;404&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-37e946a6aec6e8b28d1c3e282fc9e24b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;404&quot; data-rawheight=&quot;278&quot; class=&quot;content_image lazy&quot; width=&quot;404&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-37e946a6aec6e8b28d1c3e282fc9e24b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;用 tidb-server 举例，我们通过 http 接口，看一个 statement QPS 的 metric：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;# 可以看到实时 qps 的数据，区分不同的 type，value 是 counter 类型的累计值（科学计数法）

curl http://__tidb_ip__:10080/metrics |grep tidb_executor_statement_total
tidb_executor_statement_total{type=&amp;#34;Delete&amp;#34;} 520197
tidb_executor_statement_total{type=&amp;#34;Explain&amp;#34;} 1
tidb_executor_statement_total{type=&amp;#34;Insert&amp;#34;} 7.20799402e+08
tidb_executor_statement_total{type=&amp;#34;Select&amp;#34;} 2.64983586e+08
tidb_executor_statement_total{type=&amp;#34;Set&amp;#34;} 2.399075e+06
tidb_executor_statement_total{type=&amp;#34;Show&amp;#34;} 500531
tidb_executor_statement_total{type=&amp;#34;Use&amp;#34;} 466016&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个数据会在 Prometheus 存储下来，然后在 Grafana 展示，我们在面板上点击右键会出现 &lt;code&gt;Edit&lt;/code&gt; 按钮（或直接按 e），如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-33f500dfc1a3b3076bf5f0a9ea826110_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;775&quot; data-rawheight=&quot;277&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;775&quot; data-original=&quot;https://pic1.zhimg.com/v2-33f500dfc1a3b3076bf5f0a9ea826110_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-33f500dfc1a3b3076bf5f0a9ea826110_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;775&quot; data-rawheight=&quot;277&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;775&quot; data-original=&quot;https://pic1.zhimg.com/v2-33f500dfc1a3b3076bf5f0a9ea826110_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-33f500dfc1a3b3076bf5f0a9ea826110_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2 metric 面板的编辑入口&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们可以在 &lt;code&gt;Metric&lt;/code&gt; 面板上，看到利用该 metric 的 query 表达式。&lt;/p&gt;&lt;p&gt;面板上一些细节的含义：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;rate[1m]&lt;/code&gt;：表示 1 分钟的增长速率，只能用于 counter 类型的数据。&lt;/li&gt;&lt;li&gt;&lt;code&gt;sum&lt;/code&gt;：表示 value 求和。&lt;/li&gt;&lt;li&gt;&lt;code&gt;by type&lt;/code&gt;：表示将求和后的数据按 metric 的原始值中的 type 进行分组。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Legend format&lt;/code&gt;：表示指标名称的格式。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Resolution&lt;/code&gt;：默认打点步长是 15s，&lt;code&gt;Resolution&lt;/code&gt; 表示是否分解。&lt;/li&gt;&lt;/ol&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-da973f7abee4f9ba71861fbcc13136ba_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;362&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-da973f7abee4f9ba71861fbcc13136ba_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-da973f7abee4f9ba71861fbcc13136ba_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;362&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-da973f7abee4f9ba71861fbcc13136ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-da973f7abee4f9ba71861fbcc13136ba_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3 metric 面板中的表达式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Prometheus 支持很多表达式与函数，更多表达式请参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//prometheus.io/docs/prometheus/latest/querying&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;官网页面&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;四、Grafana 使用技巧&lt;/h2&gt;&lt;h3&gt;技巧 1：查看所有维度并编辑表达式&lt;/h3&gt;&lt;p&gt;如上一小节的例子，是按照 type 进行分组，是否还能用其他维度分组？如何能快速得知还有哪些维度呢？这里推荐的技巧是，在 query 的表达式上只用指标名称，不做任何计算，format 也留空，这样就能显示出原始的 metric 数据，比如下图能看到有 3 个维度（&lt;code&gt;instance&lt;/code&gt;、&lt;code&gt;job&lt;/code&gt;、&lt;code&gt;type&lt;/code&gt;）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3a653ca29fa35cc58954c6c0df28cb19_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;383&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-3a653ca29fa35cc58954c6c0df28cb19_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3a653ca29fa35cc58954c6c0df28cb19_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;383&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-3a653ca29fa35cc58954c6c0df28cb19_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3a653ca29fa35cc58954c6c0df28cb19_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4 编辑表达式并查看所有维度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;得到 &lt;code&gt;instance&lt;/code&gt; 这个维度后，我们调整表达式，在原有的 type 后面加上 &lt;code&gt;instance&lt;/code&gt; 这个维度，调整 &lt;code&gt;legend format&lt;/code&gt; 格式增加 &lt;code&gt;{{instance}}&lt;/code&gt;，就可以看到每个 tidb-server 上执行的不同类型 SQL 的 QPS 了。如下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8b5983eb4b274ded704ff7c6046def28_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;387&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-8b5983eb4b274ded704ff7c6046def28_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8b5983eb4b274ded704ff7c6046def28_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;387&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-8b5983eb4b274ded704ff7c6046def28_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8b5983eb4b274ded704ff7c6046def28_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5 给表达式增加一个 instance 维度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;技巧 2：调整 Y 轴标尺的计算方式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以 &lt;code&gt;query duration&lt;/code&gt; 指标为例，默认的比例尺采用 2 的对数计算，显示上会将差距缩小。为了观察明显的变化，可以将比例尺改为线性，通过下面两张图，可以看到显示上的区别，明显的发现那个时刻有个 SQL 运行较慢。&lt;/p&gt;&lt;p&gt;当然也不是所有场景都适合用线性，比如观察 1 个月的性能趋势，用线性可能就会有很多噪点，不好观察。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-df520f520f79db64159cb77b2a2221fc_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-df520f520f79db64159cb77b2a2221fc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-df520f520f79db64159cb77b2a2221fc_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-df520f520f79db64159cb77b2a2221fc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-df520f520f79db64159cb77b2a2221fc_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6 标尺默认的比例尺为 2 的对数&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a6ff65cb955876d2f8c1bc80e0895fc1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a6ff65cb955876d2f8c1bc80e0895fc1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a6ff65cb955876d2f8c1bc80e0895fc1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a6ff65cb955876d2f8c1bc80e0895fc1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a6ff65cb955876d2f8c1bc80e0895fc1_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7 调整标尺的比例尺为线性&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;提示：我们可以结合技巧 1，发现这里还有一个 &lt;code&gt;sql_type&lt;/code&gt; 的维度，可以立刻分析出是 select 慢还是 update 慢，并且可以分析出是在哪个 instance 上慢。&lt;/blockquote&gt;&lt;h3&gt;技巧 3：调整 Y 轴基线，放大变化&lt;/h3&gt;&lt;p&gt;有一种情况：已经用了线性显示，还是看不出变化趋势。比如下图中，我们在扩容后想观察 &lt;code&gt;Store size&lt;/code&gt; 的实时变化效果，由于基数较大，微弱的变化观察不到。 这时我们可以将 Y 轴最小值从 &lt;code&gt;0&lt;/code&gt; 改为 &lt;code&gt;auto&lt;/code&gt;，将上部放大，观察下面两张图的区别，可以观察到数据已开始迁移了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;404&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;404&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8 基线默认为 0&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;404&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;404&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9 调整基线为 auto&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;技巧 4：标尺联动&lt;/h3&gt;&lt;p&gt;在 Setting 面板中，有 &lt;code&gt;Graph Tooltip&lt;/code&gt; 的设置，默认使用 &lt;code&gt;Default&lt;/code&gt;。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-65fcf7b366bb88bf67e7aebd49abbb5c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;216&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-65fcf7b366bb88bf67e7aebd49abbb5c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-65fcf7b366bb88bf67e7aebd49abbb5c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;216&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-65fcf7b366bb88bf67e7aebd49abbb5c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-65fcf7b366bb88bf67e7aebd49abbb5c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10 图形展示工具&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们调整为 &lt;code&gt;Shared crosshair&lt;/code&gt; 和 &lt;code&gt;Shared Tooltip&lt;/code&gt; 分别试一下效果： 可以看到标尺可以联动展示了，方便排查问题时，确认 2 个指标的关联性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ed30406174113b1df75cff2054f10c8b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;158&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-ed30406174113b1df75cff2054f10c8b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ed30406174113b1df75cff2054f10c8b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;158&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-ed30406174113b1df75cff2054f10c8b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ed30406174113b1df75cff2054f10c8b_b.jpg&quot;/&gt;&lt;figcaption&gt;图 11 调整图形展示工具为 Shared crosshair&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c8abcc11f617a38e37039ed2b2819a8c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;162&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-c8abcc11f617a38e37039ed2b2819a8c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c8abcc11f617a38e37039ed2b2819a8c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;162&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-c8abcc11f617a38e37039ed2b2819a8c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c8abcc11f617a38e37039ed2b2819a8c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 12 调整图形展示工具为 Shared Tooltip&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;技巧 5：调整过滤项&lt;/h3&gt;&lt;p&gt;PD 的 Dashboard，只展示当前 leader 的 metric 信息，有时候会想看一下历史上 pd-leader 当时的状况，但是 instance 下拉列表中不存在这个成员了，我们也可以手动输入 &lt;code&gt;ip:2379&lt;/code&gt; 来看到当时的数据。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5d8cb9782a722bd11359e2628f93c8b6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5d8cb9782a722bd11359e2628f93c8b6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5d8cb9782a722bd11359e2628f93c8b6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5d8cb9782a722bd11359e2628f93c8b6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5d8cb9782a722bd11359e2628f93c8b6_b.jpg&quot;/&gt;&lt;figcaption&gt;图 13 手动输入并查看 metric&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;技巧 6：巧用 &lt;code&gt;Avg&lt;/code&gt; 函数&lt;/h3&gt;&lt;p&gt;通常默认图例中只有 &lt;code&gt;Max&lt;/code&gt; 和 &lt;code&gt;Current&lt;/code&gt;，但有时指标波动较大时，我们可以增加 &lt;code&gt;Avg&lt;/code&gt; 等其他汇总函数的图例，可以看一段时间的整体趋势。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot;/&gt;&lt;figcaption&gt;图 14 增加 Avg 等汇总函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot;/&gt;&lt;figcaption&gt;图 15 增加 Avg 函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;技巧 7：使用 Prometheus 的 API 接口获得表达式的结果&lt;/h3&gt;&lt;p&gt;Grafana 通过 Prometheus 的接口获取数据，我们也可以用该接口获取数据，这个用法可以扩散出很多功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;自动化平台获取集群规模、状态等信息。&lt;/li&gt;&lt;li&gt;对表达式稍加改动给报表提供数据，如统计每天的 QPS 总量、每天的 QPS 峰值、每天响应时间的汇总。&lt;/li&gt;&lt;li&gt;将重要的指标进行定期健康巡检。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot;/&gt;&lt;figcaption&gt;图 16 Prometheus 的 API 接口&lt;/figcaption&gt;&lt;/figure&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;curl -u user:pass &amp;#39;http://__grafana_ip__:3000/api/datasources/proxy/1/api/v1/query_range?query=sum(tikv_engine_size_bytes%7Binstancexxxxxxxxx20181%22%7D)%20by%20(instance)&amp;amp;start=1565879269&amp;amp;end=1565882869&amp;amp;step=30&amp;#39; |python -m json.tool
{
    &amp;#34;data&amp;#34;: {
        &amp;#34;result&amp;#34;: [
            {
                &amp;#34;metric&amp;#34;: {
                    &amp;#34;instance&amp;#34;: &amp;#34;xxxxxxxxxx:20181&amp;#34;
                },
                &amp;#34;values&amp;#34;: [
                    [
                        1565879269,
                        &amp;#34;1006046235280&amp;#34;
                    ],
                    [
                        1565879299,
                        &amp;#34;1006057877794&amp;#34;
                    ],
                    [
                        1565879329,
                        &amp;#34;1006021550039&amp;#34;
                    ],
                    [
                        1565879359,
                        &amp;#34;1006021550039&amp;#34;
                    ],
                    [
                        1565882869,
                        &amp;#34;1006132630123&amp;#34;
                    ]
                ]
            }
        ],
        &amp;#34;resultType&amp;#34;: &amp;#34;matrix&amp;#34;
    },
    &amp;#34;status&amp;#34;: &amp;#34;success&amp;#34;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;五、总结&lt;/h2&gt;&lt;p&gt;Grafana + Prometheus 是一套非常强大的组合，用好他们可以为我们的分析节省很多时间，提高效率，更重要的是能增加发现问题的可能性。在运维 TiDB 集群时，尤其数据量大的时候，这套工具能派上大用场。这里抛砖引玉，也希望大家也能提供一些技巧，一起共同学习。&lt;/p&gt;&lt;p&gt;&lt;b&gt;原文阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/use-grafana-to-monitor-and-analyze-tidb-metrics/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;如何高效利用 Grafana 监控分析 TiDB 指标 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-10-81926744</guid>
<pubDate>Tue, 10 Sep 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
