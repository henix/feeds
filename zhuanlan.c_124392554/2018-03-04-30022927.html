<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>“宝葫芦能收宝葫芦么？”——苗苗大人</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/30022927">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-a21b2ca680cc9bec90c55d6ec1787ed8_r.jpg" alt=""></div><p>早晨，我闺女<b>苗苗</b>大人问我——</p><p>苗苗：这个★★大学这么大，怎么把它带回家啊？<br>我：用个宝葫芦！什么东西啊，说“收！”就都收进宝葫芦里面了（这时的我还在盲目沾沾自喜我的机智）。 </p><p>苗苗：那宝葫芦能把宝葫芦装进去么？</p><p>我：(°ㅂ° ╬)………………Emmmmmmmmm这个问题在<i>公理化</i>“宝葫芦”的世界里<b>不讨论</b>。 </p><p>苗苗：为什么啊(ง ˙o˙)ว？ </p><p>我：因为——“<b>正则公理</b>”。</p><hr><p>话说吧，大家都知道吧，<b>集合论（set theory）</b>是现代数学的基础。</p><p>德国数学家康托（Georg Cantor，1845-1918）对集合论的思考与研究是从对三角级数的研究中产生的。1874年他发表了第一篇关于无穷集合的文章，开创了集合论（准确地说，他所建立的是<b>朴素集合论</b>，naive set theory，NST）。而且他和戴德金（Julius Wilhelm Richard Dedekind，1831–1916）一起建立了<b>实数理论</b>，基本上为<b>第二次数学危机</b>的解决画上了完满的句号。</p><hr><p>康托自己提出了<b>康托悖论（Cantor's paradox）</b>：</p><p>首先康托证明了“康托定理”（可见“<a href="https://zhuanlan.zhihu.com/p/34097692">不能证明也无法否定的“连续统假说”——集合的势（三）</a>”）。</p><p>由此定理可得：对于任意集合 <equation>A</equation> 而言， <equation> \wp(A)\not\subseteq A</equation> 。其中 <equation> \wp(A)</equation> 表示 <equation>A</equation> 的幂集。</p><p>好的，下面假设 <equation>S</equation> 是“所有集合的集合”，那么问题就来了：对于任意 <equation>B\in \wp(S)</equation> ，由于 <equation>B</equation> 是集合，所以 <equation>B \in S</equation> ，于是 <equation> \wp(S)\subseteq S</equation> ，而这就产生了矛盾。</p><p>但这时，康托只认为这一悖论通过反证法恰恰证明了没有“所有集合的集合”或者说“最大的集合”。</p><p>其实这时已经出现了 <equation>S \in S</equation> （ <equation> S\in\wp(S)\subseteq S</equation> ）这种表述。</p><hr><p>直到1901年罗素发表了著名的<b>罗素悖论（Russell's paradox）</b>：设集合 <equation>S=\{x|x ∉S\}</equation> ，那么问题是 <equation>S\in S</equation> 是否成立？</p><p>根据排中律，回答必然是“是”或“不是”。然而若 <equation>S\in S</equation> ，则 <equation>S\not\in S</equation> ；若 <equation>S\not\in S</equation> ，则 <equation>S\in S</equation> 。——这就是“悖论”。</p><p>罗素悖论还有一种广为流传的通俗描述——<b>理发师悖论（barber paradox）</b>：在一个村子里有一位理发师，这位理发师声称：“给而且只给那些不给自己理发的人理发”。现在的问题是理发师是否给自己理发？ （首先在这个流行的说法中，必须补充一个条件：村子里<b>至少有一个</b>村民不给自己理发）</p><p>理发师悖论和罗素悖论的等价性很晦(bie4)/(nan2)涩(niu4)/(shou4)：“理发师 <equation>x</equation> 给自己理发”表示 <equation>x\in x</equation> ，这里的两个 <equation>x</equation> 含义不同，左边的 <equation>x</equation> 表示理发师 <equation>x</equation> ，右边的是 <equation>x</equation> 给理发的人的集合，于是理发师 <equation>S</equation>是否属于他给理发的人 <equation>S</equation> 。</p><blockquote>不过这种晦(bie4)(nan2)涩(niu4)(shou4)也很容易理解：<br>一般民众（包括我）很难理解一个个体组成的集合“ <equation>x</equation> ”居然是自身的一个成员，就像“某某大学其实是自己的一个系”一样难以接受。<br>而另一方面，真正能理解“ <equation>x\in x</equation> ”写法的人又何必去看理发师悖论？罗素悖论的表述已经足够清晰简单了。<br>因此在向民众传播时，理发师悖论是个（虽然无可奈何但是）非常好的选择。</blockquote><hr><p><br></p><p>（<b>简单地</b>说，）在Zermelo-Fraenkel公理化集合论中有如下公理及公理模式：</p><p><b>分离公理模式（Axiom schema of specification）：</b></p><p>若 <equation>z</equation> 是任一集合， <equation>\phi(x)</equation> 是与 <equation>x</equation> 有关的陈述句（事实上是一阶逻辑中的公式），那么可以定义集合 <equation>y=\{x\in z|\phi (x)为真\}</equation> ，是 <equation>z</equation> 的一个子集。</p><p>也就是说只能由已给的集合定义<b>子集</b>（称作restricted comprehension），而不允许直接如 <equation>\{x|\phi (x)\}</equation> 形式定义集合（称作unrestricted comprehension）。</p><p>于是回避（而不是解决）了罗素悖论，也即认为 <equation>S=\{x|x ∉S\}</equation> 所定义的不是“集合”。</p><hr><p>下面谈“ <equation>S\in S</equation> ”：<b>配对公理（Axiom of pairing）：</b>若 <equation>x,y</equation> 都是集合，则存在集合 <equation>z</equation> ，使得 <equation>x\in z 且 y\in z</equation> 。</p><p>结合分离公理模式，可以定义 <equation>z_1=\{w\in z| w=x或者w=y\}</equation> ，它的成员完全是 <equation>x,y</equation> 。</p><p><b>正则公理/基础公理（Axiom of regularity or Axiom of foundation）：</b>若 <equation>x</equation> 是任一非空集合，则存在 <equation>x</equation> 的某元素 <equation>y</equation> 使得 <equation>y\cap x=\emptyset</equation> 。</p><p>用一阶逻辑的语言就是： <equation>\forall x[\exists a(a\in x)\Rightarrow \exists y(y\in x\land \lnot \exists z(z\in y\land z\in x))]</equation> 。</p><p>正则公理就保证了在Zermelo-Fraenkel公理化集合论的世界里<b>不允许出现“ <equation>S\in S</equation> ”</b>：</p><p><b><i>证明：</i></b>如果存在某个集合 <equation>S</equation> 使得 <equation>S\in S</equation> ，则由配对公理及分离公理模式可以构造集合 <equation>T=\{S\}</equation> 。</p><p>根据正则公理，有： <equation>T</equation> 的唯一元素 <equation>S</equation> 满足 <equation>S\cap T=\emptyset</equation> ，即 <equation>S\cap \{S\}=\emptyset</equation> 。而这就与 <equation>S\in S且S\in\{S\}</equation> 产生了矛盾。</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
