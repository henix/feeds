<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>MLsub大概是个什么鬼.一</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/69565293">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-4b66c35b47a7a554e4fc8f7ff2da185b_b.jpg" alt=""></div><p>我们知道(PS:不知道的可以不看了) <b>Hindley-Milner</b> 类型系统是一个非常流行(PS:荼毒万年,又让人无可奈何)的类型系统,<b>ML</b>又是一个很基本的一种函数式编程语言(家族).</p><p><b>ML</b>使用了<b>Hindley-Milner</b>类型系统,但是,现在来讲<b>HM</b>类型系统已经过时了,因为<b>OOP</b>(面向对象编程)的范式越来越多的被人们熟知,而<b>HM</b>并不支持<b>OOP</b>赖以生存的<b>Subtyping</b>,这就是为什么我们要把<b>subtyping</b>加入到<b>HM</b>里了,当然这并不是一个非常简单的过程,既然是学术文章,那么我们就不能摆出来<b>Java</b>之类的残废语言讨论,真正的<b>subtyping</b>还应该(道德绑架)支持</p><ul><li><br/><b>Extensible records</b>来自<b>ELM</b>语言的例子</li></ul><div class="highlight"><pre><code class="language-elm"><span class="kr">type</span> <span class="kr">alias</span> <span class="kt">Positioned</span> <span class="nv">a</span> <span class="nf">=</span>
  <span class="p">{</span> <span class="nv">a</span> <span class="nf">|</span> <span class="nv">x</span> <span class="nf">:</span> <span class="kt">Float</span><span class="p">,</span> <span class="nv">y</span> <span class="nf">:</span> <span class="kt">Float</span> <span class="p">}</span></code></pre></div><ul><li><b>polymorphic variants</b>这是一个<b>ReasonML</b>里的一个例子</li></ul><div class="highlight"><pre><code class="language-ocaml"><span class="k">type</span> <span class="n">rgbnormal</span> <span class="o">=</span> <span class="nc">Redn</span> <span class="o">|</span> <span class="nc">Greenn</span> <span class="o">|</span> <span class="nc">Bluen</span><span class="o">;</span>

<span class="k">type</span> <span class="n">rgbvariants</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Redv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Greenv</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bluev</span><span class="o">];</span></code></pre></div><p>为了支持<b>subtyping</b>我们需要很好的考虑类型和数据流的关系,数据流的方向,一个信息源必须提供一个目的地.</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">select</span> <span class="nf">p</span> <span class="nf">v</span> <span class="nf">d</span> <span class="ow">=</span> <span class="kr">if</span> <span class="p">(</span><span class="nf">p</span> <span class="nf">v</span><span class="p">)</span> <span class="kr">then</span> <span class="nf">v</span> <span class="kr">else</span> <span class="nf">d</span></code></pre></div><p><b>ML</b>里的类型信息</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha+.%28%5Calpha+%5Crightarrow+bool%29%5Crightarrow+%5Calpha++%5Crightarrow+%5Calpha++%5Crightarrow+%5Calpha" alt="\forall \alpha .(\alpha \rightarrow bool)\rightarrow \alpha  \rightarrow \alpha  \rightarrow \alpha" eeimg="1"/> </p><p>不用想都知道,这肯定不对,有人建议我们写对的</p><p><img src="https://www.zhihu.com/equation?tex=%28%5Calpha+%5Crightarrow+bool%29%5Crightarrow+%5Calpha+%5Crightarrow+%5Cbeta+%5Crightarrow+%5Cgamma+%7C%5Calpha+%5Cleq+%5Cgamma+%2C+%5Cbeta+%5Cleq+%5Cgamma" alt="(\alpha \rightarrow bool)\rightarrow \alpha \rightarrow \beta \rightarrow \gamma |\alpha \leq \gamma , \beta \leq \gamma" eeimg="1"/> </p><p>对是对了,然后那群科学家发现者玩意儿怎么TM用,太难了! 于是有一个人 <b>Pottier</b> 觉得我们可以化简一波</p><p>于是就有了<b>MLsubj</b>的s小本本里建议的这种写法</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha+%2C+%5Cbeta+.%28%5Calpha+%5Crightarrow+bool%29+%5Crightarrow+%5Calpha+%5Crightarrow+%5Cbeta+%5Crightarrow+%28%5Calpha+%5Csqcup+%5Cbeta%29" alt="\forall \alpha , \beta .(\alpha \rightarrow bool) \rightarrow \alpha \rightarrow \beta \rightarrow (\alpha \sqcup \beta)" eeimg="1"/> </p><p>乍一看是对的,这个<b>select</b>函数的定义就跟符合直觉了</p><p>所以本质上<b>MLsub</b>的主要贡献大概有四点</p><ul><li><b>MLsub类型系统</b></li><ul><li>我们扩充了<b>ML</b>的类型系统,添加了<b>subtyping</b>的特性,然后我们采用了一些输入输出上的规则,简化了类型推断</li></ul><li><b>类型推断</b></li><ul><li>我们引入了一种处理<b>subtype</b>的<b>unification</b>算法 <b>(biunification)</b></li></ul><li><b>类型化简</b></li><ul><li><b>MLsub</b>里面会产生很多的类型实质上一样但是表述上有区别的类型,就比如 <img src="https://www.zhihu.com/equation?tex=bool+%5Csqcup+bool+%5Csqcup+%5Cbot" alt="bool \sqcup bool \sqcup \bot" eeimg="1"/> 实际上和<i>bool</i>是一个类型的,我们将会使用一个自动机来化简类型</li></ul><li><b>引入了更多BUG</b></li></ul><hr/><p>说了这么多没用的简介,那我们可以理一理实现了,从代数层面上</p><p>一个标准的类型,函数类型,顶类型,底类型定义为</p><p><img src="https://www.zhihu.com/equation?tex=%5Ctau+%3A%3A%3D+%5Cbot+%7C+%5Ctau+%5Crightarrow+%5Ctau+%7C+%5Ctop" alt="\tau ::= \bot | \tau \rightarrow \tau | \top" eeimg="1"/> </p><p>对于任意类型 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1%2C%5Ctau_2" alt="\tau_1,\tau_2" eeimg="1"/> ,有他们的上限是 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1+%5Csqcup+%5Ctau_2" alt="\tau_1 \sqcup \tau_2" eeimg="1"/> ,他们最大的下限是 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1+%5Csqcap+%5Ctau_2" alt="\tau_1 \sqcap \tau_2" eeimg="1"/> </p><p>然后,我们发现好像不太对</p><p><img src="https://www.zhihu.com/equation?tex=%28E%29%3A%5Cquad%28%5Cbot+%5Crightarrow+%5Ctop%29%5Crightarrow+%5Cbot+%5Cleq+%28%5Calpha+%5Crightarrow+%5Cbot%29+%5Csqcup+%5Calpha" alt="(E):\quad(\bot \rightarrow \top)\rightarrow \bot \leq (\alpha \rightarrow \bot) \sqcup \alpha" eeimg="1"/> </p><p><b>MLsub</b>就是为了避免这个的发生,使用了更加复杂的语法和直接添加的类型而不是使用一个<b>Ground Type</b>慢慢往上搭屎山.</p><p>其次呢,他们使用了一种词法叫<b>分配格</b>,确保了构建类型的时候仅少量的出现相同的<b>subtype</b>. 但是问题又来了,加入我们有一个类型 <img src="https://www.zhihu.com/equation?tex=%5Ctau_f" alt="\tau_f" eeimg="1"/>用来描述函数和一个类型 <img src="https://www.zhihu.com/equation?tex=%5Ctau_r" alt="\tau_r" eeimg="1"/>用来描述一个记录(record),那么下面公式成立<img src="https://www.zhihu.com/equation?tex=%5Ctau_f%5Csqcap%5Ctau_r+%3D+%5Cbot+" alt="\tau_f\sqcap\tau_r = \bot " eeimg="1"/>虽然第一眼看起来没有任何问题</p><p>给没看出问题的你一点时间......</p><p>我们可以推导出 <img src="https://www.zhihu.com/equation?tex=%5Ctau_f%5Csqcap%5Ctau_r+%5Cleq+bool" alt="\tau_f\sqcap\tau_r \leq bool" eeimg="1"/> 蛤?! 这是什么?! 为什么?!     因为 <img src="https://www.zhihu.com/equation?tex=%5Ctau_f%5Csqcap%5Ctau_r+%3D+%5Cbot" alt="\tau_f\sqcap\tau_r = \bot" eeimg="1"/>这个公式成立啊! </p><p>这个非常的反直觉,但是,毕竟定义上合情合理 &lt;del&gt;所以这个编译器就必须能处理这个东西(一个函数和记录作为布尔值)......&lt;/del&gt;</p><p>下面是<b>MLsub</b>的类型推导</p><p><img src="https://www.zhihu.com/equation?tex=%28VAR-%5Clambda%29%5Cquad%5Cfrac%7B%7D%7B%5CGamma%5Cvdash+x%3A%5Ctau%7D%5CGamma%28x%29%3D%5Ctau%5C%5C+%5C%5C+%28VAR-%5Cforall%29%5Cquad%5Cfrac%7B%7D%7B%5CGamma+%5Cvdash+%5Chat+x+%3A+%5Ctau%5B%5Cvec+%5Ctau+%2F+%5Cvec+%5Calpha%5D%7D+%5CGamma%28%5Chat+x%29+%3D+%5Cforall+%5Cvec+%5Calpha+.+%5Ctau%5C%5C+%28ABS%29%5Cquad+%5Cfrac%7B%5CGamma%2Cx%3A%5Ctau_1+%5Cvdash+e+%3A%5Ctau_2%7D%7B%5CGamma+%5Cvdash+%5Clambda+x.e+%3A+%5Ctau_1+%5Crightarrow+%5Ctau_2%7D%5C%5C+%28APP%29+%5Cquad+%5Cfrac%7B%5CGamma+%5Cvdash+e_1+%3A+%5Ctau_1+%5Crightarrow+%5Ctau_2+%5Cquad+%5CGamma+%5Cvdash+e_2+%3A+%5Ctau_1%7D%7B%5CGamma+%5Cvdash+e_1+e_2+%3A+%5Ctau_2%7D%5C%5C+%28LET%29+%5Cfrac%7B%5CGamma+%5Cvdash+e_1%3A%5Ctau_1+%5Cquad+%5CGamma%2Cx%3A%5Cforall+%5Cvec+a+.%5Ctau_1+%5Cvdash+e_2+%3A+%5Ctau_2%7D%7B%5CGamma+%5Cvdash+let+%5C++%5Chat%7Bx%7D+%3D+e_1%5C++in%5C++e_2+%3A+%5Ctau_2%7D%5C%5C+%28PROJ%29+%5Cquad+%5Cfrac%7B%5CGamma%5Cvdash+e%3A+%5C%7B+l+%3A+%5Ctau%2C...%5C%7D%7D%7B%5CGamma+%5Cvdash+e.l+%3A+%5Ctau%7D%5C%5C+%28SUB%29+%5Cquad+%5Cfrac%7B%5CGamma+%5Cvdash+e%3A%5Ctau%7D%7B%5CGamma+%5Cvdash+e%3A%5Ctau%27%7D+%5Ctau+%5Cleq+%5Ctau%27%5C%5C" alt="(VAR-\lambda)\quad\frac{}{\Gamma\vdash x:\tau}\Gamma(x)=\tau\\ \\ (VAR-\forall)\quad\frac{}{\Gamma \vdash \hat x : \tau[\vec \tau / \vec \alpha]} \Gamma(\hat x) = \forall \vec \alpha . \tau\\ (ABS)\quad \frac{\Gamma,x:\tau_1 \vdash e :\tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2}\\ (APP) \quad \frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2}\\ (LET) \frac{\Gamma \vdash e_1:\tau_1 \quad \Gamma,x:\forall \vec a .\tau_1 \vdash e_2 : \tau_2}{\Gamma \vdash let \  \hat{x} = e_1\  in\  e_2 : \tau_2}\\ (PROJ) \quad \frac{\Gamma\vdash e: \{ l : \tau,...\}}{\Gamma \vdash e.l : \tau}\\ (SUB) \quad \frac{\Gamma \vdash e:\tau}{\Gamma \vdash e:\tau&#39;} \tau \leq \tau&#39;\\" eeimg="1"/></p><p>最后我们可以得出,如果 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1+%5Csqcap%5Ctau_2+%5Cleq+%5Ctau_3" alt="\tau_1 \sqcap\tau_2 \leq \tau_3" eeimg="1"/> 那么 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1%27+%5Csqcap%5Ctau_2%27+%3D+%5Ctau_3" alt="\tau_1&#39; \sqcap\tau_2&#39; = \tau_3" eeimg="1"/>所以 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1%27%5Cleq%5Ctau_3%2C%5Ctau_2%27%5Cleq%5Ctau_3" alt="\tau_1&#39;\leq\tau_3,\tau_2&#39;\leq\tau_3" eeimg="1"/> </p><p>很好,锅居多,作者表态,嗯,下章我们要用更加科学的方法去修补.</p><p class="ztext-empty-paragraph"><br/></p><hr/><p>第一次写关于这个的文章,其实这是我这个垃圾的笔记,完全是按照自己易懂的方法写的,看不懂属于正常现象,大佬要是发现了我的理解错误随时评论区指正</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
