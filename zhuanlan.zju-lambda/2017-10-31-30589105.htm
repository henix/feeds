<div class="title-image"><img src="https://pic2.zhimg.com/v2-e0f19ec073781989a02c6f364831f0c8_b.jpg" alt=""></div><h2><b>这篇文章讲了什么</b></h2><p>我将会在这篇文章中提到一点 Finger Tree 的设计思想、Finger Tree 的实现细节、 Finger Tree 的应用等内容。</p><h2><b>我需要看这篇文章吗</b></h2><p>你需要对数据结构有着简单的了解，并且对 Finger Tree 有一定兴趣但没有深入了解。</p><p>你可能需要学会基础的 Haskell 语法</p><h2><b>为什么是 Finger Tree</b></h2><p>它提供了高效的各种序列操作：</p><p><br></p><figure><noscript><img src="https://pic2.zhimg.com/v2-ac2cb9cc296d8cfa67580d33d49af82d_b.jpg" data-caption="" data-rawwidth="1125" data-rawheight="519" class="origin_image zh-lightbox-thumb" width="1125" data-original="https://pic2.zhimg.com/v2-ac2cb9cc296d8cfa67580d33d49af82d_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-ac2cb9cc296d8cfa67580d33d49af82d_b.jpg" data-caption="" data-rawwidth="1125" data-rawheight="519" class="origin_image zh-lightbox-thumb lazy" width="1125" data-original="https://pic2.zhimg.com/v2-ac2cb9cc296d8cfa67580d33d49af82d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-ac2cb9cc296d8cfa67580d33d49af82d_b.jpg"></figure><p><br></p><p>它在很多方面几乎达到了理论上的极限，这也是我们为什么在很多地方要使用 Finger Tree 来作为储存序列的东西。</p><h2>Finger Tree 是什么</h2><p>我们首先从简单的二叉树开始谈起</p><p>我们在 Haskell 中如何表示一颗二叉树？</p><p>这很简单，像这样就可以了</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> 
      <span class="ow">=</span> <span class="kt">Nil</span>
      <span class="o">|</span> <span class="kt">Tree</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>当然我们也可以这样写（我们把它叫做 leafy 的二叉树）</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span>
      <span class="ow">=</span> <span class="kt">Leaf</span> <span class="n">a</span>
      <span class="o">|</span> <span class="kt">Tree</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>我们可以发现第二种树是无法表达“空树”这个概念的，而且我们每次访问树上的值都需要到达叶子结点才能取到值。</p><p>那么如何表示一棵满的 leafy 的二叉树呢？我们可以借鉴自然数的定义。</p><p>自然数我们一般会写成这样</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Nat</span> <span class="ow">=</span> <span class="kt">Z</span> <span class="o">|</span> <span class="kt">S</span> <span class="kt">Nat</span>
</code></pre></div><p>借助它我们可以表达类型的嵌套层数</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Nat</span> <span class="n">s</span> <span class="n">a</span> 
      <span class="ow">=</span> <span class="kt">Z</span> <span class="n">a</span>
      <span class="o">|</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">Nat</span> <span class="n">s</span> <span class="p">(</span><span class="n">s</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div><p>于是我们只需要定义 leafy 二叉树的结点类型</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Node</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="n">a</span>
</code></pre></div><p>就有</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">type</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nat</span> <span class="kt">Node</span> <span class="n">a</span>
</code></pre></div><p><code>Nat</code> 每推进一层，<code>Node</code> 就会多嵌套一层，而 <code>Node</code> 的定义保证了它一定是一棵满的 leafy 二叉树，比如</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kt">Z</span> <span class="mi">1</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="kt">Int</span>
  <span class="kt">S</span> <span class="p">(</span><span class="kt">Z</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="kt">Int</span>
  <span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">Z</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))))</span>
</code></pre></div><p>而不满的二叉树会产生类型错误</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">Z</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))))</span> <span class="c1">-- error</span>
</code></pre></div><p>然后我们把二叉树结点换成 2-3 树的结点</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Node23</span> <span class="n">a</span> 
      <span class="ow">=</span> <span class="kt">Node2</span> <span class="n">a</span> <span class="n">a</span>
      <span class="o">|</span> <span class="kt">Node3</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span>
  <span class="kr">data</span> <span class="kt">Tree23</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nat</span> <span class="kt">Node23</span> <span class="n">a</span> 
</code></pre></div><p>这就得到了 Finger Tree 的前身，我们给一个例子 (这个例子是 Paper 上的)</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kt">S</span> 
      <span class="p">(</span><span class="kt">S</span> 
          <span class="p">(</span><span class="kt">S</span> 
              <span class="p">(</span><span class="kt">Z</span> 
                  <span class="p">(</span><span class="kt">Node2</span> 
                      <span class="p">(</span><span class="kt">Node3</span> 
                          <span class="p">(</span><span class="kt">Node2</span> <span class="n">t</span> <span class="n">h</span><span class="p">)</span> 
                          <span class="p">(</span><span class="kt">Node2</span> <span class="n">i</span> <span class="n">s</span><span class="p">)</span> 
                          <span class="p">(</span><span class="kt">Node2</span> <span class="n">i</span> <span class="n">s</span><span class="p">)</span>
                      <span class="p">)</span> 
                      <span class="p">(</span><span class="kt">Node3</span> 
                          <span class="p">(</span><span class="kt">Node3</span> <span class="n">n</span> <span class="n">o</span> <span class="n">t</span><span class="p">)</span> 
                          <span class="p">(</span><span class="kt">Node2</span> <span class="n">a</span> <span class="n">t</span><span class="p">)</span> 
                          <span class="p">(</span><span class="kt">Node3</span> <span class="n">r</span> <span class="n">e</span> <span class="n">e</span><span class="p">)</span>
                      <span class="p">)</span>
                  <span class="p">)</span>
              <span class="p">)</span>
          <span class="p">)</span>
      <span class="p">)</span>
</code></pre></div><p>画出来是这个样子</p><p><br></p><figure><noscript><img src="https://pic2.zhimg.com/v2-99efb528caa536e49c98e6de2a596995_b.jpg" data-caption="" data-rawwidth="1079" data-rawheight="229" class="origin_image zh-lightbox-thumb" width="1079" data-original="https://pic2.zhimg.com/v2-99efb528caa536e49c98e6de2a596995_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-99efb528caa536e49c98e6de2a596995_b.jpg" data-caption="" data-rawwidth="1079" data-rawheight="229" class="origin_image zh-lightbox-thumb lazy" width="1079" data-original="https://pic2.zhimg.com/v2-99efb528caa536e49c98e6de2a596995_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-99efb528caa536e49c98e6de2a596995_b.jpg"></figure><p><br></p><p>这棵树储存的序列是 "thisisnotatree"。</p><p>树形结构在访问时对效率很大的一个限制就是深度。大多数情况，平衡树都是单纯通过限制深度来保证访问时间能达到  ，在这里的这棵树中也是一样的。但我们想要更快的访问头尾结点，同时不牺牲随机访问其它结点的效率，于是我们想到的方法是缩短树的头尾结点到根结点的距离。</p><p>我们把树最左端和最右端的两条链提起来，变成下面这个样子</p><figure><noscript><img src="https://pic1.zhimg.com/v2-a0556d0b975040f0f43a410789924e28_b.jpg" data-caption="" data-rawwidth="698" data-rawheight="413" class="origin_image zh-lightbox-thumb" width="698" data-original="https://pic1.zhimg.com/v2-a0556d0b975040f0f43a410789924e28_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-a0556d0b975040f0f43a410789924e28_b.jpg" data-caption="" data-rawwidth="698" data-rawheight="413" class="origin_image zh-lightbox-thumb lazy" width="698" data-original="https://pic1.zhimg.com/v2-a0556d0b975040f0f43a410789924e28_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-a0556d0b975040f0f43a410789924e28_b.jpg"></figure><p><br></p><p>然后把这两条链粘在一起，就得到了一棵能  访问头尾结点的树了。</p><p>被提起来的那两条链，我们把它们叫做 Digit,  被粘起来之后合成的那些结点我们把它们叫做 Deep，于是我们下面给出 Finger Tree 的定义</p><h2><b>Finger Tree 的定义</b></h2><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">FingerTree</span> <span class="n">a</span> 
      <span class="o">|</span> <span class="kt">Empty</span>
      <span class="o">|</span> <span class="kt">Single</span> <span class="n">a</span>
      <span class="o">|</span> <span class="kt">Deep</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">))</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">a</span><span class="p">)</span>
  
  <span class="kr">type</span> <span class="kt">Digit</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Digit</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</code></pre></div><p>Digit 这里我们使用 List 来表示。</p><p>可以看出，Finger Tree 中的 a 是一个嵌套了 n 次的 <code>Node</code> ，所以 Finger Tree 每向下一层，结点的数量就会至少增加一倍，所以这棵树的深度显然是 <img src="https://www.zhihu.com/equation?tex=O%28%5Clog+n%29" alt="O(\log n)" eeimg="1"> 的。</p><p>下面是 <a href="http://link.zhihu.com/?target=http%3A//www.staff.city.ac.uk/%7Eross/papers/FingerTree.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a> 给出的一些例子，其中红色是 <code>Deep</code> ，绿色是 <code>Node</code> ，蓝色是数据</p><figure><noscript><img src="https://pic4.zhimg.com/v2-42ed25ba850e8c60efb828d9ea5986d7_b.jpg" data-rawwidth="109" data-rawheight="142" class="content_image" width="109"></noscript><img src="https://pic4.zhimg.com/v2-42ed25ba850e8c60efb828d9ea5986d7_b.jpg" data-rawwidth="109" data-rawheight="142" class="content_image lazy" width="109" data-actualsrc="https://pic4.zhimg.com/v2-42ed25ba850e8c60efb828d9ea5986d7_b.jpg"><figcaption>Deep (Digit [a]) (Single (Node3 b c d)) (Digit [e])</figcaption></figure><figure><noscript><img src="https://pic2.zhimg.com/v2-9bb9f1f5b49d1191703085fe62c43e6d_b.jpg" data-caption="" data-rawwidth="209" data-rawheight="198" class="content_image" width="209"></noscript><img src="https://pic2.zhimg.com/v2-9bb9f1f5b49d1191703085fe62c43e6d_b.jpg" data-caption="" data-rawwidth="209" data-rawheight="198" class="content_image lazy" width="209" data-actualsrc="https://pic2.zhimg.com/v2-9bb9f1f5b49d1191703085fe62c43e6d_b.jpg"></figure><figure><noscript><img src="https://pic2.zhimg.com/v2-e6e32fa7cd4b135f2593d7733b479421_b.jpg" data-caption="" data-rawwidth="787" data-rawheight="271" class="origin_image zh-lightbox-thumb" width="787" data-original="https://pic2.zhimg.com/v2-e6e32fa7cd4b135f2593d7733b479421_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-e6e32fa7cd4b135f2593d7733b479421_b.jpg" data-caption="" data-rawwidth="787" data-rawheight="271" class="origin_image zh-lightbox-thumb lazy" width="787" data-original="https://pic2.zhimg.com/v2-e6e32fa7cd4b135f2593d7733b479421_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-e6e32fa7cd4b135f2593d7733b479421_b.jpg"></figure><p><br></p><p><br></p><p>为了保证 Finger Tree 的操作效率，我们限制了 <code>Digit</code> 的大小在 1 到 4 之间。</p><p>下面我们就可以开始实现 Finger Tree 的各种操作了。</p><h2>Finger Tree 上的操作</h2><h2><b>头尾插入单个结点</b></h2><p>第一个是 push-front 和 push-back ，即从头/尾插入 </p><p>（迫真安利：使用 Fira-Code 可以达到更好的符号显示效果）</p><p>push-front 的实现: </p><p><br></p><figure><noscript><img src="https://pic4.zhimg.com/v2-bb889a069b57953b0b41025ed697e807_b.jpg" data-caption="" data-rawwidth="772" data-rawheight="267" class="origin_image zh-lightbox-thumb" width="772" data-original="https://pic4.zhimg.com/v2-bb889a069b57953b0b41025ed697e807_r.jpg"></noscript><img src="https://pic4.zhimg.com/v2-bb889a069b57953b0b41025ed697e807_b.jpg" data-caption="" data-rawwidth="772" data-rawheight="267" class="origin_image zh-lightbox-thumb lazy" width="772" data-original="https://pic4.zhimg.com/v2-bb889a069b57953b0b41025ed697e807_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-bb889a069b57953b0b41025ed697e807_b.jpg"></figure><p><br></p><p>在插入时我们优先插在 <code>Digit</code> 上，当 <code>Digit</code> 满了我们会把 <code>Digit</code> 分裂并向下一级插入一个新的 <code>Node</code> 结点。每向下一级需要的 <code>a</code> 的数量会翻  倍，所以插入这个过程是均摊 <img src="https://www.zhihu.com/equation?tex=%5CTheta%281%29" alt="\Theta(1)" eeimg="1">  的。</p><h2><b>头尾删除单个结点</b></h2><p>然后是删除头/尾结点。这个过程的效率和插入一样，也是 <img src="https://www.zhihu.com/equation?tex=%5CTheta%281%29" alt="\Theta(1)" eeimg="1"> 的。</p><p>我们(&lt;del&gt;Paper 上&lt;/del&gt;)实现了一个数据类型 <code>ViewL</code> （实际上是可以使用 <code>Maybe</code> 的）来储存提取的结果</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">ViewL</span> <span class="n">s</span> <span class="n">a</span> 
      <span class="ow">=</span> <span class="kt">Nil</span>
      <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="n">s</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>然后有</p><div class="highlight"><pre><code class="language-haskell"><span></span>  <span class="n">viewL</span> <span class="ow">::</span> <span class="kt">FingerTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ViewL</span> <span class="kt">FingerTree</span> <span class="n">a</span>
  <span class="n">viewL</span> <span class="kt">Empty</span> <span class="ow">=</span> <span class="kt">Nil</span>
  <span class="n">viewL</span> <span class="p">(</span><span class="kt">Single</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="kt">Empty</span>
  <span class="n">viewL</span> <span class="p">(</span><span class="kt">Deep</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">l</span><span class="p">)</span> <span class="n">m</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="p">(</span><span class="n">head</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">deepL</span> <span class="p">(</span><span class="n">tail</span> <span class="n">l</span><span class="p">)</span> <span class="n">m</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div><p>这里的 <code>deepL</code> 是处理左 <code>Digit</code> 不一定存在时的 Finger Tree 构造函数</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">deepL</span> <span class="ow">::</span> 
      <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> 
      <span class="kt">Digit</span> <span class="n">a</span> <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="n">a</span>
  <span class="n">deepL</span> <span class="kt">[]</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">viewL</span> <span class="n">m</span> <span class="kr">of</span> 
      <span class="kt">Nil</span> <span class="ow">-&gt;</span> <span class="n">toTree</span> <span class="n">r</span>
      <span class="kt">Cons</span> <span class="n">a</span> <span class="n">as</span> <span class="ow">-&gt;</span> <span class="kt">Deep</span> <span class="p">(</span><span class="n">nodeToDigit</span> <span class="n">a</span><span class="p">)</span> <span class="n">as</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">r</span><span class="p">)</span>
  <span class="n">deepL</span> <span class="n">l</span> <span class="n">m</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Deep</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">l</span><span class="p">)</span> <span class="n">m</span> <span class="n">r</span>
</code></pre></div><p>如果为空，就再从中间的子树中分离出一个结点（但在这里是 <code>Node a</code>），转化为 <code>Digit</code> 后再放在左边。(转化为 <code>Digit</code> 的过程是 trivial 的)</p><p>有了 <code>viewL</code> 我们就能得到诸如 <code>headL</code> , <code>tailL</code> 这样的函数。</p><p>到这里我们就已经拥有一个合格的 <code>Deque</code> 了，我们不妨封装一下</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">newtype</span> <span class="kt">Deque</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Deque</span> <span class="p">(</span><span class="kt">FingerTree</span> <span class="n">a</span><span class="p">)</span>
  
  <span class="n">pushFront</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Deque</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Deque</span> <span class="n">a</span>
  <span class="n">pushFront</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Deque</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Deque</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;|</span> <span class="n">xs</span><span class="p">)</span>
  
  <span class="n">pushBack</span> <span class="ow">::</span> <span class="kt">Deque</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Deque</span> <span class="n">a</span>
  <span class="n">pushBack</span> <span class="p">(</span><span class="kt">Deque</span> <span class="n">xs</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Deque</span> <span class="p">(</span><span class="n">xs</span> <span class="o">|&gt;</span> <span class="n">a</span><span class="p">)</span>
  
  <span class="n">popFront</span> <span class="ow">::</span> <span class="kt">Deque</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">View</span> <span class="kt">Deque</span> <span class="n">a</span>
  <span class="n">popFront</span> <span class="p">(</span><span class="kt">Deque</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">viewL</span> <span class="n">xs</span> <span class="kr">of</span>
      <span class="kt">Nil</span> <span class="ow">-&gt;</span> <span class="kt">Nil</span>
      <span class="kt">Cons</span> <span class="n">a</span> <span class="n">as</span> <span class="ow">-&gt;</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Deque</span> <span class="n">as</span><span class="p">)</span>
  
  <span class="n">popBack</span> <span class="ow">::</span> <span class="kt">Deque</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">View</span> <span class="kt">Deque</span> <span class="n">a</span>
  <span class="n">popBack</span> <span class="p">(</span><span class="kt">Deque</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">viewR</span> <span class="n">xs</span> <span class="kr">of</span>
      <span class="kt">Nil</span> <span class="ow">-&gt;</span> <span class="kt">Nil</span>
      <span class="kt">Cons</span> <span class="n">a</span> <span class="n">as</span> <span class="ow">-&gt;</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Deque</span> <span class="n">as</span><span class="p">)</span>
</code></pre></div><p>看上去还不错。</p><p>但还不够，我们需要让两个 Finger Tree 连起来。</p><h2><b>把两棵 Finger Tree 连起来</b></h2><p>考虑两个 Finger Tree ， <code>Deep l1 m1 r1</code>  和 <code>Deep l2 m2 r2</code> ，我们需要把它们拼起来。</p><p>自然的想法就是把 <code>l1</code> 和 <code>r2</code> 拿出来，把中间的部分再组装一次成为一棵新树。</p><p>那么我们需要这样一个函数：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">appendDigits</span> <span class="ow">::</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span>
      <span class="kt">Digit</span> <span class="n">a</span> <span class="ow">-&gt;</span>
      <span class="kt">Digit</span> <span class="n">a</span> <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span>
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>但事实上我们可以把 <code>Digit</code> 都塞到一起（因为它们本质上还是 <code>[a]</code>），来组成一些 <code>Node a</code>  ( <code>Node a</code> 是中间那棵 Finger Tree 的数据类型)，这样我们只需要实现这样两个函数：(conc for concat)</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">conc</span> <span class="ow">::</span> <span class="kt">FingerTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">FingerTree</span> <span class="n">a</span>
  <span class="n">nodes</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Node</span> <span class="n">a</span><span class="p">]</span>
</code></pre></div><p>第二个函数的实现也没什么，每隔 2 / 3 个元素切一刀就好了。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">nodes</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Node2</span> <span class="n">a</span> <span class="n">b</span><span class="p">]</span>
  <span class="n">nodes</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Node3</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">]</span>
  <span class="n">nodes</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Node2</span> <span class="n">a</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Node2</span> <span class="n">c</span> <span class="n">d</span><span class="p">]</span>
  <span class="n">nodes</span> <span class="p">(</span><span class="n">a</span><span class="kt">:</span> <span class="n">b</span><span class="kt">:</span> <span class="n">c</span><span class="kt">:</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Node3</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="kt">:</span> <span class="n">nodes</span> <span class="n">xs</span>
  <span class="n">nodes</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"What the fuck??"</span>
</code></pre></div><p>第一个函数则有一些细节需要考虑。</p><p>当其中一颗树是空树或者 <code>Single</code> 时，我们可以直接把 <code>List</code> 中的元素一个一个塞进去（这个函数的调用者传进来的 <code>List</code> 大小是常数，所以不会影响时间复杂度）。</p><p>当两颗树都是 <code>Deep</code> 时，情形和直接连接两颗树差不多，只需要把 <code>l2</code> ，<code>r2</code> 和加进来的 <code>list</code> 一起转成 <code>list</code> 就行了。</p><p>所以 <code>conc</code> 的实现也就很自然了</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">conc</span> <span class="kt">Empty</span> <span class="n">as</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">listConTree</span> <span class="n">as</span> <span class="n">xs</span>
  <span class="n">conc</span> <span class="n">xs</span> <span class="n">as</span> <span class="kt">Empty</span> <span class="ow">=</span> <span class="n">treeConList</span> <span class="n">xs</span> <span class="n">as</span>
  <span class="n">conc</span> <span class="p">(</span><span class="kt">Single</span> <span class="n">x</span><span class="p">)</span> <span class="n">as</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&lt;|</span> <span class="n">listConTree</span> <span class="n">as</span> <span class="n">xs</span>
  <span class="n">conc</span> <span class="n">xs</span> <span class="n">as</span> <span class="p">(</span><span class="kt">Single</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">treeConList</span> <span class="n">xs</span> <span class="n">as</span> <span class="o">|&gt;</span> <span class="n">x</span>
  <span class="n">conc</span> <span class="p">(</span><span class="kt">Deep</span> <span class="n">l1</span> <span class="n">m1</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">r1</span><span class="p">))</span> <span class="n">as</span> <span class="p">(</span><span class="kt">Deep</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">l2</span><span class="p">)</span> <span class="n">m2</span> <span class="n">r2</span><span class="p">)</span> <span class="ow">=</span> 
      <span class="kt">Deep</span> <span class="n">l1</span> <span class="p">(</span><span class="n">conc</span> <span class="n">m1</span> <span class="p">(</span><span class="n">nodes</span> <span class="p">(</span><span class="n">r1</span> <span class="o">++</span> <span class="n">as</span> <span class="o">++</span> <span class="n">l2</span><span class="p">))</span> <span class="n">m2</span><span class="p">)</span> <span class="n">r2</span>
</code></pre></div><p>listConTree和treeConList是两个辅助函数，暴力地把list中的东西一个一个塞到树里</p><p>于是我们可以有：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">infixl</span> <span class="mi">5</span> <span class="o">&gt;&lt;</span>
  <span class="p">(</span><span class="o">&gt;&lt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">FingerTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">FingerTree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">FingerTree</span> <span class="n">a</span>
  <span class="n">a</span> <span class="o">&gt;&lt;</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">conc</span> <span class="n">a</span> <span class="kt">[]</span> <span class="n">b</span>
</code></pre></div><p>显然的，每一次我们调用 <code>conc</code> 时的 <code>list</code> 的长度不会大于 ，所以每次调用是均摊  的 ，而每一次会使两颗树同时向下一层，在其中一颗树触底时递归结束，所以递归层数不会超过  。</p><p>好的，我们的树现在可以实现 <code>concat</code> 了，めでたしめでたし。</p><h2>实现其它操作的基础</h2><p>但上面的数据结构也仅仅只能做到这一步了，如果想要实现其它的功能，我们需要为它加上一些东西。</p><p>我们重写 Finger Tree 的各组成部分并添加标注 <code>v</code>：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Node</span> <span class="n">v</span> <span class="n">a</span>
      <span class="ow">=</span> <span class="kt">Node2</span> <span class="n">v</span> <span class="n">a</span> <span class="n">a</span>
      <span class="o">|</span> <span class="kt">Node3</span> <span class="n">v</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span>
  
  <span class="kr">data</span> <span class="kt">FingerTree</span> <span class="n">v</span> <span class="n">a</span>
      <span class="ow">=</span> <span class="kt">Empty</span>
      <span class="o">|</span> <span class="kt">Single</span> <span class="n">a</span>
      <span class="o">|</span> <span class="kt">Deep</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">FingerTree</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">v</span> <span class="n">a</span><span class="p">))</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>这里的 <code>v</code> 是 Finger Tree 需要维护的<i>某种</i>东西，而我们将会限制它的类型为 <code>Monoid</code> 。</p><h2><b>为什么是 <code>Monoid</code> ？</b></h2><p>Finger Tree 事实上维护的是一个序列，而这里的 <code>v</code> 是序列的某种性质，那么它应该对<i>空序列</i>有对应的值，而且能正确的处理 Finger Tree 中频繁的序列合并的情况。所以我们需要一个有幺元和有结合律的东西。</p><p>为了用到我们添加的 <code>v</code> ，我们可以引入一个 type class :</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">class</span> <span class="kt">Monoid</span> <span class="n">v</span> <span class="ow">=&gt;</span> <span class="kt">Measured</span> <span class="n">a</span> <span class="n">v</span> <span class="kr">where</span>
      <span class="n">measure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">v</span>
</code></pre></div><p>直接写是会报错的，需要打开 GHC 扩展</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="cm">{-# LANGUAGE MultiParamTypeClasses #-}</span>
</code></pre></div><p>我们利用 <code>Measure</code> 来<i>计算</i>出我们需要的值</p><p>Finger Tree 的各部分都可以实现为 <code>Measured</code> 的一个实例</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">instance</span> <span class="kt">Measured</span> <span class="n">a</span> <span class="n">v</span> <span class="ow">=&gt;</span> <span class="kt">Measured</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">v</span> <span class="n">a</span><span class="p">)</span> <span class="n">v</span> <span class="kr">where</span>
      <span class="n">measure</span> <span class="p">(</span><span class="kt">Node2</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span>
      <span class="n">measure</span> <span class="p">(</span><span class="kt">Node3</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span>
  
  <span class="kr">instance</span> <span class="kt">Measured</span> <span class="n">a</span> <span class="n">v</span> <span class="ow">=&gt;</span> <span class="kt">Measured</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">v</span> <span class="n">a</span><span class="p">)</span> <span class="n">v</span> <span class="kr">where</span>
      <span class="n">measure</span> <span class="p">(</span><span class="kt">Node2</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span>
      <span class="n">measure</span> <span class="p">(</span><span class="kt">Node3</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span>
      
  <span class="kr">instance</span> <span class="kt">Measured</span> <span class="n">a</span> <span class="n">v</span> <span class="ow">=&gt;</span> <span class="kt">Measured</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">a</span><span class="p">)</span> <span class="n">v</span> <span class="kr">where</span>
      <span class="n">measure</span> <span class="p">(</span><span class="kt">Digit</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="ow">=</span> <span class="n">measure</span> <span class="n">a</span>
      <span class="n">measure</span> <span class="p">(</span><span class="kt">Digit</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="n">as</span><span class="p">))</span> <span class="ow">=</span> 
          <span class="n">measure</span> <span class="n">a</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">measure</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">as</span><span class="p">)</span>
      
  <span class="kr">instance</span> <span class="kt">Measured</span> <span class="n">a</span> <span class="n">v</span> <span class="ow">=&gt;</span> <span class="kt">Measured</span> <span class="p">(</span><span class="kt">FingerTree</span> <span class="n">v</span> <span class="n">a</span><span class="p">)</span> <span class="n">v</span> <span class="kr">where</span>
      <span class="n">measure</span> <span class="kt">Empty</span> <span class="ow">=</span> <span class="n">mempty</span>
      <span class="n">measure</span> <span class="p">(</span><span class="kt">Single</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">measure</span> <span class="n">a</span>
      <span class="n">measure</span> <span class="p">(</span><span class="kt">Deep</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">v</span>
</code></pre></div><p>为了简化 <code>mappend</code> 的使用，我们把 Semi Group 中的 <code>&lt;&gt;</code> 借过来用一下</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">infixl</span> <span class="mi">5</span> <span class="o">&lt;&gt;</span>
  <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">mappend</span>
</code></pre></div><p>然后我们就可以愉快的重写之前的代码了 XD</p><p>首先是 <code>Node</code> 的新构造函数需要把 <code>v</code> 一并计算(只写 node2)：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">node2</span> <span class="ow">::</span> <span class="kt">Measured</span> <span class="n">a</span> <span class="n">v</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Node</span> <span class="n">v</span> <span class="n">a</span>
  <span class="n">node2</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Node2</span> <span class="p">(</span><span class="n">measure</span> <span class="n">a</span> <span class="o">&lt;&gt;</span> <span class="n">measure</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div><p><code>Deep</code> 也一样</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">deep</span> <span class="ow">::</span> 
      <span class="kt">Measured</span> <span class="n">a</span> <span class="n">v</span> <span class="ow">=&gt;</span> 
      <span class="kt">Digit</span> <span class="n">a</span> <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">v</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> 
      <span class="kt">Digit</span> <span class="n">a</span> <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="n">v</span> <span class="n">a</span>
  <span class="n">deep</span> <span class="n">l</span> <span class="n">m</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Deep</span> <span class="p">(</span><span class="n">measure</span> <span class="n">l</span> <span class="o">&lt;&gt;</span> <span class="n">measure</span> <span class="n">m</span> <span class="o">&lt;&gt;</span> <span class="n">measure</span> <span class="n">r</span><span class="p">)</span> <span class="n">l</span> <span class="n">m</span> <span class="n">r</span>
</code></pre></div><p>其它的部分也没有很多变化，照着写即可。</p><h2><b>把树分裂成两棵</b></h2><p>有了 <code>Measured</code> 我们就能够实现 <code>split</code> 了。为了合理的表示 <code>split</code> 的结果，我们定义这么一个数据结构</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Split</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Split</span> <span class="p">(</span><span class="n">s</span> <span class="n">a</span><span class="p">)</span> <span class="n">a</span> <span class="p">(</span><span class="n">s</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p><code>Split</code> 的三个数据域分别存放 <code>split</code> 目标的左侧部分、目标、右侧部分。</p><p>当然这里用 Tuple 也是可以的</p><p>假设给出一个函数 <code>f :: v -&gt; Bool</code> ，对 Finger Tree 所维护的序列使用时结果是单调的，即在越过某个结点之前结果都是 <code>False</code>  ，我们就能将 Finger Tree 在这个结点分成 3 份。</p><p>我们要实现这么一个函数：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">splitTree</span> <span class="ow">::</span> 
      <span class="kt">Measured</span> <span class="n">a</span> <span class="n">v</span> <span class="ow">=&gt;</span>
      <span class="p">(</span><span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span>
      <span class="n">v</span> <span class="ow">-&gt;</span>
      <span class="kt">FingerTree</span> <span class="n">v</span> <span class="n">a</span> <span class="ow">-&gt;</span>
      <span class="kt">Split</span> <span class="p">(</span><span class="kt">FingerTree</span> <span class="n">v</span> <span class="n">a</span><span class="p">)</span> <span class="n">a</span>
</code></pre></div><p>显然的，我们不应该在一棵空树上 <code>split</code> ，所以</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">splitTree</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">Empty</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"You should not split on an empty tree"</span>
</code></pre></div><p><code>Single</code> 的话很简单，问题就在于 <code>Deep</code> 该如何处理，方法和线段树一样。</p><p>分  种情况，分界点在左 <code>Digit</code> 上、分界点在子树上、分界点在右 <code>Digit</code> 上。 ,  实际上是一种，我们放在一起考虑。</p><p>如果分界点在 <code>Digit</code> 上，我们可以单独使用一个函数来处理这种情形</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">splitDigit</span> <span class="ow">::</span> <span class="kt">Measure</span> <span class="n">a</span> <span class="n">v</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">Digit</span> <span class="ow">-&gt;</span> <span class="kt">Split</span> <span class="kt">[]</span> <span class="n">a</span>
</code></pre></div><p>因为 <code>Digit</code> 实际上就是个 <code>list</code> ，所以只需要沿着每个结点判断一次就可以了</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">splitDigit</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Digit</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="ow">=</span> <span class="kt">Split</span> <span class="kt">[]</span> <span class="n">a</span> <span class="kt">[]</span>
  <span class="n">splitDigit</span> <span class="n">f</span> <span class="n">i</span> <span class="p">(</span><span class="kt">Digit</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="n">as</span><span class="p">))</span>
      <span class="o">|</span> <span class="n">f</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&gt;</span> <span class="n">measure</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Split</span> <span class="kt">[]</span> <span class="n">a</span> <span class="n">as</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> 
          <span class="kr">let</span> <span class="kt">Split</span> <span class="n">l</span> <span class="n">x</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">splitDigit</span> <span class="n">f</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&gt;</span> <span class="n">measure</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Digit</span> <span class="n">as</span><span class="p">)</span> 
          <span class="kr">in</span>
              <span class="kt">Split</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="n">l</span><span class="p">)</span> <span class="n">x</span> <span class="n">r</span>
  <span class="n">splitDigit</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"What the fuck ??"</span>
</code></pre></div><p>而如果分界点在树上，我们就可以递归调用这个过程，对子树直接使用 <code>splitTree</code> ，会拿到一个 <code>Node a</code> 回来，再把它转成 <code>Digit</code> 并再使用一次 <code>splitDigit</code> 就能拿到那个元素了。</p><p>再者就是 <code>splitDigit</code> 拿回来的可能是一个空 <code>list</code> ，所以这里要使用前面提到的 <code>deepL</code> 和 <code>deepR</code> 来构造新的 Finger Tree</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">splitTree</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">Empty</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"Split on an empty tree!"</span>
  <span class="n">splitTree</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Single</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Split</span> <span class="kt">Empty</span> <span class="n">x</span> <span class="kt">Empty</span>
  <span class="n">splitTree</span> <span class="n">f</span> <span class="n">i</span> <span class="p">(</span><span class="kt">Deep</span> <span class="kr">_</span> <span class="n">l</span> <span class="n">m</span> <span class="n">r</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">f</span> <span class="n">iml</span> <span class="ow">=</span> <span class="kr">let</span> <span class="kt">Split</span> <span class="n">l'</span> <span class="n">x</span> <span class="n">r'</span> <span class="ow">=</span> <span class="n">splitDigit</span> <span class="n">f</span> <span class="n">i</span> <span class="n">l</span> <span class="kr">in</span>
          <span class="kt">Split</span> <span class="p">(</span><span class="n">toTree</span> <span class="n">l'</span><span class="p">)</span> <span class="n">x</span> <span class="p">(</span><span class="n">deepL</span> <span class="n">r'</span> <span class="n">m</span> <span class="n">r</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">f</span> <span class="n">imm</span> <span class="ow">=</span> <span class="kr">let</span> <span class="kt">Split</span> <span class="n">l'</span> <span class="n">xs</span> <span class="n">r'</span> <span class="ow">=</span> <span class="n">splitTree</span> <span class="n">f</span> <span class="n">iml</span> <span class="n">m</span>
                    <span class="kt">Split</span> <span class="n">l''</span> <span class="n">x</span> <span class="n">r''</span> <span class="ow">=</span> <span class="n">splitDigit</span> <span class="n">f</span> <span class="p">(</span><span class="n">iml</span> <span class="o">&lt;&gt;</span> <span class="n">measure</span> <span class="n">l'</span><span class="p">)</span> <span class="p">(</span><span class="n">nodeToDigit</span> <span class="n">xs</span><span class="p">)</span> <span class="kr">in</span>
          <span class="kt">Split</span> <span class="p">(</span><span class="n">deepR</span> <span class="n">l</span> <span class="n">l'</span> <span class="n">l''</span><span class="p">)</span> <span class="n">x</span> <span class="p">(</span><span class="n">deepL</span> <span class="n">r''</span> <span class="n">r'</span> <span class="n">r</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> 
          <span class="kr">let</span> <span class="kt">Split</span> <span class="n">l'</span> <span class="n">x</span> <span class="n">r'</span> <span class="ow">=</span> <span class="n">splitDigit</span> <span class="n">f</span> <span class="n">imm</span> <span class="n">r</span> <span class="kr">in</span>
              <span class="kt">Split</span> <span class="p">(</span><span class="n">deepR</span> <span class="n">l</span> <span class="n">m</span> <span class="n">l'</span><span class="p">)</span> <span class="n">x</span> <span class="p">(</span><span class="n">toTree</span> <span class="n">r'</span><span class="p">)</span>
      <span class="kr">where</span> <span class="n">iml</span> <span class="ow">=</span> <span class="n">i</span> <span class="o">&lt;&gt;</span> <span class="n">measure</span> <span class="n">l</span>
            <span class="n">imm</span> <span class="ow">=</span> <span class="n">iml</span> <span class="o">&lt;&gt;</span> <span class="n">measure</span> <span class="n">m</span>
</code></pre></div><p>于是 <code>split</code> 也很显然了</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">split</span> <span class="ow">::</span> <span class="kt">Measured</span> <span class="n">a</span> <span class="n">v</span> <span class="ow">=&gt;</span>
      <span class="p">(</span><span class="n">v</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="n">v</span> <span class="n">a</span> <span class="ow">-&gt;</span>
      <span class="p">(</span><span class="kt">FingerTree</span> <span class="n">v</span> <span class="n">a</span><span class="p">,</span> <span class="kt">FingerTree</span> <span class="n">v</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">split</span> <span class="kr">_</span> <span class="kt">Empty</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Empty</span><span class="p">,</span> <span class="kt">Empty</span><span class="p">)</span>
  <span class="n">split</span> <span class="n">f</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="n">f</span> <span class="p">(</span><span class="n">measure</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;|</span> <span class="n">r</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="kt">Empty</span><span class="p">)</span>
      <span class="kr">where</span> <span class="kt">Split</span> <span class="n">l</span> <span class="n">x</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">splitTree</span> <span class="n">f</span> <span class="n">mempty</span> <span class="n">xs</span>
</code></pre></div><p>在整个序列都不满足条件的时候我们直接返回空树</p><p>它的时间复杂度与合并两颗 Finger Tree 类似，也是均摊 <img src="https://www.zhihu.com/equation?tex=%5CTheta%28%5Cmin%28n%2C+n+-+m%29%29" alt="\Theta(\min(n, n - m))" eeimg="1"> </p><h2><b>下标访问</b></h2><p>为了提供 <code>Seq</code> 的 <code>index</code> 功能，我们需要为它定制一个 <code>Monoid</code> 来实现取 size 的功能</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">newtype</span> <span class="kt">Sized</span> <span class="ow">=</span> <span class="kt">Size</span> <span class="p">{</span><span class="n">getSize</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">}</span> <span class="kr">deriving</span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</code></pre></div><p>这里的 <code>Sized</code> 就是封装过的 <code>Int</code> ，而整数本身是一个幺半群。</p><p>于是有：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Sized</span> <span class="kr">where</span>
      <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">Size</span> <span class="mi">0</span>
      <span class="kt">Size</span> <span class="n">a</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Size</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Size</span> <span class="o">$</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div><p>然后可以把它套到 <code>Measure</code> 上，但这里我们需要对 <code>Seq</code> 的原始数据进行一次封装，塞到 <code>Elem</code> 中。</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">newtype</span> <span class="kt">Elem</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Elem</span> <span class="p">{</span><span class="n">getElem</span> <span class="ow">::</span> <span class="n">a</span><span class="p">}</span>
  <span class="kr">newtype</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Seq</span> <span class="p">(</span><span class="kt">FingerTree</span> <span class="kt">Size</span> <span class="p">(</span><span class="kt">Elem</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div><p>然后实现 <code>Measure</code> 的 <code>instance</code></p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">instance</span> <span class="kt">Measure</span> <span class="p">(</span><span class="kt">Elem</span> <span class="n">a</span><span class="p">)</span> <span class="kt">Sized</span> <span class="kr">where</span>
      <span class="n">measure</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Size</span> <span class="mi">1</span>
</code></pre></div><p>于是在 <code>FingerTree Size (Elem a)</code> 的数据域中，存放的就是当前树的大小，所以我们可以轻松地实现 <code>length</code> ：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">length</span> <span class="ow">::</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
  <span class="n">length</span> <span class="p">(</span><span class="kt">Seq</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">getSize</span> <span class="o">$</span> <span class="n">measure</span> <span class="n">xs</span>
</code></pre></div><p>还记得我们之前实现的 <code>FingerTree v a</code> 作为 <code>Measure</code> 的实例吗，在这里就派上了用场。</p><p>然后是 <code>splitAt</code> ，在特定的下标处分离两个序列</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">splitAt</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Seq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Seq</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">splitAt</span> <span class="n">i</span> <span class="p">(</span><span class="kt">Seq</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Seq</span> <span class="n">l</span><span class="p">,</span> <span class="kt">Seq</span> <span class="n">r</span><span class="p">)</span>
      <span class="kr">where</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">split</span> <span class="p">(</span><span class="kt">Size</span> <span class="n">i</span> <span class="o">&lt;</span><span class="p">)</span> <span class="n">xs</span>
</code></pre></div><p>在满足 <code>Size i &lt; Size x</code> 之前的一共有  个元素，所以就是相当于从  处切开。</p><p>同时 <code>index</code> 也类似</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">index</span> <span class="ow">::</span> <span class="kt">Seq</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span>
  <span class="n">index</span> <span class="p">(</span><span class="kt">Seq</span> <span class="n">xs</span><span class="p">)</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">getElem</span> <span class="n">x</span>
      <span class="kr">where</span> <span class="kt">Split</span> <span class="kr">_</span> <span class="n">x</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">splitTree</span> <span class="p">(</span><span class="kt">Size</span> <span class="n">i</span> <span class="o">&lt;</span><span class="p">)</span> <span class="n">mempty</span> <span class="n">xs</span>
</code></pre></div><h2><b>实现优先队列</b></h2><p>类似于 <code>Sized</code> 这个 Monoid ，我们同样可以借助其它的 Monoid 来使我们的 Finger Tree 支持其它的操作，优先队列就是一个例子。</p><p>我们维护的序列性质就变成了序列中的最大值：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Priority</span> <span class="n">a</span>
      <span class="ow">=</span> <span class="kt">MinusInf</span>
      <span class="o">|</span> <span class="kt">Priority</span> <span class="n">a</span>
      <span class="kr">deriving</span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</code></pre></div><p>显然，它也是一个 Monoid :</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">instance</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Priority</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
      <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">MinusInf</span>
      <span class="n">a</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">MinusInf</span> <span class="ow">=</span> <span class="n">a</span>
      <span class="kt">MinusInf</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span>
      <span class="p">(</span><span class="kt">Priority</span> <span class="n">a</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="p">(</span><span class="kt">Priority</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Priority</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">max</span><span class="p">`</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div><p>当它用在 Finger Tree 上时表示一个区间上的最大值，我们可以定义：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">newtype</span> <span class="kt">PriorityQueue</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">PQ</span> <span class="p">(</span><span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Priority</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Elem</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div><p>然后定义 <code>Measured</code> 的 <code>instance</code></p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">instance</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Measured</span> <span class="p">(</span><span class="kt">Elem</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Priority</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
      <span class="n">measure</span> <span class="p">(</span><span class="kt">Elem</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Priority</span> <span class="n">a</span>
</code></pre></div><p>作为优先队列它可以随意从前面或者后面插入，当删除最大结点时只需要利用 <code>splitTree</code> 找到最大结点把它拿出来即可</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">pop</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">PriorityQueue</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">PriorityQueue</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">pop</span> <span class="p">(</span><span class="kt">PQ</span> <span class="n">q</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kt">PQ</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;&lt;</span> <span class="n">r</span><span class="p">))</span>
      <span class="kr">where</span> <span class="kt">Split</span> <span class="n">l</span> <span class="n">x</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">splitTree</span> <span class="p">(</span><span class="n">measure</span> <span class="n">q</span> <span class="o">&lt;=</span><span class="p">)</span> <span class="n">mempty</span> <span class="n">q</span>
</code></pre></div><h2><b>实现有序序列</b></h2><p>如果再换一个 Monoid 实现，我们又能得到一个类似于有序列表的东西</p><p>有序表中较大元素在右边，而我们维护的序列性质仍然是序列最大值，所以 <code>Monoid</code> 的操作也很显然</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Key</span> <span class="n">a</span> 
      <span class="ow">=</span> <span class="kt">None</span>
      <span class="o">|</span> <span class="kt">Key</span> <span class="n">a</span>
      <span class="kr">deriving</span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
  
  <span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Key</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
      <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">None</span>
      <span class="kt">None</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">None</span> <span class="ow">=</span> <span class="kt">None</span>
      <span class="n">a</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">None</span> <span class="ow">=</span> <span class="n">a</span>
      <span class="kr">_</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span>
</code></pre></div><p>然后我们定义</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">newtype</span> <span class="kt">Set</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Set</span> <span class="p">(</span><span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Key</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Elem</span> <span class="n">a</span><span class="p">))</span>
  
  <span class="kr">instance</span> <span class="kt">Measured</span> <span class="p">(</span><span class="kt">Elem</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Key</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
      <span class="n">measure</span> <span class="p">(</span><span class="kt">Elem</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Key</span> <span class="n">a</span>
</code></pre></div><p>同样是依赖于 <code>split</code> ，我们可以实现根据一个元素来划分序列的函数：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">partition</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Set</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">partition</span> <span class="n">k</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">l</span><span class="p">,</span> <span class="kt">Set</span> <span class="n">r</span><span class="p">)</span>
      <span class="kr">where</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">split</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="kt">Key</span> <span class="n">k</span><span class="p">)</span> <span class="n">xs</span>
</code></pre></div><p>于是我们可以实现 <code>Set</code> 的插入和删除</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">insert</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span>
  <span class="n">insert</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Set</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;&lt;</span> <span class="p">(</span><span class="kt">Elem</span> <span class="n">x</span> <span class="o">&lt;|</span> <span class="n">r</span><span class="p">))</span>
      <span class="kr">where</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">split</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="kt">Key</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span>
  
  <span class="n">delete</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span>
  <span class="n">delete</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Set</span> <span class="p">(</span><span class="n">l1</span> <span class="o">&gt;&lt;</span> <span class="n">r2</span><span class="p">)</span>
      <span class="kr">where</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">split</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="kt">Key</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span>
            <span class="p">(</span><span class="kr">_</span> <span class="p">,</span> <span class="n">r2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">split</span> <span class="p">(</span><span class="o">&gt;</span>  <span class="kt">Key</span> <span class="n">x</span><span class="p">)</span> <span class="n">r1</span>
</code></pre></div><p>合并两个 <code>Set</code> 可以用启发式合并，具体的思路是每次取出其中一棵树的最小值，然后以其为基准把另一棵树分开，随即将“左半部分和该最小值”与“右半部份和取出最小值后剩下的部分继续合并的结果”连接起来。</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">merge</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Set</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="n">a</span>
  <span class="n">merge</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Set</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Set</span> <span class="p">(</span><span class="n">mergeSet</span> <span class="n">xs</span> <span class="n">ys</span><span class="p">)</span>
      <span class="kr">where</span> <span class="n">mergeSet</span> <span class="n">as</span> <span class="n">bs</span> <span class="ow">=</span> 
              <span class="kr">case</span> <span class="n">viewL</span> <span class="n">bs</span> <span class="kr">of</span>
              <span class="kt">Nil</span> <span class="ow">-&gt;</span> <span class="n">as</span>
              <span class="kt">Cons</span> <span class="n">b</span> <span class="n">bs'</span> <span class="ow">-&gt;</span> <span class="n">l</span> <span class="o">&gt;&lt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;|</span> <span class="n">mergeSet</span> <span class="n">bs'</span> <span class="n">r</span><span class="p">)</span>
                  <span class="kr">where</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">split</span> <span class="p">(</span><span class="o">&gt;</span> <span class="n">measure</span> <span class="n">b</span><span class="p">)</span> <span class="n">as</span>
</code></pre></div><p>它的时间复杂度是 <img src="https://www.zhihu.com/equation?tex=O%28m%5Clog%5Cfrac%7Bn%7D%7Bm%7D%29" alt="O(m\log\frac{n}{m})" eeimg="1">  。这个结果不是那么显然，这里简要的说几句。</p><p>两个有序序列 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"> (长度为 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"> )和  <img src="https://www.zhihu.com/equation?tex=Y" alt="Y" eeimg="1"> (长度为 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"> )的合并结果一定可以表示为下个式子的形式</p><p><img src="https://www.zhihu.com/equation?tex=X_0Y_1X_1%5Ccdots+X_%7Bb-1%7DY_b" alt="X_0Y_1X_1\cdots X_{b-1}Y_b" eeimg="1"> </p><p>其中 <img src="https://www.zhihu.com/equation?tex=X_0" alt="X_0" eeimg="1">  和  <img src="https://www.zhihu.com/equation?tex=Y_b" alt="Y_b" eeimg="1"> 可能为空。</p><p>而把 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1">  个大小分别为 <img src="https://www.zhihu.com/equation?tex=a_1%2C+a_2%2C+a_3%2C+%5Ccdots+%2C+a_n" alt="a_1, a_2, a_3, \cdots , a_n" eeimg="1"> 的 Finger Tree 直接粘起来的复杂度是 </p><p><img src="https://www.zhihu.com/equation?tex=O%5CBig%28%5Csum_%7Bi+%3D+1%7D%5En%5Clog+a_i%5CBig%29" alt="O\Big(\sum_{i = 1}^n\log a_i\Big)" eeimg="1"> </p><p>我们把这里 <img src="https://www.zhihu.com/equation?tex=O%28b%29" alt="O(b)" eeimg="1">  个片段粘起来的复杂度是</p><p><img src="https://www.zhihu.com/equation?tex=O%5Cbigg%28%5Csum_%7Bi%3D0%7D%5E%7Bb-1%7D%5Clog%7B%7CX_i%7C%7D+%2B+%5Csum_%7Bi+%3D+1%7D%5Eb%5Clog+%7B%7CY_i%7C%7D%5Cbigg%29" alt="O\bigg(\sum_{i=0}^{b-1}\log{|X_i|} + \sum_{i = 1}^b\log {|Y_i|}\bigg)" eeimg="1"> </p><p>而 </p><p><img src="https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D0%7D%5E%7Bb-1%7D%5Clog%7B%7CX_i%7C%7D+%2B+%5Csum_%7Bi%3D1%7D%5Eb%7B%5Clog%7B%7CY_i%7C%7D%7D+%5Cleq+b%5Clog%5Cfrac%7Bm%7D%7Bb%7D+%2B+b%5Clog%5Cfrac%7Bn%7D%7Bb%7D+%5Cleq+2b%5Clog%5Cfrac%7Bn%7D%7Bb%7D+%5Cleq+2m%5Clog%5Cfrac%7Bn%7D%7Bm%7D" alt="\sum_{i=0}^{b-1}\log{|X_i|} + \sum_{i=1}^b{\log{|Y_i|}} \leq b\log\frac{m}{b} + b\log\frac{n}{b} \leq 2b\log\frac{n}{b} \leq 2m\log\frac{n}{m}" eeimg="1"> </p><p>所以复杂度不高于 <img src="https://www.zhihu.com/equation?tex=O%28m%5Clog%5Cfrac%7Bn%7D%7Bm%7D%29" alt="O(m\log\frac{n}{m})" eeimg="1"> </p><h2><b>继续扩展</b></h2><p>Finger Tree 的可扩展性在于你只需要定制一种需要维护的区间性质的 <code>Monoid</code> ，你就能轻易地套上去并使用。比如玩烂的区间最大连续和，Finger Tree 套上就能写。</p><h2><b>一点点实现细节</b></h2><p>事实上，<code>Digit</code> 我们使用的是 <code>list</code> 来实现的，这肯定会带来一些效率上的问题，所以在库中，<code>Digit</code> 都是这么定义的</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">Digit</span> <span class="n">a</span>
      <span class="ow">=</span> <span class="kt">One</span> <span class="n">a</span>
      <span class="o">|</span> <span class="kt">Two</span> <span class="n">a</span> <span class="n">a</span> 
      <span class="o">|</span> <span class="kt">Three</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span>
      <span class="o">|</span> <span class="kt">Four</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span>
</code></pre></div><p>这会带来很可怕的代码膨胀，尤其是在实现 <code>appendTree</code> 这个函数时。</p><p>首先我们需要的是</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">addDigits</span> <span class="ow">::</span> <span class="kt">Sized</span> <span class="n">a</span> <span class="ow">=&gt;</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> 
      <span class="kt">Digit</span> <span class="n">a</span>             <span class="ow">-&gt;</span> 
      <span class="kt">Digit</span> <span class="n">a</span>             <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span>
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>种 <code>Digit</code> ，有两个，共有  种情形，每种都要写一个。</p><p>而不同的 <code>Digit</code> 揉在一起的 <code>Node</code> 数量也不一样，所以也需要像这样的函数</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">appendTree'</span> <span class="ow">::</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> 
      <span class="kt">Node</span> <span class="n">a</span>              <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>而它的实现又不可避开一个这样的函数：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">addDigits'</span> <span class="ow">::</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">))</span>  <span class="ow">-&gt;</span> 
      <span class="kt">Digit</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span>              <span class="ow">-&gt;</span> 
      <span class="kt">Node</span> <span class="n">a</span>                      <span class="ow">-&gt;</span> 
      <span class="kt">Digit</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span>              <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">))</span>  <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div><p>而它又依赖另外一个：</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="n">appendTree''</span> <span class="ow">::</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> 
      <span class="kt">Node</span> <span class="n">a</span>              <span class="ow">-&gt;</span> 
      <span class="kt">Node</span> <span class="n">a</span>              <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> 
      <span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>如此循环往复，直到参数中间包含  个 <code>Node</code> 。</p><p>这些全部实现下来大概有 200 行……我放一张 code map 缩略图给大家看一下</p><p><br></p><figure><noscript><img src="https://pic4.zhimg.com/v2-ddff8a519e6faf7b690845787029f763_b.jpg" data-caption="" data-rawwidth="87" data-rawheight="581" class="content_image" width="87"></noscript><img src="https://pic4.zhimg.com/v2-ddff8a519e6faf7b690845787029f763_b.jpg" data-caption="" data-rawwidth="87" data-rawheight="581" class="content_image lazy" width="87" data-actualsrc="https://pic4.zhimg.com/v2-ddff8a519e6faf7b690845787029f763_b.jpg"></figure><p><br></p><p>还有就是在真正实现高性能 Haskell 代码时，不可避免的要涉及到 Strictness,  Unpack 等特性，例如在 <code>Data.Seq</code> 中实现的 Finger Tree,  就使用了 Strictness flag 来防止不必要的延迟求值，并使用了 unpack 来提升性能</p><div class="highlight"><pre><code class="language-haskell"><span></span> <span class="kr">data</span> <span class="kt">FingerTree</span> <span class="n">a</span>
      <span class="ow">=</span> <span class="kt">Empty</span>
      <span class="o">|</span> <span class="kt">Single</span> <span class="n">a</span>
      <span class="o">|</span> <span class="kt">Deep</span> <span class="cm">{-# UNPACK #-}</span> <span class="o">!</span><span class="kt">Int</span> <span class="o">!</span><span class="p">(</span><span class="kt">Digit</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">FingerTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span><span class="p">))</span> <span class="o">!</span><span class="p">(</span><span class="kt">Digit</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>在这里不做讨论(不懂)。</p><h2>你看完了这篇文章</h2><h2><b>你学到了什么</b></h2><p>可能学到了一点 Haskell 实现数据结构的姿势</p><h2><b>你觉得这篇文章可能有很多问题</b></h2><p>欢迎指正</p><h2>参考文献 &amp; 推荐阅读</h2><p><a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Finger_tree" class=" wrap external" target="_blank" rel="nofollow noreferrer">Finger Tree 的维基百科</a> </p><p><a href="http://link.zhihu.com/?target=http%3A//hackage.haskell.org/package/fingertree-0.1.2.1/docs/src/Data-FingerTree.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Finger Tree 的 hackage 源码</a></p><p><a href="http://link.zhihu.com/?target=http%3A//www.staff.city.ac.uk/%7Eross/papers/FingerTree.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">Finger Tree 的论文</a>  （强烈推荐）</p><p><a href="http://link.zhihu.com/?target=http%3A//xueshu.baidu.com/s%3Fwd%3Dpaperuri%253A%2528bf79af0c1ab7a3574e965f8457c1e424%2529%26filter%3Dsc_long_sign%26tn%3DSE_xueshusource_2kduw22v%26sc_vurl%3Dhttp%253A%252F%252Fciteseerx.ist.psu.edu%252Fviewdoc%252Fdownload%253Fdoi%253D10.1.1.51.4571%2526rep%253Drep1%2526type%253Dpdf%26ie%3Dutf-8%26sc_us%3D6093570767507930986" class=" wrap external" target="_blank" rel="nofollow noreferrer">Finger Tree 的部分复杂度证明</a></p><p><a href="http://link.zhihu.com/?target=http%3A//www.staff.city.ac.uk/%7Eross/papers/FingerTree.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Paper 的网站</a></p>