<div class="title-image"><img src="https://pic3.zhimg.com/v2-5e48dd90d980cdbb9a0b3e4b855f4c24_b.jpg" alt=""></div><blockquote>DeepSpec 是由<a href="https://link.zhihu.com/?target=http%3A//www.nsf.gov/cise/about.jsp" class=" wrap external" target="_blank" rel="nofollow noreferrer">美国国家科学基金会（NSF）</a>赞助的<a href="https://link.zhihu.com/?target=https%3A//www.nsf.gov/news/news_summ.jsp%3Fpreview%3Dy%26cntn_id%3D137328" class=" wrap external" target="_blank" rel="nofollow noreferrer">计算远征项目</a>，专注于软硬件全功能正确性的规范和验证。<br/>DeepSpec 有几个主要的研究项目，其远大目标是按照规范接口将它们连接起来，端到端地证明整个系统的正确性。<br/>本文主要译自 <a href="https://link.zhihu.com/?target=https%3A//deepspec.org/" class=" wrap external" target="_blank" rel="nofollow noreferrer">DeepSpec 官方网站</a>，译文按照 <a href="https://link.zhihu.com/?target=https%3A//creativecommons.org/licenses/by-sa/4.0/deed.zh" class=" wrap external" target="_blank" rel="nofollow noreferrer">创作共用 署名-相同方式共享 4.0 (CC BY-SA 4.0) 国际许可协议</a>授权。<br/>本介绍为系列文章，分为<b>科研篇</b>、<b>教育篇</b>、<b>项目篇</b>和<b>人物篇</b>。本文为<b>科研篇。</b></blockquote><h2>序</h2><p>在我们的互联世界中，软件错误和安全漏洞带来了巨大的成本和风险，而深度规范（Deep Specification，后称 DeepSpec）项目就要解决这个问题。DeepSpec 展示了如何构建行为精确符合预期的软件，即不多做也不少做：不会有后门让黑客入侵，也不会有 Bug 导致你的应用程序、计算机或汽车崩溃。「软件应该做什么」，或者说软件的预期<b>行为（Behavior）</b>称作它的<b>规范（Specification）</b>。</p><p>为了指明程序应该做什么，为了构建符合规范的程序，也为了验证程序的行为与预期行为精确匹配，<b>DeepSpec 联盟</b>将会发展新的科学、技术和工具。我们专注于核心软件系统的基础设施建设，如操作系统、编程语言的编译器以及计算机芯片，还有选举和投票系统、汽车系统以及智能手机这类的应用。</p><p>经验表明，为软件编写良好的规范极具挑战性。最大限度可用的接口规范必须同时满足：</p><ul><li><b>丰富（Rich）</b>的表达能力：能够详细描述复杂组件的行为</li><li><b>兼顾（Two-sided）</b>上层和下层：能够将自身的实现和使用者连接起来</li><li><b>形式化（Formal）</b>的方法：将清晰的语义用数学记法书写，以支持如类型检查器、代码分析和测试工具，自动化或机器辅助的证明器，以及高级 IDE 等工具</li><li><b>有活力（Live）</b>：通过可机器检查的证明，将规范与实现和使用者的代码相连接</li></ul><p>我们将满足这些性质的规范称作<b>深度规范（Deep Specification）</b>。</p><h2>研究概览</h2><p>在软件工程中，模块会导出接口（API），而模块本身又依赖于下层接口。在软件验证中，我们会为每个接口编写对应的规范，之后就能通过检查规范来证明接口的正确性：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-15ce209338cdfa7eb0f39576998fbe08_b.jpg" data-size="normal" data-rawwidth="1372" data-rawheight="270" class="origin_image zh-lightbox-thumb" width="1372" data-original="https://pic1.zhimg.com/v2-15ce209338cdfa7eb0f39576998fbe08_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-15ce209338cdfa7eb0f39576998fbe08_b.jpg" data-size="normal" data-rawwidth="1372" data-rawheight="270" class="origin_image zh-lightbox-thumb lazy" width="1372" data-original="https://pic1.zhimg.com/v2-15ce209338cdfa7eb0f39576998fbe08_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-15ce209338cdfa7eb0f39576998fbe08_b.jpg"/><figcaption>模块及其证明</figcaption></figure><p>在软件工程中，接口通常以编程语言编写，例如包含函数原型的 C 语言头文件，或者 Java 语言中类的描述。它们可以描述接口函数的类型，但却无法指定它们的行为。UML 之类的建模语言可以做得稍好一些，但表达能力不够<b>丰富（Rich）</b>，不足以刻画出我们想要该模块做什么。</p><p>程序验证逻辑可利用<b>形式逻辑（Formal Logic）</b>完整的表达能力来刻画行为，但由于历史原因，它们没有「<b>活力（Live）</b>」：它们一直注重程序的模型，却没有将其自身与程序直接而机械式地连接起来。（相比之下，编译器的类型检查器则能在每次编译时，确保 API 规范中的类型会与实现中的类型相匹配。）</p><p>使用<b>形式化（Formal）</b>逻辑能让我们用自动证明器和证明检查器来验证程序，从而保证实现满足接口。</p><p>然而还有一个重点需要考量：规范是<b>兼顾（Two-sided）</b>的吗？即它的上层和下层都被验证过了吗？具体来说，我们的研究主要在组件的规范和验证上，如操作系统内核，编译器和程序分析工具。例如，CertiKOS 是一个用 C 实现的<b>虚拟层（Hypervisor）</b>内核。它应当遵循操作系统的规范（如进程独立和调度公平等性质）以证明其正确性。然而它的证明依赖于 C 语言规范，若没有 C 的<b>形式语义（Formal Semantics）</b>，我们对代码行为的论证便无从谈起了。而 CompCert 正是这样一种 C 编译器，它遵循 C 语言的形式化语义，所产生的机器码同样遵循形式化语义，这样便证明了它的正确性：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-cbdb2fa8e18d46340aade037c97e468e_b.jpg" data-size="normal" data-rawwidth="732" data-rawheight="270" class="origin_image zh-lightbox-thumb" width="732" data-original="https://pic3.zhimg.com/v2-cbdb2fa8e18d46340aade037c97e468e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-cbdb2fa8e18d46340aade037c97e468e_b.jpg" data-size="normal" data-rawwidth="732" data-rawheight="270" class="origin_image zh-lightbox-thumb lazy" width="732" data-original="https://pic3.zhimg.com/v2-cbdb2fa8e18d46340aade037c97e468e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-cbdb2fa8e18d46340aade037c97e468e_b.jpg"/><figcaption>CertiKOS 与 CompCert</figcaption></figure><p class="ztext-empty-paragraph"><br/></p><p>例如在实践中，我们经常会发现证明 CertiKOS 时用到的 C 语言规范与 CompCert 提供的 C 语言规范并不匹配。CompCert 的 C 语言规范是专为证明 CompCert 的正确性而设计的，因而从使用者的角度来看，就显得所有不足或过度限制了。CertiKOS 可能需要 CompCert 的规范中未提供的特性。而我们只有将这些模块组合在一起时，才能以兼顾的方式运用 C 语言规范，并从中学习如何改进并加强规范。</p><p>每位 DeepSpec 团队中的研究员都在推进重大的研究项目。每个项目都会导入一些规范，导出其它规范。它们的规范是富于表现力，有活力且形式化的。但只有将它们连接在一起时，才能确保规范是兼顾的。于是，我们设想了这个经过验证的软件组件网络，它通过<b>富于表现力（Rich）</b>、<b>有活力（Live）</b>、<b>形式化（Formal）</b>且<b>兼顾（Two-sided）</b>的，DeepSpec（Deep Specifications，深度规范）构建的规范连接起来。</p><h2>规范之网</h2><p>普适性的洞见一定是从特定系统的详细描述和实现开始的。此远征项目的核心目标，就是从软件系统中高安全性要求的「中间层」中创建一组相互关联的规范，以及连接它们的<b>工件（Artifact）</b>。</p><blockquote>译注：<b>组件（Component）</b>即构成系统的原件，而<b>工件（Artifact）</b>则是在构建系统时用到的工具。举例来说，螺丝是组件，而螺丝刀是工件。在程序开发时，代码中导入的库是组件；而编译器、IDE、测试用例，甚至调试所用到的各种信息都是工件。在本文中，为程序构造的证明只是为了保证程序的正确性，并不会作为软件的一部分实际交付给用户，因此它属于工件。</blockquote><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-ae67bbfdac669aeebb7bbf7cf57b5f0e_b.jpg" data-size="normal" data-rawwidth="2220" data-rawheight="1486" class="origin_image zh-lightbox-thumb" width="2220" data-original="https://pic3.zhimg.com/v2-ae67bbfdac669aeebb7bbf7cf57b5f0e_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-ae67bbfdac669aeebb7bbf7cf57b5f0e_b.jpg" data-size="normal" data-rawwidth="2220" data-rawheight="1486" class="origin_image zh-lightbox-thumb lazy" width="2220" data-original="https://pic3.zhimg.com/v2-ae67bbfdac669aeebb7bbf7cf57b5f0e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-ae67bbfdac669aeebb7bbf7cf57b5f0e_b.jpg"/><figcaption>规范、组件与工件</figcaption></figure><p>上图展示了深度规范网络与工件（实现，翻译或证明）之间的联系，即我们在远征结束时的构想。图中不同区域内纵向的标签和括号标明了哪位主要的研究员负责该项目。紫色标签标注的组件由外部协作者负责。</p><p>图的顶部为应用级接口的规范，如 <code>SQL</code> 查询语言的语义，或者管理公平选举（<code>Elections</code>）的规则。底部是某些特定微处理器的<b>寄存器传递语言（Register-Transfer Language,</b> <b><code>RTL</code>）</b>实现的语义，如 x86。投票或数据库系统以遵循「C 程序规范」（<code>Spec of C Program</code>）的 C 程序实现，它按照「可验证的 C」（<code>Verifiable C</code>）的程序逻辑编写。我们用 Coq 配合 Floyd 自动证明系统，证明了该 C 程序通过将程序逻辑应用到程序上从而正确实现了 SQL。「可验证的 C」是一组程序正确性的论证规则，无论关于程序的何种性质被证明，该性质都会在程序运行时成立。这一点在 Coq 中被形式化为「将『可验证的 C』连接到 <code>C-light</code> 的操作语义」的<b>可靠性证明（Soundness Proof）</b>。CompCert 优化编译器将 C-light 编译为 ARM、PowerPC 或 <code>x86-ISA</code> 上的机器码。CompCert 的翻译正确性由 Coq 证明。最后，硬件也是正确的：x86-ISA 指令集架构由 <code>Bluespec</code> 硬件描述语言指定，该语言通过深度规范精确定义了它的语义。Kami 合成器将它翻译为 <code>Verilog</code>（同样，它也有深度规范）编写的寄存器传递。</p><p>当然，用户层的应用不会在裸机上运行，它需要操作系统。操作系统中的错误和漏洞可能会危害整个系统，因为它可能会错误理解操作系统-客户端之间的接口。因此我们也需要在这一层建立规范和验证。CertiKOS 就是经过形式化验证的<b>虚拟层（Supervisor）</b> 内核，以及对应的 <code>CertiKOS-spec</code> 规范。它在 <code>CertiClight</code> 程序逻辑中通过<b>精化证明（Refinement Proof）</b>的方法证明了其<b>正确性（Correctness）</b>，而与之对应的通过 CompCert 编译的 <code>C-light</code>语言变体则保证了其<b>可靠性（Soundness）</b>。这样它就建立了从 <code>x86-ISA</code> 到 <code>x86-RTL</code> 的<b>端到端（End-to-End）</b>的连接。</p><p>LLVM 是 21 世纪的工业标准编译器的中间表示和工具集。它有一个深度规范 <code>LLVM</code>，以及与之对应的，关键的 LLVM 编译<b>阶段（Phase）</b>的正确性证明。CompCert 的 <code>C-light</code> 前端通过一个经验证的，C-light 到 LLVM 的翻译器被连接到 LLVM 后端。</p><p>Haskell 是一种广泛应用的函数式编程语言。Glasgow Haskell 编译器（GHC）将它翻译到一种高级的内部语言，我们会将它深度规范化为 <code>Core-Haskell</code> GHC，它用于将 Core Haskell 翻译到 LLVM。</p><p>对于函数式编程而言，Haskell 之外的另一种选择是嵌入到 Coq 自身逻辑系统之内的 <code>Gallina</code> 语言。Gallina 语言会通过一个经验证的工具链，以<b>续体传递风格（<code>CPS</code>）</b>的中间表示被连接到 CompCert <code>C-light</code>。</p><p>最终的结果是一个 x86-RTL 电路，它是一种操作系统和用户代码指令的二进制表示；还有一个端到端的证明，用于在电路上执行这些指令，并产生由用户层规范（如 <code>SQL</code>、<code>Elections</code>、<code>Gallina</code> 或 Haskell 程序等）描述的行为。</p><p>图中的实线框表示形式化验证。然而即便是未验证的虚线框部分，也可以通过建立在深度规范之上的，<b>基于性质（Property-based）</b>的随机测试来提供极高的保障。严格的随机测试也可用于开发或调试最终用于形式化验证的组件和规范，也就是图中的其它部分。这部分的工作交由 QuickChick 完成。</p><p>图中的一些规范和连接组件已经作为独立的攻坚点而存在了。为了实现图中所展现的端到端连接验证的愿景，我们必须缩小关键规范之间的差距。这需要持续地研究，大部分情况下还需要不断地突破。实际上，「C-light」的规范可以说是整个图中唯一真正的深度规范，因为它已经在上层（可验证 C 的可靠性证明）和下层（CompCert 的正确性证明）中被着力运用了。然而即便是 C-light 的规范，还需要处理并发和分布式编程。同样，目前的 <code>CertiKOS-spec</code>尚未在上层广泛应用；<code>x86-ISA</code> 规范也尚未在下层应用；<code>LLVM</code> 规范的模块化程度尚不足以应对工业 LLVM 的可扩展性；目前 <code>BlueSpec</code> 和 <code>Verilog</code> 的规范只有一个很小子集的演示原型；而 <code>Core-Haskell</code> 规范尚未开始。</p><p>现有的 <code>CertiClight</code> 和 <code>Verifiable C</code> 都很接近深度规范了，然而二者之间的差距还比较明显。此远征计划的主要目标之一就是将基于<b>精化（Refinement）</b>的 <code>CertiClight</code> 方法与基于<b>分离逻辑（Separation Logic）</b>的 <code>Verifiable C</code> 统一到程序验证中。另一个目标就是扩展 <code>Verifiable C</code> 的程序逻辑，使其可以验证并发和分布式的程序。</p><p>若能够将我们心目中的，由规范化/经验证的工件构成的一致性系统构建出来，那将会是一项重大的突破。被选择用于实现接口的，特定的经验证的组件也可以广泛地应用于此远征项目之外的情景中，例如 C 和 x86 汇编。然而，最大的回报在于它可以阐明深度规范作为抽象和模块化技术的概念基础，它还具有潜在的与数据抽象等概念等同甚至更大的实际效益，而且效益会随着规模不断增加。对于内部规范，如 <code>C-light</code> 语言的定义，人们不必考虑「我是否为程序指定了正确的行为？」因为关于 SQL 的端到端证明已经通过 <code>SQL</code> 和 <code>x86-RTL</code> 的规范得证了。我们会研究构建完整系统的<b>语用学（Pragmatics）</b>，其暴露的规范仅涉及 Verilog 和 SQL 的语义，确保对于所有的中间实现和验证都有的可靠的措施。</p><blockquote>译注：<b>语用学（Pragmatics）</b>主要研究<b>语境（Context）</b>对语言含义产生的影响以及做出的贡献。</blockquote><p><b>目录</b></p><p><a href="https://zhuanlan.zhihu.com/p/75028703" class="internal">深度规范科学（DeepSpec）简介：科研篇</a></p><p>深度规范科学（DeepSpec）简介：教育篇</p><p>深度规范科学（DeepSpec）简介：项目篇</p><p>深度规范科学（DeepSpec）简介：人物篇</p>