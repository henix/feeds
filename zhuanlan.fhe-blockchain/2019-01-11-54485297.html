<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>电子货币30年：从电子现金到区块链-part4</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/54485297">原文</a></p>
<p>一．<b>推动电子货币的发展，我们需要解决几个关键的问题</b></p><p><b>1.</b> 如何扩大交易规模。</p><p>比特币和区块链的交易频率大约为每秒7笔交易(理论)，可能更低。相比于VISA, 可以支持来自全球的大约40,000笔交易。我们需要用一些方法提高交易频率，将货币吞吐量提高到合理的量级。</p><p><b>引入通道的概念：闪电网络</b></p><p>有两个交易方，想要进行多次交易，但不想占用比特币太多带宽，所以他们建立了一个三方契约。基本实现就是每个人都在区块链上抵押一部分资金，所有交易汇款，双方对交易完成签名时，这笔交易就会被解锁，或一个交易方中止交易后的一段时间，就会自动解锁。三方契约在其中起到的是中介作用，让交易双方可以快速交易，而区块链在确保最终交易的结果。闪电网络已经上线，并在相应的节点建测试。</p><p>这种网络存在如下问题。不能保护交易双方的隐私，但可以理解，它不是隐私保护技术，它是为了双方的即时交易，而不受限于区块链的容量。如果想要实现隐私保护，不想知道通道终点的个体是谁，就需要在通道中设置更多的的中间人，如果几个个体不合谋，则彼此交易双方无法得知另一方的信息。</p><p>但是这种系统不太可能运转起来。首先为了实现隐私保护，我们不得不设置多条交易，但不会有人希望在系统中设置多条交易，我们甚至不知道两个参与方之间是都存在一条可以联通的一些通道，我们也不知道位于多条通道之间的参与方是否在区块链上抵押了足够的代币。</p><p>即使上述假设都成立，在lighting 中还存在一个非常重要的问题，为了让支付通道可以自动关闭，参与方之间需要分享一种叫哈希锁（hashlock）的东西。这意味着通道中的每个独立的参与方都要分享一个哈希值H，这个哈希值会将支付通道的各个节点绑定到一起，这意味着如果I1和I3合谋，即使I2是诚实的支付通，这个支付通道中的参与方也将面临去匿名化的风险，这种解决方案安全性十分弱。</p><p>那如何解决这个问题，如何解决支付通道中的隐私问题，<b>支付通道技术似乎是密码货币的未来</b>。</p><p>我们用支付通道技术购买咖啡，支付租金，我们希望自己的隐私被保护。</p><p>David Chaum提出的e-Cash(电子货币技术)已经有 30年了，让我们把它部署在支付通道中。在简单的单通道场景，我们把一个参与方看成是银行，我们可以在两个参与方之间(A and B)建立余额记账系统，这样一来，只要A要花费一笔钱，A就从B那里撤销一部分代币，然后通过匿名的方式将代币发送给B,假设B开启了很多个支付通道，他就无法知道这笔代币是谁发送的，这看起来是个简单的解决方案。</p><p>在多跳场景下如何解决隐私问题？</p><p>如果我不能和支付方直接建立连接，该怎么办？</p><p>A无法与C直接交易，A可以与银行交易，C不可以和银行交易。</p><p>事实证明只要修改系统架构，就能让Chaum的电子货币，在两跳点上运行。我们选择让B作为中间人(当然这个B的可能性有很多，所以才能保证两跳场景下的成功交易)B充当银行的角色,</p><p>A与C建立连接，提取现金，与C交换代币。</p><p>B可以做相同的操作，与C建立联系，提取现金，与C交换代笔。如果我们能建立一个同时能支持转入和转出的代币支付系统。我们可以完成3跳吗？</p><p>我们认为不可以运转，还没找到一种支持超过两跳节点支付的隐私保护解决方案，<b>当通道的跳转次数变得更多后，Chaum的电子货币系统似乎就无法支撑了</b>。</p><p>因为在多跳场景下，需要通过一种方法将不相干的通道绑定在一起，但我们还没有找到一种可以实现隐私保护的绑定方式，这是一个公开的问题，如果我们想要实现一个网络，允许多个用户在网络中建立多条支付通道，我们需要一种既能建立长支付通道，又能实现隐私保护的方法，但我们目前还没有找到这种方法。</p><p><b>2.</b> 找到可以代替工作量证明的共识机制。</p><p> 对这个问题我们很感兴趣，很多学者在这方面进行了很深的研究。比特币耗费大量的能源，其一年耗电量和瑞典的耗电量相同，显然的解决方式是将工作量证明替换成其他的密码学证明技术，我们可以用签名密钥对区块进行签名，并于其它参与方建立共识。</p><p>如何通过签名密钥选举出记账节点呢，目前摆在台面上的方法是权益证明技术，这个技术的基本思想是拥有越多的节点越可信，越可以生成正确的签名区块。如何实现这一点，所有权益证明技术的思路都类似，要通过协议查出网络中的主要权益持有方，建立一个权益持有方列表，公开纰漏权益持有放的身份，然后根据各个权益持有方所拥有的权益设置采样权重。</p><p>接下来从列表中采样，在采样时我们如何得到随机状态呢？从NIST的<a href="http://link.zhihu.com/?target=http%3A//random.org" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">random.org</span><span class="invisible"></span></a>网站获得随机量吗。我们如何从比特币和网络上获得随机数，这是个公开的问题，目前我们还是有一些解决方案的，有一组学者在EUROCRYOT(欧密会)上发表了一个非常优异的工作成果[DGKR18],[KRDO17],Ouroboros,其中一些测略被部署到实际的代币系统中，那个代币系统叫Cardano。</p><p><b>所有这些系统都面临一个问题，他们都需要依靠一个随机变量来完成采样</b>。在原始的Ouroboros协议中，这个协议需要在成百上千的节点中执行一个交互式协议，从而建立一个随机种子，此种子将被用于后期的采样过程中，要达到的核心目的是，即使一定数量的节点离开系统，此协议也可以正确执行。但如果太多的节点离开网络，该怎么办，我们不知道是否可以正确的执行。</p><p>新的协议应用一个稍显不同的方法来解决此问题，新协议使用基于计算Deffie-Hellman问题的抗碰撞哈希函数。基本思想是，网络中的一些个体要为函数提供输入，我们要计算输入的哈希值，从而生成随机锚点，但不管怎么设计协议，总有一个参与方要执行协议的最后一步。这个参与方，他可以利用他的哈希算力计算不同输入的采样结果，从而偏斜输出随机状态的分配。设计者设计哈希函数，这个哈希函数会组织参与者参与方实施碰撞攻击，使他们难以偏离随机量的概率分布。</p><p>哈希函数的设计依赖于相对较强的假设，评估参与方偏离随机量的分布的程度，可以对方案进行严谨的证明，我认为这是最有意思的地方，但为了考察协议是否真的可以运转，我们需要在实际中部署协议。<b>总的来说，密码货币最感到激动的是，它允许我们在上面部署新的密码方案。</b></p><p><b>3.</b> Ledger-conditioned computation, 分类帐本条件计算，</p><p>我们反过来看待这些问题。我们一直讨论密码学如何帮助密码货币，但可能密码货币或者区块链可以反过来帮助我们建立密码系统，领域中的很多人都在研究这样一个问题。</p><p>假象我们有一些可信的硬件，可以认为这些硬件是可信的，安全的。密码学安全计算技术这一领域，正在快速发展，从理论角度，密码安全技术的实施依赖于硬件平台，或者纯软件平台，程序混淆技术允许我们构建可信计算设备或可信计算电路完成特定的计算任务(技术支持)。</p><p>假设我们拥有一些安全硬件，但假设这些可信计算设备无法记录当前状态，这是一个很现实的假设。对于程序混淆等通过软件平台实现的技术更加现实，软件本身没有记录当前状态的能力，我们可以不费吹灰之力构建硬件可信计算平台，</p><p>我们想用这些设备完成多步骤交互式计算任务，这意味着我想根据某些输入执行程序得到输出，再把输出作为输入的执行程序。</p><p>另一个面临此问题的场景是，假设我们有一个网络，每个节点都是可信的计算设备，我们要运行一个单轮多步骤的，但程序的每个计算步骤都要在不同设备上完成。每一个智能合约系统都会面临上述场景，很多无服务系统，亚马逊的ASW　Lambda 等也面临上述场景，在此类场景下，显然我们需要记录一个同步状态，如何记录同步状态？</p><p>解决方案是：假设每个安全计算设备都有一个密钥。用户A将密钥发送给计算设备，我们可以得到输出结果和一个加密后的计算状态，用于后续的计算过程。我要根据下一个输入执行下一个计算步骤，我把加密状态输入一个可信设备中，得到输出和一个新的加密状态。</p><p><br></p><p>但我们可能会碰到一个问题trivial Replay Attacks，简单的重放攻击。因为设备无法在内部储存状态，我们把第三个输出和第一个加密状态发送给设备，这样我们可以让设备计算出一个新的输出结果，我们重复多次实施这种攻击，并且计算设备上执行的是交互式密码协议，这种攻击方式会破坏协议的安全性。</p><figure><noscript><img src="https://pic1.zhimg.com/v2-51c97eb8621e3e6fdd23d6548f0588d8_b.png" data-caption="" data-size="normal" data-rawwidth="192" data-rawheight="188" class="content_image" width="192"></noscript><img src="https://pic1.zhimg.com/v2-51c97eb8621e3e6fdd23d6548f0588d8_b.png" data-caption="" data-size="normal" data-rawwidth="192" data-rawheight="188" class="content_image lazy" width="192" data-actualsrc="https://pic1.zhimg.com/v2-51c97eb8621e3e6fdd23d6548f0588d8_b.png"></figure><p>……</p><p>假设我们有一个区块链，我们有一个公开可验证账本，公开验证的意思是我们可以把字符串放置在账本上，账本可以返回一个签名。或者可验证证明，告诉我们字符串已经放置在账本上，你也可以把整个账本拷贝下来，把完整的账本送给设备。利用这种方法，可以很容易的实现状态记录功能。我们可以把我们的输入发送给账本，我们可以得到储存的内容和相关的证明，设备可以验证账本，查看当前的状态，设备可以返回一个输出结果和一个加密状态，进一步完成相关的细节设计，我们就可以建立一个可信的计算机系统了，只要我们可以于某个账本进行交互，我们就可以抵御重放攻击。抵御重放攻击对智能合约来说非常重要，尤其对于隐私智能合约，对于可信安全计算设备来说，这更为重要。</p><p>应用密码程序混淆技术，我们还能实现哪些功能，对此表示好奇。</p><p><b>二．下面我们讨论不同密码学中涉及到的一些糟糕的密码学方案</b></p><p>1. BitGrain 损失1.7亿美元因为他们把系统中的余额检查功能放在了客户端的javascript代码中。</p><p>2. NIST的一个网站<a href="http://link.zhihu.com/?target=http%3A//random.org" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">random.org</span><span class="invisible"></span></a> （生成公开可验证的随机量）,用https替换http,这就导致之前用用户为了获得随机量而调用<a href="http://link.zhihu.com/?target=http%3A//random.org" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">random.org</span><span class="invisible"></span></a>的网站，那么他们现在得到是404，这让他们损失一笔钱。</p><p> 某人实现了ECDSA,他们想让ECDSA中的临时随机变得更安全，他们把消息和私钥的XOR结果作为临时随机量，这使得临时随机量的分布变得偏离。可以通过256个签名结果恢复私钥，很多用户都恢复了私钥，这种攻击方式被实际验证可行</p><h2><b>     IOTA利用人工智能发明了自己的哈希函数。 IOTA用基于哈希函数的数字签名，不知道他这样做的原因。IOTA使用的签名是 Winternitz signature</b> <b>温特尼茨签名。</b></h2><figure><noscript><img src="https://pic1.zhimg.com/v2-1a3ffc99fb61da72e3bd08bf09c09ea4_b.jpg" data-caption="" data-size="normal" data-rawwidth="353" data-rawheight="156" class="content_image" width="353"></noscript><img src="https://pic1.zhimg.com/v2-1a3ffc99fb61da72e3bd08bf09c09ea4_b.jpg" data-caption="" data-size="normal" data-rawwidth="353" data-rawheight="156" class="content_image lazy" width="353" data-actualsrc="https://pic1.zhimg.com/v2-1a3ffc99fb61da72e3bd08bf09c09ea4_b.jpg"></figure><h2><b>私钥通过哈希迭代计算哈希值，最终的到公钥</b></h2><h2><b>假设我们要对一串字节进行签名，我们要从私钥开始（123434），计算特定次数的哈希值，为了对3进行签名，我需要计算3次哈希值，得到对应的私钥，然后将哈希结果作为签名的一部分，接下来我会对下一个字节进行签名。</b></h2><h2><b>问题是:</b></h2><h2><b>我们计算出3的哈希值，任何人都可以计算一次哈希值，从而得到字节4对应的签名结果，这样你把消息从3换成4，且对应的签名任然可以得到验证，因此很容易对次签名进行伪造。</b></h2><h2><b>解决方法:</b><br> <b>实现一个单独的验证码，在签名之前，我们需要把验证嘛放在消息的末尾处，验证码的特性是你不能在保持验证码不变的条件下，把签名中的任何字节增1。验证码的引入对签名算法的安全起到了决定性的作用，IOTA是对消息求和，IOTA发明了自己的验证码，这使得任何人可以把签名消息中的字节增1，同时使新消息对应的签名通过验证。，因此假如我有一个消息M,你就可以创造另一个消息M_1,其各个字节都比M大1，你可以多计算一次哈希结果，从而伪造住M_1对应的签名。</b></h2><h2><b>即使如此，我们也很难找到满足上述条件有意义的两个消息。因为如果两个消息很长，带签名的消息还是另外一个哈希函数的输出结果，IOTA只验证完其中的1/3签名，也就是验证27字节，他们称IOTA应用了调优技术，因此验证过程会尝试27次，即验证27字节消息的签名，因此这不是一个安全的签名方案。</b></h2><p>3.Zcash没有对元素所在数域进行验证的漏洞</p><p> 最尴尬的攻击实例，让某人的账户凭空传创建了370，000个代币，通过买卖得到上百万美元的收入。</p><p>密码货币是个有趣而火爆的话题，但我们要严肃的对待密码货币，因为密码货币值很多钱，一旦出问题，很多人会受到伤害，但密码货币为我们创造了独一无二的机会，可以让我们研究很多有趣的新密码方案，这里面包含了很多有意思的问题，我们之前没有机会去解决这些问题，我们应该利用好这些独一无二的机会去解决这些问题，在领域内部创新密码技术。</p><p> ===============================================================<br><b>文章首发在微信公众号：btc201800</b><br><b><a href="http://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">weixin.qq.com/r/GC8UDDj</span><span class="invisible">EjmXxrXxv93oK</span><span class="ellipsis"></span></a></b> <b>(二维码自动识别)</b><br><b>音频发布在喜马拉雅上“区块链杂谈 (第2季)“</b></p><p><b>宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。</b></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
