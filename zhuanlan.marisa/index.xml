<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Wed, 26 Jun 2019 01:57:23 +0800</lastBuildDate>
<item>
<title>MLsub大概是个什么鬼.三</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-06-25-70664217.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/70664217&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50d5e0dadc4d32a2414185f712f8c530_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;这一章我们重新整理一下之前的类型系统 , 因为之前定义的类型系统并不是特别的细化,所以这回我们将根据上回的类型系统添加细节&lt;/p&gt;&lt;p&gt;ML语言的优点是表达式只用写一次 , 然后使用&lt;b&gt;let&lt;/b&gt;可以在不同类型下使用多次,打个比方&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=let+%5C+g+%3D+%5Clambda+x.x+%5C+in+%5C+%28...g...g...%29&quot; alt=&quot;let \ g = \lambda x.x \ in \ (...g...g...)&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;g&lt;/b&gt;函数就会被类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha.%5Calpha+%5Crightarrow+%5Calpha&quot; alt=&quot;\forall \alpha.\alpha \rightarrow \alpha&quot; eeimg=&quot;1&quot;/&gt; 约束然后&lt;b&gt;g&lt;/b&gt;就可以被当成&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_n+%5Crightarrow+%5Ctau_n&quot; alt=&quot;\tau_n \rightarrow \tau_n&quot; eeimg=&quot;1&quot;/&gt;但是 , 假如这个类型不能完全的泛化就操蛋了 就比如&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+f.let+%5C+g+%3D+%5Clambda+x.if+%5C+f+%5C+x+%5C+then+%5C+x+%5C+else+%5C+x+%5C+in+%5C+%28...g...g...%29&quot; alt=&quot;\lambda f.let \ g = \lambda x.if \ f \ x \ then \ x \ else \ x \ in \ (...g...g...)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;假如我们有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma%28f%29+%3D+%5Calpha+%5Crightarrow+bool&quot; alt=&quot;\Gamma(f) = \alpha \rightarrow bool&quot; eeimg=&quot;1&quot;/&gt;那么&lt;b&gt;g&lt;/b&gt;的类型就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+%5Crightarrow+%5Calpha&quot; alt=&quot;\alpha \rightarrow \alpha&quot; eeimg=&quot;1&quot;/&gt;但是这个就不能被完全的泛化因为 &lt;b&gt;g&lt;/b&gt;依赖于&lt;b&gt;f&lt;/b&gt;.&lt;/p&gt;&lt;p&gt;添加了子类型之后呢 , 就更加的复杂 , 假如我们有一个函数&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma%28f%29+%3D+%5Ctau_0+%5Crightarrow+bool&quot; alt=&quot;\Gamma(f) = \tau_0 \rightarrow bool&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;然后 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%2C+%5Ctau_2&quot; alt=&quot;\tau_1 , \tau_2&quot; eeimg=&quot;1&quot;/&gt; 都是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_0&quot; alt=&quot;\tau_0&quot; eeimg=&quot;1&quot;/&gt; 的子类型 , 为了保持 &lt;img src=&quot;https://www.zhihu.com/equation?tex=let%5C+x%3De_1%5C+in%5C+e_2&quot; alt=&quot;let\ x=e_1\ in\ e_2&quot; eeimg=&quot;1&quot;/&gt;的类型是合法的 , 我们就必须确定 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e_2%5Be_1%2Fx%5D&quot; alt=&quot;e_2[e_1/x]&quot; eeimg=&quot;1&quot;/&gt;(可替换) , 我们就必须让上边的类型同时满足 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1%5Crightarrow%5Ctau_1&quot; alt=&quot;\tau_1\rightarrow\tau_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_2%5Crightarrow%5Ctau_2&quot; alt=&quot;\tau_2\rightarrow\tau_2&quot; eeimg=&quot;1&quot;/&gt;但是&lt;b&gt;g&lt;/b&gt;的类型是单调的 , 所以我们就必须满足这样的一个东西&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha+%5C+where%5C+%5Calpha+%5Cleq+%5Ctau_0.%5Calpha+%5Crightarrow+%5Calpha&quot; alt=&quot;\forall \alpha \ where\ \alpha \leq \tau_0.\alpha \rightarrow \alpha&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;所以是时候需要重新调整一下类型检查的规则了!&lt;/p&gt;&lt;h2&gt;类型模板&lt;/h2&gt;&lt;p&gt;根据&lt;b&gt;TrifonovSmith&lt;/b&gt;和&lt;b&gt;Pottier&lt;/b&gt;的规则我们把这个新的规则称为&lt;b&gt;Lambda-lifted&lt;/b&gt;, 我们使用一个新的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B%5CDelta%5D%5Ctau&quot; alt=&quot;[\Delta]\tau&quot; eeimg=&quot;1&quot;/&gt;其 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CDelta&quot; alt=&quot;\Delta&quot; eeimg=&quot;1&quot;/&gt; 是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+-+bound&quot; alt=&quot;\lambda - bound&quot; eeimg=&quot;1&quot;/&gt; 类型变量的前结束映射 , 这就阻止了自由变量的诞生 , 使得所有的变量都隐士的被泛化 , 然后我们就可以扔掉 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall&quot; alt=&quot;\forall&quot; eeimg=&quot;1&quot;/&gt; 了 , 所有的类型都现实的携带他们的依赖信息(但是这并不叫依赖类型)这个我们叫他 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda-bound%5C+programme%5C+variables&quot; alt=&quot;\lambda-bound\ programme\ variables&quot; eeimg=&quot;1&quot;/&gt;虽然没有子类型的普通&lt;b&gt;ML&lt;/b&gt;没有这方面的问题就是了...&lt;/p&gt;&lt;p&gt;现在我们就可以给之前的那个&lt;b&gt;g&lt;/b&gt;赋予类型了&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bf%3A%5Calpha%5Crightarrow%5Cbeta%5D%5Calpha+%5Crightarrow+%5Calpha&quot; alt=&quot;[f:\alpha\rightarrow\beta]\alpha \rightarrow \alpha&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;嗯!看起来他是对的~ 为了重新制定规则 , 我们假设所有的表达式都有类型 , 其次通过了&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+-renaming&quot; alt=&quot;\alpha -renaming&quot; eeimg=&quot;1&quot;/&gt; , 他的绑定是单一的(这个是为了避免一个叫shadowing的东西) , 所以我们就 把&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt;分成了两个部分 , 一个是单态的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CDelta&quot; alt=&quot;\Delta&quot; eeimg=&quot;1&quot;/&gt; , 另一个是多态的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CPi&quot; alt=&quot;\Pi&quot; eeimg=&quot;1&quot;/&gt;  , 其 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CDelta&quot; alt=&quot;\Delta&quot; eeimg=&quot;1&quot;/&gt;映射类型的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+-+bound&quot; alt=&quot;\lambda - bound&quot; eeimg=&quot;1&quot;/&gt;到单态类型 , 然后 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CPi&quot; alt=&quot;\Pi&quot; eeimg=&quot;1&quot;/&gt; 呢就是处理&lt;b&gt;let&lt;/b&gt;到一个多态的类型 , 下面是类型规则&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CDelta+%3A%3A%3D+%5Cin+%7C+%5CDelta++%2C++x%3A%5Ctau%5C%5C+%5CPi+%3A%3A%3D+%5Cin+%7C+%5CPi+%2C+%5Chat%7Bx%7D%3A%5B%5CDelta%5D%5Ctau&quot; alt=&quot;\Delta ::= \in | \Delta  ,  x:\tau\\ \Pi ::= \in | \Pi , \hat{x}:[\Delta]\tau&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;所以呢 , 我们可以推出这个东西 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CPi+%5CVdash+e%3A%5B%5CDelta%5D%5Ctau&quot; alt=&quot;\Pi \Vdash e:[\Delta]\tau&quot; eeimg=&quot;1&quot;/&gt; , 同时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CDelta_1+%5Csqcap+%5CDelta_2&quot; alt=&quot;\Delta_1 \sqcap \Delta_2&quot; eeimg=&quot;1&quot;/&gt;标志了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=dom%5C+%5CDelta+%3D+dom%5C+%5CDelta_1+%5Ccup+dom%5C+%5CDelta_2&quot; alt=&quot;dom\ \Delta = dom\ \Delta_1 \cup dom\ \Delta_2&quot; eeimg=&quot;1&quot;/&gt; , 同时呢 , 满足 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CDelta%28x%29%3D%5CDelta_1%28x%29%5Csqcap%5CDelta_2%28x%29&quot; alt=&quot;\Delta(x)=\Delta_1(x)\sqcap\Delta_2(x)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;通常情况下 , 这个转换都会让 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CDelta&quot; alt=&quot;\Delta&quot; eeimg=&quot;1&quot;/&gt;的范围乱七八飞 , 除了new(SUB)规则使用的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cleq%5E%5Cforall&quot; alt=&quot;\leq^\forall&quot; eeimg=&quot;1&quot;/&gt;, 这个结合了子类型和类型变量的实例化的过程 , 这个呢...假设这个子类型是平凡的(我知道 , 数学家骂人都说你是个平凡的(AKA.&lt;b&gt;trivial&lt;/b&gt;) , 这里的意思是子类型和父类型相等) , 这个情况下呢&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cleq%5E%5Cforall&quot; alt=&quot;\leq^\forall&quot; eeimg=&quot;1&quot;/&gt;关系就被简化成了&lt;b&gt;Hindley-Milner instantiation&lt;/b&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;理论六 &lt;/b&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvdash+e%3A%5Ctau%5C+iff+%5CVdash+e%3A%5B%5D%5Ctau&quot; alt=&quot;\vdash e:\tau\ iff \Vdash e:[]\tau&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;感谢我的上帝 , 这个是proof的!&lt;/p&gt;&lt;p&gt; 这个证明是使用了一个更强的理论 , 在不是空类型的情况下能用 , 这个的证明就是一个简单的常见的归纳虽然 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+&quot; alt=&quot;\Gamma &quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CPi%2F%5CDelta&quot; alt=&quot;\Pi/\Delta&quot; eeimg=&quot;1&quot;/&gt; 环境类型不太兼容&lt;/p&gt;&lt;p&gt;根据之前的证明 , 我们可以写一下新的类型规则了&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B%5CDelta%5D%5Ctau%5Cleq%5E%5Cforall%5B%5CDelta%27%5D%5Ctau%27%5C+iff%5C+dom%28%5CDelta%29+%5Csubseteq+dom%28%5CDelta%27%29%5C%5C+and%5C+%5CDelta%27%28x%29%5Cleq+%5Crho%28%5CDelta%28x%29%29%5C+in+%5C+%5Cforall+x.x%5Cin+dom%28%5CDelta%29%5C%5C+and%5C+%5Crho%28%5Ctau%29%5Cleq+%5Ctau%27+%2C+for%5C+some%5C+substitution%5C+%5Crho%5C%5C&quot; alt=&quot;[\Delta]\tau\leq^\forall[\Delta&amp;#39;]\tau&amp;#39;\ iff\ dom(\Delta) \subseteq dom(\Delta&amp;#39;)\\ and\ \Delta&amp;#39;(x)\leq \rho(\Delta(x))\ in \ \forall x.x\in dom(\Delta)\\ and\ \rho(\tau)\leq \tau&amp;#39; , for\ some\ substitution\ \rho\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28VAR-%5CPi%29%5Cqquad+%5Cfrac%7B%7D%7B%5CPi%5CVdash%5Chat%7Bx%7D%3A%5B%5CDelta%5D%5Ctau%7D%5CPi%28%5Chat%7Bx%7D%29%3D%5B%5CDelta%5D%5Ctau%5C%5C+%28VAR-%5CDelta%29%5Cqquad%5Cfrac%7B%7D%7B%5CPi%5CVdash+x%3A%5Bx%3A%5Ctau%5D%5Ctau%7D%5C%5C+%28ABS%29%5Cqquad%5Cfrac%7B%5CPi%5CVdash+e%3A%5B%5CDelta+%2C+x%3A%5Ctau%5D%5Ctau%27%7D%7B%5CPi+%5CVdash+%5Clambda+x.e%3A%5B%5CDelta%5D%5Ctau%5Crightarrow%5Ctau%27%7D%5C%5C+%28APP%29%5Cqquad%5Cfrac%7B%5CPi%5CVdash+e_1%3A%5B%5CDelta%5D%5Ctau%5Crightarrow%5Ctau%27%5Cquad%5CPi%5CVdash+e_2%3A%5B%5CDelta%5D%5Ctau%7D%7B%5CPi+%5CVdash+e_1%5C+e_2%3A%5B%5CDelta%5D%5Ctau%27%7D%5C%5C+%28LET%29%5Cqquad%5Cfrac%7B%5CPi%5CVdash+e_1%5B%5CDelta_1%5D%5Ctau_1%5Cquad%5CPi+%2C+%5Chat%7Bx%7D%3A%5B%5CDelta_1%5D%5Ctau_1+%5CVdash+e_2%3A%5B%5CDelta_2%5D%5Ctau_2%7D%7B+++++%5CPi%5CVdash+let%5C+%5Chat%7Bx%7D%3De_1%5C+in+%5C+e_2%3A%5B%5CDelta_1%5Csqcap%5CDelta_2%5D%5Ctau_2++%7D%5C%5C+%28PROJ%29%5Cqquad%5Cfrac%7B%5CPi%5CVdash+e%3A%5B%5CDelta%5D%5C%7Bl%3A%5Ctau%5C%7D%7D%7B%5CPi%5CVdash+e.l%3A%5B%5CDelta%5D%5Ctau%7D%5C%5C+%28SUB%29%5Cqquad%5Cfrac%7B%5CPi%5CVdash+e%3A%5B%5CDelta%5D%5Ctau%7D%7B%5CPi%5CVdash+e%3A%5B%5CDelta%27%5D%5Ctau%27%7D%5B%5CDelta%5D%5Ctau%5Cleq%5E%5Cforall%5B%5CDelta%27%5D%5Ctau%27&quot; alt=&quot;(VAR-\Pi)\qquad \frac{}{\Pi\Vdash\hat{x}:[\Delta]\tau}\Pi(\hat{x})=[\Delta]\tau\\ (VAR-\Delta)\qquad\frac{}{\Pi\Vdash x:[x:\tau]\tau}\\ (ABS)\qquad\frac{\Pi\Vdash e:[\Delta , x:\tau]\tau&amp;#39;}{\Pi \Vdash \lambda x.e:[\Delta]\tau\rightarrow\tau&amp;#39;}\\ (APP)\qquad\frac{\Pi\Vdash e_1:[\Delta]\tau\rightarrow\tau&amp;#39;\quad\Pi\Vdash e_2:[\Delta]\tau}{\Pi \Vdash e_1\ e_2:[\Delta]\tau&amp;#39;}\\ (LET)\qquad\frac{\Pi\Vdash e_1[\Delta_1]\tau_1\quad\Pi , \hat{x}:[\Delta_1]\tau_1 \Vdash e_2:[\Delta_2]\tau_2}{     \Pi\Vdash let\ \hat{x}=e_1\ in \ e_2:[\Delta_1\sqcap\Delta_2]\tau_2  }\\ (PROJ)\qquad\frac{\Pi\Vdash e:[\Delta]\{l:\tau\}}{\Pi\Vdash e.l:[\Delta]\tau}\\ (SUB)\qquad\frac{\Pi\Vdash e:[\Delta]\tau}{\Pi\Vdash e:[\Delta&amp;#39;]\tau&amp;#39;}[\Delta]\tau\leq^\forall[\Delta&amp;#39;]\tau&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这个就使得&lt;b&gt;MLsub&lt;/b&gt;带上子类型后和&lt;b&gt;ML&lt;/b&gt;有些定义并不太一样 , 就比如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B%5CDelta_1%5D%5Ctau_1&quot; alt=&quot;[\Delta_1]\tau_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B%5CDelta_2%5D%5Ctau_2&quot; alt=&quot;[\Delta_2]\tau_2&quot; eeimg=&quot;1&quot;/&gt;我们说他们是相等当他们互相归入时.但是在我们蠢萌的&lt;b&gt;ML&lt;/b&gt;里两个类型相等仅当他们看起来一样的时候.&lt;/p&gt;&lt;p&gt;(这是虽然对的 , 但是蠢萌 , 就好比我说鸭子和一只鸟呱呱叫还喜欢游泳&lt;b&gt;ML&lt;/b&gt;告诉我他俩不相等一样) &lt;/p&gt;&lt;p&gt;我们拿&lt;b&gt;choose&lt;/b&gt;函数举例子&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=1.%5Cqquad%5B%5D%5Calpha%5Crightarrow%5Calpha%5Crightarrow%5Calpha%5C%5C+2.%5Cqquad%5B%5D%5Cbeta%5Crightarrow%5Cgamma%5Crightarrow%28%5Cbeta%5Csqcup%5Cgamma%29&quot; alt=&quot;1.\qquad[]\alpha\rightarrow\alpha\rightarrow\alpha\\ 2.\qquad[]\beta\rightarrow\gamma\rightarrow(\beta\sqcup\gamma)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;第一个在我们蠢萌的&lt;b&gt;ML&lt;/b&gt;里面就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha.%5Calpha%5Crightarrow%5Calpha%5Crightarrow%5Calpha&quot; alt=&quot;\forall \alpha.\alpha\rightarrow\alpha\rightarrow\alpha&quot; eeimg=&quot;1&quot;/&gt; , 第二个就引入了子类型 , 但是我们可以发现其实他们的定义时一样的但是第二个更加的细化 , 所以 &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5B%5D%5Cbeta%5Crightarrow%5Cgamma%5Crightarrow%28%5Cbeta%5Csqcup%5Cgamma%29%5Cleq%5E%5Cforall%5B%5D%5Calpha%5Crightarrow%5Calpha%5Crightarrow%5Calpha+&quot; alt=&quot;[]\beta\rightarrow\gamma\rightarrow(\beta\sqcup\gamma)\leq^\forall[]\alpha\rightarrow\alpha\rightarrow\alpha &quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;当我们断定 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbeta+%3D%5Cgamma+%3D%5Calpha&quot; alt=&quot;\beta =\gamma =\alpha&quot; eeimg=&quot;1&quot;/&gt;时 , 我们甚至可以反过来写因为相等的. 再举一些蠢萌的&lt;b&gt;ML&lt;/b&gt;和我们&lt;b&gt;MLsub&lt;/b&gt;不一样的地方 , 假如我有第一个式子 , 在&lt;b&gt;ML&lt;/b&gt;里 , 输入的两个类型不许是一样的 , 但是在&lt;b&gt;MLsub&lt;/b&gt;里可以不一样 , 为什么呢? 因为对于任何&lt;i&gt;α&lt;/i&gt;我们都接受任意&lt;i&gt;α&lt;/i&gt;&lt;/p&gt;&lt;h2&gt;极类型(我们之前提到过)&lt;/h2&gt;&lt;p&gt;这个呢我就用自己的话简单的解释一下了&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau%5E%2B&quot; alt=&quot;\tau^+&quot; eeimg=&quot;1&quot;/&gt;就是我们可以用作一个函数的输出的类型&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau%5E%2B+%3A%3A%3D+%5Ctau_1%5E-%5Crightarrow%5Ctau_2%5E%2B+%7C%5C%7Bl_1%3A%5Ctau_1%5E%2B+%2C+...+%2C+l_n%3A%5Ctau_n%5E%2B%5C%7D%7C%5Calpha%7C%5Ctau_1%5E%2B%5Csqcup%5Ctau_2%5E%2B%7C%5Cbot%7C%5Cmu+%5Calpha+.+%5Ctau%5E%2B&quot; alt=&quot;\tau^+ ::= \tau_1^-\rightarrow\tau_2^+ |\{l_1:\tau_1^+ , ... , l_n:\tau_n^+\}|\alpha|\tau_1^+\sqcup\tau_2^+|\bot|\mu \alpha . \tau^+&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这个确保了不会输出巨大无比的类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctop&quot; alt=&quot;\top&quot; eeimg=&quot;1&quot;/&gt;相反的 , &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau%5E-&quot; alt=&quot;\tau^-&quot; eeimg=&quot;1&quot;/&gt;就是用来输入的 ,  &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctop&quot; alt=&quot;\top&quot; eeimg=&quot;1&quot;/&gt;类型是允许的 , 同时避免引入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Csqcup&quot; alt=&quot;\sqcup&quot; eeimg=&quot;1&quot;/&gt; , 因为我们大多数的带有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctop&quot; alt=&quot;\top&quot; eeimg=&quot;1&quot;/&gt;类型的输入的时候我们都不会用到233333&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau%5E-+%3A%3A%3D+%5Ctau_1%5E%2B%5Crightarrow%5Ctau_2%5E-+%7C%5C%7Bl_1%3A%5Ctau_1%5E-+%2C+...+%2C+l_n%3A%5Ctau_n%5E-%5C%7D%7C%5Calpha%7C%5Ctau_1%5E-%5Csqcap%5Ctau_2%5E-%7C%5Ctop%7C%5Cmu+%5Calpha+.+%5Ctau%5E-&quot; alt=&quot;\tau^- ::= \tau_1^+\rightarrow\tau_2^- |\{l_1:\tau_1^- , ... , l_n:\tau_n^-\}|\alpha|\tau_1^-\sqcap\tau_2^-|\top|\mu \alpha . \tau^-&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;hr/&gt;&lt;p&gt;这个是我在飞机上写的 , 我在吃饭前喝了一瓶威士忌 , 然后晕机吐了 , 吃完饭后肚子不舒服又吐了一次 , 多亏我这会买的商务舱座位宽敞 , 我可以把饭放在脚下跑去厕所 , 这回可能有很多不对因为到现在我整个人都是晕的(醉酒+晕机).&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>柠檬浣熊</author>
<guid isPermaLink="false">2019-06-25-70664217</guid>
<pubDate>Tue, 25 Jun 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>MLsub大概是个什么鬼.二</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-06-21-69889087.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69889087&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9d6722460086c35f984571254f16343_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;上回我们讲完了类型推导,&lt;b&gt;HM&lt;/b&gt;类型推断中遇到的所有的困难都是来自于自身的短板,但是不使用子类型我们也可以使用无数的类型进行类型海作战达到这一目的,显然这是我们开发者和用户都不想看到的 (瞄一眼我们的垃圾JAWA)&lt;/p&gt;&lt;p&gt;因为&lt;b&gt;ML&lt;/b&gt;的变体太多了&lt;b&gt;MLf  &lt;/b&gt;,  &lt;b&gt;MLext-row  &lt;/b&gt;,  &lt;b&gt;MLrec  &lt;/b&gt;等 所以不介意我们再多加一种实现呢(笑嘻嘻)&lt;/p&gt;&lt;p&gt;所以下面就是作者给&lt;b&gt;MLsub&lt;/b&gt;定义的语法&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=e+%3A%3A%3D+x%5C%5C+%7C%5Clambda+x.e%5C%5C+%7Ce_1+e_2%5C%5C+%7C%5C%7Bl_1+%3D+e_1%2Cl_2%3De_2%2C...%2Cl_n+%3D+e_n%5C%7D%5C%5C+%7Ce.l%5C%5C+%7C%5Chat%7Bx%7D%5C%5C+%7Clet+%5C+%5Chat%7Bx%7D+%5C+%3D+%5C+e_1+%5C+in+%5C+e_2&quot; alt=&quot;e ::= x\\ |\lambda x.e\\ |e_1 e_2\\ |\{l_1 = e_1,l_2=e_2,...,l_n = e_n\}\\ |e.l\\ |\hat{x}\\ |let \ \hat{x} \ = \ e_1 \ in \ e_2&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;解释一下啊,&lt;b&gt;{}&lt;/b&gt;包裹的是一个记录的构造器&lt;/p&gt;&lt;p&gt;然后环境变量的规则是&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%3A%3A%3D+e%5C%5C+%7C%5CGamma%2Cx%3A%5Ctau%5C%5C+%7C%5CGamma%2C%5Chat%7Bx%7D%3A%5Cforall%5Cvec%5Calpha.%5Ctau&quot; alt=&quot;\Gamma ::= e\\ |\Gamma,x:\tau\\ |\Gamma,\hat{x}:\forall\vec\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;定义类型&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;基本的有函数类型,记录类型,我可以添加基础的布尔类型,我们还有最大最小类型,还有那个上限下限类型运算符.&lt;/p&gt;&lt;p&gt;使用递归类型和&lt;b&gt;subtyping&lt;/b&gt;还有最大最小类型我们定义一个&lt;b&gt;Y组合子&lt;/b&gt;试试&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Y%28%5Clambda+f.%5Clambda+x.f%29&quot; alt=&quot;Y(\lambda f.\lambda x.f)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这个的类型我们写作 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctop+%5Crightarrow+%28%5Ctop+%5Crightarrow+%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow....%29&quot; alt=&quot;\top \rightarrow (\top \rightarrow (\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow....)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;很好,写不下&lt;/p&gt;&lt;p&gt;那么我们姑且把&lt;i&gt;α&lt;/i&gt;当作递归类型处理吧,所以这个东西的类型是: &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctop+%5Crightarrow+%5Calpha&quot; alt=&quot;\top \rightarrow \alpha&quot; eeimg=&quot;1&quot;/&gt; 为了写的爽,干脆类型的语法也就这么来吧&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau+%3A%3A%3D+%5Ctau_1+%5Crightarrow+%5Ctau_2%5C%5C+%7C%5C%7Bl1%3A%5Ctau_1%2C...%5C%7D%5C%5C+%7C%5Calpha%5C%5C+%7C%5Ctop%5C%5C+%7C%5Cbot%5C%5C+%7C%5Ctau+%5Csqcap%5Ctau%5C%5C+%7C%5Ctau+%5Csqcup+%5Ctau&quot; alt=&quot;\tau ::= \tau_1 \rightarrow \tau_2\\ |\{l1:\tau_1,...\}\\ |\alpha\\ |\top\\ |\bot\\ |\tau \sqcap\tau\\ |\tau \sqcup \tau&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;好了,我们有了类型构造的语法,那么我们想一下,对于这些记录(record)该怎么搞&lt;/p&gt;&lt;p&gt;如果我们有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bl_1%3A%5Ctau_1%2Cl_2%3A%5Ctau_2%5C%7D&quot; alt=&quot;\{l_1:\tau_1,l_2:\tau_2\}&quot; eeimg=&quot;1&quot;/&gt;我们可以写成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D&quot; alt=&quot;\{f\}&quot; eeimg=&quot;1&quot;/&gt;其 &lt;img src=&quot;https://www.zhihu.com/equation?tex=dom%5C+f+%3D+%5C%7Bl_1%2Cl_2%5C%7D&quot; alt=&quot;dom\ f = \{l_1,l_2\}&quot; eeimg=&quot;1&quot;/&gt; 我们就可以用这个操作获取类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28l_1%29+%3D+%5Ctau_1&quot; alt=&quot;f(l_1) = \tau_1&quot; eeimg=&quot;1&quot;/&gt;,好的这个问题处理完了,我们接着处理函数的问题.&lt;/p&gt;&lt;p&gt;我们可以让语法树的类型部分是无限的,但是我们需要采用限制操作符就不是,比如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=bool+%5Crightarrow+%28bool+%5Crightarrow%28bool+%5Crightarrow%28bool+%5Crightarrow%28....%29%29&quot; alt=&quot;bool \rightarrow (bool \rightarrow(bool \rightarrow(bool \rightarrow(....))&quot; eeimg=&quot;1&quot;/&gt;是合法的代码但是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=bool+%5Csqcap+%28bool+%5Csqcap%28bool+%5Csqcap%28bool+%5Csqcap%28....%29%29&quot; alt=&quot;bool \sqcap (bool \sqcap(bool \sqcap(bool \sqcap(....))&quot; eeimg=&quot;1&quot;/&gt;并不是合法的代码.&lt;/p&gt;&lt;p&gt;但是一般人是写不出来这种无限长的类型定义的,所以我们使用 &lt;b&gt;polar type&lt;/b&gt;进行操作,现在这一章先不讲,这是一种有限类型的子集,你知道方便写和推导就行了.&lt;/p&gt;&lt;p&gt;那么接着上一章提到的&lt;b&gt;分配格&lt;/b&gt;来讲,我们也设计一套规则&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau+%5Csqcup+%5Ctau+%5Cequiv+%5Ctau+%5Cqquad+%5Ctau+%5Csqcap+%5Ctau+%5Cequiv+%5Ctau%5C%5C+%5Ctau_1+%5Csqcup+%5Ctau_2+%5Cequiv+%5Ctau_2+%5Csqcup+%5Ctau_1+%5Cqquad+%5Ctau_1+%5Csqcap+%5Ctau_2+%5Cequiv+%5Ctau_2+%5Csqcap+%5Ctau_1%5C%5C+%5Ctau_1+%5Csqcup+%28%5Ctau_2+%5Csqcup+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcup%5Ctau_2%29+%5Csqcup+%5Ctau_1+%5Cqquad+%5Ctau_1+%5Csqcap+%28%5Ctau_2+%5Csqcap+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcap%5Ctau_2%29+%5Csqcap+%5Ctau_1%5C%5C+%5Ctau_1+%5Csqcup+%28%5Ctau_1+%5Csqcap+%5Ctau_2%29+%5Cequiv+%5Ctau_1+%5Cqquad+%5Ctau_1+%5Csqcap+%28%5Ctau_1+%5Csqcup+%5Ctau_2%29+%5Cequiv+%5Ctau_1%5C%5C+%5Cbot+%5Csqcup+%5Ctau+%5Cequiv+%5Ctau+%5Cqquad+%5Cbot+%5Csqcap+%5Ctau+%5Cequiv+%5Cbot%5C%5C+%5Ctop+%5Csqcup+%5Ctau+%5Cequiv+%5Ctop+%5Cqquad+%5Ctop+%5Csqcap+%5Ctau+%5Cequiv+%5Ctau%5C%5C+%5Ctau_1+%5Csqcup+%28%5Ctau_2+%5Csqcap+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcup%5Ctau_2%29%5Csqcap%28%5Ctau_1%5Csqcup%5Ctau_3%29%5C%5C+%5Ctau_1+%5Csqcap+%28%5Ctau_2+%5Csqcup+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcap%5Ctau_2%29%5Csqcup%28%5Ctau_1%5Csqcap%5Ctau_3%29%5C%5C&quot; alt=&quot;\tau \sqcup \tau \equiv \tau \qquad \tau \sqcap \tau \equiv \tau\\ \tau_1 \sqcup \tau_2 \equiv \tau_2 \sqcup \tau_1 \qquad \tau_1 \sqcap \tau_2 \equiv \tau_2 \sqcap \tau_1\\ \tau_1 \sqcup (\tau_2 \sqcup \tau_3) \equiv (\tau_1\sqcup\tau_2) \sqcup \tau_1 \qquad \tau_1 \sqcap (\tau_2 \sqcap \tau_3) \equiv (\tau_1\sqcap\tau_2) \sqcap \tau_1\\ \tau_1 \sqcup (\tau_1 \sqcap \tau_2) \equiv \tau_1 \qquad \tau_1 \sqcap (\tau_1 \sqcup \tau_2) \equiv \tau_1\\ \bot \sqcup \tau \equiv \tau \qquad \bot \sqcap \tau \equiv \bot\\ \top \sqcup \tau \equiv \top \qquad \top \sqcap \tau \equiv \tau\\ \tau_1 \sqcup (\tau_2 \sqcap \tau_3) \equiv (\tau_1\sqcup\tau_2)\sqcap(\tau_1\sqcup\tau_3)\\ \tau_1 \sqcap (\tau_2 \sqcup \tau_3) \equiv (\tau_1\sqcap\tau_2)\sqcup(\tau_1\sqcap\tau_3)\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;...是不是跟布尔运算规则一个样&lt;br/&gt;下面是函数和记录的构造函数限制&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Ctau_1+%5Crightarrow+%5Ctau_2%29%5Csqcup%28%5Ctau_1%27+%5Crightarrow+%5Ctau_2%27%29+%5Cequiv+%28%5Ctau_1%5Csqcap%5Ctau_1%27%29%5Crightarrow%28%5Ctau_2%5Csqcup%5Ctau_2%27%29%5C%5C+%28%5Ctau_1+%5Crightarrow+%5Ctau_2%29%5Csqcap%28%5Ctau_1%27+%5Crightarrow+%5Ctau_2%27%29+%5Cequiv+%28%5Ctau_1%5Csqcup%5Ctau_1%27%29%5Crightarrow%28%5Ctau_2%5Csqcap%5Ctau_2%27%29%5C%5C++&quot; alt=&quot;(\tau_1 \rightarrow \tau_2)\sqcup(\tau_1&amp;#39; \rightarrow \tau_2&amp;#39;) \equiv (\tau_1\sqcap\tau_1&amp;#39;)\rightarrow(\tau_2\sqcup\tau_2&amp;#39;)\\ (\tau_1 \rightarrow \tau_2)\sqcap(\tau_1&amp;#39; \rightarrow \tau_2&amp;#39;) \equiv (\tau_1\sqcup\tau_1&amp;#39;)\rightarrow(\tau_2\sqcap\tau_2&amp;#39;)\\  &quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D+%5Csqcup+%5C%7Bg%5C%7D+%5Cequiv+%5C%7Bh%5C%7D%5C%5C+%5Cqquad+where+%5C++dom+%5C+h++%3D+dom+%5C+f+%5Ccap+dom+%5C+g%5C%5C+%5Cqquad+and+%5C+h%28l%29+%3D+f%28l%29+%5Csqcup+g%28l%29%5C%5C&quot; alt=&quot;\{f\} \sqcup \{g\} \equiv \{h\}\\ \qquad where \  dom \ h  = dom \ f \cap dom \ g\\ \qquad and \ h(l) = f(l) \sqcup g(l)\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D+%5Csqcap+%5C%7Bg%5C%7D+%5Cequiv+%5C%7Bh%5C%7D%5C%5C+%5Cqquad+where+%5C++dom+%5C+h++%3D+dom+%5C+f+%5Ccup+dom+%5C+g%5C%5C+%5Cqquad+and+%5C+h%28l%29+%3D+%5Cleft%5C%7B+++++%5Cbegin%7Bmatrix%7D+++++++++++++f%28l%29+%5Csqcap+g%28l%29+%5Cquad+if+%5C+l+%5C+%5Cin+dom+%5C+f+%5Ccap+dom+%5C+g%5C%5C+++++++++++++f%28l%29+%5Cqquad+if+%5C+l+%5C+%5Cin+dom+%5C+f+-+dom+%5C+g%5C%5C+++++++++++++g%28l%29+%5Cqquad+if+%5C+l+%5C+%5Cin+dom+%5C+g+-+dom+%5C+f%5C%5C+++++%5Cend%7Bmatrix%7D+++++%5Cright%5C%7D&quot; alt=&quot;\{f\} \sqcap \{g\} \equiv \{h\}\\ \qquad where \  dom \ h  = dom \ f \cup dom \ g\\ \qquad and \ h(l) = \left\{     \begin{matrix}             f(l) \sqcap g(l) \quad if \ l \ \in dom \ f \cap dom \ g\\             f(l) \qquad if \ l \ \in dom \ f - dom \ g\\             g(l) \qquad if \ l \ \in dom \ g - dom \ f\\     \end{matrix}     \right\}&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;递归类型&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;MLsub&lt;/b&gt;作为一个牛*的语言,肯定是要支持递归类型的!&lt;/p&gt;&lt;p&gt;经典的递归类型的处理方法是:首先我们有一个类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%5Calpha.%5Ctau&quot; alt=&quot;\mu\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt;我们会把他当成一个映射的不动点 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau%27%29+%3D+%5Ctau%5B%5Ctau%27%2F%5Calpha%5D&quot; alt=&quot;\phi(\tau&amp;#39;) = \tau[\tau&amp;#39;/\alpha]&quot; eeimg=&quot;1&quot;/&gt;这个就确定了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu&quot; alt=&quot;\mu&quot; eeimg=&quot;1&quot;/&gt;的约束和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha&quot; alt=&quot;\alpha&quot; eeimg=&quot;1&quot;/&gt;,并获得了一下的推理原则:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau%5B%5Ctau_0%2F%5Calpha%5D+%3D+%5Ctau_0+%5CRightarrow+%5Cmu%5Calpha.%5Ctau+%3D+%5Ctau_0&quot; alt=&quot;\tau[\tau_0/\alpha] = \tau_0 \Rightarrow \mu\alpha.\tau = \tau_0&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是,我们并不是传统的&lt;b&gt;ML&lt;/b&gt;我们是&lt;b&gt;MLsub&lt;/b&gt;是有&lt;b&gt;subtyping&lt;/b&gt;的&lt;b&gt;ML&lt;/b&gt;,所以这个不⭐ 我们需要一种可以支持&lt;b&gt;subtyping&lt;/b&gt;的比如这样 &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau%5B%5Ctau_0%2F%5Calpha%5D+%5Cleq+%5Ctau_0+%5CRightarrow+%5Cmu%5Calpha.%5Ctau+%5Cleq+%5Ctau_0&quot; alt=&quot;\tau[\tau_0/\alpha] \leq \tau_0 \Rightarrow \mu\alpha.\tau \leq \tau_0&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这个就需要 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%5Calpha.%5Ctau&quot; alt=&quot;\mu\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt;是一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cphi&quot; alt=&quot;\phi&quot; eeimg=&quot;1&quot;/&gt;最小的不动点, 简单(数学)的术语来描述就是映射 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau%27%29+%3D+%5Ctau%5B%5Ctau%27%2F%5Calpha%5D&quot; alt=&quot;\phi(\tau&amp;#39;) = \tau[\tau&amp;#39;/\alpha]&quot; eeimg=&quot;1&quot;/&gt;单调的时候 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha%2C%5Ctau&quot; alt=&quot;\alpha,\tau&quot; eeimg=&quot;1&quot;/&gt;协变,用人话讲就是所有的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha&quot; alt=&quot;\alpha&quot; eeimg=&quot;1&quot;/&gt;都出现在偶数的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Crightarrow&quot; alt=&quot;\rightarrow&quot; eeimg=&quot;1&quot;/&gt;的左侧. &lt;br/&gt;这里带来了两个引论: &lt;/p&gt;&lt;p&gt;&lt;b&gt;引论一&lt;/b&gt;,如果&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha%2C%5Ctau&quot; alt=&quot;\alpha,\tau&quot; eeimg=&quot;1&quot;/&gt;协变,那么&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau%27%29+%3D+%5Ctau%5B%5Ctau%27%2F%5Calpha%5D&quot; alt=&quot;\phi(\tau&amp;#39;) = \tau[\tau&amp;#39;/\alpha]&quot; eeimg=&quot;1&quot;/&gt;就是有一个最小的前不动点,那么我们可以写作 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%5E%2B%5Calpha.%5Ctau&quot; alt=&quot;\mu^+\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt; 相对的,最大的后不动点就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%5E-%5Calpha.%5Ctau&quot; alt=&quot;\mu^-\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt;但是,残念有问题 &lt;i&gt;α&lt;/i&gt;和&lt;i&gt;α&lt;/i&gt;是逆变的,所以我们需要引入&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%5C%5Cmu%5E%2B%5Calpha.%5Ctau+%3D+%5Cbot%5C%5C%5Cmu%5E-%5Calpha.%5Ctau+%3D+%5Ctop%5C%5C&quot; alt=&quot;\\\mu^+\alpha.\tau = \bot\\\mu^-\alpha.\tau = \top\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;(您家的haskell就是这样的),那么假如所有的&lt;i&gt;α&lt;/i&gt;都有至少一种类型构造器,&lt;i&gt;α&lt;/i&gt;被&lt;i&gt;τ&lt;/i&gt;保护,这样凑合就能用了&lt;/p&gt;&lt;p&gt;&lt;b&gt;引论二&lt;/b&gt;,如果&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha%2C%5Ctau&quot; alt=&quot;\alpha,\tau&quot; eeimg=&quot;1&quot;/&gt;协变同时被他保护,那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%5E%2B%5Calpha.%5Ctau+%3D+%5Cmu%5E-%5Calpha.%5Ctau&quot; alt=&quot;\mu^+\alpha.\tau = \mu^-\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt;这种情况下&lt;i&gt;α&lt;/i&gt;没用 似乎看起来减少了需要处理的类型,那么就很好,然而有个叫&lt;b&gt;Bekic&lt;/b&gt;的科学家发现我们可以找到一种类型成立表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau+%5Cequiv+%5Ctau+%5Crightarrow+%5Ctau&quot; alt=&quot;\tau \equiv \tau \rightarrow \tau&quot; eeimg=&quot;1&quot;/&gt; (当然连我觉得都很扯,这都是什么烂七八糟的东西,不过人家有理有据,看看他是怎么搞得)所以按照他的思路我们可以写出这个东西 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%5C%5Ctau_1%3D%5Ctau_2+%5Crightarrow+%5Ctau_1+%5Cqquad+%5Ctau_2%3D%5Ctau_1+%5Crightarrow+%5Ctau_2%5C%5C&quot; alt=&quot;\\\tau_1=\tau_2 \rightarrow \tau_1 \qquad \tau_2=\tau_1 \rightarrow \tau_2\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;顺着这个思路带入&lt;i&gt;μ&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%5C%5Ctau_1%3D%5Cmu%5Calpha.%5Ctau_2+%5Crightarrow+%5Calpha+%5Cqquad+%5Ctau_2%3D%5Cmu%5Cbeta.%5Ctau_1+%5Crightarrow+%5Cbeta%5C%5C&quot; alt=&quot;\\\tau_1=\mu\alpha.\tau_2 \rightarrow \alpha \qquad \tau_2=\mu\beta.\tau_1 \rightarrow \beta\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;替换一下就可以得到&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%5C%5Ctau_1%3D%5Cmu%5Calpha.%28%5Cmu%5Cbeta.%5Calpha+%5Crightarrow+%5Cbeta%29+%5Crightarrow+%5Calpha+%5Cqquad+%5Ctau_2%3D%5Cmu%5Cbeta.%28%5Cmu%5Calpha.%5Cbeta+%5Crightarrow+%5Calpha%29+%5Crightarrow+%5Cbeta%5C%5C&quot; alt=&quot;\\\tau_1=\mu\alpha.(\mu\beta.\alpha \rightarrow \beta) \rightarrow \alpha \qquad \tau_2=\mu\beta.(\mu\alpha.\beta \rightarrow \alpha) \rightarrow \beta\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;然后我们说过这种情况下&lt;i&gt;α&lt;/i&gt;,&lt;i&gt;β&lt;/i&gt;没蛋的用,所以利用模式匹配总结一下&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%5Cequiv+%5Ctau_2&quot; alt=&quot;\tau_1 \equiv \tau_2&quot; eeimg=&quot;1&quot;/&gt;所以....推出来了这个脑残的表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau+%5Cequiv+%5Ctau+%5Crightarrow+%5Ctau&quot; alt=&quot;\tau \equiv \tau \rightarrow \tau&quot; eeimg=&quot;1&quot;/&gt;我们为了纪念他,给他放个特例叫他 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau_1%2C%5Ctau_2%29&quot; alt=&quot;\phi(\tau_1,\tau_2)&quot; eeimg=&quot;1&quot;/&gt;他的不动点就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%5C%5Cmu.%5Calpha.%5Cphi%28%5Cmu%5Cbeta.%5Cphi%28%5Calpha%2C%5Cbeta%29%2C%5Calpha%29%5C%5C&quot; alt=&quot;\\\mu.\alpha.\phi(\mu\beta.\phi(\alpha,\beta),\alpha)\\&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;我知道我知道,里面可以继续展开我就不展开了....&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;稳健性(Soundness)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们的&lt;b&gt;MLsub&lt;/b&gt;的&lt;b&gt;subtyping&lt;/b&gt;并不是一个由案例来定义的,同时靠着案例反演呀并不是一个非常有意义的操作(所以这就是我unsound的理由,咳咳咳) 实际上,仅仅给出 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%5Cleq+%5Ctau_2+%5Crightarrow+%5Ctau_3&quot; alt=&quot;\tau_1 \leq \tau_2 \rightarrow \tau_3&quot; eeimg=&quot;1&quot;/&gt;我们可以得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%3D+%5Cbot&quot; alt=&quot;\tau_1 = \bot&quot; eeimg=&quot;1&quot;/&gt; 或者是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%3D+%28%5Calpha+%5Crightarrow+%5Cbeta%29%5Csqcap+%5Calpha&quot; alt=&quot;\tau_1 = (\alpha \rightarrow \beta)\sqcap \alpha&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;引论三(反转性)&lt;/b&gt;, 如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1%5Crightarrow%5Ctau_2%5Cleq%5Ctau_1%27%5Crightarrow%5Ctau_2%27&quot; alt=&quot;\tau_1\rightarrow\tau_2\leq\tau_1&amp;#39;\rightarrow\tau_2&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1%27%5Cleq%5Ctau_1%2C%5Ctau_2%27%5Cleq%5Ctau_2&quot; alt=&quot;\tau_1&amp;#39;\leq\tau_1,\tau_2&amp;#39;\leq\tau_2&quot; eeimg=&quot;1&quot;/&gt;,如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D+%5Cleq+%5C%7Bg%5C%7D&quot; alt=&quot;\{f\} \leq \{g\}&quot; eeimg=&quot;1&quot;/&gt;则对于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=l+%5Cin+dom%5C+g&quot; alt=&quot;l \in dom\ g&quot; eeimg=&quot;1&quot;/&gt;里 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28l%29%5Cleq+g%28l%29&quot; alt=&quot;f(l)\leq g(l)&quot; eeimg=&quot;1&quot;/&gt;幸好这个有proof.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;理论四(进展性),&lt;/b&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvdash+e%3A%5Ctau&quot; alt=&quot;\vdash e:\tau&quot; eeimg=&quot;1&quot;/&gt; ,要么&lt;i&gt;e&lt;/i&gt;是个值,要么是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e+%5Crightarrow+e%27+forsome%5C+e&quot; alt=&quot;e \rightarrow e&amp;#39; forsome\ e&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;理论五(保留性)&lt;/b&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvdash+e%3A%5Ctau&quot; alt=&quot;\vdash e:\tau&quot; eeimg=&quot;1&quot;/&gt; ,同时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e+%5Crightarrow+e%27+forsome%5C+e&quot; alt=&quot;e \rightarrow e&amp;#39; forsome\ e&quot; eeimg=&quot;1&quot;/&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvdash+e%27%3A%5Ctau&quot; alt=&quot;\vdash e&amp;#39;:\tau&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;最后再吹一下牛逼的类型推导&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们知道&lt;b&gt;MLsub&lt;/b&gt;是一个非常的强大的东西,刚才我提到过&lt;b&gt;MLrec&lt;/b&gt;那么&lt;b&gt;MLsub&lt;/b&gt;是严格的包含了整个&lt;b&gt;MLrec&lt;/b&gt;的存在,所以看不懂很正常咳咳咳.&lt;/p&gt;&lt;p&gt;假如我们有个函数:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+f.%5Clambda+x.f%28f+x%29&quot; alt=&quot;\lambda f.\lambda x.f(f x)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;在一般的&lt;b&gt;ML&lt;/b&gt;下的类型回事这样式(shai)儿的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha.%28%5Calpha+%5Crightarrow+%5Calpha%29+%5Crightarrow+%5Calpha+%5Crightarrow+%5Calpha&quot; alt=&quot;\forall \alpha.(\alpha \rightarrow \alpha) \rightarrow \alpha \rightarrow \alpha&quot; eeimg=&quot;1&quot;/&gt; 我们&lt;b&gt;MLsub&lt;/b&gt;能带来更加符合直觉,更好看的类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha%2C%5Cbeta.%28%28%5Calpha+%5Csqcup+%5Cbeta%29%5Crightarrow+%5Cbeta%29%5Crightarrow%28%5Calpha+%5Crightarrow+%5Cbeta%29&quot; alt=&quot;\forall \alpha,\beta.((\alpha \sqcup \beta)\rightarrow \beta)\rightarrow(\alpha \rightarrow \beta)&quot; eeimg=&quot;1&quot;/&gt; 这个栗子不是特别突出&lt;/p&gt;&lt;p&gt;再举一个栗子,大家都知道这个函数吧 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+x.+xx&quot; alt=&quot;\lambda x. xx&quot; eeimg=&quot;1&quot;/&gt; 我们蠢萌的&lt;b&gt;ML&lt;/b&gt;没法举出这个东西的类型,但是我们&lt;b&gt;MLsub&lt;/b&gt;就可以差不多的推出来个这样的东西&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha%2C%5Cbeta.%28%28%5Calpha+%5Crightarrow+%5Cbeta%29%5Csqcap+%5Calpha%29%5Crightarrow+%5Cbeta&quot; alt=&quot;\forall \alpha,\beta.((\alpha \rightarrow \beta)\sqcap \alpha)\rightarrow \beta&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;一看,哇,漂亮对吧,一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Csqcap&quot; alt=&quot;\sqcap&quot; eeimg=&quot;1&quot;/&gt;就解决了这个&lt;i&gt;x&lt;/i&gt;的类型归属问题,同时解决了递归. &lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;这一章稍微有点长,有的没的的东西讲的有点多,还是老规矩,大佬觉得错了就赶紧评论&lt;/p&gt;</description>
<author>柠檬浣熊</author>
<guid isPermaLink="false">2019-06-21-69889087</guid>
<pubDate>Fri, 21 Jun 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>MLsub大概是个什么鬼.二</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-06-20-69889087.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69889087&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9d6722460086c35f984571254f16343_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;上回我们讲完了类型推导,&lt;b&gt;HM&lt;/b&gt;类型推断中遇到的所有的困难都是来自于自身的短板,但是不使用子类型我们也可以使用无数的类型进行类型海作战达到这一目的,显然这是我们开发者和用户都不想看到的 (瞄一眼我们的垃圾JAWA)&lt;/p&gt;&lt;p&gt;因为&lt;b&gt;ML&lt;/b&gt;的变体太多了&lt;b&gt;MLf  &lt;/b&gt;,  &lt;b&gt;MLext-row  &lt;/b&gt;,  &lt;b&gt;MLrec  &lt;/b&gt;等 所以不介意我们再多加一种实现呢(笑嘻嘻)&lt;/p&gt;&lt;p&gt;所以下面就是作者给&lt;b&gt;MLsub&lt;/b&gt;定义的语法&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=e+%3A%3A%3D+x%5C%5C+%7C%5Clambda+x.e%5C%5C+%7Ce_1+e_2%5C%5C+%7C%5C%7Bl_1+%3D+e_1%2Cl_2%3De_2%2C...%2Cl_n+%3D+e_n%5C%7D%5C%5C+%7Ce.l%5C%5C+%7C%5Chat%7Bx%7D%5C%5C+%7Clet+%5C+%5Chat%7Bx%7D+%5C+%3D+%5C+e_1+%5C+in+%5C+e_2&quot; alt=&quot;e ::= x\\ |\lambda x.e\\ |e_1 e_2\\ |\{l_1 = e_1,l_2=e_2,...,l_n = e_n\}\\ |e.l\\ |\hat{x}\\ |let \ \hat{x} \ = \ e_1 \ in \ e_2&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;解释一下啊,&lt;b&gt;{}&lt;/b&gt;包裹的是一个记录的构造器&lt;/p&gt;&lt;p&gt;然后环境变量的规则是&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%3A%3A%3D+e%5C%5C+%7C%5CGamma%2Cx%3A%5Ctau%5C%5C+%7C%5CGamma%2C%5Chat%7Bx%7D%3A%5Cforall%5Cvec%5Calpha.%5Ctau&quot; alt=&quot;\Gamma ::= e\\ |\Gamma,x:\tau\\ |\Gamma,\hat{x}:\forall\vec\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;定义类型&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;基本的有函数类型,记录类型,我可以添加基础的布尔类型,我们还有最大最小类型,还有那个上限下限类型运算符.&lt;/p&gt;&lt;p&gt;使用递归类型和&lt;b&gt;subtyping&lt;/b&gt;还有最大最小类型我们定义一个&lt;b&gt;Y组合子&lt;/b&gt;试试&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Y%28%5Clambda+f.%5Clambda+x.f%29&quot; alt=&quot;Y(\lambda f.\lambda x.f)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这个的类型我们写作 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctop+%5Crightarrow+%28%5Ctop+%5Crightarrow+%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow%28%5Ctop+%5Crightarrow....%29&quot; alt=&quot;\top \rightarrow (\top \rightarrow (\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow(\top \rightarrow....)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;很好,写不下&lt;/p&gt;&lt;p&gt;么我们姑且吧&lt;i&gt;α&lt;/i&gt;当作递归类型处理吧,所以这个东西的类型是: &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctop+%5Crightarrow+%5Calpha&quot; alt=&quot;\top \rightarrow \alpha&quot; eeimg=&quot;1&quot;/&gt; 为了写的爽,干脆类型的语法也就这么来吧&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau+%3A%3A%3D+%5Ctau_1+%5Crightarrow+%5Ctau_2%5C%5C+%7C%5C%7Bl1%3A%5Ctau_1%2C...%5C%7D%5C%5C+%7C%5Calpha%5C%5C+%7C%5Ctop%5C%5C+%7C%5Cbot%5C%5C+%7C%5Ctau+%5Csqcap%5Ctau%5C%5C+%7C%5Ctau+%5Csqcup+%5Ctau&quot; alt=&quot;\tau ::= \tau_1 \rightarrow \tau_2\\ |\{l1:\tau_1,...\}\\ |\alpha\\ |\top\\ |\bot\\ |\tau \sqcap\tau\\ |\tau \sqcup \tau&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;好了,我们有了类型构造的语法,那么我们想一下,对于这些记录(record)该怎么搞&lt;/p&gt;&lt;p&gt;如果我们有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bl_1%3A%5Ctau_1%2Cl_2%3A%5Ctau_2%5C%7D&quot; alt=&quot;\{l_1:\tau_1,l_2:\tau_2\}&quot; eeimg=&quot;1&quot;/&gt;我们可以写成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D&quot; alt=&quot;\{f\}&quot; eeimg=&quot;1&quot;/&gt;其 &lt;img src=&quot;https://www.zhihu.com/equation?tex=dom%5C+f+%3D+%5C%7Bl_1%2Cl_2%5C%7D&quot; alt=&quot;dom\ f = \{l_1,l_2\}&quot; eeimg=&quot;1&quot;/&gt; 我们就可以用这个操作获取类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28l_1%29+%3D+%5Ctau_1&quot; alt=&quot;f(l_1) = \tau_1&quot; eeimg=&quot;1&quot;/&gt;,好的这个问题处理完了,我们接着处理函数的问题.&lt;/p&gt;&lt;p&gt;我们可以让语法树的类型部分是无限的,但是我们需要采用限制操作符就不是,比如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=bool+%5Crightarrow+%28bool+%5Crightarrow%28bool+%5Crightarrow%28bool+%5Crightarrow%28....%29%29&quot; alt=&quot;bool \rightarrow (bool \rightarrow(bool \rightarrow(bool \rightarrow(....))&quot; eeimg=&quot;1&quot;/&gt;是合法的代码但是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=bool+%5Csqcap+%28bool+%5Csqcap%28bool+%5Csqcap%28bool+%5Csqcap%28....%29%29&quot; alt=&quot;bool \sqcap (bool \sqcap(bool \sqcap(bool \sqcap(....))&quot; eeimg=&quot;1&quot;/&gt;并不是合法的代码.&lt;/p&gt;&lt;p&gt;但是一般人是写不出来这种无限长的类型定义的,所以我们使用 &lt;b&gt;polar type&lt;/b&gt;进行操作,现在这一章先不讲,这是一种有限类型的子集,你知道方便写和推导就行了.&lt;/p&gt;&lt;p&gt;那么接着上一章提到的&lt;b&gt;分配格&lt;/b&gt;来讲,我们也设计一套规则&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau+%5Csqcup+%5Ctau+%5Cequiv+%5Ctau+%5Cqquad+%5Ctau+%5Csqcap+%5Ctau+%5Cequiv+%5Ctau%5C%5C+%5Ctau_1+%5Csqcup+%5Ctau_2+%5Cequiv+%5Ctau_2+%5Csqcup+%5Ctau_1+%5Cqquad+%5Ctau_1+%5Csqcap+%5Ctau_2+%5Cequiv+%5Ctau_2+%5Csqcap+%5Ctau_1%5C%5C+%5Ctau_1+%5Csqcup+%28%5Ctau_2+%5Csqcup+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcup%5Ctau_2%29+%5Csqcup+%5Ctau_1+%5Cqquad+%5Ctau_1+%5Csqcap+%28%5Ctau_2+%5Csqcap+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcap%5Ctau_2%29+%5Csqcap+%5Ctau_1%5C%5C+%5Ctau_1+%5Csqcup+%28%5Ctau_1+%5Csqcap+%5Ctau_2%29+%5Cequiv+%5Ctau_1+%5Cqquad+%5Ctau_1+%5Csqcap+%28%5Ctau_1+%5Csqcup+%5Ctau_2%29+%5Cequiv+%5Ctau_1%5C%5C+%5Cbot+%5Csqcup+%5Ctau+%5Cequiv+%5Ctau+%5Cqquad+%5Cbot+%5Csqcap+%5Ctau+%5Cequiv+%5Cbot%5C%5C+%5Ctop+%5Csqcup+%5Ctau+%5Cequiv+%5Ctop+%5Cqquad+%5Ctop+%5Csqcap+%5Ctau+%5Cequiv+%5Ctau%5C%5C+%5Ctau_1+%5Csqcup+%28%5Ctau_2+%5Csqcap+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcup%5Ctau_2%29%5Csqcap%28%5Ctau_1%5Csqcup%5Ctau_3%29%5C%5C+%5Ctau_1+%5Csqcap+%28%5Ctau_2+%5Csqcup+%5Ctau_3%29+%5Cequiv+%28%5Ctau_1%5Csqcap%5Ctau_2%29%5Csqcup%28%5Ctau_1%5Csqcap%5Ctau_3%29%5C%5C&quot; alt=&quot;\tau \sqcup \tau \equiv \tau \qquad \tau \sqcap \tau \equiv \tau\\ \tau_1 \sqcup \tau_2 \equiv \tau_2 \sqcup \tau_1 \qquad \tau_1 \sqcap \tau_2 \equiv \tau_2 \sqcap \tau_1\\ \tau_1 \sqcup (\tau_2 \sqcup \tau_3) \equiv (\tau_1\sqcup\tau_2) \sqcup \tau_1 \qquad \tau_1 \sqcap (\tau_2 \sqcap \tau_3) \equiv (\tau_1\sqcap\tau_2) \sqcap \tau_1\\ \tau_1 \sqcup (\tau_1 \sqcap \tau_2) \equiv \tau_1 \qquad \tau_1 \sqcap (\tau_1 \sqcup \tau_2) \equiv \tau_1\\ \bot \sqcup \tau \equiv \tau \qquad \bot \sqcap \tau \equiv \bot\\ \top \sqcup \tau \equiv \top \qquad \top \sqcap \tau \equiv \tau\\ \tau_1 \sqcup (\tau_2 \sqcap \tau_3) \equiv (\tau_1\sqcup\tau_2)\sqcap(\tau_1\sqcup\tau_3)\\ \tau_1 \sqcap (\tau_2 \sqcup \tau_3) \equiv (\tau_1\sqcap\tau_2)\sqcup(\tau_1\sqcap\tau_3)\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;...是不是跟布尔运算规则一个样&lt;br/&gt;下面是函数和记录的构造函数限制&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Ctau_1+%5Crightarrow+%5Ctau_2%29%5Csqcup%28%5Ctau_1%27+%5Crightarrow+%5Ctau_2%27%29+%5Cequiv+%28%5Ctau_1%5Csqcap%5Ctau_1%27%29%5Crightarrow%28%5Ctau_2%5Csqcup%5Ctau_2%27%29%5C%5C+%28%5Ctau_1+%5Crightarrow+%5Ctau_2%29%5Csqcap%28%5Ctau_1%27+%5Crightarrow+%5Ctau_2%27%29+%5Cequiv+%28%5Ctau_1%5Csqcup%5Ctau_1%27%29%5Crightarrow%28%5Ctau_2%5Csqcap%5Ctau_2%27%29%5C%5C++&quot; alt=&quot;(\tau_1 \rightarrow \tau_2)\sqcup(\tau_1&amp;#39; \rightarrow \tau_2&amp;#39;) \equiv (\tau_1\sqcap\tau_1&amp;#39;)\rightarrow(\tau_2\sqcup\tau_2&amp;#39;)\\ (\tau_1 \rightarrow \tau_2)\sqcap(\tau_1&amp;#39; \rightarrow \tau_2&amp;#39;) \equiv (\tau_1\sqcup\tau_1&amp;#39;)\rightarrow(\tau_2\sqcap\tau_2&amp;#39;)\\  &quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D+%5Csqcup+%5C%7Bg%5C%7D+%5Cequiv+%5C%7Bh%5C%7D%5C%5C+%5Cqquad+where+%5C++dom+%5C+h++%3D+dom+%5C+f+%5Ccap+dom+%5C+g%5C%5C+%5Cqquad+and+%5C+h%28l%29+%3D+f%28l%29+%5Csqcup+g%28l%29%5C%5C&quot; alt=&quot;\{f\} \sqcup \{g\} \equiv \{h\}\\ \qquad where \  dom \ h  = dom \ f \cap dom \ g\\ \qquad and \ h(l) = f(l) \sqcup g(l)\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D+%5Csqcap+%5C%7Bg%5C%7D+%5Cequiv+%5C%7Bh%5C%7D%5C%5C+%5Cqquad+where+%5C++dom+%5C+h++%3D+dom+%5C+f+%5Ccup+dom+%5C+g%5C%5C+%5Cqquad+and+%5C+h%28l%29+%3D+%5Cleft%5C%7B+++++%5Cbegin%7Bmatrix%7D+++++++++++++f%28l%29+%5Csqcap+g%28l%29+%5Cquad+if+%5C+l+%5C+%5Cin+dom+%5C+f+%5Ccap+dom+%5C+g%5C%5C+++++++++++++f%28l%29+%5Cqquad+if+%5C+l+%5C+%5Cin+dom+%5C+f+-+dom+%5C+g%5C%5C+++++++++++++g%28l%29+%5Cqquad+if+%5C+l+%5C+%5Cin+dom+%5C+g+-+dom+%5C+f%5C%5C+++++%5Cend%7Bmatrix%7D+++++%5Cright%5C%7D&quot; alt=&quot;\{f\} \sqcap \{g\} \equiv \{h\}\\ \qquad where \  dom \ h  = dom \ f \cup dom \ g\\ \qquad and \ h(l) = \left\{     \begin{matrix}             f(l) \sqcap g(l) \quad if \ l \ \in dom \ f \cap dom \ g\\             f(l) \qquad if \ l \ \in dom \ f - dom \ g\\             g(l) \qquad if \ l \ \in dom \ g - dom \ f\\     \end{matrix}     \right\}&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;递归类型&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;MLsub&lt;/b&gt;作为一个牛*的语言,肯定是要支持递归类型的!&lt;/p&gt;&lt;p&gt;经典的递归类型的处理方法是:首先我们有一个类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%5Calpha.%5Ctau&quot; alt=&quot;\mu\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt;我们会把他当成一个映射的不动点 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau%27%29+%3D+%5Ctau%5B%5Ctau%27%2F%5Calpha%5D&quot; alt=&quot;\phi(\tau&amp;#39;) = \tau[\tau&amp;#39;/\alpha]&quot; eeimg=&quot;1&quot;/&gt;这个就确定了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu&quot; alt=&quot;\mu&quot; eeimg=&quot;1&quot;/&gt;的约束和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha&quot; alt=&quot;\alpha&quot; eeimg=&quot;1&quot;/&gt;,并获得了一下的推理原则:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau%5B%5Ctau_0%2F%5Calpha%5D+%3D+%5Ctau_0+%5CRightarrow+%5Cmu%5Calpha.%5Ctau+%3D+%5Ctau_0&quot; alt=&quot;\tau[\tau_0/\alpha] = \tau_0 \Rightarrow \mu\alpha.\tau = \tau_0&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是,我们并不是传统的&lt;b&gt;ML&lt;/b&gt;我们是&lt;b&gt;MLsub&lt;/b&gt;是有&lt;b&gt;subtyping&lt;/b&gt;的&lt;b&gt;ML&lt;/b&gt;,所以这个不⭐ 我们需要一种可以支持&lt;b&gt;subtyping&lt;/b&gt;的比如这样 &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau%5B%5Ctau_0%2F%5Calpha%5D+%5Cleq+%5Ctau_0+%5CRightarrow+%5Cmu%5Calpha.%5Ctau+%5Cleq+%5Ctau_0&quot; alt=&quot;\tau[\tau_0/\alpha] \leq \tau_0 \Rightarrow \mu\alpha.\tau \leq \tau_0&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这个就需要 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%5Calpha.%5Ctau&quot; alt=&quot;\mu\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt;是一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cphi&quot; alt=&quot;\phi&quot; eeimg=&quot;1&quot;/&gt;最小的不动点, 简单(数学)的术语来描述就是映射 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau%27%29+%3D+%5Ctau%5B%5Ctau%27%2F%5Calpha%5D&quot; alt=&quot;\phi(\tau&amp;#39;) = \tau[\tau&amp;#39;/\alpha]&quot; eeimg=&quot;1&quot;/&gt;单调的时候 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha%2C%5Ctau&quot; alt=&quot;\alpha,\tau&quot; eeimg=&quot;1&quot;/&gt;协变,用人话讲就是所有的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha&quot; alt=&quot;\alpha&quot; eeimg=&quot;1&quot;/&gt;都出现在偶数的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Crightarrow&quot; alt=&quot;\rightarrow&quot; eeimg=&quot;1&quot;/&gt;的左侧. &lt;br/&gt;这里带来了两个引论: &lt;/p&gt;&lt;p&gt;&lt;b&gt;引论一&lt;/b&gt;,如果&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha%2C%5Ctau&quot; alt=&quot;\alpha,\tau&quot; eeimg=&quot;1&quot;/&gt;协变,那么&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau%27%29+%3D+%5Ctau%5B%5Ctau%27%2F%5Calpha%5D&quot; alt=&quot;\phi(\tau&amp;#39;) = \tau[\tau&amp;#39;/\alpha]&quot; eeimg=&quot;1&quot;/&gt;就是有一个最小的前不动点,那么我们可以写作 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%5E%2B%5Calpha.%5Ctau&quot; alt=&quot;\mu^+\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt; 相对的,最大的后不动点就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%5E-%5Calpha.%5Ctau&quot; alt=&quot;\mu^-\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt;但是,残念有问题 &lt;i&gt;α&lt;/i&gt;和&lt;i&gt;α&lt;/i&gt;是逆变的,所以我们需要引入&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%5C%5Cmu%5E%2B%5Calpha.%5Ctau+%3D+%5Cbot%5C%5C%5Cmu%5E-%5Calpha.%5Ctau+%3D+%5Ctop%5C%5C&quot; alt=&quot;\\\mu^+\alpha.\tau = \bot\\\mu^-\alpha.\tau = \top\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;(您家的haskell就是这样的),那么假如所有的&lt;i&gt;α&lt;/i&gt;都有至少一种类型构造器,&lt;i&gt;α&lt;/i&gt;被&lt;i&gt;τ&lt;/i&gt;保护,这样凑合就能用了&lt;/p&gt;&lt;p&gt;&lt;b&gt;引论二&lt;/b&gt;,如果&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha%2C%5Ctau&quot; alt=&quot;\alpha,\tau&quot; eeimg=&quot;1&quot;/&gt;协变同时被他保护,那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu%5E%2B%5Calpha.%5Ctau+%3D+%5Cmu%5E-%5Calpha.%5Ctau&quot; alt=&quot;\mu^+\alpha.\tau = \mu^-\alpha.\tau&quot; eeimg=&quot;1&quot;/&gt;这种情况下&lt;i&gt;α&lt;/i&gt;没用 似乎看起来减少了需要处理的类型,那么就很好,然而有个叫&lt;b&gt;Bekic&lt;/b&gt;的科学家发现我们可以找到一种类型成立表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau+%5Cequiv+%5Ctau+%5Crightarrow+%5Ctau&quot; alt=&quot;\tau \equiv \tau \rightarrow \tau&quot; eeimg=&quot;1&quot;/&gt; (当然连我觉得都很扯,这都是什么烂七八糟的东西,不过人家有理有据,看看他是怎么搞得)所以按照他的思路我们可以写出这个东西 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%5C%5Ctau_1%3D%5Ctau_2+%5Crightarrow+%5Ctau_1+%5Cqquad+%5Ctau_2%3D%5Ctau_1+%5Crightarrow+%5Ctau_2%5C%5C&quot; alt=&quot;\\\tau_1=\tau_2 \rightarrow \tau_1 \qquad \tau_2=\tau_1 \rightarrow \tau_2\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;顺着这个思路带入&lt;i&gt;μ&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%5C%5Ctau_1%3D%5Cmu%5Calpha.%5Ctau_2+%5Crightarrow+%5Calpha+%5Cqquad+%5Ctau_2%3D%5Cmu%5Cbeta.%5Ctau_1+%5Crightarrow+%5Cbeta%5C%5C&quot; alt=&quot;\\\tau_1=\mu\alpha.\tau_2 \rightarrow \alpha \qquad \tau_2=\mu\beta.\tau_1 \rightarrow \beta\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;替换一下就可以得到&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%5C%5Ctau_1%3D%5Cmu%5Calpha.%28%5Cmu%5Cbeta.%5Calpha+%5Crightarrow+%5Cbeta%29+%5Crightarrow+%5Calpha+%5Cqquad+%5Ctau_2%3D%5Cmu%5Cbeta.%28%5Cmu%5Calpha.%5Cbeta+%5Crightarrow+%5Calpha%29+%5Crightarrow+%5Cbeta%5C%5C&quot; alt=&quot;\\\tau_1=\mu\alpha.(\mu\beta.\alpha \rightarrow \beta) \rightarrow \alpha \qquad \tau_2=\mu\beta.(\mu\alpha.\beta \rightarrow \alpha) \rightarrow \beta\\&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;然后我们说过这种情况下&lt;i&gt;α&lt;/i&gt;,&lt;i&gt;β&lt;/i&gt;没蛋的用,所以利用模式匹配总结一下&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%5Cequiv+%5Ctau_2&quot; alt=&quot;\tau_1 \equiv \tau_2&quot; eeimg=&quot;1&quot;/&gt;所以....推出来了这个脑残的表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau+%5Cequiv+%5Ctau+%5Crightarrow+%5Ctau&quot; alt=&quot;\tau \equiv \tau \rightarrow \tau&quot; eeimg=&quot;1&quot;/&gt;我们为了纪念他,给他放个特例叫他 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cphi%28%5Ctau_1%2C%5Ctau_2%29&quot; alt=&quot;\phi(\tau_1,\tau_2)&quot; eeimg=&quot;1&quot;/&gt;他的不动点就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%5C%5Cmu.%5Calpha.%5Cphi%28%5Cmu%5Cbeta.%5Cphi%28%5Calpha%2C%5Cbeta%29%2C%5Calpha%29%5C%5C&quot; alt=&quot;\\\mu.\alpha.\phi(\mu\beta.\phi(\alpha,\beta),\alpha)\\&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;我知道我知道,里面可以继续展开我就不展开了....&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;稳健性(Soundness)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们的&lt;b&gt;MLsub&lt;/b&gt;的&lt;b&gt;subtyping&lt;/b&gt;并不是一个由案例来定义的,同时靠着案例反演呀并不是一个非常有意义的操作(所以这就是我unsound的理由,咳咳咳) 实际上,仅仅给出 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%5Cleq+%5Ctau_2+%5Crightarrow+%5Ctau_3&quot; alt=&quot;\tau_1 \leq \tau_2 \rightarrow \tau_3&quot; eeimg=&quot;1&quot;/&gt;我们可以得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%3D+%5Cbot&quot; alt=&quot;\tau_1 = \bot&quot; eeimg=&quot;1&quot;/&gt; 或者是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%3D+%28%5Calpha+%5Crightarrow+%5Cbeta%29%5Csqcap+%5Calpha&quot; alt=&quot;\tau_1 = (\alpha \rightarrow \beta)\sqcap \alpha&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;引论三(反转性)&lt;/b&gt;, 如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1%5Crightarrow%5Ctau_2%5Cleq%5Ctau_1%27%5Crightarrow%5Ctau_2%27&quot; alt=&quot;\tau_1\rightarrow\tau_2\leq\tau_1&amp;#39;\rightarrow\tau_2&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1%27%5Cleq%5Ctau_1%2C%5Ctau_2%27%5Cleq%5Ctau_2&quot; alt=&quot;\tau_1&amp;#39;\leq\tau_1,\tau_2&amp;#39;\leq\tau_2&quot; eeimg=&quot;1&quot;/&gt;,如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Bf%5C%7D+%5Cleq+%5C%7Bg%5C%7D&quot; alt=&quot;\{f\} \leq \{g\}&quot; eeimg=&quot;1&quot;/&gt;则对于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=l+%5Cin+dom%5C+g&quot; alt=&quot;l \in dom\ g&quot; eeimg=&quot;1&quot;/&gt;里 &lt;img src=&quot;https://www.zhihu.com/equation?tex=f%28l%29%5Cleq+g%28l%29&quot; alt=&quot;f(l)\leq g(l)&quot; eeimg=&quot;1&quot;/&gt;幸好这个有proof.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;理论四(进展性),&lt;/b&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvdash+e%3A%5Ctau&quot; alt=&quot;\vdash e:\tau&quot; eeimg=&quot;1&quot;/&gt; ,要么&lt;i&gt;e&lt;/i&gt;是个值,要么是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e+%5Crightarrow+e%27+forsome%5C+e&quot; alt=&quot;e \rightarrow e&amp;#39; forsome\ e&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;理论五(保留性)&lt;/b&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvdash+e%3A%5Ctau&quot; alt=&quot;\vdash e:\tau&quot; eeimg=&quot;1&quot;/&gt; ,同时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=e+%5Crightarrow+e%27+forsome%5C+e&quot; alt=&quot;e \rightarrow e&amp;#39; forsome\ e&quot; eeimg=&quot;1&quot;/&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvdash+e%27%3A%5Ctau&quot; alt=&quot;\vdash e&amp;#39;:\tau&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;最后再吹一下牛逼的类型推导&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们知道&lt;b&gt;MLsub&lt;/b&gt;是一个非常的强大的东西,刚才我提到过&lt;b&gt;MLrec&lt;/b&gt;那么&lt;b&gt;MLsub&lt;/b&gt;是严格的包含了整个&lt;b&gt;MLrec&lt;/b&gt;的存在,所以看不懂很正常咳咳咳.&lt;/p&gt;&lt;p&gt;假如我们有个函数:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+f.%5Clambda+x.f%28f+x%29&quot; alt=&quot;\lambda f.\lambda x.f(f x)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;在一般的&lt;b&gt;ML&lt;/b&gt;下的类型回事这样式(shai)儿的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha.%28%5Calpha+%5Crightarrow+%5Calpha%29+%5Crightarrow+%5Calpha+%5Crightarrow+%5Calpha&quot; alt=&quot;\forall \alpha.(\alpha \rightarrow \alpha) \rightarrow \alpha \rightarrow \alpha&quot; eeimg=&quot;1&quot;/&gt; 我们&lt;b&gt;MLsub&lt;/b&gt;能带来更加符合直觉,更好看的类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha%2C%5Cbeta.%28%28%5Calpha+%5Csqcup+%5Cbeta%29%5Crightarrow+%5Cbeta%29%5Crightarrow%28%5Calpha+%5Crightarrow+%5Cbeta%29&quot; alt=&quot;\forall \alpha,\beta.((\alpha \sqcup \beta)\rightarrow \beta)\rightarrow(\alpha \rightarrow \beta)&quot; eeimg=&quot;1&quot;/&gt; 这个栗子不是特别突出&lt;/p&gt;&lt;p&gt;再举一个栗子,大家都知道这个函数吧 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+x.+xx&quot; alt=&quot;\lambda x. xx&quot; eeimg=&quot;1&quot;/&gt; 我们蠢萌的&lt;b&gt;ML&lt;/b&gt;没法举出这个东西的类型,但是我们&lt;b&gt;MLsub&lt;/b&gt;就可以差不多的推出来个这样的东西&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha%2C%5Cbeta.%28%28%5Calpha+%5Crightarrow+%5Cbeta%29%5Csqcap+%5Calpha%29%5Crightarrow+%5Cbeta&quot; alt=&quot;\forall \alpha,\beta.((\alpha \rightarrow \beta)\sqcap \alpha)\rightarrow \beta&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;一看,哇,漂亮对吧,一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Csqcap&quot; alt=&quot;\sqcap&quot; eeimg=&quot;1&quot;/&gt;就解决了这个&lt;i&gt;x&lt;/i&gt;的类型归属问题,同时解决了递归. &lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;这一章稍微有点长,有的没的的东西讲的有点多,还是老规矩,大佬觉得错了就赶紧评论&lt;/p&gt;</description>
<author>柠檬浣熊</author>
<guid isPermaLink="false">2019-06-20-69889087</guid>
<pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>MLsub大概是个什么鬼.一</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-06-18-69565293.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69565293&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4b66c35b47a7a554e4fc8f7ff2da185b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;我们知道(PS:不知道的可以不看了) &lt;b&gt;Hindley-Milner&lt;/b&gt; 类型系统是一个非常流行(PS:荼毒万年,又让人无可奈何)的类型系统,&lt;b&gt;ML&lt;/b&gt;又是一个很基本的一种函数式编程语言(家族).&lt;/p&gt;&lt;p&gt;&lt;b&gt;ML&lt;/b&gt;使用了&lt;b&gt;Hindley-Milner&lt;/b&gt;类型系统,但是,现在来讲&lt;b&gt;HM&lt;/b&gt;类型系统已经过时了,因为&lt;b&gt;OOP&lt;/b&gt;(面向对象编程)的范式越来越多的被人们熟知,而&lt;b&gt;HM&lt;/b&gt;并不支持&lt;b&gt;OOP&lt;/b&gt;赖以生存的&lt;b&gt;Subtyping&lt;/b&gt;,这就是为什么我们要把&lt;b&gt;subtyping&lt;/b&gt;加入到&lt;b&gt;HM&lt;/b&gt;里了,当然这并不是一个非常简单的过程,既然是学术文章,那么我们就不能摆出来&lt;b&gt;Java&lt;/b&gt;之类的残废语言讨论,真正的&lt;b&gt;subtyping&lt;/b&gt;还应该(道德绑架)支持&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;br/&gt;&lt;b&gt;Extensible records&lt;/b&gt;来自&lt;b&gt;ELM&lt;/b&gt;语言的例子&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-elm&quot;&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;alias&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Positioned&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;polymorphic variants&lt;/b&gt;这是一个&lt;b&gt;ReasonML&lt;/b&gt;里的一个例子&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rgbnormal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Redn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Greenn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bluen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rgbvariants&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Redv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Greenv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Bluev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了支持&lt;b&gt;subtyping&lt;/b&gt;我们需要很好的考虑类型和数据流的关系,数据流的方向,一个信息源必须提供一个目的地.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;d&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;ML&lt;/b&gt;里的类型信息&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha+.%28%5Calpha+%5Crightarrow+bool%29%5Crightarrow+%5Calpha++%5Crightarrow+%5Calpha++%5Crightarrow+%5Calpha&quot; alt=&quot;\forall \alpha .(\alpha \rightarrow bool)\rightarrow \alpha  \rightarrow \alpha  \rightarrow \alpha&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;不用想都知道,这肯定不对,有人建议我们写对的&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Calpha+%5Crightarrow+bool%29%5Crightarrow+%5Calpha+%5Crightarrow+%5Cbeta+%5Crightarrow+%5Cgamma+%7C%5Calpha+%5Cleq+%5Cgamma+%2C+%5Cbeta+%5Cleq+%5Cgamma&quot; alt=&quot;(\alpha \rightarrow bool)\rightarrow \alpha \rightarrow \beta \rightarrow \gamma |\alpha \leq \gamma , \beta \leq \gamma&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;对是对了,然后那群科学家发现者玩意儿怎么TM用,太难了! 于是有一个人 &lt;b&gt;Pottier&lt;/b&gt; 觉得我们可以化简一波&lt;/p&gt;&lt;p&gt;于是就有了&lt;b&gt;MLsubj&lt;/b&gt;的s小本本里建议的这种写法&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha+%2C+%5Cbeta+.%28%5Calpha+%5Crightarrow+bool%29+%5Crightarrow+%5Calpha+%5Crightarrow+%5Cbeta+%5Crightarrow+%28%5Calpha+%5Csqcup+%5Cbeta%29&quot; alt=&quot;\forall \alpha , \beta .(\alpha \rightarrow bool) \rightarrow \alpha \rightarrow \beta \rightarrow (\alpha \sqcup \beta)&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;乍一看是对的,这个&lt;b&gt;select&lt;/b&gt;函数的定义就跟符合直觉了&lt;/p&gt;&lt;p&gt;所以本质上&lt;b&gt;MLsub&lt;/b&gt;的主要贡献大概有四点&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;MLsub类型系统&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;我们扩充了&lt;b&gt;ML&lt;/b&gt;的类型系统,添加了&lt;b&gt;subtyping&lt;/b&gt;的特性,然后我们采用了一些输入输出上的规则,简化了类型推断&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;类型推断&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;我们引入了一种处理&lt;b&gt;subtype&lt;/b&gt;的&lt;b&gt;unification&lt;/b&gt;算法 &lt;b&gt;(biunification)&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;类型化简&lt;/b&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;MLsub&lt;/b&gt;里面会产生很多的类型实质上一样但是表述上有区别的类型,就比如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=bool+%5Csqcup+bool+%5Csqcup+%5Cbot&quot; alt=&quot;bool \sqcup bool \sqcup \bot&quot; eeimg=&quot;1&quot;/&gt; 实际上和&lt;i&gt;bool&lt;/i&gt;是一个类型的,我们将会使用一个自动机来化简类型&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;b&gt;引入了更多BUG&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;说了这么多没用的简介,那我们可以理一理实现了,从代数层面上&lt;/p&gt;&lt;p&gt;一个标准的类型,函数类型,顶类型,底类型定义为&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau+%3A%3A%3D+%5Cbot+%7C+%5Ctau+%5Crightarrow+%5Ctau+%7C+%5Ctop&quot; alt=&quot;\tau ::= \bot | \tau \rightarrow \tau | \top&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;对于任意类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1%2C%5Ctau_2&quot; alt=&quot;\tau_1,\tau_2&quot; eeimg=&quot;1&quot;/&gt; ,有他们的上限是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%5Csqcup+%5Ctau_2&quot; alt=&quot;\tau_1 \sqcup \tau_2&quot; eeimg=&quot;1&quot;/&gt; ,他们最大的下限是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%5Csqcap+%5Ctau_2&quot; alt=&quot;\tau_1 \sqcap \tau_2&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;然后,我们发现好像不太对&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28E%29%3A%5Cquad%28%5Cbot+%5Crightarrow+%5Ctop%29%5Crightarrow+%5Cbot+%5Cleq+%28%5Calpha+%5Crightarrow+%5Cbot%29+%5Csqcup+%5Calpha&quot; alt=&quot;(E):\quad(\bot \rightarrow \top)\rightarrow \bot \leq (\alpha \rightarrow \bot) \sqcup \alpha&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;MLsub&lt;/b&gt;就是为了避免这个的发生,使用了更加复杂的语法和直接添加的类型而不是使用一个&lt;b&gt;Ground Type&lt;/b&gt;慢慢往上搭屎山.&lt;/p&gt;&lt;p&gt;其次呢,他们使用了一种词法叫&lt;b&gt;分配格&lt;/b&gt;,确保了构建类型的时候仅少量的出现相同的&lt;b&gt;subtype&lt;/b&gt;. 但是问题又来了,加入我们有一个类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_f&quot; alt=&quot;\tau_f&quot; eeimg=&quot;1&quot;/&gt;用来描述函数和一个类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_r&quot; alt=&quot;\tau_r&quot; eeimg=&quot;1&quot;/&gt;用来描述一个记录(record),那么下面公式成立&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_f%5Csqcap%5Ctau_r+%3D+%5Cbot+&quot; alt=&quot;\tau_f\sqcap\tau_r = \bot &quot; eeimg=&quot;1&quot;/&gt;虽然第一眼看起来没有任何问题&lt;/p&gt;&lt;p&gt;给没看出问题的你一点时间......&lt;/p&gt;&lt;p&gt;我们可以推导出 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_f%5Csqcap%5Ctau_r+%5Cleq+bool&quot; alt=&quot;\tau_f\sqcap\tau_r \leq bool&quot; eeimg=&quot;1&quot;/&gt; 蛤?! 这是什么?! 为什么?!     因为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_f%5Csqcap%5Ctau_r+%3D+%5Cbot&quot; alt=&quot;\tau_f\sqcap\tau_r = \bot&quot; eeimg=&quot;1&quot;/&gt;这个公式成立啊! &lt;/p&gt;&lt;p&gt;这个非常的反直觉,但是,毕竟定义上合情合理 &amp;lt;del&amp;gt;所以这个编译器就必须能处理这个东西(一个函数和记录作为布尔值)......&amp;lt;/del&amp;gt;&lt;/p&gt;&lt;p&gt;下面是&lt;b&gt;MLsub&lt;/b&gt;的类型推导&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28VAR-%5Clambda%29%5Cquad%5Cfrac%7B%7D%7B%5CGamma%5Cvdash+x%3A%5Ctau%7D%5CGamma%28x%29%3D%5Ctau%5C%5C+%5C%5C+%28VAR-%5Cforall%29%5Cquad%5Cfrac%7B%7D%7B%5CGamma+%5Cvdash+%5Chat+x+%3A+%5Ctau%5B%5Cvec+%5Ctau+%2F+%5Cvec+%5Calpha%5D%7D+%5CGamma%28%5Chat+x%29+%3D+%5Cforall+%5Cvec+%5Calpha+.+%5Ctau%5C%5C+%28ABS%29%5Cquad+%5Cfrac%7B%5CGamma%2Cx%3A%5Ctau_1+%5Cvdash+e+%3A%5Ctau_2%7D%7B%5CGamma+%5Cvdash+%5Clambda+x.e+%3A+%5Ctau_1+%5Crightarrow+%5Ctau_2%7D%5C%5C+%28APP%29+%5Cquad+%5Cfrac%7B%5CGamma+%5Cvdash+e_1+%3A+%5Ctau_1+%5Crightarrow+%5Ctau_2+%5Cquad+%5CGamma+%5Cvdash+e_2+%3A+%5Ctau_1%7D%7B%5CGamma+%5Cvdash+e_1+e_2+%3A+%5Ctau_2%7D%5C%5C+%28LET%29+%5Cfrac%7B%5CGamma+%5Cvdash+e_1%3A%5Ctau_1+%5Cquad+%5CGamma%2Cx%3A%5Cforall+%5Cvec+a+.%5Ctau_1+%5Cvdash+e_2+%3A+%5Ctau_2%7D%7B%5CGamma+%5Cvdash+let+%5C++%5Chat%7Bx%7D+%3D+e_1%5C++in%5C++e_2+%3A+%5Ctau_2%7D%5C%5C+%28PROJ%29+%5Cquad+%5Cfrac%7B%5CGamma%5Cvdash+e%3A+%5C%7B+l+%3A+%5Ctau%2C...%5C%7D%7D%7B%5CGamma+%5Cvdash+e.l+%3A+%5Ctau%7D%5C%5C+%28SUB%29+%5Cquad+%5Cfrac%7B%5CGamma+%5Cvdash+e%3A%5Ctau%7D%7B%5CGamma+%5Cvdash+e%3A%5Ctau%27%7D+%5Ctau+%5Cleq+%5Ctau%27%5C%5C&quot; alt=&quot;(VAR-\lambda)\quad\frac{}{\Gamma\vdash x:\tau}\Gamma(x)=\tau\\ \\ (VAR-\forall)\quad\frac{}{\Gamma \vdash \hat x : \tau[\vec \tau / \vec \alpha]} \Gamma(\hat x) = \forall \vec \alpha . \tau\\ (ABS)\quad \frac{\Gamma,x:\tau_1 \vdash e :\tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2}\\ (APP) \quad \frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2}\\ (LET) \frac{\Gamma \vdash e_1:\tau_1 \quad \Gamma,x:\forall \vec a .\tau_1 \vdash e_2 : \tau_2}{\Gamma \vdash let \  \hat{x} = e_1\  in\  e_2 : \tau_2}\\ (PROJ) \quad \frac{\Gamma\vdash e: \{ l : \tau,...\}}{\Gamma \vdash e.l : \tau}\\ (SUB) \quad \frac{\Gamma \vdash e:\tau}{\Gamma \vdash e:\tau&amp;#39;} \tau \leq \tau&amp;#39;\\&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;最后我们可以得出,如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1+%5Csqcap%5Ctau_2+%5Cleq+%5Ctau_3&quot; alt=&quot;\tau_1 \sqcap\tau_2 \leq \tau_3&quot; eeimg=&quot;1&quot;/&gt; 那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1%27+%5Csqcap%5Ctau_2%27+%3D+%5Ctau_3&quot; alt=&quot;\tau_1&amp;#39; \sqcap\tau_2&amp;#39; = \tau_3&quot; eeimg=&quot;1&quot;/&gt;所以 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau_1%27%5Cleq%5Ctau_3%2C%5Ctau_2%27%5Cleq%5Ctau_3&quot; alt=&quot;\tau_1&amp;#39;\leq\tau_3,\tau_2&amp;#39;\leq\tau_3&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;很好,锅居多,作者表态,嗯,下章我们要用更加科学的方法去修补.&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;第一次写关于这个的文章,其实这是我这个垃圾的笔记,完全是按照自己易懂的方法写的,看不懂属于正常现象,大佬要是发现了我的理解错误随时评论区指正&lt;/p&gt;</description>
<author>柠檬浣熊</author>
<guid isPermaLink="false">2019-06-18-69565293</guid>
<pubDate>Tue, 18 Jun 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Encode Extensible Tuple In λ-Calculus</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-06-10-68506839.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/68506839&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-89a92d224f91a0df1cd674752eacfa96_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;在λ-calculus中我们可以通过scott encoding来对所有常见的ADT进行直观的encode，但是对于一些其他的数据结构却不尽如此。例如本文中要实现的数据结构便是用church encoding的natural number来作为tuple的arity来实现extensible tuple，此数据结构便无法简单的用scott encoding来进行encode。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;前置知识&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;对函数式编程及相关编程语言的知识&lt;/li&gt;&lt;li&gt;对λ-calculus的相关知识&lt;/li&gt;&lt;li&gt;对church number的相关知识&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;分析&lt;/h2&gt;&lt;p&gt;首先对于非extensible的tuple，我们可以使用scott encoding来进行encode，例如以下例子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;tuple0 := λt.t

tuple1 := λx.λt.t x
tuple1_0th := λx.x

tuple2 := λx.λy.λt.t x y
tuple2_0th := λx.λy.x
tuple2_1th := λx.λy.y

tuple3 := λx.λy.λz.λt.t x y z
tuple3_0th := λx.λy.λz.x
tuple3_1th := λx.λy.λz.y
tuple3_2th := λx.λy.λz.z&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;能够发现明显的规律，因此，我们需要对这些constructor和pattern match函数进行generalize写出tuple和nth这两个函数。&lt;/p&gt;&lt;h2&gt;实现&lt;/h2&gt;&lt;p&gt;对于constructor tuple来说，可以注意到是由n个argument以及1个进行pattern match的higher order function作为参数传入，并给这个function依次apply n个argument。此时应用church number的性质，一个church number相当于对一个x，以及一个函数f，将x apply n次f，那么x就应该是tuple0，因为要将一个参数传入其内部，所以将其变换为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;λu.λt.u t&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后最后apply一个id，但由于实际上变换前和变换后的lambda term是eta equivalent的，所以这一步不是必须的，现在得到如下的lambda term：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;λn.n f (λu.λt.u t) id&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于f，相当于将一个argument加在之前的tuple constructor上，那么就应该是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;λf.λu.λx.f (λt.u t x)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将其合并起来组成extensible tuple的constructor：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;λn.n (λf.λu.λx.f (λt.u t x)) (λu.λt.u t) id&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后进行简化就得到了extensible tuple的constructor：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;tuple := λn.n (λf.λu.λx.f (λt.u t x)) (λu.u) (λx.x)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于pattern match函数，需要2个church number，n作为tuple的大小，m作为第m的element。同样应用church number的性质，先生成n - m个arity的const function：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(m pred n) (λf.λx.f)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在外部加m个constant argument，组成extensible tuple的pattern match函数nth：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nth := λn.λm.m (λf.λx.f) ((m pred n) (λf.λx.f))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中pred定义为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pred := λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果需要测试相关代码，可以直接使用我写的λ-calculus在线测试工具：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//yuxuanchiadm.github.io/hyperlambda/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hyper Lambda&lt;/a&gt;&lt;h2&gt;相关文章&lt;/h2&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36081360&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-fc94609d676b4704ccfce8b67fd56e62_180x120.jpg&quot; data-image-width=&quot;1440&quot; data-image-height=&quot;816&quot; class=&quot;internal&quot;&gt;非构造性雨轩菌：lambda演算与数据类型&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>非构造性雨轩菌</author>
<guid isPermaLink="false">2019-06-10-68506839</guid>
<pubDate>Mon, 10 Jun 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>某不知名的 Lambda Calculus Calculator 实现 吃人了~！</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-06-05-68084517.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/68084517&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6765c36a65c96091e2d1fb5522da91a0_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;先放链接吧！&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//yuxuanchiadm.github.io/hyperlambda/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hyper Lambda&lt;/a&gt;&lt;p&gt;最近突然想把以前用scala写的一个叫做lamcalcj的东西翻出来玩一玩，然后想想9102年已经完全是web的时代了，javascript都成为21st century assembly language了（雾&lt;/p&gt;&lt;p&gt;所以去一个造web版的lambda calculus的计算器、REPL那岂不是能获得双倍的快乐了？&lt;/p&gt;&lt;p&gt;然后就开始弄起来了，花了2天时间目前已经用scalajs把lamcalcj给cross compile到了js上，然后用element-ui简单的做了一波前端（不要在意目前的排版www），最终目标是做一个完整的online IDE性质的东西出来，然后再考虑加一下奇怪的东西上去。&lt;/p&gt;&lt;p&gt;那么欢迎对这东西有兴趣的同学来找我摸鱼、划水、闲聊、发PR！（真的能吃到人么？&lt;/p&gt;&lt;p&gt;相关项目：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/yuxuanchiadm/hyperlambda&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-b81dd42e0396d4444d0d5c2ec0b9973a_ipico.jpg&quot; data-image-width=&quot;400&quot; data-image-height=&quot;400&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;yuxuanchiadm/hyperlambda&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/yuxuanchiadm/lamcalcj&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-b81dd42e0396d4444d0d5c2ec0b9973a_ipico.jpg&quot; data-image-width=&quot;400&quot; data-image-height=&quot;400&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;yuxuanchiadm/lamcalcj&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/yuxuanchiadm/lambdacore&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-b81dd42e0396d4444d0d5c2ec0b9973a_ipico.jpg&quot; data-image-width=&quot;400&quot; data-image-height=&quot;400&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;yuxuanchiadm/lambdacore&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>非构造性雨轩菌</author>
<guid isPermaLink="false">2019-06-05-68084517</guid>
<pubDate>Wed, 05 Jun 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>里奇微积分(Ricci Calculus)：一种计算向量求导，矩阵求导，张量求导的简单方法</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-30-63176747.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/63176747&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6d3fbfcd00ac16612dbb8cae27304da6_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在计算反向传播或最优化问题时，经常遇到向量、矩阵、张量对向量、矩阵、张量的求导问题，而类比普通函数求导经常无法处理矩阵转置的问题，因此需要使用一套更简单的符号系统进行运算，即&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Ricci_calculus&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;里奇微积分&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Einstein_notation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;爱因斯坦求和约定&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;相乘时符号相同且共轭的指标，如一个&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Covariance_and_contravariance_of_vectors&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;共变自由指标&lt;/a&gt;(下标）遇到一个符号相同的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Covariance_and_contravariance_of_vectors&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;反变自由指标&lt;/a&gt;（上标），会发生缩并运算成为哑指标，整个表达式自由指标的个数表示最终结果的自由指标个数；当自由指标只有一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot; eeimg=&quot;1&quot;/&gt; （如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%5Ei%2CA_i%5Ejx%5Ei%3Dy%5Ej&quot; alt=&quot;x^i,A_i^jx^i=y^j&quot; eeimg=&quot;1&quot;/&gt; ）时，表达式是一个向量（一维张量），有两个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=i%2Cj&quot; alt=&quot;i,j&quot; eeimg=&quot;1&quot;/&gt; （如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_i%5Ej%2CA%5E%7Bij%7D%2CA_i%5Ejx%5Ej&quot; alt=&quot;A_i^j,A^{ij},A_i^jx^j&quot; eeimg=&quot;1&quot;/&gt; ）时，表达式是一个二维张量，以此类推。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;符号约定&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=R%5En&quot; alt=&quot;R^n&quot; eeimg=&quot;1&quot;/&gt; 表示n维列向量空间， &lt;img src=&quot;https://www.zhihu.com/equation?tex=R%5E%7Bn%2A%7D&quot; alt=&quot;R^{n*}&quot; eeimg=&quot;1&quot;/&gt; 表示n维行向量空间，&lt;img src=&quot;https://www.zhihu.com/equation?tex=A_%7Bij%7D&quot; alt=&quot;A_{ij}&quot; eeimg=&quot;1&quot;/&gt; 表示&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Bilinear_map&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;双线性映射&lt;/a&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=R%5En%5Ctimes+R%5En%5Crightarrow+R&quot; alt=&quot;R^n\times R^n\rightarrow R&quot; eeimg=&quot;1&quot;/&gt;  ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5E%7Bij%7D&quot; alt=&quot;A^{ij}&quot; eeimg=&quot;1&quot;/&gt; 表示双线性映射 &lt;img src=&quot;https://www.zhihu.com/equation?tex=R%5E%7Bn%2A%7D%5Ctimes+R%5E%7Bn%2A%7D%5Crightarrow+R&quot; alt=&quot;R^{n*}\times R^{n*}\rightarrow R&quot; eeimg=&quot;1&quot;/&gt;，&lt;img src=&quot;https://www.zhihu.com/equation?tex=x%5Ei&quot; alt=&quot;x^i&quot; eeimg=&quot;1&quot;/&gt; 表示列向量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt;， &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_i&quot; alt=&quot;x_i&quot; eeimg=&quot;1&quot;/&gt; 表示行向量&lt;img src=&quot;https://www.zhihu.com/equation?tex=x%5ET&quot; alt=&quot;x^T&quot; eeimg=&quot;1&quot;/&gt;（也叫&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Linear_form&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;线性泛函&lt;/a&gt;或余向量）。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta_i%5Ej&quot; alt=&quot;\delta_i^j&quot; eeimg=&quot;1&quot;/&gt; 是一个单位矩阵， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta_%7Bij%7D&quot; alt=&quot;\delta_{ij}&quot; eeimg=&quot;1&quot;/&gt; 是度量张量（一个双线性映射）， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta%5E%7Bij%7D&quot; alt=&quot;\delta^{ij}&quot; eeimg=&quot;1&quot;/&gt; 是共轭度量张量，它们有这些性质：&lt;img src=&quot;https://www.zhihu.com/equation?tex=x%5Ej%28%3Dx%29&quot; alt=&quot;x^j(=x)&quot; eeimg=&quot;1&quot;/&gt; 表示原向量则&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta_%7Bij%7Dx%5Ej%3Dx_i%28%3Dx%5E%7B%5Ctop%7D%29&quot; alt=&quot;\delta_{ij}x^j=x_i(=x^{\top})&quot; eeimg=&quot;1&quot;/&gt; 表示转置向量， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta%5Ei_jx%5Ei%3D%5Coperatorname%7Bdiag%7D%28x%29&quot; alt=&quot;\delta^i_jx^i=\operatorname{diag}(x)&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_j%5Ei%28%3DA%29&quot; alt=&quot;A_j^i(=A)&quot; eeimg=&quot;1&quot;/&gt; 表示原矩阵则&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta_%7Bii%7D%5Cdelta%5E%7Bjj%7DA_j%5Ei%28%3DA%5E%5Ctop%29&quot; alt=&quot;\delta_{ii}\delta^{jj}A_j^i(=A^\top)&quot; eeimg=&quot;1&quot;/&gt; 表示转置矩阵， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta_%7Bii%7D%5Cdelta%5E%7Bii%7D%3D1&quot; alt=&quot;\delta_{ii}\delta^{ii}=1&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta_%7Bij%7D%5Cdelta%5E%7Bii%7D%3D%5Cdelta_j%5Ei&quot; alt=&quot;\delta_{ij}\delta^{ii}=\delta_j^i&quot; eeimg=&quot;1&quot;/&gt; ，&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Bdx_i%7D%7Bdx%5Ej%7D%3D%5Cdelta_i%5Ej&quot; alt=&quot;\frac{dx_i}{dx^j}=\delta_i^j&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Bdx%5Ei%7D%7Bdx%5Ej%7D%3D%5Cdelta%5E%7Bij%7D&quot; alt=&quot;\frac{dx^i}{dx^j}=\delta^{ij}&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Bdx_i%7D%7Bdx_j%7D%3D%5Cdelta_%7Bij%7D&quot; alt=&quot;\frac{dx_i}{dx_j}=\delta_{ij}&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Bd+X_i%5Ej%7D%7Bd+X_k%5El%7D+%3D+%5Cdelta%5E%7Bjl%7D%5Cdelta_%7Bik%7D&quot; alt=&quot;\frac{d X_i^j}{d X_k^l} = \delta^{jl}\delta_{ik}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;矩阵表示与Ricci Calculus表示法的对比&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=c+%3D+x+%5E+%7B+%5Ctop+%7D+y+%5Cquad+c+%3D+x+_+%7B+i+%7D+y+%5E+%7B+i+%7D&quot; alt=&quot;c = x ^ { \top } y \quad c = x _ { i } y ^ { i }&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%3D+A+y+%5Cquad+x+%5E+%7B+i+%7D+%3D+A+_+%7B+j+%7D+%5E+%7B+i+%7D+y+%5E+%7B+j+%7D&quot; alt=&quot;x = A y \quad x ^ { i } = A _ { j } ^ { i } y ^ { j }&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5E+%7B+%5Ctop+%7D+%3D+y+%5E+%7B+%5Ctop+%7D+A+%5Cquad+x+_+%7B+j+%7D+%3D+y+_+%7B+i+%7D+A+_+%7B+j+%7D+%5E+%7B+i+%7D&quot; alt=&quot;x ^ { \top } = y ^ { \top } A \quad x _ { j } = y _ { i } A _ { j } ^ { i }&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=C+%3D+A+%5Ccdot+B+%5Cquad+C+_+%7B+k+%7D+%5E+%7B+i+%7D+%3D+A+_+%7B+j+%7D+%5E+%7B+i+%7D+B+_+%7B+k+%7D+%5E+%7B+j+%7D&quot; alt=&quot;C = A \cdot B \quad C _ { k } ^ { i } = A _ { j } ^ { i } B _ { k } ^ { j }&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=A+%3D+x+y+%5E+%7B+%5Ctop+%7D+%5Cquad+A+_+%7B+j+%7D+%5E+%7B+i+%7D+%3D+x+%5E+%7B+i+%7D+y+_+%7B+j+%7D&quot; alt=&quot;A = x y ^ { \top } \quad A _ { j } ^ { i } = x ^ { i } y _ { j }&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=z+%3D+x+%5Codot+y+%5Cquad+z+%5E+%7B+i+%7D+%3D+x+%5E+%7B+i+%7D+y+%5E+%7B+i+%7D&quot; alt=&quot;z = x \odot y \quad z ^ { i } = x ^ { i } y ^ { i }&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=A%3Dx%5Cotimes+y+%5Cquad++A%5E%7Bij%7D%3Dx%5Ei+y%5Ej&quot; alt=&quot;A=x\otimes y \quad  A^{ij}=x^i y^j&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=C%3DA%5Cotimes+B%5Cquad+C%5E%7Bij%7D_%7Bkl%7D%3DA_k%5Ei+B_l%5Ej&quot; alt=&quot;C=A\otimes B\quad C^{ij}_{kl}=A_k^i B_l^j&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=B%3DA%5Cotimes+x%5Cquad+B_%7Bij%7D%5Ek%3DA_%7Bij%7Dx%5Ek&quot; alt=&quot;B=A\otimes x\quad B_{ij}^k=A_{ij}x^k&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=B+%3D+A+%5Coperatorname+%7B+diag+%7D+%28+x+%29+%5Cquad+B+_+%7B+j+%7D+%5E+%7B+i+%7D+%3D+A+_+%7B+j+%7D+%5E+%7B+i+%7D+x+_+%7B+j+%7D&quot; alt=&quot;B = A \operatorname { diag } ( x ) \quad B _ { j } ^ { i } = A _ { j } ^ { i } x _ { j }&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=B+%3D+%5Coperatorname+%7B+diag+%7D+%28+x+%29+A+%5Cquad+B+_+%7B+j+%7D+%5E+%7B+i+%7D+%3D+x+%5E+%7B+i+%7D+A+_+%7B+j+%7D+%5E+%7B+i+%7D&quot; alt=&quot;B = \operatorname { diag } ( x ) A \quad B _ { j } ^ { i } = x ^ { i } A _ { j } ^ { i }&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;示例&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;根据上述原理计算 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%5ETAx&quot; alt=&quot;x^TAx&quot; eeimg=&quot;1&quot;/&gt; 对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;/&gt; 的导数：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Bd+%28x%5E%7B%5Ctop%7DAx%29%7D%7Bdx%7D&quot; alt=&quot;\frac{d (x^{\top}Ax)}{dx}&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3D%5Cfrac%7Bd+%28x_i+A_j%5Ei+x%5Ej%29%7D%7Bd+x%5Ek%7D&quot; alt=&quot;=\frac{d (x_i A_j^i x^j)}{d x^k}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3D%5Cfrac%7Bd+x_i%7D%7Bd+x%5Ek%7DA_j%5Ei+x%5Ej%2Bx_i+A_j%5Ei+%5Cfrac%7Bd+x%5Ej%7D%7Bd+x%5Ek%7D&quot; alt=&quot;=\frac{d x_i}{d x^k}A_j^i x^j+x_i A_j^i \frac{d x^j}{d x^k}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3D%5Cdelta_i%5Ek+A_j%5Ei+x%5Ej%2B+x_i+A_j%5Ei+%5Cdelta%5E%7Bjk%7D&quot; alt=&quot;=\delta_i^k A_j^i x^j+ x_i A_j^i \delta^{jk}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3DA_j%5Ek+x%5Ej%2Bx_i+A_j%5Ei+%5Cdelta%5E%7Bjk%7D+%5Cdelta_%7Bkk%7D+%5Cdelta%5E%7Bkk%7D&quot; alt=&quot;=A_j^k x^j+x_i A_j^i \delta^{jk} \delta_{kk} \delta^{kk}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3DA_j%5Ek+x%5Ej%2Bx_i+A_j%5Ei+%5Cdelta%5E%7Bj%7D_k+%5Cdelta%5E%7Bkk%7D&quot; alt=&quot;=A_j^k x^j+x_i A_j^i \delta^{j}_k \delta^{kk}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3DA_j%5Ek+x%5Ej%2Bx_i+A_k%5Ei++%5Cdelta%5E%7Bkk%7D&quot; alt=&quot;=A_j^k x^j+x_i A_k^i  \delta^{kk}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3DA_j%5Ek+x%5Ej%2B%5Cdelta_%7Bii%7Dx%5Ei+A_k%5Ei++%5Cdelta%5E%7Bkk%7D&quot; alt=&quot;=A_j^k x^j+\delta_{ii}x^i A_k^i  \delta^{kk}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3DAx%2BA%5E%7B%5Ctop%7Dx&quot; alt=&quot;=Ax+A^{\top}x&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;计算 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y%5Codot+%28Xw%29&quot; alt=&quot;y\odot (Xw)&quot; eeimg=&quot;1&quot;/&gt; 对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;/&gt; 的导数：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+%28y%5Codot+%28Xw%29%29%7D%7B%5Cpartial+X%7D&quot; alt=&quot;\frac{\partial (y\odot (Xw))}{\partial X}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3D%5Cfrac%7B%5Cpartial+%28y%5Ei+X_j%5Eiw%5Ej%29%7D%7B%5Cpartial+X_k%5El%7D&quot; alt=&quot;=\frac{\partial (y^i X_j^iw^j)}{\partial X_k^l}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3Dy%5Ei%5Cdelta%5E%7Bil%7D%5Cdelta_%7Bjk%7Dw%5Ej&quot; alt=&quot;=y^i\delta^{il}\delta_{jk}w^j&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3Dy%5Ei%5Cdelta%5E%7Bil%7Dw_k&quot; alt=&quot;=y^i\delta^{il}w_k&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%3D%5Coperatorname%7Bdiag%7D%28y%29%5Cotimes+w%5E%5Ctop&quot; alt=&quot;=\operatorname{diag}(y)\otimes w^\top&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;需要注意的是， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta_%7Bii%7D&quot; alt=&quot;\delta_{ii}&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta%5E%7Bii%7D&quot; alt=&quot;\delta^{ii}&quot; eeimg=&quot;1&quot;/&gt; 并不像常规的Kronecker符号一样等于n（n是下标对应的维数），而是满足&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta_%7Bii%7D%5Cdelta%5E%7Bii%7D%3D1&quot; alt=&quot;\delta_{ii}\delta^{ii}=1&quot; eeimg=&quot;1&quot;/&gt; ，它有特殊的用途。在本文中，它主要用于表示矩阵转置。在爱因斯坦约定中，表示矩阵转置是一个容易引起记号混乱的事，如果使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_i%5Ej&quot; alt=&quot;A_i^j&quot; eeimg=&quot;1&quot;/&gt; 表示原矩阵（方阵）， &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_j%5Ei&quot; alt=&quot;A_j^i&quot; eeimg=&quot;1&quot;/&gt; 表示转置矩阵，那么原本 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_i%5Ej+x%5Ei%3Dy%5Ej&quot; alt=&quot;A_i^j x^i=y^j&quot; eeimg=&quot;1&quot;/&gt; ，转置后却因为指标无法缩并而无法相乘得到列向量了： &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_j%5Ei+%3F+x%5Ei&quot; alt=&quot;A_j^i ? x^i&quot; eeimg=&quot;1&quot;/&gt; ，这是匪夷所思的。但是根据上面的定义，可以使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_j%5Ei+%5Cdelta_%7Bii%7D%5Cdelta%5E%7Bjj%7Dx%5Ei&quot; alt=&quot;A_j^i \delta_{ii}\delta^{jj}x^i&quot; eeimg=&quot;1&quot;/&gt; 表示 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5E%5Ctop+x&quot; alt=&quot;A^\top x&quot; eeimg=&quot;1&quot;/&gt; ，而不会产生歧义。事实上，在爱因斯坦约定中，指标只能用于表示张量的各个维，如果张量是对称的，那么不管怎么排列指标，表达式看起来都是一样的，因此本文的参考文献[4]使用了上述 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta_%7Bii%7D&quot; alt=&quot;\delta_{ii}&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cdelta%5E%7Bii%7D&quot; alt=&quot;\delta^{ii}&quot; eeimg=&quot;1&quot;/&gt; 符号规避了此问题。&lt;/p&gt;&lt;p&gt;如果你没有看懂本文，没有关系，使用参考文献[4]对应的网站&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//matrixcalculus.org/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;matrixcalculus.org/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;即可在线计算矩阵、张量求导。即使你不懂如何计算爱因斯坦约定，你也可以通过numpy的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.scipy.org/doc/numpy/reference/generated/numpy.einsum.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;np.einsum()&lt;/a&gt;来帮助你计算爱因斯坦约定，更多有关爱因斯坦约定的内容请参考[10]。&lt;/p&gt;&lt;p&gt;在tensorflow中使用&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Einstein_notation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;爱因斯坦求和约定&lt;/a&gt;可以极大的简化代码，使用以下代码实现矩阵乘法：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=R%3DA+B%5Cquad+R_i%5Ek%3DA_i%5Ej+B_j%5Ek&quot; alt=&quot;R=A B\quad R_i^k=A_i^j B_j^k&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tensorflow&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tf&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;einsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;ij,jk-&amp;gt;ik&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;参考文献&lt;/b&gt;&lt;/p&gt;&lt;p&gt;[1] &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Matrix_calculus&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Matrix calculus - Wikipedia&lt;/a&gt; &lt;/p&gt;&lt;p&gt;[2] &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Tensor_index_notation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ricci calculus - Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[3] &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Kronecker_delta&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Kronecker delta - Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[4] S. Laue, M. Mitterreiter, and J. Giesen. Computing Higher Order Derivatives of Matrix and Tensor Expressions, NIPS 2018.&lt;/p&gt;&lt;p&gt;[5] &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Einstein_notation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Einstein notation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[6] &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Bilinear_map&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bilinear map - Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[7] &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Linear_form&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Linear form - Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[8] &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Covariance_and_contravariance_of_vectors&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Covariance and contravariance of vectors&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[9] &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Abstract_index_notation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Abstract index notation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[10] &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zhangwfjh.wordpress.com/2014/07/19/einstein-notation-and-generalized-kronecker-symbol/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Einstein notation and generalized Kronecker symbol&lt;/a&gt; &lt;/p&gt;</description>
<author>柴士童</author>
<guid isPermaLink="false">2019-05-30-63176747</guid>
<pubDate>Thu, 30 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Cubical Type Theory 实现 contributor 招募</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-25-66954600.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66954600&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hello....&lt;/p&gt;&lt;p&gt;本人正在写一个cartisian cubical type theory的实现 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/molikto/mlang&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/molikto/mlan&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt; ..&lt;/p&gt;&lt;p&gt;已经实现了基本的 MLTT, path type, 部分的 comp 和 coe, implicit arguments.&lt;/p&gt;&lt;p&gt;目前还没有 hit 和 univalance; comp, coe 也没有对 sum type 实现. 也没有 HIT 和 univalance. termination checking 和 coverage checking 也没有.&lt;/p&gt;&lt;p&gt;还很不完善, 比如 implicit arguments 和 context restriction 的实现还没有经过仔细的推敲, 所以有一些我已知但是没有解决的 bug.&lt;/p&gt;&lt;p&gt;基本的一些例子现在基本在这两个文件夹: &lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/molikto/mlang/tree/master/tests/pass&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/molikto/mlan&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;g/tree/master/tests/pass&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/molikto/mlang/tree/master/library/01_foundations&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-373df4b256abdb6bf3208b3dbaed10ed_ipico.jpg&quot; data-image-width=&quot;354&quot; data-image-height=&quot;353&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;molikto/mlang&lt;/a&gt;&lt;p&gt;其中的tests文件名可以看作部分feature的概览...&lt;/p&gt;&lt;p&gt;现在欢迎大家 contribute 实现代码...&lt;/p&gt;&lt;p&gt;如果 bug 解决的差不多了, 并且也实现了 HIT 和 univalance 之后, 就可以 contribute 库代码了 (移植 Cubical Agda 的 library). 但感觉现在还不是时候.&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;或者欢迎对 dependent type 实现有兴趣的同学去 Gitter 闲聊...&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/mlang-discuess/community%3Futm_source%3Dbadge%26utm_medium%3Dbadge%26utm_campaign%3Dpr-badge%26utm_content%3Dbadge&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gitter.im/mlang-discues&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;s/community?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/mlang-discuess/community%3Futm_source%3Dbadge%26utm_medium%3Dbadge%26utm_campaign%3Dpr-badge%26utm_content%3Dbadge&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;mlang-discuess/community&lt;/a&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitter.im/mlang-discuess/community%3Futm_source%3Dbadge%26utm_medium%3Dbadge%26utm_campaign%3Dpr-badge%26utm_content%3Dbadge&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;mlang-discuess/community&lt;/a&gt;&lt;/p&gt;</description>
<author>Minghao Liu</author>
<guid isPermaLink="false">2019-05-25-66954600</guid>
<pubDate>Sat, 25 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>超市买菜</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-20-66349646.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66349646&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;几天前，有个人来找我，问我：‘我这语言语法设计得怎么样？’&lt;/p&gt;&lt;p&gt;我连语法都没看，就问：‘你这语言的设计&lt;b&gt;目的&lt;/b&gt;是什么？’&lt;/p&gt;&lt;p&gt;&amp;#39;我希望设计一个语言，融合FP跟OOP，这样我可以既有FP的表达力，也有OOP的易用性&amp;#39;&lt;/p&gt;&lt;p&gt;我忍着吐槽的欲望，问：‘那你有继承吧？’&lt;/p&gt;&lt;p&gt;‘有’&lt;/p&gt;&lt;p&gt;‘那Subtyping呢？’&lt;/p&gt;&lt;p&gt;‘当然也有’&lt;/p&gt;&lt;p&gt;‘那你打算怎么做类型推导？’&lt;/p&gt;&lt;p&gt;‘Algorithm W’&lt;/p&gt;&lt;p&gt;‘你该知道，Algorithm W是靠unification做推导的，你如果有subtyping，跟Algorithm W不相容，你想好这么解了吗？’&lt;/p&gt;&lt;p&gt;‘啊。。没有’&lt;/p&gt;&lt;p&gt;其实如果答出来，还有很多相近的设计问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OOP提倡extensibility，但是FP的ADT是封闭的，无法扩展新类型 - 而Class/Object无法在类型安全且不更改以前代码的前提下扩展新的method，这个语言该怎么提高扩展性？&lt;/li&gt;&lt;li&gt;Invariant/Covariant/Contravariant/Recursive Type/Existential Universal Quantification/Module的Subtyping怎么做？&lt;/li&gt;&lt;li&gt;Ad Hoc Polymorphism呢？如果靠Typeclass，这套东西怎么跟OOP的Class System整合？如果靠implicit Coherent问题怎么解决？&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些问题不是不能解，毕竟融合FP跟OOP的语言一大推，OCaml跟Scala不说，往早说，Luca的一推paper全是这个套路，&lt;b&gt;但是问题是，当你要设计语言的时候，这些东西要先考虑清楚，而不是先去考虑语法&lt;/b&gt;。比如说Subtyping可以看F&amp;lt;:跟MLSub，Extensibility可以看MLPolyR/Data a la carte/Object Algebra。&lt;/p&gt;&lt;p&gt;另一个我想吐槽的事情，就是‘超市买菜’模型。很多人在设计语言的时候，都会有如下的思路：‘X是好的，Y是好的，Z是好的，我也刚好都需要，所以我这个语言要有X, Y, Z。’,比如上面那个人，就认为‘FP是好的，OOP是好的，我都需要，于是我去设计语法去了’&lt;/p&gt;&lt;p&gt;这样做的问题是完全没考虑到各种feature之间的互相影响-而这才是设计语言最麻烦的地方。&lt;/p&gt;&lt;p&gt;比如说，某个语言是Dynamically Typed的，但是有个叫Type Stability的概念：如果我能静态用Dataflow Analysis分析出类型，我就会用Type Directed Compilation做传统静态类型的优化。同时，我提供Type Annotation，所以如果分析不出来还可以手动加类型。&lt;/p&gt;&lt;p&gt;那好，这语言有Reference（指针），这再加上Higher Order Function，跟Dataflow Analysis很合不来，随便写点高阶的东西推不出，性能突然暴死怎么办？而Type Annotation则因为这个语言有Subtyping，同时Type Annotation选择会runtime check/convert的原因，导致没有Arrow Type，所以无法给高阶函数加Annotation，而这又恰巧是最需要的时候。。（Gradual Typing性能坑，而且他们还有Union Type，这下不止性能有问题，连做都不好做，见&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//dl.acm.org/citation.cfm%3Fid%3D3276504&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The root cause of blame: contracts for intersection and union types&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;IMO，如果设计语言，应该正好反过来：很多人都是先设计语法，然后再写实现，最后interaction管都不管听天由命的。如果是这个顺序：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先去考虑我这个语言的&lt;b&gt;目的&lt;/b&gt;是什么（提示：如果你不是GRAIL，Scratch，APL，那答案不会是‘语法’）（提示：答案九成是‘我在设计这个领域的DSL’。）&lt;/li&gt;&lt;li&gt;然后去找可以实现目的的&lt;b&gt;最小&lt;/b&gt;feature set-不可以被desugar的feature set越大，设计如上所说，越多坑，静态分析/类型推导/Partial Evaluation等操作也越难实现（要处理的case更多是一码事，不好处理的特性也是一码事（比如高阶语言不适合静态分析，指针不适合Partial Eval，Lambda Cube越往上爬越不好推类型，Subtyping更不好推等等））&lt;/li&gt;&lt;li&gt;想想看自己要实现的Pass，脑袋里面建个大概的蓝图，想想要采用啥算法，看看有没有坑（要用Dataflow analysis做分析？跟高阶函数说再见吧。HM？Subtyping不相容。想在Effectful Language里面做Dead Code Elimination？你还是高阶的？好好想想Effect Analysis怎么设计吧）&lt;/li&gt;&lt;li&gt;如果上一步发现&lt;b&gt;冲突&lt;/b&gt;，移除一定的Feature/Pass，看看能不能被啥弥补，或者直接不要，然后接着找冲突&lt;/li&gt;&lt;li&gt;好了，开始实现各种Pass吧&lt;/li&gt;&lt;li&gt;到了最后，才到实现Surface Language/Concrete Syntax/Parser/Pretty Printing/IDE Support这些外观上的东西的地步。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那才可以在第零时间发现这些特性/Pass interact的坑，也可以有个明确的目的，而不是看到啥好的特性，就往语言里面乱塞，最后做出一个跟C++一样复杂坑多又不好扩展的语言。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2019-05-20-66349646</guid>
<pubDate>Mon, 20 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>类型系统简介</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-05-20-65626985.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65626985&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11e1ed02fda8354157f6711554a721d4_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;类型系统是编程语言的重要组成部分，本文是对&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//lucacardelli.name/papers/typesystems.pdf&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;type system&lt;/a&gt;&lt;p&gt;的阅读笔记和梗概，强烈推荐感兴趣的同学阅读文章本身。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;h2&gt;类型系统的目的&lt;/h2&gt;&lt;p&gt;&lt;b&gt;类型系统(type system)&lt;/b&gt;的基本目标是防止程序在运行时发生类型错误。当且仅当语言运行时不存在任何形式的类型错误，那么它就是&lt;b&gt;sound&lt;/b&gt;的。soundness是类型系统研究的重要目标。&lt;/p&gt;&lt;h2&gt;对类型系统的描述&lt;/h2&gt;&lt;p&gt;描述类型系统使用的是一种符号系统，它来自于&lt;b&gt;自然推演&lt;/b&gt;(Natural Deduction)。有如下几个组成部分：&lt;/p&gt;&lt;h3&gt;Judgments&lt;/h3&gt;&lt;p&gt;Judgement是一条断言，一般具有如下形式:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+%5CIm&quot; alt=&quot;\Gamma \vdash \Im&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 表示&lt;b&gt;已知的事实&lt;/b&gt;，&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvdash&quot; alt=&quot;\vdash&quot; eeimg=&quot;1&quot;/&gt; 表示&lt;b&gt;推导出&lt;/b&gt;，&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CIm&quot; alt=&quot;\Im&quot; eeimg=&quot;1&quot;/&gt; 表示&lt;b&gt;推导的结果&lt;/b&gt;，类型断言一般用来表示变量具有指定类型。例如：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+M%3AA&quot; alt=&quot;\Gamma \vdash M:A&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;表示在类型环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 中，自由变量M具有类型A。&lt;/p&gt;&lt;p&gt;有一条常用的通用断言：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma+%5Cvdash+%5Cdiamond&quot; alt=&quot;\Gamma \vdash \diamond&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;表示类型环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 是&lt;b&gt;形式良好(well formed)的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;还有一种语义： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma%2C%5C+%5CGamma%27+%5Cvdash+e&quot; alt=&quot;\Gamma,\ \Gamma&amp;#39; \vdash e&quot; eeimg=&quot;1&quot;/&gt; ,这表示了已知环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 加上一个本地环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma%27&quot; alt=&quot;\Gamma&amp;#39;&quot; eeimg=&quot;1&quot;/&gt;，可以推导出e。&lt;/p&gt;&lt;h3&gt;Type rules&lt;/h3&gt;&lt;p&gt;类型规则通过一条或多条断言来决定一条断言的正确性，一般有如下形式：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Rule%5C+name%29%5C+%5C+%28Annotations%29+%5C+%5CGamma_1+%5Cvdash+%5CIm_1+%E2%80%A6+%5CGamma_n+%5Cvdash+%5CIm_n%5C+%28Annotations%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5CIm%7D&quot; alt=&quot;\frac{\begin{gather} (Rule\ name)\ \ (Annotations) \ \Gamma_1 \vdash \Im_1 … \Gamma_n \vdash \Im_n\ (Annotations) \end{gather} }{\Gamma \vdash \Im}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;横线上方是一条或多条判断，描述了规则的&lt;b&gt;前提(premise)&lt;/b&gt;。下方只能有一个判断，描述了规则的&lt;b&gt;结论(conclusion)&lt;/b&gt;。顶部可以标注规则的名称和注释。前提的右边也可以写一些注释。&lt;/p&gt;&lt;p&gt;我们来举个例子：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+n%29%5C+%5C+%28n+%3D+0%2C%5C+1%2C%5C+%E2%80%A6%29+%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+n%3ANat%7D%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+%2B%29+%5C+%5CGamma+%5Cvdash+M%3ANat%5C+%5C+%5C+%5CGamma+%5Cvdash+N%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+M%2BN%3ANat%7D&quot; alt=&quot;\frac {\begin{gather} (Val\ n)\ \ (n = 0,\ 1,\ …) \ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash n:Nat}\ \ \  \frac {\begin{gather} (Val\ +) \ \Gamma \vdash M:Nat\ \ \ \Gamma \vdash N:Nat \end{gather} } {\Gamma \vdash M+N:Nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;这个例子认为在一个行为良好的类型环境中，所有的自然数都有类型Nat，两个类型同为Nat的表达式M和N相加的结果也为一个自然数。&lt;/p&gt;&lt;p&gt;有一条基本规则：空的环境是类型良好的，不需要任何假设：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D&quot; alt=&quot;\frac{\begin{gather} (Env\ \varnothing)\ \  \end{gather} }{\varnothing \vdash \diamond}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;一系列类型规则组成的集合称为一个正式的类型系统。&lt;/p&gt;&lt;h3&gt;Type derivations&lt;/h3&gt;&lt;p&gt;&lt;b&gt;类型导出(Type derivations)&lt;/b&gt;在一个给定的类型系统中，是一颗树，它的底部的根节点和顶部的叶节点都是类型断言，且每条断言都可以由它上方的断言结合类型系统的规则直接获得。给定一个类型断言，我们可以将它放置在类型导出的根部（底部），利用类型规则一步一步向上推导，如果能够顺利推出，说明断言是合法的。&lt;/p&gt;&lt;p&gt;例如根据我们此前的规则，可以判断 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvarnothing+%5Cvdash+1%2B2%3ANat&quot; alt=&quot;\varnothing \vdash 1+2:Nat&quot; eeimg=&quot;1&quot;/&gt; 是否合法：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B+%5Cfrac%7B%7D%7B%5Cfrac%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D%7B%5Cvarnothing+%5Cvdash+1%3ANat%7D%7D+%5C+%5C++%5Cfrac%7B%7D%7B%5Cfrac%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D%7B%5Cvarnothing+%5Cvdash+2%3ANat%7D%7D+%7D%7B%5Cvarnothing+%5Cvdash+1+%2B+2%3A+Nat%7D&quot; alt=&quot;\frac{ \frac{}{\frac{\varnothing \vdash \diamond}{\varnothing \vdash 1:Nat}} \ \  \frac{}{\frac{\varnothing \vdash \diamond}{\varnothing \vdash 2:Nat}} }{\varnothing \vdash 1 + 2: Nat}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Type inference&lt;/h3&gt;&lt;p&gt;给定一个项M，如果它在类型环境 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CGamma&quot; alt=&quot;\Gamma&quot; eeimg=&quot;1&quot;/&gt; 中是&lt;b&gt;良型的(well typed)&lt;/b&gt;，那么存在一个类型A可以赋给M。通过类型导出为M确定A，称为&lt;b&gt;类型推导(Type inference)&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; &lt;/h2&gt;&lt;h2&gt;基础构成&lt;/h2&gt;&lt;h3&gt;语法&lt;/h3&gt;&lt;p&gt;&lt;b&gt;一阶类型化的&lt;/b&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot; eeimg=&quot;1&quot;/&gt; &lt;b&gt;演算(first-order typed &lt;/b&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot; eeimg=&quot;1&quot;/&gt; &lt;b&gt;-calculus)&lt;/b&gt;被称作System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 。我们可以给 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot; eeimg=&quot;1&quot;/&gt; 演算添加类型注释，它的语法如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+A%2C+B+%26%3A%3A%3D%5C+types+%5C%5C+%26K%5C+%5C+%5C+%5C+K+%5Cin+Basic+%26basic%5C+types+%5C%5C+%26A+%5Crightarrow+B+%26function%5C+types+%5C%5C+M%2CN+%26%3A%3A%3D%5C+terms+%5C%5C+%26x+%26variable+%5C%5C+%26%5Clambda+x%3AA.M+%26function+%5C%5C+%26M+N+%26application+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} A, B &amp;amp;::=\ types \\ &amp;amp;K\ \ \ \ K \in Basic &amp;amp;basic\ types \\ &amp;amp;A \rightarrow B &amp;amp;function\ types \\ M,N &amp;amp;::=\ terms \\ &amp;amp;x &amp;amp;variable \\ &amp;amp;\lambda x:A.M &amp;amp;function \\ &amp;amp;M N &amp;amp;application \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;断言&lt;/h3&gt;&lt;p&gt;对于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 我们只需要三条简单的断言：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\Gamma \vdash \diamond\\ &amp;amp;\Gamma \vdash A \\ &amp;amp;\Gamma \vdash M:A \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;规则&lt;/h3&gt;&lt;p&gt;有了这三条断言，我们可以写出它的类型规则：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C++%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+x+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C%5C+x%3AA+%5Cvdash+%5Cdiamond%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Const%29%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond%5C+%5C+%5C+%5C+K+%5Cin+Basic+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+K%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Arrow%29%5C%5C+%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A+%5Crightarrow+B%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+x%29%5C%5C+%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+x%3AA%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun%29%5C%5C+%5CGamma%2C%5C+x%3AA+%5Cvdash+M%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+x%3AA.M%3AA+%5Crightarrow+B%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl%29%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Crightarrow+B%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M+N%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac{\begin{gather} (Env\ \varnothing)\\ \  \end{gather} }{\varnothing \vdash \diamond} \ \ \ \  \frac{\begin{gather} (Env\ x)\\  \Gamma \vdash A\ \ \ \ x \notin dom(\Gamma) \end{gather} }{\Gamma,\ x:A \vdash \diamond} \\ \\ &amp;amp;\frac{\begin{gather} (Type\ Const)\\ \Gamma \vdash \diamond\ \ \ \ K \in Basic \end{gather} }{\Gamma \vdash K}\ \ \ \  \frac{\begin{gather} (Type\ Arrow)\\ \Gamma \vdash A\ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash A \rightarrow B} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ x)\\ \Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash \diamond \end{gather} }{\Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash x:A}\ \ \ \  \frac{\begin{gather} (Val\ Fun)\\ \Gamma,\ x:A \vdash M:B \end{gather} }{\Gamma \vdash \lambda x:A.M:A \rightarrow B}\ \ \ \  \frac{\begin{gather} (Val\ Appl)\\ \Gamma \vdash M:A \rightarrow B\ \ \ \  \Gamma \vdash N:A \end{gather} }{\Gamma \vdash M N:B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;基础类型&lt;/h2&gt;&lt;p&gt;我们有了System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 的基础骨架后，就可以给它增加一些基础类型。&lt;/p&gt;&lt;h3&gt;Unit Type&lt;/h3&gt;&lt;p&gt;Unit Type很常见，在很多语言中它又叫&lt;code&gt;Void&lt;/code&gt;或&lt;code&gt;Null&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Unit%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Unit%7D%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Unit%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+unit%3AUnit%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Unit) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Unit}\ \ \  \frac {\begin{gather} (Val\ Unit) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash unit:Unit}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Bool Type&lt;/h3&gt;&lt;p&gt;Bool Type也很常见，它是布尔值的类型，它一般拥有一个有用的操作，即通常语言中的&lt;code&gt;if else&lt;/code&gt;语句，我们在这里称为&lt;code&gt;cond&lt;/code&gt;:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Bool%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Bool%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+True%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+true%3ABool%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+False%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+false%3ABool%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Cond%29+%5C%5C+%5CGamma+%5Cvdash+M%3ABool+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N_1%3AA+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N_2%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28if_A%5C+M%5C+then%5C+N_1%5C+else%5C+N_2%29%3AA%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Bool) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Bool} \ \ \ \   \frac {\begin{gather} (Val\ True) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash true:Bool} \ \ \ \   \frac {\begin{gather} (Val\ False) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash false:Bool} \\ \\ \frac {\begin{gather} (Val\ Cond) \\ \Gamma \vdash M:Bool \ \ \ \  \Gamma \vdash N_1:A \ \ \ \  \Gamma \vdash N_2:A \end{gather} } {\Gamma \vdash (if_A\ M\ then\ N_1\ else\ N_2):A}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;在Cond中我们需要通过下标A来告诉类型检查器，结果应该是类型A，来消除潜在的类型检查困难。&lt;/p&gt;&lt;h3&gt;Nat Type&lt;/h3&gt;&lt;p&gt;Nat Type就是自然数的类型。假设我们有0和&lt;code&gt;Succ&lt;/code&gt;，则1为&lt;code&gt;Succ 0&lt;/code&gt;，2为&lt;code&gt;Succ Succ 0&lt;/code&gt;。Nat还存在两种计算：&lt;code&gt;pred&lt;/code&gt;和&lt;code&gt;isZero&lt;/code&gt;，前者用来得到当前自然数前一位的自然数，后者用来判断自然数是否为0.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Nat%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Nat%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Zero%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+0%3ANat%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Succ%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+succ%5C+M%3ANat%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pred%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+pred%5C+M%3ANat%7D%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+IsZero%29+%5C%5C+%5CGamma+%5Cvdash+M%3ANat+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+isZero%5C+M%3ABool%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Nat) \\ \Gamma \vdash \diamond \end{gather} }{\Gamma \vdash Nat} \ \ \ \   \frac {\begin{gather} (Val\ Zero) \\ \Gamma \vdash \diamond \end{gather} } {\Gamma \vdash 0:Nat} \ \ \ \   \frac {\begin{gather} (Val\ Succ) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash succ\ M:Nat} \\ \\ \frac {\begin{gather} (Val\ Pred) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash pred\ M:Nat}\ \ \ \  \frac {\begin{gather} (Val\ IsZero) \\ \Gamma \vdash M:Nat \end{gather} } {\Gamma \vdash isZero\ M:Bool}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;结构类型&lt;/h2&gt;&lt;h3&gt;Product Types&lt;/h3&gt;&lt;p&gt;Product Types是一对类型，由两个类型构成，例如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1+%5Ctimes+A_2&quot; alt=&quot;A_1 \times A_2&quot; eeimg=&quot;1&quot;/&gt; 就是一个product type。这两个类型可以通过&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;second&lt;/code&gt;操作符来提取出来。通过&lt;code&gt;with&lt;/code&gt;语句，我们可以把product type解构为两个单独的变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1&quot; alt=&quot;x_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_2&quot; alt=&quot;x_2&quot; eeimg=&quot;1&quot;/&gt; ，应用在作用域N中。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Product%29%5C%5C+%5CGamma+%5Cvdash+A_1%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A_1+%5Ctimes+A_2%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pair%29%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_2%3AA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clangle+M1%2CM2+%5Crangle%3A+A_1+%5Ctimes+A_2%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+First%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2++%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+first%5C+M%3AA_1%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Second%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2++%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+second%5C+M%3AA_2%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+With%29%5C%5C+%5CGamma+%5Cvdash+M%3AA_1+%5Ctimes+A_2%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_1%3AA_1%2C%5C+x_2%3AA_2+%5Cvdash+N%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%28with+%28x_1%3AA_1%2C+x_2%3AA_2%29+%3A%3D+M%5C+do%5C+N%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac{\begin{gather} (Type\ Product)\\ \Gamma \vdash A_1\ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash A_1 \times A_2}\ \ \ \  \frac{\begin{gather} (Val\ Pair)\\ \Gamma \vdash M_1:A_1\ \ \ \  \Gamma \vdash M_2:A_2 \end{gather} }{\Gamma \vdash \langle M1,M2 \rangle: A_1 \times A_2} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ First)\\ \Gamma \vdash M:A_1 \times A_2  \end{gather} }{\Gamma \vdash first\ M:A_1}\ \ \ \  \frac{\begin{gather} (Val\ Second)\\ \Gamma \vdash M:A_1 \times A_2  \end{gather} }{\Gamma \vdash second\ M:A_2} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ With)\\ \Gamma \vdash M:A_1 \times A_2\ \ \ \  \Gamma,\ x_1:A_1,\ x_2:A_2 \vdash N:B \end{gather} }{\Gamma \vdash (with (x_1:A_1, x_2:A_2) := M\ do\ N):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Union Types&lt;/h3&gt;&lt;p&gt;Union Types指的是结合类型。例如一个union type &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1%2BA_2&quot; alt=&quot;A_1+A_2&quot; eeimg=&quot;1&quot;/&gt; 可以认为是一个带有left标记的类型为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1&quot; alt=&quot;A_1&quot; eeimg=&quot;1&quot;/&gt; 的元素或带有right的类型为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_2&quot; alt=&quot;A_2&quot; eeimg=&quot;1&quot;/&gt; 的元素。这一标记可以由&lt;code&gt;isLeft&lt;/code&gt;和&lt;code&gt;isRight&lt;/code&gt;来进行测试，相应的类型可以由&lt;code&gt;asLeft&lt;/code&gt;或&lt;code&gt;asRight&lt;/code&gt;来提取。和之前Bool Type的Cond语句类似，&lt;code&gt;asLeft&lt;/code&gt;和&lt;code&gt;asRight&lt;/code&gt;也需要下标来帮助类型检查器进行判断。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Union%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A_1+%2B+A_2%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+inLeft%29+%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+A_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+inLeft_%7BA_2%7D+M_1%3AA_1+%2B+A_2%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+inRight%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_2%3AA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+inRight_%7BA_1%7D+M_2%3AA_1+%2B+A_2%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+isLeft%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+isLeft%5C+M%3ABool%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+isRight%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+isRight%5C+M%3ABool%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+asLeft%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+asLeft%5C+M%3AA_1%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+asRight%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+asRight%5C+M%3AA_2%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Case%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA_1%2BA_2+%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_1%3AA_1+%5Cvdash+N_1%3AB+%5C+%5C+%5C+%5C++%5CGamma%2C%5C+x_2%3AA_2+%5Cvdash+N_2%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%28case_B+M%5C+of%5C+x_1%3AA_1%5C+then%5C+N_1%5C+%7C%5C+x_2%3AA_2%5C+then%5C+N_2%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Union) \\ \Gamma \vdash A_1 \ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash A_1 + A_2} \ \ \ \  \frac {\begin{gather} (Val\ inLeft) \\ \Gamma \vdash M_1:A_1 \ \ \ \  \Gamma \vdash A_2 \end{gather} }{\Gamma \vdash inLeft_{A_2} M_1:A_1 + A_2} \ \ \ \  \frac {\begin{gather} (Val\ inRight) \\ \Gamma \vdash A_1 \ \ \ \  \Gamma \vdash M_2:A_2 \end{gather} }{\Gamma \vdash inRight_{A_1} M_2:A_1 + A_2} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ isLeft) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash isLeft\ M:Bool} \ \ \ \  \frac {\begin{gather} (Val\ isRight) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash isRight\ M:Bool} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ asLeft) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash asLeft\ M:A_1} \ \ \ \  \frac {\begin{gather} (Val\ asRight) \\ \Gamma \vdash M:A_1+A_2 \end{gather} }{\Gamma \vdash asRight\ M:A_2} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Case) \\ \Gamma \vdash M:A_1+A_2 \ \ \ \  \Gamma,\ x_1:A_1 \vdash N_1:B \ \ \ \  \Gamma,\ x_2:A_2 \vdash N_2:B \end{gather} }{\Gamma \vdash (case_B M\ of\ x_1:A_1\ then\ N_1\ |\ x_2:A_2\ then\ N_2):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;如果&lt;code&gt;asRight&lt;/code&gt;被错误的应用在了由&lt;code&gt;isLeft&lt;/code&gt;标记的元素上，那么我们就得到了一个被捕获的异常，这个异常不属于forbidden error。因此有了union Type，我们可以定义一个典型的被捕获的错误类型：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=error_A+%3D+asRight%28inLeft_A%28unit%29%29%3AA&quot; alt=&quot;error_A = asRight(inLeft_A(unit)):A&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;我们可以用它来表示任何类型的异常。&lt;/p&gt;&lt;h3&gt;Record Types&lt;/h3&gt;&lt;p&gt;Record Types是product types的升级版，它由product types迭代而来。对于record M中的每个组成变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1+%E2%80%A6+x_2&quot; alt=&quot;x_1 … x_2&quot; eeimg=&quot;1&quot;/&gt; ，都有名称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=l_1+%E2%80%A6+l_2&quot; alt=&quot;l_1 … l_2&quot; eeimg=&quot;1&quot;/&gt; 和它绑定。与product types相似，record types也有with语句。Product types &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1+%5Ctimes+A_2&quot; alt=&quot;A_1 \times A_2&quot; eeimg=&quot;1&quot;/&gt; 在record types中可以定义为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Record%28first%3A+A_1%2C+second%3A+A_2%29&quot; alt=&quot;Record(first: A_1, second: A_2)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Record%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+Record%28l_1%3AA_1%2C+%E2%80%A6%2C+l_n%3AA_n%29%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val+Record%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+M_1%3AA_1+%E2%80%A6+%5CGamma+%5Cvdash+M_n%3AA_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+record%28l_1%3DM_1%2C%E2%80%A6%2Cl_n%3DM_n%29%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%7D%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Record%5C+Select%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M.l_j%3AA_j%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Record%5C+With%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARecord%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C++%5CGamma%2Cx_1%3AA_1%2C%E2%80%A6%2Cx_n%3AA_n+%5Cvdash+N%3AB+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+%28with+%28l_1%3Dx_1%3AA_1%2C%E2%80%A6%2Cl_n%3Dx_n%3AA_n%29+%3A%3D+M%5C+do%5C+N%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Record)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \end{gather}} {\Gamma \vdash Record(l_1:A_1, …, l_n:A_n)} \ \ \ \  \frac {\begin{gather} (Val Record)\ \ \ \  (l_i distinct) \\ \Gamma \vdash M_1:A_1 … \Gamma \vdash M_n:A_n \end{gather}} {\Gamma \vdash record(l_1=M_1,…,l_n=M_n):Record(l_1:A_1,…,l_n:A_n)}\\ \\ &amp;amp;\frac {\begin{gather} (Val\ Record\ Select) \\ \Gamma \vdash M:Record(l_1:A_1,…,l_n:A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M.l_j:A_j} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Record\ With) \\ \Gamma \vdash M:Record(l_1:A_1,…,l_n…A_n)\ \ \ \  \Gamma,x_1:A_1,…,x_n:A_n \vdash N:B \end{gather}} {\Gamma \vdash (with (l_1=x_1:A_1,…,l_n=x_n:A_n) := M\ do\ N):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Variant Types&lt;/h3&gt;&lt;p&gt;与recotd types和product的关系类似，variant types也由union types迭代而来。Union types &lt;img src=&quot;https://www.zhihu.com/equation?tex=A_1+%2B+A_2&quot; alt=&quot;A_1 + A_2&quot; eeimg=&quot;1&quot;/&gt; 在variant types中可以被定义为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=Variant%28left%3AA_1%2C+right%3AA_2%29&quot; alt=&quot;Variant(left:A_1, right:A_2)&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Variant%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+Variant%28l_1%3AA_1%2C+%E2%80%A6%2C+l_n%3AA_n%29%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%29%5C+%5C+%5C+%5C++%28l_i+distinct%29+%5C%5C+%5CGamma+%5Cvdash+A_1+%E2%80%A6+%5CGamma+%5Cvdash+A_n+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+M_j%3AA_j+%5C+%5C+%5C+%5C++j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+variant_%7Bl_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%7D%28l_j%3DM_j%29%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%7D%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+Is%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%3AA_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M%5C+is%5C+l_j%3ABool%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+As%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C+j+%5Cin+1..n+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+M%5C+as%5C+l_j%3AA_j%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Variant%5C+Case%29+%5C%5C+%5CGamma+%5Cvdash+M%3AVariant%28l_1%3AA_1%2C%E2%80%A6%2Cl_n%E2%80%A6A_n%29%5C+%5C+%5C+%5C++%5CGamma%2C+x_1%3AA_1+%5Cvdash+N_1%3AB+%E2%80%A6+%5CGamma%2Cx_n%3AA_n+%5Cvdash+N_n%3AB+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%5Cvdash+%28case_B%5C+M%5C+of%5C+l_1%3Dx_1%3AA_1%5C+then%5C+N_1%5C+%7C%E2%80%A6%7C%5C+l_n%3Dx_n%3AA_n%5C+then%5C+N_n%29%3AB%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Variant)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \end{gather}} {\Gamma \vdash Variant(l_1:A_1, …, l_n:A_n)} \ \ \ \  \frac {\begin{gather} (Val\ Variant)\ \ \ \  (l_i distinct) \\ \Gamma \vdash A_1 … \Gamma \vdash A_n \ \ \ \  \Gamma \vdash M_j:A_j \ \ \ \  j \in 1..n \end{gather}} {\Gamma \vdash variant_{l_1:A_1,…,l_n:A_n}(l_j=M_j):Variant(l_1:A_1,…,l_n:A_n)}\\ \\ &amp;amp;\frac {\begin{gather} (Val\ Variant\ Is) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n:A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M\ is\ l_j:Bool} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Variant\ As) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n…A_n)\ \ \ \ j \in 1..n \end{gather}} {\Gamma \vdash M\ as\ l_j:A_j} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Variant\ Case) \\ \Gamma \vdash M:Variant(l_1:A_1,…,l_n…A_n)\ \ \ \  \Gamma, x_1:A_1 \vdash N_1:B … \Gamma,x_n:A_n \vdash N_n:B \end{gather}} {\Gamma \vdash (case_B\ M\ of\ l_1=x_1:A_1\ then\ N_1\ |…|\ l_n=x_n:A_n\ then\ N_n):B} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Reference Types&lt;/h3&gt;&lt;p&gt;引用类型在命令式语言中很常见，它用来包裹地址可变的元素。可以由&lt;code&gt;ref&lt;/code&gt;分配，由&lt;code&gt;assign&lt;/code&gt;更新，并由&lt;code&gt;deref&lt;/code&gt;解除。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Ref%29+%5C%5C+%5CGamma+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+Ref%5C+A%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Ref%29+%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+ref%5C+M%3ARef%5C+A%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Deref%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARef%5C+A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+deref%5C+M%3AA%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Assign%29+%5C%5C+%5CGamma+%5Cvdash+M%3ARef%5C+A+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+M%3A%3DN%3AUnit%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Type\ Ref) \\ \Gamma \vdash A \end{gather} }{\Gamma \vdash Ref\ A} \ \ \ \   \frac {\begin{gather} (Val\ Ref) \\ \Gamma \vdash M:A \end{gather} } {\Gamma \vdash ref\ M:Ref\ A} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Deref) \\ \Gamma \vdash M:Ref\ A \end{gather} } {\Gamma \vdash deref\ M:A} \ \ \ \  \frac {\begin{gather} (Val\ Assign) \\ \Gamma \vdash M:Ref\ A \ \ \ \  \Gamma \vdash N:A \end{gather} } {\Gamma \vdash M:=N:Unit} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Recursive Types&lt;/h3&gt;&lt;p&gt;递归类型需要为环境中扩展一个&lt;b&gt;类型变量X&lt;/b&gt;。类型变量的应用形式为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu+X.A&quot; alt=&quot;\mu X.A&quot; eeimg=&quot;1&quot;/&gt; 。例如有一个树类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+%3D+unit+%2B+int+%5Ctimes+%5Calpha+%5Ctimes+%5Calpha&quot; alt=&quot;\alpha = unit + int \times \alpha \times \alpha&quot; eeimg=&quot;1&quot;/&gt; ，我们可以将等式写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+%3D+%5Ctau&quot; alt=&quot;\alpha = \tau&quot; eeimg=&quot;1&quot;/&gt; ，如果存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Ctau&quot; alt=&quot;\tau&quot; eeimg=&quot;1&quot;/&gt; 不是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha&quot; alt=&quot;\alpha&quot; eeimg=&quot;1&quot;/&gt; ，且有唯一解使等式成立的情况。那么我们将这个解写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu+%5Calpha+.+%5Ctau&quot; alt=&quot;\mu \alpha . \tau&quot; eeimg=&quot;1&quot;/&gt; 。我们通过方式表示这个recursive type。由于在这里 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+%3D+%5Ctau&quot; alt=&quot;\alpha = \tau&quot; eeimg=&quot;1&quot;/&gt; ，那么等式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmu+%5Calpha+.+%5Ctau+%3D+%5Ctau+%7B%5Cfrac+%7B%5Cmu+%5Calpha+.+%5Ctau%7D+%7B%5Calpha%7D%7D&quot; alt=&quot;\mu \alpha . \tau = \tau {\frac {\mu \alpha . \tau} {\alpha}}&quot; eeimg=&quot;1&quot;/&gt; 是成立的。我们把从左向右变换的操作称为&lt;code&gt;unfold&lt;/code&gt;，把从右向左变换的过程称为&lt;code&gt;fold&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Env%5C+X%29+%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5C+%5C+%5C+%5C++X+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C+X+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Rec%29+%5C%5C+%5CGamma%2C+X+%5Cvdash+A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%5Cmu+X.A%7D+%5C%5C+%5C%5C+%26%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fold%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5B%5Cmu+X.A%2FX%5DA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+fold_%7B%5Cmu+X.A%7D+M%3A%5Cmu+X.A%7D+%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Unfold%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cmu+X.A+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+unfold_%7B%5Cmu+X.A%7D+M%3A%5B%5Cmu+X.A+%2F+X%5D+A%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac {\begin{gather} (Env\ X) \\ \Gamma \vdash \diamond \ \ \ \  X \notin dom(\Gamma) \end{gather} }{\Gamma, X \vdash \diamond} \ \ \ \   \frac {\begin{gather} (Type\ Rec) \\ \Gamma, X \vdash A \end{gather} } {\Gamma \vdash \mu X.A} \\ \\ &amp;amp;\frac {\begin{gather} (Val\ Fold) \\ \Gamma \vdash M:[\mu X.A/X]A \end{gather} } {\Gamma \vdash fold_{\mu X.A} M:\mu X.A} \ \ \ \  \frac {\begin{gather} (Val\ Unfold) \\ \Gamma \vdash M:\mu X.A \end{gather} } {\Gamma \vdash unfold_{\mu X.A} M:[\mu X.A / X] A} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h2&gt;System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; &lt;/h2&gt;&lt;h2&gt;Type Parameters&lt;/h2&gt;&lt;p&gt;我们使用一种新语法来表示类型的参数： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+X.M&quot; alt=&quot;\lambda X.M&quot; eeimg=&quot;1&quot;/&gt; ，表示程序M中有类型变量X，例如对于&lt;code&gt;id&lt;/code&gt;函数 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+x%3AA.x&quot; alt=&quot;\lambda x:A.x&quot; eeimg=&quot;1&quot;/&gt; 就可以被写为带有类型变量的： &lt;img src=&quot;https://www.zhihu.com/equation?tex=id+%5Ctriangleq+%5Clambda+X.%5Clambda+x%3AX.x&quot; alt=&quot;id \triangleq \lambda X.\lambda x:X.x&quot; eeimg=&quot;1&quot;/&gt; ，将类型A代入X，写为&lt;code&gt;id A&lt;/code&gt;，就可以得到 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+x%3AA.x&quot; alt=&quot;\lambda x:A.x&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;h3&gt;Universally Quantified Types&lt;/h3&gt;&lt;p&gt;对应新的项： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda+X.M&quot; alt=&quot;\lambda X.M&quot; eeimg=&quot;1&quot;/&gt; ，我们有新的&lt;b&gt;universally quantified types&lt;/b&gt;，前式可写为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+X.A&quot; alt=&quot;\forall X.A&quot; eeimg=&quot;1&quot;/&gt; ，表示对于所有的X，程序体M都有类型A。例如上文中的&lt;code&gt;id&lt;/code&gt;为： &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cforall+X.X+%5Crightarrow+X&quot; alt=&quot;\forall X.X \rightarrow X&quot; eeimg=&quot;1&quot;/&gt; ，表示对于所有的X，&lt;code&gt;id X&lt;/code&gt;都有类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X+%5Crightarrow+X&quot; alt=&quot;X \rightarrow X&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/p&gt;&lt;h2&gt;基础构成&lt;/h2&gt;&lt;h3&gt;语法&lt;/h3&gt;&lt;p&gt;System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; 的类型如下，由于我们有了类型参数，所以System &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 中的基础类型K被去掉了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+A%2C+B+%26%3A%3A%3D%5C+types+%5C%5C+%26X+%26type%5C+variable+%5C%5C+%26A+%5Crightarrow+B+%26function%5C+type+%5C%5C+%26%5Cforall+X.A+%26universally%5C+quantified%5C+type+%5C%5C+M%2CN+%26%3A%3A%3D%5C+terms+%5C%5C+%26x+%26variable+%5C%5C+%26%5Clambda+x%3AA.M+%26function+%5C%5C+%26M+N+%26application+%5C%5C+%26%5Clambda+X.M+%26polymorphic%5C+abstraction+%5C%5C+%26M+A+%26type%5C+instantiation+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} A, B &amp;amp;::=\ types \\ &amp;amp;X &amp;amp;type\ variable \\ &amp;amp;A \rightarrow B &amp;amp;function\ type \\ &amp;amp;\forall X.A &amp;amp;universally\ quantified\ type \\ M,N &amp;amp;::=\ terms \\ &amp;amp;x &amp;amp;variable \\ &amp;amp;\lambda x:A.M &amp;amp;function \\ &amp;amp;M N &amp;amp;application \\ &amp;amp;\lambda X.M &amp;amp;polymorphic\ abstraction \\ &amp;amp;M A &amp;amp;type\ instantiation \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;断言&lt;/h3&gt;&lt;p&gt;对于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; ，断言和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 完全相同：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\Gamma \vdash \diamond\\ &amp;amp;\Gamma \vdash A \\ &amp;amp;\Gamma \vdash M:A \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;规则&lt;/h3&gt;&lt;p&gt;相比 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; 的类型环境添加了类型变量X。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+%5Cvarnothing%29%5C%5C+%5C++%5Cend%7Bgather%7D+%7D%7B%5Cvarnothing+%5Cvdash+%5Cdiamond%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C++%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+x+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D+%7D%7B%5CGamma%2C%5C+x%3AA+%5Cvdash+%5Cdiamond%7D%5C+%5C+%5C+%5C++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Env%5C+x%29%5C%5C+%5CGamma+%5Cvdash+%5Cdiamond+%5C+%5C+%5C+%5C+X+%5Cnotin+dom%28%5CGamma%29+%5Cend%7Bgather%7D%7D+%7B%5CGamma+%2C+X+%5Cvdash+%5Cdiamond%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+X%29%5C%5C+%5CGamma%27%2C+X%2C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C+X%2C+%5CGamma%27%27+%5Cvdash+X%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Arrow%29%5C%5C+%5CGamma+%5Cvdash+A%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+A+%5Crightarrow+B%7D+%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Type%5C+Forall%29%5C%5C+%5CGamma+X%2C+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Cforall+X.A%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+x%29%5C%5C+%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+%5Cdiamond+%5Cend%7Bgather%7D+%7D%7B%5CGamma%27%2C%5C+x%3AA%2C%5C+%5CGamma%27%27+%5Cvdash+x%3AA%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun%29%5C%5C+%5CGamma%2C%5C+x%3AA+%5Cvdash+M%3AB+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+x%3AA.M%3AA+%5Crightarrow+B%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl%29%5C%5C+%5CGamma+%5Cvdash+M%3AA+%5Crightarrow+B%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+N%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M+N%3AB%7D+%5C%5C+%5C%5C+%26%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Fun2%29%5C%5C+%5CGamma%2C+X+%5Cvdash+M%3AA+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Clambda+X.M%3A%5Cforall+X.A%7D%5C+%5C+%5C+%5C++%5Cfrac%7B%5Cbegin%7Bgather%7D+%28Val%5C+Appl2%29%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cforall+X.A+%5C+%5C+%5C+%5C+%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+M%5C+B+%3A+%5BB%2FX%5DA%7D+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\frac{\begin{gather} (Env\ \varnothing)\\ \  \end{gather} }{\varnothing \vdash \diamond} \ \ \ \  \frac{\begin{gather} (Env\ x)\\  \Gamma \vdash A\ \ \ \ x \notin dom(\Gamma) \end{gather} }{\Gamma,\ x:A \vdash \diamond}\ \ \ \  \frac {\begin{gather} (Env\ x)\\ \Gamma \vdash \diamond \ \ \ \ X \notin dom(\Gamma) \end{gather}} {\Gamma , X \vdash \diamond} \\ \\ &amp;amp;\frac{\begin{gather} (Type\ X)\\ \Gamma&amp;#39;, X, \Gamma&amp;#39;&amp;#39; \vdash \diamond \end{gather} }{\Gamma&amp;#39;, X, \Gamma&amp;#39;&amp;#39; \vdash X}\ \ \ \  \frac{\begin{gather} (Type\ Arrow)\\ \Gamma \vdash A\ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash A \rightarrow B} \ \ \ \  \frac{\begin{gather} (Type\ Forall)\\ \Gamma X, \vdash A \end{gather} }{\Gamma \vdash \forall X.A} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ x)\\ \Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash \diamond \end{gather} }{\Gamma&amp;#39;,\ x:A,\ \Gamma&amp;#39;&amp;#39; \vdash x:A}\ \ \ \  \frac{\begin{gather} (Val\ Fun)\\ \Gamma,\ x:A \vdash M:B \end{gather} }{\Gamma \vdash \lambda x:A.M:A \rightarrow B}\ \ \ \  \frac{\begin{gather} (Val\ Appl)\\ \Gamma \vdash M:A \rightarrow B\ \ \ \  \Gamma \vdash N:A \end{gather} }{\Gamma \vdash M N:B} \\ \\ &amp;amp;\frac{\begin{gather} (Val\ Fun2)\\ \Gamma, X \vdash M:A \end{gather} }{\Gamma \vdash \lambda X.M:\forall X.A}\ \ \ \  \frac{\begin{gather} (Val\ Appl2)\\ \Gamma \vdash M:\forall X.A \ \ \ \ \Gamma \vdash B \end{gather} }{\Gamma \vdash M\ B : [B/X]A} \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;p&gt;Appl2中的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5BB%2FX%5DA&quot; alt=&quot;[B/X]A&quot; eeimg=&quot;1&quot;/&gt; 是指用B替换A中出现的X。&lt;/p&gt;&lt;h3&gt;Existentially Quantified Types&lt;/h3&gt;&lt;p&gt;与universally quantified types相反，existentially quantified types表示存在某个类型可以满足等式。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Type%5C+Exists%29+%5C%5C+%5CGamma%2C+X+%5Cvdash+A+%5Cend%7Bgather%7D+%7D%7B%5CGamma+%5Cvdash+%5Cexists+X.A%7D+%5C+%5C+%5C+%5C+++%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Pack%29+%5C%5C+%5CGamma+%5Cvdash+%5BB%2FX%5DM%3A%5BB%2FX%5DA+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28pack_%7B%5Cexists+X.A%7DX+%3D+B%5C+with%5C+M%29%3A+%5Cexists+X.A%7D+%5C%5C+%5C%5C+%5Cfrac+%7B%5Cbegin%7Bgather%7D+%28Val%5C+Open%29+%5C%5C+%5CGamma+%5Cvdash+M%3A%5Cexists+X.A+%5C+%5C+%5C+%5C++%5CGamma%2CX%2Cx%3AA+%5Cvdash+N%3AB+%5C+%5C+%5C+%5C++%5CGamma+%5Cvdash+B+%5Cend%7Bgather%7D+%7D+%7B%5CGamma+%5Cvdash+%28open_B%5C+M%5C+as%5C+X%2C+x%3AA%5C+in%5C+N%29%3AB%7D&quot; alt=&quot;\frac {\begin{gather} (Type\ Exists) \\ \Gamma, X \vdash A \end{gather} }{\Gamma \vdash \exists X.A} \ \ \ \   \frac {\begin{gather} (Val\ Pack) \\ \Gamma \vdash [B/X]M:[B/X]A \end{gather} } {\Gamma \vdash (pack_{\exists X.A}X = B\ with\ M): \exists X.A} \\ \\ \frac {\begin{gather} (Val\ Open) \\ \Gamma \vdash M:\exists X.A \ \ \ \  \Gamma,X,x:A \vdash N:B \ \ \ \  \Gamma \vdash B \end{gather} } {\Gamma \vdash (open_B\ M\ as\ X, x:A\ in\ N):B}&quot; eeimg=&quot;1&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于pack和open，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65626985/%5Bhttp://notebook.xyli.me/TAPL/type-system/%5D(http://notebook.xyli.me/TAPL/type-system/)&quot; class=&quot;internal&quot;&gt;这篇文章&lt;/a&gt;的解释非常详细，推荐阅读。&lt;/p&gt;&lt;h2&gt;子类型&lt;/h2&gt;&lt;p&gt;子类型的定义很简单：如果A是B的子类型，则任何A中的元素都属于B，记为： &lt;img src=&quot;https://www.zhihu.com/equation?tex=A+%3C%3A+B&quot; alt=&quot;A &amp;lt;: B&quot; eeimg=&quot;1&quot;/&gt; 。带有子类型的系统的断言如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%26%5CGamma+%5Cvdash+%5Cdiamond%5C%5C+%26%5CGamma+%5Cvdash+A+%5C%5C+%26%5CGamma+%5Cvdash+A+%3C%3A+B+%5C%5C+%26%5CGamma+%5Cvdash+M%3AA+%5Cend%7Balign%7D&quot; alt=&quot;\begin{align} &amp;amp;\Gamma \vdash \diamond\\ &amp;amp;\Gamma \vdash A \\ &amp;amp;\Gamma \vdash A &amp;lt;: B \\ &amp;amp;\Gamma \vdash M:A \end{align}&quot; eeimg=&quot;1&quot;/&gt; &lt;/p&gt;&lt;h3&gt;Contravariant &amp;amp; Covariant&lt;/h3&gt;&lt;p&gt;&lt;b&gt;逆变(contravariant)和协变(covariant)&lt;/b&gt;是与子类型密切相关。如果有函数类型 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A+%5Crightarrow+B&quot; alt=&quot;A \rightarrow B&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%27+%5Crightarrow+B%27&quot; alt=&quot;A&amp;#39; \rightarrow B&amp;#39;&quot; eeimg=&quot;1&quot;/&gt; ，前者是后者的子类型。那么A一定接受任何A&amp;#39;，所以A&amp;#39;是A的子类型，而产生的B一定属于任何B&amp;#39;，那么B是B&amp;#39;的子类型。可以看出参数的子类型方向变化和函数整体是相反的，所以A是逆变的。而返回结果则是一致的，所以B是协变的。&lt;/p&gt;&lt;p&gt;总是出现在第奇数个箭头左边的类型是函数类型的逆变。&lt;/p&gt;&lt;p&gt;子类型可以与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_1&quot; alt=&quot;F_1&quot; eeimg=&quot;1&quot;/&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=F_2&quot; alt=&quot;F_2&quot; eeimg=&quot;1&quot;/&gt; 结合，没有难以理解的部分，推荐阅读原文 。&lt;/p&gt;</description>
<author>mirone</author>
<guid isPermaLink="false">2019-05-20-65626985</guid>
<pubDate>Mon, 20 May 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
