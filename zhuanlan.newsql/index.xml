<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>TiDB 的后花园</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Wed, 25 Sep 2019 18:28:05 +0800</lastBuildDate>
<item>
<title>TiKV 在京东云对象存储元数据管理的实践</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-24-83781540.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83781540&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-611f8b95212de7861cc8076f3de9fd0a_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;作者介绍&lt;/b&gt;&lt;br/&gt;崔灿，京东云产品研发部专家架构师，目前主要负责京东云对象存储产品的工作。&lt;/blockquote&gt;&lt;p&gt;京东云对象存储是在 2016 年作为公有云对外公开的，主要特点是可靠、安全、海量、低成本，应用于包括一些常用的业务场景，比如京东内部的京东商城视频/图片云存储，面向京东云公有云外部的开发者的服务，和面向政府、企业的私有云服务，甚至混合云服务。&lt;/p&gt;&lt;p&gt;本文将介绍京东云对象存储服务的架构演进，以及迁移到 TiKV 的经验。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;一、对象存储简介&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-386d4ebbb5bcb05e82eb11ee7498abed_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-386d4ebbb5bcb05e82eb11ee7498abed_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-386d4ebbb5bcb05e82eb11ee7498abed_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-386d4ebbb5bcb05e82eb11ee7498abed_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-386d4ebbb5bcb05e82eb11ee7498abed_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 &lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先举例说明一下这里的“对象 (Object)”概念。比如我们把一张照片当作一个“对象”，除了照片本身的二进制数据，它还应该包含一些元信息（照片数据长度、上次修改时间等）、涉及用户的数据（拍摄者、拍摄设备数据等）。对象存储的特点是这些数据不会频繁地修改。&lt;/p&gt;&lt;p&gt;如果是数量比较少的图片存储，我们可能会用类似 LVM 之类的东西，把一个节点上的多个磁盘使用起来，这种方法一般适用于数量级在 1M ~ 10M 的图片。随着业务的增长，图片会越来越多甚至有视频存储，因此我们采用分布式文件系统来存储，这种方法是基于 DFS 的架构（如下图所示）。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-29a0a3106ce903a22a9a8c01e81ae899_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-29a0a3106ce903a22a9a8c01e81ae899_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-29a0a3106ce903a22a9a8c01e81ae899_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-29a0a3106ce903a22a9a8c01e81ae899_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-29a0a3106ce903a22a9a8c01e81ae899_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这种方法的前提是单机容量受限，必须把数据放在多台机器上存储，并且用一个或多个独立的 node 存储元数据，并且元数据会维持树状目录的结构，拆分比较困难。但是这个架构一般适合存储到 10 亿级别的对象，同时存在两个比较大的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据分布式存储在不同的节点上，如果存在一个中心的 master 节点的数据是相对有限的，那么这个机器就不太可能无限扩张下去。&lt;/li&gt;&lt;li&gt;元数据管理是树状结构，它本身并不适合做分布式存储，并且目录结构需要多次访问，不适合把它放到 SSD 上，而更适合放在内存里，然后一般授权一个 master 节点 list。HDFS 基本也是这样。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么如果要求做千亿级的对象存储，如何实现呢？最容易想到的办法是将元数据分布式存储，不再像文件系统中那样存储在单独的机器上，是一个树状结构，而是变成一个平坦结构。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;二、对象存储元数据管理系统&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;回到上面的举例，针对一个图片对象我们主要有四类操作：上传（Put）、下载（Get）、删除（Delete），Scan。Scan 操作相对比较传统 ，比如查看当前有多少图片对象，获取所有图片名称。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 元数据管理系统 v1.0&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b252ad52ac734505bb46cedc5f6de6de_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-b252ad52ac734505bb46cedc5f6de6de_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b252ad52ac734505bb46cedc5f6de6de_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-b252ad52ac734505bb46cedc5f6de6de_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b252ad52ac734505bb46cedc5f6de6de_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;上面是一个最简单、原始的方案，这里 Bucket 相当于名字空间（Namespace）。很多人最开始设计的结构也就是这样的，但后期数据量增长很快的时候会遇到一些问题，如下图。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5db9fd80613f4e2c162a6e715518aaf4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-5db9fd80613f4e2c162a6e715518aaf4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5db9fd80613f4e2c162a6e715518aaf4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-5db9fd80613f4e2c162a6e715518aaf4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5db9fd80613f4e2c162a6e715518aaf4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第一个问题是，在初期数据量比较小的时候，可能只分了 4 个 Bucket 存储，随着业务增长，需要重新拆分到 400 个 Bucket 中，数据迁移是一个 Rehash 过程，这是一件非常复杂且麻烦的事情。所以，我们在思考对象存储连续的、跨数量级的无限扩展要怎么做呢？下图是一个相对复杂的解决方案，核心思想是把绝大部分数据做静态处理，因为静态的存储，无论是做迁移还是做拆分，都比较简单。比如每天都把前一天写入的数据静态化，合到历史数据中去。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fcf1dd399c6dba258988dbd3564e5e65_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-fcf1dd399c6dba258988dbd3564e5e65_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fcf1dd399c6dba258988dbd3564e5e65_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-fcf1dd399c6dba258988dbd3564e5e65_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-fcf1dd399c6dba258988dbd3564e5e65_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;针对第二个问题，如果单个 Bucket 数据量很大，那么在往 Stable Meta（上图中黄色部分）做静态化迁移时需要做深度拆分，单个 Bucket 的对象的数量非常多，在一个数据库里面存储不下来，需要存储在多个数据库里面，再建立一层索引，存储每个数据库里面存储那个区间的数据。同时，我们在运行的时候其实也会出现一个 Bucket 数量变多的情况，这种是属于非预期的变多，这种情况下我们的做法是弄了一大堆外部的监控程序，监控 Bucket 的量，在 Bucket 量过大的时候，会主动去触发表分裂、迁移等一系列流程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ce0bf8904a94acc5ec501d265412f0c1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-ce0bf8904a94acc5ec501d265412f0c1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ce0bf8904a94acc5ec501d265412f0c1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-ce0bf8904a94acc5ec501d265412f0c1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ce0bf8904a94acc5ec501d265412f0c1_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;这个解决方案有两个明显的问题，第一数据分布复杂，管理困难；第二，调度不灵活，给后期维护带来很大的困难。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-94d42c3fb18b15496a0ce8995975d446_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-94d42c3fb18b15496a0ce8995975d446_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-94d42c3fb18b15496a0ce8995975d446_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;522&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-94d42c3fb18b15496a0ce8995975d446_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-94d42c3fb18b15496a0ce8995975d446_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;所以，我们思考了这个事情本质其实是做一个全局有序 KV，并且需要“足够大”，能够弹性扩张。这样系统架构就会变得非常简单（如上图所示）。当然最终我们找到了分布式 KV 数据库—— TiKV。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 基于 TiKV 的元数据管理系统&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们前期调研了很多产品，最终选择 TiKV 主要原因有以下四点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;全局有序 KV，可轻松⽔平扩展，功能上完全能够满⾜对象存储元数据管理的需求。&lt;/li&gt;&lt;li&gt;经过一些测试，性能上很好，能够满足要求。&lt;/li&gt;&lt;li&gt;社区活跃，文档和工具相对比较完善。这一点也很重要，TiKV 目前已经是 CNCF（云原生计算基金会）的孵化项目，很多功能可以快速开发，产品迭代也很迅速。&lt;/li&gt;&lt;li&gt;相对于 TiDB Server 而言，TiKV 的代码更加简单，而且我们后续可以在 TiKV 的基础上做更多开发工作。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在上线之前，我们主要进行了以下几方面的测试：                       &lt;/p&gt;&lt;ul&gt;&lt;li&gt;功能测试：测试 TiKV 的基本功能是否满足业务需求。&lt;/li&gt;&lt;li&gt;性能测试：测试了常规的 QPS、Latency (Avg, TP90, TP99) 等指标。&lt;/li&gt;&lt;li&gt;异常测试：其实我们做数据存储的同学往往最关注的是各种异常故障的情况，性能倒是其次，而且分布式存储相比单机存储更为复杂。所以我们测试了各种机器/磁盘/网络故障，业务异常情况。更进一步的，我们将这些异常情况随机组合，并在系统内触发，再验证系统的正确性。  &lt;/li&gt;&lt;li&gt;预发布环境验证：在大规模上线之前，我们会在相对不太重要的、实际业务上跑一段时间，收集一些问题和可优化的部分，包括运维上的调优等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过上面的测试我们认为 TiKV 无论是从性能还是系统安全性的角度，都能很好的满足要求，于是我们在 TiKV 基础之上，实现了对象元数据管理系统 v2.0，如下图所示。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9812c4f0fd4afb8d1b32dd50735c0dfb_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-9812c4f0fd4afb8d1b32dd50735c0dfb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9812c4f0fd4afb8d1b32dd50735c0dfb_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-9812c4f0fd4afb8d1b32dd50735c0dfb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9812c4f0fd4afb8d1b32dd50735c0dfb_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;将 v1.0 中一堆复杂的数据库和逻辑结构用 TiKV 替代之后，整个系统变得非常简洁。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;三、业务迁移&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;很多用户可能直接将 MySQL 迁移到 TiDB 上，这个迁移过程已经非常成熟，但是由于迁移到 TiKV 前人的经验比较少，所以我们在迁移过程中也做了很多探索性的工作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 迁移方案&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-62df5af84e668a3839f9031b8ad617c4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-62df5af84e668a3839f9031b8ad617c4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-62df5af84e668a3839f9031b8ad617c4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;525&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-62df5af84e668a3839f9031b8ad617c4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-62df5af84e668a3839f9031b8ad617c4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;上图是我们设计的迁移方案，首先线上的数据都必须双写，保证数据安全。第二，我们将存量数据设置为只读之后迁移到 TiKV 中，同时迁移过程中的增量数据直接写入 TiKV，每天将前一日的增量数据做静态化处理，然后与 MySQL 中的数据对比，验证数据正确性。另外，如果双写失败，会启用 MySQL backup。&lt;/p&gt;&lt;p&gt;下面详细介绍实际操作过程中的相关细节。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 切换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在存量数据切换方面，我们首先将存量数据静态化，简化迁移、数据对比、回滚的流程；在增量数据切换方面，首先将增量数据双写 TiKV &amp;amp; MySQL，并且保证出现异常情况时快速回滚至 MySQL，不影响线上的业务。值得一提的是，由于 TiKV 在测试环境下的验证结果非常好，所以我们采用 TiKV 作为双写的 Primary。&lt;/p&gt;&lt;p&gt;整个切换 过程分为三个步骤：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;存量数据切换到 TiKV，验证读。&lt;/li&gt;&lt;li&gt;增量数据切换到 TiKV，验证读写。&lt;/li&gt;&lt;li&gt;验证 TiKV 中的数据正确性之后，就下线 MySQL。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;3. 验证&lt;/b&gt;&lt;/p&gt;&lt;p&gt;数据验证过程最大的困难在于增量数据的验证，因为增量数据是每天变化的，所以我们双写了 MySQL 和 TiKV，并且每天将增量数据进行静态化处理，用 MySQL 中的记录来验证 TiKV 的数据是否可靠（没有出现数据丢失和错误），如下图所示。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fd796a16ecc5dd055ae3a00c359d5c93_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;466&quot; data-rawheight=&quot;504&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;466&quot; data-original=&quot;https://pic4.zhimg.com/v2-fd796a16ecc5dd055ae3a00c359d5c93_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fd796a16ecc5dd055ae3a00c359d5c93_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;466&quot; data-rawheight=&quot;504&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;466&quot; data-original=&quot;https://pic4.zhimg.com/v2-fd796a16ecc5dd055ae3a00c359d5c93_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-fd796a16ecc5dd055ae3a00c359d5c93_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因为同时双写 MySQL 和 TiKV 可能会出现一种情况是，写入 TiKV 就成功了，但是写入 MySQL 失败了，这两个写入不在同一个事务中，所以不能保证一定同时成功或者失败，尤其是在业务量比较大的情况下。对于这种不一致的情况，我们会通过业务层的操作记录，来判断是由于业务层的问题导致的，还是由 TiKV 导致的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;四、业务现状及后续优化工作&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;目前 TiKV 在京东云对象存储业务上是 Primary 数据库，计划 2019 年年底会把原数据库下线。总共部署的集群数量为 10+，生产环境单集群 QPS 峰值 4 万（读写 1:1），最大的单集群数据量 200+亿，共有 50 余万个 Region，我们元数据管理业务对 Latency 要求比较高，目前 Latency 能保证在 10ms 左右。另外，我们正在测试 TiKV 3.0，预计 2019 年第四季度能够上线。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;针对目前的业务运行情况，我们后续还将做一些优化工作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一点是灾备&lt;/b&gt;，目前我们是在业务层做灾备，后续可能会直接在 TiKV 层做灾备，也很期待 TiKV 之后的版本中能够有这方面的功能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二点是集群规模优化&lt;/b&gt;，因为对象存储是存储密集型的业务，我们希望压缩硬件成本，比如可以用到 8T 、10T 的磁盘，或者用更廉价的磁盘，这点我们后续可能 PingCAP 研发同学们一起考虑怎么优化提升。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三点是 Region 调度优化&lt;/b&gt;，目前 TiKV 的调度整体比较复杂，这对于存储密集型的业务来说就比较麻烦，尤其是数据量特别大的情况下，我们并不希望有一丝的波动就把数据迁移到其他机器上。&lt;/p&gt;&lt;p&gt;&lt;i&gt;本文整理自崔灿老师在 TiDB TechDay 2019 杭州站上的演讲。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;&lt;b&gt;更多精彩案例：&lt;/b&gt;&lt;/i&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/cases-cn/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;案例 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-24-83781540</guid>
<pubDate>Tue, 24 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>广州见！PingCAP Talent Plan 第四期即将开启</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-19-83232114.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83232114&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bf19b99a508a22402bb89d40dc1adc02_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;大家期待已久的第四期 PingCAP Talent Plan 线下培训课程，将在 10 月 14 日于 PingCAP 广州 Office 开启！这可能是今年最后一波分布式数据库「从入门到实战开发」的系统培训哦，错过只能等明年啦～ &lt;/blockquote&gt;&lt;p&gt;众所周知，PingCAP Talent Plan 是我们为 TiDB 开源社区小伙伴提供的学习通道，&lt;b&gt;课程围绕着 SQL 引擎 &amp;amp; 分布式存储的基础知识和前沿技术（包括 Go、Rust 两门编程语言）设计&lt;/b&gt;，线下课程培训更注重通过实战练习，帮助学员提升实操能力，甚至有能力参与工业级分布式数据库项目 TiDB 的开发。&lt;/p&gt;&lt;p&gt;自 2018 年启动至今，已知的参与线上课程学习的人数已突破 200 人，而线下课程培训也已成功举办 3 期，共 30 余名学员通过线下考核顺利结业，其中有 8 名学员更是以实习生/校招生的身份加入了 PingCAP。当然也有不少学员继续活跃在 TiDB 开源社区的其他活动中，并开启了 Contributor 的进阶之路。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;自第三期线下培训落幕，就有小伙伴来问第四期将有哪些“新玩法”，现在这就一并透露啦～请往下看！&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;第四期线下课程安排&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4fa03844208905242cf7a754a3d00e25_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;551&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-4fa03844208905242cf7a754a3d00e25_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4fa03844208905242cf7a754a3d00e25_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;551&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic2.zhimg.com/v2-4fa03844208905242cf7a754a3d00e25_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4fa03844208905242cf7a754a3d00e25_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;* 注：线上课程详见文末【阅读原文】链接，通过线上课程考核且成绩优异的同学就有机会参与线下培训哦～&lt;/p&gt;&lt;h2&gt;&lt;b&gt;本期 Talent Plan “新玩法”&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;1. 增加在线视频教学内容，突破学习时间和地点的限制&lt;/b&gt;有不少参加线下课程的学员反馈说，除了现场授课之外，也希望课下能够提供更多视频资源方便进行知识巩固。所以，&lt;b&gt;本期线下课程中将增加在线视频教学的内容，视频可以课后回放，反复温习。&lt;/b&gt;后续我们也会定期选取部分优质的课程视频，开放给没有参与线下培训的社区小伙伴，让更多人有机会体验 Talent Plan 的干货课程。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 与 TiDB Hackathon 2019 相结合，实现从理论到工程的蜕变&lt;/b&gt;10 月 26 ～ 27日，恰逢我们举办 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489710%26idx%3D1%26sn%3D6cd0480cd7d134de44b0f743684a5289%26chksm%3Deb163fc4dc61b6d2dc1ed81599d8e3c84b9efdf6cc5516ee2e3f08e158da9e2fae1eefd50920%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Hackathon 2019&lt;/a&gt;&lt;/u&gt;，所以我们将线下实战题目与 Hackathon 的主题相结合，&lt;b&gt;学员们可以使用线下实战题目直接参与 Hackathon 比赛&lt;/b&gt;。学员们不仅能够阶段性检验自己学习成果，还可以与众多大咖导师零距离交流，获得新的启发，在代码世界中实现自我蜕变（可能还会拿个大奖回家 ^ ^），戳 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489710%26idx%3D1%26sn%3D6cd0480cd7d134de44b0f743684a5289%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;&lt;/u&gt; 了解更多关于 TiDB Hackathon 2019 的信息。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 授课地点在毗邻珠江的广州 Office，带你体验分布式办公的独特魅力&lt;/b&gt;前三期学员们大部分时间都在 PingCAP 北京 Office 集中学习。不过，当北京的十月已经红叶满地，并裹挟着一丝秋冬交接的寒意时，广州则刚刚敛去夏日的炎热，舒适宜人，于是我们将本期授课地点选在了广州 Office，学员们还可以趁此机会，体验一下“PingCAP 分布式办公 Style”（想要更进一步了解广州 Office，可以戳今日推送第二条）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d09fff27a6712c972a535a9705e2bd48_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;810&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-d09fff27a6712c972a535a9705e2bd48_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d09fff27a6712c972a535a9705e2bd48_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;810&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1080&quot; data-original=&quot;https://pic1.zhimg.com/v2-d09fff27a6712c972a535a9705e2bd48_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d09fff27a6712c972a535a9705e2bd48_b.jpg&quot;/&gt;&lt;figcaption&gt;广州 Office 实景⬆️&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;FAQ&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;Q：线上课程是否必须严格遵循学习周计划，在一个月之内完成？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：一个月的学习时长是我们根据学习资料以及题目难易程度给出的建议。考虑到社区小伙伴学习时间比较分散，&lt;b&gt;我们并未对线上课程学习时间做强制要求，大家可以结合自己的时间自由安排&lt;/b&gt;。如果时间充裕能够在一个月内完成那当然再好不过咯~&lt;/p&gt;&lt;p&gt;&lt;b&gt;Q：线上作业完成后如何提交？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：线上作业提交通道（ts-team@pingcap.com）每周六 0:00 开启，至周日 24:00 关闭，持续 48h 开放。大家可选择分批次提交，完成一个 Section 就提交一个 Section，也可以选择完成所有 Section 后集中提交。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Q：能否同时学习 TiDB 和 TiKV 两个方向的线上课程？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：由于线上课程学习时间不做限制，所以如果你的时间和精力充足，我们当然欢迎你多多学习线上课程。但需要特别提醒的是：&lt;b&gt;通过了线上课程考核之后，由于两个方向的线下课程并行授课，所以同一时间段只能选择参与一个方向的线下课程。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Q：如何参与 Talent Plan 线下课程？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：&lt;b&gt;线下课程采用邀请制&lt;/b&gt;，每年会开设 2-3 期，除 7-8 月份的暑期特别企划外，每年的 4-5 月份或 11-12 月份会开设 1-2 期。&lt;b&gt;在线下课程开始前 1 周，完成所有线上作业且成绩优秀的同学将会被邀请参与线下课程。所以在 10 月 8 日前完成线上课程学习的小伙伴将有机会参与第四期的线下课程哦&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;查看线上课程：&lt;/b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//university.pingcap.com/6ee8482c05034a81ba380d40a1570034.shtml%3Fdiliater%3D6YvzZjyL97Z5c4G09GRzLQ%3D%3D&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;university.pingcap.com/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;6ee8482c05034a81ba380d40a1570034.shtml?diliater=6YvzZjyL97Z5c4G09GRzLQ==&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Q：从 Talent Plan 结业之后，我还可以通过哪些方式更进一步了解 TiDB？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A：TiDB 开源社区还有很多有意思的事情等着你去发现。你可以参加社区的其他活动提升技术能力，比如 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489381%26idx%3D1%26sn%3D77bd5b27048bd14a35a8a5e63ba669ca%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;提升 TiDB Parser 对 MySQL 8.0 语法的兼容性&lt;/a&gt;&lt;/u&gt; 或 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489720%26idx%3D1%26sn%3D814c9bb328d00c5ba8443c46c19ff925%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;助力 TiDB 表达式计算性能提升 10 倍&lt;/a&gt;&lt;/u&gt; 等等；如果你喜欢分享，线上 Paper Reading、&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//asktug.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;asktug.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;、Infra Meetup 等都可以成为你进行技术布道的平台。除此之外，你甚至可以选择加入 PingCAP，与 PingCAP 小伙伴一起专注地打造一款应用广泛的、工业级开源数据库产品。总之，我们非常期待着小伙伴们通过 Talent Plan 提升个人技术能力之外，能够持续活跃在 TiDB 开源社区，与 TiDB 一起共同成长～&lt;/p&gt;&lt;p&gt;&lt;b&gt;延展阅读：PingCAP Talent Plan 背后的故事 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489352%26idx%3D1%26sn%3D7fafdf71f32caedea317044fe76e13ad%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;我们是如何设计 Golang &amp;amp; SQL 引擎课程的？&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489198%26idx%3D1%26sn%3D982b72f123f27b8463275345adecd21a%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;我们是如何设计 Rust &amp;amp; 分布式存储教程的？&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NDIxNTQyOQ%3D%3D%26mid%3D2247489451%26idx%3D2%26sn%3D019d4e74677020c2f1f4a1b6f9a352c9%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这门分布式 KV 存储系统课程教会了我什么？&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;blockquote&gt;PingCAP Talent Plan 是 PingCAP 为 TiDB 开源社区小伙伴提供的进阶式学习计划。课程设置上分为两个方向，分别是面向 SQL 引擎的 TiDB 方向和面向大规模、一致性的分布式存储的 TiKV 方向。每个方向的课程都包含线上和线下两部分，线上课程侧重于对基础知识的讲解，对社区所有小伙伴们开放，时间上比较灵活。线下课程在夯实基础知识的基础上，注重实操能力的培养。&lt;br/&gt;完成线上课程并通过线上考核的小伙伴可以获得线上课程结业证书，表现优秀的还将有机会拿到 PingCAP 校招/实习免笔试绿色通道，而且有机会参与半年内 PingCAP 组织的任意一期线下课程；完成线下课程的小伙伴可以获得专属 PingCAP Talent Plan 结业证书，表现优秀的还将有机会拿到 PingCAP 校招/实习免面试绿色通道/Special Offer、 PingCAP/TiDB 全球 Meetup 的邀请函等。&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-19-83232114</guid>
<pubDate>Thu, 19 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>十分钟成为 Contributor 系列 | 助力 TiDB 表达式计算性能提升 10 倍</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-17-82815389.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82815389&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-582f31db4cda79465dc1c28b3dfbd7d7_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;最近我们扩展了 TiDB 表达式计算框架，增加了向量化计算接口，初期的性能测试显示，多数表达式计算性能可大幅提升，部分甚至可提升 1~2 个数量级。为了让所有的表达式都能受益，我们需要为所有内建函数实现向量化计算。&lt;/p&gt;&lt;p&gt;TiDB 的向量化计算是在经典 Volcano 模型上的进行改进，尽可能利用 CPU Cache，SIMD Instructions，Pipeline，Branch Predicatation 等硬件特性提升计算性能，同时降低执行框架的迭代开销，这里提供一些参考文献，供感兴趣的同学阅读和研究：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cidrdb.org/cidr2005/papers/P19.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MonetDB/X100: Hyper-Pipelining Query Execution&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//dare.uva.nl/search%3Fidentifier%3D5ccbb60a-38b8-4eeb-858a-e7735dd37487&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Balancing Vectorized Query Execution with Bandwidth-Optimized Storage&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.nowpublishers.com/article/DownloadSummary/DBS-024&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Design and Implementation of Modern Column-Oriented Database Systems&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在这篇文章中，我们将描述：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;如何在计算框架下实现某个函数的向量化计算；&lt;/li&gt;&lt;li&gt;如何在测试框架下做正确性和性能测试；&lt;/li&gt;&lt;li&gt;如何参与进来成为 TiDB Contributor。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;表达式向量化&lt;/h2&gt;&lt;h3&gt;1. 如何访问和修改一个向量&lt;/h3&gt;&lt;p&gt;在 TiDB 中，数据按列在内存中连续存在 Column 内，Column 详细介绍请看：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-source-code-reading-10/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 源码阅读系列文章（十）Chunk 和执行框架简介&lt;/a&gt;。本文所指的向量，其数据正是存储在 Column 中。&lt;/p&gt;&lt;p&gt;我们把数据类型分为两种：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;定长类型：&lt;code&gt;Int64&lt;/code&gt;、&lt;code&gt;Uint64&lt;/code&gt;、&lt;code&gt;Float32&lt;/code&gt;、&lt;code&gt;Float64&lt;/code&gt;、&lt;code&gt;Decimal&lt;/code&gt;、&lt;code&gt;Time&lt;/code&gt;、&lt;code&gt;Duration&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;变长类型：&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Bytes&lt;/code&gt;、&lt;code&gt;JSON&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;Enum&lt;/code&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;定长类型和变长类型数据在 Column 中有不同的组织方式，这使得他们有如下的特点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;定长类型的 Column 可以随机读写任意元素；&lt;/li&gt;&lt;li&gt;变长类型的 Column 可以随机读，但更改中间某元素后，可能需要移动该元素后续所有元素，导致随机写性能很差。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对于定长类型（如 &lt;code&gt;int64&lt;/code&gt;），我们在计算时会将其转成 Golang Slice（如 &lt;code&gt;[]int64&lt;/code&gt;），然后直接读写这个 Slice。相比于调用 Column 的接口，需要的 CPU 指令更少，性能更好。同时，转换后的 Slice 仍然引用着 Column 中的内存，修改后不用将数据从 Slice 拷贝到 Column 中，开销降到了最低。&lt;/p&gt;&lt;p&gt;对于变长类型，元素长度不固定，且为了保证元素在内存中连续存放，所以不能直接用 Slice 的方式随机读写。我们规定变长类型数据以追加写（&lt;code&gt;append&lt;/code&gt;）的方式更新，用 Column 的 &lt;code&gt;Get()&lt;/code&gt; 接口进行读取。&lt;/p&gt;&lt;p&gt;总的来说，变长和定长类型的读写方式如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;定长类型（以 &lt;code&gt;int64&lt;/code&gt; 为例)&lt;br/&gt;a. &lt;code&gt;ResizeInt64s(size, isNull)&lt;/code&gt;：预分配 size 个元素的空间，并把所有位置的 &lt;code&gt;null&lt;/code&gt; 标记都设置为 &lt;code&gt;isNull&lt;/code&gt;；&lt;br/&gt;b. &lt;code&gt;Int64s()&lt;/code&gt;：返回一个 &lt;code&gt;[]int64&lt;/code&gt; 的 Slice，用于直接读写数据；&lt;br/&gt;c. &lt;code&gt;SetNull(rowID, isNull)&lt;/code&gt;：标记第 &lt;code&gt;rowID&lt;/code&gt; 行为 &lt;code&gt;isNull&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;变长类型（以 &lt;code&gt;string&lt;/code&gt; 为例）&lt;br/&gt;a. &lt;code&gt;ReserveString(size)&lt;/code&gt;：预估 size 个元素的空间，并预先分配内存；&lt;br/&gt;b. &lt;code&gt;AppendString(string)&lt;/code&gt;: 追加一个 string 到向量末尾；&lt;br/&gt;c. &lt;code&gt;AppendNull()&lt;/code&gt;：追加一个 &lt;code&gt;null&lt;/code&gt; 到向量末尾；&lt;br/&gt;d. &lt;code&gt;GetString(rowID)&lt;/code&gt;：读取下标为 &lt;code&gt;rowID&lt;/code&gt; 的 string 数据。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当然还有些其他的方法如 &lt;code&gt;IsNull(rowID)&lt;/code&gt;，&lt;code&gt;MergeNulls(cols)&lt;/code&gt; 等，就交给大家自己去探索了，后面会有这些方法的使用例子。&lt;/p&gt;&lt;h3&gt;2. 表达式向量化计算框架&lt;/h3&gt;&lt;p&gt;向量化的计算接口大概如下（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/blob/master/expression/builtin.go%23L340&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;完整的定义在这里&lt;/a&gt;）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;vectorized() bool
vecEvalXType(input *Chunk, result *Column) error&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;XType&lt;/code&gt; 可能表示 &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt; 等，不同的函数需要实现不同的接口；&lt;/li&gt;&lt;li&gt;&lt;code&gt;input&lt;/code&gt; 表示输入数据，类型为 &lt;code&gt;*Chunk&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;&lt;code&gt;result&lt;/code&gt; 用来存放结果数据。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;外部执行算子（如 Projection，Selection 等算子），在调用表达式接口进行计算前，会通过 &lt;code&gt;vectorized()&lt;/code&gt; 来判断此表达式是否支持向量化计算，如果支持，则调用向量化接口，否则就走行式接口。&lt;/p&gt;&lt;p&gt;对于任意表达式，只有当其中所有函数都支持向量化后，才认为这个表达式是支持向量化的。&lt;/p&gt;&lt;p&gt;比如 &lt;code&gt;(2+6)*3&lt;/code&gt;，只有当 &lt;code&gt;MultiplyInt&lt;/code&gt; 和 &lt;code&gt;PlusInt&lt;/code&gt; 函数都向量化后，它才能被向量化执行。&lt;/p&gt;&lt;h2&gt;为函数实现向量化接口&lt;/h2&gt;&lt;p&gt;要实现函数向量化，还需要为其实现 &lt;code&gt;vecEvalXType()&lt;/code&gt; 和 &lt;code&gt;vectorized()&lt;/code&gt; 接口。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;vectorized()&lt;/code&gt; 接口中返回 &lt;code&gt;true&lt;/code&gt; ，表示该函数已经实现向量化计算；&lt;/li&gt;&lt;li&gt;在 &lt;code&gt;vecEvalXType()&lt;/code&gt; 实现此函数的计算逻辑。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;尚未向量化的函数在&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/issues/12058&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;issue/12058&lt;/a&gt;&lt;/b&gt; &lt;b&gt;中，欢迎感兴趣的同学加入我们一起完成这项宏大的工程。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;向量化代码需放到以 &lt;code&gt;_vec.go&lt;/code&gt; 结尾的文件中，如果还没有这样的文件，欢迎新建一个，注意在文件头部加上 licence 说明。&lt;/p&gt;&lt;p&gt;这里是一个简单的例子 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12012&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR/12012&lt;/a&gt;，以 &lt;code&gt;builtinLog10Sig&lt;/code&gt; 为例：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;这个函数在 &lt;code&gt;expression/builtin_math.go&lt;/code&gt; 文件中，则向量化实现需放到文件 &lt;code&gt;expression/builtin_math_vec.go&lt;/code&gt; 中；&lt;/li&gt;&lt;li&gt;&lt;code&gt;builtinLog10Sig&lt;/code&gt; 原始的非向量化计算接口为 &lt;code&gt;evalReal()&lt;/code&gt;，那么我们需要为其实现对应的向量化接口为 &lt;code&gt;vecEvalReal()&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;实现完成后请根据后续的说明添加测试。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下面为大家介绍在实现向量化计算过程中需要注意的问题。&lt;/p&gt;&lt;h3&gt;1. 如何获取和释放中间结果向量&lt;/h3&gt;&lt;p&gt;存储表达式计算中间结果的向量可通过表达式内部对象 &lt;code&gt;bufAllocator&lt;/code&gt; 的 &lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;put()&lt;/code&gt; 来获取和释放，参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12014&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR/12014&lt;/a&gt;，以 &lt;code&gt;builtinRepeatSig&lt;/code&gt; 的向量化实现为例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;buf2, err := b.bufAllocator.get(types.ETInt, n)
if err != nil {
    return err
}
defer b.bufAllocator.put(buf2) // 注意释放之前申请的内存&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;2. 如何更新定长类型的结果&lt;/h3&gt;&lt;p&gt;如前文所说，我们需要使用 &lt;code&gt;ResizeXType()&lt;/code&gt; 和 &lt;code&gt;XTypes()&lt;/code&gt; 来初始化和获取用于存储定长类型数据的 Golang Slice，直接读写这个 Slice 来完成数据操作，另外也可以使用 &lt;code&gt;SetNull()&lt;/code&gt; 来设置某个元素为 &lt;code&gt;NULL&lt;/code&gt;。代码参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12012&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR/12012&lt;/a&gt;，以 &lt;code&gt;builtinLog10Sig&lt;/code&gt; 的向量化实现为例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;f64s := result.Float64s()
for i := 0; i &amp;lt; n; i++ {
    if isNull {
        result.SetNull(i, true)
    } else {
        f64s[i] = math.Log10(f64s[i])
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;3. 如何更新变长类型的结果&lt;/h3&gt;&lt;p&gt;如前文所说，我们需要使用 &lt;code&gt;ReserveXType()&lt;/code&gt; 来为变长类型预分配一段内存（降低 Golang runtime.growslice() 的开销），使用 &lt;code&gt;AppendXType()&lt;/code&gt; 来追加一个变长类型的元素，使用 &lt;code&gt;GetXType()&lt;/code&gt; 来读取一个变长类型的元素。代码参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12014&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR/12014&lt;/a&gt;，以 &lt;code&gt;builtinRepeatSig&lt;/code&gt; 的向量化实现为例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;result.ReserveString(n)
...
for i := 0; i &amp;lt; n; i++ {
    str := buf.GetString(i)
    if isNull {
        result.AppendNull()
    } else {
    result.AppendString(strings.Repeat(str, int(num)))
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;4. 如何处理 Error&lt;/h3&gt;&lt;p&gt;所有受 SQL Mode 控制的 Error，都利用对应的错误处理函数在函数内就地处理。部分 Error 可能会被转换成 Warn 而不需要立即抛出。&lt;/p&gt;&lt;p&gt;这个比较杂，需要查看对应的非向量化接口了解具体行为。代码参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/12042&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR/12042&lt;/a&gt;，以 &lt;code&gt;builtinCastIntAsDurationSig&lt;/code&gt; 的向量化实现为例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;for i := 0; i &amp;lt; n; i++ {
    ...
    dur, err := types.NumberToDuration(i64s[i], int8(b.tp.Decimal))
    if err != nil {
       if types.ErrOverflow.Equal(err) {
          err = b.ctx.GetSessionVars().StmtCtx.HandleOverflow(err, err) // 就地利用对应处理函数处理错误
       }
       if err != nil { // 如果处理不掉就抛出
          return err
       }
       result.SetNull(i, true)
       continue
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;5. 如何添加测试&lt;/h3&gt;&lt;p&gt;我们做了一个简易的测试框架，可避免大家测试时做一些重复工作。&lt;/p&gt;&lt;p&gt;该测试框架的代码在 &lt;code&gt;expression/bench_test.go&lt;/code&gt; 文件中，被实现在 &lt;code&gt;testVectorizedBuiltinFunc&lt;/code&gt; 和 &lt;code&gt;benchmarkVectorizedBuiltinFunc&lt;/code&gt; 两个函数中。&lt;/p&gt;&lt;p&gt;我们为每一个 &lt;code&gt;builtin_XX_vec.go&lt;/code&gt; 文件增加了 &lt;code&gt;builtin_XX_vec_test.go&lt;/code&gt; 测试文件。当我们为一个函数实现向量化后，需要在对应测试文件内的 &lt;code&gt;vecBuiltinXXCases&lt;/code&gt; 变量中，增加一个或多个测试 case。下面我们为 log10 添加一个测试 case：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;var vecBuiltinMathCases = map[string][]vecExprBenchCase {
    ast.Log10: {
        {types.ETReal, []types.EvalType{types.ETReal}, nil},
    },
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体来说，上面结构体中的三个字段分别表示:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;该函数的返回值类型；&lt;/li&gt;&lt;li&gt;该函数所有参数的类型；&lt;/li&gt;&lt;li&gt;是否使用自定义的数据生成方法（dataGener），&lt;code&gt;nil&lt;/code&gt; 表示使用默认的随机生成方法。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对于某些复杂的函数，你可自己实现 dataGener 来生成数据。目前我们已经实现了几个简单的 dataGener，代码在 &lt;code&gt;expression/bench_test.go&lt;/code&gt; 中，可直接使用。&lt;/p&gt;&lt;p&gt;添加好 case 后，在 expression 目录下运行测试指令：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;# 功能测试
GO111MODULE=on go test -check.f TestVectorizedBuiltinMathFunc

# 性能测试
go test -v -benchmem -bench=BenchmarkVectorizedBuiltinMathFunc -run=BenchmarkVectorizedBuiltinMathFunc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在你的 PR Description 中，请把性能测试结果附上。不同配置的机器，性能测试结果可能不同，我们对机器配置无任何要求，你只需在 PR 中带上你本地机器的测试结果，让我们对向量化前后的性能有一个对比即可。&lt;/p&gt;&lt;h2&gt;如何成为 Contributor&lt;/h2&gt;&lt;p&gt;&lt;b&gt;为了推进表达式向量化计算，我们正式成立 Vectorized Expression Working Group，其具体的目标和制度详见&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/community/blob/master/working-groups/wg-vec-expr.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;。与此对应，我们在&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/tidbslack/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Community Slack&lt;/a&gt;&lt;/b&gt; &lt;b&gt;中创建了&lt;/b&gt; &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//app.slack.com/client/TH91JCS4W/CMRD79DRR&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;wg-vec-expr channel&lt;/a&gt;&lt;/b&gt; &lt;b&gt;供大家交流讨论，不设门槛，欢迎感兴趣的同学加入。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如何成为 Contributor：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在此 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/issues/12058&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;issue&lt;/a&gt; 内选择感兴趣的函数并告诉大家你会完成它；&lt;/li&gt;&lt;li&gt;为该函数实现 &lt;code&gt;vecEvalXType()&lt;/code&gt; 和 &lt;code&gt;vectorized()&lt;/code&gt; 的方法；&lt;/li&gt;&lt;li&gt;在向量化测试框架内添加对该函数的测试；&lt;/li&gt;&lt;li&gt;运行 &lt;code&gt;make dev&lt;/code&gt;，保证所有 test 都能通过；&lt;/li&gt;&lt;li&gt;发起 Pull Request 并完成 merge 到主分支。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果贡献突出，可能被提名为 reviewer，reviewer 的介绍请看 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/community/blob/master/CONTRIBUTING.md%23reviewer&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;如果你有任何疑问，也欢迎到 wg-vec-expr channel 中提问和讨论。&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-17-82815389</guid>
<pubDate>Tue, 17 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>跨越、爆发，所见「可提升」之处，皆是你的竞技场 | TiDB Hackathon 2019 启动</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-15-82263579.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82263579&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ac90f82e4787e10516ecf46ae044fedc_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;TiDB 社区有一个信念是：我们从不给自己设限，突破&amp;amp;提升才是一直追求的常态。在 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/hackathon2018/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;去年举办的 TiDB 黑客马拉松&lt;/a&gt;&lt;/u&gt; 上，诞生了很多兼具想象力和实用性的 TiDB 生态工具，我们当然也并不满足于此，&lt;b&gt;10 月 26 - 27 日，TiDB  Hackathon 2019 重磅回归！本届主题较去年更加广泛&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;&lt;b&gt;IMPROVE · 跃 界&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;本届比赛将弱化地域限制&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;北京、上海、广州三地联动&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;奖金依然丰厚&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;但好点子无价&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;大咖导师巡场带教&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;10 分钟零距离交流可能胜过埋头苦思 1 个月&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;啤酒 Pizza 不眠夜&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;期待各路大神集结，享受代码世界中的极致自由&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;冲撞 跨越 爆发&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;让 TiDB 来一次简单粗暴、突破常规的「跃界」吧！&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;选题方向&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;参赛选手可以为 TiDB 性能、易用性、稳定性、功能等各方面做出提升，当然也可以围绕 TiDB 生态做一些周边工具提升效率，比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Key Visualizer for TiKV&lt;/b&gt;&lt;br/&gt;可视化的 KV 的诊断工具，做到对集群的热点，访问模式一目了然。&lt;/li&gt;&lt;li&gt;&lt;b&gt;基于历史的查询优化&lt;/b&gt;&lt;br/&gt;让 TiDB 的 SQL 优化器能通过稳态的查询历史生成稳定的执行计划，防止执行计划跳变。&lt;/li&gt;&lt;li&gt;&lt;b&gt;Follower Read 与 MVCC 的结合&lt;/b&gt;&lt;br/&gt;让 TiDB 的多副本能够承担读流量， 提升整体的吞吐。&lt;/li&gt;&lt;li&gt;&lt;b&gt;TiDB Playground&lt;/b&gt;&lt;br/&gt;类似 Go Playground (&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//play.golang.org&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;play.golang.org&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;) 的所见即所得的交互式 TiDB Web 体验工具。&lt;/li&gt;&lt;li&gt;&lt;b&gt;更期待你能够提出新点子&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;奖项设置&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本届 Hackathon 的奖金依然非常「实在」：&lt;/p&gt;&lt;p&gt;🏅&lt;b&gt;一等奖（1 支队伍）： ¥ 60,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;🥈&lt;b&gt;二等奖（2 支队伍）：每队 ¥ 30,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;🥉&lt;b&gt;三等奖（3 支队伍）：每队 ¥ 10,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;另设最佳贡献奖、最佳创意奖、最具潜力奖，将有 TiDB 周边礼品奖励。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;学习资料&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;由于大家普遍反映 TiDB 源码上手难度有点高，所以我们列出了一些「学习资料」，大家可以根据个人基础和选题方向灵活选择。&lt;/p&gt;&lt;p&gt;Hackathon 专项学习文档汇总了 TiDB 核心团队出品的数十篇精选技术详解文章，帮助大家轻松掌握 TiDB 各核心组件的原理及功能，文档链接：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/presentations/blob/master/hackathon-2019/reference-document-of-hackathon-2019.md&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-2e73d3d3251663decc70dfbbe5be5f6a_ipico.jpg&quot; data-image-width=&quot;283&quot; data-image-height=&quot;283&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;pingcap/presentations&lt;/a&gt;&lt;p&gt;另外，大家也可以参考 PingCAP University 丰富的视频教程，网站链接：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//university.pingcap.com/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-0f1b58d10b1c02e158081b6141adfb4d_ipico.jpg&quot; data-image-width=&quot;217&quot; data-image-height=&quot;264&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PingCAP University&lt;/a&gt;&lt;h2&gt;&lt;b&gt;报名参赛&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;比赛时间：2019 年 10 月 26 ～ 27 日&lt;/li&gt;&lt;li&gt;比赛地点：PingCAP 北京、上海、广州 Office&lt;/li&gt;&lt;li&gt;组队规则：1～4 人成队，选择一地参赛&lt;/li&gt;&lt;li&gt;报名时间：即日起至 10 月 23 日&lt;/li&gt;&lt;li&gt;报名审核：5 个工作日内反馈审核结果&lt;/li&gt;&lt;li&gt;报名地址：&lt;/li&gt;&lt;/ul&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//nc9hsk15y2xczuor.mikecrm.com/PiwBPaL&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Hackathon 重磅回归！&lt;/a&gt;&lt;p&gt;* 本次大赛诚招志愿者参与活动现场支持。如果你想近距离接触技术大咖，体验大赛氛围，那就联系 TiDB Robot（微信号：tidbai）报名吧～志愿者也可以获得活动定制纪念品哦！&lt;/p&gt;&lt;p&gt;&lt;b&gt;合作伙伴&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;云计算基础设施支持：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;132&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;132&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;社区支持：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;246&quot; data-rawheight=&quot;80&quot; class=&quot;content_image&quot; width=&quot;246&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;246&quot; data-rawheight=&quot;80&quot; class=&quot;content_image lazy&quot; width=&quot;246&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;338&quot; data-rawheight=&quot;80&quot; class=&quot;content_image&quot; width=&quot;338&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;338&quot; data-rawheight=&quot;80&quot; class=&quot;content_image lazy&quot; width=&quot;338&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;进入活动官网了解更多信息：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/hackathon2019/%3Futm_source%3Dwechat%26utm_medium%3Dpingcap%26utm_campaign%3Dpingcap%2520190911&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt; | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-15-82263579</guid>
<pubDate>Sun, 15 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>从使用者到开发者，知乎参与 TiDB 社区背后的故事</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-12-82318701.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82318701&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0d2f4bfe8a576e111a55da7e3a0a816_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;作者介绍&lt;/b&gt;：孙晓光，知乎技术平台团队负责人，负责建设知乎在线和离线的基础设施平台，为业务开发提供统一的基础设施。曾多年从事私有云相关产品开发工作，关注云原生技术，TiKV 项目 Committer。&lt;/blockquote&gt;&lt;p&gt;关注 TiDB 的朋友们可能发现继 Follower Read 在 TiKV 端的 PR 合并后，TiDB 端相关的 PR 也于近期完成了到主干的合并工作。如果后期的稳定性测试一切正常，相关功能应该会随 TiDB 3.1 发布。Follower Read 功能本身从代码量上看并不大，但这个功能的意义尤其是对互联网类型业务来说是非常大的。&lt;/p&gt;&lt;p&gt;前段时间 PingCAP CTO 黄东旭已经写了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/follower-read-the-new-features-of-tidb/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;一篇文章&lt;/a&gt;，从原理角度对 Follower Read 做了非常透彻的介绍和分析。今天我想从非技术的角度介绍 Follower Read 功能的落地过程，并从 Contributor 的视角跟大家聊一聊个人参与 TiDB 开发过程中的体验和感受。最后站在知乎技术平台团队的角度，聊一下我们未来在积极参与开源项目，共同建设社区的愿望和决心。&lt;/p&gt;&lt;h2&gt;Follower Read 背后的故事&lt;/h2&gt;&lt;p&gt;Follower Read 的实现思路在 PingCAP 工程师大脑里应该已经存在很久了，但出于各种原因这个特性的优先级一直不够高，并没有能排到开发计划中。年中的时候我们开始尝试在知乎更广泛的业务中引入 TiDB，在灰度过程中我们遇到了某些特定工作负载下 TiDB 表现不够理想的问题。目前看来 TiDB 读写操作都交给 Leader 完成，是我们目前在特定负载下遇到吞吐问题的瓶颈点。&lt;/p&gt;&lt;p&gt;在理清思路后，我们同 PingCAP 的工程师做了几次交流并达成一致，决定通过 Follower Read 的方式来解决我们业务场景中极端热点数据访问的吞吐问题。在实际需求的驱动下， PingCAP 同学将 Follower Read 相关特性的优先级提高，快速确定了相关功能的技术方案并启动了 TiKV 端的开发工作。作为 Follower Read 功能的需求方，知乎负责这个需求在 TiDB 上的落地工作。&lt;/p&gt;&lt;p&gt;PingCAP 工程师用了大约两周的时间完成了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/pull/5051&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiKV 层 Follower Read 整个功能的开发测试&lt;/a&gt;，并将其合并到 master 分支中，随后我们开始了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb/pull/11347&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 侧相应功能的开发&lt;/a&gt;，在 PingCAP 小伙伴们的帮助下最终完成了相应功能到 master 分支的合并。作为知乎和 PingCAP 两家公司第一次联合开发的成果，这个功能的落地对双方都有着重大的意义。&lt;/p&gt;&lt;h2&gt;从 Contributor 到 Committer&lt;/h2&gt;&lt;p&gt;在以知乎技术平台团队成员的身份参与 TiDB 贡献之前，个人曾经在过去的一年里以用户的身份为 TiKV &amp;amp; TiDB 做过一些小型的贡献。接下来我就从个人角度聊一下从 Contributor 到 Committer 的成长过程和其中的体验。&lt;/p&gt;&lt;p&gt;第一次为 PingCAP 旗下项目提交 PR 并成为 Contributor 发生在大约一年前，我在为内部开发的业务系统选择合适的存储后端时，尝试给 TiKV 增加了一些批量操作接口。PR 提出后，PingCAP 首席架构师唐刘很快就跟我建立了联系，在随后的交流中帮助我快速完善 PR 并最终合并到 TiKV 的主干中。&lt;/p&gt;&lt;p&gt;虽然以往以零散的方式给很多开源项目提交过 Patch，但这次的体验是完全不同的，PingCAP 和社区伙伴们热心的帮助和鼓励让我切身感受到了活跃的开源社区所具有的独特魅力。随后出于个人兴趣，我在 TiDB 相关的项目中又陆陆续续做了一些简单的贡献，最终得到大家的认可成为 TiKV 项目的 Committer 之一。&lt;/p&gt;&lt;h2&gt;拥抱开源&lt;/h2&gt;&lt;p&gt;回过头来看这段时间的成长和收获都是巨大的，不但学习到了如何同开源社区众多优秀的贡献者更加高效的交流，并且对开源的价值理念和开源在基础软件领域的重大意义有了更加深入的理解。&lt;/p&gt;&lt;p&gt;近期随着在公司所在团队的转换，我个人开始更多的关注在线和离线的基础设施在知乎的演进。知乎一直以来都鼓励拥抱开源，并基于大量开源组件搭建了知乎的技术架构，得益于开源的力量，知乎的内部平台一直都紧随着行业技术发展的潮流。从前我们更多是站在使用者的角度从开源社区汲取养分，随着知乎技术架构和内部工程能力的成长，未来我们希望能够以更加积极主动的状态参与开源项目，回馈社区。Follower Read 是知乎第一次以 Contributor 身份参与 TiDB 社区建设，未来我们会参与更多的技术社区的建设为开源社区的发展贡献我们的力量。&lt;/p&gt;&lt;p&gt;&lt;b&gt;原文阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/zhihu-the-story-of-contributing-to-tidb-community/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;从使用者到开发者，知乎参与 TiDB 社区背后的故事 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-12-82318701</guid>
<pubDate>Thu, 12 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>跨越、爆发，所见「可提升」之处，皆是你的竞技场 | TiDB Hackathon 2019 启动</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-12-82263579.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82263579&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ac90f82e4787e10516ecf46ae044fedc_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;TiDB 社区有一个信念是：我们从不给自己设限，突破&amp;amp;提升才是一直追求的常态。在 &lt;u&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/hackathon2018/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;去年举办的 TiDB 黑客马拉松&lt;/a&gt;&lt;/u&gt; 上，诞生了很多兼具想象力和实用性的 TiDB 生态工具，我们当然也并不满足于此，&lt;b&gt;10 月 26 - 27 日，TiDB  Hackathon 2019 重磅回归！本届主题较去年更加广泛&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;&lt;b&gt;IMPROVE · 跃 界&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;本届比赛将弱化地域限制&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;北京、上海、广州三地联动&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;奖金依然丰厚&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;但好点子无价&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;大咖导师巡场带教&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;10 分钟零距离交流可能胜过埋头苦思 1 个月&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;啤酒 Pizza 不眠夜&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;期待各路大神集结，享受代码世界中的极致自由&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;冲撞 跨越 爆发&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;让 TiDB 来一次简单粗暴、突破常规的「跃界」吧！&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;选题方向&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;参赛选手可以为 TiDB 性能、易用性、稳定性、功能等各方面做出提升，当然也可以围绕 TiDB 生态做一些周边工具提升效率，比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Key Visualizer for TiKV&lt;/b&gt;&lt;br/&gt;可视化的 KV 的诊断工具，做到对集群的热点，访问模式一目了然。&lt;/li&gt;&lt;li&gt;&lt;b&gt;基于历史的查询优化&lt;/b&gt;&lt;br/&gt;让 TiDB 的 SQL 优化器能通过稳态的查询历史生成稳定的执行计划，防止执行计划跳变。&lt;/li&gt;&lt;li&gt;&lt;b&gt;Follower Read 与 MVCC 的结合&lt;/b&gt;&lt;br/&gt;让 TiDB 的多副本能够承担读流量， 提升整体的吞吐。&lt;/li&gt;&lt;li&gt;&lt;b&gt;TiDB Playground&lt;/b&gt;&lt;br/&gt;类似 Go Playground (&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//play.golang.org&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;play.golang.org&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;) 的所见即所得的交互式 TiDB Web 体验工具。&lt;/li&gt;&lt;li&gt;&lt;b&gt;更期待你能够提出新点子&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;奖项设置&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本届 Hackathon 的奖金依然非常「实在」：&lt;/p&gt;&lt;p&gt;🏅&lt;b&gt;一等奖（1 支队伍）： ¥ 60,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;🥈&lt;b&gt;二等奖（2 支队伍）：每队 ¥ 30,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;🥉&lt;b&gt;三等奖（3 支队伍）：每队 ¥ 10,000 现金奖励&lt;/b&gt;&lt;/p&gt;&lt;p&gt;另设最佳贡献奖、最佳创意奖、最具潜力奖，将有 TiDB 周边礼品奖励。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;学习资料&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;由于大家普遍反映 TiDB 源码上手难度有点高，所以我们列出了一些「学习资料」，大家可以根据个人基础和选题方向灵活选择。&lt;/p&gt;&lt;p&gt;Hackathon 专项学习文档汇总了 TiDB 核心团队出品的数十篇精选技术详解文章，帮助大家轻松掌握 TiDB 各核心组件的原理及功能，文档链接：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/presentations/blob/master/hackathon-2019/reference-document-of-hackathon-2019.md&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-2e73d3d3251663decc70dfbbe5be5f6a_ipico.jpg&quot; data-image-width=&quot;283&quot; data-image-height=&quot;283&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;pingcap/presentations&lt;/a&gt;&lt;p&gt;另外，大家也可以参考 PingCAP University 丰富的视频教程，网站链接：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//university.pingcap.com/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-0f1b58d10b1c02e158081b6141adfb4d_ipico.jpg&quot; data-image-width=&quot;217&quot; data-image-height=&quot;264&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PingCAP University&lt;/a&gt;&lt;h2&gt;&lt;b&gt;报名参赛&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;比赛时间：2019 年 10 月 26 ～ 27 日&lt;/li&gt;&lt;li&gt;比赛地点：PingCAP 北京、上海、广州 Office&lt;/li&gt;&lt;li&gt;组队规则：1～4 人成队，选择一地参赛&lt;/li&gt;&lt;li&gt;报名时间：即日起至 10 月 23 日&lt;/li&gt;&lt;li&gt;报名审核：5 个工作日内反馈审核结果&lt;/li&gt;&lt;li&gt;报名地址：&lt;/li&gt;&lt;/ul&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//nc9hsk15y2xczuor.mikecrm.com/PiwBPaL&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Hackathon 重磅回归！&lt;/a&gt;&lt;p&gt;* 本次大赛诚招志愿者参与活动现场支持。如果你想近距离接触技术大咖，体验大赛氛围，那就联系 TiDB Robot（微信号：tidbai）报名吧～志愿者也可以获得活动定制纪念品哦！&lt;/p&gt;&lt;p&gt;&lt;b&gt;合作伙伴&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;云计算基础设施支持：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;132&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;132&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-f3b19d0182e62a1277d4cec811e2b0be_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;社区支持：&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;246&quot; data-rawheight=&quot;80&quot; class=&quot;content_image&quot; width=&quot;246&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;246&quot; data-rawheight=&quot;80&quot; class=&quot;content_image lazy&quot; width=&quot;246&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-37c5b1a93f8b18320dce027e0c5fbaf5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;338&quot; data-rawheight=&quot;80&quot; class=&quot;content_image&quot; width=&quot;338&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;338&quot; data-rawheight=&quot;80&quot; class=&quot;content_image lazy&quot; width=&quot;338&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3e28c353b74f7059b4066fe735bdd299_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;进入活动官网了解更多信息：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/hackathon2019/%3Futm_source%3Dwechat%26utm_medium%3Dpingcap%26utm_campaign%3Dpingcap%2520190911&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt; | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-12-82263579</guid>
<pubDate>Thu, 12 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何高效利用 Grafana 监控分析 TiDB 指标</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-10-81926744.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/81926744&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e4100a49788fc94b31574d46f7d52994_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;作者介绍&lt;/b&gt;：李坤，PingCAP 互联网架构师，TUG Ambassador，前美团、去哪儿数据库专家。&lt;/blockquote&gt;&lt;h2&gt;一、概述&lt;/h2&gt;&lt;p&gt;使用 TiDB Ansible 部署 TiDB 集群，会同时部署一套 Grafana + Prometheus 的监控平台，这套监控用来收集和展示 TiDB 集群各个组件和机器的 metric 信息，这些 metric 信息非常丰富，可以帮助使用者分析 TiDB 集群的状态以及 Trouble shooting。随着使用经验的增多，我们积累了一些监控使用上的技巧，在这里分享给大家。&lt;/p&gt;&lt;h2&gt;二、监控架构&lt;/h2&gt;&lt;p&gt;Prometheus 是一个拥有多维度数据模型的、灵活的查询语句的时序数据库。Grafana 是一个开源的 metric 分析及可视化系统。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-616f81b79759b78472302897dc5496d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;477&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-616f81b79759b78472302897dc5496d5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-616f81b79759b78472302897dc5496d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;477&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-616f81b79759b78472302897dc5496d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-616f81b79759b78472302897dc5496d5_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 TiDB 监控整体架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;从 TiDB 2.1.3 版本开始，监控采用 pull 的方式，而之前采用的是 push 的方式，这是一个非常好的调整，它解决了几个问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;之前如果 Prometheus 需要迁移，需要重启整个集群，因为组件要调整 push 的目标地址。&lt;/li&gt;&lt;li&gt;现在可以部署 2 套 Prometheus，防止监控的单点，因为 pull 的 source 端是可以多个。&lt;/li&gt;&lt;li&gt;去掉了 &lt;code&gt;PushGateWay&lt;/code&gt; 这个单点组件。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;三、监控数据的来源与展示&lt;/h2&gt;&lt;p&gt;TiDB 的 3 个核心组件（TiDB，TiKV，PD）可以通过 http 接口来获取 metric 数据，这些指标都是从程序代码中统计上传的，端口如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-37e946a6aec6e8b28d1c3e282fc9e24b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;404&quot; data-rawheight=&quot;278&quot; class=&quot;content_image&quot; width=&quot;404&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-37e946a6aec6e8b28d1c3e282fc9e24b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;404&quot; data-rawheight=&quot;278&quot; class=&quot;content_image lazy&quot; width=&quot;404&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-37e946a6aec6e8b28d1c3e282fc9e24b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;用 tidb-server 举例，我们通过 http 接口，看一个 statement QPS 的 metric：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;# 可以看到实时 qps 的数据，区分不同的 type，value 是 counter 类型的累计值（科学计数法）

curl http://__tidb_ip__:10080/metrics |grep tidb_executor_statement_total
tidb_executor_statement_total{type=&amp;#34;Delete&amp;#34;} 520197
tidb_executor_statement_total{type=&amp;#34;Explain&amp;#34;} 1
tidb_executor_statement_total{type=&amp;#34;Insert&amp;#34;} 7.20799402e+08
tidb_executor_statement_total{type=&amp;#34;Select&amp;#34;} 2.64983586e+08
tidb_executor_statement_total{type=&amp;#34;Set&amp;#34;} 2.399075e+06
tidb_executor_statement_total{type=&amp;#34;Show&amp;#34;} 500531
tidb_executor_statement_total{type=&amp;#34;Use&amp;#34;} 466016&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个数据会在 Prometheus 存储下来，然后在 Grafana 展示，我们在面板上点击右键会出现 &lt;code&gt;Edit&lt;/code&gt; 按钮（或直接按 e），如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-33f500dfc1a3b3076bf5f0a9ea826110_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;775&quot; data-rawheight=&quot;277&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;775&quot; data-original=&quot;https://pic1.zhimg.com/v2-33f500dfc1a3b3076bf5f0a9ea826110_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-33f500dfc1a3b3076bf5f0a9ea826110_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;775&quot; data-rawheight=&quot;277&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;775&quot; data-original=&quot;https://pic1.zhimg.com/v2-33f500dfc1a3b3076bf5f0a9ea826110_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-33f500dfc1a3b3076bf5f0a9ea826110_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2 metric 面板的编辑入口&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们可以在 &lt;code&gt;Metric&lt;/code&gt; 面板上，看到利用该 metric 的 query 表达式。&lt;/p&gt;&lt;p&gt;面板上一些细节的含义：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;rate[1m]&lt;/code&gt;：表示 1 分钟的增长速率，只能用于 counter 类型的数据。&lt;/li&gt;&lt;li&gt;&lt;code&gt;sum&lt;/code&gt;：表示 value 求和。&lt;/li&gt;&lt;li&gt;&lt;code&gt;by type&lt;/code&gt;：表示将求和后的数据按 metric 的原始值中的 type 进行分组。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Legend format&lt;/code&gt;：表示指标名称的格式。&lt;/li&gt;&lt;li&gt;&lt;code&gt;Resolution&lt;/code&gt;：默认打点步长是 15s，&lt;code&gt;Resolution&lt;/code&gt; 表示是否分解。&lt;/li&gt;&lt;/ol&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-da973f7abee4f9ba71861fbcc13136ba_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;362&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-da973f7abee4f9ba71861fbcc13136ba_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-da973f7abee4f9ba71861fbcc13136ba_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;362&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-da973f7abee4f9ba71861fbcc13136ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-da973f7abee4f9ba71861fbcc13136ba_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3 metric 面板中的表达式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Prometheus 支持很多表达式与函数，更多表达式请参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//prometheus.io/docs/prometheus/latest/querying&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;官网页面&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;四、Grafana 使用技巧&lt;/h2&gt;&lt;h3&gt;技巧 1：查看所有维度并编辑表达式&lt;/h3&gt;&lt;p&gt;如上一小节的例子，是按照 type 进行分组，是否还能用其他维度分组？如何能快速得知还有哪些维度呢？这里推荐的技巧是，在 query 的表达式上只用指标名称，不做任何计算，format 也留空，这样就能显示出原始的 metric 数据，比如下图能看到有 3 个维度（&lt;code&gt;instance&lt;/code&gt;、&lt;code&gt;job&lt;/code&gt;、&lt;code&gt;type&lt;/code&gt;）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3a653ca29fa35cc58954c6c0df28cb19_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;383&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-3a653ca29fa35cc58954c6c0df28cb19_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3a653ca29fa35cc58954c6c0df28cb19_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;383&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-3a653ca29fa35cc58954c6c0df28cb19_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3a653ca29fa35cc58954c6c0df28cb19_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4 编辑表达式并查看所有维度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;得到 &lt;code&gt;instance&lt;/code&gt; 这个维度后，我们调整表达式，在原有的 type 后面加上 &lt;code&gt;instance&lt;/code&gt; 这个维度，调整 &lt;code&gt;legend format&lt;/code&gt; 格式增加 &lt;code&gt;{{instance}}&lt;/code&gt;，就可以看到每个 tidb-server 上执行的不同类型 SQL 的 QPS 了。如下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8b5983eb4b274ded704ff7c6046def28_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;387&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-8b5983eb4b274ded704ff7c6046def28_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8b5983eb4b274ded704ff7c6046def28_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;387&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-8b5983eb4b274ded704ff7c6046def28_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8b5983eb4b274ded704ff7c6046def28_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5 给表达式增加一个 instance 维度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;技巧 2：调整 Y 轴标尺的计算方式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以 &lt;code&gt;query duration&lt;/code&gt; 指标为例，默认的比例尺采用 2 的对数计算，显示上会将差距缩小。为了观察明显的变化，可以将比例尺改为线性，通过下面两张图，可以看到显示上的区别，明显的发现那个时刻有个 SQL 运行较慢。&lt;/p&gt;&lt;p&gt;当然也不是所有场景都适合用线性，比如观察 1 个月的性能趋势，用线性可能就会有很多噪点，不好观察。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-df520f520f79db64159cb77b2a2221fc_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-df520f520f79db64159cb77b2a2221fc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-df520f520f79db64159cb77b2a2221fc_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-df520f520f79db64159cb77b2a2221fc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-df520f520f79db64159cb77b2a2221fc_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6 标尺默认的比例尺为 2 的对数&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a6ff65cb955876d2f8c1bc80e0895fc1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a6ff65cb955876d2f8c1bc80e0895fc1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a6ff65cb955876d2f8c1bc80e0895fc1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a6ff65cb955876d2f8c1bc80e0895fc1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a6ff65cb955876d2f8c1bc80e0895fc1_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7 调整标尺的比例尺为线性&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;提示：我们可以结合技巧 1，发现这里还有一个 &lt;code&gt;sql_type&lt;/code&gt; 的维度，可以立刻分析出是 select 慢还是 update 慢，并且可以分析出是在哪个 instance 上慢。&lt;/blockquote&gt;&lt;h3&gt;技巧 3：调整 Y 轴基线，放大变化&lt;/h3&gt;&lt;p&gt;有一种情况：已经用了线性显示，还是看不出变化趋势。比如下图中，我们在扩容后想观察 &lt;code&gt;Store size&lt;/code&gt; 的实时变化效果，由于基数较大，微弱的变化观察不到。 这时我们可以将 Y 轴最小值从 &lt;code&gt;0&lt;/code&gt; 改为 &lt;code&gt;auto&lt;/code&gt;，将上部放大，观察下面两张图的区别，可以观察到数据已开始迁移了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;404&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;404&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8 基线默认为 0&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;404&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;404&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fe201607cff04b0c89b720c961f115f4_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9 调整基线为 auto&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;技巧 4：标尺联动&lt;/h3&gt;&lt;p&gt;在 Setting 面板中，有 &lt;code&gt;Graph Tooltip&lt;/code&gt; 的设置，默认使用 &lt;code&gt;Default&lt;/code&gt;。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-65fcf7b366bb88bf67e7aebd49abbb5c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;216&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-65fcf7b366bb88bf67e7aebd49abbb5c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-65fcf7b366bb88bf67e7aebd49abbb5c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;216&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-65fcf7b366bb88bf67e7aebd49abbb5c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-65fcf7b366bb88bf67e7aebd49abbb5c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10 图形展示工具&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们调整为 &lt;code&gt;Shared crosshair&lt;/code&gt; 和 &lt;code&gt;Shared Tooltip&lt;/code&gt; 分别试一下效果： 可以看到标尺可以联动展示了，方便排查问题时，确认 2 个指标的关联性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ed30406174113b1df75cff2054f10c8b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;158&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-ed30406174113b1df75cff2054f10c8b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ed30406174113b1df75cff2054f10c8b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;158&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-ed30406174113b1df75cff2054f10c8b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ed30406174113b1df75cff2054f10c8b_b.jpg&quot;/&gt;&lt;figcaption&gt;图 11 调整图形展示工具为 Shared crosshair&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c8abcc11f617a38e37039ed2b2819a8c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;162&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-c8abcc11f617a38e37039ed2b2819a8c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c8abcc11f617a38e37039ed2b2819a8c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;162&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-c8abcc11f617a38e37039ed2b2819a8c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c8abcc11f617a38e37039ed2b2819a8c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 12 调整图形展示工具为 Shared Tooltip&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;技巧 5：调整过滤项&lt;/h3&gt;&lt;p&gt;PD 的 Dashboard，只展示当前 leader 的 metric 信息，有时候会想看一下历史上 pd-leader 当时的状况，但是 instance 下拉列表中不存在这个成员了，我们也可以手动输入 &lt;code&gt;ip:2379&lt;/code&gt; 来看到当时的数据。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5d8cb9782a722bd11359e2628f93c8b6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5d8cb9782a722bd11359e2628f93c8b6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5d8cb9782a722bd11359e2628f93c8b6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5d8cb9782a722bd11359e2628f93c8b6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5d8cb9782a722bd11359e2628f93c8b6_b.jpg&quot;/&gt;&lt;figcaption&gt;图 13 手动输入并查看 metric&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;技巧 6：巧用 &lt;code&gt;Avg&lt;/code&gt; 函数&lt;/h3&gt;&lt;p&gt;通常默认图例中只有 &lt;code&gt;Max&lt;/code&gt; 和 &lt;code&gt;Current&lt;/code&gt;，但有时指标波动较大时，我们可以增加 &lt;code&gt;Avg&lt;/code&gt; 等其他汇总函数的图例，可以看一段时间的整体趋势。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot;/&gt;&lt;figcaption&gt;图 14 增加 Avg 等汇总函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot;/&gt;&lt;figcaption&gt;图 15 增加 Avg 函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;技巧 7：使用 Prometheus 的 API 接口获得表达式的结果&lt;/h3&gt;&lt;p&gt;Grafana 通过 Prometheus 的接口获取数据，我们也可以用该接口获取数据，这个用法可以扩散出很多功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;自动化平台获取集群规模、状态等信息。&lt;/li&gt;&lt;li&gt;对表达式稍加改动给报表提供数据，如统计每天的 QPS 总量、每天的 QPS 峰值、每天响应时间的汇总。&lt;/li&gt;&lt;li&gt;将重要的指标进行定期健康巡检。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-539a6f80ef6aa6930762a2a36d9df3d5_b.jpg&quot;/&gt;&lt;figcaption&gt;图 16 Prometheus 的 API 接口&lt;/figcaption&gt;&lt;/figure&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;curl -u user:pass &amp;#39;http://__grafana_ip__:3000/api/datasources/proxy/1/api/v1/query_range?query=sum(tikv_engine_size_bytes%7Binstancexxxxxxxxx20181%22%7D)%20by%20(instance)&amp;amp;start=1565879269&amp;amp;end=1565882869&amp;amp;step=30&amp;#39; |python -m json.tool
{
    &amp;#34;data&amp;#34;: {
        &amp;#34;result&amp;#34;: [
            {
                &amp;#34;metric&amp;#34;: {
                    &amp;#34;instance&amp;#34;: &amp;#34;xxxxxxxxxx:20181&amp;#34;
                },
                &amp;#34;values&amp;#34;: [
                    [
                        1565879269,
                        &amp;#34;1006046235280&amp;#34;
                    ],
                    [
                        1565879299,
                        &amp;#34;1006057877794&amp;#34;
                    ],
                    [
                        1565879329,
                        &amp;#34;1006021550039&amp;#34;
                    ],
                    [
                        1565879359,
                        &amp;#34;1006021550039&amp;#34;
                    ],
                    [
                        1565882869,
                        &amp;#34;1006132630123&amp;#34;
                    ]
                ]
            }
        ],
        &amp;#34;resultType&amp;#34;: &amp;#34;matrix&amp;#34;
    },
    &amp;#34;status&amp;#34;: &amp;#34;success&amp;#34;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;五、总结&lt;/h2&gt;&lt;p&gt;Grafana + Prometheus 是一套非常强大的组合，用好他们可以为我们的分析节省很多时间，提高效率，更重要的是能增加发现问题的可能性。在运维 TiDB 集群时，尤其数据量大的时候，这套工具能派上大用场。这里抛砖引玉，也希望大家也能提供一些技巧，一起共同学习。&lt;/p&gt;&lt;p&gt;&lt;b&gt;原文阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/use-grafana-to-monitor-and-analyze-tidb-metrics/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;如何高效利用 Grafana 监控分析 TiDB 指标 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-10-81926744</guid>
<pubDate>Tue, 10 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>一体化数据同步平台 DM 1.0 GA 发布</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-06-81484498.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/81484498&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d1432cfde0c525a5e57f6869c8f2efa0_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;DM（TiDB Data Migration）是由 PingCAP 开发的一体化数据同步平台，支持从 MySQL 或 MariaDB 到 TiDB 的全量数据迁移和增量数据同步。无论是从 MySQL 向 TiDB 进行平滑数据迁移还是用 TiDB 作为多个 MySQL 实例的数据汇总库，都可以通过 DM 来实现。DM 在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/community-cn/devcon2019/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB DevCon 2019&lt;/a&gt; 上正式开源，经过半年多时间在大量用户、开发者的支持和反馈下，其功能和稳定性越来越完善。在今天，我们宣布 DM 1.0 GA 正式发布。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3310efac36f9ac42b54dd0b3fc664f36_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;464&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-3310efac36f9ac42b54dd0b3fc664f36_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3310efac36f9ac42b54dd0b3fc664f36_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;464&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-3310efac36f9ac42b54dd0b3fc664f36_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3310efac36f9ac42b54dd0b3fc664f36_b.jpg&quot;/&gt;&lt;figcaption&gt;DM Architecture&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;核心特性&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;一体化数据同步&lt;/h3&gt;&lt;p&gt;在进行上下游数据同步的时候，一般需要先进行全量数据复制，再进行增量数据同步。DM 同步任务支持配置多个上游 MySQL/MariaDB 实例，并且同时执行全量迁移和增量同步，可以简单稳定地满足用户迁移数据的场景。&lt;/p&gt;&lt;h3&gt;同步规则可配置&lt;/h3&gt;&lt;p&gt;DM 提供了包括库表路由（Table routing）、黑白名单（Black &amp;amp; white table lists）、binlog 过滤（Binlog event filter）在内丰富的数据同步规则，支持在数据同步中进行自定义配置。&lt;/p&gt;&lt;h3&gt;分库分表自动合并&lt;/h3&gt;&lt;p&gt;在使用 MySQL 支撑大量数据时，经常会选择使用分库分表的方案。但当将数据同步到 TiDB 后，通常希望逻辑上进行合库合表。DM 针对合库合表的同步场景，提供了强大的分库分表自动合并机制，能够协调上游各分片之间的 DDL 同步，保证数据同步的正确性。&lt;/p&gt;&lt;h3&gt;异常任务自动恢复&lt;/h3&gt;&lt;p&gt;在数据同步的过程中，上游、下游、DM 自身的问题都有可能导致同步任务的中断。DM 针对常见的异常同步场景进行了优化，支持自动检测相关服务状态并自动尝试恢复大部分的异常同步任务，使得同步任务的运行更加稳定可靠。&lt;/p&gt;&lt;h2&gt;更多资料&lt;/h2&gt;&lt;p&gt;大家可以参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/tools/data-migration/deploy/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DM 使用文档&lt;/a&gt; 来部署并体验。想深入了解 DM 相关实现原理的同学，也可以查看 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DM 源代码&lt;/a&gt; 以及配套的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/%23DM-%25E6%25BA%2590%25E7%25A0%2581%25E9%2598%2585%25E8%25AF%25BB&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;DM 源码阅读系列&lt;/a&gt; 文章。如果有相关的问题，欢迎在 Github 上提 issue 或者是在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//asktug.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AskTUG 问答社区&lt;/a&gt; 中讨论。&lt;/p&gt;&lt;h2&gt;下一步计划&lt;/h2&gt;&lt;p&gt;最后再次感谢各位用户、开发者对 DM 提供的支持和帮助。在 DM 1.0 GA 发布之后，我们会持续打磨优化 DM，在接下来的版本中，提供 DM 组件高可用、优化分库分表合并机制、支持同步过程在线校验等新特性，向更加完善的数据同步平台方向持续演进。&lt;/p&gt;&lt;p&gt;&lt;b&gt;阅读原文：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/dm-1.0-ga/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;一体化数据同步平台 DM 1.0 GA 发布 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-06-81484498</guid>
<pubDate>Fri, 06 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>TiDB 高并发写入常见热点问题及规避方法</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-05-81316899.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/81316899&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5a65bfef70bec5133d0bcee6e23ccfab_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：姚维&lt;/p&gt;&lt;p&gt;本文通过阐述一个高并发批量写入数据到 TiDB 的典型场景中，TiDB 中常见的问题，给出一个业务的最佳实践，避免业务在开发的时候陷入 TiDB 使用的 “反模式”。&lt;/p&gt;&lt;h2&gt;面向的对象&lt;/h2&gt;&lt;p&gt;本文主要面向对 TiDB 有一定了解的读者，读者在阅读本文之前，推荐先阅读讲解 TiDB 原理的三篇文章（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-internal-1&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;讲存储&lt;/a&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-internal-2&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;说计算&lt;/a&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-internal-3&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;谈调度&lt;/a&gt;），以及 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-best-practice/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB Best Practice&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;场景&lt;/h2&gt;&lt;p&gt;高并发批量插入场景，通常存在于业务系统中的批量任务中，例如清算以及结算等业务。它存在以下显著的特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据量大&lt;/li&gt;&lt;li&gt;需要短时间内将历史数据入库&lt;/li&gt;&lt;li&gt;需要短时间内读取大量数据&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这就对 TiDB 提出了一些挑战：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;写入/读取能力是否可以线性水平扩展&lt;/li&gt;&lt;li&gt;数据在持续大并发写入，性能是否稳定不衰减&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于分布式数据库来说，除了本身的基础性能之外，最重要的就是充分利用所有节点能力，避免出现单个节点成为瓶颈。&lt;/p&gt;&lt;h2&gt;TiDB 数据分布原理&lt;/h2&gt;&lt;p&gt;如果要解决以上挑战，需要从 TiDB 数据切分以及调度的原理开始讲起。这里只是作简单的说明，详细请大家参见：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-internal-3/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;说调度&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;TiDB 对于数据的切分，按 Region 为单位，一个 Region 有大小限制（默认 96M）。 Region 的切分方式是范围切分。每个 Region 会有多副本，每一组副本，称为一个 Raft-Group。由 Leader 负责执行这块数据的读 &amp;amp; 写（当然 TiDB 即将支持 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/78164196&quot; class=&quot;internal&quot;&gt;Follower-Read&lt;/a&gt;）。Leader 会自动地被 PD 组件均匀调度在不同的物理节点上，用以均分读写压力。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6e34614a0e4eab501275f7cb20b08cde_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;420&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-6e34614a0e4eab501275f7cb20b08cde_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6e34614a0e4eab501275f7cb20b08cde_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;420&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-6e34614a0e4eab501275f7cb20b08cde_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6e34614a0e4eab501275f7cb20b08cde_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 TiDB 数据概览&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;只要业务的写入没有 AUTO_INCREMENT 的主键或者单调递增的索引（也即没有业务上的写入热点，更多细节参见 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/25574778&quot; class=&quot;internal&quot;&gt;TiDB 正确使用方式&lt;/a&gt;）。从原理上来说，TiDB 依靠这个架构，是可以线性扩展读写能力，并且可以充分利用分布式的资源的。这一点上 TiDB 尤其适合高并发批量写入场景的业务。&lt;/p&gt;&lt;p&gt;但是软件世界里，没有银弹。具体的事情还需要具体分析。我们接下来就通过一些简单的负载来探讨 TiDB 在这种场景下，需要如何被正确的使用，才能达到此场景理论上的最佳性能。&lt;/p&gt;&lt;h2&gt;简单的例子&lt;/h2&gt;&lt;p&gt;有一张简单的表：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;CREATE TABLE IF NOT EXISTS TEST_HOTSPOT(
      id                   BIGINT PRIMARY KEY,
      age                INT,
      user_name  VARCHAR(32),
      email 	 VARCHAR(128)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个表结构非常简单，除了 id 为主键以外，没有额外的二级索引。写入的语句如下，id 通过随机数离散生成：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;INSERT INTO TEST_HOTSPOT(id, age, user_name, email) values(%v, %v, &amp;#39;%v&amp;#39;, &amp;#39;%v&amp;#39;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;负载是短时间内密集地执行以上写入语句。&lt;/p&gt;&lt;p&gt;到目前为止，似乎已经符合了我们上述提到的 TiDB 最佳实践了，业务上没有热点产生，只要我们有足够的机器，就可以充分利用 TiDB 的分布式能力了。要验证这一点，我们可以在实验环境中试一试（实验环境部署拓扑是 2 个 TiDB 节点，3 个 PD 节点，6 个 TiKV 节点，请大家忽略 QPS，这里的测试只是为了阐述原理，并非 benchmark）：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5814fbfb2eb2cd1d91a37cf258b073ea_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;300&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5814fbfb2eb2cd1d91a37cf258b073ea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5814fbfb2eb2cd1d91a37cf258b073ea_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;300&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5814fbfb2eb2cd1d91a37cf258b073ea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5814fbfb2eb2cd1d91a37cf258b073ea_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2 监控截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;客户端在短时间内发起了 “密集” 的写入，TiDB 收到的请求是 3K QPS。如果没有意外的话，压力应该均摊给 6 个 TiKV 节点。但是从 TiKV 节点的 CPU 使用情况上看，存在明显的写入倾斜（tikv - 3 节点是写入热点）：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a069a631ce5d24b794c058ab58741cd9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;377&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a069a631ce5d24b794c058ab58741cd9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a069a631ce5d24b794c058ab58741cd9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;377&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-a069a631ce5d24b794c058ab58741cd9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a069a631ce5d24b794c058ab58741cd9_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3 监控截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8c4d20dbd53b82c1d16982b7daf02b7b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;350&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-8c4d20dbd53b82c1d16982b7daf02b7b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8c4d20dbd53b82c1d16982b7daf02b7b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;350&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-8c4d20dbd53b82c1d16982b7daf02b7b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8c4d20dbd53b82c1d16982b7daf02b7b_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4 监控截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/key-monitoring-metrics/tikv-dashboard/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Raft store CPU&lt;/a&gt; 代表 raftstore 线程的 CPU 使用率，通常代表着写入的负载，在这个场景下 tikv-3 是 raft 的 leader，tikv-0 跟 tikv-1 是 raft 的 follower，其他的 tikv 节点的负载几乎为空。&lt;/p&gt;&lt;p&gt;从 PD 的监控中也可以印证这一点：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b3e752ea92204cec3a3d6a013132c12e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;664&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-b3e752ea92204cec3a3d6a013132c12e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b3e752ea92204cec3a3d6a013132c12e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;664&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-b3e752ea92204cec3a3d6a013132c12e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b3e752ea92204cec3a3d6a013132c12e_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5 监控截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;反直觉的原因&lt;/p&gt;&lt;p&gt;上面这个现象是有一些违反直觉的，造成这个现象的原因是：刚创建表的时候，这个表在 TiKV 只会对应为一个 Region，范围是:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[CommonPrefix + TableID, CommonPrefix + TableID + 1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于在短时间内的大量写入，它会持续写入到同一个 Region。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9226f136204e8c622c853ab9076f855a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1204&quot; data-rawheight=&quot;510&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1204&quot; data-original=&quot;https://pic3.zhimg.com/v2-9226f136204e8c622c853ab9076f855a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9226f136204e8c622c853ab9076f855a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1204&quot; data-rawheight=&quot;510&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1204&quot; data-original=&quot;https://pic3.zhimg.com/v2-9226f136204e8c622c853ab9076f855a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9226f136204e8c622c853ab9076f855a_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6 TiKV Region 分裂流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;上图简单描述了这个过程，持续写入，TiKV 会将 Region 切分。但是由于是由原 Leader 所在的 Store 首先发起选举，所以大概率下旧的 Store 会成为新切分好的两个 Region 的 Leader。对于新切分好的 Region 2，3。也会重复之前发生在 Region 1 上的事情。也就是压力会密集地集中在 TiKV-Node 1 中。&lt;/p&gt;&lt;p&gt;在持续写入的过程中， PD 能发现 Node 1 中产生了热点，它就会将 Leader 均分到其他的 Node 上。如果 TiKV 的节点数能多于副本数的话，还会发生 Region 的迁移，尽量往空闲的 Node 上迁移，这两个操作在插入过程，在 PD 监控中也可以印证：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3536017902bb5e3cf8b8a253642c1bc_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;339&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3536017902bb5e3cf8b8a253642c1bc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3536017902bb5e3cf8b8a253642c1bc_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;339&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-c3536017902bb5e3cf8b8a253642c1bc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c3536017902bb5e3cf8b8a253642c1bc_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7 监控截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在持续写入一段时间以后，整个集群会被 PD 自动地调度成一个压力均匀的状态，到那个时候才会真正利用整个集群的能力。对于大多数情况来说，这个是没有问题的，这个阶段属于表 Region 的预热阶段。&lt;/p&gt;&lt;p&gt;但是对于高并发批量密集写入场景来说，这个却是应该避免的。&lt;/p&gt;&lt;p&gt;那么我们能否跳过这个预热的过程，直接将 Region 切分为预期的数量，提前调度到集群的各个节点中呢？&lt;/p&gt;&lt;h2&gt;解决方法&lt;/h2&gt;&lt;p&gt;TiDB 在 v3.0.x 版本以及 v2.1.13 以后的版本支持了一个新特性叫做 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/sql/statements/split-region/%23split-region-%25E4%25BD%25BF%25E7%2594%25A8%25E6%2596%2587%25E6%25A1%25A3&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Split Region&lt;/a&gt;。这个特性提供了新的语法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SPLIT TABLE table_name [INDEX index_name] BETWEEN (lower_value) AND (upper_value) REGIONS region_num

SPLIT TABLE table_name [INDEX index_name] BY (value_list) [, (value_list)]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;读者可能会有疑问，为何 TiDB 不自动将这个切分动作提前完成？大家先看一下下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4c8a53ac065f89083b3dbcfc9f1de694_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1156&quot; data-rawheight=&quot;685&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1156&quot; data-original=&quot;https://pic1.zhimg.com/v2-4c8a53ac065f89083b3dbcfc9f1de694_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4c8a53ac065f89083b3dbcfc9f1de694_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1156&quot; data-rawheight=&quot;685&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1156&quot; data-original=&quot;https://pic1.zhimg.com/v2-4c8a53ac065f89083b3dbcfc9f1de694_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4c8a53ac065f89083b3dbcfc9f1de694_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8 Table Region Range&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;从图 8 可以知道，Table 行数据 key 的编码之中，行数据唯一可变的是行 ID （rowID）。在 TiDB 中 rowID 是一个 Int64 整形。那么是否我们将 Int64 整形范围均匀切分成我们要的份数，然后均匀分布在不同的节点就可以解决问题呢？&lt;/p&gt;&lt;p&gt;答案是不一定，需要看情况，如果行 id 的写入是完全离散的，那么上述方式是可行的。但是如果行 id 或者索引是有固定的范围或者前缀的。例如，我只在 [2000w, 5000w) 的范围内离散插入，这种写入依然是在业务上没有热点的，但是如果按上面的方式切分，那么就有可能在开始也还是只写入到某个 Region。&lt;/p&gt;&lt;p&gt;作为通用的数据库，TiDB 并不对数据的分布作假设，所以开始只用一个 Region 来表达一个表，等到真实数据插入进来以后，TiDB 自动地根据这个数据的分布来作切分。这种方式是较通用的。&lt;/p&gt;&lt;p&gt;所以 TiDB 提供了 Split Region 语法，来专门针对短时批量写入场景作优化，下面我们尝试在上面的例子中用以下语句提前切散 Region，再看看负载情况。&lt;/p&gt;&lt;p&gt;由于测试的写入是在正数范围内完全离散，所以我们可以用以下语句，在 Int64 空间内提前将表切散为 128 个 Region：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SPLIT TABLE TEST_HOTSPOT BETWEEN (0) AND (9223372036854775807) REGIONS 128;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;切分完成以后，可以通过 &lt;code&gt;SHOW TABLE test_hotspot REGIONS;&lt;/code&gt; 语句查看打散的情况，如果 SCATTERING 列值全部为 0，代表调度成功。&lt;/p&gt;&lt;p&gt;也可以通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-ansible/blob/dabf60baba5e740a4bee9faf95e77563d8084be1/scripts/table-regions.py&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;table-regions.py&lt;/a&gt; 脚本，查看 Region 的分布，已经比较均匀了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[root@172.16.4.4 scripts]# python table-regions.py --host 172.16.4.3 --port 31453 test test_hotspot
[RECORD - test.test_hotspot] - Leaders Distribution:
  total leader count: 127
  store: 1, num_leaders: 21, percentage: 16.54%
  store: 4, num_leaders: 20, percentage: 15.75%
  store: 6, num_leaders: 21, percentage: 16.54%
  store: 46, num_leaders: 21, percentage: 16.54%
  store: 82, num_leaders: 23, percentage: 18.11%
  store: 62, num_leaders: 21, percentage: 16.54%&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们再重新运行插入负载：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-daf6296de25b31b28798ba2186018eb9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;379&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-daf6296de25b31b28798ba2186018eb9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-daf6296de25b31b28798ba2186018eb9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;379&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-daf6296de25b31b28798ba2186018eb9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-daf6296de25b31b28798ba2186018eb9_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9 监控截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf3e8ca5cdbdf1cc204e77dccfcf5686_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;343&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf3e8ca5cdbdf1cc204e77dccfcf5686_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf3e8ca5cdbdf1cc204e77dccfcf5686_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;343&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf3e8ca5cdbdf1cc204e77dccfcf5686_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bf3e8ca5cdbdf1cc204e77dccfcf5686_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10 监控截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65312d15b81fbe0636bc526c21b03079_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;339&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-65312d15b81fbe0636bc526c21b03079_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65312d15b81fbe0636bc526c21b03079_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;339&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-65312d15b81fbe0636bc526c21b03079_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-65312d15b81fbe0636bc526c21b03079_b.jpg&quot;/&gt;&lt;figcaption&gt;图 11 监控截图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;可以看到已经消除了明显的热点问题了。&lt;/p&gt;&lt;p&gt;当然，这里只是举例了一个简单的表，还有索引热点的问题。如何预先切散索引相关的 Region？&lt;/p&gt;&lt;p&gt;这个问题可以留给读者，通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/sql/statements/split-region/%23split-region-%25E4%25BD%25BF%25E7%2594%25A8%25E6%2596%2587%25E6%25A1%25A3&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Split Region 文档&lt;/a&gt; 可以获得更多的信息。&lt;/p&gt;&lt;h3&gt;更复杂一些的情况&lt;/h3&gt;&lt;p&gt;如果表没有主键或者主键不是 int 类型，用户也不想自己生成一个随机分布的主键 ID，TiDB 内部会有一个隐式的 _tidb_rowid 列作为行 id。在不使用 SHARD_ROW_ID_BITS 的情况下，_tidb_rowid 列的值基本上也是单调递增的，此时也会有写热点存在。（查看什么是 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/configuration/tidb-server/tidb-specific-variables/%23shard-row-id-bits&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SHARD_ROW_ID_BITS&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;要避免由 _tidb_rowid 带来的写入热点问题，可以在建表时，使用 SHARD_ROW_ID_BITS  和 PRE_SPLIT_REGIONS 这两个建表 option（查看什么是 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/sql/statements/split-region/%23pre-split-regions&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PRE_SPLIT_REGIONS&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;SHARD_ROW_ID_BITS 用来把 _tidb_rowid 列生成的行 ID 随机打散，pre_split_regions 用来在建完表后就预先 split region。注意：pre_split_regions 必须小于等于 shard_row_id_bits。&lt;/p&gt;&lt;p&gt;示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;create table t (a int, b int) shard_row_id_bits = 4 pre_split_regions=·3;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;SHARD_ROW_ID_BITS = 4 表示 tidb_rowid 的值会随机分布成 16 （16=2^4） 个范围区间。&lt;/li&gt;&lt;li&gt;pre_split_regions=3 表示建完表后提前 split 出 8 (2^3) 个 region。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在表 t 开始写入后，数据写入到提前 split 好的 8 个 region 中，这样也避免了刚开始建表完后因为只有一个 region 而存在的写热点问题。&lt;/p&gt;&lt;h2&gt;参数配置&lt;/h2&gt;&lt;h3&gt;关闭 TiDB 的 Latch 机制&lt;/h3&gt;&lt;p&gt;TiDB 2.1 版本中在 SQL 层引入了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/reference/configuration/tidb-server/configuration-file/%23txn-local-latches&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;latch 机制&lt;/a&gt;，用于在写入冲突比较频繁的场景中提前发现事务冲突，减少 TiDB 跟 TiKV 事务提交时写写冲突导致的重试。对于跑批场景，通常是存量数据，所以并不存在事务的写入冲突。可以把 TiDB 的 latch 关闭，以减少细小内存对象的分配：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[txn-local-latches]
enabled = false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;阅读原文：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tidb-in-high-concurrency-scenarios/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiDB 高并发写入常见热点问题及规避方法 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-05-81316899</guid>
<pubDate>Thu, 05 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>TiKV 源码解析系列文章（十三）MVCC 数据读取</title>
<link>https://henix.github.io/feeds/zhuanlan.newsql/2019-09-03-81003380.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/81003380&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a1a34bbb226599454f1da2b4db6b6a1f_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：施闻轩&lt;/p&gt;&lt;p&gt;在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tikv-source-code-reading-12/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《TiKV 源码解析系列文章（十二）分布式事务》&lt;/a&gt; 中，我们介绍了如何在满足事务特性的要求下进行数据写入。本文将介绍数据读取的流程。由于顺序扫（Forward Scan）比较具有代表性，因此本文只介绍顺序扫的流程，而不会介绍点查或逆序扫。点查是顺序扫的简化，相信读者理解了顺序扫的流程后能自己想出点查的实现，而逆序扫与顺序扫也比较类似，主要区别在于从后向前扫，稍复杂一些，相信大家在阅读本文后，也能自己对照着代码读懂逆序扫的实现。&lt;/p&gt;&lt;h2&gt;数据格式&lt;/h2&gt;&lt;p&gt;首先回忆一下事务写入完成后，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tikv.org/docs/deep-dive/distributed-transaction/percolator/%23percolator-in-tikv&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;在 RocksDB 层面存储的具体是什么样的数据&lt;/a&gt;：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a95f9dd035625e599e3f00839dbd1e9b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1396&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1396&quot; data-original=&quot;https://pic4.zhimg.com/v2-a95f9dd035625e599e3f00839dbd1e9b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a95f9dd035625e599e3f00839dbd1e9b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1396&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1396&quot; data-original=&quot;https://pic4.zhimg.com/v2-a95f9dd035625e599e3f00839dbd1e9b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a95f9dd035625e599e3f00839dbd1e9b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;其中：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;为了消除歧义，约定 User Key (&lt;code&gt;user_key&lt;/code&gt;) 指 TiKV Client（如 TiDB）所写入的或所要读取的 Key，User Value (&lt;code&gt;user_value&lt;/code&gt;) 指 User Key 对应的 Value。&lt;/li&gt;&lt;li&gt;&lt;code&gt;lock_info&lt;/code&gt; 包含 lock type、primary key、timestamp、ttl 等信息，见 &lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/blob/1924a32376b7823c3faa0795f53e836e65eb9ff0/src/storage/mvcc/lock.rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;src/storage/mvcc/lock.rs&lt;/a&gt;&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;&lt;code&gt;write_info&lt;/code&gt; 包含 write type、start_ts 等信息，见 &lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/blob/1924a32376b7823c3faa0795f53e836e65eb9ff0/src/storage/mvcc/write.rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;src/storage/mvcc/write.rs&lt;/a&gt;&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;事务样例&lt;/h2&gt;&lt;p&gt;为了便于大家理解代码，我们假设 TiKV Client 之前进行了下面这些事务：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-51c7549d4bbbe51407b41adf09d7736f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1360&quot; data-rawheight=&quot;408&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1360&quot; data-original=&quot;https://pic4.zhimg.com/v2-51c7549d4bbbe51407b41adf09d7736f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-51c7549d4bbbe51407b41adf09d7736f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1360&quot; data-rawheight=&quot;408&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1360&quot; data-original=&quot;https://pic4.zhimg.com/v2-51c7549d4bbbe51407b41adf09d7736f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-51c7549d4bbbe51407b41adf09d7736f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;注意，TiDB 向 TiKV 写入的 Key（及上面的 user_key）并不会长成 foo、abc、box 这样，而大部分会是 &lt;code&gt;tXXXXXXXX_rXXXXXXXX&lt;/code&gt; 或 &lt;code&gt;tXXXXXXXX_iXXXXXXXX&lt;/code&gt; 的格式。但 Key 的格式并不影响 TiKV 的逻辑处理，所以我们这里仅采用简化的 Key 作为样例。Value 同理。&lt;/blockquote&gt;&lt;p&gt;每个事务 Prewrite 并 Commit 完毕后，落到 RocksDB 上的数据类似于这样：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;事务 #1：&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-72e76792375417a1196220e4e559b8f5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1222&quot; data-rawheight=&quot;264&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1222&quot; data-original=&quot;https://pic2.zhimg.com/v2-72e76792375417a1196220e4e559b8f5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-72e76792375417a1196220e4e559b8f5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1222&quot; data-rawheight=&quot;264&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1222&quot; data-original=&quot;https://pic2.zhimg.com/v2-72e76792375417a1196220e4e559b8f5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-72e76792375417a1196220e4e559b8f5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;事务 #2：&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4f029017dbec4dec7f9004440c2baea6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1210&quot; data-rawheight=&quot;258&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1210&quot; data-original=&quot;https://pic3.zhimg.com/v2-4f029017dbec4dec7f9004440c2baea6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4f029017dbec4dec7f9004440c2baea6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1210&quot; data-rawheight=&quot;258&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1210&quot; data-original=&quot;https://pic3.zhimg.com/v2-4f029017dbec4dec7f9004440c2baea6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4f029017dbec4dec7f9004440c2baea6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;事务 #3&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8dbf8dd1a3b8c86200cf1519b689a2b4_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1246&quot; data-rawheight=&quot;188&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1246&quot; data-original=&quot;https://pic1.zhimg.com/v2-8dbf8dd1a3b8c86200cf1519b689a2b4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8dbf8dd1a3b8c86200cf1519b689a2b4_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1246&quot; data-rawheight=&quot;188&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1246&quot; data-original=&quot;https://pic1.zhimg.com/v2-8dbf8dd1a3b8c86200cf1519b689a2b4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8dbf8dd1a3b8c86200cf1519b689a2b4_b.png&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;事务 #4：&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c29c81cd77ed7833c7723ff2fefd877f_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1236&quot; data-rawheight=&quot;178&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1236&quot; data-original=&quot;https://pic4.zhimg.com/v2-c29c81cd77ed7833c7723ff2fefd877f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c29c81cd77ed7833c7723ff2fefd877f_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1236&quot; data-rawheight=&quot;178&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1236&quot; data-original=&quot;https://pic4.zhimg.com/v2-c29c81cd77ed7833c7723ff2fefd877f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-c29c81cd77ed7833c7723ff2fefd877f_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际在 RocksDB 中存储的数据与上面表格里写的略微不一样，主要区别有：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;TiKV Raft 层会修改实际写入 RocksDB 的 Key（例如增加前缀 &lt;code&gt;z&lt;/code&gt;）以便进行数据区分。对于 MVCC 和事务来说这个操作是透明的，因此我们先忽略这个。&lt;/li&gt;&lt;li&gt;User Key 会被按照 Memory Comparable Encoding 方式进行编码，编码算法是以 8 字节为单位进行 Padding。这个操作确保了我们在 User Key 后面追加 &lt;code&gt;start_ts&lt;/code&gt; 或 &lt;code&gt;commit_ts&lt;/code&gt; 之后实际写入的 Key 能保持与 User Key 具有相同的顺序。&lt;br/&gt;例如，假设我们依次写入 &lt;code&gt;abc&lt;/code&gt;、&lt;code&gt;abc\x00..\x00&lt;/code&gt; 两个 User Key，在不进行 Padding 的情况下：&lt;/li&gt;&lt;/ol&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3508c16ac241da50500cb049f5d51bb5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1106&quot; data-rawheight=&quot;254&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1106&quot; data-original=&quot;https://pic2.zhimg.com/v2-3508c16ac241da50500cb049f5d51bb5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3508c16ac241da50500cb049f5d51bb5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1106&quot; data-rawheight=&quot;254&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1106&quot; data-original=&quot;https://pic2.zhimg.com/v2-3508c16ac241da50500cb049f5d51bb5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3508c16ac241da50500cb049f5d51bb5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ol&gt;&lt;li&gt;可见，User Key 顺序是 &lt;code&gt;abc &amp;lt; abc\x00..\x00&lt;/code&gt;，但写入的 Key 顺序却是 &lt;code&gt;abc\x00\x00..\x05 &amp;gt; abc\x00\x00..\x00\x00\x00..\x10&lt;/code&gt;。显然，在这之后，我们若想要有序地扫数据就会面临巨大的挑战。因此需要对 User Key 进行编码：&lt;br/&gt;Example 1:&lt;br/&gt;User Key:      abc Encoded:       abc\x00\x00\x00\x00\x00\xFA                ^^^                    ^^^^                Key                    Pad=5                   ^^^^^^^^^^^^^^^^^^^^                   Padding&lt;br/&gt;Example 2:&lt;br/&gt;User Key:      abc\x00\x00\x00\x00\x00\x00\x00\x00 Encoded[0..9]: abc\x00\x00\x00\x00\x00\xFF                ^^^^^^^^^^^^^^^^^^^^^^^                Key[0..8]                                       ^^^^                                       Pad=0 Encoded[9..]:  \x00\x00\x00\x00\x00\x00\x00\x00\xFA                ^^^^^^^^^^^^                    ^^^^                Key[8..11]                      Pad=5                            ^^^^^^^^^^^^^^^^^^^^                            Padding&lt;br/&gt;编码后的 Key 无论后面再追加什么 8 字节的 Timestamp，都能保持原来的顺序。&lt;/li&gt;&lt;li&gt;TiKV 在 Key 中存储的 Timestamp（无论是 &lt;code&gt;start_ts&lt;/code&gt; 还是 &lt;code&gt;commit_ts&lt;/code&gt;）都是 Timestamp 取反后的结果，其目的是让较新的数据（即 Timestamp 比较大的数据）排列在较老的数据（即 Timestamp 比较小的数据）前面。扫数据的流程利用了这个特性优化性能，继续阅读本文可以有所感受。后面本文中关于时间戳的部分将写作 &lt;code&gt;{!ts}&lt;/code&gt; 来反映这个取反操作。&lt;/li&gt;&lt;li&gt;TiKV 对较小（&amp;lt;= 64 字节）的 User Value 会进行优化，不存储在 Default CF 中，而是直接内嵌在 Lock Info 或 Write Info 中，从而加快这类 User Key 的扫的效率及写入效率。我们这个示例先暂且忽略这个优化，就当成 User Value 都很长没有进行内嵌。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;顺序扫&lt;/h2&gt;&lt;p&gt;顺序扫的代码位于 &lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tikv/tikv/blob/1924a32376b7823c3faa0795f53e836e65eb9ff0/src/storage/mvcc/reader/scanner/forward.rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;src/storage/mvcc/reader/scanner/forward.rs&lt;/a&gt;&lt;/code&gt;。顺序扫的定义是给定 &lt;code&gt;scan_ts&lt;/code&gt;、可选的下界 &lt;code&gt;lower_bound&lt;/code&gt; 与可选的上界 &lt;code&gt;upper_bound&lt;/code&gt;，需要依次知道在 &lt;code&gt;[lower_bound, upper_bound)&lt;/code&gt; 范围内所有满足 &lt;code&gt;scan_ts&lt;/code&gt;（即最新 &lt;code&gt;commit_ts &amp;lt;= scan_ts&lt;/code&gt;）的数据。扫的过程中可以随时中止，不需要扫出范围内所有数据。&lt;/p&gt;&lt;p&gt;以「事务样例」为例，假设其所有事务都 Commit 后：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;scan_ts = 0x00 顺序扫 &lt;code&gt;[-∞, +∞)&lt;/code&gt; 可依次扫出：(空)。&lt;/li&gt;&lt;li&gt;scan_ts = 0x05 顺序扫 &lt;code&gt;[-∞, +∞)&lt;/code&gt; 可依次扫出：&lt;code&gt;bar =&amp;gt; bar_value&lt;/code&gt;、&lt;code&gt;foo =&amp;gt; foo_value&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;scan_ts = 0x12 顺序扫 &lt;code&gt;[-∞, +∞)&lt;/code&gt;，可依次扫出 &lt;code&gt;bar =&amp;gt; bar_value&lt;/code&gt;、&lt;code&gt;foo =&amp;gt; foo_value&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;scan_ts = 0x15 顺序扫 &lt;code&gt;[-∞, +∞)&lt;/code&gt; 可依次扫出：&lt;code&gt;bar =&amp;gt; bar_value&lt;/code&gt;、&lt;code&gt;box =&amp;gt; box_value&lt;/code&gt;、&lt;code&gt;foo =&amp;gt; foo_value2&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;scan_ts = 0x35 顺序扫 &lt;code&gt;[-∞, +∞)&lt;/code&gt; 可依次扫出：&lt;code&gt;bar =&amp;gt; bar_value&lt;/code&gt;、&lt;code&gt;foo =&amp;gt; foo_value2&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;scan_ts = 0x05 顺序扫 &lt;code&gt;[c, +∞)&lt;/code&gt; 可依次扫出：&lt;code&gt;foo =&amp;gt; foo_value&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;假设「事务样例」中事务 #1 已 Commit 而事务 #2 已 Prewrite 未 Commit，此时：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;scan_ts = 0x05 顺序扫 &lt;code&gt;[-∞, +∞)&lt;/code&gt;，可依次扫出：&lt;code&gt;bar =&amp;gt; bar_value&lt;/code&gt;、&lt;code&gt;foo =&amp;gt; foo_value&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;scan_ts = 0x12 顺序扫 &lt;code&gt;[-∞, +∞)&lt;/code&gt;，会先扫出 &lt;code&gt;bar =&amp;gt; bar_value&lt;/code&gt;，若还要继续扫应当返回 &lt;code&gt;box&lt;/code&gt; 的锁冲突。TiDB 拿到这个错误后会等锁、清锁并重试。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;顺序扫流程&lt;/h2&gt;&lt;p&gt;根据上面所说的顺序扫定义及例子，在不考虑锁冲突的情况下，可以想出一个最简单的实现思路就是不断将 Write CF 的 Cursor 从 &lt;code&gt;lower_bound&lt;/code&gt; 往后移动，对于各个 User Key 跳过它 &lt;code&gt;commit_ts &amp;gt; scan_ts&lt;/code&gt; 的版本，采纳第一个 &lt;code&gt;commit_ts &amp;lt;= scan_ts&lt;/code&gt; 的版本，根据版本 Write Info 从 Default CF 中获取 Value，即可组成返回给上层的 KV 对。&lt;/p&gt;&lt;p&gt;这个思路很简单，但无法处理锁冲突。在有锁冲突的情况下，顺序扫只应当对扫到的数据处理锁冲突，没扫到的数据即使有锁，也不应该影响无冲突数据的正常扫（例如用户的 SQL 中有 limit）。由于不同 User Key（及同一个 User Key 的不同版本）都可能同时散落在 Write CF 与 Lock CF 中，因此 &lt;b&gt;TiKV 的思路类似于归并排序&lt;/b&gt;：同时移动 Write CF Cursor 与 Lock CF Cursor，在移动过程中这两个 Cursor 可能对应了不同的 User Key，较小的那个就是要优先处理的 User Key。如果这个 User Key 是 Lock CF 中的，说明可能遇到了锁冲突，需要返回失败或忽略。如果这个 User Key 是 Write CF 中的，说明有多版本可以供读取，需要找到最近的一个满足 &lt;code&gt;scan_ts&lt;/code&gt; 要求的版本信息 Write Info，根据其内部记载的 &lt;code&gt;start_ts&lt;/code&gt; 再从 Default CF 中获取 Value，从而组成 KV 对返回给上层。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8b372947f4dda0ecdae470d4e51dd068_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;483&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-8b372947f4dda0ecdae470d4e51dd068_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8b372947f4dda0ecdae470d4e51dd068_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;483&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-8b372947f4dda0ecdae470d4e51dd068_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8b372947f4dda0ecdae470d4e51dd068_b.jpg&quot;/&gt;&lt;figcaption&gt;图 1 TiKV 扫数据算法示意&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;单次迭代的具体流程为：&lt;/p&gt;&lt;h3&gt;步骤 1.&lt;/h3&gt;&lt;p&gt;首次迭代：将 Lock 及 Write CF Cursor Seek 到 &lt;code&gt;lower_bound&lt;/code&gt; 处。此时它们各自指向了第一个 &lt;code&gt;&amp;gt;= lower_bound&lt;/code&gt; 的 Key。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;if !self.is_started {
    if self.cfg.lower_bound.is_some() {
        self.write_cursor.seek(
            self.cfg.lower_bound.as_ref().unwrap(),
            ...,
        )?;
        self.lock_cursor.seek(
            self.cfg.lower_bound.as_ref().unwrap(),
            ...,
        )?;
    } else {
        self.write_cursor.seek_to_first(...);
        self.lock_cursor.seek_to_first(...);
    }
    self.is_started = true;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;步骤 2.&lt;/h3&gt;&lt;p&gt;Lock Cursor 和 Write Cursor 分别指向的 Key 可能对应不同的 User Key（也可能指向空，代表该 CF 已没有更多数据）。比较 Lock Cursor 与 Write Cursor 可得出第一个遇到的 User Key：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let w_key = if self.write_cursor.valid()? {
    Some(self.write_cursor.key(...))
} else {
    None
};
let l_key = if self.lock_cursor.valid()? {
    Some(self.lock_cursor.key(...))
} else {
    None
};

match (w_key, l_key) { ... }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;分支 2.1.&lt;/h3&gt;&lt;p&gt;Write Cursor 指向空，Lock Cursor 指向空：说明两个 CF 都扫完了，该直接结束了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b986b7452d388672540ca834b3a7a0eb_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;508&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-b986b7452d388672540ca834b3a7a0eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b986b7452d388672540ca834b3a7a0eb_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;508&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic4.zhimg.com/v2-b986b7452d388672540ca834b3a7a0eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b986b7452d388672540ca834b3a7a0eb_b.jpg&quot;/&gt;&lt;figcaption&gt;图 2 进入本分支的一种情况，若 Seek 的是 e，则处于 Write Cursor 和 Lock Cursor 都指向空的状态&lt;/figcaption&gt;&lt;/figure&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(current_user_key_slice, has_write, has_lock) = match (w_key, l_key) {
    (None, None) =&amp;gt; {
        // Both cursors yield `None`: we know that there is nothing remaining.
        return Ok(None);
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;分支 2.2.&lt;/h3&gt;&lt;p&gt;Write Cursor 指向某个值 &lt;code&gt;w_key&lt;/code&gt;，Lock Cursor 指向空：说明存在一个 &lt;code&gt;User Key = w_key&lt;/code&gt; 的 Write Info，且没有任何 &lt;code&gt;&amp;gt;= Start Key&lt;/code&gt; 的 Lock Info。&lt;code&gt;w_key&lt;/code&gt; 即为第一个遇到的 User Key。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(current_user_key_slice, has_write, has_lock) = match (w_key, l_key) {
    ...
    (Some(k), None) =&amp;gt; {
        // Write cursor yields something but lock cursor yields `None`:
        // We need to further step write cursor to our desired version
        (Key::truncate_ts_for(k)?, true, false)
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;分支 2.3.&lt;/h3&gt;&lt;p&gt;Write Cursor 指向空，Lock Cursor 指向某个值 &lt;code&gt;l_key&lt;/code&gt;：说明存在一个 &lt;code&gt;User Key = l_key&lt;/code&gt; 的 Lock Info。&lt;code&gt;l_key&lt;/code&gt; 即是第一个遇到的 User Key。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(current_user_key_slice, has_write, has_lock) = match (w_key, l_key) {
    ...
    (None, Some(k)) =&amp;gt; {
        // Write cursor yields `None` but lock cursor yields something:
        // In RC, it means we got nothing.
        // In SI, we need to check if the lock will cause conflict.
        (k, false, true)
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;分支 2.4.&lt;/h3&gt;&lt;p&gt;Write Cursor 指向某个值 &lt;code&gt;w_key&lt;/code&gt;，Lock Cursor 指向某个值 &lt;code&gt;l_key&lt;/code&gt;：说明存在一个 &lt;code&gt;User Key = l_key&lt;/code&gt; 的 Lock Info、存在一个 &lt;code&gt;User Key = w_key&lt;/code&gt; 的 Write Info。&lt;code&gt;l_key&lt;/code&gt; 与 &lt;code&gt;w_key&lt;/code&gt; 中小的那个是第一个遇到的 User Key。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5a2de2c5380c8841f81334a7e2852df2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;454&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5a2de2c5380c8841f81334a7e2852df2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5a2de2c5380c8841f81334a7e2852df2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;454&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-5a2de2c5380c8841f81334a7e2852df2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5a2de2c5380c8841f81334a7e2852df2_b.jpg&quot;/&gt;&lt;figcaption&gt;图 3 进入本分支的一种情况，若 Seek 的是 a，则处于 Write Cursor 和 Lock Cursor 都指向某个值的状态&lt;/figcaption&gt;&lt;/figure&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;(current_user_key_slice, has_write, has_lock) = match (w_key, l_key) {
    ...
    (Some(wk), Some(lk)) =&amp;gt; {
        let write_user_key = Key::truncate_ts_for(wk)?;
        match write_user_key.cmp(lk) {
            Ordering::Less =&amp;gt; {
                // Write cursor user key &amp;lt; lock cursor, it means the lock of the
                // current key that write cursor is pointing to does not exist.
                (write_user_key, true, false)
            }
            Ordering::Greater =&amp;gt; {
                // Write cursor user key &amp;gt; lock cursor, it means we got a lock of a
                // key that does not have a write. In SI, we need to check if the
                // lock will cause conflict.
                (lk, false, true)
            }
            Ordering::Equal =&amp;gt; {
                // Write cursor user key == lock cursor, it means the lock of the
                // current key that write cursor is pointing to *exists*.
                (lk, true, true)
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;步骤 3.&lt;/h3&gt;&lt;p&gt;如果在步骤 2 中，第一个遇到的 User Key 来自于 Lock，则：&lt;/p&gt;&lt;h3&gt;步骤 3.1.&lt;/h3&gt;&lt;p&gt;检查 Lock Info 是否有效，例如需要忽略 &lt;code&gt;start_ts &amp;gt; scan_ts&lt;/code&gt; 的 lock。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let lock = {
    let lock_value = self.lock_cursor.value(...);
    Lock::parse(lock_value)?
};
match super::util::check_lock(&amp;amp;current_user_key, self.cfg.ts, &amp;amp;lock)? {
    CheckLockResult::NotLocked =&amp;gt; {}
    CheckLockResult::Locked(e) =&amp;gt; result = Err(e),
    CheckLockResult::Ignored(ts) =&amp;gt; get_ts = ts,
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;我们一般以当前的时间构造 scan_ts，为什么实际看到的似乎是“未来”的 lock？原因是这个读请求可能来自于一个早期开始的事务，或这个请求被网络阻塞了一会儿，或者我们正在&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/docs-cn/v3.0/how-to/get-started/read-historical-data/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;读取历史数据&lt;/a&gt;。&lt;/blockquote&gt;&lt;h3&gt;步骤 3.2.&lt;/h3&gt;&lt;p&gt;将 Lock Cursor 往后移动一个 Key，以便下次迭代可以直接从新的 Lock 继续。此时 Lock Cursor 指向下一个 Lock（也可能指向空）。&lt;/p&gt;&lt;h3&gt;步骤 3.3.&lt;/h3&gt;&lt;p&gt;在 3.1 步骤中检查下来有效的话报错返回这个 Lock，TiDB 后续需要进行清锁操作。&lt;/p&gt;&lt;h3&gt;步骤 4.&lt;/h3&gt;&lt;p&gt;如果在步骤 2 中，第一个遇到的 User Key 来自于 Write：&lt;/p&gt;&lt;blockquote&gt;注：Lock Cursor 与 Write Cursor 可能一起指向了同一个 User Key 的不同版本。由于我们只想忽略锁对应的版本而不是想忽略这整个 User Key，因此此时步骤 3 和步骤 4 都会被执行，如下图所示。&lt;br/&gt;&lt;/blockquote&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-002f317c5d057af90587d5a122350f8c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;454&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-002f317c5d057af90587d5a122350f8c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-002f317c5d057af90587d5a122350f8c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;454&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-002f317c5d057af90587d5a122350f8c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-002f317c5d057af90587d5a122350f8c_b.jpg&quot;/&gt;&lt;figcaption&gt;图 4 一种 User Cursor 和 Lock Cursor 具有相同 User Key 的情况，Seek 的是 c&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;走到了目前这一步，说明我们需要从 Write Info 中读取 User Key 满足 &lt;code&gt;scan_ts&lt;/code&gt; 的记录。需要注意，此时 User Key 可能是存在 Lock 的，但已被判定为应当忽略。&lt;/p&gt;&lt;h3&gt;步骤 4.1.&lt;/h3&gt;&lt;p&gt;将 Write Cursor Seek 到 &lt;code&gt;{w_key}{!scan_ts}&lt;/code&gt; 处（注：参见「事务样例」中区别 3，时间戳存储时取了反，因此这里及本文其余部分都以 &lt;code&gt;!&lt;/code&gt; 标记取反操作）。如果版本数很少（同时这也符合绝大多数场景），那么这个要 Seek 的 Key 很可能非常靠近当前位置。在这个情况下为了避免较大的 Seek 开销，TiKV 采取先 &lt;code&gt;next&lt;/code&gt; 若干次再 &lt;code&gt;seek&lt;/code&gt; 的策略：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Try to iterate to `${user_key}_${ts}`. We first `next()` for a few times,
// and if we have not reached where we want, we use `seek()`.

// Whether we have *not* reached where we want by `next()`.
let mut needs_seek = true;

for i in 0..SEEK_BOUND {
    if i &amp;gt; 0 {
        self.write_cursor.next(...);
        if !self.write_cursor.valid()? {
            // Key space ended.
            return Ok(None);
        }
    }
    {
        let current_key = self.write_cursor.key(...);
        if !Key::is_user_key_eq(current_key, user_key.as_encoded().as_slice()) {
            // Meet another key.
            *met_next_user_key = true;
            return Ok(None);
        }
        if Key::decode_ts_from(current_key)? &amp;lt;= ts {
            // Founded, don&amp;#39;t need to seek again.
            needs_seek = false;
            break;
        }
    }
}
// If we have not found `${user_key}_${ts}` in a few `next()`, directly `seek()`.
if needs_seek {
    // `user_key` must have reserved space here, so its clone has reserved space too. So no
    // reallocation happens in `append_ts`.
    self.write_cursor
        .seek(&amp;amp;user_key.clone().append_ts(ts), ...)?;
    if !self.write_cursor.valid()? {
        // Key space ended.
        return Ok(None);
    }
    let current_key = self.write_cursor.key(...);
    if !Key::is_user_key_eq(current_key, user_key.as_encoded().as_slice()) {
        // Meet another key.
        *met_next_user_key = true;
        return Ok(None);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;步骤 4.2.&lt;/h3&gt;&lt;p&gt;&lt;code&gt;w_key&lt;/code&gt; 可能没有任何 &lt;code&gt;commit_ts &amp;lt;= scan_ts&lt;/code&gt; 的记录，因此 Seek &lt;code&gt;{w_key}{!scan_ts}&lt;/code&gt; 时可能直接越过了当前 User Key 进入下一个 &lt;code&gt;w_key&lt;/code&gt;，因此需要先判断一下现在 Write Cursor 对应的 User Key 是否仍然是 &lt;code&gt;w_key&lt;/code&gt;。如果是的话，说明这是我们找到的最大符合 &lt;code&gt;scan_ts&lt;/code&gt; 的版本（Write Info）了，我们就可以依据该版本直接确定数据内容。若版本中包含的类型是 &lt;code&gt;DELETE&lt;/code&gt;，说明在这个版本下 &lt;code&gt;w_key&lt;/code&gt; 或者说 User Key 已被删除，那么我们就当做它不存在；否则如果类型是 &lt;code&gt;PUT&lt;/code&gt;，就可以按照版本中存储的 &lt;code&gt;start_ts&lt;/code&gt; 在 Default CF 中直接取得 User Value：Get &lt;code&gt;{w_key}{!start_ts}&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;另一方面，如果这一步 Seek 到了下一个 &lt;code&gt;w_key&lt;/code&gt;，我们就不能采信这个新的 &lt;code&gt;w_key&lt;/code&gt;，什么也不做，回到步骤 2，因为这个新的 &lt;code&gt;w_key&lt;/code&gt; 可能比 &lt;code&gt;l_key&lt;/code&gt; 大了，需要先重新看一下 &lt;code&gt;l_key&lt;/code&gt; 的情况。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Now we must have reached the first key &amp;gt;= `${user_key}_${ts}`. However, we may
// meet `Lock` or `Rollback`. In this case, more versions needs to be looked up.
loop {
    let write = Write::parse(self.write_cursor.value(...))?;
    self.statistics.write.processed += 1;

    match write.write_type {
        WriteType::Put =&amp;gt; return Ok(Some(self.load_data_by_write(write, user_key)?)),
        WriteType::Delete =&amp;gt; return Ok(None),
        WriteType::Lock | WriteType::Rollback =&amp;gt; {
            // Continue iterate next `write`.
        }
    }

    ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;步骤 4.3.&lt;/h3&gt;&lt;p&gt;此时我们已经知道了 &lt;code&gt;w_key&lt;/code&gt;（即 User Key）符合 &lt;code&gt;scan_ts&lt;/code&gt; 版本要求的 Value。为了能允许后续进一步迭代到下一个 &lt;code&gt;w_key&lt;/code&gt;，我们需要移动 Write Cursor 跳过当前 &lt;code&gt;w_key&lt;/code&gt; 剩余所有版本。跳过的方法是 Seek &lt;code&gt;{w_key}{\xFF..\xFF}&lt;/code&gt;，此时 Write Cursor 指向第一个 &lt;code&gt;&amp;gt;= {w_key}{\xFF..\xFF}&lt;/code&gt; 的 Key，也就是下一个 &lt;code&gt;w_key&lt;/code&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;fn move_write_cursor_to_next_user_key(&amp;amp;mut self, current_user_key: &amp;amp;Key) -&amp;gt; Result&amp;lt;()&amp;gt; {
    for i in 0..SEEK_BOUND {
        if i &amp;gt; 0 {
            self.write_cursor.next(...);
        }
        if !self.write_cursor.valid()? {
            // Key space ended. We are done here.
            return Ok(());
        }
        {
            let current_key = self.write_cursor.key(...);
            if !Key::is_user_key_eq(current_key, current_user_key.as_encoded().as_slice()) {
                // Found another user key. We are done here.
                return Ok(());
            }
        }
    }
    // We have not found another user key for now, so we directly `seek()`.
    // After that, we must pointing to another key, or out of bound.
    // `current_user_key` must have reserved space here, so its clone has reserved space too.
    // So no reallocation happens in `append_ts`.
    self.write_cursor.internal_seek(
        &amp;amp;current_user_key.clone().append_ts(0),
        ...,
    )?;
    Ok(())
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;步骤 4.4.&lt;/h3&gt;&lt;p&gt;依据之前取得的 User Value 返回 (User Key, User Value)。&lt;/p&gt;&lt;h3&gt;步骤 5.&lt;/h3&gt;&lt;p&gt;如果没有扫到值，回到 2。&lt;/p&gt;&lt;h2&gt;样例解释&lt;/h2&gt;&lt;p&gt;上面的步骤可能过于枯燥，接下来结合「事务样例」看一下流程。假设现在样例中的事务 #1 已递交而事务 #2 prewrite 完毕但还没 commit，则这几个样例事务在 RocksDB 存储的数据类似于如下所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e16a5456727e6c6164aca87a73cebcea_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;224&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-e16a5456727e6c6164aca87a73cebcea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e16a5456727e6c6164aca87a73cebcea_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;224&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-e16a5456727e6c6164aca87a73cebcea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e16a5456727e6c6164aca87a73cebcea_b.jpg&quot;/&gt;&lt;figcaption&gt;图 5 样例事务在 RocksDB 的存储数据&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;现在尝试以 scan_ts = 0x05 顺序扫 &lt;code&gt;[-∞, +∞)&lt;/code&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;执行步骤 1：首次迭代：将 Lock 及 Write CF Cursor Seek 到 &lt;code&gt;lower_bound&lt;/code&gt; 处。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ba546e4ff3e8b1ce72cf1769c4bababd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-ba546e4ff3e8b1ce72cf1769c4bababd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ba546e4ff3e8b1ce72cf1769c4bababd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-ba546e4ff3e8b1ce72cf1769c4bababd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ba546e4ff3e8b1ce72cf1769c4bababd_b.jpg&quot;/&gt;&lt;figcaption&gt;图 6 执行完毕后各个 Cursor 位置示意&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;执行步骤 2：对比 Lock Cursor 与 Write Cursor，进入分支 2.4。&lt;/li&gt;&lt;li&gt;执行分支 2.4：Write Cursor 指向 &lt;code&gt;bar&lt;/code&gt;，Lock Cursor 指向 &lt;code&gt;box&lt;/code&gt;，User Key 为 &lt;code&gt;bar&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;执行步骤 3：User Key = bar 不来自于 Lock，跳过。&lt;/li&gt;&lt;li&gt;执行步骤 4：User Key = bar 来自于 Write，继续。&lt;/li&gt;&lt;li&gt;执行步骤 4.1：Seek &lt;code&gt;{w_key}{!scan_ts}&lt;/code&gt;，即 Seek &lt;code&gt;bar......\xFF\xFF..\xFA&lt;/code&gt;。Write Cursor 仍然是当前位置。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ba546e4ff3e8b1ce72cf1769c4bababd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-ba546e4ff3e8b1ce72cf1769c4bababd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ba546e4ff3e8b1ce72cf1769c4bababd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-ba546e4ff3e8b1ce72cf1769c4bababd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ba546e4ff3e8b1ce72cf1769c4bababd_b.jpg&quot;/&gt;&lt;figcaption&gt;图 7 执行完毕后各个 Cursor 位置示意&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;执行步骤 4.2：此时 Write Key 指向 bar 与 User Key 相同，因此依据 &lt;code&gt;PUT (start_ts=1)&lt;/code&gt; 从 Default CF 中获取到 &lt;code&gt;value = bar_value&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;执行步骤 4.3：移动 Write Cursor 跳过当前 &lt;code&gt;bar&lt;/code&gt; 剩余所有版本，即 Seek &lt;code&gt;bar......\xFF\xFF..\xFF&lt;/code&gt;：&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f775386aa759a47092d1e4bb5e7ea358_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-f775386aa759a47092d1e4bb5e7ea358_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f775386aa759a47092d1e4bb5e7ea358_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-f775386aa759a47092d1e4bb5e7ea358_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f775386aa759a47092d1e4bb5e7ea358_b.jpg&quot;/&gt;&lt;figcaption&gt;图 8 执行完毕后各个 Cursor 位置示意&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;执行步骤 4.4：对外返回 Key Value 对 &lt;code&gt;(bar, bar_value)&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;若外部只需要 1 个 KV 对（例如 limit = 1），此时就可以停止了，若外部还要继续获取更多 KV 对，则重新开始执行步骤 1。&lt;/li&gt;&lt;li&gt;执行步骤 1：不是首次迭代，跳过。&lt;/li&gt;&lt;li&gt;执行步骤 2：对比 Lock Cursor 与 Write Cursor，进入分支 2.4。&lt;/li&gt;&lt;li&gt;执行分支 2.4：Write Cursor 指向 &lt;code&gt;foo&lt;/code&gt;，Lock Cursor 指向 &lt;code&gt;box&lt;/code&gt;，User Key 为 &lt;code&gt;box&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f775386aa759a47092d1e4bb5e7ea358_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-f775386aa759a47092d1e4bb5e7ea358_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f775386aa759a47092d1e4bb5e7ea358_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-f775386aa759a47092d1e4bb5e7ea358_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f775386aa759a47092d1e4bb5e7ea358_b.jpg&quot;/&gt;&lt;figcaption&gt;图 9 执行完毕后各个 Cursor 位置示意&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;执行步骤 3：User Key = box 来自于 Lock，继续。&lt;/li&gt;&lt;li&gt;执行步骤 3.1：检查 Lock Info。Lock 的 ts 为 0x11，&lt;code&gt;scan_ts&lt;/code&gt; 为 0x05，忽略这个 Lock 不返回锁冲突错误。&lt;/li&gt;&lt;li&gt;执行步骤 3.2：将 Lock Cursor 往后移动一个 Key。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6adc28ac1e095e0eb0e4e9855b6955f8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-6adc28ac1e095e0eb0e4e9855b6955f8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6adc28ac1e095e0eb0e4e9855b6955f8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-6adc28ac1e095e0eb0e4e9855b6955f8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6adc28ac1e095e0eb0e4e9855b6955f8_b.jpg&quot;/&gt;&lt;figcaption&gt;图 10 执行完毕后各个 Cursor 位置示意&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;执行步骤 4：User Key = box 不来自于 Write，跳过，回到步骤 2。&lt;/li&gt;&lt;li&gt;执行步骤 2：对比 Lock Cursor 与 Write Cursor，进入分支 2.4。&lt;/li&gt;&lt;li&gt;执行分支 2.4：Write Cursor 指向 &lt;code&gt;foo&lt;/code&gt;，Lock Cursor 指向 &lt;code&gt;foo&lt;/code&gt;，User Key 为 &lt;code&gt;foo&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6adc28ac1e095e0eb0e4e9855b6955f8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-6adc28ac1e095e0eb0e4e9855b6955f8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6adc28ac1e095e0eb0e4e9855b6955f8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic1.zhimg.com/v2-6adc28ac1e095e0eb0e4e9855b6955f8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6adc28ac1e095e0eb0e4e9855b6955f8_b.jpg&quot;/&gt;&lt;figcaption&gt;图 11 执行完毕后各个 Cursor 位置示意&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;执行步骤 3：User Key = foo 来自于 Lock，继续。与之前类似，锁被忽略，且 Lock Cursor 往后移动。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-556e3a8901aa429b3de5813ffa188ff2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-556e3a8901aa429b3de5813ffa188ff2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-556e3a8901aa429b3de5813ffa188ff2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;187&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic3.zhimg.com/v2-556e3a8901aa429b3de5813ffa188ff2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-556e3a8901aa429b3de5813ffa188ff2_b.jpg&quot;/&gt;&lt;figcaption&gt;图 12 执行完毕后各个 Cursor 位置示意&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;执行步骤 4：User Key = foo 同样来自于 Write，继续。&lt;/li&gt;&lt;li&gt;执行步骤 4.1：Seek &lt;code&gt;{w_key}{!scan_ts}&lt;/code&gt;，即 Seek &lt;code&gt;foo......\xFF\xFF..\xFA&lt;/code&gt;。Write Cursor 仍然是当前位置。&lt;/li&gt;&lt;li&gt;执行步骤 4.2：此时 Write Key 指向 foo 与 User Key 相同，因此依据 &lt;code&gt;PUT (start_ts=1)&lt;/code&gt; 从 Default CF 中获取到 &lt;code&gt;value = foo_value&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;执行步骤 4.3：移动 Write Cursor 跳过当前 &lt;code&gt;foo&lt;/code&gt; 剩余所有版本，即 Seek &lt;code&gt;foo......\xFF\xFF..\xFF&lt;/code&gt;：&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-27a2386e7e6ee8c6b5ed410ca90d0735_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;214&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-27a2386e7e6ee8c6b5ed410ca90d0735_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-27a2386e7e6ee8c6b5ed410ca90d0735_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;214&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-27a2386e7e6ee8c6b5ed410ca90d0735_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-27a2386e7e6ee8c6b5ed410ca90d0735_b.jpg&quot;/&gt;&lt;figcaption&gt;图 13 执行完毕后各个 Cursor 位置示意&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;执行步骤 4.4：对外返回 Key Value 对 &lt;code&gt;(foo, foo_value)&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;若外部选择继续扫，则继续回到步骤 1。&lt;/li&gt;&lt;li&gt;执行步骤 1：不是首次迭代，跳过。&lt;/li&gt;&lt;li&gt;执行步骤 2：对比 Lock Cursor 与 Write Cursor，进入分支 2.1。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-27a2386e7e6ee8c6b5ed410ca90d0735_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;214&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-27a2386e7e6ee8c6b5ed410ca90d0735_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-27a2386e7e6ee8c6b5ed410ca90d0735_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;939&quot; data-rawheight=&quot;214&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;939&quot; data-original=&quot;https://pic2.zhimg.com/v2-27a2386e7e6ee8c6b5ed410ca90d0735_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-27a2386e7e6ee8c6b5ed410ca90d0735_b.jpg&quot;/&gt;&lt;figcaption&gt;图 14 执行完毕后各个 Cursor 位置示意&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;执行步骤 2.1：Write Cursor 和 Lock Cursor 都指向空，没有更多数据了。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;以上就是 MVCC 顺序扫数据代码的解析，点查和逆序扫流程与其类似，并且代码注释很详细，大家可以自主阅读理解。下篇文章我们会详细介绍悲观事务的代码实现。&lt;/p&gt;&lt;p&gt;&lt;b&gt;原文阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/tikv-source-code-reading-13/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;TiKV 源码解析系列文章（十三）MVCC 数据读取 | PingCAP&lt;/a&gt;&lt;p&gt;&lt;b&gt;更多 TiKV 源码阅读：&lt;/b&gt;&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/%23TiKV-%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E6%259E%2590&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg&quot; data-image-width=&quot;1200&quot; data-image-height=&quot;1200&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Blog-cns | PingCAP&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>ZoeyZhai</author>
<guid isPermaLink="false">2019-09-03-81003380</guid>
<pubDate>Tue, 03 Sep 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
