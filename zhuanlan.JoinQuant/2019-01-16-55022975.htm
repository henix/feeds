<div class="title-image"><img src="https://pic3.zhimg.com/v2-eec28930db291fc846fc003e70b71081_b.jpg" alt=""></div><p>今天我们构建的量化模型，尝试用python搭建，首先它把数据拆分重构，使用15分钟或者更低颗粒度的K线，重构成为1小时线或者半日线。然后在重构的K线上，搭建ATR自适应通道交易模型。</p><p>如果说后半部分模型开发是很多软件都可以做的，前半部分就并非如此了。我们要以每天中午12点，下午15点为切分点，<b>把每天的时间序列切分成3段。</b></p><p>让我们从最简单的模型本体交易逻辑开始讲。</p><p><b>一、模型本体——ATR自适应通道</b></p><p>很多做期货动量交易的人都明白，通道突破类策略是典型的趋势策略，这类策略指导构建的交易模型也比较简单清晰，并且将标准差等波动率表达方式考虑到模型中，有助于提升绩效。这里说的提升绩效，一方面是通过通道的中轨确定大致方向，另一方面是通过标准差等波动率指标，确认通道宽度。</p><p>首当其中的就是布林带，这个经典指标已经几十年被使用，基本上没人敢说这套系统不能用，但是它毕竟太过于古老，需要改进，这是共识。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-9814459da10dfa05c457887e66b6a442_b.jpg" data-caption="" data-size="normal" data-rawwidth="704" data-rawheight="398" class="origin_image zh-lightbox-thumb" width="704" data-original="https://pic3.zhimg.com/v2-9814459da10dfa05c457887e66b6a442_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-9814459da10dfa05c457887e66b6a442_b.jpg" data-caption="" data-size="normal" data-rawwidth="704" data-rawheight="398" class="origin_image zh-lightbox-thumb lazy" width="704" data-original="https://pic3.zhimg.com/v2-9814459da10dfa05c457887e66b6a442_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-9814459da10dfa05c457887e66b6a442_b.jpg"/></figure><p><b>典型的通道突破类策略是Aberration，实际上就是布林带，它被翻译理解为“失常、离开正路、越轨”等含义。</b>该模型在均线上，构建了上下两个通道，通过波动率高低调节通道大小，如果价格突破上轨，就做多，如果价格突破下轨，就做空，价格回到中轨平仓，达到一定的自适应突破效果。</p><p>它的原理是这样：</p><p>// 中轨AverageMA，此处的Length是计算均线的窗口期<br/>AverageMA = Average(Close<a href="https://link.zhihu.com/?target=https%3A//image.joinquant.com/e85ed81deb0959f39b6438a7c0f0cab6" class=" wrap external" target="_blank" rel="nofollow noreferrer">1</a>,Length);<br/>// 价格序列的标准差<br/>StdValue = StandardDev(Close<a href="https://link.zhihu.com/?target=https%3A//image.joinquant.com/e85ed81deb0959f39b6438a7c0f0cab6" class=" wrap external" target="_blank" rel="nofollow noreferrer">1</a>,Length);<br/>// 上轨和下轨，此处的StdDev是标准差倍数<br/>UpperBand = Avema StdDev <i>StdValue;</i><br/><i>LowerBand = Avema - StdDev</i> StdValue;</p><p>今天的改进针对标准差部分，我们发现ATR比标准差更能够反应波动率的真伪，毕竟ATR采用的时间序列信息含量更高。</p><p>标准差是一个统计工具，不再叙述。ATR概念由威尔德（J. Welles Wilder）1978年于《New Concepts in Technical Trading Systems》书中提出，它取一定时间周期内的价格波动幅度的移动平均值，和你看到的网络上的注解不同，它并不是主要用于研判买卖时机，也不是做什么反趋势指标，它能感知到波动率。</p><p>海通证券测试了ATR和标准差的性能差异，这四种情况虽然特殊，但是以极端方式，体现了<b>标准差和ATR的区别。</b></p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-d2b30d12a5649d6b8eb52d0d8f3b5544_b.jpg" data-caption="" data-size="normal" data-rawwidth="1017" data-rawheight="588" class="origin_image zh-lightbox-thumb" width="1017" data-original="https://pic1.zhimg.com/v2-d2b30d12a5649d6b8eb52d0d8f3b5544_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-d2b30d12a5649d6b8eb52d0d8f3b5544_b.jpg" data-caption="" data-size="normal" data-rawwidth="1017" data-rawheight="588" class="origin_image zh-lightbox-thumb lazy" width="1017" data-original="https://pic1.zhimg.com/v2-d2b30d12a5649d6b8eb52d0d8f3b5544_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-d2b30d12a5649d6b8eb52d0d8f3b5544_b.jpg"/></figure><p>图1，标准差的表现力更强，因为价格确实出现了波动幅度变化。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-9da0d2ebbfd5e8032df9bd91a4a80e0a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1019" data-rawheight="585" class="origin_image zh-lightbox-thumb" width="1019" data-original="https://pic3.zhimg.com/v2-9da0d2ebbfd5e8032df9bd91a4a80e0a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-9da0d2ebbfd5e8032df9bd91a4a80e0a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1019" data-rawheight="585" class="origin_image zh-lightbox-thumb lazy" width="1019" data-original="https://pic3.zhimg.com/v2-9da0d2ebbfd5e8032df9bd91a4a80e0a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-9da0d2ebbfd5e8032df9bd91a4a80e0a_b.jpg"/></figure><p>图2，和研报观点相同，ATR可以稳定的保持着较高的水平，能对新的价格运行方向上的波动状态进行有效的刻画，但是标准差不行。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-bd1e992b64b9dc9a2887435e32ccf6b9_b.jpg" data-caption="" data-size="normal" data-rawwidth="1019" data-rawheight="584" class="origin_image zh-lightbox-thumb" width="1019" data-original="https://pic2.zhimg.com/v2-bd1e992b64b9dc9a2887435e32ccf6b9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-bd1e992b64b9dc9a2887435e32ccf6b9_b.jpg" data-caption="" data-size="normal" data-rawwidth="1019" data-rawheight="584" class="origin_image zh-lightbox-thumb lazy" width="1019" data-original="https://pic2.zhimg.com/v2-bd1e992b64b9dc9a2887435e32ccf6b9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-bd1e992b64b9dc9a2887435e32ccf6b9_b.jpg"/></figure><p>图3，标准差在适应新趋势时又一次表现出对趋势逆转时波动率提升的错误描述，它在新趋势刚开始出现时先缓慢下降，此时很容易造成通道类突破系统做出错误判断。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-a179e4a20fd967db8c396b20ac4defd5_b.jpg" data-caption="" data-size="normal" data-rawwidth="1036" data-rawheight="586" class="origin_image zh-lightbox-thumb" width="1036" data-original="https://pic2.zhimg.com/v2-a179e4a20fd967db8c396b20ac4defd5_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-a179e4a20fd967db8c396b20ac4defd5_b.jpg" data-caption="" data-size="normal" data-rawwidth="1036" data-rawheight="586" class="origin_image zh-lightbox-thumb lazy" width="1036" data-original="https://pic2.zhimg.com/v2-a179e4a20fd967db8c396b20ac4defd5_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-a179e4a20fd967db8c396b20ac4defd5_b.jpg"/></figure><p>图4，很罕见的情况，但是ATR采用了最高最低价，而标准差没有，所以它对于波动率的分析显然错了。</p><p>所以，我们要使用ATR改进布林带了，改进完的这套系统，应该被称作<b>肯特纳通道</b>，网上会有很多资料，这里使用公众号《量化投资训练营》的结果，来体现两者的细微差距。</p><p>我们关闭掉模型中其他条件，仅以布林带或者说使用ATR为逻辑的Keltner Band作为开平仓条件进行测试。测试目标是螺纹钢RB000，2010年开始指数合约，沪深300指数2010年开始时间序列。频率都在1小时。</p><p>为了公平起见，参数统一为20周日ATR或者标准差。且为了得到均等的参数面绩效，我们令中轨周期参数Length在30~200之间波动，间隔5,。令Offset上下轨宽度参数在1~3之间波动，间隔0.5.。这样既可得到一个约180组绩效。</p><p>TOP组的意思是取按净利润排列，前30个绩效。ALL组的意思是所有绩效。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-194a0c96ebddda1ab0782f0ef0f5c6a0_b.jpg" data-caption="" data-size="normal" data-rawwidth="664" data-rawheight="395" class="origin_image zh-lightbox-thumb" width="664" data-original="https://pic1.zhimg.com/v2-194a0c96ebddda1ab0782f0ef0f5c6a0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-194a0c96ebddda1ab0782f0ef0f5c6a0_b.jpg" data-caption="" data-size="normal" data-rawwidth="664" data-rawheight="395" class="origin_image zh-lightbox-thumb lazy" width="664" data-original="https://pic1.zhimg.com/v2-194a0c96ebddda1ab0782f0ef0f5c6a0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-194a0c96ebddda1ab0782f0ef0f5c6a0_b.jpg"/></figure><p>螺纹钢参数面测试结果</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-4313844a91ad77253f0eb38c363de8d6_b.jpg" data-caption="" data-size="normal" data-rawwidth="671" data-rawheight="403" class="origin_image zh-lightbox-thumb" width="671" data-original="https://pic3.zhimg.com/v2-4313844a91ad77253f0eb38c363de8d6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-4313844a91ad77253f0eb38c363de8d6_b.jpg" data-caption="" data-size="normal" data-rawwidth="671" data-rawheight="403" class="origin_image zh-lightbox-thumb lazy" width="671" data-original="https://pic3.zhimg.com/v2-4313844a91ad77253f0eb38c363de8d6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-4313844a91ad77253f0eb38c363de8d6_b.jpg"/></figure><p>沪深300参数面测试结果</p><p>经过测试发现，商品期货上性能差异不够明显，但是到了股指方面，ATR的优势进一步显现。这其中最核心的因素恰巧是交易次数，带来的绩效IR提升，这里我们定义的IR和信息广度有关，我们认为信号数量是对于绩效可信度的考察方式。</p><p>ATR通道，在螺纹钢和沪深300指数上，信号数量是标准差的1.14倍和1.05倍，且同时绩效略好，所以导致这里定义的绩效IR = 绩效*SQRT（交易次数）差别更显著。</p><p>该部分逻辑，使用python语言撰写效果如下：</p><div class="highlight"><pre><code class="language-python3"><span class="c1"># ATR计算  </span>
        <span class="n">g</span><span class="o">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">AM</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span><span class="o">.</span><span class="n">exportArray</span><span class="p">(</span><span class="s1">&#39;low&#39;</span><span class="p">)[</span><span class="o">-</span><span class="n">g</span><span class="o">.</span><span class="n">TodayBar</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">Window</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">g</span><span class="o">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">AM</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span><span class="o">.</span><span class="n">exportArray</span><span class="p">(</span><span class="s1">&#39;high&#39;</span><span class="p">)[</span><span class="o">-</span><span class="n">g</span><span class="o">.</span><span class="n">TodayBar</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">Window</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">g</span><span class="o">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">AM</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span><span class="o">.</span><span class="n">exportArray</span><span class="p">(</span><span class="s1">&#39;close&#39;</span><span class="p">)[</span><span class="o">-</span><span class="n">g</span><span class="o">.</span><span class="n">TodayBar</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">Window</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># 为了防止ATR误算，如果出现大面积的空数据，则不计算ATR</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">close</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">ATR</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span> <span class="o">=</span> <span class="n">talib</span><span class="o">.</span><span class="n">ATR</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">high</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">low</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">close</span><span class="p">,</span> <span class="n">timeperiod</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">TodayBar</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">Window</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">ATR</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">])</span>
            <span class="c1"># 布林带计算</span>
            <span class="n">g</span><span class="o">.</span><span class="n">MidLine</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">close</span><span class="p">[</span><span class="o">-</span><span class="n">g</span><span class="o">.</span><span class="n">Window</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">TodayBar</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]:]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">g</span><span class="o">.</span><span class="n">BollUp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">MidLine</span>   <span class="n">g</span><span class="o">.</span><span class="n">offset</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">ATR</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span>
            <span class="n">g</span><span class="o">.</span><span class="n">BollDown</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">MidLine</span> <span class="o">-</span> <span class="n">g</span><span class="o">.</span><span class="n">offset</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">ATR</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span>


            <span class="c1"># 交易信号计算</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">close</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">g</span><span class="o">.</span><span class="n">BollUp</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">Cross</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">close</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">g</span><span class="o">.</span><span class="n">BollDown</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">Cross</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">Cross</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1">#判断交易信号：布林带突破 可二次入场条件成立</span>
            <span class="k">if</span>  <span class="n">g</span><span class="o">.</span><span class="n">Cross</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">Reentry_long</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">Signal</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">Cross</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">Reentry_short</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">Signal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">Signal</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># 执行交易</span>
            <span class="n">Trade</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="n">RealFuture</span><span class="p">,</span><span class="n">IndexFuture</span><span class="p">)</span>
            <span class="c1"># 运行防止充入模块</span>
            <span class="n">Dont_Re_entry</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="n">IndexFuture</span><span class="p">,</span><span class="n">ins</span><span class="p">)</span>
            <span class="c1"># 计数器 1</span>
            <span class="n">g</span><span class="o">.</span><span class="n">Times</span><span class="p">[</span><span class="n">IndexFuture</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">1</span></code></pre></div><p>需要注意的是，我们肯定要在模型中放入止损逻辑，也肯定要放入止损后的防止重入逻辑，这两部分大家应该都熟悉了。</p><p>还有一个重点变量计算：TodayBar，它可以帮助我们获取每天的bar数量，以此来得到均线的参数，ATR的参数。</p><div class="highlight"><pre><code class="language-text"># 吊灯止损模块
def TrailingStop(context,RealFuture,IndexFuture):

    # 仓位状态
    long_positions = context.portfolio.long_positions
    short_positions = context.portfolio.short_positions
    # 多头进场后最高价 空头进场后最低价
    g.HighPrice[IndexFuture] = max(g.HighPrice[IndexFuture],g.close[-1])
    g.LowPrice[IndexFuture] = min(g.LowPrice[IndexFuture],g.close[-1])

    if RealFuture in long_positions.keys():
        if long_positions[RealFuture].total_amount &gt; 0:
            if g.HighPrice[IndexFuture]:
                if g.close[-1]  &lt; g.HighPrice[IndexFuture]  - g.NATRstop*g.ATR[IndexFuture]:
                    log.info(&#39;多头止损:\t&#39;    RealFuture)
                    order_target(RealFuture,0,side = &#39;long&#39;)
                    g.Reentry_long = True

    if RealFuture in short_positions.keys():
        if short_positions[RealFuture].total_amount &gt; 0:
            if g.LowPrice[IndexFuture]:
                if g.close[-1]  &gt; g.LowPrice[IndexFuture]   g.NATRstop*g.ATR[IndexFuture]:
                    log.info(&#39;空头止损:\t&#39;   RealFuture)
                    order_target(RealFuture,0,side = &#39;short&#39;)
                    g.Reentry_short = True</code></pre></div><p>还有就是移仓换月，我在比较早的帖子里已经写了它的逻辑，大家可以通过源码理解，其实不难，但是刚开始写确实有难度，<b>好在以后聚宽会把这部分做成官方函数</b>，各位就不用费心思写了。</p><p><b>二、数据重构——分钟线拼接为半日线</b></p><p>数据重构是量化交易中的重要工作，我觉得有这样几个原因：</p><p><b>1、</b>大部分交易者在关键时间点上发单，会产生交易拥挤。<br/><b>2、</b>很多K线并不是我们想要的长度，因为其时间含金量不同。比如夜盘从21点到某些品种的凌晨2点半，交易清淡，但是依然占据等时间划分的K线并不科学。<br/><b>3、</b>除了改变时间颗粒度之外，还可以通过成交量、波动率等方法，重构K线，带来非常意外的超额收益。</p><p>这些功能，基本上是传统的期货软件不具备的，它们都需要使用更精密地编程语言完成，python就是这样一个工具，这里有它的价值，也是我们和身边很多朋友都要转移到python平台上开发交易策略的原因。</p><p>我们可以在【研究】平台打印出某品种的15分钟K线看看效果：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-f53b2626f0db984ccc2912b976ede15d_b.jpg" data-caption="" data-size="normal" data-rawwidth="958" data-rawheight="551" class="origin_image zh-lightbox-thumb" width="958" data-original="https://pic2.zhimg.com/v2-f53b2626f0db984ccc2912b976ede15d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-f53b2626f0db984ccc2912b976ede15d_b.jpg" data-caption="" data-size="normal" data-rawwidth="958" data-rawheight="551" class="origin_image zh-lightbox-thumb lazy" width="958" data-original="https://pic2.zhimg.com/v2-f53b2626f0db984ccc2912b976ede15d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-f53b2626f0db984ccc2912b976ede15d_b.jpg"/></figure><p>之后我们和聚宽技术客服沟通了解到：<b>使用get_bars函数能够更好地获取到每天都是9点开始的数据</b>，这样使用较大粒度的K线，如1小时线，也可以完成拼接，且效率更高。</p><p>这套模型中，我们首先在DataPrepare函数中，读取了15分钟K线，每次取50个样本进入之后要介绍的ArrayManager模块。</p><div class="highlight"><pre><code class="language-text">g.LastPrice[IndexFuture] = attribute_history(IndexFuture,50, unit=&#39;15m&#39;,fields = [&#39;close&#39;,&#39;open&#39;,&#39;high&#39;,&#39;low&#39;])</code></pre></div><p><b>然后构建了ArrayManager</b>，该模块用于拼接K线的类，该策略基于不均匀的K线完成，在固定时间输出bar（日内，如早盘收盘时）。而当前平台未推出该功能，因而自定义ArrayManager类来实现，完整代码在模型中可看到。</p><div class="highlight"><pre><code class="language-text">class ArrayManager(object):

    # 初始化函数，设定基准等等
    def __init__(self, size=100):
        # 设定Array的缓存大小
        self.size = size  

        # 基本指标与基本指标的Array字典初始化（用于K线按收盘时间分割）
        # 在这里VarArrays指的是全新K线的数据，以字典的形式存放，Vars是更新K线前的缓存
        self.Vars = {&#39;close&#39;:False,
                    &#39;open&#39;:False,
                    &#39;high&#39;:False,
                    &#39;low&#39;:False}

        self.VarsArrays = {&#39;close&#39;:np.zeros(size),
                          &#39;open&#39;:np.zeros(size),
                          &#39;high&#39;:np.zeros(size),
                          &#39;low&#39;:np.zeros(size)}

    # 更新Array，形成新的bar数据，后续指标等都是基于该Array进行计算    
    def updateBarArray(self):
        for var in self.VarsArrays.keys():
            self.VarsArrays[var][0:self.size-1] = self.VarsArrays[var][1:self.size]
            self.VarsArrays[var][-1] = self.Vars[var]</code></pre></div><p>在拼接数据前，我们做了一个小的识别，看数据是有有夜盘，<b>有夜盘的品种我们可以定todaybar=3，没有夜盘的品种，我们定todaybar=2。</b>该变量用于在模型里帮助计算参数。这部分逻辑放在before_market_open函数中。g.TodayBar[IndexFuture]作为全局变量在模型里传递。</p><div class="highlight"><pre><code class="language-text"># 以下逻辑判断该品种是否有夜盘，并计算TodayBar
        g.Data[IndexFuture] = attribute_history(IndexFuture,120, unit=&#39;60m&#39;,fields = [&#39;close&#39;])
        HourList = [x.strftime(&#39;%H&#39;) for x in g.Data[IndexFuture].index[:]]
        if &#39;21&#39; in HourList: 
            g.TodayBar[IndexFuture] = 3
        else:
            g.TodayBar[IndexFuture] = 2</code></pre></div><p>然后就是在DataPrepare函数中，拼接数据：</p><div class="highlight"><pre><code class="language-text"># 如果当前时间在该品种实际交易时间内（基于15分钟bar），则执行拼接
            if str(context.current_dt.time()) in [x.strftime(&#39;%H:%M:%S&#39;) for x in g.LastPrice[IndexFuture].index[:]]:
                # 初始化
                if IndexFuture not in g.AM.keys():
                    g.AM[IndexFuture] = ArrayManager()
                    g.AM[IndexFuture].updateBar(g.LastPrice[IndexFuture][&#39;close&#39;][-1],
                                            g.LastPrice[IndexFuture][&#39;high&#39;][-1],
                                            g.LastPrice[IndexFuture][&#39;low&#39;][-1],
                                            g.LastPrice[IndexFuture][&#39;open&#39;][-1])
                else:
                    # 收盘时间时输出新Bar
                    if g.LastPrice[IndexFuture].index[-1].strftime(&#39;%H%M&#39;) in g.CloseMarket :
                        # 没有夜盘的品种在9点15分不输出新Bar
                        if g.TodayBar[IndexFuture] == 2 and g.LastPrice[IndexFuture].index[-1].strftime(&#39;%H%M&#39;) == &#39;0915&#39;:
                            pass
                        else:
                    ......</code></pre></div><p>这部分的关键语句就是g.LastPrice[IndexFuture].index[-1].strftime(&#39;%H%M&#39;) in g.CloseMarket : 数据开始切分，g.CloseMarket被我们定义为[&#39;0915&#39;,&#39;1130&#39;,&#39;1500&#39;]，在这3个时间点上，模型通过updateBarArray产生新的拼接完毕后的K线。每次拼接完毕后，要执行数据删除clear函数。</p><p>updateBar函数用于更新数据，这里不用更新open数据，因为一个重构后的K线的open等于最初传入的open。close数据始终更新，因为要取到最后切分那一刻之前的close。最高和最低价，自然要寻找这段时间的最高最低点了，所以进行max和min比较方法。</p><p>模型中其他逻辑都比较简单易懂，所以搞懂此部分，基本上就能完成计算所需的数据支撑。下面我们进行参数组合测试，发现全过程表现较优质的参数。因为数据拼接涉及到IO量大，计算速度较慢，所以我建议从2014年测试，且如果你想要得到一个完整、可信度高的参数表现，要和之前测试动量模型一样，测试大约25个以上的品种。</p><p><b>三、绩效测试</b></p><p>今天的文章仅演示6个品种。多组资金曲线的回测，是通过【研究】调用【回测】得到的，具体过程在这里讲过：</p><a href="https://link.zhihu.com/?target=https%3A//www.joinquant.com/post/4351%3Ftag%3Dalgorithm" data-draft-node="block" data-draft-type="link-card" class=" wrap external" target="_blank" rel="nofollow noreferrer">【量化课堂】多回测运行和参数分析框架 - JoinQuant量化课堂 - JoinQuant</a><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-44af69b948bf82baea28cd8aa56504bd_b.jpg" data-caption="" data-size="normal" data-rawwidth="1122" data-rawheight="469" class="origin_image zh-lightbox-thumb" width="1122" data-original="https://pic2.zhimg.com/v2-44af69b948bf82baea28cd8aa56504bd_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-44af69b948bf82baea28cd8aa56504bd_b.jpg" data-caption="" data-size="normal" data-rawwidth="1122" data-rawheight="469" class="origin_image zh-lightbox-thumb lazy" width="1122" data-original="https://pic2.zhimg.com/v2-44af69b948bf82baea28cd8aa56504bd_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-44af69b948bf82baea28cd8aa56504bd_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-3f6e37c86a715b96bfea808d19034b60_b.jpg" data-caption="" data-size="normal" data-rawwidth="1241" data-rawheight="489" class="origin_image zh-lightbox-thumb" width="1241" data-original="https://pic1.zhimg.com/v2-3f6e37c86a715b96bfea808d19034b60_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-3f6e37c86a715b96bfea808d19034b60_b.jpg" data-caption="" data-size="normal" data-rawwidth="1241" data-rawheight="489" class="origin_image zh-lightbox-thumb lazy" width="1241" data-original="https://pic1.zhimg.com/v2-3f6e37c86a715b96bfea808d19034b60_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-3f6e37c86a715b96bfea808d19034b60_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-b99bf2efd92698bfa68ff03fb7b20d00_b.jpg" data-caption="" data-size="normal" data-rawwidth="1194" data-rawheight="429" class="origin_image zh-lightbox-thumb" width="1194" data-original="https://pic1.zhimg.com/v2-b99bf2efd92698bfa68ff03fb7b20d00_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-b99bf2efd92698bfa68ff03fb7b20d00_b.jpg" data-caption="" data-size="normal" data-rawwidth="1194" data-rawheight="429" class="origin_image zh-lightbox-thumb lazy" width="1194" data-original="https://pic1.zhimg.com/v2-b99bf2efd92698bfa68ff03fb7b20d00_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-b99bf2efd92698bfa68ff03fb7b20d00_b.jpg"/></figure><p>多组（参数）绩效如上图所示。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-0d8d7130f788f8cdf1cf0be8d2700f1c_b.jpg" data-caption="" data-size="normal" data-rawwidth="853" data-rawheight="361" class="origin_image zh-lightbox-thumb" width="853" data-original="https://pic1.zhimg.com/v2-0d8d7130f788f8cdf1cf0be8d2700f1c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-0d8d7130f788f8cdf1cf0be8d2700f1c_b.jpg" data-caption="" data-size="normal" data-rawwidth="853" data-rawheight="361" class="origin_image zh-lightbox-thumb lazy" width="853" data-original="https://pic1.zhimg.com/v2-0d8d7130f788f8cdf1cf0be8d2700f1c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-0d8d7130f788f8cdf1cf0be8d2700f1c_b.jpg"/></figure><p>单组绩效如上图所示。</p><p>对于每个期货模型，<b>因为很强的动量效应存在，结果都是比较理想的</b>。但是其中也不免一些参数由于设置不合理，导致性能偏低。还是建议大家在品种数量更多的环境下，且最好能够分离训练集和测试集，找到合适的实盘参数。</p><p>我们将全部源码放在<a href="https://link.zhihu.com/?target=https%3A//www.joinquant.com/post/16022" class=" wrap external" target="_blank" rel="nofollow noreferrer">原文链接</a>部分，需要的朋友们可以点击获取。</p>