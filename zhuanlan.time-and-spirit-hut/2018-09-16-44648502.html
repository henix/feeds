<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>「Rust每日新闻」本周精选 • 第十一期</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/44648502">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-10c6913d0bc44f08fed6d57e31af7e30_r.jpg" alt=""></div><blockquote>前言：<br>从2018年开始，我每天会花1个小时关注Rust社区动态，并且在<a href="https://link.zhihu.com/?target=http%3A//rust.cc">http://rust.cc</a>论坛、<a href="https://link.zhihu.com/?target=https%3A//t.me/rust_daily_news">tg channel</a>、<a href="https://link.zhihu.com/?target=https%3A//steemit.com/%40blackanger">Steemit</a>、GitHub都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。今天突然想到，在这个知乎专栏里，每周精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。<br><i>2018-09-16</i></blockquote><h2><b>官方新闻</b></h2><p><b>Rust 1.29 稳定版发布</b></p><p>这次是一个小版本发布，在1.30和1.31版本中会有更多更新内容。该版本中重要的更新是cargo fix和cargo clippy，而非语言特性。</p><p>[原文](<a href="https://blog.rust-lang.org/2018/09/13/Rust-1.29.html">The Rust Programming Language Blog</a>)</p><p><b>【重要】涨潮了： 建立开放的模块化Web框架Tide</b></p><p>网络服务工作组今年的目标是改进网络开发：通过建立Tide（潮汐）框架，来改进基于async/await网络相关crate的生态系统。之所以取名为Tide（潮汐），意指“涨潮使得所有的船都得以上升”，也就是中国的那句成语，水涨船高。（开个玩笑，withoutboat怎么办？）总目标是提升Rust中所有web开发和框架之间的共享、兼容和改进。</p><p>Tide的愿景：</p><ul><li>加强提供核心网络功能中充当「体力活」的crate，要确定并改进、标准化一批像http、url这样的基础库。</li><li>在这些基础库之上构建一个严肃的框架。理想情况下，只要可行就使用现成的crate，如果不合适，就自己创造一些小的、独立的crate。</li></ul><p>这些均会记录到Tide的书中。并且这些工作都将是开放的，本篇文章就是这一系列的第一篇博文，如果你想参与这项工作的任何方面，请访问Discord上的WG-net-web频道！</p><p>初始主题：</p><p>基础服务API。</p><p>大多数语言生态系统最终都有一个关键的界面来讨论Web服务：Ruby有Rack，Python有WSGI，Java有Servlets等等。拥有这样的接口意味着你可以从底层Web服务器中分离Web框架。还可以提供可用于任何服务器和框架的通用底层中间件。现在tower-web已经开始这部分工作。简而言之，这种Service trait建模是通用的。</p><p>但当前的问题是：</p><ol><li>Service trait建模是在async/await之前设计的，可能需要一些更改。</li><li>还需要标准化HTTP处理，可以参考tower-web中的BufStream参与讨论。总的来说，Tide就是打算在这些现有抽象的基础上来实现标准化和改进。</li></ol><p>路由策略。</p><p>当前路由策略一共有三种：</p><ol><li>Endpoint-centric 路由。是Rocket和tower-web的方式。就是利用属性，比如#[get("/")]，将对应函数设置为endpoint。</li><li>Table-of-contents路由，是Gotham, Rouille, 和 Actix Web采用的方式。<br>比如</li></ol><code lang="rust">route.request(vec![Get, Head], "/").to(index);
        route.get_or_head("/products").to(products::index);
        route.get("/bag").to(bag::index);</code><p>这种方式有助于处理多个endpoint的问题，但是它比前一种策略更重一些，并且从请求信息中提取信息可能没那么灵活。</p><ol><li>自由格式组合的路由</li></ol><p>就是Wrap采用的方式。在某种程度上，也可以称为无路由方法。endpoint和应用中其他函数没有什么区别。一切皆filter，你可以通过组合filter来构建你的服务。</p><code lang="rust">// Just the path segment "todos"...
let todos = warp::path("todos");

// Combined with `index`, this means nothing comes after "todos".
// So, for example: `GET /todos`, but not `GET /todos/32`.
let todos_index = todos.and(warp::path::index());

// `GET /todos`
let list = warp::get2()
    .and(todos_index)
    .and(db.clone())
    .map(list_todos);

// `POST /todos`
let create = warp::post2()
    .and(todos_index)
    .and(warp::body::json())
    .and(db.clone())
    .and_then(create_todo);

// Combine our endpoints, since we want requests to match any of them:
let api = list
    .or(create);

// View access logs by setting `RUST_LOG=todos`.
let routes = api.with(warp::log("todos"));</code><p>现在谈这种方式的优缺点还有点早，所以这里没谈。（无关个人喜好）</p><p>Tide中的路由是什么方式？</p><p>Tide倾向于 Table-of-contents路由，因为它比endpoint-centric路由更容易模块化和扩展，比自由式路由更容易理解。</p><p>在下一篇文章中，将深入研究Rust中的 Table-of-contents式路由中出现的一些API设计问题，并研究模块化和共享的途径。</p><p>（小声BB： 预计2019年Rust在Web领域的应用将爆发。。。）</p><p><a href="https://rust-lang-nursery.github.io/wg-net/2018/09/11/tide.html">原文</a></p><p><b>嵌入式工作组报告 11</b></p><p>简要：</p><ul><li>rustc现在支持4个Cortex-R编译目标，现在只需要使用rust-toolchain就行</li><li>James Munns在RustConf 2018上发表了演讲，内容涉及嵌入式系统的基础知识，以及Rust的Zero Cost Abstractions如何与裸机系统完美匹配的嵌入式项目</li><li>atsamd21-rs现在已经支持Arduino MKRZERO开发板</li><li><a href="https://branan.github.io/teensy/">Exploring Rust on Teensy系列文章</a> 第四章正在构思，该系列将专注于使用futures-rs来表示DMA传输</li></ul><p>更多内容请查看原文</p><p><a href="https://rust-embedded.github.io/blog/2018-09-09-newsletter-11/">原文</a></p><p><b>WebRender将开始在部分Firefox Nightly用户上启用</b></p><p>WebRender是一个基于GPU的实验性网页内容渲染器，用Rust编写。现在默认为桌面Windows 10 w / Nvidia GPU上的用户启用。</p><p><a href="https://www.reddit.com/r/rust/comments/9fhxz2/webrender_an_experimental_gpubased_renderer_for/">原文</a></p><p><b>澄清wasm-bindgen 和 stdweb关系</b></p><p>对wasm-bindgen 和 stdweb关系迷惑的朋友可以看看官方的回答</p><p><a href="https://github.com/rustwasm/team/issues/226#issuecomment-417801729">原文</a></p><p><b>niko开启「Rust预约咨询」</b></p><p>Rust核心团队领导者Niko开启了在办公时间段内的「Rust预约咨询」服务，旨在为初学者答疑解惑。</p><p>详情参考下面链接。</p><p><a href="http://smallcultfollowing.com/babysteps/blog/2018/09/12/rust-office-hours/">原文</a></p><p><b>网络工作组报告 1</b></p><p>过去的六周，网络工作组做了些什么？</p><ul><li>WG-Net 愿景发布</li><li>Tide框架构建开启</li><li>Futures 0.3-alpha-4 现在可用</li><li>在考虑Pin API？<a href="https://boats.gitlab.io/blog/post/rethinking-pin/">Pin Api</a></li><li>tower-web 相关</li><li><a href="https://github.com/rust-lang-nursery/wg-net/blob/master/meetings/2018-08-31-net-wg-leads.md">会议记录</a></li></ul><p><a href="https://internals.rust-lang.org/t/the-networking-working-group-newsletter-01/8391">原文</a></p><hr><h2><b>社区新闻</b></h2><p><b>RustConf 2018闭幕演讲文稿</b></p><p>该演讲嘉宾是Starbound的首席程序员，Chucklefish的技术主管，专注游戏开发。</p><p>他认为Rust非常适合做面向数据（data-oriented）的设计，因此非常适合做游戏开发，而且不仅仅是游戏开发。在可以预计的未来，他将继续使用Rust进行游戏开发。</p><p>本文介绍了游戏开发中使用Rust进行OO设计的各种弊端，并且通过示例逐渐给出了ECS架构的思想。</p><p>文章很长，耐心阅读。</p><p><a href="https://kyren.github.io/2018/09/14/rustconf-talk.html">原文</a></p><p><b>StackoverFlow已经累计了超过1万个Rust相关问题</b></p><p><a href="https://stackoverflow.com/questions/tagged/rust">原文</a></p><p><b>【重要】如何组织复杂的Rust代码库</b></p><p>这篇文章是Flare开发者在构建Flare这个复杂软件过程中，思考的一些Rust代码库相关的细节。</p><ul><li>使用JetBrains CLion开发Rust</li><li>目前是使用Nightly版本，但指定了edition = 2018，但目标是等待stable Rust 2018。虽然目前使用了一些unstable 特性，但是越来越少了，Rust 2018版本对他们来说，已经非常适合使用。</li><li>依赖库。 可以到<a href="http://docs.getseq.net/v5.0/docs/acknowledgements">这里</a>找到他们使用的依赖库。比较出名的有failure、serde、lazy_static、libc、rand等。</li><li>源码组织。 遵循Rust的传统，将项目构建为单独的crate。文章中包含了相关模块介绍。</li><li>管理unsafe代码。 它们在项目根模块添加了#![deny(unsafe_code)] ，但是自己实现了一个unsafe_block!宏：</li></ul><code lang="rust">macro_rules! unsafe_block {  
    ($reason:tt =&gt; $body:expr) =&gt; {{
        #[allow(unsafe_code)]
        let r = unsafe { $body };
        r
    }};
}</code><ul><li>在编写unsafe代码的时候使用这个宏，这就使得不安全的代码更具有审计性，达到了统一管理的目的。这个实践很棒。</li><li>管理cross-cutting concerns代码。 cross-cutting concerns来自于AOP的一个术语，叫横切关注点。这里其实是指那些在代码中复用的一些「工具类」函数或类型。代码越复杂，这种东西就会越多，需要好好管理它们。文章作者使用std_ext模块来统一管理这些「工具」</li><li>开发中可能会经常为结构体中增加新字段来解决一些问题，但有时候新加的字段，在一些方法里并没有被使用。所以 利用#![deny(unused_variables)]属性来限制结构体，如果出现这种在方法里没有被使用的字段，则会报错。从而提醒开发者，仔细考虑这个需求。</li><li>还有很多值得探索的地方; 包括与.NET互操作，跨平台打包，测试和模糊测试。</li></ul><p>看得出来，Rust语言本身为开发大型复杂应用提供了很多工具。</p><p>期待后续文章。</p><p><a href="https://blog.getseq.net/rust-at-datalust-how-we-organize-a-complex-rust-codebase/">原文</a></p><p><b>你不能在Rust中关闭借用检查</b></p><p>官方steveklabnik写文章来驳斥社区中「unsafe代码可以关闭借用检查器」这种说法，并给予了详细的解释。</p><p><a href="https://words.steveklabnik.com/you-can-t-turn-off-the-borrow-checker-in-rust">原文</a></p><p><b>两篇 ： 一场由逻辑漏洞引发的「血案」</b></p><ul><li><a href="https://zhuanlan.zhihu.com/p/44499068">原文</a></li><li><a href="https://zhuanlan.zhihu.com/p/44639109">后续</a></li></ul><p><b>Miniserde发布</b></p><p>Serde作者发布了新的Miniserde库，这个新库和Serde在设计目标上是不同的</p><ul><li>最小化设计，不像serde那样适用范围更广泛，只限JSON、仅限结构体、不能定制</li><li>只序列化String，确保序列化总是成功。</li><li>没有单态、没有递归、没有反序列化失败的错误消息。</li></ul><p>在一些不需要serde那么复杂的场景之下，也许miniserde更有用</p><p><a href="https://github.com/dtolnay/miniserde">miniserde</a></p><p><b>gtk-rs新版本发布</b></p><p>添加了futures和异步处理函数</p><ul><li>gio_futures</li><li>gio_features_await</li></ul><p><a href="http://gtk-rs.org/blog/2018/09/09/new-release.html">原文</a></p><p><b>「论文」优化编译器的未来方向</b></p><p>这个问题确实需要考虑了</p><p><a href="https://arxiv.org/pdf/1809.02161.pdf">PDF</a></p><p><b>Rust源码分析：crossbeam之ms_queue(1)</b></p><p>crossbeam源码分析系列文章。</p><p>crossbeam是官方核心成语Aaron编写的并发库，提供了mpmc channel、scoped thread、并发数据结构、扩展了标准库的原子类型、以及其他的一些工具。</p><p>文章里介绍的是crossbeam库中Michael-Scott非阻塞队列(lock-free)算法的Rust实现，MS-queue算法主要依赖于CAS原子操作。</p><p><a href="https://zhuanlan.zhihu.com/p/44104743">原文</a></p><p><b>Rust和JS交互</b></p><p>该文主要是探讨wasm-bindgen的用法，看看数字（因为wasm只能理解数字类型）和字符串类型如何转换，并且会介绍wasm-bindgen内部结构。推荐阅读。</p><p><a href="https://blog.ryanlevick.com/posts/wasm-bindgen-interop/">原文</a></p><p><b>Vulkan刚刚成为世界上第一个具有正式内存模型的图形API</b></p><p>本周，Vulkan®已成为世界上第一个为其相关GLSL™和SPIR-V™编程语言提供正式内存模型的图形API。使Vulkan开发人员能够更好地控制着色器如何在并行执行环境中同步访问内存.</p><p>那估计gfx-rs也要马上跟进了吧</p><p><a href="https://www.khronos.org/blog/vulkan-has-just-become-the-worlds-first-graphics-api-with-a-formal-memory-model.-so-what-is-a-memory-model-and-why-should-i-care">原文</a></p><p><b>indexlist: 基于Vector的双向链表</b></p><p>这是steveklabnik发布的一个新的crate，使用了分代索引模式（RustConf闭幕演讲中介绍过）基于Vector来建立链表，确保引用的正确性。并且是100% Safe Rust。</p><p>这种方式可以避免循环引用。</p><ul><li><a href="https://users.rust-lang.org/t/indexlist-a-doubly-linked-list-backed-by-a-vector/20434">原文</a></li><li><a href="https://github.com/steveklabnik/indexlist/">indexlist</a></li></ul><p>但是和这个库比怎么样呢？ <a href="https://github.com/fitzgen/generational-arena">generational-arena</a></p><p>该库Readme中罗列的ABA问题，indexlist是否避免了呢？</p><p><b>Julia挑战赛</b></p><p>作者希望Rust也参与，大家踊跃应战吧！</p><p><a href="https://nextjournal.com/sdanisch/the-julia-challenge">原文</a></p><p><b>Ripgrep 现在ubuntu上可用</b></p><p><a href="https://github.com/BurntSushi/ripgrep/pull/1054">原文</a></p><hr><h2><b>博文与库</b></h2><p><b>到底什么是系统编程？</b></p><p>作者思考的这个问题，正好也是我疑惑的。</p><p>一般来说，系统编程包含两个概念：</p><ul><li>底层编程，用于处理机器的各种细节</li><li>系统设计，创建和管理复杂的各种组件</li></ul><p>作者回顾从计算机起源对系统编程的定义进行了回顾：</p><p>系统编程这个词起源于20世纪70年代，在《系统编程语言》（Bergeron1 et al.1972）中作者说：“系统程序是一组集成的子程序，它们一起构成一个大于其各部分之和的整体，并超过一些大小和/或复杂度的阈值。。。”，该定义的一个关键思想是：倡导将底层语言与系统语言分离。这个阶段认为系统应该是为用户服务。</p><p>20世纪90年代中期，随着动态类型脚本语言的兴起，编程语言发生了重大的变化。Perl、Python、Ruby等，于是就有了高级语言和系统编程语言的二分法（Ousterhout 1998），系统编程用于创建组件，脚本用于将它们粘合在一起。也就是这个时候，静态类型和垃圾回收语言也开始兴起，Java和C#，虽然它们被认为不是传统的系统编程语言，但是Ousterhout中提到：“在正在形成的互联网中，Java被用于系统编程”</p><p>2010年开始，这个边界变得模糊了起来。Dropbox用Python也构建了大型的可扩展系统，JS也逐渐成为主流，可以构建复杂的UI系统，并且JIT编译器也开始流行，使得脚本语言也可以和传统系统编程语言拼一下性能。Julia、Swift和Go这样的新的编程语言也在推进垃圾回收语言的性能边界。</p><p>Bjarne Stroustrup（C ++的创建者），Rob Pike（Go的创建者），Andrei Alexandrescu（D开发人员），和Niko Matsakis（Rust开发人员）。当被问及“2014年什么是系统编程语言”时，他们说（编辑转录）：</p><ul><li>Niko Matsakis：具有高延迟需求，高安全性要求，以及服务器端的各种需求。</li><li>Bjarne Stroustrup：系统编程出自你必须处理硬件的领域，然后应用程序变得更加复杂。你需要处理复杂性。如果您遇到任何重大资源限制问题，那么您就处于系统编程领域。如果您需要更精细的控制，那么您也在系统编程领域。决定它是否是系统编程的是约束。你的内存不足吗？你没时间了吗？</li><li>Rob Pike：当我们第一次宣布Go时，我们称它为系统编程语言，我有点遗憾，因为很多人认为它是一种编写操作系统的语言。我们应该称它为服务器端语言，现在我明白我们拥有的是云基础架构语言。系统编程的另一个定义是在云中运行的东西。</li><li>Andrei Alexandrescu：我有一些试金石用于检查某些东西是否是系统编程语言。系统编程语言必须能够允许您在其中编写自己的内存分配器。你应该能够将一个数字伪造成一个指针，因为这就是硬件的工作原理。</li></ul><p>那么系统编程是关于高性能的吗？资源限制？硬件控制？云基础架构？从广义上讲，似乎C，C ++，Rust和D类别中的语言在它们与机器的抽象级别方面有所区别。这些语言公开了底层硬件的细节，如内存分配/布局和细粒度资源管理。</p><p>Rust语言特点是将好的软件设计和工程性原则应用于底层的编程，这方面极具创新性。</p><p>所以到底什么是系统编程语言？</p><p>作者认为，系统编程语言应该是特指底层编程语言，因为系统设计的领域太广，它不能有自己的命名，将这两个概念分清楚比较好。</p><p><a href="http://willcrichton.net/notes/systems-programming/">原文</a></p><p><b>Iridium是指用Rust编写的语言VM</b></p><p>感兴趣可以了解下，原文里包含了一系列如何使用Rust构建语言虚拟机的教程</p><p><a href="https://blog.subnetzero.io/project/iridium-vm/">iridium-vm</a></p><p><b>Rust关联类型</b></p><p>本文比较了泛型和关联类型，帮助你更好的理解关联类型</p><p><a href="https://medium.com/codechain/rust-associated-type-2281dbf98229">原文</a></p><p><b>用Rust写OS内核正在编写第二版</b></p><p><a href="https://os.phil-opp.com/">原文</a></p><p><a href="https://github.com/phil-opp/blog_os">blog_os</a></p><p><a href="https://hackaday.com/2018/09/08/pun-intended-bare-metal-attracts-rust/">原文</a></p><p><b>mdproof： markdown转换到PDF</b></p><p><a href="https://github.com/Geemili/mdproof">mdproof</a></p><p><b>可以作为wasm模块使用的编程语言P64Lang</b></p><p>完全用Rust实现，基于nom，支持no_std 。 这个厉害了。</p><p><a href="https://www.polaris64.net/resources/programming/p64lang_wasm/">demo </a></p><p><a href="https://github.com/polaris64/p64lang_rust">p65lang_rust</a></p><p><b>cryptostream：读写流适配器，用于即时加密和解密</b></p><p>该库是模拟.NET Cryptostream类的Rust实现，基于rust-openssl，完全可配置。</p><p><a href="https://github.com/neosmart/cryptostream">cryptostream</a></p><p><a href="https://neosmart.net/blog/2018/transparent-encryption-and-decryption-in-rust-with-cryptostreams/">介绍博客</a></p><p><b>使用Rust开发桌面应用</b></p><p>作者探讨了基于wasm实现桌面应用的可能性。作者不太喜欢js和Electron。但是探索下来，发现Rust目前工具链还不太稳定，所以他建议目前暂时使用Electron和wasm。</p><p>但是在使用Rust+Electron+wasm之前，他认为目前还有一些工作需要做：</p><ul><li>webpack还需要完善（#7983）</li><li>浏览器API库确定可以支持Electron。这需要web-sys和std-web之类的库支持。</li><li>std-web和percy将来会转向web-sys库，这工作量不小</li><li>wasm-bindgen很棒，但还需要点时间稳定</li></ul><p>在这一切条件成熟以后，未来作者可能会出一个模板项目。</p><ul><li><a href="https://speice.io/2018/09/isomorphic-apps.html">原文</a></li><li><a href="https://github.com/bspeice/isomorphic_rust">作者折腾的源码isomorphic_rust</a></li></ul><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
