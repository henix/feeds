<p>在上一篇文章<a href="https://zhuanlan.zhihu.com/p/70609434" class="internal">parker liu：从单位半群到单子</a> 中，已经给大家详细介绍了如何从单位半群一步步得到单子。但单子是如何构造出来的呢，即如何从类型得到单位半群，从函子得到单子呢？在这篇文章中，我将给大家介绍最一般的单位半群和单子的构造方式，即单位半群和单子的自由构造。</p><p>我们知道一些具体的单位半群，如自然数、布尔值，那有没有一种方法从一般的类型构造出单位半群呢？答案是有的，这就是单位半群的自由构造。同样的，单子也存在着自由构造。</p><p>我们先来看看单位半群的自由构造是怎么样的。我们知道单位半群有如下的定义：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">class</span> <span class="kt">Monoid</span> <span class="nf">m</span> <span class="kr">where</span>
    <span class="nf">mempty</span>   <span class="ow">::</span> <span class="nf">m</span>                       <span class="o">--^</span> <span class="err">这就是单位元</span> <span class="nf">e</span>
    <span class="nf">mappend</span> <span class="ow">::</span> <span class="nf">m</span> <span class="ow">-&gt;</span> <span class="nf">m</span> <span class="ow">-&gt;</span> <span class="nf">m</span>              <span class="o">--^</span> <span class="err">这就是二元运算</span> <span class="o">*</span></code></pre></div><p>那我们如何来从类型 a 来构造出一个单位半群 m 呢？假装我们是万能的上帝，上帝说要有光，于是就有了光。我们说要有单位半群 m，于是就有了单位半群 m。</p><p>假设下面的List a 就是我们说要有的单位半群：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">List</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Nil</span>
            <span class="o">|</span> <span class="kt">Cons</span> <span class="nf">a</span> <span class="p">(</span><span class="kt">List</span> <span class="nf">a</span><span class="p">)</span>
            <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">type</span> <span class="kt">FreeMon</span> <span class="ow">=</span> <span class="kt">List</span> <span class="nf">a</span></code></pre></div><p>上面的Nil是一个无参数构造子，等价于Unit（也就是()），即Hask这个幺半范畴的单位元i，而Cons则和Hask这个幺半范畴的张量积⊗等价。于是上面的List a的定义相当于定义了一个函子 F x = i + a ⊗ x，其中List a是函子 F x 的不动点，(List a, in)则是F x这个函子构造的 F-Alg 范畴的初始对象。可以证明函子 F x = i + a ⊗ x 的不动点是一个单位半群，于是就有了单位半群List a。</p><p>我们考虑以所有单位半群 m 为对象的由F x构造的 F-Alg 子范畴，因 (List a, in) 是F-Alg 范畴的初始对象，所以必然存在一个唯一的从 (List a, in) 到 (m, fm) 的态射，这个态射也是 List a 到 m 的态射。于是单位半群 List a和单位半群 m 之间存在唯一的态射。</p><p>若我们把单位半群看成一个对象，则单位半群之间存在态射，于是所有单位半群构成了单位半群范畴 <b>Mon</b>。上面的单位半群 List a是这个单位半群范畴 <b>Mon</b>的初始对象，称之为自由单位半群。List a 是函子 F x 的不动点，我们将其展开，即不停的将x = i + a ⊗ x 代入到 i + a ⊗ x 中，得到下面的表达式：</p><p>   List a = i + a ⊗ i + a ⊗ a ⊗ i + a ⊗ a ⊗ a ⊗ i + a ⊗ a ⊗ a ⊗ a ⊗ i + ...</p><p>这样我们就有了从类型 a 到单位半群 List a 的最一般的构造方式，上式就是单位半群上的自由构造。</p><p>对于由自函子构成的幺半范畴，其对象是自函子 F，单位元是自函子 Id，张量积是函子的组合运算 ◦，我们也同样的有从自函子到自函子的幺半范畴上的单位半群（就是自由单子）的最一般的构造方式，自由单子是高阶函子 HF (Free F) = Id + F ◦ Free F 的不动点，是所有单子构成的单子范畴的初始对象，这个自由单子的Haskell代码定义如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Free</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Pure</span> <span class="nf">a</span>
              <span class="o">|</span> <span class="kt">Free</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">))</span></code></pre></div><p>我们可以看到，自由单子和自由单位半群类似，都是形如 F x = i + a ⊗ x 的函子的不动点。因此，自由单子也有类似自由单位半群的展开式：</p><p>    Free F = Id + F ◦ Id + F ◦ F ◦ Id + F ◦ F ◦ F ◦ Id + F ◦ F ◦ F ◦ F ◦ Id + ...</p><p>这就是单子的自由构造。我们使用自由单子的Haskell代码的定义，可以得到更直观的展开式：</p><p>    Free f a = Pure a + Free (f (Pure a)) + Free (f (Free (f (Pure a)))) + ...</p><p>有了单位半群和单子的一般构造方式，我们就可以用来构造自由单位半群和自由单子，再将其求值到具体的特定的单位半群和单子。</p><p>我们先来看单位半群，从任意类型 a 得到的自由单位半群List a定义如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">List</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Nil</span>
            <span class="o">|</span> <span class="kt">Cons</span> <span class="nf">a</span> <span class="p">(</span><span class="kt">List</span> <span class="nf">a</span><span class="p">)</span>
            <span class="kr">deriving</span> <span class="kt">Show</span></code></pre></div><p>这是函子 F x = i + a ⊗ x 的不动点 Fix F，(Fix F, in) 是这个函子构成的 F-Alg 范畴的初始对象，用Haskell表示如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="kt">Alg</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>

<span class="kr">newtype</span> <span class="kt">Fix</span> <span class="nf">f</span>  <span class="ow">=</span> <span class="kt">In</span> <span class="p">{</span> <span class="nf">out</span> <span class="ow">::</span> <span class="nf">f</span> <span class="p">(</span> <span class="kt">Fix</span> <span class="nf">f</span><span class="p">)</span> <span class="p">}</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="kt">Fix</span> <span class="nf">f</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Fix</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">In</span> <span class="nf">fix</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;(In (&#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">fix</span> <span class="o">++</span> <span class="s">&#34;))&#34;</span>

<span class="nf">cata</span> <span class="ow">::</span>  <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="kt">Alg</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Fix</span> <span class="nf">f</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="nf">cata</span> <span class="nf">alg</span>  <span class="ow">=</span> <span class="nf">alg</span> <span class="o">.</span> <span class="nf">map</span> <span class="p">(</span><span class="nf">cata</span> <span class="nf">alg</span><span class="p">)</span> <span class="o">.</span> <span class="nf">out</span>

<span class="kt">ListF</span> <span class="nf">a</span> <span class="nf">x</span> <span class="ow">=</span> <span class="kt">NilF</span>
             <span class="o">|</span> <span class="kt">ConsF</span> <span class="nf">a</span> <span class="nf">x</span>
            <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">ListF</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">fmap</span> <span class="nf">f</span> <span class="kt">NilF</span> <span class="ow">=</span> <span class="kt">NilF</span>
  <span class="nf">fmap</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">ConsF</span> <span class="nf">a</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">ConsF</span> <span class="nf">a</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Fix</span> <span class="p">(</span><span class="kt">ListF</span> <span class="nf">a</span><span class="p">))</span> <span class="kr">where</span>
  <span class="nf">mempty</span> <span class="ow">=</span> <span class="kt">In</span> <span class="kt">NilF</span>
  <span class="p">(</span><span class="kt">In</span> <span class="kt">NilF</span><span class="p">)</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="nf">fixl2</span> <span class="ow">=</span> <span class="nf">fixl2</span>
  <span class="nf">fixl1</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="p">(</span><span class="kt">In</span> <span class="kt">NilF</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">fixl1</span>
  <span class="p">(</span><span class="kt">In</span> <span class="p">(</span><span class="kt">ConsF</span> <span class="nf">a</span> <span class="nf">fixl1</span><span class="p">))</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="nf">fixl2</span> <span class="ow">=</span> <span class="kt">In</span> <span class="p">(</span><span class="kt">ConsF</span> <span class="nf">a</span> <span class="p">(</span><span class="nf">fixl1</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="nf">fixl2</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">List</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">mempty</span> <span class="ow">=</span> <span class="kt">Nil</span>
  <span class="kt">Nil</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="nf">ls2</span> <span class="ow">=</span> <span class="nf">ls2</span>
  <span class="nf">ls1</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="nf">ls1</span>
  <span class="p">(</span><span class="kt">Cons</span> <span class="nf">a</span> <span class="nf">ls1</span><span class="p">)</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="nf">ls2</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="nf">a</span> <span class="p">(</span><span class="nf">ls1</span> <span class="p">`</span><span class="nf">mappend</span><span class="p">`</span> <span class="nf">ls2</span><span class="p">)</span></code></pre></div><p>上面的ListF a就是函子 F x = i + a ⊗ x 的Haskell代码的表示，List a 就是Fix (ListF a)，也就是ListF a的不动点，都是单位半群，也是自由单位半群。我们只要定义一个Alg就可以对List a求值了，例如定义一个计算长度的Alg，就可以得到List a 也就是Fix (ListF a) 的长度了，而定义一个计算和的Alg，就可以得到List Int 也就是Fix (ListF Int) 的和了</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">lengthAlg</span> <span class="ow">::</span> <span class="kt">Alg</span> <span class="p">(</span><span class="kt">ListF</span> <span class="nf">a</span><span class="p">)</span> <span class="kt">Int</span>
<span class="nf">lengthAlg</span> <span class="kt">NilF</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">lengthAlg</span> <span class="p">(</span><span class="kt">ConsF</span> <span class="nf">a</span> <span class="nf">x</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">x</span>

<span class="nf">lengthListF</span> <span class="ow">::</span> <span class="kt">Fix</span> <span class="p">(</span><span class="kt">ListF</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">lengthListF</span> <span class="ow">=</span> <span class="nf">cata</span> <span class="nf">lengthAlg</span>

<span class="nf">sumAlg</span> <span class="ow">::</span> <span class="kt">Alg</span> <span class="p">(</span><span class="kt">ListF</span> <span class="kt">Int</span><span class="p">)</span> <span class="kt">Int</span>
<span class="nf">sumAlg</span> <span class="kt">NilF</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">sumAlg</span> <span class="p">(</span><span class="kt">ConsF</span> <span class="nf">a</span> <span class="nf">l</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">a</span> <span class="o">+</span> <span class="nf">l</span>

<span class="nf">sumListF</span> <span class="ow">::</span> <span class="kt">Fix</span> <span class="p">(</span><span class="kt">ListF</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">sumListF</span> <span class="ow">=</span> <span class="nf">cata</span> <span class="nf">sumAlg</span></code></pre></div><p>接下来我们来看单子的情况，从任意函子 F 得到的自由单子 Free F 定义如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Free</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Pure</span> <span class="nf">a</span>
              <span class="o">|</span> <span class="kt">Free</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">))</span></code></pre></div><p>这也是函子 F x = i + a ⊗ x 的不动点 Fix F，(Fix F, in) 是这个函子构成的 F-Alg 范畴的初始对象。不过这里的函子 F 中的 x 也是一个函子，函子 F 是一个高阶函子，即作用在函子上的函子。对应的F-Alg范畴也是高阶的，Fix F是一个函子，不是一个类型。用Haskell表示如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">infixr</span> <span class="mi">0</span> <span class="kt">:~&gt;</span>
<span class="c1">-- define a natural transformation</span>
<span class="kr">type</span> <span class="nf">f</span> <span class="kt">:~&gt;</span> <span class="nf">g</span> <span class="ow">=</span> <span class="nf">forall</span> <span class="nf">a</span><span class="o">.</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">g</span> <span class="nf">a</span>

<span class="c1">-- define Higher order functor</span>
<span class="kr">class</span> <span class="kt">HFunctor</span> <span class="nf">hf</span> <span class="kr">where</span>
  <span class="nf">hfmap</span> <span class="ow">::</span> <span class="p">(</span><span class="nf">g</span> <span class="kt">:~&gt;</span> <span class="nf">h</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">hf</span> <span class="nf">g</span> <span class="kt">:~&gt;</span> <span class="nf">hf</span> <span class="nf">h</span>
  <span class="nf">ffmap</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">g</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">hf</span> <span class="nf">g</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">hf</span> <span class="nf">g</span> <span class="nf">b</span>

<span class="c1">-- define Higher order F-Alg</span>
<span class="kr">type</span> <span class="kt">HAlg</span> <span class="nf">hf</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">hf</span> <span class="nf">f</span> <span class="kt">:~&gt;</span> <span class="nf">f</span>

<span class="kr">newtype</span> <span class="kt">HFix</span> <span class="nf">hf</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">InH</span> <span class="p">{</span> <span class="nf">outH</span> <span class="ow">::</span> <span class="nf">hf</span> <span class="p">(</span><span class="kt">HFix</span> <span class="nf">hf</span><span class="p">)</span> <span class="nf">a</span> <span class="p">}</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="p">(</span><span class="nf">hf</span> <span class="p">(</span><span class="kt">HFix</span> <span class="nf">hf</span><span class="p">)</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">HFix</span> <span class="nf">hf</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">InH</span> <span class="nf">hfix</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;(InH (&#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">hfix</span> <span class="o">++</span> <span class="s">&#34;))&#34;</span>

<span class="nf">hcata</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">HFunctor</span> <span class="nf">hf</span><span class="p">,</span> <span class="kt">Functor</span> <span class="nf">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">HAlg</span> <span class="nf">hf</span> <span class="nf">f</span> <span class="ow">-&gt;</span> <span class="kt">HFix</span> <span class="nf">hf</span> <span class="kt">:~&gt;</span> <span class="nf">f</span>
<span class="nf">hcata</span> <span class="nf">halg</span> <span class="ow">=</span> <span class="nf">halg</span> <span class="o">.</span> <span class="nf">hfmap</span> <span class="p">(</span><span class="nf">hcata</span> <span class="nf">halg</span><span class="p">)</span> <span class="o">.</span> <span class="nf">outH</span></code></pre></div><p>高阶F-Alg范畴形式的自由单子的定义如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- FList f a is same as Free f a</span>
<span class="kr">data</span> <span class="kt">FList</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">FNil</span> <span class="nf">a</span> <span class="o">|</span> <span class="kt">FCons</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="kt">FList</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">))</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="kt">FList</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)),</span> <span class="kt">Show</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">FList</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">FNil</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;FNil &#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">a</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">FCons</span> <span class="nf">fx</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;Fcons &#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">fx</span>

<span class="kr">data</span> <span class="kt">FListF</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">FNilF</span> <span class="nf">a</span> <span class="o">|</span> <span class="kt">FConsF</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">))</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">)),</span> <span class="kt">Show</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">FListF</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">FNilF</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;FNilF &#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">a</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">FConsF</span> <span class="nf">fga</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;FConsF &#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">fga</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">HFunctor</span> <span class="p">(</span><span class="kt">FListF</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">hfmap</span> <span class="nf">nat</span> <span class="p">(</span><span class="kt">FNilF</span> <span class="nf">a</span><span class="p">)</span>    <span class="ow">=</span> <span class="kt">FNilF</span> <span class="nf">a</span>
  <span class="nf">hfmap</span> <span class="nf">nat</span> <span class="p">(</span><span class="kt">FConsF</span> <span class="nf">fga</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FConsF</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">nat</span> <span class="nf">fga</span><span class="p">)</span>
  <span class="nf">ffmap</span> <span class="nf">k</span> <span class="p">(</span><span class="kt">FNilF</span> <span class="nf">a</span><span class="p">)</span>    <span class="ow">=</span> <span class="kt">FNilF</span> <span class="p">(</span><span class="nf">k</span> <span class="nf">a</span><span class="p">)</span>
  <span class="nf">ffmap</span> <span class="nf">k</span> <span class="p">(</span><span class="kt">FConsF</span> <span class="nf">fga</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FConsF</span> <span class="p">(</span><span class="nf">fmap</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">k</span><span class="p">)</span> <span class="nf">fga</span><span class="p">)</span>

<span class="c1">-- FreeMF f g a is same as FListF f g a</span>
<span class="kr">data</span> <span class="kt">FreeMF</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">PureMF</span> <span class="nf">a</span> <span class="o">|</span> <span class="kt">FreeMF</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">))</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">HFunctor</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">hfmap</span> <span class="nf">nat</span> <span class="p">(</span><span class="kt">PureMF</span> <span class="nf">a</span><span class="p">)</span>   <span class="ow">=</span> <span class="kt">PureMF</span> <span class="nf">a</span>
  <span class="nf">hfmap</span> <span class="nf">nat</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="nf">fga</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FreeMF</span> <span class="o">$</span> <span class="nf">fmap</span> <span class="nf">nat</span> <span class="nf">fga</span>
  <span class="nf">ffmap</span> <span class="nf">f</span>   <span class="p">(</span><span class="kt">PureMF</span> <span class="nf">a</span><span class="p">)</span>   <span class="ow">=</span> <span class="kt">PureMF</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span>
  <span class="nf">ffmap</span> <span class="nf">f</span>   <span class="p">(</span><span class="kt">FreeMF</span> <span class="nf">fga</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FreeMF</span> <span class="o">$</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">f</span><span class="p">)</span> <span class="nf">fga</span>

<span class="c1">-- Free f =  FList f = HFix (FListF f) = HFix (FreeMF f)</span>
<span class="kr">type</span> <span class="kt">FreeMonad</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">HFix</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="nf">f</span><span class="p">)</span>

<span class="nf">liftMF</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">FreeMonad</span> <span class="nf">f</span> <span class="nf">a</span>
<span class="nf">liftMF</span> <span class="ow">=</span> <span class="kt">InH</span> <span class="o">.</span> <span class="kt">FreeMF</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="p">(</span><span class="kt">InH</span> <span class="o">.</span> <span class="kt">PureMF</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">FreeMonad</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">fmap</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">InH</span> <span class="nf">frmf</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">InH</span> <span class="p">(</span><span class="nf">ffmap</span> <span class="nf">f</span> <span class="nf">frmf</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">FreeMonad</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">InH</span> <span class="o">.</span> <span class="kt">PureMF</span>
  <span class="p">(</span><span class="kt">InH</span> <span class="p">(</span><span class="kt">PureMF</span> <span class="nf">f</span><span class="p">))</span>   <span class="o">&lt;*&gt;</span> <span class="nf">fixmf</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">fixmf</span>
  <span class="p">(</span><span class="kt">InH</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="nf">frf</span><span class="p">))</span> <span class="o">&lt;*&gt;</span> <span class="nf">fixmf</span> <span class="ow">=</span> <span class="kt">InH</span> <span class="o">.</span> <span class="kt">FreeMF</span> <span class="o">$</span> <span class="nf">fmap</span> <span class="p">(</span><span class="o">&lt;*&gt;</span> <span class="nf">fixmf</span><span class="p">)</span> <span class="nf">frf</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">FreeMonad</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">return</span> <span class="ow">=</span> <span class="kt">InH</span> <span class="o">.</span> <span class="kt">PureMF</span>
  <span class="p">(</span><span class="kt">InH</span> <span class="p">(</span><span class="kt">PureMF</span> <span class="nf">a</span><span class="p">))</span>   <span class="o">&gt;&gt;=</span> <span class="nf">k</span> <span class="ow">=</span> <span class="nf">k</span> <span class="nf">a</span>
  <span class="p">(</span><span class="kt">InH</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="nf">fga</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="nf">k</span> <span class="ow">=</span> <span class="kt">InH</span> <span class="o">.</span> <span class="kt">FreeMF</span> <span class="o">$</span> <span class="nf">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="nf">k</span><span class="p">)</span> <span class="nf">fga</span></code></pre></div><p>上面的FList f 就是我们前面定义的自由单子Free f，这个名字揭示了自由单子实际上就是函子 f 的列表，对应了自由单子的展开式 。FListF f g 就是高阶函子 (F f) g = Id + f ◦ g 的Haskell代码的表示，FList f 就是HFix (FListF f)，是FListF f的不动点，也就是自由单子。</p><p>liftMF是一个非常有用的函数，其将任意一个函子的值提升为自由单子的值，使得我们可以方便的构造自由单子。构造好自由单子后，再定义一个HAlg，我们就可以对自由单子Flist f求值了。下面我们定义了一个函子StackF，由这个函子构造了一个自由单子HFix (FreeMF StackF)，然后定义了两个不同的HAlg，分别用于计算自由单子HFix (FreeMF StackF)的值，和打印自由单子HFix (FreeMF StackF)的表达式。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">StackF</span> <span class="nf">k</span> <span class="ow">=</span> <span class="kt">Push</span> <span class="kt">Int</span> <span class="nf">k</span>
              <span class="o">|</span> <span class="kt">Pop</span> <span class="nf">k</span>
              <span class="o">|</span> <span class="kt">Top</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="nf">k</span><span class="p">)</span>
              <span class="o">|</span> <span class="kt">Add</span> <span class="nf">k</span>
              <span class="o">|</span> <span class="kt">Mul</span> <span class="nf">k</span>
              <span class="kr">deriving</span> <span class="kt">Functor</span>

<span class="nf">pushF</span> <span class="nf">x</span> <span class="ow">=</span> <span class="nf">liftMF</span> <span class="p">(</span><span class="kt">Push</span> <span class="nf">x</span> <span class="nb">()</span><span class="p">)</span>
<span class="nf">popF</span>    <span class="ow">=</span> <span class="nf">liftMF</span> <span class="p">(</span><span class="kt">Pop</span> <span class="nb">()</span><span class="p">)</span>
<span class="nf">topF</span>    <span class="ow">=</span> <span class="nf">liftMF</span> <span class="p">(</span><span class="kt">Top</span> <span class="nf">id</span><span class="p">)</span>
<span class="nf">addF</span>    <span class="ow">=</span> <span class="nf">liftMF</span> <span class="p">(</span><span class="kt">Add</span> <span class="nb">()</span><span class="p">)</span>
<span class="nf">mulF</span>    <span class="ow">=</span> <span class="nf">liftMF</span> <span class="p">(</span><span class="kt">Mul</span> <span class="nb">()</span><span class="p">)</span>

<span class="nf">calcF</span> <span class="ow">=</span> <span class="kr">do</span> 
  <span class="nf">pushF</span> <span class="mi">3</span>
  <span class="nf">pushF</span> <span class="mi">4</span>
  <span class="nf">addF</span>
  <span class="nf">pushF</span> <span class="mi">5</span>
  <span class="nf">mulF</span>
  <span class="nf">x</span> <span class="ow">&lt;-</span> <span class="nf">topF</span>
  <span class="nf">popF</span>
  <span class="nf">return</span> <span class="nf">x</span>

<span class="kr">type</span> <span class="kt">MemState</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>

<span class="nf">runAlg</span> <span class="ow">::</span> <span class="kt">HAlg</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="kt">StackF</span><span class="p">)</span> <span class="kt">MemState</span>
<span class="nf">runAlg</span> <span class="p">(</span><span class="kt">PureMF</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">return</span> <span class="nf">a</span>
<span class="nf">runAlg</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="p">(</span><span class="kt">Push</span> <span class="nf">a</span> <span class="nf">k</span><span class="p">))</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">State</span> <span class="o">$</span> <span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span> <span class="nf">a</span><span class="kt">:</span><span class="nf">s</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="nf">k</span>
<span class="nf">runAlg</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="p">(</span><span class="kt">Pop</span> <span class="nf">k</span><span class="p">))</span>  <span class="ow">=</span> <span class="p">(</span><span class="kt">State</span> <span class="o">$</span> <span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span> <span class="nf">tail</span> <span class="nf">s</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="nf">k</span>
<span class="nf">runAlg</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="p">(</span><span class="kt">Top</span> <span class="nf">ik</span><span class="p">))</span> <span class="ow">=</span> <span class="nf">get</span> <span class="o">&gt;&gt;=</span> <span class="nf">ik</span> <span class="o">.</span> <span class="nf">head</span>
<span class="nf">runAlg</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="p">(</span><span class="kt">Add</span> <span class="nf">k</span><span class="p">))</span>  <span class="ow">=</span> <span class="p">(</span><span class="kt">State</span> <span class="o">$</span> <span class="nf">\s</span><span class="o">@</span><span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">y</span><span class="kt">:</span><span class="nf">ts</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span> <span class="p">(</span><span class="nf">x</span><span class="o">+</span><span class="nf">y</span><span class="p">)</span><span class="kt">:</span><span class="nf">ts</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="nf">k</span>
<span class="nf">runAlg</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="p">(</span><span class="kt">Mul</span> <span class="nf">k</span><span class="p">))</span>  <span class="ow">=</span> <span class="p">(</span><span class="kt">State</span> <span class="o">$</span> <span class="nf">\s</span><span class="o">@</span><span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">y</span><span class="kt">:</span><span class="nf">ts</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span> <span class="p">(</span><span class="nf">x</span><span class="o">*</span><span class="nf">y</span><span class="p">)</span><span class="kt">:</span><span class="nf">ts</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="nf">k</span>

<span class="c1">-- Const String is not a monad, but can get generate all calculation string</span>
<span class="nf">runShow</span> <span class="ow">::</span> <span class="kt">HAlg</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="kt">StackF</span><span class="p">)</span> <span class="p">(</span><span class="kt">Const</span> <span class="kt">String</span><span class="p">)</span>
<span class="nf">runShow</span> <span class="p">(</span><span class="kt">PureMF</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Const</span> <span class="s">&#34;Done!&#34;</span>
<span class="nf">runShow</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="p">(</span><span class="kt">Push</span> <span class="nf">a</span> <span class="nf">k</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">Const</span> <span class="o">$</span> <span class="s">&#34;Push &#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">a</span> <span class="o">++</span> <span class="s">&#34;, &#34;</span> <span class="o">++</span> <span class="nf">getConst</span> <span class="nf">k</span>
<span class="nf">runShow</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="p">(</span><span class="kt">Pop</span> <span class="nf">k</span><span class="p">))</span>  <span class="ow">=</span> <span class="kt">Const</span> <span class="o">$</span> <span class="s">&#34;Pop, &#34;</span> <span class="o">++</span> <span class="nf">getConst</span> <span class="nf">k</span>
<span class="nf">runShow</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="p">(</span><span class="kt">Top</span> <span class="nf">ik</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">Const</span> <span class="o">$</span> <span class="s">&#34;Top, &#34;</span> <span class="o">++</span> <span class="nf">getConst</span> <span class="p">(</span><span class="nf">ik</span> <span class="mi">42</span><span class="p">)</span>
<span class="nf">runShow</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="p">(</span><span class="kt">Add</span> <span class="nf">k</span><span class="p">))</span>  <span class="ow">=</span> <span class="kt">Const</span> <span class="o">$</span> <span class="s">&#34;Add, &#34;</span> <span class="o">++</span> <span class="nf">getConst</span> <span class="nf">k</span>
<span class="nf">runShow</span> <span class="p">(</span><span class="kt">FreeMF</span> <span class="p">(</span><span class="kt">Mul</span> <span class="nf">k</span><span class="p">))</span>  <span class="ow">=</span> <span class="kt">Const</span> <span class="o">$</span> <span class="s">&#34;Mul, &#34;</span> <span class="o">++</span> <span class="nf">getConst</span> <span class="nf">k</span></code></pre></div><p>上面的runAlg中，StackF k中的k是一个Monad，是类型MemState。通过hcata函数，我们可以将calcF求值为类型MemState的值，再通过runState得到最后的calcF表达式的值，结果是35。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">calcState</span> <span class="ow">=</span> <span class="nf">hcata</span> <span class="nf">runAlg</span> <span class="nf">calcF</span>
<span class="nf">calcValue</span> <span class="ow">=</span> <span class="nf">fat</span> <span class="o">$</span> <span class="nf">runState</span> <span class="nf">calcState</span> <span class="kt">[]</span></code></pre></div><p></p>