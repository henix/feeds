<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>与 Rust 在一起的四年</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/24781740">原文</a></p>
<p><b>2017-01-10 更新：</b>修复坏掉的超链接，修正 "This sort is stable" 的翻译<br></p><p> ———— 分割线 —————-</p><p>本文翻译自 Steve Klabnik 的<a href="http://words.steveklabnik.com/four-years-with-rust" data-title="博客" class="" data-editable="true">博客</a>。Steve 是 Rust 核心团队成员，主要负责文档撰写和社区建设。这篇文章是 Rust 0.5 发布公告的一个考古文，对比着今天的 Rust 看还是蛮有意思的</p><p>———— 分割线 —————-</p><p>从我第一次听说 Rust 语言到今天已经是第 4 个年头了。之所以还记得这个日子是因为我用的第一个 Rust 版本是 0.5。这四年来 Rust 发生了很大的变化。关于发展历史概况可以观看<a href="https://www.youtube.com/watch?v=79PSagCD_AY" data-title="我这个演讲" class="" data-editable="true">我这个演讲</a>。但是我觉得今天回过头来去查查当时的<a href="https://mail.mozilla.org/pipermail/rust-dev/2012-December/002787.html" data-title="发布公告" class="" data-editable="true">发布公告</a>，看看哪些东西发生了变化，哪些东西仍然保留会很有意思。</p><h2>rust-dev</h2><p>首先说说公告本身，<a href="https://mail.mozilla.org/listinfo/rust-dev" data-title="rust-dev 邮件列表" class="" data-editable="true">rust-dev 邮件列表</a>曾经是 Rust 存档形式的一站式讨论聚焦地。不过在 <a href="https://mail.mozilla.org/pipermail/rust-dev/2015-January/011558.html" data-title="2015年1月" class="" data-editable="true">2015年1月</a>，我们决定关掉它。为什么呢？让我们回顾一下 Brian 当时说的</p><blockquote><p>你很可能已经注意到了，最近几个月 rust-dev 邮件列表流量大幅下降。这最初是项目协调的自然结果，继而我们又刻意逐步废掉邮件列表。<br>项目最初用来讨论 Rust 的只有 #rust 频道和 rust-dev 邮件列表两个地方，并且多年来我们一直很开心地用这两种交流方式。随着项目的发展，项目协调也被转移到不同渠道，大家在许多不同的地方交流，于是 rust-dev 邮件列表的目的变得不那么明确了。与此同时邮件列表里面也出现了许多白热化不受管理的撕逼讨论，导致许多人对邮件列表的有效性失去了信心。</p></blockquote><p>我喜欢邮件列表，但我知道在这方面我比较独特。但邮件列表的确有一个很大的问题，管理员的管理功能很弱。你当然可以禁言某人，但这就是你所能做的全部管理了。不能只删除某些帖子，不能设置冷静时段，不能 shadow banning(译注：被禁言者依然可以发言，不过其他人看不到)。尽管 Rust 社区在管理上面广受赞誉，但绝不代表一切都很完美。我们艰难地从经验中吸取教训。</p><p>并且 mailman 在某种意义上是开源界的“老土货”，大家把它看作落后过时的东西。现在很少有人想用邮件，文化在发生变化，我们意识到这一点，所以决定转向 <a href="http://www.discourse.org" data-title="Discourse" class="" data-editable="true">Discourse</a>。rust-dev 以 Discourse 的 <a href="http://users.rust-lang.org" data-title="users" class="" data-editable="true">users</a> 和 <a href="https://internals.rust-lang.org" data-title="internals" class="" data-editable="true">internals</a> 形式幸存下来。这两个版块的明显区别是，前者讨论 Rust，后者讨论构建 Rust。Discourse 也同样是自由/开源软件，但是却有更好的管理工具，甚至你仍然可以让它给你发邮件。</p><p>我们也不会在这些论坛里做版本发布公告，我们有专门的<a href="https://blog.rust-lang.org" data-title="博客" class="" data-editable="true">博客</a>发公告。</p><p>让我们来818那次的发布注记！</p><h2>900 个变更，大量的 bug 修复</h2><p>900 个变更相当多！那时 Rust 基本上是6个月的发布周期，所以意味着每天有 5 个 PR 被合并。Rust 1.14 在6周的发布周期里<a href="https://github.com/rust-lang/blog.rust-lang.org/pull/141" data-title="会有" class="" data-editable="true">会有</a> 1230 个 PR，即每天有超过 29 个 PR。这是非常非常快的发展速度。而且这只算了我们的主仓库，我们已经加了更多的仓库，比如 <a href="https://github.com/rust-lang/cargo" data-title="Cargo" class="" data-editable="true">Cargo</a> 和 <a href="https://github.com/rust-lang/crates.io" data-title="crates.io" class="" data-editable="true">crates.io</a>。实际上这也是我很长一段时间以来的困扰，我们只在发布公告里表扬了给 rust-lang/rust 贡献过代码的人，基于这段历史，现今发生了更多的事情。我想给 Rust 项目做一份像 <a href="http://contributors.rubyonrails.org" data-title="Rails 贡献者" class="" data-editable="true">Rails 贡献者</a>一样的列表，谁愿意抽时间跟我一起来做这个工作？</p><h2>语法变化</h2><ul><li>删掉 move 操作符 &lt;-</li></ul><p>Rust 在生命周期”什么时候 move ，什么时候 copy ”的语法表示上经历过好多次迭代。如今是通过看类型是否实现了 Copy 来做区分的。但是过去 Rust 有多种形式，我用的第一个版本的 Rust 移除了这个语法，尽管我记得不大清楚，但我想应该是下面这样的</p><code lang="text">x &lt;- y; // move
x = y; // copy
</code><p>我相信 Rust 还曾用过下面这种形式</p><code lang="text">x = move y; // move
x =  y; // copy
</code><p>我们决定在语法上统一这两种形式的两个理由是：第一，标注看起来是比较繁重的活，如果你弄错了，编译器会告诉你应该用 move 还是 copy。第二，至少在如今的 Rust 里 move 和 copy 是等价的操作，除了在这两个操作之后，你能否继续用旧变量这一点区别之外。而让 move 和 copy 操作使用相同的语法则强化了这一点。</p><p>Niko 的博客里有很多很赞的历史细节，<a href="http://smallcultfollowing.com/babysteps/blog/2012/10/01/moves-based-on-type" data-title="关于这个话题也不例外" class="" data-editable="true">关于这个话题也不例外</a></p><ul><li>完成了从 #fmt 扩展语法到 fmt! 的彻底转换</li></ul><p>很久以前 Rust 有一条规则 “关键字不能超过 5 个字母”，所以很多词都被简写了。这个特殊的语法扩展延续到今天，只不过换成了更长的名字 <a href="https://doc.rust-lang.org/stable/std/macro.format.html" data-title="format!" class="" data-editable="true">format!</a></p><ul><li>移除了原来固定长度向量的语法 - [T]/N</li></ul><p>我们今天所知道的 Rust 里面的向量和数组类型经历过很多内部迭代。[T]/N 在今天的等价形式是 [T; N]，但是我敢肯定的是这两种表示方式也有些细微的差别，不过我不大记得了。</p><ul><li>quasi-quoter 的新语法 quote_tokens!, quote_expr! 等</li></ul><p>这些在某种意义上仍然存在，不过始终没有稳定下来，以至于根本没有出现在官方文档里面，不过 <a href="https://manishearth.github.io/rust-internals-docs/syntax/ext/quote/index.html" data-title="Manish 维护着一份文档拷贝" class="" data-editable="true">Manish 维护着一份文档拷贝</a>。这些是“语法扩展”的工具，属于 Rust 元编程最强有力的形式。它们的设计终稿<a href="https://github.com/rust-lang/rfcs/pull/1566" data-title="8天前才被接收" class="" data-editable="true">8天前才被接收</a>，所以等到在稳定版 Rust 见到这个语法还要等好一阵子。</p><ul><li>宏现在可以延拓到 item 和 statement 了</li></ul><p>尽管我不知道为什么之前宏不能这样做，但是现在却是可以的，而且也非常有用。</p><ul><li>a.b() 总是被解析成方法调用而不是一个字段</li></ul><p>这是一个有意思的边界情况，下面这段代码展示了这一问题：</p><code lang="text">struct Env&lt;F: Fn(i32)&gt; {
    f: F,
}

let e = Env { f: |i| println!("Hello, {}", i) };

e.f(); // what does this do?
</code><p>根据这一条注记，这里会是一个方法调用。但是如今却会是一个错误，你需要写成 (e.f)(); 才行，不过至少错误提示可以告诉你该怎么做</p><code lang="text">error: no method named `f` found for type `Env&lt;[closure@&lt;anon&gt;:6:22: 6:50]&gt;` in the current scope
 --&gt; &lt;anon&gt;:8:7
  |
8 |     e.f(); // what does this do?
  |       ^
  |
note: use `(e.f)(...)` if you meant to call the function stored in the `f` field
 --&gt; &lt;anon&gt;:8:7
  |
8 |     e.f(); // what does this do?
  |       ^
</code><ul><li>通过 #[deriving_eq] 和 #[deriving_iter_bytes] 会自动生成 Eq 和 IterBytes 的实现</li></ul><p>我们现在有更通用的方法派生 trait：例如 #[derive(Eq)]。Eq trait 现在仍然存在，而 IterBytes trait 则已经不存在了，我不大记得这个 trait 是干啥的了。</p><p>当前哪些 trait 可以派生仍然只能由编译器决定的，对于一些像 <a href="http://serde.rs" data-title="Serde" class="" data-editable="true">Serde</a> 和 <a href="http://diesel.rs" data-title="Diesel" class="" data-editable="true">Diesel</a> 这样实用的库，这也成了大家用 nightly 版本的一个重要原因。但是随着 1.15 版本的到来，这一限制将会放宽，大家使用稳定版 Rust 的一个最大障碍将会被消除！🎊🎊🎊</p><ul><li>移除了 .rc 文件的特殊 crate 语言（译注：应该是之前 crate 文件需要手动用 DSL 来描述）</li></ul><p>今天与 .rc 文件等价的是 .crate 文件，这些文件会被 Cargo 上传到 crates.io。但是与 0.5 时代不同的是，现在你几乎从来不用关心这些，因为 Cargo 使之能工作。</p><ul><li>函数参数可以由 irrefutable 模式构成</li></ul><p>的确如此，而且也是大家所知道的一个事实！像下面这样的：</p><code lang="text">struct Point {
    x: i32,
    y: i32,
}

fn takes_point(Point {x, y}: Point) {
    println!("({}, {})", x, y);
}

fn main() {
    let origin = Point { x: 0, y: 0 };
    takes_point(origin);
}
</code><p>即参数对于函数来说是 PATTERN: TYPE 而不是 NAME: TYPE，在上面的 takes_point 函数中作用域内的是 x 和 y 而不是整个 point。</p><h2>语义变化</h2><ul><li>&amp; 和 ~ 指针可以指向对象</li></ul><p>Rust 很久以前的确是有对象的，不过我认为我接触 Rust 时就已经移除了，我不大清楚这一点。</p><p>值得一提的是 ~ 现在变成 Box&lt;T&gt; 了，不过这又是一个很长的故事了。。。</p><ul><li>元组结构 - struct Foo(Bar, Baz) 替换了 newtype 枚举</li></ul><p><a href="https://doc.rust-lang.org/stable/book/structs.html#tuple-structs" data-title="当前的 Rust 中" class="" data-editable="true">当前的 Rust 中</a>依然有这些。</p><ul><li>Enum variant 可以是结构</li></ul><p>现在也是如此</p><code lang="text">enum Foo {
    Variant { x: i32, y: i32 },
}
</code><ul><li>析构可以通过 Drop trait 加到所有标称类型(nominal type)</li></ul><p>现在也是<a href="https://doc.rust-lang.org/stable/std/ops/trait.Drop.html" data-title="如此" class="" data-editable="true">如此</a></p><p>我觉得这里的 “nominal” 暗指 Rust 类型系统里面比较老的一些东西，如果没记错的话，现在 Rust 已经不再区分这些了，所有类型都是 nominal 的，不过我不敢 100% 肯定。</p><ul><li>结构和空 enum variant 可以是常量</li></ul><p>现在也是如此</p><ul><li>不能隐式拷贝的值不用显式写 move 也会被自动 move</li></ul><p>我在上面谈 &lt;- 时也提到过这点</p><ul><li>&amp;T 现在可以被强制转换成 *T</li></ul><p>现在 *T 可以是 *const T 或者是 *mut T，不过这条注记也是对的：</p><code lang="text">let x = &amp;5;
let y: *const i32 = x;
</code><ul><li>let 语句和函数调用里会发生强制类型转换</li></ul><p>多年来我们在“什么时候进行强制类型转换什么时候不转”上经历了许多不同的迭代。实际上我期望上面的例子中 *const i32 必需要有个 as 来做转换。</p><ul><li>use 语句现在取的是 crate 相对路径</li></ul><p>现在也如此。我真的是很喜欢这一点，但是很多人发现这个很迷惑。基本上 “use” 总是从 crate 的根开始，所以有下面的</p><code lang="text">mod bar {
    struct Foo;
    mod baz {
        use bar::Foo; // from the root
        use super::Foo; // if you want to start from the parent
        use self::super::Foo; // self makes it be relative. Not even sure if self + super works, but you get the idea.
    }
}
</code><ul><li>模块和类型的名字空间合并了，以便静态方法的名字可以在定义的 trait 里被查找到</li></ul><p>这一条不太确定，也有点野生。</p><h2>改善了语言特性的支持</h2><ul><li>trait 继承可以在许多场景下工作</li></ul><p>用继承这个词一直有点不恰当，这里继承是指</p><code lang="text">trait Foo: Bar {
}
</code><p>如果你想实现 Foo 的话，你必须还得实现 Bar，就是这么回事。这一行让我感到很愉快：“这个解释比继承更好”</p><ul><li>支持方法里显式的带上 self 参数 - self, &amp;self, @self 和 ~self 这些都如预期的一样工作</li></ul><p>现在的 Rust 不仅仅支持这么做，而且是强制要求带上的，不过</p><ul><li>self 仍然是 self</li><li>&amp;self 也仍然是 &amp;self</li><li>@self 类似于 Rc&lt;self&gt;</li><li>~self 则变成 Box&lt;self&gt;</li></ul><p>@self 本来是用来表示 GC 类型的，但却除了用来引用计数外从来没有成为 GC 类型</p><p>另外后面两种也不是那样写的，而是 self: Rc&lt;Self&gt; 和 self: Box&lt;Self&gt;。 后者可以编译，而 Rc 那个却不行，因为 Box 有黑魔法。不过这一点最终会被修正过来。</p><ul><li>静态方法可以在更多的情景下工作</li></ul><p>又一行“哇，更多的特性可以工作”。：）</p><ul><li>实验特性：Trait 可以定义默认的方法给 impl 用</li></ul><p>如今也是，而且这一点很有用。考虑 <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html" data-title="Iterator" class="" data-editable="true">Iterator</a>：所有的方法都有默认实现，所以你只需要定义 next()，其它的方法就可以自动获得了</p><h2>库</h2><ul><li>core::condition 中新的 condition 处理系统</li></ul><p>condition 是 Lisp 用来处理错误的方式，Rust 曾经支持过一段时间。这一点非常酷，但是没人知道如何有效的使用，所以也就没有人去用，于是乎现在就消失了</p><ul><li>Timsort 被加到 std::sort</li></ul><p>std::sort 现在已经不存在了，尽管我们有 <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.sort" data-title="slice 排序函数" class="" data-editable="true">slice 排序函数</a>。我们不再声明是某种特别的算法，而只是说“这种排序方法是稳定的，并且在最坏情况下是 O(n log n)，但是需要分配大约 2*n 的空间，其中 n 是 self 的长度”。</p><p><a href="https://github.com/rust-lang/rust/pull/38192" data-title="最近这个算法得到大量的改善" class="" data-editable="true">最近这个算法得到大量的改善</a>，这些工作还是一个初次贡献者做的，简直干得太漂亮了。在这个 PR 里，他是这样解释这个算法的：</p><blockquote><p>然而如果我们从 TimSort(排序时智能归并策略)中汲取主要观点并且放弃 gallop，则对于随机输入可以获得极高的性能，而且对于部分排序的输入也不会太差。</p></blockquote><p>TimSort 仍然在那并发挥着巨大的作用。</p><ul><li>新的优先级队列：std::priority_queue</li></ul><p>如今是 <a href="https://doc.rust-lang.org/std/collections/binary_heap" data-title="std::collections::binary_heap" class="" data-editable="true">std::collections::binary_heap</a></p><ul><li>针对可序列化类型的管道： std::flatpipes</li></ul><p>不知道如今这个东西去哪里了</p><ul><li>序列化大幅修改变成基于 trait 的了</li></ul><p>如今也是。见上面提到的 Serde，不过 <a href="https://crates.io/crates/rustc-serialize" data-title="rustc-serialize" class="" data-editable="true">rustc-serialize</a> 算是作弊，编译器可以理解 RustcEncodable 和 RustcDecodable。对于 1.15 的到来迫不及待！</p><ul><li>扩展了 getopts 定义</li></ul><p>我们已经把 <a href="https://github.com/rust-lang-nursery/getopts" data-title="getopts 从标准库源码树中移除了" class="" data-editable="true">getopts 从标准库源码树中移除了</a>，不过这个库仍然健在</p><ul><li>将 futures 移到 std</li></ul><p>卧靠！我都忘了我们曾经在标准库里是有 futures 的。Futures 是现在 Rust 社区里最火的话题之一。<a href="https://github.com/tokio-rs" data-title="Tokio" class="" data-editable="true">Tokio</a>是 Rust 圈里有史以来最受期待的发布之一。想尝鲜的可以看看这个<a href="https://www.youtube.com/watch?v=bcrzfivXpc4" data-title="演讲" class="" data-editable="true">演讲</a>。一个哥们告诉我 Tokio 很快就会发布 0.1 了。。。</p><ul><li>有更多的纯函数了</li></ul><p>Rust 已经没有纯函数的概念了，尽管 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md" data-title="const fn" class="" data-editable="true">const fn</a>（仍然是 unstable）在某种程度上算是纯函数。关于 Rust 纯函数的历史可以看看 <a href="http://smallcultfollowing.com/babysteps/blog/2012/10/12/extending-the-definition-of-purity-in-rust" data-title="Niko 的博客" class="" data-editable="true">Niko 的博客</a>，或者是 <a href="https://mail.mozilla.org/pipermail/rust-dev/2013-April/003926.html" data-title="Graydon 关于为什么纯函数被移除了的解释" class="" data-editable="true">Graydon 关于为什么纯函数被移除了的解释</a>。</p><ul><li>core::comm 重命名为 oldcomm，仍然是废弃的</li></ul><p>很早很早以前就消失了</p><ul><li>rustdoc 和 cargo 现在变成库了</li></ul><p>Rustdoc 仍然存在，不过不是以库的形式。Cargo 则已经不是你所想的 cargo 了，<a href="https://github.com/rust-lang/rust-wiki-backup/blob/73816d6f888c24fb8115d78078a1601805cbecb5/Doc-using-cargo-to-manage-packages.md" data-title="完全是另一个东西" class="" data-editable="true">完全是另一个东西</a>。在当前的 cargo 之前，Rust 的包管理经历过许多次迭代。例如曾经有 <a href="https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/doc/guide-rustpkg.md" data-title="rustpkg" class="" data-editable="true">rustpkg</a>，出现在这里提到的 Cargo 之后，今天我们用的 Cargo 之前。</p><h2>杂项</h2><ul><li>初步增加了 REPL：rusti</li></ul><p>我们现在从 Rust 源码里移除了 repl，因为 repl 从来没有真正起作用过，而且还是代码维护的噩梦。<a href="https://github.com/murarth/rusti" data-title="这个" class="" data-editable="true">这个</a>是当前我所知道的唯一一个。一些人要求提供一个，不过没有人一起来做这件事去实现一个好用的 repl。这是一件很艰难的事情！</p><ul><li>许可证从 MIT 变成了 MIT/APL2 双许可证</li></ul><p>现在也是如此，也没有计划改变这个。</p><h2>Rust 0.5 的贡献者：</h2><p>Rust 0.5 版本有 41 个贡献者，而 1.14 则有 144 个，这是这些日子以来的每版的平均贡献者人数。这 41 个人中，我粗略看了下，认出了其中 17 个人的名字，其中大概有 6 个依然参与着当前 Rust 和 Servo 项目，另外 11 个人呢？一些是实习生现在已经在其它地方工作了，所以不能继续为 Rust 工作了，一些贡献者由于不同的原因离开了，自然包括 Graydon。</p><p>在发现 Rust 语言后第六天我提了我个人的<a href="https://github.com/rust-lang/rust/pull/4305" data-title="第一个 PR" class="" data-editable="true">第一个 PR</a>。你会注意到这个 PR 没有被合并，原因是操作失误，我把它发到错误的分支上去了！现在 GitHub 允许你修改这样的失误，但是我当时又开了<a href="https://github.com/rust-lang/rust/pull/4308" data-title="另一个 PR" class="" data-editable="true">另一个 PR</a>。</p><p>我在那个 PR 里面是这样说的：</p><blockquote><p>我刚刚开始使用 Rust，并且非常喜欢它。其中一个让 Rust 显得很困难的是文档的缺乏，当然这没什么大问题，毕竟 Rust 还没有达到生产可用。<br>我愿意帮助改变这一点。<br>作为开始，我只是修改了 rustdoc 里面这一段短短的描述，如果这个有帮助，并且你们都喜欢我的修改，我将会按这种方式修改 core 的其它部分文档，继而可能修改 stdlib 的文档。</p></blockquote><p>你也许会说的确起作用了，我现在是<a href="https://blog.rust-lang.org/2014/12/12/Core-Team.html" data-title="核心团队" class="" data-editable="true">核心团队</a>的一员了。从那之后我已经提交了 866 个 PR，第一个 PR 在 <a href="https://mail.mozilla.org/pipermail/rust-dev/2013-April/003427.html" data-title="Rust 0.6 版本里" class="" data-editable="true">Rust 0.6 版本里</a>，而 Rust 0.10 是唯一一个我没有提 PR 的版本。而现在我负责写 Rust 发布公告。</p><p>我希望你喜欢这一小段记忆航线。如今我依然喜欢 Rust 及其社区，这是给未来更多年的😳♥</p><br>​
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
