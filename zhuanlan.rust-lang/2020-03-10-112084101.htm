<p>使用rust tokio Interval作为定时器，可能会在系统休眠或进程挂起恢复后，CPU爆满，甚至导致死机，Windows、iOS、Android都有这个问题。</p><h2>引言</h2><p>虽然rust代码写得不多，但使用C++的性能分析方法论和工具链，也能分析rust代码的性能。这次，就是通过WPT（Windows Performance Tools）和Instruments分析了rust的第三方库tokio的Interval的一个性能问题。</p><h2>问题的发现</h2><p>在Win10系统（CPU 12核）休眠恢复之后，发现rust进程的CPU占比超过6%，相当于1个CPU核的70%。于是，赶紧用WPT抓了一个现场。通过WPT分析，发现CPU主要被其中一个线程消耗。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-f3ee9902769ae6f2d42194a7a9627ed9_b.jpg" data-caption="" data-size="normal" data-rawwidth="394" data-rawheight="137" class="content_image" width="394"/></noscript><img src="https://pic2.zhimg.com/v2-f3ee9902769ae6f2d42194a7a9627ed9_b.jpg" data-caption="" data-size="normal" data-rawwidth="394" data-rawheight="137" class="content_image lazy" width="394" data-actualsrc="https://pic2.zhimg.com/v2-f3ee9902769ae6f2d42194a7a9627ed9_b.jpg"/></figure><h2>其他平台的测试验证</h2><p>由于rust代码是跨平台的SDK，因此，也需要验证下其他平台是否有同样的问题。</p><h2>iOS</h2><p>使用Instruments抓了iOS与Windows类似场景，消耗CPU最多的也是这个线程。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-87834d96012f0f676c26272699cac89b_b.jpg" data-caption="" data-size="normal" data-rawwidth="441" data-rawheight="191" class="origin_image zh-lightbox-thumb" width="441" data-original="https://pic4.zhimg.com/v2-87834d96012f0f676c26272699cac89b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-87834d96012f0f676c26272699cac89b_b.jpg" data-caption="" data-size="normal" data-rawwidth="441" data-rawheight="191" class="origin_image zh-lightbox-thumb lazy" width="441" data-original="https://pic4.zhimg.com/v2-87834d96012f0f676c26272699cac89b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-87834d96012f0f676c26272699cac89b_b.jpg"/></figure><h2>Mac</h2><p>经过反复测试，未发现Mac有这个问题。</p><h2>Android</h2><p>经过反复测试，未发现Android有这个问题。（后来发现，是因为Android连上电脑是充电模式，进程不会自动挂起，没有进入到可复现这个问题的路径。）</p><h2>tokio的Interval的Demo实验</h2><p>经过多平台的测试验证，发现Windows和iOS有这个问题，但是Mac没有发现这个问题，这就感觉到很迷糊了。通过WPT和Instruments的分析数据，已定位到相关代码，使用tokio的Interval运行一个定时任务，每隔1S执行1次。其中，tokio版本0.1.13。排查了自有代码，没有找到可能引起这个问题的代码。经过现象分析，推测可能跟tokio有关，于是，写了一个简化的Demo进行验证。</p><h2>实验代码说明</h2><p>创建一个循环定时器任务，每隔1S运行1次。在每次定时器任务触发时，输出以下调试信息：</p><ul><li>当前任务的序号</li><li>任务触发的绝对时间</li><li>Instant::now()获取的时间</li><li>当前任务的到期时间</li></ul><div class="highlight"><pre><code class="language-rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">test_interval</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">interval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Interval</span>::<span class="n">new_interval</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">deadline</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TIME_COUNT</span><span class="p">.</span><span class="n">write</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="o">*</span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="o">*</span><span class="n">count</span><span class="w">
</span><span class="w">            </span><span class="p">};</span><span class="w">
</span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}, {}, now: {:?}, deadline: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">Utc</span>::<span class="n">now</span><span class="p">().</span><span class="n">format</span><span class="p">(</span><span class="s">&#34;%T&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">Instant</span>::<span class="n">now</span><span class="p">(),</span><span class="w"> </span><span class="n">deadline</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">        </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">        </span><span class="n">MY_RUNTIME</span><span class="p">.</span><span class="n">executor</span><span class="p">().</span><span class="n">spawn</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2>系统休眠实验</h2><p>由于Windows平台发现的问题，就是通过系统休眠的方式来发现的，因此，对Windows、Mac、Linux都进行了系统休眠实验。</p><p>实验方法：先让系统休眠一段时间（超过2分钟），然后重新激活系统，观察激活后的任务执行次数。如果系统重新激活后1S内，任务执行次数只有1-3次，属于没有问题；如果有大量任务执行，则是有问题的。</p><h3>Windows系统休眠实验结果</h3><ul><li>系统开始休眠时间：14:08:33。</li><li>激活系统时间：14:15:05。</li><li>系统激活后1S内，执行任务394次，存在问题。</li></ul><blockquote>1, 14:08:18, now: Instant { t: 1287693.9087257s }, deadline: Instant { t: 1287693.9079829s }<br/>2, 14:08:19, now: Instant { t: 1287694.9086322s }, deadline: Instant { t: 1287694.9079829s }<br/>16, 14:08:33, now: Instant { t: 1287708.9085874s }, deadline: Instant { t: 1287708.9079829s }<br/>17, 14:15:05, now: Instant { t: 1288101.05249s }, deadline: Instant { t: 1287709.9079829s }<br/>18, 14:15:05, now: Instant { t: 1288101.0528517s }, deadline: Instant { t: 1287710.9079829s }<br/>409, 14:15:06, now: Instant { t: 1288101.9091369s }, deadline: Instant { t: 1288101.9079829s }<br/>410, 14:15:07, now: Instant { t: 1288102.9145323s }, deadline: Instant { t: 1288102.9079829s }<br/>411, 14:15:08, now: Instant { t: 1288103.9128121s }, deadline: Instant { t: 1288103.9079829s }</blockquote><h3>Mac系统休眠实验结果</h3><ul><li>系统开始休眠时间：14:10:19。</li><li>激活系统时间：14:18:39。</li><li>结束休眠后1S内，执行任务1次，没有问题。</li></ul><blockquote>1, 14:09:50, now: Instant { t: 306133377041330 }, deadline: Instant { t: 306133373882499 }<br/>2, 14:09:51, now: Instant { t: 306134375199583 }, deadline: Instant { t: 306134373882499 }<br/>30, 14:10:19, now: Instant { t: 306162380111871 }, deadline: Instant { t: 306162373882499 }<br/>31, 14:18:39, now: Instant { t: 306164208046139 }, deadline: Instant { t: 306163373882499 }<br/>32, 14:18:40, now: Instant { t: 306164378924112 }, deadline: Instant { t: 306164373882499 }<br/>33, 14:18:41, now: Instant { t: 306165379182917 }, deadline: Instant { t: 306165373882499 }<br/>34, 14:18:42, now: Instant { t: 306166375919484 }, deadline: Instant { t: 306166373882499 }</blockquote><h2>Linux系统休眠实验结果</h2><p>使用的测试系统为ubuntu 18.04。</p><ul><li>进程开始休眠时间：11:10:11。</li><li>进程激活时间：11:31:52。</li><li>进程激活后1S内，执行任务2次，没有问题。</li></ul><blockquote>1, 11:09:58, now: Instant { tv_sec: 3437, tv_nsec: 200974533 }, deadline: Instant { tv_sec: 3437, tv_nsec: 199134350 }<br/>14, 11:10:11, now: Instant { tv_sec: 3450, tv_nsec: 200868087 }, deadline: Instant { tv_sec: 3450, tv_nsec: 199134350 }<br/>15, 11:31:52, now: Instant { tv_sec: 3452, tv_nsec: 388860753 }, deadline: Instant { tv_sec: 3451, tv_nsec: 199134350 }<br/>16, 11:31:52, now: Instant { tv_sec: 3452, tv_nsec: 389004878 }, deadline: Instant { tv_sec: 3452, tv_nsec: 199134350 }<br/>17, 11:31:53, now: Instant { tv_sec: 3453, tv_nsec: 201303263 }, deadline: Instant { tv_sec: 3453, tv_nsec: 199134350 }<br/>18, 11:31:54, now: Instant { tv_sec: 3454, tv_nsec: 201269682 }, deadline: Instant { tv_sec: 3454, tv_nsec: 199134350 }</blockquote><h2>进程挂起实验</h2><p>通过iOS之前的测试分析，iOS出现问题时，并不是系统休眠，而是进程挂起，于是，对移动端进行了进程挂起的实验。</p><h3>iOS进程挂起实验结果</h3><p>先运行进程，然后把进程切换到后台，等待一段时间后，把进程切换到前台，观察运行结果。</p><ul><li>进程开始休眠时间：09:40:07。</li><li>进程激活时间：09:41:56。</li><li>进程激活后1S内，运行了109次任务，存在问题。</li></ul><blockquote>1, 09:39:10, Instant { t: 8575538386338 }, Instant { t: 8575538224636 }<br/>58, 09:40:07, Instant { t: 8576906237923 }, Instant { t: 8576906224636 }<br/>59, 09:41:56, Instant { t: 8579507571088 }, Instant { t: 8576930224636 }<br/>60, 09:41:56, Instant { t: 8579507573627 }, Instant { t: 8576954224636 }<br/>167, 09:41:56, Instant { t: 8579522286057 }, Instant { t: 8579522224636 }<br/>168, 09:41:57, Instant { t: 8579546357653 }, Instant { t: 8579546224636 }<br/>169, 09:41:58, Instant { t: 8579570335229 }, Instant { t: 8579570224636 }</blockquote><h3>Android进程挂起实验结果</h3><p>在测试Android时，发现连上电脑后，手机处于充电模式，App切换到后台之后，仍然会运行，因此，切到后台的方式不能测试进程挂起。下面就通过打断点的方式，测试进程挂起恢复后的情况。</p><ul><li>进程开始挂起时间：08:51:01。</li><li>进程激活时间：08:55:25。</li><li>进程激活后1S内，运行任务264次，存在问题。</li></ul><blockquote>1, 08:50:48, now: Instant { tv_sec: 16422, tv_nsec: 449018405 }, deadline: Instant { tv_sec: 16422, tv_nsec: 446896405 }<br/>14, 08:51:01, now: Instant { tv_sec: 16435, tv_nsec: 449331405 }, deadline: Instant { tv_sec: 16435, tv_nsec: 446896405 }<br/>15, 08:55:25, now: Instant { tv_sec: 16698, tv_nsec: 727410405 }, deadline: Instant { tv_sec: 16436, tv_nsec: 446896405 }<br/>278, 08:55:25, now: Instant { tv_sec: 16699, tv_nsec: 449296405 }, deadline: Instant { tv_sec: 16699, tv_nsec: 446896405 }<br/>279, 08:55:26, now: Instant { tv_sec: 16700, tv_nsec: 450704405 }, deadline: Instant { tv_sec: 16700, tv_nsec: 446896405 }<br/>280, 08:55:27, now: Instant { tv_sec: 16701, tv_nsec: 449870405 }, deadline: Instant { tv_sec: 16701, tv_nsec: 446896405 }<br/>281, 08:55:28, now: Instant { tv_sec: 16702, tv_nsec: 449879405 }, deadline: Instant { tv_sec: 16702, tv_nsec: 446896405 }</blockquote><h2>小结</h2><p>通过以上的实验结果证明，测试代码能复现相同场景问题，因此，这个问题跟tokio的Interval有关。</p><ul><li>系统休眠恢复后，Windows有此问题，Mac和Linux无此问题。</li><li>进程挂起恢复后，iOS和Android都有此问题。同时，经过推测，Windows、Mac、Linux的进程挂起，也会有此问题。</li></ul><h2>tokio源码分析</h2><p>下面就研究tokio的相关源码来分析问题原因。</p><h2>Interval的实现原理</h2><p>Interval处理定时器到期的函数为poll，主要作用是设置下一次定时器到期的时间。这里是通过本次到期时间加上定时器时间间隔，作为下一次到期的时间。这里使用的是相对时间，因此，每一次循环都需要执行。</p><div class="highlight"><pre><code class="language-rust"><span class="k">impl</span><span class="w"> </span><span class="n">Stream</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Interval</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_ready</span><span class="o">!</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">delay</span><span class="p">.</span><span class="n">poll</span><span class="p">());</span><span class="w">
</span><span class="w">        </span><span class="c1">// 这里使用的当前时间是上次定时器到期的时间
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">delay</span><span class="p">.</span><span class="n">deadline</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="c1">// 然后用上次到期时间加上时间间隔，作为下一次触发定时器的时间
</span><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">delay</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">now</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">duration</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">now</span><span class="p">).</span><span class="n">into</span><span class="p">())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>定时器的等待时间和唤醒的处理，是由Timer类的park和unpark函数实现。park是处理定时器等待的函数，通过当前实时时间和下一次定时器到期时间对比，判断定时器是否到期。如果定时器未到期，则会进入park_timeout进行剩余时间的等待。</p><div class="highlight"><pre><code class="language-rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Park</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Timer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="nc">Park</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">N</span>: <span class="nc">Now</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Unpark</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">Unpark</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">unpark</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Unpark</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">park</span><span class="p">.</span><span class="n">unpark</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">park</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">process_queue</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">wheel</span><span class="p">.</span><span class="n">poll_at</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">when</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 获取当前的实时时间,调用的是Instant::now()
</span><span class="c1"></span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">now</span><span class="p">.</span><span class="n">now</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="c1">// 本次定时器到期的时间
</span><span class="c1"></span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">deadline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">expiration_instant</span><span class="p">(</span><span class="n">when</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="c1">// 如果定时器未到期，会进行等待
</span><span class="c1"></span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">deadline</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="bp">self</span><span class="p">.</span><span class="n">park</span><span class="p">.</span><span class="n">park_timeout</span><span class="p">(</span><span class="n">deadline</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">now</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="bp">self</span><span class="p">.</span><span class="n">park</span><span class="p">.</span><span class="n">park_timeout</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">park</span><span class="p">.</span><span class="n">park</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">process</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>通过上面几个函数的逻辑判断，Timer的等待和唤醒的处理使用的是实时时间，而Interval的定时器到期处理使用了相对时间。系统休眠或者进程挂起会导致相对时间暂停，休眠恢复后，就可能导致休眠期间的任务累加到休眠恢复后执行，从而导致短期内CPU消耗高。这个逻辑推断，正好验证了前面在Windows平台中发现的问题。但是，为什么Mac平台下没有和Windows一样的问题呢？这个跟Instant的实现原理有关。</p><h2>Instant的实现原理</h2><p>Timer的park函数获取实时时间是调用的Instant::now()函数，这个函数是获取了系统当前时间，通过查看源码和测试发现，各平台的Instant::now()的实现原理不一样。</p><h3>Instant::now()的Windows相关源码</h3><p>Windows系统中，Instant::now()调用的是QueryPerformanceCounter函数。经过测试，这个函数的时间计算包括系统休眠时间。</p><div class="highlight"><pre><code class="language-rust"><span class="k">impl</span><span class="w"> </span><span class="n">Instant</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">now</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Instant</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">perf_counter</span>::<span class="n">PerformanceCounterInstant</span>::<span class="n">now</span><span class="p">().</span><span class="n">into</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">mod</span> <span class="nn">perf_counter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">PerformanceCounterInstant</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">now</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ts</span>: <span class="nc">query</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">query</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">c</span>::<span class="n">LARGE_INTEGER</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">qpc_value</span>: <span class="nc">c</span>::<span class="n">LARGE_INTEGER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">cvt</span><span class="p">(</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">c</span>::<span class="n">QueryPerformanceCounter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">qpc_value</span><span class="p">)</span><span class="w"> </span><span class="p">}).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">qpc_value</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3>Instant::now()的Mac和iOS相关源码</h3><p>Mac和iOS系统中，Instant::now()调用的是mach_absolute_time函数。查看苹果的开发者文档得知，mach_absolute_time的时间不包括系统休眠的时间。</p><div class="highlight"><pre><code class="language-rust"><span class="k">impl</span><span class="w"> </span><span class="n">Instant</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">now</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Instant</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">fn</span> <span class="nf">mach_absolute_time</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u64</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">Instant</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">t</span>: <span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">mach_absolute_time</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3>mach_absolute_time在苹果开发者文档中的说明如下：</h3><blockquote>mach_absolute_time<br/>Returns current value of a clock that increments monotonically in tick units (starting at an arbitrary point), this clock does not increment while the system is asleep.</blockquote><h3>Instant::now()的Android和Linux相关源码</h3><p>Android和Linux系统中，Instant::now()调用的是clock_gettime函数。查看相关资料得知，clock_gettime的CLOCK_MONOTONIC的时间不包括系统休眠的时间。</p><div class="highlight"><pre><code class="language-rust"><span class="k">impl</span><span class="w"> </span><span class="n">Instant</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">now</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Instant</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Instant</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">t</span>: <span class="nc">now</span><span class="p">(</span><span class="n">libc</span>::<span class="n">CLOCK_MONOTONIC</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">now</span><span class="p">(</span><span class="n">clock</span>: <span class="nc">clock_t</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Timespec</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Timespec</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">t</span>: <span class="nc">libc</span>::<span class="n">timespec</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">tv_sec</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">tv_nsec</span>: <span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">cvt</span><span class="p">(</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">libc</span>::<span class="n">clock_gettime</span><span class="p">(</span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">}).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">t</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在StackOverflow查到的关于clock_gettime的问题回答如下：</p><blockquote>Note that on Linux, CLOCK_MONOTONIC does not measure time spent in suspend, although by the POSIX definition it should. You can use the Linux-specific CLOCK_BOOTTIME for a monotonic clock that keeps running during suspend.<br/><a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/3523442/difference-between-clock-realtime-and-clock-monotonic" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">stackoverflow.com/quest</span><span class="invisible">ions/3523442/difference-between-clock-realtime-and-clock-monotonic</span><span class="ellipsis"></span></a></blockquote><h3>小结</h3><p>Windows的实时时间计算会包括系统休眠时间。Mac、iOS、Android、Linux的实时时间计算不包括系统休眠时间。</p><p>系统Instant调用函数是否包括系统休眠时间WindowsQueryPerformanceCounter是Mac、iOSmach_absolute_time否Android、Linuxclock_gettime (Monotonic Clock)否</p><h2>问题处理</h2><p>通过以上的分析，得出结论：</p><ul><li>Windows的系统休眠恢复后有问题，是因为Windows平台的Instant的时间计算包括系统休眠时间。</li><li>所有系统的进程挂起都有问题，是因为Instant的时间计算包括进程挂起时间。</li></ul><p>要想解决这个问题，要么弃用tokio::timer::Interval，或者修改Interval的代码。</p><h2>Interval的修改建议</h2><p>要解决这个问题，重点是要使用系统时间来计算下一次定时器的到期时间。但是这种修复不一定符合tokio库对Interval的设计，只适合修改之后自己使用。</p><div class="highlight"><pre><code class="language-rust"><span class="k">impl</span><span class="w"> </span><span class="n">Stream</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Interval</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_ready</span><span class="o">!</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">delay</span><span class="p">.</span><span class="n">poll</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// let now = self.delay.deadline();
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Instant</span>::<span class="n">now</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">delay</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">now</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">duration</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">now</span><span class="p">).</span><span class="n">into</span><span class="p">())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>本文使用的tokio版本为0.1.13，但看了目前最新的0.2.13，也是同样的实现方式。</p><h2>关于作者</h2><p>微信公众号：程序员bingo<br/>Blog: <a href="https://link.zhihu.com/?target=https%3A//bingoli.github.io/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">bingoli.github.io/</span><span class="invisible"></span></a><br/>GitHub: <a href="https://link.zhihu.com/?target=https%3A//github.com/bingoli" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/bingoli</span><span class="invisible"></span></a></p>