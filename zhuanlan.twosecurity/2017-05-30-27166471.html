<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Backslash Powered Scanning</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/27166471">原文</a></p>
<h2><b>摘要</b></h2><br>现有的web扫描器通过在某个参数上利用大量特定payload进行测试或者寻找特征来找寻服务端的注入漏洞--几乎像一个杀软。在本文中，作将分享另一种扫描方式的概念和开发过程，这种扫描方式能够发现和确认已知与未知类型的注入漏洞。这种方式从经典的手工检测进化而来，拥有手工测试的众多优势，例如WAF避规，极小的网络痕迹和针对过滤的灵活输入。<br><br>与以往相同，这种方式依然会设法利用一些对于经验丰富的手工测试者来说十分熟悉的漏洞。作者将通过展示几千个网站的样例来分享一些有趣的发现和教训，并放出一个特定的扫描工具。最后，作者将展示这款工具如何能被继续开发，让你有更多的研究方向。<h2>介绍</h2><img src="https://pic1.zhimg.com/v2-0f189c008e0e9a61ef8b8f77127f4c0a_r.png" data-rawwidth="880" data-rawheight="843"><br>web应用程序扫描器被广泛认为是只能识别’low-hanging fruit’（注释:容易摘的果子，形容唾手可得）-- 很明显任何人都能找到的漏洞，这通常是一个公正的判断；与手工测试相比，自动扫描器依赖于大量特定技术的payload，缺乏应变性意味着即使是最先进的扫描器也不能像人类一样识别某些明显的漏洞。在某种意义上，这种比较也是不公平的--扫描器越来越擅长发现客户端的问题，例如跨站点脚本(XSS)，甚至能通过动态与静态分析识别出基于DOM的XSS。然而，黑盒扫描器对服务端的运作缺乏了解，因此他们通常难以检测出服务端的注入漏洞，例如SQL注入，代码注入，命令注入。<p>在这篇文章中，作者将拆分出扫描器对服务端注入漏洞检测的三个核心盲点，接着展示如何实现一个从手工检测进化而来的扫描方式，作者将开发一个开源扫描器能够检测远高于’low-hanging fruit’的漏洞。特别是，作者将展示这个扫描器能够在发现漏洞类之前，检测出服务端的模板注入(SSTI)漏洞。</p><p>这个扫描器作为一个Burpsuite的插件能够从BApp store中获取到，源代码也可以从Github中获取到：<a href="https://github.com/PortSwigger/backslash-powered-scanner" data-title="backslash-powered-scanner" class="" data-editable="true">backslash-powered-scanner</a>，<a href="https://github.com/PortSwigger/distribute-damage" data-editable="true" data-title="distribute-damage" class="">distribute-damage</a></p><h2>扫描器的三个薄弱之处</h2><ol><li><b>盲点一：Rare Technology</b><br><br>通过安全防范扫描仪。举一个例子，来看下模板注入(SSTI)，当应用程序不做防范，将用户输入嵌入到模板中时，即会出现漏洞。根据使用的模板引擎，这可能会被利用，导致任意代码执行甚至完全控制服务器。为了使扫描器能检测到这种漏洞，需要使用到每一种模板引擎的payload硬编码。如果你的应用程序使用的是一个流行模板引擎例如FreeMarker或者Jinja，那没有什么问题。但是你的扫描器能够支持以下多少个模板引擎：<br><br><blockquote><p>Amber, Apache Velocity, action4JAVA, ASP.NET (Microsoft), ASP.NET (Mono), AutoGen, Beard, Blade, Blitz, Casper, CheetahTemplate, Chip Template Engine, Chunk Templates, CL-EMB, CodeCharge Studio, ColdFusion, Cottle, csharptemplates, CTPP, dbPager, Dermis, Django, DTL::Fast (port of Django templates), Djolt-objc, Dwoo, Dylan Server Pages, ECT, eRuby, FigDice, FreeMarker, Genshi (templating language), Go templates, Google-ctemplate, Grantlee Template System, GvTags, H2o, HAH, Haml, Hamlets, Handlebars, Hyperkit PHP/XML Template Engine, Histone template Engine, HTML-TEMPLATE, HTTL, Jade, JavaServer Pages, jin-template, Jinja, Jinja2, JScore, Kalahari, Kid (templating language), Liquid, Lofn, Lucee, Mako, Mars-Templater, MiniTemplator, mTemplate, Mustache, nTPL, Open Power Template, Obyx, Pebble, Outline, pHAML, PHP, PURE Unobtrusive Rendering Engine, pyratemp, QueryTemplates, RainTPL, Razor, Rythm, Scalate, Scurvy, Simphple, Smarty, StampTE, StringTemplate, SUIT Framework, Template Attribute Language, Twital, Template Blocks, Template Toolkit, Thymeleaf, TinyButStrong, Tonic, Toupl, Twig, Twirl, uBook Template, vlibTemplate, WebMacro, ZeniTPL, BabaJS, Rage, PlannerFw, Fenom</p></blockquote><p>这个列表只包含了一些在维基百科上众所周知的模板引擎。Michael Stepankin最近发现一个在 paypal 上的远程代码执行漏洞(<a href="http://artsploit.blogspot.jp/2016/08/pprce2.html" data-editable="true" data-title="remote code execution vulnerability in Paypal" class="">remote code execution vulnerability in Paypal</a>),起因于<a href="https://github.com/linkedin/dustjs" data-editable="true" data-title="Dust.js" class="">Dust.js</a> 产生的 SSTI，这个来自 LinkedIn 的模板引擎明显不在上面的列表之中。匮乏的扫描器适用范围同样适用于使用无数数据库语言的用户，更不用说那些超出理解范围的扭曲框架的代码注入。<br></p><p>此外，使扫描器对后端技术进行假设，这意味着改变任何一个服务端组件的改变都会破坏对其余漏洞的检测。例如，在 SELinux 下运行一个 Webapp 能够组织对本地文件包含和外部实体包含漏洞的检测，这些检测通常通过读取 /etc/passwd来验证，而 SELinux 将会阻止这些行为。</p><p>最终，扫描器对于使用小众技术的应用程序进行检测时，性能严重下降。</p></li><li><p><b>盲点二：Variants and Filters</b><br><br>利用一个众所周知的语言来思考一个经典的漏洞:在 PHP 双引号中的 blind code injection。扫描器可以通过发送一个 time-delay 的 payload 轻易检测出这个问题：</p><code lang="text">".sleep(10)."</code><p>到目前还好。但是如果应用程序碰巧过滤了括号，代码将会出错，但是我们仍然可以利用：</p><code lang="text">".`sleep 10`."</code><p>如果应用程序的 WAF 检测 payload 是否存在 ’sleep’ 这个关键词，我们几乎可以肯定会再次出错。如果应用程序能正常化输出，那么我们仍然可以通过利用 Cyrillic 的’e’字符，希望能变成正常的’e’从而执行：</p><code lang="text">".sl%D0%B5ep(10)."</code><p>如果应用程序过滤了双引号，我们会再一次获得错误的结果，但是我们仍然能轻易的执行我们的代码：</p><code lang="text">{${sleep(10)}}</code><p>这三个例子中，我在渗透测试中遇到过两个，在别人的 Writeup 中看到了第三个。</p><p>扫描器的设计使得他们很容易因为意想不到的过滤和变体而检测失败。扫描器当然可以发送上面展示的变体 payload，但是这些仅仅是一个漏洞的众多变体中的三个。发送足够的 payload覆盖每一种的漏洞的每一个变体，在现在的网络速度上基本上是难以置信的 --因为有数百万个 payload。扫描器仅限于发送’best-effort’（注释:尽力而为）的 payload，这意味着即使是使用双引号代替单引号封装 SQL 语句也会导致扫描器的检测失败。</p></li><li><b>盲点三：Buried Vulnerabilities</b><br><br>下面这个请求是 Ebay 的一个端点上的HTTP请求，以前被用作 PHP 的代码注入，那么扫描器该从何处加载 payload?<code lang="text">GET /search/?q=david HTTP/1.1
Host: sea.ebay.com.sg
User-Agent: Mozilla/5.0 etc Firefox/49.0
Accept: text/html
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://sea.ebay.com.sg/
Cookie: session=pZGFjciI6IjAkLCJlx2V4cCI6MTA4
Connection: close</code><p>很明显的加载地点是参数’q’，但是并没有起作用，同样也不是 Referer，User-Agent 或者是 Session cookie。一个经验丰富的测试者可能会尝试在不曾出现过的 headers 中加载 payload，例如 Origin，X-Forwarded-For 或者是 X-Forwarded Host。这些 headers 没有一个起作用的，而扫描器扫描到这个地步时，已经发送了大量的 payload 且都没有成功，David Vieira-Kurz 发现有可能可以通过传入第二个参数在此端点形成代码注入，通过创建一个服务端的恶意数组</p><code lang="text">GET /search/?q=david&amp;q[1]=sec{${phpinfo()}}</code><p>他之所以尝试这种攻击方式时因为参数 q 会引起一个具有拼写检查，关键字过滤的搜索功能，这提供了一个线索表明了服务端会发生一些有趣的事情。在这里，我们再次遇到一个漏洞，即只有扫描器对每个端点可能发送的有效载荷数量没有限制（或者可以说是检测到的拼写检查器），才能检测到。这是一个比较极端的例子，但是其他很少有用的 header 比如 Accept-Language 处的漏洞也很可能被遗漏。</p></li></ol><br><h2><b>另一种扫描方式</b></h2><p>在这一点上你该知道如何让应用程序或多或少的做到防扫描；只需要使用不出名的 web 语言编写代码，将数据与非标准语法的 NoSQL 变体存储在一起，在上面分层覆盖 WAF。</p><p>那么手工测试者时如何避开这些盲点的？最根本的区别是他们对于无用、有趣、可疑或者有效输入的概念。David Vieira-Kurz 的观察指出一个具有拼写检查功能的输入点会直接导致他的广泛审计，可能这会在你的正常输入中浪费时间。</p><p>我们可以从中学到，相比起扫描漏洞，我们需要的是扫描那些有趣的行为。接着，我们可以进一步调查以确认产生这些有趣行为的极小部分的输入。这种识别漏洞的迭代方法在漏洞确实存在时非常的灵活和高效。不会产生任何有趣行为的输入被快速的忽略掉，为持续调查更有希望的输入节省时间，形成一个部署探针-扫描比对-结果研究的循环：</p><img src="https://pic1.zhimg.com/v2-3de0995ac208e3bdb92f38a0620af4b0_r.png"><br><h2><b>可疑的输入转换</b></h2><p>用于探测可疑行为的初始检测应该尽可能的简单和通用。例如如下用于利用 FreeMarker SSTI的 payload：</p><code lang="text">&lt;#assign ex="freemarker.template.utility.Execute"?new()&gt; ${ex("id")}</code><p>这可以很轻易的回滚成一个更为通用的 payload 用以检测大多数利用了流行语法的模板引擎：</p><code lang="text">${7*7} (expect 49)</code><p>如何扩大用于检测通用代码的覆盖范围？作者尝试了如下方法：</p><code lang="text">7*7 (expect 49)</code><p>但其仅能够适用于数字输入。为了检测字符串的注入，可以这样做：</p><code lang="text">\x41 (expect A)</code><p>然而很多语言，特别是包括 SQL，并不支持 Hex 转义。那下面这个探针则可以做到更一步的通用，基本支持所有的语言：</p><code lang="text">\\ (expect \)</code><p>在这一点上作者首先探测出可疑的输入变换。接着进入到扫描阶段的开发过程，在大量的应用程序中尝试这种 payload 看看会发生什么。如果探针是有效的且试验台足够大（稍后讲解），那么将会得到一组适当大小的结果，从而手动调查并从中发现有趣有用的东西。</p><p>这种情况下，第一步去理解应用程序的行为是为了寻找出其他的输入变换，例如 \x41=&gt;A。通过对比应用程序对已知的不良字符和其他字符的处理方式，可以获得一些微妙的线索，知道在服务端哪些字符具有特殊的意义。例如，以\zz为基线，可以很轻易的发现异常：</p><code lang="text">\zz =&gt; \zz

 \" =&gt; \"
 \$ =&gt; \$
 \{ =&gt; {
 \x41 =&gt; \x41</code><p>上面这组测试说明了“{”这个字符具有特殊的意义。通过多次重复和完善探测的过程，可以循环成一个‘实施’阶段，自动化实行。下面这张扫描器截图展示一个易受到 Markdown 注入的页面的输出情况：</p><img src="https://pic1.zhimg.com/v2-63540bf7823bde3839b1530d266a8797_r.png"><p>这是一个没有什么薄弱点的页面，只不过是在输入上调用了 stripslashes() (注释：用于删除反斜杠)<br></p><img src="https://pic1.zhimg.com/v2-e30f60342a271510aa4b8c49b983a17d_r.png"><p>这种自动化跟进意味着我们将一目了然的知道端点的可利用性。潜在的进一步优化是对具体转换的指纹的识别与分类。</p><p>值得注意的是即使这种技术有能力检测出大量的脆弱点，在大部分输入上，它只会发送一次单独的请求。这种灵活性和效率性的组合是迭代扫描的核心。</p><p>如果你意识到（或者能构建）目标是明显存在问题的，则可以验证扫描器的误报率。作者发现扫描器无法识别 JSON 响应中的漏洞，因为虽然服务端会将\\解码成\，但是当其被嵌入 JSON字符串的时候会重新从\转义成\\。通过在适当的地方进行 JSON 解码响应很容易能解决这个问题。</p><p>不幸的是，还有一个更为严重的弱点。这种扫描方式依赖于用户的输入被处理后展示出来。例如，如果一个应用程序将用户的输入拼接一个 SQL 的 SELECT 语句中，但是并不会显示该查询，这个漏洞将会被完全忽视掉。这是一个最根本的缺陷，依赖于可疑的输入转换来检测漏洞。</p><h2><b>Probe-Pair Fuzzing</b></h2><ol><li><b>核心逻辑</b><br><br>我们可以通过分析整个响应内容和判断我们的输入是否造成了明显的变化来避免依赖于输入转换。在最基本的情况下，这与经典的 webapp fuzzer 非常的相似（在应用程序中提供输入来查看是否崩溃），并且很多渗透测试者都很熟悉适用 Burp Intruder 和 fuzzlists 来实现部分自动化。他们并不会局限于只是查看自动扫描结果的状态码和检查错误信息，而是将细微到某个单独的单词或者空白行的消失都当作是一种变化。<p>就像手工测试者一样，我们可以利用探针来获取更多的信息。首先，我们通过发送包含随机字母数字字符的探针来识别出应用程序正常的响应。这将会被当作是一个基准响应。如果携带’的探针获得的响应始终与基准响应不同，那么就可以断定’这个字符对于应用程序来说有着特殊的意义。但这并不表明就是一个漏洞，或许只是因为应用程序拒绝携带’的输入。再次的，我们可以利用 backslashes 来摆脱这个困境。如果应用程序对于携带\’的探针的响应与随机字母数字的探针响应相同，我们便可以断定对于’的异常响应是因为未能逃逸。下面的图可能更有意义。笑脸和哭脸分别代表了 ’interseting’ 和 ’boring’ ：<br><img src="https://pic1.zhimg.com/v2-afb7fc8bafee2c63e2d6ad7138105b80_r.png"><br>这种技术并不仅局限于识别字符串的注入。我们还可以通过替换探针来识别其他各种环境的注入。每一种额外的探针都只需要几行代码，所以我们已经在使用不少的代码了：</p><code lang="text">' vs \' // single-quoted string
' vs '' // single-quoted string (alternative escaping)
" vs \" // double-quoted string
7/0 vs 7/1 // number
${{ vs $}} // interpolation
/**/ vs /*/ // raw code
,99 vs ,1 // order-by
sprintz vs sprintf // function name</code><p>我们还可以通过很多探针的共同使用迭代搜集一个潜在漏洞的信息。当遇到一个字符串注入时，Backslash Powered Scanner 将首先识别正在使用的引号，接着是字符的连接方式，识别可能的函数调用，最后发送一组特定语言的函数尝试来识别后端语言。下面的一个截图展示了一个指出了有 Javascript 注入漏洞的应用程序的扫描输出。注意，每个阶段获取的信息都被用于下个阶段。<br><img src="https://pic1.zhimg.com/v2-8821bbb90fcd3fd43f67d970d3d97e0b_r.png"><br>即使扫描器无法识别确切的漏洞，它依然会报告漏洞：它仅显示所有成功的探针。这意味着它有效的将输入分成三类:’boring’(没有问题存在的)，’vulnerable’（一种显然存在漏洞的已知语言）,’interseting’（很多探针成功，应用程序容易受到未知问题的影响）。<br></p><br></li><li><b>类型的变化</b><br>应用程序以两种不同方式之一来处理修改后的输入。大多数输入容易受到服务端注入的影响，特别是那些来源于于自由文本格式的输入，例如评论，只有当触及语法错误时服务端才会显示不同的响应：<code lang="text">/post_comment?text=baseComment 200 OK
/post_comment?text=randomtext 200 OK
/post_comment?text=random'text 500 Oops
/post_comment?text=random\'text 200 OK</code><p>其他的输入上，任何与预期输入不同都会引起一个错误：</p><code lang="text">/profile?user=bob 200 OK
/profile?user=randomtext 500 Oops
/profile?user=random'text 500 Oops
/profile?user=random\'text 500 Oops
/profile?user=bo'||'b 200 OK
/profile?user=bo'|z'b 500 Oops
</code><p>后一种情况很难处理。为了找到这样响应的漏洞，我们需要跳过引号识别阶段并且猜测字符的连接方式以找出漏洞的证明，这使扫描器效率更低。由于无法将随机文本放入探针中，我们被限制在一定数量的唯一探针，使得可靠的指纹识别响应变得更加困难。在写这篇文章时，扫描器还不会处理这种情况。</p><p>这种限制不适用于检测数字注入的输入 -- 给定了一个基数，使用简单的算术有无数的方式能够表达相同的数目。我选择x/1和x/0，因为除以零的好处时会在某些情况下抛出异常。</p><br></li><li><p><b>识别有意义的响应差异</b><br>这种技术的核心问题是识别应用程序对两个不同探针的响应是否一致。只是一个简单的字符串的比较在整个应用程序中是没有什么作用的，因为应用程序本身就是动态的。响应中充满了动态生成的一次性令牌，时间戳，缓存以及对输入的响应。</p><p>作者三年前遇到这个问题时，他意识到响应是由静态的内容和动态的 ’fuzzy points’ 共同组成独。因此，作者尝试用一组响应来生成一个正则表达式，将静态的内容与通配符拼接到一起。为了简洁起见，作者只提及了这种方法的一些小问题。最开始，计算密集度，作者使用的最长公共子序列的实现是 O(n2)；处理响应花费的时间与响应长度的平方成正比。正则表达式通常十分复杂，因此扫描到错误的应用程序会导致扫描器停止工作。它也无法处理和正则完全不同的应用程序响应，也无法处理顺序改变的响应。甚至响应中的时间戳也引起了困难，因为有些时间戳每10，60或者100秒才会产生改变。最后，调试起来非常困难，因为响应内容与500多行的正则表达式不匹配的原因很难确定。这些问题听起来好像都可以解决，但是作者尝试解决他们这也是为什么扫描器代码在两年前没有放出来。</p><p>相反的，Backslash Powered Scanner 使用更简单的方法计算每个响应的属性值，并注意到响应中的哪些属性没有发生变化。其中包括状态码，content type，HTML 结构，行数，单词数，输入的处理数量以及各种关键字的出现频率。</p></li></ol><h2><b>Hunting Findings</b></h2><ol><li><b>分布式扫描系统</b><br><br>为了保证扫描器在扫网站的时候不会出现发包过快导致 IP 被屏蔽的问题，以及扫描时超出授权的测试范围，我需要限制它每3秒向一个网站发送一个请求，但 Burpsuite 只支持线程调节，为此，我又写了一个扩展，用于实现分流，也就是前面说的功能，它可以在不同的主机上交叉扫描，提供整体扫描速度，又不被屏蔽。还有就是可以只扫描不常用的参数等。</li><li><b>样本结果</b><br><br>为了说明扫描器所提供的发现的漏洞类型以及如何阐述他们，作者将检查一组选定的扫描结果。这或许会帮助我们理解为什么 Backslash Powered Scanner 相比起像一个漏扫，更像是一个技术理解有限的助理。</li><ol><li> Mysql injection <br><br>以下结果来源于一个User-Agent头存在SQL注入的站点：<code lang="text">Basic fuzz (\z`z'z"\ vs \`z\'z\"\\)
Content: 5357 vs 5263

String - apostrophe (\zz'z vs z\\\'z)
Content: 5357 vs 5263

Concatenation: '|| (z||'z(z'z vs z(z'||'z)
Content: 5357 vs 5263

Basic function injection ('||abf(1)||' vs '||abs(1)||')
Content: 5281 vs 5263

MySQL injection ('||power(unix_timestanp(),0)||' vs '||power(unix_timestamp(),0)||')
Content: 5281 vs 5263</code><br>扫描器识别出输入是’interesting’，并且通过注入一个只存在于 Mysql 中的函数正确的识别出了漏洞。’Content:5357 VS 5263’这样的一行是用来表示扫描器对比了两个结果。在这个例子里，两个响应中单词的数目是不同的。当这么多数量的证据显现出来时，那么问题就不太可能是假的。<br></li><li>存在过滤的 code injection<br><br>下面这个例子来源于一个已经经过多次测试的网站，这将充分展现扫描器的能力：<code lang="text">String - doublequoted (\zz" vs \") 
error: 1 vs 0 
Content: 9 vs 1 
Tags: 3 vs 0 

Concatenation: ". (z."z(z"z vs z(z"."z) 
error: 1 vs 0 
Content: 9 vs 1 
Tags: 3 vs 0 

Interpolation - dollar (z${{z vs }}$z) 
error: 1 vs 0 
Content: 9 vs 1 
Tags: 3 vs 0</code><p>这是一个容易受到 PHP 代码注入的点，但是应用程序过滤了括号。因为括号被过滤，所以扫描器就无法注入一个函数，但是可以一点一点的手工测试尝试执行任意的shell命令。</p><p>作者认为这样的问题被之前的渗透测试人员忽略可能是因为注入点在文件路径处，这不是一个手工测试者会花费大量时间测试代码执行的地方。但为什么应用程序会在一个路径上调用 eval()，这就不得而知了。</p><br></li><li><p>以前存在过的漏洞<br><br>以下的发现表明当前状态的 sea.ebay.com 站点上的输入是很容易受到 PHP 代码执行攻击的。可以清晰的看到应用程序对携带“{”的输入所产生的完全不同的响应。<br><img src="https://pic1.zhimg.com/v2-7cb04e207cce4631e7687da49d6c695b_r.png">值得注意的是响应状态与测试者预期的情况完全不同，应当使服务器报错的${{z却使200的状态，而本应该无害的字符却导致了500的错误。搜索功能虽然损坏了，但是扫描器却能给我们一个信息，就是这儿以前可能存在这样的漏洞。因为扫描器具有极高的效率，因此在每一个输入点上都尝试 PHP 的 bypass 序列是完全合理的。<br></p></li><li>正则表达式注入<br><br>扫描器经常会报告很多正则表达式注入，这是一个低危漏洞，它可以干扰应用程序的运行，严重时可能会导致拒绝服务。但有一个例外的是，当服务器上的 PHP 版本低于5.4.7时，利用<a href="https://bitquark.co.uk/blog/2013/07/23/the_unexpected_dangers_of_preg_replace" data-title="null byte to specify the 'e' flag" class="" data-editable="true">null byte to specify the 'e' flag</a>，这个注入将会升级为任意代码执行。这个技术被用来<a href="https://www.phpmyadmin.net/security/PMASA-2016-27/" data-title="攻击过phpmyadmin" class="" data-editable="true">攻击过phpmyadmin</a>，作者证实了扫描器能找到这种漏洞，通常的报告如下：<code lang="text">Diffing scanner:
Backslash (\ vs \\)

Transformation Scanner:
\0 =&gt; Truncated 
\1 =&gt; Truncated 
\$ =&gt; &gt;nbsp;
$ =&gt; $</code><p>\0经常被用于识别正则表达式注入。</p><code lang="text">GET /folder?q=foo\0bar HTTP/1.1

HTTP/1.1 301 Moved Permanently
Location:
https://redacted.com/folder/?q=foohttp://redacted.com/folder/bar</code></li><li>Escaping Flaws<br><br>扫描器发现了一个有趣却无用的缺陷，一个流行框架将输入放入了 cookie 中：<br><code lang="text">foo"z: Set-Cookie: bci=1234; domain="foo\"z";
foo\: Set-Cookie: bci=1234; domain="foo\";
foo"z\: 500 Internal Server Error</code>这个框架是非常受欢迎的，作者添加了新的探针来跟进分类这个问题，让其余的测试者可以不用在这个上浪费时间：<br><code lang="text">Basic fuzz  (\z`z'z"\ vs \`z\'z\"\\)
    exception: 1 vs 0
 Doublequote plus slash  (z"z\ vs z\z)
    exception: 1 vs 0</code></li><li> Semantic False Positives<br><br>利用一个构造的词来测试功能注入：<br><code lang="text">Function hijacking (sprintg vs sprintf) 
&lt;div: 13 vs 14</code><br>URL: <a href="https://code.google.com/hosting/search?q=sprintg" class="">https://code.google.com/hosting/search?q=sprintg</a>显而易见存在这个问题，参数 q用来搜寻一个很大的 codebase ，其中 ’sprintf’ 是比 ’sprintg’ 更为常用的术语。搜索功能经常被扫描器列为优先搜索，特别是那些支持高级语法的功能，他们很多时候和代码执行很相似。<br><br></li><li> 应用程序防火墙<br><p>应用程序防火墙对于为扫描器提供了另一种 ’interesting’ 输入的识别。扫描器发现内联注释的代码被防火墙所忽略：</p><code lang="text">0/**z'*/ vs 0/*/*/z'*/</code><p>手工测试显示，即使被 HTML 注释，iframe 还是能识别</p><code lang="text">0&lt;!--foo--&gt; vs 0&lt;!--foo-&gt;
0&lt;iframe&gt; vs 0&lt;zframe&gt;</code><p>看起来好像是防火墙为了删除有害的 HTML 标签和注释而重写了输入。输入重写能很好的使 xss 过滤器失效。像之前一样，我们自动化跟进 HTML 注释，防止在测试中再次遇到这样的 WAF。</p></li><li>SOLR JSON Injection<br><br>扫描器标记了很多搜索功能的有趣行为:<code lang="text">Basic fuzz (\z`z'z"\ vs \`z\'z\"\\) 
Content: 1578 vs 1575 
Backslash (\ vs \\) 
Content: 1576 vs 1575 
String - doublequoted (\zz" vs \") 
Content: 1578 vs 1575</code><p>手工测试显示应用程序会解码输入的 UNICODE -即查找\u006d\u0069\u0072\u0072\u006f\u0072和查找’mirror’是一样的结果。这表明用户的输入没有经过转义直接进入到了 json 里面，这样的话我们就有可能突破查询字符串并更改查询结构。</p><br></li></ol></ol><br><h2><b>得到的教训</b></h2><p>这些例子都清晰的表明，迭代过程是非常重要的，这意味着测试者可以一目了然的将一个明显的问题和需要多次验证的问题进行区分。目前，搜索功能，WAF 和正则表达式注入还有待发展，暂时不会导致任何有利用价值的漏洞。由于探针的灵活性，我们几乎可以将以后遇到的各种问题都加入到探针中进行自动化跟进分类。</p><p>扫描器还能获得很多有用的信息，虽然有些并不会导致漏洞。</p><p>很多应用程序上的漏洞都被 WAF 所防御，因为 payload 的简洁性导致他们往往会被检测，但是作者发现 WAF 会忽略一些来自可信 IP 的数据，因此作者尝试了分布式发包来使得办公室的IP 不会被 ban。</p><h2><b>后续研究</b></h2><p>扫描器所使用的技术和代码已经能够检测远超服务端注入的漏洞。作者将继续尝试让扫描器识别 WAF 和搜索功能。</p><h2><b>结论</b></h2><p>经典扫描器在扫描服务端的注入漏洞时存在着几个盲点。通过对手工测试方式的模拟，开发了一款能够避免这些盲点并且十分高效的扫描器。这款扫描器目前将输入分为 ’boring’, ’interesting’ 和 ’vulnerable’ 三种情况。’interesting’ 需要测试者手动检查，因此，目前这个扫描器仅适用于安全从业者。但是，随着时间的推移，更多的 ’interesting’ 将会慢慢变为 ’vulnerable’，这款扫描器将会适用于更为广泛的用户。</p><h2><b>Burpsuite 中开启反斜线探索式扫描</b></h2><p>在 BApp Store 中直接安装「Backslash Powered Scanning」这个扩展，其它情况可以参考扩展的开源地址的安装方式：<a href="https://github.com/portswigger/backslash-powered-scanner#installation" data-editable="true" data-title="PortSwigger/backslash-powered-scanner" class="">PortSwigger/backslash-powered-scanner</a>。</p><p>安装好之后我们只需要开启代理，访问需要测试的站点，再到「Target」中对目标站点开启「Acitvely scan this host」也就是主动扫描即可进行测试。</p><p><img src="https://pic1.zhimg.com/v2-1952596ec01945f7952ef42334c85023_r.png" data-rawwidth="395" data-rawheight="142">开启扫描后，我们打开「Scanner 」模块，如果出现 Interesting 开头的的 Issue，就表示这可能是一个有趣的漏洞了，Boring  则表示扫描器认为没什么用但符合扫描特征，而 Vuln 就是说扫描器已经验证是漏洞了。<br></p><h2><b>参考链接：</b></h2><a href="https://github.com/portswigger/backslash-powered-scanner" data-editable="true" data-title="PortSwigger/backslash-powered-scanner" class="">PortSwigger/backslash-powered-scanner</a><a href="https://github.com/portswigger/backslash-powered-scanner" data-editable="true" data-title="PortSwigger/backslash-powered-scanner" class=""><br></a><a href="http://blog.portswigger.net/2016/11/backslash-powered-scanning-hunting.html" class="" data-editable="true" data-title="Backslash Powered Scanning: Hunting Unknown Vulnerability Classes">Backslash Powered Scanning: Hunting Unknown Vulnerability Classes</a>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
