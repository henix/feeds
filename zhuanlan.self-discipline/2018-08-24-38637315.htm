<p></p><img src="https://pic2.zhimg.com/v2-75e143d489da7f3868b15af2d84ebd0d_r.jpg" data-caption="" data-size="normal" data-rawwidth="1595" data-rawheight="900" data-watermark="watermark" data-original-src="v2-75e143d489da7f3868b15af2d84ebd0d" data-watermark-src="v2-94f0f95a75186f4260363dff8dc3acb8" data-private-watermark-src=""><h2><b>1. 通用图灵机</b></h2><p><b>代码</b>可以看做储存在磁盘上的，一种特殊类型的<b>数据</b>，<br>计算机读取到这些代码之后，就会模拟代码所描述的行为，<br>再针对不同的输入完成不同的动作。</p><p>这一过程的理论模型，称为<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%9C%96%E9%9D%88%E6%A9%9F">通用图灵机</a>。</p><img src="https://pic1.zhimg.com/v2-f6d3de05c5484e0cbd33c65f70130bb5_r.jpg" data-caption="" data-size="normal" data-rawwidth="410" data-rawheight="429" data-watermark="watermark" data-original-src="v2-f6d3de05c5484e0cbd33c65f70130bb5" data-watermark-src="v2-afc3d01562b27b4881c6e590dd9e54ab" data-private-watermark-src=""><p>和<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机</a>不同的是，</p><p>图灵机，是一台<b>固定的</b>计算机器，根据输入计算结果，<br>而<b>通用图灵机</b>，则可用来模拟不同的图灵机，因此它有两个输入。</p><p>一个是被模拟的图灵机计算过程之<b>编码</b>，另一个则是被模拟图灵机的<b>原始输入</b>，<br>最终，通用图灵机会得到被模拟图灵机的计算结果。</p><p>因此，代码可以被当做数据来看待。<br>反之亦然。</p><p><a href="https://en.wikipedia.org/wiki/Interpreter_pattern">解释器模式</a>就是这种思想的一个应用，<br>实际工程中，我们会对配置信息或<a href="https://zh.wikipedia.org/zh-hans/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80">DSL</a>进行解析，<br>还原出它们所描述的计算行为。</p><h2><b>2. 描述层次</b></h2><p>对于大部分编程语言的代码而言，有一个比较好的性质，<br>那就是，我们有一定的活动空间，对代码进行<b>重新组织</b>，<br>却不会改变它们（被关心）的外部行为。</p><p>这正是<a href="https://zh.wikipedia.org/zh-hans/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84">代码重构</a>的可行性基础。</p><p>在代码的组织方式上，不同人会有不同的办法，<br>但区分出不同的<b>描述层次</b>，应当会是一项良好的编程实践，<br>提升描述层次的过程，在计算机科学中，通常被称为<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">抽象</a>。</p><img src="https://pic1.zhimg.com/v2-9df090cf50960f3072a1d18ebd81ce35_r.jpg" data-caption="" data-size="normal" data-rawwidth="500" data-rawheight="360" data-watermark="watermark" data-original-src="v2-9df090cf50960f3072a1d18ebd81ce35" data-watermark-src="v2-4a7ab78d1395f9c62b1bbe32869690aa" data-private-watermark-src=""><blockquote>管理计算机系统复杂性的关键是通过一些定义明确的接口把计算机系统分成不同的抽象层次。<br>抽象层次允许忽略或简化系统设计的底层实现细节，从而简化高层组件的设计。<br>—— 《<a href="https://book.douban.com/subject/3611865/">虚拟机-系统与进程的通用平台</a>》</blockquote><p>实际操作中，接口也是用编程语言来书写的，<br>因此，程序员首先面对的是<b>语言</b>，其次是理解语言背后被描述的下一层事实。</p><p><b>配置</b>也是一种语言形式，只不过它很少提供<b>抽象机制</b>。<br>这样的话，我们就很难对配置信息进行<b>指代</b>，不利于控制复杂度。</p><h2><b>3. 不可判定性</b></h2><p><a href="https://www.w3.org/2001/tag/doc/leastPower">The Rule of Least Power</a>指出了与编程语言相关的一项原则，</p><blockquote>Powerful languages inhibit information reuse.</blockquote><p>对于<a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7">图灵完备</a>的计算模型，<br>其结果是<a href="https://zh.wikipedia.org/zh-hans/%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7">不可判定</a>的，<br>得到结果的唯一的办法，是将它运行一遍。</p><p>一种<a href="https://zh.wikipedia.org/zh-hans/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B">计算模型</a>越强大，就越难<b>预测</b>它的行为。</p><img src="https://pic4.zhimg.com/v2-7c734c358842ded3d665993bbd34ed50_r.jpg" data-caption="" data-size="normal" data-rawwidth="548" data-rawheight="426" data-watermark="watermark" data-original-src="v2-7c734c358842ded3d665993bbd34ed50" data-watermark-src="v2-c7fad5bc4f4a54641bbe5df44ca45a14" data-private-watermark-src=""><p>如果我们<b>有幸</b>发明了一种足够强大的<a href="https://zh.wikipedia.org/zh-hans/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80">领域特定语言</a>，<br>那么在判定它的运行时特征时，就会遇到麻烦，<br>如果没有完整的测试用例来保障，部分错误就不得不<b>在用户使用时</b>才显现出来。</p><p>因此，在决定设计DSL之前，不妨先考虑一下，<br>我们可以对它进行哪些<b>静态检查</b>以避免用户犯错。</p><h2><b>4. 新语言问题</b></h2><p>随着用户需要的<b>语言特性</b>被不断添加，<br>语言障碍会变得越来越明显，称为<a href="http://www.yinwang.org/blog-cn/2017/05/25/dsl">新语言问题</a>，<br>极大的增加了用户的<b>学习成本</b>。</p><img src="https://pic3.zhimg.com/v2-7630846cdf1ecfaa62422919ca5242e4_r.jpg" data-caption="" data-size="normal" data-rawwidth="600" data-rawheight="400" data-watermark="watermark" data-original-src="v2-7630846cdf1ecfaa62422919ca5242e4" data-watermark-src="v2-b3cc10c892141ac2b186fc4099a4109d" data-private-watermark-src=""><p><b>灵活是要有代价的。</b></p><blockquote>就像一个平衡游标，一端是只有单一用途的软件，而且工作得很好，但很难或根本无法改变它的行为。<br>然而另一端则是编程语言，你可以用它编写游戏，应用服务器或股票管理系统，这就是灵活性。<br>显然，大多数软件都在两点之间，而不是这两端点中的任何一个。<br>—— 《<a href="https://book.douban.com/subject/6862062/">持续交付</a>》</blockquote><p>况且，用户可能并不需要<b>灵活性</b>，而是不想受到不该有的<b>限制</b>，<br>用户也不想写配置文件，更不想用DSL进行编程，他们想要的是<b>功能</b>，<br>因此我们还是将<b>键盘</b>从用户那里拿回来吧。</p><p>也许只有当我们自己写配置文件的时候才会发现，<br>它们与一些<b>难以维护</b>的晦涩代码，并没什么太大区别。</p><h2><b>5. 傻瓜式框架</b></h2><p>让系统可配的另一个动机是，让无法胜任<b>设计</b>工作的人员，也有能力进行开发。</p><p>然而，《<a href="https://book.douban.com/subject/5344973/">领域驱动设计</a>》一书中这样强调，</p><blockquote>如果这些人在设计方面不够聪明，就不应该让他们来开发软件。<br>如果他们足够聪明，那么用『傻瓜式』的框架来应付他们只会为他们造成障碍，使他们得不到所需的工具。</blockquote><img src="https://pic4.zhimg.com/v2-13d34e35301b69a7800c8f393045572d_r.jpg" data-caption="" data-size="normal" data-rawwidth="302" data-rawheight="339" data-watermark="watermark" data-original-src="v2-13d34e35301b69a7800c8f393045572d" data-watermark-src="v2-95081944fc2b769931482f19ea1934b3" data-private-watermark-src=""><p><b>消除重复劳动</b>的软件开发宗旨，会终结在傻瓜式框架的边界上。<br>因为未经良好构思的框架，并没有仔细考虑<b>如何解决用户的重复操作问题</b>，<br>所以，本可避免的重复劳动，就这样转移到了<b>框架用户</b>的日常工作之中，<b>制造了重复劳动</b>。</p><p>这样做到底划不划算，值得深思。</p><h2><b>结语</b></h2><p>让系统可配置，或者采用领域特定语言，是一种很好的实践，<br>但是一旦构思不当，所<b>带来的问题</b>就会比它要解决的问题还要多。</p><p>其主要原因在于，未经深思熟虑的配置以及DSL，<b>会限制用户的表达能力</b>，<br>这也是另外一个从模式的<b>使用者</b>角度评判设计优劣的例子。</p><hr><h2><b>参考</b></h2><p><a href="https://www.w3.org/2001/tag/doc/leastPower">The Rule of Least Power</a><br><a href="https://book.douban.com/subject/4262627/">重构：改善既有代码的设计</a><br><a href="https://book.douban.com/subject/1052241/">设计模式</a><br><a href="https://book.douban.com/subject/6862062/">持续交付</a><br><a href="https://book.douban.com/subject/5344973/">领域驱动设计</a><br><a href="https://book.douban.com/subject/1310925/">可计算性与计算复杂度导引</a><br><a href="https://book.douban.com/subject/2179488/">形式语言与自动机理论</a><br><a href="https://book.douban.com/subject/3611865/">虚拟机-系统与进程的通用平台</a></p>