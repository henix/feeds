<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>你好，类型（七）：Recursive type</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34861374">原文</a></p>
<p></p><img src="https://pic1.zhimg.com/v2-052f4243204bd6731d6fe46e0070730e_r.jpg" data-caption="" data-size="normal" data-rawwidth="720" data-rawheight="380"><p>上文我们介绍了简单类型化 <equation>\lambda</equation> 演算系统 <equation>\lambda^\to</equation> ，并给它扩充了单位类型，<br>本文继续为它添加新的特性。</p><p>我们将提到<code class="inline">let</code>和<code class="inline">letrec</code>表达式，函数的不动点，<br>代数数据类型，以及递归类型。</p><p>最后我们发现，无类型系统实际上是具有，唯一递归类型的一种情形。</p><h2><b>let绑定</b></h2><p>当写一个复杂表达式的时候，为了避免重复和增加可读性，<br>通常我们会给某些子表达式命名，其中一个常用办法是，使用<b><code class="inline">let</code>表达式</b>。</p><p>为此，我们要对简单类型化 <equation>\lambda</equation> 演算系统 <equation>\lambda^\to</equation> 进行扩展，<br>添加<code class="inline">let</code>表达式的语法项，求值规则以及类型规则。</p><p><b>新的语法：</b></p><p><equation>t::=...|let~x:T=t~in~t</equation> </p><p><b>新的求值规则：</b></p><p><equation>let~x:T=v~in~t\to [x\mapsto v]t</equation> <br><equation>\frac{t_1\to t'_1}{let~x:T_1=t_1~in~t_2\to let~x:T_1=t'_1~in~t_2}</equation> </p><p><b>新的类型规则：</b></p><p><equation>\frac{\Gamma\vdash t_1:T_1~~~~\Gamma,x:T_1\vdash t_2:T_2}{\Gamma\vdash let~x:T_1=t_1~in~t_2:T_2}</equation> </p><p>这样我们就可以写出<code class="inline">let</code>表达式了， <equation>let~x:T_1=t_1~in~t_2</equation> ，<br>它表示，求值表达式 <equation>t_1</equation> ，然后将其绑定到 <equation>t_2</equation> 中自由出现的 <equation>x</equation> 上面，<br>即在当前这种情况下（顾及<a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Let-polymorphism">let polymorphism</a>），<code class="inline">let</code>可以表示为， <equation>(\lambda x:T_1.t_2)t_1</equation> 。</p><h2><b>不动点</b></h2><img src="https://pic3.zhimg.com/v2-6cfcb32e2362408c47cd0d6629e1f93f_r.jpg" data-caption="" data-size="normal" data-rawwidth="264" data-rawheight="191"><p>以上<code class="inline">let</code>表达式， <equation>let~x:T_1=t_1~in~t_2</equation> ，<br>对 <equation>t_1</equation> 求值的时候有一个限制，那就是 <equation>t_1</equation> 中不能出现 <equation>x</equation> ，<br>否则就像方程一样， <equation>x</equation> 出现在了等式的两边， <equation>x=t_1(x)</equation> ，<br>此时， <equation>t_2</equation> 中自由出现的 <equation>x</equation> ，将是这个方程的解。</p><p>不过，通常而言， <equation>t_1</equation> 中是可以出现 <equation>x</equation> 的，这时候我们就需要使用<code class="inline">letrec</code>进行绑定了。</p><p>为了看清<code class="inline">letrec</code>的真面目，我们用一个求阶乘的例子来说明问题，<br> <equation>letrec~f:nat\to nat=\lambda y:nat.(if~Eq?~y~0~then~1~else~y*f(y-1))~in~f~5</equation> <br>其中， <equation>nat</equation> 表示整数类型。</p><p>为了求解 <equation>f=\lambda y:nat.(if~Eq?~y~0~then~1~else~y*f(y-1))</equation> ，<br>我们定义一个新函数 <equation>F</equation> ，使得，<br> <equation>F=\lambda f:nat\to nat.\lambda y:nat.(if~Eq?~y~0~then~1~else~y*f(y-1))</equation> ，<br>注意到 <equation>f=F(f)</equation> ，所以 <equation>f</equation> 是 <equation>F</equation> 的<b>不动点</b>。</p><p>这里我们暂且不讨论不动点的存在性和唯一性问题，<br>只是引入一个不动点算子， <equation>fix_\sigma:(\sigma\to\sigma)\to\sigma</equation> ，<br>它可以用来计算任意函数 <equation>F:\sigma\to\sigma</equation> 的不动点。</p><p>为了达到这个目的， <equation>fix_\sigma</equation> 必须满足以下约束条件， <equation>fix_\sigma=\lambda f:\sigma\to\sigma.f(fix_\sigma f)</equation> 。</p><p>引入了 <equation>fix_\sigma</equation> 之后，<code class="inline">letrec</code>就可以用<code class="inline">let</code>表示出来了，<br> <equation>letrec~f:\sigma=t_1~in~t_2\Leftrightarrow let~f:\sigma=(fix_\sigma\lambda f:\sigma.t_1)~in~t_2</equation> </p><h2><b>代数数据类型</b></h2><img src="https://pic1.zhimg.com/v2-4f3fd841349e86357a6d5a48a4ef4187_r.jpg" data-caption="" data-size="normal" data-rawwidth="220" data-rawheight="129"><p>在某些编程语言中，可以自定义递归类型，例如在Haskell中，</p><code lang="haskell">data List a = Nil | Cons a (List a)
lst :: List Int 
lst = Cons 1 $ Cons 2 $ Nil</code><p>以上定义采用了递归的方式，定义了一个<a href="https://wiki.haskell.org/Algebraic_data_type">代数数据类型</a><code class="inline">List</code>，<br>所谓代数数据类型，是由基本类型经过复合运算，得来的类型。</p><p>Haskell中，使用<code class="inline">|</code>表示<b>和类型</b>（sum type），<br>而带参数值构造器（value constructor）<code class="inline">Cons</code>，<br>用于表示各参数（<code class="inline">a</code>，<code class="inline">List a</code>）类型的<b>积类型</b>（product type），<br>无参构造器<code class="inline">Nil</code>，用来表示<b>单位乘积类型</b>（empty product）。</p><p>（关于函数类型与指数的关系，以后有机会再介绍。）</p><p>和<code class="inline">letrec</code>中的场景相似的是，<code class="inline">List</code>也出现在了等式的两边，<br>于是，我们定义 <equation>\mu t.\sigma</equation> ，表示满足等式 <equation>t=\sigma</equation> 的最小类型，<br>其中， <equation>t</equation> 和 <equation>\sigma</equation> 是类型，且 <equation>t</equation> 通常会在 <equation>\sigma</equation> 中出现。</p><p>因此，以上递归定义的<code class="inline">List</code>类型可以表示为， <equation>\mu\phi.\lambda\alpha.(1+\alpha\times(\phi~\alpha))</equation> </p><p>其中， <equation>\alpha</equation> 表示类型参数<code class="inline">a</code>，<br> <equation>\phi</equation> 是一个函数，用于表示类型构造器（data constructor）<code class="inline">List</code>，<br> <equation>\mu</equation> 算子用来计算类型的不动点。</p><h2><b>无类型<i>λ</i>演算</b></h2><img src="https://pic2.zhimg.com/v2-42709a95436618c777b3032e41fb6eff_r.jpg" data-caption="" data-size="normal" data-rawwidth="337" data-rawheight="76"><p>在无类型 <equation>\lambda</equation> 演算系统 <equation>\lambda_\beta</equation> 中，定义递归类型， <equation>\mu t.t\to t</equation> ，它满足类型等式 <equation>t=t\to t</equation> 。</p><p>这样的话，无类型 <equation>\lambda</equation> 演算系统 <equation>\lambda_\beta</equation> ，就可以无缝的<b>嵌入到</b>一个类型化的系统中去了，<br>该系统只存在一个类型，即递归类型 <equation>\mu t.t\to t</equation> ，<br>所有的项，都具有这个类型。</p><p>因此，对于支持递归类型的系统而言，<br>无类型相当于具有唯一类型（<b>Untyped means uni-typed</b>）。</p><h2><b>总结</b></h2><p>本文介绍了递归类型，引入了两个算子 <equation>fix_\sigma</equation> 和 <equation>\mu</equation> ，分别用来求解函数和类型的不动点。<br>但是，待求的不动点是否存在，是否唯一，我们仍不能确定。</p><p>要想证明这件事情并不简单，需要补充很多额外的数学知识，<br>例如，良基归纳法和最小不动点定理，<br>此外，不动点的存在性，和递归的终止性也有关系。</p><p>好在我们所遇到的大多数场景，都是满足这些要求的，<br>因为，我们总是先确信这个解是存在的，然后再去编程，例如，</p><code lang="haskell">fact :: Int -&gt; Int 
fact 1 = 1
fact n = n * fact (n - 1)</code><p>将<code class="inline">fact</code>写到等式两边，能让我们更方便对<code class="inline">fact</code>进行定义。</p><hr><h2><b>参考</b></h2><p><a href="https://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic data type</a><br><a href="https://en.wikipedia.org/wiki/Empty_product">Empty product</a><br><a href="https://book.douban.com/subject/1761918/">Foundations for programmming languages</a><br><a href="https://book.douban.com/subject/26782198/">Practical Foundations for Programming Languages</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
