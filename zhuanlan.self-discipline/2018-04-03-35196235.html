<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>语言背后的代数学（七）：数学结构</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/35196235">原文</a></p>
<p></p><img src="https://pic4.zhimg.com/v2-27827c397b0021738c85f354a4ac1a29_r.jpg" data-caption="" data-size="normal" data-rawwidth="960" data-rawheight="600" data-watermark="watermark" data-original-src="v2-27827c397b0021738c85f354a4ac1a29" data-watermark-src="v2-4b04610094818b4d074320614025cc4b" data-private-watermark-src=""><h2><b>回顾</b></h2><p>上文我们介绍了Henkin模型，以及它的环境模型条件和组合模型条件，<br>它们分别为合法的 <equation>\lambda</equation> 项和 <equation>CL</equation> 项，找到了对应的语义解释。<br>然而这只是简单类型化 <equation>\lambda</equation> 演算 <equation>\lambda^\to</equation> 的其中一种解释。</p><p>另一种常用的解释方式，建立在范畴论基础之上，称为<b>笛卡尔闭范畴</b>。<br>为了理解这个概念，我们需要补充一些简单的范畴论方面的内容。</p><h2><b>1. 数学结构</b></h2><img src="https://pic4.zhimg.com/v2-15c0afbc750cd718cccc5c687d907251_r.jpg" data-caption="" data-size="normal" data-rawwidth="386" data-rawheight="252" data-watermark="watermark" data-original-src="v2-15c0afbc750cd718cccc5c687d907251" data-watermark-src="v2-548a7f1498a94ad8562175e088793b5b" data-private-watermark-src=""><p>范畴论的研究数学结构的形式化方法，<br>它不考虑具体的数学对象，而是考虑数学对象以及它们之间的联系。</p><p>学习范畴论最好的办法，我认为不宜马上从抽象的概念开始，<br>而是先回到具体的例子上面，找到相似性，<b>理解概念被发明的动机</b>。</p><p>因此，我们要先理解什么是<b>数学结构</b>。<br>后文中，我们会首先介绍最常被提及的群结构，然后再介绍拓扑空间和CPO（完全偏序）。<br>有了这些例子之后，对抽象概念的理解是事半功倍的。</p><h2><b>2. 群结构</b></h2><img src="https://pic4.zhimg.com/v2-c2e40eb216c9642a8ae011d979ebf2f9_r.jpg" data-caption="" data-size="normal" data-rawwidth="268" data-rawheight="272" data-watermark="watermark" data-original-src="v2-c2e40eb216c9642a8ae011d979ebf2f9" data-watermark-src="v2-254492ee31ded3056ba06f187ea2ec1e" data-private-watermark-src=""><p>群是一种满足结合律的乘法结构，<br>但是它的运算对象，却并不局限于整数，有理数甚至实数上。<br>因此，群论对概念采用了不同的定义方式，和初等代数有明显的不同。</p><p>在初等代数中，我们研究的是具体的运算系统，<br>例如，我们会先介绍什么是自然数，然后再介绍自然数上的四则运算。<br>群论则不然。</p><p>它会先抽象的定义满足哪些条件的运算系统是<b>群</b>，<br>然后再去寻找（或证明）具体的运算系统满足这些条件。</p><p>为此，我们先从条件最弱的<b>半群</b>开始，<br>逐渐增加约束条件，最终认识群结构是怎么建立起来的。</p><p><b>半群</b></p><p>集合 <equation>G</equation> 和 <equation>G</equation> 上满足结合律的二元运算 <equation>\cdot</equation> ，所形成的代数结构，叫做<b>半群</b>，记为 <equation>(G,\cdot)</equation> ，<br>半群运算 <equation>x\cdot y</equation> ，也常简记为 <equation>xy</equation> 。</p><p>好在我们<a href="https://zhuanlan.zhihu.com/p/35017879">第二篇</a>中，对“什么是代数”进行了严谨的定义，<br>因此，对这里提到的“代数结构”应该并不陌生，很显然半群是一个代数。</p><p>满足半群条件的例子是非常多的，<br>例如，自然数集以及自然数上的乘法运算，构成了一个半群。</p><p>值得注意的是，集合和运算要放在一起考虑才行，<br>集合包含了运算对象，运算表明了运算对象之间的关系。</p><p><b>幺半群</b></p><img src="https://pic4.zhimg.com/v2-a9acc7bf821b71d3d4bcc269058b8016_r.jpg" data-caption="" data-size="normal" data-rawwidth="174" data-rawheight="164" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>设 <equation>G</equation> 是半群，元素 <equation>e\in G</equation> ，称为半群 <equation>G</equation> 的<b>幺元</b>，如果 <equation>\forall x\in G</equation> ， <equation>ex=xe=x</equation> 。<br>可以证明，如果半群存在幺元，则必定是唯一的。</p><p>幺元常被记为 <equation>1_S</equation> ，或者直接写成 <equation>1</equation> 。<br>具有幺元的半群，称为<b>幺半群</b>，记为 <equation>(G,\cdot,e)</equation> 。</p><p>幺半群的例子，我们可以考虑字符串及其连接运算，在连接运算下，空串是幺元。</p><p><b>群</b></p><p>设 <equation>G</equation> 是幺半群，如果它的每个元素都可逆，我们就称它为<b>群</b>。</p><p>所谓可逆指的是， <equation>\forall g\in G</equation> ， <equation>\exists g^{-1}\in G</equation> ，使得 <equation>gg^{-1}=g^{-1}g=e</equation> ，<br>其中 <equation>e\in G</equation> 为 <equation>G</equation> 的幺元。</p><p>自然数集以及自然数上的乘法运算组成的代数结构，是半群，<br>如果把自然数 <equation>1</equation> 看做幺元，则构成了一个幺半群，但是它不是群。<br>因为，除了 <equation>1</equation> 之外，任何自然数都没有逆元。</p><p>字符串及其连接运算，构成了一个幺半群，但也不是群，<br>因为，没有任何两个非空字符串连接在一起会得到空串。</p><p>下面我们来看一个群的例子。</p><p>如果我们把整数集（包含正负整数）看做运算对象的集合，<br>把整数集上的加法运算看做群定义中的二元运算，<br>整数 <equation>0</equation> 看做加法运算的幺元，则这样的运算系统构成了一个群。<br>因为，每一个整数的相反数，都是它的逆元。</p><p><b>群同态</b></p><img src="https://pic2.zhimg.com/v2-1dad98d538dbb99ed7df169371a75acc_r.jpg" data-caption="" data-size="normal" data-rawwidth="335" data-rawheight="150" data-watermark="watermark" data-original-src="v2-1dad98d538dbb99ed7df169371a75acc" data-watermark-src="v2-74213495efd2725607eb2a55d66bdd8e" data-private-watermark-src=""><p>有了群之后，很自然的一步我们会考虑两个群是否足够相似，<br>这就需要我们找到两个群之间的对应关系。</p><p>设 <equation>(G,\cdot)</equation> 和 <equation>(G',\circ)</equation> 是两个群，我们把映射 <equation>f:G\to G'</equation> 称为<b>群同态</b>，如果 <equation>\forall a,b\in G</equation> ，<br>都有 <equation>f(a\cdot b)=f(a)\circ f(b)</equation> 。</p><p>如果 <equation>f</equation> 是单射，则称 <equation>f</equation> 为<b>单同态</b>，如果 <equation>f</equation> 是满射，则称 <equation>f</equation> 为<b>满同态</b>。<br>如果 <equation>f</equation> 是双射，则称 <equation>f</equation> 为<b>群同构</b>，同构的两个群，记为 <equation>G\cong G'</equation> 。</p><p><b>小结</b></p><p>现在我们理解了半群，幺半群，群，群同态，这些概念放在一起，就是所谓的群结构。<br>结构一般所指的是一些运算规则，或者约束条件。</p><p>为了更好的理解数学结构，<br>下面我们来介绍另一个概念，它来自拓扑学，称为拓扑空间。</p><h2><b>3. 拓扑结构</b></h2><img src="https://pic4.zhimg.com/v2-b19804f92307f61dfa9c884943d0de29_r.jpg" data-caption="" data-size="normal" data-rawwidth="227" data-rawheight="222" data-watermark="watermark" data-original-src="v2-b19804f92307f61dfa9c884943d0de29" data-watermark-src="v2-a7e83ab352c37df599387d19028ac7a2" data-private-watermark-src=""><p>拓扑学，被人们戏称橡皮膜上的几何学，它主要研究在连续变换下保持不变的几何性质，<br>例如，连通性和紧致性。</p><p>这里我们先不展开，主要看一下在拓扑学中是怎么建立数学结构的。</p><p><b>子集族</b></p><p>设 <equation>X</equation> 是一个非空集合， <equation>2^X</equation> 是 <equation>X</equation> 的幂集（所有子集构成的集合），<br>把 <equation>2^X</equation> 的子集（即以 <equation>X</equation> 的一部分子集为成员的集合）称为 <equation>X</equation> 的<b>子集族</b>。</p><p><b>拓扑空间</b></p><p>设 <equation>X</equation> 是一个非空集合， <equation>X</equation> 的一个子集族 <equation>\tau</equation> 称为 <equation>X</equation> 的一个<b>拓扑</b>，如果它满足<br>（1） <equation>X</equation> 和 <equation>\varnothing</equation> 都包含在 <equation>\tau</equation> 中<br>（2） <equation>\tau</equation> 中任意多个成员的并集仍在 <equation>\tau</equation> 中<br>（3） <equation>\tau</equation> 中有限多个成员的交集仍在 <equation>\tau</equation> 中</p><p>集合 <equation>X</equation> 和它的一个拓扑 <equation>\tau</equation> 一起称为一个<b>拓扑空间</b>，记作 <equation>(X,\tau)</equation> 。<br>称 <equation>\tau</equation> 中的成员为这个拓扑空间的<b>开集</b>。</p><p>从定义看出，给出集合的一个拓扑就是规定它的哪些子集是开集。</p><p><b>连续映射</b></p><img src="https://pic3.zhimg.com/v2-974ddbef8443d9229967e11c333ded9c_r.jpg" data-caption="" data-size="normal" data-rawwidth="380" data-rawheight="129" data-watermark="watermark" data-original-src="v2-974ddbef8443d9229967e11c333ded9c" data-watermark-src="v2-36a76bf9d8a466872d8d8133d0cf9ec0" data-private-watermark-src=""><p>设 <equation>X</equation> 和 <equation>Y</equation> 都是拓扑空间， <equation>f:X\rightarrow Y</equation> 是一个映射，<br> <equation>x\in X</equation> ，如果对于包含 <equation>f(x)\in Y</equation> 的每一个开集 <equation>V</equation> ，必存在包含 <equation>x</equation> 的开集 <equation>U</equation> ，<br>使得， <equation>f(U)\subseteq V</equation> ，则我们就说， <equation>f</equation> 在 <equation>x</equation> 处<b>连续</b>。</p><p>如果映射 <equation>f:X\rightarrow Y</equation> 在任一点 <equation>x\in X</equation> 都连续，则说 <equation>f</equation> 是<b>连续映射</b>。</p><p><b>同胚映射</b></p><p>如果 <equation>f:X\rightarrow Y</equation> 是双射，并且 <equation>f</equation> 及其逆 <equation>f^{-1}:Y\rightarrow X</equation> 都是连续的，<br>则称 <equation>f</equation> 是一个<b>同胚映射</b>，简称同胚。</p><p>当存在 <equation>X</equation> 到 <equation>Y</equation> 的同胚映射时，就称 <equation>X</equation> 与 <equation>Y</equation> 同胚，记作 <equation>X \cong Y</equation> 。</p><p>值得注意的是，同胚映射中条件 <equation>f^{-1}</equation> 连续不可忽视，<br>它不能从双射和 <equation>f</equation> 的连续性推出来。</p><p><b>小结</b></p><p>以上我们介绍了拓扑空间，以及两个拓扑空间之间的连续映射，<br>这和群以及两个群之间的群同态是很相似的。</p><p>它们表现出了一种结构上的相似性，<br>范畴论正是看到这种相似性，于是跳出具体的运算系统，<br>例如，它可以考虑群结构与拓扑结构之间的关系。</p><p>接下来我们来介绍CPO（完全偏序）。<br>它在范畴论中，对于摆脱集合论的观念束缚，帮助是很大的。</p><h2><b>4. 完全偏序</b></h2><img src="https://pic4.zhimg.com/v2-532615f76c50c7808ee4c139213ee560_r.jpg" data-caption="" data-size="normal" data-rawwidth="457" data-rawheight="347" data-watermark="watermark" data-original-src="v2-532615f76c50c7808ee4c139213ee560" data-watermark-src="v2-22529599b32d63a83febc0f08d8ad746" data-private-watermark-src=""><p>在《<a href="https://zhuanlan.zhihu.com/p/34604220">递归函数</a>》系列文章中，我们已经介绍过CPO（<a href="https://zh.wikipedia.org/zh-hans/%E5%AE%8C%E5%85%A8%E5%81%8F%E5%BA%8F">完全偏序</a>）的概念了。<br>为了方便与本文中其他概念进行对比，我们再简单的梳理一下。</p><p><b>二元关系</b></p><p>集合 <equation>S</equation> 和 <equation>T</equation> 上的<b>二元关系</b> <equation>R</equation> ，指的是它们笛卡尔积 <equation>S\times T</equation> 的子集， <equation>R\subseteq S\times T</equation> 。</p><p><b>自反性，对称性，反对称性，传递性</b></p><p>一个二元关系 <equation>R\subseteq A\times A</equation> 是<b>自反的</b>，如果 <equation>R(a,a)</equation> 对于所有的 <equation>a\in A</equation> 成立；<br>是<b>对称的</b>，如果 <equation>R(a,b)</equation> 就有 <equation>R(b,a)</equation> ，对于所有的 <equation>a,b\in A</equation> 都成立；<br>是<b>反对称的</b>，如果 <equation>R(a,b)</equation> 且 <equation>R(b,a)</equation> ，则 <equation>a,b</equation> 是同一个元素，对于所有 <equation>a,b\in A</equation> 都成立；<br>是<b>传递的</b>，如果 <equation>R(a,b)</equation> 和 <equation>R(b,c)</equation> 能推出 <equation>R(a,c)</equation> ，对于所有的 <equation>a,b,c\in A</equation> 都成立。</p><p><b>偏序关系</b></p><p>等价关系是同时具有自反性，对称性和传递性的关系。<br><b>偏序关系</b>是具有自反性，反对称性和传递性的关系。</p><p>等价关系的一个例子就是相等性，相等性关系 <equation>R(a,b)</equation> 当且仅当 <equation>a,b</equation> 是同一个元素。<br>偏序关系，例如通常的序关系 <equation>R\subseteq N\times N</equation> ， <equation>R(a,b)</equation> 当且仅当 <equation>a\leqslant b</equation> 。</p><p><b>最小元与上确界</b></p><img src="https://pic3.zhimg.com/v2-d13edf6ede5bb0d53616bec489bed30f_r.jpg" data-caption="" data-size="normal" data-rawwidth="450" data-rawheight="362" data-watermark="watermark" data-original-src="v2-d13edf6ede5bb0d53616bec489bed30f" data-watermark-src="v2-64344ef688ab03db3908fa429ea51c15" data-private-watermark-src=""><p>对于偏序集 <equation>(D,\leqslant )</equation> ，以及它的一个子集 <equation>S\subseteq D</equation> ，<br>如果存在 <equation>y\in S</equation> ，且对于任意的 <equation>x\in S</equation> ，有 <equation>y\leqslant x</equation> ，则称 <equation>y</equation> 为 <equation>S</equation> 的<b>最小元</b>。</p><p>对于偏序集 <equation>(D,\leqslant )</equation> ，以及它的一个子集 <equation>S\subseteq D</equation> ，<br>如果存在 <equation>y\in D</equation> ，（注意， <equation>y</equation> 不一定在子集 <equation>S</equation> 中）<br>使得对于任意的 <equation>x\in S</equation> ， <equation>x\leqslant y</equation> ，则称 <equation>y</equation> 为 <equation>S</equation> 的<b>上界</b>，<br>如果 <equation>S</equation> 的所有上界存在最小元，则称它为 <equation>S</equation> 最小上界，或<b>上确界</b>。</p><p><b>完全偏序集</b></p><p>偏序集 <equation>(D,\leqslant )</equation> 的非空子集 <equation>S\subseteq D</equation> 叫做<b>有向子集</b>，<br>当且仅当，对于 <equation>S</equation> 中的任意元素 <equation>a,b\in S</equation> ，存在 <equation>S</equation> 中的一个元素 <equation>c</equation> ，有 <equation>a\leqslant c</equation> 且 <equation>b\leqslant c</equation> 。</p><p>如果一个偏序集 <equation>(D,\leqslant )</equation> 的每个有向子集 <equation>S\subseteq D</equation> 都有上确界（记为 <equation>\bigvee S</equation> ）<br>就称它是一个有向完全偏序集，<br>此外，如果它还有最小元，就称它是一个<b>完全偏序集</b>。</p><p>注意，完全偏序集并不是每一个子集都有上确界，而是它的每一个有向子集都有上确界。</p><p><b>连续函数</b></p><p>假设 <equation>(D,\leqslant )</equation> 与 <equation>(E,\leqslant )</equation> 是完全偏序集， <equation>f:D\rightarrow E</equation> 是集合上定义的一个函数，<br>对于任意的 <equation>d,d'\in D</equation> ，如果 <equation>d\leqslant d'</equation> 就有 <equation>f(d)\leqslant f(d')</equation> ，我们就说 <equation>f</equation> 是<b>单调的</b>。</p><p>如果 <equation>f</equation> 是单调的，且对于任意有向子集 <equation>S\subseteq D</equation> ，<br>有 <equation>f(\bigvee S)=\bigvee f(S)</equation> ，就称 <equation>f</equation> 是<b>连续的</b>。</p><p><b>小结</b></p><p>我们又重新回顾了完全偏序这一概念，<br>实际上，任意一个CPO（完全偏序），都构成了一个范畴，<br>而所有的群，也构成了一个范畴。</p><p>群范畴的对象是集合，而CPO（完全偏序）范畴的对象不一定是集合。<br>这对摆脱集合论来理解范畴是很关键的。</p><h2><b>总结</b></h2><p>本文介绍了三种数学结构，群结构，拓扑结构，以及CPO（完全偏序）。<br>作为例子，可以为后面学习范畴论打下扎实的基础。</p><p>我们看到了这些数学结构之间的相似性，<br>从下一篇开始，我们要开始范畴论的学习之旅了。</p><hr><h2><b>参考</b></h2><p><a href="https://en.wikipedia.org/wiki/Category_theory">Category theory</a> <br><a href="https://book.douban.com/subject/1230394/">离散数学教程</a> <br><a href="https://book.douban.com/subject/4201293/">近世代数引论</a> <br><a href="https://book.douban.com/subject/1230382/">基础拓扑学讲义</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
