<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 01 Apr 2019 19:35:31 +0800</lastBuildDate>
<item>
<title>PFPL 读书笔记 1 —— 语法对象</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-30-60920045.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60920045&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7f919b07f53a8fc3dbd8ea7551513998_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前记&lt;/h2&gt;&lt;p&gt;PFPL，即 Practical Foundations for Programming Languages，是关于编程语言的类型结构和语法表现的一本书。有一定编程经验的人都知道不同的语言有不同的特点。通俗地举例来说，一些语言的变量类型在编写的时候就确定了，而有一些要在运行的时候才知道；有一些语言对变量类型的检查比较“严格”，而有一些则比较“宽松”。继续深入地思考，就会发现它们有很多奇妙的地方。其中似乎有一些规律，但又无法清楚地描述究竟是什么。PFPL 就是一本解释这方面内容的书。&lt;/p&gt;&lt;p&gt;纸上得来终觉浅，但目前又没有合适的方式让我将其运用到实践中，只好把书上的内容复述一遍，记录下想法，希望能对自己的理解有所帮助。&lt;/p&gt;&lt;h2&gt;语法对象&lt;/h2&gt;&lt;p&gt;编程语言是一种语言，它们用于表示计算机和人类都能理解的计算过程。一门编程语言的语法确定了它可以由哪些语句组成。那么这些语句是如何确定的，程序是如何组成的呢？&lt;/p&gt;&lt;p&gt;当提到语法的时候，可能表示的是几个不同的概念。一个是 &lt;i&gt;表层语法&lt;/i&gt;，表示语句是如何输入并展示在计算机上的，通常是一些字符串等形式。而 &lt;i&gt;抽象语法&lt;/i&gt; 表示语句之间是如何组合在一起的。从这个层面来说，语法是一颗树，称为 &lt;i&gt;抽象语法树&lt;/i&gt;。这种树的节点是运算符，将几个语句组合在一起。另外还有关于标识符的声明和使用的问题，这部分结构称为 &lt;i&gt;绑定&lt;/i&gt;。这个层次的语法称为 &lt;i&gt;抽象绑定树&lt;/i&gt;，它在 &lt;i&gt;抽象语法树&lt;/i&gt; 的基础上增加了绑定和作用域的概念。&lt;/p&gt;&lt;h2&gt;抽象语法树&lt;/h2&gt;&lt;p&gt;一棵 &lt;i&gt;抽象语法树&lt;/i&gt;（&lt;i&gt;abstract syntax tree&lt;/i&gt;，简称为 &lt;i&gt;ast&lt;/i&gt;），是一棵有序树。它的叶子节点是 &lt;i&gt;变量&lt;/i&gt;，内部节点是 &lt;i&gt;运算符&lt;/i&gt;，&lt;i&gt;运算符&lt;/i&gt; 的参数是它的子树。Ast 可以分为很多种 &lt;i&gt;类别&lt;/i&gt;，表示不同形式的语法。&lt;i&gt;变量&lt;/i&gt; 代表特定类别的语法中一个未确定的片段。Ast 可以用 &lt;i&gt;运算符&lt;/i&gt; 组合起来。&lt;i&gt;运算符&lt;/i&gt; 具有类别和 &lt;i&gt;参数表&lt;/i&gt;，&lt;i&gt;参数表&lt;/i&gt; 使用类别的有限序列来表示它的参数数量和每个参数的类别。举例来说，如果一个运算符具有类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 和参数表 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_n&quot; alt=&quot;s_1,…,s_n&quot; eeimg=&quot;1&quot;&gt; ，那么它可以将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot; eeimg=&quot;1&quot;&gt; 个分别属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_n&quot; alt=&quot;s_1,…,s_n&quot; eeimg=&quot;1&quot;&gt; 的 ast 组合成一个类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的 ast。如果一个运算符不接受参数，那么称它为 &lt;i&gt;零元&lt;/i&gt; 运算符，同理还有 &lt;i&gt;一元&lt;/i&gt; 运算符、&lt;i&gt;二元&lt;/i&gt; 运算符等等。&lt;/p&gt;&lt;p&gt;变量在其中是一个很重要的概念。在数学领域，变量一般表示某个作用域下的未知对象（如未知的实数），而在这里变量表示的是某个类别的 ast。因为这是一个未知的量，所以只有在 &lt;i&gt;代换&lt;/i&gt; 的时候变量才能获得意义。例如数学中我们可能会将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cpi&quot; alt=&quot;\pi&quot; eeimg=&quot;1&quot;&gt; 代入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 计算结果。在 ast 中也是类似的，只需要将一个 ast 中的变量换成另一个 ast 即可。&lt;/p&gt;&lt;p&gt;举例来说，有一门简单的语言用于表示数字、加法和乘法。它的语法中只有一个类别 Exp，以及一个无限的运算符集合：&lt;img src=&quot;https://www.zhihu.com/equation?tex=num%5Bn%5D&quot; alt=&quot;num[n]&quot; eeimg=&quot;1&quot;&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=n+%5Cin+N&quot; alt=&quot;n \in N&quot; eeimg=&quot;1&quot;&gt; ，包含 Exp 类别的零元运算符， &lt;img src=&quot;https://www.zhihu.com/equation?tex=plus&quot; alt=&quot;plus&quot; eeimg=&quot;1&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=times&quot; alt=&quot;times&quot; eeimg=&quot;1&quot;&gt; 是二元运算符，且参数都是 Exp 类别的。如这个含 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 的表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2+%2B+%283+%5Ctimes+x%29&quot; alt=&quot;2 + (3 \times x)&quot; eeimg=&quot;1&quot;&gt; 可以表示为 ast&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=plus%28num%5B2%5D%3Btimes%28num%5B3%5D%3B+x%29%29%5C%5C+&quot; alt=&quot;plus(num[2];times(num[3]; x))\\ &quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;如果将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=num%5B4%5D&quot; alt=&quot;num[4]&quot; eeimg=&quot;1&quot;&gt; 代入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; ，就能得到 ast&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=plus%28num%5B2%5D%3Btimes%28num%5B3%5D%3B+num%5B4%5D%29%29%5C%5C&quot; alt=&quot;plus(num[2];times(num[3]; num[4]))\\&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;即表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=2+%2B+%283+%5Ctimes+4%29&quot; alt=&quot;2 + (3 \times 4)&quot; eeimg=&quot;1&quot;&gt; 。当然也可以将其它 ast 代入 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 得到更加复杂的结果。&lt;/p&gt;&lt;p&gt;Ast 的树形结构支持一种非常有用的原则推理，称为 &lt;i&gt;结构归纳&lt;/i&gt;。假设我们想证明对于一个类别中所有的 ast， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; ，都具有性质 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%28a%29+%E2%80%8B&quot; alt=&quot; P(a) ​&quot; eeimg=&quot;1&quot;&gt; ，那么可以考虑所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 是怎么生成的，并且证明在每种情况下都具有该性质。所以根据刚才对 Exp 的定义，我们需要证明&lt;/p&gt;&lt;ol&gt;&lt;li&gt;所有 Exp 类别的变量 $ x $ 都具有该性质： &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28x%29&quot; alt=&quot;P(x)&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;对于所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+n+%5Cin+N+&quot; alt=&quot; n \in N &quot; eeimg=&quot;1&quot;&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=num%5Bn%5D+&quot; alt=&quot;num[n] &quot; eeimg=&quot;1&quot;&gt; 都具有该性质： &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%28num%5Bn%5D%29&quot; alt=&quot; P(num[n])&quot; eeimg=&quot;1&quot;&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=+n+%5Cin+N+&quot; alt=&quot; n \in N &quot; eeimg=&quot;1&quot;&gt;.&lt;/li&gt;&lt;li&gt;假设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1&quot; alt=&quot;a_1&quot; eeimg=&quot;1&quot;&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_2&quot; alt=&quot;a_2&quot; eeimg=&quot;1&quot;&gt; 都具有该性质，证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=plus%28a_1%3Ba_2%29+&quot; alt=&quot;plus(a_1;a_2) &quot; eeimg=&quot;1&quot;&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=times%28a_1%3Ba_2%29+&quot; alt=&quot;times(a_1;a_2) &quot; eeimg=&quot;1&quot;&gt; 都具有该性质：if &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a_1%29&quot; alt=&quot;P(a_1)&quot; eeimg=&quot;1&quot;&gt; and &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a_2%29&quot; alt=&quot;P(a_2)&quot; eeimg=&quot;1&quot;&gt; , then &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%28plus%28a_1%3Ba_2%29%29&quot; alt=&quot; P(plus(a_1;a_2))&quot; eeimg=&quot;1&quot;&gt; and &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%28times%28a_1%3Ba_2%29%29+&quot; alt=&quot; P(times(a_1;a_2)) &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因为以上过程说明了所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 的可能性，所以可以证明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a%29&quot; alt=&quot;P(a)&quot; eeimg=&quot;1&quot;&gt; 对所有 Exp 类别的 ast 成立。&lt;/p&gt;&lt;p&gt;接下来考虑更加一般的情况。设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=S&quot; alt=&quot;S&quot; eeimg=&quot;1&quot;&gt; 是类别的有限集合， &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5C%7B+O_s+%5C%7D%7Bs+%5Cin+S%7D+&quot; alt=&quot; \{ O_s \}{s \in S} &quot; eeimg=&quot;1&quot;&gt;是运算符族，其中的运算符 &lt;img src=&quot;https://www.zhihu.com/equation?tex=o&quot; alt=&quot;o&quot; eeimg=&quot;1&quot;&gt; 都属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; ，参数表为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=ar%28o%29+%3D+%28s_1%2C%E2%80%A6s_n%29+&quot; alt=&quot;ar(o) = (s_1,…s_n) &quot; eeimg=&quot;1&quot;&gt; 。设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7BX_s%5C%7D_%7Bs+%5Cin+S%7D&quot; alt=&quot;\{X_s\}_{s \in S}&quot; eeimg=&quot;1&quot;&gt; 为类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的变量族。那么类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的 ast 族 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5BX%5D+%3D+%5C%7BA%5Bx%5D_s%5C%7D_%7Bs+%5Cin+S%7D&quot; alt=&quot;A[X] = \{A[x]_s\}_{s \in S}&quot; eeimg=&quot;1&quot;&gt; 的定义如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;一个类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的变量是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的一个 ast：if &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%5Cin+X_s&quot; alt=&quot; x \in X_s&quot; eeimg=&quot;1&quot;&gt; , then &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+A%5BX%5D_s&quot; alt=&quot;x \in A[X]_s&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;运算符可以组合 ast：if &lt;img src=&quot;https://www.zhihu.com/equation?tex=o+%5Cin+O_s&quot; alt=&quot;o \in O_s&quot; eeimg=&quot;1&quot;&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=+ar%28o%29+%3D+%28s_1%2C%E2%80%A6s_n%29+&quot; alt=&quot; ar(o) = (s_1,…s_n) &quot; eeimg=&quot;1&quot;&gt; and &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_1+%5Cin+A%5BX%5D_%7Bs_1%7D&quot; alt=&quot; a_1 \in A[X]_{s_1}&quot; eeimg=&quot;1&quot;&gt; ,…, &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_n+%5Cin+A%5BX%5D_%7Bs_n%7D+&quot; alt=&quot; a_n \in A[X]_{s_n} &quot; eeimg=&quot;1&quot;&gt; , then &lt;img src=&quot;https://www.zhihu.com/equation?tex=+o%28a_1%3B%E2%80%A6%3Ba_n%29+%5Cin+A%5BX%5D_s&quot; alt=&quot; o(a_1;…;a_n) \in A[X]_s&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;同样地，这个方法也可以用于证明所有 ast 具有性质 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P&quot; alt=&quot;P&quot; eeimg=&quot;1&quot;&gt; 。要证明所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a+%5Cin+A%5BX%5D+&quot; alt=&quot; a \in A[X] &quot; eeimg=&quot;1&quot;&gt; 具有性质 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a%29&quot; alt=&quot;P(a)&quot; eeimg=&quot;1&quot;&gt; ，只需要证明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;if &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+X_s&quot; alt=&quot;x \in X_s&quot; eeimg=&quot;1&quot;&gt; , then &lt;img src=&quot;https://www.zhihu.com/equation?tex=P_s%28x%29&quot; alt=&quot;P_s(x)&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;if &lt;img src=&quot;https://www.zhihu.com/equation?tex=+o+%5Cin+O_s&quot; alt=&quot; o \in O_s&quot; eeimg=&quot;1&quot;&gt; and &lt;img src=&quot;https://www.zhihu.com/equation?tex=+ar%28o%29+%3D+%28s_1%2C%E2%80%A6%2Cs_n%29&quot; alt=&quot; ar(o) = (s_1,…,s_n)&quot; eeimg=&quot;1&quot;&gt; , then if &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P_%7Bs_1%7D%28a_1%29&quot; alt=&quot; P_{s_1}(a_1)&quot; eeimg=&quot;1&quot;&gt; and … and &lt;img src=&quot;https://www.zhihu.com/equation?tex=P_%7Bs_n%7D%28a_n%29&quot; alt=&quot;P_{s_n}(a_n)&quot; eeimg=&quot;1&quot;&gt; , then &lt;img src=&quot;https://www.zhihu.com/equation?tex=P_s%28o%28a_1%3B%E2%80%A6%3Ba_n%29%29&quot; alt=&quot;P_s(o(a_1;…;a_n))&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;根据上面的原理，我们可以轻松地证明如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X+%5Csubseteq+Y&quot; alt=&quot;X \subseteq Y&quot; eeimg=&quot;1&quot;&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5BX%5D+%5Csubseteq+A%5BY%5D&quot; alt=&quot;A[X] \subseteq A[Y]&quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; 是一个变量族， &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 是一个类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的变量且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cnotin+X_s&quot; alt=&quot;x \notin X_s&quot; eeimg=&quot;1&quot;&gt; ，那么称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X%2C+x+&quot; alt=&quot;X, x &quot; eeimg=&quot;1&quot;&gt; 为将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 邻接于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; ，具体含义如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D++X%2Cx+%3D+%5Cbegin%7Bcases%7D++X_i+%5Ccup+%7Bx%7D%26+i%3Ds%5C%5C++X_i%26+i+%5Cneq+s++%5Cend%7Bcases%7D+%5Cquad+i+%5Cin+S++%5Cend%7Bequation%7D+%5C%5C&quot; alt=&quot;\begin{equation}  X,x = \begin{cases}  X_i \cup {x}&amp;amp; i=s\\  X_i&amp;amp; i \neq s  \end{cases} \quad i \in S  \end{equation} \\&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;&lt;i&gt;代换&lt;/i&gt; 赋予变量意义。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 类别的变量， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%5Cin+A%5BX%2C+x%5D_%7Bs%27%7D&quot; alt=&quot;a \in A[X, x]_{s&#39;}&quot; eeimg=&quot;1&quot;&gt; ，且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+%5Cin+A%5BX%5D_s&quot; alt=&quot;b \in A[X]_s&quot; eeimg=&quot;1&quot;&gt; ，那么可以将 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 中出现的所有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;&gt; 进行代换，记为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da&quot; alt=&quot;[b/x]a&quot; eeimg=&quot;1&quot;&gt; ，且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da+%5Cin+A%5BX%5D_%7Bs%27%7D&quot; alt=&quot;[b/x]a \in A[X]_{s&#39;}&quot; eeimg=&quot;1&quot;&gt; 。其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 被称为 &lt;i&gt;代换目标&lt;/i&gt;， &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 被称为 &lt;i&gt;代换项&lt;/i&gt;。代换可以定义为以下等式：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Dx+%3D+b+&quot; alt=&quot;[b/x]x = b &quot; eeimg=&quot;1&quot;&gt; and &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Dy+%3D+y+%E2%80%8B&quot; alt=&quot; [b/x]y = y ​&quot; eeimg=&quot;1&quot;&gt; if &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cneq+y+%E2%80%8B&quot; alt=&quot;x \neq y ​&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Do%28a_1%3B%E2%80%A6%3Ba_n%29+%3D+o%28%5Bb%2Fx%5Da1%3B%E2%80%A6%3B%5Bb%2Fx%5Da_n%29+&quot; alt=&quot;[b/x]o(a_1;…;a_n) = o([b/x]a1;…;[b/x]a_n) &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;例如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bnum%5B2%5D%2Fx%5Dplus%28x%3Bnum%5B3%5D%29+%3D+plus%28num%5B2%5D%3Bnum%5B3%5D%29+&quot; alt=&quot; [num[2]/x]plus(x;num[3]) = plus(num[2];num[3]) &quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理 1.1.&lt;/b&gt; 如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%5Cin+A%5BX%2Cx%5D+&quot; alt=&quot;a \in A[X,x] &quot; eeimg=&quot;1&quot;&gt; ，那么对于每一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+b+%5Cin+A%5BX%5D+&quot; alt=&quot; b \in A[X] &quot; eeimg=&quot;1&quot;&gt; 都存在唯一的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c+%5Cin+A%5BX%5D+&quot; alt=&quot;c \in A[X] &quot; eeimg=&quot;1&quot;&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da+%3D+c+&quot; alt=&quot;[b/x]a = c &quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;p&gt;&lt;i&gt;证明：&lt;/i&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a+%3D+x&quot; alt=&quot; a = x&quot; eeimg=&quot;1&quot;&gt; ，根据定义 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b+%3D+c&quot; alt=&quot;b = c&quot; eeimg=&quot;1&quot;&gt; 。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+y+%5Cneq+x+&quot; alt=&quot;a = y \neq x &quot; eeimg=&quot;1&quot;&gt; ，同样根据定义 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+y+%3D+c+&quot; alt=&quot; y = c &quot; eeimg=&quot;1&quot;&gt; 。否则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+o%28a_1%2C%E2%80%A6%2Ca_n%29+&quot; alt=&quot;a = o(a_1,…,a_n) &quot; eeimg=&quot;1&quot;&gt; ，使用归纳法假设存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1%2C%E2%80%A6%2Cc_n&quot; alt=&quot;c_1,…,c_n&quot; eeimg=&quot;1&quot;&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Da_1+%3D+c_1&quot; alt=&quot; [b/x]a_1 = c_1&quot; eeimg=&quot;1&quot;&gt; , …, &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da_n+%3D+c_n&quot; alt=&quot;[b/x]a_n = c_n&quot; eeimg=&quot;1&quot;&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+c+%3D+o%28c_1%3B%E2%80%A6%3Bc_n%29+&quot; alt=&quot; c = o(c_1;…;c_n) &quot; eeimg=&quot;1&quot;&gt; 。可得对于所有的情况都成立。&lt;/p&gt;&lt;p&gt;大部分情况下可以提前枚举出所有运算符，但是在一些情况下却不行，有些运算符只能在固定的上下文生效，此时运算符的集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O&quot; alt=&quot;O&quot; eeimg=&quot;1&quot;&gt; 不是确定的，所以必须留出扩展性。这时可以将 &lt;i&gt;形式参数&lt;/i&gt; 作为运算符族的索引。如有一个零元运算符族 &lt;img src=&quot;https://www.zhihu.com/equation?tex=cls%5Bu%5D&quot; alt=&quot;cls[u]&quot; eeimg=&quot;1&quot;&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u&quot; alt=&quot;u&quot; eeimg=&quot;1&quot;&gt; 是 &lt;i&gt;活跃&lt;/i&gt; 的形式参数集合中的元素，其中不同的形式参数对应不同的运算符：如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u&quot; alt=&quot;u&quot; eeimg=&quot;1&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=v&quot; alt=&quot;v&quot; eeimg=&quot;1&quot;&gt; 是活跃的形式参数且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+u+%5Cneq+v&quot; alt=&quot; u \neq v&quot; eeimg=&quot;1&quot;&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=cls%5Bu%5D+%5Cneq+cls%5Bv%5D&quot; alt=&quot;cls[u] \neq cls[v]&quot; eeimg=&quot;1&quot;&gt; 。需要扩展新的运算符时，只需要添加新的形式参数即可。如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u&quot; alt=&quot;u&quot; eeimg=&quot;1&quot;&gt; 是不活跃的， &lt;img src=&quot;https://www.zhihu.com/equation?tex=+cls%5Bu%5D&quot; alt=&quot; cls[u]&quot; eeimg=&quot;1&quot;&gt; 没有意义，但当它活跃时， &lt;img src=&quot;https://www.zhihu.com/equation?tex=+cls%5Bu%5D&quot; alt=&quot; cls[u]&quot; eeimg=&quot;1&quot;&gt; 就是一个零元运算符。&lt;/p&gt;&lt;p&gt;形式参数可能会和变量混淆，但它们是根本不相同的两个概念。变量是一个未知的 ast，而形式参数不代表任何东西，它只是用来区分其它的形式参数。我们用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+A%5BU%3BX%5D&quot; alt=&quot; A[U;X]&quot; eeimg=&quot;1&quot;&gt; 表示一个 ast 的集合，其中的变量属于集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; ，形式参数属于集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;h2&gt;抽象绑定树&lt;/h2&gt;&lt;p&gt;抽象绑定树（&lt;i&gt;abstract binding tree&lt;/i&gt;，简称为 &lt;i&gt;abt&lt;/i&gt;）,为 ast 添加了新变量和形式参数的声明，称为 &lt;i&gt;绑定&lt;/i&gt;，以及他们的有效范围，称为 &lt;i&gt;作用域&lt;/i&gt;，一个绑定的作用域是被绑定的标识符所在的 abt。因此一棵子树的活跃标识符集合可能比外层的集合大，不同的子树也可能会包含不同的标识符。但是所有的标识符都只是一个引用，也就是说选用不同的标识符所表达的含义是一致的，因此我们总是可以给绑定关联一个不同的标识符。&lt;/p&gt;&lt;p&gt;比如有一个表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=let+%7E+x+%7E+be+%7E+a_1+%7E+in+%7E+a_2&quot; alt=&quot;let ~ x ~ be ~ a_1 ~ in ~ a_2&quot; eeimg=&quot;1&quot;&gt; ，声明了一个变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 在表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_2+&quot; alt=&quot;a_2 &quot; eeimg=&quot;1&quot;&gt; 中代表 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1&quot; alt=&quot;a_1&quot; eeimg=&quot;1&quot;&gt; ，而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_1&quot; alt=&quot;a_1&quot; eeimg=&quot;1&quot;&gt; 中的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 即使拥有相同的名字，也是不同的变量。相同的绑定更换名字不改变它的含义，如表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+x%2Ax+%7E+in+%7E+x+%2B+x+&quot; alt=&quot; let ~ x ~ be ~ x*x ~ in ~ x + x &quot; eeimg=&quot;1&quot;&gt;与&lt;img src=&quot;https://www.zhihu.com/equation?tex=+let+%7E+y+%7E+be+%7E+x%2Ax+%7E+in+%7E+y+%2B+y+&quot; alt=&quot; let ~ y ~ be ~ x*x ~ in ~ y + y &quot; eeimg=&quot;1&quot;&gt; 是等价的。而 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+y%2Ay+%7E+in+%7E+x+%2B+x+&quot; alt=&quot; let ~ x ~ be ~ y*y ~ in ~ x + x &quot; eeimg=&quot;1&quot;&gt; 与前面两个表达式都不同，因为这里的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; 代表的可能是外层 abt 中的另一个变量。另外在改变变量命名时不能改变引用的结构，如 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+2+%7E+in+%7E+let+%7E+y+%7E+be+%7E+3+%7E+in+%7E+x+%2B+x+&quot; alt=&quot; let ~ x ~ be ~ 2 ~ in ~ let ~ y ~ be ~ 3 ~ in ~ x + x &quot; eeimg=&quot;1&quot;&gt; 与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=let+%7E+y+%7E+be+%7E+2+%7E+in+%7E+let+%7E+y+%7E+be+%7E+3+%7E+in+%7E+y+%2B+y&quot; alt=&quot;let ~ y ~ be ~ 2 ~ in ~ let ~ y ~ be ~ 3 ~ in ~ y + y&quot; eeimg=&quot;1&quot;&gt; 所表示的意义不同。后者的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+y+%2B+y&quot; alt=&quot; y + y&quot; eeimg=&quot;1&quot;&gt; 中的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; 表示的是内部结构的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; 而不是外部的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;span&gt;&lt;/span&gt;let x be 2 in
    let y be 3 in
        x + x

let y be 2 in
    let y be 3 in
        y + y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Abt 可以给运算符参数绑定有限个变量，记作 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1%2C%E2%80%A6%2Cx_k.a+&quot; alt=&quot;x_1,…,x_k.a &quot; eeimg=&quot;1&quot;&gt; 。变量序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x_1%2C%E2%80%A6%2Cx_k&quot; alt=&quot; x_1,…,x_k&quot; eeimg=&quot;1&quot;&gt; 绑定在 abt &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 中，当 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+k+%3D+0+&quot; alt=&quot; k = 0 &quot; eeimg=&quot;1&quot;&gt; 时 &lt;img src=&quot;https://www.zhihu.com/equation?tex=.a&quot; alt=&quot;.a&quot; eeimg=&quot;1&quot;&gt; 可以省略为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 。如表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+a_1+%7E+in+%7E+a_2&quot; alt=&quot; let ~ x ~ be ~ a_1 ~ in ~ a_2&quot; eeimg=&quot;1&quot;&gt; 写作 abt 就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=let%28a_1%3Bx.a_2%29&quot; alt=&quot;let(a_1;x.a_2)&quot; eeimg=&quot;1&quot;&gt; 。另外使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cvec%7Bx%7D&quot; alt=&quot; \vec{x}&quot; eeimg=&quot;1&quot;&gt; 表示有限不重复序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1%2C%E2%80%A6%2Cx_n+&quot; alt=&quot;x_1,…,x_n &quot; eeimg=&quot;1&quot;&gt; ，所以 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_1%2C%E2%80%A6%2Cx_n.a&quot; alt=&quot;x_1,…,x_n.a&quot; eeimg=&quot;1&quot;&gt; 也可以写作 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cvec%7Bx%7D.a&quot; alt=&quot; \vec{x}.a&quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;p&gt;为了表示绑定，abt 中运算符的参数表使用 &lt;i&gt;格&lt;/i&gt; 的有限序列表示。这个序列的长度表示参数的数量，其中每个格表示一个参数的类别和绑定的变量类别。一个格用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%28s_1%2C%E2%80%A6%2Cs_k%29s&quot; alt=&quot; (s_1,…,s_k)s&quot; eeimg=&quot;1&quot;&gt; 的形式表示 &lt;img src=&quot;https://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot; eeimg=&quot;1&quot;&gt; 个类别分别为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_k+&quot; alt=&quot;s_1,…,s_k &quot; eeimg=&quot;1&quot;&gt; 的变量绑定在类别为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的参数上，并且使用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bs%7D&quot; alt=&quot;\vec{s}&quot; eeimg=&quot;1&quot;&gt; 表示有限序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_n&quot; alt=&quot;s_1,…,s_n&quot; eeimg=&quot;1&quot;&gt; 。如果变量序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bx%7D&quot; alt=&quot;\vec{x}&quot; eeimg=&quot;1&quot;&gt; 和类别序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cvec%7Bs%7D&quot; alt=&quot; \vec{s}&quot; eeimg=&quot;1&quot;&gt; 具有相同的长度，且每个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x_i+&quot; alt=&quot;x_i &quot; eeimg=&quot;1&quot;&gt; 都属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_i+&quot; alt=&quot;s_i &quot; eeimg=&quot;1&quot;&gt; ，那么称 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bx%7D&quot; alt=&quot;\vec{x}&quot; eeimg=&quot;1&quot;&gt; 属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bs%7D&quot; alt=&quot;\vec{s}&quot; eeimg=&quot;1&quot;&gt; 。举例来说， &lt;img src=&quot;https://www.zhihu.com/equation?tex=let&quot; alt=&quot;let&quot; eeimg=&quot;1&quot;&gt; 运算符的参数表为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%28%5Ctext%7BExp%7D%2C+%28%5Ctext%7BExp%7D%29%5Ctext%7BExp%7D%29&quot; alt=&quot; (\text{Exp}, (\text{Exp})\text{Exp})&quot; eeimg=&quot;1&quot;&gt; ，表示第一个参数是 Exp 类别的且没有绑定的变量，第二个参数是 Exp 类别的且绑定了一个 Exp 类别的变量。表达式 &lt;img src=&quot;https://www.zhihu.com/equation?tex=let+%7E+x+%7E+be+%7E+2+%2B+2+%7E+in+%7E+x+%5Ctimes+x+&quot; alt=&quot;let ~ x ~ be ~ 2 + 2 ~ in ~ x \times x &quot; eeimg=&quot;1&quot;&gt; 写作 abt 是&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=let%28plus%28num%5B2%5D%3Bnum%5B2%5D%29%3Bx.times%28x%3Bx%29%29%5C%5C&quot; alt=&quot;let(plus(num[2];num[2]);x.times(x;x))\\&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=O&quot; alt=&quot;O&quot; eeimg=&quot;1&quot;&gt; 是运算符族，其中的运算符 &lt;img src=&quot;https://www.zhihu.com/equation?tex=o&quot; alt=&quot;o&quot; eeimg=&quot;1&quot;&gt; 的参数表为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=ar%28o%29&quot; alt=&quot;ar(o)&quot; eeimg=&quot;1&quot;&gt; 。对于变量族 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; ，对应的 abt 族 &lt;img src=&quot;https://www.zhihu.com/equation?tex=B%5BX%5D&quot; alt=&quot;B[X]&quot; eeimg=&quot;1&quot;&gt; 的定义与 &lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5BX%5D&quot; alt=&quot;A[X]&quot; eeimg=&quot;1&quot;&gt; 类似，但是它活跃的变量会随着绑定的变量而改变：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+X_s&quot; alt=&quot;x \in X_s&quot; eeimg=&quot;1&quot;&gt; , 则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+B%5BX%5D_s&quot; alt=&quot;x \in B[X]_s&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=ar%28o%29+%3D+%28%28%5Cvec%7Bs_1%7D%29s_1%2C%E2%80%A6%2C%28%5Cvec%7Bs_n%7D%29s_n%29+&quot; alt=&quot;ar(o) = ((\vec{s_1})s_1,…,(\vec{s_n})s_n) &quot; eeimg=&quot;1&quot;&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bx_i%7D+&quot; alt=&quot;\vec{x_i} &quot; eeimg=&quot;1&quot;&gt; 属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cvec%7Bs_i%7D+&quot; alt=&quot; \vec{s_i} &quot; eeimg=&quot;1&quot;&gt; 且 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a_i+%5Cin+B%5BX%2C+%5Cvec%7Bx_i%7D%5D_%7Bs_i%7D+&quot; alt=&quot;a_i \in B[X, \vec{x_i}]_{s_i} &quot; eeimg=&quot;1&quot;&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+%5Cin+B%5BX%5D_s+&quot; alt=&quot;o(\vec{x_1}.a_1;…;\vec{x_n}.a_n) \in B[X]_s &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这个定义有一点问题，考虑下面这个 abt： &lt;img src=&quot;https://www.zhihu.com/equation?tex=+let%28a_1%3Bx.let%28a_2%3Bx.a_3%29%29&quot; alt=&quot; let(a_1;x.let(a_2;x.a_3))&quot; eeimg=&quot;1&quot;&gt; 。根据上面的定义，这个 abt 是不合法的。内层的 abt 在构造的时候引入了变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; ，因此变量族从 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; 变为了 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X%2Cx&quot; alt=&quot;X,x&quot; eeimg=&quot;1&quot;&gt; 。接下来考虑外层的时候，需要把 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 邻接于 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X%2Cx&quot; alt=&quot;X,x&quot; eeimg=&quot;1&quot;&gt; ，这就产生了冲突。因为两个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 的符号相同，但是表示的意思是不同的。实际上选取不同的变量名不应该造成含义上的区别，因此可以修改第二条定义，考虑重命名变量：&lt;/p&gt;&lt;p&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=ar%28o%29+%3D+%28%28%5Cvec%7Bx_1%7D%29s_1%2C%E2%80%A6%2C%28%5Cvec%7Bx_n%7D%29s_n%29+&quot; alt=&quot;ar(o) = ((\vec{x_1})s_1,…,(\vec{x_n})s_n) &quot; eeimg=&quot;1&quot;&gt; ，且对于每个重命名 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cpi_i%3A%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bx_i%27%7D+%7E%7E%7E%7E+%28%24+%5Cvec%7Bx_i%27%7D+%5Cnotin+X+%24%29&quot; alt=&quot;\pi_i:\vec{x_i} \leftrightarrow \vec{x_i&#39;} ~~~~ ($ \vec{x_i&#39;} \notin X $)&quot; eeimg=&quot;1&quot;&gt; ，都有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cpi_i+%5Ccdot+a_i+%5Cin+B%5BX%2C%5Cvec%7Bx_i%27%7D%5D+&quot; alt=&quot; \pi_i \cdot a_i \in B[X,\vec{x_i&#39;}] &quot; eeimg=&quot;1&quot;&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+%5Cin+B%5BX%5D_s+%E2%80%8B&quot; alt=&quot;o(\vec{x_1}.a_1;…;\vec{x_n}.a_n) \in B[X]_s ​&quot; eeimg=&quot;1&quot;&gt; 。&lt;/p&gt;&lt;p&gt;这个重命名规则避免了外部的变量和内部的变量冲突的情况。它保证了所有绑定的变量都与外围环境无关。&lt;/p&gt;&lt;p&gt;类似于 ast，如果需要证明一个性质 &lt;img src=&quot;https://www.zhihu.com/equation?tex=P%28a%29%5BX%5D+&quot; alt=&quot;P(a)[X] &quot; eeimg=&quot;1&quot;&gt; 对于所有的 abt &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%5Cin+B%5BX%5D&quot; alt=&quot;a \in B[X]&quot; eeimg=&quot;1&quot;&gt; 都成立，那么只需要证明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+X_s&quot; alt=&quot;x \in X_s&quot; eeimg=&quot;1&quot;&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%5BX%5D_s%28x%29+&quot; alt=&quot; P[X]_s(x) &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;对于任意属于类别 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; ，具有参数表 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%28%5Cvec%7Bs_1%7D%29s_1%2C%E2%80%A6%2C%28%5Cvec%7Bs_n%7D%29s_n+&quot; alt=&quot; (\vec{s_1})s_1,…,(\vec{s_n})s_n &quot; eeimg=&quot;1&quot;&gt; 的运算符 &lt;img src=&quot;https://www.zhihu.com/equation?tex=o&quot; alt=&quot;o&quot; eeimg=&quot;1&quot;&gt; ，如果对于每个重命名 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cpi_i%3A%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bx_i%27%7D+&quot; alt=&quot;\pi_i:\vec{x_i} \leftrightarrow \vec{x_i&#39;} &quot; eeimg=&quot;1&quot;&gt; 都有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%5BX%2C+%5Cvec%7Bx_i%27%7D%5D_%7Bs_i%7D%28%5Cpi_i+%5Ccdot+a_i%29&quot; alt=&quot; P[X, \vec{x_i&#39;}]_{s_i}(\pi_i \cdot a_i)&quot; eeimg=&quot;1&quot;&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+P%5BX%5D_s%28o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29%29&quot; alt=&quot; P[X]_s(o(\vec{x_1}.a_1;…;\vec{x_n}.a_n))&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这也是一个归纳性的推理，遵循了上面构造 abt 的过程。举例来说，我们定义一个命题 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%5Cin+a+%7E%7E%7E+%28a+%5Cin+B%5BX%2C+x%5D+%29&quot; alt=&quot; x \in a ~~~ (a \in B[X, x] )&quot; eeimg=&quot;1&quot;&gt; ，表示 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 中是自由变量。具体来说，它的意思是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 变量绑定在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 之外，而不是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 内部。那么要证明这个命题只需要说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cin+x&quot; alt=&quot;x \in x&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;如果存在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+1+%5Cle+i+%5Cle+n&quot; alt=&quot; 1 \le i \le n&quot; eeimg=&quot;1&quot;&gt; 对于每个重命名 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cpi+%3A+%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bz_i%7D&quot; alt=&quot; \pi : \vec{x_i} \leftrightarrow \vec{z_i}&quot; eeimg=&quot;1&quot;&gt; 使得 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%5Cin+%5Cpi+%5Ccdot+a_i+&quot; alt=&quot; x \in \pi \cdot a_i &quot; eeimg=&quot;1&quot;&gt; ，则 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%5Cin+o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29&quot; alt=&quot; x \in o(\vec{x_1}.a_1;…;\vec{x_n}.a_n)&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一个条件说明 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 在 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 本身中是自由的，但是在任何其它的变量中不是自由的。第二个条件表面如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 在某个参数中，无论使用那个绑定的变量名称，都是自由的，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 在整个 abt 中是自由的。&lt;/p&gt;&lt;p&gt;如果两个 abt， &lt;img src=&quot;https://www.zhihu.com/equation?tex=a&quot; alt=&quot;a&quot; eeimg=&quot;1&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=b&quot; alt=&quot;b&quot; eeimg=&quot;1&quot;&gt; ，无论选取什么绑定变量名都是相同的，则称为 &lt;i&gt;α 等价&lt;/i&gt;，记为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D_%5Calpha+b+&quot; alt=&quot;a =_\alpha b &quot; eeimg=&quot;1&quot;&gt; 。它的具体定义如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%3D_%5Calpha+x+&quot; alt=&quot; x =_\alpha x &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;对于每个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+1+%5Cle+i+%5Cle+n+&quot; alt=&quot; 1 \le i \le n &quot; eeimg=&quot;1&quot;&gt; 和所有新的重命名 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cpi_i+%3A+%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bz_i%7D+&quot; alt=&quot; \pi_i : \vec{x_i} \leftrightarrow \vec{z_i} &quot; eeimg=&quot;1&quot;&gt; 和 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cpi_i%27%3A%5Cvec%7Bx_i%27%7D+%5Cleftrightarrow+%5Cvec%7Bz_i%7D&quot; alt=&quot;\pi_i&#39;:\vec{x_i&#39;} \leftrightarrow \vec{z_i}&quot; eeimg=&quot;1&quot;&gt; ，都有 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+o%28%5Cvec%7Bx_i%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+&quot; alt=&quot; o(\vec{x_i}.a_1;…;\vec{x_n}.a_n) &quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D_%5Calpha+b&quot; alt=&quot;a =_\alpha b&quot; eeimg=&quot;1&quot;&gt; ，那么称它们互为 &lt;i&gt;α 变体&lt;/i&gt;。&lt;/p&gt;&lt;p&gt;考虑 abt 中将某个自由变量 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 的 &lt;i&gt;代换&lt;/i&gt; 为同类别的 abt，可以粗略地定义为：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5D%3Db+&quot; alt=&quot;[b/x]=b &quot; eeimg=&quot;1&quot;&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Dy+%3D+y+%7E+%28x+%5Cneq+y%29&quot; alt=&quot; [b/x]y = y ~ (x \neq y)&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;li&gt;对于每个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+1+%5Cle+i+%5Cle+n&quot; alt=&quot; 1 \le i \le n&quot; eeimg=&quot;1&quot;&gt; ，要求 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cvec%7Bx_i%7D+%5Cnotin+b+&quot; alt=&quot; \vec{x_i} \notin b &quot; eeimg=&quot;1&quot;&gt; ，且若 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+%5Cnotin+%5Cvec%7Bx_i%7D+&quot; alt=&quot; x \notin \vec{x_i} &quot; eeimg=&quot;1&quot;&gt; ，设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_i%27+%3D+%5Bb%2Fx%5Da_i+&quot; alt=&quot; a_i&#39; = [b/x]a_i &quot; eeimg=&quot;1&quot;&gt; ，否则设 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_i%27+%3D+a_i+&quot; alt=&quot; a_i&#39; = a_i &quot; eeimg=&quot;1&quot;&gt; ，那么 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Do%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29&quot; alt=&quot; [b/x]o(\vec{x_1}.a_1;…;\vec{x_n}.a_n)&quot; eeimg=&quot;1&quot;&gt; .&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;从第二个条件可以看出，如果 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 绑定于某个参数中，那么参数中的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 不会进行代换，因为这两个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; 的含义是不同的，所以需要判断是否 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cnotin+%5Cvec%7Bx_i%7D+&quot; alt=&quot;x \notin \vec{x_i} &quot; eeimg=&quot;1&quot;&gt; 。同样地， &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cvec%7Bx_i%7D+%5Cnotin+b&quot; alt=&quot;\vec{x_i} \notin b&quot; eeimg=&quot;1&quot;&gt; 也是为了保证代换后的变量不会与原来的绑定变量发生冲突，造成含义的混淆。如果这两个条件不都成立，那么这个代换是没有定义的。为了解决这种没有定义的问题，可以在条件中添加新的重命名的设定。我们知道对于任意新的重命名 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cpi_i+%3A+%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bx_i%27%7D+&quot; alt=&quot; \pi_i : \vec{x_i} \leftrightarrow \vec{x_i&#39;} &quot; eeimg=&quot;1&quot;&gt; ，代换 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Bb%2Fx%5D+%28%5Cpi_i+%5Ccdot+a_i%29+&quot; alt=&quot;[b/x] (\pi_i \cdot a_i) &quot; eeimg=&quot;1&quot;&gt; 都是合法的。所以对于选定的新的重命名，我们可以定义&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Do%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+%3D+o%28%5Cvec%7Bx_1%27%7D.%5Bb%2Fx%5D+%28%5Cpi_1+%5Ccdot+a_1%29%3B%E2%80%A6%3B%5Cvec%7Bx_n%27%7D.%5Bb%2Fx%5D+%28%5Cpi_n+%5Ccdot+a_n%29%29%5C%5C&quot; alt=&quot; [b/x]o(\vec{x_1}.a_1;…;\vec{x_n}.a_n) = o(\vec{x_1&#39;}.[b/x] (\pi_1 \cdot a_1);…;\vec{x_n&#39;}.[b/x] (\pi_n \cdot a_n))\\&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;这样我们就不需要关注 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x+%5Cnotin+%5Cvec%7Bx_i%7D+&quot; alt=&quot;x \notin \vec{x_i} &quot; eeimg=&quot;1&quot;&gt; 这个条件了，因为通过重命名可以保证这个条件的成立。另外，我们也可以通过选择一个不包含冲突变量名的 α 变体作为代换目标，这样就可以安全地进行代换。换句话说，abt 的代换是定义在整个 α 等价类上的。为了避免绑定带来的其它问题，我们将所有 α 等价的 abt 看成是相同的。也就是说所有对于 abt 的讨论都针对整个 α 等价类，而非某个 abt 本身。因此当我们研究一个 abt 时，只需要选择一个具有代表性的 abt，而不用关系它的变量名。&lt;/p&gt;&lt;p&gt;和变量类似，形式参数也可以绑定在运算符的参数上。为了表示形式参数，我们把格扩展为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cvec%7Bs_1%7D%3B%5Cvec%7Bs_2%7D%29s&quot; alt=&quot;(\vec{s_1};\vec{s_2})s&quot; eeimg=&quot;1&quot;&gt; ，表示类别为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+s_1+&quot; alt=&quot; s_1 &quot; eeimg=&quot;1&quot;&gt; 的形式参数和类别为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s_2&quot; alt=&quot;s_2&quot; eeimg=&quot;1&quot;&gt; 的变量绑定在类别为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=s&quot; alt=&quot;s&quot; eeimg=&quot;1&quot;&gt; 的参数上。Abt 族 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+B%5BU%3BX%5D+&quot; alt=&quot; B[U;X] &quot; eeimg=&quot;1&quot;&gt; 的形式参数来源于集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot; eeimg=&quot;1&quot;&gt; ，变量来源于集合 &lt;img src=&quot;https://www.zhihu.com/equation?tex=X&quot; alt=&quot;X&quot; eeimg=&quot;1&quot;&gt; 。按照习惯，用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=u&quot; alt=&quot;u&quot; eeimg=&quot;1&quot;&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=v&quot; alt=&quot;v&quot; eeimg=&quot;1&quot;&gt; 表示形式参数，用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt; , &lt;img src=&quot;https://www.zhihu.com/equation?tex=y&quot; alt=&quot;y&quot; eeimg=&quot;1&quot;&gt; 表示变量。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;这部分介绍了语法的基本概念，将 &lt;i&gt;表层语法&lt;/i&gt; 和 &lt;i&gt;抽象语法&lt;/i&gt; 进行了区分。在抽象语法中又分为仅包含语句结构的 &lt;i&gt;抽象语法树&lt;/i&gt; 和包含标识符定义和作用域的 &lt;i&gt;抽象绑定树&lt;/i&gt;，并提出了相关的定义和定理。其中运用了大量的归纳法，从定义出发按照构造的过程对一些定义进行了说明。这部分是后面更为深入的内容的基础，需要熟悉里面的符号表示并理解概念。&lt;/p&gt;&lt;p&gt;区分这几个不同层次的概念可以帮助我们更好地理解语法结构，也能够知道在遇到什么问题时要从什么地方下手。如重构代码时，需要保证重命名前后的变量在语义上保持一致，且不与其它的变量名产生冲突。这部分涉及到变量的绑定问题，就需要从 abt 层面进行解决。以 JavaScript 为例，@babel/parser 可以将代码转化为 ast，但根据刚刚的分析，仅仅根据这个是很难帮助我们完成重命名的操作的。这时候可以借助 @babel/traverse 遍历 ast，在遍历的过程中能够访问到当前节点的作用域以及绑定等信息，这样就有了更多的信息，可以保证重命名前后语法的一致性。&lt;/p&gt;</description>
<author>Means88</author>
<guid isPermaLink="false">2019-03-30-60920045</guid>
<pubDate>Sat, 30 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>0x07：SICP 的魔法 - 元语言抽象</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-21-59996663.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59996663&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7a397e027ba36ea5e82efe73ee883863_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;我的github地址：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;lfkdsk&lt;/a&gt;，还创建了相关的仓库，可以clone下来看：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk/SICP-Magical-Book&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SICP 的魔法&lt;/a&gt;，这个仓库还绑定了 gitbook 可以去下载。&lt;/blockquote&gt;&lt;p&gt;从这一篇文章开始就进入了 SICP 第四章的内容了，在前三章的内容之中我们接触了 &lt;code&gt;数据抽象&lt;/code&gt;，&lt;code&gt;过程抽象&lt;/code&gt;，&lt;code&gt;模块化&lt;/code&gt; 三个，第四章的内容主要就是实现了一个元循环解释器 (meta-circular) 并对其进行不断地改造引申出别的问题。从篇幅内容来看这一章的主要内容反倒是对当时初读的我最为简单的，因为在学过编译原理的相关课程之后，笔者已经尝试使用了自举的方式实现了一些基于 JVM 的编程语言(这里也建议大家在学习理论的同时也要加强知识的运用，否则没有实际的使用过很多知识就不是那么立体)。本章我们对这个 Scheme 求值器的具体实现不会介绍的特别具体，毕竟书上已经把全部代码都贴上去了，这里更想关注一些引申的问题。&lt;/p&gt;&lt;p&gt;在之前的篇幅之中我们讨论了很多和程序设计相关的内容，主要研究的三个内容是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;数据抽象：如何组合程序的基本元素，构造更复杂的结构&lt;/li&gt;&lt;li&gt;过程抽象：如何将复杂的结构抽象出高层组件，提供更高维度的组合型&lt;/li&gt;&lt;li&gt;模块化，通过高抽象层次的组织方法，提高系统的模块性&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;通过这些手段已经足够我们设计大部分程序了，但是现实世界中遇到的问题可能更为复杂，或者可能类似的问题出现在同一个领域内。这时候我们可能就要在程序之中引入 &lt;b&gt;DSL&lt;/b&gt;(领域内语言)了。本质上来讲我们引入 DSL 就是通过语言设计，为程序提供一种 &lt;b&gt;语言层的抽象&lt;/b&gt; ，来进一步提高我们程序的模块化。&lt;/p&gt;&lt;h2&gt;元语言抽象&lt;/h2&gt;&lt;p&gt;这节之中我们会试着用 Scheme 来实现一个 Scheme 的解释器，用一种语言实现其自身的求值器，称为元循环（meta-circular）。这里我们可以复习一下 &lt;code&gt;3.2&lt;/code&gt; 节之中出现的求值模型，其中的求值流程分成两步：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;求值组合式（非特殊形式）时&lt;/li&gt;&lt;li&gt;先求值组合式的各子表达式&lt;/li&gt;&lt;li&gt;把运算符子表达式的值作用于运算对象子表达式的值&lt;/li&gt;&lt;li&gt; 把复合过程应用于实参，是在一个新环境里求值过程体&lt;/li&gt;&lt;li&gt;新环境：过程对象（里环境指针指向）的环境加一个新框架&lt;/li&gt;&lt;li&gt;新框架里是过程的形参与对应实参的约束&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这两个步骤构成了 Scheme 求值的基本循环，这两个步骤也是能相互调用和递归 (自己递归或相互递归。求值的子表达式可能要应用复合过程，过程体本身通常又是组合式)，逐步规约到：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;符号 (从 env 里面取值）&lt;/li&gt;&lt;li&gt;基本过程（直接调用基本过程的代码）&lt;/li&gt;&lt;li&gt;值类型 (primary type 直接取值)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上的两个步骤可以被抽象为过程 eval 和 apply ，其中 eval 负责表达式的求值，apply 把一个过程对象应用于一组实际参数，这两者相互递归调用，eval 还有自递归。eval 和 apply 就像下图的这个像是太极图一样的图里，两者相互调用相互生成。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ec53e1568b737c4761f975ab7c7ecd80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1542&quot; data-rawheight=&quot;878&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1542&quot; data-original=&quot;https://pic1.zhimg.com/v2-ec53e1568b737c4761f975ab7c7ecd80_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ec53e1568b737c4761f975ab7c7ecd80_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1542&quot; data-rawheight=&quot;878&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1542&quot; data-original=&quot;https://pic1.zhimg.com/v2-ec53e1568b737c4761f975ab7c7ecd80_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ec53e1568b737c4761f975ab7c7ecd80_b.jpg&quot;&gt;&lt;/figure&gt;&lt;h3&gt;基础的递归解释器&lt;/h3&gt;&lt;h3&gt;核心 eval 和 apply&lt;/h3&gt;&lt;p&gt;整个 &lt;code&gt;eval&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 的过程直接看代码实现就可以了，这里可以看到 &lt;code&gt;eval&lt;/code&gt; 的过程就是接受一个表达式 exp 和一个环境变量 env ，根据表达式类型的不同进行分别处理。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;cond &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;self-evaluating?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;; 基本表达式&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;variable?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lookup-variable-value&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; 特殊形式&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;quoted?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;text-of-quotation&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;assignment?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;eval-assignment&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;definition?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;eval-definition&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;                                               &lt;span class=&quot;c1&quot;&gt;; 组合形式&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unknown expression type: EVAL&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据 exp 分情况来处理的过程，里面大概有三种类型的处理：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;基本表达式：包括能够自求值的表达式、变量&lt;/li&gt;&lt;li&gt;各种特殊表达式：if、quote、lambda、cond 里面还会涉及到和 env 操作的部分&lt;/li&gt;&lt;li&gt;过程结构：递归的对各个子表达式进行求值，然后 apply 应用过程&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这里用 &lt;code&gt;cond&lt;/code&gt; 写了一个 &lt;code&gt;switch&lt;/code&gt; 结构的过程，这对处理的逻辑顺序有很多的要求，比如在一个 cond 的逻辑之中不同的分支的拜访位置不能有问题，不如使用数据分发的方式去设计这个 eval 的结构，还记得我们在第二章设计数据导向的 API 的时候做的事情么？首先是抽象一个 api 的表格：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; 操作／类型 ／过程&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;op&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;type&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;item&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 操作／类型&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;op&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;type&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后给数据类型打上 tag 然后在使用前预先 install 对应的 api，这里我们甚至可以把不同类型的相同实现给出相同的名称，方便直接根据 data-type 去调用：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;install-rectangular-package&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; internal procedures&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;real-part &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;car &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;imag-part &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;; ... 省略其中的过程&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;make-from-real-imag&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;rectangular&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-from-real-imag&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;make-from-mag-ang&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;rectangular&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-from-mag-ang&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&#39;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过暂时我们先不这么做，因为现在明显我们的 &lt;code&gt;eval&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 的过程是混杂在一起，我们并没有对 expr 进行相应的预处理给每种数据结构打上 tag，这里可以看到 &lt;code&gt;eval&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 的互生带来了解释器设计和实现上的便利，但是也在具体的效率、代码编写的规范和拓展性上有了一定的问题。&lt;/p&gt;&lt;p&gt;接着来看核心的 &lt;code&gt;apply&lt;/code&gt; 过程吧，&lt;code&gt;apply&lt;/code&gt; 的应用过程就简单了很多，把 &lt;code&gt;dispatch&lt;/code&gt; 放到比较具体的调用环境：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;cond &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;primitive-procedure?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; primary procedure&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;apply-primitive-procedure&lt;/span&gt; 
          &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt; 
          &lt;span class=&quot;nv&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;compound-procedure?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; compound procedure&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;eval-sequence&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;procedure-body&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;extend-environment&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;procedure-parameters&lt;/span&gt; 
              &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;nv&quot;&gt;arguments&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;procedure-environment&lt;/span&gt; 
              &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unknown procedure type: APPLY&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;procedure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;primitive procedure 是 Scheme 里面也会出现的原生过程，这部分在 &lt;code&gt;apply&lt;/code&gt; 的时候会直接下发给 Scheme 自带的 &lt;code&gt;apply procedure&lt;/code&gt; ，因此我们在自己定义 &lt;code&gt;apply&lt;/code&gt; 之前记得先保存下默认的实现。&lt;/li&gt;&lt;li&gt;compound-procedure 这个看起来也很简单，就是把各个 procedure 分别 eval 处理过之后又会回到 &lt;code&gt;apply&lt;/code&gt; 过程之中，一个互生的调用又出现了。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;表达式处理和派生表达式&lt;/h3&gt;&lt;p&gt;要是详细的介绍对各种表达式的处理过程未免失与琐碎，这里就只挑选一个有代表性的 &lt;code&gt;if&lt;/code&gt; 语句来介绍处理过程，&lt;code&gt;if&lt;/code&gt; 的具体 eval 实现过程如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;eval-if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;true?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-predicate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-consequent&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-alternative&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个过程非常的简单，其中的 &lt;code&gt;if-predicate&lt;/code&gt; , &lt;code&gt;if-consequent&lt;/code&gt; , &lt;code&gt;if-alternative&lt;/code&gt; 都很不过是取出整个 &lt;code&gt;if-expr&lt;/code&gt; 之中的不同部分的：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tagged-list?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-predicate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cadr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-consequent&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;caddr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;if-alternative&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;not &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;null? &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdddr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cadddr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;ss&quot;&gt;&#39;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;整个 &lt;code&gt;if&lt;/code&gt; 的流程就这样拆解完了，根据 &lt;code&gt;predicate&lt;/code&gt; 拆借出来的结果运算流程重新进入了 &lt;code&gt;eval&lt;/code&gt; 投入了其他表达式类型的求值过程之中。这里使用 &lt;code&gt;if&lt;/code&gt; 作为例子还有一个因素就是这个 DSL 实现之中的 &lt;code&gt;cond&lt;/code&gt; 语句没有自己的具体实现逻辑，而是依赖组合的 &lt;code&gt;if&lt;/code&gt; 实现的，这被称作派生表达式。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tagged-list?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-clauses&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-else-clause?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-predicate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-predicate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;car &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-actions&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;clause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-&amp;gt;if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;expand-clauses&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-clauses&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;expand-clauses&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clauses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;null? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;clauses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;ss&quot;&gt;&#39;false&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;; no else clause&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;car &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;clauses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;clauses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-else-clause?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;null? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sequence-&amp;gt;exp&lt;/span&gt; 
                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-actions&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ELSE clause isn&#39;t &lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;                        last: COND-&amp;gt;IF&quot;&lt;/span&gt;
                       &lt;span class=&quot;nv&quot;&gt;clauses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-predicate&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sequence-&amp;gt;exp&lt;/span&gt; 
                      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cond-actions&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;expand-clauses&lt;/span&gt; 
                      &lt;span class=&quot;nv&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这段代码比较核心的也就是 &lt;code&gt;cond-&amp;gt;if&lt;/code&gt; 相关的函数了，但是也非常的简单就是解析 &lt;code&gt;cond&lt;/code&gt; 的结构，层层解析然后通过 &lt;code&gt;make-&amp;gt;if&lt;/code&gt; 生成逐级的 &lt;code&gt;nested-if&lt;/code&gt; 。&lt;/p&gt;&lt;h3&gt;解释器环境操作&lt;/h3&gt;&lt;p&gt;解释器的运行环境和我们在第一章、第二章里面解释过的运行环境基本上是一个东西，这不过这里面我们要来手动实现这个环境。这里我们把环境理解为绑定参数的表格就好了。这里给出了环境提供的默认的几个 API：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lookup-variable-value&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;extend-environment&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;variables&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;base-env&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;define-variable!&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-variable-value!&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;其中的 &lt;code&gt;lookup-variable-value&lt;/code&gt; 负责了在环境之中查找对应的变量，而  &lt;code&gt;extend-environment&lt;/code&gt; 则是在根据上级环境来拓展新的 env。&lt;/li&gt;&lt;li&gt;&lt;code&gt;define-variable!&lt;/code&gt; 和 &lt;code&gt;set-variable-value!&lt;/code&gt; 这一对 API 就比较简单了在环境之中定义变量和修改变量。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt; Tips 基础递归解释器的 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk/SICP-Magical-Book/blob/master/code/meta-evaluator/evaluator.rkt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;源码&lt;/a&gt;：&lt;br&gt; 这里给出了基础的递归解释器的实现代码，这里的程序可以直接使用 &lt;code&gt;racket&lt;/code&gt; 运行，记得要安装 &lt;code&gt;sicp&lt;/code&gt; 的包。&lt;br&gt; PS：这里还有一个问题，就是之前提到要提前把 &lt;code&gt;apply&lt;/code&gt; 方法保存起来，但是如果保存的过程和 &lt;code&gt;apply&lt;/code&gt; 的定义同时出现在一个文件里，就会被 &lt;code&gt;racket&lt;/code&gt; 认为是提前使用未定义方法 orz，因此这里我们单独把这个方法单独提出到一个文件里面引用了。&lt;br&gt; &lt;/blockquote&gt;&lt;h3&gt;以数据作为程序&lt;/h3&gt;&lt;p&gt;在上一节 &lt;code&gt;基础的递归解释器&lt;/code&gt; 之中我们实现了一个用 Scheme 描述的 Scheme 解释器，我们意识到一个元循环解释器本质上也是一个 Scheme procedure 本身，只不过输入的内容变成了 Scheme 程序本身。这也就是本节标题的意味，我们以数据作为求值器的输入，因此我们能够把数据作为程序来使用。&lt;/p&gt;&lt;p&gt;举出一个我们非常熟悉的 &lt;code&gt;factorial&lt;/code&gt; 过程：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;= &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;* &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们把这个过程看做一台机器，那我们就获得了一台只能够计算斐波那契数的机器：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a748e2250040f10540e9a6fc7b1b4d1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;324&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;500&quot; data-original=&quot;https://pic2.zhimg.com/v2-a748e2250040f10540e9a6fc7b1b4d1d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a748e2250040f10540e9a6fc7b1b4d1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;324&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;500&quot; data-original=&quot;https://pic2.zhimg.com/v2-a748e2250040f10540e9a6fc7b1b4d1d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a748e2250040f10540e9a6fc7b1b4d1d_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;如果我们接受了这种设定，那我们就可以以更高维度的眼光来看我们上述的元循环求值器。如果 &lt;code&gt;factorial&lt;/code&gt; 是一个特定的机器，那本身求值器就可以被认为是一台通用机器 (要素察觉)，其输入不再是一个具体的内容而是另一台机器（程序）的描述，而功能则变成了对这个机器的模拟过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-138b930b9c48b12eeb6a1377b4c30ba5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;479&quot; data-rawheight=&quot;289&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;479&quot; data-original=&quot;https://pic2.zhimg.com/v2-138b930b9c48b12eeb6a1377b4c30ba5_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-138b930b9c48b12eeb6a1377b4c30ba5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;479&quot; data-rawheight=&quot;289&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;479&quot; data-original=&quot;https://pic2.zhimg.com/v2-138b930b9c48b12eeb6a1377b4c30ba5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-138b930b9c48b12eeb6a1377b4c30ba5_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;这里我们意识到，我们上面的描述 &quot;另一台机器&quot; 并不准确，求值器是 Scheme 的一个 procedure ，因此求值器本身也可以描述自己。这也就是在书中元循环解释器为什么会被描述为编程语言和用户之间的桥梁，因为用户的输入本身成为了程序运行的一部分，现代的大多数语言也大多都实现了应用内的 &lt;code&gt;eval&lt;/code&gt; 过程。&lt;/p&gt;&lt;p&gt;其实在书中我们曾经提供以数据为程序的思想，当时的方式是把过程当成可传递的元素来处理，而现在我们能够提供更高层次的数据抽象 —— 抽象到语言。&lt;/p&gt;&lt;h3&gt;图灵机&lt;/h3&gt;&lt;p&gt;我们在上文中提到了求值器本质上是一个 &lt;code&gt;&quot;通用机器&quot;&lt;/code&gt; ，这种描述方式让人感觉似曾相识。按照我们上文讨论的说法，我们通过 Scheme 本身实现了一个 Scheme 的解释器，忽略时间和空间的角度上来讲一个解释器可以模拟任意的其他解释器。这样原则上可计算的概念向我们揭示了一个有关 &lt;code&gt;可计算性的&lt;/code&gt; 全新的领域，图灵根据上文的相似思想给出了称为图灵机的计算模型，证明了计算机的可实现。&lt;/p&gt;&lt;p&gt;图灵的基本思想是用机器来模拟人们用纸笔进行&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%2595%25B0%25E5%25AD%25A6&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;数学&lt;/a&gt;运算的过程，他把这样的过程看作下列两种简单的动作：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在纸上写上或擦除某个符号；&lt;/li&gt;&lt;li&gt;把注意力从纸的一个位置移动到另一个位置；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而在每个阶段，人要决定下一步的动作，依赖于（a）此人当前所关注的纸上某个位置的符号和（b）此人当前思维的状态。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-af98d4613865db3338ecd8422f11938e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;78&quot; class=&quot;content_image&quot; width=&quot;300&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-af98d4613865db3338ecd8422f11938e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;78&quot; class=&quot;content_image lazy&quot; width=&quot;300&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-af98d4613865db3338ecd8422f11938e_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3c21478a6a1aad0e5565d0e5f630a5b9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;84&quot; class=&quot;content_image&quot; width=&quot;300&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3c21478a6a1aad0e5565d0e5f630a5b9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;84&quot; class=&quot;content_image lazy&quot; width=&quot;300&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3c21478a6a1aad0e5565d0e5f630a5b9_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了模拟人的这种运算过程，图灵构造出一台假想的机器，该机器由以下几个部分组成：&lt;/p&gt;&lt;ol&gt;&lt;li&gt; 一条无限长的纸带&lt;b&gt;TAPE&lt;/b&gt;。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号 ${\displaystyle \square } $ 表示空白。纸带上的格子从左到右依次被编号为0, 1, 2, ...，纸带的右端可以无限伸展。&lt;br&gt; &lt;/li&gt;&lt;li&gt; 一个读写头&lt;b&gt;HEAD&lt;/b&gt;。该读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。&lt;br&gt; &lt;/li&gt;&lt;li&gt; 一套控制规则&lt;br&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;TABLE&lt;/p&gt;&lt;p&gt;。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态，按照以下顺序告知图灵机命令：&lt;/p&gt;&lt;ol&gt;&lt;li&gt; 写入（替换）或擦除当前符号；&lt;br&gt; &lt;/li&gt;&lt;li&gt; 移动 &lt;b&gt;HEAD&lt;/b&gt;， &#39;L&#39;向左， &#39;R&#39;向右或者&#39;N&#39;不移动；&lt;br&gt; &lt;/li&gt;&lt;li&gt; 保持当前状态或者转到另一状态&lt;br&gt; &lt;/li&gt;&lt;li&gt; 一个&lt;b&gt;状态寄存器&lt;/b&gt;。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态，称为&lt;i&gt;停机状态&lt;/i&gt;。&lt;br&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;注意这个机器的每一部分都是有限的，但它有一个潜在的无限长的纸带，因此这种机器只是一个理想的设备。图灵认为这样的一台机器就能模拟人类所能进行的任何计算过程。图灵机这样的定义在我们现在看来是显然的，基本上就是一个 &lt;code&gt;有限状态机&lt;/code&gt;的通俗化描述，但是在计算机还未诞生的当时代表了一种伟大的思想性革命。&lt;/p&gt;&lt;p&gt;结合上文，如果和我们使用的 Scheme 类比，每个 procedure 都能类比为一个特定的图灵机，那我们制作的 Scheme 解释器就可以类比于 &lt;code&gt;元图灵机(Universal Turing-Machine)&lt;/code&gt; ，元图灵机以其他的图灵机作为输入能够模拟其他图灵机的行为，这也是为何我们说 &lt;code&gt;通用机器&lt;/code&gt; 的描述不谋而合了。&lt;/p&gt;&lt;blockquote&gt; Tips: 关于可计算性 (Computability) &lt;br&gt; 关于图灵机、可计算性相关的知识笔者也只有概念上的理解。涉及到具体知识的学习笔者在看 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//introtcs.org/public/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CS121 Introduction to Theoretical Computer Science&lt;/a&gt; 这门入门课和 《Computability》这本书。&lt;br&gt; &lt;/blockquote&gt;&lt;h3&gt;停机问题&lt;/h3&gt;&lt;p&gt;在上一节图灵机的描述里面我们提到了图灵机有一个特殊的停机问题，通俗地说，停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。这个题目也出现在了书中的 4.15 题目之中：&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;Exercise 4.15:&lt;/b&gt; Given a one-argument procedure &lt;code&gt;p&lt;/code&gt; and an object &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; is said to “halt” on &lt;code&gt;a&lt;/code&gt; if evaluating the expression &lt;code&gt;(p a)&lt;/code&gt;returns a value (as opposed to terminating with an error message or running forever). Show that it is impossible to write a procedure &lt;code&gt;halts?&lt;/code&gt; that correctly determines whether &lt;code&gt;p&lt;/code&gt; halts on &lt;code&gt;a&lt;/code&gt; for any procedure &lt;code&gt;p&lt;/code&gt; and object &lt;code&gt;a&lt;/code&gt;. Use the following reasoning: If you had such a procedure &lt;code&gt;halts?&lt;/code&gt;, you could implement the following program:&lt;br&gt; &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run-forever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run-forever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;halts?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run-forever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;ss&quot;&gt;&#39;halted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 &lt;code&gt;halts&lt;/code&gt; 肯定是找不到的，&lt;code&gt;try&lt;/code&gt; 的实现本身就是 &lt;b&gt;交叉&lt;/b&gt; 矛盾的，如果有 &lt;code&gt;(halts? p p )&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; 那就会 &lt;code&gt;run-forever&lt;/code&gt; 持续运行下去，而如果 &lt;code&gt;(halts? p p)&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt;，那么程序又会 &lt;code&gt;halted&lt;/code&gt; 。因此我们能非常直观的从程序而非逻辑、数学的角度来发现这个问题。&lt;/p&gt;&lt;blockquote&gt; Tips 其实图灵发现的这个奇怪的反证方法并不是靠灵光一闪，而是康托尔 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%25B0%258D%25E8%25A7%2592%25E8%25AB%2596%25E8%25AD%2589%25E6%25B3%2595&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;对角线方法&lt;/a&gt; 的一个实质的应用，读一下 《Gödel, Escher, Bach: An Eternal Golden Braid》 之中的相关章节，能获得更多的情报。&lt;br&gt; &lt;/blockquote&gt;&lt;h3&gt;内部定义&lt;/h3&gt;&lt;p&gt;内部定义这一节里我们主要讨论的问题的主要是关于查找环境引用，我们上面实现的 &lt;code&gt;eval &amp;amp; apply&lt;/code&gt; 系统之中环境的置入都是按照顺序的，好在我们的 Scheme 求值器的方法定义和实际使用的求值时机不同。例子可以看一下这个互调的方法示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;even? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;= &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;odd? &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;odd? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;= &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;even? &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rest&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;even&lt;/code&gt; 的过程被定义的时候 &lt;code&gt;odd&lt;/code&gt; 的实现还没有被定义，按照我们的定义的语义应该是 &lt;code&gt;even&lt;/code&gt; 和 &lt;code&gt;odd&lt;/code&gt; 同时被加入该环境。这在实际之中很难被实现，不过我们也应该能很简单的想出解决办法，可以在原部分放一个名字或者一个假的引用，当对应的 &lt;code&gt;define&lt;/code&gt; 被填充进去了之后被调用就能正常被 link 到了。书中给出的方法其实也是其中的一种方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vars&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;; 转换成&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vars&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;*unassigned*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;*unassigned*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set! &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set! &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;e3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里是通过自动为每个定义块自动提前添加一个 &lt;code&gt;let&lt;/code&gt; 的定义项目，然后先设置为预定义状态，然后当对应的项目被定义之后再对其进行重定义。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;这一节的内容比较的简单，主要是通过对前几章提供的抽象手段，再一次提供一个更为深入的抽象方法 —— 语言抽象。随即我们引入 &lt;code&gt;eval &amp;amp; apply&lt;/code&gt; 的核心流程、增加解释器的环境操作，完成了基础的 Scheme 元循环解释器。随后又讨论了和程序抽象环境查找的一些 case ，浅尝辄止的引入了和图灵机、停机问题的相关讨论。下一章里面我们会对基础的 Scheme 解释器实现进行修改，增加诸如 JIT、amb 实现等相关内容。&lt;/p&gt;</description>
<author>lfkdsk</author>
<guid isPermaLink="false">2019-03-21-59996663</guid>
<pubDate>Thu, 21 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>试论 co- 的译法：余弦 cosine 词源漫谈</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-21-56285253.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56285253&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-67648d140ef6622892298c7b7d3b66a7_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;本文作为生日礼物题献给 &lt;/b&gt;&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/67ebe1bd8e4a63f17a42572e40afaac7&quot; data-hash=&quot;67ebe1bd8e4a63f17a42572e40afaac7&quot; data-hovercard=&quot;p$b$67ebe1bd8e4a63f17a42572e40afaac7&quot;&gt;@兴趣使然千里冰封&lt;/a&gt;&lt;b&gt;，内容以深度优先遍历的方式论述。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;题图为&lt;/b&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.pixiv.net/member_illust.php%3Fmode%3Dmedium%26illust_id%3D66039061&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;鬼人正邪&lt;/a&gt;&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;#2019-3-14 更新&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;在思考了各种现行翻译和词义演变的现象后，笔者最终还是决定在一些情况下将 co- 译作「余」，即将「余」字的含义泛化，等同于 co-。这样处理后可以避免各种歧义和不必要的联想，也方便翻译工作。如果有人好奇 co- 翻译成「余」的原因，那么可以将本文作为参考来源告知。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;根据评论里 Sora 的说法：&lt;/p&gt;&lt;blockquote&gt;私以为 coinductive 用“余”还更好点，因为它有“恰到好处的疏离感”。跟其他的， where “逆”有特定含义的数学分支凑在一起时，这样反而可能引起不好的联想，逆似乎暗示着某种结合性。上同调那个就是很好的例子，并不是什么都反过来了。要是动用一点“空间想象”，我们也可以把 inductive 跟 coinductive 当成图论里那种对偶--在概念的空间里互相插空--的关系。&lt;br&gt;另外，似乎 co- 因能指广泛被（懒惰的）数学家拿来当 gateway 用才让事情变得这么麻烦的&lt;/blockquote&gt;&lt;p&gt;以下为原文：&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;从勾股定理到三角函数&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;数之法，出于圆方。圆出于方，方出于矩。矩出于九九八十一。故折矩，以为句广三，股修四，径隅五。既方之外，半其一矩。环而共盘，得成三、四、五。两矩共长二十有五，是谓积矩。&lt;/blockquote&gt;&lt;p&gt;这段话出自我国的第一部数学著作《周髀算经》，开篇即是商高对勾股定理的最早表述。因此勾股定理又称商高定理。其中「句广三，股修四，径隅五」为勾股定理最经典的一个特例。后人则直接简称为「勾三股四弦五」来表述勾股定理。&lt;br&gt;&lt;br&gt;呃..简称？简在哪了？句怎么变成了勾？径怎么变成了弦？「广」「修」「隅」又是什么鬼？这要从甲古文说起。&lt;br&gt;&lt;br&gt;先说勾。其实汉字在隶变之前并没有这个字，而只有「句（gōu）」字。句源于丩，甲古文和金文如下图所示，很像一个钩子上挂了东西：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ce7512d8460d8b8b724e852cd8c63d5d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;514&quot; data-rawheight=&quot;267&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;514&quot; data-original=&quot;https://pic2.zhimg.com/v2-ce7512d8460d8b8b724e852cd8c63d5d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ce7512d8460d8b8b724e852cd8c63d5d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;514&quot; data-rawheight=&quot;267&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;514&quot; data-original=&quot;https://pic2.zhimg.com/v2-ce7512d8460d8b8b724e852cd8c63d5d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ce7512d8460d8b8b724e852cd8c63d5d_b.jpg&quot;&gt;&lt;figcaption&gt;「句」的演变&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;丩在演变成金文时，多了下面的口字，许是用来钩鱼嘴的。一直到小篆，下面这个口都是可选的，后来才慢慢定了下来。在汉字的书体隶变时，口变成了厶，才有了现在的勾。同样因隶变而成为异体字的的还有「强」和「強」。&lt;br&gt;&lt;br&gt;那么「句」又是如何有了「语句」的意思呢？原因是古文中没有标点，教学时要明句读。为了辅助标记，便在断句处的字旁边勾一个𠄌，久而久之，「勾」便有了语句的意思。勾句自此分化。兴许是为了表示区分，用带厶的表示勾批，用带口的表示语句。至于朱批句读画出的圆圈变成了句号，那是后话了。&lt;br&gt;&lt;br&gt;说到这里，不得不提一下被万千程序员吐槽的「句柄（handle）」。「柄」好理解，「句」哪来的？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;句柄乎？勾柄乎？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;「句柄」一词最早的考证来自于一本编译原理的著作，指的是语句中最先被归约的部分。维基百科中该词条给出的来源如下：&lt;/p&gt;&lt;blockquote&gt;康奈尔大学副教授David Gries所著的《Compiler Construction for Digital Computer》. John Wiley and Sons, New York, 1971, 491 pages, ISBN 0-471-32776-X，给出如下定义：&lt;br&gt;(2.3.10) DEFINITION. A handle of any sentential form is a leftmost simple phrase.&lt;br&gt;&lt;br&gt;在该书的中译本： D.格里斯著,仲萃豪等译：《数字计算机的编译程序构造》，科学出版社, 1976年版，给出了如下翻译：&lt;br&gt;(2.3.10) 定义. 任一句型的句柄就是此句型的最左简单短语。&lt;/blockquote&gt;&lt;p&gt;这里似乎应当读 jù 了，可后面紧接着又来了一句：&lt;/p&gt;&lt;blockquote&gt;「句」字在汉语中发 gōu 音时，做「查考」之义，如:句校(查考校核);句考(查考);句稽(查考;核算)。&lt;/blockquote&gt;&lt;p&gt;而「句」作「查考」解的来源，则是古人在查阅卷集时「勾批」的动作衍生而来的。&lt;/p&gt;&lt;p&gt;很明显，原文中只是「句子」，并无「查考」之意。&lt;br&gt;&lt;br&gt;然而，handle 还有另一个意思：&lt;/p&gt;&lt;blockquote&gt;在程序设计中，句柄（handle）是 Windows 操作系统用来标识被应用程序所创建或使用的对象的整数。其本质相当于带有引用计数的智能指针。&lt;/blockquote&gt;&lt;p&gt;这个解释更为广大程序员所熟知。在这里，「句柄」变成了用以索取对象这个大头的小钩子，正如提起一只樱桃时双指捏住的果柄。而在使用 git cherry-pick 时，散列值（hash）便成了对应提交（commit）的勾柄（handle）或指针（pointer）。&lt;br&gt;&lt;br&gt;handle 本有两义，在翻译成汉语时也应区别对待。仲老古汉语修为颇深，在翻译语句的 handle 时想到了「柄」字。而后人遇到了作为指针的 handle 时，前面的「句」想也不想便直接拿来用了。而巧合的是，「句」作「勾」解居然也是可以的。&lt;/p&gt;&lt;p&gt;网上有人说「句柄」是「勾柄」打错了字，虽是臆测，不过也不失为一个好写法。有鉴于此，我比较倾向于&lt;a href=&quot;https://www.zhihu.com/question/64808475/answer/224510814&quot; class=&quot;internal&quot;&gt;「句柄」的句应该读jù还是gōu？ - 思無邪SyiMyuZya的回答&lt;/a&gt;，即表示语句（sentence）时，读 jù。而作指针解时，「勾柄」则是现代汉语中更好的写法。&lt;br&gt;&lt;br&gt;其实「勾柄」这个东西，99%的中国人都见过，也都用过。用白话说，勾柄就是弯弯的「把手」，它长这样：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-70afcc93359534c44200465ee5fe31d9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2000&quot; data-rawheight=&quot;1250&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2000&quot; data-original=&quot;https://pic2.zhimg.com/v2-70afcc93359534c44200465ee5fe31d9_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-70afcc93359534c44200465ee5fe31d9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2000&quot; data-rawheight=&quot;1250&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2000&quot; data-original=&quot;https://pic2.zhimg.com/v2-70afcc93359534c44200465ee5fe31d9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-70afcc93359534c44200465ee5fe31d9_b.jpg&quot;&gt;&lt;figcaption&gt;门把手&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;而还有一种东西，它在某宝上的名字叫「勾柄直杆伞」，它长这样：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0074ca36aad3b04f9a2145317cb21dce_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3500&quot; data-rawheight=&quot;2372&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;3500&quot; data-original=&quot;https://pic3.zhimg.com/v2-0074ca36aad3b04f9a2145317cb21dce_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0074ca36aad3b04f9a2145317cb21dce_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3500&quot; data-rawheight=&quot;2372&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;3500&quot; data-original=&quot;https://pic3.zhimg.com/v2-0074ca36aad3b04f9a2145317cb21dce_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0074ca36aad3b04f9a2145317cb21dce_b.jpg&quot;&gt;&lt;figcaption&gt;Pixiv ID: 72998875&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;相信你已经知道什么是句柄了。&lt;/p&gt;&lt;p&gt;跑个题：「套接管」长这个样子：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0a45495ec4cc024ddb7a530deabdbb84_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;309&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;580&quot; data-original=&quot;https://pic1.zhimg.com/v2-0a45495ec4cc024ddb7a530deabdbb84_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0a45495ec4cc024ddb7a530deabdbb84_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;309&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;580&quot; data-original=&quot;https://pic1.zhimg.com/v2-0a45495ec4cc024ddb7a530deabdbb84_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-0a45495ec4cc024ddb7a530deabdbb84_b.jpg&quot;&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;修广长宽，径隅成弦&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;说完了句，后面就好说了。「修」表示长，「广」表示宽。「宽广」「修长」，汉语中很常见的近义字组词。《诗经·小雅·六月》中亦有「四牡修广，其大有颙」来形容战马的长宽高大。&lt;br&gt;「股」是大腿，「句」是曲折勾起来的脚。用勾股来形容短边长边，再合适不过了。&lt;br&gt;（&lt;b&gt;此处应有冰冰黑丝勾股照.jpg&lt;/b&gt;）有趣的是，广本意为宽，到了矩形里却成了短边。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2be199ce7efa402491a2ab696319480_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;375&quot; data-rawheight=&quot;281&quot; class=&quot;content_image&quot; width=&quot;375&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2be199ce7efa402491a2ab696319480_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;375&quot; data-rawheight=&quot;281&quot; class=&quot;content_image lazy&quot; width=&quot;375&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a2be199ce7efa402491a2ab696319480_b.jpg&quot;&gt;&lt;figcaption&gt;曲尺&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;「折矩」语出《礼记 - 玉藻》：「周还中规，折还中矩。」后亦有《复庄卫生书》：「周规折矩，尺步绳趋」。用矩尺定的折角，就是直角。&lt;/p&gt;&lt;p&gt;「径」为形声字，从「彳(chì)」「巠」声。本义为步行小路。「远上寒山石径斜」就是这个意思。「勾股」成曲，「径直」走的近路便是指长边了。&lt;/p&gt;&lt;p&gt;「隅」为角落，「偏安一隅」就是这个意思。把一根棍子搭在墙角，就是径隅。&lt;br&gt;&lt;br&gt;「故折矩，以为句广三，股修四，径隅五。」&lt;br&gt;&lt;br&gt;这句话翻译成现代汉语就是：如果有一个直角，短边宽三，长边长四，那么搭在这个角上的斜边就是五。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-93d0fb80cde6b41f31ddb943482f9db4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;330&quot; data-rawheight=&quot;266&quot; class=&quot;content_image&quot; width=&quot;330&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-93d0fb80cde6b41f31ddb943482f9db4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;330&quot; data-rawheight=&quot;266&quot; class=&quot;content_image lazy&quot; width=&quot;330&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-93d0fb80cde6b41f31ddb943482f9db4_b.jpg&quot;&gt;&lt;figcaption&gt;勾股定理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;现在还有个问题：径是怎么变成弦的？&lt;/p&gt;&lt;p&gt;弦即弓弦，下面这个图形叫「弓形」，其中的线段 AB 就是「弦」：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8ed4dedf989fb2cecbc33f03dfbb519f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1238&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-8ed4dedf989fb2cecbc33f03dfbb519f_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8ed4dedf989fb2cecbc33f03dfbb519f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1238&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1920&quot; data-original=&quot;https://pic4.zhimg.com/v2-8ed4dedf989fb2cecbc33f03dfbb519f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8ed4dedf989fb2cecbc33f03dfbb519f_b.jpg&quot;&gt;&lt;figcaption&gt;弓形&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当弦最长时，所得弓形即为半圆。&lt;/p&gt;&lt;p&gt;周朝的《周髀算经》虽然记载了商高对勾股定理的描述，但并没有给出严格的证明。到了三国时期，赵爽在他的《周髀算经注·勾股圆方图说》中第一次给出了勾股定理的严格证明。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a614f7c2b42e522274d5fef0e590a568_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;871&quot; data-rawheight=&quot;475&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;871&quot; data-original=&quot;https://pic1.zhimg.com/v2-a614f7c2b42e522274d5fef0e590a568_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a614f7c2b42e522274d5fef0e590a568_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;871&quot; data-rawheight=&quot;475&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;871&quot; data-original=&quot;https://pic1.zhimg.com/v2-a614f7c2b42e522274d5fef0e590a568_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a614f7c2b42e522274d5fef0e590a568_b.jpg&quot;&gt;&lt;figcaption&gt;赵爽 - 勾股圆方图&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cf26c0f675c973e07d3aaaedf5817b38_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;236&quot; class=&quot;content_image&quot; width=&quot;270&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cf26c0f675c973e07d3aaaedf5817b38_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;236&quot; class=&quot;content_image lazy&quot; width=&quot;270&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cf26c0f675c973e07d3aaaedf5817b38_b.jpg&quot;&gt;&lt;figcaption&gt;泰勒斯定理：如果AC是直径，那么∠ABC是直角。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;到了这里，勾股定理和圆的联系已呼之欲出，径也自然变成了直角三角的弦。魏晋时期的《九章算术》所用术语已于今无二：「勾股各自乘，并之，为弦实。开方除之，即弦。」我们终于可以说「勾三股四弦五」了。随之而来的「周三径一」，径也有了圆的直径的意思。后世宋朝的祖冲之也沿用了这一名词。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;西学东渐，余正相生&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;时光荏苒，转眼已到了明朝末年，这是第一次西学东渐开始的时代。&lt;/p&gt;&lt;blockquote&gt;三角学传入中国，始于明崇祯 4 年（1631年）。是年，邓玉函、汤若望和徐光启合编《大测》，作为历书的一部份呈献给朝廷，这是我国第一部编译的三角学。在《大测》中，首先将 sine 译为「正半弦」，简称「正弦」，这就成了「正弦」一词的由来。&lt;/blockquote&gt;&lt;p&gt;其实 sine 源于拉丁语 sinus，本意为「衣物的褶边，弯曲，曲线，女人的胸部」。可是本来表示弯曲的词，怎么又变成了直的弦了呢？&lt;/p&gt;&lt;p&gt;原来在最初，印度人将连结弧的两端的弦称为 ज्या (jyā)，源自梵语弓弦 जीव (jīva)。后来 jīva 这个词被中世纪伊斯兰数学家沿用了下来，译成了阿拉伯语     (jība)。由于阿拉伯语不写短元音，就以长元音 yāʾ 表示，写成了同形异义词 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+++++%E2%80%8E&quot; alt=&quot;     ‎&quot; eeimg=&quot;1&quot;&gt; (jayb)，意为「胸部，乳房」。到了 12 世纪中叶，意大利克雷莫纳的 Gherardo 在将一本阿拉伯文的几何学著作转译成中世纪拉丁语时，没有辨清词义，把本应指弓弦的 jayb 直译成了拉丁语中对应的乳房「sinus」。1590 年代，Thomas Fale 在他论述日晷的著作《Horologiographia, the Art of Dialling》一书中首先用 sinus 来表示现代三角学意义上的正弦函数。之后演变成了英语中的 sine。这样一来，「弦」就被掰弯了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0cf8f042eaca02e5cdd731d15a02b68_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;376&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;498&quot; data-original=&quot;https://pic1.zhimg.com/v2-c0cf8f042eaca02e5cdd731d15a02b68_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0cf8f042eaca02e5cdd731d15a02b68_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;376&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;498&quot; data-original=&quot;https://pic1.zhimg.com/v2-c0cf8f042eaca02e5cdd731d15a02b68_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c0cf8f042eaca02e5cdd731d15a02b68_b.jpg&quot;&gt;&lt;figcaption&gt;维基百科：梵语 jyā 的字面意思&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;而徐光启并未受此影响，因为他直接看到了三角函数的图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;470&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;676&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;470&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;676&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot;&gt;&lt;figcaption&gt;三角函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当然他看到的并不是这张图，但相信与此类似。中国古代研究圆时，向来以直径为基准，因此有「周三径一」的说法。徐光启在《大测》中，以圆的直径为基准，∠AOB 正对弓形 ADB 的弦 AB，即为正弦，线段 AC 则为正半弦。&lt;/p&gt;&lt;p&gt;而他在和利玛窦合译《几何原本》第三卷《圆与角》时，发现书中以半径为基准。由于三角函数的「正弦」描述的其实是正弦与直径之比，而等比缩放不改变比例关系，因此正半弦与半径之比自然还应该叫「正弦」。&lt;br&gt;&lt;br&gt;三角之于圆，有三条直线：弦线，切线和割线。sine line 为弦线，tangent line 为切线，secant line 为割线。如果把下图的 sin 和 tan 沿横轴对称补上，sec 以圆心对称补上，那就是汉语里原本意义上的弦、切和割了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4018dcbdeb6bfb115b5d5786b08f1e88_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;599&quot; class=&quot;content_image&quot; width=&quot;410&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4018dcbdeb6bfb115b5d5786b08f1e88_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;599&quot; class=&quot;content_image lazy&quot; width=&quot;410&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4018dcbdeb6bfb115b5d5786b08f1e88_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;相信不少人曾有这样的困惑：「切」和「割」有什么区别呢？其实在日常生活中，二者意思很接近。「割」就是割开，一分为二；「切」呢？还是切开的意思。&lt;/p&gt;&lt;p&gt;然而在「切线」这里，「切」其实应该读 qiè。《广雅》中有「切，摩也。」的解释。确切来说，就是「密合，贴近，紧挨着」的意思。「切脉」不是割脉，而是手指贴着脉来感受；「切肤之痛」也不是皮肤被划破了，而是与自身关系极为密切，自己能切身感受的痛苦。如果你是还不能理解，那么别人在对你表示亲切问候，深切关怀时，请做好防御准备（病娇控除外）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-89a970c841c649877f05e8b24d17e3d4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;450&quot; data-original=&quot;https://pic1.zhimg.com/v2-89a970c841c649877f05e8b24d17e3d4_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-89a970c841c649877f05e8b24d17e3d4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;450&quot; data-original=&quot;https://pic1.zhimg.com/v2-89a970c841c649877f05e8b24d17e3d4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-89a970c841c649877f05e8b24d17e3d4_b.jpg&quot;&gt;&lt;figcaption&gt;切与割&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;「切」读 qiē 时，和割还是有些区别的。割其实还有个「划拉」的动作，你可以从「割肉」「切水果」感受出来。&lt;/p&gt;&lt;p&gt;到这里，「正弦」「正切」「正割」已经溯本清源。现在终于轮到本文的主角「余」了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;470&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;676&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;470&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;676&quot; data-original=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c9b87f895fc8d43dad471e640d95d02a_b.jpg&quot;&gt;&lt;figcaption&gt;三角函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们还来看这张图。现在想象你站在圆心 O 点，向 E 处看去。∠AOB 是你可以清楚看到的范围，正前方的正弦是你看到的画面。然而当你注视前方时，你会还会发现视角的两边也能感受到模糊的画面，这叫做眼角的「余光」。余光所看到的画面（图中蓝线），就是余弦。&lt;br&gt;&lt;br&gt;「余」即剩余，我们在数学中最早接触的「余」就是「余数」，表示除不尽剩下的数。如果我们把正视的角叫「正角」∠AOB，那么余光所视的角就是它的「余角」∠AOF。于是我们得到了余角的定义：&lt;/p&gt;&lt;p&gt;若两角之和为直角（即 90°），则称这两个角「互为余角（complementary angles）」，简称「互余」。余角所对的弦，就是余弦。&lt;/p&gt;&lt;p&gt;顺带一提，若两角之和为平角（即 180°），则称这两个角「互为补角（supplementary angle）」，简称「互补」。&lt;/p&gt;&lt;p&gt;互余（complementary）的前缀 com-，和余弦（cosine）的 co- 其实来自同一个词源，作为拉丁语的前缀表示「一起，相伴（with, together）」的意思。com- 放到元音和轻音之前，变成了 co-；在 -g- 前，为 cog- 或 con-；在 -l- 前，为 col-；在 -r- 前为 cor-；在 -c-、-d-、-j-、-n-、-q-、-s-、-t- 和 -v- 前则化成了 con-。&lt;/p&gt;&lt;p&gt;一根射线将直角分为两半，二角相伴相生，此消彼长。所对应的正弦余弦亦是如此。然而在中文里，「余」只有剩余的意思，因此并不能把所有的 co- 都翻译成余。实际上，一切相生相克的东西，都是互 co- 的。男是 co-女，阴是 co-阳，天是 co-地，柔是 co-刚。&lt;/p&gt;&lt;p&gt;所以 co- 有了太多太多的译法：&lt;br&gt;&lt;br&gt;coerce 是围在一起，成了约制；covariant 是一起变型，成了协变；collect 是选出来放在一起，成了收集；conjugate 比作马车曲木的两端，成了共轭。coauthor 是合作者；codomain 是陪域。&lt;/p&gt;&lt;p&gt;余、共、互、逆、陪、伴、协、同、交、合、配、对、逆、反、偶、上……我们在看到这个词头时，不必像意呆利那个把胸部当成 jiba 的曲直不分的家伙那样直译，而是像徐光启那样，直接看清它的本质是什么。&lt;b&gt;知其变，守其恒，为天下式。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当我看到陈意云老师把 coinduction 翻译成「余归纳」的时候，我很困惑：「余」在哪了？而当我发现 coinduction 就是把归纳的过程反过来后，自然就有了它的译法：逆归纳。「反」是一个静态的描述，而「逆」是一个动态的表述。当归纳的箭头有了流动的方向，逆流而上便是把箭头反过来最自然的想法了。于是在英语世界，有了很多关于 co- 的妙语：&lt;/p&gt;&lt;blockquote&gt;Q : What does a category theorist call a reader?&lt;br&gt;A : A &quot;co-author&quot;.&lt;br&gt;问：范畴论学家把读者称为什么？&lt;br&gt;答：「协作者」。&lt;br&gt;&lt;br&gt;&quot;I had a dream last night. I cheated on my wife and she knew it.&quot;&lt;br&gt;&quot;But dream is coreality.&quot;&lt;br&gt;&quot;So the reality is?&quot;&lt;br&gt;&quot;Your wife cheated on you and you didn&#39;t know it.&quot;&lt;br&gt;「我做了一个梦，梦见我对我妻子出轨了，被我妻子知道了。」&lt;br&gt;「可是梦是与现实伴生的（co-现实）。」&lt;br&gt;「所以现实应该是？」&lt;br&gt;「你的妻子对你出轨了，而你还不知道。」&lt;br&gt;&lt;br&gt;A mathematician is a machine that turns coffee into theorems.&lt;br&gt;A comathematician is a comachine that coturns cotheorems onto ffee.&lt;br&gt;&lt;br&gt;在一个叫“上古卷轴”的游戏里，有一个卫兵的膝盖中了一箭。&lt;br&gt;在一个叫“古卷轴”的游戏里，有一枚上箭从上士兵的上膝盖里上射了出来。&lt;br&gt;&lt;br&gt;A coconut is just a nut.&lt;br&gt;（椰子就是坚果。）&lt;/blockquote&gt;&lt;p&gt;负负得正，看来 co- 是对合（involution）的。&lt;/p&gt;&lt;p&gt;本文其实已经接近尾声了，不过还有一个词的翻译差点让咱想瞒混过去：上同调（cohomology）。&lt;/p&gt;&lt;p&gt;「上」是哪来的？带着这个疑问，咱打开了维基百科的 cohomology 词条：&lt;/p&gt;&lt;blockquote&gt;In mathematics, specifically in homology theory and algebraic topology, cohomology is a general term for a sequence of abelian groups associated to a topological space, often defined from a cochain complex. Cohomology can be viewed as a method of assigning richer algebraic invariants to a space than homology. Some versions of cohomology arise by dualizing the construction of homology. In other words, cochains are functions on the group of chains in homology theory.&lt;/blockquote&gt;&lt;p&gt;当时咱就这个表情：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f7cdfa69c480febaa6fa8984227588f5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;400&quot; class=&quot;content_image&quot; width=&quot;400&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f7cdfa69c480febaa6fa8984227588f5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;400&quot; class=&quot;content_image lazy&quot; width=&quot;400&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f7cdfa69c480febaa6fa8984227588f5_b.jpg&quot;&gt;&lt;figcaption&gt;这啥？.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;不过既然是「上」，说不定有可以看出「上」的图来呢？Google 一下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-209d7c0633b2a752d1f9d6b374858b40_b.png&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;197&quot; data-rawheight=&quot;300&quot; class=&quot;content_image&quot; width=&quot;197&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-209d7c0633b2a752d1f9d6b374858b40_b.png&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;197&quot; data-rawheight=&quot;300&quot; class=&quot;content_image lazy&quot; width=&quot;197&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-209d7c0633b2a752d1f9d6b374858b40_b.png&quot;&gt;&lt;figcaption&gt;上环OwO？&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0bbb2bae7021842acbd6f5793c254ce_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1896&quot; data-rawheight=&quot;1720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1896&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0bbb2bae7021842acbd6f5793c254ce_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b0bbb2bae7021842acbd6f5793c254ce_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1896&quot; data-rawheight=&quot;1720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1896&quot; data-original=&quot;https://pic3.zhimg.com/v2-b0bbb2bae7021842acbd6f5793c254ce_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b0bbb2bae7021842acbd6f5793c254ce_b.jpg&quot;&gt;&lt;figcaption&gt;螺旋升天OwO？&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0cec68c0cc89f7878f9c9dfa3a8ec4f6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0cec68c0cc89f7878f9c9dfa3a8ec4f6_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0cec68c0cc89f7878f9c9dfa3a8ec4f6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1280&quot; data-original=&quot;https://pic3.zhimg.com/v2-0cec68c0cc89f7878f9c9dfa3a8ec4f6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0cec68c0cc89f7878f9c9dfa3a8ec4f6_b.jpg&quot;&gt;&lt;figcaption&gt;啥啥啥？这都是啥OwO？&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;好吧看来不行。不过那边有个 cochain complex，似乎很有关系，咱去瞅瞅：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-af9d7351ba4666bfb1ae22a7d368d261_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1075&quot; data-rawheight=&quot;1421&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1075&quot; data-original=&quot;https://pic2.zhimg.com/v2-af9d7351ba4666bfb1ae22a7d368d261_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-af9d7351ba4666bfb1ae22a7d368d261_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1075&quot; data-rawheight=&quot;1421&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1075&quot; data-original=&quot;https://pic2.zhimg.com/v2-af9d7351ba4666bfb1ae22a7d368d261_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-af9d7351ba4666bfb1ae22a7d368d261_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;虽然还是看不懂，不过这里能感受到某种对称性，最直观的就是反过来的箭头，那么「逆」或许是个不错的译法。不过且慢……&lt;/p&gt;&lt;p&gt;&lt;b&gt;chain complex&lt;/b&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28A_%7B%5Cbullet+%7D%2Cd_%7B%5Cbullet+%7D%29&quot; alt=&quot;(A_{\bullet },d_{\bullet })&quot; eeimg=&quot;1&quot;&gt; ↔ &lt;b&gt;cochain complex&lt;/b&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=%28A%5E%7B%5Cbullet+%7D%2Cd%5E%7B%5Cbullet+%7D%29&quot; alt=&quot;(A^{\bullet },d^{\bullet })&quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;cochain&lt;/b&gt; 里的黑点、数字和字母都标在右上角，所以 co 是「上」；&lt;b&gt;chain&lt;/b&gt; 里标在右下角的记法就是「下」了。我们在范畴论和各种 cohomology 里也能找到很多这种&lt;b&gt;上下角标对偶&lt;/b&gt;记法：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-839f826a55991a6d815db9de84890a7d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1079&quot; data-rawheight=&quot;238&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1079&quot; data-original=&quot;https://pic2.zhimg.com/v2-839f826a55991a6d815db9de84890a7d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-839f826a55991a6d815db9de84890a7d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1079&quot; data-rawheight=&quot;238&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1079&quot; data-original=&quot;https://pic2.zhimg.com/v2-839f826a55991a6d815db9de84890a7d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-839f826a55991a6d815db9de84890a7d_b.jpg&quot;&gt;&lt;figcaption&gt;注意 π 的上下角标对换了&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;哈哈，看来「上同调」的译者早已深谙此道了。&lt;br&gt;&lt;br&gt;这就是 co-，一个相生为伴，互克而消的故事。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这篇文章其实咱早就有了把它写出来的打算，可无奈拖延症+懒癌作怪，也想着收集更多的资料去印证各种想法。然而精力和学识有限，无法面面俱到，至臻完美。恰逢冰冰要作一个关于 CuTT 的演讲，里面很多术语找不到很好的译法，于是咱肝了两天把它写了出来，以作参考。同时，今天也是冰冰的生日，于是作为生日礼物送给他。&lt;b&gt;冰冰酱生快喵~！=w=&lt;/b&gt;&lt;br&gt;&lt;br&gt;本文参考了大量的资料，但写着写着网页就开了太多，内存被 Chrome 吞噬掉了，于是只好看完一点就关掉。很多参考来源已经不好找了，还要翻历史记录。后期咱会把引用来源慢慢补上。&lt;br&gt;&lt;br&gt;因为咱毕竟是 CS 专业的，这些内容很多属于词源学，所以超出了咱的专业范畴，本文可信度也略有折扣。文中字词之解时有妄测，Cat Oling 在这里恳请各位 reader 们能够真的作为 CO-author 帮忙审校斧正，在咱说「波乃水之皮时」能戏以「然则滑，水之骨也？」驳之。&lt;/p&gt;&lt;p&gt;其实在语言文字的演化过程中，我们会发现和生物演化很像的现象。生物演化的单位是基因（gene），而文化演化的单位是模因（meme），它们在历史的长河中演进、分化、变异、融合。时而复制出错，产生了功能完全不同的「蛋白质」，又反过来作用于文化自身，继续奔流涌进。正如有些生命会偷取其它基因片段一样，文化里也会拿来直接用。古人用典，今人玩梗，十分有趣。而有些在不同语言中本不相干的东西，因为巧合而变得更加挠人心魄。不过这些表面的东西，总是难以触碰到本质的。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;如果你对知识进行了彻底的分析而非某种机械的套弄，在你脑中生成的概念与生硬的文字之间已经没有很强的相似性，我们就认为这个概念是被理解的。彻底的分析和非凡的变换，是获得真知的标志性特征。—— 蛛酱&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;咱在写作过程中，发现了很多有用的网站，在这里推荐给大家：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.zdic.net/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;汉典&lt;/a&gt; 用于查找古汉语的字词之源&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.etymonline.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Online Etymology Dictionary&lt;/a&gt; 用于查询英语词源&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.wiktionary.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;维基词典&lt;/a&gt; 同样用于查询词源词义&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//wikisource.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;维基文库&lt;/a&gt; 查阅古籍很好用&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.geogebra.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GeoGebra&lt;/a&gt; 很棒的几何绘图工具&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//humanum.arts.cuhk.edu.hk/Lexis/lexi-mf/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;汉语多功能字库&lt;/a&gt; 汉语词源&lt;/p&gt;&lt;p&gt;其它还有维基百科、百度百科、知乎、雅虎问答、Quora、Stack Overflow 等都可以用来参考。当然，你必须能够&lt;b&gt;正常访问互联网&lt;/b&gt;，毕竟我们仍在西学东渐中，多几个没有生在明末的徐光启总是好的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;引用来源（持续补充中）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//tw.answers.yahoo.com/question/index%3Fqid%3D20060408000012KK11826%26guccounter%3D1&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《周髀算经》首段翻译&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/28528431/answer/45928559&quot; class=&quot;internal&quot;&gt;「勾」与「句」二字（一字）是如何演变的？ - restraint的回答 - 知乎&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wiktionary.org/zh-hans/%25E4%25B8%25A9&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;丩 - 维基词典&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/64808475/answer/224510814&quot; class=&quot;internal&quot;&gt;「句柄」的句应该读jù还是gōu？ - 思無邪SyiMyuZya的回答 - 知乎&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/22950899/answer/25216796&quot; class=&quot;internal&quot;&gt;为什么handle会被翻译成句柄？ - Peng DU的回答 - 知乎&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/20127354/answer/14062370&quot; class=&quot;internal&quot;&gt;三角函数：正弦、余弦、正切、余切、正割、余割，这些名字的来源是什么？ - 知乎&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/31643084&quot; class=&quot;internal&quot;&gt;在数学里co-这个词头是个什么感觉?&lt;/a&gt;&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2019-03-21-56285253</guid>
<pubDate>Thu, 21 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（七）初见 Hylomorphism</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-19-59661152.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59661152&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;到目前为止，我们已经讨论了相当多种 recursion schemes。Catamorphism 和 Anamorphisms 对数据结构进行折叠和展开。Paramorphisms 和 Apomorphisms 在维持上述操作的同时还能保持额外的信息，而 Histomorphisms 和 Futumorphisms 可以让我们在折叠时使用历史的信息，或者在展开时使用自定义的控制流。&lt;/p&gt;&lt;p&gt;对于每种折叠操作 &lt;code&gt;cata&lt;/code&gt;，&lt;code&gt;para&lt;/code&gt;，&lt;code&gt;histo&lt;/code&gt;，我们通过“翻转箭头”来导出对应的展开操作。更正式一点地说，我们实际上求解的是折叠操作范畴上的对偶操作。现在我们知道可以通过折叠操作来导出展开操作（反之亦然）。再加上函数的组合性质，一个新的问题呼之欲出“如果我们把展开操作和折叠操作组合起来会发生什么？”我们这次就来讨论这个问题。（这篇文章的所以代码均使用 Haskell，所有出现的代码均可以在&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/patrickt/recschemes/blob/master/src/Part5.lhs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;找到）&lt;/p&gt;&lt;h2&gt;折叠与基质&lt;/h2&gt;&lt;p&gt;Meijer et. al 在 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//maartenfokkinga.github.io/utwente/mmf91m.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bananas, Lenses, Envelopes, and Barbed Wire&lt;/a&gt; 中回答了这一问题，我们首先从一个种子数值里生成某种数据结构，接着在该数据结构上通过折叠计算最终结果，这样得到的复合操作我们称为 Hylomorphism[1]，这个名字实在难以直观理解，我更喜欢将这一方法称为‘生产者消费者方法’，其中展开操作负责生产，而折叠操作则负责消费。&lt;/p&gt;&lt;p&gt;如果你理解了之前的关于 Catamorphism（折叠）与 Anamorphism（展开）的概念，那么 Hylomorphism 是非常简单的。就是后者紧接着前者即可，所以容易得到：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hylo&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Coalgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;hylo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ana&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cata&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;非常直观，对吧？&lt;code&gt;ana&lt;/code&gt; 负责展开并提供 coalgebra，&lt;code&gt;cata&lt;/code&gt; 负责折叠并提供 algebra。&lt;/p&gt;&lt;p&gt;Hylomorphism 中的 hylo 来做 希腊语 hyle， ὕλη，意思是基质。古希腊人用基质代表一个物体产生之前的原料，我们这里的 Hylomorphism 正是作为某种将基质转换为最终结果的函数。&lt;/p&gt;&lt;p&gt;有趣的一点是 &lt;code&gt;Term&lt;/code&gt;，作为 &lt;code&gt;Functor&lt;/code&gt; 的不动点，在 &lt;code&gt;hylo&lt;/code&gt; 的函数签名中并没有出现。尽管 &lt;code&gt;ana&lt;/code&gt; 和 &lt;code&gt;cata&lt;/code&gt; 的函数签名中均包含 &lt;code&gt;Term f&lt;/code&gt;，但它在最终的函数签名中被抵消掉了，唯一必要的是一个可以生成 algebra 和 coalgebra 的 &lt;code&gt;Functor&lt;/code&gt;。类似地，在 Kmett 的&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html%23v%3Ahylo&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;形式化&lt;/a&gt;中，&lt;code&gt;hylo&lt;/code&gt; 也不使用 &lt;code&gt;Base&lt;/code&gt; 函子。&lt;/p&gt;&lt;h2&gt;形形色色的 Hylo&lt;/h2&gt;&lt;p&gt;Hylomorphism 并不仅仅是一个漂亮的理论结果，它可以被看做是许多我们日常计算的抽象，一个陈词滥调的例子是阶乘函数。单实际上 Hylo 的能力远不仅仅于此，尽管我们常常未能注意到这一一般性，我们在各个地方都会使用 hylomorphism：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;聚合某些数据结构的属性，比如决定一组数据的平均数或是中位数&lt;/li&gt;&lt;li&gt;从某种文字嵌套结构中解释或编译得到最终结果&lt;/li&gt;&lt;li&gt;实现递归的分治结构，比如快速排序，归并排序，甚至于快速傅里叶变换&lt;/li&gt;&lt;li&gt;计算两种结构上的差异，比如字符串的编辑距离或莱文斯坦距离&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们来看一个 &lt;code&gt;hylo&lt;/code&gt; 的实践例子。我们使用 &lt;code&gt;hylo&lt;/code&gt; 来搭建一个&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Reverse_Polish_notation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;逆波兰表达式计算器&lt;/a&gt;。给出字符串 &lt;code&gt;1 2 +&lt;/code&gt;，我们应该计算 &lt;code&gt;1 + 2&lt;/code&gt;，而 &lt;code&gt;2 1 12 3 / - +&lt;/code&gt; 则对应 &lt;code&gt;2 + 1 - 12 / 3&lt;/code&gt;：每个逆波兰表达式都有唯一确定的解析形式，使用逆波兰表达式可以不使用中缀表达式中我们常见的括号。我们的 coalgebra 会将一个字符串展开为操作的列表，接着 algrbra 会消费这个列表，从而得到一个一组计算结果。&lt;/p&gt;&lt;p&gt;如前所述，我们的逆波兰表达式的计算器包括两种值：数值运算或整数字面量。我们定义 &lt;code&gt;Token&lt;/code&gt; 类型来表示：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;
  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意到我们的构造函数里包括一个函数 &lt;code&gt;Int -&amp;gt; Int -&amp;gt; Int&lt;/code&gt;，而非一个字符串表示，由于函数没有有意义的字符串表示，导致 &lt;code&gt;Token&lt;/code&gt; 不是 &lt;code&gt;Show&lt;/code&gt; 的一个实例。但这样会简化我们的实现，当我们需要使用这个函数时，我们只需从栈中弹出这个函数，并直接应用计算即可。&lt;/p&gt;&lt;p&gt;我们还需要将字符串解析为 &lt;code&gt;Token&lt;/code&gt;，正统一点的做法将是使用一个解析函数库，例如 &lt;code&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//hackage.haskell.org/package/megaparsec&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;megaparsec&lt;/a&gt;&lt;/code&gt;或 &lt;code&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//hackage.haskell.org/package/trifecta&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;trifecta&lt;/a&gt;&lt;/code&gt; 甚至使用 &lt;code&gt;Maybe&lt;/code&gt; 函子去做错误处理。但这里出于代码简洁性考虑，我们就简单地使用 &lt;code&gt;read&lt;/code&gt;，如果有不合法数据，就直接抛出运行时错误。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;+&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码很好理解，我们使用模式匹配得到对应的数学表达式，放入 &lt;code&gt;Op&lt;/code&gt; 中，如果是数字的话，我们使用 &lt;code&gt;read&lt;/code&gt; 来获取 &lt;code&gt;Int&lt;/code&gt; 包裹成字面量。&lt;/p&gt;&lt;p&gt;一个先进先出的栈在 Haskell 中可以很好地用列表来表示，&lt;code&gt;push&lt;/code&gt; 操作使用 &lt;code&gt;:&lt;/code&gt;，&lt;code&gt;pop&lt;/code&gt; 操作可以使用 &lt;code&gt;tail&lt;/code&gt; 即可。尽管上一章中我们讨论了如何使用 &lt;code&gt;Base&lt;/code&gt; 类型类来使 Haskell 中的 &lt;code&gt;[]&lt;/code&gt; 兼容 recursion schemes。但我们还是在这里使用我们自己定义的方式。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们已经有了 &lt;code&gt;List&lt;/code&gt; 用来存放 &lt;code&gt;Token&lt;/code&gt;，那么我们下一步就要定义 &lt;code&gt;Coalgebra&lt;/code&gt; 来从 &lt;code&gt;String&lt;/code&gt; 中得到 &lt;code&gt;Token&lt;/code&gt;。回忆我们此前 &lt;code&gt;Coalgebra&lt;/code&gt; 的定义：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Coalgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的种子值 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;String&lt;/code&gt;，而 &lt;code&gt;f&lt;/code&gt; 为 &lt;code&gt;List Token&lt;/code&gt;，我们将类型签名代入 &lt;code&gt;Coalgebra&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Coalgebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;记住 &lt;code&gt;List Token&lt;/code&gt; 是部分应用的，它的签名是 &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;，所以 &lt;code&gt;f a&lt;/code&gt; 是 &lt;code&gt;List Token String&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样也是合理的，在每一步，我们展开列表中的元素，并得到 &lt;code&gt;Token&lt;/code&gt;，以及其余需要解析的 &lt;code&gt;String&lt;/code&gt; 直到我们得到 &lt;code&gt;Nil&lt;/code&gt;，这时我们就停止展开，因为 &lt;code&gt;Nil&lt;/code&gt; 也是 &lt;code&gt;List Token String&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;现在我们来实现 &lt;code&gt;rpn&lt;/code&gt; 的函数体。最简单地情况是处理空字符串，对于空字符串我们不需要做任何展开，直接返回 &lt;code&gt;Nil&lt;/code&gt; 即可。（&lt;code&gt;ana&lt;/code&gt; 知道在遇到 &lt;code&gt;Nil&lt;/code&gt; 时停止递归是因为递归的 &lt;code&gt;fmap&lt;/code&gt; 在这时会停止，&lt;code&gt;Nil&lt;/code&gt; 不包含其它子节点）&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于非空字符串的情形会更有趣一些，我们首先从字符串 &lt;code&gt;str&lt;/code&gt; 中按空格分割，并将第一段传给 &lt;code&gt;parseToken&lt;/code&gt;，将结果 &lt;code&gt;Cons&lt;/code&gt; 的 &lt;code&gt;a&lt;/code&gt; 部分，而将剩余的字符串作为 &lt;code&gt;b&lt;/code&gt; 部分。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;     &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;   &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dropWhile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将两种情况合并起来：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Coalgebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;     &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parseToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;   &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dropWhile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看起来还不错，仅仅只有六行代码，如果输入是 &lt;code&gt;3 4 +&lt;/code&gt;，我们运行 &lt;code&gt;ana parseRPN&lt;/code&gt;，就会得到与列表 &lt;code&gt;Lit 3, Lit 4, Op +, Nil&lt;/code&gt; 等价的结果。&lt;/p&gt;&lt;p&gt;现在我们还要实现 &lt;code&gt;Algebra&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们这里的 &lt;code&gt;f&lt;/code&gt; 也将是 &lt;code&gt;List Token&lt;/code&gt;，但是 &lt;code&gt;a&lt;/code&gt; 是不一样的，我们希望这里的类型是一个整数栈，既可以压元素入栈，也可以使用 &lt;code&gt;Op&lt;/code&gt; 来操作。具体的定义如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么代入类型签名得到：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但这时我们遇上了问题，考虑一个逆波兰表达式 &lt;code&gt;2 3 +&lt;/code&gt; 或 &lt;code&gt;4 2 5 * + 1 3 2 * + /&lt;/code&gt;，我们需要由左向右求解，将字面量压入栈中，接着对于栈顶的两个元素应用操作，这意味着我们的求值器必须由左向右进行计算（类似 &lt;code&gt;foldl&lt;/code&gt;）而不能由右向左计算（即 &lt;code&gt;foldr&lt;/code&gt;）。但我们的 &lt;code&gt;cata&lt;/code&gt; 是右折叠的，它一直递归到 &lt;code&gt;Nil&lt;/code&gt; 元素，并从这里开始向上传递结果。而 &lt;code&gt;holy&lt;/code&gt; 并没有给我们逆转解析完成的数组的机会，我们该怎么解决这个问题呢？ &lt;/p&gt;&lt;p&gt;答案也很简单，我们并不会使用一般的 &lt;code&gt;Stack&lt;/code&gt; 元素作为返回值。而是返回一个由 &lt;code&gt;Stack&lt;/code&gt; 到 &lt;code&gt;Stack&lt;/code&gt; 的函数：&lt;code&gt;Stack -&amp;gt; Stack&lt;/code&gt;。而对于最后返回的函数，我们使用一个空栈来激活计算并获得最终结果。&lt;i&gt;因为最左边的元素是最晚处理的，所以得到的结果函数中会最先处理最左边的元素&lt;/i&gt;。这样我们就可以由左到右完成计算，直到 &lt;code&gt;Nil&lt;/code&gt;。而这一函数的输入参数就是计算使用的初始值。&lt;/p&gt;&lt;p&gt;下图也许能够对于理解这一问题有所帮助：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1022&quot; data-rawheight=&quot;766&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1022&quot; data-original=&quot;https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1022&quot; data-rawheight=&quot;766&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1022&quot; data-original=&quot;https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;构建过程如蓝线所示：自右向左构建函数，初始函数为 id，并对后续元素不断调用 algebra 来获取之后生成的函数。 1. cata 函数从这里进入，并递归只最右侧。 2. 从最右侧元素开始自右向左构建返回函数。 求值过程如红线所示：函数最先操作最后生成的节点，由左向右进行。 3. 函数调用位置为 cata 函数结束的位置，自左向右完成调用。 4. 最后获得最终结果 [9]。&lt;/p&gt;&lt;p&gt;通过将返还值改为返回函数，我们就可以将 cata 的由右至左求值顺序改写为由左至右求值，这一过程往往令人疑惑。通过改变返回值我们增强了 &lt;code&gt;cata&lt;/code&gt; 的能力。而这一个在函数式编程领域人所共知的技巧。而这里的 &lt;code&gt;Stack&lt;/code&gt; 就是某种差分结构，一如 Haskell 中 &lt;code&gt;Show&lt;/code&gt; 的实现。&lt;/p&gt;&lt;p&gt;下面我们使用 &lt;code&gt;Stack -&amp;gt; Stack&lt;/code&gt; 改写下上面的代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们展开 &lt;code&gt;Algebra&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在实现时我们需要考虑 &lt;code&gt;Nil&lt;/code&gt; 和 &lt;code&gt;Cons&lt;/code&gt; 两种情况，&lt;code&gt;Nil&lt;/code&gt; 的情况比较简单，我们只需要返回同样的函数即可，因为没有任何需要对原函数进行更改的地方。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 即 `id`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;尽管这里我们需要返回的是一个函数，但我们可以将它的参数 &lt;code&gt;Stack&lt;/code&gt; 视为 &lt;code&gt;evalRPN&lt;/code&gt; 的参数[2]。&lt;/p&gt;&lt;p&gt;下面我们处理需要修改 &lt;code&gt;Stack&lt;/code&gt; 值的情况。对于一个包含整数的 &lt;code&gt;Lit&lt;/code&gt; 字面量，为了使 &lt;code&gt;Stack -&amp;gt; Stack&lt;/code&gt; 方法运行下去，我们只需将当前值压入栈中，并使用之后的函数进行调用即可。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于 &lt;code&gt;Op&lt;/code&gt; 的情况是类似的，我们提取 &lt;code&gt;stack&lt;/code&gt; 的头部两个元素，接着应用到 &lt;code&gt;Op&lt;/code&gt; 上，在将结果压回栈中：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于其他情况，我们直接报错退出[3]：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;too few arguments on stack: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们合并起来看一下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;                      &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;      &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;                        &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;too few arguments on stack: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样我们可以清晰地看到，求值的过程会在 &lt;code&gt;Nil&lt;/code&gt; 处停止，而在 &lt;code&gt;Cons&lt;/code&gt; 中通过 &lt;code&gt;cont&lt;/code&gt; 的调用传递下去。&lt;/p&gt;&lt;p&gt;下面我们在 GHCi 中将 &lt;code&gt;parseRPN&lt;/code&gt; 和 &lt;code&gt;evalRPN&lt;/code&gt; 传入 &lt;code&gt;hylo&lt;/code&gt;，并显示函数的类型：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hylo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parseRPN&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这也是合理的，&lt;code&gt;String&lt;/code&gt; 是我们初始需要解析的字符串，&lt;code&gt;Stack&lt;/code&gt; 是 RPN 栈的初始状态，因此我们可以再封装一层，以空列表作为栈的初始状态：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rpn&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;rpn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hylo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evalRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parseRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面我们做一个简单测试，如果在 GHCi 中调用：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rpn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;15 7 1 1 + - / 3 * 2 1 1 + + -&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;得到：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完美。&lt;/p&gt;&lt;p&gt;尽管 RPN 计算器并没有多么复杂，但我们的实现显示出了 recursion schemes 的本质：是我们在&lt;i&gt;做什么&lt;/i&gt;和我们&lt;i&gt;怎么做&lt;/i&gt;分离开，这使我们得以把精力放到问题的主要部分解析字符串和栈操作上，而无需关心数据是怎样完成遍历的。这些机制全部包含在了 &lt;code&gt;hylo&lt;/code&gt; 内部，而我们只需要关心问题的本质即可。&lt;/p&gt;&lt;h2&gt;深度优化&lt;/h2&gt;&lt;p&gt;实际上我们不需要调用 &lt;code&gt;cata&lt;/code&gt; 或 &lt;code&gt;ana&lt;/code&gt; 而仅仅使用 algrbra 和 coalgebra 就能表示 Hylomorphism。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hylo&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Coalgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;hylo&#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hylo&#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;尽管这样的实现不能清晰地看出 Hylomorphism 是 Anamorphism 和 Catamorphism 的组合，但是这样做也有好处：我们对 &lt;code&gt;fmap&lt;/code&gt; 的调用会降低到原来的一半。&lt;/p&gt;&lt;p&gt;对于我们之前的定义，&lt;code&gt;hylo&lt;/code&gt; 使用 &lt;code&gt;ana&lt;/code&gt; 展开 &lt;code&gt;List&lt;/code&gt; 需要调用 n 次 &lt;code&gt;fmap&lt;/code&gt;，其中 n 为 &lt;code&gt;Token&lt;/code&gt; 的个数。接着折叠的时候，&lt;code&gt;cata&lt;/code&gt; 需要再调用 n 次 &lt;code&gt;fmap&lt;/code&gt;。而在我们新的定义中，&lt;code&gt;fmap&lt;/code&gt; 的调用次数下降为 n 次，我们在每次展开后立即进行折叠，每一层的结构会直接在 &lt;code&gt;coalg&lt;/code&gt; 展开后被 &lt;code&gt;alg&lt;/code&gt; 所调用。这项优化对于嵌套结构很深的数据类型能显著提升运行速度。&lt;/p&gt;&lt;h2&gt;时不我待&lt;/h2&gt;&lt;p&gt;尽管 Meijer 等人在介绍 Catamorphism 和 Anamorphism 时就引入了 Hylomorphism，但 Uustalu 和 Vene 的论文却没有讨论组合 Histomorphism 和 Futumorphism 会发生什么。直到整整九年后，Edward Kmett 在 #haskell IRC 频道中，将其命名为 Chronomorphism —— chrono（χρόνος）是一个表示时间的词缀。&lt;/p&gt;&lt;p&gt;Chronomorphism 的定义与 Hylomorphism 类似：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;chrono&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CVAlgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CVCoalgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;chrono&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cvalg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cvcoalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;futu&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cvcoalg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;histo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cvalg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;非常直观地：&lt;code&gt;futu&lt;/code&gt; 展开一个多层的数据结构，接着 &lt;code&gt;histo&lt;/code&gt; 负责折叠数据。&lt;/p&gt;&lt;p&gt;然而不幸地是，Chronomorphism 并不像 Hylomorphism 那样具有丰富地应用实例。我们在之前文章中提到的生命游戏或许是个很接近的例子，我们使用 Futumorphism 来生成植物生命，但我们只需使用 Catamorphism 来将它打印出来。当然我们可以用 Histomorphism 来代替 Catamorphism，但我们并没有使用这样带来的红利。我一直未能找到一个有意义的使用 &lt;code&gt;chrono&lt;/code&gt; 的场景，如果你发现了可以联系我。但是至少 Chronomorphism 的发明者也&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//twitter.com/kmett/status/318410115101380608&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;想不到合适的例子&lt;/a&gt;。不过 &lt;code&gt;chrono&lt;/code&gt; 可以用于实现 &lt;code&gt;dynamorphism&lt;/code&gt;，这是一种为动态规划问题特化的递归模板。我们或许会在下篇文章中进行介绍。（或许 Uustalu 和 Vene 正是因为无法找到合理的应用，而没有提及它）&lt;/p&gt;&lt;h2&gt;Elgot Algebra 的优化&lt;/h2&gt;&lt;p&gt;Histomorphism 清晰地分离了 “做什么” 和 “怎样做” 这两个问题，但在实践中，有时我们在构造数据时会发现输入数据与预期不符，或者在解析数据时会有可以优化的状态。&lt;/p&gt;&lt;p&gt;我们当然可以结合去 &lt;code&gt;hylo&lt;/code&gt; 错误处理的函子来表达这一模式，但 Jiří Adámek，Stefan Milius 和 Jiří Velebil 在他们的文章中提出了一个更好的解决方案，&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//arxiv.org/pdf/cs/0609040.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Elgot Algebra&lt;/a&gt;，在范畴论的框架下为这个问题提供了解决方案，从而避免避免使用错误处理的手段。其命名来源于美国数学家 Calvin Elgot，他致力于弥合数学与软件工程间上的差距。Elgot Algebra 和 CoAlgebra 对 Hylomorphism，Catamorphism 和 Anamorphism 作了泛化，使其更加简洁和实用。文章本身非常的&lt;i&gt;困难&lt;/i&gt;。但是 Kmett 一如既往地为社区做出贡献，将其转化为了 Haskell 的代码。&lt;/p&gt;&lt;p&gt;让我们考虑一个将 &lt;code&gt;Algebra&lt;/code&gt; 和 &lt;code&gt;CoAlgebra&lt;/code&gt; 均代入后得到的 &lt;code&gt;hylo&lt;/code&gt; 的类型签名：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hylo&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个方法告诉我们，给出一个 &lt;code&gt;a&lt;/code&gt; 的 F-CoAlgebra 以及一个 &lt;code&gt;b&lt;/code&gt; 的 F-Algebra，怎样从 &lt;code&gt;a&lt;/code&gt; 得到 &lt;code&gt;b&lt;/code&gt;。但是如果我们有捷径呢？我们可以直接短接掉整个 Hylomorphism，而返回 &lt;code&gt;b&lt;/code&gt;。然后我们可以直接使用 &lt;code&gt;hylo&lt;/code&gt; 来描述这样的短路，而不需要引入 &lt;code&gt;Maybe&lt;/code&gt;，&lt;code&gt;Either&lt;/code&gt; 这些函子。&lt;/p&gt;&lt;p&gt;为了达到这个目的，&lt;code&gt;a -&amp;gt; f a&lt;/code&gt; 必须支持返回两种值，&lt;code&gt;f a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 来用于短接，显然 Haskell 提供了 &lt;code&gt;Either&lt;/code&gt; 功能来完成这一工作。我们把 &lt;code&gt;Elgot&lt;/code&gt; 改写如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;elgot&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们需要一个辅助函数来定义 Elgot Algebra，给出函数 &lt;code&gt;b -&amp;gt; a&lt;/code&gt;，和函数 &lt;code&gt;c -&amp;gt; a&lt;/code&gt;，得到一个 &lt;code&gt;Either b c&lt;/code&gt; 返回 &lt;code&gt;a&lt;/code&gt; 的函数。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|||&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以将这个函数当做或操作的升级版，它操作的是函数 &lt;code&gt;f&lt;/code&gt; 或 &lt;code&gt;g&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们可以直接从之前 &lt;code&gt;hylo&lt;/code&gt; 的定义推导出 &lt;code&gt;elgot&lt;/code&gt;，如果我们得到 &lt;code&gt;Right&lt;/code&gt; 值则继续进行递归。这一部分与 &lt;code&gt;hylo&lt;/code&gt; 表现一致。而如果我们得到 &lt;code&gt;Left&lt;/code&gt; 值，则我们停止递归并跳出。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;elgot&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;elgot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elgot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们使用 Elgot Algebra 为 RPN 计算器带来更多的安全性。我们不使用 &lt;code&gt;error&lt;/code&gt; 而自定义一下成功和失败的类型。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;
  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ParseError&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TooFewArguments&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Stack&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正如上文我们所提到的，我们依然要使用 CPS 风格，但是不是一个 &lt;code&gt;Stack&lt;/code&gt; 的函数，而是一个 &lt;code&gt;Result&lt;/code&gt; 的函数。为了简便起见，我们定义&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cont&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们重写 &lt;code&gt;parseToken&lt;/code&gt;，我们使用 &lt;code&gt;readMaybe&lt;/code&gt; 来获取 &lt;code&gt;Maybe Int&lt;/code&gt;，接着其转换为 &lt;code&gt;Either&lt;/code&gt; 类型。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cont&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;+&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readMaybe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Left&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ParseError&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与之类似，&lt;code&gt;parseRPN&lt;/code&gt; 可以重写为 &lt;code&gt;safeRPN&lt;/code&gt;，&lt;code&gt;parsed&lt;/code&gt; 作为 &lt;code&gt;Right&lt;/code&gt; 值而使用 do 语法隐式处理 &lt;code&gt;Left&lt;/code&gt; 值。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;safeRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeRPN&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nil&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;   &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dropWhile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSpace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;parsed&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeToken&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parsed&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newSeed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样我们要重写 &lt;code&gt;safeEval&lt;/code&gt; 这里需要使用模式匹配来处理 &lt;code&gt;Success&lt;/code&gt; 的值，当函数调用参数不足时，我们可以使用 &lt;code&gt;TooFewArguments&lt;/code&gt; 来作为值：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;safeEval&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Algebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cont&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeEval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Lit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeEval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;          &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TooFewArguments&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeEval&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;  &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样我们可以隐式的处理这些错误，并且不需要调用 &lt;code&gt;throw&lt;/code&gt; 等就可以错误处理模式。&lt;/p&gt;&lt;p&gt;而对它的调用是十分简单的，我们只需将 &lt;code&gt;hylo&lt;/code&gt; 替换为 &lt;code&gt;elgot&lt;/code&gt;，并且使用空 &lt;code&gt;Success&lt;/code&gt; 即可求值。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;safeRPN&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;safeRPN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elgot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeEval&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeParse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Success&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他使用了 Elgot Algebra 的工作非常少，Vanessa McHale 在她的&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//blog.vmchale.com/article/elgot-performance&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;博客&lt;/a&gt;中有一个用来计算&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//esolangs.org/wiki/Collatz_sequence&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Collatz 序列&lt;/a&gt;的例子，文章表明，这样的实现与同样效果的基于 rust 的底层实现计算能力上是相近的。&lt;/p&gt;&lt;h2&gt;再次翻转箭头&lt;/h2&gt;&lt;p&gt;在上面定义 &lt;code&gt;elgot&lt;/code&gt; 时，我们使用了 &lt;code&gt;|||&lt;/code&gt; 来表达区分左右值的情况，同样我们也可以在这里进行翻转箭头的操作，折叠就会变成展开，而对 Elgot Algebra 进行翻转箭头，我们就可以得到可以在折叠时短路的 Hylomorphism。&lt;/p&gt;&lt;p&gt;翻转箭头的把戏与我们之前常见的相同，&lt;code&gt;alg&lt;/code&gt; 变为 &lt;code&gt;coalg&lt;/code&gt;，&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 变为 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;，而 &lt;code&gt;|||&lt;/code&gt; 的对偶稍微有些棘手，还记得之前 &lt;code&gt;Either a b&lt;/code&gt; 的对偶是元祖 &lt;code&gt;(a,b)&lt;/code&gt; 吗？所以相应对偶是 &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由此我们可以得到 Coelgot：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;coelgot&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;coelgot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coelgot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coalg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以我们可以将 Elgot Algebra 看作是 &lt;code&gt;RCoalgebra&lt;/code&gt; 和 &lt;code&gt;Algebra&lt;/code&gt; 的结合，而对偶地来讲，我们可以将 Elgot Coalgebra 看作是 &lt;code&gt;RAlgebra&lt;/code&gt; 和 &lt;code&gt;Coalgebra&lt;/code&gt; 的结合，那么我们甚至可以构建更加强大的 &lt;code&gt;RAlgebra&lt;/code&gt; 与 &lt;code&gt;RCoalgebra&lt;/code&gt; 的结合：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hypo&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RAlgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;RCoalgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;hypo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ralg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcoalg&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcoalg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;para&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ralg&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就我所知来讲，这一构造形式尚未被命名，我们把它称为 Hypomorphism，之后的工作与 &lt;code&gt;hylo&lt;/code&gt; 类似，这里留作练习，不在赘述。&lt;/p&gt;&lt;h2&gt;致谢&lt;/h2&gt;&lt;p&gt;我要感谢 Manuel Chakravarty 为这个系列做的严谨的校对，以及 Colin Barrett，Ross Angle 和 Scott Voke 为本系列提出的宝贵意见。&lt;/p&gt;&lt;p&gt;我还要感谢读者们耐心地读到了这里，下一篇文章中，我们将讨论折叠展开这些操作的本质，以及如何抓住这些本质，来使上面的种种 Recursion Schemes 可以更快地运行。&lt;/p&gt;&lt;h2&gt;译者的话&lt;/h2&gt;&lt;p&gt;首先抱歉拖更了这么久，译者原本的翻译计划本来到此为止的，但是原文作者在上个月似乎又更新了一篇，所以，本着不挖坑的想法，应该会把下一篇也翻译一下。之后的专栏更新可能会考虑做一些函数编程的工程实践，或者从范畴论的角度讨论一下“翻转箭头”的本质。两个方向的内容笔者目前都在做，具体情况需要再看看。&lt;/p&gt;&lt;p&gt;最后打个广告，下面是笔者建的一个范畴论讨论电报群，主要希望能为正在学习范畴论的新手，提供一个迅速交流的地方，欢迎大家加入~&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//t.me/wecattheory&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;t.me/wecattheory&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;[1]:如果你在谷歌上搜索 Hylomorphism，那么很有可能你的结果中只包括亚里士多德提出在他的哲学理论中提出的同名&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Hylomorphism&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;哲学概念&lt;/a&gt;。尽管这一理论与 recursion schemes 并无关联，我们仍然要解释一下为什么这一命名对于我们定义的这一复合计算是适当的。 &lt;/p&gt;&lt;p&gt;[2]:换句话说 Haskell 对于 &lt;code&gt;a -&amp;gt; b -&amp;gt; c&lt;/code&gt; 和 &lt;code&gt;a -&amp;gt; (b -&amp;gt; c)&lt;/code&gt; 两者在语法表示上并无差别。 &lt;/p&gt;&lt;p&gt;[3]:如果我们小心地选取初始值来保持栈中始终有足够元素，比如将初始值设为无限长的列表 [0, 0...]，那么我们就不用保留错误处理的情形了。&lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2019-03-19-59661152</guid>
<pubDate>Tue, 19 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>0x06: SICP 的魔法 - 并发、时间与流模拟</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-18-59528108.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59528108&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf0aff72cb5761f1249a8c89180dfcd9_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;我的github地址：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;lfkdsk&lt;/a&gt;，还创建了相关的仓库，可以clone下来看：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk/SICP-Magical-Book&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SICP 的魔法&lt;/a&gt;，这个仓库还绑定了 gitbook 可以去下载。&lt;/blockquote&gt;&lt;p&gt;在上一篇文章之中我们见识到了基于变动数据、内部状态的程序设计的能力，但是就像之前提及过多次的引用透明性的问题被打破，程序中引入了时间的概念，导致我们无论是求值顺序还是过程的运行都出现了一个时序性的问题，我们在 &lt;code&gt;数字电路模拟&lt;/code&gt; 之中使用了一个 &lt;i&gt;待处理表&lt;/i&gt; 的子过程，用来为我们的信号传播进行排序，通过模拟延时构造了程序的时序性。但是在现实世界中，我们不可能只通过一张表去排序构造顺序，现实系统中的对象都有更为复杂的同时的活动，为了构造这种更为现实的模拟系统，我们可能需要：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用一组系统进行对同时发生的事情进行模拟&lt;/li&gt;&lt;li&gt;分解我们使用的模型，增强内部状态的演化，就是更为 &lt;b&gt;模块化&lt;/b&gt;&lt;/li&gt;&lt;li&gt;能够支持多个进程的硬件支持&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在多内核处理器普及的今天，硬件支持已经渐渐不是并发编程的难题了。但是并发编程的复杂性让然没有因为这个原因而降低难度。首先我们要承认正确的运用并行编程是有利的，能提升我们程序的运行效率和对硬件的利用率。&lt;/p&gt;&lt;p&gt;但是由于并发系统的时间的不确定性，两个同时运行并有所依赖的进程，我们并不能确定什么时候某个能运行完，而一个又不能对另一个的结果进行无限的等待。还有就是资源获取的问题，两个并行的程序如何对资源进行管理，比如第三章开始的那个例子，从银行取钱，如果无法控制程序对资源的有效管理就可能造成两个人同时使用一个账户同时取钱，都能取出来的情况出现。&lt;/p&gt;&lt;p&gt;这一节会谈及和并发相关的内容，对于有编程理论经验的同学，这并不是什么复杂的理论内容，其中涉及到的时序控制、锁和信号量等等的知识都是能在各种 OS 相关的课程和书中了解到的知识。&lt;/p&gt;&lt;h2&gt;并发和时间&lt;/h2&gt;&lt;blockquote&gt; 时间是一种设施，发明它就是为了不让所有事情都立即发生。&lt;/blockquote&gt;&lt;p&gt;从抽象的角度来看时间就像是加在事件上的一种顺序，一件事情发生比另一件事情发生的早，只是事件顺序的相对关系，这个过程听起来能够非常原子的控制，但是本身事件还会消耗时间。这就引出了并发带来的一些问题，之前也已经提到了，来自于对相同资源的控制问题，和操作的顺序问题，解决这个问题我们就是在解决程序的 &lt;b&gt;正确性&lt;/b&gt; 和 &lt;b&gt;健壮性&lt;/b&gt; 的问题，通常我们可以这么去理解程序的正确性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;并发运行不受外界的影响&lt;/li&gt;&lt;li&gt;运行的表现要和不进行并发程序的状态是一样的&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;并发控制&lt;/h2&gt;&lt;p&gt;对正确性的保证其实就是在做和 &lt;b&gt;并发控制&lt;/b&gt; 相关的工作，其实质就是对并行操作进行一定的控制，书中谈到的很多策略其实在做开发中都是经常见到的：&lt;/p&gt;&lt;h2&gt;禁止所有共享资源的并行操作&lt;/h2&gt;&lt;blockquote&gt; Tips :  锁粒度： 简单说就是指不允许并行运行的加锁区域。&lt;/blockquote&gt;&lt;p&gt;其实典型就是加了个 &lt;i&gt;锁&lt;/i&gt; ，但是问题也比较明显，书中的反面 Demo 明显是一个锁粒度设定非常大的例子，这也是这种方案的一个比较突出的缺陷，并不是所有的时间都需要禁止并行进行。很多操作并非互相干扰的，比如非常常见的 &lt;b&gt;读写分离&lt;/b&gt; 锁就是这样，我们很多时候对读操作和写操作的要求不同不能一概而论。&lt;/p&gt;&lt;h2&gt;允许不互相干扰的并发&lt;/h2&gt;&lt;p&gt;书中提到了另一种控制方式，是对一种想法的一种改进，这时候我们允许对很多的不互相干扰的并发执行，但是对结果的要求仅仅期望与某种顺序的运行方式相同，这样会有另一个方面的问题，并发结果有很多种，我们没办法对其结果进行预测。&lt;/p&gt;&lt;h2&gt;串行控制器&lt;/h2&gt;&lt;p&gt;串行化控制器的思路就是，程序可以并行执行，但是其中也有时序性的要求的部分，这部分无法并行执行程序的部分就靠一个控制器，将所有的执行过程通过一个集合控制起来，同一个时间段只会有一个过程在执行。最简单的应用我们可以借助共享变量去理解，同一个时间段可能有很多个进程在请求同一个资源，但是 &lt;i&gt;同时&lt;/i&gt; 只能有一个进程能够获得这个资源，其余的将在等待队列中等待：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1aaa456c0ca387077bbbfcfe0b65277e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;820&quot; data-rawheight=&quot;482&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;820&quot; data-original=&quot;https://pic3.zhimg.com/v2-1aaa456c0ca387077bbbfcfe0b65277e_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1aaa456c0ca387077bbbfcfe0b65277e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;820&quot; data-rawheight=&quot;482&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;820&quot; data-original=&quot;https://pic3.zhimg.com/v2-1aaa456c0ca387077bbbfcfe0b65277e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1aaa456c0ca387077bbbfcfe0b65277e_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;通过对程序的分组的方式来禁止不正当的并发行为，并且可通过程序控制将某个方法设置为 &lt;b&gt;串行化&lt;/b&gt; 的方法。&lt;/p&gt;&lt;p&gt;我们引入一个内部方法 &lt;code&gt;make-serializer&lt;/code&gt; 去提供这个是过程串行化的功能，&lt;code&gt;make-serializer&lt;/code&gt;  接受一个过程作为参数返回同样行为的过程，参数与原过程保持一样，但保证其执行被串行化，我们可以继续使用之前的 &lt;code&gt;make-account&lt;/code&gt; 的例子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-account&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;&amp;gt;= &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;begin &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set! &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Insufficient funds&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set! &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;+ &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
     &lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;; 引入内部过程 make-serializer &lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;cond &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unknown request -- MAKE-ACCOUNT&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看出我们引入了内部过程，通过对每个向外暴露的方法包装一层方法。&lt;/p&gt;&lt;blockquote&gt; Tips：这里面可以类比 Java 中的 synchronized 和 Lock 机制，在实际的开发中使用 synchronized 设置为某个方法的关键字，这样我们对某个方法的封装就能让具体的处理业务 &lt;i&gt;互斥&lt;/i&gt; 进行处理。&lt;/blockquote&gt;&lt;h2&gt;多重资源的复杂性&lt;/h2&gt;&lt;p&gt;我们考虑完单一资源的串行化操作之后来看一下涉及到多重资源的程序，比如刚才对 account 的操作，如果我们提供一个过程能够交换两个账户的金额（通过计算差值分别赋值给两个账户）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;exchange&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;difference&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account2&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;difference&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account2&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;difference&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是这就涉及到了另外一个问题，这个的操作确实能在对两个账户进行使用的时候保持并发正确，但是如果我们同时运行两个这个程序分别交换 &lt;code&gt;account1&lt;/code&gt; 和 &lt;code&gt;account2&lt;/code&gt; 以及 &lt;code&gt;account2&lt;/code&gt; 和 &lt;code&gt;account3&lt;/code&gt; 的时候，这时候情况就变得复杂了，account 的操作能保证串行化，但是 &lt;code&gt;exchange&lt;/code&gt; 的程序还没有保证串行化。&lt;/p&gt;&lt;p&gt;这时候我们就要改变 &lt;code&gt;exchange&lt;/code&gt; 的串行租的策略，我们要是能够使用两个 account 的用户的串行组就能让 &lt;code&gt;exchange&lt;/code&gt; 过程也并行正确，这里我们提取出了对应方法，把串行租从账户模块中暴露出来，这样就能在想加锁的时候用上锁了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; 还是那段 make-account&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; ... &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serializer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;cond &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unknown request -- MAKE-ACCOUNT&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以看到我们在程序内部没有给操作的过程加锁，而是把锁暴露在了外面，这样我们对操作的定义可能需要一定的修改：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们的 &lt;code&gt;exchange&lt;/code&gt; 的定义也可以用提取出来的串行控制器进行重构了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serialized-exchange&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serializer1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serializer2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account2&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serializer1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serializer2&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exchange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分别把两个串行控制器提取出来了，并且确信要拿到两道锁的 exchange 程序来操作两个账户。&lt;/p&gt;&lt;p&gt;看起来我们实现了我们所需要的整个功能不是么？可是未必意识到了我们对这个程序都做了什么，首先我们来看修改版本的 &lt;b&gt;deposit&lt;/b&gt; 程序，这个 deposit 明显已经不是 account 的一个内部方法了，这是在外面包裹了一层的一个新的方法，破坏了本身的模块和封装。&lt;/p&gt;&lt;p&gt;而且在看我们对 &lt;b&gt;serializer&lt;/b&gt; 的使用上来看，明显和上个原因相同以外，我们暴露的是对象所在的串行组，想想串行组是用来管理资源的，这个东西都暴露在了模块的外部，无论是使用还是管理起来都是特别不方便还容易出现危险。&lt;/p&gt;&lt;blockquote&gt; Tips : 我们之前简单的描述过，可以把这里提到的串行控制器等价于我们在实际开发中使用的 &lt;b&gt;锁&lt;/b&gt;，多种资源引来的复杂性实际上就是程序所使用的锁的数量不足，不能有效的管控所有的资源。而我们在程序的修改的结果其实就是拆解了模块，把我们的 &lt;b&gt;锁&lt;/b&gt; 暴露在了外部，对于封装和安全的问题可想而知。&lt;/blockquote&gt;&lt;h2&gt;串行控制器的实现&lt;/h2&gt;&lt;p&gt;我们刚才在谈及串行控制器的实质上面，我们可以把它想象成一把锁和一个请求锁的等待队列，在书中的模拟中是使用了 &lt;b&gt;互斥量(mutex)&lt;/b&gt; 这个更为细粒度的抽象数据实现的。&lt;/p&gt;&lt;p&gt;互斥元是一个可以被获取、在使用之后被释放的数据抽象（类比锁实现），如果某个互斥元已经被获取，想获取该互斥元的其他操作需要等到该互斥元被释放（任何时候只有一个进程能拿到），来看 &lt;code&gt;make-serializer&lt;/code&gt; 的实现过程：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;; 创建互斥元&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serialized-p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;; 获取互斥元&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;; 执行 p 过程&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;; 释放互斥元&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;nv&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;serialized-p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就是我们之前生成串行控制器的过程，以一个过程作为参数，我们先对获取互斥元再执行完过程 &lt;code&gt;p&lt;/code&gt; 然后再释放我们的互斥元。我们还需要一个生成互斥元的过程：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;the-mutex&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;cond &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;test-and-set!&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;the-mutex&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set-car! &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;the-mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意到互斥元的管理本身也是依赖一个变量来操作的，其中的 &lt;code&gt;test-and-set!&lt;/code&gt; 检查参数的 car 值，如果参数的 car 值为假就在返回值前将其设为真值。&lt;/p&gt;&lt;p&gt;&lt;code&gt;test-and-set!&lt;/code&gt; 这个方法是生成互斥元的核心，这个操作需要以 &lt;b&gt;原子操作&lt;/b&gt; 的方式执行，具体实现可能是一个特殊的硬件指令或者是系统提供的一个专门的过程。在单处理器程序中系统通过轮转时间片的方式为每一个可执行程序安排一段运行时间，多处理器机器中我们就必须通过硬件支持的专门指令。&lt;/p&gt;&lt;h2&gt;死锁&lt;/h2&gt;&lt;p&gt;在资源抢占和申请的过程中，我们会遇到更为严重的问题 —— 死锁。我们刚才对 &lt;code&gt;serialized-exchange&lt;/code&gt; 的修改之后，通过增加一条锁，已经能让我们在交换账户的时候控制好时序性了，但是我们还可能遇到资源互相抢占的问题比如文中的例子：&lt;/p&gt;&lt;blockquote&gt; 实例：设 Peter 要交换账户 a1 和 a2，同时 Paul 想交换 a2 和 a1&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;假定 Peter 进程已进入保护 a1 的串行化过程，与此同时 Paul 也进入了保护 a2 的串行化过程&lt;/li&gt;&lt;li&gt;这时 Peter 占着保护 a1 的串行化过程，等待进入保护 a2 的过程（等待 Paul 的进程释放该过程），而 Paul 占有保护 a2 的串行化过程，并等待进入保护 a1 的过程&lt;/li&gt;&lt;li&gt;两人的进程将相互等待，永远也不能前进&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-afca18cba71d10ee28db4ac32451da6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;474&quot; data-rawheight=&quot;348&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;474&quot; data-original=&quot;https://pic2.zhimg.com/v2-afca18cba71d10ee28db4ac32451da6d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-afca18cba71d10ee28db4ac32451da6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;474&quot; data-rawheight=&quot;348&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;474&quot; data-original=&quot;https://pic2.zhimg.com/v2-afca18cba71d10ee28db4ac32451da6d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-afca18cba71d10ee28db4ac32451da6d_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;这样两个以上的进程，由于相互等待其他方释放资源无法前进，这种情况我们就称之为死锁，如果并发系统涉及到多种资源的管理和申请，就有可能出现死锁。&lt;/p&gt;&lt;h2&gt;流&lt;/h2&gt;&lt;p&gt;之前我们引入赋值是为了解决对状态的 &lt;b&gt;模拟&lt;/b&gt; 的问题，之前的数字电路模拟之中也向我们证实了使用赋值的方式是一种正确的实现模拟的方式。但是同时我们也意识到了一个新的问题，一个由引入赋值带来的问题——计算对象包含可变的局部状态，并且这种状态是根据时间可变的了，在这种情况之下我们就不再能像之前一样把所有数据都当成不可变数据来进行计算了。&lt;/p&gt;&lt;p&gt;因此本节讨论的 &lt;b&gt;流&lt;/b&gt; 就是为了解决引入赋值所产生的状态变化问题而引入的，目的是使用另一种方法来进行模拟。之前我们对时间的模拟来自于对状态根据时间的修改，也就是说一个具体的状态在不同的时间之下是不同的，不断地修改状态实现了模拟就像下图一样一个局部状态在不断地被修改和覆盖：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-76f9fe335595345b0b88e260cc7cc93e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;338&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-76f9fe335595345b0b88e260cc7cc93e_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-76f9fe335595345b0b88e260cc7cc93e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;338&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-76f9fe335595345b0b88e260cc7cc93e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-76f9fe335595345b0b88e260cc7cc93e_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;而使用 &lt;b&gt;流&lt;/b&gt; 来模拟采取了另一种方式来对状态随时间这个事实进行模拟，我们假设每一个状态  &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt;  都包含一个随时间进行改变状态的函数  &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%28t%29&quot; alt=&quot;x(t)&quot; eeimg=&quot;1&quot;&gt;  ，每一个时间片  &lt;img src=&quot;https://www.zhihu.com/equation?tex=t+&quot; alt=&quot;t &quot; eeimg=&quot;1&quot;&gt;  都对应着一个&lt;img src=&quot;https://www.zhihu.com/equation?tex=x+&quot; alt=&quot;x &quot; eeimg=&quot;1&quot;&gt;的具体状态，在这种角度来看虽然时间、状态仍然在进行着变化，但是 &lt;b&gt;由时间到状态的映射&lt;/b&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%28t%29&quot; alt=&quot;x(t)&quot; eeimg=&quot;1&quot;&gt; 本身是不变的。因此我们就可以不再只关注 $x$ 本身作为一个变化量的变化，但是从整个时间的流逝角度来看时间和状态的映射函数本身是不变的。&lt;/p&gt;&lt;blockquote&gt; Tips：关于上面用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%28t%29&quot; alt=&quot;x(t)&quot; eeimg=&quot;1&quot;&gt; 来解释流的原因&lt;br&gt; SICP 用上述使用  &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%28t%29&quot; alt=&quot;x(t)&quot; eeimg=&quot;1&quot;&gt;  的方式来解释 stream 的实质，其实不是在说 stream 是用来保存一个 state x 的变化过程 (随说可以提供这个功能，但是这个听起来很像是 state monad)，其实 stream 更像是一个 &lt;code&gt;operator&lt;/code&gt; 的作用。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;如书中所说我们如果从离散步长的角度上来讲，流可以被看做一个无限长的序列，通过对不同时间阶段内容的取值，来模拟由时间到状态的映射。但是从实现的角度上来讲我们并不能为了实现流而构造一个无限长度的队列，因此引入一种延迟求值的技术来表示任意（以致无限长度的序列）。&lt;/p&gt;&lt;blockquote&gt; 在&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E7%25A8%258B%25E5%25BC%258F%25E8%25AA%259E%25E8%25A8%2580%25E7%2590%2586%25E8%25AB%2596&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;编程语言理论&lt;/a&gt;中，&lt;b&gt;惰性求值&lt;/b&gt;（英语：Lazy Evaluation），又译为&lt;b&gt;惰性计算&lt;/b&gt;、&lt;b&gt;懒惰求值&lt;/b&gt;，也称为&lt;b&gt;传需求调用&lt;/b&gt;（call-by-need），是一个&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BC%2596%25E7%25A8%258B&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;计算机编程&lt;/a&gt;中的一个概念，它的目的是要最小化计算机要做的工作。它有两个相关而又有区别的含意，可以表示为“延迟求值”和“最小化求值”，惰性计算的最重要的好处是它可以构造一个无限的&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%2595%25B8%25E6%2593%259A%25E9%25A1%259E%25E5%259E%258B&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;数据类型&lt;/a&gt;。&lt;br&gt; 惰性求值的相反是&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%258F%258A%25E6%2597%25A9%25E6%25B1%2582%25E5%2580%25BC&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;及早求值&lt;/a&gt;，这是一个大多数&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E7%25BC%2596%25E7%25A8%258B%25E8%25AF%25AD%25E8%25A8%2580&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;编程语言&lt;/a&gt;所拥有的普通计算方式。&lt;br&gt; —— wiki&lt;/blockquote&gt;&lt;p&gt;如果我们在了解延迟求值的技术之前，我们编写的代码是会在编写完立刻执行的，即使没运行到也是因为处理时间过长等因素在一段时间之后自动运行到。而延迟求值则是相当于把求值的方法写在了代码里但是不会立刻运行，而是在我们需要的时候调用，并且使用当时的 context 来进行计算得到结果。有了这样的一种表示方式，我们自然而然的可以多次调用来生成多个不同状态下的结果，并最终形成一个我们想要长度的序列。其实不需要向书中卖那么长的关子，听到这学过之前内容的同学应该已经能想到了，一个能带 context 的、不会立刻进行计算的东西 —— lambda 就呼之欲出了。&lt;/p&gt;&lt;p&gt;事实上 Scheme 之中的延迟求值的实现也非常简单就是使用 lambda 的封装进行的：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; 使用 delay 包裹&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;delay &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;; 使用 force 直接拿出来调用&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;force &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因此通过这样延时求值的定义我们能够做出之前我们无法实现的一些操作，比如书中的一个无限的正整数流：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; 1) 直接 cons 生成 stream&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;integers-starting-from&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;integers-starting-from&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;+ &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;integers&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;integers-starting-from&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 2) 隐式生成的 stream&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ones&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add-streams&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-map&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;integers2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add-streams&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ones&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;integers2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使计算过程中事件的 &lt;b&gt;实际发生顺序&lt;/b&gt; 和 &lt;b&gt;过程表面结构&lt;/b&gt; 之间的对应关系变得比较宽松，因此既能获得之前我们探索模块化获得的优势，又能在效率上有所提升。&lt;/p&gt;&lt;h2&gt;流计算的应用&lt;/h2&gt;&lt;p&gt;通过引入 &lt;code&gt;流&lt;/code&gt; 这种编程概念对我们的编程方式有很大的补充能力，使用流式编程构造系统的时候本质上和使用状态和变量来构造系统有很大的区别。但其实更简单的理解方式还是可以从前几章我们所说的 &lt;code&gt;引用透明&lt;/code&gt;，流的实质也不过是过程传递和延迟加载技术的综合。书中介绍的几个流计算的应用，包括引入迭代、无穷流和和之前呼应的表示信号。&lt;/p&gt;&lt;h2&gt;将迭代操作表示为流操作&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqrt-improve&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;average&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;/ &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;guess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 求一个数的平方根&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqrt-stream&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;guesses&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;
                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;guess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqrt-improve&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                             &lt;span class=&quot;nv&quot;&gt;guesses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 打印出整个流&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;display-stream&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqrt-stream&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;还有一个例子是通过交错级数不断地收敛来生成  &lt;img src=&quot;https://www.zhihu.com/equation?tex=%CF%80&quot; alt=&quot;π&quot; eeimg=&quot;1&quot;&gt;  的近似值： &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cfrac%7B%CF%80%7D%7B4%7D+%3D+1+-+%5Cfrac%7B1%7D%7B3%7D+%2B+%5Cfrac%7B1%7D%7B5%7D+-+%5Cfrac%7B1%7D%7B7%7D+%2B+.....+&quot; alt=&quot; \frac{π}{4} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + ..... &quot; eeimg=&quot;1&quot;&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; 生成交错级数的流&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pi-summands&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;/ &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-map&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pi-summands&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;+ &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 部分前缀和 exercise 3.55 有提到&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;partial-sums&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add-streams&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;partial-sums&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; pi 的近似流&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pi-stream&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scale-stream&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;partial-sums&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pi-summands&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt; Tips :  流的加速收敛&lt;br&gt; 书中包含了针对这个交错级数的加速方案 euler-transform：&lt;br&gt; 加速的项目为：  &lt;img src=&quot;https://www.zhihu.com/equation?tex=S%7Bn%2B1%7D+-+%5Cfrac%7B%28S%7Bn%2B1%7D+-+S+%7Bn%7D%29+%5E+2%7D%7BS%7Bn-1%7D+-+2+S%7Bn%7D+%2B+S%7Bn%2B1%7D%7D&quot; alt=&quot;S{n+1} - \frac{(S{n+1} - S {n}) ^ 2}{S{n-1} - 2 S{n} + S{n+1}}&quot; eeimg=&quot;1&quot;&gt; &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;euler-transform&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;s0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;; Sn₋₁&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;; Sn&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;; Sn₊₁&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;/ &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;+ &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;* &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;-2&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;euler-transform&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;无穷序列&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6f5a5ab416abe1dfd188955c11ed1b83_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;203&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;481&quot; data-original=&quot;https://pic4.zhimg.com/v2-6f5a5ab416abe1dfd188955c11ed1b83_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6f5a5ab416abe1dfd188955c11ed1b83_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;203&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;481&quot; data-original=&quot;https://pic4.zhimg.com/v2-6f5a5ab416abe1dfd188955c11ed1b83_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6f5a5ab416abe1dfd188955c11ed1b83_b.jpg&quot;&gt;&lt;/figure&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pairs&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;combine-in-some-way&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
                  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pairs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;尝试通过 stream 的方式去生成如上图所示的无穷序列，途中主要分成了三个区域，最左上角的初始序对，和右上角的 list ，还有就是右下角的部分。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; (S0, T0)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;; (S0, T1) , (S0, T2), (S0, T3) ,...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
              &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 交错 items&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pairs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而其中比较重要的部分就是怎么组合两个 inf-stream 的，普通的 &lt;code&gt;stream-append&lt;/code&gt; 肯定是不行的，因为这样会一直在求值第一个 stream ，这里使用了下述的方法来交错的使用 inf-stream：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interleave&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-null?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; 
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interleave&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;将流作为信号&lt;/h2&gt;&lt;p&gt;前面以信号处理为背景讨论流问题。也可以用流建模信号处理过程，用流中元素表示一个信号在一系列顺序时间点上的值： $$ S{i} = C + \sum_{j-1}^{i}x_{j}d{t} $$&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;integral&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;integrand&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;initial-value&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; 
     &lt;span class=&quot;nv&quot;&gt;initial-value&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add-streams&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scale-stream&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;integrand&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                  &lt;span class=&quot;nv&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过积分器的方式表示信号系统：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-45cfd5a7c411c7bb59219a21fe3209b6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;758&quot; data-rawheight=&quot;396&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;758&quot; data-original=&quot;https://pic3.zhimg.com/v2-45cfd5a7c411c7bb59219a21fe3209b6_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-45cfd5a7c411c7bb59219a21fe3209b6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;758&quot; data-rawheight=&quot;396&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;758&quot; data-original=&quot;https://pic3.zhimg.com/v2-45cfd5a7c411c7bb59219a21fe3209b6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-45cfd5a7c411c7bb59219a21fe3209b6_b.jpg&quot;&gt;&lt;/figure&gt;&lt;h2&gt;流计算的问题&lt;/h2&gt;&lt;p&gt;流的大量使用会导致系统之中有很多部分需要显示的使用 &lt;code&gt;delay&lt;/code&gt; ，&lt;code&gt;force&lt;/code&gt; 进行管理，一种解决办法就是把系统中的 &lt;code&gt;应用序&lt;/code&gt; 求值全部换成 &lt;code&gt;正则序&lt;/code&gt; 求值。这样的求值方式更加接近流的使用方式，统一了参数的求值逻辑。但是全部换成了 &lt;code&gt;正则序&lt;/code&gt; 后可能真实的求值时间就不能够得到保障了，并且本身理解程序也会有一些困难，程序的语义也变得复杂起来了。书中的归并账号的问题也向我们揭示了另一个问题，在处理这种并发的约束条件的时候我们不能用分片、轮流的方式(这明显和实际情况不符)，因此还是要引入强制的同步。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;本章主要是在讨论有内部状态的对象，基于状态编程和模拟，我们提供了两种解决方案去表示对时间的模拟，但是都不能尽善尽美。首先是通过局部变量的模拟，对于赋值和状态的讨论是本章贯穿的内容，我们进一步揭示了赋值的引入本质上是是对时间的依赖，赋值改变了变量的状态，从而改变了依赖于这些变量的表达式的计算。具有变动状态的对象给程序带来了时间问题，程序本身也失去了引用透明性，并发会使得问题变得更加严重。引入流是作为一种替代技术，延时求值的序列是很强力模拟工具，能在一定范围内替代赋值的状态模拟。而状态变动、时间模拟、程序的非确定性这种本质性问题也很难有最优解存在。&lt;/p&gt;&lt;p&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这篇文章真的是摸的时间够长的啊，我看了一下创建时间竟然是 2017 年的 9 月份，一下子一年多的时间就溜走了。这一年多的时间里真的发生了不少事情呢，从打算出国读个 master 到暂时鸽了，在杭州阿里摸了半年，临近毕业又来了某条。SICP 也是一样，书早就读完了，但是文章却是一直鸽着，接下来的时间尽量都写完吧。这一年多见证了好多人的变化和进步，又来了北京和红红 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/c3a3b37f42ed38a9783c00cea5156e55&quot; data-hash=&quot;c3a3b37f42ed38a9783c00cea5156e55&quot; data-hovercard=&quot;p$b$c3a3b37f42ed38a9783c00cea5156e55&quot;&gt;@头顶青天红美铃&lt;/a&gt;  当了大半年的邻居。有的时候真的还是很感慨、羡慕大家的，能有很明确喜欢和努力的方向，并去不断地投入进去。相较于我，似乎平时什么都不怵，很多有点困难事情都能搞得定，但在这找喜欢的事情、方向却总是非常的迷茫。接下来的几个月尽量把这个系列的东西写完吧，也希望自己能 &quot;日拱一卒，功不唐捐&quot; QwQ。&lt;/p&gt;</description>
<author>lfkdsk</author>
<guid isPermaLink="false">2019-03-18-59528108</guid>
<pubDate>Mon, 18 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>0x06: SICP 的魔法 - 并发、时间与流模拟</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-17-59528108.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59528108&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf0aff72cb5761f1249a8c89180dfcd9_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;我的github地址：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;lfkdsk&lt;/a&gt;，还创建了相关的仓库，可以clone下来看：&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/lfkdsk/SICP-Magical-Book&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SICP 的魔法&lt;/a&gt;，这个仓库还绑定了 gitbook 可以去下载。&lt;/blockquote&gt;&lt;p&gt;在上一篇文章之中我们见识到了基于变动数据、内部状态的程序设计的能力，但是就像之前提及过多次的引用透明性的问题被打破，程序中引入了时间的概念，导致我们无论是求值顺序还是过程的运行都出现了一个时序性的问题，我们在 &lt;code&gt;数字电路模拟&lt;/code&gt; 之中使用了一个 &lt;i&gt;待处理表&lt;/i&gt; 的子过程，用来为我们的信号传播进行排序，通过模拟延时构造了程序的时序性。但是在现实世界中，我们不可能只通过一张表去排序构造顺序，现实系统中的对象都有更为复杂的同时的活动，为了构造这种更为现实的模拟系统，我们可能需要：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用一组系统进行对同时发生的事情进行模拟&lt;/li&gt;&lt;li&gt;分解我们使用的模型，增强内部状态的演化，就是更为 &lt;b&gt;模块化&lt;/b&gt;&lt;/li&gt;&lt;li&gt;能够支持多个进程的硬件支持&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在多内核处理器普及的今天，硬件支持已经渐渐不是并发编程的难题了。但是并发编程的复杂性让然没有因为这个原因而降低难度。首先我们要承认正确的运用并行编程是有利的，能提升我们程序的运行效率和对硬件的利用率。&lt;/p&gt;&lt;p&gt;但是由于并发系统的时间的不确定性，两个同时运行并有所依赖的进程，我们并不能确定什么时候某个能运行完，而一个又不能对另一个的结果进行无限的等待。还有就是资源获取的问题，两个并行的程序如何对资源进行管理，比如第三章开始的那个例子，从银行取钱，如果无法控制程序对资源的有效管理就可能造成两个人同时使用一个账户同时取钱，都能取出来的情况出现。&lt;/p&gt;&lt;p&gt;这一节会谈及和并发相关的内容，对于有编程理论经验的同学，这并不是什么复杂的理论内容，其中涉及到的时序控制、锁和信号量等等的知识都是能在各种 OS 相关的课程和书中了解到的知识。&lt;/p&gt;&lt;h2&gt;并发和时间&lt;/h2&gt;&lt;blockquote&gt; 时间是一种设施，发明它就是为了不让所有事情都立即发生。&lt;/blockquote&gt;&lt;p&gt;从抽象的角度来看时间就像是加在事件上的一种顺序，一件事情发生比另一件事情发生的早，只是事件顺序的相对关系，这个过程听起来能够非常原子的控制，但是本身事件还会消耗时间。这就引出了并发带来的一些问题，之前也已经提到了，来自于对相同资源的控制问题，和操作的顺序问题，解决这个问题我们就是在解决程序的 &lt;b&gt;正确性&lt;/b&gt; 和 &lt;b&gt;健壮性&lt;/b&gt; 的问题，通常我们可以这么去理解程序的正确性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;并发运行不受外界的影响&lt;/li&gt;&lt;li&gt;运行的表现要和不进行并发程序的状态是一样的&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;并发控制&lt;/h2&gt;&lt;p&gt;对正确性的保证其实就是在做和 &lt;b&gt;并发控制&lt;/b&gt; 相关的工作，其实质就是对并行操作进行一定的控制，书中谈到的很多策略其实在做开发中都是经常见到的：&lt;/p&gt;&lt;h2&gt;禁止所有共享资源的并行操作&lt;/h2&gt;&lt;blockquote&gt; Tips :  锁粒度： 简单说就是指不允许并行运行的加锁区域。&lt;/blockquote&gt;&lt;p&gt;其实典型就是加了个 &lt;i&gt;锁&lt;/i&gt; ，但是问题也比较明显，书中的反面 Demo 明显是一个锁粒度设定非常大的例子，这也是这种方案的一个比较突出的缺陷，并不是所有的时间都需要禁止并行进行。很多操作并非互相干扰的，比如非常常见的 &lt;b&gt;读写分离&lt;/b&gt; 锁就是这样，我们很多时候对读操作和写操作的要求不同不能一概而论。&lt;/p&gt;&lt;h2&gt;允许不互相干扰的并发&lt;/h2&gt;&lt;p&gt;书中提到了另一种控制方式，是对一种想法的一种改进，这时候我们允许对很多的不互相干扰的并发执行，但是对结果的要求仅仅期望与某种顺序的运行方式相同，这样会有另一个方面的问题，并发结果有很多种，我们没办法对其结果进行预测。&lt;/p&gt;&lt;h2&gt;串行控制器&lt;/h2&gt;&lt;p&gt;串行化控制器的思路就是，程序可以并行执行，但是其中也有时序性的要求的部分，这部分无法并行执行程序的部分就靠一个控制器，将所有的执行过程通过一个集合控制起来，同一个时间段只会有一个过程在执行。最简单的应用我们可以借助共享变量去理解，同一个时间段可能有很多个进程在请求同一个资源，但是 &lt;i&gt;同时&lt;/i&gt; 只能有一个进程能够获得这个资源，其余的将在等待队列中等待：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1aaa456c0ca387077bbbfcfe0b65277e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;820&quot; data-rawheight=&quot;482&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;820&quot; data-original=&quot;https://pic3.zhimg.com/v2-1aaa456c0ca387077bbbfcfe0b65277e_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1aaa456c0ca387077bbbfcfe0b65277e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;820&quot; data-rawheight=&quot;482&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;820&quot; data-original=&quot;https://pic3.zhimg.com/v2-1aaa456c0ca387077bbbfcfe0b65277e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1aaa456c0ca387077bbbfcfe0b65277e_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;通过对程序的分组的方式来禁止不正当的并发行为，并且可通过程序控制将某个方法设置为 &lt;b&gt;串行化&lt;/b&gt; 的方法。&lt;/p&gt;&lt;p&gt;我们引入一个内部方法 &lt;code&gt;make-serializer&lt;/code&gt; 去提供这个是过程串行化的功能，&lt;code&gt;make-serializer&lt;/code&gt;  接受一个过程作为参数返回同样行为的过程，参数与原过程保持一样，但保证其执行被串行化，我们可以继续使用之前的 &lt;code&gt;make-account&lt;/code&gt; 的例子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-account&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;&amp;gt;= &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;begin &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set! &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Insufficient funds&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set! &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;+ &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
     &lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;; 引入内部过程 make-serializer &lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;cond &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unknown request -- MAKE-ACCOUNT&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看出我们引入了内部过程，通过对每个向外暴露的方法包装一层方法。&lt;/p&gt;&lt;blockquote&gt; Tips：这里面可以类比 Java 中的 synchronized 和 Lock 机制，在实际的开发中使用 synchronized 设置为某个方法的关键字，这样我们对某个方法的封装就能让具体的处理业务 &lt;i&gt;互斥&lt;/i&gt; 进行处理。&lt;/blockquote&gt;&lt;h2&gt;多重资源的复杂性&lt;/h2&gt;&lt;p&gt;我们考虑完单一资源的串行化操作之后来看一下涉及到多重资源的程序，比如刚才对 account 的操作，如果我们提供一个过程能够交换两个账户的金额（通过计算差值分别赋值给两个账户）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;exchange&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;difference&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account2&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;difference&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account2&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;difference&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是这就涉及到了另外一个问题，这个的操作确实能在对两个账户进行使用的时候保持并发正确，但是如果我们同时运行两个这个程序分别交换 &lt;code&gt;account1&lt;/code&gt; 和 &lt;code&gt;account2&lt;/code&gt; 以及 &lt;code&gt;account2&lt;/code&gt; 和 &lt;code&gt;account3&lt;/code&gt; 的时候，这时候情况就变得复杂了，account 的操作能保证串行化，但是 &lt;code&gt;exchange&lt;/code&gt; 的程序还没有保证串行化。&lt;/p&gt;&lt;p&gt;这时候我们就要改变 &lt;code&gt;exchange&lt;/code&gt; 的串行租的策略，我们要是能够使用两个 account 的用户的串行组就能让 &lt;code&gt;exchange&lt;/code&gt; 过程也并行正确，这里我们提取出了对应方法，把串行租从账户模块中暴露出来，这样就能在想加锁的时候用上锁了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; 还是那段 make-account&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; ... &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serializer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;cond &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unknown request -- MAKE-ACCOUNT&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以看到我们在程序内部没有给操作的过程加锁，而是把锁暴露在了外面，这样我们对操作的定义可能需要一定的修改：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们的 &lt;code&gt;exchange&lt;/code&gt; 的定义也可以用提取出来的串行控制器进行重构了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serialized-exchange&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serializer1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serializer2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;account2&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serializer1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serializer2&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;exchange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;account2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分别把两个串行控制器提取出来了，并且确信要拿到两道锁的 exchange 程序来操作两个账户。&lt;/p&gt;&lt;p&gt;看起来我们实现了我们所需要的整个功能不是么？可是未必意识到了我们对这个程序都做了什么，首先我们来看修改版本的 &lt;b&gt;deposit&lt;/b&gt; 程序，这个 deposit 明显已经不是 account 的一个内部方法了，这是在外面包裹了一层的一个新的方法，破坏了本身的模块和封装。&lt;/p&gt;&lt;p&gt;而且在看我们对 &lt;b&gt;serializer&lt;/b&gt; 的使用上来看，明显和上个原因相同以外，我们暴露的是对象所在的串行组，想想串行组是用来管理资源的，这个东西都暴露在了模块的外部，无论是使用还是管理起来都是特别不方便还容易出现危险。&lt;/p&gt;&lt;blockquote&gt; Tips : 我们之前简单的描述过，可以把这里提到的串行控制器等价于我们在实际开发中使用的 &lt;b&gt;锁&lt;/b&gt;，多种资源引来的复杂性实际上就是程序所使用的锁的数量不足，不能有效的管控所有的资源。而我们在程序的修改的结果其实就是拆解了模块，把我们的 &lt;b&gt;锁&lt;/b&gt; 暴露在了外部，对于封装和安全的问题可想而知。&lt;/blockquote&gt;&lt;h2&gt;串行控制器的实现&lt;/h2&gt;&lt;p&gt;我们刚才在谈及串行控制器的实质上面，我们可以把它想象成一把锁和一个请求锁的等待队列，在书中的模拟中是使用了 &lt;b&gt;互斥量(mutex)&lt;/b&gt; 这个更为细粒度的抽象数据实现的。&lt;/p&gt;&lt;p&gt;互斥元是一个可以被获取、在使用之后被释放的数据抽象（类比锁实现），如果某个互斥元已经被获取，想获取该互斥元的其他操作需要等到该互斥元被释放（任何时候只有一个进程能拿到），来看 &lt;code&gt;make-serializer&lt;/code&gt; 的实现过程：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-serializer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;; 创建互斥元&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;serialized-p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;; 获取互斥元&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;; 执行 p 过程&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;; 释放互斥元&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;nv&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;serialized-p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就是我们之前生成串行控制器的过程，以一个过程作为参数，我们先对获取互斥元再执行完过程 &lt;code&gt;p&lt;/code&gt; 然后再释放我们的互斥元。我们还需要一个生成互斥元的过程：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;make-mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;the-mutex&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;cond &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;test-and-set!&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;the-mutex&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eq? &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&#39;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set-car! &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;the-mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意到互斥元的管理本身也是依赖一个变量来操作的，其中的 &lt;code&gt;test-and-set!&lt;/code&gt; 检查参数的 car 值，如果参数的 car 值为假就在返回值前将其设为真值。&lt;/p&gt;&lt;p&gt;&lt;code&gt;test-and-set!&lt;/code&gt; 这个方法是生成互斥元的核心，这个操作需要以 &lt;b&gt;原子操作&lt;/b&gt; 的方式执行，具体实现可能是一个特殊的硬件指令或者是系统提供的一个专门的过程。在单处理器程序中系统通过轮转时间片的方式为每一个可执行程序安排一段运行时间，多处理器机器中我们就必须通过硬件支持的专门指令。&lt;/p&gt;&lt;h2&gt;死锁&lt;/h2&gt;&lt;p&gt;在资源抢占和申请的过程中，我们会遇到更为严重的问题 —— 死锁。我们刚才对 &lt;code&gt;serialized-exchange&lt;/code&gt; 的修改之后，通过增加一条锁，已经能让我们在交换账户的时候控制好时序性了，但是我们还可能遇到资源互相抢占的问题比如文中的例子：&lt;/p&gt;&lt;blockquote&gt; 实例：设 Peter 要交换账户 a1 和 a2，同时 Paul 想交换 a2 和 a1&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;假定 Peter 进程已进入保护 a1 的串行化过程，与此同时 Paul 也进入了保护 a2 的串行化过程&lt;/li&gt;&lt;li&gt;这时 Peter 占着保护 a1 的串行化过程，等待进入保护 a2 的过程（等待 Paul 的进程释放该过程），而 Paul 占有保护 a2 的串行化过程，并等待进入保护 a1 的过程&lt;/li&gt;&lt;li&gt;两人的进程将相互等待，永远也不能前进&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-afca18cba71d10ee28db4ac32451da6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;474&quot; data-rawheight=&quot;348&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;474&quot; data-original=&quot;https://pic2.zhimg.com/v2-afca18cba71d10ee28db4ac32451da6d_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-afca18cba71d10ee28db4ac32451da6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;474&quot; data-rawheight=&quot;348&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;474&quot; data-original=&quot;https://pic2.zhimg.com/v2-afca18cba71d10ee28db4ac32451da6d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-afca18cba71d10ee28db4ac32451da6d_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;这样两个以上的进程，由于相互等待其他方释放资源无法前进，这种情况我们就称之为死锁，如果并发系统涉及到多种资源的管理和申请，就有可能出现死锁。&lt;/p&gt;&lt;h2&gt;流&lt;/h2&gt;&lt;p&gt;之前我们引入赋值是为了解决对状态的 &lt;b&gt;模拟&lt;/b&gt; 的问题，之前的数字电路模拟之中也向我们证实了使用赋值的方式是一种正确的实现模拟的方式。但是同时我们也意识到了一个新的问题，一个由引入赋值带来的问题——计算对象包含可变的局部状态，并且这种状态是根据时间可变的了，在这种情况之下我们就不再能像之前一样把所有数据都当成不可变数据来进行计算了。&lt;/p&gt;&lt;p&gt;因此本节讨论的 &lt;b&gt;流&lt;/b&gt; 就是为了解决引入赋值所产生的状态变化问题而引入的，目的是使用另一种方法来进行模拟。之前我们对时间的模拟来自于对状态根据时间的修改，也就是说一个具体的状态在不同的时间之下是不同的，不断地修改状态实现了模拟就像下图一样一个局部状态在不断地被修改和覆盖：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-76f9fe335595345b0b88e260cc7cc93e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;338&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-76f9fe335595345b0b88e260cc7cc93e_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-76f9fe335595345b0b88e260cc7cc93e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;702&quot; data-rawheight=&quot;338&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;702&quot; data-original=&quot;https://pic3.zhimg.com/v2-76f9fe335595345b0b88e260cc7cc93e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-76f9fe335595345b0b88e260cc7cc93e_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;而使用 &lt;b&gt;流&lt;/b&gt; 来模拟采取了另一种方式来对状态随时间这个事实进行模拟，我们假设每一个状态  &lt;img src=&quot;https://www.zhihu.com/equation?tex=x&quot; alt=&quot;x&quot; eeimg=&quot;1&quot;&gt;  都包含一个随时间进行改变状态的函数  &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%28t%29&quot; alt=&quot;x(t)&quot; eeimg=&quot;1&quot;&gt;  ，每一个时间片  &lt;img src=&quot;https://www.zhihu.com/equation?tex=t+&quot; alt=&quot;t &quot; eeimg=&quot;1&quot;&gt;  都对应着一个&lt;img src=&quot;https://www.zhihu.com/equation?tex=x+&quot; alt=&quot;x &quot; eeimg=&quot;1&quot;&gt;的具体状态，在这种角度来看虽然时间、状态仍然在进行着变化，但是 &lt;b&gt;由时间到状态的映射&lt;/b&gt; &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%28t%29&quot; alt=&quot;x(t)&quot; eeimg=&quot;1&quot;&gt; 本身是不变的。因此我们就可以不再只关注 $x$ 本身作为一个变化量的变化，但是从整个时间的流逝角度来看时间和状态的映射函数本身是不变的。&lt;/p&gt;&lt;blockquote&gt; Tips：关于上面用 &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%28t%29&quot; alt=&quot;x(t)&quot; eeimg=&quot;1&quot;&gt; 来解释流的原因&lt;br&gt; SICP 用上述使用  &lt;img src=&quot;https://www.zhihu.com/equation?tex=x%28t%29&quot; alt=&quot;x(t)&quot; eeimg=&quot;1&quot;&gt;  的方式来解释 stream 的实质，其实不是在说 stream 是用来保存一个 state x 的变化过程 (随说可以提供这个功能，但是这个听起来很像是 state monad)，其实 stream 更像是一个 &lt;code&gt;operator&lt;/code&gt; 的作用。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;如书中所说我们如果从离散步长的角度上来讲，流可以被看做一个无限长的序列，通过对不同时间阶段内容的取值，来模拟由时间到状态的映射。但是从实现的角度上来讲我们并不能为了实现流而构造一个无限长度的队列，因此引入一种延迟求值的技术来表示任意（以致无限长度的序列）。&lt;/p&gt;&lt;blockquote&gt; 在&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E7%25A8%258B%25E5%25BC%258F%25E8%25AA%259E%25E8%25A8%2580%25E7%2590%2586%25E8%25AB%2596&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;编程语言理论&lt;/a&gt;中，&lt;b&gt;惰性求值&lt;/b&gt;（英语：Lazy Evaluation），又译为&lt;b&gt;惰性计算&lt;/b&gt;、&lt;b&gt;懒惰求值&lt;/b&gt;，也称为&lt;b&gt;传需求调用&lt;/b&gt;（call-by-need），是一个&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BC%2596%25E7%25A8%258B&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;计算机编程&lt;/a&gt;中的一个概念，它的目的是要最小化计算机要做的工作。它有两个相关而又有区别的含意，可以表示为“延迟求值”和“最小化求值”，惰性计算的最重要的好处是它可以构造一个无限的&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%2595%25B8%25E6%2593%259A%25E9%25A1%259E%25E5%259E%258B&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;数据类型&lt;/a&gt;。&lt;br&gt; 惰性求值的相反是&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%258F%258A%25E6%2597%25A9%25E6%25B1%2582%25E5%2580%25BC&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;及早求值&lt;/a&gt;，这是一个大多数&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E7%25BC%2596%25E7%25A8%258B%25E8%25AF%25AD%25E8%25A8%2580&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;编程语言&lt;/a&gt;所拥有的普通计算方式。&lt;br&gt; —— wiki&lt;/blockquote&gt;&lt;p&gt;如果我们在了解延迟求值的技术之前，我们编写的代码是会在编写完立刻执行的，即使没运行到也是因为处理时间过长等因素在一段时间之后自动运行到。而延迟求值则是相当于把求值的方法写在了代码里但是不会立刻运行，而是在我们需要的时候调用，并且使用当时的 context 来进行计算得到结果。有了这样的一种表示方式，我们自然而然的可以多次调用来生成多个不同状态下的结果，并最终形成一个我们想要长度的序列。其实不需要向书中卖那么长的关子，听到这学过之前内容的同学应该已经能想到了，一个能带 context 的、不会立刻进行计算的东西 —— lambda 就呼之欲出了。&lt;/p&gt;&lt;p&gt;事实上 Scheme 之中的延迟求值的实现也非常简单就是使用 lambda 的封装进行的：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; 使用 delay 包裹&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;delay &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;; 使用 force 直接拿出来调用&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;force &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因此通过这样延时求值的定义我们能够做出之前我们无法实现的一些操作，比如书中的一个无限的正整数流：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; 1) 直接 cons 生成 stream&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;integers-starting-from&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;integers-starting-from&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;+ &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;integers&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;integers-starting-from&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 2) 隐式生成的 stream&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ones&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add-streams&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-map&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;integers2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add-streams&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ones&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;integers2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使计算过程中事件的 &lt;b&gt;实际发生顺序&lt;/b&gt; 和 &lt;b&gt;过程表面结构&lt;/b&gt; 之间的对应关系变得比较宽松，因此既能获得之前我们探索模块化获得的优势，又能在效率上有所提升。&lt;/p&gt;&lt;h2&gt;流计算的应用&lt;/h2&gt;&lt;p&gt;通过引入 &lt;code&gt;流&lt;/code&gt; 这种编程概念对我们的编程方式有很大的补充能力，使用流式编程构造系统的时候本质上和使用状态和变量来构造系统有很大的区别。但其实更简单的理解方式还是可以从前几章我们所说的 &lt;code&gt;引用透明&lt;/code&gt;，流的实质也不过是过程传递和延迟加载技术的综合。书中介绍的几个流计算的应用，包括引入迭代、无穷流和和之前呼应的表示信号。&lt;/p&gt;&lt;h2&gt;将迭代操作表示为流操作&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqrt-improve&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;average&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;/ &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;guess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 求一个数的平方根&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqrt-stream&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;guesses&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;
                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;guess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqrt-improve&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                             &lt;span class=&quot;nv&quot;&gt;guesses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 打印出整个流&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;display-stream&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sqrt-stream&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;还有一个例子是通过交错级数不断地收敛来生成  &lt;img src=&quot;https://www.zhihu.com/equation?tex=%CF%80&quot; alt=&quot;π&quot; eeimg=&quot;1&quot;&gt;  的近似值： &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Cfrac%7B%CF%80%7D%7B4%7D+%3D+1+-+%5Cfrac%7B1%7D%7B3%7D+%2B+%5Cfrac%7B1%7D%7B5%7D+-+%5Cfrac%7B1%7D%7B7%7D+%2B+.....+&quot; alt=&quot; \frac{π}{4} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + ..... &quot; eeimg=&quot;1&quot;&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; 生成交错级数的流&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pi-summands&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;/ &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-map&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pi-summands&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;+ &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 部分前缀和 exercise 3.55 有提到&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;partial-sums&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add-streams&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;partial-sums&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; pi 的近似流&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pi-stream&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scale-stream&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;partial-sums&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pi-summands&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt; Tips :  流的加速收敛&lt;br&gt; 书中包含了针对这个交错级数的加速方案 euler-transform：&lt;br&gt; 加速的项目为：  &lt;img src=&quot;https://www.zhihu.com/equation?tex=S%7Bn%2B1%7D+-+%5Cfrac%7B%28S%7Bn%2B1%7D+-+S+%7Bn%7D%29+%5E+2%7D%7BS%7Bn-1%7D+-+2+S%7Bn%7D+%2B+S%7Bn%2B1%7D%7D&quot; alt=&quot;S{n+1} - \frac{(S{n+1} - S {n}) ^ 2}{S{n-1} - 2 S{n} + S{n+1}}&quot; eeimg=&quot;1&quot;&gt; &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;euler-transform&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;s0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;; Sn₋₁&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;; Sn&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;; Sn₊₁&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;/ &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;+ &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;* &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;-2&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;euler-transform&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;无穷序列&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6f5a5ab416abe1dfd188955c11ed1b83_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;203&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;481&quot; data-original=&quot;https://pic4.zhimg.com/v2-6f5a5ab416abe1dfd188955c11ed1b83_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6f5a5ab416abe1dfd188955c11ed1b83_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;203&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;481&quot; data-original=&quot;https://pic4.zhimg.com/v2-6f5a5ab416abe1dfd188955c11ed1b83_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6f5a5ab416abe1dfd188955c11ed1b83_b.jpg&quot;&gt;&lt;/figure&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pairs&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟨&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;combine-in-some-way&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;⟩&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
                  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pairs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;尝试通过 stream 的方式去生成如上图所示的无穷序列，途中主要分成了三个区域，最左上角的初始序对，和右上角的 list ，还有就是右下角的部分。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;; (S0, T0)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;; (S0, T1) , (S0, T2), (S0, T3) ,...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
              &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; 交错 items&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pairs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而其中比较重要的部分就是怎么组合两个 inf-stream 的，普通的 &lt;code&gt;stream-append&lt;/code&gt; 肯定是不行的，因为这样会一直在求值第一个 stream ，这里使用了下述的方法来交错的使用 inf-stream：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interleave&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-null?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; 
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-car&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interleave&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stream-cdr&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;将流作为信号&lt;/h2&gt;&lt;p&gt;前面以信号处理为背景讨论流问题。也可以用流建模信号处理过程，用流中元素表示一个信号在一系列顺序时间点上的值： $$ S{i} = C + \sum_{j-1}^{i}x_{j}d{t} $$&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;integral&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;integrand&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;initial-value&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cons-stream&lt;/span&gt; 
     &lt;span class=&quot;nv&quot;&gt;initial-value&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add-streams&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scale-stream&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;integrand&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                  &lt;span class=&quot;nv&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过积分器的方式表示信号系统：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-45cfd5a7c411c7bb59219a21fe3209b6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;758&quot; data-rawheight=&quot;396&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;758&quot; data-original=&quot;https://pic3.zhimg.com/v2-45cfd5a7c411c7bb59219a21fe3209b6_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-45cfd5a7c411c7bb59219a21fe3209b6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;758&quot; data-rawheight=&quot;396&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;758&quot; data-original=&quot;https://pic3.zhimg.com/v2-45cfd5a7c411c7bb59219a21fe3209b6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-45cfd5a7c411c7bb59219a21fe3209b6_b.jpg&quot;&gt;&lt;/figure&gt;&lt;h2&gt;流计算的问题&lt;/h2&gt;&lt;p&gt;流的大量使用会导致系统之中有很多部分需要显示的使用 &lt;code&gt;delay&lt;/code&gt; ，&lt;code&gt;force&lt;/code&gt; 进行管理，一种解决办法就是把系统中的 &lt;code&gt;应用序&lt;/code&gt; 求值全部换成 &lt;code&gt;正则序&lt;/code&gt; 求值。这样的求值方式更加接近流的使用方式，统一了参数的求值逻辑。但是全部换成了 &lt;code&gt;正则序&lt;/code&gt; 后可能真实的求值时间就不能够得到保障了，并且本身理解程序也会有一些困难，程序的语义也变得复杂起来了。书中的归并账号的问题也向我们揭示了另一个问题，在处理这种并发的约束条件的时候我们不能用分片、轮流的方式(这明显和实际情况不符)，因此还是要引入强制的同步。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;本章主要是在讨论有内部状态的对象，基于状态编程和模拟，我们提供了两种解决方案去表示对时间的模拟，但是都不能尽善尽美。首先是通过局部变量的模拟，对于赋值和状态的讨论是本章贯穿的内容，我们进一步揭示了赋值的引入本质上是是对时间的依赖，赋值改变了变量的状态，从而改变了依赖于这些变量的表达式的计算。具有变动状态的对象给程序带来了时间问题，程序本身也失去了引用透明性，并发会使得问题变得更加严重。引入流是作为一种替代技术，延时求值的序列是很强力模拟工具，能在一定范围内替代赋值的状态模拟。而状态变动、时间模拟、程序的非确定性这种本质性问题也很难有最优解存在。&lt;/p&gt;&lt;p&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这篇文章真的是摸的时间够长的啊，我看了一下创建时间竟然是 2017 年的 9 月份，一下子一年多的时间就溜走了。这一年多的时间里真的发生了不少事情呢，从打算出国读个 master 到暂时鸽了，在杭州阿里摸了半年，临近毕业又来了某条。SICP 也是一样，书早就读完了，但是文章却是一直鸽着，接下来的时间尽量都写完吧。这一年多见证了好多人的变化和进步，又来了北京和红红 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/c3a3b37f42ed38a9783c00cea5156e55&quot; data-hash=&quot;c3a3b37f42ed38a9783c00cea5156e55&quot; data-hovercard=&quot;p$b$c3a3b37f42ed38a9783c00cea5156e55&quot;&gt;@头顶青天红美铃&lt;/a&gt;  当了大半年的邻居。有的时候真的还是很感慨、羡慕大家的，能有很明确喜欢和努力的方向，并去不断地投入进去。相较于我，似乎平时什么都不怵，很多有点困难事情都能搞得定，但在这找喜欢的事情、方向却总是非常的迷茫。接下来的几个月尽量把这个系列的东西写完吧，也希望自己能 &quot;日拱一卒，功不唐捐&quot; QwQ。&lt;/p&gt;</description>
<author>lfkdsk</author>
<guid isPermaLink="false">2019-03-17-59528108</guid>
<pubDate>Sun, 17 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>First Lens to Lenses</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-12-58868310.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/58868310&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0ab22bd71bf809dd634a62d79be068b5_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;Haskell中有一个很强大的库，叫做Lens。&lt;/p&gt;&lt;p&gt;在Haskell中，只提供了「模式匹配」的语法来访问/修改数据结构。于是处理深层的数据就成为了老大难的问题。&lt;/p&gt;&lt;p&gt;比如在这样的数据结构里：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionX&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionY&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Segment&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Segment&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segmentStart&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segmentEnd&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Segment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们要修改l1的第二个端点的横坐标：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segmentEnd&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segmentEnd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;positionX&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果数据结构更加复杂的时候，代码就会变得更冗长。&lt;/p&gt;&lt;p&gt;这时候Lens库就出场了,刚刚那段代码等价于：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endLens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xLens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中endLens . xLens就是一个透镜组，先访问end，再访问x，.~就是set。很composable有木有。&lt;/p&gt;&lt;p&gt;但是我们打开Hackage想要看看Lens究竟是啥的时候，第一眼就被lens的类型吓到了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是啥！？&lt;/p&gt;&lt;p&gt;当我们打开某乎，搜索关键字，想看看各路dalao的解释的时候，又被吓到了：&lt;/p&gt;&lt;blockquote&gt; 一个Lens不过就是Coalgebra for the CoState Comonad，这有什么难理解的。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;这又是啥！？&lt;/p&gt;&lt;p&gt;不懂不懂！但这不妨碍我们自己去摸索……&lt;/p&gt;&lt;h2&gt;从零开始的getter和setter&lt;/h2&gt;&lt;p&gt;无论是深层还是浅层，lens做的都是get和set的操作。我们先把getter和setter抽象出来。&lt;/p&gt;&lt;p&gt;数据b到数据a的getter和setter应该具有如下类型：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;setter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们同时需要getter和setter，于是将这两个函数合起来：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果现在有一个GS b a， 我就可以对b进行set或者get的操作了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gs&lt;/span&gt; 

&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于Point到Double类型，我们可以写下一些GS：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;xGS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yGS&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;xGS&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionX&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;yGS&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionY&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以像Lens一样，对Point进行get和set：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xGS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- = 1.0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yGS&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- = Point 3.0 10.0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Lens有一个很重要的性质就是可组合性，多个lens可以组合在一起。不知GS能不能做到呢，先写下类型：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（此处省略填坑的步骤）我们可以写出组合GS的代码！&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; 
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;验证一下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xGS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- get x of the end of l1 = 3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endLens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xLens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;！好耶，我们的GS也是可以组合的！这就是我们的Lens！那么我们也给它一个Lens的名字吧！&lt;/p&gt;&lt;p&gt;附上：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt; 

&lt;span class=&quot;nf&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;over&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;over&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;compLens&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;compLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; 
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 

&lt;span class=&quot;kr&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compLens&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;infixl&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%~&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;over&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;infixl&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; 
&lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;大胆猜想 小心求证&lt;/h2&gt;&lt;p&gt;可是我们现在得到的是&lt;code&gt;b -&amp;gt; (a -&amp;gt; b, a)&lt;/code&gt;和库里的&lt;code&gt;forall f. Functor f. (a -&amp;gt; f b) -&amp;gt; (s -&amp;gt; f t)&lt;/code&gt;八竿子打不着啊。难道它们冥冥之中有什么关系！？&lt;/p&gt;&lt;p&gt;我们看一个lens的一个简化版本&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lens&#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--forall f. Functor f. (a -&amp;gt; f a) -&amp;gt; (b -&amp;gt; f b)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;调一下参数的位置就有&lt;code&gt;b -&amp;gt; forall f. Functor f. (a -&amp;gt; f a) -&amp;gt; f b&lt;/code&gt;，跟&lt;code&gt;b -&amp;gt; (a -&amp;gt; b, a)&lt;/code&gt;进行比较，不同的是&lt;code&gt;forall f. Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; f b&lt;/code&gt;和&lt;code&gt;(a -&amp;gt; b, a)&lt;/code&gt;这两部分。&lt;/p&gt;&lt;p&gt;如果这两部分是等价的（isomorphism），不就可以得到MyLens和Lens&#39;也等价了吗！？&lt;/p&gt;&lt;p&gt;于是大胆猜想：&lt;b&gt;&lt;code&gt;forall f. Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; f b&lt;/code&gt;和&lt;code&gt;(a -&amp;gt; b, a)&lt;/code&gt;是等价的&lt;/b&gt;&lt;/p&gt;&lt;p&gt;然后小（shi）心（fen）论（cao）证（shuai），（省略填hole的n步），我们写出了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lensPart&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lensPart&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afa&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;afa&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- f = (a,)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;afa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;psi&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;psi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afa&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;！好耶我们证明了MyLens和Lens&#39;是等价的！&lt;/p&gt;&lt;h2&gt;泛化的版本&lt;/h2&gt;&lt;p&gt;但是，Lens库里提供的Lens是这样的：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这又是什么意思呢？现在先别管这个，我们继续来看我们自己造的Lens。&lt;/p&gt;&lt;p&gt;现在我们可以写出这样的代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;_2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;_2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- = (10, 2)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;--set _1 10 (1, 2)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Ho Ho Ho&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;How bad could it be?&quot;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;-- ((1, &quot;How bad could it be?&quot;), 2)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是我们暂时写不出：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;1&#39;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--期望得到(&#39;1&#39;, 2)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的代码，会报错：&lt;/p&gt;&lt;p&gt;&lt;code&gt;? Could not deduce (Num Char) arising from the literal ‘1’       from the context: Num b         bound by the inferred type of it :: Num b =&amp;gt; (Char, b)         at &amp;lt;interactive&amp;gt;:2:1-18&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这是因为MyLens对getter和setter的抽象，限制了set进去的东西要和get到的东西具有同样的类型，并且set完之后的类型要和set之前一样：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;--             ^ here，这是get到的值的类型&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;setter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;--             ^ here，这是set进去的值的类型&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以来消除这个限制，将getter和setter抽象为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 从s中get到a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;setter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--把s中的a set为b，s变为t&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;于是MyLens可以重写为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- getter :: s -&amp;gt; a&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- setter :: s -&amp;gt; b -&amp;gt; t&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- set, view, over, (&amp;gt;.)等的实现和之前完全一样!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们就可以写出：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;1&#39;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- (&#39;1&#39;, 2)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么，问题来了，现在这个MyLens的版本是否是和库里的Lens等价呢？现在也给出一个证明（省略填hole过程）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Helper&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Helper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unHelper&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;psi&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;psi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afb&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lensPart&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unHelper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lensPart&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afb&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;afb&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Helper&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- f = (a, b -&amp;gt; _)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;afb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Helper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;Further more?&lt;/h2&gt;&lt;p&gt;到这里，我们已经得到了一个属于自己的Lens。我们也会用它从一些数据结构中的字段，但是Lens远远不是只有这点威力。&lt;/p&gt;&lt;p&gt;首先，MyLens中的getter和setter其实是抽象的，&lt;code&gt;getter :: b -&amp;gt; a&lt;/code&gt;a并不一定指的是b中的字段，而就是一个普普通通的函数。比如我设写一个lens，从[a]中get到length，而set并不改变值：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;_length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们根据这个_length可以写出一些代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;view&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Tora!Tora!Tora!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 3 &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- [1, 2, 3]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此，我们发现MyLens和库中的Lens并没有什么使用上的不同（毕竟是等价的）。而MyLens这么直观，为何库中Lens要采用这种形式呢？我现在是不知道的，但我仍然被库中的Lens所折服：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;(a -&amp;gt; f b) -&amp;gt; (s -&amp;gt; f t)&lt;/code&gt;形式优美，跟CPS变换有很深的联系。&lt;/li&gt;&lt;li&gt;通过取不同的函子，能达到不同层次的抽象，实现不同的行为。（而MyLens就做不了很多其它抽象了。比如说Lens库中的Traversal，不过这个其实是我自己写不出行为一致的代码，从而下的断言）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下面开始解答前面的一些问题：&lt;/p&gt;&lt;h2&gt;Co-Algebra for Co-State Co-Monad?&lt;/h2&gt;&lt;p&gt;回到前文提到，ekmett大神说过：&lt;/p&gt;&lt;blockquote&gt; 一个Lens不过就是Coalgebra for the CoState Comonad，这有什么难理解的。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;我们也验证一下这句abstract nonsense&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先CoState Comonad就是Haskell中的Store&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Store&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Store&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是&lt;code&gt;(s-&amp;gt;a, s)&lt;/code&gt;。它是一个Comonad，自然也就是一个Endofunctor&lt;/p&gt;&lt;ul&gt;&lt;li&gt;然后CoAlgebra for Endofunctor f就是一个a，和一个态射&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CoAlgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;最后Coalgebra for the CoState Comonad就是&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;CoAlgebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Store&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;   
&lt;span class=&quot;c1&quot;&gt;-- -&amp;gt;   &lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Store&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;  
 &lt;span class=&quot;c1&quot;&gt;-- ~   a -&amp;gt;(s-&amp;gt;a, s)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这玩意儿就是咱们定义的MyLens的初始版本。&lt;/p&gt;&lt;p&gt;哦！这句话原来是这个意思（我怎么还是啥都没学到）&lt;/p&gt;&lt;h2&gt;Yoneda lemma？&lt;/h2&gt;&lt;p&gt;Yoneda lemma说的是，对象A和函子F满足：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=+Nat%28Hom%28A%2C%5C_%29%2C+F%29+%5Ccong+F%5C+A+&quot; alt=&quot; Nat(Hom(A,\_), F) \cong F\ A &quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;在Haskell中，在*范畴，可以具体写出：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Yoneda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 与&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 等价&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们观察到&lt;code&gt;forall f. Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; f b&lt;/code&gt;和形式1是很像的，那有没有可能两种Lens的等价关系可以由Yoneda lemma导出呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;直觉是对的，但是这里要绕点弯子：&lt;/p&gt;&lt;p&gt;首先Yoneda lemma是对所有的范畴都成立的，我们可以看一下在自函子范畴的形式是怎么样的（伪代码）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;-- eta :: (*-&amp;gt;*)-&amp;gt;*, 函子的函子&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Yoneda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eta&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--f到g的自然变换，也就是函子间的态射，Hom(f, _)&lt;/span&gt;
        &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eta&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 与&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;eta&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 等价&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在给一个不严谨的证明：&lt;/p&gt;&lt;p&gt;将&lt;code&gt;eta g = g b&lt;/code&gt;，&lt;code&gt;f t = (a, a-&amp;gt;t)&lt;/code&gt;代入在自函子范畴上的Yoneda lemma，得到&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 与&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 等价&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（很接近了！）&lt;/p&gt;&lt;p&gt;对形式1中&lt;code&gt;forall t. ((a, a-&amp;gt;t) -&amp;gt; g t)&lt;/code&gt;进行curry化，得到&lt;code&gt;a -&amp;gt; forall t. (a-&amp;gt;t) -&amp;gt; g t&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对&lt;code&gt;forall t. (a-&amp;gt;t) -&amp;gt; g t&lt;/code&gt;应用*范畴下的Yoneda lemma，替换成&lt;code&gt;g a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;于是形式1等价于&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;于是就得到了：&lt;/p&gt;&lt;p&gt;&lt;code&gt;forall g. Functor g =&amp;gt; (a -&amp;gt; g a) -&amp;gt; f b&lt;/code&gt;和&lt;code&gt;(a -&amp;gt; b, a)&lt;/code&gt;是等价的！&lt;/p&gt;&lt;p&gt;（目的达成！功德圆满！）&lt;/p&gt;&lt;h2&gt;后记&lt;/h2&gt;&lt;p&gt;终于能拿两三天来瞅瞅Lens库，着实被Lens库的优美所震撼！然后又按图索骥，自己鼓捣出上面这些东西，真的挺满足的。说是填hole，但其实都是在草稿纸上推的。。。然后灵光一闪填一个函子进去，然后就ok了。不过过程中我是想用idris来证明那些等价关系的，最后发现idris写出来的东西很冗长，于是就算了，毕竟也没用上dt。&lt;/p&gt;&lt;p&gt;然后就是我到现在对MyLens是否能实现Traversal的功能，我还是存疑的，望大佬解惑。写过这样一个函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;traverse&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Traversable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monoid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;traverse&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fold&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发现行为和traverse之于Lens不一致。（就不应该出现fold fa的）。。。就很困惑，直觉告诉我是写不出来的。又尝试将Helper a b实现了Applicative，再代入一个同构的map中，得到的行为也不一致555。&lt;/p&gt;&lt;p&gt;关于标题双关：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Lens to Lenses就是从自己写的Lens再看库里的Lens&lt;/li&gt;&lt;li&gt;第一个Lens作动词，想表达focus的意思（生掰），就是关注Lens（及背后的一些东西）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后 望各路大神指正（溜了&lt;/p&gt;</description>
<author>Xyzt Toe</author>
<guid isPermaLink="false">2019-03-12-58868310</guid>
<pubDate>Tue, 12 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>First Lens to Lenses</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-11-58868310.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/58868310&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0ab22bd71bf809dd634a62d79be068b5_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;Haskell中有一个很强大的库，叫做Lens。&lt;/p&gt;&lt;p&gt;在Haskell中，只提供了「模式匹配」的语法来访问/修改数据结构。于是处理深层的数据就成为了老大难的问题。&lt;/p&gt;&lt;p&gt;比如在这样的数据结构里：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionX&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionY&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Segment&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Segment&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segmentStart&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segmentEnd&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Segment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们要修改l1的第二个端点的横坐标：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segmentEnd&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;segmentEnd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;positionX&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果数据结构更加复杂的时候，代码就会变得更冗长。&lt;/p&gt;&lt;p&gt;这时候Lens库就出场了,刚刚那段代码等价于：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endLens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xLens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中endLens . xLens就是一个透镜组，先访问end，再访问x，.~就是set。很composable有木有。&lt;/p&gt;&lt;p&gt;但是我们打开Hackage想要看看Lens究竟是啥的时候，第一眼就被lens的类型吓到了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是啥！？&lt;/p&gt;&lt;p&gt;当我们打开某乎，搜索关键字，想看看各路dalao的解释的时候，又被吓到了：&lt;/p&gt;&lt;blockquote&gt; 一个Lens不过就是Coalgebra for the CoState Comonad，这有什么难理解的。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;这又是啥！？&lt;/p&gt;&lt;p&gt;不懂不懂！但这不妨碍我们自己去摸索……&lt;/p&gt;&lt;h2&gt;从零开始的getter和setter&lt;/h2&gt;&lt;p&gt;无论是深层还是浅层，lens做的都是get和set的操作。我们先把getter和setter抽象出来。&lt;/p&gt;&lt;p&gt;数据b到数据a的getter和setter应该具有如下类型：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;setter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们同时需要getter和setter，于是将这两个函数合起来：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果现在有一个GS b a， 我就可以对b进行set或者get的操作了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gs&lt;/span&gt; 

&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于Point到Double类型，我们可以写下一些GS：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;xGS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yGS&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;xGS&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionX&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;yGS&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionY&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以像Lens一样，对Point进行get和set：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xGS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- = 1.0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yGS&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- = Point 3.0 10.0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Lens有一个很重要的性质就是可组合性，多个lens可以组合在一起。不知GS能不能做到呢，先写下类型：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（此处省略填坑的步骤）我们可以写出组合GS的代码！&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kt&quot;&gt;GS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; 
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;验证一下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xGS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- get x of the end of l1 = 3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endLens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xLens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;！好耶，我们的GS也是可以组合的！这就是我们的Lens！那么我们也给它一个Lens的名字吧！&lt;/p&gt;&lt;p&gt;附上：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt; 

&lt;span class=&quot;nf&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;over&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;over&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;compLens&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;compLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; 
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 

&lt;span class=&quot;kr&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compLens&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;infixl&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%~&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;over&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;infixl&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; 
&lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;大胆猜想 小心求证&lt;/h2&gt;&lt;p&gt;可是我们现在得到的是&lt;code&gt;b -&amp;gt; (a -&amp;gt; b, a)&lt;/code&gt;和库里的&lt;code&gt;forall f. Functor f. (a -&amp;gt; f b) -&amp;gt; (s -&amp;gt; f t)&lt;/code&gt;八竿子打不着啊。难道它们冥冥之中有什么关系！？&lt;/p&gt;&lt;p&gt;我们看一个lens的一个简化版本&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lens&#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--forall f. Functor f. (a -&amp;gt; f a) -&amp;gt; (b -&amp;gt; f b)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;调一下参数的位置就有&lt;code&gt;b -&amp;gt; forall f. Functor f. (a -&amp;gt; f a) -&amp;gt; f b&lt;/code&gt;，跟&lt;code&gt;b -&amp;gt; (a -&amp;gt; b, a)&lt;/code&gt;进行比较，不同的是&lt;code&gt;forall f. Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; f b&lt;/code&gt;和&lt;code&gt;(a -&amp;gt; b, a)&lt;/code&gt;这两部分。&lt;/p&gt;&lt;p&gt;如果这两部分是等价的（isomorphism），不就可以得到MyLens和Lens&#39;也等价了吗！？&lt;/p&gt;&lt;p&gt;于是大胆猜想：&lt;b&gt;&lt;code&gt;forall f. Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; f b&lt;/code&gt;和&lt;code&gt;(a -&amp;gt; b, a)&lt;/code&gt;是等价的&lt;/b&gt;&lt;/p&gt;&lt;p&gt;然后小（shi）心（fen）论（cao）证（shuai），（省略填hole的n步），我们写出了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lensPart&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lensPart&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afa&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;afa&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- f = (a,)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;afa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;psi&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;psi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afa&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;！好耶我们证明了MyLens和Lens&#39;是等价的！&lt;/p&gt;&lt;h2&gt;泛化的版本&lt;/h2&gt;&lt;p&gt;但是，Lens库里提供的Lens是这样的：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这又是什么意思呢？现在先别管这个，我们继续来看我们自己造的Lens。&lt;/p&gt;&lt;p&gt;现在我们可以写出这样的代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;_2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;_2&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- = (10, 2)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;--set _1 10 (1, 2)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Ho Ho Ho&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;How bad could it be?&quot;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;-- ((1, &quot;How bad could it be?&quot;), 2)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是我们暂时写不出：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;1&#39;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--期望得到(&#39;1&#39;, 2)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的代码，会报错：&lt;/p&gt;&lt;p&gt;&lt;code&gt;? Could not deduce (Num Char) arising from the literal ‘1’       from the context: Num b         bound by the inferred type of it :: Num b =&amp;gt; (Char, b)         at &amp;lt;interactive&amp;gt;:2:1-18&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这是因为MyLens对getter和setter的抽象，限制了set进去的东西要和get到的东西具有同样的类型，并且set完之后的类型要和set之前一样：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;--             ^ here，这是get到的值的类型&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;setter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;--             ^ here，这是set进去的值的类型&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以来消除这个限制，将getter和setter抽象为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 从s中get到a&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;setter&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--把s中的a set为b，s变为t&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;于是MyLens可以重写为：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- getter :: s -&amp;gt; a&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- setter :: s -&amp;gt; b -&amp;gt; t&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- set, view, over, (&amp;gt;.)等的实现和之前完全一样!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们就可以写出：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;1&#39;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- (&#39;1&#39;, 2)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么，问题来了，现在这个MyLens的版本是否是和库里的Lens等价呢？现在也给出一个证明（省略填hole过程）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Lens&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Helper&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Helper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unHelper&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;psi&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;psi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afb&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lensPart&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unHelper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lensPart&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;afb&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;snd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fst&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;afb&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Helper&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- f = (a, b -&amp;gt; _)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;afb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Helper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;Further more?&lt;/h2&gt;&lt;p&gt;到这里，我们已经得到了一个属于自己的Lens。我们也会用它从一些数据结构中的字段，但是Lens远远不是只有这点威力。&lt;/p&gt;&lt;p&gt;首先，MyLens中的getter和setter其实是抽象的，&lt;code&gt;getter :: b -&amp;gt; a&lt;/code&gt;a并不一定指的是b中的字段，而就是一个普普通通的函数。比如我设写一个lens，从[a]中get到length，而set并不改变值：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;_length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们根据这个_length可以写出一些代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;view&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 3&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Tora!Tora!Tora!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 3 &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.~&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- [1, 2, 3]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此，我们发现MyLens和库中的Lens并没有什么使用上的不同（毕竟是等价的）。而MyLens这么直观，为何库中Lens要采用这种形式呢？我现在是不知道的，但我仍然被库中的Lens所折服：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;(a -&amp;gt; f b) -&amp;gt; (s -&amp;gt; f t)&lt;/code&gt;形式优美，跟CPS变换有很深的联系。&lt;/li&gt;&lt;li&gt;通过取不同的函子，能达到不同层次的抽象，实现不同的行为。（而MyLens就做不了很多其它抽象了。比如说Lens库中的Traversal，不过这个其实是我自己写不出行为一致的代码，从而下的断言）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下面开始解答前面的一些问题：&lt;/p&gt;&lt;h2&gt;Co-Algebra for Co-State Co-Monad?&lt;/h2&gt;&lt;p&gt;回到前文提到，ekmett大神说过：&lt;/p&gt;&lt;blockquote&gt; 一个Lens不过就是Coalgebra for the CoState Comonad，这有什么难理解的。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;我们也验证一下这句abstract nonsense&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先CoState Comonad就是Haskell中的Store&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Store&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Store&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是&lt;code&gt;(s-&amp;gt;a, s)&lt;/code&gt;。它是一个Comonad，自然也就是一个Endofunctor&lt;/p&gt;&lt;ul&gt;&lt;li&gt;然后CoAlgebra for Endofunctor f就是一个a，和一个态射&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CoAlgebra&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;最后Coalgebra for the CoState Comonad就是&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;CoAlgebra&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Store&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;   
&lt;span class=&quot;c1&quot;&gt;-- -&amp;gt;   &lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Store&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;  
 &lt;span class=&quot;c1&quot;&gt;-- ~   a -&amp;gt;(s-&amp;gt;a, s)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这玩意儿就是咱们定义的MyLens的初始版本。&lt;/p&gt;&lt;p&gt;哦！这句话原来是这个意思（我怎么还是啥都没学到）&lt;/p&gt;&lt;h2&gt;Yoneda lemma？&lt;/h2&gt;&lt;p&gt;Yoneda lemma说的是，对象A和函子F满足：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=+Nat%28Hom%28A%2C%5C_%29%2C+F%29+%5Ccong+F%5C+A+&quot; alt=&quot; Nat(Hom(A,\_), F) \cong F\ A &quot; eeimg=&quot;1&quot;&gt; &lt;/p&gt;&lt;p&gt;在Haskell中，在*范畴，可以具体写出：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Yoneda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 与&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 等价&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们观察到&lt;code&gt;forall f. Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; f b&lt;/code&gt;和形式1是很像的，那有没有可能两种Lens的等价关系可以由Yoneda lemma导出呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;直觉是对的，但是这里要绕点弯子：&lt;/p&gt;&lt;p&gt;首先Yoneda lemma是对所有的范畴都成立的，我们可以看一下在自函子范畴的形式是怎么样的（伪代码）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;-- eta :: (*-&amp;gt;*)-&amp;gt;*, 函子的函子&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Yoneda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eta&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--f到g的自然变换，也就是函子间的态射，Hom(f, _)&lt;/span&gt;
        &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eta&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 与&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;eta&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 等价&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在给一个不严谨的证明：&lt;/p&gt;&lt;p&gt;将&lt;code&gt;eta g = g b&lt;/code&gt;，&lt;code&gt;f t = (a, a-&amp;gt;t)&lt;/code&gt;代入在自函子范畴上的Yoneda lemma，得到&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 与&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 等价&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（很接近了！）&lt;/p&gt;&lt;p&gt;对形式1中&lt;code&gt;forall t. ((a, a-&amp;gt;t) -&amp;gt; g t)&lt;/code&gt;进行curry化，得到&lt;code&gt;a -&amp;gt; forall t. (a-&amp;gt;t) -&amp;gt; g t&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对&lt;code&gt;forall t. (a-&amp;gt;t) -&amp;gt; g t&lt;/code&gt;应用*范畴下的Yoneda lemma，替换成&lt;code&gt;g a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;于是形式1等价于&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;于是就得到了：&lt;/p&gt;&lt;p&gt;&lt;code&gt;forall g. Functor g =&amp;gt; (a -&amp;gt; g a) -&amp;gt; f b&lt;/code&gt;和&lt;code&gt;(a -&amp;gt; b, a)&lt;/code&gt;是等价的！&lt;/p&gt;&lt;p&gt;（目的达成！功德圆满！）&lt;/p&gt;&lt;h2&gt;后记&lt;/h2&gt;&lt;p&gt;终于能拿两三天来瞅瞅Lens库，着实被Lens库的优美所震撼！然后又按图索骥，自己鼓捣出上面这些东西，真的挺满足的。说是填hole，但其实都是在草稿纸上推的。。。然后灵光一闪填一个函子进去，然后就ok了。不过过程中我是想用idris来证明那些等价关系的，最后发现idris写出来的东西很冗长，于是就算了，毕竟也没用上dt。&lt;/p&gt;&lt;p&gt;然后就是我到现在对MyLens是否能实现Traversal的功能，我还是存疑的，望大佬解惑。写过这样一个函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;traverse&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Traversable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monoid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;traverse&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyLens&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fold&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发现行为和traverse之于Lens不一致。（就不应该出现fold fa的）。。。就很困惑，直觉告诉我是写不出来的。又尝试将Helper a b实现了Applicative，再代入一个同构的map中，得到的行为也不一致555。&lt;/p&gt;&lt;p&gt;关于标题双关：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Lens to Lenses就是从自己写的Lens再看库里的Lens&lt;/li&gt;&lt;li&gt;第一个Lens作动词，想表达focus的意思（生掰），就是关注Lens（及背后的一些东西）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后 望各路大神指正（溜了&lt;/p&gt;</description>
<author>Xyzt Toe</author>
<guid isPermaLink="false">2019-03-11-58868310</guid>
<pubDate>Mon, 11 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 Idris 实现带有状态的系统：ST 教程</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-03-01-58065559.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/58065559&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-51626f48ce2333edbd5aa531b7567d47_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;《用 Idris 实现带有状态的系统：ST 教程》为 Idris-zh 项目的另一个主要教程，鸽了很久之后终于翻译完毕。大家可以前去阅读审校。如有问题可在 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/Idris-zh/Idris-dev/issues&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Idris-zh/Idris-dev&lt;/a&gt; 提出 Issue 或直接发起 PR。&lt;/p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//Idris-zh.rtfd.org/zh_CN/latest/st/index.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;用 Idris 实现带有状态的系统：ST 教程&lt;/a&gt;&lt;blockquote&gt;像 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.idris-lang.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Idris&lt;/a&gt; 这种可以直接用类型系统对程序进行推理的函数式语言， 仅凭程序能够编译这一点，我们就能&lt;b&gt;确定&lt;/b&gt;该程序会正确运行（即按照类型描述的规范运行）。&lt;br&gt;&lt;br&gt;然而在现实中，软件依赖于状态，很多组件则依赖于状态机。它们可以描述像 TCP 这样的网络传输协议， 实现事件驱动的系统以及正则表达式的匹配。此外，像网络 Socket 和文件这类的很多基础资源， 都由状态机隐式地管理；特定操作只有在资源处于特定状态时才可行，而这些操作也可以改变底层资源的状态。 例如，只有向已建立连接的网络 Socket 发送消息才有意义，关闭 Socket 会将其状态从“打开”切换为“关闭”。 状态机同样可以编码重要的安全性质。比如，在一个 ATM（自动取款机）的软件实现中， 有一点性质非常重要：ATM 只有在卡片插入且通过密码验证的状态下才能吐出钞票。&lt;br&gt;&lt;br&gt;本教程介绍了 &lt;code&gt;Control.ST&lt;/code&gt; 库，它支持对带有状态和副作用的程序进行编程和推理。 该库已包含在 Idris 发行版当中（目前属于 &lt;code&gt;contrib&lt;/code&gt; 包）。本教程假设读者已经熟悉 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//idris-zh.readthedocs.io/zh_CN/latest/tutorial/index.html%23tutorial-index&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Idris 教程&lt;/a&gt;中所述的纯函数式的编程方法。&lt;code&gt;ST&lt;/code&gt; 库基于&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.manning.com/books/type-driven-development-with-idris&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Idris 类型驱动开发》&lt;/a&gt;一书中第 13 和 14 章所讨论的内容，如需更多背景信息可以参考此书。&lt;/blockquote&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2019-03-01-58065559</guid>
<pubDate>Fri, 01 Mar 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>用HoTT/CuTT玩转代数拓扑： 证明torus = s1 × s1</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2019-02-14-56587949.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56587949&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在主流HoTT的可计算模型都基于cubical type,而ct又有2种：cartesian 与De Morgan：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-78f16c24d8edd9ade3e34c7e0c60648f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;677&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;901&quot; data-original=&quot;https://pic4.zhimg.com/v2-78f16c24d8edd9ade3e34c7e0c60648f_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-78f16c24d8edd9ade3e34c7e0c60648f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;677&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;901&quot; data-original=&quot;https://pic4.zhimg.com/v2-78f16c24d8edd9ade3e34c7e0c60648f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-78f16c24d8edd9ade3e34c7e0c60648f_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;而今天介绍的是一个基于cartesian cubical set 的theorem prover : redtt。&lt;/p&gt;&lt;p&gt;这里是一个HIT的例子：在代数拓扑里边，有torus =s1 * s1 ，你可以想象一个甜甜圈等价与与一个圆绕着另一个圆一圈。这里给出了 t2c : torus =&amp;gt;s1 * s1 函数的构造，只要我们再证明t2c是一个equivalence，然后用UA即可证明torus =s1 * s1&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8be8294d68e6ce44a7fcedccb97f0c10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;902&quot; data-rawheight=&quot;671&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;902&quot; data-original=&quot;https://pic1.zhimg.com/v2-8be8294d68e6ce44a7fcedccb97f0c10_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8be8294d68e6ce44a7fcedccb97f0c10_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;902&quot; data-rawheight=&quot;671&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;902&quot; data-original=&quot;https://pic1.zhimg.com/v2-8be8294d68e6ce44a7fcedccb97f0c10_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8be8294d68e6ce44a7fcedccb97f0c10_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;已经证明的一些东西：&lt;/p&gt;&lt;figure&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-487703ce5d1d5ba1f5fc04aed4111e4f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;913&quot; data-rawheight=&quot;683&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;913&quot; data-original=&quot;https://pic4.zhimg.com/v2-487703ce5d1d5ba1f5fc04aed4111e4f_r.jpg&quot;&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-487703ce5d1d5ba1f5fc04aed4111e4f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;913&quot; data-rawheight=&quot;683&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;913&quot; data-original=&quot;https://pic4.zhimg.com/v2-487703ce5d1d5ba1f5fc04aed4111e4f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-487703ce5d1d5ba1f5fc04aed4111e4f_b.jpg&quot;&gt;&lt;/figure&gt;&lt;p&gt;详细的slides请看&lt;/p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=http%3A//www.jonmsterling.com/pdfs/dagstuhl.pdf&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;jonmsterling.com/pdfs/d&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;agstuhl.pdf&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Martin awodey</author>
<guid isPermaLink="false">2019-02-14-56587949</guid>
<pubDate>Thu, 14 Feb 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
