<p><i>原文<a href="https://link.zhihu.com/?target=https%3A//aphyr.com/posts/342-typing-the-technical-interview" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">aphyr.com/posts/342-typ</span><span class="invisible">ing-the-technical-interview</span><span class="ellipsis"></span></a></i> </p><p><i>草稿，没加译注，欢迎校对</i></p><p>在很久，很久以前，比基督信仰的存在还要早的时候，在那些无定形的旧日时光里，所有的咒语都是由纯粹的因果关系所编织而成的，所有的行为都是被允许的，而死亡是司空见惯的。在那时，许多女巫被她们自己失控的法术所毁灭：人们常常见到，她们支离破碎的躯体躺在一个由扭曲的、被结晶侵蚀的树木和在池水中不断燃烧的石头组成的圆圈的中心。另一些人则完全消失了，或者说，她们在沿着虚无的无尽山脊漫步：她们的脚再也无法触碰地面，她们的呼吸再也无法温暖空气。</p><p>你在孩提时代便听闻了古尔薇格[1]的故事，她曾三次重生于对她的审判之火，她曾周游世界表演Seiðr魔术：一种预知并重新编织未来的技艺。她的预言(有很多)是非常著名的-甚至那些超越世界的传奇女巫Völva[2]们也曾提起过-但是真正改变历史的，是她的永生。在Seiðr魔术带来的的狂喜恍惚和谵妄之间，她预见了自己的命运，并征服了死亡。她的咒语<i>永远不会崩溃</i>，她是为社会所不容之人-你这类人的前辈-们的朋友。据说连奥丁本人也是从她那里学到了不老不死的秘密。</p><p>直到今天，所有的女巫都欠古尔薇格一笔债。现在很少有人深入研究古代的、非结构化的魔法。今日你用来写下咒语的语言，都是在语法层面稳定的。这些语言通过(或多或少地)安全的途径来引导你所召唤的能量。当然，爆炸偶尔也会发生。但这些事故只是...那种会燎到你的眉毛的类型，而不是那种，会摧毁大地并创造出一些新的，形状有趣的峡湾的类型。</p><hr/><p>“一切都顺利吗？你还好吗？”</p><p>面试官(他的胸牌上写着他的名字，“克里斯”)很年轻，这是硅谷的惯例。他穿着连帽衫，从在衣服上找不到品牌logo这一点来看，这件衣服至少值三百美元。他不像是那种会让你不知所措的类型，你觉得你会处理好这场面试的。</p><p>“一般来说？我不这么认为。“你环顾会议室，好像在确认这个世界是否在正常运转。房间的墙壁散发着slack私聊和试图回避矛盾的气息。</p><p>“啊，好吧，嗯。是的，可能是吧。“他听起来很害羞。“但是还是让我们来做一道小题。只是一个简单的算法题，让我了解一下你是如何解决难题的。“</p><p>有一次，你用一把碎玻璃做的小刀解决了一个难题。你期待着克里斯是否有能力去做你已经做到过的事情。</p><p>“所以说...这个问题叫做N-皇后，它相当简单。给定一个NxN棋盘，你需要找到一种方法，将N个皇后安全地放在那个棋盘上。“</p><p>你在白板上画了一个8x8的网格，并在中心将八个皇后整齐地排列在一起。她们面对面围成一个紧密的圆圈，平等地交谈。</p><p>“呃，不-那是不对的。看这里，这个皇后可以一步移动吃掉这四个中的任何一个“。</p><p>“你真的无法想象，”你的声音如同岩石般冷静，“想象八个强悍的女人待在一个房间里，而她们没有开始自相残杀吗？”</p><p>“呃...反正问题就是这么问的“</p><p>那么，也许她们是正在互相交战的氏族的首领。在一起讨论停战协定，但没有人能够在短剑的攻击范围内相信其他人-这种情形在你们族人的历史上也发生过。</p><p>“我可以使用任何编程语言来写这道题吗？”</p><p>“当然可以。”</p><p>赶快行动，在他意识到自己犯下何种大错之前。</p><div class="highlight"><pre><code class="language-haskell"><span class="cm">{-# OPTIONS_GHC -fno-warn-missing-methods #-}</span>
<span class="cm">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="cm">{-# LANGUAGE FunctionalDependencies #-}</span>
<span class="cm">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="cm">{-# LANGUAGE UndecidableInstances #-}</span></code></pre></div><p>“哦，这是Haskell！我在大学里学过这个！“他停顿了一下，皱起了眉头。“<code>UndecidableInstances</code>？”</p><p>“我们必须用这个扩展，”你兴高采烈地告诉他，“因为<code>Hask</code>不是一个范畴。”</p><p>“哦，好吧。”他虚张声势地说了一句没有针对性的开放观点，“这就是我们通常认为Haskell的子集中的类型没有底值的原因。”</p><p>“没错。”你小声同意。但是他由于没听到而觉得你在否认他。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">nil</span> <span class="ow">=</span> <span class="nf">undefined</span></code></pre></div><p>一个令人不安的问题随着你脑海中浮现的第一件事脱口而出，“为了存储皇后的位置，我们需要某种链表，对吗？”</p><p>“当然可以，也可以是<code>Vector</code>。”</p><p>“列表更简单。”</p><p>“好的，当然。都行。“</p><p>你从虚空中召来一个链表。它漂浮在屏幕的表面：一个永恒的结构，能够以一千种方式表达，但总是美妙的。你心满意足地叹了口气。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Nil</span>
<span class="kr">data</span> <span class="kt">Cons</span> <span class="nf">x</span> <span class="nf">xs</span></code></pre></div><p>“你不用标准库吗？”克里斯问，他皱着眉头。</p><p>“什么？”你根本不知道他在说什么。“哦，不-我不想<code>import</code>外部库。我觉得手动定义更简单。“</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">class</span> <span class="kt">First</span> <span class="nf">list</span> <span class="nf">x</span> <span class="o">|</span> <span class="nf">list</span> <span class="ow">-&gt;</span> <span class="nf">x</span>
<span class="kr">instance</span> <span class="kt">First</span> <span class="kt">Nil</span> <span class="kt">Nil</span>
<span class="kr">instance</span> <span class="kt">First</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">x</span> <span class="nf">more</span><span class="p">)</span> <span class="nf">x</span></code></pre></div><p>“我用<code>class</code>关键字定义了一个函数签名，”你提醒克里斯，他看起来很迷茫。“首先获取列表并从中返回一个值<code>x</code>。我们的函数有两个实现-Haskell使用模式匹配来决定调用哪个。传一个<code>Nil</code>列表给<code>First</code>会返回<code>Nil</code>，传一个<code>Cons</code>则会返回这个列表单元对象里面装的值“</p><p>你确保他理解了这一点，然后将两个列表连接在一起。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">class</span> <span class="kt">ListConcat</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">c</span> <span class="o">|</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">c</span>
<span class="kr">instance</span> <span class="kt">ListConcat</span> <span class="kt">Nil</span> <span class="nf">x</span> <span class="nf">x</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">ListConcat</span> <span class="nf">as</span> <span class="nf">bs</span> <span class="nf">cs</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">ListConcat</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">a</span> <span class="nf">as</span><span class="p">)</span> <span class="nf">bs</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">a</span> <span class="nf">cs</span><span class="p">)</span></code></pre></div><p>“这个箭头是啥？”克里斯问。你告诉他这意味着实质蕴涵。要得到箭头后面的ListConcat，我们需要箭头之前的那个ListConcat。</p><p>他灵光一闪，“哦，对！这是递归，因为第二个<code>ListConcat</code>的实现里也出现了<code>ListConcat</code>。第一个有<code>Nil</code>的实现是base case。“</p><p>“没错。”你为克里斯感到骄傲，他跟上了。“底下的那个实现是当我们想连接列表时的一般情况。”</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- Concatenate all lists in a list</span>
<span class="kr">class</span> <span class="kt">ListConcatAll</span> <span class="nf">ls</span> <span class="nf">l</span> <span class="o">|</span> <span class="nf">ls</span> <span class="ow">-&gt;</span> <span class="nf">l</span>
<span class="kr">instance</span> <span class="kt">ListConcatAll</span> <span class="kt">Nil</span> <span class="kt">Nil</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">ListConcat</span> <span class="nf">chunk</span> <span class="nf">acc</span> <span class="nf">result</span><span class="p">,</span>
          <span class="kt">ListConcatAll</span> <span class="nf">rest</span> <span class="nf">acc</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">ListConcatAll</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">chunk</span> <span class="nf">rest</span><span class="p">)</span> <span class="nf">result</span>

<span class="c1">-- Is any element of this list True?</span>
<span class="kr">class</span> <span class="kt">AnyTrue</span> <span class="nf">list</span> <span class="nf">t</span> <span class="o">|</span> <span class="nf">list</span> <span class="ow">-&gt;</span> <span class="nf">t</span>
<span class="kr">instance</span> <span class="kt">AnyTrue</span> <span class="kt">Nil</span>              <span class="kt">False</span>
<span class="kr">instance</span> <span class="kt">AnyTrue</span> <span class="p">(</span><span class="kt">Cons</span> <span class="kt">True</span> <span class="nf">more</span><span class="p">)</span> <span class="kt">True</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">AnyTrue</span> <span class="nf">list</span> <span class="nf">t</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">AnyTrue</span> <span class="p">(</span><span class="kt">Cons</span> <span class="kt">False</span> <span class="nf">list</span><span class="p">)</span> <span class="nf">t</span></code></pre></div><p>思考这个问题需要比你预期的更多的注意力，所以你准备退回到一些更容易的事情上。 “让我们定义一下布尔代数。”你建议，就像邀请他共进午餐一样。</p><p>“为什么？”</p><p>“当然是因为我们需要。”</p><p>你从虚空中抓住两个无意义的常数，然后赋予它们意义。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">True</span>
<span class="kr">data</span> <span class="kt">False</span>

<span class="kr">class</span> <span class="kt">Not</span> <span class="nf">b1</span> <span class="nf">b</span> <span class="o">|</span> <span class="nf">b1</span> <span class="ow">-&gt;</span> <span class="nf">b</span>
<span class="kr">instance</span> <span class="kt">Not</span> <span class="kt">False</span> <span class="kt">True</span>
<span class="kr">instance</span> <span class="kt">Not</span> <span class="kt">True</span>  <span class="kt">False</span>

<span class="kr">class</span> <span class="kt">Or</span> <span class="nf">b1</span> <span class="nf">b2</span> <span class="nf">b</span> <span class="o">|</span> <span class="nf">b1</span> <span class="nf">b2</span> <span class="ow">-&gt;</span> <span class="nf">b</span>
<span class="kr">instance</span> <span class="kt">Or</span> <span class="kt">True</span>  <span class="kt">True</span>  <span class="kt">True</span>
<span class="kr">instance</span> <span class="kt">Or</span> <span class="kt">True</span>  <span class="kt">False</span> <span class="kt">True</span>
<span class="kr">instance</span> <span class="kt">Or</span> <span class="kt">False</span> <span class="kt">True</span>  <span class="kt">True</span>
<span class="kr">instance</span> <span class="kt">Or</span> <span class="kt">False</span> <span class="kt">False</span> <span class="kt">False</span></code></pre></div><p>弗蕾雅女神[4]会很高兴的。一个代数系统降生到这个世界上是一件美妙的事情。</p><p>“我想我们也需要整数系统，来表达皇后的位置。”你喃喃地说，“我们只用得到正整数坐标，所以普通的皮亚诺构造应该足够了。” 你从头上拔下一根头发，打了一个首尾相连的结。零。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Z</span>
<span class="kr">data</span> <span class="kt">S</span> <span class="nf">n</span>

<span class="kr">type</span> <span class="kt">N0</span> <span class="ow">=</span> <span class="kt">Z</span>
<span class="kr">type</span> <span class="kt">N1</span> <span class="ow">=</span> <span class="kt">S</span> <span class="kt">N0</span>
<span class="kr">type</span> <span class="kt">N2</span> <span class="ow">=</span> <span class="kt">S</span> <span class="kt">N1</span>
<span class="kr">type</span> <span class="kt">N3</span> <span class="ow">=</span> <span class="kt">S</span> <span class="kt">N2</span>
<span class="kr">type</span> <span class="kt">N4</span> <span class="ow">=</span> <span class="kt">S</span> <span class="kt">N3</span>
<span class="kr">type</span> <span class="kt">N5</span> <span class="ow">=</span> <span class="kt">S</span> <span class="kt">N4</span>
<span class="kr">type</span> <span class="kt">N6</span> <span class="ow">=</span> <span class="kt">S</span> <span class="kt">N5</span>
<span class="kr">type</span> <span class="kt">N7</span> <span class="ow">=</span> <span class="kt">S</span> <span class="kt">N6</span>
<span class="kr">type</span> <span class="kt">N8</span> <span class="ow">=</span> <span class="kt">S</span> <span class="kt">N7</span></code></pre></div><p>“你在...手动定义自然数？为什么要这么做？“</p><p>“Haskell是给数学家设计的，”你解释道。“我们总是自己定义东西。”</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- Equality</span>
<span class="kr">class</span> <span class="kt">PeanoEqual</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">t</span> <span class="o">|</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">t</span>
<span class="kr">instance</span> <span class="kt">PeanoEqual</span> <span class="kt">Z</span>     <span class="kt">Z</span>     <span class="kt">True</span>
<span class="kr">instance</span> <span class="kt">PeanoEqual</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">a</span><span class="p">)</span> <span class="kt">Z</span>     <span class="kt">False</span>
<span class="kr">instance</span> <span class="kt">PeanoEqual</span> <span class="kt">Z</span>     <span class="p">(</span><span class="kt">S</span> <span class="nf">b</span><span class="p">)</span> <span class="kt">False</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">PeanoEqual</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">t</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">PeanoEqual</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">b</span><span class="p">)</span> <span class="nf">t</span>

<span class="c1">-- Comparison (&lt;)</span>
<span class="kr">class</span> <span class="kt">PeanoLT</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">t</span> <span class="o">|</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">t</span>
<span class="kr">instance</span> <span class="kt">PeanoLT</span> <span class="kt">Z</span>      <span class="kt">Z</span>     <span class="kt">False</span>
<span class="kr">instance</span> <span class="kt">PeanoLT</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">x</span><span class="p">)</span>  <span class="kt">Z</span>     <span class="kt">False</span>
<span class="kr">instance</span> <span class="kt">PeanoLT</span> <span class="kt">Z</span>      <span class="p">(</span><span class="kt">S</span> <span class="nf">x</span><span class="p">)</span> <span class="kt">True</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">PeanoLT</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">t</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">PeanoLT</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">b</span><span class="p">)</span> <span class="nf">t</span>

<span class="c1">-- Absolute difference</span>
<span class="kr">class</span> <span class="kt">PeanoAbsDiff</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">c</span> <span class="o">|</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">c</span>
<span class="kr">instance</span> <span class="kt">PeanoAbsDiff</span> <span class="kt">Z</span> <span class="kt">Z</span> <span class="kt">Z</span>
<span class="kr">instance</span> <span class="kt">PeanoAbsDiff</span> <span class="kt">Z</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">b</span><span class="p">)</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">b</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">PeanoAbsDiff</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">a</span><span class="p">)</span> <span class="kt">Z</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">a</span><span class="p">)</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">PeanoAbsDiff</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">c</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">PeanoAbsDiff</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">b</span><span class="p">)</span> <span class="nf">c</span>

<span class="c1">-- Integers from n to 0</span>
<span class="kr">class</span> <span class="kt">Range</span> <span class="nf">n</span> <span class="nf">xs</span> <span class="o">|</span> <span class="nf">n</span> <span class="ow">-&gt;</span> <span class="nf">xs</span>
<span class="kr">instance</span> <span class="kt">Range</span> <span class="kt">Z</span> <span class="kt">Nil</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Range</span> <span class="nf">n</span> <span class="nf">xs</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Range</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">n</span> <span class="nf">xs</span><span class="p">)</span></code></pre></div><p>“等等，停一下，”克里斯打断了我。“你不应该...这里不应该有类型声明吗？至少在我们的函数上？“。</p><p>你和蔼的微笑，”Haskell是一种<i>动态类型</i>的<i>解释型</i>语言。“</p><p>克里斯看起来好像活吞了一只青蛙。</p><p>“我给你演示一下，让我们检查一下一是否等于一。“</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">class</span> <span class="kt">LegalCompare</span> <span class="nf">t</span> <span class="o">|</span> <span class="ow">-&gt;</span> <span class="nf">t</span>
  <span class="kr">where</span> <span class="nf">legalCompare</span> <span class="ow">::</span> <span class="nf">t</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">PeanoEqual</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span> <span class="nf">t</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">LegalCompare</span> <span class="nf">t</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="nf">legalCompare</span>
<span class="nf">legalCompare</span> <span class="ow">::</span> <span class="kt">True</span></code></pre></div><p>“看见没？<code>legalCompare</code>就是<code>True</code>。现在让我们试着写一个执行无效比较的表达式。比如，将<code>True</code>和一个列表进行比较。“</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">class</span> <span class="kt">IllegalCompare</span> <span class="nf">t</span> <span class="o">|</span> <span class="ow">-&gt;</span> <span class="nf">t</span>
  <span class="kr">where</span> <span class="nf">illegalCompare</span> <span class="ow">::</span> <span class="nf">t</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">PeanoEqual</span> <span class="kt">True</span> <span class="p">(</span><span class="kt">Cons</span> <span class="kt">Z</span> <span class="kt">False</span><span class="p">)</span> <span class="nf">t</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">IllegalCompare</span> <span class="nf">t</span></code></pre></div><p>“看，你可以把它加载进去。只有当你试图对它求值时，它才会崩溃-记住，Haskell是惰性的。“</p><div class="highlight"><pre><code class="language-haskell"><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="nf">illegalCompare</span>
<span class="nf">illegalCompare</span> <span class="ow">::</span> <span class="kt">PeanoEqual</span> <span class="kt">True</span> <span class="p">(</span><span class="kt">Cons</span> <span class="kt">Z</span> <span class="kt">False</span><span class="p">)</span> <span class="nf">t</span> <span class="ow">=&gt;</span> <span class="nf">t</span></code></pre></div><p>“跑一下试试。看！一个运行时类型错误。“。</p><p>“这哪里报错了吗...”</p><p>“嗯，你知道的。Haskell的错误消息是出了名的难以理解。”</p><p>克里斯看起来很难受。你抓住这个机会继续开始实现高阶函数。</p><p>“不幸的是，Haskell<i>没有柯里化</i>，所以我们不得不自己整一个实现partial function的机制。这是通用的单参数函数调用的签名。“</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">class</span> <span class="kt">Apply</span> <span class="nf">f</span> <span class="nf">a</span> <span class="nf">r</span> <span class="o">|</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">r</span></code></pre></div><p>“这只是一个接受输入a并返回r的函数f。”<br/> 这些变量有着可爱的如歌般的旋律。<br/> “对于partial function，我们可以定义像<code>Partial1</code>、<code>Partial2</code>之类的数据类型，但由于我们只需要其中的几个，所以直接定义我们需要的那些函数的显式柯里化版本会更容易。像这样。“</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Conj1</span> <span class="nf">list</span>
<span class="kr">instance</span> <span class="kt">Apply</span> <span class="p">(</span><span class="kt">Conj1</span> <span class="nf">list</span><span class="p">)</span> <span class="nf">x</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">x</span> <span class="nf">list</span><span class="p">)</span></code></pre></div><p>你深吸了一口气，准备将你的精神体从这些具体的形式中解脱出来，提升到高阶函数的层面。</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- Map f over a list</span>
<span class="kr">class</span> <span class="kt">Map</span> <span class="nf">f</span> <span class="nf">xs</span> <span class="nf">ys</span> <span class="o">|</span> <span class="nf">f</span> <span class="nf">xs</span> <span class="ow">-&gt;</span> <span class="nf">ys</span>
<span class="kr">instance</span> <span class="kt">Map</span> <span class="nf">f</span> <span class="kt">Nil</span> <span class="kt">Nil</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nf">f</span> <span class="nf">x</span> <span class="nf">y</span><span class="p">,</span> <span class="kt">Map</span> <span class="nf">f</span> <span class="nf">xs</span> <span class="nf">ys</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Map</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">x</span> <span class="nf">xs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">y</span> <span class="nf">ys</span><span class="p">)</span>

<span class="c1">-- Map f over list and concatenate results together</span>
<span class="kr">class</span> <span class="kt">MapCat</span> <span class="nf">f</span> <span class="nf">xs</span> <span class="nf">zs</span> <span class="o">|</span> <span class="nf">f</span> <span class="nf">xs</span> <span class="ow">-&gt;</span> <span class="nf">zs</span>
<span class="kr">instance</span> <span class="kt">MapCat</span> <span class="nf">f</span> <span class="kt">Nil</span> <span class="kt">Nil</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Map</span> <span class="nf">f</span> <span class="nf">xs</span> <span class="nf">chunks</span><span class="p">,</span> <span class="kt">ListConcatAll</span> <span class="nf">chunks</span> <span class="nf">ys</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">MapCat</span> <span class="nf">f</span> <span class="nf">xs</span> <span class="nf">ys</span>

<span class="c1">-- Filter a list with an Apply-able predicate function</span>
<span class="kr">class</span> <span class="kt">AppendIf</span> <span class="nf">pred</span> <span class="nf">x</span> <span class="nf">ys</span> <span class="nf">zs</span> <span class="o">|</span> <span class="nf">pred</span> <span class="nf">x</span> <span class="nf">ys</span> <span class="ow">-&gt;</span> <span class="nf">zs</span>
<span class="kr">instance</span> <span class="kt">AppendIf</span> <span class="kt">True</span> <span class="nf">x</span> <span class="nf">ys</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">x</span> <span class="nf">ys</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">AppendIf</span> <span class="kt">False</span> <span class="nf">x</span> <span class="nf">ys</span> <span class="nf">ys</span>

<span class="kr">class</span> <span class="kt">Filter</span> <span class="nf">f</span> <span class="nf">xs</span> <span class="nf">ys</span> <span class="o">|</span> <span class="nf">f</span> <span class="nf">xs</span> <span class="ow">-&gt;</span> <span class="nf">ys</span>
<span class="kr">instance</span> <span class="kt">Filter</span> <span class="nf">f</span> <span class="kt">Nil</span> <span class="kt">Nil</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nf">f</span> <span class="nf">x</span> <span class="nf">t</span><span class="p">,</span>
          <span class="kt">Filter</span> <span class="nf">f</span> <span class="nf">xs</span> <span class="nf">ys</span><span class="p">,</span>
          <span class="kt">AppendIf</span> <span class="nf">t</span> <span class="nf">x</span> <span class="nf">ys</span> <span class="nf">zs</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Filter</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">x</span> <span class="nf">xs</span><span class="p">)</span> <span class="nf">zs</span></code></pre></div><p>先暂时回到具体值的世界一小会。克里斯还在这里，至少物理上还在这里。由于抽象世界的深沉寒冷，你的笔记本电脑屏幕已经变成了华丽的不同紫色色块(指关键字高亮)的混合，但代码依然隐约可见。它让你想起黄昏时结冰的湖。<br/> 液态的结晶。</p><p>“克里斯。克里斯。“他快速眨着眼睛，好像刚从黑暗中走出来。好漂亮的眼睛。你想起了你的双眼仍然有颜色的时候。“我们准备好了”</p><p>“是的...“。</p><p>“皇后是由她在棋盘上的两个坐标定义的：x和y。我们还将构建一个部分求值的构造函数，用于从给定的单独x坐标构造皇后。”</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Queen</span> <span class="nf">x</span> <span class="nf">y</span>
<span class="kr">data</span> <span class="kt">Queen1</span> <span class="nf">x</span>
<span class="kr">instance</span> <span class="kt">Apply</span> <span class="p">(</span><span class="kt">Queen1</span> <span class="nf">x</span><span class="p">)</span> <span class="nf">y</span> <span class="p">(</span><span class="kt">Queen</span> <span class="nf">x</span> <span class="nf">y</span><span class="p">)</span>

<span class="c1">-- A list of queens in row x with y from 0 to n.</span>
<span class="kr">class</span> <span class="kt">QueensInRow</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">queens</span> <span class="o">|</span> <span class="nf">n</span> <span class="nf">x</span> <span class="ow">-&gt;</span> <span class="nf">queens</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Range</span> <span class="nf">n</span> <span class="nf">ys</span><span class="p">,</span> <span class="kt">Map</span> <span class="p">(</span><span class="kt">Queen1</span> <span class="nf">x</span><span class="p">)</span> <span class="nf">ys</span> <span class="nf">queens</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">QueensInRow</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">queens</span></code></pre></div><p>“终于来了，皇后！”你喃喃自语。遗憾的是，这不是<i>那种</i>面试。</p><p>这些皇后可以朝八个方向侵攻。你一直以为那不过是个隐喻。</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- Does queen a threaten queen b?</span>
<span class="kr">class</span> <span class="kt">Threatens</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">t</span> <span class="o">|</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">t</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">PeanoEqual</span> <span class="nf">ax</span> <span class="nf">bx</span> <span class="nf">xeq</span><span class="p">,</span>
          <span class="kt">PeanoEqual</span> <span class="nf">ay</span> <span class="nf">by</span> <span class="nf">yeq</span><span class="p">,</span>
          <span class="kt">Or</span> <span class="nf">xeq</span> <span class="nf">yeq</span> <span class="nf">xyeq</span><span class="p">,</span>
          <span class="kt">PeanoAbsDiff</span> <span class="nf">ax</span> <span class="nf">bx</span> <span class="nf">dx</span><span class="p">,</span>
          <span class="kt">PeanoAbsDiff</span> <span class="nf">ay</span> <span class="nf">by</span> <span class="nf">dy</span><span class="p">,</span>
          <span class="kt">PeanoEqual</span> <span class="nf">dx</span> <span class="nf">dy</span> <span class="nf">deq</span><span class="p">,</span>
          <span class="kt">Or</span> <span class="nf">xyeq</span> <span class="nf">deq</span> <span class="nf">res</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Threatens</span> <span class="p">(</span><span class="kt">Queen</span> <span class="nf">ax</span> <span class="nf">ay</span><span class="p">)</span> <span class="p">(</span><span class="kt">Queen</span> <span class="nf">bx</span> <span class="nf">by</span><span class="p">)</span> <span class="nf">res</span>

<span class="c1">-- Partial application of Threatens</span>
<span class="kr">data</span> <span class="kt">Threatens1</span> <span class="nf">a</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Threatens</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">t</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Apply</span> <span class="p">(</span><span class="kt">Threatens1</span> <span class="nf">a</span><span class="p">)</span> <span class="nf">b</span> <span class="nf">t</span></code></pre></div><p>新的一名女皇进入棋盘，昂首阔步地走进了自己的位置。她警觉地看着她的对手们，小心地保持在安全距离。她能站在哪里？你设想了一堆宇宙-不同的世界，每个世界里皇后们都在不同的地方。</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- Is queen b compatible with all queen as?</span>
<span class="kr">class</span> <span class="kt">Safe</span> <span class="nf">config</span> <span class="nf">queen</span> <span class="nf">t</span> <span class="o">|</span> <span class="nf">config</span> <span class="nf">queen</span> <span class="ow">-&gt;</span> <span class="nf">t</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">(</span><span class="kt">Threatens1</span> <span class="nf">queen</span><span class="p">)</span> <span class="nf">config</span> <span class="nf">m1</span><span class="p">,</span>
          <span class="kt">AnyTrue</span> <span class="nf">m1</span> <span class="nf">t1</span><span class="p">,</span>
          <span class="kt">Not</span>     <span class="nf">t1</span> <span class="nf">t2</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Safe</span> <span class="nf">config</span> <span class="nf">queen</span> <span class="nf">t2</span>

<span class="kr">data</span> <span class="kt">Safe1</span> <span class="nf">config</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Safe</span> <span class="nf">config</span> <span class="nf">queen</span> <span class="nf">t</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Apply</span> <span class="p">(</span><span class="kt">Safe1</span> <span class="nf">config</span><span class="p">)</span> <span class="nf">queen</span> <span class="nf">t</span>

<span class="c1">-- Add a queen with the given x coordinate to a legal configuration, returning</span>
<span class="c1">-- a set of legal configurations.</span>
<span class="kr">class</span> <span class="kt">AddQueen</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">c</span> <span class="nf">cs</span> <span class="o">|</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">c</span> <span class="ow">-&gt;</span> <span class="nf">cs</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">QueensInRow</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">candidates</span><span class="p">,</span>
          <span class="kt">Filter</span> <span class="p">(</span><span class="kt">Safe1</span> <span class="nf">c</span><span class="p">)</span> <span class="nf">candidates</span> <span class="nf">filtered</span><span class="p">,</span>
          <span class="kt">Map</span> <span class="p">(</span><span class="kt">Conj1</span> <span class="nf">c</span><span class="p">)</span> <span class="nf">filtered</span> <span class="nf">cs</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">AddQueen</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">c</span> <span class="nf">cs</span>

<span class="kr">data</span> <span class="kt">AddQueen2</span> <span class="nf">n</span> <span class="nf">x</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">AddQueen</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">c</span> <span class="nf">cs</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Apply</span> <span class="p">(</span><span class="kt">AddQueen2</span> <span class="nf">n</span> <span class="nf">x</span><span class="p">)</span> <span class="nf">c</span> <span class="nf">cs</span>

<span class="c1">-- Add a queen at x to every configuration, returning a set of legal</span>
<span class="c1">-- configurations.</span>
<span class="kr">class</span> <span class="kt">AddQueenToAll</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="nf">cs&#39;</span> <span class="o">|</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="ow">-&gt;</span> <span class="nf">cs&#39;</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">MapCat</span> <span class="p">(</span><span class="kt">AddQueen2</span> <span class="nf">n</span> <span class="nf">x</span><span class="p">)</span> <span class="nf">cs</span> <span class="nf">cs&#39;</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">AddQueenToAll</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="nf">cs&#39;</span></code></pre></div><p>“现在，让万物归于正轨。”你悄声低语，然后将咒语循环给它自己，并用控制流之线将一切缝合。<br/> 每行一个皇后，在每个合法的位置，对于每个可能的布局。你可以想象在她们start-up公司官网上的“关于我们”页面会是什么样子。</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- Add queens recursively</span>
<span class="kr">class</span> <span class="kt">AddQueensIf</span> <span class="nf">pred</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="nf">cs&#39;</span> <span class="o">|</span> <span class="nf">pred</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="ow">-&gt;</span> <span class="nf">cs&#39;</span>
<span class="kr">instance</span> <span class="kt">AddQueensIf</span> <span class="kt">False</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="nf">cs</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">AddQueenToAll</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="nf">cs2</span><span class="p">,</span>
          <span class="kt">AddQueens</span> <span class="nf">n</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">x</span><span class="p">)</span> <span class="nf">cs2</span> <span class="nf">cs&#39;</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">AddQueensIf</span> <span class="kt">True</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="nf">cs&#39;</span>

<span class="kr">class</span> <span class="kt">AddQueens</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="nf">cs&#39;</span> <span class="o">|</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="ow">-&gt;</span> <span class="nf">cs&#39;</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">PeanoLT</span> <span class="nf">x</span> <span class="nf">n</span> <span class="nf">pred</span><span class="p">,</span>
          <span class="kt">AddQueensIf</span> <span class="nf">pred</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="nf">cs&#39;</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">AddQueens</span> <span class="nf">n</span> <span class="nf">x</span> <span class="nf">cs</span> <span class="nf">cs&#39;</span>

<span class="c1">-- Solve</span>
<span class="kr">class</span> <span class="kt">Solution</span> <span class="nf">n</span> <span class="nf">c</span> <span class="o">|</span> <span class="nf">n</span> <span class="ow">-&gt;</span> <span class="nf">c</span> <span class="kr">where</span>
  <span class="nf">solution</span> <span class="ow">::</span> <span class="nf">n</span> <span class="ow">-&gt;</span> <span class="nf">c</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">AddQueens</span> <span class="nf">n</span> <span class="kt">Z</span> <span class="p">(</span><span class="kt">Cons</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="nf">cs</span><span class="p">,</span>
          <span class="kt">First</span> <span class="nf">cs</span> <span class="nf">c</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Solution</span> <span class="nf">n</span> <span class="nf">c</span> <span class="kr">where</span> <span class="nf">solution</span> <span class="ow">=</span> <span class="nf">nil</span></code></pre></div><p>克里斯看起来已经适应了从荒古而来的遥远凝视。你轻轻地扶着他的肩膀。<br/> “嘘！”你低声说。“万事俱备，答案就在眼前。”</p><div class="highlight"><pre><code class="language-haskell"><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="nf">solution</span> <span class="p">(</span><span class="nf">nil</span> <span class="ow">::</span> <span class="kt">N6</span><span class="p">)</span>
<span class="nf">solution</span> <span class="p">(</span><span class="nf">nil</span> <span class="ow">::</span> <span class="kt">N6</span><span class="p">)</span>
  <span class="ow">::</span> <span class="kt">Cons</span> <span class="p">(</span><span class="kt">Queen</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)))))</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))</span>
       <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Queen</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))))</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))))</span>
          <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Queen</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)))</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))))))</span>
             <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Queen</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">))</span> <span class="kt">Z</span><span class="p">)</span>
                <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Queen</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)))</span>
                   <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Queen</span> <span class="kt">Z</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)))))</span>
                      <span class="kt">Nil</span><span class="p">)))))</span></code></pre></div><p>看！我们漂亮的标准输出格式就是<i>这样</i>对齐的，沿垂直轴创建了一条可爱的零线。<br/> “所以，皇后的位置在(5,1), (4,3), (3,5), (2,0), (1,2)和(0,4)。这样可以吗，克里斯？”</p><p>克里斯盯了你好一会。“你从来没有...你从来没有写过具体值。你...你应该知道类型系统只是用来<i>约束</i>值的，对吧？“</p><p>“不。”你实事求是地告诉他。“不，不是这样的。”</p><p>他向后靠在椅子上-你担心他可能会摔倒-然后将整张脸埋进了双手。<br/> 你，通过Seiðr魔术，已经清晰地看到了你的拒信，并且知道他将要在拒信上写些什么。</p><p>“我们会保持联系的。”</p><p><i>衷心感谢Patrick Thomson和Conrad Parker的Type Level Instant Insanity</i></p>