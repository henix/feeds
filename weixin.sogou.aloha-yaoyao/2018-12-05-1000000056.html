<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>白话 Docker：每位工程师都用得上的容器技术</title>
</head>
<body>
<p><a href="https://mp.weixin.qq.com/s?timestamp=1558694613&amp;src=3&amp;ver=1&amp;signature=2liRu-ibQc3n7b06iE9*g220SfDD3ydsGuJ0j19ZWUggh77PvAS5rDzu3qUEk27SGM5ToLknPbPU45xUQUV6UtN3e5B9*G7OGhL*YJjiy*oSfHeCY2P-FNnG4mY*mhg-HPcGTWw8N-frFwntr14eFhPlEbrCdOHRrCFqtcLzqvA=">原文</a></p>
<div id="js_top_ad_area" class="top_banner"></div><div class="rich_media_inner">

        
        
        <div id="page-content" class="rich_media_area_primary">
          <div class="rich_media_area_primary_inner">
                                    
                        

            <div id="img-content">

                
                <h2 class="rich_media_title" id="activity-name">
                    
                    
                    白话 Docker：每位工程师都用得上的容器技术

                                                                                </h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                            <span id="copyright_logo" class="rich_media_meta rich_media_meta_text meta_tag_text">原创：</span>
                                                            <span class="rich_media_meta rich_media_meta_text">
                                                <span id="js_author_name" class="rich_media_meta_link" data-rewardsn="" data-timestamp="" data-canreward="0">陆遥</span>
                                            </span>
                                        
                                       
                                                                    
                                        <span class="rich_media_meta rich_media_meta_nickname" id="profileBt">
                      <a href="javascript:void(0);" id="js_name">
                        了不起的陆茨比                      </a>
                      <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                          <div class="profile_inner">
                              <strong class="profile_nickname">了不起的陆茨比</strong>
                              <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                              <p class="profile_meta">
                              <label class="profile_meta_label">微信号</label>
                              <span class="profile_meta_value">aloha-yaoyao</span>
                              </p>

                              <p class="profile_meta">
                              <label class="profile_meta_label">功能介绍</label>
                              <span class="profile_meta_value">与你分享我所知道的一切</span>
                              </p>
                              
                          </div>
                          <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                              <i class="profile_arrow arrow_out"></i>
                              <i class="profile_arrow arrow_in"></i>
                          </span>
                      </div>
                    </span>


                    <em id="publish_time" class="rich_media_meta rich_media_meta_text"></em>





                </div>
                
                
                
                
                                                
                                                                
                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <h2 data-source-line="1" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.75em;font-weight: 600;line-height: 1.25;padding-bottom: 0.3em;border-bottom: 1px solid rgb(234, 236, 239);color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>导语</h2><p data-source-line="3" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'><span style="font-size: 15px;">以 Docker 为代表的容器技术发展到今天，已经在弹性部署和资源调度领域获得了广泛成熟的应用，接下来很可能呈两个趋势发展：</span><span style="box-sizing: border-box;font-weight: 600;font-size: 15px;color: rgb(217, 33, 66);">上升</span><span style="font-size: 15px;">和</span><span style="box-sizing: border-box;font-weight: 600;font-size: 15px;color: rgb(217, 33, 66);">下沉</span><span style="font-size: 15px;">。</span></p><p data-source-line="3" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'><span style="font-size: 15px;">借助容器、微服务和动态编排技术，将助力存量业务系统往云上迁移，未来的应用甚至基于云原生，应用架构的演化会逐步向云靠拢，称作“上升”；由于容器和微服务逐渐成为应用部署的共识标准，反过来会推动软件工程开发流程，影响到千千万万工程师的日常工作，体现在应用开发生命周期每个环节，是为“下沉”。在这两个趋势到来之时，我们要提前做好准备。</span></p><p data-source-line="5" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'><span style="font-size: 15px;">笔者在撰写本文时，参考了大量同行的优秀经验。由于 Docker 的资料在网络上已经相对丰富，所以决定以简要原理讲解+优秀文章导读的方式来组织本文。我们首先对容器技术做一个快速的了解，然后会列举应用领域的案例，配合笔者自己的解读，希望能为大家了解学习容器技术提供一个参考路径。文中同时提供了不少外文资源，也鼓励大家在精力时间允许的情况下去阅读优质英文原文。</span></p><p data-source-line="5" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'><span style="font-size: 15px;color: rgb(217, 33, 66);">由于微信公号文章不允许外链，你可以通过本文的【原文链接】访问到带完整链接版本的文章。</span></p><p data-source-line="5" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'><br></p><h2 data-source-line="9" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.75em;font-weight: 600;line-height: 1.25;padding-bottom: 0.3em;border-bottom: 1px solid rgb(234, 236, 239);color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>什么是容器</h2><h3 data-source-line="11" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.5em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>容器诞生的目的</h3><p data-source-line="13" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>容器是什么？在我看来，所有对资源隔离封装、独立运行的计算单元，都可以理解成容器。大到一个 OS、小到一个线程，由于都靠独占所需资源来完成计算任务，都是容器的一种形态。</p><p data-source-line="15" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>不过，为什么我们今天所讲的容器特指以 Docker 为代表的进程封装技术，而不是线程、普通进程、虚拟机或者 OS 呢？核心区别在于：容器包含了应用所需的最小完整运行时环境，OS 和其他基础环境的差异被底层的容器引擎抽象隔离，使得容器可以无差异地被调度运行。这是容器技术要解决的核心痛点，也正因为容器抓住了这个机会，能够迅速发展壮大。</p><p data-source-line="17" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>从下图中对比 Docker 容器（左）和普通虚拟机（右）架构，不同的 APP 在进程级别的独立 Docker 容器中运行，而 Docker 引擎运行在单一的 Host OS 上，相对于每个虚拟机运行单个 APP，节省了相当可观的资源。为什么以前我们要在虚拟机上做应用部署，主要目的是为了隔离不同 APP 之间的环境依赖。</p><p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.40866510538641687" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/kx4FsdHKWEszP8L1QI8twIUAseiczG36kj4EuISltegJChXDMOeicWvFOmnaMXL8jLic4mYnbiaSRIb9GfcVfgL4Pw/640?wx_fmt=png" data-type="png" data-w="854" style=""></p><p><br></p><p data-source-line="25" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>简而言之，容器认为现实世界的应用依赖太复杂，所以直接把应用和依赖“一次性打包发售”。但是不同于虚拟机，借助现代操作系统提供的底层技术支持，这种打包动作可以做到进程级别，也使得容器的构建和运行足够轻量级，让应用的分发和部署都变得更高效。而当近年来微服务技术大行其道，DevOps 之风越吹越盛，几门技术凑在一起，干柴遇上烈火，不火爆都不行。</p><p data-source-line="27" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>所以我们常说，哪里有痛点，哪里就有机会。骂的人越多，能做的事越大。每件新事物都有它的目的，我们抓住了它存在的目的，也就找到了学习和应用的切入点。</p><h3 data-source-line="29" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.5em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>为什么要使用容器</h3><p data-source-line="31" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>过去几年来，国内外的 IT 巨头陆续跟进容器技术，分别构建了自己的弹性部署和资源调度平台，AWS、阿里云这样的巨头甚至把容器包装成服务对外出售。卖得好不好我们不知道，但容器技术在稳步而坚定地重构着已有的运维技术体系，是不争的事实。除了在运维领域，容器也正在缓慢而深刻地影响着软件分发和开发的方式，与每一位工程师的日常工作息息相关。</p><p data-source-line="33" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>下图是国内某知名云厂商的 Container Service 容器产品框架，主要卖点集中在 DevOps 持续交付、基于高性能计算的机器学习、微服务和混合云架构。</p><p data-source-line="33" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'><br></p><p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5769230769230769" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/kx4FsdHKWEszP8L1QI8twIUAseiczG36klp8RHZdpmrwnAukPkqiaWYgwVdMEkWKiaCeP6uugmDp5T7ntpudhVib8w/640?wx_fmt=png" data-type="png" data-w="832" style=""></p><p style="text-align: center;"><br></p><p data-source-line="41" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>在过去，如果把部署运维过程看作软件开发流程中的末端黑盒，对容器技术的了解也许没有那么迫切。但是我的观点是，对于每一位工程师，现在正是了解容器的最佳时机：其技术体系已经趋于完善，工具也相对成熟稳定。如果能借助容器技术把自己的日常开发工作变得更高效，在现在云原生大势所趋的背景下，无疑能为自己的下个技术层次和职业生涯打下良好的基础。</p><p data-source-line="43" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>可以参考一下 Docker 的官宣：<span class="Apple-converted-space"> </span><span style="color: rgb(0, 128, 255);">Why Docker? Docker Containerization Unlocks the Potential for Dev and Ops</span></p><h3 data-source-line="45" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.5em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>Docker 的三个核心概念</h3><p data-source-line="47" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>上文我们了解到的容器是一个广义的概念，泛指容器相关的构建、运行和管理技术。从严格的狭义上来讲，容器是镜像的运行实例，镜像和容器的关系可以简单地类比为 OOP 中类和对象。我们按照应用需求把 APP 及运行时依赖构建成镜像，然后在宿主 OS 上以容器方式运行提供服务。除此之外，我们利用中心化仓库机制来存储、管理和分发镜像。所以，要理解 Docker 的工作机制，关键在于掌握下面三个概念及其后面的运作机制：</p><ul data-source-line="49" style="" class=" list-paddingleft-2"><li><p><span style="box-sizing: border-box;font-weight: 600;">镜像（Image）</span>：相当于一个 Linux root 文件系统，提供 APP 进程的可执行程序、运行所需环境依赖及启停钩子程序等模块（通过 dockerfile 描述），不包含与业务场景关联的数据，并利用联合文件系统实现现分层存储，让镜像本身的复用、定制变得更为容易。</p></li></ul><p><br></p><ul data-source-line="49" style="" class=" list-paddingleft-2"><li><p><span style="box-sizing: border-box;font-weight: 600;">容器（Container）</span>：容器的本质是进程，运行于属于自己的独立的命名空间，运行在镜像描述的文件系统环境里。容器存储层的生存周期和容器一样，容器进程停止后，容器本身生命也就结束了，所以，容器内的文件写入操作都应该使用数据卷（Volume）或绑定宿主 OS 目录，防止数据丢失。</p></li></ul><p><br></p><ul data-source-line="49" style="" class=" list-paddingleft-2"><li><p><span style="box-sizing: border-box;font-weight: 600;">仓库（Repository）</span>：一个集中的存储、分发镜像的服务，类似于 Linux 系统中的软件包管理系统，但是我们可以看出，容器仓库提供的是完整的可运行实体，相对于 Linux 的二进制软件包，减少了用户配置环境、处理依赖等众多繁杂事项，使得软件的分发变得高效简易。</p></li></ul><p><br></p><p data-source-line="53" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>掌握了这三个概念后，我们来看看 Docker 的生命周期：</p><p style="text-align: center;"><img class="" data-copyright="0" data-ratio="0.5093002657218778" data-s="300,640" src="https://mmbiz.qpic.cn/mmbiz_png/kx4FsdHKWEszP8L1QI8twIUAseiczG36k9XKokXqeKibpSRSVcAnVyleLVEjficGpLsYlnNs7bxOo5STgzQNvsg0A/640?wx_fmt=png" data-type="png" data-w="1129" style=""></p><p><br></p><p data-source-line="59" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>要管理好容器的生老病死，需要掌握比较多的运维命令；同样，要掌握构建分发镜像的最佳实践，也需要参阅大量的资料和亲自动手操作。我在这里不一一列举容器相关的命令，但是建议读者尽量理解并记忆上图中容器的生命周期状态机，通过每一条状态转换学习掌握对应的命令，可以达到较好的练习效果；也能为未来基于容器设计上层系统或开发流程时起到提纲挈领的作用。图片来源于<span class="Apple-converted-space"> </span><span style="color: rgb(0, 128, 255);">Docker Internals</span>，来自越南国际友人总结的 Docker 介绍文章。</p><p data-source-line="61" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>除了上面提到的核心概念，有几个 Docker 的基本组件也需要我们了解：</p><ul data-source-line="63" style="" class=" list-paddingleft-2"><li><p><span style="box-sizing: border-box;font-weight: 600;">Docker Daemon</span>：Docker 主进程，运行于宿主操作系统之上，处理各种服务请求。</p></li><li><p><span style="box-sizing: border-box;font-weight: 600;">Docker Client</span>：Docker 客户端，处理与 Docker Daemon 之间通信（C/S 架构）。</p></li><li><p><span style="box-sizing: border-box;font-weight: 600;">DockerFile</span>：Docker 容器构建文件，用来说明如何创建镜像和启动容器。</p></li></ul><p><br></p><p data-source-line="67" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>下面几份我认为质量还不错的教程，详细讲解了 Docker 的组成、原理和命令用法，对你完整学习 Docker 知识和的日常工作会有所帮助：</p><ul data-source-line="69" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">Docker Tutorial</span>，中文版翻译在<span class="Apple-converted-space"> </span>这里</p></li><li><p><span style="color: rgb(0, 128, 255);">Docker 命令大全</span>，用来速查很不错</p></li><li><p><span style="color: rgb(0, 128, 255);">Docker 技术入门与实战</span>，系统化的入门书籍</p></li><li><p><span style="color: rgb(0, 128, 255);">阮一峰的 Docker 入门教程</span>，如果不想看书看这个也可以的</p></li></ul><h3 data-source-line="74" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.5em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>容器的底层技术</h3><p data-source-line="76" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>Docker 底层主要基于三个已有的 Linux 核心技术构建：Namespace、CGroups 和 Union File System。如果你熟悉 Linux 系统，应该对这些技术不陌生。所以从某种意义上讲，Docker 的发扬光大，是对“旧瓶装新酒”式技术演进的最好注脚。我们来看看这三个核心技术主要解决哪些问题。</p><ul data-source-line="78" style="" class=" list-paddingleft-2"><li><p><span style="box-sizing: border-box;font-weight: 600;">Namespace</span>：用于内核级别的环境隔离，可以把 APP 进程“圈养”到一个虚拟的 OS 空间；在这个空间里，APP 进程看到的其他进程、网络与存储位置，以及用户列表等静态系统信息，都是独一无二的，保证了不同的 APP 进程互不干扰。Namespace 广泛应用于软件系统的模块隔离场景，在这里 Linux 帮我们从底层做了这件事，对上层应用来说是透明的。</p></li></ul><p><br></p><ul data-source-line="78" style="" class=" list-paddingleft-2"><li><p><span style="box-sizing: border-box;font-weight: 600;">CGroup</span>：用于资源限制，决定 APP 进程可以使用多少配额的 CPU、存储及网络带宽资源。类似于 Namespace，Linux 也提供了对上层应用透明的实现机制，我们可能通过简单的配置就能立即实现对当前进程所需资源的分配使用。如果你想在上手 Docker 前体验一把幕后的机制，建议你可以手动配置玩一玩。</p></li></ul><p><br></p><ul data-source-line="78" style="" class=" list-paddingleft-2"><li><p><span style="box-sizing: border-box;font-weight: 600;">Union File System</span>：虽然大家翻译成“联合文件系统”，但是在 Docker 应用的场景下，意译成“层次文件系统”似乎更贴切。我们在构建 Docker 镜像时，每条构建命令都会在原有的镜像基础上创建一个新层，以达到中间层镜像复用的目的。这个机制就是借助 Union File System 来实现的。你大概可以猜到了，要把镜像的构建工作做好不太容易，搞不好的情况下会浪费存储空间，这个我后面会提到。</p></li></ul><p><br></p><p data-source-line="82" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>如果你还想了解更多，建议阅读左耳朵耗子写的四篇文章：<br></p><ul data-source-line="84" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">DOCKER基础技术：LINUX NAMESPACE（上）</span></p></li><li><p><span style="color: rgb(0, 128, 255);">DOCKER基础技术：LINUX NAMESPACE（下）</span></p></li><li><p><span style="color: rgb(0, 128, 255);">DOCKER基础技术：LINUX CGROUP</span></p></li><li><p><span style="color: rgb(0, 128, 255);">DOCKER基础技术：AUFS</span></p></li></ul><p><br style='box-sizing: border-box;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'></p><h2 data-source-line="91" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.75em;font-weight: 600;line-height: 1.25;padding-bottom: 0.3em;border-bottom: 1px solid rgb(234, 236, 239);color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>如何使用容器</h2><h3 data-source-line="93" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.5em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>容器应用场景之一：软件分发</h3><h4 data-source-line="95" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.25em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>亲手分发你的第一个 Docker 应用</h4><p data-source-line="97" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>这是一个简单而又完整的 Docker 镜像制作教程，基于 Python 2.7 和<span class="Apple-converted-space"> </span>Flask<span class="Apple-converted-space"> </span>发布了一个 Hello World 应用 Web 程序。不同于普通的 Docker 教程，该教程从 Dockerfile 的编写开始，从无到有一步步地示范基于镜像分发软件的完整步骤。如果你不熟悉 Python 也没关系，相信你看完教程后很快就会触类旁通，总结出你现在所负责的系统的容器化方法。本教程是 Docker 官方出品，不会存在各种二手资料常见的环境差异问题，又红又专，可以放心食用。</p><ul data-source-line="99" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">Get started with Docker, Part 2: Containers</span></p></li></ul><h4 data-source-line="101" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.25em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>如何构建出一份好的 Docker Image</h4><p data-source-line="103" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>容器既然是在云上运行，就要按照云应用的思路来构建：轻量级、无状态、省空间。另外，Dockerfile 是给人看的，要写得清晰简洁。常见的准则有：</p><ul data-source-line="105" style="" class=" list-paddingleft-2"><li><p>容器应该是短暂无状态的</p></li><li><p>明确建立应用上下文</p></li><li><p>避免安装不必要的包</p></li><li><p>一个容器只专注做一件事情</p></li><li><p>使用多阶段构建以减少镜像大小</p></li><li><p>最小化镜像层数</p></li><li><p>使用 .dockerignore 文件</p></li><li><p>尝试使用构建缓存</p></li></ul><p><br></p><p data-source-line="114" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>完整说明请参考：</p><ul data-source-line="116" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">Dockerfile 最佳实践</span></p></li><li><p><span style="color: rgb(0, 128, 255);">Building Good Docker Images</span></p></li></ul><h4 data-source-line="119" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.25em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>富容器技术</h4><p data-source-line="121" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>富容器技术主要解决存量业务系统上云的问题。从技术角度而言，富容器帮助业务在单个容器镜像中除了业务应用本身之外，还打包更多业务所需的运维套件、系统服务等组件。富容器模式下的应用有能力在不改变任何业务或运维代码的情况下，取得和在物理机一样的运行效果。简单说来，除了把应用打包，富容器技术把运维组件也一起打包运行了。通过富容器技术打包的业务应用可以达到以下两个目的：</p><ul data-source-line="123" style="" class=" list-paddingleft-2"><li><p>容器镜像实现业务的快速交付</p></li><li><p>容器环境兼容企业原有运维体系</p></li></ul><p><br></p><p data-source-line="126" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>国内代表性的富容器技术是阿里巴巴的 PouchContainer，对于下了决心借助容器上云但又割舍不下一堆五花八门的运维套件的同学，有一定的参考价值。</p><ul data-source-line="128" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">PouchContainer - An Efficient Container Engine</span></p></li><li><p><span style="color: rgb(0, 128, 255);">深度解析 PouchContainer 的富容器技术</span></p></li></ul><p><br style='box-sizing: border-box;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'></p><h3 data-source-line="133" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.5em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>容器应用场景之二：软件开发</h3><h4 data-source-line="135" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.25em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>如何用 Docker Compose 设置开发环境</h4><p data-source-line="137" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>Docker Compose 是一个用来定义和运行复杂应用的 Docker 工具，可以从源码或利用 Python pip 工具安装。一个使用 Docker 容器构建的应用，通常由多个功能正交的容器组成。Docker Compose 通过解读用户定义的 docker-compose.yml 文件，来配置管理多个容器及容器间的关联依赖，并负责应用的启停。这里有一份不错的 Docker Compose 教程，建议在使用 Docker Compose 进行正儿八经的开发或上线应用之前通读学习：</p><ul data-source-line="139" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">Docker Compose 教程</span></p></li></ul><h4 data-source-line="141" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.25em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>写给 Java 程序员的官方 Docker 使用指南</h4><p data-source-line="143" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>如果你是一名 Java 程序员，这份资料一定要完整地了解一遍，不仅涵盖了环境配置、JDK 安装、容器化 Java 工程、IDE 调试等主题，也涉及 CI/CD 、监控报警和上云的生产环境实践。如果你打算从头开始就基于 Docker 进行 Java 应用或服务开发，照着这份指南去做就是了。</p><ul data-source-line="145" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">Docker for Java Developers</span></p></li></ul><h4 data-source-line="147" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.25em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>用 Docker 搭建开发环境的经验总结</h4><p data-source-line="149" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>从利用 Docker 搭建独立完整的开发环境而言，这篇文章写得很专业了，甚至总结出了八种 Docker 开发环境的构建模式：</p><ol data-source-line="151" style="" class=" list-paddingleft-2"><li><p>The Shared Base Container(s)：最基础的共享容器，安装开发、测试和运行应用的最小化运行时依赖</p></li><li><p>The Shared Volume Dev Container：除了运行依赖，存储依赖也用容器做了底层封装，方便代码同步等骚操作</p></li><li><p>The Dev Tools Container：开发工具专门放在单独的容器里，也是很专业了</p></li><li><p>The Test In A Different Environment containers：测试用的容器，保持环境干净</p></li><li><p>The Build Container：你猜？</p></li><li><p>The Installation Container：你猜？</p></li><li><p>The Default-Service-In-A-Box Containers：你猜？</p></li><li><p>The Infrastructure / Glue Containers：你猜？</p></li></ol><p><br></p><p data-source-line="160" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>整个搭建运作流程的具体做法是怎样的、在我们自己的开发环境里是不是也要这么专业复杂呢？看完这篇文章，相信你自己会有自己的答案：</p><ul data-source-line="162" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">Eight Docker Development Patterns</span></p></li></ul><p><br style='box-sizing: border-box;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'></p><h3 data-source-line="166" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.5em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>容器应用场景之三：弹性部署和资源调度</h3><p data-source-line="168" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>应用在容器化之后，就可以借助容器编排来实现弹性部署和资源调度。提起大规模容器编排技术，最出名的应属 Google 的<span class="Apple-converted-space"> </span><span style="color: rgb(0, 128, 255);">Kubernetes</span>（简称 K8S）、UC Berkeley 的<span class="Apple-converted-space"> </span><span style="color: rgb(0, 128, 255);">Mesos </span>和 Docker 自家的<span class="Apple-converted-space"> </span><span style="color: rgb(0, 128, 255);">Swarm</span>。按照业界的通常做法，业务应用部署优先采用 K8S，大数据类应用首选 Mesos，Swarm 虽然是 Docker 原厂出口，奈何功能稍逊一筹，败下阵来，其中 Docker 公司还因此和 Google 有过一段恩恩怨怨，在这里就不展开了。</p><p data-source-line="170" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>如果我们暂时没有基于容器编排的部署调度的实践经验也没关系，可以从下面几篇总结一窥门径：</p><ul data-source-line="172" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">美团点评容器平台HULK的调度系统</span>，本文的亮点是资源调度算法，考虑了超售、在线离线混布、业务实例打散等问题，对于实际设计有较好的参考价值。</p></li></ul><p><br></p><ul data-source-line="172" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">美团容器平台架构及容器技术实践</span>，继续对 HULK 系统进行深一步的讲解，涉及更多实际应用中的极端问题，是一份不错的避坑指南。</p></li></ul><p><br></p><ul data-source-line="172" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">Peloton: Uber’s Unified Resource Scheduler for Diverse Cluster Workloads</span>，Uber 的统一资源调度器介绍，兼容有状态任务、无状态任务、批处理任务和后台常驻任务的调度运行，调度单元基于 Docker 容器，调试框架采用 Mesos；文中披露了不少实现细节，继承了 Uber 技术博客高质量的优良传统。</p></li></ul><p><br></p><p data-source-line="176" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>对于咱们研发中心来说，容器化部署已经接入多个核心服务，并在全局资源调度和扩缩容方面表现出不俗的实力。感兴趣的同学可以联系李海洋同志作进一步的了解。</p><p><br style='box-sizing: border-box;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'></p><h3 data-source-line="180" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.5em;font-weight: 600;line-height: 1.25;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>容器应用场景之四：云原生</h3><p data-source-line="182" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>用云原生计算基金会（CNCF）的话来说，达到容器化封装、动态管理（编排/调度）和面向微服务三个标准的应用，可以称为云原生应用。从这个视角看来，我们现在开发的大多数微服务应用，在利用 Docker 进行容器化后，就能在云上畅行无阻了。</p><p data-source-line="182" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>我们常说90后是网络的原住民，没有见过拨号上网的和下线的场景；那从现在起，云原生的思潮会影响未来软件开发和部署的规范，即新应用在创建之时就要考虑在云上运行的种种要求。随着云原生认知的普及和工具链的完善，云原生将逐渐成为下一代应用开发生命周期的标准；CNCF 组织中各大 IT 巨头的加持，也清晰表明一种信号：越早拥抱云原生、建立起研发竞争力，获得的技术红利越多。</p><p data-source-line="184" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>要实现云原生，并不是把基础设施或者应用部署在云上就够了，系统的设计原则和实现技术都和传统应用不同。限于篇幅不在这里展开，大家可以参考下面的资料了解详情：</p><ul data-source-line="186" style="" class=" list-paddingleft-2"><li><p><span style="color: rgb(0, 128, 255);">Kubernetes 中文指南/云原生应用架构实践手册 </span>较完整地介绍了云原生技术栈的背景、方法和工具等方面话题</p></li><li><p><span style="color: rgb(0, 128, 255);">Running Cloud Native Applications on DigitalOcean Kubernetes</span><span class="Apple-converted-space"> </span>DigitalOcean 发布的云原生应用白皮书，详细描述了把单体应用分解成微服务、再利用 K8S 技术把微服务搬迁到云上的完整流程</p></li><li><p><span style="color: rgb(0, 128, 255);">Cloud Native Infrastructure</span><span class="Apple-converted-space"> </span>Patterns for Scalable Infrastructure and Applications in a Dynamic Environment</p></li><li><p><span style="color: rgb(0, 128, 255);">Cloud Native Java</span><span class="Apple-converted-space"> </span>Designing Resilient Systems with Spring Boot, Spring Cloud, and Cloud Foundry</p></li></ul><p><br style='box-sizing: border-box;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'></p><h2 data-source-line="193" style='box-sizing: border-box;margin-top: 24px;margin-bottom: 16px;font-size: 1.75em;font-weight: 600;line-height: 1.25;padding-bottom: 0.3em;border-bottom: 1px solid rgb(234, 236, 239);color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;white-space: normal;'>结束语</h2><p data-source-line="195" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>关于 Docker 的介绍就暂时告一段落了，希望能给你在探索 Docker 的道路上带来一点帮助，哪怕本文有一两处参考资料能让你有所获，也算起到抛砖引玉的作用了。尽管还存在镜像质量参差不齐、没有统一管控标准、使用门槛稍高等问题，但仍不能忽视 Docker 对未来软件开发的流程和方法的产生越来越大的影响。</p><p data-source-line="197" style='box-sizing: border-box;margin-bottom: 16px;color: rgb(36, 41, 46);font-family: -apple-system, BlinkMacSystemFont, 微软雅黑, "PingFang SC", Helvetica, Arial, "Hiragino Sans GB", "Microsoft YaHei", SimSun, 宋体, Heiti, 黑体, sans-serif;font-size: 14px;white-space: normal;'>Docker 带来的变化是一个虽缓慢但坚定的过程。从现在起，希望每位工程师积极去了解拥抱 Docker，为下一个十年做好准备。</p><p><br></p>
                </div>
                <script nonce="150661324" type="text/javascript">
                    var first_sceen__time = (+new Date());

                    if ("" == 1 && document.getElementById('js_content')) {
                        document.getElementById('js_content').addEventListener("selectstart",function(e){ e.preventDefault(); });
                    }

                    
                    (function(){
                        if (navigator.userAgent.indexOf("WindowsWechat") != -1){
                            var link = document.createElement('link');
                            var head = document.getElementsByTagName('head')[0];
                            link.rel = 'stylesheet';
                            link.type = 'text/css';
                            link.href = "//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg_new/winwx3ec991.css";
                            head.appendChild(link);
                        }
                    })();
                </script>

                
                <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display:none;"></div>
                
                
                <div class="read-more__area" id="js_more_read_area" style="display:none;">
                    
                </div>

                
                                <div class="reward_area tc reward_area_primary" id="js_reward_area" style="display:none;">
                    <div class="reward-avatar" style="display: none;" id="js_reward_avatar">
                        <img src="" alt="" id="js_reward_author_head">
                    </div>
                    
                                       
                                                <div class="reward-author" style="display: none;" id="js_reward_author">陆遥</div>
                                            
                                       

                                        <p>
                        <a class="reward_button" id="js_reward_link" href="##"><span id="js_reward_link_text">赞赏</span></a>
                    </p>
                    <div id="js_reward_inner" class="reward_area_inner" style="display:none;">
                        <p class="weui-loadmore weui-loadmore_line reward_user_tips" id="js_reward_total_parent">
                          <span class="weui-loadmore__tips"><a href="##" id="js_reward_total"></a> 人<span id="js_reward_total_text">赞赏</span></span>
                        </p>
                        
                        <div id="js_reward_list" class="reward_user_list"></div>
                    </div>
                </div>
                                <div class="reward_qrcode_area reward_area tc" id="js_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                                        <p class="reward_tips"></p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" id="js_reward_qrcode_img"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                                                
                
                            </div>
                                    
                        


                        
            <ul id="js_hotspot_area" class="article_extend_area"></ul>


            
                        <div class="rich_media_tool" id="js_toobar3">

                                            <a class="media_tool_meta meta_primary" id="js_view_source" href="##">阅读原文</a>
                                <div id="js_read_area3" class="media_tool_meta tips_global_primary meta_primary" style="display:none;">阅读 <span id="readNum3"></span></div>


                <span style="display:none;" class="media_tool_meta meta_extra meta_praise" id="like_old">
                    <i class="icon_praise_gray"></i><span class="praise_num" id="likeNum_old"></span>
                </span>

                <span style="display:none;" class="media_tool_meta meta_extra meta_like" id="like3">
                    <button class="like_btn" id="js_like_btn"> 
                      好看<span class="like_num" id="likeNum3"></span>
                    </button>
                </span>
                
                <div id="js_like_educate" style="display:none">
                    <div class="weui-mask"></div>
                    <div class="weui-dialog">
                    <div class="weui-dialog__hd"><strong class="weui-dialog__title">推荐到好看</strong></div>
                    <div class="weui-dialog__bd">
                        <img src="" alt="">
                        你的朋友可以在“发现-看一看里看到你认为好看的文章”                    </div>
                    <div class="weui-dialog__ft">
                        <a href="javascript:;" class="weui-dialog__btn weui-dialog__btn_primary" id="js_acknowledge">知道了</a>
                    </div>
                    </div>
                </div>
            </div>

            
            <div class="like_comment_wrp" id="js_a_like_comment" style="display: none;">
              <div class="like_comment_inner">
                <div class="like_comment_hd" style="display:none" id="js_like_title"></div>
                <div class="like_comment_bd">
                  <textarea class="like_comment_textarea weui-textarea" placeholder="写下你的想法" id="js_a_like_comment_text"></textarea>
                  <div style="display:none" id="like_a_comment_len_span"><span id="a_like_comment_len">0</span>/200</div>
                </div>
                <div class="like_comment_ft">
                  <span id="js_like_comment_msg" class="like_comment_msg" style="visibility:hidden">最多200字，当前共<span id="js_like_current_cnt"></span>字</span>
                  <button class="like_comment_btn" disabled id="js_a_like_confirm">发送</button>
                </div>
              </div>
            </div>

            <div id="js_like_toast" style="display: none;">
              <div class="weui-mask_transparent"></div>
              <div class="weui-toast">
                <i class="weui-icon-success-no-circle weui-icon_toast"></i>
                <p class="weui-toast__content" id="js_toast_msg">已发送</p>
              </div>
            </div>

            
            <div style="display: none;" id="js_b_comment_panel">
              <div class="like_comment_primary_wrp">
                <div class="like_comment_primary_inner">
                  <div class="like_comment_primary_hd">
                    <h4 class="like_comment_primary_title">
                      朋友将在看一看可见                    </h4>
                    <button id="js_b_like_confirm" class="like_comment_primary_btn">确定</button>
                  </div>
                  <div id="js_b_comment_text_first" class="like_comment_primary_bd">
                    <span class="tips_global_primary">
                      分享你的想法...                    </span>
                  </div>
                </div>
              </div>
              <div class="like_comment_primary_mask"></div>
            </div>

            <div style="display: none;" id="js_b_comment_final">
              <div class="like_comment_primary_wrp editing">
                <div class="like_comment_primary_inner">
                  <div class="like_comment_primary_hd">
                    <h4 class="like_comment_primary_title">
                      <button class="like_comment_primary_cancel" id="js_b_comment_cancel">取消</button>
                    </h4>
                    <span class="like_comment_msg">最多200字，当前共234字</span>
                    <button class="like_comment_primary_btn" id="js_b_comment_confirm">确定</button>
                  </div>
                  <div class="like_comment_primary_bd">
                    <textarea class="like_comment_textarea weui-textarea" placeholder="写下你的想法" id="js_b_comment_text_second"></textarea>
                  </div>
                </div>
              </div>
              <div class="like_comment_primary_mask"></div>
            </div>






                        <div class="rich_media_tool" id="js_sg_bar">

                                <a class="media_tool_meta meta_primary" href="https://note.youdao.com/share/?id=51dde102cff4b5b8ecd0ad6cca229619&amp;type=note#/" target="_blank">阅读原文</a>
                                
            </div>
                      </div>
        </div>

        <div class="rich_media_area_primary sougou" id="sg_tj" style="display:none"></div>


        
        <div class="rich_media_area_extra">
          <div class="rich_media_area_extra_inner">
              
              <div id="js_share_appmsg">
              </div>

              
                            <div class="mpda_bottom_container" id="js_bottom_ad_area"></div>
                            
              <div id="js_iframetest" style="display:none;"></div>
                            
                            
              <div class="rich_media_extra rich_media_extra_discuss" id="js_cmt_container" style="display:none">
                

                
                <div class="discuss_mod" id="js_friend_cmt_area" style="display:none">
                  
                  
                  
                </div>

                                <div class="discuss_mod" id="js_cmt_area" style="display:none">
                </div>
                              </div>
          </div>
        </div>

        
        <div id="js_pc_qr_code" class="qr_code_pc_outer" style="display:none;">
            <div class="qr_code_pc_inner">
                <div class="qr_code_pc">
                    <img id="js_pc_qr_code_img" class="qr_code_pc_img">
                    <p>微信扫一扫<br>关注该公众号</p>
                </div>
            </div>
        </div>
    </div>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
