<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>互联网项目里，如何以正确的姿势保存密码？</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20135083">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/59e6d04626ef2eabc2039afb3459bdfc_r.jpg" alt=""></div><p>现在做一个互联网项目，真的是越来越简单。第三方的服务商帮你打点各种各样项目那些离不开做起来又伤神的功能：发email，发sms，push notification，甚至搜索，个性化推荐这样的功能。有人说未来互联网会越来越却缺frontend engineer - backend engineer / devops / data scientist 的活越来越多被各种各样的SaaS和open source项目取代，一个原本复杂的中型项目如今慢慢只需要少量的BE和devops就能搞定，却很可能要N个FE负责各个平台（app developer也暂且算FE），做个项目，快成了PM和FE的二人转。</p><p>第三方的服务越来越多，意味着我们需要保存越来越多的第三方api key（典型的如各类access token），加上项目本身用到各个服务，如database，message queue，cache server，big data engine等的用于authentication的密码（即便这些服务部署在禁止外网连接的VPC但production你不好裸奔吧，好歹给黑客脱裤的时候制造点障碍啊），所以要保存的password还不少。很多team database server的root password干脆就是password，或者123456，自己是方便了，也养肥了乐开花的黑客们。</p><p>所以我们要以正确的态度对待各类密码。严肃认真地问问自己：这么多api key / password（咱们把certificate也算在password内）究竟怎么管理？</p><p>有team直接将其放在项目里，典型的像django/flask的setting.py文件，一打开，简直是密码集散地。这么干的小团队不在少数，有些甚至得意洋洋将一些软件开源出去，结果连自己那简陋的常用密码一起开源了，让人大开眼界（不要笑，我曾经使用github search API 搜出来一大票密码）。给大家看一个人畜无害的搜索结果吧：</p><p><img src="https://pic1.zhimg.com/dd8418f1b821b67a81dcb2476e639f9e_r.jpg" data-rawwidth="1305" data-rawheight="288">所以存在项目里绝对是个糟糕的选择。</p><p>成熟一些的team，使用chef/puppet/ansible来做配置管理和部署，密码放在加密的data bag里（如chef），进了一大步。但是，当application要使用数据库密码的时候，又需要data bag的密码来访问数据库密码，不少人为了方便，干脆所有encrypt data bag就使用一个或者若干个密码。于是这些密码又被暴露出来，正所谓前驱狼后迎虎。</p><p>痛定思痛，你一定会想：既然密码的管理是个大问题，有没有什么通用的服务来专门管理密码，像1password那样？</p><p>嗯，还真有这样的服务。大概几周前，我先后注意到了vault和keywhiz（vault作为竞品介绍时我知道的）。由于vault是用golang写的，github上的like比java写的keywhiz多些，同时它又是consul [1] 的东家hashicorp做的，基于对consul的信心，我便好好研究了一下vault。</p><p>Vault能帮你干这几件事：</p><ul><li><p>密码的安全存储。Vault把密码以加密的形式存储起来，黑客拿到了密文，也很难解密。这个是最基本的需求。</p></li><li><p>动态密码。一般我们创建一个db，会创建一个新的role和db关联，为此要创建密码。这样的密码越复杂越好，反正不需要人来记。Vault能够帮你动态生成这些密码。更舒服的是，动态密码可以设置生存周期，过期后生成新密码，旧密码失效，进一步在密码泄漏出去后增加了安全性。</p></li><li><p>on-the-fly加解密。既然都做了密码相关的事情，Vault顺带着又提供了加解密的API。类似于信用卡资料这种极度敏感的信息都可以使用其加密存储。而使用的时候可以在内存中直接完成解密，用完销毁，尽可能少地暴露敏感信息。</p></li><li><p>Audit log。由于集中管理密码，Vault能记录任何访问密码的行为供日后审核。这是个非常重要的功能，否则密码遭到误用滥用或者被黑客使用，你都还蒙在谷里呢。</p></li></ul><p>为了做这些事情，Vault设计了很复杂的结构：</p><p><img src="https://pic2.zhimg.com/62d1c16a44af3de461ebaead836a1474_r.jpg" data-rawwidth="751" data-rawheight="391">我们先看看它的一些概念：</p><ul><li><p>Storage backend：顾名思义，存储后段。Vault允许你把密码存储在内存（dev），磁盘，aws等等地方。</p></li><li><p>Barrier：这就像一道防火墙，将受信区域和非受信区域隔离开（HTTP API和storage就属于非受信区），过barrier必须先unseal，unseal的概念先放在一边。</p></li><li><p>Policy：相当于access list，定义了密码在什么情况下允许什么样的操作。</p></li><li><p>Secret backend：application获取密码的时候究竟是怎么获取，一般是把原密码直接返回，用户也可以通过policy设置，每次返回自动生成的密码；或者，使用aws的IAM。</p></li><li><p>Authentication/Credential backend：用什么方式来认证application。最基本的是用户名和密码。Vault集成了一些第三方的auth server，比如github。</p></li><li><p>Audit backend：处理audit log。audit log可以写到不同的provider里。</p></li><li><p>Token：Vault提供给application的，用于访问整个系统的标识。application通过token获取权限，进而能够通过Vault赋予的权限进行读写操作。</p></li></ul><p>还是挺复杂的一个系统，不过做的非常灵活，各个backend都可以自由组合。如果Vault已有的backend不满足需求，还能自己撰写（没试过）。</p><p>是不是有点懵懵懂懂的？没关系，你就把Vault当成一个上了锁的藏宝箱就好。现在新的问题来了：打开这个藏宝箱，总还是要钥匙的吧？这把钥匙怎么存储？怎么使用？</p><p>用过1password的同学都知道，这货把你的私房密码都藏在它身上，你想使用之前必须用一个叫master password的密码来解锁，才能访问你存储的密码。Vault也有这个概念。不过，1password的master password是存在你的脑子里的，你自己知道就好，毋须存在什么地方；Vault的master password是给Vault启动时unseal使用的，如果存在一台机器里，岂不是得到了master password就破解了Vault辛辛苦苦设下的barrier？</p><p>所以Vault得把自己弄得更强壮一些。了解密码学的人都知道，有个算法能将一份密码拆解成N份，只要能提供其中K份，就可以还原密码。对，就是 Shamir’s Secret Sharing [2]，Vault就使用这个算法。当其第一次初始化时，会生成master key，分成5份，凑齐任意3份，就可以打开（unseal）这个藏宝箱。部署时，这5份key可以分别放在5台机器上，这样即便一台被compromise，也没有master key泄漏的威胁。</p><img src="https://pic3.zhimg.com/7c12e0dc3a933480e469c7036f933c6d_r.jpg" data-rawwidth="510" data-rawheight="312"><p>Vault启动时，凑好master key后，会解密storage里的数据，解密出来的内容放在内存里。Vault自己的配置信息，policy等也都被加载。这时，application可以通过http API访问密码信息。</p><p>接下来就是application如何访问Vault的问题了：application必须以某种方式来通过authentication backend的验证。这个验证可以是密码（OMG，用密码保护密码，死循环了，不推荐），公钥私钥，通过MAC地址生成的密钥，通过TPM（Trust Platform Module）生成的密钥等等。这个环节是最薄弱的环节，因为通信的两端：application和Vault都要互相取信于对方。Vault作为服务端，是中心节点，可以通过证书来证明自己的身份，application是客户端，可能基数庞大，又是动态建立和消亡，所以麻烦一些。application的认证通过，会获得有时间限制的session token，以此来进行后续访问。</p><p>总结一下，Vault通过这些手段来尽可能保护application可能用到的密码：</p><ul><li><p>任何重要信息，持久化时都以密文存在</p></li><li><p>拆解成N份的master key，只有K份凑齐，才能通过barrier unseal，密码的明文在内存中存在</p></li><li><p>application需要认证才能访问</p></li><li><p>application的权限由认证后的policy提供（这个policy是管理员配置的，application无权改动）</p></li><li><p>认证后通过session token在TLS信道里读取和写入密码</p></li></ul><p>如果你的系统各类密码很多，管理起来不方便，系统的安全性要求又高，可以考虑一下部署和使用Vault。</p><p>题图：银行的地下金库。对了，金库就叫Vault。</p><p>欢迎订阅公众号『程序人生』（搜索微信号 programmer_life）。每篇文章都力求原汁原味，北京时间中午12点左右，美西时间下午8点左右与您相会。</p><p>1. 一个service discovery tool</p><p>2. 见：<a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing" data-editable="true" data-title="Shamir's Secret Sharing">Shamir's Secret Sharing</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
