<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Coq中的Inductive简单学习分享</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/25096584">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-4ae331743540c3e8eb5dce093c7973b1_r.jpg" alt=""></div><p>作为一个初学者，下文中简要介绍Coq中最基本的一些知识，会包含一些主观的理解和认识，理解错误和不恰当的地方还希望大家见谅并指正_(:зゝ∠)_。</p><p>Coq是基于<a href="http://www4.di.uminho.pt/~mjf/pub/SFV-CIC-2up.pdf" data-title="CIC" class="" data-editable="true">CIC</a>（Calculus of Inductive Construction）实现的，因此Inductive是具有十分重要且核心的作用，深刻的理解Inductive对我们认识Coq的理论和实践都有十分重要的作用。</p><p>在Coq中Inductive是可以理解为公理般的存在，是之后进行形式化描述的基础与根源，它一般由三部分构成：归纳的类型名，归纳的类型和构造子。【详见<a href="https://coq.inria.fr/distrib/current/refman/" data-title="reference manual" class="" data-editable="true">reference manual</a> 1.3.3】<img src="https://pic3.zhimg.com/v2-e6c43b6e0d4adffe00a11906a3dec457_r.png" data-rawwidth="240" data-rawheight="105"></p><br>1）归纳的类型名称：顾名思义就是要新定义的这个类型名；<br><br>2）归纳的类型：Inductive的sort表示该datatype是什么类型，可以是Set/Type/Prop，也可以是返回类型Set/Type/Prop的函数类型（含参的），要注意的是无论是那一种返回类型都只能是基本类型Set, Prop和Type大类，原因的话目前个人理解是因为正如前文所提到的，Inductive是作为公理存在，这三个大类也是所有类型的基石，除了这三个大类之外的其余类型均是基于此三个大类的基础构建起来的，返回类型必须是此三个大类Inductive是不是也就理所当然呢，如果不是，Inductive又如何能作为公理基石呢（没有看过Coq源码，纯个人理解orz）（而且一般而言作为约定用于programming的定义为Set大类，用于Proposition的定义为Prop大类，原文CPDT(<a href="http://adam.chlipala.net/cpdt/" data-editable="true" data-title="Certified Programming with Dependent Types" class="">Certified Programming with Dependent Types</a>)原文如下：“The convention goes like this: Set is the type of normal types used in programming, and the values of such types are programs. Prop is the type of logical propositions, and the values of such types are proofs.”）；<br><br>3）构造子（constructor）：熟悉ML或者Haskell的童鞋应该都对它不陌生，在Coq中顾名思义，其实就是我们新归纳的这个Inductive类型的基本属性或者说可以认为是Specification/Evidence，它（们）作为潜在的公理，并且最终的返回类型必须是归纳定义这个类型，原因后面再说。<br>constructor之间有两种关系：<br>第一种关系是彼此并列且在此Inductive中是非递归的，例如SF(<a href="http://www.cis.upenn.edu/~bcpierce/sf/" data-editable="true" data-title="Software Foundations">Software Foundations</a>)开篇就提到的（SF上下文没引入）：<img src="https://pic1.zhimg.com/v2-838c86cd61f01fe38a1e72391cb08349_r.png" data-rawwidth="258" data-rawheight="171">这种也通常被称为归纳的枚举类型，在Coq Art的第6章的6.1和6.2节也有详细的讲解，但是要注意的是不一定彼此并列就一定是零秩函数（在数理逻辑中constant也被称为零秩函数，因此在Coq中或者其他FP中这些常量都认为是一种特殊的函数），为什么不一定呢，大家可以自己想想。【其实因为Coq并不在意或者说<a href="https://en.wikipedia.org/wiki/Calculus_of_constructions" data-editable="true" data-title="CoC">CoC</a>(Calculus of constructions)也并不关心你有没有前置条件是什么样的前置条件，有前置条件的话只要能给出对应这个前置条件的公理或者已经证明了的定理即可，其它乱七八糟的并不关心，不知道讲清楚了没233_(:зゝ∠)_】。<br><br>第二种关系是递归关系（如果定义为Prop大类这种归纳类型也可被称为归纳谓词，见CPDT第4章），最经典的例子是自然数nat类型的定义，但是我个人更喜欢le类型的定义来作为例子，在Coq中，le是使用Inductive归纳的一个recursive type，所以在证明的时候使用constructor不断进行 recursive proof即可证明<img src="https://pic4.zhimg.com/v2-ed28c9bf4741f04eab8790cb4a1a6014_r.png" data-rawwidth="278" data-rawheight="61">以这个例子来说，小于等于是什么，不是一个功能，而是一条性质，是一个归纳定义的规则，所以对于性质我们要用定义性质的形式去描述而不能去把它定义为功能，当然为了可执行再定义一个le函数并证明le函数与le类型一致也是可以的。<p>认识这个Inductive我们主要从一下三个方面来认识，Inductive的参数，indexed parameter，以及recursive definition：</p><p>对于参数和indexed parameter其含义其实和Definition或者Fixpoint定义是类似的，如果只是为了使用那么只需要记住如果会用到具体的参数那么就定义为参数类型，如果是需要一个类型，但是具体对应的参数不定，那么就定义为indexed parameter。当然我们还要注意le_S中的forall的含义，这里的forall因为是作为已知公理中的forall，所以是general的，换句话说，它可以specify为任意的值，即只要实例化为一个满足这个prop的值即可用于证明，在le中是根据nat的递归定义会自动实例化，有的时候是不会自动实例化的，这种时候就需要我们手动去指定一个值（SF上的练习本来有个例子，但是找了半天没找到，忘记在哪里了orz）</p><p>最后是递归性：那么为什么可以递归起来呢，其实和递归函数是一个道理，只要有一个base构造子和以及与之相联系的递归步构造子，这个例子中le_n和le_S这两个分别就是base和递归步。</p><p>这种递归在证明中是如何运作的呢，我们不妨来看下面这个例子：<img src="https://pic3.zhimg.com/v2-8037a7a8cf2db51f7d8470932a45a026_r.png" data-rawwidth="927" data-rawheight="70">乍一看似乎没有任何前置条件可以使用，但是不能忘记了Inductive就是最基本的公理，因此对照le的定义可以看见1≤5符合le_S构造子规则，因此调用此规则，按照公理约定就会得到1≤4（因为le_S公理是forall m, n≤m -&gt; n≤S m，这里specify为n := 1，S m := 5，m := 4）<br><img src="https://pic2.zhimg.com/v2-27d5211aa30c4d861e22841b724a1747_r.png" data-rawwidth="920" data-rawheight="69">可以看见证明按照我们的预想进行，那么1≤4依然不可证，因为没有已经存在的常量公理存在，但是依然可以递归化简，不断地递归将会得到1≤1，这符合le_n构造子这个base，可以直接得证，这个例子也比较好的演示了如何构造构造再构造backward chaining的方式最终得到公理得证的过程。（当然可以直接eauto之类的直接证明，当我没说233）<br>（画外音：Record也是一种特殊的Inductive，<a href="https://github.com/math-comp/mcb/blob/master/docs/book.pdf" data-editable="true" data-title="MCB">MCB</a>（Mathematical Components Book）的第5章，Coq Art的6.1.3都有比较细的说明，有兴趣可以自己看看，(⊙v⊙)嗯~我偷懒了）<br><br>此外还有很基本的一点就是，在定义了一个Inductive类型之后我们会看见提示同时定义了XXX_ind，XXX_rect和XXX_rec，当我们使用Print XXX_ind和XXX_rect来看这个induction principle，以nat为例<img src="https://pic1.zhimg.com/v2-d2a87dc07add1ddd886d577918b4716d_r.png" data-rawwidth="769" data-rawheight="87"><img src="https://pic2.zhimg.com/v2-d9d4b716d8c8a4a44150fbb15fa34b80_r.png" data-rawwidth="799" data-rawheight="195">当然首先要补充一点关于curry-howard correspondenece的定义，它是联系程序与证明的桥梁，简单来说就是，function type~proposition，所以Inductive中的构造子也既是proposition又是abstract function， -&gt;既代表function type又代表logic implication，更加生动的讲解可以在SF的proofObject一章中找到。</p><br><img src="https://pic1.zhimg.com/v2-a0dd7b4e3b8e2340071367b09d48b5fd_r.png" data-rawwidth="245" data-rawheight="53"><p>所以Coq中的证明简单来说，其实就是构造出符合待证明的定理（也就是函数类型）的program，对Coq熟练的使用者可以直接使用proof script来定义一个可执行函数，这里自动生成的induction principle其实就是将此Inductive类型转换成对应的函数类型（或者说定理）并提供可执行函数（即对应的证明），并将此函数类型作为公理加入当前的上下文（context）中。从上图可以看见，每一个构造子都会生成一个对应的前提条件（如nat中的即对应P 0和 forall n, P n -&gt; P (S n)），同时这里也有助于理解为什么构造子的返回类型（看做抽象函数）的返回类型必须是此归纳类型，这是因为，要符合命题P的构造才能够对命题P进行证明，再说了，返回类型都和此归纳类型无关了，那为什么要定义这个构造子呢，这不是在自己没事找事吗。对吧。其相关的简介内容在SF的moreInduction这一章里面有十分详细的解释，在CPDT中的第三章也有详细的练习和解释。</p><p>接下来是一些经验分享：<br><br>1）我自己初学的时候曾有过这样的疑问，为什么Inductive定义的构造子可以直接在其它函数中使用，比如自然数nat类型的定义，其没有任何函数体或者实际的什么功能实现为什么就能代表自然数还能被当作自然数使用呢（总能想起初学时候的黑历史呢），这其实是一种思维方式的转变，在Coq中只要在CIC的理论框架下是拥有极高的自由度的，这里被Inductive形式定义的是某个类型的一系列规则，以自然数为例：无穷的自然数如何表达呢，用informal的话来说“从zero开始，依次递增1，即可表示自然数集”，用更加formal的judgment nat 来表示的话就形成了下面的递归定义【详见PFPL（Practical Foundations for Programming Languages，2nd）第2章2.1和2.2节】<img src="https://pic3.zhimg.com/v2-8532d7e87880dde60868ad953f56d7fa_r.png" data-rawwidth="511" data-rawheight="169">在Coq中，我们要做的就是将两个规则作为自然数类型的构造子进行表示即可，这样我们就在Coq中定义了自然数nat类型，任何符合这个归纳定义的类型都是nat类型<img src="https://pic3.zhimg.com/v2-3292e56b6ec665c6b8c014ba6cc9ae26_r.png" data-rawwidth="532" data-rawheight="25">我们可以用于这个规则去构造任意具体的value（这就是传统程序语言的不同，传统的lang是直接定义好了基本类型规则和对应的value，而这里是可以让我们自己去构造属于我们自己的基本类型规则并应用此规则去生成对应的value，初学时如果一下接受不了应该是没有意识到这其实是更基础的一层，是以前别人已经为我们提供了的一层）。<br>当然有好事者（比如我）肯定会想为什么要这样定呢，那我用其他名称类型来表示同样的规则是不是也代表nat或者不代表了呢，比如下图这样<img src="https://pic3.zhimg.com/v2-15c843e741122898f18370b1e0bd2147_r.png" data-rawwidth="585" data-rawheight="23">首先，这样定义或者其它任何个人喜欢的方式定义都是可以，但是这样定义是不符合我们的直觉和约定，符号和规则本身是没有任何意义的，其意义是我们为了形式表达与联系对于我们有意义的实物理论时所赋予的，如果没有符合直觉的联系，那么可读性和可理解性就极差（感觉还是没有讲清楚，但是大概就是这个意思吧，雾）。<br>此外，含义一致吗，只要采用的judgment没变，那么所代表的含义就一般不会改变，这一点不难理解，比如：我们可以叫魔理沙，沙沙，可爱沙沙，帅气沙沙，baka沙沙等等（乱入了一项划掉）但是无论名字怎么变其核心都是我们认识的这个人，只要精神活动未发生根本改变都是指代同一个人，但有为什么说一般不会呢，假如有一个类型和另一个类型递归模式一致，就像双胞胎虽然精神活动有不同但是极其类似，所以第一点的符合直觉的名称定义是可以避免这种混乱，不要纠结那些有的没的就好，<b>人本来就是唯心主义生物好伐</b>（逃。<br><br>2）对Inductive的结构和所代表的基本意思有了一定认识后还可以治好另一个毛病——傻傻分不清类型，以<a href="https://coq.inria.fr/distrib/8.4beta2/stdlib/Coq.Init.Logic.html#True" data-editable="true" data-title="True">True</a>，<a href="https://coq.inria.fr/distrib/8.4beta2/stdlib/Coq.Init.Datatypes.html#true" data-editable="true" data-title="true">true</a>，<a href="https://coq.inria.fr/distrib/8.4beta2/stdlib/Coq.Init.Logic.html#True" data-editable="true" data-title="False">False</a>，<a href="https://coq.inria.fr/distrib/8.4beta2/stdlib/Coq.Init.Datatypes.html#true" data-editable="true" data-title="false">false</a>为例，初学的时候应该有一部分童鞋和我一样傻傻分不清它们有什么区别，当分不清的时候就可以追本溯源看看其定义：</p><img src="https://pic4.zhimg.com/v2-d4f74db4a294dccf88dcd36c259f73f1_r.png" data-rawwidth="154" data-rawheight="58"><img src="https://pic1.zhimg.com/v2-9ecf0ac3c47ed6fbd8f4966b783bc808_r.png" data-rawwidth="165" data-rawheight="39"><img src="https://pic4.zhimg.com/v2-109a73bc2d4cbca3ee95a2145febe811_r.png" data-rawwidth="174" data-rawheight="21"><p>可以很清楚的看见它们的区别，True和False是定义的Inductive类型，而true和false只是Inductive类型bool的构造子（主要目的是为了可执行程序的设计方便），有兴趣的话还可以看看robert harper的boolean blindness（雾）。<br><br>3）最后要说的就是每个Inductive根据想要的属性来定义，并且每个人定义也肯定不同，因为每个人的知识储备，对问题的认识深度以及思考的方式都不尽相同，而Inductive定义的好坏也将直接决定后面所有相关定理的正确性，可证性以及可靠性等等，我最喜欢的例子是SF的Imp一章中的Exercise: 3 stars (no_whilesR)这个练习</p><p><img src="https://pic2.zhimg.com/v2-c115bb1b1726039ba80bc63b196db933_r.png" data-rawwidth="372" data-rawheight="238"><img src="https://pic4.zhimg.com/v2-0695de367094717c6ea1db52b07eca29_r.png" data-rawwidth="342" data-rawheight="62">在已经给出了具体fix函数，根据no_whiles来定义其Inductive judgement，初学的时候可能会纠结IFB和WHILE如何定义，对于IFB最容易混淆的地方应该是不知道是否需要对b : Bool进行规则定义（因为这一章的上面定义了一个tool lang对b有分析），而WHILE是永远不能成立的，又应该如何设定。</p><br>这里就需要从定义这个Inductive的目的来想：这里检查的是是否有WHILE，那么EN_IF不是WHILE成立的前提是什么呢，就是c1和c2也是非WHILE的，所以和b其实一点关系都没有<br><img src="https://pic4.zhimg.com/v2-0ec3e270818a45c7b962f231846eda6f_r.png" data-rawwidth="610" data-rawheight="86">EN_WHILE如何写呢，其实是因为是no while，所以只有False的时候no_whilesR才会成立<br><img src="https://pic3.zhimg.com/v2-82792de9b2382ee4805ef9e290254c91_r.png" data-rawwidth="531" data-rawheight="64">这个练习其实很清晰的解释了Inductive要视归纳和证明的目的而写，如果只是去仿照此章前面的smallstep的内容，这个练习将无法完成（当时坑了半天）。<br><p>暂时能想到的大概就是这么多，我对inductive的认识也比较浅第一次分享写得不太好，漏洞也应该很多，但是都是一些初学过程中的一些心得和经验，希望能在大家的学习过程中能有所帮助。如果可能的话后面会想分享下对Coq中的CoInductive和Dependent Type的认识。<br><br>最后谢谢沙沙<a href="https://www.zhihu.com/people/0251012c87c2d3f56ac34de7d71cdcbc" data-hash="0251012c87c2d3f56ac34de7d71cdcbc" class="member_mention" data-editable="true" data-title="@雾雨魔理沙" data-hovercard="p$b$0251012c87c2d3f56ac34de7d71cdcbc">@雾雨魔理沙</a>的支持，指导和审稿，让我完成了处女作，同时安利一下Coq群：372347110，总之最大且群主是帅气可爱的沙沙的就是了_(:зゝ∠)_，完结撒花</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
