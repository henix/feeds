<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>从根儿上干掉你：固件和物理攻击（下）——防御技术</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20393380">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/37f2f218be9467232a8cfc8cd9e6acb7_r.jpg" alt=""></div>这周开始的时候我留了个坑，固件和物理攻击这么凶，如何防御呢？Black Hat的演讲者们后面也介绍了一些防御技术。当然了，介绍的时候也没忘打广告，演讲者同时介绍了一下他们公司的研究内容。不过，我觉得这个研究内容还是挺不错的。好了，闲话少说，我们继续。<p>===============================</p><br><p>1 Boot Integrity Attack防御技术</p><p>Boot Integrity Attack的攻击原理本质上就是篡改启动程序，也就是Boot。设计针对任何攻击的防御技术前都需要先解决一个问题：自己的系统从本质上能否遭受这样的攻击呢？演讲者提供了一些开源或者闭源的工具，用于检测系统的BIOS是否可以允许被修改。注意，这里的允许与否指的是硬件层的。也就是说，硬件或者固件本身是否允许修改Boot。</p><p><img src="https://pic3.zhimg.com/d47658aaecce74f5aa9d348efdd9787e_r.jpg" data-rawwidth="1280" data-rawheight="720">这些工具比较多，也比较杂，我就不过多介绍了。链接已经在图中给出了，有兴趣的知友们可以了解一下。</p><p>如果Boot不允许被修改或者恶意篡改的话，皆大欢喜！但是如果允许呢？如果Boot本身可以锁定的话，这也不是一个很严重的问题。不过，锁定Boot并不是一个彻底的解决方案。由于这种锁定是软锁定（比如BIOS里面设置个密码什么的），攻击者终究是有方法解除的。比如对于PC来说，就有传说中的BIOS断电攻击法，直接让BIOS短路并且重置。如果重置的BIOS默认开启了允许修改的权限，那BIOS就能被恶意篡改了。从根本上如何抵御这种攻击呢？</p><p>——————————————</p><p>1.1 Verified Boot</p><p>第一种方法是一个特别常见的防御方法，叫做Verified Boot。</p><p><img src="https://pic3.zhimg.com/713e9812f4710885fa3dd997161d9aa1_r.jpg" data-rawwidth="1280" data-rawheight="720">这个机制的原理是，固件中本身被固化了一个只允许读取的、可以信任的模块。这个模块中固化一个公钥，私钥由用户或者硬件生产厂商保留。用户在写入启动程序的时候，需要用私钥对这个启动程序签名。同时，这个启动程序中也写入一个用户自定义的公钥。以此类推。</p><p>系统启动时所涉及到的所有模块，从可以信任的模块，到BIOS，到操作系统，再到具体硬件，按照启动流程，使用上一层的公钥进行签名的验证，验证通过后才允许启动。这样就构成了一个逐层验证的链表，从上到下依次进行验证。如果系统启动时涉及到的某个模块被恶意修改了，那么签名将无法验证通过，这就抵御了针对启动模块的恶意攻击。</p><br><p>——————————————</p><br><p>1.2 Trusted Execution Technology</p><p>在讲第二个防御方法前，需要补充个知识。上面提到了一个只允许读取的、可以信任的模块，这个模块一般来说叫做可信根。Verified Boot的可信根直接嵌入到了BIOS的内部。什么叫做可信呢？有的知友说，只要这个程序不是恶意的，就是可信的。根本上说，可信的定义是：</p><br><blockquote>一段程序，如果可以预估它的全部操作，这个程序就可认为是可信的。</blockquote><p>举个极端的例子。有个计算机病毒，中毒的用户完全获知源代码，了解了这个计算机病毒的全部运行原理，并了解中毒后的全部现象。那么这个计算机病毒是否是可信的呢？答案是肯定的，这个计算机病毒是可信的。</p><p>为什么这样定义？这样定义的意义是，既然已经知道这段程序的全部操作，全部原理，那么用户就可以根据需要任意地安装、卸载等等。既然程序可以被用户完全控制，就可以认为是可信的了。再举个极端的例子，恶意软件全家桶估计大家都中招过。对于恶意软件全家桶，用户虽然知道安装了软件，但是安装过程中修改了操作系统的哪些地方，如何修改的，安装了哪些程序，这些程序是否上传用户信息。这一大堆功能用户都不了解。因此，这类恶意软件就是不可信的。</p><p>但是，用户又不是计算机专家。况且，就算是计算机专家，估计也无法了解程序的全部功能。软件来说是的，硬件也是这样。Verified Boot的一个问题是，如果用户签字的启动程序本身就是恶意的，但是用户不知道，这技术也就瞎了。怎么办呢？专家们说了，干脆，我来帮你验证。你可以信任我，我来告诉你这个程序是不是可信的。第二个技术应用而生，就是Trusted Execution Technology（TXT）。</p><p>这个技术的原理是，在硬件上增加一个叫做Trusted Platform Module（可信平台模块）。用户通过这个模块，来对启动的硬件进行验证。这个模块中可以存储可以信任的启动程序特征（比如这个程序的哈希值什么的）。启动时，TPM扫描启动程序，计算哈希值等特征，和内部存有的特征对比，如果正确，则可以启动。这样做的好处是，用户不再需要为恶意的启动程序提心吊胆了，而是将信任交给TPM，让它来进行验证。坏处呢？显而易见，如果用户想自己添加启动程序的话，也需要找TPM提交一下。</p><p>总的来说，TXT这个组织有点像Apple Store，它来验证所有跟启动有关的程序，并把合法程序发布给用户。用户安装时，通过TXT验证。对于恶意程序，这个Apple Store不允许发布，用户也就不会安装了。</p><p>TXT技术的问题在于，毕竟TPM是安装到用户服务器上的，因此如果TPM本身有问题的话，没法对TPM进行及时更新等。实际上，TPM，包括TXT涉及到的软件协议栈，还是有安全隐患的。具体内容大家还是看视频吧… 不过，这些问题都是TPM 1.1的问题。现在，业界已经推出了第二代TPM标准，TPM 2.0。随着技术的不断完善，我相信在未来TPM可以作为抵御Boot Integrity Attack的有效手段。</p><img src="https://pic3.zhimg.com/643ad928671bea25e800156bd4ddc0f3_r.jpg" data-rawwidth="1280" data-rawheight="720"><br><p>===============================</p><p>2 Direct Memory Access Attack防御技术</p><p>DMA攻击的防御手段也有两大类。</p><p>第一类防御手段是从硬件着手，叫做IOMMU（I/O Memory Management Unit）。主内存的访问并不是直接访问，而是通过CPU中的IOMMU模块访问。IOMMA模块有点像网络中的防火墙。IOMMU会阻止越界访问内存信息。这样一来，插个USB设备什么的东西，只允许访问和这个USB设备有关的内存地址，不允许访问其它地址。这就可以有效抵御DMA了。</p><br><p>===============================</p><p>3 Physical Memory Extraction防御技术<br></p><p>IOMMU虽然好，但是只能抵御通过CPU访问内存的攻击行为。但是，正如上一篇专栏提到的，我可以冰冻内存啦，通过硬件直接把内存的内容拷下来什么的，从而绕过CPU对内存访问。也就是说，IOMMU无法抵御Physical Memory Extraction。解决这种攻击的最直接方法就是把内存加密了… 然而，内存读取时也得解密对吗？这个密钥存在哪里，解密程序又存在哪里呢？</p><p>Black Hat演讲者给出了这样几类技术，并总结了一个表格。</p><p><img src="https://pic4.zhimg.com/6183efc6f9b7fea37b4bbc15ddb0a7b5_r.jpg" data-rawwidth="1280" data-rawheight="720">表格最下面两列的方法是，我把密钥也放在内存里面，但是只有我知道放置的位置。攻击者如果把内存内容拷走，得花点时间分辨内存中哪里存了密钥。这个方法对于一些低端攻击者和比较懒的攻击者比较有效。其实有点像数据库的随机存储技术了。密钥随便放个随机的地方，你能找到算你厉害…</p><p>然而，这种方法毕竟不能解决所有的问题… Tresor技术是把密钥放在缓存器（Registers）里面，然后把能内存中能加密的地方都加密了。对于访问缓存器信息的内容，就只能暴露给攻击者。这确实能解决部分问题，然而，攻击者还是有方法从暴露的内存信息中得知密钥存放在了哪一个缓存器里面，从而想办法去攻击缓存器。</p><p>缓存器不行，还有什么方法呢？演讲者开的公司所做的工作就是，我们把密钥放在CPU的L3缓存区里面吧！L3缓存区本质上是个高速缓存区，可以更快地对数据进行读取和写入，用来提高CPU对内存的读取能力。以前缓存区都比较小。随着时代的发展，CPU越来越厉害，缓存区也越来越大。现在，L3缓存区能达到数M大小。这样，我们可以干脆在L3缓存区放个小的、固化的操作系统，这个操作系统就是加密、解密内存。CPU只把这个操作系统当Black Box（黑盒）使用，无法读取密钥，只能让它加密内存或者解密内存。这样一来，攻击者想攻击，只能把CPU和内存全都搬走，而不是仅拷贝内存信息了。不过，如何抵御搬CPU… 人为检查嘛，肉身搜索！</p><p>===============================</p><p>3 未来技术</p><p>未来技术方面，我就不详细说了。第一个结束叫做Software-Based Attestation。这个技术有点像TPM，但是是软件认证，真的是准备开个计算机的Apple Store。</p><p><img src="https://pic1.zhimg.com/1900d59be14fba1fbe441d9e65e02222_r.jpg" data-rawwidth="1280" data-rawheight="720">第二个技术叫做Enhanced Privacy ID。这个技术的本质是，在CPU固化一个密钥和一个身份。这个密钥和身份每个CPU独有一份。这样，所有的密码学操作所用的密钥啦，随机数啦，算法啦，都通过CPU的密钥和身份执行。这就有点像我们的IPv6了。每个人一个IP！</p><p><img src="https://pic2.zhimg.com/d689fa757515a26e1accf66ebb2f59bb_r.jpg" data-rawwidth="1280" data-rawheight="720">EPID技术的一种一个分支叫做Software Guard Extensions（SGX）。我想提醒的是，如果知友们想做硬件安全或者移动安全的话，SGX一定要看看，现在这可是热门哦！<img src="https://pic4.zhimg.com/a8236b22bf66973d5a40ca71ad93ae29_r.jpg" data-rawwidth="1280" data-rawheight="720"></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
