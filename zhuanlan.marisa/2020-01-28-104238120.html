<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>函数式的动态规划</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/104238120">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-9a78a9c6e24193617a4cadf4b6b59d41_b.jpg" alt=""></div><h2>函数式的动态规划</h2><p>动态规划是一类很常用的算法，在C/C++/Java中一般使用于数组进行记忆化。而函数式编程语言一般无法方便地操作数组这些依赖副作用的数据结构，函数式的记忆化便要另寻他法。</p><p>本文就是一个简单的笔记，用一些代码片段展示我所知的函数式动态规划的技巧。</p><h2>Course-of-Values Recursion</h2><p><i>Course-of-Values Recursion</i>是我认为最直观的一种技巧，就是将遍历过的结果当作返回值的一部分保留下来，在递归的时候可以取得运算过的值。</p><p>对于递归函数<code>f</code>，定义一个辅助的函数<code>bar</code></p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%5Coverline%7Bf%7D%28n%29+%3D+%5Bf%28n%29%2C+f%28n-1%29%2C...%2Cf%280%29%5D+%5Cend%7Balign%7D" alt="\begin{align} \overline{f}(n) = [f(n), f(n-1),...,f(0)] \end{align}" eeimg="1"/> </p><p>则原递归函数<code>f</code>可以用<code>bar</code>表示出来：</p><p><img src="https://www.zhihu.com/equation?tex=head%28%5Coverline%7Bf%7D%28n%29%29" alt="head(\overline{f}(n))" eeimg="1"/> </p><p><b>斐波那契数列：</b></p><div class="highlight"><pre><code class="language-haskell"><span class="nf">fibBar</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">fibBar</span> <span class="mi">0</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nf">fibBar</span> <span class="mi">1</span> <span class="ow">=</span> <span class="mi">1</span><span class="kt">:</span><span class="nf">fibBar</span> <span class="mi">0</span>
<span class="nf">fibBar</span> <span class="nf">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">course</span> <span class="ow">=</span> <span class="nf">fibBar</span> <span class="p">(</span><span class="nf">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="kr">in</span> <span class="c1">-- [fib(n-1)..fib(0)]</span>
           <span class="kr">let</span> <span class="nf">p</span>  <span class="ow">=</span> <span class="nf">course</span> <span class="o">!!</span> <span class="mi">0</span> <span class="kr">in</span> <span class="c1">-- fib(n-1)</span>
           <span class="kr">let</span> <span class="nf">pp</span> <span class="ow">=</span> <span class="nf">course</span> <span class="o">!!</span> <span class="mi">1</span> <span class="kr">in</span> <span class="c1">-- fib(n-2)</span>
           <span class="nf">p</span> <span class="o">+</span> <span class="nf">pp</span> <span class="kt">:</span> <span class="nf">course</span>

<span class="c1">-- &gt;&gt;&gt; fibBar 10</span>
<span class="c1">-- [55,34,21,13,8,5,3,2,1,1,0]</span>
<span class="c1">--</span></code></pre></div><p><b>Binary Partitions：</b></p><p>数的二次幂拆分方法有多少种，其状态转移方程为：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D++a_0+%26+%3D+1+%5C%5C+a_%7B2n%7D+%26+%3D+a_%7B2n+-+1%7D+%2B+a_%7Bn%7D+%5C%5C+a_%7Bn%7D+%26+%3D+a_%7Bn-1%7D++%5Cend%7Balign%7D+" alt="\begin{align}  a_0 &amp; = 1 \\ a_{2n} &amp; = a_{2n - 1} + a_{n} \\ a_{n} &amp; = a_{n-1}  \end{align} " eeimg="1"/> </p><p>则：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">bpBar</span> <span class="nf">n</span>
  <span class="o">|</span> <span class="nf">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="o">|</span> <span class="nf">even</span> <span class="nf">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">course</span> <span class="ow">=</span> <span class="nf">bpBar</span> <span class="p">(</span><span class="nf">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="kr">in</span>
             <span class="kr">let</span> <span class="nf">pred</span> <span class="ow">=</span> <span class="nf">course</span> <span class="o">!!</span> <span class="mi">0</span> <span class="kr">in</span>                 <span class="c1">-- bp (n-1)</span>
             <span class="kr">let</span> <span class="nf">half</span> <span class="ow">=</span> <span class="nf">course</span> <span class="o">!!</span> <span class="p">(</span><span class="nf">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="nf">n</span> <span class="p">`</span><span class="nf">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="kr">in</span> <span class="c1">-- bp (n/2)</span>
             <span class="nf">pred</span> <span class="o">+</span> <span class="nf">half</span> <span class="kt">:</span> <span class="nf">course</span>
  <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">course</span> <span class="ow">=</span> <span class="nf">bpBar</span> <span class="p">(</span><span class="nf">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="kr">in</span> <span class="nf">head</span> <span class="nf">course</span> <span class="kt">:</span> <span class="nf">course</span>

<span class="c1">-- &gt;&gt;&gt; bpBar 20</span>
<span class="c1">-- [60,46,46,36,36,26,26,20,20,14,14,10,10,6,6,4,4,2,2,1,1]</span>
<span class="c1">--</span></code></pre></div><p>但遗憾的是，其复杂度并不是<code>O(n)</code>，因为每次都会索引链表，这很糟糕。</p><p><b>0-1背包问题：</b></p><p>其状态转移方程为：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+Knapsack%280%2C+y%29+%26+%3D+0+%5C%5C+Knapsack%28i%2C+y%29+%26+%3D+Knapsack%28i-1%2C+y%29+%26+%5Ctext%7Bif%7D%5C+w_i+%5Cge+y+%5C%5C+Knapsack%28i%2C+y%29+%26+%3D+max%28Knapsack%28i-1%2C+y%29%2C+v_j+%2B+Knapsack%28i-1%2C+y-w_i%29%29+%26+%5Ctext%7Botherwise%7D+%5Cend%7Balign%7D" alt="\begin{align} Knapsack(0, y) &amp; = 0 \\ Knapsack(i, y) &amp; = Knapsack(i-1, y) &amp; \text{if}\ w_i \ge y \\ Knapsack(i, y) &amp; = max(Knapsack(i-1, y), v_j + Knapsack(i-1, y-w_i)) &amp; \text{otherwise} \end{align}" eeimg="1"/> </p><p>这里也需要将这个<code>n*W</code>状态空间塞到<code>course</code>里：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D%5Coverline%7BKnapsack%7D%28i%2C+y%29+%3D++%26%5BKnapsack%28i%2C+y%29%2C+Knapsack%28i%2C+y-1%29%2C...%2CKnapsack%28i%2C+0%29%2C%5C%5C+++%26Knapsack%28i-1%2C+capacity%29%2C...%2CKnapscak%280%2C+0%29%5D%5Cend%7Balign%7D" alt="\begin{align}\overline{Knapsack}(i, y) =  &amp;[Knapsack(i, y), Knapsack(i, y-1),...,Knapsack(i, 0),\\   &amp;Knapsack(i-1, capacity),...,Knapscak(0, 0)]\end{align}" eeimg="1"/> </p><p>则：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="kt">Weight</span> <span class="ow">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">Value</span> <span class="ow">=</span> <span class="kt">Double</span>
<span class="kr">type</span> <span class="kt">Items</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Weight</span><span class="p">,</span> <span class="kt">Value</span><span class="p">)]</span>

<span class="nf">knapsack</span> <span class="ow">::</span> <span class="kt">Items</span> <span class="ow">-&gt;</span> <span class="kt">Weight</span> <span class="ow">-&gt;</span> <span class="kt">Value</span>
<span class="nf">knapsack</span> <span class="nf">items</span> <span class="nf">capacity</span> <span class="ow">=</span> <span class="nf">head</span> <span class="o">$</span> <span class="nf">bar</span> <span class="nf">items</span> <span class="nf">capacity</span> <span class="kr">where</span>
    <span class="nf">bar</span> <span class="ow">::</span> <span class="kt">Items</span> <span class="ow">-&gt;</span> <span class="kt">Weight</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
    <span class="nf">bar</span> <span class="kt">[]</span>             <span class="mi">0</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nf">bar</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="nf">items</span><span class="p">)</span>      <span class="mi">0</span> <span class="ow">=</span> <span class="mi">0</span> <span class="kt">:</span> <span class="nf">bar</span> <span class="nf">items</span> <span class="nf">capacity</span>
    <span class="nf">bar</span> <span class="kt">[]</span>             <span class="nf">y</span> <span class="ow">=</span> <span class="mi">0</span> <span class="kt">:</span> <span class="nf">bar</span> <span class="kt">[]</span>    <span class="p">(</span><span class="nf">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="nf">bar</span> <span class="p">((</span><span class="nf">w</span><span class="p">,</span> <span class="nf">v</span><span class="p">)</span><span class="kt">:</span><span class="nf">items</span><span class="p">)</span> <span class="nf">y</span>
        <span class="o">|</span> <span class="nf">w</span> <span class="o">&lt;=</span> <span class="nf">y</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">course</span> <span class="ow">=</span> <span class="nf">bar</span> <span class="p">((</span><span class="nf">w</span><span class="p">,</span> <span class="nf">v</span><span class="p">)</span><span class="kt">:</span><span class="nf">items</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="kr">in</span>
                   <span class="kr">let</span> <span class="nf">v1</span>     <span class="ow">=</span> <span class="nf">course</span> <span class="o">!!</span> <span class="nf">capacity</span> <span class="kr">in</span>        <span class="c1">-- knapsack(i-1, y)</span>
                   <span class="kr">let</span> <span class="nf">v2</span>     <span class="ow">=</span> <span class="nf">course</span> <span class="o">!!</span> <span class="p">(</span><span class="nf">capacity</span> <span class="o">+</span> <span class="nf">w</span><span class="p">)</span> <span class="kr">in</span>  <span class="c1">-- knapsack(i-1, y-wi)</span>
                   <span class="kr">let</span> <span class="nf">new</span>    <span class="ow">=</span> <span class="nf">max</span> <span class="nf">v1</span> <span class="p">(</span><span class="nf">v2</span> <span class="o">+</span> <span class="nf">v</span><span class="p">)</span> <span class="kr">in</span>
                   <span class="nf">new</span> <span class="kt">:</span> <span class="nf">course</span>
        <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">course</span> <span class="ow">=</span> <span class="nf">bar</span> <span class="p">((</span><span class="nf">w</span><span class="p">,</span> <span class="nf">v</span><span class="p">)</span><span class="kt">:</span><span class="nf">items</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="kr">in</span> 
                      <span class="nf">course</span> <span class="o">!!</span> <span class="nf">capacity</span> <span class="kt">:</span> <span class="nf">course</span>


<span class="c1">-- &gt;&gt;&gt; knapsack [(2, 6.0), (2, 3.0), (6, 5.0), (5, 4.0), (4, 6.0)] 10</span>
<span class="c1">-- 15.0</span>
<span class="c1">--</span></code></pre></div><p>CoV除了经常要索引链表意外还有其它限制，并非所有的递归函数都能转化为这种形式，比如阿克曼函数（Ackermann&#39;s function）。</p><h2>Streaming</h2><p>这是专属于Haskell的优雅的方法。</p><p>斐波那契数列就是一个经典的例子：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">fibs</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>
<span class="nf">fibs</span> <span class="ow">=</span> <span class="mi">1</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span><span class="nf">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="nf">fibs</span> <span class="p">(</span><span class="nf">tail</span> <span class="nf">fibs</span><span class="p">)</span>

<span class="c1">-- &gt;&gt;&gt; take 10 fibs</span>
<span class="c1">-- [1,1,2,3,5,8,13,21,34,55]</span></code></pre></div><p>需要把<code>fibs</code>看作一个流，<code>fibs</code>前两个元素为<code>1</code>且剩余部分由其自身(<code>fibs</code>)与自身去首(<code>tail fibs</code>)合成(<code>zipWith (+)</code>)。取“下一个”的时候才会计算，并且不会重复计算，这就是Haskell惰性求值的威力。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-1675f7b414cad247defe6750650885e3_b.jpg" data-caption="" data-size="normal" data-rawwidth="938" data-rawheight="460" class="origin_image zh-lightbox-thumb" width="938" data-original="https://pic4.zhimg.com/v2-1675f7b414cad247defe6750650885e3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-1675f7b414cad247defe6750650885e3_b.jpg" data-caption="" data-size="normal" data-rawwidth="938" data-rawheight="460" class="origin_image zh-lightbox-thumb lazy" width="938" data-original="https://pic4.zhimg.com/v2-1675f7b414cad247defe6750650885e3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-1675f7b414cad247defe6750650885e3_b.jpg"/></figure><p>类似的，阶乘流由[1..]和其自身合成：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">facts</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>
<span class="nf">facts</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kt">:</span> <span class="nf">zipWith</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="nf">facts</span>

<span class="c1">-- &gt;&gt;&gt; take 10 facts</span>
<span class="c1">-- [1,1,2,6,24,120,720,5040,40320,362880]</span>
<span class="c1">--</span></code></pre></div><p>流还可以表达更复杂的问题，比如刚刚的Binary Partitions：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">bps</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>
<span class="nf">bps</span> <span class="ow">=</span> <span class="mi">1</span><span class="kt">:</span><span class="nf">zipWith3</span> <span class="nf">reduce</span> 
          <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> 
          <span class="nf">bps</span> 
          <span class="p">(</span><span class="nf">tail</span> <span class="o">$</span> <span class="nf">dup</span> <span class="nf">bps</span><span class="p">)</span> <span class="c1">-- bp (n/2) 组成的流</span>
  <span class="kr">where</span>
  <span class="nf">dup</span> <span class="nf">xs</span> <span class="ow">=</span> <span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="nf">\x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">x</span><span class="p">,</span> <span class="nf">x</span><span class="p">]</span> <span class="c1">-- 每个元素个数*2</span>

  <span class="nf">reduce</span> <span class="nf">n</span> <span class="nf">a</span> <span class="nf">b</span>
    <span class="o">|</span> <span class="nf">even</span> <span class="nf">n</span>    <span class="ow">=</span> <span class="nf">a</span> <span class="o">+</span> <span class="nf">b</span>
    <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="nf">a</span>

<span class="c1">-- &gt;&gt;&gt; take 21 bps</span>
<span class="c1">-- [1,1,2,2,4,4,6,6,10,10,14,14,20,20,26,26,36,36,46,46,60]</span>
<span class="c1">--</span></code></pre></div><p>可以发现顺序是和CoV的反过来的。同时，这里还没有了索引的开销，很<code>O(n)</code>，很棒。</p><p>流的形式很优美，当然也很少的情况能将流写的很优美，毕竟算法本身就是丑陋的，比如刚刚0-1背包问题换成什么写法都只能写得这样丑陋（但这已经是很简单的算法了）。</p><h2>Dynamorphism</h2><p><i>dynamorphism</i>是<i>recursion schemes</i>的一种，是<i>anamorphism</i>和<i>histomorphism</i>的组合，由<i>anamorphism</i>构造递归树，由<i>histomorphism</i>完成记忆化和规约。</p><p>过程上可以看作是CoV的抽象，自动完成<i>记忆化</i>和<i>递归</i>，并且推广了course的结构（但一般还是用List）。</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- dynamorphism</span>
<span class="nf">dyna</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="kt">Cofree</span> <span class="nf">f</span> <span class="nf">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">c</span><span class="p">)</span>  <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">c</span>
<span class="nf">dyna</span> <span class="nf">phi</span> <span class="nf">psi</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">x</span> <span class="kt">:&lt;</span> <span class="kr">_</span> <span class="ow">=</span>  <span class="nf">h</span> <span class="nf">a</span> <span class="kr">in</span> <span class="nf">x</span> <span class="kr">where</span>
  <span class="nf">h</span> <span class="ow">=</span> <span class="nf">uncurry</span> <span class="p">(</span><span class="kt">:&lt;</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">psi</span> <span class="nf">a</span><span class="p">,</span> <span class="nf">a</span><span class="p">))</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="nf">h</span> <span class="o">.</span> <span class="nf">phi</span>
<span class="c1">-- dyna phi psi = histo psi . ana phi</span></code></pre></div><p><b>Binary Partitions：</b></p><div class="highlight"><pre><code class="language-haskell"><span class="nf">bpDyna</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">bpDyna</span> <span class="ow">=</span> <span class="nf">dyna</span> <span class="nf">phi</span> <span class="nf">psi</span> <span class="kr">where</span>
  <span class="nf">phi</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Nil</span>
  <span class="nf">phi</span> <span class="nf">n</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="nf">n</span> <span class="p">(</span><span class="nf">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

  <span class="nf">psi</span> <span class="kt">Nil</span>             <span class="ow">=</span> <span class="mi">0</span>
  <span class="nf">psi</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">n</span> <span class="nf">course</span><span class="p">)</span> 
    <span class="o">|</span> <span class="nf">even</span> <span class="nf">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">pred</span> <span class="ow">=</span> <span class="nf">fromJust</span> <span class="o">$</span> <span class="nf">lookupCourse</span> <span class="nf">course</span> <span class="mi">0</span> <span class="kr">in</span>
               <span class="kr">let</span> <span class="nf">half</span> <span class="ow">=</span> <span class="nf">fromJust</span> <span class="o">$</span> <span class="nf">lookupCourse</span> <span class="nf">course</span> <span class="p">(</span><span class="nf">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="nf">n</span> <span class="p">`</span><span class="nf">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="kr">in</span>
               <span class="nf">pred</span> <span class="o">+</span> <span class="nf">half</span>
    <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="nf">fromJust</span> <span class="o">$</span> <span class="nf">lookupCourse</span> <span class="nf">course</span> <span class="mi">0</span>

<span class="nf">lookupCourse</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="nf">n</span><span class="p">,</span> <span class="kt">Eq</span> <span class="nf">n</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Cofree</span> <span class="p">(</span><span class="kt">ListF</span> <span class="nf">e</span><span class="p">)</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">n</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="nf">a</span>
<span class="nf">lookupCourse</span> <span class="p">(</span><span class="nf">x</span> <span class="kt">:&lt;</span> <span class="kr">_</span><span class="p">)</span>    <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="nf">x</span>
<span class="nf">lookupCourse</span> <span class="p">(</span><span class="kr">_</span> <span class="kt">:&lt;</span> <span class="nf">hole</span><span class="p">)</span> <span class="nf">n</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="nf">hole</span> <span class="kr">of</span>
    <span class="kt">Nil</span>         <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
    <span class="kt">Cons</span> <span class="kr">_</span> <span class="nf">next</span> <span class="ow">-&gt;</span> <span class="nf">lookupCourse</span> <span class="nf">next</span> <span class="p">(</span><span class="nf">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>


<span class="c1">-- &gt;&gt;&gt; map bpDyna [0..20]</span>
<span class="c1">-- [1,1,2,2,4,4,6,6,10,10,14,14,20,20,26,26,36,36,46,46,60]</span>
<span class="c1">--</span></code></pre></div><p><b>最长公共子序列：</b></p><p>也是一道经典的dp题，我也不再赘述内容，其状态转移方程为：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+lcs%28%5B%5D%2C+ys%29+%26+%3D+%5B%5D+%5C%5C+lcs%28xs%2C+%5B%5D%29+%26+%3D+%5B%5D+%5C%5C+lcs%28x%3Axs%2C+y%3Ays%29+%26+%3D+x%3Alcs%28xs%2C+ys%29+%26+%5Ctext%7Bif+%7D+x%3Dy+%5C%5C+lcs%28x%3Axs%2C+y%3Ays%29+%26+%3D+lcs%28x%3Axs%2C+ys%29+%26+%5Ctext%7Bif+%7D+%5C%23lcs%28x%3Axs%2C+ys%29+%5Cgt+%5C%23lcs%28xs%2C+y%3Ays%29+%5C%5C+lcs%28x%3Axs%2C+y%3Ays%29+%26+%3D+lcs%28xs%2C+y%3Ays%29+%26+%5Ctext%7Botherwise%7D+%5Cend%7Balign%7D" alt="\begin{align} lcs([], ys) &amp; = [] \\ lcs(xs, []) &amp; = [] \\ lcs(x:xs, y:ys) &amp; = x:lcs(xs, ys) &amp; \text{if } x=y \\ lcs(x:xs, y:ys) &amp; = lcs(x:xs, ys) &amp; \text{if } \#lcs(x:xs, ys) \gt \#lcs(xs, y:ys) \\ lcs(x:xs, y:ys) &amp; = lcs(xs, y:ys) &amp; \text{otherwise} \end{align}" eeimg="1"/> </p><div class="highlight"><pre><code class="language-haskell"><span class="nf">lcsDyna</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">lcsDyna</span> <span class="nf">as</span> <span class="nf">bs</span> <span class="ow">=</span> <span class="nf">dyna</span> <span class="nf">phi</span> <span class="nf">psi</span> <span class="p">(</span><span class="nf">as</span><span class="p">,</span> <span class="nf">bs</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">aslen</span> <span class="ow">=</span> <span class="nf">length</span> <span class="nf">as</span>

  <span class="nf">phi</span>     <span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>   <span class="ow">=</span> <span class="kt">Nil</span>
  <span class="nf">phi</span> <span class="nf">all</span><span class="o">@</span><span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="nf">y</span><span class="kt">:</span><span class="nf">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="nf">all</span> <span class="p">(</span><span class="nf">as</span><span class="p">,</span> <span class="nf">ys</span><span class="p">)</span>
  <span class="nf">phi</span> <span class="nf">all</span><span class="o">@</span><span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">,</span> <span class="nf">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="nf">all</span> <span class="p">(</span><span class="nf">xs</span><span class="p">,</span> <span class="nf">ys</span><span class="p">)</span>

  <span class="nf">psi</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">[]</span>
  <span class="nf">psi</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">[]</span>
  <span class="nf">psi</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">[]</span>
  <span class="nf">psi</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">,</span> <span class="nf">y</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="nf">course</span><span class="p">)</span>
    <span class="o">|</span> <span class="nf">x</span> <span class="o">==</span> <span class="nf">y</span> <span class="ow">=</span> <span class="nf">x</span> <span class="kt">:</span> <span class="nf">zs</span>
    <span class="o">|</span> <span class="nf">length</span> <span class="nf">xs</span> <span class="o">&gt;</span> <span class="nf">length</span> <span class="nf">ys</span> <span class="ow">=</span> <span class="nf">xs</span>
    <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span> <span class="nf">ys</span>
    <span class="kr">where</span>
      <span class="nf">xs</span> <span class="ow">=</span> <span class="nf">fromJust</span> <span class="o">$</span> <span class="nf">lookupCourse</span> <span class="nf">course</span> <span class="mi">0</span>
      <span class="nf">ys</span> <span class="ow">=</span> <span class="nf">fromJust</span> <span class="o">$</span> <span class="nf">lookupCourse</span> <span class="nf">course</span> <span class="nf">aslen</span>
      <span class="nf">zs</span> <span class="ow">=</span> <span class="nf">fromJust</span> <span class="p">(</span><span class="nf">lookupCourse</span> <span class="nf">course</span> <span class="p">(</span><span class="nf">aslen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span></code></pre></div><p><b>0-1背包问题</b></p><div class="highlight"><pre><code class="language-haskell"><span class="nf">knapsackDyna</span> <span class="ow">::</span> <span class="kt">Items</span> <span class="ow">-&gt;</span> <span class="kt">Weight</span> <span class="ow">-&gt;</span> <span class="kt">Value</span>
<span class="nf">knapsackDyna</span> <span class="nf">goods</span> <span class="nf">w</span> <span class="ow">=</span> <span class="nf">dyna</span> <span class="nf">phi</span> <span class="nf">psi</span> <span class="p">(</span><span class="nf">goods</span><span class="p">,</span> <span class="nf">w</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">phi</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>       <span class="ow">=</span> <span class="kt">Nil</span>
  <span class="nf">phi</span> <span class="p">(</span><span class="nf">wv</span><span class="kt">:</span><span class="nf">goods</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="p">(</span><span class="nf">wv</span><span class="kt">:</span><span class="nf">goods</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">goods</span><span class="p">,</span> <span class="nf">w</span><span class="p">)</span>
  <span class="nf">phi</span> <span class="p">(</span><span class="nf">goods</span><span class="p">,</span> <span class="nf">w</span><span class="p">)</span>    <span class="ow">=</span> <span class="kt">Cons</span> <span class="p">(</span><span class="nf">goods</span><span class="p">,</span> <span class="nf">w</span><span class="p">)</span> <span class="p">(</span><span class="nf">goods</span><span class="p">,</span> <span class="nf">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

  <span class="nf">psi</span> <span class="kt">Nil</span>              <span class="ow">=</span> <span class="mi">0</span>
  <span class="nf">psi</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">0</span>
  <span class="nf">psi</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">((</span><span class="nf">w&#39;</span><span class="p">,</span> <span class="nf">v&#39;</span><span class="p">)</span><span class="kt">:</span><span class="nf">goods&#39;</span><span class="p">,</span> <span class="nf">rest</span><span class="p">)</span> <span class="nf">course</span><span class="p">)</span> 
    <span class="o">|</span> <span class="nf">w&#39;</span> <span class="o">&gt;</span> <span class="nf">rest</span>  <span class="ow">=</span> <span class="nf">fromJust</span> <span class="o">$</span> <span class="nf">lookupCourse</span> <span class="nf">course</span> <span class="nf">w</span>  <span class="c1">-- course[i-1][w]</span>
    <span class="o">|</span> <span class="nf">otherwise</span> <span class="ow">=</span>
      <span class="kr">let</span> <span class="nf">v1</span> <span class="ow">=</span> <span class="nf">fromJust</span> <span class="o">$</span> <span class="nf">lookupCourse</span> <span class="nf">course</span> <span class="nf">w</span>      
          <span class="nf">v2</span> <span class="ow">=</span> <span class="nf">fromJust</span> <span class="o">$</span> <span class="nf">lookupCourse</span> <span class="nf">course</span> <span class="p">(</span><span class="nf">w&#39;</span> <span class="o">+</span> <span class="nf">w</span><span class="p">)</span> <span class="c1">-- course[i-1][w - w&#39;]</span>
      <span class="kr">in</span>  <span class="nf">max</span> <span class="nf">v1</span> <span class="p">(</span><span class="nf">v2</span> <span class="o">+</span> <span class="nf">v&#39;</span><span class="p">)</span>

<span class="c1">-- &gt;&gt;&gt; knapsackDyna [(2, 6.0), (2, 3.0), (6, 5.0), (5, 4.0), (4, 6.0)] 10</span>
<span class="c1">-- 15.0</span>
<span class="c1">--</span></code></pre></div><p>另外，这里的recursion schemes的库是直接在hackage里找的。懒得自己写了。dynamorphisim的介绍，我可能会令写一篇文章吧（咕咕咕）。其实我觉得这也没减少什么复杂度。。。</p><h2>总结</h2><p>没啥想总结的23333。总之，我觉得除了streaming以外，都很丑陋。recursion schemes也是，还是最多用到hylomorphism就算了，同时我认为应用将recursion schemes在“不是处理数据”的递归上，也不是正确的用途，因为这并不直观。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
