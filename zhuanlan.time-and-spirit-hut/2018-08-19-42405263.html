<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>「Rust每日新闻」本周精选 • 第七期</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/42405263">原文</a></p>
<blockquote>前言：<br>从2018年开始，我每天会花1个小时关注Rust社区动态，并且在<a href="https://link.zhihu.com/?target=http%3A//rust.cc">http://rust.cc</a>论坛、<a href="https://link.zhihu.com/?target=https%3A//t.me/rust_daily_news">tg channel</a>、GitHub都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。今天突然想到，在这个知乎专栏里，每周精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。<br><i>2018-08-19</i></blockquote><p><br></p><h2><b>官方新闻：</b></h2><p><b>RustConf 2018在波特兰盛大开幕</b></p><p><a href="http://rustconf.com/schedule.html">RustConf Schedule</a></p><p><br></p><p><b>Rust 2018 预览版2发布</b></p><p>此次预览版是alpha预览版，主要目的是用来测试和反馈，仅适用于Nightly Rust。</p><p>与上次预览版相比，有以下改进：</p><ul><li> cargo fix是cargo内置的了</li><li> 模块系统的更改已经分解为了几个独立的小特性，用于跟踪和反馈</li><li>  NLL已经默认可用，测试的时候注意，如果代码被NLL拒绝，但是旧的借用检查器可以通过，这种情况下NLL会报告错误。如果发现错误警告有问题，可以提交反馈。</li><li>  In-band生命周期分为两部分： impl头生命周期参数省略完整功能仍然存在，但是其他内容都已经从Rust 2018 features gates中移除，原因是反馈不一。</li></ul><p>这个里程碑的意义：</p><p>至此Rust 2018已经进入了最终的Release周期，结束是9.13号。在这个周期内，需要针对剩余的功能达成最终稳定的决策，仍然未完全确定的最后一个主要特征是模块系统的改进，尤其是精确path的那部分。</p><p>在这个周期结束后，会生成1.30 beta版本。到时候会再次高调发布。在这之后，还需要三个月的最终测试、反馈和润色。直到12月6号向全世界发布Rust 2018.</p><p><a href="https://internals.rust-lang.org/t/announcing-rust-2018-preview-2/8218">Announcing Rust 2018 Preview 2!</a> </p><p><br></p><p><b>嵌入式工作组报告第9期</b></p><ul><li> 嵌入式工作组转移到了新的仓库：[rust-embedded/wg](<a href="https://github.com/rust-embedded/wg">rust-embedded/wg</a>)， rust-embedded是新创建的组织</li><li>嵌入式工作组现在拥有18个人，6个小分队，分别专注于Cortex-M、HAL、MS430、RISCV、Resources和Tools领域。</li><li>也罗列了embedded-hal生态系统一些可用的库</li></ul><p>更多详细看文章</p><p>[原文](<a href="https://internals.rust-lang.org/t/the-embedded-working-group-newsletter-9/8185">The Embedded Working Group Newsletter - 9</a>) </p><p><br></p><p><b>Niko的博文：关于将Never Type引入match匹配的想法</b></p><p>Never类型就是(!)，将Nerver引入match匹配，比如有可能解决穷举匹配的问题</p><p><a href="http://smallcultfollowing.com/babysteps/blog/2018/08/13/never-patterns-exhaustive-matching-and-uninhabited-types-oh-my/">http://smallcultfollowing.com/babysteps/blog/2018/08/13/never-patterns-exhaustive-matching-and-uninhabited-types-oh-my/</a> </p><p><br></p><p><b>Futrues 0.3 - alpha 3发布</b></p><p>主要发布了 0.3和0.1的兼容层，现在可以在Tokio的executor上运行0.3 futures和async函数了</p><p><a href="https://rust-lang-nursery.github.io/futures-rs/blog/2018/08/15/futures-0.3.0-alpha.3.html">Futures 0.3.0-alpha.3</a> </p><p>toykio 集成futures 0.3的示例</p><p><a href="https://rust-lang-nursery.github.io/futures-rs/blog/2018/08/17/toykio.html">Fahrenheit</a></p><p><br></p><p><br></p><h2><b>社区新闻：</b></h2><p><b>小道消息： Leetcode目前正在开发Rust支持</b></p><p>上线以后我会第一时间通知大家</p><p><br></p><p><b>招聘：又有两家公司在招聘Rust</b></p><p>不过是国外的两家：OneSignal和HealPay</p><p><br></p><p><b>Rust几个版本的性能比较</b></p><p>性能在不断提升，越来越快</p><p><a href="http://chimper.org/rawloader-rustc-benchmarks/">http://chimper.org/rawloader-rustc-benchmarks/</a> </p><p><br></p><p><b>Rust 和Wasm 本周报告第6期</b></p><p>简要：</p><ul><li>正在为wasm添加SIMD 128位矢量类型的支持 </li><li>让Firefox的debbuger工具可以使用DWARF调试信息对Rust+Wasm的内联栈帧进行调试，WebAssembly官方成立了调试小组</li><li>wasm-bindgen 0.2.16发布</li><li>首次发布wasm-bindgen-futures，支持在Rust Futures和JavaScript Promises之间无缝切换。</li><li>在wasm book中增加了两章：「你应该知道的工具」以及「你应该知道的crate」</li><li>rustwasm组收到了新的RFC： 通过wasm-bindgen实现Rust的trait和Javascript的类继承的无缝切换。此功能在stdweb中已经被实现。</li></ul><p><a href="https://rustwasm.github.io/2018/08/14/this-week-in-rust-wasm-006.html">This Week in Rust and WebAssembly 006</a> </p><p><br></p><p><b>软件的安全是编程语言的问题</b></p><p>这是PL Enthusiast发表的一篇文章。之前马里兰大学开设了一门课程CMSC 330，这门课程中包含了Rust的基础教学。</p><p>PL Enthusiast由马里兰大学计算机科学教授Michael Hicks在College Park组织。</p><p>在CMSC 330课程中，课程的最后1/4，讲软件安全性的时候，同时讲Rust语言。</p><p>教授如是说：</p><blockquote>&gt; 我相信，如果我们要解决我们的安全问题，那么我们必须从一开始就牢记安全性。要做到这一点，所有程序员都需要了解安全性，而不仅仅是少数专家。各种语言（错误）功能和编程（反）模式都可以启用和阻止安全漏洞。因此，在编程（语言）课程中引入这些概念是有意义的，尤其是所有学生必须参加的课程。</blockquote><p>这篇文章分为三个部分：</p><ul><li>对安全性编程的需求</li><li>如何在330中介绍这个主题</li><li>对Rust的介绍。</li></ul><p>感兴趣的可以看详细的文章内容</p><p><a href="http://www.cs.umd.edu/class/spring2018/cmsc330/">CMSC 330, Spring 2018</a> </p><p><br></p><p><b>Tower Web 0.2 发布</b></p><p>上周 Tower Web才发布了0.1，其中使用了注释魔法来替代Rust的属性功能。</p><code lang="text">impl_web! {
    impl HelloWorld {
        /// @get("/")
        fn hello_world(&amp;self) -&gt; Result&lt;String, ()&gt; {
            Ok("Hello world".to_string())
        }
    }
}</code><p><br></p><p>比如上面的 `/// @get("/")`。 然后serde、syn、quote的作者dtolnay看不下去了，就给提交了一个PR，将文档注释魔法改成了 属性的写法</p><code lang="text">impl_web! {
    impl HelloWorld {
        #[get("/")]
        fn hello_world(&amp;self) -&gt; Result&lt;String, ()&gt; {
            Ok("Hello world".to_string())
        }
    }
}</code><p>于是Tower Web的作者就赶紧发布了0.2版本，就当0.1从来没有存在过一样。</p><p>文章作者还解释了他之前为什么要用文档注释魔法来替代属性。</p><p><a href="https://medium.com/@carllerche/tower-web-0-2-now-100-comment-attribute-free-3ed0633e47e5">https://medium.com/@carllerche/tower-web-0-2-now-100-comment-attribute-free-3ed0633e47e5</a></p><p>PR  <a href="https://github.com/carllerche/tower-web/pull/59/files">Attributes by dtolnay · Pull Request #59 · carllerche/tower-web</a> </p><p><br></p><p><b>介绍 routinator 3000</b></p><p>一个Rust实现的实验性的RPKI 依赖方（relying party ）软件。</p><p>由NLnet Labs出品，接下来的几个月，将开发一个旨在使BGP路由更安全的RPKI工具集。它将由三部分组成：证书颁发机构包，发布服务器和依赖方软件。选择使用现代系统编程语言Rust进行开发。</p><p><br></p><p>&gt;为了抵御日趋频繁和严重的互联网路由劫持事故，RPKI（互联网码号资源公钥基础设施）应运而生。它通过签发和认证一种特定格式的x.509数字证书和数字签名，帮助路由器检验BGP消息的真实性，从而增强BGP协议的安全，帮助避免互联网路由劫持。本期我们将详细介绍RPKI的原理和发展现状。</p><p>&gt;RPKI的基本思想是构建一个PKI（公钥基础设施）来完成对IP地址前缀和AS号的所有权和使用权的认证。RPKI包括证书认证体系和依赖方两大组件。</p><p>感觉Rust在互联网核心基础设施的应用越来越多，未来的互联网将由Rust来守护了！</p><p><a href="https://medium.com/nlnetlabs/introducing-the-routinator-3000-2a234d455b2b">https://medium.com/nlnetlabs/introducing-the-routinator-3000-2a234d455b2b</a></p><p><br></p><p><b>美国百度X-Lab的新项目</b></p><p>内存安全的Linux发行版，计划用Rust和Go重写整个用户空间程序</p><p><a href="https://github.com/mesalock-linux/mesalock-distro">mesalock-linux/mesalock-distro</a></p><p><br></p><h2><b>博文与工具：</b></h2><p><b>为macro_rules! 宏生成语法图(syntax diagrams)</b></p><p>语法图，也叫做铁路图（railroad diagram)，是一种表示形式语法的方式，规则如下:</p><ul><li>从左边界开始，沿着轨道到右边界。</li><li>沿途，你在圆框中遇到的是字面量，在方块中遇到的是规则或描述。</li><li>任何沿着轨道能走通的序列都是合法的。</li><li>任何不能沿着轨道走通的序列都是非法的。</li><li>末端只有一个竖条的铁路图，表示允许在任意一对符号中插入空白。而在末端有两个竖条的铁路图则不允许。</li></ul><p>看铁路图比直接看macro_rules!定义要简单的多，没那么烧脑</p><ul><li>[Demo]( <a href="https://lukaslueg.github.io/macro_railroad_wasm_demo/">https://lukaslueg.github.io/macro_railroad_wasm_demo/</a>)</li><li>[Code](<a href="https://github.com/lukaslueg/macro_railroad">lukaslueg/macro_railroad</a>)</li></ul><img src="https://pic1.zhimg.com/v2-09e7cc85329d2e9b9b2b707fb28e0fb4_r.jpg" data-caption="nom中name!宏生成的铁路图" data-size="normal" data-rawwidth="1280" data-rawheight="361" data-watermark="watermark" data-original-src="v2-09e7cc85329d2e9b9b2b707fb28e0fb4" data-watermark-src="v2-8a1a23f9edfeddaacaeb5271b7d5a454" data-private-watermark-src=""><p><br></p><p><b>如何缓解Rust编译时间长的痛苦</b></p><p>本文作者介绍了一些小技巧：</p><ul><li>使用cargo check。如果只是想验证语法、类型检查等，那么可以直接使用这个命令，它只会调用编译器前端。比cargo build快2倍，比cargo build —release快6倍。</li><li>使用sccache，该工具是Mozilla出品的Rust兼容的编译缓存服务，一般可以获得2倍速度提升。使用`cargo install sccache`安装sccache，并且在.bashrc中添加环境变量`export RUSTC_WRAPPER=sccache`</li><li>避免LTO。 LTO是链接时优化的缩写。LTO将付出更高的编译时间代价。</li><li>控制crate依赖。</li></ul><p><a href="https://vfoley.xyz/rust-compile-speed-tips/">https://vfoley.xyz/rust-compile-speed-tips/</a></p><p><br></p><p><b>Rust需要BFGS</b></p><p>什么是BFGS？Rust极有可能成为构建世界级机器学习工具的语言，但它目前缺少一些重要的数学基础设施。 BFGS是这些缺失的部分之一。</p><p>在许多流行的机器学习算法中，目标是找到最小化算法预测和训练数据之间误差的参数。这可以表述为找到最小化损失函数的输入。线性回归，逻辑回归，神经网络和一些不同的贝叶斯技术，都可以表示为最小化问题。</p><p>并没有一个通用的最佳的「最小化」功能，但是Python和R中都使用了BFGS算法。</p><p>BFGS代表Broyden-Fletcher-Goldfarb-Shanno，它是1970年各自独立发布该算法的四位研究人员的名字。</p><p>[bfgs代码](<a href="https://github.com/paulkernfeld/bfgs">paulkernfeld/bfgs</a>)</p><p>如果你有能力有兴趣，可以来这里帮忙改进Rust代码</p><p>友情提示：参看原文需要机器学习基础</p><p>[原文](<a href="https://paulkernfeld.com/2018/08/06/rust-needs-bfgs.html">Rust needs BFGS. What is BFGS?</a>)</p><p><br></p><p><b>使用Clippy发现Rust代码中隐藏的问题</b></p><p>该文演示了如何通过Clippy的cast_lossless警告发现隐藏的Bug</p><p><a href="https://benjamincongdon.me/blog/2018/08/06/Clippys-cast_lossless-Lint-Warning/">Clippy's "cast_lossless" Lint Warning</a> </p><p><br></p><p><b>WebAssembly： How and Why</b></p><p>WebAssembly对JavaScript和Web开发的未来意味着什么？</p><p>为什么需要WebAssembly？</p><ul><li>将许多其他应用程序能做的事带到浏览器上，比如运行大型游戏、渲染等需要大量计算的事情</li><li> Web才是未来，真正的通用平台</li><li> WebAssembly提供了速度、可移植性和灵活性。 wasm文件大小比js更小，速度更快，更可靠的性能保证</li><li> WebAssembly提供了可移植性。不仅仅是Web可用，其他平台也可用，包括iOS和Android、区块链等。</li><li> WebAssembly提供了巨大的灵活性。JS将不再是浏览器支持的唯一语言，在遇到瓶颈的时候，开发者可以选择任意喜欢的其他语言（包括js本身）来优化现有js系统的性能，并且是无缝对接。目前C、C++、Rust、Kotlin和.NET均先后增加支持</li></ul><p>WebAssembly如何工作？</p><ul><li>需要一个将代码编译为WASM的工具。C/C++通过LLVM和Emscripten，而Rust编译器可以直接编译wasm。</li><li>将编译出来的wasm通过js加载，可以和js无缝互通</li></ul><p>未来？</p><ul><li>正在开发新的特性</li><li>比如支持dom、线程和垃圾回收</li><li>支持调试工具</li><li>虽然js无法直接编译为wasm，但是有工具可以将js转换为wasm的文本格式，然后再转为wasm</li></ul><p><a href="https://blog.logrocket.com/webassembly-how-and-why-559b7f96cd71">https://blog.logrocket.com/webassembly-how-and-why-559b7f96cd71</a></p><p><br></p><p><b>Rust和WASM实现的交互式文本游戏</b></p><p>最流行的一个是Z-Machine，该网站就是Z-Machine的Rust和WASM实现</p><p><a href="https://sterlingdemille.com/encrusted/">Encrusted - Home</a></p><p>源码：<a href="https://github.com/demille/encrusted">DeMille/encrusted</a> </p><p><br></p><p><b>光线跟踪： WebAssembly vs Javascript</b></p><p>作者用用3D光线跟踪的案例来学习WebAssembly，想看看它在计算密集型应用中的表现。</p><p>结果很吃惊：</p><ul><li>WebAssembly: 22.0fps</li><li>JavaScript: 2.5fps</li></ul><p>WebAssembly性能是JS的9倍。</p><p>作者使用Rust工具链： wasm-bindgen和wasm-pack，在Firefox Quantum 61.0.2浏览器进行测试。</p><p><a href="http://matt-harrison.com/raytracing-webassembly-vs-javascript/">Ray Tracing: WebAssembly vs JavaScript</a></p><p>源码 <a href="https://github.com/mtharrison/wasm-raytracer">mtharrison/wasm-raytracer</a></p><p><br></p><p><br></p><p><br></p><p><b>Amp：面向终端的文本编辑器</b></p><p>功能相当于Vim/Vi，但是对Vim做了简化，并捆绑了现代编辑器的功能。目前刚发布0.5版本</p><p>这个工具这么酷，为什么我刚知道？</p><p><a href="https://amp.rs/">A complete text editor for your terminal</a> </p><p><a href="https://github.com/jmacdonald/amp">jmacdonald/amp</a> </p><p><br></p><p><b>使用  Warp, Juniper 和 MongoDB实现Graphql Server</b></p><p><a href="http://alex.amiran.it/post/2018-08-16-rust-graphql-webserver-with-warp-juniper-and-mongodb.html">http://alex.amiran.it/post/2018-08-16-rust-graphql-webserver-with-warp-juniper-and-mongodb.html</a></p><p><br></p><p><b>视频： 函数式Rust</b></p><p>讨论在Rust中如何编写函数式代码</p><p><a href="https://www.infoq.com/presentations/functional-rust">Functional Rust - An Exploration </a></p><p><br></p><p><b>【RustConf 2018】 主题之一： 从零开始写一个Crate</b></p><p>turtle（小海龟画图）指南</p><p><a href="https://slides.com/sunjay/tour-of-turtle#/">Writing Crates for Complete Beginners: A Tour of Turtle</a> </p><p><br></p><p>【RustConf 2018】 跟着Mgattozzi学Rust异步编程</p><p><a href="https://mgattozzi.com/classes/run-await-with-me">https://mgattozzi.com/classes/run-await-with-me</a> </p><p><br></p><p><b>【嵌入式】Rust实现TSL256X光强度传感器驱动器</b></p><p>该文作者在Rust嵌入式工作组的成果上完成了自己的第一个嵌入式驱动开发，他表示：</p><blockquote>&gt;对于驱动程序编写者来说，有一个明确的期望和一个明确的标准来确定应该如何完成，非常exciting。</blockquote><p><a href="https://www.joshmcguigan.com/blog/tsl256x-light-intensity-sensor-driver/">TSL256X Light Intensity Sensor Driver</a> </p><p></p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
