<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Rust中的各种指针</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/76945648">原文</a></p>
<p>Rust 中的指针大体可以分为以下四种：</p><ol><li>引用 references</li><li>“胖指针 fat pointers”（<i>该分类存有争议</i>）</li><li>智能指针 smart pointers</li><li>裸指针 raw pointers</li></ol><h3>1. 引用</h3><p>就是直接对一个变量执行 &amp;、&amp;mut  操作，永远不会为 null。<br/>其占用的大小与 usize 一致。</p><p>与引用相关的一个名词是 借用（borrowing）。<br/>其定义为：将获取引用作为函数参数称为 借用（borrowing）</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">test_ref</span><span class="p">(){</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="o">*</span><span class="n">num_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{} sizeof &amp;i32 {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">())</span><span class="w">
</span><span class="w">    </span><span class="c1">// output 100 sizeof &amp;i32:8
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3>2.  <b>胖指针</b></h3><p>比引用多了些其它数据。<br/>在 rust 中，属于胖指针的数据：切片( &amp;[T] )。 T 为切片内元素的类型。<br/>切片类型存有： &#34;地址(ptr) + 长度(len) &#34;两个字段。<br/>图中红框内，就是一个切片。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-936954aabd29818278e3000ac5dfece0_b.jpg" data-caption="" data-size="normal" data-rawwidth="428" data-rawheight="436" class="origin_image zh-lightbox-thumb" width="428" data-original="https://pic1.zhimg.com/v2-936954aabd29818278e3000ac5dfece0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-936954aabd29818278e3000ac5dfece0_b.jpg" data-caption="" data-size="normal" data-rawwidth="428" data-rawheight="436" class="origin_image zh-lightbox-thumb lazy" width="428" data-original="https://pic1.zhimg.com/v2-936954aabd29818278e3000ac5dfece0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-936954aabd29818278e3000ac5dfece0_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">test_fat_pointers</span><span class="p">(){</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="mi">4</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="n">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">);</span><span class="w">   </span><span class="c1">// [1, 100, 3, 4]
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="mi">4</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:p} {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">slice</span><span class="p">,</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">transmute</span>::<span class="o">&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span><span class="w"> </span><span class="p">});</span><span class="w">
</span><span class="w">    </span><span class="c1">// Output: 0x8a6c0ff4ac (594518471852, 3)
</span><span class="c1"></span><span class="w">    </span><span class="c1">//      0x8a6c0ff4ac 594518471852 这两个值是相等的。
</span><span class="c1"></span><span class="w">    </span><span class="c1">//      (594518471852, 3) 分别表示 具体数据的堆地址 和 长度 两个字段。
</span><span class="c1"></span><span class="w">    </span><span class="c1">//      注意这里是用 slice，而不是 &amp;slice。(&amp;slice表示这个变量本身的栈地址)
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;sizeof &amp;[i32]:{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="c1">// Output: sizeof &amp;[i32]:16
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 因为包含了两个字段：地址 + 长度，所以其占用内存为 2 个 usize 类型大小
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p class="ztext-empty-paragraph"><br/></p><h3>3. <b>智能指针</b></h3><p>有特殊功能的，实现了 Deref、drop 相关的trait。</p><p>在 rust 中，属于智能指针的数据：String、 Vec&lt;T&gt;、Box、Cell、Rc 等等。</p><p>每一个智能指针的实现都不大一样，这里就不再展开叙述。<br/>仅以 Box 举例：</p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">test_smart_pointers</span><span class="p">(){</span><span class="w">
</span><span class="w">    </span><span class="c1">// 将本应存在栈上的地址，存在了堆上
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// num_address 指向 box 里面的具体内容（也就是储存在堆上的数值 1）
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_address</span><span class="w"> </span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="n">num</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="n">num_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> 
</span><span class="w">    </span><span class="c1">// Output: 200
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p class="ztext-empty-paragraph"><br/></p><h3>4. 裸指针</h3><p>类似 C 语言里面的指针，可以为 null ！</p><p><b>创建裸指针，是 safe 的，读写裸指针，才需要 unsafe ！</b></p><p>裸指针又可以分为可变、不可变，分别写作 *mut T 和 *const T</p><p>这里的星号不是解引用运算符，它是类型名称的一部分。</p><p>这里的 T 表示指针指向的具体类型，裸指针本身的的类型大小与 usize 一致。</p><blockquote>评论区有朋友指出：裸指针也能指向不定长类型，而且跟指向不定长类型的引用具有一样的内存布局。所以调用 sizeof，获得的大小是原始类型的大小。<br/>（不过指针这个变量本身的占用大小应该还是 一个 usize）<br/>详见评论区的讨论 </blockquote><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-rust"><span class="k">fn</span> <span class="nf">test_raw_pointers</span><span class="p">(){</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="c1">// 将引用转为裸指针
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_raw_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="n">num_raw_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{} {} {:p}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">num_raw_point</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num</span><span class="p">);</span><span class="w"> 
</span><span class="w">        </span><span class="c1">// Output: 100 100 0x8d8c6ff6bc
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_raw_point</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="c1">// 将一个 usize 对象，转化为 裸指针
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">raw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="n">raw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{} {} {:p} {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">num_raw_point</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="c1">// Output: 200 200 0x8d8c6ff6bc 607946536636
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p class="ztext-empty-paragraph"><br/></p><p class="ztext-empty-paragraph"><br/></p><h3>补充</h3><p>这是 大佬 <a class="member_mention" href="https://www.zhihu.com/people/bf95908efb41f3447704e267c6be7139" data-hash="bf95908efb41f3447704e267c6be7139" data-hovercard="p$b$bf95908efb41f3447704e267c6be7139">@F001</a> 给的反馈，大家可以留意下。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-b836dfd67b6f2acccb47fe8a8cac0fb2_b.jpg" data-caption="" data-size="normal" data-rawwidth="493" data-rawheight="399" class="origin_image zh-lightbox-thumb" width="493" data-original="https://pic3.zhimg.com/v2-b836dfd67b6f2acccb47fe8a8cac0fb2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-b836dfd67b6f2acccb47fe8a8cac0fb2_b.jpg" data-caption="" data-size="normal" data-rawwidth="493" data-rawheight="399" class="origin_image zh-lightbox-thumb lazy" width="493" data-original="https://pic3.zhimg.com/v2-b836dfd67b6f2acccb47fe8a8cac0fb2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-b836dfd67b6f2acccb47fe8a8cac0fb2_b.jpg"/></figure><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
