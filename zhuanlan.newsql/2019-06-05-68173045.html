<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>DM 源码阅读系列文章（七）定制化数据同步功能的实现</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/68173045">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-4042c5af270bdcfaf1255c0973c84c2f_b.jpg" alt=""></div><p>作者：王相</p><p>本文为 DM 源码阅读系列文章的第七篇，在 <a href="https://link.zhihu.com/?target=https%3A//pingcap.com/blog-cn/dm-source-code-reading-6/" class=" wrap external" target="_blank" rel="nofollow noreferrer">上篇文章</a> 中我们介绍了 relay log 的实现，主要包括 relay log 目录结构定义、relay log 数据的处理流程、主从切换支持、relay log 的读取等逻辑。<b>本篇文章我们将会对 DM 的定制化数据同步功能进行详细的讲解。</b></p><p>在一般的数据同步中，上下游的数据是一一对应的，即上下游的库名、表名、列名以及每一列的值都是相同的，但是很多用户因为业务的原因希望 DM 在同步数据到 TiDB 时进行一些定制化的转化。下面我们将主要介绍数据同步定制化中的库表路由（Table routing）、黑白名单（Black &amp; white table lists）、列值转化（Column mapping）、binlog 过滤（Binlog event filter）四个主要功能的实现。值得注意的是，由于其他一些工具（例如 TiDB Lightning 和 TiDB Binlog）也需要类似的功能，所以这四个功能都以 package 的形式维护在 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/tree/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg" class=" wrap external" target="_blank" rel="nofollow noreferrer">tidb-tools</a> 项目下，这样方便使用和维护。</p><h2>库表路由（<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L116" class=" wrap external" target="_blank" rel="nofollow noreferrer">Table routing</a>）</h2><p>库表路由顾名思义就是对库名和表名根据一定的路由规则进行转换。比如用户在上游多个 MySQL 实例或者 schema 有多个逻辑上相同的表，需要把这些表的数据同步到 TiDB 集群的同一个表中，这个时候就可以使用 table-router 功能，如下图所示：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-7a4eca51c6029c558ef0ce2bb2cc707c_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="454" class="origin_image zh-lightbox-thumb" width="939" data-original="https://pic1.zhimg.com/v2-7a4eca51c6029c558ef0ce2bb2cc707c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-7a4eca51c6029c558ef0ce2bb2cc707c_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="454" class="origin_image zh-lightbox-thumb lazy" width="939" data-original="https://pic1.zhimg.com/v2-7a4eca51c6029c558ef0ce2bb2cc707c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-7a4eca51c6029c558ef0ce2bb2cc707c_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>该功能实现在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/tree/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/table-router" class=" wrap external" target="_blank" rel="nofollow noreferrer">pkg/table-router</a></code> 中，库表路由的规则定义在结构 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/table-router/router.go%23L25" class=" wrap external" target="_blank" rel="nofollow noreferrer">TableRule</a></code> 中，其中的属性 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/table-router/router.go%23L26" class=" wrap external" target="_blank" rel="nofollow noreferrer">SchemaPattern</a></code> 和 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/table-router/router.go%23L27" class=" wrap external" target="_blank" rel="nofollow noreferrer">TablePattern</a></code> 用于配置原库名和表名的模式，<code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/table-router/router.go%23L28" class=" wrap external" target="_blank" rel="nofollow noreferrer">TargetSchema</a></code> 和 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/table-router/router.go%23L29" class=" wrap external" target="_blank" rel="nofollow noreferrer">TargetTable</a></code> 用于配置目标库和表名，即符合指定 pattern 的库和表名都将转化成目标库名和表名。</p><p>使用结构 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/table-router/router.go%23L52" class=" wrap external" target="_blank" rel="nofollow noreferrer">Table</a> 对路由规则进行维护，Table 提供了如下方法：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-e2b7c52195e423b1523a6644a0b1def1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1260" data-rawheight="422" class="origin_image zh-lightbox-thumb" width="1260" data-original="https://pic2.zhimg.com/v2-e2b7c52195e423b1523a6644a0b1def1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-e2b7c52195e423b1523a6644a0b1def1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1260" data-rawheight="422" class="origin_image zh-lightbox-thumb lazy" width="1260" data-original="https://pic2.zhimg.com/v2-e2b7c52195e423b1523a6644a0b1def1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-e2b7c52195e423b1523a6644a0b1def1_b.jpg"/></figure><p>Table 结构中组合了<code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/table-router/router.go%23L53" class=" wrap external" target="_blank" rel="nofollow noreferrer">Selector</a></code>，<code>Selector</code>用于管理指定模式的库、表的规则，提供如下方法：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-03270453b2d148d64d1aac21bd2140b1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1264" data-rawheight="394" class="origin_image zh-lightbox-thumb" width="1264" data-original="https://pic2.zhimg.com/v2-03270453b2d148d64d1aac21bd2140b1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-03270453b2d148d64d1aac21bd2140b1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1264" data-rawheight="394" class="origin_image zh-lightbox-thumb lazy" width="1264" data-original="https://pic2.zhimg.com/v2-03270453b2d148d64d1aac21bd2140b1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-03270453b2d148d64d1aac21bd2140b1_b.jpg"/></figure><p>Selector 的底层实现是 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/table-rule-selector/trie_selector.go%23L71" class=" wrap external" target="_blank" rel="nofollow noreferrer">trieSelector</a></code>，使用了单词查找树的结构来维护库、表与规则的对应关系，感兴趣的同学可以阅读代码深入了解一下。 trieSelector 中使用 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/table-rule-selector/trie_selector.go%23L74" class=" wrap external" target="_blank" rel="nofollow noreferrer">cache</a> 缓存了库、表到规则的映射关系，这样可以减少相同库、表匹配规则的资源消耗。除了 table routing，以下的列值转化和 binlog 过滤功能也都使用了 Selector，在下面的介绍中就不再赘述。</p><h2>黑白名单（<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L119" class=" wrap external" target="_blank" rel="nofollow noreferrer">black &amp; white table lists</a>）</h2><p>黑白名单功能用来选择同步哪些库和表，以及不同步哪些库和表，这部分代码维护在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/tree/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/filter" class=" wrap external" target="_blank" rel="nofollow noreferrer">pkg/filter</a></code> 中。</p><p>黑白名单规则配置在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/filter/filter.go%23L66" class=" wrap external" target="_blank" rel="nofollow noreferrer">Rules</a></code> 结构中，该结构包括 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/filter/filter.go%23L67" class=" wrap external" target="_blank" rel="nofollow noreferrer">DoTables</a></code>、<code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/filter/filter.go%23L68" class=" wrap external" target="_blank" rel="nofollow noreferrer">DoDBs</a></code>、<code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/filter/filter.go%23L70" class=" wrap external" target="_blank" rel="nofollow noreferrer">IgnoreTables</a></code> 和 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/filter/filter.go%23L71" class=" wrap external" target="_blank" rel="nofollow noreferrer">IgnoreDBs</a></code> 四个属性，下面以判断表 <code>test.t</code> 是否应该被过滤的例子说明配置的作用：</p><p>1.首先 schema 过滤判断。</p><ul><ul><li>如果 <code>do-dbs</code> 不为空，则判断 <code>do-dbs</code> 中是否存在一个匹配的 schema。</li><ul><li>如果存在，则进入 table 过滤判断。</li><li>如果不存在，则过滤 <code>test.t</code>。</li></ul><li>如果 <code>do-dbs</code> 为空并且 <code>ignore-dbs</code> 不为空，则判断 <code>ignore-dbs</code> 中是否存在一个匹配的 schema。</li><ul><li>如果存在，则过滤 <code>test.t</code>。</li><li>如果不存在，则进入 table 过滤判断。</li></ul><li>如果 <code>do-dbs</code> 和 <code>ignore-dbs</code> 都为空，则进入 table 过滤判断。</li></ul></ul><p>2.进行 table 过滤判断。</p><ul><ul><li>如果 <code>do-tables</code> 不为空，则判断 <code>do-tables</code> 中是否存在一个匹配的 table。</li><ul><li>如果存在，则同步 <code>test.t</code>。</li><li>如果不存在，则过滤 <code>test.t</code>。</li></ul><li>如果 <code>ignore-tables</code> 不为空，则判断 <code>ignore-tables</code> 中是否存在一个匹配的 table。</li><ul><li>如果存在，则过滤 <code>test.t</code>。</li><li>如果不存在，则同步 <code>test.t</code>。</li></ul><li>如果 <code>do-tables</code> 和 <code>ignore-tables</code> 都为空，则同步 <code>test.t</code>。</li></ul></ul><p>使用 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/filter/filter.go%23L97" class=" wrap external" target="_blank" rel="nofollow noreferrer">Filter</a> 对黑白名单进行管理，Filter 提供了 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/filter/filter.go%23L164" class=" wrap external" target="_blank" rel="nofollow noreferrer">ApplyOn</a></code> 方法来判断一组 table 中哪些表可以同步。</p><h2>列值转化（<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L118" class=" wrap external" target="_blank" rel="nofollow noreferrer">Column mapping</a>）</h2><p>列值转化功能用于对指定列的值做一些转化，主要用于分库分表的同步场景。比较典型的场景是：在上游分表中使用自增列作为主键，这样数据在同步到 TiDB 的一个表时会出现主键冲突，因此我们需要根据一定规则对主键做转化，保证每个主键在全局仍然是唯一的。</p><p>该功能实现在 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/tree/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/column-mapping" class=" wrap external" target="_blank" rel="nofollow noreferrer">pkg/column-mapping</a></code> 中的 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/column-mapping/column.go%23L438" class=" wrap external" target="_blank" rel="nofollow noreferrer">PartitionID</a></code>：修改列的值的最高几位为 <code>PartitionID</code> 的值（只能作用于 Int64 类型的列）。</p><p>代码中使用 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/column-mapping/column.go%23L77" class=" wrap external" target="_blank" rel="nofollow noreferrer">Rule</a> 来设置 column mapping 的规则，Rule 的属性及说明如下表所示：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-69bbb20ddf83473641299274843cfd80_b.jpg" data-caption="" data-size="normal" data-rawwidth="1260" data-rawheight="822" class="origin_image zh-lightbox-thumb" width="1260" data-original="https://pic1.zhimg.com/v2-69bbb20ddf83473641299274843cfd80_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-69bbb20ddf83473641299274843cfd80_b.jpg" data-caption="" data-size="normal" data-rawwidth="1260" data-rawheight="822" class="origin_image zh-lightbox-thumb lazy" width="1260" data-original="https://pic1.zhimg.com/v2-69bbb20ddf83473641299274843cfd80_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-69bbb20ddf83473641299274843cfd80_b.jpg"/></figure><p>Expression 为 <code>PartitionID</code> 的配置和转化的计算方式都较为复杂，下面举个例子说明。</p><p>例如 Arguments 为 <code>[1, “test”, “t”, “_”]</code>，<code>1</code> 表示数据库实例的 <code>InstanceID</code>，<code>“test”</code> 为库名称的前缀，<code>“t”</code> 为表名称的前缀，<code>“_”</code> 为前缀与 ID 的分隔符，则表 <code>test_1.t_2</code> 的 <code>SchemaID</code> 为 <code>1</code>，<code>TableID</code> 为 <code>2</code>。转化列值时需要对 <code>InstanceID</code>、<code>SchemaID</code>、<code>TableID</code> 进行一定的位移计算，然后与原始的值进行或运算得出一个新的值。对于具体的计算方式，可以查看代码 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/column-mapping/column.go%23L438" class=" wrap external" target="_blank" rel="nofollow noreferrer">partitionID</a></code> 和 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/column-mapping/column.go%23L487" class=" wrap external" target="_blank" rel="nofollow noreferrer">computePartitionID</a></code>。下面是一个 <code>PartitionID</code> 逻辑简化后的示意图：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-7d6b5551f5220ea8e5b8ce3919dc46c2_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="452" class="origin_image zh-lightbox-thumb" width="939" data-original="https://pic3.zhimg.com/v2-7d6b5551f5220ea8e5b8ce3919dc46c2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-7d6b5551f5220ea8e5b8ce3919dc46c2_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="452" class="origin_image zh-lightbox-thumb lazy" width="939" data-original="https://pic3.zhimg.com/v2-7d6b5551f5220ea8e5b8ce3919dc46c2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-7d6b5551f5220ea8e5b8ce3919dc46c2_b.jpg"/></figure><p>使用 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/column-mapping/column.go%23L153" class=" wrap external" target="_blank" rel="nofollow noreferrer">Mapping</a> 结构对 column mapping 的规则进行管理，Mapping 提供列如下方法：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-780f9f40ce2f15a409658428333c929b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1264" data-rawheight="432" class="origin_image zh-lightbox-thumb" width="1264" data-original="https://pic4.zhimg.com/v2-780f9f40ce2f15a409658428333c929b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-780f9f40ce2f15a409658428333c929b_b.jpg" data-caption="" data-size="normal" data-rawwidth="1264" data-rawheight="432" class="origin_image zh-lightbox-thumb lazy" width="1264" data-original="https://pic4.zhimg.com/v2-780f9f40ce2f15a409658428333c929b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-780f9f40ce2f15a409658428333c929b_b.jpg"/></figure><h2>binlog 过滤（<a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/dm/blob/8bfa3e0e99b1bb1d59d9efd6320d9a86fa468217/syncer/syncer.go%23L117" class=" wrap external" target="_blank" rel="nofollow noreferrer">binlog event filter</a>）</h2><p>binlog 过滤功能支持过滤指定类型的 binlog，或者指定模式的 query，该功能维护在 <a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/tree/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/binlog-filter" class=" wrap external" target="_blank" rel="nofollow noreferrer">pkg/binlog-filter</a> 中。某些用户不希望同步一些指定类型的 binlog，例如 drop table 和 truncate table，这样就可以在下游仍然保存这些表的数据作为备份，或者某些 SQL 语句在 TiDB 中不兼容，希望可以在同步中过滤掉，都可以通过配置 binlog event filter 功能来实现。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-6a9061eeaf8bfde6340d494ed67c6ff4_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="449" class="origin_image zh-lightbox-thumb" width="939" data-original="https://pic1.zhimg.com/v2-6a9061eeaf8bfde6340d494ed67c6ff4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-6a9061eeaf8bfde6340d494ed67c6ff4_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="449" class="origin_image zh-lightbox-thumb lazy" width="939" data-original="https://pic1.zhimg.com/v2-6a9061eeaf8bfde6340d494ed67c6ff4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-6a9061eeaf8bfde6340d494ed67c6ff4_b.jpg"/></figure><p>首先需要对 binlog 进行分类，可以查看代码 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/binlog-filter/filter.go%23L42" class=" wrap external" target="_blank" rel="nofollow noreferrer">Event Type List</a></code>。然后再定义过滤规则 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/binlog-filter/filter.go%23L85" class=" wrap external" target="_blank" rel="nofollow noreferrer">BinlogEventRule</a></code>，包括以下属性：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-bd7d10ede2725d55aacdf40a5c820429_b.jpg" data-caption="" data-size="normal" data-rawwidth="1252" data-rawheight="788" class="origin_image zh-lightbox-thumb" width="1252" data-original="https://pic2.zhimg.com/v2-bd7d10ede2725d55aacdf40a5c820429_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-bd7d10ede2725d55aacdf40a5c820429_b.jpg" data-caption="" data-size="normal" data-rawwidth="1252" data-rawheight="788" class="origin_image zh-lightbox-thumb lazy" width="1252" data-original="https://pic2.zhimg.com/v2-bd7d10ede2725d55aacdf40a5c820429_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-bd7d10ede2725d55aacdf40a5c820429_b.jpg"/></figure><p>例如，TiDB 对 <code>ADD PARTITION</code> 和 <code>DROP PARTITION</code> 语句不兼容，在同步时需要过滤掉相关的 SQL 语句，就可以在 DM 中使用如下配置：</p><div class="highlight"><pre><code class="language-text">filter-partition-rule:
    schema-pattern: &#34;*&#34;
    sql-pattern: [&#34;ALTER\\s+TABLE[\\s\\S]*ADD\\s+PARTITION&#34;, &#34;ALTER\\s+TABLE[\\s\\S]*DROP\\s+PARTITION&#34;]
    action: Ignore</code></pre></div><p>如果需要过滤掉所有的 <code>DROP DATABASE</code> 语句，则可以在 DM 中使用如下配置：</p><div class="highlight"><pre><code class="language-text">filter-schema-rule:
    schema-pattern: &#34;*&#34;
    events: [&#34;drop database&#34;]
    action: Ignore</code></pre></div><p>代码中通过 <code><a href="https://link.zhihu.com/?target=https%3A//github.com/pingcap/tidb-tools/blob/f5fc4cb670ced38fb362eda0766a9db1c1856a0a/pkg/binlog-filter/filter.go%23L120" class=" wrap external" target="_blank" rel="nofollow noreferrer">BinlogEvent</a></code> 结构对 binlog event 过滤规则做统一的管理，<code>BinlogEvent</code> 提供了如下的方法：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-98c8fc916958be7692bfc2f3260ca1f1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1256" data-rawheight="428" class="origin_image zh-lightbox-thumb" width="1256" data-original="https://pic2.zhimg.com/v2-98c8fc916958be7692bfc2f3260ca1f1_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-98c8fc916958be7692bfc2f3260ca1f1_b.jpg" data-caption="" data-size="normal" data-rawwidth="1256" data-rawheight="428" class="origin_image zh-lightbox-thumb lazy" width="1256" data-original="https://pic2.zhimg.com/v2-98c8fc916958be7692bfc2f3260ca1f1_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-98c8fc916958be7692bfc2f3260ca1f1_b.jpg"/></figure><h2>小结</h2><p>以上就是定制化数据同步功能中库表路由（Table routing）、黑白名单（Black &amp; white table lists）、列值转化（Column mapping）、binlog 过滤（Binlog event filter）的实现介绍。欢迎大家阅读相关代码深入了解，也欢迎给我们提 pr 优化代码。下一篇我们将介绍 DM 是如何支持上游 online DDL 工具（pt-osc，gh-ost）的 DDL 同步场景的。</p><p><b><i>原文阅读：</i></b></p><a href="https://link.zhihu.com/?target=https%3A//www.pingcap.com/blog-cn/dm-source-code-reading-7/" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-60ab5bd867c2434d70c957a02a2169e1_ipico.jpg" data-image-width="1200" data-image-height="1200" class=" wrap external" target="_blank" rel="nofollow noreferrer">DM 源码阅读系列文章（七）定制化数据同步功能的实现</a><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
