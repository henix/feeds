<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>71803倍！超强Pandas循环提速攻略</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/80328910">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-7976dc5a70e10a1882fef0f98c2a39d8_b.jpg" alt=""></div><blockquote>作者：Benedikt Droste<br/>编译：1+1=6</blockquote><h2><b>前言</b></h2><p>如果你使用Python和Pandas进行数据分析，循环是不可避免要使用的。然而，即使对于较小的DataFame来说，使用标准循环也是非常耗时的，对于较大的DataFrame来说，你懂的。今天，公众号为大家分享一个关于Pandas提速的小攻略，助你一臂之力！</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-dc067151ef42008be7f3c20b8cff4c0a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="537" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic3.zhimg.com/v2-dc067151ef42008be7f3c20b8cff4c0a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-dc067151ef42008be7f3c20b8cff4c0a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="537" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic3.zhimg.com/v2-dc067151ef42008be7f3c20b8cff4c0a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-dc067151ef42008be7f3c20b8cff4c0a_b.jpg"/></figure><h2><b>相关文章</b></h2><p><u><a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzAxNTc0Mjg0Mg%3D%3D%26mid%3D2653293723%26idx%3D1%26sn%3D8fcb3effaffd583882d5ffe13b330fe2%26chksm%3D802dce8eb75a4798bcb14f9f9cb19b1333c2e31d78fc837448b8a4c8990da9ad083c7fe5ecee%26scene%3D21%23wechat_redirect" class=" wrap external" target="_blank" rel="nofollow noreferrer">1、30倍！使用Cython加速Python代码</a></u></p><p><u>2、<a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzAxNTc0Mjg0Mg%3D%3D%26mid%3D2653294102%26idx%3D1%26sn%3D5dc9d21b3497fe6e1c8df98ee61e02c7%26chksm%3D802dcc03b75a4515a630076cbbe4d116ba1897f4fbb961b0811a888272f9e12953c3ca967c3c%26scene%3D21%23wechat_redirect" class=" wrap external" target="_blank" rel="nofollow noreferrer">CuPy：将Numpy提速700倍！</a></u></p><p><u>3<a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzAxNTc0Mjg0Mg%3D%3D%26mid%3D2653293923%26idx%3D2%26sn%3D3c344ab8661a2d9d6b79caa6f253f35d%26chksm%3D802dcf76b75a466080145f290dc01ddc5775906e16e04cec5d48a10f1356b37b2644fd67a38a%26scene%3D21%23wechat_redirect" class=" wrap external" target="_blank" rel="nofollow noreferrer">、10个提高工作效率的Pandas小技巧</a></u></p><p><u>4<a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzAxNTc0Mjg0Mg%3D%3D%26mid%3D2653292258%26idx%3D1%26sn%3Dd5d79cecb461eab3591ab8e3c2c03ce0%26chksm%3D802dc4f7b75a4de195bcd6211ac8532d68096bef4d7ca0e5a4fcd792d1e2c7dd5bbea85f91cf%26scene%3D21%23wechat_redirect" class=" wrap external" target="_blank" rel="nofollow noreferrer">、高逼格使用Pandas加速代码，向for循环说拜拜！</a></u></p><h2><b>标准循环</b></h2><p>Datatrame是Pandas对象，具有行和列。如果使用循环，你将遍历整个对象。Python不能利用任何内置函数，而且速度非常慢。 我们创建了一个包含65列和1140行的Dataframe。它包含了2016-2019赛季的足球比赛结果。我们希望创建一个新列，用于标注某个特定球队是否打了平局。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-ca5fccfe61a3e213a78d190a6aa3b6c0_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="500" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-ca5fccfe61a3e213a78d190a6aa3b6c0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-ca5fccfe61a3e213a78d190a6aa3b6c0_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="500" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic1.zhimg.com/v2-ca5fccfe61a3e213a78d190a6aa3b6c0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-ca5fccfe61a3e213a78d190a6aa3b6c0_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-7c0dcd2541f929c9cd0af9ddd4be1382_b.jpg" data-caption="" data-size="normal" data-rawwidth="539" data-rawheight="93" class="origin_image zh-lightbox-thumb" width="539" data-original="https://pic3.zhimg.com/v2-7c0dcd2541f929c9cd0af9ddd4be1382_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-7c0dcd2541f929c9cd0af9ddd4be1382_b.jpg" data-caption="" data-size="normal" data-rawwidth="539" data-rawheight="93" class="origin_image zh-lightbox-thumb lazy" width="539" data-original="https://pic3.zhimg.com/v2-7c0dcd2541f929c9cd0af9ddd4be1382_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-7c0dcd2541f929c9cd0af9ddd4be1382_b.jpg"/></figure><p>正如你看到的，这个循环非常慢，花了<b>20.7秒</b>。让我们看看如何才能更有效率。</p><h2><b>iterrows()：快321倍</b></h2><p>在第一个例子中，我们循环遍历了整个DataFrame。Iterrows()<b>为每一行返回一个 Series，因此它以索引对的形式遍历DataFrame，以Series的形式遍历目标列</b>。这使得它比标准循环更快：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-cadd40b0ec73adc80c6fcbbb8fc18d2d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="518" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic2.zhimg.com/v2-cadd40b0ec73adc80c6fcbbb8fc18d2d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-cadd40b0ec73adc80c6fcbbb8fc18d2d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="518" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic2.zhimg.com/v2-cadd40b0ec73adc80c6fcbbb8fc18d2d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-cadd40b0ec73adc80c6fcbbb8fc18d2d_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-0ed44d7f4861b53625dc66c092a0db51_b.jpg" data-caption="" data-size="normal" data-rawwidth="694" data-rawheight="140" class="origin_image zh-lightbox-thumb" width="694" data-original="https://pic2.zhimg.com/v2-0ed44d7f4861b53625dc66c092a0db51_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-0ed44d7f4861b53625dc66c092a0db51_b.jpg" data-caption="" data-size="normal" data-rawwidth="694" data-rawheight="140" class="origin_image zh-lightbox-thumb lazy" width="694" data-original="https://pic2.zhimg.com/v2-0ed44d7f4861b53625dc66c092a0db51_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-0ed44d7f4861b53625dc66c092a0db51_b.jpg"/></figure><p>该代码运行时间为<b>87毫秒</b>，<b>比标准循环快321倍</b>。 </p><p>但是，我们建议不要使用它，因为有更快的选择，而且<b>iterrows()不能保留行之间的 dtype</b>。这意味着，如果你在dataframe dtypes上使用iterrows() ，它会被更改，这可能会导致很多问题。如果一定要保留dtypes，也可以使用itertuple()。这里我们不详细讨论，你可以在这里找到官方文件：</p><p><i><a href="https://link.zhihu.com/?target=https%3A//pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html%3Fsource%3Dpost_page-----805030df4f06----------------------" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">pandas.pydata.org/panda</span><span class="invisible">s-docs/stable/reference/api/pandas.DataFrame.itertuples.html?source=post_page-----805030df4f06----------------------</span><span class="ellipsis"></span></a></i></p><h2><b>Apply()：快811倍</b></h2><p>apply本身并不快，但与DataFrame结合使用时，它具有很大的优势。这取决于apply表达式的内容。 如果它可以在Cython中执行，那么apply要快得多。</p><p>我们可以在Lambda函数中使用apply。 所要做的就是指定轴，使用axis=1，因为我们希望执行按列操作：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-a437bbe396b590dc33e666935c92e7ce_b.png" data-caption="" data-size="normal" data-rawwidth="848" data-rawheight="97" class="origin_image zh-lightbox-thumb" width="848" data-original="https://pic3.zhimg.com/v2-a437bbe396b590dc33e666935c92e7ce_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-a437bbe396b590dc33e666935c92e7ce_b.png" data-caption="" data-size="normal" data-rawwidth="848" data-rawheight="97" class="origin_image zh-lightbox-thumb lazy" width="848" data-original="https://pic3.zhimg.com/v2-a437bbe396b590dc33e666935c92e7ce_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-a437bbe396b590dc33e666935c92e7ce_b.png"/></figure><p>这段代码甚至比以前的方法更快，时间为<b>27毫秒</b>。</p><h2><b>Pandas Vectorization：快9280倍</b></h2><p>我们利用向量化的优势来创建真正高效的代码。关键是要避免案例1中那样的循环代码：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-0287247e9f994fd8cdc52462f271b90c_b.png" data-caption="" data-size="normal" data-rawwidth="597" data-rawheight="96" class="origin_image zh-lightbox-thumb" width="597" data-original="https://pic1.zhimg.com/v2-0287247e9f994fd8cdc52462f271b90c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-0287247e9f994fd8cdc52462f271b90c_b.png" data-caption="" data-size="normal" data-rawwidth="597" data-rawheight="96" class="origin_image zh-lightbox-thumb lazy" width="597" data-original="https://pic1.zhimg.com/v2-0287247e9f994fd8cdc52462f271b90c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-0287247e9f994fd8cdc52462f271b90c_b.png"/></figure><p>我们再次使用了开始时构建的函数。我们所要做的就是改变输入。我们直接将Pandas Series传递给我们的功能，这使我们获得了巨大的速度提升。</p><h2><b>Nump Vectorization：快71803倍</b></h2><p>在前面的示例中，我们将Pandas Series传递给函数。通过adding.values，我们得到一个Numpy数组：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-257321f5a92e53411cc297627574c938_b.png" data-caption="" data-size="normal" data-rawwidth="755" data-rawheight="97" class="origin_image zh-lightbox-thumb" width="755" data-original="https://pic1.zhimg.com/v2-257321f5a92e53411cc297627574c938_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-257321f5a92e53411cc297627574c938_b.png" data-caption="" data-size="normal" data-rawwidth="755" data-rawheight="97" class="origin_image zh-lightbox-thumb lazy" width="755" data-original="https://pic1.zhimg.com/v2-257321f5a92e53411cc297627574c938_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-257321f5a92e53411cc297627574c938_b.png"/></figure><p>Numpy数组是如此之快，因为我们引用了局部性的好处：</p><p><b>访问局部性（locality of reference）</b></p><p>在计算机科学中，访问局部性，也称为局部性原理，是取决于存储器访问模式频繁访问相同值或相关存储位置的现象的术语。访问局部性有两种基本类型——时间和空间局部性。时间局部性是指在相对较小的持续时间内对特定数据和/或资源的重用。空间局部性是指在相对靠近的存储位置内使用数据元素。当数据元素被线性地排列和访问时，例如遍历一维数组中的元素，发生顺序局部性，即空间局部性的特殊情况。</p><p>局部性只是计算机系统中发生的一种可预测的行为。展示强访问局部性的系统是通过使用诸如在处理器核心的流水线级处的高速缓存，用于存储器的预取和高级分支预测器的技术的性能优化的良好候选者。</p><p>代码运行了<b>0.305毫秒</b>，比开始时使用的标准循环快了 <b>71803倍！</b></p><h2><b>总结</b></h2><p>我们比较了五种不同的方法，并根据一些计算将一个新列添加到我们的DataFrame中。我们注意到了速度方面的巨大差异：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-d3341b355e9f0fadf42f0955ceaed71a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="533" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic3.zhimg.com/v2-d3341b355e9f0fadf42f0955ceaed71a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-d3341b355e9f0fadf42f0955ceaed71a_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="533" class="origin_image zh-lightbox-thumb lazy" width="1080" data-original="https://pic3.zhimg.com/v2-d3341b355e9f0fadf42f0955ceaed71a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-d3341b355e9f0fadf42f0955ceaed71a_b.jpg"/></figure><p>请记住：</p><p><b>1、如果确定需要使用循环，则应始终选择apply方法。</b></p><p><b>2、否则，vectorization总是更好的，因为它更快！</b></p><p><b>文章参考</b></p><p>[1] <a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/52673285/performance-of-pandas-apply-vs-np-vectorize-to-create-new-column-from-existing-c" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">stackoverflow.com/quest</span><span class="invisible">ions/52673285/performance-of-pandas-apply-vs-np-vectorize-to-create-new-column-from-existing-c</span><span class="ellipsis"></span></a></p><p>[2 ] <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Locality_of_reference" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">en.wikipedia.org/wiki/L</span><span class="invisible">ocality_of_reference</span><span class="ellipsis"></span></a></p><p><i>—End—</i></p><p>量化投资与机器学习微信公众号，是业内垂直于<b>Quant</b>、<b>MFE</b>、<b>CST、AI</b>等专业的<b>主流量化自媒体</b>。公众号拥有来自<b>公募、私募、券商、银行、海外</b>等众多圈内<b>10W+</b>关注者。每日发布行业前沿研究成果和最新量化资讯。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
