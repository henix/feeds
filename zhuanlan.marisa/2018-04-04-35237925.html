<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>语言背后的代数学（八）：范畴</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/35237925">原文</a></p>
<p></p><img src="https://pic4.zhimg.com/v2-8fd16e3275832ced282b1a9c125bb8c2_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="775" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><h2><b>回顾</b></h2><p>上文中，我们用群，拓扑空间，CPO作为例子，<br>来说明什么是<b>数学结构</b>，以及数学结构是如何通过映射来保持的。<br>群同态保持了群结构，连续映射保持了拓扑结构，连续函数保持了完全偏序结构。</p><p>那么群结构与拓扑结构之间是否有联系呢？<br>我们能否建立拓扑空间与群之间的对应关系呢？</p><p>在代数拓扑中，就存在这样的例子，<br>人们找到了和拓扑空间相关的群论概念，例如基本群和同调群，<br>拓扑空间的连续映射可以导出这些群的群同态。</p><p>这就为了人们使用代数学方法研究其他数学分支，奠定了基础，<br>实际上，最原始的范畴论想法也是起源于此。</p><h2><b>1. 图示法</b></h2><p>在前一篇中我们学过了<b>幺半群</b>，<br>它指的是一个集合 <equation>M</equation> ，以及 <equation>M</equation> 上的二元运算 <equation>\cdot</equation> ，满足以下两个条件，<br>（1） <equation>\forall x,y,z\in M</equation> ， <equation>(x\cdot y)\cdot z=x\cdot (y\cdot z)</equation> ，<br>（2） <equation>\exists e\in M</equation> ， <equation>\forall x\in M</equation> ， <equation>x\cdot e=e\cdot x=x</equation> 。</p><p>这两个条件除了可以用等式来表示，还可以用<b>图</b>（diagram）来表示，</p><img src="https://pic4.zhimg.com/v2-1bd56c30e34a673a998895029362c270_r.jpg" data-caption="" data-size="normal" data-rawwidth="1138" data-rawheight="234" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>我们称以上两张图都是<b>可交换的</b>（commutative），<br>即，沿着不同的路径进行运算，只要起点和终点相同，则运算的结果就相同。</p><p>例如， <equation>&lt;x,y,z&gt;\mapsto &lt;x,yz&gt;\mapsto x(yz)</equation> ，总是等于 <equation>&lt;x,y,z&gt;\mapsto &lt;xy,z&gt;\mapsto (xy)z</equation> ，<br>即， <equation>x(yz)=(xy)z</equation> ，表明 <equation>M</equation> 中元素的运算满足<b>结合律</b>。</p><p>又例， <equation>&lt;0,x&gt;\mapsto &lt;e,x&gt;\mapsto ex</equation> ，总是等于 <equation>&lt;0,x&gt;\mapsto x</equation> ，即 <equation>ex=x</equation> ，<br> <equation>&lt;x,0&gt;\mapsto &lt;x,e&gt;\mapsto xe</equation> ，总是等于 <equation>&lt;x,0&gt;\mapsto x</equation> ，即 <equation>xe=x</equation> 。<br>因此， <equation>ex=x=xe</equation> ，表明 <equation>M</equation> 中存在<b>幺元</b> <equation>e</equation> 。</p><p>所以，我们可以用以上两个图表，作为幺半群的定义，称为<b>图示法</b>。</p><p>另一方面，考虑在集合论中讨论映射的时候，一般都不写具体元素，还可以表示为，</p><img src="https://pic2.zhimg.com/v2-65f472da6c217b0f01bbc9704f4df946_r.jpg" data-caption="" data-size="normal" data-rawwidth="1070" data-rawheight="218" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>其中， <equation>\mu:M\times M\to M</equation> ， <equation>\eta:1\to M</equation> ，是两个函数， <equation>1=\{0\}</equation> 是只有一个元素的集合。</p><p>用图示法来表示幺半群，更具一般性。</p><h2><b>2. 范畴</b></h2><p>范畴是一个数学概念，也可以用图示法来表示。</p><img src="https://pic3.zhimg.com/v2-07f823a724618aaf5e160d394a7eab6e_r.jpg" data-caption="" data-size="normal" data-rawwidth="178" data-rawheight="161" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>一个<b>范畴</b> <equation>Cat</equation> 由一系列<b>对象</b>（object）和<b>箭头</b>（arrow）组成。<br>对于每一个箭头 <equation>f</equation> ，有两个对象与之关联，<br>称为箭头 <equation>f</equation> 的<b>定义域</b>（domain）和<b>值域</b>（codomain）。</p><p>并且，还要满足以下几条规则，<br>（1）对于每一个对象 <equation>a</equation> ，存在<b>恒等箭头</b>（identity arrow）， <equation>i:a\to a</equation> <br>（2）箭头满足<b>结合律</b>，对于任意的箭头 <equation>f,g,h</equation> ，有 <equation>(f\cdot g)\cdot h=f\cdot (g\cdot h)</equation> <br>（3）箭头的集合在箭头组合运算下是<b>封闭的</b></p><p>其中， <equation>f\cdot g</equation> 表示 <equation>g</equation> 和 <equation>f</equation> 的组合运算，它也是一个箭头，其中 <equation>g</equation> 的值域是 <equation>f</equation> 的定义域。</p><p>例子：<br>所有的集合，以集合为对象，集合之间的映射作为箭头，构成了一个范畴，<br>所有的群，以群作为对象，群同态作为箭头，构成了一个范畴，<br>所有的拓扑空间，以拓扑空间作为对象，拓扑空间之间的连续映射为箭头，构成了一个范畴。</p><p>以上三个例子中，<br>范畴中的对象都是集合，箭头都是映射，这就很容易造成误解。<br>因为，<b>范畴中的对象可以不是集合，箭头也可以不是映射，<br></b>理解这一点至关重要。</p><p>例如，完全偏序 <equation>(D,\leqslant)</equation> ，<br>以 <equation>D</equation> 中的元素作为对象，以 <equation>x\leqslant y</equation> 作为 <equation>x,y</equation> 之间的箭头，同样构成了一个范畴。</p><h2><b>3. 函子</b></h2><p>函子就是两个范畴之间的箭头。</p><img src="https://pic2.zhimg.com/v2-9a2d8a5e543c0e1e27695a353869dda1_r.jpg" data-caption="" data-size="normal" data-rawwidth="436" data-rawheight="243" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>一个<b>函子</b> <equation>F</equation> 是范畴 <equation>C</equation> 到范畴 <equation>D</equation> 的箭头， <equation>F:C\to D</equation> ，它满足以下条件，<br> <equation>F</equation> 把 <equation>C</equation> 中的对象 <equation>c</equation> 映射为 <equation>D</equation> 中的对象 <equation>F~c</equation> ，把 <equation>C</equation> 中的箭头 <equation>f</equation> 映射为 <equation>D</equation> 中的箭头 <equation>F~f</equation> 。<br>并且， <equation>F~(f\cdot g)=(F~f)\cdot (F~g)</equation> 。</p><p>值得注意的是，等式左边的 <equation>\cdot</equation> ，表示 <equation>C</equation> 中的箭头组合运算，<br>等式右边的 <equation>\cdot</equation> ，表示D<i>D</i>中的箭头组合运算。</p><h2><b>4. 自然变换</b></h2><p><b>自然变换</b>（natural transformation）是<b>一族箭头</b>，<br>将范畴 <equation>A</equation> 在一个函子中的像（picture），变换成了另一个函子的像。</p><p>给定两个函子 <equation>S,T:A\to B</equation> ，其中 <equation>A</equation> 和 <equation>B</equation> 是范畴。<br>自然变换的每个<b>分量</b>（components）使下图可交换。</p><img src="https://pic3.zhimg.com/v2-eed0e9ebd54183d14091dd04da29d37f_r.jpg" data-caption="" data-size="normal" data-rawwidth="696" data-rawheight="225" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>其中， <equation>\tau_a</equation> 是 <equation>B</equation> 中的箭头， <equation>\tau_a:Sa\to Ta</equation> 。</p><h2><b>5. Monad</b></h2><p>范畴到自身的函子，称为<b>自函子</b>（endofunctor）。<br>设 <equation>T:X\to X</equation> 是任意范畴 <equation>X</equation> 上的自函子，自函子复合之后仍为自函子，<br> <equation>T^2=T\circ T:X\to X</equation> ， <equation>T^3=T^2\circ T:X\to X</equation> 。</p><p>令 <equation>\mu:T^2\to T</equation> 是一个自然变换，其分量为 <equation>\mu_x:T^2x\to Tx</equation> ， <equation>\forall x\in X</equation> ，<br>则使用 <equation>\mu</equation> 可以定义另外两个自然变换，<br> <equation>T\mu:T^3\to T^2</equation> ，它的分量为 <equation>(T\mu)_x=T(\mu_x):T^3x\to T^2x</equation> ，<br> <equation>\mu T:T^3\to T^2</equation> ，它的分量为 <equation>(\mu T)_x=\mu_{Tx}</equation> 。</p><p>范畴 <equation>X</equation> 上的一个<b>Monad</b>，指的是三元组 <equation>\left \langle T,\eta,\mu \right \rangle</equation> ，它们使下图可交换，</p><img src="https://pic2.zhimg.com/v2-b877301e440b9c0f78a488e7e0022833_r.jpg" data-caption="" data-size="normal" data-rawwidth="732" data-rawheight="194" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>其中， <equation>T:X\to X</equation> 是范畴 <equation>X</equation> 上的自函子， <equation>\eta:I_X\to T</equation> ， <equation>\mu:T^2\to T</equation> 是两个自然变换。</p><p>值得注意的是，Monad与幺半群的图示法是相似的，<br>只需要将幺半群定义中的 <equation>\times</equation> ，改写成自函子的复合运算，<br>把单位集合 <equation>1</equation> ，改写成单位自函子即可。</p><p>因此，我们说<b>Monad是自函子范畴上的一个幺半群</b>。</p><blockquote>All told, a monad in X is just a monoid in the category of endofunctors of X, with product x replaced by composition of endofunctors and unit set by the identity endofunctor.</blockquote><h2><b>6. Hask范畴上的Monad</b></h2><p>如果把Haskell语言中的类型作为对象，把类型之间的函数看做箭头，<br>则在函数复合运算下，构成了一个范畴，称为<b>Hask范畴</b>。</p><p><b>函子</b></p><p>Haskell中类型类（type class）<code class="inline">Functor</code>的每一个实例，定义了Hask范畴中的一个函子。</p><code lang="haskell">class Functor (f :: * -&gt; *) where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code><p><code class="inline">fmap</code>表示了函子作用在箭头上的结果。<br>作用在对象上，可以使用<code class="inline">pure :: a -&gt; f a</code>来表示。</p><p>在Haskell中，一个类型要成为<code class="inline">Functor</code>的实例，还要满足相应的“<a href="https://wiki.haskell.org/Functor#Functor_Laws">Functor Law</a>”，</p><code lang="haskell">fmap id = id
fmap (f . g) = fmap f . fmap g</code><p>可以<a href="https://en.wikibooks.org/wiki/Haskell/Category_theory#Functors">证明</a>，这些“Functor Law”刚好使<code class="inline">f</code>，<code class="inline">fmap</code>和<code class="inline">pure</code>构成了范畴论意义上的函子。</p><p><b>Monad</b></p><p>Haskell中类型类<code class="inline">Monad</code>的每一个实例，定义了Hask范畴中的一个Monad。</p><code lang="haskell">class Functor m =&gt; Monad m where
    return :: a -&gt; m a
    (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</code><p>在Haskell中，一个类型要成为<code class="inline">Monad</code>的实例，还要满足相应的“<a href="https://wiki.haskell.org/Monad#Monad_class">Monad Law</a>”，</p><code lang="haskell">return a &gt;&gt;= k                  =  k a
m        &gt;&gt;= return             =  m
m        &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)  =  (m &gt;&gt;= k) &gt;&gt;= h</code><p>可以<a href="https://en.wikibooks.org/wiki/Haskell/Category_theory#Monads">证明</a>，这些“Monad Law”刚好使<code class="inline">m</code>，<code class="inline">&gt;&gt;=</code>和<code class="inline">return</code>构成了范畴论意义上的Monad。</p><h2><b>总结</b></h2><p>本文介绍了范畴论相关的一些内容，<br>介绍了什么是<b>范畴</b>，什么是<b>函子</b>，什么是<b>自然变换</b>，<br>这些都是理解笛卡尔闭范畴所必须的。</p><p>为了理解什么是范畴，我们列举了前一篇提到的群，拓扑空间，CPO作为例子，<br>还借用了Haskell中的Functor和Monad学习了Hask范畴。</p><p>下文我们将继续学习范畴论，<br>理解什么是笛卡尔闭范畴，以及如何用它解释简单类型 <equation>\lambda</equation> 演算的语义。</p><hr><h2><b>参考</b></h2><p><a href="https://en.wikipedia.org/wiki/Category_(mathematics)">Category (mathematics)</a> <br><a href="https://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell/Category theory</a> <br><a href="https://book.douban.com/subject/1823110/">Categories for the Working Mathematician</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
