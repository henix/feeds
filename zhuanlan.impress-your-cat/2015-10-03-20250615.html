<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[21天]第一章内容提要</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20250615">原文</a></p>
<p><b>把这个发出来，这样大家都可以开始写起来了。写好了，就可以赶紧发Pull Request了。</b></p><p>参考资料 <a class="" data-title="Home · xn--21Erlang-p00o82pmp3o/erlang-for-dummies-zh-cn Wiki · GitHub" data-editable="true" href="https://github.com/xn--21Erlang-p00o82pmp3o/erlang-for-dummies-zh-cn/wiki">Home · xn--21Erlang-p00o82pmp3o/erlang-for-dummies-zh-cn Wiki · GitHub</a></p><p>在第一章之前会简单介绍Erlang最最基本的功能，也就是函数和模式匹配</p><p>以下是第一章内容提要。注意不是目录，有些是正文，有些是习题，且不保证严格按这个顺序来。</p><p><br>1. 写一个最原始的Lisp解释器<br>2. 加pattern matching<br>3. 用Erlang解释之前写的Erlang代码<br>4. 改写之前的解释器，改成自己维护call stack<br>5. 写一个程序，来完成4的工作<br>6. 加回溯<br>7. pattern matching升级成unification<br>8. 改成Prolog那样，以predicate为主的风格 (此时只有AST)<br>9. 用Prolog写Parser(DCG风格)来parse Prolog代码(这样就可以直接从Prolog代码开始了)<br>10. 让这个Prolog解释器足够解释大部分99 Prolog Problems里的答案<br>11. 让这个Prolog解释器足够解释Erlang解释器最早的原型<br>### Prolog太难用了，我们需要Datalog ###<br>12. Datalog之Naive/Semi Naive Evaluation<br>13. Datalog之QSQI<br>14. Datalog之Magic Set<br>15. Datalog之OLDT/SLG<br>### Datalog也可以是Parser，扔掉DCG了 ###<br>16.  从Datalog到CYK/Earley<br>17. 改成LR<br>18. 改成正则表达式<br>### 加一点backtracking回来 ###<br>19. Packrat<br>20. PCRE风格的Regex<br>### 来写个Shell ###<br>21. Erlang I/O protocol<br>22. 第一章这么快就结束了，简单回顾一下</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
