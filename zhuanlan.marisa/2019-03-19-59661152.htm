<div class="title-image"><img src="https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_b.jpg" alt=""></div><p>到目前为止，我们已经讨论了相当多种 recursion schemes。Catamorphism 和 Anamorphisms 对数据结构进行折叠和展开。Paramorphisms 和 Apomorphisms 在维持上述操作的同时还能保持额外的信息，而 Histomorphisms 和 Futumorphisms 可以让我们在折叠时使用历史的信息，或者在展开时使用自定义的控制流。</p><p>对于每种折叠操作 <code>cata</code>，<code>para</code>，<code>histo</code>，我们通过“翻转箭头”来导出对应的展开操作。更正式一点地说，我们实际上求解的是折叠操作范畴上的对偶操作。现在我们知道可以通过折叠操作来导出展开操作（反之亦然）。再加上函数的组合性质，一个新的问题呼之欲出“如果我们把展开操作和折叠操作组合起来会发生什么？”我们这次就来讨论这个问题。（这篇文章的所以代码均使用 Haskell，所有出现的代码均可以在<a href="http://link.zhihu.com/?target=https%3A//github.com/patrickt/recschemes/blob/master/src/Part5.lhs" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a>找到）</p><h2>折叠与基质</h2><p>Meijer et. al 在 <a href="http://link.zhihu.com/?target=https%3A//maartenfokkinga.github.io/utwente/mmf91m.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">Bananas, Lenses, Envelopes, and Barbed Wire</a> 中回答了这一问题，我们首先从一个种子数值里生成某种数据结构，接着在该数据结构上通过折叠计算最终结果，这样得到的复合操作我们称为 Hylomorphism[1]，这个名字实在难以直观理解，我更喜欢将这一方法称为‘生产者消费者方法’，其中展开操作负责生产，而折叠操作则负责消费。</p><p>如果你理解了之前的关于 Catamorphism（折叠）与 Anamorphism（展开）的概念，那么 Hylomorphism 是非常简单的。就是后者紧接着前者即可，所以容易得到：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">hylo</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">Algebra</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Coalgebra</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">hylo</span> <span class="n">alg</span> <span class="n">coalg</span> <span class="ow">=</span> <span class="n">ana</span> <span class="n">coalg</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">cata</span> <span class="n">alg</span>
</code></pre></div><p>非常直观，对吧？<code>ana</code> 负责展开并提供 coalgebra，<code>cata</code> 负责折叠并提供 algebra。</p><p>Hylomorphism 中的 hylo 来做 希腊语 hyle， ὕλη，意思是基质。古希腊人用基质代表一个物体产生之前的原料，我们这里的 Hylomorphism 正是作为某种将基质转换为最终结果的函数。</p><p>有趣的一点是 <code>Term</code>，作为 <code>Functor</code> 的不动点，在 <code>hylo</code> 的函数签名中并没有出现。尽管 <code>ana</code> 和 <code>cata</code> 的函数签名中均包含 <code>Term f</code>，但它在最终的函数签名中被抵消掉了，唯一必要的是一个可以生成 algebra 和 coalgebra 的 <code>Functor</code>。类似地，在 Kmett 的<a href="http://link.zhihu.com/?target=https%3A//hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html%23v%3Ahylo" class=" wrap external" target="_blank" rel="nofollow noreferrer">形式化</a>中，<code>hylo</code> 也不使用 <code>Base</code> 函子。</p><h2>形形色色的 Hylo</h2><p>Hylomorphism 并不仅仅是一个漂亮的理论结果，它可以被看做是许多我们日常计算的抽象，一个陈词滥调的例子是阶乘函数。单实际上 Hylo 的能力远不仅仅于此，尽管我们常常未能注意到这一一般性，我们在各个地方都会使用 hylomorphism：</p><ol><li>聚合某些数据结构的属性，比如决定一组数据的平均数或是中位数</li><li>从某种文字嵌套结构中解释或编译得到最终结果</li><li>实现递归的分治结构，比如快速排序，归并排序，甚至于快速傅里叶变换</li><li>计算两种结构上的差异，比如字符串的编辑距离或莱文斯坦距离</li></ol><p>我们来看一个 <code>hylo</code> 的实践例子。我们使用 <code>hylo</code> 来搭建一个<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Reverse_Polish_notation" class=" wrap external" target="_blank" rel="nofollow noreferrer">逆波兰表达式计算器</a>。给出字符串 <code>1 2 +</code>，我们应该计算 <code>1 + 2</code>，而 <code>2 1 12 3 / - +</code> 则对应 <code>2 + 1 - 12 / 3</code>：每个逆波兰表达式都有唯一确定的解析形式，使用逆波兰表达式可以不使用中缀表达式中我们常见的括号。我们的 coalgebra 会将一个字符串展开为操作的列表，接着 algrbra 会消费这个列表，从而得到一个一组计算结果。</p><p>如前所述，我们的逆波兰表达式的计算器包括两种值：数值运算或整数字面量。我们定义 <code>Token</code> 类型来表示：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Token</span>
  <span class="ow">=</span> <span class="kt">Lit</span> <span class="kt">Int</span>
  <span class="o">|</span> <span class="kt">Op</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span>
</code></pre></div><p>注意到我们的构造函数里包括一个函数 <code>Int -&gt; Int -&gt; Int</code>，而非一个字符串表示，由于函数没有有意义的字符串表示，导致 <code>Token</code> 不是 <code>Show</code> 的一个实例。但这样会简化我们的实现，当我们需要使用这个函数时，我们只需从栈中弹出这个函数，并直接应用计算即可。</p><p>我们还需要将字符串解析为 <code>Token</code>，正统一点的做法将是使用一个解析函数库，例如 <code><a href="http://link.zhihu.com/?target=https%3A//hackage.haskell.org/package/megaparsec" class=" wrap external" target="_blank" rel="nofollow noreferrer">megaparsec</a></code>或 <code><a href="http://link.zhihu.com/?target=https%3A//hackage.haskell.org/package/trifecta" class=" wrap external" target="_blank" rel="nofollow noreferrer">trifecta</a></code> 甚至使用 <code>Maybe</code> 函子去做错误处理。但这里出于代码简洁性考虑，我们就简单地使用 <code>read</code>，如果有不合法数据，就直接抛出运行时错误。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">parseToken</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Token</span>
<span class="nf">parseToken</span> <span class="s">"+"</span> <span class="ow">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
<span class="nf">parseToken</span> <span class="s">"-"</span> <span class="ow">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span>
<span class="nf">parseToken</span> <span class="s">"*"</span> <span class="ow">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="nf">parseToken</span> <span class="s">"/"</span> <span class="ow">=</span> <span class="kt">Op</span> <span class="n">div</span>
<span class="nf">parseToken</span> <span class="n">num</span> <span class="ow">=</span> <span class="kt">Lit</span> <span class="o">$</span> <span class="n">read</span> <span class="n">num</span>
</code></pre></div><p>代码很好理解，我们使用模式匹配得到对应的数学表达式，放入 <code>Op</code> 中，如果是数字的话，我们使用 <code>read</code> 来获取 <code>Int</code> 包裹成字面量。</p><p>一个先进先出的栈在 Haskell 中可以很好地用列表来表示，<code>push</code> 操作使用 <code>:</code>，<code>pop</code> 操作可以使用 <code>tail</code> 即可。尽管上一章中我们讨论了如何使用 <code>Base</code> 类型类来使 Haskell 中的 <code>[]</code> 兼容 recursion schemes。但我们还是在这里使用我们自己定义的方式。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="n">b</span>
  <span class="ow">=</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="n">b</span>
  <span class="o">|</span> <span class="kt">Nil</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Functor</span><span class="p">)</span>
</code></pre></div><p>现在我们已经有了 <code>List</code> 用来存放 <code>Token</code>，那么我们下一步就要定义 <code>Coalgebra</code> 来从 <code>String</code> 中得到 <code>Token</code>。回忆我们此前 <code>Coalgebra</code> 的定义：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Coalgebra</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div><p>这里的种子值 <code>a</code> 为 <code>String</code>，而 <code>f</code> 为 <code>List Token</code>，我们将类型签名代入 <code>Coalgebra</code>：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">parseRPN</span> <span class="ow">::</span> <span class="kt">Coalgebra</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Token</span><span class="p">)</span> <span class="kt">String</span>
</code></pre></div><p>记住 <code>List Token</code> 是部分应用的，它的签名是 <code>* -&gt; * -&gt; *</code>，所以 <code>f a</code> 是 <code>List Token String</code>：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">parseRPN</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="kt">Token</span> <span class="kt">String</span>
</code></pre></div><p>这样也是合理的，在每一步，我们展开列表中的元素，并得到 <code>Token</code>，以及其余需要解析的 <code>String</code> 直到我们得到 <code>Nil</code>，这时我们就停止展开，因为 <code>Nil</code> 也是 <code>List Token String</code>。</p><p>现在我们来实现 <code>rpn</code> 的函数体。最简单地情况是处理空字符串，对于空字符串我们不需要做任何展开，直接返回 <code>Nil</code> 即可。（<code>ana</code> 知道在遇到 <code>Nil</code> 时停止递归是因为递归的 <code>fmap</code> 在这时会停止，<code>Nil</code> 不包含其它子节点）</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">parseRPN</span> <span class="s">""</span> <span class="ow">=</span> <span class="kt">Nil</span>
</code></pre></div><p>对于非空字符串的情形会更有趣一些，我们首先从字符串 <code>str</code> 中按空格分割，并将第一段传给 <code>parseToken</code>，将结果 <code>Cons</code> 的 <code>a</code> 部分，而将剩余的字符串作为 <code>b</code> 部分。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">parseRPN</span> <span class="n">str</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="n">token</span> <span class="n">newSeed</span>
  <span class="kr">where</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">span</span> <span class="p">(</span><span class="n">not</span> <span class="o">.</span> <span class="n">isSpace</span><span class="p">)</span> <span class="n">str</span>
        <span class="n">token</span>     <span class="ow">=</span> <span class="n">parseToken</span> <span class="n">x</span>
        <span class="n">newSeed</span>   <span class="ow">=</span> <span class="n">dropWhile</span> <span class="n">isSpace</span> <span class="n">rest</span>
</code></pre></div><p>将两种情况合并起来：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">parseRPN</span> <span class="ow">::</span> <span class="kt">Coalgebra</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Token</span><span class="p">)</span> <span class="kt">String</span>
<span class="nf">parseRPN</span> <span class="s">""</span>  <span class="ow">=</span> <span class="kt">Nil</span>
<span class="nf">parseRPN</span> <span class="n">str</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="n">token</span> <span class="n">newSeed</span>
  <span class="kr">where</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">span</span> <span class="p">(</span><span class="n">not</span> <span class="o">.</span> <span class="n">isSpace</span><span class="p">)</span> <span class="n">str</span>
        <span class="n">token</span>     <span class="ow">=</span> <span class="n">parseToken</span> <span class="n">x</span>
        <span class="n">newSeed</span>   <span class="ow">=</span> <span class="n">dropWhile</span> <span class="n">isSpace</span> <span class="n">rest</span>
</code></pre></div><p>看起来还不错，仅仅只有六行代码，如果输入是 <code>3 4 +</code>，我们运行 <code>ana parseRPN</code>，就会得到与列表 <code>Lit 3, Lit 4, Op +, Nil</code> 等价的结果。</p><p>现在我们还要实现 <code>Algebra</code>：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Algebra</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</code></pre></div><p>我们这里的 <code>f</code> 也将是 <code>List Token</code>，但是 <code>a</code> 是不一样的，我们希望这里的类型是一个整数栈，既可以压元素入栈，也可以使用 <code>Op</code> 来操作。具体的定义如下：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Stack</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
</code></pre></div><p>那么代入类型签名得到：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">evalRPN</span> <span class="ow">::</span> <span class="kt">Algebra</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Token</span><span class="p">)</span> <span class="kt">Stack</span>
</code></pre></div><p>但这时我们遇上了问题，考虑一个逆波兰表达式 <code>2 3 +</code> 或 <code>4 2 5 * + 1 3 2 * + /</code>，我们需要由左向右求解，将字面量压入栈中，接着对于栈顶的两个元素应用操作，这意味着我们的求值器必须由左向右进行计算（类似 <code>foldl</code>）而不能由右向左计算（即 <code>foldr</code>）。但我们的 <code>cata</code> 是右折叠的，它一直递归到 <code>Nil</code> 元素，并从这里开始向上传递结果。而 <code>holy</code> 并没有给我们逆转解析完成的数组的机会，我们该怎么解决这个问题呢？ </p><p>答案也很简单，我们并不会使用一般的 <code>Stack</code> 元素作为返回值。而是返回一个由 <code>Stack</code> 到 <code>Stack</code> 的函数：<code>Stack -&gt; Stack</code>。而对于最后返回的函数，我们使用一个空栈来激活计算并获得最终结果。<i>因为最左边的元素是最晚处理的，所以得到的结果函数中会最先处理最左边的元素</i>。这样我们就可以由左到右完成计算，直到 <code>Nil</code>。而这一函数的输入参数就是计算使用的初始值。</p><p>下图也许能够对于理解这一问题有所帮助：</p><p><br></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1022" data-rawheight="766" class="origin_image zh-lightbox-thumb" width="1022" data-original="https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_b.jpg" data-caption="" data-size="normal" data-rawwidth="1022" data-rawheight="766" class="origin_image zh-lightbox-thumb lazy" width="1022" data-original="https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-38cfb2f3b18c0bfcb23f90ba766ce04d_b.jpg"></figure><p><br></p><p>构建过程如蓝线所示：自右向左构建函数，初始函数为 id，并对后续元素不断调用 algebra 来获取之后生成的函数。 1. cata 函数从这里进入，并递归只最右侧。 2. 从最右侧元素开始自右向左构建返回函数。 求值过程如红线所示：函数最先操作最后生成的节点，由左向右进行。 3. 函数调用位置为 cata 函数结束的位置，自左向右完成调用。 4. 最后获得最终结果 [9]。</p><p>通过将返还值改为返回函数，我们就可以将 cata 的由右至左求值顺序改写为由左至右求值，这一过程往往令人疑惑。通过改变返回值我们增强了 <code>cata</code> 的能力。而这一个在函数式编程领域人所共知的技巧。而这里的 <code>Stack</code> 就是某种差分结构，一如 Haskell 中 <code>Show</code> 的实现。</p><p>下面我们使用 <code>Stack -&gt; Stack</code> 改写下上面的代码：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">evalRPN</span> <span class="ow">::</span> <span class="kt">Algebra</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Token</span><span class="p">)</span> <span class="p">(</span><span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="kt">Stack</span><span class="p">)</span>
</code></pre></div><p>我们展开 <code>Algebra</code>：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">evalRPN</span> <span class="ow">::</span> <span class="kt">List</span> <span class="kt">Token</span> <span class="p">(</span><span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="kt">Stack</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="kt">Stack</span><span class="p">)</span>
</code></pre></div><p>在实现时我们需要考虑 <code>Nil</code> 和 <code>Cons</code> 两种情况，<code>Nil</code> 的情况比较简单，我们只需要返回同样的函数即可，因为没有任何需要对原函数进行更改的地方。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">evalRPN</span> <span class="kt">Nil</span> <span class="n">stack</span> <span class="ow">=</span> <span class="n">stack</span> <span class="c1">-- 即 `id`</span>
</code></pre></div><p>尽管这里我们需要返回的是一个函数，但我们可以将它的参数 <code>Stack</code> 视为 <code>evalRPN</code> 的参数[2]。</p><p>下面我们处理需要修改 <code>Stack</code> 值的情况。对于一个包含整数的 <code>Lit</code> 字面量，为了使 <code>Stack -&gt; Stack</code> 方法运行下去，我们只需将当前值压入栈中，并使用之后的函数进行调用即可。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">evalRPN</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">i</span><span class="p">)</span> <span class="n">cont</span><span class="p">)</span> <span class="n">stack</span> <span class="ow">=</span> <span class="n">cont</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="n">stack</span><span class="p">)</span>
</code></pre></div><p>对于 <code>Op</code> 的情况是类似的，我们提取 <code>stack</code> 的头部两个元素，接着应用到 <code>Op</code> 上，在将结果压回栈中：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">evalRPN</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">i</span><span class="p">)</span> <span class="n">cont</span><span class="p">)</span> <span class="n">stack</span> <span class="ow">=</span> <span class="n">cont</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="n">stack</span><span class="p">)</span>
</code></pre></div><p>对于其他情况，我们直接报错退出[3]：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">evalRPN</span> <span class="kr">_</span> <span class="n">stack</span> <span class="ow">=</span> <span class="ne">error</span> <span class="p">(</span><span class="s">"too few arguments on stack: "</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">stack</span><span class="p">)</span>
</code></pre></div><p>现在我们合并起来看一下：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">evalRPN</span> <span class="ow">::</span> <span class="kt">Algebra</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Token</span><span class="p">)</span> <span class="p">(</span><span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="kt">Stack</span><span class="p">)</span>
<span class="nf">evalRPN</span> <span class="kt">Nil</span> <span class="n">stack</span>                      <span class="ow">=</span> <span class="n">stack</span>
<span class="nf">evalRPN</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">i</span><span class="p">)</span> <span class="n">cont</span><span class="p">)</span> <span class="n">stack</span>      <span class="ow">=</span> <span class="n">cont</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="n">stack</span><span class="p">)</span>
<span class="nf">evalRPN</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">fn</span><span class="p">)</span> <span class="n">cont</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">b</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">cont</span> <span class="p">(</span><span class="n">fn</span> <span class="n">b</span> <span class="n">a</span> <span class="kt">:</span> <span class="n">rest</span><span class="p">)</span>
<span class="nf">evalRPN</span> <span class="kr">_</span> <span class="n">stack</span>                        <span class="ow">=</span> <span class="ne">error</span> <span class="p">(</span><span class="s">"too few arguments on stack: "</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">stack</span><span class="p">)</span>
</code></pre></div><p>这样我们可以清晰地看到，求值的过程会在 <code>Nil</code> 处停止，而在 <code>Cons</code> 中通过 <code>cont</code> 的调用传递下去。</p><p>下面我们在 GHCi 中将 <code>parseRPN</code> 和 <code>evalRPN</code> 传入 <code>hylo</code>，并显示函数的类型：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">λ</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">hylo</span> <span class="n">evalRPN</span> <span class="n">parseRPN</span>
<span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="kt">Stack</span>
</code></pre></div><p>这也是合理的，<code>String</code> 是我们初始需要解析的字符串，<code>Stack</code> 是 RPN 栈的初始状态，因此我们可以再封装一层，以空列表作为栈的初始状态：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">rpn</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Stack</span>
<span class="nf">rpn</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">hylo</span> <span class="n">evalRPN</span> <span class="n">parseRPN</span> <span class="n">s</span> <span class="kt">[]</span>
</code></pre></div><p>下面我们做一个简单测试，如果在 GHCi 中调用：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">λ</span><span class="o">&gt;</span> <span class="n">rpn</span> <span class="s">"15 7 1 1 + - / 3 * 2 1 1 + + -"</span>
</code></pre></div><p>得到：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div><p>完美。</p><p>尽管 RPN 计算器并没有多么复杂，但我们的实现显示出了 recursion schemes 的本质：是我们在<i>做什么</i>和我们<i>怎么做</i>分离开，这使我们得以把精力放到问题的主要部分解析字符串和栈操作上，而无需关心数据是怎样完成遍历的。这些机制全部包含在了 <code>hylo</code> 内部，而我们只需要关心问题的本质即可。</p><h2>深度优化</h2><p>实际上我们不需要调用 <code>cata</code> 或 <code>ana</code> 而仅仅使用 algrbra 和 coalgebra 就能表示 Hylomorphism。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">hylo'</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">Algebra</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Coalgebra</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">hylo'</span> <span class="n">alg</span> <span class="n">coalg</span> <span class="ow">=</span> <span class="n">coalg</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">hylo'</span> <span class="n">alg</span> <span class="n">coalg</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">alg</span>
</code></pre></div><p>尽管这样的实现不能清晰地看出 Hylomorphism 是 Anamorphism 和 Catamorphism 的组合，但是这样做也有好处：我们对 <code>fmap</code> 的调用会降低到原来的一半。</p><p>对于我们之前的定义，<code>hylo</code> 使用 <code>ana</code> 展开 <code>List</code> 需要调用 n 次 <code>fmap</code>，其中 n 为 <code>Token</code> 的个数。接着折叠的时候，<code>cata</code> 需要再调用 n 次 <code>fmap</code>。而在我们新的定义中，<code>fmap</code> 的调用次数下降为 n 次，我们在每次展开后立即进行折叠，每一层的结构会直接在 <code>coalg</code> 展开后被 <code>alg</code> 所调用。这项优化对于嵌套结构很深的数据类型能显著提升运行速度。</p><h2>时不我待</h2><p>尽管 Meijer 等人在介绍 Catamorphism 和 Anamorphism 时就引入了 Hylomorphism，但 Uustalu 和 Vene 的论文却没有讨论组合 Histomorphism 和 Futumorphism 会发生什么。直到整整九年后，Edward Kmett 在 #haskell IRC 频道中，将其命名为 Chronomorphism —— chrono（χρόνος）是一个表示时间的词缀。</p><p>Chronomorphism 的定义与 Hylomorphism 类似：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">chrono</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">CVAlgebra</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">CVCoalgebra</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">chrono</span> <span class="n">cvalg</span> <span class="n">cvcoalg</span> <span class="ow">=</span> <span class="n">futu</span> <span class="n">cvcoalg</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">histo</span> <span class="n">cvalg</span>
</code></pre></div><p>非常直观地：<code>futu</code> 展开一个多层的数据结构，接着 <code>histo</code> 负责折叠数据。</p><p>然而不幸地是，Chronomorphism 并不像 Hylomorphism 那样具有丰富地应用实例。我们在之前文章中提到的生命游戏或许是个很接近的例子，我们使用 Futumorphism 来生成植物生命，但我们只需使用 Catamorphism 来将它打印出来。当然我们可以用 Histomorphism 来代替 Catamorphism，但我们并没有使用这样带来的红利。我一直未能找到一个有意义的使用 <code>chrono</code> 的场景，如果你发现了可以联系我。但是至少 Chronomorphism 的发明者也<a href="http://link.zhihu.com/?target=https%3A//twitter.com/kmett/status/318410115101380608" class=" wrap external" target="_blank" rel="nofollow noreferrer">想不到合适的例子</a>。不过 <code>chrono</code> 可以用于实现 <code>dynamorphism</code>，这是一种为动态规划问题特化的递归模板。我们或许会在下篇文章中进行介绍。（或许 Uustalu 和 Vene 正是因为无法找到合理的应用，而没有提及它）</p><h2>Elgot Algebra 的优化</h2><p>Histomorphism 清晰地分离了 “做什么” 和 “怎样做” 这两个问题，但在实践中，有时我们在构造数据时会发现输入数据与预期不符，或者在解析数据时会有可以优化的状态。</p><p>我们当然可以结合去 <code>hylo</code> 错误处理的函子来表达这一模式，但 Jiří Adámek，Stefan Milius 和 Jiří Velebil 在他们的文章中提出了一个更好的解决方案，<a href="http://link.zhihu.com/?target=https%3A//arxiv.org/pdf/cs/0609040.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">Elgot Algebra</a>，在范畴论的框架下为这个问题提供了解决方案，从而避免避免使用错误处理的手段。其命名来源于美国数学家 Calvin Elgot，他致力于弥合数学与软件工程间上的差距。Elgot Algebra 和 CoAlgebra 对 Hylomorphism，Catamorphism 和 Anamorphism 作了泛化，使其更加简洁和实用。文章本身非常的<i>困难</i>。但是 Kmett 一如既往地为社区做出贡献，将其转化为了 Haskell 的代码。</p><p>让我们考虑一个将 <code>Algebra</code> 和 <code>CoAlgebra</code> 均代入后得到的 <code>hylo</code> 的类型签名：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">hylo</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</code></pre></div><p>这个方法告诉我们，给出一个 <code>a</code> 的 F-CoAlgebra 以及一个 <code>b</code> 的 F-Algebra，怎样从 <code>a</code> 得到 <code>b</code>。但是如果我们有捷径呢？我们可以直接短接掉整个 Hylomorphism，而返回 <code>b</code>。然后我们可以直接使用 <code>hylo</code> 来描述这样的短路，而不需要引入 <code>Maybe</code>，<code>Either</code> 这些函子。</p><p>为了达到这个目的，<code>a -&gt; f a</code> 必须支持返回两种值，<code>f a</code> 或 <code>b</code> 来用于短接，显然 Haskell 提供了 <code>Either</code> 功能来完成这一工作。我们把 <code>Elgot</code> 改写如下：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">elgot</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">Algebra</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">b</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</code></pre></div><p>我们需要一个辅助函数来定义 Elgot Algebra，给出函数 <code>b -&gt; a</code>，和函数 <code>c -&gt; a</code>，得到一个 <code>Either b c</code> 返回 <code>a</code> 的函数。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="p">(</span><span class="o">|||</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div><p>我们可以将这个函数当做或操作的升级版，它操作的是函数 <code>f</code> 或 <code>g</code>。</p><p>我们可以直接从之前 <code>hylo</code> 的定义推导出 <code>elgot</code>，如果我们得到 <code>Right</code> 值则继续进行递归。这一部分与 <code>hylo</code> 表现一致。而如果我们得到 <code>Left</code> 值，则我们停止递归并跳出。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">elgot</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">Algebra</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">b</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">elgot</span> <span class="n">alg</span> <span class="n">coalg</span> <span class="ow">=</span> <span class="n">coalg</span> <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">id</span> <span class="o">|||</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">elgot</span> <span class="n">alg</span> <span class="n">coalg</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">alg</span><span class="p">))</span>
</code></pre></div><p>我们使用 Elgot Algebra 为 RPN 计算器带来更多的安全性。我们不使用 <code>error</code> 而自定义一下成功和失败的类型。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">data</span> <span class="kt">Result</span>
  <span class="ow">=</span> <span class="kt">Success</span> <span class="kt">Stack</span>
  <span class="o">|</span> <span class="kt">ParseError</span> <span class="kt">String</span>
  <span class="o">|</span> <span class="kt">TooFewArguments</span> <span class="kt">Stack</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</code></pre></div><p>正如上文我们所提到的，我们依然要使用 CPS 风格，但是不是一个 <code>Stack</code> 的函数，而是一个 <code>Result</code> 的函数。为了简便起见，我们定义</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Cont</span> <span class="ow">=</span> <span class="kt">Result</span> <span class="ow">-&gt;</span> <span class="kt">Result</span>
</code></pre></div><p>这里我们重写 <code>parseToken</code>，我们使用 <code>readMaybe</code> 来获取 <code>Maybe Int</code>，接着其转换为 <code>Either</code> 类型。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">safeToken</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">Cont</span> <span class="kt">Token</span>
<span class="nf">safeToken</span> <span class="s">"+"</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="kt">Op</span> <span class="p">(</span><span class="o">+</span><span class="p">))</span>
<span class="nf">safeToken</span> <span class="s">"-"</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="kt">Op</span> <span class="p">(</span><span class="o">-</span><span class="p">))</span>
<span class="nf">safeToken</span> <span class="s">"*"</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="kt">Op</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span>
<span class="nf">safeToken</span> <span class="s">"/"</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">div</span><span class="p">)</span>
<span class="nf">safeToken</span> <span class="n">str</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">readMaybe</span> <span class="n">str</span> <span class="kr">of</span>
  <span class="kt">Just</span> <span class="n">num</span> <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">num</span><span class="p">)</span>
  <span class="kt">Nothing</span>  <span class="ow">-&gt;</span> <span class="kt">Left</span>  <span class="p">(</span><span class="n">const</span> <span class="p">(</span><span class="kt">ParseError</span> <span class="n">str</span><span class="p">))</span>
</code></pre></div><p>与之类似，<code>parseRPN</code> 可以重写为 <code>safeRPN</code>，<code>parsed</code> 作为 <code>Right</code> 值而使用 do 语法隐式处理 <code>Left</code> 值。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">safeRPN</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">Cont</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Token</span> <span class="kt">String</span><span class="p">)</span>
<span class="nf">safeRPN</span> <span class="s">""</span>  <span class="ow">=</span> <span class="n">return</span> <span class="kt">Nil</span>
<span class="nf">safeRPN</span> <span class="n">str</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">span</span> <span class="p">(</span><span class="n">not</span> <span class="o">.</span> <span class="n">isSpace</span><span class="p">)</span> <span class="n">str</span>
  <span class="kr">let</span> <span class="n">newSeed</span>   <span class="ow">=</span> <span class="n">dropWhile</span> <span class="n">isSpace</span> <span class="n">rest</span>
  <span class="n">parsed</span> <span class="ow">&lt;-</span> <span class="n">safeToken</span> <span class="n">x</span>
  <span class="n">return</span> <span class="o">$</span> <span class="kt">Cons</span> <span class="n">parsed</span> <span class="n">newSeed</span>
</code></pre></div><p>同样我们要重写 <code>safeEval</code> 这里需要使用模式匹配来处理 <code>Success</code> 的值，当函数调用参数不足时，我们可以使用 <code>TooFewArguments</code> 来作为值：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">safeEval</span> <span class="ow">::</span> <span class="kt">Algebra</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Token</span><span class="p">)</span> <span class="kt">Cont</span>
<span class="nf">safeEval</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">i</span><span class="p">)</span> <span class="n">cont</span><span class="p">)</span> <span class="p">(</span><span class="kt">Success</span> <span class="n">stack</span><span class="p">)</span> <span class="ow">=</span> <span class="n">cont</span> <span class="p">(</span><span class="kt">Success</span> <span class="p">(</span><span class="n">i</span> <span class="kt">:</span> <span class="n">stack</span><span class="p">))</span>
<span class="nf">safeEval</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">fn</span><span class="p">)</span> <span class="n">cont</span><span class="p">)</span> <span class="p">(</span><span class="kt">Success</span> <span class="n">s</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">cont</span> <span class="p">(</span><span class="kr">case</span> <span class="n">s</span> <span class="kr">of</span>
  <span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">b</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Success</span> <span class="p">(</span><span class="n">fn</span> <span class="n">b</span> <span class="n">a</span> <span class="kt">:</span> <span class="n">rest</span><span class="p">)</span>
  <span class="kr">_</span>          <span class="ow">-&gt;</span> <span class="kt">TooFewArguments</span> <span class="n">s</span><span class="p">)</span>
<span class="nf">safeEval</span> <span class="kr">_</span> <span class="n">result</span>  <span class="ow">=</span> <span class="n">result</span>
</code></pre></div><p>这样我们可以隐式的处理这些错误，并且不需要调用 <code>throw</code> 等就可以错误处理模式。</p><p>而对它的调用是十分简单的，我们只需将 <code>hylo</code> 替换为 <code>elgot</code>，并且使用空 <code>Success</code> 即可求值。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">safeRPN</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Result</span>
<span class="nf">safeRPN</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">elgot</span> <span class="n">safeEval</span> <span class="n">safeParse</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Success</span> <span class="kt">[]</span><span class="p">)</span>
</code></pre></div><p>其他使用了 Elgot Algebra 的工作非常少，Vanessa McHale 在她的<a href="http://link.zhihu.com/?target=http%3A//blog.vmchale.com/article/elgot-performance" class=" wrap external" target="_blank" rel="nofollow noreferrer">博客</a>中有一个用来计算<a href="http://link.zhihu.com/?target=https%3A//esolangs.org/wiki/Collatz_sequence" class=" wrap external" target="_blank" rel="nofollow noreferrer">Collatz 序列</a>的例子，文章表明，这样的实现与同样效果的基于 rust 的底层实现计算能力上是相近的。</p><h2>再次翻转箭头</h2><p>在上面定义 <code>elgot</code> 时，我们使用了 <code>|||</code> 来表达区分左右值的情况，同样我们也可以在这里进行翻转箭头的操作，折叠就会变成展开，而对 Elgot Algebra 进行翻转箭头，我们就可以得到可以在折叠时短路的 Hylomorphism。</p><p>翻转箭头的把戏与我们之前常见的相同，<code>alg</code> 变为 <code>coalg</code>，<code>&gt;&gt;&gt;</code> 变为 <code>&lt;&lt;&lt;</code>，而 <code>|||</code> 的对偶稍微有些棘手，还记得之前 <code>Either a b</code> 的对偶是元祖 <code>(a,b)</code> 吗？所以相应对偶是 <code>&amp;&amp;&amp;</code>:</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="p">(</span><span class="o">&amp;&amp;&amp;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
</code></pre></div><p>由此我们可以得到 Coelgot：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">coelgot</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">coelgot</span> <span class="n">alg</span> <span class="n">coalg</span> <span class="ow">=</span> <span class="n">alg</span> <span class="o">&lt;&lt;&lt;</span> <span class="p">(</span><span class="n">id</span> <span class="o">&amp;&amp;&amp;</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">coelgot</span> <span class="n">alg</span> <span class="n">coalg</span><span class="p">)</span> <span class="o">&lt;&lt;&lt;</span> <span class="n">coalg</span><span class="p">))</span>
</code></pre></div><p>所以我们可以将 Elgot Algebra 看作是 <code>RCoalgebra</code> 和 <code>Algebra</code> 的结合，而对偶地来讲，我们可以将 Elgot Coalgebra 看作是 <code>RAlgebra</code> 和 <code>Coalgebra</code> 的结合，那么我们甚至可以构建更加强大的 <code>RAlgebra</code> 与 <code>RCoalgebra</code> 的结合：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">hypo</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">RAlgebra</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">RCoalgebra</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">hypo</span> <span class="n">ralg</span> <span class="n">rcoalg</span> <span class="ow">=</span> <span class="n">apo</span> <span class="n">rcoalg</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">para</span> <span class="n">ralg</span>
</code></pre></div><p>就我所知来讲，这一构造形式尚未被命名，我们把它称为 Hypomorphism，之后的工作与 <code>hylo</code> 类似，这里留作练习，不在赘述。</p><h2>致谢</h2><p>我要感谢 Manuel Chakravarty 为这个系列做的严谨的校对，以及 Colin Barrett，Ross Angle 和 Scott Voke 为本系列提出的宝贵意见。</p><p>我还要感谢读者们耐心地读到了这里，下一篇文章中，我们将讨论折叠展开这些操作的本质，以及如何抓住这些本质，来使上面的种种 Recursion Schemes 可以更快地运行。</p><h2>译者的话</h2><p>首先抱歉拖更了这么久，译者原本的翻译计划本来到此为止的，但是原文作者在上个月似乎又更新了一篇，所以，本着不挖坑的想法，应该会把下一篇也翻译一下。之后的专栏更新可能会考虑做一些函数编程的工程实践，或者从范畴论的角度讨论一下“翻转箭头”的本质。两个方向的内容笔者目前都在做，具体情况需要再看看。</p><p>最后打个广告，下面是笔者建的一个范畴论讨论电报群，主要希望能为正在学习范畴论的新手，提供一个迅速交流的地方，欢迎大家加入~</p><blockquote><a href="http://link.zhihu.com/?target=http%3A//t.me/wecattheory" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">t.me/wecattheory</span><span class="invisible"></span></a><br> </blockquote><p>[1]:如果你在谷歌上搜索 Hylomorphism，那么很有可能你的结果中只包括亚里士多德提出在他的哲学理论中提出的同名<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Hylomorphism" class=" wrap external" target="_blank" rel="nofollow noreferrer">哲学概念</a>。尽管这一理论与 recursion schemes 并无关联，我们仍然要解释一下为什么这一命名对于我们定义的这一复合计算是适当的。 </p><p>[2]:换句话说 Haskell 对于 <code>a -&gt; b -&gt; c</code> 和 <code>a -&gt; (b -&gt; c)</code> 两者在语法表示上并无差别。 </p><p>[3]:如果我们小心地选取初始值来保持栈中始终有足够元素，比如将初始值设为无限长的列表 [0, 0...]，那么我们就不用保留错误处理的情形了。</p>