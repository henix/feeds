<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>给类型求导</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20570808">原文</a></p>
熟识类型的用家可能都知道两个非常常见的类型构造：二元组和标签并，在代数类型（Algebraic type）中分别映射到乘法和加法，于是多项式<equation>1+t^2</equation>可以用来表示<equation>\mathrm{Either}\;()\;(t,t)</equation>这样的构造。继续扩展下去，比如把递归类型引入的话，就得到了许多递归类型的有理式表示，比如列表，它可以表示成<equation>L(a)=\frac{1}{1-a}</equation>，因为它是方程<equation>L(a)=1+aL(a)</equation>的解 [注 1]，而这个方程是列表的递归类型表示（在 Isorecursive 语义下，它表示<equation>L(a)</equation>和<equation>1+aL(a)</equation>之间存在一一映射，在实现时则用「指针」表示这种映射）。<p>上面的列表若是实现出来的话，是用链表实现的，对于双向遍历的话性能很差，于是我们发明一个 Zipper 类型，它同时存储一个焦点项目和它的左右两侧：</p><code lang="haskell">data Zipper a = Z [a] a [a]
</code><p>向左右两侧遍历的操作就可以写成</p><code lang="haskell">left  (Z (l:ls) c rs) = Z ls l (c:rs)
right (Z ls c (r:rs)) = Z (c:ls) r rs
</code><p>反向遍历的复杂度也降低到了 O(1)，性能获得了很可观的提升。除了列表，其他更复杂的数据结构，如二叉树等，也可以定义出 Zipper。</p><p>从代数类型的角度看，Zipper 的方程可以写作<equation>Z(a)=L(a)\cdot a \cdot L(a)=aL(a)^2</equation>，换言之，一个列表的 Zipper 可以看作一个「焦点」和两个列表的积，而后者则是原来列表类型敲掉一个空位。<img src="https://pic1.zhimg.com/0ed4cd4fd0e3bae9483c9a58ae37461c_r.png" data-rawwidth="400" data-rawheight="49"></p><p>给数据结构挖个洞是个不太罕见的需求，我们已经知道<equation>\mathrm{Hole}_a\ \frac{1}{1-a}=\left(\frac{1}{1-a}\right)^2</equation>。对于更简单的类型，我们也可以试试在上面挖洞，比如，类型 1 因为挖不出来洞，所以<equation>\mathrm{Hole}_a 1= 0</equation>；「一元组」a 挖洞之后都变一样了，于是<equation>\mathrm{Hole}_a\;a=1</equation>；而对于二元组<equation>a^2</equation>，因为存在两种可能的「挖」法（左或右），所以<equation>\mathrm{Hole}_a\;a^2=((),a)+(a,())=2a</equation>。这可以推广到所有的简单元祖，我们总可以得到<equation>\mathrm{Hole}_a\;a^n=na^{n-1}</equation>。</p><p>看上去怎么那么眼熟。</p><p>…………………………</p><p>这不是求导么？</p><p>对，Conor McBride 的<a href="http://strictlypositive.org/diff.pdf" class="" data-editable="true" data-title="论文">论文</a>中，就论述了类型上的导子（Derivation）<equation>\partial_a</equation>，并且证明了它和「挖洞」行为之间的联系。导子的三个基础法则——和法则、莱布尼兹法则和链式法则，都可以用挖洞的行为「证明」。<img src="https://pic2.zhimg.com/40d585a0d6a2e0bf510df7b3a984e5b4_r.png" data-rawwidth="1828" data-rawheight="344"><img src="https://pic4.zhimg.com/a5830a07404680c707a5a911582d0902_r.png" data-rawwidth="1875" data-rawheight="688"><img src="https://pic1.zhimg.com/7f40b2bfe902ccd0782cd2801579e807_r.png" data-rawwidth="1774" data-rawheight="556"></p><p>除此之外隐函数的「微分」同样适用于数据类型。考虑将导子作用到二叉树<equation>T(a)=1+aT(a)^2</equation>上：</p><equation>\partial_a T(a)=T(a)^2+2aT(a)\cdot\partial_a T(a)</equation><br><p>可以解得<equation>\partial_a T(a)=\frac{T(a)^2}{1-2aT(a)}=T(a)^2\cdot L(2\cdot a\cdot T(a))</equation> [注 2]</p><p>这个式子表明，带有空位的二叉树可以用两个子树和一个列表的二元组表示，这个列表的每项包含三个部分：一个布尔值，一个节点和一个子树。事实上，这个列表就表示了从树根到空位走过的路径：布尔值分辨每次是左转还是右转，节点值标记路过的节点，子树值标记另一侧的东西；而前面那两个树则是空位下面的子树。</p><p>——</p><p>最后，如果说数学家就是在寻找相似性的话，那么这个应该是一个非常好的案例了。</p><br><br><p>————————</p><p>[注 1]：考虑到一般来说，类型的相反数和倒数并没有良好定义，此处<equation>L(a)=\frac{1}{1-a}</equation>可以理解为泰勒展式<equation>L(a)=\sum_{j=0}^\infty a^j</equation>。更严谨的表述需要使用<equation>\mu</equation>符号。</p><p>[注 2]：用级数表示的话，<equation>\partial_a T(a)=\sum_{k=0}^{\infty} T(a)[2aT(a)]^k</equation>。此外也可以解出，<equation>T(a)=\sum_k \frac{a^k}{k+1}{2k \choose k}</equation></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
