<p>上回聊到自然数的半环结构，侧重于数量的解释和运算，虽然提到数也能表示顺序或者其他关系，但没有深入地研究数的序结构，其实在讨论species时我们已经运用了序理论的很多原理，比如写玫瑰树Rose a = Rose a [Rose a]的species，你可能会不假思索地写出enumerate as = fmap (\(CauchyProd (X a) (PartitionComp (Lin rs))) -&gt; Rose a rs) (enumerate as)，在定义Rose的enumerate函数时递归调用了这个函数，试了下好像也能跑出结果，计算过程能终止其实就会用到序理论不动点原理。今天我们就试着用Haskell来表达各种序关系，代数意义上的序-格论以及不动点的一些基础结论。你会发现序理论和代数结构之间有很多共通的地方，从任何满足交换律和幂等律的半群出发我们可以定义出某些偏序（Partial Order），而某些偏序结构比如半格（Semilattice）本身就是一种特殊的半群（Semigroup），如果幺半群（monoid）和预序（Pre-Order）兼容不冲突我们可以定义所谓的幺半预序（Monoidial Preorder），自然数的乘法运算和整除序关系就是一个例子。同样这两者跟范畴联系都很紧密，事实上范畴可以分别看作幺半群和预序的推广，合并范畴所有的对象就能得到幺半群，合并范畴所有的类型相同的态射就能得到预序。我们知道有向图（Directed Graph）加上一组指明箭头composites和identities信息的等式可以表示范畴，或者说范畴有一个天然的遗忘函子（Forgetful Functor），我们还知道图可以导出自由范畴（Free Category），那么自由范畴看起来就像“始对象（initial object）”，只要求我们添加范畴单位律和结合律要求的最少的等式；而我们尽可能多地添加等式，合并所有起始点相同的箭头得到的预序范畴就像“终对象（terminal object）”，等式越多表明我们可以在图上省略更多的箭头（这跟前文自然数的自由幺半群构造类似，那边是运算律指定等式），图就越稀疏，这也是预序范畴也叫“地中海范畴”（thin category）的由来，程序员不擅长处理关系，头发越稀疏，人际关系越简单。</p><div class="highlight"><pre><code class="language-haskell"><span class="cm">{-# LANGUAGE GADTs                #-}</span>
<span class="cm">{-# LANGUAGE RankNTypes           #-}</span>
<span class="cm">{-# LANGUAGE DeriveFunctor        #-}</span>
<span class="cm">{-# LANGUAGE FlexibleInstances    #-}</span>
<span class="cm">{-# LANGUAGE TypeSynonymInstances #-}</span>

<span class="kr">import</span> <span class="nn">Control.Lens</span>
<span class="kr">import</span> <span class="nn">Test.QuickCheck</span>
<span class="kr">import</span> <span class="nn">Control.Arrow</span> <span class="p">((</span><span class="o">&amp;&amp;&amp;</span><span class="p">))</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Set</span> <span class="k">as</span> <span class="n">S</span>

<span class="kr">class</span> <span class="kt">Relation</span>     <span class="nf">a</span> <span class="kr">where</span> <span class="nf">related</span>      <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>    
<span class="kr">class</span> <span class="kt">PreOrder</span>     <span class="nf">a</span> <span class="kr">where</span> <span class="nf">preOrdered</span>   <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="c1">-- reflexive, transitive</span>
<span class="kr">class</span> <span class="kt">Equivalence</span>  <span class="nf">a</span> <span class="kr">where</span> <span class="nf">equivalent</span>   <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="c1">-- reflexive, transitive, symmetric  </span>
<span class="kr">class</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="kr">where</span> <span class="nf">ordered</span>      <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="c1">-- reflexive, transitive, antisymmetric</span>
<span class="kr">class</span> <span class="kt">TotalOrder</span>   <span class="nf">a</span> <span class="kr">where</span> <span class="nf">totalOrdered</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="c1">-- transitive, antisymmetric, connexity(imply reflexive)</span></code></pre></div><p><br/>序关系是分层的，预序是满足自反性和传递性的关系，用简单有向图表示，等价关系是在预序基础上加上对称性，而偏序额外需要的是反对称性，偏序对应着有向无环图，完全的偏序关系则是全序，对应着有向链。用类型类来表示关系，关系需要满足的性质则作为类型类相应的公理，这里给出的定义没有表现出序关系的分层，因为公理没法在Haskell里表达，有两种方法可以在形式上体现分层，一种是类型类扩展，Eq和Ord就是这样定义的，比如class PartialOrder a =&gt; TotalOrder a，但这样写类型类实例时很繁琐，另一种是instance TotalOrder a =&gt; PartialOrder a，不过得打开额外的编译器扩展或者用newtype加wrapper，我都不喜欢。来看一些例子吧，这些例子我都声明成了偏序关系，虽然很多例子也满足全序公理，但因为全序条件强结构简单，预序要处理Haskell不擅长的相等，而偏序结构丰富应用更广。自然满足Ord约束的都是偏序，可以给出自然数的序定义，另外整除也是自然数的一种偏序关系。同样集合也有多种序关系，比如最简单的集合基数大小定义了一种预序，以包含为序子集的集合构成一种偏序，另外集合的非空划分也构成一种偏序，序由划分的精细程度定义，所谓划分A比划分B精细意味着划分A的所有集合都是划分B某个集合的子集。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Nat</span> <span class="ow">=</span> <span class="kt">Zero</span> <span class="o">|</span> <span class="kt">Succ</span> <span class="kt">Nat</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">PartialOrder</span> <span class="kt">Nat</span> <span class="kr">where</span>
  <span class="kt">Zero</span>   <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kr">_</span>      <span class="ow">=</span> <span class="kt">True</span>  
  <span class="kr">_</span>      <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">Zero</span>   <span class="ow">=</span> <span class="kt">False</span>
  <span class="kt">Succ</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">Succ</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="nf">b</span>

<span class="kr">newtype</span> <span class="kt">WrapOrd</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">WrapOrd</span> <span class="p">{</span> <span class="nf">unwrapOrd</span> <span class="ow">::</span> <span class="nf">a</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">PartialOrder</span> <span class="p">(</span><span class="kt">WrapOrd</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">WrapOrd</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">WrapOrd</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">a</span> <span class="o">&lt;=</span> <span class="nf">b</span>

<span class="kr">newtype</span> <span class="kt">WrapDiv</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">WrapDiv</span> <span class="p">{</span> <span class="nf">unwrapDiv</span> <span class="ow">::</span> <span class="nf">a</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">Integral</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">PartialOrder</span> <span class="p">(</span><span class="kt">WrapDiv</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">WrapDiv</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">WrapDiv</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">mod</span> <span class="nf">b</span> <span class="nf">a</span> <span class="o">==</span> <span class="mi">0</span></code></pre></div><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="kt">Power</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">S</span><span class="o">.</span><span class="kt">Set</span> <span class="nf">a</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">PartialOrder</span> <span class="p">(</span><span class="kt">Power</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">ordered</span> <span class="ow">=</span> <span class="kt">S</span><span class="o">.</span><span class="nf">isSubsetOf</span>

<span class="nf">powsets</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Power</span> <span class="nf">a</span><span class="p">]</span> <span class="c1">-- CauchyProd Bag Bag a</span>
<span class="nf">powsets</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="kt">S</span><span class="o">.</span><span class="nf">fromList</span> <span class="o">.</span> <span class="nf">disjoint2</span>
  <span class="kr">where</span>
    <span class="nf">disjoint2</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="p">[</span><span class="kt">[]</span><span class="p">]</span>
    <span class="nf">disjoint2</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="p">)</span> <span class="p">(</span><span class="nf">disjoint2</span> <span class="nf">xs</span><span class="p">)</span> <span class="o">++</span> <span class="nf">disjoint2</span> <span class="nf">xs</span>
    
<span class="kr">data</span> <span class="kt">Partition</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Partition</span> <span class="p">[</span><span class="kt">S</span><span class="o">.</span><span class="kt">Set</span> <span class="nf">a</span><span class="p">]</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span> <span class="c1">-- partition is isomorphic to equivalence set, surjective function</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">PartialOrder</span> <span class="p">(</span><span class="kt">Partition</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Partition</span> <span class="nf">ass</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">Partition</span> <span class="nf">bss</span> <span class="ow">=</span> <span class="nf">flip</span> <span class="nf">all</span> <span class="nf">ass</span> <span class="p">(</span><span class="nf">flip</span> <span class="nf">any</span> <span class="nf">bss</span> <span class="o">.</span> <span class="nf">ordered</span><span class="p">)</span>
  
<span class="nf">parsets</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Partition</span> <span class="nf">a</span><span class="p">]</span> <span class="c1">-- PartitionComp Bag Bag a</span>
<span class="nf">parsets</span> <span class="ow">=</span>  <span class="nf">fmap</span> <span class="p">(</span><span class="kt">Partition</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="kt">S</span><span class="o">.</span><span class="nf">fromList</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="nf">pure</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="nf">traverse</span> <span class="nf">pure</span><span class="p">)</span> <span class="o">.</span> <span class="nf">partition</span>
  <span class="kr">where</span>
    <span class="nf">partition</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="p">[</span><span class="kt">[]</span><span class="p">]</span>
    <span class="nf">partition</span> <span class="p">[</span><span class="nf">x</span><span class="p">]</span>    <span class="ow">=</span> <span class="p">[[[</span><span class="nf">x</span><span class="p">]]]</span>
    <span class="nf">partition</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">([</span><span class="nf">x</span><span class="p">]</span><span class="kt">:</span><span class="p">)</span> <span class="p">(</span><span class="nf">partition</span> <span class="nf">xs</span><span class="p">)</span> <span class="o">++</span> <span class="p">(</span><span class="nf">partition</span> <span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="nf">insert</span> <span class="nf">x</span><span class="p">)</span>
    <span class="nf">insert</span> <span class="nf">x</span> <span class="nf">xxs</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">\n</span> <span class="ow">-&gt;</span> <span class="nf">over</span> <span class="p">(</span><span class="nf">element</span> <span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="p">)</span> <span class="nf">xxs</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="nf">length</span> <span class="nf">xxs</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span></code></pre></div><p><br/>我们还可以在Haskell里表示偏序集合中的特殊元素或者子集。比如极大元和最大元，可以看出把数学概念在类型系统里表达出来更直观，看类型就能知道极大元有很多，而最大元可能不存在。再比如上界集合和上确界，从函数定义中很容易看出上确界是上界集合的最小元。还可以定义理想和，这里我只给出了主理想的定义，因为好像在这种表示下很难写出求偏序集合所有理想的高效算法，一般都会先转化为图的表示。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">ordered&#39;</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">ordered&#39;</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">ordered</span> <span class="nf">a</span> <span class="nf">b</span> <span class="o">&amp;&amp;</span> <span class="nf">not</span> <span class="p">(</span><span class="nf">ordered</span> <span class="nf">b</span> <span class="nf">a</span><span class="p">)</span>

<span class="nf">equal</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">equal</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">ordered</span> <span class="nf">a</span> <span class="nf">b</span> <span class="o">&amp;&amp;</span> <span class="nf">ordered</span> <span class="nf">b</span> <span class="nf">a</span>

<span class="c1">-- minimal/maximal not unique</span>
<span class="nf">minimal</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">minimal</span> <span class="nf">as</span> <span class="ow">=</span> <span class="nf">foldr</span> <span class="p">(</span><span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="nf">any</span> <span class="p">(</span><span class="nf">flip</span> <span class="nf">ordered&#39;</span> <span class="nf">a</span><span class="p">)</span> <span class="nf">as</span> <span class="kr">then</span> <span class="nf">id</span> <span class="kr">else</span> <span class="p">(</span><span class="nf">a</span><span class="kt">:</span><span class="p">))</span> <span class="kt">[]</span> <span class="nf">as</span>

<span class="nf">maximal</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">maximal</span> <span class="nf">as</span> <span class="ow">=</span> <span class="nf">foldr</span> <span class="p">(</span><span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="nf">any</span> <span class="p">(</span><span class="nf">ordered&#39;</span> <span class="nf">a</span><span class="p">)</span> <span class="nf">as</span> <span class="kr">then</span> <span class="nf">id</span> <span class="kr">else</span> <span class="p">(</span><span class="nf">a</span><span class="kt">:</span><span class="p">))</span> <span class="kt">[]</span> <span class="nf">as</span>

<span class="c1">-- least(minimum)/greatest(maximum) if exist then unique</span>
<span class="nf">least</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="nf">a</span>
<span class="nf">least</span> <span class="nf">as</span> <span class="ow">=</span> <span class="nf">foldr</span> <span class="p">(</span><span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="nf">all</span> <span class="p">(</span><span class="nf">ordered</span> <span class="nf">a</span><span class="p">)</span> <span class="nf">as</span> <span class="kr">then</span> <span class="nf">const</span> <span class="p">(</span><span class="kt">Just</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">else</span> <span class="nf">id</span><span class="p">)</span> <span class="kt">Nothing</span> <span class="nf">as</span>

<span class="nf">greatest</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="nf">a</span>
<span class="nf">greatest</span> <span class="nf">as</span> <span class="ow">=</span> <span class="nf">foldr</span> <span class="p">(</span><span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="nf">all</span> <span class="p">(</span><span class="nf">flip</span> <span class="nf">ordered</span> <span class="nf">a</span><span class="p">)</span> <span class="nf">as</span> <span class="kr">then</span> <span class="nf">const</span> <span class="p">(</span><span class="kt">Just</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">else</span> <span class="nf">id</span><span class="p">)</span> <span class="kt">Nothing</span> <span class="nf">as</span>

<span class="c1">-- principal</span>
<span class="c1">-- poset ideal: lower set</span>
<span class="c1">-- lattice ideal: directed lower set</span>
<span class="nf">principal_ideal</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">principal_ideal</span> <span class="nf">p</span> <span class="ow">=</span> <span class="nf">filter</span> <span class="p">(</span><span class="nf">flip</span> <span class="nf">ordered</span> <span class="nf">p</span><span class="p">)</span>

<span class="nf">principal_filter</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">principal_filter</span> <span class="nf">p</span> <span class="ow">=</span> <span class="nf">filter</span> <span class="p">(</span><span class="nf">ordered</span> <span class="nf">p</span><span class="p">)</span>

<span class="c1">-- bound, glb/lub</span>
<span class="nf">lower_bound</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">lower_bound</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">filter</span> <span class="p">((</span><span class="o">==</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">))</span> <span class="o">.</span> <span class="p">(</span><span class="nf">flip</span> <span class="nf">ordered</span> <span class="nf">a</span> <span class="o">&amp;&amp;&amp;</span> <span class="nf">flip</span> <span class="nf">ordered</span> <span class="nf">b</span><span class="p">))</span>

<span class="nf">upper_bound</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">upper_bound</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">filter</span> <span class="p">((</span><span class="o">==</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">))</span> <span class="o">.</span> <span class="p">(</span><span class="nf">ordered</span> <span class="nf">a</span> <span class="o">&amp;&amp;&amp;</span> <span class="nf">ordered</span> <span class="nf">b</span><span class="p">))</span>

<span class="nf">glb</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="nf">a</span>
<span class="nf">glb</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">greatest</span> <span class="o">.</span> <span class="nf">lower_bound</span> <span class="nf">a</span> <span class="nf">b</span>

<span class="nf">lub</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="nf">a</span>
<span class="nf">lub</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">least</span> <span class="o">.</span> <span class="nf">upper_bound</span> <span class="nf">a</span> <span class="nf">b</span></code></pre></div><p><br/>关系跟矩阵和图联系非常紧密，比如关系矩阵，偏序关系则经常用哈斯图（Hasse Digram）表示。哈斯图用线段表示覆盖（cover），覆盖也是一种关系，它是非自反，非传递，非对称的。另外还可以定义区间，链和反链，哈斯图的高度和宽度。这里面有很多有趣的结论，比如Fibonacci数对应着一种特殊的偏序集fence中反链的数目，又比如对于宽度（高度）为n的哈斯图，那么存在一个n个链（反链）的划分，还有对于有限偏序集所有理想的偏序集和所有反链的偏序集同构。偏序集同样有不少代数构造，比如两个偏序集的积就可以定义自然的笛卡尔积序或者不那么自然的字典序。至于两个偏序集的和可以用来表示串并行关系，计算偏序集和包含理想的总数目则对应着加法原理和乘法原理，前面说到可以对偏序集做链或者反链的划分，对于series parallel偏序集我们也可以按照这种串并关系进行划分构成树，用来解决规划问题。</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- directed acyclic graph/Hasse diagram</span>
<span class="nf">interval</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
<span class="nf">interval</span> <span class="nf">l</span> <span class="nf">r</span> <span class="ow">=</span> <span class="nf">filter</span> <span class="p">(</span><span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="nf">ordered</span> <span class="nf">l</span> <span class="nf">a</span> <span class="o">&amp;&amp;</span> <span class="nf">ordered</span> <span class="nf">a</span> <span class="nf">r</span><span class="p">)</span>

<span class="nf">covering</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">covering</span> <span class="nf">l</span> <span class="nf">r</span> <span class="ow">=</span> <span class="nf">not</span> <span class="o">.</span> <span class="nf">any</span> <span class="p">(</span><span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="nf">ordered&#39;</span> <span class="nf">l</span> <span class="nf">a</span> <span class="o">&amp;&amp;</span> <span class="nf">ordered&#39;</span> <span class="nf">a</span> <span class="nf">r</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Lexicon</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="kt">Lexicon</span> <span class="nf">a</span> <span class="nf">b</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span> <span class="c1">--versioning</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">PartialOrder</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">PartialOrder</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">PartialOrder</span> <span class="p">(</span><span class="kt">Lexicon</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Lexicon</span> <span class="nf">a</span> <span class="nf">b</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">Lexicon</span> <span class="nf">a&#39;</span> <span class="nf">b&#39;</span> <span class="ow">=</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="nf">a&#39;</span> <span class="o">||</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">equal</span><span class="p">`</span> <span class="nf">a&#39;</span> <span class="o">&amp;&amp;</span> <span class="nf">b</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="nf">b&#39;</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">PartialOrder</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">PartialOrder</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">PartialOrder</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span> <span class="nf">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="p">(</span><span class="nf">a</span><span class="p">,</span> <span class="nf">b</span><span class="p">)</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="p">(</span><span class="nf">a&#39;</span><span class="p">,</span> <span class="nf">b&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="nf">a&#39;</span> <span class="o">&amp;&amp;</span> <span class="nf">b</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="nf">b&#39;</span>

<span class="c1">-- series parallel poset/N-free poset decomposition</span>
<span class="kr">data</span> <span class="kt">Parallel</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="kt">Inl</span> <span class="nf">a</span> <span class="o">|</span> <span class="kt">Inr</span> <span class="nf">b</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span> <span class="c1">-- rule of product, N(P*Q) = N(P) * N(Q)</span>
<span class="kr">data</span> <span class="kt">Series</span> <span class="nf">a</span> <span class="nf">b</span>   <span class="ow">=</span> <span class="kt">Inp</span> <span class="nf">a</span> <span class="o">|</span> <span class="kt">Ins</span> <span class="nf">b</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span> <span class="c1">-- rule of sum, N(P+Q) = N(P) + N(Q) - 1</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">PartialOrder</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">PartialOrder</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">PartialOrder</span> <span class="p">(</span><span class="kt">Parallel</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Inl</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">Inl</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="nf">b</span>
  <span class="kt">Inr</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">Inr</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="nf">b</span>
  <span class="kr">_</span>     <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kr">_</span>     <span class="ow">=</span> <span class="kt">False</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">PartialOrder</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">PartialOrder</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">PartialOrder</span> <span class="p">(</span><span class="kt">Series</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Inp</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">Inp</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="nf">b</span>
  <span class="kt">Ins</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">Ins</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">a</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="nf">b</span>
  <span class="kt">Inp</span> <span class="kr">_</span> <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kt">Ins</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="kr">_</span>     <span class="p">`</span><span class="nf">ordered</span><span class="p">`</span> <span class="kr">_</span>     <span class="ow">=</span> <span class="kt">False</span>

<span class="kr">data</span> <span class="kt">SPTree</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Atom</span> <span class="nf">a</span> <span class="o">|</span> <span class="kt">P</span> <span class="p">(</span><span class="kt">SPTree</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">SPTree</span> <span class="nf">a</span><span class="p">)</span> <span class="o">|</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">SPTree</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">SPTree</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="nf">satisfy</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">SPTree</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">satisfy</span> <span class="p">(</span><span class="kt">Atom</span> <span class="nf">c</span><span class="p">)</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">a</span> <span class="o">==</span> <span class="nf">c</span> <span class="o">&amp;&amp;</span> <span class="nf">b</span> <span class="o">==</span> <span class="nf">c</span>
<span class="nf">satisfy</span> <span class="p">(</span><span class="kt">P</span> <span class="nf">l</span> <span class="nf">r</span> <span class="p">)</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">satisfy</span> <span class="nf">l</span> <span class="nf">a</span> <span class="nf">b</span> <span class="o">||</span> <span class="nf">satisfy</span> <span class="nf">r</span> <span class="nf">a</span> <span class="nf">b</span>
<span class="nf">satisfy</span> <span class="p">(</span><span class="kt">S</span> <span class="nf">p</span> <span class="nf">s</span> <span class="p">)</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">locatedP</span> <span class="o">&amp;&amp;</span> <span class="nf">locatedS</span> <span class="o">||</span> <span class="nf">not</span> <span class="nf">locatedS</span> <span class="o">&amp;&amp;</span> <span class="nf">satisfy</span> <span class="nf">p</span> <span class="nf">a</span> <span class="nf">b</span> <span class="o">||</span> <span class="nf">not</span> <span class="nf">locatedP</span> <span class="o">&amp;&amp;</span> <span class="nf">satisfy</span> <span class="nf">s</span> <span class="nf">a</span> <span class="nf">b</span> <span class="kr">where</span>
  <span class="nf">locatedP</span> <span class="ow">=</span> <span class="nf">satisfy</span> <span class="nf">p</span> <span class="nf">a</span> <span class="nf">a</span>
  <span class="nf">locatedS</span> <span class="ow">=</span> <span class="nf">satisfy</span> <span class="nf">s</span> <span class="nf">b</span> <span class="nf">b</span></code></pre></div><p><br/>同样偏序集自身也能成为范畴的对象，箭头是单调保序的映射。比如求有限集合的偏序集基数，或者生物学分类把物种映射为界门纲目科属种，还有强规范化的重写系统存在着天然的保序自映射。进一步的如果偏序集的所有有向子集都有上确界，保持上确界的映射则称是连续的，连续蕴含着单调保序。有了连续的概念就可以聊不动点了，常说的不动点理论对应着kleene chain的最小不动点，需要满足三要素：上确界封闭，映射连续和最小元存在，知乎上很多人都证明过了，我就不证了。在Haskell里不动点不唯一，最小不动点和最大不动点同构，可以定义类型类来表示，代数和余代数是一对可逆函数的类型都是不动点类型。简单类型是无法表达不动点类型的，要处理递归需要额外添加fix或者Fix f，如果切换到高阶类型，就能用GADT显式写出最小不动点Lfp f和最大不动点Gfp f，我们需要证明其对应的代数和余代数互为可逆，偷个懒用quickcheck，我们还能证明Lfp f， Fix f和Gfp f两两同构。另外用最小不动点来编码插入排序和用最大不动点来编码选择排序，你会发现其实Lfp f里的函数对应着插入函数，Gfp f里的函数对应着选择函数。</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">kleene_lfp</span> <span class="ow">::</span> <span class="kt">PartialOrder</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="nf">kleene_lfp</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="nf">supre</span> <span class="p">(</span><span class="nf">iterate</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="nf">supre</span> <span class="ow">=</span> <span class="nf">\as</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="nf">as</span> <span class="kr">of</span>
      <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">y</span><span class="kt">:</span><span class="nf">zs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="nf">equal</span> <span class="nf">x</span> <span class="nf">y</span> <span class="kr">then</span> <span class="nf">x</span> <span class="kr">else</span> <span class="nf">supre</span> <span class="p">(</span><span class="nf">y</span><span class="kt">:</span><span class="nf">zs</span><span class="p">)</span>
      <span class="kr">_</span>        <span class="ow">-&gt;</span> <span class="nf">a</span>

<span class="nf">fix</span> <span class="ow">::</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="nf">fix</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kr">let</span> <span class="nf">x</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">x</span> <span class="kr">in</span> <span class="nf">x</span>

<span class="kr">newtype</span> <span class="kt">Fix</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Fix</span> <span class="p">{</span> <span class="nf">unFix</span> <span class="ow">::</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">Fix</span> <span class="nf">f</span><span class="p">)</span> <span class="p">}</span> 
<span class="kr">data</span> <span class="kt">Lfp</span> <span class="nf">f</span> <span class="kr">where</span> <span class="kt">Lfp</span> <span class="ow">::</span> <span class="p">(</span><span class="nf">forall</span> <span class="nf">a</span><span class="o">.</span> <span class="p">((</span><span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kt">Lfp</span> <span class="nf">f</span>
<span class="kr">data</span> <span class="kt">Gfp</span> <span class="nf">f</span> <span class="kr">where</span> <span class="kt">Gfp</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Gfp</span> <span class="nf">f</span>

<span class="c1">-- alg . coa = id = coa . alg</span>
<span class="kr">class</span> <span class="kt">FixT</span> <span class="nf">t</span> <span class="kr">where</span>
  <span class="nf">alg</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="nf">f</span> <span class="p">(</span><span class="nf">t</span> <span class="nf">f</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">t</span> <span class="nf">f</span>
  <span class="nf">coa</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="nf">t</span> <span class="nf">f</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="p">(</span><span class="nf">t</span> <span class="nf">f</span><span class="p">)</span>
  
  <span class="nf">cata</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">t</span> <span class="nf">f</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
  <span class="nf">cata</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">f</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">cata</span> <span class="nf">f</span><span class="p">)</span> <span class="o">.</span> <span class="nf">coa</span>
  
  <span class="nf">ana</span>  <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">t</span> <span class="nf">f</span>
  <span class="nf">ana</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">alg</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">ana</span> <span class="nf">f</span><span class="p">)</span> <span class="o">.</span> <span class="nf">f</span>

<span class="nf">algebra_law</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">FixT</span> <span class="nf">t</span><span class="p">,</span> <span class="kt">Functor</span> <span class="nf">f</span><span class="p">,</span> <span class="kt">Eq</span> <span class="p">(</span><span class="nf">t</span> <span class="nf">f</span><span class="p">),</span> <span class="kt">Eq</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">t</span> <span class="nf">f</span><span class="p">)))</span> <span class="ow">=&gt;</span> <span class="nf">t</span> <span class="nf">f</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="p">(</span><span class="nf">t</span> <span class="nf">f</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">algebra_law</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">alg</span> <span class="p">(</span><span class="nf">coa</span> <span class="nf">a</span><span class="p">)</span> <span class="o">==</span> <span class="nf">a</span> <span class="o">&amp;&amp;</span> <span class="nf">coa</span> <span class="p">(</span><span class="nf">alg</span> <span class="nf">b</span><span class="p">)</span> <span class="o">==</span> <span class="nf">b</span>

<span class="kr">instance</span> <span class="kt">FixT</span> <span class="kt">Fix</span> <span class="kr">where</span>
  <span class="nf">alg</span> <span class="ow">=</span> <span class="kt">Fix</span>
  <span class="nf">coa</span> <span class="ow">=</span> <span class="nf">unFix</span>
  
<span class="c1">-- least fix point, least/minimum element, initial object in F-algebra</span>
<span class="kr">instance</span> <span class="kt">FixT</span> <span class="kt">Lfp</span> <span class="kr">where</span>
  <span class="nf">cata</span> <span class="ow">=</span> <span class="nf">\eval</span> <span class="p">(</span><span class="kt">Lfp</span> <span class="nf">k</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">k</span> <span class="nf">eval</span>  
  <span class="nf">alg</span> <span class="ow">=</span> <span class="nf">\fx</span> <span class="ow">-&gt;</span> <span class="kt">Lfp</span> <span class="o">$</span> <span class="nf">\k</span> <span class="ow">-&gt;</span> <span class="nf">k</span> <span class="p">(</span><span class="nf">cata</span> <span class="nf">k</span> <span class="o">&lt;$&gt;</span> <span class="nf">fx</span><span class="p">)</span>
  <span class="nf">coa</span> <span class="ow">=</span> <span class="nf">cata</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">alg</span><span class="p">)</span>
  
<span class="c1">-- greatest fix point, greatest/maximum element, terminal object in F-coalgebra</span>
<span class="kr">instance</span> <span class="kt">FixT</span> <span class="kt">Gfp</span> <span class="kr">where</span>
  <span class="nf">ana</span> <span class="ow">=</span> <span class="nf">flip</span> <span class="kt">Gfp</span>  
  <span class="nf">alg</span> <span class="ow">=</span> <span class="nf">ana</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">coa</span><span class="p">)</span>  
  <span class="nf">coa</span> <span class="ow">=</span> <span class="nf">\</span><span class="p">(</span><span class="kt">Gfp</span> <span class="nf">a</span> <span class="nf">f</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">ana</span> <span class="nf">f</span> <span class="o">&lt;$&gt;</span> <span class="nf">f</span> <span class="nf">a</span>

<span class="c1">-- Lfp f &lt;-&gt; Fix f &lt;-&gt; Gfp f</span>
<span class="nf">fwLeast</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Lfp</span> <span class="nf">f</span> <span class="ow">-&gt;</span> <span class="kt">Fix</span> <span class="nf">f</span>
<span class="nf">fwLeast</span> <span class="ow">=</span> <span class="kt">Fix</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="nf">fwLeast</span> <span class="o">.</span> <span class="nf">coa</span>

<span class="nf">bwLeast</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Fix</span> <span class="nf">f</span> <span class="ow">-&gt;</span> <span class="kt">Lfp</span> <span class="nf">f</span>
<span class="nf">bwLeast</span> <span class="ow">=</span> <span class="nf">alg</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="nf">bwLeast</span> <span class="o">.</span> <span class="nf">unFix</span>

<span class="nf">fwGreatest</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Fix</span> <span class="nf">f</span> <span class="ow">-&gt;</span> <span class="kt">Gfp</span> <span class="nf">f</span>
<span class="nf">fwGreatest</span> <span class="ow">=</span> <span class="nf">alg</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="nf">fwGreatest</span> <span class="o">.</span> <span class="nf">unFix</span>

<span class="nf">bwGreatest</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Gfp</span> <span class="nf">f</span> <span class="ow">-&gt;</span> <span class="kt">Fix</span> <span class="nf">f</span>
<span class="nf">bwGreatest</span> <span class="ow">=</span> <span class="kt">Fix</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="nf">bwGreatest</span> <span class="o">.</span> <span class="nf">coa</span>

<span class="kr">data</span> <span class="kt">ListF</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Nil</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="kt">Int</span> <span class="nf">a</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Functor</span><span class="p">)</span>

<span class="nf">insertion_sort</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">insertion_sort</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">cata</span> <span class="nf">insertion</span> <span class="ow">::</span> <span class="kt">Lfp</span> <span class="kt">ListF</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">.</span> <span class="nf">ana</span> <span class="nf">embed</span>
  <span class="kr">where</span>
    <span class="nf">insertion</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">[]</span>
    <span class="nf">insertion</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">x</span> <span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="nf">null</span> <span class="nf">xs</span> <span class="o">||</span> <span class="nf">x</span> <span class="o">&lt;</span> <span class="nf">head</span> <span class="nf">xs</span> <span class="kr">then</span> <span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span> <span class="kr">else</span> <span class="nf">head</span> <span class="nf">xs</span><span class="kt">:</span><span class="nf">insertion</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">x</span> <span class="p">(</span><span class="nf">tail</span> <span class="nf">xs</span><span class="p">))</span>

<span class="nf">selection_sort</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">selection_sort</span> <span class="ow">=</span> <span class="nf">cata</span> <span class="nf">project</span> <span class="o">.</span> <span class="p">(</span><span class="nf">ana</span> <span class="nf">selection</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Gfp</span> <span class="kt">ListF</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="nf">selection</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nil</span>
    <span class="nf">selection</span> <span class="nf">xs</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="p">(</span><span class="nf">minimum</span> <span class="nf">xs</span><span class="p">)</span> <span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="o">/=</span> <span class="nf">minimum</span> <span class="nf">xs</span><span class="p">)</span> <span class="nf">xs</span><span class="p">)</span>

<span class="nf">well_sorted</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>      
<span class="nf">well_sorted</span> <span class="nf">xs</span> <span class="ow">=</span> <span class="nf">all</span> <span class="p">(</span><span class="o">==</span> <span class="kt">True</span><span class="p">)</span> <span class="o">$</span> <span class="nf">zipWith</span> <span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span> <span class="nf">xs</span> <span class="p">(</span><span class="nf">tail</span> <span class="nf">xs</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Arbitrary</span> <span class="p">(</span><span class="kt">ListF</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">sized</span> <span class="o">$</span> <span class="nf">\n</span> <span class="ow">-&gt;</span> <span class="nf">oneof</span> <span class="p">(</span><span class="nf">return</span> <span class="kt">Nil</span> <span class="kt">:</span> <span class="nf">replicate</span> <span class="nf">n</span> <span class="p">(</span><span class="kt">Cons</span> <span class="o">&lt;$&gt;</span> <span class="nf">arbitrary</span> <span class="o">&lt;*&gt;</span> <span class="nf">arbitrary</span><span class="p">))</span>
  <span class="nf">shrink</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">[]</span>
  <span class="nf">shrink</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">i</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="o">&lt;$&gt;</span> <span class="nf">shrink</span> <span class="nf">i</span> <span class="o">&lt;*&gt;</span> <span class="nf">shrink</span> <span class="nf">a</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Lfp</span> <span class="kt">ListF</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">a</span> <span class="o">==</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">cata</span> <span class="nf">project</span> <span class="nf">a</span> <span class="o">==</span> <span class="nf">cata</span> <span class="nf">project</span> <span class="nf">b</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Gfp</span> <span class="kt">ListF</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">a</span> <span class="o">==</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">cata</span> <span class="nf">project</span> <span class="nf">a</span> <span class="o">==</span> <span class="nf">cata</span> <span class="nf">project</span> <span class="nf">b</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Lfp</span> <span class="kt">ListF</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="ow">=</span> <span class="nf">show</span> <span class="o">.</span> <span class="nf">cata</span> <span class="nf">project</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Gfp</span> <span class="kt">ListF</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="ow">=</span> <span class="nf">show</span> <span class="o">.</span> <span class="nf">cata</span> <span class="nf">project</span>
    
<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="p">(</span><span class="kt">Lfp</span> <span class="kt">ListF</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">ana</span> <span class="nf">embed</span> <span class="o">&lt;$&gt;</span> <span class="nf">arbitrary</span>
  <span class="nf">shrink</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">ana</span> <span class="nf">embed</span><span class="p">)</span> <span class="o">.</span> <span class="nf">shrink</span> <span class="o">.</span> <span class="nf">cata</span> <span class="nf">project</span>

<span class="kr">instance</span> <span class="kt">Arbitrary</span> <span class="p">(</span><span class="kt">Gfp</span> <span class="kt">ListF</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">arbitrary</span> <span class="ow">=</span> <span class="nf">ana</span> <span class="nf">embed</span> <span class="o">&lt;$&gt;</span> <span class="nf">arbitrary</span>
  <span class="nf">shrink</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">ana</span> <span class="nf">embed</span><span class="p">)</span> <span class="o">.</span> <span class="nf">shrink</span> <span class="o">.</span> <span class="nf">cata</span> <span class="nf">project</span>

<span class="nf">embed</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">ListF</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">embed</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">Nil</span>
<span class="nf">embed</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="nf">x</span> <span class="nf">xs</span>

<span class="nf">project</span> <span class="ow">::</span> <span class="kt">ListF</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">project</span> <span class="kt">Nil</span>         <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">project</span> <span class="p">(</span><span class="kt">Cons</span> <span class="nf">x</span> <span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span>

<span class="nf">gfp_iso_law</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">gfp_iso_law</span> <span class="nf">a</span> <span class="ow">=</span> <span class="nf">cata</span> <span class="nf">project</span> <span class="p">((</span><span class="nf">ana</span> <span class="nf">embed</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Gfp</span> <span class="kt">ListF</span><span class="p">)</span> <span class="nf">a</span><span class="p">)</span> <span class="o">==</span> <span class="nf">a</span>

<span class="nf">lfp_iso_law</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">lfp_iso_law</span> <span class="nf">a</span> <span class="ow">=</span> <span class="nf">cata</span> <span class="nf">project</span> <span class="p">((</span><span class="nf">ana</span> <span class="nf">embed</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Lfp</span> <span class="kt">ListF</span><span class="p">)</span> <span class="nf">a</span><span class="p">)</span> <span class="o">==</span> <span class="nf">a</span></code></pre></div><p><br/>有一类偏序集——格，数学家也研究得特别多。格有完整的代数定义，非常适合用Haskell表达，格也是分层的，从半格一路向上可以定义格，有界格，完全格，完全分配格，我们之前提到的偏序集几乎都是格。这篇文章只是简单介绍，偏序集以及格在分布计算，并发性，程序语言理论都有很多应用，另外理想还可以用在组合计数，解决有基数约束条件的计数特别有效。以后有机会可能会写一篇关于格理论应用的文章。</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- associative, commutative, idempotent</span>
<span class="kr">class</span> <span class="kt">JoinSemilattice</span> <span class="nf">a</span> <span class="kr">where</span> <span class="nf">join</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="c1">-- least upper bound/supremum</span>
<span class="kr">class</span> <span class="kt">MeetSemilattice</span> <span class="nf">a</span> <span class="kr">where</span> <span class="nf">meet</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="c1">-- greatest lower bound/infimum  </span>

<span class="c1">-- absorption</span>
<span class="kr">infixr</span> <span class="mi">2</span> <span class="o">\/</span>
<span class="kr">infixr</span> <span class="mi">3</span> <span class="o">/\</span>
<span class="kr">class</span> <span class="p">(</span><span class="kt">JoinSemilattice</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">MeetSemilattice</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Lattice</span> <span class="nf">a</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">/\</span><span class="p">)</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
  <span class="p">(</span><span class="o">/\</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">meet</span>
  <span class="p">(</span><span class="o">\/</span><span class="p">)</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
  <span class="p">(</span><span class="o">\/</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">join</span>

<span class="c1">-- lens lattice</span>
<span class="kr">class</span> <span class="kt">Lattice</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">BoundedLattice</span> <span class="nf">a</span> <span class="kr">where</span>
  <span class="nf">bottom</span> <span class="ow">::</span> <span class="nf">a</span> <span class="c1">-- least/minimum element</span>
  <span class="nf">top</span>    <span class="ow">::</span> <span class="nf">a</span> <span class="c1">-- greatest/maximum element</span>

<span class="c1">-- all finite lattices are complete</span>
<span class="kr">class</span> <span class="kt">Lattice</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">CompleteLattice</span> <span class="nf">a</span> <span class="kr">where</span>
  <span class="nf">inf</span> <span class="ow">::</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="nf">a</span>  
  <span class="nf">sup</span> <span class="ow">::</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="nf">a</span>

<span class="kr">instance</span> <span class="kt">Integral</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">JoinSemilattice</span> <span class="p">(</span><span class="kt">WrapDiv</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">join</span> <span class="p">(</span><span class="kt">WrapDiv</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">WrapDiv</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">WrapDiv</span> <span class="o">$</span> <span class="nf">lcm</span> <span class="nf">a</span> <span class="nf">b</span>

<span class="kr">instance</span> <span class="kt">Integral</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">MeetSemilattice</span> <span class="p">(</span><span class="kt">WrapDiv</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">meet</span> <span class="p">(</span><span class="kt">WrapDiv</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">WrapDiv</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">WrapDiv</span> <span class="o">$</span> <span class="nf">gcd</span> <span class="nf">a</span> <span class="nf">b</span>

<span class="kr">instance</span> <span class="kt">Integral</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Lattice</span> <span class="p">(</span><span class="kt">WrapDiv</span> <span class="nf">a</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">JoinSemilattice</span> <span class="p">(</span><span class="kt">Power</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">join</span> <span class="ow">=</span> <span class="kt">S</span><span class="o">.</span><span class="nf">union</span>

<span class="kr">instance</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">MeetSemilattice</span> <span class="p">(</span><span class="kt">Power</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">meet</span> <span class="ow">=</span> <span class="kt">S</span><span class="o">.</span><span class="nf">intersection</span>

<span class="kr">instance</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Lattice</span> <span class="p">(</span><span class="kt">Power</span> <span class="nf">a</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">JoinSemilattice</span> <span class="p">(</span><span class="kt">Partition</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">join</span> <span class="p">(</span><span class="kt">Partition</span> <span class="nf">as</span><span class="p">)</span> <span class="p">(</span><span class="kt">Partition</span> <span class="nf">bs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Partition</span> <span class="o">.</span> <span class="nf">prune</span><span class="p">)</span> <span class="o">$</span> <span class="nf">foldr</span> <span class="p">(</span><span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="p">(</span><span class="kt">S</span><span class="o">.</span><span class="nf">unions</span> <span class="p">(</span><span class="nf">a</span><span class="kt">:</span> <span class="nf">filter</span> <span class="p">(</span><span class="nf">not</span> <span class="o">.</span> <span class="nf">disjoint</span> <span class="nf">a</span><span class="p">)</span> <span class="nf">bs</span><span class="p">)))</span> <span class="kt">[]</span> <span class="nf">as</span>
    <span class="kr">where</span>
      <span class="nf">disjoint</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">S</span><span class="o">.</span><span class="nf">null</span> <span class="o">.</span> <span class="kt">S</span><span class="o">.</span><span class="nf">intersection</span> <span class="nf">a</span>
      <span class="nf">prune</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
      <span class="nf">prune</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="nf">ls</span><span class="p">,</span> <span class="nf">rs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">span</span> <span class="p">(</span><span class="nf">disjoint</span> <span class="nf">x</span><span class="p">)</span> <span class="nf">xs</span> <span class="kr">in</span> <span class="kt">S</span><span class="o">.</span><span class="nf">unions</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">rs</span><span class="p">)</span> <span class="kt">:</span> <span class="nf">prune</span> <span class="nf">ls</span>

<span class="kr">instance</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">MeetSemilattice</span> <span class="p">(</span><span class="kt">Partition</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">meet</span> <span class="p">(</span><span class="kt">Partition</span> <span class="nf">as</span><span class="p">)</span> <span class="p">(</span><span class="kt">Partition</span> <span class="nf">bs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Partition</span> <span class="o">$</span> <span class="nf">go</span> <span class="nf">as</span> <span class="nf">bs</span>
    <span class="kr">where</span>
      <span class="nf">disjoint</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">S</span><span class="o">.</span><span class="nf">null</span> <span class="o">.</span> <span class="kt">S</span><span class="o">.</span><span class="nf">intersection</span> <span class="nf">a</span>      
      <span class="nf">go</span> <span class="nf">as</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="nf">as</span>
      <span class="nf">go</span> <span class="nf">as</span> <span class="p">(</span><span class="nf">b</span><span class="kt">:</span><span class="nf">bs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">go</span> <span class="p">(</span><span class="nf">foldr</span> <span class="p">(</span><span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="nf">disjoint</span> <span class="nf">a</span> <span class="nf">b</span> <span class="o">||</span> <span class="kt">S</span><span class="o">.</span><span class="nf">isSubsetOf</span> <span class="nf">a</span> <span class="nf">b</span> <span class="kr">then</span> <span class="p">(</span><span class="nf">a</span><span class="kt">:</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="kt">S</span><span class="o">.</span><span class="nf">difference</span> <span class="nf">a</span> <span class="nf">b</span><span class="kt">:</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="kt">S</span><span class="o">.</span><span class="nf">intersection</span> <span class="nf">a</span> <span class="nf">b</span><span class="kt">:</span><span class="p">))</span> <span class="kt">[]</span> <span class="nf">as</span><span class="p">)</span> <span class="nf">bs</span>

<span class="kr">instance</span> <span class="kt">Ord</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Lattice</span> <span class="p">(</span><span class="kt">Partition</span> <span class="nf">a</span><span class="p">)</span></code></pre></div><p></p>