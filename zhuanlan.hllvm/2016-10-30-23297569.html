<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[Java] 动态生成类的场景的考察</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/23297569">原文</a></p>
开个坑慢慢填哈。<p>============================================</p><h2><b>Oracle/Sun JDK / OpenJDK的Java SE中的场景</b></h2><br><p>在Oracle/Sun JDK及OpenJDK内，动态生成类（字节码）的场景有：</p><ul><li>Java 1.4之后的反射实现。传送门：</li><ul><li><a href="http://rednaxelafx.iteye.com/blog/548536" data-editable="true" data-title="关于反射调用方法的一个log">关于反射调用方法的一个log</a></li></ul><li>Java 1.3开始<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html" data-editable="true" data-title="Proxy (Java Platform SE 8 )" class="">java.lang.reflect.Proxy</a>的实现，会动态根据给定的接口和handler来生成类</li><li>Java 5开始的annotation，其背后的类也是动态生成的Proxy。传送门：</li><ul><li><a href="http://rednaxelafx.iteye.com/blog/1148983" data-editable="true" data-title="Java annotation的实例是什么类的？">Java annotation的实例是什么类的？</a><br></li></ul><li>Java 7开始的JSR 292实现的MethodHandle / LambdaForm到Java字节码的编译</li><li>Java 8开始的Nashorn将JavaScript编译为Java字节码</li><li>Java 8开始的Nashorn里的joni正则表达式库，将正则表达式编译到Java字节码</li><li>Java 8开始的默认的Java lambda表达式背后的字节码生成，相当于自动生成了跟手写的匿名内部类相似的东西。传送门：</li><ul><li><a href="https://www.zhihu.com/question/51491241/answer/126232275" data-editable="true" data-title="Java中普通lambda表达式和方法引用本质上有什么区别？ - RednaxelaFX 的回答">Java中普通lambda表达式和方法引用本质上有什么区别？ - RednaxelaFX 的回答</a><br></li></ul><li>Java 9开始的indify string concatenation，对使用Java中“+”运算符来拼接字符串的表达式做动态字节码生成。传送门：</li><ul><li><a href="http://openjdk.java.net/jeps/280" data-editable="true" data-title="JEP 280: Indify String Concatenation">JEP 280: Indify String Concatenation</a><br></li></ul><li>（待补充）</li></ul><br><p>其中MethodHandle的LambdaForm实现与Nashorn都是比较新的实现，它们里面有些思路是相当有趣的。回头再展开来说。例如它们会为了有效地存储数据而根据需要的数据类型/结构来生成存储数据的对象。例如说Nashorn里实现可以存8个字段的JavaScript对象的背后的Java类，是一个叫做“JO8”的类，而这个类就是根据需要动态生成出来的。同理，MethodHandle中有一系列叫做“BoundMethodHandle”的东西，可以捕获参数的值（读作“currying”），其存储参数的类也是动态生成出来的，例如说Species_LII表示能按顺序保存1个引用类型、2个int类型字段的类。</p><p>Java 7新加入的invokedynamic指令现在被广泛应用于“compact encoding of boilerplate code”（我得想想怎么组织语言来用中文说…）。上面提到的Java lambda表达式、indify string concat都是这样的例子。</p><p>============================================<br></p><h2><b>其它场景</b></h2><br><br><p>在需要动态访问Java对象属性但又需要规避反射开销的地方，动态字节码生成也是很常见的。例如：</p><ul><li>（待补充）</li></ul><br><br><p>在JVM上实现的动态语言，要性能好的话，生成Java字节码也是必经之路。有些语言可以静态编译出Java Class（例如Groovy），而更多还是在运行时生成Class（有些可能可以缓存生成的Class）。除了前面提到的Nashorn外，动态生成字节码的还例如：</p><ul><li>JRuby</li><li>Jython</li><li>（待补充）</li></ul><br><br><p>比完整的编程语言更轻量级的“表达式语言”（expression language）也很流行用动态字节码生成。例如：</p><ul><li>MVEL</li><li>（待补充）</li></ul><br><br><p>有些本来是可以静态编译的、在JVM上实现的语言，为了减小发布的JAR包大小，也有可能会选择用动态类生成来仅在运行时需要某些类的时候才将它们生成出来。例如：</p><ul><li>Scala</li><li>Fortress</li><li>（待补充）</li></ul><br><br><p>有些模版引擎为了提升渲染速度，也会选择做字节码生成。例如：</p><ul><li>各种JSP实现。例如Tomcat会把JSP先生成为Java源码，然后用Eclipse JDT（或者叫ECJ）将其编译到Java字节码。</li><li>淘宝以前尝试过将原本是在AST上解释执行来实现渲染的Velocity模版引擎，改造为将Velocity模版编译为等价的Java源码然后再编译到Java字节码的编译版。</li></ul><br><br><br><p>在动态做bytecode instrumentation的地方（或者说Java类的redefine / retransform）的地方，显然也会用到动态字节码生成。例如说：</p><ul><li>BTrace</li><li>某些AOP实现</li><li>（待补充）</li></ul><br><br><p>有些测试框架会做mock，这些mock类也常常是通过proxy来实现的，所以也会用到上述场景中的其中一些（例如JDK自带的Proxy类）。</p><br><p>============================================</p><br><p>说到动态字节码生成，顺带考察一下一些常用的工具 / 库吧。</p><ul><li><a href="http://asm.ow2.org/" data-editable="true" data-title="ASM">ASM</a></li><li><a href="http://bytebuddy.net/" data-editable="true" data-title="Byte Buddy">Byte Buddy</a></li><li><a href="http://jboss-javassist.github.io/javassist/" data-editable="true" data-title="Javassist">Javassist</a></li><li><a href="https://github.com/cglib/cglib" data-editable="true" data-title="cglib">cglib</a><br></li><li><a href="http://commons.apache.org/proper/commons-bcel/" data-editable="true" data-title="BCEL">BCEL</a><br></li><li>其它：<a href="https://java-source.net/open-source/bytecode-libraries" data-editable="true" data-title="Open Source ByteCode Libraries in Java">Open Source ByteCode Libraries in Java</a></li><li>（待补充）</li></ul><br><br><p>============================================<br></p><br><p>还有啥有趣的大类别这里遗漏了的，或者是每个大类别下有哪些您觉得有趣的例子的，欢迎在评论中补充 ^_^ 我也会慢慢补充上我知道的一些，并且对某些点稍微展开来说说动态生成了怎样的类。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
