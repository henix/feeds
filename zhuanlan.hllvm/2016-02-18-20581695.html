<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[新闻] CPython / 微软 Pyjion / IBM Python+OMR</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20581695">原文</a></p>
<h2><b>大背景</b></h2><br><p>在进入主题前，请先看看IBM Research以前做过的类似项目的经验：Fiorano项目。</p><p>Fiorano是IBM Research做的一次尝试，将IBM J9 JVM所使用的Testarossa（TR）编译器单独拿出来，插入到CPython运行时中为后者提供JIT编译服务。</p><p>传送门：</p><ul><li><a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p169.pdf" data-editable="true" data-title="Adding Dynamically-Typed Language Support to a Statically-Typed Language Compiler: Performance Evaluation, Analysis, and Tradeoffs" class="">Adding Dynamically-Typed Language Support to a Statically-Typed Language Compiler: Performance Evaluation, Analysis, and Tradeoffs</a><br></li><li><a href="http://researcher.watson.ibm.com/researcher/files/us-pengwu/oopsla12-final-dsl.pdf" data-editable="true" data-title="ibm.com 的页面" class="">On the Benefits and Pitfalls of Extending a Statically Typed Language JIT Compiler for Dynamic Scripting Languages</a><br></li></ul><p>结果呢？当然Fiorano没有被整合到官方CPython里，不然现在大家就已经在用它了。但作为研究性项目它还是有点意思的——我觉得最重要的一点，是在一个原本没有打算与高性能JIT编译器搭配使用的runtime上，很难实现出特别有效的优化。在主流JVM上，JIT编译后的代码的速度可以轻易达到解释器速度的10x水平；而Fiorano带上了JIT却也就达到了纯解释执行的CPython的速度的1.2x～2.74x的水平范围，并没有给大家带来多少震撼…</p><br><br><h2><b>Pyjion</b></h2><br><p>项目地址：<a href="https://github.com/Microsoft/Pyjion" data-editable="true" data-title="GitHub - Microsoft/Pyjion: Pyjion" class="">GitHub - Microsoft/Pyjion: Pyjion</a></p><p>开源许可证：MIT</p><p>是的，微软近期也加入了给<a href="https://www.python.org/" data-editable="true" data-title="CPython">CPython</a>加JIT编译器的大混战。微软甚至还有一个寄身于Data Group in Azure组的Python研发组，最近<a href="https://blogs.msdn.microsoft.com/pythonengineering/2016/02/12/welcome/" data-title="开始对外宣传" class="" data-editable="true">开始对外宣传</a>。</p><p>项目名是“Pyjion”，读作“pigeon”（鸽子），因为项目主力成员Dino大大想要有Python的Py音节、JIT的Ji音节的词…就找（sheng）到（zao）了这么个词出来。GJ！<br></p><p>说起项目主要成员之一的<a href="http://blogs.msdn.com/b/dinoviehland/" data-editable="true" data-title="Dino Viehland" class="">Dino Viehland</a>大大，他以前是IronPython与DLR的主力开发之一，后来也参与了<a href="http://microsoft.github.io/PTVS/" data-editable="true" data-title="Python Tools for Visual Studio（PTVS）">Python Tools for Visual Studio（PTVS）</a>的开发。大家用Visual Studio / VS Express开发Python爽不？里面就有Dino大大的功劳。</p><p>可见他对Python那可是有深深的怨念…是真爱啊！</p><p>而Pyjion项目的另一个主要成员是Brett Cannon。他从2003年开始就是CPython的core commiter了。这也是真爱啊！</p><p>未来传送门：</p><ul><li>PyCon US 2016：<a href="https://us.pycon.org/2016/schedule/presentation/1866/" data-editable="true" data-title="Presentation: Pyjion: who doesn’t want faster for free?" class="">Presentation: Pyjion: who doesn’t want faster for free?</a> - 2016-05-30<br></li></ul><br><p>言归正传，这Pyjion到底是啥呢？它是Brett和Dino做的<b>实验产物</b>，为了在保持完全兼容的前提下提升CPython的性能。目前基于的CPython版本是3.6 alpha 1。</p><br><p>项目官网的一句话说明是："A JIT for Python based upon CoreCLR"。它目前的项目目标有三个：</p><ol><li><b>Add a C API to CPython for plugging in a JIT</b>（<a href="https://github.com/Microsoft/Pyjion/blob/master/Patches/python.diff" data-editable="true" data-title="代码">代码</a>） &lt;- 最主要的目标<br></li></ol><br><ol><li>Develop a JIT module using CoreCLR utilizing the C API mentioned in goal #1（<a href="https://github.com/Microsoft/Pyjion/tree/master/Pyjion" data-editable="true" data-title="代码">代码</a>） &lt;- 概念验证用<br></li><li>Develop a C++ framework<br></li></ol><p>目标1很简单，就是给CPython添加一组新的C API及其实现，来为外部的JIT编译器提供接入CPython运行时的钩子。这部分目前设计和实现都很直观，看看上面的代码链接的patch就知道它是啥了——在解释器入口处添加钩子，当有JIT编译器注册进来时，一个函数在即将开始被解释执行时会先尝试JIT编译，如果成功以后就执行JIT出来的机器码；如果不成功就会把该函数标记为不可JIT编译，以后就不再尝试了。</p><p>目前这C API并不太灵活，只允许以Python函数为单元来编译，编译必须对整个函数成功，否则就得整个函数留在解释器里跑。这个API没有考虑到在函数中间跳进JIT编译的代码（On-Stack Replacement，OSR）或从JIT编译的代码中途跳回到解释器（deoptimization）之类的需求。</p><p>目标2的描述方式挺有趣的：把<a href="https://github.com/dotnet/coreclr" data-editable="true" data-title="CoreCLR">CoreCLR</a>当作JIT编译器插入CPython。啥？难道为了JIT还得把整个CoreCLR都拉进来么？太可怕了！</p><p>实际上当然没那么糟糕。这个描述方式感觉是故意说得模糊一些。其实Pyjion只是要使用CoreCLR里带着的<a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-overview.md" data-editable="true" data-title="RyuJIT编译器">RyuJIT编译器</a>来为CPython服务。但是当前的RyuJIT的实现依赖了CLR / CoreCLR提供的JIT编译器接口，所以要单独使用RyuJIT的话，得要把原本由CLR / CoreCLR提供的一些服务/接口给模拟出来才行。这个模拟层在Pyjion代码里就是CExecutionEngine、CorJitInfo等类。</p><p>换言之，Pyjion自身在pyjit.dll中，而它并不真的需要依赖整个CoreCLR（主体位于coreclr.dll），而只需要其中的RyuJIT（位于clrjit.dll）及其必须依赖的库（例如gcinfo），然后提供CExecutionEngine、CorJitInfo等类的实现给RyuJIT模拟出它所依赖CoreCLR的一些功能。</p><p>据说RyuJIT其实是希望未来与CLR / CoreCLR分离开，变得更独立，便于在诸如Pyjion这样的场景单独使用。目前RyuJIT与CLR确实不是由同一个组负责开发的，要分家也很合理。但未来会如何发展，外界也只能拭目以待了。</p><p>那么Pyjion是如何使用RyuJIT的呢？</p><p>它并没有实现一个RyuJIT的前端，直接把CPython字节码转换为RyuJIT的IR；而是把CPython字节码先转换为CLR的<a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language" data-editable="true" data-title="MSIL">MSIL</a>字节码，然后再让RyuJIT去把这MSIL编译成机器码，最后安装到CPython运行时里去运行。这种做法或许多少与项目组成员之前做IronPython的经历有关系，或者是与RyuJIT现在与CLR / CoreCLR的偶和有关系。</p><p>不过这里生成的MSIL只用了MSIL的指令集，而没有完全实现标准的Assembly格式；其元数据相关部分都是Pyjion用自己的数据结构模拟出来的，所以无法将生成的MSIL交给诸如ildasm之类的工具来查看。</p><p>具体的转换步骤是：</p><ul><li>CPython的解释器入口<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Patches/python.diff#L364" data-editable="true" data-title="Pyjion/python.diff at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub" class="">PyEval_EvalFrameEx()</a>调用JIT编译器JitCompile()函数，传入CPython字节码。<br></li><li>JIT编译器入口<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pyjit.cpp#L52" data-editable="true" data-title="Pyjion/pyjit.cpp at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub" class="">JitCompile()</a>创建AbstractInterpreter与PythonCompiler，调用<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp#L2971" data-editable="true" data-title="Pyjion/absint.cpp at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub" class="">AbstractInterpreter::compile()</a>开始编译流程。</li><li><a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.h#L157" data-editable="true" data-title="AbstractInterpreter" class="">AbstractInterpreter</a>类充当CPython字节码的解析器（parser），一边抽象解释CPython字节码一边调用PythonCompiler来生成MSIL。<br></li><ul><li><a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp#L59" data-editable="true" data-title="Pyjion/absint.cpp at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub" class="">AbstractInterpreter::preprocess()</a>先把CPython字节码里偷懒而设计的"Block"给预处理掉，把循环的跳转目标、异常处理块的边界给找出来并扁平化。可能有同学不理解“偷懒”是什么意思：Python的字节码编译器在处理循环和异常相关的控制流时，没有在编译器里处理嵌套关系，而是把“作用域栈”留到了解释器里。而正确的做法是<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.h#L185" data-editable="true" data-title="在编译器里处理掉它">在编译器里处理掉它</a>，例如这样：<a href="https://www.zhihu.com/question/28992261/answer/43400987" data-editable="true" data-title="如何对C语言的FOR语句给出一个生成中间代码的语法制导定义？ - RednaxelaFX 的回答" class="">如何对C语言的FOR语句给出一个生成中间代码的语法制导定义？ - RednaxelaFX 的回答</a><br></li><li><a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp#L190" data-editable="true" data-title="AbstractInterpreter::interpret()" class="">AbstractInterpreter::interpret()</a>遍历一遍整个CPython函数的字节码，找出基本块边界、异常处理块的边界，以及收集一些后续优化可能用到的信息。例如说它会做个很保守的逃逸分析来判断哪些值没有逃逸，后面就可以选择对它们做进一步特殊优化，例如下文提到的tagged pointer。<br></li><li><a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp#L1796" data-editable="true" data-title="AbstractInterpreter::compile_worker()" class="">AbstractInterpreter::compile_worker()</a>一个个基本块遍历CPython字节码并生成MSIL字节码。<br></li></ul><li><a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pycomp.h#L221" data-editable="true" data-title="PythonCompiler" class="">PythonCompiler</a>会把每种CPython字节码的操作映射为合适的MSIL字节码序列。简单的CPython字节码可以直接映射为一条或多条MSIL字节码，而复杂的字节码则映射为Pyjion的<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.h" data-editable="true" data-title="intrinsic函数">intrinsic函数</a>的调用。</li><ul><li>例如两个Python对象相加，会映射为对Pyjion提供的“<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.cpp#L87" data-editable="true" data-title="PyJit_Add()">PyJit_Add()</a>”函数的调用，而这个函数会调用回到CPython运行时里的实现。</li><li>具体生成MSIL的有一个<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/ilgen.h#L66" data-editable="true" data-title="ILGenerator">ILGenerator</a>类。它与.NET的<a href="https://msdn.microsoft.com/en-us/library/system.reflection.emit.ilgenerator.aspx" data-title="System.Reflection.Emit.ILGenerator" class="" data-editable="true">System.Reflection.Emit.ILGenerator</a>颇为神似。</li></ul><li><a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pycomp.cpp#L1084" data-editable="true" data-title="Pyjion/pycomp.cpp at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub" class="">PythonCompiler::emit_compile()</a> -&gt; <a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/ilgen.h#L470" class="" data-editable="true" data-title="Pyjion/ilgen.h at 2450d32ddefc14a884e5d76d88df08222ae0dbb6 · Microsoft/Pyjion · GitHub">ILGenerator::compile()</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/b16ff5935ff9df3211798f18f0c951666ae27774/src/jit/ee_il_dll.cpp#L135" data-editable="true" data-title="CILJit::compileMethod()">CILJit::compileMethod()</a> MSIL传入RyuJIT开始编译。<br></li><li>接下来就交给RyuJIT编译，得到编译好的机器码以及一些相关的元数据。</li></ul><p>换句话说，Pyjion这种实现JIT编译的方式，实际的效果是把一个Python函数的字节码全部粘合到一起，去掉了解释器循环自身的开销，但是大部分复杂的操作还是调用回到CPython运行时去处理的。</p><p>要说在语义层面上的优化，Pyjion尝试了给CPython添加<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/taggedptr.h" data-editable="true" data-title="tagged pointer" class="">tagged pointer</a>来减少小整数的内存开销，顺带提高运行性能（因为实际数据就伪装在指针里，离运算更近了）。但为了保证兼容性，tagged pointer只在被JIT编译的函数内部使用，一到<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/absint.cpp#L3051" data-editable="true" data-title="return_value">return_value</a>之类的要暴露（escape）出去的地方就还是装箱（box）回到原本的对象形态。对应的intrinsic实现在<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/intrins.cpp#L2291" data-editable="true" data-title="TAGGED_METHOD宏">TAGGED_METHOD宏</a>里（例如<a href="https://github.com/Microsoft/Pyjion/blob/2450d32ddefc14a884e5d76d88df08222ae0dbb6/Pyjion/pycomp.cpp#L1277" data-editable="true" data-title="PyJit_Add_Int()" class="">PyJit_Add_Int()</a>就是这样来的）。</p><p>原本CPython解释器在解释执行每N条字节码指令后都会做些周期性检查，例如是否应该释放GIL来给别的线程机会执行。Pyjion把Python代码JIT编译后，这些周期性检查就安放在用户代码里的循环回跳（backedge）的地方。这跟HotSpot VM的JIT编译代码选择的放置safepoint polling的位置一样。</p><p>总体来说，Pyjion采用了一种非常保守的实现方式，很容易保证正确性，但能带来的性能提升也会非常有限。保守是否就意味着容易被接受呢？难说…搞不好会给人太多想像空间结果很失望orz</p><p>希望当前的保守设计只是一个过渡阶段。毕竟这个设计比Fiorano的做法还要保守，能带来的性能提升就更有限了。</p><p>在JIT编译之外，Pyjion还有没有向CPython注入任何其它东西呢？一点也没有。GIL、GC、监控之类的额外功能一概没碰。</p><br><p>更新传送门：<a href="https://www.zhihu.com/question/49182031/answer/115462306" class="" data-title="如何看待微软 Pyjion的进展以及CPython性能优化的未来？ - RednaxelaFX的回答">如何看待微软 Pyjion的进展以及CPython性能优化的未来？ - RednaxelaFX 的回答</a></p><br><br><h2><b>IBM Python+OMR</b></h2><br><p>回头一点点更新。先放个传送门讲解背景：<a href="https://www.zhihu.com/question/38480772/answer/76715935" data-editable="true" data-title="如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答">如何评价 IBM 的 Ruby + OMR？ - RednaxelaFX 的回答</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
