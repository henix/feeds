<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>MLsub大概是个什么鬼.三</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/70664217">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-50d5e0dadc4d32a2414185f712f8c530_b.jpg" alt=""></div><p>这一章我们重新整理一下之前的类型系统 , 因为之前定义的类型系统并不是特别的细化,所以这回我们将根据上回的类型系统添加细节</p><p>ML语言的优点是表达式只用写一次 , 然后使用<b>let</b>可以在不同类型下使用多次,打个比方</p><p><img src="https://www.zhihu.com/equation?tex=let+%5C+g+%3D+%5Clambda+x.x+%5C+in+%5C+%28...g...g...%29" alt="let \ g = \lambda x.x \ in \ (...g...g...)" eeimg="1"/></p><p><b>g</b>函数就会被类型 <img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha.%5Calpha+%5Crightarrow+%5Calpha" alt="\forall \alpha.\alpha \rightarrow \alpha" eeimg="1"/> 约束然后<b>g</b>就可以被当成<img src="https://www.zhihu.com/equation?tex=%5Ctau_n+%5Crightarrow+%5Ctau_n" alt="\tau_n \rightarrow \tau_n" eeimg="1"/>但是 , 假如这个类型不能完全的泛化就操蛋了 就比如</p><p><img src="https://www.zhihu.com/equation?tex=%5Clambda+f.let+%5C+g+%3D+%5Clambda+x.if+%5C+f+%5C+x+%5C+then+%5C+x+%5C+else+%5C+x+%5C+in+%5C+%28...g...g...%29" alt="\lambda f.let \ g = \lambda x.if \ f \ x \ then \ x \ else \ x \ in \ (...g...g...)" eeimg="1"/> </p><p>假如我们有 <img src="https://www.zhihu.com/equation?tex=%5CGamma%28f%29+%3D+%5Calpha+%5Crightarrow+bool" alt="\Gamma(f) = \alpha \rightarrow bool" eeimg="1"/>那么<b>g</b>的类型就是 <img src="https://www.zhihu.com/equation?tex=%5Calpha+%5Crightarrow+%5Calpha" alt="\alpha \rightarrow \alpha" eeimg="1"/>但是这个就不能被完全的泛化因为 <b>g</b>依赖于<b>f</b>.</p><p>添加了子类型之后呢 , 就更加的复杂 , 假如我们有一个函数</p><p><img src="https://www.zhihu.com/equation?tex=%5CGamma%28f%29+%3D+%5Ctau_0+%5Crightarrow+bool" alt="\Gamma(f) = \tau_0 \rightarrow bool" eeimg="1"/> </p><p>然后 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1+%2C+%5Ctau_2" alt="\tau_1 , \tau_2" eeimg="1"/> 都是 <img src="https://www.zhihu.com/equation?tex=%5Ctau_0" alt="\tau_0" eeimg="1"/> 的子类型 , 为了保持 <img src="https://www.zhihu.com/equation?tex=let%5C+x%3De_1%5C+in%5C+e_2" alt="let\ x=e_1\ in\ e_2" eeimg="1"/>的类型是合法的 , 我们就必须确定 <img src="https://www.zhihu.com/equation?tex=e_2%5Be_1%2Fx%5D" alt="e_2[e_1/x]" eeimg="1"/>(可替换) , 我们就必须让上边的类型同时满足 <img src="https://www.zhihu.com/equation?tex=%5Ctau_1%5Crightarrow%5Ctau_1" alt="\tau_1\rightarrow\tau_1" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=%5Ctau_2%5Crightarrow%5Ctau_2" alt="\tau_2\rightarrow\tau_2" eeimg="1"/>但是<b>g</b>的类型是单调的 , 所以我们就必须满足这样的一个东西</p><p><img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha+%5C+where%5C+%5Calpha+%5Cleq+%5Ctau_0.%5Calpha+%5Crightarrow+%5Calpha" alt="\forall \alpha \ where\ \alpha \leq \tau_0.\alpha \rightarrow \alpha" eeimg="1"/></p><p>所以是时候需要重新调整一下类型检查的规则了!</p><h2>类型模板</h2><p>根据<b>TrifonovSmith</b>和<b>Pottier</b>的规则我们把这个新的规则称为<b>Lambda-lifted</b>, 我们使用一个新的 <img src="https://www.zhihu.com/equation?tex=%5B%5CDelta%5D%5Ctau" alt="[\Delta]\tau" eeimg="1"/>其 <img src="https://www.zhihu.com/equation?tex=%5CDelta" alt="\Delta" eeimg="1"/> 是 <img src="https://www.zhihu.com/equation?tex=%5Clambda+-+bound" alt="\lambda - bound" eeimg="1"/> 类型变量的前结束映射 , 这就阻止了自由变量的诞生 , 使得所有的变量都隐士的被泛化 , 然后我们就可以扔掉 <img src="https://www.zhihu.com/equation?tex=%5Cforall" alt="\forall" eeimg="1"/> 了 , 所有的类型都现实的携带他们的依赖信息(但是这并不叫依赖类型)这个我们叫他 <img src="https://www.zhihu.com/equation?tex=%5Clambda-bound%5C+programme%5C+variables" alt="\lambda-bound\ programme\ variables" eeimg="1"/>虽然没有子类型的普通<b>ML</b>没有这方面的问题就是了...</p><p>现在我们就可以给之前的那个<b>g</b>赋予类型了</p><p><img src="https://www.zhihu.com/equation?tex=%5Bf%3A%5Calpha%5Crightarrow%5Cbeta%5D%5Calpha+%5Crightarrow+%5Calpha" alt="[f:\alpha\rightarrow\beta]\alpha \rightarrow \alpha" eeimg="1"/> </p><p>嗯!看起来他是对的~ 为了重新制定规则 , 我们假设所有的表达式都有类型 , 其次通过了<img src="https://www.zhihu.com/equation?tex=%5Calpha+-renaming" alt="\alpha -renaming" eeimg="1"/> , 他的绑定是单一的(这个是为了避免一个叫shadowing的东西) , 所以我们就 把<img src="https://www.zhihu.com/equation?tex=%5CGamma" alt="\Gamma" eeimg="1"/>分成了两个部分 , 一个是单态的 <img src="https://www.zhihu.com/equation?tex=%5CDelta" alt="\Delta" eeimg="1"/> , 另一个是多态的 <img src="https://www.zhihu.com/equation?tex=%5CPi" alt="\Pi" eeimg="1"/>  , 其 <img src="https://www.zhihu.com/equation?tex=%5CDelta" alt="\Delta" eeimg="1"/>映射类型的 <img src="https://www.zhihu.com/equation?tex=%5Clambda+-+bound" alt="\lambda - bound" eeimg="1"/>到单态类型 , 然后 <img src="https://www.zhihu.com/equation?tex=%5CPi" alt="\Pi" eeimg="1"/> 呢就是处理<b>let</b>到一个多态的类型 , 下面是类型规则</p><p><img src="https://www.zhihu.com/equation?tex=%5CDelta+%3A%3A%3D+%5Cin+%7C+%5CDelta++%2C++x%3A%5Ctau%5C%5C+%5CPi+%3A%3A%3D+%5Cin+%7C+%5CPi+%2C+%5Chat%7Bx%7D%3A%5B%5CDelta%5D%5Ctau" alt="\Delta ::= \in | \Delta  ,  x:\tau\\ \Pi ::= \in | \Pi , \hat{x}:[\Delta]\tau" eeimg="1"/> </p><p>所以呢 , 我们可以推出这个东西 <img src="https://www.zhihu.com/equation?tex=%5CPi+%5CVdash+e%3A%5B%5CDelta%5D%5Ctau" alt="\Pi \Vdash e:[\Delta]\tau" eeimg="1"/> , 同时 <img src="https://www.zhihu.com/equation?tex=%5CDelta_1+%5Csqcap+%5CDelta_2" alt="\Delta_1 \sqcap \Delta_2" eeimg="1"/>标志了 <img src="https://www.zhihu.com/equation?tex=dom%5C+%5CDelta+%3D+dom%5C+%5CDelta_1+%5Ccup+dom%5C+%5CDelta_2" alt="dom\ \Delta = dom\ \Delta_1 \cup dom\ \Delta_2" eeimg="1"/> , 同时呢 , 满足 <img src="https://www.zhihu.com/equation?tex=%5CDelta%28x%29%3D%5CDelta_1%28x%29%5Csqcap%5CDelta_2%28x%29" alt="\Delta(x)=\Delta_1(x)\sqcap\Delta_2(x)" eeimg="1"/> </p><p>通常情况下 , 这个转换都会让 <img src="https://www.zhihu.com/equation?tex=%5CDelta" alt="\Delta" eeimg="1"/>的范围乱七八飞 , 除了new(SUB)规则使用的 <img src="https://www.zhihu.com/equation?tex=%5Cleq%5E%5Cforall" alt="\leq^\forall" eeimg="1"/>, 这个结合了子类型和类型变量的实例化的过程 , 这个呢...假设这个子类型是平凡的(我知道 , 数学家骂人都说你是个平凡的(AKA.<b>trivial</b>) , 这里的意思是子类型和父类型相等) , 这个情况下呢<img src="https://www.zhihu.com/equation?tex=%5Cleq%5E%5Cforall" alt="\leq^\forall" eeimg="1"/>关系就被简化成了<b>Hindley-Milner instantiation</b> </p><p><b>理论六 </b><img src="https://www.zhihu.com/equation?tex=%5Cvdash+e%3A%5Ctau%5C+iff+%5CVdash+e%3A%5B%5D%5Ctau" alt="\vdash e:\tau\ iff \Vdash e:[]\tau" eeimg="1"/></p><p>感谢我的上帝 , 这个是proof的!</p><p> 这个证明是使用了一个更强的理论 , 在不是空类型的情况下能用 , 这个的证明就是一个简单的常见的归纳虽然 <img src="https://www.zhihu.com/equation?tex=%5CGamma+" alt="\Gamma " eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=%5CPi%2F%5CDelta" alt="\Pi/\Delta" eeimg="1"/> 环境类型不太兼容</p><p>根据之前的证明 , 我们可以写一下新的类型规则了</p><p><img src="https://www.zhihu.com/equation?tex=%5B%5CDelta%5D%5Ctau%5Cleq%5E%5Cforall%5B%5CDelta%27%5D%5Ctau%27%5C+iff%5C+dom%28%5CDelta%29+%5Csubseteq+dom%28%5CDelta%27%29%5C%5C+and%5C+%5CDelta%27%28x%29%5Cleq+%5Crho%28%5CDelta%28x%29%29%5C+in+%5C+%5Cforall+x.x%5Cin+dom%28%5CDelta%29%5C%5C+and%5C+%5Crho%28%5Ctau%29%5Cleq+%5Ctau%27+%2C+for%5C+some%5C+substitution%5C+%5Crho%5C%5C" alt="[\Delta]\tau\leq^\forall[\Delta&#39;]\tau&#39;\ iff\ dom(\Delta) \subseteq dom(\Delta&#39;)\\ and\ \Delta&#39;(x)\leq \rho(\Delta(x))\ in \ \forall x.x\in dom(\Delta)\\ and\ \rho(\tau)\leq \tau&#39; , for\ some\ substitution\ \rho\\" eeimg="1"/> </p><p><img src="https://www.zhihu.com/equation?tex=%28VAR-%5CPi%29%5Cqquad+%5Cfrac%7B%7D%7B%5CPi%5CVdash%5Chat%7Bx%7D%3A%5B%5CDelta%5D%5Ctau%7D%5CPi%28%5Chat%7Bx%7D%29%3D%5B%5CDelta%5D%5Ctau%5C%5C+%28VAR-%5CDelta%29%5Cqquad%5Cfrac%7B%7D%7B%5CPi%5CVdash+x%3A%5Bx%3A%5Ctau%5D%5Ctau%7D%5C%5C+%28ABS%29%5Cqquad%5Cfrac%7B%5CPi%5CVdash+e%3A%5B%5CDelta+%2C+x%3A%5Ctau%5D%5Ctau%27%7D%7B%5CPi+%5CVdash+%5Clambda+x.e%3A%5B%5CDelta%5D%5Ctau%5Crightarrow%5Ctau%27%7D%5C%5C+%28APP%29%5Cqquad%5Cfrac%7B%5CPi%5CVdash+e_1%3A%5B%5CDelta%5D%5Ctau%5Crightarrow%5Ctau%27%5Cquad%5CPi%5CVdash+e_2%3A%5B%5CDelta%5D%5Ctau%7D%7B%5CPi+%5CVdash+e_1%5C+e_2%3A%5B%5CDelta%5D%5Ctau%27%7D%5C%5C+%28LET%29%5Cqquad%5Cfrac%7B%5CPi%5CVdash+e_1%5B%5CDelta_1%5D%5Ctau_1%5Cquad%5CPi+%2C+%5Chat%7Bx%7D%3A%5B%5CDelta_1%5D%5Ctau_1+%5CVdash+e_2%3A%5B%5CDelta_2%5D%5Ctau_2%7D%7B+++++%5CPi%5CVdash+let%5C+%5Chat%7Bx%7D%3De_1%5C+in+%5C+e_2%3A%5B%5CDelta_1%5Csqcap%5CDelta_2%5D%5Ctau_2++%7D%5C%5C+%28PROJ%29%5Cqquad%5Cfrac%7B%5CPi%5CVdash+e%3A%5B%5CDelta%5D%5C%7Bl%3A%5Ctau%5C%7D%7D%7B%5CPi%5CVdash+e.l%3A%5B%5CDelta%5D%5Ctau%7D%5C%5C+%28SUB%29%5Cqquad%5Cfrac%7B%5CPi%5CVdash+e%3A%5B%5CDelta%5D%5Ctau%7D%7B%5CPi%5CVdash+e%3A%5B%5CDelta%27%5D%5Ctau%27%7D%5B%5CDelta%5D%5Ctau%5Cleq%5E%5Cforall%5B%5CDelta%27%5D%5Ctau%27" alt="(VAR-\Pi)\qquad \frac{}{\Pi\Vdash\hat{x}:[\Delta]\tau}\Pi(\hat{x})=[\Delta]\tau\\ (VAR-\Delta)\qquad\frac{}{\Pi\Vdash x:[x:\tau]\tau}\\ (ABS)\qquad\frac{\Pi\Vdash e:[\Delta , x:\tau]\tau&#39;}{\Pi \Vdash \lambda x.e:[\Delta]\tau\rightarrow\tau&#39;}\\ (APP)\qquad\frac{\Pi\Vdash e_1:[\Delta]\tau\rightarrow\tau&#39;\quad\Pi\Vdash e_2:[\Delta]\tau}{\Pi \Vdash e_1\ e_2:[\Delta]\tau&#39;}\\ (LET)\qquad\frac{\Pi\Vdash e_1[\Delta_1]\tau_1\quad\Pi , \hat{x}:[\Delta_1]\tau_1 \Vdash e_2:[\Delta_2]\tau_2}{     \Pi\Vdash let\ \hat{x}=e_1\ in \ e_2:[\Delta_1\sqcap\Delta_2]\tau_2  }\\ (PROJ)\qquad\frac{\Pi\Vdash e:[\Delta]\{l:\tau\}}{\Pi\Vdash e.l:[\Delta]\tau}\\ (SUB)\qquad\frac{\Pi\Vdash e:[\Delta]\tau}{\Pi\Vdash e:[\Delta&#39;]\tau&#39;}[\Delta]\tau\leq^\forall[\Delta&#39;]\tau&#39;" eeimg="1"/> </p><p>这个就使得<b>MLsub</b>带上子类型后和<b>ML</b>有些定义并不太一样 , 就比如 <img src="https://www.zhihu.com/equation?tex=%5B%5CDelta_1%5D%5Ctau_1" alt="[\Delta_1]\tau_1" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=%5B%5CDelta_2%5D%5Ctau_2" alt="[\Delta_2]\tau_2" eeimg="1"/>我们说他们是相等当他们互相归入时.但是在我们蠢萌的<b>ML</b>里两个类型相等仅当他们看起来一样的时候.</p><p>(这是虽然对的 , 但是蠢萌 , 就好比我说鸭子和一只鸟呱呱叫还喜欢游泳<b>ML</b>告诉我他俩不相等一样) </p><p>我们拿<b>choose</b>函数举例子</p><p><img src="https://www.zhihu.com/equation?tex=1.%5Cqquad%5B%5D%5Calpha%5Crightarrow%5Calpha%5Crightarrow%5Calpha%5C%5C+2.%5Cqquad%5B%5D%5Cbeta%5Crightarrow%5Cgamma%5Crightarrow%28%5Cbeta%5Csqcup%5Cgamma%29" alt="1.\qquad[]\alpha\rightarrow\alpha\rightarrow\alpha\\ 2.\qquad[]\beta\rightarrow\gamma\rightarrow(\beta\sqcup\gamma)" eeimg="1"/> </p><p>第一个在我们蠢萌的<b>ML</b>里面就是 <img src="https://www.zhihu.com/equation?tex=%5Cforall+%5Calpha.%5Calpha%5Crightarrow%5Calpha%5Crightarrow%5Calpha" alt="\forall \alpha.\alpha\rightarrow\alpha\rightarrow\alpha" eeimg="1"/> , 第二个就引入了子类型 , 但是我们可以发现其实他们的定义时一样的但是第二个更加的细化 , 所以 </p><p><img src="https://www.zhihu.com/equation?tex=%5B%5D%5Cbeta%5Crightarrow%5Cgamma%5Crightarrow%28%5Cbeta%5Csqcup%5Cgamma%29%5Cleq%5E%5Cforall%5B%5D%5Calpha%5Crightarrow%5Calpha%5Crightarrow%5Calpha+" alt="[]\beta\rightarrow\gamma\rightarrow(\beta\sqcup\gamma)\leq^\forall[]\alpha\rightarrow\alpha\rightarrow\alpha " eeimg="1"/> </p><p>当我们断定 <img src="https://www.zhihu.com/equation?tex=%5Cbeta+%3D%5Cgamma+%3D%5Calpha" alt="\beta =\gamma =\alpha" eeimg="1"/>时 , 我们甚至可以反过来写因为相等的. 再举一些蠢萌的<b>ML</b>和我们<b>MLsub</b>不一样的地方 , 假如我有第一个式子 , 在<b>ML</b>里 , 输入的两个类型不许是一样的 , 但是在<b>MLsub</b>里可以不一样 , 为什么呢? 因为对于任何<i>α</i>我们都接受任意<i>α</i></p><h2>极类型(我们之前提到过)</h2><p>这个呢我就用自己的话简单的解释一下了</p><p><img src="https://www.zhihu.com/equation?tex=%5Ctau%5E%2B" alt="\tau^+" eeimg="1"/>就是我们可以用作一个函数的输出的类型</p><p><img src="https://www.zhihu.com/equation?tex=%5Ctau%5E%2B+%3A%3A%3D+%5Ctau_1%5E-%5Crightarrow%5Ctau_2%5E%2B+%7C%5C%7Bl_1%3A%5Ctau_1%5E%2B+%2C+...+%2C+l_n%3A%5Ctau_n%5E%2B%5C%7D%7C%5Calpha%7C%5Ctau_1%5E%2B%5Csqcup%5Ctau_2%5E%2B%7C%5Cbot%7C%5Cmu+%5Calpha+.+%5Ctau%5E%2B" alt="\tau^+ ::= \tau_1^-\rightarrow\tau_2^+ |\{l_1:\tau_1^+ , ... , l_n:\tau_n^+\}|\alpha|\tau_1^+\sqcup\tau_2^+|\bot|\mu \alpha . \tau^+" eeimg="1"/> </p><p>这个确保了不会输出巨大无比的类型 <img src="https://www.zhihu.com/equation?tex=%5Ctop" alt="\top" eeimg="1"/>相反的 , <img src="https://www.zhihu.com/equation?tex=%5Ctau%5E-" alt="\tau^-" eeimg="1"/>就是用来输入的 ,  <img src="https://www.zhihu.com/equation?tex=%5Ctop" alt="\top" eeimg="1"/>类型是允许的 , 同时避免引入 <img src="https://www.zhihu.com/equation?tex=%5Csqcup" alt="\sqcup" eeimg="1"/> , 因为我们大多数的带有 <img src="https://www.zhihu.com/equation?tex=%5Ctop" alt="\top" eeimg="1"/>类型的输入的时候我们都不会用到233333</p><p><img src="https://www.zhihu.com/equation?tex=%5Ctau%5E-+%3A%3A%3D+%5Ctau_1%5E%2B%5Crightarrow%5Ctau_2%5E-+%7C%5C%7Bl_1%3A%5Ctau_1%5E-+%2C+...+%2C+l_n%3A%5Ctau_n%5E-%5C%7D%7C%5Calpha%7C%5Ctau_1%5E-%5Csqcap%5Ctau_2%5E-%7C%5Ctop%7C%5Cmu+%5Calpha+.+%5Ctau%5E-" alt="\tau^- ::= \tau_1^+\rightarrow\tau_2^- |\{l_1:\tau_1^- , ... , l_n:\tau_n^-\}|\alpha|\tau_1^-\sqcap\tau_2^-|\top|\mu \alpha . \tau^-" eeimg="1"/> </p><hr/><p>这个是我在飞机上写的 , 我在吃饭前喝了一瓶威士忌 , 然后晕机吐了 , 吃完饭后肚子不舒服又吐了一次 , 多亏我这会买的商务舱座位宽敞 , 我可以把饭放在脚下跑去厕所 , 这回可能有很多不对因为到现在我整个人都是晕的(醉酒+晕机).</p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
