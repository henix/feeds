<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Agda 中的证明，从零到一</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/30686586">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-461e72ecf40a21b6804d43e7201d21de_r.jpg" alt=""></div><p>最近在学 Agda ，感觉摸到了定理证明的门，希望各路大神不吝赐教。这是一个系列，这篇文章讲的太基础是因为它是第一篇哈。原文链接：<a href="http://ice1000.org/2017/11/01/ProofInAgda/">Agda 中的证明，从零到一</a></p><p>类型则命题，程序则证明。这句话表达了定理证明的一个很重要的思想。</p><p>我一开始就没有搞懂这句话在说什么。 在我自认为搞懂的时候，我把我以前没有搞懂的原因归结为我看的教程太垃圾了。</p><p>一开始我理解这个问题的同时，我以为我也理解了之前一个 Haskell 关于 <code class="inline">IO Monad</code> 的问题，但实际上不是我想的那样。 <a href="https://zhuanlan.zhihu.com/p/30686586/h%3Ccode%3Ettps://h%3C/code%3Eackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-1173">Haskell 的 IO Monad 的实现</a> 比我想象的要复杂一些，因此本文不谈 Haskell 。</p><h2>前置知识</h2><p>这是一篇面向略懂 dependent type 的人的定理证明教程，然后你要看得懂类 Haskell 的语法。 因为我在学这个的时候就是只会点 Haskell ，然后用过 GADT 和 type family 模拟过 dependent type 。</p><p>给出一些参考资料：</p><ul><li><a href="http://learn%3Ci%3Eyouahaskell.com/cha%3C/i%3Epters">一个比较简单的 Haskell 入门教程 Learn you a Haskell</a></li><li><a href="https://www.zhihu.com/question/67043774/answer/249019401">虎哥介绍的 GADT</a></li><li><a href="https://www.codewars.com/kata/singletons">介绍 GADT 的 CodeWars Kata: Singletons</a></li><li><a href="https://www.codewars.com/kata/scott-encoding">介绍 GADT 的 CodeWars Kata: Scott Encoding</a></li></ul><h2>声明在前面</h2><p>由于 Agda 语言的特殊性，本文将使用 LaTeX 和代码块来共同展示代码。 前者是为了保证字符的正确显示，后者是为了方便读者复制代码。</p><p>本文不讲 Agda 基本语法和 Emacs 的使用。可能以后会有另外的文章。</p><p>本文主要内容是帮助一个没接触过定理证明但是接触过 dependent type 的人（这就是我接触定理证明之前的状态）理解一个非常非常简单的定理证明的例子。</p><h2>如何理解定理证明</h2><p>首先，我们已经知道，我们这是要用类型表达命题，类型对应的实现来证明这个命题的正确性。</p><p>命题中的基本元素一般是值的类型(而且很多时候都是代数数据类型)，也就是 <equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} p \rightarrow q</equation> 的那个 <equation>p</equation> 或者 <equation>q</equation> 。 而这个 <equation>\rightarrow</equation> 对应的就是 “函数” 这一概念，它组合了两个类型，表达了 “推出” 这一逻辑概念。</p><p>比如，我实现了一个这样的类型的函数：</p><p><equation>p \rightarrow q</equation> </p><code lang="agda">p → q </code><p>那么这个函数的实现就是</p><blockquote>如果 p 成立，则 q 成立</blockquote><p>，或者说，</p><blockquote><equation>p \rightarrow q</equation> </blockquote><p>这个命题的证明。</p><p>再比如，我实现了一个这样的类型的函数：</p><p><equation>p \rightarrow q \rightarrow r </equation> </p><code lang="agda">p → q → r </code><p>那么这个函数的实现就是</p><blockquote>如果 p 成立，那么 “如果 q 成立，那么 r 成立” 这一命题成立</blockquote><p>，或者说，</p><blockquote><equation>p \rightarrow ( q \rightarrow r )</equation> </blockquote><p>这个命题的证明。</p><p>其实我们原本想表达的意思是</p><blockquote><equation> p\ \&amp;\&amp;\ q\rightarrow r </equation> </blockquote><p>但是这个 <equation>\&amp;\&amp;</equation> 关系暂时没讲所以先就这样。</p><p>这就是 “类型则命题，程序则证明” 的含义。</p><p>在 Agda 中，上面的代码应该写成这样：</p><p><equation> \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \proof : \{p\ q\ r : \Set\} \rightarrow p \rightarrow q \rightarrow r </equation> </p><code lang="agda">proof : {p q r : Set} → p → q → r </code><p>下面我们看一些实例。</p><h2>refl 与相等性</h2><p>之所以我没有再学习 Idris 就是因为那些教程没说 <code class="inline">Refl</code> 是啥 (Idris 叫 <code class="inline">Refl</code> ， Agda 叫 <code class="inline">refl</code>) 就直接在代码里面用了，我看的时候就一脸蒙蔽，还以为是我智商太低没看懂他 implicit 的东西。 但是好在我看了一坨很友好的 Agda 代码后民白了。</p><p>首先，我们可以定义这样一个用来表示相等关系的 GADT ，它对于任何一个 Level 的任何一个实例都成立。 这里我们用了 Universal Polymorphism 表达这个 “对于任何一个 Level “ 的概念。</p><p>然后我们使用 <code class="inline">refl</code> 这个类型构造器表达 “这个相等关系成立” 这一事实。</p><p>我们用 <equation>\equiv</equation> 表示他（标准库的定义在 <code class="inline"><a href="http://agda.readthedocs.io/en/v2.5.3/language/built-ins.html#equality">Agda.Builtin.Equality</a></code> 中）：</p><p><equation> \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \begin{align*} &amp; \data\ \_{\equiv}\_\ \{a\} \{A : \Set a\} (x : A) : A \rightarrow \Set a\where \\ &amp;\ \ \refl : x \equiv x \end{align*}</equation> </p><code lang="agda">data _≡_ {a} {A : Set a} (x : A) : A → Set a where
  refl : x ≡ x </code><p>如果你看不懂这个类型签名也没有关系，只需要接受”这个 GADT 只有一个叫 <code class="inline">refl</code> 的类型构造器”这一事实就好了。</p><p>然后我们可以用它进行一些证明。比如我们来证明相等性的传递性，也就是</p><blockquote>如果 a <equation>\equiv</equation> b 并且 b <equation>\equiv</equation> c ，那么 a <equation>\equiv</equation> c</blockquote><p>。然后我们来看看这个命题对应的类型：</p><p><equation> \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_ : \{A : \Set\} \{a\ b\ c : A\} \rightarrow a \equiv b \rightarrow b \equiv c \rightarrow a \equiv c </equation> </p><code lang="agda">_⇆_ : {A : Set} {a b c : A} → a ≡ b → b ≡ c → a ≡ c </code><p>那么我们要怎么实现它，也就是证明它呢？</p><p>我一开始写下了这样的东西：</p><p><equation> \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_\ ab\ bc = ? </equation> </p><code lang="agda">_⇆_ ab bc = ? </code><p>然后我就不知道该怎么办了。</p><p>事实上，这个原本就很简单的证明被我想复杂了。 因为这个定理是不证则明的，那么我们要如何表达，如何通过 <code class="inline">ab</code>, <code class="inline">bc</code> 这两个模式匹配出来的结果进行变换得到这个不证则明的定理呢？</p><p>首先这个模式匹配的参数就不应该这样通配地用 <code class="inline">ab</code>, <code class="inline">bc</code> 来表达。 我们应该把这两个相等关系 (他们的本质是 GADT) 给模式匹配出来。</p><p>由于直接写 <code class="inline">ab</code>, <code class="inline">bc</code> 什么都得不出来，我于是尝试将 <code class="inline">ab</code> <code class="inline">bc</code> 用模式匹配消耗掉，然后 Agda 直接在右边给我自动填入了 <code class="inline">refl</code> ，然后好像就 Q.E.D 了：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_\ \refl\ \refl =\refl </equation> </p><code lang="text">_⇆_ refl refl = refl -- 编译通过！ </code><p>这是为什么呢？我们来分别看下这两种写法的含义。</p><h2>使用 ab bc</h2><p>这样的话实际上是把 <equation>a \equiv b</equation> 和 <equation> b \equiv c</equation> 两个条件当成了”变量”而不是作为”条件”。 也就是说，当使用 <code class="inline">abbc</code> 时，右边就需要”通过 <equation>a \equiv b</equation> 和 <equation>b \equiv c</equation> 这两个条件，再对这两个条件套用一些变换，得出 <equation>a \equiv c</equation> ”。</p><p>在这个时候，编译器并没有把 <equation>a \equiv b</equation> 和 <equation>b \equiv c </equation> 当成既成条件，而是当成了 “变量” 。</p><p>这就回到了我们原本的需求，我们原本就是需要写出一个 <equation>a \equiv b\ \&amp;\&amp;\ b \equiv c \Rightarrow a \equiv c</equation> 的变换。</p><p>如果要用变换强行实现的话，可以使用 <code class="inline">with</code> 语句（就是 Agda 的 <code class="inline">case of</code>）把这两个变量模式匹配出来，然后直接得证。 这里给出一个代码实现。</p><p><equation> \begin{eqnarray} \_{\leftrightarrows}_1\_\ ab\ bc \with ab\ &amp;|&amp;bc \\ ... \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \refl\ &amp;|&amp;\refl = \refl \end{eqnarray}</equation> </p><code lang="agda">_⇆₁_ ab bc with ab  | bc
...           | refl | refl = refl </code><p>这种方法和下面的做法是等价的。</p><p>如果你没有看懂这一坨，可以尝试继续读下去，说不定看完下面那坨你就懂了。</p><h2>使用 refl</h2><p>由于 <equation>a \equiv b</equation> 已经是一个条件了，我们直接把它的值取出来。 这时，右边的代码就 <b>已经是建立在</b> <equation>a \equiv b</equation> <b>和</b> <equation>b \equiv c</equation> <b>这两个既成条件下</b> 的了，因此这时 Agda 已经认为 <code class="inline">a</code> <code class="inline">b</code> <code class="inline">c</code> 三者相等了。</p><p>利用这一点，我们直接使用 <code class="inline">refl</code> 是没有问题的。</p><p><equation>\_{\leftrightarrows}_0\_\ \refl\ \refl = \refl </equation> </p><code lang="agda">_⇆₀_ refl refl = refl </code><h2>顺带一提</h2><p>当然我们也可以这样写，这是一个语法糖：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \refl {\leftrightarrows}_0\refl = \refl </equation> </p><code lang="agda">refl ⇆₀ refl = refl</code><p>之前那个比较 trivial 的模式匹配也可以这样写：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect}\begin{eqnarray} ab\ {\leftrightarrows}_1\ ab \with ab\ &amp;|&amp;bc \\ ... \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \refl\ &amp;|&amp;\refl = \refl \end{eqnarray}</equation> </p><code lang="agda">ab ⇆₁ bc with ab  | bc
...         | refl | refl = refl </code><h2>另一个例子</h2><p>现在你肯定有点感觉了，但是这个例子太 trivial 你又感觉自己有点没懂， 那么我们再来看看这个稍微复杂点的例子帮你加深一下理解。</p><p>首先：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \forall\ \{ a \}\ \{ A : \Set a \} </equation> </p><p>表示 Universal Polymorphism 。然后考虑一个函数，我们有：</p><p><equation>\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \begin{align*} &amp; \ggg : \forall\ \{a\ b\}\ \{A : \Set a\}\ \{B : \Set b\} \{m\ n\} \{f : A \rightarrow B\} \rightarrow m \equiv n \rightarrow f\ m \equiv f\ n \\ &amp; \ggg \refl = \refl \end{align*}</equation> </p><code lang="agda">⋙ : ∀ {a b} {A : Set a} {B : Set b} {m n} {f : A → B} → m ≡ n → f m ≡ f n
⋙ refl = refl </code><p>和上面一样，在建立了 <i>m</i>≡<i>n</i>m≡n 的基础上，可以直接用 <code class="inline">refl</code> 表达他们对于同一个函数应用的结果相等。</p><p>我是在 <a href="https://stackoverflow.com/questions/27091668/refl-in-agda-explaining-congruence-property">这个 StackOverflow 问题</a> 里看到这个代码的，唯一的回答里面还有更多的解释。</p><p>这个我就暂时不作过多讲解了，以后再说。</p><h2>结束</h2><p>这个证明太简单了，只有一步，没有什么实际意义，仅用于入门理解。 下一篇文章我们将会进行一个稍微复杂点的关于与或关系的证明。</p><p>我说完了。</p><p><br></p><p><br></p><p>执壶的代码块高亮竟然支持 Agda ，感动中国简直</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
