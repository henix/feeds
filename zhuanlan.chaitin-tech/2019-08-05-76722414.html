<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>DVP 解谜游戏 Writeup | Smart Contract Puzzle</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/76722414">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-8cae571d19e2a74081325f0997a4e0c0_b.jpg" alt=""></div><p>本文作者：<b>Mir4c1e</b>，长亭科技区块链安全研究员</p><p class="ztext-empty-paragraph"><br/></p><blockquote><b>编者按：</b><br/>日前，DVP 去中心化漏洞平台（全称 Decentralized Vulnerability Platform）开启“区块链安全进化论”周年庆典活动，发布“三重礼”线上安全解题挑战活动。<br/>7月23日，经过近40个小时激烈角逐，“二重礼”解谜游戏第二项挑战被长亭科技的大佬“Mir4c1e”和“BubbLess”联手攻克，赢得8ETH的大奖。<br/>小编特邀 Mir4c1e 大佬现身说法，智能合约拼图解题逻辑走一波，快来前排围观。</blockquote><p class="ztext-empty-paragraph"><br/></p><p><b>1. 题名：</b>Deadend</p><p><b>2.挑战类型：</b></p><p>此项挑战为智能合约相关，适合广大区块链开发者。</p><p><b>3. 挑战规则：</b></p><p>参赛者需取走合约内所有余额，并使用解题所用的钱包地址对“dvpisbest”签名，然后将签名后的信息以漏洞方式提交到DVP平台，并附带解题思路。</p><p class="ztext-empty-paragraph"><br/></p><h2><b>一、理解题意</b></h2><p>打开题目链接 (<a href="https://link.zhihu.com/?target=http%3A//challenge2.dvpnet.io/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">challenge2.dvpnet.io/</span><span class="invisible"></span></a>)，看到给出了合约地址(<a href="https://link.zhihu.com/?target=https%3A//ropsten.etherscan.io/address/0xb3597869fbf0cc3c415f955deeedfbe0c7143259" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">ropsten.etherscan.io/ad</span><span class="invisible">dress/0xb3597869fbf0cc3c415f955deeedfbe0c7143259</span><span class="ellipsis"></span></a>)与如下源码：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-ae798d275a4d77b756f8e5168ed306c4_b.jpg" data-size="normal" data-rawwidth="618" data-rawheight="449" class="origin_image zh-lightbox-thumb" width="618" data-original="https://pic1.zhimg.com/v2-ae798d275a4d77b756f8e5168ed306c4_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-ae798d275a4d77b756f8e5168ed306c4_b.jpg" data-size="normal" data-rawwidth="618" data-rawheight="449" class="origin_image zh-lightbox-thumb lazy" width="618" data-original="https://pic1.zhimg.com/v2-ae798d275a4d77b756f8e5168ed306c4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-ae798d275a4d77b756f8e5168ed306c4_b.jpg"/><figcaption>图：题目页面部分截图</figcaption></figure><p class="ztext-empty-paragraph"><br/></p><p>从给出的源码里注意到 constructor 里有 assembly 片段，且最后提前进行了 return 操作，因此得知题目一定是替换了链上真实的字节码，而源码应仅供参考。断定此题是个 Honeypot Contract。另外合约地址上有一个 ETH ，因此目标就是转走这个 ETH 。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-3882dc14c804fb282df2c8b85afa8500_b.jpg" data-caption="" data-size="normal" data-rawwidth="585" data-rawheight="215" class="origin_image zh-lightbox-thumb" width="585" data-original="https://pic1.zhimg.com/v2-3882dc14c804fb282df2c8b85afa8500_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-3882dc14c804fb282df2c8b85afa8500_b.jpg" data-caption="" data-size="normal" data-rawwidth="585" data-rawheight="215" class="origin_image zh-lightbox-thumb lazy" width="585" data-original="https://pic1.zhimg.com/v2-3882dc14c804fb282df2c8b85afa8500_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-3882dc14c804fb282df2c8b85afa8500_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>由 solidity 中 bytes 的编码格式可知，add(0x20,b)是实际数据的开始， mload(b) 返回的是 (bytes)b 最前面 32 字节内容，即 len(b) 。</p><p>由此知，实际链上字节码是传入的参数 b 。</p><p>于是查看[合约的部署交易]（<a href="https://link.zhihu.com/?target=https%3A//ropsten.etherscan.io/tx/0xfb1a05122ebd80cc0828e1906c59e43890e9a7e323de9f63eefa88f33a08503d" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">ropsten.etherscan.io/tx</span><span class="invisible">/0xfb1a05122ebd80cc0828e1906c59e43890e9a7e323de9f63eefa88f33a08503d</span><span class="ellipsis"></span></a>)，把 input 里的 b 拿出来逆向即可：</p><div class="highlight"><pre><code class="language-text">0x608060405260405161002338038061002383398101604052805101805160208201f300000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000006706080604052600436106100565763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416632d1d744a811461006c......90fd5b92915050560000000000000000000000000000000000</code></pre></div><blockquote><i>0xf300 通常是 creation code 的结束标志，后面是完整的 b，0x670 是 b 的长度，可知后面几乎都是 b 的实际内容（除去末尾的 0 们）。（通常在 creation code 和参数间是 runtime code ，但由于提前 return ，且出题人编译时应该开启了 optimization ，所以此段省略了，这种方式可以避免由于调换 runtime code 导致 input 过长。</i></blockquote><p class="ztext-empty-paragraph"><br/></p><p>废话说多了。</p><p>既然题目目的是获得合约 ETH ，一定需要转账功能，于是反汇编搜了一下 call 字节码，看到在 0x05eb 有一个，跟前后汇编操作加一起是 msg.sender.transfer(address(this).balance)，所以只需要调用合约走到这里就好了。</p><p class="ztext-empty-paragraph"><br/></p><h2>二、逆向</h2><p>一开始感觉核心是猜数字的算法，但大概看了一下没有把算法搞得很清楚。于是拿源码作参考，拿头逆了一下，理解了代码逻辑。</p><p>函数只有 isPass，show_hand，0xd5a7f198 三个，前两个看了一下还好，第三个逻辑最复杂于是重点关照。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-cd8bc23bbd1ead67839849806db32780_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="535" class="origin_image zh-lightbox-thumb" width="939" data-original="https://pic1.zhimg.com/v2-cd8bc23bbd1ead67839849806db32780_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-cd8bc23bbd1ead67839849806db32780_b.jpg" data-caption="" data-size="normal" data-rawwidth="939" data-rawheight="535" class="origin_image zh-lightbox-thumb lazy" width="939" data-original="https://pic1.zhimg.com/v2-cd8bc23bbd1ead67839849806db32780_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-cd8bc23bbd1ead67839849806db32780_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>先看到要求 msg.sender 末尾字节是 0x11 ，否则 revert ，套路 match 。</p><p>由于当时是用合约调用测试的，方便起见先 patch 了一下字节码过去这里。把 0x14 eq 换成了 0x17 or 。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-5f18ece3950b0a570cbd71e3a24f49a9_b.jpg" data-caption="" data-size="normal" data-rawwidth="520" data-rawheight="395" class="origin_image zh-lightbox-thumb" width="520" data-original="https://pic2.zhimg.com/v2-5f18ece3950b0a570cbd71e3a24f49a9_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-5f18ece3950b0a570cbd71e3a24f49a9_b.jpg" data-caption="" data-size="normal" data-rawwidth="520" data-rawheight="395" class="origin_image zh-lightbox-thumb lazy" width="520" data-original="https://pic2.zhimg.com/v2-5f18ece3950b0a570cbd71e3a24f49a9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-5f18ece3950b0a570cbd71e3a24f49a9_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>​接下来不难发现有一个循环：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-87a3a3b6d7cbb89d61d88634f89a0eef_b.jpg" data-caption="" data-size="normal" data-rawwidth="725" data-rawheight="318" class="origin_image zh-lightbox-thumb" width="725" data-original="https://pic4.zhimg.com/v2-87a3a3b6d7cbb89d61d88634f89a0eef_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-87a3a3b6d7cbb89d61d88634f89a0eef_b.jpg" data-caption="" data-size="normal" data-rawwidth="725" data-rawheight="318" class="origin_image zh-lightbox-thumb lazy" width="725" data-original="https://pic4.zhimg.com/v2-87a3a3b6d7cbb89d61d88634f89a0eef_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-87a3a3b6d7cbb89d61d88634f89a0eef_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p> var8 是 i，经 0x14 次循环后跳出，在这之前如果 var8&amp;0xff &gt;= 某数就跪了，然后每次循环时 var5 左移 2 字节再加上一个表达式的结果。</p><p>看一下 label_02db :</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-814093dd5536e3c7d60aae40c7d272d2_b.jpg" data-caption="" data-size="normal" data-rawwidth="666" data-rawheight="156" class="origin_image zh-lightbox-thumb" width="666" data-original="https://pic3.zhimg.com/v2-814093dd5536e3c7d60aae40c7d272d2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-814093dd5536e3c7d60aae40c7d272d2_b.jpg" data-caption="" data-size="normal" data-rawwidth="666" data-rawheight="156" class="origin_image zh-lightbox-thumb lazy" width="666" data-original="https://pic3.zhimg.com/v2-814093dd5536e3c7d60aae40c7d272d2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-814093dd5536e3c7d60aae40c7d272d2_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>可知var5需要等于msg.sender，否则revert，所以只要看出来循环里的算法就好了，这里可以直接逆也可以调试探索。</p><p class="ztext-empty-paragraph"><br/></p><h2><b>三、调试</b></h2><p>既然前面知道了 b 值，可以在 remix 里模拟部署调试，顺带打上 patch 。</p><p>二话不说先传一堆数进去瞅瞅：</p><div class="highlight"><pre><code class="language-text">target.call.value(0).gas(0x10000000)(0xd5a7f198, 0x41, 0x42, 0x43, 0x44,0x45,0x46,0x47,0x48,0x49);</code></pre></div><p>探索了一下发现，参数处理阶段有这样逻辑：</p><figure data-size="small"><noscript><img src="https://pic2.zhimg.com/v2-8db8027b17ae4d5de4600633574e6c91_b.jpg" data-caption="" data-size="small" data-rawwidth="743" data-rawheight="356" class="origin_image zh-lightbox-thumb" width="743" data-original="https://pic2.zhimg.com/v2-8db8027b17ae4d5de4600633574e6c91_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-8db8027b17ae4d5de4600633574e6c91_b.jpg" data-caption="" data-size="small" data-rawwidth="743" data-rawheight="356" class="origin_image zh-lightbox-thumb lazy" width="743" data-original="https://pic2.zhimg.com/v2-8db8027b17ae4d5de4600633574e6c91_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-8db8027b17ae4d5de4600633574e6c91_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-1d1b6d6ad47d132597aa2ddc8391a758_b.jpg" data-caption="" data-size="normal" data-rawwidth="283" data-rawheight="550" class="content_image" width="283"/></noscript><img src="https://pic1.zhimg.com/v2-1d1b6d6ad47d132597aa2ddc8391a758_b.jpg" data-caption="" data-size="normal" data-rawwidth="283" data-rawheight="550" class="content_image lazy" width="283" data-actualsrc="https://pic1.zhimg.com/v2-1d1b6d6ad47d132597aa2ddc8391a758_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>（之类的</p><p>等价于：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-33d5eeb33e488c554e8c4b23367dfd22_b.png" data-caption="" data-size="normal" data-rawwidth="629" data-rawheight="81" class="origin_image zh-lightbox-thumb" width="629" data-original="https://pic3.zhimg.com/v2-33d5eeb33e488c554e8c4b23367dfd22_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-33d5eeb33e488c554e8c4b23367dfd22_b.png" data-caption="" data-size="normal" data-rawwidth="629" data-rawheight="81" class="origin_image zh-lightbox-thumb lazy" width="629" data-original="https://pic3.zhimg.com/v2-33d5eeb33e488c554e8c4b23367dfd22_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-33d5eeb33e488c554e8c4b23367dfd22_b.png"/></figure><p class="ztext-empty-paragraph"><br/></p><p>因为数据随便传的， tmp 此时是 0x4300 。</p><p>继续调试，先走过之前打的 patch ：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-75e7c0c3024c32e726c71fa2a99faecb_b.jpg" data-caption="" data-size="normal" data-rawwidth="358" data-rawheight="150" class="content_image" width="358"/></noscript><img src="https://pic4.zhimg.com/v2-75e7c0c3024c32e726c71fa2a99faecb_b.jpg" data-caption="" data-size="normal" data-rawwidth="358" data-rawheight="150" class="content_image lazy" width="358" data-actualsrc="https://pic4.zhimg.com/v2-75e7c0c3024c32e726c71fa2a99faecb_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>之后发现已经进入了 var8&lt;0x14 循环里，到了之前说的如果小于某个数就会 assert 跪掉那里，看一下此时：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-badca1fd2e7a3394fcf06444d2adec90_b.jpg" data-caption="" data-size="normal" data-rawwidth="343" data-rawheight="725" class="content_image" width="343"/></noscript><img src="https://pic1.zhimg.com/v2-badca1fd2e7a3394fcf06444d2adec90_b.jpg" data-caption="" data-size="normal" data-rawwidth="343" data-rawheight="725" class="content_image lazy" width="343" data-actualsrc="https://pic1.zhimg.com/v2-badca1fd2e7a3394fcf06444d2adec90_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>了解到是 tmp 之前存到了 memory ，这里又读出来，所以只要 tmp&gt;=0x14 就可以。</p><p>继续分析，容易看出循环中是把 memory[0xa0] 取出来，然后从最高位开始每次取1字节，与相邻前字节 xor ，右拼接到结果（即 var5）中，经过 0x14==20 次后刚好是地址长度，再跟 msg.sender 比对，一致则通过。</p><p>于是简单计算一下：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-f9ba8e1b8fdf8c7c499918de36ff36b2_b.jpg" data-caption="" data-size="normal" data-rawwidth="672" data-rawheight="203" class="origin_image zh-lightbox-thumb" width="672" data-original="https://pic3.zhimg.com/v2-f9ba8e1b8fdf8c7c499918de36ff36b2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-f9ba8e1b8fdf8c7c499918de36ff36b2_b.jpg" data-caption="" data-size="normal" data-rawwidth="672" data-rawheight="203" class="origin_image zh-lightbox-thumb lazy" width="672" data-original="https://pic3.zhimg.com/v2-f9ba8e1b8fdf8c7c499918de36ff36b2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-f9ba8e1b8fdf8c7c499918de36ff36b2_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>修改一下传参：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-155d0a32d98fae9ce6994fb4e3b21272_b.png" data-caption="" data-size="normal" data-rawwidth="879" data-rawheight="93" class="origin_image zh-lightbox-thumb" width="879" data-original="https://pic3.zhimg.com/v2-155d0a32d98fae9ce6994fb4e3b21272_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-155d0a32d98fae9ce6994fb4e3b21272_b.png" data-caption="" data-size="normal" data-rawwidth="879" data-rawheight="93" class="origin_image zh-lightbox-thumb lazy" width="879" data-original="https://pic3.zhimg.com/v2-155d0a32d98fae9ce6994fb4e3b21272_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-155d0a32d98fae9ce6994fb4e3b21272_b.png"/></figure><p class="ztext-empty-paragraph"><br/></p><p>可以看到过了这一环：</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-4fad99e2be3078206e9349515ebecf27_b.jpg" data-caption="" data-size="normal" data-rawwidth="381" data-rawheight="829" class="content_image" width="381"/></noscript><img src="https://pic4.zhimg.com/v2-4fad99e2be3078206e9349515ebecf27_b.jpg" data-caption="" data-size="normal" data-rawwidth="381" data-rawheight="829" class="content_image lazy" width="381" data-actualsrc="https://pic4.zhimg.com/v2-4fad99e2be3078206e9349515ebecf27_b.jpg"/></figure><p class="ztext-empty-paragraph"><br/></p><p>过了之后再看卡在了哪里，发现是在 0x0584 处的一个 jumpi 失败了，如果成功的话可以走到 0x05d4 ，即 transfer 的位置。</p><p>于是可知基本是最后一步了，分析得知最后一步是计算出的 finalFlag 如果符合</p><p>(finalFlag - (finalFlag / 0x03e8 * 0x03e8)) &lt; 0xa，则可以通过，通过率 1%，相比于源码高了一些。</p><p>最后懒了没有分析 finalFlag 计算方式，已知随机量是 msg.sender，timestamp， blocknumber，直接批量生成 0x11 结尾地址，跑了十几个就出来了。</p><p class="ztext-empty-paragraph"><br/></p><p><b>成功的交易：</b></p><p><a href="https://link.zhihu.com/?target=https%3A//ropsten.etherscan.io/tx/0x59851896a46048108655f1ed0c46d51270957fae18b62b61772abff83976fd81" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">ropsten.etherscan.io/tx</span><span class="invisible">/0x59851896a46048108655f1ed0c46d51270957fae18b62b61772abff83976fd81</span><span class="ellipsis"></span></a></p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-fa83a8b8a0fa57c6e7c77c6457047d75_b.png" data-caption="" data-size="normal" data-rawwidth="768" data-rawheight="108" class="origin_image zh-lightbox-thumb" width="768" data-original="https://pic2.zhimg.com/v2-fa83a8b8a0fa57c6e7c77c6457047d75_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-fa83a8b8a0fa57c6e7c77c6457047d75_b.png" data-caption="" data-size="normal" data-rawwidth="768" data-rawheight="108" class="origin_image zh-lightbox-thumb lazy" width="768" data-original="https://pic2.zhimg.com/v2-fa83a8b8a0fa57c6e7c77c6457047d75_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-fa83a8b8a0fa57c6e7c77c6457047d75_b.png"/></figure><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
