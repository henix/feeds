<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Weighted linear matroid parity问题</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/27679823">原文</a></p>
<p>今年的STOC best papers之一是<a href="http://www.opt.mist.i.u-tokyo.ac.jp/~iwata/" data-editable="true" data-title="Satoru Iwata">Satoru Iwata</a>和<a href="http://infoshako.sk.tsukuba.ac.jp/~kobayashi/eindex.html" data-editable="true" data-title="Yusuke Kobayashi">Yusuke Kobayashi</a>的文章. A weighted linear matroid parity algorithm. </p><p>这个实际上2011年Pap和Iwata都独自说已经有算法了, 但是花了这么多年才把paper写出来... Pap的文章还没有发出来... 有兴趣的可以去看那个快60页纸的technical report, 全是算法的描述和证明. <a href="http://www.keisu.t.u-tokyo.ac.jp/research/techrep/data/2017/METR17-01.pdf" class="" data-editable="true" data-title="u-tokyo.ac.jp 的页面">http://www.keisu.t.u-tokyo.ac.jp/research/techrep/data/2017/METR17-01.pdf</a></p><p>那么什么是weighted linear matroid parity(也叫matroid matching)问题, 为什么这文章可以拿STOC best paper呢?</p><blockquote><p><b>Input:</b> 给一些集合<equation>S_1,\ldots,S_n</equation>. 每个集合里有两个向量(任何域都可以). 集合<equation>S_i</equation>有weight <equation>w(S_i)</equation>. 让<equation>S=\bigcup_{i=1}^n S_i</equation>.</p><p><b>Output: </b>找到<equation>X\subset [n]</equation>, 使得 </p><p>1. 对于任意<equation>i, j\in X</equation>,<equation>i\neq j</equation>,不存在向量同时存在于<equation>S_i</equation>和<equation>S_j
</equation>中.</p><p>2. <equation>\bigcup_{i\in X} S_i</equation>是<equation>S
</equation>的一个基.</p><p>3. 满足上诉两个条件的<equation>X</equation>下<equation>\sum_{i \in X} w(S_i)</equation>最小.</p></blockquote><br><br><p>一个算法问题, 见得多了之后, 感觉如果有多项式时间算法, 也就那几种.</p><p>一般的设计方法, 自然是算法课上的那些常见的设计方法. DP啊, Greedy啊这些常见的小锤子. 不行的话, 就要开始拿稍微强劲一点的锤子来砸了.</p><br><p>有两个稍微常见的锤子</p><p>- min-cost (integral) flow</p><p>- max weight matching</p><br><p>这两个锤子在无向图上都可以规约到一个更高端的问题, 最大weight的vertex disjoint S-path问题.</p><br><br><p>给一个图G=(V,E), 以及一个一些特殊的顶点<equation>T\subset V</equation>. <equation>T</equation>被partition为<equation>\mathcal{S}=\{S_1,\ldots,S_k\}</equation> , 其中<equation>S_i\subset V</equation>. 每个边上有一个weight. 一个path叫做<equation>\mathcal{S}</equation>-path, 如果这个path的起点属于<equation>S_i</equation>, 终点属于<equation>S_j</equation>, 中间不通过任何其他<equation>T</equation>里面的顶点.</p><p><equation>\mathcal{S}</equation> -path问题: 找到一些vertex disjoint的S-paths, 使得weight的和最大.</p><p>这个看起来非常NP-hard的问题可以规约到weighted linear matroid parity问题上. 而Iwata和Kobayashi的这个文章就解决了这个问题, 给了我们可以合二为一的大锤子. 现在我挥舞着这个锤子会想我以前的哪些钉子/手机可以用这个来敲...</p><br><p>最近在日本这边交流, 和上诉的作者都见过面聊了聊. 我在想的几个问题被告知是一些我听都没有听过的问题的特殊版本. 不愧是(理论的)组合优化强国啊.</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
