<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>你好，类型（八）：Subtype</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34887359">原文</a></p>
<p></p><img src="https://pic2.zhimg.com/v2-ef77da94879248acb923dc4d037b5b31_r.jpg" data-caption="" data-size="normal" data-rawwidth="900" data-rawheight="554"><h2><b>对象和类</b></h2><p>子类型几乎是面向对象编程语言所特有的，<br>在面向对象的编程语言中，计算是由<b>对象和对象之间消息传递</b>来完成的，<br>对象（object）通常包含两个组成部分，数据（data）和代码（method）。</p><p>其中数据（data）一般是可变的，由每个对象所专有，通常称之为<b>对象的状态</b>（state）。<br>代码（method）通常是不可变的。</p><p>大部分面向对象的编程语言是基于类（class）的，但类（class）却并不是必须的，<br>一个支持<b>词法作用域</b>的编程语言中，<b>闭包</b>（closure）就是包含内部状态的对象（object）。</p><code lang="racket">; let over lambda
(define counter
    (let ((n 0)) 
        (lambda () (set! n (+ n 1)) n)))
(counter)    ; 1
(counter)    ; 2</code><p>类（class）实际上可以看做一个工厂函数，用来生成对象。</p><code lang="racket">; lambda over let over lambda
(define create-counter
    (lambda () 
        (let ((n 0)) 
            (lambda () (set! n (+ n 1)) n))))
(define counter 
    (create-counter))
(counter)    ; 1
(counter)    ; 2</code><h2><b>类型和类</b></h2><img src="https://pic1.zhimg.com/v2-695c87c5b9dd61927f549375f2286d3d_r.jpg" data-caption="" data-size="normal" data-rawwidth="463" data-rawheight="180"><p>类型（type）是与类（class）不同的概念。<br>对象所属的类（class）是它的工厂函数，<br>而对象的类型（type），是它在形式系统中，所具有的逻辑性质（logical property）。</p><p>子类（subclass），通过编写与父类之间的差别，创建一个新类，目的是<b>代码复用</b>。</p><blockquote>A subclass is a differential description of a class.</blockquote><p>包含子类（subclass）之后，众多类（class）之间，<br>构成一个<b>前序关系</b>（<a href="https://en.wikipedia.org/wiki/Preorder">preorder</a>）（自反，传递）。</p><p>而引入子类型（subtype）是为了放宽类型系统的约束条件。<br>例如， <equation>(\lambda r:\{x:Nat\}.~r.x)~\{x=0,y=1\}</equation> <br>其中， <equation>r</equation> 的类型为 <equation>\{x:Nat\}</equation> ，表示<b>记录类型</b>（record）。</p><p><equation>\{x=0,y=1\}</equation> 的类型为 <equation>\{x:Nat,y:Nat\}</equation> ，与 <equation>r</equation> 的类型不同，<br>根据推导规则， <equation>\frac{\Gamma\vdash t_1:T_1\to T_2~~~~\Gamma\vdash t_2:T_1}{\Gamma\vdash t_1~t_2:T_2}</equation> ，<br> <equation>(\lambda r:\{x:Nat\}.~r.x)~\{x=0,y=1\}</equation> 将无法通过类型检查。</p><p>可是，函数中确实只用到了 <equation>r.x</equation> ，多传一个 <equation>y</equation> 理应总是安全的。<br>因此，不带子类型的简单类型化 <equation>\lambda</equation> 演算，它的推导规则就显得过于严谨了。</p><p>我们可以引入记录类型（record）之间的<b>子类型关系</b>，记为，<br> <equation>\{x:Nat,y:Nat\}&lt;:\{x:Nat\}</equation> <br>用于表示类型 <equation>\{x:Nat,y:Nat\}</equation> 是 <equation>\{x:Nat\}</equation> 的子类型。</p><p>对于记录类型来说，这里可能有些奇怪，因为更“小”的类型却包含更多的字段。</p><p>一般的， <equation>S&lt;:T</equation> 表示 <equation>S</equation> 为 <equation>T</equation> 的<b>子类型</b>，<br>如果在某个上下文中，期待一个 <equation>T</equation> 类型的项，那么 <equation>S</equation> 在这个上下文中也是合法的，<br>即， <equation>\frac{\Gamma\vdash t:S~~~~S&lt;:T}{\Gamma\vdash t:T}</equation> ，该推导规则，通常称之为<b>安全替换原则</b>。</p><p>为了能够安全替换，子类型应该具有<b>自反性</b>： <equation>S&lt;:S</equation> ，<br>还应该具有<b>传递性</b>， <equation>\frac{S&lt;:U~~~~U&lt;:T}{S&lt;:T}</equation> 。</p><h2><b>Top类型与Bottom类型</b></h2><img src="https://pic1.zhimg.com/v2-7bdba08bbfb0afbb007f92fcc302e575_r.jpg" data-caption="" data-size="normal" data-rawwidth="596" data-rawheight="436"><p><b>（1）Top类型</b></p><p>理解了子类型之后，我们就可以引入一个新的类型常量 <equation>Top</equation> ，称为<b>Top类型</b>。<br>所有其它类型都是它的子类型， <equation>S&lt;:Top</equation> 。</p><p>因为具有自反性和传递性，子类型之间构成了一个<b>前序关系</b>（<a href="https://en.wikipedia.org/wiki/Preorder">preorder</a>），<br>由于记录类型中的字段，顺序是可以置换的，<br> <equation>\{x:Nat,y:Nat\}</equation> 和 <equation>\{y:Nat,x:Nat\}</equation> 分别为另一个的子类型，<br>因此，子类型关系不是一个<b>偏序关系</b>（<a href="https://en.wikipedia.org/wiki/Partially_ordered_set#Formal_definition">partial order</a>）（自反，传递，反对称）。</p><p><b>（2）Bottom类型</b></p><p>除了Top类型之外，我们很自然的会问，<br>是否存在一个类型，它是所有其他类型的子类型，<br>为此，我们需要对类型系统再扩展，引入 <equation>Bot</equation> 类型常量，称为<b>Bottom类型</b>，<br>满足 <equation>Bot&lt;:T</equation> 。</p><p><equation>Bot</equation> 类型中是不能有<b>闭值</b>的，否则，假设 <equation>v</equation> 是 <equation>Bot</equation> 类型的一个值，<br>则根据安全替换原则有 <equation>v:Top\to Top</equation> ，表明 <equation>v</equation> 是一个函数，<br>此外还有 <equation>v:\{\}</equation> ，表明 <equation>v</equation> 是一个记录，<br>但是 <equation>v</equation> 作为一个值，不可能既是函数又是记录，矛盾。</p><p>我们在第六篇中提到过，所谓<b>封闭</b>，指的是不含自由变量。<br>所谓<b>值</b>，就是事先约定好的<b>项的子集</b>。<br>值都是<b>范式</b>，没有求值规则可被继续使用，是对<b>项</b>求值的最终结果。</p><p><equation>Bot</equation> 类型中虽然不能有闭值，<br>但是却可以包含<b>受阻项</b>，即事先约定好的<b>不是值的范式</b>。</p><p>例如，我们可以指定 <equation>error</equation> 是一个受阻项（不给它指定求值规则），<br>再指定它为<b>Bottom类型</b>， <equation>error:Bot</equation> 。<br>这样 <equation>error</equation> 就可以在不同的上下文中，被提升为不同的类型了。</p><p><equation>\lambda x:T.</equation> <br><equation>~~~~if ... then</equation> <br><equation>~~~~~~~~result</equation> <br><equation>~~~~else</equation> <br><equation>~~~~~~~~error</equation><br>以上 <equation>\lambda</equation> 项是良类型的（well typed），无论 <equation>result</equation> 是何种类型。</p><p>关于Top类型和Bottom类型，我们最后再看一个例子，<br><a href="https://www.typescriptlang.org/index.html">TypeScript</a>中的<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#any">any</a>类型，是一个Top类型，<br>而<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#never">never</a>类型，是一个Bottom类型。</p><h2><b>总结</b></h2><p>本文为简单类型化 <equation>\lambda</equation> 演算添加了子类型，<br>并且对比了类（class）与类型（type）这两个概念。</p><p>lambda calculus是函数式编程语言的计算模型，<br>前几篇，我们保持基本的演算系统（求值规则）不变，<br>给它添加了不同的类型推导规则，得到了不同的类型系统。</p><p><a href="https://www.nada.kth.se/~karlm/ooteori/ObjectCalculus.pdf">object calculus</a>是面向对象语言的计算模型，<br>在它之上，我们同样可以添加相似的类型系统。</p><p>因此，类型系统是与演算（calculus）独立的概念。<br>这印证了我们之前在第一篇中提到的一句话，<br>类型系统，可以看做是附着在语言语法之上的一套符号证明系统。</p><hr><h2><b>参考</b></h2><p><a href="https://book.douban.com/subject/3864436/">Let Over Lambda</a><br><a href="https://book.douban.com/subject/1761910/">Types and programming languages</a><br><a href="http://lucacardelli.name/Talks/1997-06%20A%20Theory%20of%20Object%20(LICS).pdf">A Theory of Objects</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
