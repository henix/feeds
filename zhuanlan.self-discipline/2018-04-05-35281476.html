<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>语言背后的代数学（九）：笛卡尔闭范畴</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/35281476">原文</a></p>
<p></p><img src="https://pic3.zhimg.com/v2-249328aa0e740de961f0a8ce0c329c51_r.jpg" data-caption="" data-size="normal" data-rawwidth="1240" data-rawheight="775" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><h2><b>回顾</b></h2><p>上文我们简单的介绍了一些范畴论相关的内容，<br><b>范畴</b>由一些<b>对象</b>和<b>箭头</b>组成，范畴之间的箭头称为<b>函子</b>，<br>函子之间的一族箭头称为<b>自然变换</b>。</p><p>范畴的对象不一定是集合，所有的箭头也不一定构成一个集合。<br>如果一个范畴 <equation>C</equation> ，它的对象都是集合，所有的箭头也构成了一个集合，<br>就称该范畴是一个<b>小范畴</b>（<a href="https://en.wikipedia.org/wiki/Category_(mathematics)#Small_and_large_categories">small categories</a>）。</p><h2><b>1. 定义域和值域</b></h2><img src="https://pic4.zhimg.com/v2-07a4c0b329a05ec427d5f5b9e9681ba6_r.jpg" data-caption="" data-size="normal" data-rawwidth="318" data-rawheight="208" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>在集合论中，函数自变量所有可取值的集合，称为函数的<b>定义域</b>，<br>给定函数 <equation>f:A\to B</equation> ，其中 <equation>A</equation> 就是 <equation>f</equation> 的定义域，记为 <equation>D_f</equation> ，<br>集合 <equation>f(A)=\{f(x)|x\in A\}</equation> ，称为 <equation>f</equation> 的<b>值域</b>，记为 <equation>R_f</equation> 。</p><p>在范畴论中，箭头也有定义域和值域的概念。<br>箭头 <equation>f:a\to b</equation> ，表示了对象 <equation>a</equation> 和 <equation>b</equation> 之间的关系，<br>我们称 <equation>a</equation> 为箭头 <equation>f</equation> 的<b>定义域</b>（domain），记为 <equation>dom~f</equation> ，<br> <equation>b</equation> 为箭头 <equation>f</equation> 的<b>值域</b>（codomain），记为 <equation>cod~f</equation> 。</p><p>由此，我们还可以定义范畴 <equation>C</equation> 中，从对象 <equation>a</equation> 到对象 <equation>b</equation> 所有箭头的集合，<br> <equation>hom(a,b)=\{f|f\in C,dom~f=a,cod~f=b\}</equation> ，常被称为<b><a href="https://en.wikipedia.org/wiki/Morphism#Definition">hom-set</a></b>。</p><h2><b>2. 笛卡尔闭范畴</b></h2><img src="https://pic2.zhimg.com/v2-7359d35caef3fc0840b8d5ea4b17cc0f_r.jpg" data-caption="" data-size="normal" data-rawwidth="343" data-rawheight="147" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>笛卡尔闭范畴是一种带有附加结构的范畴，这个名字虽然不是那么熟悉，<br>而实际上，我们经常遇到它。</p><p><b>2.1 笛卡尔积</b></p><p>两个集合 <equation>X</equation> 和 <equation>Y</equation> 的<b>笛卡尔积</b>，是以下所有可能有序对构成的集合，<br> <equation>X\times Y=\{(x,y)|x\in X,y\in Y\}</equation> 。</p><p><b>2.2 笛卡尔积上的函数</b></p><p><equation>f:X\times Y\to Z</equation> ，是从笛卡尔积 <equation>X\times Y</equation> 到 <equation>Z</equation> 的函数，<br>我们可以用两种不同的视角来看待它，</p><p>（1）它是一个一元函数，参数取遍 <equation>X\times Y</equation> 中的所有元素。<br>（2）它是一个二元函数，一个参数来自于 <equation>X</equation> ，另一个来自于 <equation>Y</equation> 。</p><p>原则上，这两种理解应该是不同的，然而它们却是等价的。</p><p><b>2.3 柯里化</b></p><img src="https://pic4.zhimg.com/v2-6059ea733638bb9ffd73dcabe9510b88_r.jpg" data-caption="" data-size="normal" data-rawwidth="496" data-rawheight="232" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><p>笛卡尔闭范畴就是反映这一类性质的数学结构，<br>一个范畴中，定义在乘积对象 <equation>a\times b</equation> 上的箭头 <equation>f</equation> ，<br>总是可以“自然的”由定义在某一个对象 <equation>a</equation> 或 <equation>b</equation> 上的箭头来决定。</p><p>这就是<b>柯里化</b>（curring）的概念，<br>将一个二元函数柯里化指的是，将它看成一个一元函数，这个函数返回另一个一元函数。</p><p>假设 <equation>f:X\times Y\to Z</equation> 是一个函数，<br>令 <equation>Z^Y=\{f|f(y)\in Z,y\in Y\}</equation> 是所有 <equation>Y</equation> 到 <equation>Z</equation> 的函数，<br>则存在唯一的 <equation>g=X\to Z^Y</equation> ，使得 <equation>g(x)(y)=f(x,y)</equation> ， <equation>\forall x\in X,y\in Y</equation> 。<br>函数 <equation>g</equation> 称为 <equation>f</equation> 的<b>柯里化</b>。</p><p>用hom-set的术语来表述就是，存在一个一一映射，使得，<br> <equation>hom(X\times Y,Z)\cong hom(X,Z^Y)</equation> </p><p><b>2.4 Cartesian Closed</b></p><p>将以上柯里化的概念推广到范畴论中，我们就有，<br>一个<b>笛卡尔闭范畴</b>（cartesian closed category） <equation>C</equation> ，是满足以下几个额外条件的范畴。</p><p>（1） <equation>C</equation> 中存在一个对象 <equation>1</equation> ，使得对于任意对象 <equation>A\in C</equation> ，有唯一的箭头 <equation>A\to 1</equation> ，<br>这样的对象 <equation>1</equation> ，称为<b>终对象</b>（<a href="https://en.wikipedia.org/wiki/Initial_and_terminal_objects">terminal object</a>）。</p><p>（2）对于任意两个对象 <equation>X</equation> 和 <equation>Y</equation> ，范畴 <equation>C</equation> 中存在一个对象 <equation>X\times Y</equation> ，<br>以及两个箭头 <equation>p_1</equation> 和 <equation>p_2</equation> ，使得， <equation>p_1:X\times Y\to X</equation> ， <equation>p_2:X\times Y\to Y</equation> 。</p><p>（3）对于任意两个对象 <equation>Y</equation> 和 <equation>Z</equation> ，<br>范畴 <equation>C</equation> 中存在一个对象 <equation>Z^Y</equation> ，以及一个箭头 <equation>e:Z^Y\times Y\to Z</equation> ，使得，<br>对于任意的箭头 <equation>f:X\times Y\to Z</equation> ，存在唯一的箭头 <equation>g:X\to Z^Y</equation> ，<br>有 <equation>f=e\circ (g\times I)</equation> 恒成立。</p><p>即， <equation>(e\circ (g\times I))(X\times Y)=e((g\times I)(X\times Y))=e(Z^Y\times Y)=Z</equation> 。<br>其中 <equation>I:Y\to Y</equation> ，为对象 <equation>Y</equation> 的恒等箭头， <equation>Z^Y</equation> 称为<b>指数对象</b>（exponential object）。</p><img src="https://pic1.zhimg.com/v2-ff51be8d96c9c10cb2fb0995941cd926_r.jpg" data-caption="" data-size="normal" data-rawwidth="470" data-rawheight="302" data-watermark="" data-original-src="" data-watermark-src="" data-private-watermark-src=""><h2><b>3. 项的解释</b></h2><p>在<a href="https://zhuanlan.zhihu.com/p/35170799">第六篇</a>中，为了解释简单类型化 <equation>\lambda</equation> 演算，<br>我们为每一个 <equation>\lambda</equation> 项，找到了一个 <equation>\Sigma</equation> 代数中数学对象与之对应，<br>简要的说，我们用 <equation>\Sigma</equation> 代数的载体 <equation>A^\sigma</equation> 来解释基本类型 <equation>\sigma</equation> ，<br>用载体上的函数集 <equation>A^{\sigma\to\tau}</equation> 来解释类型为 <equation>\sigma\to\tau</equation> 的所有函数。</p><p>现在有了笛卡尔闭范畴，我们准备为每一个<b>基本类型</b>选择范畴中的一个对象，<br>而将<b>项常量</b> <equation>b</equation> 解释为范畴中的一个箭头 <equation>unit\to\mathscr{A}[\![b]\!]</equation> （原因在下文解释），<br>其中 <equation>\mathscr{A}[\![\cdot]\!]</equation> 为我们在Henkin模型中定义的<b>含义函数</b>。</p><p><b>3.1 封闭项的解释</b></p><p>我们这样定义一个<b>含义函数</b> <equation>\mathscr{C}[\![\cdot]\!]</equation> ，<br>（1） <equation>\mathscr{C}[\![unit]\!]=unit</equation> <br>（2） <equation>\mathscr{C}[\![b]\!]=unit\to\mathscr{A}[\![b]\!]</equation> <br>（3） <equation>\mathscr{C}[\![\sigma\times\tau]\!]=\mathscr{C}[\![\sigma]\!]\times\mathscr{C}[\![\tau]\!]</equation> <br>（4） <equation>\mathscr{C}[\![\sigma\to\tau]\!]=\mathscr{C}[\![\sigma]\!]\to\mathscr{C}[\![\tau]\!]</equation> </p><p><b>3.2 带有自由变量的项</b></p><p>如果 <equation>\Gamma\vdash M:\sigma</equation> 是一个含有自由变量的 <equation>\lambda</equation> 项，<br>则在笛卡尔闭范畴中，它应该解释为从自由变量的语义对象到 <equation>\sigma</equation> 的语义对象的一个箭头，<br> <equation>\mathscr{C}[\![\Gamma\vdash M:\sigma]\!]=\mathscr{C}[\![\Gamma]\!]\to\mathscr{C}[\![\sigma]\!]</equation> 。</p><p>值得一提的是，这里说明了，项常量 <equation>b</equation> 为什么不能被解释为范畴中的对象，<br>而是解释成了箭头 <equation>unit\to\mathscr{A}[\![b]\!]</equation> 。</p><p>其中，类型上下文 <equation>\Gamma</equation> 的解释，定义如下，<br>（1） <equation>\mathscr{C}[\![\varnothing]\!]=unit</equation> <br>（2） <equation>\mathscr{C}[\![\Gamma,x:\sigma]\!]=\mathscr{C}[\![\Gamma]\!]\times\mathscr{C}[\![\sigma]\!]</equation> </p><h2><b>回顾</b></h2><p>本文介绍了笛卡尔闭范畴，是一种具有特殊结构的范畴，<br>它补充了柯里化这一概念所需满足的约束条件。</p><p>接着我们用笛卡尔闭范畴解释了，<br>带有<a href="https://zhuanlan.zhihu.com/p/34815896">单位类型</a>，乘积类型的简单类型化 <equation>\lambda</equation> 演算 <equation>\lambda^{unit,\times,\to}</equation> 。</p><hr><h2><b>参考</b></h2><p><a href="https://zhuanlan.zhihu.com/p/34815896">你好，类型（六）：Simply typed lambda calculus</a><br><a href="https://zhuanlan.zhihu.com/p/35170799">语言背后的代数学（六）：Henkin模型</a><br><a href="https://en.wikipedia.org/wiki/Category_(mathematics)#Small_and_large_categories">Small and Large Categories</a><br><a href="https://en.wikipedia.org/wiki/Class_(set_theory)">Class</a><br><a href="https://book.douban.com/subject/26684696/">Category Theory for Computing Science</a><br><a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">Cartesian closed category</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
