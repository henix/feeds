<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>写给你的金融时间序列分析：补完篇</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/77307871">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-2b3ae835fd9f6b161c9817ca85c4d657_b.jpg" alt=""></div><p><b>摘要</b></p><p>本文介绍时间序列分析中的 GARCH 模型，阐述使用 mean model 和 volatility model 对收益率序列联合建模的方法。</p><h2><b>1 引言</b></h2><p>两年前，我们推出了《写给你的金融时间序列分析》系列，通过四篇文章介绍了金融数据时序分析建模的基础知识。这四篇文章的内容分别为：</p><ul><li><b><a href="https://zhuanlan.zhihu.com/p/38320827" class="internal">基础篇：</a></b>介绍金融时序特性和进行时间序列分析的目的；解释时间序列分析中的核心概念：自相关性。</li><li><b><a href="https://zhuanlan.zhihu.com/p/38321845" class="internal">初级篇：</a></b>说明时间序列建模的过程；介绍时间序列分析中的最基本模型：白噪声和随机游走。</li><li><b><a href="https://zhuanlan.zhihu.com/p/38322333" class="internal">进阶篇：</a></b>介绍时间序列分析中常用的线性模型：AR、MA 以及 ARMA。</li><li><b><a href="https://zhuanlan.zhihu.com/p/38322638" class="internal">应用篇：</a></b>利用 ARMA 对上证指数收益率序列建模，并以此产生交易信号、构建投资策略，以此说明时间序列分析在量化投资领域的应用。</li></ul><p>通过前述四篇文章的介绍可知，金融时间序列分析的核心是找到资产收益率序列的自相关性，并利用它。以 2012 年 1 月 1 日到 2019 年 7 月 31 日上证指数日频对数收益率为例，假设使用 ARMA(3, 2) 对其建模，并考察其残差。下图展示了残差时序以及它的 ACF 和 Partial ACF（PACF）。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-5d5a3c36f0dc39473a7fdc30343c184a_b.jpg" data-caption="" data-size="normal" data-rawwidth="977" data-rawheight="510" class="origin_image zh-lightbox-thumb" width="977" data-original="https://pic3.zhimg.com/v2-5d5a3c36f0dc39473a7fdc30343c184a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-5d5a3c36f0dc39473a7fdc30343c184a_b.jpg" data-caption="" data-size="normal" data-rawwidth="977" data-rawheight="510" class="origin_image zh-lightbox-thumb lazy" width="977" data-original="https://pic3.zhimg.com/v2-5d5a3c36f0dc39473a7fdc30343c184a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-5d5a3c36f0dc39473a7fdc30343c184a_b.jpg"/></figure><p>从 ACF 和 PACF 上不难看出，在很多 lags 上，自相关系数是超过 95% 的置信区间的；而从最上面一副图中也能明显看出收益率序列的一大特征 —— 波动率聚类。如果把残差取平方，并再次作图，上述波动率聚类则会变得更加直观。它在数学上被称为条件异方差（conditional heteroskedasticity）。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-cabd6652bc4d1fb655278c5bd902587c_b.jpg" data-caption="" data-size="normal" data-rawwidth="963" data-rawheight="503" class="origin_image zh-lightbox-thumb" width="963" data-original="https://pic1.zhimg.com/v2-cabd6652bc4d1fb655278c5bd902587c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-cabd6652bc4d1fb655278c5bd902587c_b.jpg" data-caption="" data-size="normal" data-rawwidth="963" data-rawheight="503" class="origin_image zh-lightbox-thumb lazy" width="963" data-original="https://pic1.zhimg.com/v2-cabd6652bc4d1fb655278c5bd902587c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-cabd6652bc4d1fb655278c5bd902587c_b.jpg"/></figure><p>上述结果意味着，仅使用 ARMA 对收益率序列建模是不够的，它对条件异方差无能为力。为了解决这个问题需要对波动率建模，即使用 <b>Generalized Autoregressive Conditional Heteroskedasticity（GARCH）模型</b>。</p><p>不介绍 GARCH 的时间序列分析系列大抵是不完整的；此外也有小伙伴留言说能不能写写 GARCH。所以今天就来补作业了，也因此给这篇文章起了个“补完篇”的名字。</p><p>考虑到本系列前四篇“狠狠”的参考了 <a href="https://link.zhihu.com/?target=http%3A//quantstart.com" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">quantstart.com</span><span class="invisible"></span></a> 上相关文章的“优良传统”，我在本文第 3 小节介绍 GARCH 的数学模型时也会再次借鉴（参考文献中有链接）。最后，再给 <a href="https://link.zhihu.com/?target=http%3A//quantstart.com" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">quantstart.com</span><span class="invisible"></span></a> 打个 call（必须给足它 credits），它上面的所有文章都非常值得一读。</p><p>下文以资产收益率序列作为研究对象，介绍相关概念：第 2 节解释模型的结构；第 3 节介绍 ARCH 和 GARCH 的数学背景知识；第 4 节说明如何使用 ARMA 和 GARCH 对收益率的条件均值和条件方差进行联合建模；第 5 节针对上证指数做简单实证；第 6 节总结全文。</p><h2><b>2 模型的结构</b></h2><p>首先来看看“条件异方差”一词。</p><p>波动率聚类说明不同阶段收益率的方差是不同的，这就是异方差性（heteroskedastic）。而很多时候，资产收益率表现出高波动伴随着高波动时期（大牛市或者股灾的时候），而低波动又往往伴随着低波动，因此<b>波动率之间是存在序列相关性的</b>，这就是“条件”一词的来源。将二者结合就有了条件异方差。</p><p><b>使用 GARCH 建模，是为了在 </b><img src="https://www.zhihu.com/equation?tex=r_t" alt="r_t" eeimg="1"/><b> 的线性自相关性之上考虑其方差之间的相关性，即把均值模型和波动率模型放在一个整体框架中考虑（Tsay 2010）。</b>假设 t – 1 时刻所有已知的信息为 <img src="https://www.zhihu.com/equation?tex=F_%7Bt-1%7D" alt="F_{t-1}" eeimg="1"/> ，则当给定 <img src="https://www.zhihu.com/equation?tex=F_%7Bt-1%7D" alt="F_{t-1}" eeimg="1"/> 时，t 时刻收益率的条件均值和条件方差可写为：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Brll%7D+%5Cmu_t%26%3D%26%5Cdisplaystyle%5Cmbox%7BE%7D%5Br_t%7CF_%7Bt-1%7D%5D%5C%5C+%5Csigma_t%5E2%26%3D%26%5Cdisplaystyle%5Cmbox%7Bvar%7D%28r_t%7CF_%7Bt-1%7D%29%3D%5Cmbox%7BE%7D%5Cleft%5B%28r_t-%5Cmu_t%29%5E2%7CF_%7Bt-1%7D%5Cright%5D+%5Cend%7Barray%7D" alt="\begin{array}{rll} \mu_t&amp;=&amp;\displaystyle\mbox{E}[r_t|F_{t-1}]\\ \sigma_t^2&amp;=&amp;\displaystyle\mbox{var}(r_t|F_{t-1})=\mbox{E}\left[(r_t-\mu_t)^2|F_{t-1}\right] \end{array}" eeimg="1"/> </p><p>对于条件均值  <img src="https://www.zhihu.com/equation?tex=%CE%BC_t" alt="μ_t" eeimg="1"/> ，它可以是一个常数，也可以使用我们已经掌握的 ARMA 模型对其建模。一旦有了  <img src="https://www.zhihu.com/equation?tex=%CE%BC_t" alt="μ_t" eeimg="1"/>  的模型， <img src="https://www.zhihu.com/equation?tex=r_t" alt="r_t" eeimg="1"/>  可以写作：</p><p><img src="https://www.zhihu.com/equation?tex=r_t%3D%5Cmu_t%2B%5Cepsilon_t" alt="r_t=\mu_t+\epsilon_t" eeimg="1"/> </p><p>上式中  <img src="https://www.zhihu.com/equation?tex=%CE%B5_t" alt="ε_t" eeimg="1"/>  是 t 时刻的扰动或者新息。结合上式和条件方差的定义可知，t 时刻收益率 r_t 的条件方差由  <img src="https://www.zhihu.com/equation?tex=%CE%B5_t" alt="ε_t" eeimg="1"/>  的方差决定：</p><p><img src="https://www.zhihu.com/equation?tex=%5Csigma_t%5E2%3D%5Cmbox%7Bvar%7D%28r_t%7CF_%7Bt-1%7D%29%3D%5Cmbox%7Bvar%7D%28%5Cepsilon_t%7CF_%7Bt-1%7D%29" alt="\sigma_t^2=\mbox{var}(r_t|F_{t-1})=\mbox{var}(\epsilon_t|F_{t-1})" eeimg="1"/> </p><p>从模型结构不难看出，为了考虑条件异方差则需要对 <img src="https://www.zhihu.com/equation?tex=%CE%B5_t" alt="ε_t" eeimg="1"/> 建模，而这正是 GARCH 的目标。</p><h2><b>3 ARCH 和 GARCH</b></h2><p>在介绍 GARCH 之前不妨先来看看 ARCH，毕竟 GARCH 只是在它前面加了一个 G（generalized）从而将其推广了。ARCH 由 Engle (1982) 提出，它是第一个对波动率建模的系统性框架。</p><p>对于 <img src="https://www.zhihu.com/equation?tex=%CE%B5_t" alt="ε_t" eeimg="1"/> ，考虑如下模型（其中 <img src="https://www.zhihu.com/equation?tex=%CF%89_t" alt="ω_t" eeimg="1"/> 表示均值为 0、方差为 1 的白噪声）：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Brll%7D+%5Cepsilon_t%26%3D%26%5Csigma_t%5Comega_t%5C%5C+%5Csigma_t%5E2%26%3D%26%5Calpha_0%2B%5Calpha_1%5Cepsilon_%7Bt-1%7D%5E2+%5Cend%7Barray%7D" alt="\begin{array}{rll} \epsilon_t&amp;=&amp;\sigma_t\omega_t\\ \sigma_t^2&amp;=&amp;\alpha_0+\alpha_1\epsilon_{t-1}^2 \end{array}" eeimg="1"/> </p><p>把 <img src="https://www.zhihu.com/equation?tex=%CF%83_t" alt="σ_t" eeimg="1"/> 的表达式带回到 <img src="https://www.zhihu.com/equation?tex=%CE%B5_t" alt="ε_t" eeimg="1"/> 中可得：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cdisplaystyle%5Cepsilon_t%3D%5Comega_t%5Csqrt%7B%5Calpha_0%2B%5Calpha_1%5Cepsilon_%7Bt-1%7D%5E2%7D" alt="\displaystyle\epsilon_t=\omega_t\sqrt{\alpha_0+\alpha_1\epsilon_{t-1}^2}" eeimg="1"/> </p><p><b>这个关于序列 </b><img src="https://www.zhihu.com/equation?tex=%5C%7B%CE%B5_t%5C%7D" alt="\{ε_t\}" eeimg="1"/><b> 的模型称作一阶自回归条件异方差模型，也就是最简单的 ARCH(1) 过程</b> —— 括号里的系数 1 表明自回归模型中只考虑了 lag = 1 阶。为了直观看出方差序列之间的关系，将上式两边平方：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Brll%7D+%5Cmbox%7Bvar%7D%28%5Cepsilon_t%29%26%3D%26%5Cmbox%7BE%7D%5B%5Cepsilon_t%5E2%5D-%28%5Cmbox%7BE%7D%5B%5Cepsilon_t%5D%29%5E2%5C%5C+%26%3D%26%5Cmbox%7BE%7D%5B%5Cepsilon_t%5E2%5D%5C%5C+%26%3D%26%5Cmbox%7BE%7D%5B%5Comega_t%5E2%5D%5Cmbox%7BE%7D%5B%5Calpha_0%2B%5Calpha_1%5Cepsilon_%7Bt-1%7D%5E2%5D%5C%5C+%26%3D%26%5Cmbox%7BE%7D%5B%5Calpha_0%2B%5Calpha_1%5Cepsilon_%7Bt-1%7D%5E2%5D%5C%5C+%26%3D%26%5Calpha_0%2B%5Calpha_1%5Cmbox%7Bvar%7D%28%5Cepsilon_%7Bt-1%7D%29+%5Cend%7Barray%7D" alt="\begin{array}{rll} \mbox{var}(\epsilon_t)&amp;=&amp;\mbox{E}[\epsilon_t^2]-(\mbox{E}[\epsilon_t])^2\\ &amp;=&amp;\mbox{E}[\epsilon_t^2]\\ &amp;=&amp;\mbox{E}[\omega_t^2]\mbox{E}[\alpha_0+\alpha_1\epsilon_{t-1}^2]\\ &amp;=&amp;\mbox{E}[\alpha_0+\alpha_1\epsilon_{t-1}^2]\\ &amp;=&amp;\alpha_0+\alpha_1\mbox{var}(\epsilon_{t-1}) \end{array}" eeimg="1"/> </p><p>上式清晰的显示了 <img src="https://www.zhihu.com/equation?tex=%5Cmbox%7Bvar%7D%28%CE%B5_t%29" alt="\mbox{var}(ε_t)" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=%5Cmbox%7Bvar%7D%28%CE%B5_%7Bt-1%7D%29" alt="\mbox{var}(ε_{t-1})" eeimg="1"/> 之间的关系。前面我们提到， <img src="https://www.zhihu.com/equation?tex=%5C%7B%CE%B5_t%5C%7D" alt="\{ε_t\}" eeimg="1"/> 的模型是一个 ARCH(1) 过程。从 <img src="https://www.zhihu.com/equation?tex=%5Cmbox%7Bvar%7D%28%CE%B5_t%29" alt="\mbox{var}(ε_t)" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=%5Cmbox%7Bvar%7D%28%CE%B5_%7Bt-1%7D%29" alt="\mbox{var}(ε_{t-1})" eeimg="1"/> 的关系可知，<b>一个 ARCH(1) 过程的方差 —— 即 var(ε_t) —— 正是一个 AR(1)，即一阶自回归过程。</b></p><p>接下来我们照猫画虎，将 ARCH(1) 简单推广到多阶 lags，就得到 ARCH(p) 过程：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cdisplaystyle%5Cepsilon_t%3D%5Comega_t%5Csqrt%7B%5Calpha_0%2B%5Csum_%7Bi%3D1%7D%5Ep%5Calpha_i%5Cepsilon_%7Bt-i%7D%5E2%7D" alt="\displaystyle\epsilon_t=\omega_t\sqrt{\alpha_0+\sum_{i=1}^p\alpha_i\epsilon_{t-i}^2}" eeimg="1"/> </p><p>类似的，我们可以说一个 ARCH(p) 过程的方差是一个 AR(p)，即 p 阶自回归过程；这相当于对方差使用 AR(p) 来建模。<b>既然能对方差用 AR(p) 来建模，那么很自然的一个问题就是，为什么不把 MA(q) 也加上得到方差的 ARMA(p, q) 模型呢？如此便引出了 GARCH(p, q)。</b></p><p>对于  <img src="https://www.zhihu.com/equation?tex=%CE%B5_t" alt="ε_t" eeimg="1"/> ，考虑如下模型：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Brll%7D+%5Cepsilon_t%26%3D%26%5Csigma_t%5Comega_t%5C%5C+%5Csigma_t%5E2%26%3D%26%5Cdisplaystyle%5Calpha_0%2B%5Csum_%7Bi%3D1%7D%5E%7Bp%7D%5Calpha_i%5Cepsilon_%7Bt-i%7D%5E2%2B%5Csum_%7Bj%3D1%7D%5E%7Bq%7D%5Cbeta_j%5Csigma_%7Bt-j%7D%5E2+%5Cend%7Barray%7D" alt="\begin{array}{rll} \epsilon_t&amp;=&amp;\sigma_t\omega_t\\ \sigma_t^2&amp;=&amp;\displaystyle\alpha_0+\sum_{i=1}^{p}\alpha_i\epsilon_{t-i}^2+\sum_{j=1}^{q}\beta_j\sigma_{t-j}^2 \end{array}" eeimg="1"/> </p><p>这就是大名鼎鼎的 <b>GARCH(p, q) 模型 —— (p, q) 阶的广义自回归条件异方差模型。</b>有了 GARCH 我们就可以用它对收益率建模了。</p><h2><b>4 使用 ARMA + GARCH 对收益率建模</b></h2><p>本小节来看看如何在第二节介绍的体系下使用 ARMA(p, q) 和 GARCH(p&#39;, q&#39;) 来对 <img src="https://www.zhihu.com/equation?tex=r_t" alt="r_t" eeimg="1"/> 进行联合建模。为了区分条件均值模型和条件方差模型中的自回归阶数，我特意用了 (p, q) 和 (p&#39;, q&#39;) 表示。</p><p>将前面的内容整合到一起得到关于 <img src="https://www.zhihu.com/equation?tex=r_t" alt="r_t" eeimg="1"/> 的模型如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Brll%7D+r_t%26%3D%26%5Cmu_t%2B%5Cepsilon_t%5C%5C+%5Cmu_t%26%3D%26%5Cdisplaystyle+%5Ctheta_0%2B%5Csum_%7Bi%3D1%7D%5Ep%5Ctheta_i+r_%7Bt-i%7D%2B%5Csum_%7Bj%3D1%7D%5Eq%5Ceta_j%5Cepsilon_%7Bt-j%7D+%5C%5C+%5Cepsilon_t%26%3D%26%5Csigma_t%5Comega_t%5C%5C+%5Csigma_t%5E2%26%3D%26%5Cdisplaystyle%5Calpha_0%2B%5Csum_%7Bi%3D1%7D%5E%7Bp%5E%5Cprime%7D%5Calpha_i%5Cepsilon_%7Bt-i%7D%5E2%2B%5Csum_%7Bj%3D1%7D%5E%7Bq%5E%5Cprime%7D%5Cbeta_j%5Csigma_%7Bt-j%7D%5E2+%5Cend%7Barray%7D" alt="\begin{array}{rll} r_t&amp;=&amp;\mu_t+\epsilon_t\\ \mu_t&amp;=&amp;\displaystyle \theta_0+\sum_{i=1}^p\theta_i r_{t-i}+\sum_{j=1}^q\eta_j\epsilon_{t-j} \\ \epsilon_t&amp;=&amp;\sigma_t\omega_t\\ \sigma_t^2&amp;=&amp;\displaystyle\alpha_0+\sum_{i=1}^{p^\prime}\alpha_i\epsilon_{t-i}^2+\sum_{j=1}^{q^\prime}\beta_j\sigma_{t-j}^2 \end{array}" eeimg="1"/> </p><p><b>当我们对 </b><img src="https://www.zhihu.com/equation?tex=r_t" alt="r_t" eeimg="1"/><b> 建模时，需要同时指定</b> <b>mean model（对 </b><img src="https://www.zhihu.com/equation?tex=%CE%BC_t" alt="μ_t" eeimg="1"/><b> 建模）以及 volatility model（对 </b><img src="https://www.zhihu.com/equation?tex=%CE%B5_t" alt="ε_t" eeimg="1"/><b> 建模）。</b>上式使用了 ARMA(p, q) 作为 mean model，但根据实际问题也可以使用更简单的模型，比如 <img src="https://www.zhihu.com/equation?tex=%CE%BC_t" alt="μ_t" eeimg="1"/> = 常数；使用了 GARCH(p&#39;, q&#39;) 作为 volatility model。最后使用已有的数据对这两个模型的参数进行联合估计。</p><p>在实际应用中，无论使用 python 还是 R 的相关 package，在调用时都要指定 mean model 和 volatility model。举个例子，在 <a href="https://link.zhihu.com/?target=http%3A//quantstart.com" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">quantstart.com</span><span class="invisible"></span></a> 上一篇使用 ARMA 对 mean 建模、用 GARCH 对 volatility 建模来交易 S&amp;P500 指数的例子中，作者对两个模型同时进行了设定。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-010f5929732bbca76aa58684c60474c8_b.jpg" data-caption="" data-size="normal" data-rawwidth="852" data-rawheight="601" class="origin_image zh-lightbox-thumb" width="852" data-original="https://pic1.zhimg.com/v2-010f5929732bbca76aa58684c60474c8_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-010f5929732bbca76aa58684c60474c8_b.jpg" data-caption="" data-size="normal" data-rawwidth="852" data-rawheight="601" class="origin_image zh-lightbox-thumb lazy" width="852" data-original="https://pic1.zhimg.com/v2-010f5929732bbca76aa58684c60474c8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-010f5929732bbca76aa58684c60474c8_b.jpg"/></figure><p>在具体 GARCH 建模时可以遵如下步骤（Tsay 2010）：</p><ol><li>使用 ARMA 对 <img src="https://www.zhihu.com/equation?tex=r_t" alt="r_t" eeimg="1"/> 建模以消除任何线性依赖，确定最优参数 p 和 q（可以利用 AIC/BIC 来确定）；</li><li>对上述模型的残差进行 GARCH 分析；</li><li>如果残差中表现出显著的条件异方差，则给定一个波动模型 GARCH(p&#39;, q&#39;)；</li><li>使用历史数据对第一步中的 ARMA(p, q) 和第三步中的 GARCH(p&#39;, q&#39;) 进行联合参数估计；</li><li>仔细检验第四步中拟合出的模型，如有必要则对其进行修改。</li></ol><p>以上五步构成了对条件均值和条件方差的联合建模，使用得到的模型就可以对未来的 <img src="https://www.zhihu.com/equation?tex=r_t" alt="r_t" eeimg="1"/> 以及 <img src="https://www.zhihu.com/equation?tex=%5Cmbox%7Bvar%7D%28r_t%29" alt="\mbox{var}(r_t)" eeimg="1"/> 进行预测。</p><p>在离开本节之前，我们再来介绍两个使用 GARCH 建模时<b>不十分正确</b>的做法（希望能帮你排雷）。</p><p><b>错误做法一：用 ARMA(p, q) 的阶数作为 GARCH(p&#39;, q&#39;) 的阶数</b></p><p>网上一些资料中提过这样的做法：首先是用 ARMA 对 r_t 建模、确定最优的参数 p 和 q；然后将它们作为波动率模型的阶数，即 GARCH(p, q)，同时在联合建模时仅假设 mean model <img src="https://www.zhihu.com/equation?tex=%5Cmu_t" alt="\mu_t" eeimg="1"/> = constant。这种做法使用从 <img src="https://www.zhihu.com/equation?tex=r_t" alt="r_t" eeimg="1"/> 线性关系找到的 p 和 q 去对 <img src="https://www.zhihu.com/equation?tex=r_t" alt="r_t" eeimg="1"/> 的波动率的关系建模，然后又假设 mean model 是常数，着实令人费解。</p><p><b>错误做法二：将 mean model 和 volatility model</b> <b>拆开估计</b></p><p>这种做法听上去更“靠谱”一些。首先是用 ARMA 对 <img src="https://www.zhihu.com/equation?tex=r_t" alt="r_t" eeimg="1"/> 建模，确定最优参数 p 和 q；然后使用 ARMA 模型的残差为被解释变量，对其进行 GARCH(p&#39;, q&#39;) 建模；第二步中因为被解释变量是残差，因此 GARCH 模型的 mean model <img src="https://www.zhihu.com/equation?tex=%5Cmu_t%3D0" alt="\mu_t=0" eeimg="1"/>，即假设残差均值为零。</p><p>这种做法看似合理，但是从条件均值角度来说，它也仅仅是利用了 ARMA 这一步（第二步的 GARCH 建模由于假设 mean model <img src="https://www.zhihu.com/equation?tex=%5Cmu_t%3D0" alt="\mu_t=0" eeimg="1"/> 因此对条件均值不再有影响），而没有利用 ARMA + GARCH 的联合估计考察异方差对收益率序列的影响。通常来说，就 ARMA 的参数而言，仅使用 ARMA 和联合使用 ARMA + GARCH 的结果是有差异的。</p><p>举个例子：使用 AR(2) 和 AR(2) + GARCH(1, 1) 两种方法对收益率建模。</p><p>插播一句：有小伙伴可能会问，为什么用 AR 不用 ARMA。这是因为 python 中的 arch package 目前所支持的 mean model 中不包括 ARMA 模型，但包括 AR 模型。R 在这方面支持的更强大一些。</p><p>OK，回到例子。下表展示了两种方法建模时，AR(2) 的参数，可以看出它们之间的差异。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-f63840dd5eb9cae4576bd615adc86b7a_b.jpg" data-caption="" data-size="normal" data-rawwidth="612" data-rawheight="245" class="origin_image zh-lightbox-thumb" width="612" data-original="https://pic3.zhimg.com/v2-f63840dd5eb9cae4576bd615adc86b7a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-f63840dd5eb9cae4576bd615adc86b7a_b.jpg" data-caption="" data-size="normal" data-rawwidth="612" data-rawheight="245" class="origin_image zh-lightbox-thumb lazy" width="612" data-original="https://pic3.zhimg.com/v2-f63840dd5eb9cae4576bd615adc86b7a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-f63840dd5eb9cae4576bd615adc86b7a_b.jpg"/></figure><p>所以，GARCH 模型虽好，但是 use with care。我们应时刻搞清楚是在对什么建模、怎么建模，mean model 是什么、volatility model 又是什么。</p><h2><b>5 简单实证</b></h2><p>最后通过一个 toy example 来介绍 ARMA + GARCH 的应用。</p><p>以下对上证指数自 2012 年 1 月到 2019 年 7 月的日频对数收益率进行时间序列建模，并使用该模型预测下一个交易的收益率。如果预测为正则选择持有上证指数，反之则空仓；假设以收盘价成交且不考虑任何交易成本。</p><p>在构建策略时，采用长度为 T 的滚动窗口历史数据。首先是用 AR 对收益率建模（因为 python arch package 不支持 ARMA 作为 mean model，所以仅使用 AR(p) 模型），并根据 AIC 选择最优 p 值（p 取值范围为 0 到 5）；然后以该 AR(p) 作为 mean model，并使用 GARCH(1, 1) 模型为 volatility model，进行联合参数估计。使用最终的模型预测下一个交易日收益率。此外作为比较，我们也考虑仅采用 AR(p) 来对收益率建模，而不考虑条件异方差的影响。</p><p>首先来看 T = 60 个交易日的情况。下图展示了 AR 和 AR + GARCH 两种策略的净值和回撤曲线。就表现而言，它们均战胜了上证指数本身（benchmark）。但是在股灾之后（波动率变大了），这两种模型的表现发生了分化，就这个简单实证而言，AR 的效果比 AR + GARCH 更好。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-8aed40b0f914ec6b90b078469e416814_b.jpg" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="578" class="origin_image zh-lightbox-thumb" width="697" data-original="https://pic1.zhimg.com/v2-8aed40b0f914ec6b90b078469e416814_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-8aed40b0f914ec6b90b078469e416814_b.jpg" data-caption="" data-size="normal" data-rawwidth="697" data-rawheight="578" class="origin_image zh-lightbox-thumb lazy" width="697" data-original="https://pic1.zhimg.com/v2-8aed40b0f914ec6b90b078469e416814_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-8aed40b0f914ec6b90b078469e416814_b.jpg"/></figure><p>再来看看把滚动窗口长度换到 T = 252 的情况。结果和上面接近，依然是 AR 战胜了 AR + GARCH 的组合。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-de3833a69aa5b6a79cb9e898a06245eb_b.jpg" data-caption="" data-size="normal" data-rawwidth="698" data-rawheight="565" class="origin_image zh-lightbox-thumb" width="698" data-original="https://pic4.zhimg.com/v2-de3833a69aa5b6a79cb9e898a06245eb_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-de3833a69aa5b6a79cb9e898a06245eb_b.jpg" data-caption="" data-size="normal" data-rawwidth="698" data-rawheight="565" class="origin_image zh-lightbox-thumb lazy" width="698" data-original="https://pic4.zhimg.com/v2-de3833a69aa5b6a79cb9e898a06245eb_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-de3833a69aa5b6a79cb9e898a06245eb_b.jpg"/></figure><p>从本小节的例子来看，加入了 GARCH 的策略似乎并没有仅使用 AR 的策略优异。我在最后的结语部分对此做简单评价。</p><h2><b>6 结语</b></h2><p>作为“补完篇”，本文填了《写给你的金融时间序列分析》最后一个大坑 —— GARCH；写作的重点在于阐述使用 mean model 和 volatility model 对收益率序列联合建模，以及在一个整合的框架下对两种模型的参数进行联合估计。</p><p>本文的第 5 节给出了一个简单实证。因 python arch package 的功能所限，实证中的 mean model 仅采用了 AR 模型。感兴趣的小伙伴不妨尝试 R 的相关 packages。</p><p>从实证结果来看，加入 GARCH 似乎没什么效果。但不要忘了，我们并没有对 GARCH 的参数进行任何优化，也没有额外利用其对波动率的建模来添加更加复杂的规则 —— 比如 volatility scaling。因此，仅仅基于这个简单的例子难以对 GARCH 的贡献做出任何正确的评判。</p><p>对于量化投资的研究来说，构建出策略并看到回测出来的净值曲线无疑是最令人激动的。然而，真正研究工作的核心却在于搞懂每个模型的原理以及它的作用，而这个过程注定是枯燥的。Quantstart Team 在其时间序列分析系列文章（以及其他系列）中不厌其烦的介绍每个基础模型，从简单到复杂，像搭积木一样为读者构建知识体系，令人敬佩。</p><p>现在，我们有了时间序列分析的各个 building blocks。但是，能够用它们做什么、如何去更科学的对收益率分析、预测，还需有经验的积累。最后，我想以下面这段出自 Quantstart 的话作为本系列的结束，也希望与各位共勉。</p><blockquote><i>True quantitative trading research is careful, measured and takes significant time to get right. There is no quick fix or &#34;get rich scheme&#34; in quant trading.</i></blockquote><p class="ztext-empty-paragraph"><br/></p><p><b>参考文献</b></p><ul><li>Engle, R. F. (1982). Autoregressive conditional heteroscedasticity with estimates of the variance of United Kingdom inflation. <i>Econometrica</i>, Vol. 50(4), 987 – 1008.</li><li>Tsay, R. S. (2010). <i>Analysis of Financial Time Series</i> (3rd ed). Wiley.</li><li><a href="https://link.zhihu.com/?target=https%3A//www.quantstart.com/articles/Generalised-Autoregressive-Conditional-Heteroskedasticity-GARCH-p-q-Models-for-Time-Series-Analysis" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">quantstart.com/articles</span><span class="invisible">/Generalised-Autoregressive-Conditional-Heteroskedasticity-GARCH-p-q-Models-for-Time-Series-Analysis</span><span class="ellipsis"></span></a></li></ul><p class="ztext-empty-paragraph"><br/></p><p><b>免责声明：</b>文章内容不可视为投资意见。市场有风险，入市需谨慎。</p><p class="ztext-empty-paragraph"><br/></p><p class="ztext-empty-paragraph"><br/></p><p>原创不易，请保护版权。如需转载，请联系获得授权，并注明出处。已委托“维权骑士”(<a href="https://link.zhihu.com/?target=http%3A//rightknights.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">维权骑士_免费版权监测/版权保护/内容多平台分发</a>) 为进行维权行动。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
