<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>「官方」WebAssembly的后MVP时代</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/47440191">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-c07285a84311fb9fe03b993bb015c329_r.jpg" alt=""></div><blockquote>本文是今天「Rust每日新闻」中的一则，较长，所以贴到专栏里。<br>每日新闻订阅地址：<br>- [Telgram Channel ](<a href="https://t.me/rust_daily_news">https://t.me/rust_daily_news</a> )<br>- [阿里云语雀订阅](<a href="https://www.yuque.com/chaosbot/rustnews">Rust每日新闻 · 语雀</a>)<br>- [Stemmit](<a href="https://steemit.com/@blackanger">Steemit</a>)<br>- [Rust.cc论坛](<a href="https://rust.cc/">Rust语言中文社区-首页</a>)<br>- [GitHub](<a href="https://github.com/RustStudy/rust_daily_news">RustStudy/rust_daily_news</a>)<br>欢迎通过GitHub issues投稿。</blockquote><p>原文「长文预警！」 <a href="https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/"> Read More </a></p><p><br></p><p>下面是简要概览，非翻译，是我看了以后梳理的总结：</p><hr><p>Mozilla工作人员 Lin Clark，最擅长的就是用卡通画来阐述技术思想，本篇就是他的新作。</p><p>他发现很多人误以为WebAssembly当前发布的MVP（minimum viable product ，最小可行产品）版本就是WebAssembly的最终版本。非也，非也。</p><p>事实上，WebAssembly还有很多能做的事情，目前大家掌握的只是技能树上的前几项。</p><p><br></p><p><b>一、mvp技能：</b></p><ul><li>编译目标</li><li>快速执行</li><li>快速加载</li><li>线性内存</li></ul><p>解锁成就： 在浏览器运行程序和游戏就像在本地机器上一样。</p><p><b>二、更重量级的桌面应用，需要技能：</b></p><ul><li>线程，已完成提案。</li><li>SIMD， 已经在非常活跃的开发阶段。</li><li>64位地址， 有了一个好的计划。</li><li>流式编译， Firefox在2017年已经支持，其他浏览器还在努力。并且firefox在2017年也增加了用于分层编译的baseline编译器，其他浏览器也在过去一年中添加了相同的架构。</li><li>隐式HTTP缓存，就快登录Firefox了</li><li>其他改进，正在讨论</li></ul><p>解锁成就：这些技能点实现以后，就会有更多重量级的应用程序进入浏览器。</p><p><b>三、常规Web开发，需要与js互操的小模块，需要技能：</b></p><ul><li>在js和wasm之间快速调用，目前在firefox已经解决了这个问题</li><li>快速简单的数据交换， reference types和host bindings 提案已经完成，Rust工具链已经创建了一些工具，可以自动为开发者处理这些数据交换，可以暂时弥补提案功能的缺席。</li><li>ES模块集成，快要递交提案。</li><li>工具链集成， Rust的wasm-pack很不错。</li><li>向后兼容性， 利用wasm2js工具。</li></ul><p>解锁成就：生态系统中将得到很多wasm和js互操作的模块。</p><p><b>四、js框架与编译到js的语言</b></p><p>一种路线是：用wasm重写现在的很多js框架，比如react、vue、ember等</p><p>另一种路线：编译到js的静态类型语言可以直接编译到wasm，比如scala.js、reason或elm</p><p>对于这两种路线，webassembly都需要支持更多高级技能：</p><ul><li>GC。 目前正在进行两项提案，JS的Typed Objects和WebAssembly的GC。Typed Objects可以描述对象的固定结构，WebAssembly GC可以直接访问该结构。有了这两个东东，js和wasm就可以共享js对象。这个估计得明年才能标准化，还不一定实现。</li><li>错误处理，处于研究和开发阶段。</li><li>Debug， 目前浏览器的devtools有一点支持，但不理想。</li><li>尾调用支持，提案正在进行。</li></ul><p>解锁成就： 达成js框架用wasm重写和编译到js的语言可以直接编译到wasm。</p><p><b>五、浏览器之外。wasm要达成什么成就？</b></p><p>网络中除了网页，还有一个非常重要的属性：链接。互联网有链接才能互联，但是，目前用户跳转到的链接内容，都是和提供其服务的机器设备重度依赖的。一个网站是否要为每个可能的设备提供不同版本的代码？ 当然不是，一个网站的源码只有一个。这里面涉及一个概念：可移植性。</p><p>可移植性很好，你可以从不认识的人那里加载代码，不用管什么设备。但这里存在一个安全问题。利用wasm可以达成以下两点：</p><ul><li>可移植性。向用户提供代码，并且可以在能运行浏览器的任何设备上执行。</li><li>安全沙箱。在wasm安全模型中运行代码，不会危机机器的安全。</li></ul><p>所以可以将wasm视为浏览器工具箱中的一个独立的工具。比如，可以使用wasm对Node.js中的一些本地扩展进行重写，比如Node.js 中用C实现的一些模块，就没必要依赖于机器，这就增强了Node.js代码的可移植性。但是目前wasm还无法访问系统资源，因此还需要更多技能：</p><ul><li>一个可移植的wasm系统接口，目前有一个package name maps的提案，可以用于将模块名称映射到加载模块的路径。这可能会得到浏览器和Node的支持，它们可以使用它来提供不同的路径，从而加载完全不同的模块，但使用相同的API。有了这个支持，就可以开始考虑接口的事了。这估计就需要更长的时间了。</li></ul><p><b>六、CDN/ Serverless/ Edge计算（物联网）</b></p><p>这些领域为什么要使用WASM？</p><p>作者举个了例子， Fastly是一家提供CDN和边缘计算的公司，他们CTO如是说：wasm可以在安全、性能和规模上提供比系统进程更加强的功能。这就意味着需要一个新的技能：</p><ul><li>运行时，执行实现一个wasm编译器或解释器。</li></ul><p>目前CraneStation在建立一个通用的wasm运行时，<a href="https://github.com/CraneStation/wasmtime">wasmtime</a>。</p><p>其他应用方向：</p><ul><li>可移植的CLI工具，可以用于不同的操作系统</li><li>物联网</li><li>区块链， （这个原文没说）</li></ul><p></p><p></p><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
