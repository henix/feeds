<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lambda calculus引论(六): 正规化与类型重建</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/27399507">原文</a></p>
<p>在上一节里介绍了简单带类型的λ-calculus的定义和基本性质, 这一节将介绍引入类型对λ-calculus系统的影响, 最重要的即是类型保证了系统的强正规性(strong normalization), 另外还将介绍类型检查与类型重建的方法(这一部分也是函数式编程应用里比较多关注的内容).</p><br><br><h2><b>弱正规化定理(Weak normalization theorem)</b></h2><b>定义:</b> 类型<equation>\tau</equation>的度(degree)记作<equation>\partial(\tau)</equation>, 定义如下:<br><br><equation>\begin{align}
&amp;\partial(\tau)=1\quad(\tau\ is\ a\ type\ variables)\\
&amp;\partial(\tau\to\sigma)=\max\{\partial(\tau),\partial(\sigma)\}+1\\
\end{align}
</equation><br><br><br><p><b>定义:</b> 可约式(redex)<equation>R</equation>的度(degree)记作<equation>\partial(R)</equation>, 定义如下:</p><equation>\begin{align}
&amp;R=(\lambda x.M)N\quad(\Gamma\vdash\lambda x.M:\tau\to\sigma)\\
&amp;\partial(R)=\partial(\tau\to\sigma)\\
\end{align}
</equation><br><br><br><p><b>定义:</b> 表达式<equation>T</equation>的度(degree)记作<equation>d(T)</equation>, 定义为其所包含的所有可约式(redex)的度的最大值. 若<equation>T</equation>为normal form, 则<equation>d(T)=0</equation>.</p><br><br><p><b>引理1:</b> <equation>d(T[U/x])\leq \max\{d(T),d(U),\partial(\tau)\}</equation>, 其中<equation>\Gamma(x)=\tau</equation>(即<equation>x</equation>的类型为<equation>\tau</equation>).</p><p>证明: 对于<equation>T[U/x]</equation>中的所有可约式<equation>R</equation>有以下几种情况</p><ul><li><equation>R</equation>是<equation>T</equation>中原有的可约式. <equation>R</equation>在替换中不变, 显然有<equation>\partial(R)\leq d(T)</equation>.<br></li><li><equation>R</equation>是<equation>U</equation>中的可约式. <equation>r</equation>在替换中引入, 显然有<equation>\partial(R)\leq d(U)</equation>.<br></li><li><equation>R</equation>是在替换<equation>x</equation>后所产生的新可约式, 根据<equation>\partial(R)</equation>定义有<equation>\partial(R)=\partial(\tau)</equation>.<br></li></ul><p>那么对于可约式<equation>R</equation>有<equation>\partial(R)\leq \max\{d(T),d(U),\partial(\tau)\}</equation>, 故根据表达式度的定义有<equation>d(T[U/x])\leq \max\{d(T),d(U),\partial(\tau)\}</equation>.</p><p>证毕.</p><br><br><p><b>引理2:</b> 若<equation>M\;\triangleright_{\beta}\;N</equation>那么<equation>d(N)\leq d(M)</equation>.</p><p>证明: <equation>M\;\triangleright_{\beta}\;N</equation>即<equation>M</equation>中的某个可约式形如<equation>(\lambda x.T)U</equation>规约为<equation>T[U/x]</equation>, 对于<equation>N</equation>中的所有可约式<equation>R</equation>有以下几种情况</p><ul><li><equation>R</equation>属于<equation>M</equation>在规约中不变, 显然<equation>R</equation>的度不发生改变, <equation>\partial(R)\leq d(M)</equation>.<br></li><li><equation>R</equation>来自于<equation>T[U/x]</equation>内部, 由引理1给出<equation>d(T[U/x])\leq \max\{d(T),d(U),\partial(\tau)\}</equation>(<equation>\tau</equation>为<equation>x</equation>的类型), 其中<equation>T</equation>与<equation>U</equation>包含在<equation>M</equation>内, 那么有<equation>d(T)\leq d(M)</equation>, <equation>d(U)\leq d(M)</equation>. 并且根据定义有:<equation>\partial(\tau)\leq d((\lambda x.T)U)\leq d(M)</equation> (<equation>(\lambda x.T)U</equation>为<equation>M</equation>中的一个可约式). 故<equation>\partial(R)\leq d(M)</equation>.<br></li><li><equation>R</equation>来自于将<equation>(\lambda x.T)U</equation>规约为<equation>T[U/x]</equation>后所产生的新可约式, 根据<equation>\partial(R)</equation>的定义有<equation>\partial(R)=\partial(\sigma)</equation>其中<equation>\lambda x.T</equation>的类型为<equation>\tau\to\sigma</equation>, <equation>U</equation>的类型为<equation>\tau</equation>. 又有<equation>\partial(\sigma)\leq d((\lambda x.T)U)\leq d(M)</equation>, 故<equation>\partial(R)\leq d(M)</equation>.<br></li></ul><p>那么对于可约式<equation>R</equation>有<equation>\partial(R)\leq d(M)</equation>, 故根据表达式度的定义有<equation>d(N)\leq d(M)</equation>.</p><p>证毕.</p><br><br><p><b>引理3:</b> 若对于一个可约式<equation>R</equation>, 其内部包含的所有的可约式的度均小于<equation>d(R)</equation>, 对<equation>R</equation>进行规约后得到的表达式<equation>N</equation>有<equation>d(N)&lt;d(R)</equation>.</p><p>证明: 可约式<equation>R</equation>形如<equation>R=(\lambda x.T)U</equation>且<equation>\Gamma \vdash R:\tau\to\sigma</equation>, 那么<equation>N=T[U/x]</equation>, 其中<equation>R</equation>内部包含的所有的可约式的度均小于<equation>d(R)=\partial(\tau\to\sigma)</equation>, 即有<equation>d(T)&lt;d(R)</equation>与<equation>d(U)&lt;d(R)</equation>. 根据引理1有<equation>d(T[U/x])\leq \max\{d(T),d(U),\partial(\tau)\}&lt;d(R)</equation>即<equation>d(N)&lt;d(R)</equation>.</p><p>证毕.</p><br><br><p><b>定理1: 弱正规化定理(weak normalization theorem)</b></p><p>简单带类型的λ-calculus具有弱规范性(weak normalization). 即所有简单带类型的λ-calculus表达式均是弱规范化的, <equation>M\in \Lambda^{\to}\Rightarrow M\in WN_{\beta}</equation>.</p><br><p>证明: </p><p>对<equation>d(M)</equation>做归纳.</p><p><u>归纳基础</u><u>:</u> 当<equation>d(M)=0</equation>时, <equation>M</equation>为normal form, 显然<equation>M\in WN_{\beta}</equation>.<br></p><p><u>归纳步骤:</u> 归纳假设当<equation>d(M)\leq n</equation>时均有<equation>M\in WN_{\beta}</equation>.</p><p>当<equation>d(M)=n+1</equation>时, 选取<equation>M</equation>中<equation>d(R)=n+1</equation>的可约式<equation>R</equation>, 且<equation>R</equation>内部包含的所有的可约式的度均小于<equation>n+1</equation>(即满足度为<equation>n+1</equation>最右可约式). 由引理3得, 对<equation>R</equation>进行规约后<equation>M</equation>中度为<equation>n+1</equation>的可约式将会减少. 重复该操作直至规约至<equation>N</equation>, 其中<equation>N</equation>中不存在<equation>d(R)=n+1</equation>的可约式<equation>R</equation>, 此时<equation>d(N)=n</equation>. 由归纳假设得<equation>N\in WN_{\beta}</equation>, 且有<equation>M\;\triangleright_{\beta}^{*}\;N</equation>, 即<equation>M\in WN_{\beta}</equation>.</p><p>故由归纳法得<equation>M\in \Lambda^{\to}\Rightarrow M\in WN_{\beta}</equation>.</p><br>证毕.<br><p>由简单带类型λ-calculus具有弱规范性, 通过leftmost reduction可得到表达式的normal form(参见第四节定理leftmost reduction).</p><br><br><h2><b>强正规化定理(Strong normalization theorem)</b></h2><p>这里介绍简单带类型λ-calculus强正规性的两种证明, 第一种证明方式将带类型λ-calculus转化为带类型λI-calculus形式, 利用λI-calculus系统中弱规范性等价于强规范性的性质进行证明, 第二种证明方式由W.W. Tait在1967年提出, 主要是利用类型在表达式和正规化子集间建立逻辑关系(logical relation).</p><br><p>第一种证明较为初等, 第二种证明可以简单地拓展到Lambda cube(后文将会介绍)上证明其强规范性.</p><br><br><p><b>Proof by λI-calculus</b></p><br><p><b>定义:</b> <equation>\iota </equation>为简单带类型λ-calculus至简单带类型λI-calculus映射</p><br><p>(λI-calculus的定义参见第四节)</p><br><p><equation>\begin{align}
&amp;\iota :\Lambda^{\to}\to\Lambda_{I}\\
&amp;\iota(x)=x\\
&amp;\iota(MN)=\iota(M)\iota(N)\\
&amp;\iota(\lambda x_1:\sigma_1.\cdots \lambda x_n:\sigma_n.P)=\lambda x_1:\sigma_1.\cdots \lambda x_n:\sigma_n.\lambda y_1:\tau_1.\cdots \lambda y_m:\tau_m.\\
&amp;\qquad k_{\rho,\sigma_1}(\cdots(k_{\rho,\sigma_n}(\iota(P)y_1\cdots y_m)x_n)\cdots)x_1\\
\end{align}</equation><br><br>其中<equation>\Gamma, x_i:\sigma_i\vdash P:\tau_1\to\cdots\to\tau_m\to\rho</equation>, <equation>k_{\rho,\sigma_n}:\rho\to\sigma_i\to\rho</equation>.</p><p>注: λI-calculus为λ-calculus子集, 简单带类型λI-calculus性质与简单带类型λ-calculus相同.<br></p><br><br><p><b>定义:</b> <equation>t</equation>为简单带类型λI-calculus至简单带类型λ-calculus映射</p><br><equation>\begin{align}
&amp;t:\Lambda^{I}\to\Lambda_{\to}\\
&amp;t(M)=\iota(M)[\mathbf{K}_{\rho,\sigma}/k_{\rho,\sigma}]
\end{align}</equation><br><p>其中<equation>\mathbf{K}_{\rho,\sigma}=\lambda x:\rho.\lambda y:\sigma.x</equation>, <equation>\vdash \mathbf{K}_{\rho,\sigma}:\rho\to\sigma_i\to\rho</equation>.</p><br><p>显然根据定义<equation>t(M)\;\triangleright_{\beta}^{*}\;M</equation>.</p><br><br><p><b>引理4: <equation>M\in \Lambda^{\to},\ \iota(M)\in SN_{\beta}</equation></b>.</p><p>证明: 由λI-calculus中<equation>SN_{\beta}\equiv WN_{\beta}</equation>(参见第四节定理(Church, Rosser))及定理1(弱正规化定理)得<equation>\iota(M)\in WN_{\beta}</equation>, 故<equation>\iota(M)\in SN_{\beta}</equation>.</p><p>证毕.</p><br><br><p><b>引理5: </b>对于<equation>M\;\triangleright_{\beta}\;N</equation>, 其中被规约的可约式形如<equation>(\lambda x:\sigma.P)Q</equation>, <equation>P:\rho</equation>, <equation>Q:\sigma</equation>(<equation>\rho</equation>为类型标识符), 则记该类规约为<equation>M\;\triangleright_{\beta1}\;N</equation>. </p><p>若有<equation>M_0\;\triangleright_{\beta1}\;M_1\;\triangleright_{\beta}\;M_2</equation>, 则存在<equation>M_3</equation>使得<equation>M_0\;\triangleright_{\beta}\;M_3\;\triangleright^{*}_{\beta1}\;M_2</equation>.</p><p>证明: 在<equation>M_0\;\triangleright_{\beta1}\;M_1\;\triangleright_{\beta}\;M_2</equation>中, 对于<equation>M_0\;\triangleright_{\beta1}\;M_1</equation>, 进行规约的可约式为<equation>R=(\lambda x:\sigma.P)Q</equation>, <equation>(\lambda x:\sigma.P)Q\;\triangleright_{\beta}\;P[Q/x]</equation>其中<equation>(\lambda x:\sigma.P):\sigma\to\rho</equation>故<equation>P[Q/x]:\rho</equation>, <equation>P[Q/x]</equation>的类型<equation>\rho</equation>表明<equation>P[Q/x]</equation>不为抽象(abstraction), 即非<equation>\lambda y:\tau.M</equation>形式. 故<equation>\triangleright_{\beta1}</equation>规约后不产生新的可约式. 故<equation>M_1\;\triangleright_{\beta}\;M_2</equation>中进行规约的可约式属于<equation>M_0</equation>, 可交换规约顺序, 即<equation>M_0\;\triangleright_{\beta}\;M_3\;\triangleright^{*}_{\beta1}\;M_2</equation>.</p><p>(在交换规约顺序后<equation>M_0\;\triangleright_{\beta}\;M_3</equation>规约中可能会复制出多个可约式<equation>R</equation>, 故交换后为<equation>M_3\;\triangleright^{*}_{\beta1}\;M_2</equation>)</p><br><p>证毕.</p><br><br><p><b>引理6: </b>若<equation>M\in \Lambda^{\to},\ t(M)\notin SN_{\beta}</equation>则存在无穷规约序列, 其中所有<equation>\mathbf{K}_{\rho,\sigma}</equation>项没被规约.</p><br><p>证明: 对于<equation>t(M)</equation>的无穷规约序列, <equation>t(M)=M_0\;\triangleright_{\beta}\;M_1\;\triangleright_{\beta}\;M_2\;\triangleright_{\beta}\;\cdots</equation>, 若其中出现<equation>M_i\;\triangleright_{\beta1}\;M_{i+1}\;\triangleright_{\beta}\;M_{i+2}</equation>则由引理5得, 可将<equation>\triangleright_{\beta1}</equation>规约交换后置, 即<equation>M_i\;\triangleright_{\beta}\;M^{'}_{i+1}\;\triangleright^{*}_{\beta1}\;M_{i+2}</equation>. 则对于任意有限长的前<equation>n</equation>项的子规约序列, 均不存在<equation>\triangleright_{\beta1}</equation>规约, 即存在无穷规约序列不包含<equation>\triangleright_{\beta1}</equation>规约.</p><br><p>在无穷规约序列<equation>M_0\;\triangleright_{\beta}\;M_1\;\triangleright_{\beta}\;M_2\;\triangleright_{\beta}\;\cdots</equation>中不存在<equation>\triangleright_{\beta1}</equation>规约, 若其中对<equation>\mathbf{K}_{\rho,\sigma}</equation>项进行规约<equation>\mathbf{K}_{\rho,\sigma}A\;\triangleright_{\beta}\;(\lambda y:\sigma.A)</equation>, 其中<equation>A:\rho</equation>, 由于规约序列中不存在<equation>\triangleright_{\beta1}</equation>规约, 即<equation>(\lambda y:\sigma.A)</equation>在后续规约没有被规约, 故可对所有<equation>\mathbf{K}_{\rho,\sigma}</equation>项规约交换后置. 那么有存在无穷规约序列, 对于其任意有限长的前<equation>n</equation>项的子规约序列, 均不存在<equation>\mathbf{K}_{\rho,\sigma}</equation>项规约, 即存在无穷规约序列不包含<equation>\mathbf{K}_{\rho,\sigma}</equation>项规约.</p><br><p>证毕.</p><br><br><p><b>引理7:</b> <equation>M\in \Lambda^{\to},\ t(M)\in SN_{\beta}</equation>.</p><p>证明: 若<equation>t(M)\notin SN_{\beta}</equation>, 由引理5得, 存在无穷规约序列<equation>t(M)=M_0\;\triangleright_{\beta}\;M_1\;\triangleright_{\beta}\;M_2\;\triangleright_{\beta}\;\cdots</equation>其中所有<equation>\mathbf{K}_{\rho,\sigma}</equation>项没有被规约, 那么表达式中的<equation>\mathbf{K}_{\rho,\sigma}</equation>项与标识符<equation>k_{\rho,\sigma_n}</equation>行为无异, 故可构造无穷规约序列<equation>M^{'}_0\;\triangleright_{\beta}\;M^{'}_1\;\triangleright_{\beta}\;M^{'}_2\;\triangleright_{\beta}\;\cdots</equation>其中<equation>M^{'}_i=t^{-1}(M_i)</equation> (<equation>t^{-1}</equation>为将表达式中所有<equation>\mathbf{K}_{\rho,\sigma}</equation>项替换为标识符<equation>k_{\rho,\sigma_n}</equation>), 故有<equation>\iota(M)=M^{'}_0\;\triangleright_{\beta}\;M^{'}_1\;\triangleright_{\beta}\;M^{'}_2\;\triangleright_{\beta}\;\cdots</equation>为无穷规约序列, 即<equation>\iota(M)\notin SN_{\beta}</equation>与引理4矛盾, 故<equation>t(M)\in SN_{\beta}</equation>.</p><p>证毕.</p><br><br><p><b>定理2.1: 强正规化定理(strong normalization theorem)</b><br></p><br>简单带类型的λ-calculus具有强规范性(strong normalization). 即所有简单带类型的λ-calculus表达式均是强规范化的, <equation>M\in \Lambda^{\to}\Rightarrow M\in SN_{\beta}</equation>.<br><p>证明: 若<equation>M\notin SN_{\beta}</equation>, 由<equation>t(M)\;\triangleright_{\beta}^{*}\;M</equation>得<equation>t(M)\notin SN_{\beta}</equation>, 与引理6矛盾. 故<equation>M\in SN_{\beta}</equation>.</p><p>证毕.</p><br><br><p><b>Proof by logical relation</b></p><br><p><b>定义: <equation>A,B\subseteq \Lambda^{-}</equation></b>, 表达式集合<equation>\left\{ F\in \Lambda^{-}\;|\;\forall a\;(a\in A\to F\;a\in B) \right\} </equation>记作<equation>A\to B</equation>.</p><br><br><p><b>定义: </b>对于类型<equation>\tau</equation>, 表达式集合<equation>[\![\tau]\!] \subseteq \Lambda^{-}</equation>为类型<equation>\tau</equation>的可计算(computable)集合, 定义如下:</p><equation>\begin{align}
&amp;\;[\![\tau]\!]=SN_{\beta}\\
&amp;\;[\![\sigma\to\rho]\!]=[\![\sigma]\!]\to [\![\rho]\!]
\end{align}
</equation><br><br><p><b>定义: </b>强正规化集合的子集<equation>X\subseteq SN_{\beta}</equation>为饱和集合(saturated)当且仅当满足:</p><ul><li>对于<equation>n\geq 0</equation>, <equation>M_1,\dots M_n\in SN_{\beta}</equation>, 有<equation>xM_1\cdots M_n\in X</equation><br></li><li>对于<equation>n\geq 1</equation>, <equation>M_1,\dots M_n\in SN_{\beta}</equation>, 有<equation>M_0[M_1/x]M_2\cdots M_n\in X\Rightarrow (\lambda x.M_0)M_1M_2\cdots M_n\in X</equation><br></li></ul><br><br><p><b>定义: </b>所有饱和集合的集合记作为<equation>\mathbb{S}</equation>, 即<equation>X\ is\ saturated\Rightarrow X\in\mathbb{S}</equation>或<equation>\mathbb{S}=\left\{ X\subseteq \Lambda^{-}\;|\;  X\ is\ saturated\right\} </equation>.</p><br><br><p><b>引理8: <equation>SN_{\beta}\in\mathbb{S}</equation></b>.</p><p>证明: 显然<equation>n\geq 0</equation>, <equation>M_1,\dots M_n\in SN_{\beta}</equation>, 有<equation>xM_1\cdots M_n\in SN_{\beta}</equation>. <equation>n\geq 1</equation>, 显然有<equation>(\lambda x.M_0)M_1M_2\cdots M_n\;\triangleright_{\beta}\;M_0[M_1/x]M_2\cdots M_n</equation>, 故<equation>M_0[M_1/x]M_2\cdots M_n\in SN_{\beta}\Rightarrow (\lambda x.M_0)M_1M_2\cdots M_n\in SN_{\beta}</equation>.</p><p>证毕.</p><br><br><p><b>引理9: </b><equation>A,B\in\mathbb{S}\Rightarrow A\to B\in\mathbb{S}</equation>.<br></p><br>证明:<p>若<equation>F=xM_1\cdots M_n</equation>(其中<equation>n\geq 0</equation>, <equation>M_1,\dots M_n\in SN_{\beta}</equation>), 有<equation>A,B\in\mathbb{S}</equation>, 令<equation>P\in A\subseteq SN_{\beta}</equation>, 那么<equation>F\;P=xM_1\cdots M_nP</equation>, 其中<equation>P\in SN_{\beta}</equation>故由<equation>B\in\mathbb{S}</equation>定义得<equation>F\;P\in B</equation>, 因此<equation>F\in A\to B</equation>.</p><br>若<equation>F=M_0[M_1/x]M_2\cdots M_n</equation>(其中<equation>n\geq 1</equation>, <equation>M_1,\dots M_n\in SN_{\beta}</equation>)且<equation>F\in A\to B</equation>, 令<equation>F^{'}=(\lambda x.M_0)M_1M_2\cdots M_n</equation>, 由<equation>F\in A\to B</equation>得, 对于<equation>P\in A\subseteq SN_{\beta}</equation>有<equation>F\;P\in B</equation>, 又有<equation>F^{'} P\;\triangleright_{\beta}\;F\; P</equation>, 即<equation>F^{'} P\in B</equation>, 故<equation>F^{'}\in A\to B</equation>.<p>证毕.</p><br><br><p><b>引理10:</b> <equation>\sigma\in\Pi\Rightarrow [\![\sigma]\!]\in\mathbb{S}</equation>.<br></p><p>证明: 对<equation>\ [\![\sigma]\!]</equation>做结构归纳.</p><p>若<equation>\sigma</equation>为类型标识符, 根据定义<equation>\ [\![\sigma]\!]=SN_{\beta}</equation>, 由引理8得<equation>\ [\![\sigma]\!]\in\mathbb{S}</equation>.<br></p><p>若<equation>\sigma=\tau\to\rho</equation>, <equation>\ [\![\sigma]\!]=[\![\tau]\!]\to [\![\rho]\!]</equation>, 由归纳假设得<equation>\ [\![\tau]\!],[\![\tau]\!]\in \mathbb{S}</equation>, 又由引理9得<equation>[\![\tau]\!]\to [\![\rho]\!]\in \mathbb{S}</equation>.</p><br><p>证毕.</p><br><br><p><b>定义: </b>求值(valuation)<equation>\rho </equation>为标识符到表达式上的映射<equation>\rho :S\to\Lambda^{-}</equation>.</p><p>部分替换记号<equation>\rho \left\{ x\!:= N\right\}</equation>为:</p><equation>\rho \left\{ x\!:= N\right\} (y)=
\begin{cases}
N&amp;(x\equiv y) \\
\rho(y)&amp;(otherwise)
\end{cases}</equation><br><br><p><b>定义: </b><equation>\rho </equation>为标识符上的求值, <equation>\ [\![M]\!]_{\rho}=M[\rho(x_1)/x_1,\cdots,\rho(x_n)/x_n]</equation>其中<equation>FV(M)=\left\{ x_1,\cdots,x_n \right\} </equation>.</p><br><br><p><b>定义: </b><equation>\rho </equation>为标识符上的求值, <equation>\rho\models M:\sigma</equation>当且仅当<equation>\;[\![M]\!]_{\rho}\in[\![\sigma]\!]</equation>; <equation>\rho\models \Gamma</equation>当且仅当<equation>\ \forall (x:\sigma)\in\Gamma\quad(\rho(x)\in[\![\sigma]\!])</equation>.</p><br><br><p><b>定义: <equation>\Gamma\models M:\sigma</equation></b>当且仅当<equation>\forall \rho\;(\rho\models \Gamma\;\Rightarrow\; \rho\models M:\sigma)</equation>.<br></p><br><br><p><b>引理11: Soundness</b></p><equation>\Gamma\vdash M:\sigma\;\Rightarrow \;\Gamma\models M:\sigma</equation><br><p>证明: 对<equation>\Gamma \vdash M:\sigma</equation>的推导做结构归纳.</p><p>若推导为<equation>\frac{}{\Delta, x:\sigma\vdash x:\sigma}</equation>, 其中<equation>\Gamma =\Delta ,x:\sigma</equation>, <equation>M=x</equation>, <equation>x\notin dom(\Delta )</equation>. 若<equation>\rho\models \Gamma</equation>则有<equation>\;[\![x]\!]_{\rho}=\rho(x)\in[\![\sigma]\!]</equation>, 即<equation>\rho\models x:\sigma</equation>, 故<equation>\Gamma\models x:\sigma</equation>.</p><p>若推导为<equation>\dfrac{\Gamma ,x:\tau_1\vdash N:\tau_2}{\Gamma \vdash (\lambda x.N):\tau_1\to\tau_2}</equation>, 其中<equation>x\notin dom(\Gamma )</equation>, <equation>\sigma=\tau_1 \to \tau_2</equation>, <equation>M=\lambda x.N</equation>. 不妨设<equation>x\notin dom(\Gamma^{'} )</equation>, 若<equation>\rho\models \Gamma</equation>, 令<equation>P\in [\![\tau_1]\!]</equation>, 那么有<equation>\rho\left\{ x\!:=P \right\} \models \Gamma,x:\tau_1</equation>. 根据归纳假设有<equation>\Gamma ,x:\tau_1\models N:\tau_2</equation>那么有<equation>\rho\left\{ x\!:=P \right\} \models N:\tau_2</equation>即<equation>\ [\![N]\!]_{\rho\{x\!:=P\}}\in [\![\tau_2]\!]</equation>.</p><equation>\begin{align}
\;[\![\lambda x.N]\!]_{\rho}P\;&amp;\equiv\; (\lambda x.N)[\rho(x_1)/x_1,\cdots,\rho(x_n)/x_n]P\\
&amp;\triangleright_{\beta}\;N[\rho(x_1)/x_1,\cdots,\rho(x_n)/x_n,P/x]\\
&amp;\equiv \;[\![N]\!]_{\rho\{x\!:=P\}}
\end{align}</equation><br><p>又有<equation>\;[\![N]\!]_{\rho\{x\!:=P\}}\in [\![\tau_2]\!]\in\mathbb{S}</equation>, 其中<equation>[\![\lambda x.N]\!]_{\rho}P\;\triangleright_{\beta}\;[\![N]\!]_{\rho\{x\!:=P\}}</equation>故<equation>\ [\![\lambda x.N]\!]_{\rho}P\in[\![\tau_2]\!]</equation>. 又有<equation>P\in [\![\tau_1]\!]</equation>, 因此可得<equation>\;[\![\lambda x.N]\!]_{\rho}\in[\![\tau_1\to\tau_2]\!]</equation>, 即<equation>\rho\models (\lambda x.N):\tau_1\to\tau_2</equation>, 故<equation>\Gamma\models (\lambda x.N):\tau_1\to\tau_2</equation>.</p><p>若推导为<equation>\dfrac{\Gamma \vdash P:\tau_1\to\tau_2\quad\Gamma \vdash Q:\tau_1}{\Gamma \vdash PQ:\tau_2}</equation>, 其中<equation>M=PQ</equation>. 若<equation>\rho\models \Gamma</equation>, 根据归纳假设有<equation>\Gamma \models P:\tau_1\to\tau_2</equation>与<equation>\Gamma \models Q:\tau_1</equation>即<equation>\rho \models P:\tau_1\to\tau_2</equation>和<equation>\rho \models Q:\tau_1</equation>, 那么有<equation>\;[\![P]\!]_{\rho}\in[\![\tau_1]\!]\to[\![\tau_2]\!]</equation>和<equation>\;[\![Q]\!]_{\rho}\in[\![\tau_1]\!]</equation>, 故<equation>\;[\![PQ]\!]_{\rho}=[\![P]\!]_{\rho}[\![Q]\!]_{\rho}\in[\![\tau_2]\!]</equation>, 即<equation>\rho\models PQ:\tau_2</equation>, 故<equation>\Gamma\models PQ:\tau_2</equation>.</p><p>根据归纳法得<equation>\Gamma\vdash M:\sigma\;\Rightarrow \;\Gamma\models M:\sigma</equation>.<br></p><br><p>证毕.</p><br><br><p><b>定理2.2: 强正规化定理(strong normalization theorem)</b><br></p><p>简单带类型的λ-calculus具有强规范性(strong normalization). 即所有简单带类型的λ-calculus表达式均是强规范化的, <equation>M\in \Lambda^{\to}\Rightarrow M\in SN_{\beta}</equation>.<br></p><p>证明: 由引理11(Soundness)得, 由<equation>\Gamma\vdash M:\sigma</equation>得<equation>\Gamma\models M:\sigma</equation>, 取求值<equation>\rho </equation>为<equation>\ \forall (x:\sigma)\in\Gamma\quad(\rho(x)=x)</equation>, 显然<equation>\rho(x)\in [\![\tau_2]\!]\in\mathbb{S}</equation>即<equation>\rho\models \Gamma</equation>. 由<equation>\Gamma\models M:\sigma</equation>得<equation>\;[\![M]\!]_{\rho}\in[\![\sigma]\!]</equation>, 其中<equation>\ [\![M]\!]_{\rho}=M</equation>, <equation>\;[\![\sigma]\!]\subseteq SN_{\beta}</equation>, 故<equation>M\in SN_{\beta}</equation>.</p><br><p>证毕.</p><br><br><p><b>推论1:</b> 所有在<equation>\lambda_{\to}</equation>中typable的表达式构成的集合为无类型λ-calculus表达式的真子集.</p><p>证明: <equation>\Omega =(\lambda x.x\;x)(\lambda x.x\;x)</equation>在<equation>\lambda_{\to}</equation> à la Curry中非可类型化(untypable)</p><p>由定理2(强正规化定理)简单带类型的λ-calculus系统具有强规范性, <equation>\Omega </equation>显然不具有normal form. 若<equation>\Omega </equation>可类型化, 则<equation>\Omega </equation>具有一个normal form. 矛盾. </p><p>证毕.</p><br><br><p><b>推论2:</b> 不动点组合子<equation>Y</equation>在<equation>\lambda_{\to}</equation> à la Curry中非可类型化(untypable), 即在<equation>\lambda_{\to}</equation> à la Curry中无法构建不动点组合子.<br></p><p>证明: <equation>Y</equation>满足<equation>Yf\;\triangleright_{\beta}^{*}\;f(Yf)\quad(\forall f\in\Lambda )</equation>, 取<equation>f=\lambda x.x\ x</equation>. 显然<equation>f</equation>为可类型化的, 若<equation>Y</equation>为可类型化的, 而显然<equation>Yf</equation>不具有normal form, 类似证明推论1, 可得矛盾. 故<equation>Y</equation>在<equation>\lambda_{\to}</equation>中非可类型化. </p><p>证毕.</p><br><br><p>对于不动点组合子<equation>Y</equation>在简单带类型λ-calculus无法构造, 直接的原因是在不动点组合子<equation>Y</equation>的构造中, 必然会遇到自我调用, 例如<equation>x\;x</equation>, 其类型推导为:</p><equation>\dfrac{\Gamma \vdash x\!:\!t_{1}\to t_{2}\quad \Gamma \vdash x\!:\!t_{1}}{\Gamma \vdash x~x\!:\!t_{2}}</equation><br><p>对于<equation>x</equation>的类型实质上是递归类型<equation>t_{1}=t_{1}\to t_{2}</equation>, 在简单带类型λ-calculus系统中不具有此种类型表达.</p><br><p>为了在带类型λ-calculus表达递归, 一个解决方式是将不动点组合子在表达式层面上引入.</p><br><p><b>定义: <equation>\mathbf{fix}</equation></b>表达式</p><ul><li>β-规约规则: <equation>\mathbf{fix}\;f\;\triangleright_{\beta}\;f(\mathbf{fix}\;f)</equation>.</li><li>类型性规则(typability): <equation>\vdash \mathbf{fix}:(\alpha\to\alpha)\to\alpha</equation>.</li></ul><p>注: 在将不动点组合子加入到简单带类型λ-calculus后, 其规范性将会被破坏. 更深层次的原因可以追溯至由递归类型引入的悖论, 参见Girard悖论.</p><br><br><h2><b>类型检查与重建(Type checking and reconstruction)</b></h2><p><b>定义: </b>在类型系统上的三类问题</p><ul><li><b>类型检查(type checking)</b> 给定前提<equation>\Gamma</equation>, 表达式<equation>M</equation>与类型<equation>\tau</equation>, 确定<equation>\Gamma \vdash M:\tau</equation>是否成立.<br></li><li><b>类型重建(type reconstruction)或类型推导(type inference) </b>给定前提<equation>\Gamma</equation>与表达式<equation>M</equation>, 确定是否存在类型<equation>\tau</equation>使得<equation>\Gamma \vdash M:\tau</equation>是否成立.</li><li><b>类型居留(type inhabitation) </b>给定前提<equation>\Gamma</equation>与类型<equation>\tau</equation>, 确定是否存在表达式<equation>M</equation>, 使得<equation>\Gamma \vdash M:\tau</equation>是否成立. (这里对居留问题不做深入介绍)</li></ul><p>注: 从直觉上来说类型检查会比类型重建更容易, 但在更为丰富的类型系统中, 类型检查并不比类型重建更容易, 反而类型重建可以问题可以规约成类型检查.</p><p>对于检查表达式<equation>M</equation>(其中<equation>FV(M)=\left\{ x_1,\cdots,x_n \right\} </equation>), 确定是否存在类型<equation>\tau</equation>在<equation>\Gamma</equation>中使得<equation>\Gamma \vdash M:\tau</equation>是否成立可以规约为确定</p><equation>x_0:\rho\vdash \mathbf{K}x_0(\lambda x_1.\dots\lambda x_n. M):\rho</equation><p>是否成立(即类型检查). </p><p>对于简单带类型λ-calculus的类型检查与类型重建问题, 首先从一阶合一化(first-order unification)开始介绍.</p><br><br><p><b>First-order unification</b><br></p><p><b>定义: </b>一阶标署(first-order signatures) <equation>\sigma</equation></p><br><p>其中<equation>A</equation>为全集, <equation>\sigma </equation>为<equation>\sigma =\langle \left\{ c_i \right\},\left\{ R_i\right\},   \left\{ f_i \right\} \rangle</equation><br></p><ul><li><equation>\left\{ c_i \right\}</equation>为常量符号集合, <equation> c_i \in A</equation>.<br></li><li><equation>\left\{ R_i \right\}</equation>为<equation>A</equation>上的<equation>k</equation>元关系, 即<equation>R_i \subseteq A^{k}</equation>.<br></li><li><equation>\left\{ f_i \right\}</equation>为<equation>k\;(k\geq 1)</equation>元函数, <equation>f_i:A^{k}\to A</equation>.<br></li></ul><br><p>其中0元函数视作为常量. 若标署中不包含关系则称该标署为代数标署(algebraic signatures), 在合一问题里只考虑代数标署.<br></p><br><br><p><b>定义: </b>在一阶标署<equation>\sigma =\langle \mathcal{C},\mathcal{R},\mathcal{F} \rangle</equation>上的代数项(algebraic term)<equation>\Sigma </equation>为</p><ul><li>常量<equation>c</equation> (<equation>c\in \mathcal{C}</equation>).</li><li><equation>f(t_1,\dots,t_n)</equation>, 其中<equation>f\in\mathcal{F}</equation>, <equation>t_1,\dots,t_n\in\Sigma </equation>.<br></li></ul><p>即<equation>\Sigma = \mathcal{C}\;|\;\mathcal{F}(\Sigma...)</equation> .</p><br><br><p><b>定义: </b>方程(equation)为一对代数项<equation>(t,u)</equation>, 写作<equation>t=u</equation>. 方程组(system of equations)为方程的有限集合. 方程中的标识符称为未知元(unknowns).</p><br><br><p><b>定义:</b> 替换(substitution)为从代数项至代数项的映射</p><equation>\begin{align}
&amp;S:\Sigma \to \Sigma \\
&amp;S(c)=c\qquad(c\ is\ a\ constant)\\
&amp;S(x)=\rho(x)\qquad(x\ is\ a\ variable)\\
&amp;S(f(t_1,\dots,t_n))=f(S(f(t_1)),\dots,S(f(t_n)))\\
\end{align}</equation><br><p>其中对于标识符, <equation>\rho :\Sigma \to\Sigma </equation>为对该标识符的求值(valuation).</p><br><br><p><b>定义:</b> 方程的解(solution of an equation)为替换<equation>S</equation>, 其中求值<equation>\rho</equation>满足对于方程<equation>t=u</equation>有<equation>S(t)\equiv S(u)</equation>. 方程组的解为替换<equation>S</equation>均为方程组中每个方程的解.</p><br><p>方程的解的一个例子:<br></p><p>对于方程<equation>f(gxy)x=fz(fyy)</equation>, 其解为</p><equation>\begin{align}
&amp;\rho(x)=fyy\\
&amp;\rho(y)=y\\
&amp;\rho(z)=g(fyy)y
\end{align}</equation><br><br><p><b>定义:</b> 对于方程组, 称其为已解(solved form)当且仅当</p><ul><li>所有方程均为<equation>x=t</equation>形式, 其中<equation>x</equation>为标识符.</li><li>对于一个在方程左边的标识符, 其不出现在方程组中的任何其他位置.</li></ul><p>对于没有出现在方程左边的标识符, 则称之为未定元(undefined).</p><p>对于一个已解的方程, 有解<equation>S</equation>:</p><equation>\begin{align}
&amp;\rho_{S}(x)=t\qquad(for\ x=t)\\
&amp;\rho_{S}(y)=y\qquad(y\ is\ undefined)
\end{align}</equation><p>其中显然有<equation>t=S(t)</equation>.</p><br><br><p><b>定义:</b> 对于方程组, 称其为不一致的(inconsistent)当且仅当存在以下几种形式的方程</p><ul><li><equation>f(t_1,\dots,t_n)=g(u_1,\dots,u_m)</equation>, 其中<equation>f,g\in\mathcal{F},f\not\equiv g</equation>.<br></li><li><equation>f(t_1,\dots,t_n)=c</equation>或<equation>c=f(t_1,\dots,t_n)</equation>, 其中<equation>f\in\mathcal{F},c\in\mathcal{C}</equation>.<br></li><li><equation>c=d</equation>, 其中<equation>c,d\in\mathcal{C},c\not\equiv d</equation>.</li><li><equation>x=f(t_1,\dots,t_n)</equation>, 其中<equation>x</equation>出现在<equation>t_1,\dots,t_n</equation>中.<br></li></ul><p>对于一个不一致的方程组, 显然其无解.</p><br><br><p><b>定义: </b>两个方程组<equation>E</equation>与<equation>E^{'}</equation>为等价的(equivalent)当且仅当其解相同, 记作<equation>E\simeq E^{'}</equation>.</p><br><br><p><b>定义: </b>对于给定方程组<equation>E</equation>, 判定该方程组<equation>E</equation>是否存在等价方程组<equation>E\simeq E^{'}</equation>, <equation>E^{'}</equation>为已解的(solved form)或不一致的(inconsistent). 该类问题为一阶合一问题(first-order unification).</p><br><br><p><b>Robinson's algorithm</b><br></p><p><b>定义: </b>方程符号替换, <equation>E\{x\!:=t\}</equation>表示将方程中出现的标识符<equation>x</equation>替换为代数项<equation>t</equation>; 定义替换<equation>S</equation>其中<equation>\rho_{S}(x)=t</equation>, 即<equation>E\{x\!:=t\}=S(E)</equation>.<br></p><br><br><p><b>定义: </b>对于方程组<equation>E</equation>的变换操作</p><equation>\begin{align}
E\;\cup\;\{t=t\}\;&amp;\Rightarrow \;E &amp;&amp; &amp;&amp; (\textrm{delete})\\
E\;\cup\;\{f(t_1,\dots,t_n)=f(u_1,\dots,u_n)\}\;&amp;\Rightarrow \;E\;\cup\;\{t_1=u_1,\dots,t_n=u_n\} &amp;&amp;
 &amp;&amp;(\textrm{decompose})\\
E\;\cup\;\{f(t_1,\dots,t_n)=g(u_1,\dots,u_m)\}\;&amp;\Rightarrow \;\bot &amp;&amp;if\ f\not\equiv g \ or\ n\ne m
 &amp;&amp;(\textrm{conflict})\\
E\;\cup\;\{f(t_1,\dots,t_n)=x\}\;&amp;\Rightarrow \;E\;\cup\;\{x=f(t_1,\dots,t_n)\} &amp;&amp;
 &amp;&amp;(\textrm{swap})\\
E\;\cup\;\{x=t\}\;&amp;\Rightarrow \;E\{x\!:=t\}\;\cup\;\{x=t\} &amp;&amp;if\ x\notin Vars(t)\ and\ x\in Vars(G)
 &amp;&amp;(\textrm{eliminate})\\
E\;\cup\;\{x=f(t_1,\dots,t_n)\}\;&amp;\Rightarrow \;\bot &amp;&amp;
if\ x\in Vars(f(t_1,\dots,t_n)) &amp;&amp;(\textrm{check})\\
\end{align}</equation><p>其中<equation>\bot</equation>表示方程组不一致.</p><br><br><p><b>引理12:</b> 方程组<equation>E</equation>经过上述删除(delete)到检查(check)变换操作后得到方程组<equation>E^{'}</equation>, 有<equation>E\simeq E^{'}</equation>.</p><p>证明: 对于矛盾(conflict)和检查(check)变换, 显然原方程组和变换后方程组均不一致, 故等价即<equation>E\simeq E^{'}</equation>.</p><p>对于交换(swap)变换, 显然交换方程两边后方程解保持不变, 即<equation>E\simeq E^{'}</equation>.</p><p>对于删除(delete)变换, 方程<equation>t=t</equation>对于任意解均成立, 删去后方程解保持不变, 即<equation>E\simeq E^{'}</equation>.</p><p>对于分解(decompose)变换, 若<equation>S</equation>为方程组<equation>E^{'}=G\;\cup\;\{t_1=u_1,\dots,t_n=u_n\}</equation>的解, 即有<equation>S(t_1)\equiv S(u_1),\dots,S(t_n)\equiv S(u_n)</equation>, 又由替换定义有<equation>S(f(t_1,\dots,t_n))=f(S(f(t_1)),\dots,S(f(t_n)))=f(S(f(u_1)),\dots,S(f(u_n)))=S(f(u_1,\dots,u_n))</equation>, 故<equation>S</equation>为方程<equation>f(t_1,\dots,t_n)=g(u_1,\dots,u_m)</equation>的解, 故<equation>S</equation>同样为方程组<equation>E=G\;\cup\;\{f(t_1,\dots,t_n)=f(u_1,\dots,u_n)\}</equation>的解, 反之亦然, 即<equation>E\simeq E^{'}</equation>,</p><p>对于消除(eliminate)变换, 若<equation>S</equation>为方程组<equation>E^{'}=G\{x\!:=t\}\;\cup\;\{x=t\}</equation>的解, 即有<equation>S(x)=S(t)</equation>, 另外对于方程组<equation>G\{x\!:=t\}</equation>, <equation>S</equation>为其解且<equation>S(x)=S(t)</equation>, 根据替换的定义, 在方程中替换标识符和代数项<equation>x</equation>与<equation>t</equation>解亦然成立(严格证明可由归纳给出), <equation>S</equation>为方程组<equation>G</equation>的解, 即<equation>S</equation>为方程组<equation>E=G\;\cup\;\{x=t\}</equation>的解, 反之亦然, 故<equation>E\simeq E^{'}</equation>.</p><p>证毕.</p><br><br><p><b>引理13:</b> 对于任意方程组<equation>E</equation>, 只能应用有限次上述删除(delete)到检查(check)变换操作.<br></p><p>证明: 对于矛盾(conflict)和检查(check)变换, 显然进行一次变换后得到<equation>\bot</equation>, 无法继续进行变换.<br></p><p>对于剩余4种变换, 定义三元组<equation>(n_{var},n_{lhs},n_{eqn})</equation>, 其中<equation>n_{var}</equation>表示方程组中重复出现的标识符的数量, <equation>n_{lhs}</equation>表示在方程左边函数符号以及常量的数目,<equation>n_{eqn}</equation>表示方程组中方程的数目. </p><p>其中在三元组上定义字典序, 即三元组<equation>n=(n_{var},n_{lhs},n_{eqn})</equation>和<equation>n^{'}=(n^{'}_{var},n^{'}_{lhs},n^{'}_{eqn})</equation>, <equation>n&lt;n^{'}</equation>当且仅当<equation>n_{var}&lt;n^{'}_{var}</equation>或<equation>n_{var}=n^{'}_{var},\ n_{lhs}&lt;n^{'}_{lhs}</equation>或<equation>n_{var}=n^{'}_{var},\ n_{lhs}=n^{'}_{lhs},\ n_{eqn}&lt;n^{'}_{eqn}</equation>; 若<equation>n_{var}=n^{'}_{var},\ n_{lhs}=n^{'}_{lhs},\ n_{eqn}=n^{'}_{eqn}</equation>则为<equation>n=n^{'}</equation>; 若非<equation>n&lt;n^{'}</equation>与<equation>n=n^{'}</equation>则为<equation>n&gt;n^{'}</equation>. 显然三元组上的字典序是良基关系, 且是全序关系.</p><p>设变换前的三元组为<equation>n</equation>, 变换后的三元组为<equation>n^{'}</equation>.</p><p>对于进行交换(swap)变换, <equation>n_{var}</equation>与<equation>n_{eqn}</equation>保持不变, <equation>n_{lhs}</equation>减小, 故<equation>n^{'}&lt;n</equation>. </p><br><p>对于进行删除(delete)变换, <equation>n_{var}</equation>与<equation>n_{lhs}</equation>不增加, <equation>n_{eqn}</equation>减小, 故<equation>n^{'}&lt;n</equation>. </p><p>对于进行分解(decompose)变换, <equation>n_{var}</equation>保持不变, <equation>n_{lhs}</equation>减小, 故<equation>n^{'}&lt;n</equation>. </p><p>对于进行消除(eliminate)变换, <equation>n_{var}</equation>减少(<equation>G\{x\!:=t\}</equation>中标识符<equation>x</equation>被替换, 变换后方程组中标识符<equation>x</equation>只出现一次, 在<equation>x=t</equation>中), 故<equation>n^{'}&lt;n</equation>.</p><br>由上, 对方程组进行交换, 删除, 分解, 消除变换后均有<equation>n^{'}&lt;n</equation>, 且三元组上定义字典序是良基的. 故对于任意的方程组均只能进行有限次变换.<p>证毕.</p><br><br><p><b>定理3: Robinson's algorithm</b></p><p>对于任意方程组<equation>E</equation>, 在通过有限次上述删除(delete)到检查(check)变换操作后得到等价方程组<equation>E^{'}</equation>, <equation>E^{'}</equation>为已解的(solved form)或不一致的(inconsistent).</p><p>证明: 对于方程组<equation>E</equation>, 若其为非已解的且非不一致的, 根据定义, 可对方程进行删除(delete)到检查(check)的变换操作, 由引理12与引理13得, 在有限次变换操作后(即算法必停机), 无法再继续进行变换, 得到的等价方程组<equation>E^{'}</equation>为已解的或不一致的.</p><p>证毕.<br></p><br><br><p><b>推论3:</b> 一阶合一问题(first-order unification)是可判定的(decidable).</p><p>证明: 由Robinson's algorithm即得. </p><p>证毕.</p><br><br><p><b>定义:</b> 替换<equation>P,R</equation>, 复合替换<equation>S=P\circ R</equation>为<equation>S(t)=(P\circ R)(t)=P(R(t))</equation>. 其中称替换<equation>S</equation>为替换<equation>R</equation>的一个实例(instance). 定义偏序关系<equation>R\leq S</equation>当且仅当<equation>\exists P\;(S=P\circ R)</equation>, 即<equation>S</equation>为<equation>R</equation>的实例.</p><br><br><p><b>定义: </b>替换<equation>R</equation>为方程组<equation>E</equation>的解, <equation>R</equation>为主解(principal solution)则对于任意替换<equation>S</equation>为方程组<equation>E</equation>的解当且仅当<equation>R\leq S</equation>.</p><p>方程的主解的一个例子:<br></p><equation>x=x</equation><br><p>其主解为<equation>R(x)=x</equation>, 另外还有解<equation>S(x)=f(x)</equation>, 其中有<equation>R\leq S</equation>.</p><br><br><p><b>引理14</b>: 若方程组<equation>E</equation>存在解, 则其存在唯一主解(principal solution).</p><p>证明: 对于方程组<equation>E</equation>, 使用Robinson's algorithm, 得到等价已解方程组<equation>E^{'}</equation>, 方程组<equation>E^{'}</equation>中的方程均形如<equation>x=t</equation>. 令替换<equation>R</equation>中的求值<equation>\rho</equation>为<equation>\rho_{R}(x)=t</equation>, 显然替换<equation>R</equation>为方程组的解, 有<equation>t=R(t)</equation>. </p><p>若替换<equation>S</equation>有<equation>R\leq S</equation>, 则<equation>S(x)=P(R(x))=P(\rho_{R}(x))=P(t)=P(R(t))=S(t)</equation>, 故替换<equation>S</equation>为方程的解. </p><p>若替换<equation>S</equation>为方程的解, 有<equation>S(x)=S(t)</equation>, 又有<equation>S(t)=S(R(t))=S(R(x))</equation>即<equation>S(x)=S(R(x))</equation>, 故<equation>R\leq S</equation>. 因此有解<equation>R</equation>为方程的主解.</p><p>显然对于由Robinson's algorithm得到的替换<equation>R</equation>, 其为唯一的.</p><br><p>证毕.</p><br><br><p><b>Type checking and reconstruction algorithm</b></p><br><p><b>定义: </b>对于给定的λ-表达式<equation>M</equation>, 构造关于<equation>M</equation>的方程组<equation>E_{M}</equation>与类型<equation>\tau_{M}</equation>.</p><ul><li>若<equation>M=x</equation>(<equation>x\in S</equation>), 构造<equation>E_{M}=\left\{ \right\} </equation>, <equation>\tau_{M}\!:=\alpha_{x}</equation>其中<equation>\alpha_{x}</equation>为一个新的类型未定元.</li><li>若<equation>M=PQ</equation>, 构造<equation>E_{M}=E_{P}\;\cup\;E_{Q}\;\cup\;\left\{ \tau_P=\tau_Q\to\alpha_M \right\} </equation>, <equation>\tau_{M}\!:=\alpha_{M}</equation>其中<equation>\alpha_{M}</equation>为一个新的类型未定元.</li><li>若<equation>M=(\lambda x.P)</equation>, 构造<equation>E_{M}=E_{P}</equation>, <equation>\tau_{M}=\alpha_{x}\to\tau_{P}</equation>.<br></li></ul><p>注: 在此的一阶标署中的函数唯有二元函数<equation>\to</equation>, 将<equation>\to(\alpha, \beta)</equation>记作<equation>\alpha\to\beta</equation>.</p><br><br><p><b>定理4: 类型检查与重建(type checking and reconstruction)</b></p><ul><li>若<equation>\Gamma \vdash M:\sigma</equation>, 对于方程组<equation>E_{M}</equation>存在解<equation>S</equation>满足<equation>\sigma=S(\tau_M)</equation>与<equation>\forall x\in FV(M)\quad(S(\alpha_{x})=\Gamma(x))</equation>.<br></li><li>若替换<equation>S</equation>为方程组<equation>E_{M}</equation>的解且<equation>\forall x\in FV(M)\quad(S(\alpha_{x})=\Gamma(x))</equation>, 则有<equation>\Gamma \vdash M:S(\tau_M)</equation>.</li></ul><p>证明:</p><p>1. 对<equation>\Gamma \vdash M:\sigma</equation>推导做结构归纳.</p><p>若推导为<equation>\frac{}{\Delta, x:\sigma\vdash x:\sigma}</equation>, 其中<equation>\Gamma =\Delta ,x:\sigma</equation>, <equation>M=x</equation>, <equation>x\notin dom(\Delta )</equation>, 且<equation>E_{M}=\left\{ \right\} </equation>, <equation>\tau_{M}=\alpha_{x}</equation> 显然解<equation>S</equation>为<equation>\rho(\alpha_x)=\sigma</equation>, 即<equation>\sigma=S(\tau_M)</equation>.</p><p>若推导为<equation>\dfrac{\Gamma ,x:\tau_1\vdash P:\tau_2}{\Gamma \vdash (\lambda x.P):\tau_1\to\tau_2}</equation>, 其中<equation>x\notin dom(\Gamma )</equation>, <equation>\sigma=\tau_1 \to \tau_2</equation>, <equation>M=\lambda x.P</equation>, 且<equation>E_{M}=E_{P}</equation>, <equation>\tau_{M}=\alpha_{x}\to\tau_{P}</equation>. 不妨设<equation>x\notin dom(\Gamma^{'} )</equation>, 根据归纳假设有对于<equation>E_{P}</equation>有解<equation>S_{P}</equation>, 令替换<equation>S</equation>为:</p><equation>\rho(\alpha_{M})=\begin{cases}
\tau_1 \to \tau_2 &amp;(M=\lambda x.P)\\
\rho_{P}(\alpha_{M})&amp;(otherwise)
\end{cases}</equation><p>显然<equation>S</equation>为<equation>E_M</equation>的解, 同时有<equation>S(\tau_{(\lambda x.M)})=\tau_1 \to \tau_2</equation>. </p><p>若推导为<equation>\dfrac{\Gamma \vdash P:\tau\to\sigma\quad\Gamma \vdash Q:\tau}{\Gamma \vdash PQ:\sigma}</equation>, 其中<equation>M=PQ</equation>, 且<equation>E_{M}=E_{P}\;\cup\;E_{Q}\;\cup\;\left\{ \tau_P=\tau_Q\to\alpha_M \right\} </equation>, <equation>\tau_{M}=\alpha_{M}</equation>. 根据归纳假设有对于<equation>E_{P}</equation>与<equation>E_{Q}</equation>有解<equation>S_{P}</equation>与<equation>S_{Q}</equation>, 其中<equation>S_{P}(\tau_{P})=\tau\to\sigma</equation>与<equation>S_{Q}(\tau_{Q})=\tau</equation>, 那么构造替换<equation>S</equation>为:</p><equation>\rho(\alpha_{M})=\begin{cases}
\sigma &amp;(M=PQ)\\
\rho_{P}(\alpha_{M})&amp;(M\ is\ sub-expression\ of\ P)\\
\rho_{Q}(\alpha_{M})&amp;(M\ is\ sub-expression\ of\ Q)
\end{cases}</equation><br><p>显然<equation>S</equation>为<equation>E_{P}</equation>与<equation>E_{Q}</equation>的解;</p><p>对于<equation>\tau_P=\tau_Q\to\alpha_M</equation>, 有:</p><equation>\begin{align}
&amp;S(\tau_P)=S(\tau_Q\to\alpha_M)\\
\Rightarrow\ &amp;S(\tau_P)=S(\tau_Q)\to S(\alpha_M)\\
\Rightarrow\  &amp;S_P(\tau_P)=S_Q(\tau_Q)\to \sigma\\
\Rightarrow\  &amp;(\tau\to\sigma)=(\tau\to \sigma)
\end{align}</equation><br><p>故<equation>S</equation>为方程<equation>\tau_P=\tau_Q\to\alpha_M</equation>的解, 即替换<equation>S</equation>为<equation>E_M</equation>的解, 同时有<equation>\sigma=S(\tau_M)</equation>.</p><p>故由归纳得原命题成立.<br></p><br><br><p>2. 对表达式<equation>M</equation>做结构归纳.</p><p>若<equation>M=x</equation>, <equation>x</equation>为任意标识符, 那么有<equation>E_{M}=\left\{ \right\} </equation>, <equation>\tau_{M}=\alpha_{x}</equation>, 原命题显然成立;<br></p><p>若<equation>M=PQ</equation>, 那么有<equation>E_{M}=E_{P}\;\cup\;E_{Q}\;\cup\;\left\{ \tau_P=\tau_Q\to\alpha_M \right\} </equation>, <equation>\tau_{M}=\alpha_{M}</equation>, 替换<equation>S</equation>为方程组<equation>E_{M}</equation>的解, 故<equation>S(\tau_P)=S(\tau_Q\to\alpha_M)=S(\tau_Q)\to S(\tau_M)</equation>, 同时<equation>S</equation>亦为方程<equation>E_P</equation>与<equation>E_Q</equation>的解, 根据归纳假设有<equation>\Gamma \vdash P:S(\tau_P)</equation>即<equation>\Gamma \vdash P:S(\tau_Q)\to S(\tau_M)</equation>与<equation>\Gamma \vdash Q:S(\tau_Q)</equation>, 因此<equation>\Gamma \vdash PQ: S(\tau_M)</equation>, 原命题成立;</p><p>若<equation>M=\lambda x. P</equation>, 那么有<equation>E_{M}=E_{P}</equation>, <equation>\tau_{M}=\alpha_{x}\to\tau_{P}</equation>, 替换<equation>S</equation>为方程组<equation>E_{M}</equation>的解即<equation>E_{P}</equation>的解, 根据归纳假设有<equation>\Gamma,x:S(\alpha_{x}) \vdash P:S(\tau_P)</equation>, 故有<equation>\Gamma \vdash \lambda x. P:S(\alpha_x)\to S(\tau_P)</equation>, 即<equation>\Gamma \vdash \lambda x. P:S(\tau_M)</equation>, 原命题成立;</p><p>故由归纳得原命题成立.<br></p><p>证毕.</p><br><br><p><b>推论4: Type checking and reconstruction algorithm</b></p><p>简单带类型λ-calculus的类型检查与重建是可判定的(decidable).</p><p>证明: 由定理4, 类型检查与重建可规约为一阶合一问题, 对于表达式<equation>M</equation>使用Robinson's algorithm求解方程组<equation>E_{M}</equation>. 由推论3得类型检查与重建是可判定的.</p><br><p>证毕.</p><br><br><p><b>定义: </b>若给定表达式<equation>M</equation>, 对于任何前提<equation>\Gamma</equation>与类型<equation>\sigma</equation>满足<equation>\Gamma \vdash M:\sigma</equation>均存在替换<equation>S</equation>使得<equation>\Gamma =S(\Gamma_{p})</equation>与<equation>\sigma=S(\sigma_p)</equation>, 且有<equation>\Gamma_p \vdash M:\sigma_p</equation>, 则类型<equation>\sigma_p</equation>称为主类型(principal type).</p><p>(<equation>S(\Gamma_{p})</equation>表示对于任意<equation>x</equation>均有<equation>(S(\Gamma))(x)=S(\Gamma(x))</equation>)</p><p>主类型的一个例子:<br></p><br><equation>\begin{align}
&amp;\vdash \lambda x.x:\sigma\to\sigma\\
&amp;\vdash \lambda x.x:(\tau\to\tau)\to(\tau\to\tau)\\
\end{align}</equation><br><p>其中<equation>\sigma\to\sigma</equation>为<equation>\lambda x.x</equation>的主类型. 对于<equation>(\tau\to\tau)\to(\tau\to\tau)</equation>替换<equation>S(\sigma)=\tau\to\tau</equation>.</p><br><br><p><b>推论5: </b>若表达式<equation>M</equation>可类型化(typable), 则其存在唯一的主类型.</p><br><p>证明: 由定理4(类型检查与重建)与引理14得主类型唯一.<br></p><br><p>证毕.</p><br><br><br><p>一阶合一问题在计算机科学与逻辑中广泛出现, 简单带类型λ-calculus的类型检查与重建为其应用之一. 例如使用合一算法可以实现树形数据结构的匹配, 例如嵌套模式匹配等等. 更多的应用就等大家取慢慢发现啦. </p><p>这篇文章介绍了不少内容, 篇幅比较长, 感谢大家的耐心阅读啦喵~</p><p>最後感謝莎莎喵一直以來的支持</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
