<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Zero谈数学——对称函数和它的弟兄们（2）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/23827725">原文</a></p>
上回说到，所有的对称函数弟兄们，都是被对称单项式<equation>m_\lambda</equation>搞基搞出来的（大雾）。<p>那我们为什么还要研究<equation>e_\lambda</equation>们呢？（<equation>e_\lambda</equation>名字叫基本对称多项式）</p><p>很简单啊！你看它名字里都有个基了，这是不是预示着什么！</p><p>（预示着可以搞基？）</p><p>预示着这玩意儿其实也是一组（线性）基。证明大意是这样的：所有的满足<equation>|\lambda|\leq n</equation>的<equation>e_\lambda</equation>可以写成所有满足同样条件的<equation>m_\lambda</equation>的线性组合，而这个矩阵是可逆的，所以我们可以反过来把<equation>m_\lambda</equation>写成<equation>e_\lambda</equation>的线性组合，所以……证毕</p><p>RMK：这里<equation>|\lambda|=\lambda_1+\lambda_2+\lambda_3+\cdots</equation>也就是<equation>\lambda</equation>这个不增序列的和，比如<equation>\lambda=(2,1,1) \Rightarrow |\lambda|=4</equation></p><h2><b>第三者！</b></h2><p>关于<equation>e_\lambda</equation>的概况，差不多到这里就结束了，接下来要介绍它的一位好朋(ji)友<equation>h_\lambda</equation>，也就是大名鼎鼎（并没有）的<b>完全齐次对称多项式（Complete Homogeneous Symmetric Polynomials）</b></p><p><equation>h_\lambda</equation>的定义和<equation>e_\lambda</equation>很相似，还记得大明湖畔的夏……，哦不，<equation>e_{(2,1,1)}=e_2\cdot e_1 \cdot e_1</equation>吗？一般来说，<equation>e_\lambda=e_{\lambda_1}\cdot e_{\lambda_2}\cdot e_{\lambda_3}\cdots</equation> 对于<equation>h_\lambda</equation>，完全就是一样的定义：<equation>h_\lambda=h_{\lambda_1}\cdot h_{\lambda_2}\cdot h_{\lambda_3}\cdots</equation><br></p><p>接下来，不是见证奇迹的时刻，因为……上面的定义其实啥用都没有，我们连<equation>h_1,h_2,\cdots</equation>这些东西是啥都不知道！</p><p>再来一个定义，<equation>h_k</equation>就是所有的次数等于<equation>k</equation>的单项式的和</p><p>举个栗子：两次单项式有<equation>x_1^2,x_2^2,x_3^2,x_1x_2,x_2x_3,x_1x_3</equation>，所以<equation>h_2=x_1^2+x_2^2+x_3^2+x_1x_2+x_2x_3+x_1x_3</equation>。当然我这里只是写出了3个变量的特殊情形，实际上我们会考虑无穷多个变量的case。</p><p>Anyway，我们已经知道了三种对称多项式<equation>m_\lambda,e_\lambda,h_\lambda</equation>了，而且我们知道前面两个是基，那第三个是不是呢？</p><p>其实，它也构成一组基，这个证明和证明<equation>e_\lambda</equation>是一组基的证明完全一样。</p><p>我们已经有了三组基了！下面是不是该考虑怎么组CP的问题了！（大雾！！</p><p>其实冥冥之中，<equation>e_\lambda</equation>和<equation>h_\lambda</equation>的命运已经被紧紧相连，而<equation>m_\lambda</equation>由于受不了这虐狗的现实，很快就将消失在以后的文章里（这难道不是作者强行规定的吗喂！）</p><br>在<equation>m_\lambda</equation>离开之前，我们还有一件事情需要<equation>m_\lambda</equation>来完成（对单身狗<equation>m_\lambda</equation>造成无穷点伤害）：我们可以在对称函数上定义一种内积结构<equation>&lt;-,-&gt;</equation>，具体为<equation>&lt;h_\lambda,m_\mu&gt;=\delta_{\lambda\mu}</equation><p>那么问题就来了：</p><ol><li>这就定义完了？这玩意儿真的是定义良好（well-defined）的吗？</li><li>为什么要这么定义？</li></ol><p>回答：</p><ol><li>其实还没有，具体的描述如下：任何两个对称函数<equation>f</equation>和<equation>g</equation>都可以唯一的展开成<equation>h_\lambda</equation>和<equation>m_\lambda</equation>的线性组合，比如<equation>f=\sum_\lambda f_\lambda h_\lambda</equation>和<equation>g=\sum_\mu g_\mu m_\mu</equation>，那么<equation>&lt;f,g&gt;=\sum_\nu f_\nu g_\nu</equation></li><li>以后你就会发现这个东西有着很神奇的作用</li></ol><p>回到<equation>e_\lambda</equation>和<equation>h_\lambda</equation>这对CP上，为什么它们之间有着很强烈的联系呢？</p><p>因为利用这俩东西，我们可以定义一个变换<equation>\omega</equation>，具体作用就是<equation>\omega(e_\lambda)=h_\lambda</equation>。可以证明，这个变换是个involution，也就说，作用两次就等于什么都没干。（就像电灯开关，拨动开关两次等于啥都没做）也就是所，<equation>\omega(h_\lambda)=e_\lambda</equation>。</p><p>有了内积我们就会问（其实懒得问），什么是一组正交基？</p><p>有了这个involution我们会问（其实根本想不到要问），它的特征向量是谁？</p><p>带着这两个问题，很快我们会迎来新的朋友</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
