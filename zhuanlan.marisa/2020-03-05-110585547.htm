<div class="title-image"><img src="https://pic1.zhimg.com/v2-9eb8fec960660da88a7ae6bbabf0bb63_b.jpg" alt=""></div><h2>废话</h2><p>（这篇文章不是monad getting started tutorial）</p><p>自从Haskell作为第一个编程语言，将monad引入软件工程后，各种基于monad实现的库开始纷纷出现。实现一些通常来说需要hack或向语言添加新特性，来做到良好支持的功能变得能通过提供monadic DSL的方法来实现。monad同时也带来了很多争议，不被理解，甚至导致其被整日拿来批判，为什么我实现一个简单的mutable variable还需要用monad？从软件工程上来说，monad并不是一个很高深的东西。很多源于cat theory的复杂性并不是monad在软件工程上使用所必须理解的，虽然懂cat theory确实会对monad有更深入的理解和看法。学会了使用monad后甚至可以在一些完全没有考虑过monad的语言上使用它，而不是局限于Haskell中。所以，如果要解决简单的问题，当然是使用合适的方法，当需要解决的问题使用monad能更容易解决的时候使用monad，而不是一味的批判使用monad孰优孰劣，使用适合的工具解决适合的问题。</p><h2>Elementary Monad</h2><p>一般来说实现一个monadic DSL首先需要定义一个datatype，其具体的定义根据实际的DSL来决定，例如对于如果要实现简单的mutable state的话：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">State</span> <span class="nf">s</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="nf">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">s</span><span class="p">,</span> <span class="nf">a</span><span class="p">))</span></code></pre></div><p>然后分别实现需要的typeclass：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">State</span> <span class="nf">s</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="kt">State</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="nf">t</span><span class="p">,</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">g</span> <span class="nf">s</span> <span class="kr">in</span> <span class="p">(</span><span class="nf">t</span><span class="p">,</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">State</span> <span class="nf">s</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">s</span><span class="p">,</span> <span class="nf">a</span><span class="p">))</span>

  <span class="kt">State</span> <span class="nf">f</span> <span class="o">&lt;*&gt;</span> <span class="kt">State</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span>
    <span class="kr">let</span> <span class="p">(</span><span class="nf">t</span><span class="p">,</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">s</span>
        <span class="p">(</span><span class="nf">u</span><span class="p">,</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">g</span> <span class="nf">t</span>
    <span class="kr">in</span> <span class="p">(</span><span class="nf">u</span><span class="p">,</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">State</span> <span class="nf">s</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">State</span> <span class="nf">g</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="nf">\s</span> <span class="ow">-&gt;</span>
    <span class="kr">let</span> <span class="p">(</span><span class="nf">t</span><span class="p">,</span> <span class="nf">a</span><span class="p">)</span>  <span class="ow">=</span> <span class="nf">g</span> <span class="nf">s</span>
        <span class="kt">State</span> <span class="nf">h</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span>
    <span class="kr">in</span> <span class="nf">h</span> <span class="nf">t</span><span class="p">)</span></code></pre></div><p>也许之后还需要进行equational reasoning来保证其符合monad laws，虽然一般来说就直接YOLO了，从工程角度上来说没什么必要www。定义了datatype之后就可以写各种DSL需要用到的function了，这个就完全是自由发挥了。</p><p>但是也存在一些问题，例如对于特定的monadic DSL，其对应的datatype应该如何下手定义？当然如果要运行一个monadic DSL，例如对于mutable state，就需要提供初始的状态，并返回其结果：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">evalState</span> <span class="ow">::</span> <span class="kt">State</span> <span class="nf">s</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">s</span> <span class="ow">-&gt;</span> <span class="nf">a</span></code></pre></div><p>当然也许还需要state monad运行完毕后的最终状态：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">runState</span> <span class="ow">::</span> <span class="kt">State</span> <span class="nf">s</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">s</span><span class="p">,</span> <span class="nf">a</span><span class="p">)</span></code></pre></div><p>就得到了state monad的datatype需要的定义。因为monad只不过是让其可以compose而已。</p><p>但是有时候事情并不是这么简单。例如对于复杂的monad，也许存在一些中间状态，并不需要暴露在外部，就像evalState一样，也许并不需要返回最终状态。又或许写到一半发现需要给monadic DSL添加新的功能，修改datatype的定义的话又会影响到已经写好的DSL function。再或许monadic DSL本身的设计还没有完全确定，那么就会陷入先有鸡还是先有蛋的问题，没有datatype的定义，写不了DSL function，确定不了具体的monadic DSL，写不了datatype的定义，最后需要要一步到位才能解决。另外就是还存在不必要的boilerplate等。</p><h2>Feeling Free</h2><p>这种情况下就可以使用free monad来解决问题，其基本思想是对于任意的functor，自动给出一个monad，monad compose时将其原封不动的构造成一个树形的结构，最后再对其进行解释运行。</p><p>例如对于常用于实现generator、coroutine的yield monad，其要么返回一个值x，要么输出一个o，然后输入一个i，然后继续执行。其基本实现如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">x</span>
  <span class="ow">=</span> <span class="kt">Done</span> <span class="nf">x</span>
  <span class="o">|</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="p">(</span><span class="nf">i</span> <span class="ow">-&gt;</span> <span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">x</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="kt">Done</span> <span class="nf">x</span>  <span class="ow">=</span> <span class="kt">Done</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">f</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">Done</span>

  <span class="kt">Done</span> <span class="nf">f</span> <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">fa</span>
  <span class="kt">Run</span> <span class="nf">o</span> <span class="nf">f</span> <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="p">((</span><span class="o">&lt;*&gt;</span> <span class="nf">fa</span><span class="p">)</span> <span class="o">.</span> <span class="nf">f</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Done</span> <span class="nf">a</span>  <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="kt">Run</span> <span class="nf">o</span> <span class="nf">g</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="nf">f</span><span class="p">)</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span>

<span class="nf">yield</span> <span class="ow">::</span> <span class="nf">o</span> <span class="ow">-&gt;</span> <span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">i</span>
<span class="nf">yield</span> <span class="nf">o</span> <span class="ow">=</span> <span class="kt">Run</span> <span class="nf">o</span> <span class="p">(</span><span class="nf">\i</span> <span class="ow">-&gt;</span> <span class="kt">Done</span> <span class="nf">i</span><span class="p">)</span></code></pre></div><p>这里其实就已经用到了free monad的思想，只不过没有将其写出来，而是inline了进去。</p><p>考虑如下更简单的情况，输出一个o，然后输入一个i，之后直接返回x：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">YieldF</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">x</span> <span class="ow">=</span> <span class="kt">YieldF</span> <span class="nf">o</span> <span class="p">(</span><span class="nf">i</span> <span class="ow">-&gt;</span> <span class="nf">x</span><span class="p">)</span></code></pre></div><p>其本身是一个functor，但并不是monad：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">YieldF</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="p">(</span><span class="kt">YieldF</span> <span class="nf">o</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">YieldF</span> <span class="nf">o</span> <span class="p">(</span><span class="nf">f</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span></code></pre></div><p>先给出free monad的定义：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Free</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="ow">=</span> <span class="kt">Pure</span> <span class="nf">a</span>
  <span class="o">|</span> <span class="kt">Impure</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Free</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="kt">Pure</span> <span class="nf">a</span>   <span class="ow">=</span> <span class="kt">Pure</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="kt">Impure</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kt">Impure</span> <span class="p">(</span><span class="nf">fmap</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">f</span><span class="p">)</span> <span class="nf">g</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Free</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">Pure</span>

  <span class="kt">Pure</span> <span class="nf">f</span>   <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">fa</span>
  <span class="kt">Impure</span> <span class="nf">f</span> <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="kt">Impure</span> <span class="p">(</span><span class="nf">fmap</span> <span class="p">(</span><span class="o">&lt;*&gt;</span> <span class="nf">fa</span><span class="p">)</span> <span class="nf">f</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Free</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Pure</span> <span class="nf">a</span>   <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="kt">Impure</span> <span class="nf">g</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Impure</span> <span class="p">(</span><span class="nf">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="nf">f</span><span class="p">)</span> <span class="nf">g</span><span class="p">)</span></code></pre></div><p>然后可以使用free monad从<code>YieldF</code>重新定义yield monad：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="kt">Yield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="ow">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">YieldF</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span></code></pre></div><p>如果仔细看free monad的定义可以发现其实free monad就是给特定的functor加上<code>Pure</code>作为tree的leaf，并使用<code>Impure</code>作为tree的branch，使得functor可以嵌套。简单来说<code>pure</code> 、<code>return</code>返回一个新的leaf， <code>&gt;&gt;=</code>对原来的tree通过<code>fmap</code>对其内部branch所有的leaf都进行扩展，来返回一个新的tree。要运行的话就对这个tree进行解释就可以了。</p><p>free monad解决了boilerplate的问题，并让任意的functor都可以变成monad。或许还额外让不进行equational reasoning更有理由了www，毕竟只要满足functor laws就自动满足monad laws了。而大部分情况下的functor都是可以直接deriving出来的。</p><p>但是free monad也存在一些问题，例如每次compose都需要对整个tree进行fmap www</p><h2>Become Freer</h2><p>freer monad是升级版的free monad。如果说free monad对于任意的functor，能自动给出一个monad的话，freer monad就能对任意的type constructor，给出一个monad。</p><p>当然，freer monad也许还有更好的解释，那就是对任意type constructor，首先给出一个free functor，然后再将这个functor通过free monad变成monad，free functor的定义如下：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">FreerF</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="nf">forall</span> <span class="nf">x</span><span class="o">.</span> <span class="kt">FreerF</span> <span class="p">(</span><span class="nf">x</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">FreerF</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="p">(</span><span class="kt">FreerF</span> <span class="nf">g</span> <span class="nf">fa</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FreerF</span> <span class="p">(</span><span class="nf">f</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span> <span class="nf">fa</span></code></pre></div><p>free functor对任意的<code>f x</code>，每<code>fmap</code>一次，就将对应的<code>f</code>compose到之前的<code>g</code>最后。</p><p>然后再将free functor变得更加freer：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">FreerF</span> <span class="nf">f</span><span class="p">)</span></code></pre></div><p>当然标准做法是直接丢掉<code>Free</code>，将其inline：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="ow">=</span> <span class="kt">FPure</span> <span class="nf">a</span>
  <span class="o">|</span> <span class="nf">forall</span> <span class="nf">x</span><span class="o">.</span> <span class="kt">FImpure</span> <span class="p">(</span><span class="nf">x</span> <span class="ow">-&gt;</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Freer</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="p">(</span><span class="kt">FPure</span> <span class="nf">a</span><span class="p">)</span>      <span class="ow">=</span> <span class="kt">FPure</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="p">(</span><span class="kt">FImpure</span> <span class="nf">g</span> <span class="nf">fx</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">(</span><span class="nf">fmap</span> <span class="nf">f</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span> <span class="nf">fx</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Freer</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">FPure</span>

  <span class="kt">FPure</span> <span class="nf">f</span>      <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">fa</span>
  <span class="kt">FImpure</span> <span class="nf">f</span> <span class="nf">fx</span> <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">((</span><span class="o">&lt;*&gt;</span> <span class="nf">fa</span><span class="p">)</span> <span class="o">.</span> <span class="nf">f</span><span class="p">)</span> <span class="nf">fx</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Freer</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">FPure</span> <span class="nf">a</span>      <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="kt">FImpure</span> <span class="nf">g</span> <span class="nf">fx</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="nf">f</span><span class="p">)</span> <span class="o">.</span> <span class="nf">g</span><span class="p">)</span> <span class="nf">fx</span> </code></pre></div><p>到这里就可以用freer monad玩一些很fancy的东西，可以将monadic DSL和对DSL的解释完全分开，解决chicken or egg problem：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">lift</span> <span class="ow">::</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">a</span>
<span class="nf">lift</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="kt">FPure</span> <span class="nf">fa</span>

<span class="kr">data</span> <span class="kt">YieldEff</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">x</span> <span class="kr">where</span>
  <span class="kt">Yield</span> <span class="ow">::</span> <span class="nf">o</span> <span class="ow">-&gt;</span> <span class="kt">YieldEff</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">i</span>

<span class="kr">type</span> <span class="kt">EffYield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="ow">=</span> <span class="kt">Freer</span> <span class="p">(</span><span class="kt">YieldEff</span> <span class="nf">i</span> <span class="nf">o</span><span class="p">)</span>

<span class="nf">yield</span> <span class="ow">::</span> <span class="nf">o</span> <span class="ow">-&gt;</span> <span class="kt">EffYield</span> <span class="nf">i</span> <span class="nf">o</span> <span class="nf">i</span>
<span class="nf">yield</span> <span class="nf">o</span> <span class="ow">=</span> <span class="nf">lift</span> <span class="p">(</span><span class="kt">Yield</span> <span class="nf">o</span><span class="p">)</span></code></pre></div><p>甚至还可以在freer monad上继续扩展，进化为extensible effect，只不过这就超纲不是这篇文章的内容了www</p><h2>About performance?</h2><p>一个技术是否能在实际工程中使用，除了易用性以外，还需要考虑其性能。当然并不是所有场景下性能都是关键的，有时候技术的易用性更重要，反之亦然。那么freer monad的性能如何？是否可以继续优化？</p><p>研究一个问题首先可以尝试先研究其更简单的情况，对于monadic DSL来说，最常使用的是do notation：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">EffYield</span> <span class="kt">Bool</span> <span class="kt">Integer</span> <span class="kt">Bool</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="nf">b1</span> <span class="ow">&lt;-</span> <span class="nf">yield</span> <span class="mi">1</span>
  <span class="nf">b2</span> <span class="ow">&lt;-</span> <span class="nf">yield</span> <span class="mi">2</span>
  <span class="nf">b3</span> <span class="ow">&lt;-</span> <span class="nf">yield</span> <span class="mi">3</span>
  <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span> <span class="o">||</span> <span class="nf">b3</span><span class="p">)</span></code></pre></div><p>将do notation desugar之后为：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">EffYield</span> <span class="kt">Bool</span> <span class="kt">Integer</span> <span class="kt">Bool</span>
<span class="nf">foo</span> <span class="ow">=</span>  <span class="nf">yield</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b3</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span> <span class="o">||</span> <span class="nf">b3</span><span class="p">))))</span></code></pre></div><p>不难发现这种情况下对于<code>&gt;&gt;=</code>来说是右结合的。将其进行展开：</p><div class="highlight"><pre><code class="language-haskell">  <span class="nf">yield</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b3</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span> <span class="o">||</span> <span class="nf">b3</span><span class="p">))))</span>
<span class="c1">-- by definition of yield</span>
<span class="ow">=</span> <span class="p">(</span><span class="kt">FImpure</span> <span class="kt">FPure</span> <span class="p">(</span><span class="kt">Yield</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b3</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span> <span class="o">||</span> <span class="nf">b3</span><span class="p">))))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
<span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b3</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span> <span class="o">||</span> <span class="nf">b3</span><span class="p">)))))</span> <span class="o">.</span> <span class="kt">FPure</span><span class="p">)</span> <span class="p">(</span><span class="kt">Yield</span> <span class="mi">1</span><span class="p">)</span></code></pre></div><p>假设对其进行解释执行后<code>yield 1</code>返回了<code>True</code>： </p><div class="highlight"><pre><code class="language-haskell">  <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b3</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span> <span class="o">||</span> <span class="nf">b3</span><span class="p">)))))</span> <span class="o">.</span> <span class="kt">FPure</span><span class="p">)</span> <span class="kt">True</span>
<span class="c1">-- by definition of (.) </span>
<span class="ow">=</span> <span class="kt">FPure</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b3</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span> <span class="o">||</span> <span class="nf">b3</span><span class="p">))))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
<span class="ow">=</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b3</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span> <span class="o">||</span> <span class="nf">b3</span><span class="p">)))</span></code></pre></div><p>不难发现对于每一个DSL operation，每次只需要常数时间。</p><p>那么对于左结合的情况呢？理想情况下应该花费的时间相对于DSL operation的个数而言应该是线性的。考虑以下情况：</p><div class="highlight"><pre><code class="language-haskell"><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">EffYield</span> <span class="kt">Bool</span> <span class="kt">Integer</span> <span class="kt">Bool</span>
<span class="nf">foo</span> <span class="nf">n</span> <span class="ow">=</span> <span class="kr">if</span> <span class="nf">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="kr">then</span> <span class="nf">return</span> <span class="kt">True</span> <span class="kr">else</span> <span class="kr">do</span>
  <span class="nf">b1</span> <span class="ow">&lt;-</span> <span class="nf">foo</span> <span class="p">(</span><span class="nf">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="nf">b2</span> <span class="ow">&lt;-</span> <span class="nf">yield</span> <span class="nf">n</span>
  <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)</span></code></pre></div><p>在<code>foo 2</code>的情况下，desugar之后是：</p><div class="highlight"><pre><code class="language-haskell"><span class="p">(</span><span class="nf">return</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span></code></pre></div><p>将其进行展开：</p><div class="highlight"><pre><code class="language-haskell">  <span class="p">(</span><span class="nf">return</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of return</span>
<span class="ow">=</span> <span class="p">(</span><span class="kt">FPure</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
<span class="ow">=</span> <span class="p">(</span><span class="nf">yield</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of yield</span>
<span class="ow">=</span> <span class="p">((</span><span class="kt">FImpure</span> <span class="kt">FPure</span> <span class="p">(</span><span class="kt">Yield</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
<span class="ow">=</span> <span class="p">(</span><span class="kt">FImpure</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">.</span> <span class="kt">FPure</span><span class="p">)</span> <span class="p">(</span><span class="kt">Yield</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
<span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">.</span> <span class="kt">FPure</span><span class="p">))</span> <span class="p">(</span><span class="kt">Yield</span> <span class="mi">1</span><span class="p">)</span></code></pre></div><p>接下来假设对其进行解释执行后<code>yield 1</code>返回了<code>True</code>：</p><div class="highlight"><pre><code class="language-haskell">  <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">.</span> <span class="kt">FPure</span><span class="p">))</span> <span class="kt">True</span>
<span class="c1">-- by definition of (.)</span>
<span class="ow">=</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">(</span><span class="kt">FPure</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of (.)</span>
<span class="ow">=</span> <span class="p">(</span><span class="kt">FPure</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
<span class="ow">=</span> <span class="nf">return</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span></code></pre></div><p>仔细观察可以注意对每一个DSL operation，其嵌套的越深，其需要拆开的<code>&gt;&gt;=</code>就越多，而且这种性能消耗不是一次性的，对于左结合的monadic DSL，每一次解释一个DSL operation都会有这种性能消耗，可想而知其花费的时间绝对不是线性的。对于<code>foo 3</code>的情况：</p><div class="highlight"><pre><code class="language-haskell">  <span class="p">((</span><span class="nf">return</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of return</span>
<span class="ow">=</span> <span class="p">((</span><span class="kt">FPure</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
  <span class="p">((</span><span class="nf">yield</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of yield</span>
  <span class="p">(((</span><span class="kt">FImpure</span> <span class="kt">FPure</span> <span class="p">(</span><span class="kt">Yield</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
  <span class="p">((</span><span class="kt">FImpure</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">.</span> <span class="kt">FPure</span><span class="p">)</span> <span class="p">(</span><span class="kt">Yield</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
  <span class="p">(</span><span class="kt">FImpure</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">.</span> <span class="kt">FPure</span><span class="p">))</span> <span class="p">(</span><span class="kt">Yield</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
  <span class="kt">FImpure</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">.</span> <span class="kt">FPure</span><span class="p">)))</span> <span class="p">(</span><span class="kt">Yield</span> <span class="mi">1</span><span class="p">)</span></code></pre></div><p>假设对其进行解释执行后<code>yield 1</code>后返回<code>True</code>：</p><div class="highlight"><pre><code class="language-haskell">  <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">.</span> <span class="kt">FPure</span><span class="p">)))</span> <span class="kt">True</span>
<span class="c1">-- by definition of (.)</span>
<span class="ow">=</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">(</span><span class="kt">FPure</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span>
<span class="c1">-- by definition of (.)</span>
<span class="ow">=</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">.</span> <span class="p">((</span><span class="kt">FPure</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span>
<span class="c1">-- by definition of (.)</span>
<span class="ow">=</span> <span class="p">((</span><span class="kt">FPure</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span>
<span class="c1">-- by definition of (&gt;&gt;=)</span>
<span class="ow">=</span> <span class="p">(</span><span class="nf">return</span> <span class="kt">True</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">))))</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b1</span> <span class="ow">-&gt;</span> <span class="nf">yield</span> <span class="mi">3</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\b2</span> <span class="ow">-&gt;</span> <span class="nf">return</span> <span class="p">(</span><span class="nf">b1</span> <span class="o">&amp;&amp;</span> <span class="nf">b2</span><span class="p">)))</span></code></pre></div><p>可以注意到结果等价于<code>foo 2</code> 。这时候，解决方案就很明显了，只要能一次性对左结合的monadic DSL进行变换，转换成右结合的形式，且其花费的时间是线性的，就可以解决这个问题了。</p><p>经过观察不难发现，问题的本质其实是在于<code>FImpure</code>只能够保存一个kleisli arrow，且需要运行这个DSL operation才能拿到内部的结构，进而导致非右结合的monadic DSL性能低下。也就是说，如果在<code>&gt;&gt;=</code>里能将kleisli arrow进行保存，就可以一次性对其进行处理，进而解决问题：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">Arrow</span> <span class="nf">f</span> <span class="nf">a</span> <span class="nf">b</span>
  <span class="ow">=</span> <span class="kt">Arrow</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">b</span><span class="p">)</span>
  <span class="o">|</span> <span class="nf">forall</span> <span class="nf">x</span><span class="o">.</span> <span class="kt">Compose</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="nf">f</span> <span class="nf">a</span> <span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="nf">f</span> <span class="nf">x</span> <span class="nf">b</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="ow">=</span> <span class="kt">FPure</span> <span class="nf">a</span>
  <span class="o">|</span> <span class="nf">forall</span> <span class="nf">x</span><span class="o">.</span> <span class="kt">FImpure</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="nf">f</span> <span class="nf">x</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">x</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Freer</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="p">(</span><span class="kt">FPure</span> <span class="nf">a</span><span class="p">)</span>        <span class="ow">=</span> <span class="kt">FPure</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span>
  <span class="nf">f</span> <span class="p">`</span><span class="nf">fmap</span><span class="p">`</span> <span class="p">(</span><span class="kt">FImpure</span> <span class="nf">arr</span> <span class="nf">fx</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">(</span><span class="kt">Compose</span> <span class="nf">arr</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="p">(</span><span class="kt">FPure</span> <span class="o">.</span> <span class="nf">f</span><span class="p">)))</span> <span class="nf">fx</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Freer</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">pure</span> <span class="ow">=</span> <span class="kt">FPure</span>

  <span class="kt">FPure</span> <span class="nf">f</span>        <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">fa</span>
  <span class="kt">FImpure</span> <span class="nf">arr</span> <span class="nf">fx</span> <span class="o">&lt;*&gt;</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">(</span><span class="kt">Compose</span> <span class="nf">arr</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="p">(</span><span class="nf">\f</span> <span class="ow">-&gt;</span> <span class="nf">fmap</span> <span class="nf">f</span> <span class="nf">fa</span><span class="p">)))</span> <span class="nf">fx</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Freer</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">FPure</span> <span class="nf">a</span>        <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="kt">FImpure</span> <span class="nf">arr</span> <span class="nf">fx</span> <span class="o">&gt;&gt;=</span> <span class="nf">f</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">(</span><span class="kt">Compose</span> <span class="nf">arr</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="nf">f</span><span class="p">))</span> <span class="nf">fx</span>

<span class="nf">lift</span> <span class="ow">::</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">a</span>
<span class="nf">lift</span> <span class="nf">fa</span> <span class="ow">=</span> <span class="kt">FImpure</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="kt">FPure</span><span class="p">)</span> <span class="nf">fa</span></code></pre></div><p>然后是最关键的一步，在对<code>Arrow</code>进行apply的时候对其一次性进行处理：</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">LeftView</span> <span class="nf">f</span> <span class="nf">a</span> <span class="nf">b</span>
  <span class="ow">=</span> <span class="kt">One</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">b</span><span class="p">)</span>
  <span class="o">|</span> <span class="nf">forall</span> <span class="nf">x</span><span class="o">.</span> <span class="kt">More</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="nf">f</span> <span class="nf">x</span> <span class="nf">b</span><span class="p">)</span>

<span class="nf">leftview</span> <span class="ow">::</span> <span class="kt">Arrow</span> <span class="nf">f</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="kt">LeftView</span> <span class="nf">f</span> <span class="nf">a</span> <span class="nf">b</span>
<span class="nf">leftview</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="nf">f</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">One</span> <span class="nf">f</span>
<span class="nf">leftview</span> <span class="p">(</span><span class="kt">Compose</span> <span class="nf">l</span> <span class="nf">r</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">transform</span> <span class="nf">l</span> <span class="nf">r</span>

<span class="nf">transform</span> <span class="ow">::</span> <span class="kt">Arrow</span> <span class="nf">f</span> <span class="nf">a</span> <span class="nf">x</span> <span class="ow">-&gt;</span> <span class="kt">Arrow</span> <span class="nf">f</span> <span class="nf">x</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="kt">LeftView</span> <span class="nf">f</span> <span class="nf">a</span> <span class="nf">b</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="nf">f</span><span class="p">)</span>     <span class="nf">r</span> <span class="ow">=</span> <span class="kt">More</span> <span class="nf">f</span> <span class="nf">r</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Compose</span> <span class="nf">l</span> <span class="nf">m</span><span class="p">)</span> <span class="nf">r</span> <span class="ow">=</span> <span class="nf">transform</span> <span class="nf">l</span> <span class="p">(</span><span class="kt">Compose</span> <span class="nf">m</span> <span class="nf">r</span><span class="p">)</span>

<span class="nf">apply</span> <span class="ow">::</span> <span class="kt">Arrow</span> <span class="nf">f</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Freer</span> <span class="nf">f</span> <span class="nf">b</span>
<span class="nf">apply</span> <span class="nf">arr</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kr">case</span> <span class="nf">leftview</span> <span class="nf">arr</span> <span class="kr">of</span>
  <span class="kt">One</span> <span class="nf">f</span>    <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">a</span>
  <span class="kt">More</span> <span class="nf">f</span> <span class="nf">r</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="nf">f</span> <span class="nf">a</span> <span class="kr">of</span>
    <span class="kt">FPure</span> <span class="nf">x</span>      <span class="ow">-&gt;</span> <span class="nf">apply</span> <span class="nf">r</span> <span class="nf">x</span>
    <span class="kt">FImpure</span> <span class="nf">l</span> <span class="nf">fy</span> <span class="ow">-&gt;</span> <span class="kt">FImpure</span> <span class="p">(</span><span class="kt">Compose</span> <span class="nf">l</span> <span class="nf">r</span><span class="p">)</span> <span class="nf">fy</span></code></pre></div><p>这样就解决了左结合的monadic DSL的性能问题。</p>