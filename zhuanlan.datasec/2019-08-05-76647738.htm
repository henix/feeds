<div class="title-image"><img src="https://pic4.zhimg.com/v2-7b01b1ba136277a4576b00ee4b38443b_b.jpg" alt=""></div><h2>写在前面</h2><p>最近收到了一位知友的私信，询问能否把《Winter School on Cryptography 2012: Lattice-Based Cryptography》的一系列字幕也发布出来，供参考和学习。经过与 <a class="member_mention" href="https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b" data-hash="60a93d8892402f3493146a4fd54c5f2b" data-hovercard="p$b$60a93d8892402f3493146a4fd54c5f2b">@i春秋学院</a> 当时字幕负责人的讨论，由于相关字幕已经发布了很长时间，我已经可以将字幕发布出来供知友们学习了！因此，在接下来一段时间，我会集中整理《Winter School on Cryptography 2012: Lattice-Based Cryptography》的字幕，重新压制视频并放出。感谢 <a class="member_mention" href="https://www.zhihu.com/people/60a93d8892402f3493146a4fd54c5f2b" data-hash="60a93d8892402f3493146a4fd54c5f2b" data-hovercard="p$b$60a93d8892402f3493146a4fd54c5f2b">@i春秋学院</a> 一直以来的支持！</p><p>虽然会集中整理之前的字幕，但是我也会不断听写新的视频，如果有任何顶级安全会议中数据安全相关讲座的听译需求，还请知友们私信我，或者直接在评论区留言。对于一些很大工作量的听译工作（如《Winter School on Cryptography 2015: Practical Secure Multi-Party Computation》这类），我也会持续坚持听译，到合适的时间再对外发布，敬请知友们耐心等待。</p><h2>演讲视频简介</h2><p>本次为知友们带来的视频是CRYPTO 2013论文《Improved OT Extension for Transferring Short Secrets》。OT Extension协议是安全多方计算中最重要、也是最核心的协议。熟悉OT的知友们可能知道，OT Extension中最核心的论文应该是CRYPTO 2003的《Extending Oblivious Transfer Efficiently》以及CCS 2013的《More Efficient Oblivious Transfer and Extensions for Faster Secure Computation》。不过我一直没有找到这两个讲座的视频，如果哪位知友知道视频链接，也可以在评论区告诉我。</p><p>《Improved OT Extension for Transferring Short Secrets》的重要程度相对这两篇论文来说没有那么高，但这篇论文是优化GMW协议的重要理论基础。如果想实现基于GMW协议的安全多方计算应用，这篇论文的阅读和实现也是必不可少的。CRYPTO 2013对应的演讲视频介绍了《Improved OT Extension for Transferring Short Secrets》的基本思想，观看视频后再去读论文会有更深入的理解。</p><h2>演讲视频信息</h2><ul><li>原始视频来源：<a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DAgPZVecLuXs" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">youtube.com/watch?</span><span class="invisible">v=AgPZVecLuXs</span><span class="ellipsis"></span></a></li><li>中文翻译视频：<a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av62237491/" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://www.</span><span class="visible">bilibili.com/video/av62</span><span class="invisible">237491/</span><span class="ellipsis"></span></a></li><li>双语字幕链接：<a href="https://link.zhihu.com/?target=https%3A//github.com/liuweiran900217/SecurityConferenceLectures/tree/master/CRYPTO%25202013/Improved%2520OT%2520Extension%2520for%2520Transferring%2520Short%2520Secrets" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/liuweiran900</span><span class="invisible">217/SecurityConferenceLectures/tree/master/CRYPTO%202013/Improved%20OT%20Extension%20for%20Transferring%20Short%20Secrets</span><span class="ellipsis"></span></a></li></ul><h2>中文字幕视频</h2><a class="video-box" href="https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1141506723897516032" target="_blank" data-video-id="" data-video-playable="true" data-name="" data-poster="https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png" data-lens-id="1141506723897516032"><img class="thumbnail" src="https://pic3.zhimg.com/v2-0bde558225e03b0e72fb9f2afd003e79.png"/><span class="content"><span class="title"><span class="z-ico-extern-gray"></span><span class="z-ico-extern-blue"></span></span><span class="url"><span class="z-ico-video"></span>https://www.zhihu.com/video/1141506723897516032</span></span></a><h2>演讲视频字幕</h2><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-ac46f458e2c1832ed857ba18b45ae588_b.jpg"/></figure><p>非常感谢主持人的介绍。此工作是我与来自贝尔实验室的Vladimir Kalashnikov所共同完成的。我们工作针对的目标是安全计算，这是密码学上一个非常典型、非常普遍的问题。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-b701869f1e4be9abe86a3d64fd0e1c19_b.jpg"/></figure><p>当前有很多重要的研究进展，尝试让安全计算从理论走向实际。这些工作的目标不仅是要提高协议的渐进效率，还要提高协议的真实执行效率。还有一些工作的方向是具体协议的实现，解决系统层面的问题。</p><p>在过去的5年，无论是理论角度还是实际角度，此领域都诞生了极多的突破性成果。从理论角度，我们得到了很多惊人的结论。我们现在只需要引入常数级额外开销，即可完成安全计算或安全函数求值。另一个突破是全同态加密。对于多种类型的函数，我们甚至可以在最优通信复杂度下构建安全计算协议。还可以使用基于ORAM的安全计算协议，利用RAM计算模型的优势完成安全计算，这样我们就能在次线性时间复杂度下完成安全计算。在实践角度，针对姚氏协议和GMW协议，学者们提出了很多算法或实现层面的优化，也尝试混合使用姚氏协议和GMW协议。特别地，姚氏协议的实现结果令人印象深刻。现在，我们可以在637毫秒内执行完AES的乱码电路。</p><p>虽然在实现层面和理论层面我们都得到了令人惊讶的成果，但在右侧，效率最高的协议仍然是20世纪80年代提出的姚氏协议和GMW协议。之所以这样，有一个很直观的原因：理论成果虽然引入常数复杂度，但这个常数可能非常大。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-aaba2051d03b5c17abddbd089ed1c0e3_b.jpg"/></figure><p>实际应用时，可能存在这样一个复杂度与效率的层级关系。FHE的复杂度目前、以后也总会比公钥密码学原语的复杂度高几个量级。公钥密码学原语的复杂度目前、以后也总会比对称密码学原语的复杂度高几个量级。对称密码学原语的复杂度目前、以后也总会比一次一密的复杂度高几个量级。本次演讲的主题是OT扩展，其出发点就是减小公钥操作和对称密码操作的效率鸿沟。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-c7c91720909074749b3da86e23008e35_b.jpg"/></figure><p>在第一部分演讲中，我会详细介绍OT扩展的研究出发点，并解释OT扩展面临的问题。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-d9ddd558ff856fbf20a5d9534d6f28d8_b.jpg"/></figure><p>诸如密钥协商、不经意传输等公钥密码学原语一般都很难高效实现。公钥密码学原语天生要依赖于某类代数结构，因此也会遭受很多密码学攻击。因此，相应的参数需要设置得比较大。这导致公钥密码学的计算复杂度也相对较高。另一方面，我们更容易实现伪随机数生成器或哈希函数等对称密码学运算。学者们设计出了很多算法，相应的参数要比公钥密码学小得多，实际中也可以更容易、更轻量级地实现对称密码学运算。这个结论背后还有相应的理论支撑。理论上，无法通过黑盒方式应用对称密码学原语构造大多数公钥密码学原语。这意味着公钥密码学原语和对称密码学原语的性能差约为3至4个数量级。对于诸如AES等被广泛使用的特定对称密码学操作，Intel专门提供了对应的指令集，进一步提高了这类运算的执行效率。因此，我们无法通过对称密码学原语实现公钥密码学原语。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-4a83f4754162f4bca131cf68d0e6b266_b.jpg"/></figure><p>那接下来该怎么办？或许可以用少量公钥原语实例和大量对称密码学操作，生成大量公钥实例。这一技术称为“扩展原语”。我们已经知道，很容易扩展公钥加密体制，具体过程是用对称加密算法加密具体的明文，用公钥加密算法加密对称加密的密钥。这样一来，我们只需要执行一次公钥操作。这一技术在我们每天使用的加密过程中起到了非常重要的作用。我们可以很自然地把这个问题展开：是否可以扩展其它公钥密码学原语。如OT？</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-443fbf61a245fb69f225548534fb78e3_b.jpg"/></figure><p>回忆一下不经意传输要解决的问题。发送方有两个输入： <img src="https://www.zhihu.com/equation?tex=x_0" alt="x_0" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=x_1" alt="x_1" eeimg="1"/> 。接收方有一个输入 <img src="https://www.zhihu.com/equation?tex=r" alt="r" eeimg="1"/> 。协议执行完毕后，发送方无法得到任何信息，接收方可以得到与其选择比特关联的发送方输入。OT是SFE的基础构建模块。姚氏电路中应用不经意传输实现了乱码密钥的2选1过程。在GMW协议中，OT的用途更加广泛，每个AND门的求值过程都要使用一次OT协议。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-b0f1696d77c5fcbc6990cbd2ef313ae6_b.jpg"/></figure><p>我们知道OT的执行开销非常大，我们无法通过对称密码学操作实现OT。但假设我们有一个可以传输短字符串的OT，通过使用标准的伪随机数生成器，我们能得到可以传输长字符串的OT。这一技术称为“OT长度扩展”。</p><p>还有一个更难解决的问题，称为“OT实例扩展”，简称“OT扩展”。幸运的是，我们知道OT扩展是可行的。我们只需要 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 个公钥密码学操作，即 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 个种子OT，再加上 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"/> 次对称密码学操作。应用这 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 次公钥密码学操作，我们就可以执行任意多项式大小次的OT操作。这一技术大幅降低了公钥密码学运算次数，对SFE的实际应用起到了重要的作用。近期大多数SFE的实现都应用了OT扩展协议，从而提高协议的执行效率。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-98f9589955fc0221f916a215ec929ae7_b.jpg"/></figure><p>Beaver在1996年提出了第一个OT扩展协议。第一个高效的OT扩展协议由Ishai、Kilian、Nissim和Petrank给出。此协议也称为IKNP协议，对应的论文发表在CRYPTO 2003上。后续，学者们期望在恶意攻击场景下提高OT扩展协议的执行效率。学者们同时也在加深对OT扩展协议的理解，从而知道OT扩展协议的上限是什么。在本工作中，我们将在半可信场景下提高IKNP协议的效率。我们给出了协议的渐进优化方法和实际优化方法。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-588e91747ca6879dfe863fd01eb1e3c0_b.jpg"/></figure><p>在接下来的讲座中，我们会描述Ishai等人的OT扩展协议构造。实际上，我们将直接使用Ishai等人CRYPTO 2003的演讲幻灯片。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-e2a528a41a1f9c9b9861f58fecccd18a_b.jpg"/></figure><p>IKNP第一个、也是最重要的步骤是将 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"/> 个OT归约为传输 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"/> 比特字符串的 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 个OT。这一步骤将引入额外的、线性数量级的对称密码学操作。下一步是长度扩展步骤，我们之前已经讲解过这一步骤了。这可以让我们把长字符串OT协议归约为短字符串OT协议。这一步骤进一步引入了线性数量级的对称密码学操作。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-fa10673ddb4a930f46bf48c498273398_b.jpg"/></figure><p>在核心归约步骤中，我们让接收方选择一个随机的 <img src="https://www.zhihu.com/equation?tex=n%5Ctimes+k" alt="n\times k" eeimg="1"/> 矩阵 <img src="https://www.zhihu.com/equation?tex=T" alt="T" eeimg="1"/> 。随后，发送方选择一个随机的行向量 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"/> 。接下来，接收方和发送方执行 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 个OT协议，但此OT协议中两个参与方的角色互换。在每个OT协议中，接收方要选择长度为 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"/> 的两列比特值。每对比特值中。第一列为矩阵 <img src="https://www.zhihu.com/equation?tex=T" alt="T" eeimg="1"/> 中的某一列，第二列为第一列比特值与选择向量 <img src="https://www.zhihu.com/equation?tex=r" alt="r" eeimg="1"/> 的异或结果。发送方实际上应用它随机选择的行向量在接收方的两列比特值中选择一列。</p><p>这样，发送方通过OT协议得到了一个矩阵 <img src="https://www.zhihu.com/equation?tex=Q" alt="Q" eeimg="1"/> 。我们来看看矩阵 Q 满足何种性质。如果 <img src="https://www.zhihu.com/equation?tex=r_i%3D0" alt="r_i=0" eeimg="1"/> ，则 <img src="https://www.zhihu.com/equation?tex=q_i%3Dt_i" alt="q_i=t_i" eeimg="1"/> 。如果 <img src="https://www.zhihu.com/equation?tex=r_i%3D1" alt="r_i=1" eeimg="1"/> ，收到的每对比特值就不太一样了。如果 <img src="https://www.zhihu.com/equation?tex=r_i%3D1" alt="r_i=1" eeimg="1"/> ，在IKNP协议中 <img src="https://www.zhihu.com/equation?tex=q_i%3Dt_i%5Coplus+s" alt="q_i=t_i\oplus s" eeimg="1"/> 。</p><p>注意到，在第一种情况下，接收方知道 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> ，但无法知道 <img src="https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+" alt="t_i \oplus s " eeimg="1"/> 。因此，在第一种情况下，接收方能得到 <img src="https://www.zhihu.com/equation?tex=q_i" alt="q_i" eeimg="1"/> ，但无法得到 <img src="https://www.zhihu.com/equation?tex=q_i+%5Coplus+s" alt="q_i \oplus s" eeimg="1"/> 。在第二种情况下， 接收方能得到 <img src="https://www.zhihu.com/equation?tex=q_i+%5Coplus+s+" alt="q_i \oplus s " eeimg="1"/> ，也就是 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> ，但无法得到 <img src="https://www.zhihu.com/equation?tex=q_i" alt="q_i" eeimg="1"/> 。这意味着我们或许可以使用 <img src="https://www.zhihu.com/equation?tex=q_i" alt="q_i" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=q_i+%5Coplus+s" alt="q_i \oplus s" eeimg="1"/> 作为OT协议中的数据加密密钥。但需要注意的是，我们必须要破坏矩阵中 <img src="https://www.zhihu.com/equation?tex=q_i" alt="q_i" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=q_i+%5Coplus+s" alt="q_i \oplus s" eeimg="1"/> 的相互关系。我们应用随机预言机 <img src="https://www.zhihu.com/equation?tex=H" alt="H" eeimg="1"/> 来破坏 <img src="https://www.zhihu.com/equation?tex=q_i" alt="q_i" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=q_i+%5Coplus+s" alt="q_i \oplus s" eeimg="1"/> 的相互关系。最后，接收方根据 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> 选择得到它的输出，也就是应用 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> 进行解密。</p><p>IKNP协议非常简单、非常优雅、效率极高。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-9498664f4008ce7f4fcb0792dbf86a61_b.jpg"/></figure><p>我们考虑 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"/> 个OT协议所需要的通信开销。其中发送方输入的长度为 <img src="https://www.zhihu.com/equation?tex=L" alt="L" eeimg="1"/> 。大家已经了解到，核心归约步骤就是对 <img src="https://www.zhihu.com/equation?tex=x_%7Bi%2C0%7D" alt="x_{i,0}" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=x_%7Bi%2C1%7D" alt="x_{i,1}" eeimg="1"/> 加密，这需要发送 <img src="https://www.zhihu.com/equation?tex=2nL" alt="2nL" eeimg="1"/> 比特的数据。在长度扩展步骤中，我们要应用一个PRG，这需要发送 <img src="https://www.zhihu.com/equation?tex=2nk" alt="2nk" eeimg="1"/> 比特的数据。</p><p>在姚氏电路中，我们需要传输长度为 <img src="https://www.zhihu.com/equation?tex=L%3Dk" alt="L=k" eeimg="1"/> 的密钥，因此核心归约步骤和长度扩展步骤中的通信开销相同。在GMW中，我们只需要传输 <img src="https://www.zhihu.com/equation?tex=L%3D1" alt="L=1" eeimg="1"/> 的信息。令人惊讶的是，这一场景下长度扩展步骤的通信开销远高于核心归约步骤的通信开销。这就是一个问题了，我们可能可以在这一场景下对通信开销进行优化。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-e2f429e6154f73cad1a9c4e1d4f2d523_b.jpg"/></figure><p>在讲座的后半部分，我们会提出IKNP的通用框架。我们也会向大家展示如何提高IKNP的效率。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-1f6595633ef704c723f317b48c4e3747_b.jpg"/></figure><p>我们先来详细分析一下IKNP协议。可以看到，接收方要选择这个 <img src="https://www.zhihu.com/equation?tex=n%5Ctimes+k" alt="n\times k" eeimg="1"/> 的随机矩阵。随后，接收方要生成另一个矩阵，这个矩阵的第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 列为第一个矩阵的第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 列异或选择向量 <img src="https://www.zhihu.com/equation?tex=r" alt="r" eeimg="1"/> 。换句话说， <img src="https://www.zhihu.com/equation?tex=U%3D+T+%5Coplus+R" alt="U= T \oplus R" eeimg="1"/> ，其中 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 是所有列均相等的矩阵，每个列都为接收方的选择向量。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-aa8d71429faf2c41a82f621647eddc53_b.jpg"/></figure><p>如果我们从行的视角看，就会发现 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 的第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 行为 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 个 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> ，这意味着 <img src="https://www.zhihu.com/equation?tex=R" alt="R" eeimg="1"/> 的每一行都是 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 的一种编码。在IKNP协议中， <img src="https://www.zhihu.com/equation?tex=0" alt="0" eeimg="1"/> 被映射为 <img src="https://www.zhihu.com/equation?tex=0%5Ek" alt="0^k" eeimg="1"/> ，而 <img src="https://www.zhihu.com/equation?tex=1" alt="1" eeimg="1"/> 被映射为 <img src="https://www.zhihu.com/equation?tex=1%5Ek" alt="1^k" eeimg="1"/> 。因此，我们可以看到IKNP这一高效协议在底层执行了一次逐行重复编码。这自然引出了一个问题：我们是否可以使用更复杂的编码？毕竟，重复编码是一种最简单的编码。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-916d36c0a373a0b369cdd0d54a6ff685_b.jpg"/></figure><p>假设我们使用编码 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> ，并且我们假定 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 属于一个很大的域，域为从 <img src="https://www.zhihu.com/equation?tex=1" alt="1" eeimg="1"/> 到 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"/> 。我们用编码 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 将 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 映射成 <img src="https://www.zhihu.com/equation?tex=C%28r_i%29+" alt="C(r_i) " eeimg="1"/> ，这是一个 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 比特长字符串。现在，接收方需要用选择比特 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 构建矩阵 <img src="https://www.zhihu.com/equation?tex=C%28R%29" alt="C(R)" eeimg="1"/> 。我们来看看，在这个理论框架下IKNP协议的执行过程。</p><p>第一步，接收方获得了矩阵 <img src="https://www.zhihu.com/equation?tex=C%28R%29" alt="C(R)" eeimg="1"/> 。随后，接收方用加法秘密分享方案将 <img src="https://www.zhihu.com/equation?tex=C%28R%29" alt="C(R)" eeimg="1"/> 分享为 <img src="https://www.zhihu.com/equation?tex=T" alt="T" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=U" alt="U" eeimg="1"/> ，即 <img src="https://www.zhihu.com/equation?tex=C%28R%29%3D+T+%5Coplus+U" alt="C(R)= T \oplus U" eeimg="1"/> 。接下来，接收方和发送方角色互换，执行 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"/> 个OT协议。在第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 个OT中，接收方的输入是 <img src="https://www.zhihu.com/equation?tex=t%5Ei" alt="t^i" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=u%5Ei" alt="u^i" eeimg="1"/> ，即 <img src="https://www.zhihu.com/equation?tex=T" alt="T" eeimg="1"/> 和 <img src="https://www.zhihu.com/equation?tex=U" alt="U" eeimg="1"/> 的第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"/> 列。执行完OT协议后，发送方得到矩阵 <img src="https://www.zhihu.com/equation?tex=Q" alt="Q" eeimg="1"/> 。在IKNP协议中，我们知道 <img src="https://www.zhihu.com/equation?tex=q_i" alt="q_i" eeimg="1"/> 或者等于 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> ，或者等于 <img src="https://www.zhihu.com/equation?tex=t_i+%5Coplus+s+" alt="t_i \oplus s " eeimg="1"/> 。在这一理论框架中，我们可以知道 <img src="https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+%28C%28r_i%29+%5Codot+s%29" alt="q_i=t_i \oplus (C(r_i) \odot s)" eeimg="1"/> ，结果不算太复杂。</p><p>我们可以验证一下，当C是重复编码时 此框架对应的协议就是IKNP协议。特别地，当 <img src="https://www.zhihu.com/equation?tex=r_i%3D0" alt="r_i=0" eeimg="1"/> 时， <img src="https://www.zhihu.com/equation?tex=C%28r_i%29" alt="C(r_i)" eeimg="1"/> 是一个全 <img src="https://www.zhihu.com/equation?tex=0" alt="0" eeimg="1"/> 向量，因此我们得到 <img src="https://www.zhihu.com/equation?tex=q_i%3Dt_i" alt="q_i=t_i" eeimg="1"/> 。当 <img src="https://www.zhihu.com/equation?tex=r_i%3D1" alt="r_i=1" eeimg="1"/> 时， <img src="https://www.zhihu.com/equation?tex=C%28r_i%29" alt="C(r_i)" eeimg="1"/> 是一个全 <img src="https://www.zhihu.com/equation?tex=1" alt="1" eeimg="1"/> 向量，此时我们可以得到 <img src="https://www.zhihu.com/equation?tex=q_i%3Dt_i+%5Coplus+s" alt="q_i=t_i \oplus s" eeimg="1"/> 。这样一来，我们得到了 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"/> 个密钥。后面的执行过程就完全一样了，密钥生成算法为 <img src="https://www.zhihu.com/equation?tex=q_i+%5Coplus+%28C%28r%29+%5Codot+s%29" alt="q_i \oplus (C(r) \odot s)" eeimg="1"/> 。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-b0db0b89abe426d368f9d34971797e1b_b.jpg"/></figure><p>我们仍然可以证明接收方只能知道 <img src="https://www.zhihu.com/equation?tex=t_i" alt="t_i" eeimg="1"/> 。因此接收方只能解密对应的密文，从而得到对应的输入。核心归约步骤在恶意发送方的攻击下是完美安全的。特别地，恶意发送方只能得到矩阵 <img src="https://www.zhihu.com/equation?tex=Q" alt="Q" eeimg="1"/> ，这是编码的随机独立分享结果。核心归约步骤在半诚实接收方的攻击下是统计安全的。这是因为除了在加密过程中使用了随机预言机之外，核心归约步骤没有安全性损失。因此，整个协议的安全性损失为 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"/> ，即 <img src="https://www.zhihu.com/equation?tex=r_i" alt="r_i" eeimg="1"/> 的取值范围，以及 <img src="https://www.zhihu.com/equation?tex=2%5E%7B-d%7D" alt="2^{-d}" eeimg="1"/> ，其中 <img src="https://www.zhihu.com/equation?tex=d" alt="d" eeimg="1"/> 是线性编码 <img src="https://www.zhihu.com/equation?tex=C" alt="C" eeimg="1"/> 的最小距离。</p><p>注意到在此理论框架下，我们可以从 <img src="https://www.zhihu.com/equation?tex=1" alt="1" eeimg="1"/> 到 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"/> 选取消息，因此从效果上看，我们可以实现 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"/> 选1-OT，而不是2选1-OT。但在这种情况下，核心归约步骤的通信开销会从 <img src="https://www.zhihu.com/equation?tex=2nL" alt="2nL" eeimg="1"/> 提高到 <img src="https://www.zhihu.com/equation?tex=nmL" alt="nmL" eeimg="1"/> 。随后，我们将标准的2选1-OT转换为 <img src="https://www.zhihu.com/equation?tex=n%2F%5Clog%28m%29" alt="n/\log(m)" eeimg="1"/> 个字符串长度稍长的 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"/> 选1-OT实例，这也允许我们将通信开销表示为与 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"/> 相关的函数。</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-aff423a98d4267515da28e12684a33d2_b.jpg"/></figure><p>现在，我们有了一个自由变量 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"/> ，用它来平衡核心归约步骤和长度扩展步骤的开销。具体来说，如果我们使用的是最小距离为 <img src="https://www.zhihu.com/equation?tex=k%2F2" alt="k/2" eeimg="1"/> 的Hadamard编码，在这种情况下，2选1-OT的通信开销可以降低2倍。在多方GMW协议中，如果 <img src="https://www.zhihu.com/equation?tex=k%3D256" alt="k=256" eeimg="1"/> ，则通信开销也可以降低2倍。</p><p>也可以进一步优化长度扩展步骤的通信开销，此开销的优化程度是算法层面的，而不是渐进层面的。结合Hadamard编码后，与未优化的IKNP协议相比，新协议的通信开销要降低3.5倍。Asharov等人也独立发现了这一优化点，他们的论文将发表在CCS 2013上。</p><p>与IKNP相比，我们从渐进层面降低了每一个OT的通信开销。当 <img src="https://www.zhihu.com/equation?tex=L%3D1" alt="L=1" eeimg="1"/> 时，IKNP需要通信 <img src="https://www.zhihu.com/equation?tex=O%28k%29" alt="O(k)" eeimg="1"/> 比特，而我们需要通信 <img src="https://www.zhihu.com/equation?tex=O%28k%2F%5Clog%28k%29%29" alt="O(k/\log(k))" eeimg="1"/> 比特。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg" data-caption="" data-size="normal" data-rawwidth="2560" data-rawheight="1440" class="origin_image zh-lightbox-thumb lazy" width="2560" data-original="https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-578c7c0a005588c62c1dedbadf4eca8c_b.jpg"/></figure><p>总结一下，为了平衡公钥密码学原语和对称密码学原语的性能鸿沟，学者们提出了OT扩展协议，这一协议在安全函数求值的实例落地中产生了巨大的影响。在本次讲座中，我们提出了IKNP的编码理论框架。可以在随机预言模型下证明此框架的安全性。随机预言模型也可以换为特定类型哈希函数假设，即相关性健壮哈希函数，这沿用了IKNP中安全性所依赖的相关性健壮哈希函数假设。当使用复杂编码时，此框架提高了多方GMW中2选1-OT和 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"/> 选1-OT的性能。</p><p>我想用GMW和姚氏电路的性能对比问题作为讲座的结尾。近期的安全多方计算研究主要关注恶意模型下姚氏电路的性能优化问题。在半可信安全模型下，学者们也提出了很多姚氏电路的优化方法。但近期的一些工作也表明，GMW协议也有很多算法层面的优化点。我们的工作适用于GMW协议。谢谢大家。</p>