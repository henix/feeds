<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>代数嘉年华</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/81101524">原文</a></p>
<p>不知道你有过这样的经历吗？紧张时我连一位数以内的加减乘除都要用草稿纸演算一下。这并不奇怪，做演算其实是在运行一套抽象重写系统，而数和算术跟重写联系非常紧密。算术始终围绕着数，或者做运算，或者研究其各类性质。但好像从小到大没人教过数到底是什么，我们却熟练地用数记录数量，用数排定次序，这一切自然而然。真正遇到尴尬的地方不多，直到某一天我们发现数学家在为哥德巴赫猜想的“1+1”犯难或者惊讶为啥ghci能接受“let 1 + 1 = 3”。这其实误解了数和算术，就跟说数学是一门严格的语言，数学语言十分不严格一样混淆了意义与表示，把两个不同层面的东西放在一起说了。<br/>说回到数，我们可以用一套简单的重写系统很方便地定义出来，首先有生成元符号s表示1，约定加法的重写规则是并排放，代表数量2的就是ss。但到了数量3出问题了，有两种，即(ss)s和s(ss)，回想一下小学算术，伴随着运算符号的还有运算律，于是把加法交换律也当作一条重写规则，数量3就是sss，这样就避免了同时要记住两种表示的麻烦。接着是数量4，不妙一下子有了五种写法，((ss)s)s，(s(ss))s，(ss)(ss)，s(s(ss))，s((ss)s)，交换律不能完全解决问题，不过还有结合律，想一想为什么需要结合律。接下来是数量5，这回有十四种，增长速度比2的幂还快，我们好像比孔乙己处境还糟糕。熟悉Catalan Number的同学会发现，写法总数跟表示N个叶节点组成的不同构二叉树数目的一样，好像这种表示方法很不方便，但其实加法交换律和加法结合律只说了一件事情就是括号可以省略，可以验证数量5在这种情况下只有一种写法。老子早就发现这点，“道生一，一生二，二生三，三生万物”（引经论典有时候也是各种意义和表示的误用）。还可以接着定义乘法，比如2*5的重写规则就是把ss中的每个s换成sssss，这里的替换必须同时进行，否则会有歧义，不同时进行的话可以把用来替换的s全部大写成S，全部换完再小写所有S，另外很自然的替换完成可以忽略掉所有括号，这是因为加法和乘法这两种幺半群兼容一起构成了半环。同样可以定义乘方运算，只不过需要多次替换。<br/>这套系统看起来是不是很熟悉，不就是小时候我们掰着手指算10以内的加法吗？人脑对这套系统蛮适应的，下次你家小朋友算完3+4却算不出4+3时别心累，因为可能是你没跟她说清楚规则，运算律是人为加进去的。刚刚只是定义了正整数，虽然我们小学晚一点才学负整数，0可是从一年级就被灌输了。0作为自然数其实很不“自然”，看来看去总像是硬塞进去的，古希腊和古代中国都没有代表0的符号，要定义0，我们加入一个新的符号z，并且添加两条重写规则，除非单独出现，出现在s序列中任意处的任意多个z都可以忽略，z出现在乘数位置结果总为z。<br/>这套系统非常强大，实际上对应着幺半群的自由构造，从生成元集合出发，列出所有的可能组合方式，合并结合律要求相等的组合方式，就能得到自由半群，如果再添加单位元素，合并左右单位律要求相等的组合方式，就得到了自由幺半群，如果约定额外规则合并更多组合方式，就能得到各种各样的幺半群。但是如果瞧见过小朋友掰手指算6+8，你可能不会说这套系统好，因为抽象表示系统还有其他考量，比如如何解释或者效率问题。重写是一种变换或者函数关系，我们还可以定义更广义的关系，比如全序，这样我们就可以用序数来解释顺序。说到效率，先要搞清楚谁在做。同样是数，如果是人脑，用数字和十进制就比用0/1和二进制更合适。表示形式并不仅限于一维的线性序列，可以是二维的树或图，可以是三维立体或者更高维的，比如哈夫曼编码就用从根到叶节点的路径表示符号的二进制编码。语言也是一种表示系统，比如英文就是从26个字母和若干标点符号出发，从词句到段落篇章，符合语法规则的长短句其实是一个树型结构，段落和文章结构就更丰富了，可能是网状，只不过最终这些都被压缩成线性的，我猜可能是因为效率，毕竟一个句子一棵树，按页发稿费出版社都得输，另外文学性的文字还承担着审美的功能，多一层别扭能激发读者想象，小说都整成思维导图就没法读了。另外一种常见的表示系统就是lambda演算，重写对应着alpha变换和beta归约，运行程序就是希望归约到一个比较简单的形式，虽然某些时候希望会落空。</p><div class="highlight"><pre><code class="language-haskell"><span class="cm">{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class="cm">{-# LANGUAGE ScopedTypeVariables  #-}</span>
<span class="cm">{-# LANGUAGE TypeApplications     #-}</span>
<span class="cm">{-# LANGUAGE DeriveFunctor        #-}</span>
<span class="cm">{-# LANGUAGE TypeOperators        #-}</span>
<span class="cm">{-# LANGUAGE RankNTypes           #-}</span>
<span class="cm">{-# LANGUAGE PolyKinds            #-}</span>
<span class="cm">{-# LANGUAGE GADTs                #-}</span>

<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">id</span><span class="p">,</span> <span class="p">(</span><span class="o">.</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">intersperse</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Arrow</span> <span class="p">((</span><span class="o">&amp;&amp;&amp;</span><span class="p">),</span> <span class="p">(</span><span class="o">***</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Control.Applicative</span>
<span class="kr">import</span> <span class="nn">Control.Category</span>
<span class="kr">import</span> <span class="nn">Data.Profunctor</span>
<span class="kr">import</span> <span class="nn">Control.Lens</span>
<span class="kr">import</span> <span class="nn">Data.Void</span></code></pre></div><p>东拉西扯了这么多，其实今天要聊的是Haskell的代数数据类型和Brent Yorgey的combinatorial species库。我们重走一遍学生路，在Haskell类型层面上玩转小学的算术和数论，中学的代数，大学的微分。类似于前文的表示系统，我们先定义生成元1，这里对应着类型Unit()，加法则对应着类型构造器Either，注意这里的加号是类型层面上的重载，需要打开TypeOperators扩展，接着很容易写出2对应的类型，另外我们用Void表示0，Void没有对应的值，没法模式匹配。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="kt">One</span>  <span class="ow">=</span> <span class="nb">()</span>

<span class="kr">type</span> <span class="nf">a</span> <span class="o">+</span> <span class="nf">b</span> <span class="ow">=</span> <span class="kt">Either</span> <span class="nf">a</span> <span class="nf">b</span>
<span class="kr">infixl</span> <span class="mi">6</span> <span class="o">+</span>
  
<span class="kr">type</span> <span class="kt">Two</span>  <span class="ow">=</span> <span class="nb">()</span> <span class="o">+</span> <span class="nb">()</span>

<span class="kr">type</span> <span class="kt">Zero</span> <span class="ow">=</span> <span class="kt">Void</span></code></pre></div><p>不严格的话，如果把基本代数数据类型看作一个有限集合，值看作里面的元素，这里用的其实是集合的基数，即集合中包含的元素的个数，我们定义Countable类型类来编码代数数据类型的这个信息，另外只考虑可数集的话，可数即可列，我们还可以列出某个类型所有的可能取值，接着定义Listable类型类，前面说到自由幺半群，单个元素集合作为生成元构造出的自由幺半群同构于自然数，这样我们甚至可以为每个类型对应集合里的元素指定统一的编码方式。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">Cardinal</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Cardinal</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">newtype</span> <span class="kt">Encode</span> <span class="nf">a</span>   <span class="ow">=</span> <span class="kt">Encode</span> <span class="p">[[</span><span class="nb">()</span><span class="p">]]</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="kr">class</span> <span class="kt">Countable</span> <span class="nf">a</span> <span class="kr">where</span>
  <span class="nf">count</span> <span class="ow">::</span> <span class="kt">Cardinal</span> <span class="nf">a</span>
  
<span class="kr">instance</span> <span class="kt">Countable</span> <span class="kt">Void</span> <span class="kr">where</span> <span class="nf">count</span> <span class="ow">=</span> <span class="kt">Cardinal</span> <span class="mi">0</span>
<span class="kr">instance</span> <span class="kt">Countable</span> <span class="nb">()</span>   <span class="kr">where</span> <span class="nf">count</span> <span class="ow">=</span> <span class="kt">Cardinal</span> <span class="mi">1</span>
<span class="kr">instance</span> <span class="kt">Countable</span> <span class="kt">Bool</span> <span class="kr">where</span> <span class="nf">count</span> <span class="ow">=</span> <span class="kt">Cardinal</span> <span class="mi">2</span>
                                                                    
<span class="kr">class</span> <span class="kt">Listable</span> <span class="nf">a</span> <span class="kr">where</span>
  <span class="nf">list</span> <span class="ow">::</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span>
  <span class="nf">code</span> <span class="ow">::</span> <span class="kt">Encode</span> <span class="nf">a</span>
  <span class="nf">code</span> <span class="ow">=</span> <span class="kt">Encode</span> <span class="o">$</span> <span class="p">(</span><span class="nf">flip</span> <span class="nf">replicate</span> <span class="nb">()</span> <span class="o">.</span> <span class="nf">snd</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="nf">zip</span> <span class="p">(</span><span class="nf">list</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> 

<span class="kr">instance</span> <span class="kt">Listable</span> <span class="kt">Void</span> <span class="kr">where</span> <span class="nf">list</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="kr">instance</span> <span class="kt">Listable</span> <span class="nb">()</span>   <span class="kr">where</span> <span class="nf">list</span> <span class="ow">=</span> <span class="p">[</span><span class="nb">()</span><span class="p">]</span>
<span class="kr">instance</span> <span class="kt">Listable</span> <span class="kt">Bool</span> <span class="kr">where</span> <span class="nf">list</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span> <span class="kt">False</span><span class="p">]</span>
</code></pre></div><p>定义相应的乘法和乘方也不难，先定义两个lift函数来避免显示的模式匹配，可以看出来类型算术和自然数算术几乎完美地对应着。定义函数的Listable实例时，用到了一个技巧tabulate，我们把函数转化成了类似于map的数据结构，不偷懒的话加层wrapper可以用可表函子Representable Functor的性质，build其实就是Representable类型类的index函数，后面还会用到这一点，即函数和数据结构之间相互转化。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="nf">a</span> <span class="o">*</span> <span class="nf">b</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span> <span class="nf">b</span><span class="p">)</span>
<span class="kr">type</span> <span class="nf">a</span> <span class="o">^</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">a</span>
<span class="kr">infixl</span> <span class="mi">7</span> <span class="o">*</span>
<span class="kr">infixr</span> <span class="mi">8</span> <span class="o">^</span>

<span class="kr">instance</span> <span class="kt">Countable</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Countable</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="nf">a</span><span class="p">)</span>              <span class="kr">where</span> <span class="nf">count</span> <span class="ow">=</span> <span class="nf">liftC1</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">count</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">Countable</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Countable</span> <span class="p">(</span><span class="kt">Const</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">)</span>            <span class="kr">where</span> <span class="nf">count</span> <span class="ow">=</span> <span class="nf">liftC1</span> <span class="nf">id</span>   <span class="p">(</span><span class="nf">count</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Countable</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Countable</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Countable</span> <span class="p">(</span><span class="nf">a</span> <span class="o">*</span> <span class="nf">b</span><span class="p">)</span> <span class="kr">where</span> <span class="nf">count</span> <span class="ow">=</span> <span class="nf">liftC2</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="nf">count</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">count</span> <span class="o">@</span><span class="nf">b</span><span class="p">)</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Countable</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Countable</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Countable</span> <span class="p">(</span><span class="nf">a</span> <span class="o">+</span> <span class="nf">b</span><span class="p">)</span> <span class="kr">where</span> <span class="nf">count</span> <span class="ow">=</span> <span class="nf">liftC2</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="nf">count</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">count</span> <span class="o">@</span><span class="nf">b</span><span class="p">)</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Countable</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Countable</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Countable</span> <span class="p">(</span><span class="nf">b</span> <span class="o">^</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span> <span class="nf">count</span> <span class="ow">=</span> <span class="nf">liftC2</span> <span class="p">(</span><span class="o">^</span><span class="p">)</span> <span class="p">(</span><span class="nf">count</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">count</span> <span class="o">@</span><span class="nf">b</span><span class="p">)</span>

<span class="nf">liftC1</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Cardinal</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Cardinal</span> <span class="nf">b</span>
<span class="nf">liftC1</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">Cardinal</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cardinal</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span>

<span class="nf">liftC2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Cardinal</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">Cardinal</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="kt">Cardinal</span> <span class="nf">c</span>
<span class="nf">liftC2</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">Cardinal</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Cardinal</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cardinal</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Listable</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Listable</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="nf">a</span><span class="p">)</span>                   <span class="kr">where</span> <span class="nf">list</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="kt">:</span> <span class="nf">fmap</span> <span class="kt">Just</span> <span class="p">(</span><span class="nf">list</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">Listable</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Listable</span> <span class="p">(</span><span class="kt">Const</span> <span class="nf">a</span> <span class="nf">b</span><span class="p">)</span>                 <span class="kr">where</span> <span class="nf">list</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="kt">Const</span> <span class="p">(</span><span class="nf">list</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Listable</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Listable</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Listable</span> <span class="p">(</span><span class="nf">a</span> <span class="o">*</span> <span class="nf">b</span><span class="p">)</span>       <span class="kr">where</span> <span class="nf">list</span> <span class="ow">=</span> <span class="p">(,)</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="nf">list</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="nf">list</span> <span class="o">@</span><span class="nf">b</span><span class="p">)</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Listable</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Listable</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Listable</span> <span class="p">(</span><span class="nf">a</span> <span class="o">+</span> <span class="nf">b</span><span class="p">)</span>       <span class="kr">where</span> <span class="nf">list</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="kt">Left</span> <span class="p">(</span><span class="nf">list</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span> <span class="o">++</span> <span class="nf">fmap</span> <span class="kt">Right</span> <span class="p">(</span><span class="nf">list</span> <span class="o">@</span><span class="nf">b</span><span class="p">)</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Listable</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Listable</span> <span class="nf">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Listable</span> <span class="p">(</span><span class="nf">b</span> <span class="o">^</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span> <span class="nf">list</span> <span class="ow">=</span> <span class="nf">build</span> <span class="o">&lt;$&gt;</span> <span class="nf">traverse</span> <span class="p">(</span><span class="nf">\k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="nf">k</span><span class="p">,</span><span class="nf">v</span><span class="p">)</span> <span class="o">|</span> <span class="nf">v</span> <span class="ow">&lt;-</span> <span class="nf">list</span> <span class="o">@</span><span class="nf">b</span><span class="p">])</span> <span class="p">(</span><span class="nf">list</span> <span class="o">@</span><span class="nf">a</span><span class="p">)</span>

<span class="nf">build</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="nf">k</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="nf">k</span><span class="p">,</span><span class="nf">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="nf">k</span> <span class="ow">-&gt;</span> <span class="nf">v</span>
<span class="nf">build</span> <span class="kt">[]</span> <span class="nf">k</span>         <span class="ow">=</span> <span class="nf">undefined</span> 
<span class="nf">build</span> <span class="p">((</span><span class="nf">k</span><span class="p">,</span><span class="nf">v</span><span class="p">)</span><span class="kt">:</span><span class="nf">kv</span><span class="p">)</span> <span class="nf">k&#39;</span><span class="ow">=</span> <span class="kr">if</span> <span class="nf">k</span> <span class="o">==</span> <span class="nf">k&#39;</span> <span class="kr">then</span> <span class="nf">v</span> <span class="kr">else</span> <span class="nf">build</span> <span class="nf">kv</span> <span class="nf">k&#39;</span>        </code></pre></div><p>如果你仔细看，前面已经出现了两个2，Bool和()+()，这是因为Haskell的类型虽然是半环Semiring，但要考虑效率或者解释的习惯，不是按照自由幺半群的方式构造的，另外其实我们还没有定义相等，说不定这两个2本来就是相等的。依照之前不严格地把类型看作有限可数集和，我们需要定义一个集合的相等，可数学里面的相等太多了，identity, equality，extensional equality, intensional equality, isomorphsim, equivalent，又一次我们看到数学语言的“不严格”。首先，集合{1，2，3}和{1，2，3}肯定相等，因为完全相同嘛。接着集合{1，2，3}和{2，1，3}也应该相等，因为集合无序，不过要验证这种相等不容易，我们还得先定义一种全序关系排完序再挨个比较相等。集合{1，2，3}和{a，b，c}或者{1，1，2，3}和{1，2，3}呢，1和a根本没法比较，数目不相同的集合看起来不应该相等。好像集合的相等很难定义，范畴论有一种等价关系-同构Isomorphism非常适合这种场景，简单来说同构就是一种满足自反传递对称的可逆态射，自反和传递由范畴的单位律和结合律保证，额外只需要对称性，对于证明集合同构，我们只需要证明双射Bijection的存在，一对可逆的total函数。当然HoTT可能有更优雅一致的解决方法，这里的同构是pointwise的，接下来谈到species还有自然同构Natural Isomorphism，简单的范畴论就不够用了，species库的作者其实有一套完整的Hott构造<sup data-text="Yorgey, Brent. (2014). Combinatorial Species and Labelled Structures." data-url="" data-draft-node="inline" data-draft-type="reference" data-numero="1">[1]</sup>，感兴趣的可以读他的论文。最后如果集合的定义是{n | 0 &lt; n &lt; 4, n是整数}，怎么办？简单，不想思考，直接拒绝，你至少先把这货弄进Haskell再说，否则哪一天集合定义里列了黎曼猜想还得先证明猜想。这其实也是Haskell强类型的好处，严进宽出，先把problem domain的问题按照语言本身或者库提供的smart constructor来“编码”，GHC接受以后就可以自由地做整体变换，最后选择一种solution domain输出想要的结果。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">infix</span> <span class="mi">1</span> <span class="o">&lt;-&gt;</span>
<span class="kr">data</span> <span class="nf">a</span> <span class="o">&lt;-&gt;</span> <span class="nf">b</span> <span class="ow">=</span> <span class="kt">PIso</span> <span class="p">{</span> <span class="nf">from</span> <span class="ow">::</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">b</span><span class="p">,</span> <span class="nf">to</span> <span class="ow">::</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="p">}</span> <span class="c1">-- from . to = id = to . from </span>

<span class="nf">reflexive</span> <span class="ow">::</span> <span class="kt">Category</span> <span class="nf">r</span> <span class="ow">=&gt;</span> <span class="nf">r</span> <span class="nf">a</span> <span class="nf">a</span>
<span class="nf">reflexive</span> <span class="ow">=</span> <span class="nf">id</span>

<span class="nf">transitive</span> <span class="ow">::</span> <span class="kt">Category</span> <span class="nf">r</span> <span class="ow">=&gt;</span> <span class="nf">r</span> <span class="nf">b</span> <span class="nf">c</span> <span class="ow">-&gt;</span> <span class="nf">r</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">r</span> <span class="nf">a</span> <span class="nf">c</span>
<span class="nf">transitive</span> <span class="ow">=</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span>

<span class="kr">class</span> <span class="kt">Category</span> <span class="nf">r</span> <span class="ow">=&gt;</span> <span class="kt">Equivalent</span> <span class="nf">r</span> <span class="kr">where</span>
  <span class="nf">symmetric</span> <span class="ow">::</span> <span class="nf">r</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">r</span> <span class="nf">b</span> <span class="nf">a</span>

<span class="kr">instance</span> <span class="kt">Category</span> <span class="p">(</span><span class="o">&lt;-&gt;</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">id</span> <span class="ow">=</span> <span class="kt">PIso</span> <span class="nf">id</span> <span class="nf">id</span>
  <span class="p">(</span><span class="kt">PIso</span> <span class="nf">bc</span> <span class="nf">cb</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="kt">PIso</span> <span class="nf">ab</span> <span class="nf">ba</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">PIso</span> <span class="p">(</span><span class="nf">bc</span> <span class="o">.</span> <span class="nf">ab</span><span class="p">)</span> <span class="p">(</span><span class="nf">ba</span> <span class="o">.</span> <span class="nf">cb</span><span class="p">)</span> 

<span class="kr">instance</span> <span class="kt">Equivalent</span> <span class="p">(</span><span class="o">&lt;-&gt;</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">symmetric</span> <span class="p">(</span><span class="kt">PIso</span> <span class="nf">ab</span> <span class="nf">ba</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">PIso</span> <span class="nf">ba</span> <span class="nf">ab</span></code></pre></div><p>有了同构，我们就从小学毕业了，不必再谈可数可列，因为我们要做代数，要和参数，变量或者多项式打交道了。我们可以证明分配律，或者利用合并同类项证明多项式同构，这里我偷了懒，各种各样的模式匹配，其实可以用运算律和同构的性质来做整体变换证明。在Haskell里证明一元类型多项式同构可以由编译器自动完成<sup data-text="" data-url="http://www.philipzucker.com/lens-as-a-divisibility-relation-goofin-off-with-the-algebra-of-types/" data-draft-node="inline" data-draft-type="reference" data-numero="2">[2]</sup>，思路大概是先用分配律把product of sum转化成sum of product，然后合并同类项，最后按照幂次bubble sort，当然这一切都需要类型层面的函数type family。</p><div class="highlight"><pre><code class="language-haskell"><span class="c1">-- data Color = Red | Green | Blue</span>
<span class="c1">-- Two + One &lt;-&gt; Color</span>

<span class="nf">distributive1</span> <span class="ow">::</span> <span class="p">(</span><span class="nf">a</span> <span class="o">+</span> <span class="nf">b</span><span class="p">)</span> <span class="o">*</span> <span class="nf">c</span> <span class="o">&lt;-&gt;</span> <span class="nf">a</span> <span class="o">*</span> <span class="nf">c</span> <span class="o">+</span> <span class="nf">b</span> <span class="o">*</span> <span class="nf">c</span>
<span class="nf">distributive1</span> <span class="ow">=</span> <span class="kt">PIso</span> <span class="nf">l2r</span> <span class="nf">r2l</span> <span class="kr">where</span>
  <span class="nf">l2r</span> <span class="p">(</span><span class="kt">Left</span>  <span class="nf">a</span><span class="p">,</span> <span class="nf">c</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">Left</span>  <span class="p">(</span><span class="nf">a</span><span class="p">,</span><span class="nf">c</span><span class="p">)</span>
  <span class="nf">l2r</span> <span class="p">(</span><span class="kt">Right</span> <span class="nf">b</span><span class="p">,</span> <span class="nf">c</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="nf">b</span><span class="p">,</span><span class="nf">c</span><span class="p">)</span>  
  <span class="nf">r2l</span> <span class="p">(</span><span class="kt">Left</span>  <span class="p">(</span><span class="nf">a</span><span class="p">,</span><span class="nf">c</span><span class="p">))</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Left</span> <span class="nf">a</span> <span class="p">,</span> <span class="nf">c</span><span class="p">)</span>
  <span class="nf">r2l</span> <span class="p">(</span><span class="kt">Right</span> <span class="p">(</span><span class="nf">b</span><span class="p">,</span><span class="nf">c</span><span class="p">))</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Right</span> <span class="nf">b</span><span class="p">,</span> <span class="nf">c</span><span class="p">)</span>

<span class="nf">distributive2</span> <span class="ow">::</span> <span class="p">(</span><span class="nf">b</span> <span class="o">*</span> <span class="nf">c</span><span class="p">)</span> <span class="o">^</span> <span class="nf">a</span> <span class="o">&lt;-&gt;</span> <span class="nf">b</span> <span class="o">^</span> <span class="nf">a</span> <span class="o">*</span> <span class="nf">c</span> <span class="o">^</span> <span class="nf">a</span>
<span class="nf">distributive2</span> <span class="ow">=</span> <span class="kt">PIso</span> <span class="nf">l2r</span> <span class="nf">r2l</span> <span class="kr">where</span>
  <span class="nf">l2r</span> <span class="nf">f</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">fst</span> <span class="o">.</span> <span class="nf">f</span><span class="p">,</span> <span class="nf">snd</span> <span class="o">.</span> <span class="nf">f</span><span class="p">)</span>
  <span class="nf">r2l</span> <span class="p">(</span><span class="nf">f</span><span class="p">,</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">f</span> <span class="o">&amp;&amp;&amp;</span> <span class="nf">g</span>
    
<span class="nf">distributive3</span> <span class="ow">::</span> <span class="nf">a</span> <span class="o">^</span> <span class="p">(</span><span class="nf">b</span> <span class="o">+</span> <span class="nf">c</span><span class="p">)</span> <span class="o">&lt;-&gt;</span> <span class="nf">a</span> <span class="o">^</span> <span class="nf">b</span> <span class="o">*</span> <span class="nf">a</span> <span class="o">^</span> <span class="nf">c</span>
<span class="nf">distributive3</span> <span class="ow">=</span> <span class="kt">PIso</span> <span class="nf">l2r</span> <span class="nf">r2l</span> <span class="kr">where</span>
  <span class="nf">l2r</span> <span class="nf">f</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">f</span> <span class="o">.</span> <span class="kt">Left</span><span class="p">,</span> <span class="nf">f</span> <span class="o">.</span> <span class="kt">Right</span><span class="p">)</span>
  <span class="nf">r2l</span> <span class="p">(</span><span class="nf">f</span><span class="p">,</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">\a</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="nf">a</span> <span class="kr">of</span>
    <span class="kt">Left</span> <span class="nf">b</span>  <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">b</span>
    <span class="kt">Right</span> <span class="nf">c</span> <span class="ow">-&gt;</span> <span class="nf">g</span> <span class="nf">c</span></code></pre></div><p>除了定义运算，我们还可以定义二元或者多元关系，比如大小比较的全序，整除，有整数对数等等。虽然知道这种Lens的存在性residue同构表示，但我没往代数数据类型方面想过，也没有意识到用Prism表示大小关系，用Lens表示整除关系<sup data-text="" data-url="https://blog.jle.im/entry/lenses-products-prisms-sums.html" data-draft-node="inline" data-draft-type="reference" data-numero="3">[3]</sup>。其实回头想非常自然，发明Lens不就是为了解决代数数据类型的view/update问题。Residue Lens，Van Laarhoven Lense和Profunctor Lens之间可以互相转化，有些转化非常简单明了，比如rl2vl就是在做destruction和construction，rl2pl是对Strong Profunctor的first&#39;做预处理和后处理，不过这五六种表示<sup data-text="" data-url="https://www.twanvl.nl/files/lenses-talk-2011-05-17.pdf" data-draft-node="inline" data-draft-type="reference" data-numero="4">[4]</sup>我还是最喜欢profunctor，尤其是配图“食用”，不过Residue Lens也有优势，可以统一Lens关于getter/setter的公理get-set，set-get，set-set，态射的可逆三条统统搞定。如果Residue的整体类型可微分OneHole Context，f a和(a, Derivative f a)也是同构的，就能得到Context Lens。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">RLens</span> <span class="nf">a</span> <span class="nf">b</span> <span class="kr">where</span>
  <span class="kt">RLens</span> <span class="ow">::</span> <span class="p">(</span><span class="nf">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nf">b</span><span class="p">,</span> <span class="nf">r</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="p">((</span><span class="nf">b</span><span class="p">,</span> <span class="nf">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">RLens</span> <span class="nf">a</span> <span class="nf">b</span>

<span class="nf">vl2rl</span> <span class="ow">::</span> <span class="kt">Lens</span> <span class="nf">a</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="kt">RLens</span> <span class="nf">a</span> <span class="nf">b</span>
<span class="nf">vl2rl</span> <span class="nf">vl</span> <span class="ow">=</span> <span class="kt">RLens</span> <span class="p">(</span><span class="nf">getConst</span> <span class="o">.</span> <span class="p">(</span><span class="nf">vl</span> <span class="kt">Const</span><span class="p">)</span> <span class="o">&amp;&amp;&amp;</span> <span class="nf">id</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="nf">b</span><span class="p">,</span><span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">runIdentity</span> <span class="p">(</span><span class="nf">vl</span> <span class="p">(</span><span class="nf">const</span> <span class="p">(</span><span class="kt">Identity</span> <span class="nf">b</span><span class="p">))</span> <span class="nf">a</span><span class="p">))</span>

<span class="nf">rl2vl</span> <span class="ow">::</span> <span class="kt">RLens</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="kt">Lens</span> <span class="nf">a</span> <span class="nf">a</span> <span class="nf">b</span> <span class="nf">b</span>
<span class="nf">rl2vl</span> <span class="p">(</span><span class="kt">RLens</span> <span class="nf">dtor</span> <span class="nf">ctor</span><span class="p">)</span> <span class="nf">f</span> <span class="nf">s</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="nf">a</span><span class="p">,</span> <span class="nf">r</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">dtor</span> <span class="nf">s</span> <span class="kr">in</span> <span class="nf">flip</span> <span class="p">(</span><span class="nf">curry</span> <span class="nf">ctor</span><span class="p">)</span> <span class="nf">r</span> <span class="o">&lt;$&gt;</span> <span class="nf">f</span> <span class="nf">a</span>

<span class="kr">type</span> <span class="kt">PLens</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">=</span> <span class="nf">forall</span> <span class="nf">p</span><span class="o">.</span> <span class="kt">Strong</span> <span class="nf">p</span> <span class="ow">=&gt;</span> <span class="nf">p</span> <span class="nf">b</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">p</span> <span class="nf">a</span> <span class="nf">a</span>

<span class="nf">rl2pl</span> <span class="ow">::</span> <span class="kt">RLens</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="kt">PLens</span> <span class="nf">a</span> <span class="nf">b</span>
<span class="nf">rl2pl</span> <span class="p">(</span><span class="kt">RLens</span> <span class="nf">pre</span> <span class="nf">post</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">dimap</span> <span class="nf">pre</span> <span class="nf">post</span> <span class="o">.</span> <span class="nf">first&#39;</span>

<span class="nf">pl2rl</span> <span class="ow">::</span> <span class="kt">PLens</span> <span class="nf">a</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="kt">RLens</span> <span class="nf">a</span> <span class="nf">b</span>
<span class="nf">pl2rl</span> <span class="nf">p</span> <span class="ow">=</span> <span class="kt">RLens</span> <span class="p">((</span><span class="nf">getConst</span> <span class="o">.</span> <span class="p">(</span><span class="nf">runStar</span> <span class="o">.</span> <span class="nf">p</span> <span class="o">.</span> <span class="kt">Star</span><span class="p">)</span> <span class="kt">Const</span><span class="p">)</span> <span class="o">&amp;&amp;&amp;</span> <span class="nf">id</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="nf">b</span><span class="p">,</span><span class="nf">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="nf">p</span> <span class="p">(</span><span class="nf">const</span> <span class="nf">b</span><span class="p">)</span> <span class="nf">a</span><span class="p">)</span>
    
<span class="c1">-- Leaf a | Fork a a | LTrunk (a,a) a | RTrunk a (a,a)</span>
<span class="c1">-- a + a * a + (a * a) * a + a * (a * a)</span>
<span class="c1">-- oneHole 1 + 2 * a + 3 * a * a + 3 * a * a </span></code></pre></div><p>同运算符一样，我们在类型层面重载一些符号来表示这三种关系，可以证明一些简单的性质，比如传递性或者闭包性，Prism/Lens的可组合直接得到传递性。直觉上a .| (b+c) -&gt; a .| b -&gt; a .| c应该是成立的，但我试了一下没写出来。在进入高中之前，我们还可以做一些有趣的事，比如证明费马小定理。费马小定理表述为如果p是质数，那么a^p-a是p倍数。用和之前同样的技巧，把a^p对应着函数p-&gt;a进行tabulate，减去a意味着排除所有const a的恒值函数，对于剩余的可能函数我们定义一种等价关系Z，先unzip任意tabulate过的函数[(p,a)]得到([p],[a]),如果把[a]分别旋转0，1，p-1然后再zip回去，问题就转化为证明每个这样的等价类基数是p。把旋转变换记作群{e，g^1，g^2，...，g^(p-1)}，反证法，假设其中g^r=e，考虑到g^p=e，得到g^(gcd(r,p))=e，gcd(r,p)=1，g=e显然这是不可能的，因为之前排除了所有的恒值函数。这样我们就证明了费马小定理，不过要在Haskell里表达出来，需要先定义减法和除法类型，类似于virtual species，好像有人在做<sup data-text="" data-url="https://www.cs.indiana.edu/~sabry/papers/rational.pdf" data-draft-node="inline" data-draft-type="reference" data-numero="5">[5]</sup>。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">type</span> <span class="nf">a</span> <span class="o">&lt;=</span> <span class="nf">b</span> <span class="ow">=</span> <span class="kt">Prism</span> <span class="nf">b</span> <span class="nf">b</span> <span class="nf">a</span> <span class="nf">a</span> <span class="c1">-- substractable, b - a </span>
<span class="kr">type</span> <span class="nf">a</span> <span class="o">.|</span> <span class="nf">b</span> <span class="ow">=</span> <span class="kt">Lens</span>  <span class="nf">b</span> <span class="nf">b</span> <span class="nf">a</span> <span class="nf">a</span> <span class="c1">-- dividable, b / a</span>
<span class="kr">type</span> <span class="nf">a</span> <span class="o">./</span> <span class="nf">b</span> <span class="ow">=</span> <span class="p">(</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="nf">a</span> <span class="o">&lt;=&gt;</span> <span class="nf">b</span>  <span class="c1">-- representable, log a b</span>
<span class="kr">infix</span> <span class="mi">1</span> <span class="o">&lt;=</span><span class="p">,</span> <span class="o">.|</span><span class="p">,</span> <span class="o">./</span>

<span class="nf">closure1</span> <span class="ow">::</span> <span class="nf">a</span> <span class="o">.|</span> <span class="nf">b</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="o">.|</span> <span class="nf">c</span> <span class="ow">-&gt;</span> <span class="nf">a</span> <span class="o">.|</span> <span class="p">(</span><span class="nf">b</span> <span class="o">+</span> <span class="nf">c</span><span class="p">)</span>
<span class="nf">closure1</span> <span class="nf">lab</span> <span class="nf">lac</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">Left</span>  <span class="nf">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span>  <span class="o">&lt;$&gt;</span> <span class="nf">lab</span> <span class="nf">f</span> <span class="nf">b</span>
<span class="nf">closure1</span> <span class="nf">lab</span> <span class="nf">lac</span> <span class="nf">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="nf">c</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="o">&lt;$&gt;</span> <span class="nf">lac</span> <span class="nf">f</span> <span class="nf">c</span>  

<span class="c1">--closure2 :: a .| (b+c) -&gt; a .| b -&gt; a .| c  </span>
  
<span class="c1">-- L x = 1 + x * L x</span>
<span class="c1">-- L x = 1 / (1 - x) = 1 + x + x * x + x * x * x + ...</span>
<span class="c1">-- L&#39; x = L x + x * L&#39; x</span>
<span class="c1">-- L&#39; x = L x / (1 - x) = L x * L x </span></code></pre></div><p>到了高中我们接触的是多项式函数和高次方程，虽然运算还是加法乘法，也会考虑一些特殊的数，比如多项式因数分解求零点和导数求鞍点，但大多数时候不直接跟数打交道了。对应Haskell就是不再关注具体类型，而是类型层面的函数-类型构造器，或者更具体一点，函子。我们常说数据结构是数据加结构，结构和数据可以完全分开，数据就是具体类型对应的值，前面说到简单的代数数据类型同构于自然数，我们甚至能给所有值统一编码，类比一下，如果把数据和结构分开，结构好像对应着定义域是自然数的函数，类似的如果说两个结构相等，是不是就是意味着这两个函数相等呢？我们又碰到了老问题，如何定义相等，但这回很轻松，因为函子在范畴论里有个拿来即用的相等定义，自然同构Natural Isomorphism，事实上自然同构比范畴论的同构出现更早，自然同构同样满足自反传递对称这三条性质，另外还比一般的同构多一个可交换图，之前是类型-集合-基数，现在是类型构造器-函子-函数，看起来问题解决了，除了没说函子定义在哪个范畴上。正常的有限集合范畴似乎不行，因为不是所有态射都可逆，这里的函子定义在态射是bijective的有限集合范畴B上，一般把这个函子B=&gt;Set称作species。接下来可以研究这个函子范畴有哪些性质，惊喜的是这个范畴竟然有六种幺半结构，意味着我们能定义六种张量积，分别是Tagged Union，Cartesian Product，Cauchy Product，Rectangle Product，Functor Composition以及Partition Composition。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">infix</span> <span class="mi">1</span> <span class="o">&lt;=&gt;</span>
<span class="kr">data</span> <span class="nf">f</span> <span class="o">&lt;=&gt;</span> <span class="nf">g</span> <span class="ow">=</span> <span class="kt">NIso</span> <span class="p">{</span> <span class="nf">fw</span> <span class="ow">::</span> <span class="nf">forall</span> <span class="nf">a</span> <span class="o">.</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">g</span> <span class="nf">a</span><span class="p">,</span> <span class="nf">bw</span> <span class="ow">::</span> <span class="nf">forall</span> <span class="nf">a</span> <span class="o">.</span> <span class="nf">g</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="nf">f</span> <span class="nf">a</span> <span class="p">}</span> <span class="c1">-- fw . bw = id = bw . fw, commutative diagram </span>

<span class="kr">instance</span> <span class="kt">Category</span> <span class="p">(</span><span class="o">&lt;=&gt;</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">id</span> <span class="ow">=</span> <span class="kt">NIso</span> <span class="nf">id</span> <span class="nf">id</span>
  <span class="p">(</span><span class="kt">NIso</span> <span class="nf">bc</span> <span class="nf">cb</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="kt">NIso</span> <span class="nf">ab</span> <span class="nf">ba</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">NIso</span> <span class="p">(</span><span class="nf">bc</span> <span class="o">.</span> <span class="nf">ab</span><span class="p">)</span> <span class="p">(</span><span class="nf">ba</span> <span class="o">.</span> <span class="nf">cb</span><span class="p">)</span> 

<span class="kr">instance</span> <span class="kt">Equivalent</span> <span class="p">(</span><span class="o">&lt;=&gt;</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">symmetric</span> <span class="p">(</span><span class="kt">NIso</span> <span class="nf">ab</span> <span class="nf">ba</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">NIso</span> <span class="nf">ba</span> <span class="nf">ab</span></code></pre></div><p>先分别定义这六种张量积和对应的单位对象，这里我们手动写一下show函数，因为打印结果非常容易占满半个屏幕。另外我们还能定义微分，即One-hole Context，而且微分与Tagged Union，Partition Product，Partition Composition是兼容的，可以验证加法，乘法的微分法则和链式微分法则<sup data-text="" data-url="https://repository.upenn.edu/cgi/viewcontent.cgi?article=1774&amp;context=cis_papers" data-draft-node="inline" data-draft-type="reference" data-numero="6">[6]</sup>。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">data</span> <span class="kt">O</span> <span class="nf">a</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span> <span class="c1">-- g = 0</span>

<span class="kr">data</span> <span class="kt">TaggedUnion</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Inl</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Inr</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Functor</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">E</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">E</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Functor</span><span class="p">)</span> <span class="c1">-- g = e^x</span>

<span class="kr">data</span> <span class="kt">CartesianProd</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">CartesianProd</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">),</span> <span class="kt">Show</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">CartesianProd</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">CartesianProd</span> <span class="nf">fa</span> <span class="nf">ga</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;(&#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">fa</span> <span class="o">++</span> <span class="s">&#34;,&#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">ga</span> <span class="o">++</span> <span class="s">&#34;)&#34;</span>
  
<span class="kr">data</span> <span class="kt">I</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">I</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Functor</span><span class="p">)</span> <span class="c1">-- g = 1</span>

<span class="kr">data</span> <span class="kt">CauchyProd</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">CauchyProd</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">),</span> <span class="kt">Show</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">CauchyProd</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">CauchyProd</span> <span class="nf">fa</span> <span class="nf">ga</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;(&#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">fa</span> <span class="o">++</span> <span class="s">&#34;,&#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">ga</span> <span class="o">++</span> <span class="s">&#34;)&#34;</span>

<span class="kr">newtype</span> <span class="kt">X</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">X</span> <span class="nf">a</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span> <span class="c1">-- g = x</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">X</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">X</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">show</span> <span class="nf">a</span>

<span class="kr">data</span> <span class="kt">RectangleProd</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">RectangleProd</span> <span class="p">(</span><span class="nf">f</span> <span class="p">[</span><span class="nf">a</span><span class="p">])</span> <span class="p">(</span><span class="nf">g</span> <span class="p">[</span><span class="nf">a</span><span class="p">])</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="p">(</span><span class="nf">f</span> <span class="p">[</span><span class="nf">a</span><span class="p">]),</span> <span class="kt">Show</span> <span class="p">(</span><span class="nf">g</span> <span class="p">[</span><span class="nf">a</span><span class="p">]))</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">RectangleProd</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">RectangleProd</span> <span class="nf">fa</span> <span class="nf">ga</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;(&#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">fa</span> <span class="o">++</span> <span class="s">&#34;,&#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">ga</span> <span class="o">++</span> <span class="s">&#34;)&#34;</span>

<span class="kr">data</span> <span class="kt">FunctorComp</span>   <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">FunctorComp</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">))</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">FunctorComp</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">FunctorComp</span> <span class="nf">fga</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">show</span> <span class="nf">fga</span>

<span class="kr">data</span> <span class="kt">PartitionComp</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">PartitionComp</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">))</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nf">a</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">PartitionComp</span> <span class="nf">f</span> <span class="nf">g</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">PartitionComp</span> <span class="nf">fga</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">show</span> <span class="nf">fga</span>

<span class="kr">data</span> <span class="kt">OneHole</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Hole</span> <span class="o">|</span> <span class="kt">Remains</span> <span class="nf">a</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">OneHole</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="kt">Hole</span>        <span class="ow">=</span> <span class="s">&#34;*&#34;</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">Remains</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">show</span> <span class="nf">a</span>

<span class="kr">data</span> <span class="kt">Derivative</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Derivative</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="kt">OneHole</span> <span class="nf">a</span><span class="p">))</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Pointed</span> <span class="nf">f</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Pointed</span> <span class="nf">a</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="nf">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="p">(</span><span class="nf">f</span> <span class="nf">a</span><span class="p">))</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Pointed</span> <span class="nf">f</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">Pointed</span> <span class="nf">a</span> <span class="nf">fa</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;(&#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">a</span> <span class="o">++</span> <span class="s">&#34;,&#34;</span> <span class="o">++</span> <span class="nf">show</span> <span class="nf">fa</span> <span class="o">++</span> <span class="s">&#34;)&#34;</span></code></pre></div><p>与之前类似，Species有两种表示方法，一种是定义域是自然数的一元函数，另外一种是[a]-&gt;[f a]。一元函数对应着母函数里面的指数生成函数，这也是Species名字的由来。这里我只写了第二种，一般把[a]叫做label集合，这样可以打印出来每种species对应的所有labelled structure的形状。Tagged Union和Cartesian Product跟一般的函子范畴类似，在这两种Species中f和g都是作用在整个label集合上，单位元素O对应着多项式0，E对应着e^x=1+x/1+x^2/(2!)+...这里没用I，一方面因为在Species范畴Cauchy Product比Cartesian Product更像一般意义的乘法，前者可以稍加变换推导出后者，另外E对应着集合的Species，不regular，因为集合多了额外的对称性，我们允许集合元素无序。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">class</span> <span class="kt">Enumerable</span> <span class="nf">f</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="ow">::</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">f</span> <span class="nf">a</span><span class="p">]</span>

<span class="kr">instance</span> <span class="kt">Enumerable</span> <span class="kt">O</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nf">undefined</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Enumerable</span> <span class="nf">f</span><span class="p">,</span> <span class="kt">Enumerable</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Enumerable</span> <span class="p">(</span><span class="kt">TaggedUnion</span> <span class="nf">f</span> <span class="nf">g</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="ow">=</span> <span class="nf">uncurry</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="nf">fmap</span> <span class="kt">Inl</span> <span class="o">.</span> <span class="nf">enumerate</span> <span class="o">&amp;&amp;&amp;</span> <span class="nf">fmap</span> <span class="kt">Inr</span> <span class="o">.</span> <span class="nf">enumerate</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Enumerable</span> <span class="kt">E</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="kr">_</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">E</span><span class="p">]</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Enumerable</span> <span class="nf">f</span><span class="p">,</span> <span class="kt">Enumerable</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Enumerable</span> <span class="p">(</span><span class="kt">CartesianProd</span> <span class="nf">f</span> <span class="nf">g</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="ow">=</span> <span class="nf">uncurry</span> <span class="p">(</span><span class="nf">liftA2</span> <span class="kt">CartesianProd</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="nf">enumerate</span> <span class="o">&amp;&amp;&amp;</span> <span class="nf">enumerate</span><span class="p">)</span></code></pre></div><p>不同于之前的两种积，Cauchy Product先把整个label集合划分成不相交的两部分，可以为空，f和g各自作用一部分再组合起来，单位元素是I，只对空集有作用。Retangle Product是这里面最难写的一种，顾名思义就是先把整个label集合排成矩形，所有行构成一种划分作为行label，所有列也构成一种划分列label，每一行或者每一列里面的元素是无序的，f和g分别作用于行label与列label上，单位元素是X，只对单元素集合有作用。比如说非空列表就可以表示为CauchyProd X L，先选出一个label作为表头，其余label再去构成列表。Rectangle Product可以描述一些常见几何形状，比如Rect Species就是Retangle E E，意味着我们可以任意交换行或列，如果label集合基数p是质数，那么Rect只有两种1xp或者px1。最后这两种积对应着Day Convolution，在指数生成函数表示中，计算过程看起来很像卷积。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">instance</span> <span class="kt">Enumerable</span> <span class="kt">I</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">I</span><span class="p">]</span>
  <span class="nf">enumerate</span> <span class="kr">_</span>  <span class="ow">=</span> <span class="kt">[]</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Enumerable</span> <span class="nf">f</span><span class="p">,</span> <span class="kt">Enumerable</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Enumerable</span> <span class="p">(</span><span class="kt">CauchyProd</span> <span class="nf">f</span> <span class="nf">g</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="ow">=</span> <span class="nf">flip</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="p">(</span><span class="nf">uncurry</span> <span class="p">(</span><span class="nf">liftA2</span> <span class="kt">CauchyProd</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="nf">enumerate</span> <span class="o">***</span> <span class="nf">enumerate</span><span class="p">))</span> <span class="o">.</span> <span class="nf">disjoint2</span>

<span class="nf">disjoint2</span> <span class="ow">::</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[([</span><span class="nf">a</span><span class="p">],</span> <span class="p">[</span><span class="nf">a</span><span class="p">])]</span>
<span class="nf">disjoint2</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="p">[(</span><span class="kt">[]</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)]</span>
<span class="nf">disjoint2</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">((</span><span class="nf">x</span><span class="kt">:</span><span class="p">)</span> <span class="o">***</span> <span class="nf">id</span><span class="p">)</span> <span class="p">(</span><span class="nf">disjoint2</span> <span class="nf">xs</span><span class="p">)</span> <span class="o">++</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">id</span> <span class="o">***</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="p">))</span> <span class="p">(</span><span class="nf">disjoint2</span> <span class="nf">xs</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Enumerable</span> <span class="kt">X</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">X</span> <span class="nf">a</span><span class="p">]</span>
  <span class="nf">enumerate</span> <span class="kr">_</span>   <span class="ow">=</span> <span class="kt">[]</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Enumerable</span> <span class="nf">f</span><span class="p">,</span> <span class="kt">Enumerable</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Enumerable</span> <span class="p">(</span><span class="kt">RectangleProd</span> <span class="nf">f</span> <span class="nf">g</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="ow">=</span> <span class="nf">flip</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="p">(</span><span class="nf">uncurry</span> <span class="p">(</span><span class="nf">liftA2</span> <span class="kt">RectangleProd</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="nf">enumerate</span> <span class="o">***</span> <span class="nf">enumerate</span><span class="p">))</span> <span class="o">.</span> <span class="nf">rectangle</span>  

<span class="nf">rectangle</span> <span class="ow">::</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[([[</span><span class="nf">a</span><span class="p">]],</span> <span class="p">[[</span><span class="nf">a</span><span class="p">]])]</span>
<span class="nf">rectangle</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">rectangle</span> <span class="nf">xs</span> <span class="ow">=</span> <span class="nf">filter</span> <span class="nf">equalLen</span> <span class="p">(</span><span class="nf">partition</span> <span class="nf">xs</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\xss</span> <span class="ow">-&gt;</span> <span class="nf">zip</span> <span class="p">(</span><span class="nf">repeat</span> <span class="nf">xss</span><span class="p">)</span> <span class="p">(</span><span class="nf">column</span> <span class="nf">xss</span><span class="p">))</span>
  <span class="kr">where</span>
    <span class="nf">column</span> <span class="p">[</span><span class="nf">xs</span><span class="p">]</span>     <span class="ow">=</span> <span class="p">[</span><span class="nf">fmap</span> <span class="p">(</span><span class="nf">\x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="nf">x</span><span class="p">])</span> <span class="nf">xs</span><span class="p">]</span>
    <span class="nf">column</span> <span class="p">(</span><span class="nf">xs</span><span class="kt">:</span><span class="nf">xss</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">zipWith</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="nf">permutate</span> <span class="nf">xs</span> <span class="o">&lt;*&gt;</span> <span class="nf">column</span> <span class="nf">xss</span>
    <span class="nf">permutate</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="p">[</span><span class="kt">[]</span><span class="p">]</span>
    <span class="nf">permutate</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">permutate</span> <span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="nf">insert</span> <span class="nf">x</span>
    <span class="nf">insert</span> <span class="nf">x</span> <span class="nf">xs</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">\n</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="nf">ls</span><span class="p">,</span><span class="nf">rs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">splitAt</span> <span class="nf">n</span> <span class="nf">xs</span> <span class="kr">in</span> <span class="nf">ls</span> <span class="o">++</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">rs</span><span class="p">))</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="nf">length</span> <span class="nf">xs</span><span class="p">)]</span>      
    <span class="nf">equalLen</span> <span class="nf">xss</span> <span class="ow">=</span> <span class="nf">all</span> <span class="p">((</span><span class="o">==</span> <span class="nf">length</span> <span class="p">(</span><span class="nf">head</span> <span class="nf">xss</span><span class="p">))</span> <span class="o">.</span> <span class="nf">length</span><span class="p">)</span> <span class="p">(</span><span class="nf">tail</span> <span class="nf">xss</span><span class="p">)</span></code></pre></div><p>最后两种对应着复合，Functor Composition对应着正常的函子复合，相比之下Partition Composition更为重要，思路是先把整个label集合做任意非空划分，然后g作用于每个子集，把结果收集起来形成一个新的label集合，最后用f作用于这个集合，单位元素同样是X。比如排列可以表示成PartitionComp E Cycle，对应着置换群的循环记法。最后我们还可以定义微分，就是把结构里具体一个位置挖空，比如Cycle的微分同构于Linear Order。</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">instance</span> <span class="p">(</span><span class="kt">Enumerable</span> <span class="nf">f</span><span class="p">,</span> <span class="kt">Enumerable</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Enumerable</span> <span class="p">(</span><span class="kt">FunctorComp</span> <span class="nf">f</span> <span class="nf">g</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="kt">FunctorComp</span> <span class="o">.</span> <span class="nf">enumerate</span> <span class="o">.</span> <span class="nf">enumerate</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Enumerable</span> <span class="nf">f</span><span class="p">,</span> <span class="kt">Enumerable</span> <span class="nf">g</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Enumerable</span> <span class="p">(</span><span class="kt">PartitionComp</span> <span class="nf">f</span> <span class="nf">g</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="kt">PartitionComp</span> <span class="o">.</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="nf">enumerate</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="nf">traverse</span> <span class="nf">enumerate</span><span class="p">)</span> <span class="o">.</span> <span class="nf">partition</span>

<span class="nf">partition</span> <span class="ow">::</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[[</span><span class="nf">a</span><span class="p">]]]</span>
<span class="nf">partition</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="p">[</span><span class="kt">[]</span><span class="p">]</span>
<span class="nf">partition</span> <span class="p">[</span><span class="nf">x</span><span class="p">]</span>    <span class="ow">=</span> <span class="p">[[[</span><span class="nf">x</span><span class="p">]]]</span>
<span class="nf">partition</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">([</span><span class="nf">x</span><span class="p">]</span><span class="kt">:</span><span class="p">)</span> <span class="p">(</span><span class="nf">partition</span> <span class="nf">xs</span><span class="p">)</span> <span class="o">++</span> <span class="p">(</span><span class="nf">partition</span> <span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="nf">insert</span> <span class="nf">x</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="nf">insert</span> <span class="nf">x</span> <span class="nf">xxs</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">\n</span> <span class="ow">-&gt;</span> <span class="nf">over</span> <span class="p">(</span><span class="nf">element</span> <span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="p">)</span> <span class="nf">xxs</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="nf">length</span> <span class="nf">xxs</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

<span class="kr">instance</span> <span class="kt">Enumerable</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Enumerable</span> <span class="p">(</span><span class="kt">Derivative</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="kt">Derivative</span> <span class="o">.</span> <span class="nf">enumerate</span> <span class="o">.</span> <span class="p">(</span><span class="kt">Hole:</span><span class="p">)</span> <span class="o">.</span> <span class="nf">fmap</span> <span class="kt">Remains</span> 

<span class="kr">instance</span> <span class="kt">Enumerable</span> <span class="nf">f</span> <span class="ow">=&gt;</span> <span class="kt">Enumerable</span> <span class="p">(</span><span class="kt">Pointed</span> <span class="nf">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">CartesianProd</span> <span class="p">(</span><span class="kt">CauchyProd</span> <span class="p">(</span><span class="kt">X</span> <span class="nf">a</span><span class="p">)</span> <span class="kt">E</span><span class="p">)</span> <span class="nf">fa</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Pointed</span> <span class="nf">a</span> <span class="nf">fa</span><span class="p">)</span> <span class="o">.</span> <span class="nf">enumerate</span>  

<span class="nf">pretty</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Either</span> <span class="kt">Char</span> <span class="nf">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">pretty</span> <span class="p">(</span><span class="kt">Left</span>  <span class="nf">c</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span><span class="nf">c</span><span class="p">]</span>
<span class="nf">pretty</span> <span class="p">(</span><span class="kt">Right</span> <span class="nf">a</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">show</span> <span class="nf">a</span>
</code></pre></div><p>除此之外我们还需要定义其他一些primitive species，比如cycle，因为定义里就规定了对称性，所以即使是labelled cycle也有了对称性，对称性意味着额外的等价关系，光靠之前的primitive species和运算符是没法运算得到的。好了，万事俱备我们可以愉快地在Species上做代数了，研究不同结构之间的关系，即结构间的结构。相同或者同构的结构可以有很多种不同的表示，因为额外的等价关系相同的表示也可以对应的不同的结构，所以说设计一个良好的数据结构不容易，光是表示和意义上就可能有偏差，更别提运行效率等其他问题了。最后看一个例子-列表，列表其实可以表示至少四种结构，Linear Order，Cycle，Bracelet和Bag，几乎完全相同的表示，在species这个框架下通过newtype wrapper可以把更多结构的信息编码在类型上了。species在日常编程中直接应用不多，暂时好像集中在随机数生成和穷举测试方面。species库是一门DSL语言，可以用来解决任何排列组合相关或者某些动态规划的问题。建议对species或者HoTT感兴趣的同学阅读一下Brent Yorgey的论文，我只是囫囵吞枣地看了一小部分。另外也可以看一下如何在集合范畴之外的范畴研究问题的思路，我最大的体会是抽象是分层的，在不同抽象层面上表示可以复用，我们从算术到代数，从数到函数，从集合范畴到函子范畴，从同构到自然同构，从普通的Cartesian幺半范畴到基于Day Convolution的幺半范畴再到基于Composition的幺半范畴，不也正是对应着自由构造里面的自由幺半群，自由合用函子和自由单子吗？</p><div class="highlight"><pre><code class="language-haskell"><span class="kr">newtype</span> <span class="kt">Lin</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Lin</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Lin</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">Lin</span> <span class="nf">as</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;&lt;&#34;</span> <span class="o">++</span> <span class="p">(</span><span class="nf">intersperse</span> <span class="p">(</span><span class="kt">Left</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">(</span><span class="nf">fmap</span> <span class="kt">Right</span> <span class="nf">as</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">pretty</span><span class="p">)</span> <span class="o">++</span> <span class="s">&#34;&gt;&#34;</span>  

<span class="kr">instance</span> <span class="kt">Enumerable</span> <span class="kt">Lin</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="p">[</span><span class="kt">Lin</span> <span class="kt">[]</span><span class="p">]</span>
  <span class="nf">enumerate</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">enumerate</span> <span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">Lin</span> <span class="nf">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Lin</span> <span class="o">&lt;$&gt;</span> <span class="nf">insert</span> <span class="nf">x</span> <span class="nf">xs</span><span class="p">)</span>
    <span class="kr">where</span>
      <span class="nf">insert</span> <span class="nf">x</span> <span class="nf">xs</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">\n</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="nf">ls</span><span class="p">,</span><span class="nf">rs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">splitAt</span> <span class="nf">n</span> <span class="nf">xs</span> <span class="kr">in</span> <span class="nf">ls</span> <span class="o">++</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">rs</span><span class="p">))</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="nf">length</span> <span class="nf">xs</span><span class="p">)]</span>

<span class="kr">newtype</span> <span class="kt">Cycle</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Cycle</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span> <span class="c1">-- equivalent over rotation</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Cycle</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">Cycle</span> <span class="nf">as</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;&lt;&#34;</span> <span class="o">++</span> <span class="p">(</span><span class="nf">intersperse</span> <span class="p">(</span><span class="kt">Left</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">(</span><span class="nf">fmap</span> <span class="kt">Right</span> <span class="nf">as</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">pretty</span><span class="p">)</span> <span class="o">++</span> <span class="s">&#34;&gt;&#34;</span>
  
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Cycle</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Cycle</span> <span class="nf">as</span> <span class="o">==</span> <span class="kt">Cycle</span> <span class="nf">bs</span> <span class="ow">=</span> <span class="nf">length</span> <span class="nf">as</span> <span class="o">==</span> <span class="nf">length</span> <span class="nf">bs</span> <span class="o">&amp;&amp;</span> <span class="nf">any</span> <span class="p">(</span><span class="o">==</span> <span class="nf">bs</span><span class="p">)</span> <span class="p">(</span><span class="nf">take</span> <span class="p">(</span><span class="nf">length</span> <span class="nf">as</span><span class="p">)</span> <span class="o">.</span> <span class="nf">flip</span> <span class="nf">drop</span> <span class="p">(</span><span class="nf">as</span> <span class="o">++</span> <span class="nf">as</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="nf">length</span> <span class="nf">as</span><span class="p">])</span>

<span class="kr">instance</span> <span class="kt">Enumerable</span> <span class="kt">Cycle</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="kt">[]</span>  <span class="ow">=</span> <span class="p">[</span><span class="kt">Cycle</span> <span class="kt">[]</span><span class="p">]</span>
  <span class="nf">enumerate</span> <span class="p">[</span><span class="nf">x</span><span class="p">]</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Cycle</span> <span class="p">[</span><span class="nf">x</span><span class="p">]]</span>
  <span class="nf">enumerate</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">enumerate</span> <span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">Cycle</span> <span class="nf">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Cycle</span> <span class="o">&lt;$&gt;</span> <span class="nf">insert</span> <span class="nf">x</span> <span class="nf">xs</span><span class="p">)</span>
    <span class="kr">where</span>
      <span class="nf">insert</span> <span class="nf">x</span> <span class="nf">xs</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">\n</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="nf">ls</span><span class="p">,</span><span class="nf">rs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">splitAt</span> <span class="nf">n</span> <span class="nf">xs</span> <span class="kr">in</span> <span class="nf">ls</span> <span class="o">++</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">rs</span><span class="p">))</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="nf">length</span> <span class="nf">xs</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

<span class="kr">newtype</span> <span class="kt">Bracelet</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Bracelet</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span> <span class="c1">-- equivalent over rotation and reflection</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Bracelet</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">Bracelet</span> <span class="nf">as</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;&lt;&lt;&#34;</span> <span class="o">++</span> <span class="p">(</span><span class="nf">intersperse</span> <span class="p">(</span><span class="kt">Left</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">(</span><span class="nf">fmap</span> <span class="kt">Right</span> <span class="nf">as</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">pretty</span><span class="p">)</span> <span class="o">++</span> <span class="s">&#34;&gt;&gt;&#34;</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Bracelet</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Bracelet</span> <span class="nf">as</span> <span class="o">==</span> <span class="kt">Bracelet</span> <span class="nf">bs</span> <span class="ow">=</span> <span class="kt">Cycle</span> <span class="nf">as</span> <span class="o">==</span> <span class="kt">Cycle</span> <span class="nf">bs</span> <span class="o">||</span> <span class="kt">Cycle</span> <span class="nf">as</span> <span class="o">==</span> <span class="kt">Cycle</span> <span class="p">(</span><span class="nf">reverse</span> <span class="nf">bs</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Enumerable</span> <span class="kt">Bracelet</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="p">[</span><span class="kt">Bracelet</span> <span class="kt">[]</span><span class="p">]</span>
  <span class="nf">enumerate</span> <span class="p">[</span><span class="nf">x</span><span class="p">]</span>    <span class="ow">=</span> <span class="p">[</span><span class="kt">Bracelet</span> <span class="p">[</span><span class="nf">x</span><span class="p">]]</span>
  <span class="nf">enumerate</span> <span class="p">[</span><span class="nf">x</span><span class="p">,</span><span class="nf">y</span><span class="p">]</span>  <span class="ow">=</span> <span class="p">[</span><span class="kt">Bracelet</span> <span class="p">[</span><span class="nf">x</span><span class="p">,</span><span class="nf">y</span><span class="p">]]</span>
  <span class="nf">enumerate</span> <span class="p">[</span><span class="nf">x</span><span class="p">,</span><span class="nf">y</span><span class="p">,</span><span class="nf">z</span><span class="p">]</span><span class="ow">=</span> <span class="p">[</span><span class="kt">Bracelet</span> <span class="p">[</span><span class="nf">x</span><span class="p">,</span><span class="nf">y</span><span class="p">,</span><span class="nf">z</span><span class="p">]]</span>    
  <span class="nf">enumerate</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">enumerate</span> <span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">Bracelet</span> <span class="nf">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bracelet</span> <span class="o">&lt;$&gt;</span> <span class="nf">insert</span> <span class="nf">x</span> <span class="nf">xs</span><span class="p">)</span>
    <span class="kr">where</span>
      <span class="nf">insert</span> <span class="nf">x</span> <span class="nf">xs</span> <span class="ow">=</span> <span class="nf">fmap</span> <span class="p">(</span><span class="nf">\n</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="nf">ls</span><span class="p">,</span><span class="nf">rs</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">splitAt</span> <span class="nf">n</span> <span class="nf">xs</span> <span class="kr">in</span> <span class="nf">ls</span> <span class="o">++</span> <span class="p">(</span><span class="nf">x</span><span class="kt">:</span><span class="nf">rs</span><span class="p">))</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="nf">length</span> <span class="nf">xs</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

<span class="kr">newtype</span> <span class="kt">Bag</span> <span class="nf">a</span> <span class="ow">=</span> <span class="kt">Bag</span> <span class="p">[</span><span class="nf">a</span><span class="p">]</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Bag</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="nf">show</span> <span class="p">(</span><span class="kt">Bag</span> <span class="nf">as</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;{&#34;</span> <span class="o">++</span> <span class="p">(</span><span class="nf">intersperse</span> <span class="p">(</span><span class="kt">Left</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">(</span><span class="nf">fmap</span> <span class="kt">Right</span> <span class="nf">as</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">pretty</span><span class="p">)</span> <span class="o">++</span> <span class="s">&#34;}&#34;</span>  

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="nf">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Bag</span> <span class="nf">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Bag</span> <span class="kt">[]</span> <span class="o">==</span> <span class="kt">Bag</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">True</span>
  <span class="kt">Bag</span> <span class="kt">[]</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
  <span class="kt">Bag</span> <span class="p">(</span><span class="nf">a</span><span class="kt">:</span><span class="nf">as</span><span class="p">)</span> <span class="o">==</span> <span class="kt">Bag</span> <span class="nf">bs</span> <span class="ow">=</span> <span class="nf">maybe</span> <span class="kt">False</span> <span class="p">((</span><span class="o">==</span> <span class="kt">Bag</span> <span class="nf">as</span><span class="p">)</span> <span class="o">.</span> <span class="kt">Bag</span><span class="p">)</span> <span class="p">(</span><span class="nf">match</span> <span class="nf">a</span> <span class="nf">bs</span><span class="p">)</span>
    <span class="kr">where</span>
      <span class="nf">match</span> <span class="nf">a</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
      <span class="nf">match</span> <span class="nf">a</span> <span class="p">(</span><span class="nf">b</span><span class="kt">:</span><span class="nf">bs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="nf">a</span> <span class="o">==</span> <span class="nf">b</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="nf">bs</span> <span class="kr">else</span> <span class="p">(</span><span class="nf">b</span><span class="kt">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="nf">match</span> <span class="nf">a</span> <span class="nf">bs</span>

<span class="kr">instance</span> <span class="kt">Enumerable</span> <span class="kt">Bag</span> <span class="kr">where</span>
  <span class="nf">enumerate</span> <span class="nf">as</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Bag</span>  <span class="nf">as</span><span class="p">]</span></code></pre></div><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
