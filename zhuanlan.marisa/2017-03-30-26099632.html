<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>使用 Cabal hook 构建复杂 Haskell 项目</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/26099632">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-b46fb0e6be6485cfbeaf007146e882f9_r.jpg" alt=""></div><p>首先说说 “复杂” Haskell 项目是怎么回事。嗯，并不是下图这种意义上的复杂：</p><img src="https://pic3.zhimg.com/v2-28f811288ed51becc76de61b3be1e5b7_r.png" data-rawwidth="735" data-rawheight="1250"><p>这里的复杂指的不是语言特性，而是 build process 的复杂性。对于 Haskell 初学者和普通用户而言，只要掌握一些基本的工具链常识（我在<a href="http://www.zhihu.com/people/4cf2f4dca8e0339f5c2a460ecb62db39" data-hash="4cf2f4dca8e0339f5c2a460ecb62db39" class="member_mention" data-editable="true" data-title="@大魔头-诺铁" data-hovercard="p$b$4cf2f4dca8e0339f5c2a460ecb62db39">@大魔头-诺铁</a> 的专栏有简单讲过：<a href="https://zhuanlan.zhihu.com/p/21798264" data-editable="true" data-title="红尘里的Haskell（之一）--Haskell工具链科普 - 知乎专栏">红尘里的Haskell（之一）--Haskell工具链科普 - 知乎专栏</a>），以及几个简单 stack/cabal 命令的用法，就可以创建和管理 Haskell 项目。</p><p>stack/cabal 之类工具的核心是 Cabal 库，它提供了描述 Haskell 的 package/module 元数据的格式，以及一些内建的 builder，在 configure/build/generate haddock/... 等流程中解析和处理这些元数据，并根据需要调用 GHC、linker、C 编译器等工具完成构建。按照 Cabal 文档的描述（<a href="https://cabal.readthedocs.io/en/latest/concepts-and-development.html" data-editable="true" data-title="3. Package Concepts and Development">3. Package Concepts and Development</a>），提供一个 .cabal 文件，以及一个简单的 Setup.hs 脚本（对于大多数 package，对应的 Cabal build type 是默认的 Simple， 这个脚本只有2行），stack/cabal 就可以自动帮你完成其他工作。</p><p>然而 Cabal 默认特性并不总是够用的。考虑以下2个例子：</p><ul><li>实现 Haskell 绑定 C/C++ 库。这个库可能在系统中装了多个版本，需要一些特殊的逻辑去寻找和设定相关的 flag，甚至有可能需要把这个库的开发版打包到 Haskell 项目中自行构建和链接。</li><li>实现 Haskell 元编程，输出一堆 Haskell module 的源文件（也许还带着 haddock 文档）并将其作为 Cabal build target</li></ul><p>对前一个例子，Cabal 本身提供了用 pkg-config 找配置，以及编译 Haskell 项目中的（不需要什么奇怪脚本预处理、不涉及 make 时吐出新代码的）C 源文件。然而不支持 C++，不支持编译动态生成新的 C/C++ 代码，也不能搞些奇怪的预处理（根据 Haskell 项目要求去 patch 原来库的代码），或者使用 ninja 之类的非主流 build 工具……</p><p>对后一个例子，Haskell 元编程的标准做法是 Template Haskell，可以在编译期执行任意计算并生成各种声明。然而 Template Haskell 暂不能生成新 module，而且其语法树中并未考虑 haddock 文档的支持。</p><p>归根结底，我们需要在 Cabal 的 setup 程序里用 Haskell 实现自定义的 build 逻辑，比如调用奇怪的工具，或者魔改自己的 package 元数据。考虑到这样的需求，Cabal 提供了 hook 接口，可以在默认的 Simple builder 上面用自己的 callback 来取得数据并做一些微小的工作。</p><p>hook 的使用方法：首先将 your-package-name.cabal（或者如果你赶时髦用 hpack 的话，package.yaml）中的 <a href="https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-type" data-editable="true" data-title="build-type">build-type</a> 一栏从 Simple 改为 Custom。另外，强烈推荐增加 <a href="https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-type" data-editable="true" data-title="custom-setup">custom-setup</a> 信息，用于描述 Setup.hs 脚本自身的 Haskell 依赖，这些依赖与项目自身的各个 build target 的依赖是完全独立的，也不会共享默认编译选项、语言扩展等 flag 。改完以后，就可以开始动手魔改 Setup.hs 脚本了。</p><p>参考 <a href="https://hackage.haskell.org/package/Cabal-1.24.2.0/docs/Distribution-Simple.html" data-editable="true" data-title="Distribution.Simple">Distribution.Simple</a> 的文档，原本我们 Setup.hs 的 main 直接使用了 defaultMain，现在可以换成 defaultMainWithHooks。UserHooks 类型包含了一堆 callback ，从 callback 的类型和名字就可以看出它们分别在什么阶段会被触发，输入/输出信息的类型是什么。现在，支持用 Haskell 代码来自定 Haskell 项目的 build 逻辑以后，前面所说的问题也就可以解决了：比如需要 build C++ 库的话，可以在 preConf 或者 confHook 上面加上“调用 make，并将 .so/.a 复制到本 package 的默认 libdir”的逻辑；要是有闲情逸致的话，甚至 make 也不必调，用 <a href="http://shakebuild.com/" data-editable="true" data-title="Shake Build System">Shake Build System</a> 把 build 逻辑自己重写一下也是完全 OK 的。至于 Haskell 代码生成，在生成代码并复制到源码目录中以后，暴力修改 LocalBuildInfo 中的 localPkgDescr ，把私货夹带进去就可以开开心心地 build 啦。<br></p><p>当然，最糙快猛的做法，无疑是用其他语言写个脚本来生成和打包所有你需要的项目文件，这样做的话 SAN 值会掉90%；或者善用 C 预处理器，在项目里到处 #include，然后像操作文本一样用宏吐出一堆 Haskell 代码，这样做 SAN 值会掉 50%。不过，最理想的做法，当然是——所有在其他系统里用到的奇技淫巧，都能用 Haskell 波澜不惊地实现出来。Best magic is no magic。</p><p>考虑到 Cabal 的 hook API 并不是一个非常 well-documented 的东西，而且行为在 stack/cabal-install 下表现还不完全一致，初学者为了避免一些陷阱，也许需要跟踪整个 Cabal build process，尤其是偷看这些 hook 在什么时机被触发、传入的参数和计算结果分别是什么。所以我写了一个简单的打日志的工具：<a href="https://github.com/TerrorJack/Cabal-playground" data-editable="true" data-title="TerrorJack/Cabal-playground">TerrorJack/Cabal-playground</a> 。这个项目包含 foreign C code/library/executable/test-suite/benchmark 各一个，以及一个用于详细观测 Cabal build process 的 Setup.hs 脚本（比原本最 verbose 的选项更 verbose），只要设定一个环境变量并启动 build ，就可以从日志读到每一个 hook 的触发时机以及调用参数/结果。这个 Setup.hs 脚本很容易通过简单修改迁移到其他的 Haskell 项目，用于 debug 其他项目的构建流程。</p><p>P.S. 为什么想到写这玩意呢？嘛，我最近写的 Haskell 代码和开头的图一比，画风完全不一样。。</p><img src="https://pic1.zhimg.com/v2-7fff128ca6e4c04ae91287427ef8d41a_r.png" data-rawwidth="1185" data-rawheight="605"><img src="https://pic4.zhimg.com/v2-b08bf7bcd963c26800132c03241fcb60_r.png" data-rawwidth="1089" data-rawheight="1398"><p>其中大多数 Haskell 代码是我用 Python 脚本吐出来的。不能用 Haskell 完成整个 workflow 的每一个环节让我掉了很多 SAN 值。所以有了这篇专栏。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
