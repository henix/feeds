<div class="title-image"><img src="https://pic2.zhimg.com/v2-81634f185a08dc132259dfdf274fd64b_b.jpg" alt=""></div><p>辣鸡知乎连目录都不能打。推荐阅读原文</p><a href="http://link.zhihu.com/?target=https%3A//hexilee.me/2018/12/17/rust-async-io/" data-draft-node="block" data-draft-type="link-card" data-image="https://pic3.zhimg.com/v2-fe574b11d1229ca57d0a0760236316b6_ipico.jpg" data-image-width="640" data-image-height="640" class=" wrap external" target="_blank" rel="nofollow noreferrer">rust asynchronous io - 李晨曦的博客 | Hexi Blog</a><h2>引言</h2><p>2018 年接近尾声，<code>rust</code> 团队勉强立住了异步 <code>IO</code> 的 flag，<code>async</code> 成为了关键字，<code>Pin</code>, <code>Future</code>, <code>Poll</code> 和 <code>await!</code> 也进入了标准库。不过一直以来实际项目中用不到这套东西，所以也没有主动去了解过。</p><p>最近心血来潮想用 <code>rust</code> 写点东西，但并找不到比较能看的文档（可能是因为 <code>rust</code> 发展太快了，很多都过时了），最后参考<a href="http://link.zhihu.com/?target=https%3A//cafbit.com/post/tokio_internals/" class=" wrap external" target="_blank" rel="nofollow noreferrer">这篇文章</a>和 <code>"new tokio"</code>( <a href="http://link.zhihu.com/?target=https%3A//github.com/withoutboats/romio" class=" wrap external" target="_blank" rel="nofollow noreferrer">romio</a> ) 写了几个 <code>demo</code>，并基于 <code>mio</code> 在 <code>coroutine</code> 中实现了简陋的异步 <code>IO</code>。</p><p>最终效果如下：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="c1">// examples/async-echo.rs</span>

<span class="cp">#![feature(async_await)]</span><span class="w"></span>
<span class="cp">#![feature(await_macro)]</span><span class="w"></span>

<span class="cp">#[macro_use]</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">log</span><span class="p">;</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">asyncio</span>::<span class="n">executor</span>::<span class="p">{</span><span class="n">block_on</span><span class="p">,</span><span class="w"> </span><span class="n">spawn</span><span class="p">,</span><span class="w"> </span><span class="n">TcpListener</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">failure</span>::<span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">env_logger</span>::<span class="n">init</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">block_on</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">listener</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpListener</span>::<span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="s">"127.0.0.1:7878"</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">())</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">"TcpListener bind fail"</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">info</span><span class="o">!</span><span class="p">(</span><span class="s">"Listening on 127.0.0.1:7878"</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Ok</span><span class="p">((</span><span class="k">mut</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">await</span><span class="o">!</span><span class="p">(</span><span class="n">listener</span><span class="p">.</span><span class="n">accept</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">info</span><span class="o">!</span><span class="p">(</span><span class="s">"connection from {}"</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">spawn</span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="n">async</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">client_hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">await</span><span class="o">!</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">read</span><span class="p">()).</span><span class="n">expect</span><span class="p">(</span><span class="s">"read from stream fail"</span><span class="p">);</span><span class="w"></span>
<span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">read_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client_hello</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">write_length</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">                            </span><span class="n">await</span><span class="o">!</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">client_hello</span><span class="p">)).</span><span class="n">expect</span><span class="p">(</span><span class="s">"write to stream fail"</span><span class="p">);</span><span class="w"></span>
<span class="w">                        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">read_length</span><span class="p">,</span><span class="w"> </span><span class="n">write_length</span><span class="p">);</span><span class="w"></span>
<span class="w">                        </span><span class="n">stream</span><span class="p">.</span><span class="n">close</span><span class="p">();</span><span class="w"></span>
<span class="w">                    </span><span class="p">},</span><span class="w"></span>
<span class="w">                </span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">"spawn stream fail"</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>写这篇文章的主要目的是梳理和总结，同时也希望能给对这方面有兴趣的 <code>Rustacean</code> 作为参考。本文代码以易于理解为主要编码原则，某些地方并没有太考虑性能，还请见谅；但如果文章和代码中有明显错误，欢迎指正。</p><p>本文代码仓库在 <a href="http://link.zhihu.com/?target=https%3A//github.com/Hexilee/async-io-demo" class=" wrap external" target="_blank" rel="nofollow noreferrer">Github</a> （部分代码较长，建议 <code>clone</code> 下来用编辑器看），所有 <code>examples</code> 在 <code>nightly-x86_64-apple-darwin 2018 Edition</code> 上均能正常运行。运行 <code>example/async-echo</code>  时设置 <code>RUST_LOG</code> 为 <code>info</code> 可以在 terminal 看到基本的运行信息，<code>debug</code> 则可见事件循环中的事件触发顺序。</p><h2>异步 <code>IO</code> 的基石 - <code>mio</code></h2><p><code>mio</code> 是一个极简的底层异步 <code>IO</code> 库，如今 <code>rust</code> 生态中几乎所有的异步 <code>IO</code> 程序都基于它。</p><p>随着 <code>channel</code>, <code>timer</code> 等 <code>sub module</code> 在 <code>0.6.5</code> 版本被标为 <code>deprecated</code>，如今的 mio 提供的唯二两个核心功能分别是：</p><ul><li>对操作系统异步网络 <code>IO</code> 的封装</li><li>用户自定义事件队列</li></ul><p>第一个核心功能对应到不同操作系统分别是</p><ul><li><code>Linux(Android) =&gt; epoll</code></li><li><code>Windows =&gt; iocp</code></li><li><code>MacOS(iOS), FreeBSD =&gt; kqueue</code> </li><li><code>Fuchsia =&gt; &lt;unknown&gt;</code></li></ul><p>mio 把这些不同平台上的 API 封装出了一套 <code>epoll like</code> 的异步网络 API，支持 <code>udp 和 tcp</code>。</p><blockquote> 除此之外还封装了一些不同平台的拓展 API，比如 <code>uds</code>，本文不对这些 API 做介绍。<br> </blockquote><h2>异步网络 IO</h2><p>下面是一个 <code>tcp</code> 的 <code>demo</code></p><div class="highlight"><pre><code class="language-rust"><span></span><span class="c1">// examples/tcp.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">mio</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">mio</span>::<span class="n">net</span>::<span class="p">{</span><span class="n">TcpListener</span><span class="p">,</span><span class="w"> </span><span class="n">TcpStream</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="n">Read</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">failure</span>::<span class="n">Error</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">time</span>::<span class="p">{</span><span class="n">Duration</span><span class="p">,</span><span class="w"> </span><span class="n">Instant</span><span class="p">};</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">SERVER_ACCEPT</span>: <span class="nc">Token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Token</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">SERVER</span>: <span class="nc">Token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Token</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">CLIENT</span>: <span class="nc">Token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Token</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">SERVER_HELLO</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b"PING"</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">CLIENT_HELLO</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b"PONG"</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"127.0.0.1:13265"</span><span class="p">.</span><span class="n">parse</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Setup the server socket</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">server</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpListener</span>::<span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Create a poll instance</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">poll</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Poll</span>::<span class="n">new</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Start listening for incoming connections</span>
<span class="w">    </span><span class="n">poll</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="n">SERVER_ACCEPT</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">(),</span><span class="w"></span>
<span class="w">                  </span><span class="n">PollOpt</span>::<span class="n">edge</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Setup the client socket</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpStream</span>::<span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">server_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Register the client</span>
<span class="w">    </span><span class="n">poll</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">CLIENT</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">writable</span><span class="p">(),</span><span class="w"></span>
<span class="w">                  </span><span class="n">PollOpt</span>::<span class="n">edge</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Create storage for events</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Events</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Instant</span>::<span class="n">now</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="na">'top</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">poll</span><span class="p">.</span><span class="n">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">events</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">start</span><span class="p">.</span><span class="n">elapsed</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="nl">'top</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">token</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">SERVER_ACCEPT</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">server</span><span class="p">.</span><span class="n">accept</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"accept from addr: {}"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="n">poll</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">SERVER</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">writable</span><span class="p">(),</span><span class="w"> </span><span class="n">PollOpt</span>::<span class="n">edge</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="n">server_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>

<span class="w">                </span><span class="n">SERVER</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_writable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">server_handler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="k">match</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">SERVER_HELLO</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"server wrote"</span><span class="p">);</span><span class="w"></span>
<span class="w">                                </span><span class="p">}</span><span class="w"></span>
<span class="w">                                </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                    </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                                </span><span class="p">}</span><span class="w"></span>
<span class="w">                            </span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_readable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">server_handler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="k">match</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">CLIENT_HELLO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hello</span><span class="p">);</span><span class="w"></span>
<span class="w">                                    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"server received"</span><span class="p">);</span><span class="w"></span>
<span class="w">                                </span><span class="p">}</span><span class="w"></span>
<span class="w">                                </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                    </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                                </span><span class="p">}</span><span class="w"></span>
<span class="w">                            </span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">CLIENT</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_writable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">match</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">CLIENT_HELLO</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"client wrote"</span><span class="p">);</span><span class="w"></span>
<span class="w">                            </span><span class="p">}</span><span class="w"></span>
<span class="w">                            </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                            </span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_readable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">                        </span><span class="k">match</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">SERVER_HELLO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hello</span><span class="p">);</span><span class="w"></span>
<span class="w">                                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"client received"</span><span class="p">);</span><span class="w"></span>
<span class="w">                            </span><span class="p">}</span><span class="w"></span>
<span class="w">                            </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                            </span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">unreachable</span><span class="o">!</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>这个 <code>demo</code> 稍微有点长，接下来我们把它一步步分解。</p><p>直接看主循环</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">poll</span><span class="p">.</span><span class="n">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>每次循环都得执行 <code>poll.poll</code>，第一个参数是用来存 <code>events</code> 的 <code>Events</code>， 容量是 <code>1024</code>；</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Events</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>第二个参数是 <code>timeout</code>，即一个 <code>Option&lt;Duration&gt;</code>，超时会直接返回。返回类型是 <code>io::Result&lt;usize&gt;</code>。</p><blockquote> 其中的 <code>usize</code> 代表 <code>events</code> 的数量，这个返回值是 <code>deprecated</code> 并且会在之后的版本移除，仅供参考<br> </blockquote><p>这里我们设置了 <code>timeout = None</code>，所以当这个函数返回时，必然是某些事件被触发了。让我们遍历 <code>events</code>：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">match</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">token</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">SERVER_ACCEPT</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">server</span><span class="p">.</span><span class="n">accept</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"accept from addr: {}"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">poll</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">SERVER</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">writable</span><span class="p">(),</span><span class="w"> </span><span class="n">PollOpt</span>::<span class="n">edge</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">server_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="n">SERVER</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_writable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">server_handler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                  </span><span class="k">match</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">SERVER_HELLO</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                      </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                          </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"server wrote"</span><span class="p">);</span><span class="w"></span>
<span class="w">                      </span><span class="p">}</span><span class="w"></span>
<span class="w">                      </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                          </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                      </span><span class="p">}</span><span class="w"></span>
<span class="w">                  </span><span class="p">}</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_readable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">server_handler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                  </span><span class="k">match</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                      </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                          </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">CLIENT_HELLO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hello</span><span class="p">);</span><span class="w"></span>
<span class="w">                          </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"server received"</span><span class="p">);</span><span class="w"></span>
<span class="w">                      </span><span class="p">}</span><span class="w"></span>
<span class="w">                      </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                          </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                      </span><span class="p">}</span><span class="w"></span>
<span class="w">                  </span><span class="p">}</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">CLIENT</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_writable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="k">match</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">CLIENT_HELLO</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                  </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                      </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"client wrote"</span><span class="p">);</span><span class="w"></span>
<span class="w">                  </span><span class="p">}</span><span class="w"></span>
<span class="w">                  </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                      </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                  </span><span class="p">}</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_readable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">              </span><span class="k">match</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                  </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                      </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">SERVER_HELLO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hello</span><span class="p">);</span><span class="w"></span>
<span class="w">                      </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"client received"</span><span class="p">);</span><span class="w"></span>
<span class="w">                  </span><span class="p">}</span><span class="w"></span>
<span class="w">                  </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                      </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                  </span><span class="p">}</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">unreachable</span><span class="o">!</span><span class="p">(),</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p>我们匹配每一个 <code>event</code> 的 <code>token</code>，这里的 <code>token</code> 就是我用来注册的那些 <code>token</code>。比如我在上面注册了 <code>server</code></p><div class="highlight"><pre><code class="language-rust"><span></span><span class="c1">// Start listening for incoming connections</span>
<span class="n">poll</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="n">SERVER_ACCEPT</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">(),</span><span class="w"></span>
<span class="w">                  </span><span class="n">PollOpt</span>::<span class="n">edge</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
</code></pre></div><p>第二个参数就是 <code>token</code></p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">const</span><span class="w"> </span><span class="n">SERVER_ACCEPT</span>: <span class="nc">Token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Token</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>这样当 <code>event.token() == SERVER_ACCEPT</code> 时，就说明这个事件跟我们注册的 <code>server</code> 有关，于是我们试图 <code>accept</code> 一个新的连接并把它注册进 <code>poll</code>，使用的 <code>token</code> 是 <code>SERVER</code>。</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">server</span><span class="p">.</span><span class="n">accept</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"accept from addr: {}"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="n">poll</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">SERVER</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">writable</span><span class="p">(),</span><span class="w"> </span><span class="n">PollOpt</span>::<span class="n">edge</span><span class="p">())</span><span class="o">??</span><span class="p">;</span><span class="w"></span>
<span class="n">server_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>这样我们之后如果发现 <code>event.token() == SERVER</code>，我们就认为它和注册的 <code>handler</code> 有关：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_writable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">server_handler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">SERVER_HELLO</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"server wrote"</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_readable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">server_handler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">CLIENT_HELLO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hello</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"server received"</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>这时候我们还需要判断 <code>event.readiness()</code>，这就是 <code>register</code> 函数的第三个参数，叫做 <code>interest</code>，顾名思义，就是“感兴趣的事”。它的类型是 <code>Ready</code>，一共四种，<code>readable, writable, error 和 hup</code>，可进行并运算。</p><p>在上面我们给 <code>handler</code> 注册了 <code>Ready::readable() | Ready::writable()</code>，所以 <code>event</code> 可能是 <code>readable</code> 也可能是 <code>writable</code>，所以我们要经过判断来执行相应的逻辑。注意这里的判断是</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">if</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>而非</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">if</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>因为一个事件可能同时是 <code>readable</code> 和 <code>writable</code>。</p><h2>容错性原则</h2><p>大概逻辑先讲到这儿，这里先讲一下 <code>mio</code> 的“容错性原则”，即不能完全相信 <code>event</code>。</p><p>可以看到我上面有一段代码是这么写的 </p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">match</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">token</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">SERVER_ACCEPT</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">server</span><span class="p">.</span><span class="n">accept</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"accept from addr: {}"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="n">poll</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">SERVER</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">writable</span><span class="p">(),</span><span class="w"> </span><span class="n">PollOpt</span>::<span class="n">edge</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">server_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
</code></pre></div><p><code>server.accept()</code> 返回的是 <code>io::Result&lt;(TcpStream, SocketAddr)&gt;</code>。如果我们选择完全相信 <code>event</code> 的话，在这里 <code>unwrap()</code> 并没有太大问题 —— 如果真的有一个新的连接就绪，<code>accept()</code> 产生的 <code>io::Result</code> 是我们无法预料且无法处理的，我们应该抛给调用者或者直接 <code>panic</code>。</p><p>但问题就是，我们可以认为 <code>event</code> 的伪消息是可预料的，可能并没有一个新的连接准备就绪，这时候我们 <code>accept()</code> 会引发 <code>WouldBlock Error</code>。但我们不应该认为 <code>WouldBlock</code> 是一种错误 —— 这是一种友善的提醒。<code>server</code> 告诉我们：“并没有新的连接，请下次再来吧。”，所以在这里我们应该忽略（可以打个 <code>log</code>）它并重新进入循环。</p><p>像我后面写的那样：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">match</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">CLIENT_HELLO</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"client wrote"</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><h2>Poll Option</h2><p>好了，现在我们可以运行：</p><div class="highlight"><pre><code class="language-bash"><span></span><span class="o">[</span>async-io-demo<span class="o">]</span> cargo run --example tcp
</code></pre></div><p>terminal 里打印出了</p><div class="highlight"><pre><code class="language-bash"><span></span>client wrote
accept from addr: <span class="m">127</span>.0.0.1:53205
client wrote
server wrote
server received
...
</code></pre></div><p>我们可以发现，在短短的 <code>10 millis</code> 内（<code>let timeout = Duration::from_millis(10);</code>），<code>server</code> 和 <code>client</code> 分别进行了数十次的读写！</p><p>如果我们不想进行这么多次读写呢？比如，我们只想让 <code>server</code> 写一次。在网络比较通畅的情况下，<code>client</code> 和 <code>server</code> 几乎一直是可写的，所以 <code>Poll::poll</code> 在数微秒内就返回了。</p><p>这时候就要看 <code>register</code> 的第四个参数了。</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="n">poll</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="n">SERVER_ACCEPT</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">(),</span><span class="w"></span>
<span class="w">                  </span><span class="n">PollOpt</span>::<span class="n">edge</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
</code></pre></div><p><code>PollOpt::edge()</code> 的类型是 <code>PollOpt</code>，一共有 <code>level, edge, oneshot</code> 三种，他们有什么区别呢？</p><p>比如在我上面的代码里，</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_readable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">SERVER_HELLO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hello</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"client received"</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>我在收到一个 <code>readable readiness</code> 时，只读了四个字节。如果这时候缓冲区里有八字节的数据，那么：</p><ul><li>如果我注册时使用 <code>PollOpt::level()</code>，我在下次 <code>poll</code> 时 <b>一定</b> 还能收到一次 <code>readable readiness event</code> （只要我没有主动执行 <code>set_readiness(Read::empty())</code>）；</li><li>如果我注册时使用 <code>PollOpt::edge()</code>，我在下次 <code>poll</code> 时 <b>不一定</b> 还能收到一次 <code>readable readiness event</code>；</li></ul><p>所以，使用 <code>PollOpt::edge()</code> 时有一个“排尽原则（<code>Draining readiness</code>）”，即每次触发 <code>event</code> 时一定要操作到资源耗尽返回 <code>WouldBlock</code>，即上面的代码要改成：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">if</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">readiness</span><span class="p">().</span><span class="n">is_readable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">hello</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">SERVER_HELLO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hello</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"client received"</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">err</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>那么，<code>oneshot</code> 又是怎样的行为呢？让我们回到上面的问题，如果我们只想让 <code>handler</code> 写一次，怎么办 —— 注册时使用 <code>PollOpt::oneshot()</code>，即</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">server</span><span class="p">.</span><span class="n">accept</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"accept from addr: {}"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="n">poll</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">SERVER</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">writable</span><span class="p">(),</span><span class="w"> </span><span class="n">PollOpt</span>::<span class="n">oneshot</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="n">server_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span><span class="w"></span>
</code></pre></div><p>这样的话，你只能收到一次 <code>SERVER</code> 事件，除非你使用 <code>Poll::reregister</code> 重新注册 <code>handler</code>。</p><blockquote><code>Poll::reregister</code> 可以更改 <code>PollOpt</code> 和 <code>interest</code><br> </blockquote><h2>Still Block</h2><p>其实上面这个 <code>demo</code> 还存在一个问题，即我们在回调代码块中使用了同步的 <code>IO</code> 操作 <code>println!</code>。我们要尽可能避免在回调的代码块里使用耗时的 <code>IO</code> 操作。</p><p>考虑到文件 <code>IO</code> (包括 <code>Stdin, Stdout, Stderr</code>) 速度很慢，我们只需要把所有的文件 <code>IO</code> 交给一个线程进行即可。</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">mpsc</span>::<span class="p">{</span><span class="n">Sender</span><span class="p">,</span><span class="w"> </span><span class="n">Receiver</span><span class="p">,</span><span class="w"> </span><span class="n">channel</span><span class="p">,</span><span class="w"> </span><span class="n">SendError</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(Clone)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Fs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">task_sender</span>: <span class="nc">Sender</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Fs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">sender</span><span class="p">,</span><span class="w"> </span><span class="n">receiver</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channel</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span>::<span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">match</span><span class="w"> </span><span class="n">receiver</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">match</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="n">Task</span>::<span class="n">Println</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="p">),</span><span class="w"></span>
<span class="w">                            </span><span class="n">Task</span>::<span class="n">Exit</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="p">},</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">});</span><span class="w"></span>
<span class="w">        </span><span class="n">Fs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">task_sender</span>: <span class="nc">sender</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">println</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">string</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">task_sender</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">Task</span>::<span class="n">Println</span><span class="p">(</span><span class="n">string</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Task</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Exit</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Println</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>之后，可以使用 <code>Fs::println</code> 替换所有的 <code>println!</code>。</p><h2>自定义事件</h2><p>上面我们实现异步 <code>println</code> 比较简单，这是因为 <code>println</code> 并没有返回值，不需要进行后续操作。设想一下，如果要我们实现 <code>open</code> 和 <code>ready_to_string</code>，先异步地 <code>open</code> 一个文件，然后异步地 <code>read_to_string</code>，最后再异步地 <code>println</code>, 我们要怎么做？</p><p>最简单的写法是回调，像这样：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="c1">// src/fs.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">crossbeam_channel</span>::<span class="p">{</span><span class="n">unbounded</span><span class="p">,</span><span class="w"> </span><span class="n">Sender</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">boxed</span>::<span class="n">FnBox</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">failure</span>::<span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[derive(Clone)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Fs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">task_sender</span>: <span class="nc">Sender</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">FsHandler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">io_worker</span>: <span class="nc">thread</span>::<span class="n">JoinHandle</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">executor</span>: <span class="nc">thread</span>::<span class="n">JoinHandle</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">fs_async</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">Fs</span><span class="p">,</span><span class="w"> </span><span class="n">FsHandler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">task_sender</span><span class="p">,</span><span class="w"> </span><span class="n">task_receiver</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unbounded</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">result_sender</span><span class="p">,</span><span class="w"> </span><span class="n">result_receiver</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unbounded</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">io_worker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">task_receiver</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">match</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">Task</span>::<span class="n">Println</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="p">),</span><span class="w"></span>
<span class="w">                        </span><span class="n">Task</span>::<span class="n">Open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="n">result_sender</span><span class="w"></span>
<span class="w">                                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">TaskResult</span>::<span class="n">Open</span><span class="p">(</span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">))</span><span class="o">?</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="n">Task</span>::<span class="n">ReadToString</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">                            </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                            </span><span class="n">result_sender</span><span class="w"></span>
<span class="w">                                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">TaskResult</span>::<span class="n">ReadToString</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">))</span><span class="o">?</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="n">Task</span>::<span class="n">Exit</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="n">result_sender</span><span class="w"></span>
<span class="w">                                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">TaskResult</span>::<span class="n">Exit</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result_receiver</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">TaskResult</span>::<span class="n">ReadToString</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">callback</span><span class="p">.</span><span class="n">call_box</span><span class="p">((</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">))</span><span class="o">?</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">TaskResult</span>::<span class="n">Open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">callback</span><span class="p">.</span><span class="n">call_box</span><span class="p">((</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">))</span><span class="o">?</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">TaskResult</span>::<span class="n">Exit</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="w"></span>
<span class="w">            </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="p">(</span><span class="n">Fs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">task_sender</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">FsHandler</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">io_worker</span><span class="p">,</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Fs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">println</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">string</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">task_sender</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">Task</span>::<span class="n">Println</span><span class="p">(</span><span class="n">string</span><span class="p">))</span><span class="o">?</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">open</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">path</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">'static</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">task_sender</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">Task</span>::<span class="n">Open</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">callback</span><span class="p">),</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">clone</span><span class="p">()))</span><span class="o">?</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read_to_string</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">file</span>: <span class="nc">File</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">'static</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">task_sender</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">Task</span>::<span class="n">ReadToString</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">callback</span><span class="p">),</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">clone</span><span class="p">()))</span><span class="o">?</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">close</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">task_sender</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">Task</span>::<span class="n">Exit</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">FsHandler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">io_worker</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">executor</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">type</span> <span class="nc">FileCallback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">FnBox</span><span class="p">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">type</span> <span class="nc">StringCallback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">FnBox</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Task</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Exit</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Println</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Open</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">FileCallback</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">ReadToString</span><span class="p">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">StringCallback</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">TaskResult</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Exit</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Open</span><span class="p">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">FileCallback</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">ReadToString</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">StringCallback</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// examples/fs.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">asyncio</span>::<span class="n">fs</span>::<span class="n">fs_async</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">failure</span>::<span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">TEST_FILE_VALUE</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">"Hello, World!"</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="n">fs_handler</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs_async</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">fs</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"./examples/test.txt"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">fs</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">TEST_FILE_VALUE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">fs</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">fs</span><span class="p">.</span><span class="n">close</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">fs_handler</span><span class="p">.</span><span class="n">join</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>测试</p><div class="highlight"><pre><code class="language-bash"><span></span><span class="o">[</span>async-io-demo<span class="o">]</span> cargo run --example fs
</code></pre></div><p>这样写在逻辑上的确是对的，但是负责跑 <code>callback</code> 的 <code>executor</code> 线程其实被负责 <code>io</code> 的线程阻塞住了（<code>result_receiver.recv()</code>）。那我们能不能在 <code>executor</code> 线程里跑一个事件循环，以达到不被 <code>io</code> 线程阻塞的目的呢？（即确定 <code>result_receiver</code> 中有 <code>result</code> 时，<code>executor</code> 才会进行 <code>result_receiver.recv()</code>）.</p><p>这就到了体现 <code>mio</code> 强大可拓展性的时候：注册用户态的事件队列。</p><p>把上面的代码稍加修改，就成了这样：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="c1">// src/fs_mio.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">crossbeam_channel</span>::<span class="p">{</span><span class="n">unbounded</span><span class="p">,</span><span class="w"> </span><span class="n">Sender</span><span class="p">,</span><span class="w"> </span><span class="n">TryRecvError</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="n">Read</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">boxed</span>::<span class="n">FnBox</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">failure</span>::<span class="n">Error</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">time</span>::<span class="n">Duration</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">mio</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[derive(Clone)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Fs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">task_sender</span>: <span class="nc">Sender</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">FsHandler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">io_worker</span>: <span class="nc">thread</span>::<span class="n">JoinHandle</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">executor</span>: <span class="nc">thread</span>::<span class="n">JoinHandle</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">FS_TOKEN</span>: <span class="nc">Token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Token</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">fs_async</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">Fs</span><span class="p">,</span><span class="w"> </span><span class="n">FsHandler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">task_sender</span><span class="p">,</span><span class="w"> </span><span class="n">task_receiver</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unbounded</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">result_sender</span><span class="p">,</span><span class="w"> </span><span class="n">result_receiver</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unbounded</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">poll</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Poll</span>::<span class="n">new</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">registration</span><span class="p">,</span><span class="w"> </span><span class="n">set_readiness</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Registration</span>::<span class="n">new2</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">poll</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">registration</span><span class="p">,</span><span class="w"> </span><span class="n">FS_TOKEN</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">(),</span><span class="w"> </span><span class="n">PollOpt</span>::<span class="n">oneshot</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">io_worker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">task_receiver</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">match</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">Task</span>::<span class="n">Println</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="p">),</span><span class="w"></span>
<span class="w">                        </span><span class="n">Task</span>::<span class="n">Open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="n">result_sender</span><span class="w"></span>
<span class="w">                                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">TaskResult</span>::<span class="n">Open</span><span class="p">(</span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                            </span><span class="n">set_readiness</span><span class="p">.</span><span class="n">set_readiness</span><span class="p">(</span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="n">Task</span>::<span class="n">ReadToString</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">                            </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                            </span><span class="n">result_sender</span><span class="w"></span>
<span class="w">                                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">TaskResult</span>::<span class="n">ReadToString</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                            </span><span class="n">set_readiness</span><span class="p">.</span><span class="n">set_readiness</span><span class="p">(</span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="n">Task</span>::<span class="n">Exit</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="n">result_sender</span><span class="w"></span>
<span class="w">                                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">TaskResult</span>::<span class="n">Exit</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                            </span><span class="n">set_readiness</span><span class="p">.</span><span class="n">set_readiness</span><span class="p">(</span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Events</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="na">'outer</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">poll</span><span class="p">.</span><span class="n">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">events</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">match</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">token</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">FS_TOKEN</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="k">match</span><span class="w"> </span><span class="n">result_receiver</span><span class="p">.</span><span class="n">try_recv</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                    </span><span class="k">match</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                        </span><span class="n">TaskResult</span>::<span class="n">ReadToString</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">callback</span><span class="p">.</span><span class="n">call_box</span><span class="p">((</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">))</span><span class="o">?</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">TaskResult</span>::<span class="n">Open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">callback</span><span class="p">.</span><span class="n">call_box</span><span class="p">((</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">))</span><span class="o">?</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">TaskResult</span>::<span class="n">Exit</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="w"> </span><span class="nl">'outer</span><span class="w"></span>
<span class="w">                                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                                </span><span class="p">}</span><span class="w"></span>
<span class="w">                                </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                    </span><span class="k">match</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                        </span><span class="n">TryRecvError</span>::<span class="n">Empty</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">TryRecvError</span>::<span class="n">Disconnected</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">?</span><span class="w"></span>
<span class="w">                                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                                </span><span class="p">}</span><span class="w"></span>
<span class="w">                            </span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="n">poll</span><span class="p">.</span><span class="n">reregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">registration</span><span class="p">,</span><span class="w"> </span><span class="n">FS_TOKEN</span><span class="p">,</span><span class="w"> </span><span class="n">Ready</span>::<span class="n">readable</span><span class="p">(),</span><span class="w"> </span><span class="n">PollOpt</span>::<span class="n">oneshot</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">unreachable</span><span class="o">!</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">Fs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">task_sender</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">FsHandler</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">io_worker</span><span class="p">,</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Fs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">println</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">string</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">task_sender</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">Task</span>::<span class="n">Println</span><span class="p">(</span><span class="n">string</span><span class="p">))</span><span class="o">?</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">open</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">path</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">'static</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">task_sender</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">Task</span>::<span class="n">Open</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">callback</span><span class="p">),</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">clone</span><span class="p">()))</span><span class="o">?</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read_to_string</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">file</span>: <span class="nc">File</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">'static</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">task_sender</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">Task</span>::<span class="n">ReadToString</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">callback</span><span class="p">),</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">clone</span><span class="p">()))</span><span class="o">?</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">close</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">task_sender</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">Task</span>::<span class="n">Exit</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">FsHandler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">io_worker</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">executor</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">type</span> <span class="nc">FileCallback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">FnBox</span><span class="p">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">type</span> <span class="nc">StringCallback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">FnBox</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Task</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Exit</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Println</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Open</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">FileCallback</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">ReadToString</span><span class="p">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">StringCallback</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">TaskResult</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Exit</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Open</span><span class="p">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">FileCallback</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">ReadToString</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">StringCallback</span><span class="p">,</span><span class="w"> </span><span class="n">Fs</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// examples/fs-mio.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">asyncio</span>::<span class="n">fs_mio</span>::<span class="n">fs_async</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">failure</span>::<span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">TEST_FILE_VALUE</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">"Hello, World!"</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="n">fs_handler</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs_async</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">fs</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"./examples/test.txt"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">fs</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">TEST_FILE_VALUE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">fs</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">fs</span><span class="p">.</span><span class="n">close</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">fs_handler</span><span class="p">.</span><span class="n">join</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>可以注意到，上面的代码发生的改变就是，<code>executor</code> 不再被 <code>result_receiver.recv</code> 阻塞，而变成了注册事件（<code>registration</code>）后等待 <code>Poll::poll</code> 返回事件；只有等到了新的事件，才会进行 <code>result_receiver.try_recv</code>。同时，<code>io_worker</code> 线程在 <code>send result</code> 之后会执行 <code>set_readiness.set_readiness(Ready::readable())?;</code>，以通知 <code>executor</code> 线程对相应结果做处理。</p><p>这样的话，<code>executor</code> 就不会被 <code>io worker</code> 阻塞了，因为我们可以把所有的事件都注册到 <code>executor</code> 上，<code>mio::Poll</code> 会同时监听多个事件（比如把 <code>fs</code> 和 <code>tcp</code> 结合起来）。</p><p>测试</p><div class="highlight"><pre><code class="language-bash"><span></span><span class="o">[</span>async-io-demo<span class="o">]</span> cargo run --example fs-mio
</code></pre></div><h2>Callback is evil</h2><p>既然文件 <code>IO</code> 的 <code>executor</code> 不再会被 <code>io worker</code> 线程阻塞了，那我们来试试让 <code>fs</code> 和 <code>tcp</code>  共用一个 <code>poll</code> 然后建立一个简单的文件服务器吧。</p><p>但可以先等等，因为我已经开始觉得写 <code>callback</code> 有点难受了 —— 如果我们还想处理错误的话，会觉得更难受，像这样</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">use</span><span class="w"> </span><span class="n">asyncio</span>::<span class="n">fs_mio</span>::<span class="n">fs_async</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">failure</span>::<span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">TEST_FILE_VALUE</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">"Hello, World!"</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="n">fs_handler</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs_async</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">fs</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"./examples/test.txt"</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="o">|</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">fs</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span>
<span class="w">                </span><span class="o">|</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">TEST_FILE_VALUE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="n">fs</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span>
<span class="w">                        </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="p">...</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="n">fs</span><span class="p">.</span><span class="n">close</span><span class="p">()</span><span class="w"></span>
<span class="w">                </span><span class="p">},</span><span class="w"></span>
<span class="w">                </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="p">...</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">fs_handler</span><span class="p">.</span><span class="n">join</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>而且对 <code>rust</code> 来说，更加艰难的是闭包中的生命周期问题（闭包几乎不能通过捕获来借用环境变量）。这就意味着，如果我要借用环境中的某个变量，我要么 <code>clone</code> 它（如果它实现了 <code>Clone</code> 的话），要么把它作为闭包参数传入（意味着你要根据需要改每一层回调函数的签名，这太屎了）。</p><p>考虑到各种原因，<code>rust</code> 最终选择用 <code>coroutine</code> 作为异步 <code>IO</code> 的 <code>API</code> 抽象。</p><h2>coroutine</h2><p>这里所说的 <code>coroutine</code> 是指基于 <code>rust generator</code> 的 <code>stackless coroutine</code> 而非早期被 <code>rust</code> 抛弃的 <code>green thread(stackful coroutine)</code>。</p><h2>generator</h2><p><code>rust</code> 大概在今年五月份引入了 <code>generator</code>，但到现在还是 unstable 的 —— 虽说也没多少人用 stable（误</p><p>一个典型的斐波那契 <code>generator</code> 如下</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="c1">// examples/fab.rs</span>

<span class="cp">#![feature(generators, generator_trait)]</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="p">{</span><span class="n">Generator</span><span class="p">,</span><span class="w"> </span><span class="n">GeneratorState</span><span class="p">};</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fab</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">gen</span><span class="p">.</span><span class="n">resume</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">GeneratorState</span>::<span class="n">Yielded</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"yield {}"</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="n">GeneratorState</span>::<span class="n">Complete</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"return {}"</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">fab</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">n</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Generator</span><span class="o">&lt;</span><span class="n">Yield</span><span class="o">=</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">Return</span><span class="o">=</span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="k">u64</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kr">yield</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kr">yield</span><span class="w"> </span><span class="n">current</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">n</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>由于 <code>generator</code> 的“中断特性”，我们很自然的可以想到，如果用 <code>generator</code> 搭配 <code>mio</code>，给每个 <code>generator</code> 分配一个 <code>token</code>，然后 <code>poll mio</code> 的事件循环，收到一个唤醒事件就 <code>resume</code> 相应的 <code>generator</code>；每个 <code>generator</code> 在要阻塞的时候拿自己的 <code>token</code> 注册一个唤醒事件然后 <code>yield</code>，不就实现了“同步代码”的异步 <code>IO</code> 吗？</p><p>这样看来原理上来说已经稳了，但 <code>rust</code> 异步 <code>IO</code> 的天空依旧漂浮着两朵乌云。</p><h2>自引用</h2><p>第一朵乌云和 <code>rust</code> 自身的内存管理机制有关。</p><p>如果你写出这样的 <code>generator</code></p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">fn</span> <span class="nf">self_ref_generator</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Generator</span><span class="o">&lt;</span><span class="n">Yield</span><span class="o">=</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">Return</span><span class="o">=</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ref_x</span>: <span class="kp">&amp;</span><span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kr">yield</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kr">yield</span><span class="w"> </span><span class="o">*</span><span class="n">ref_x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><code>rust</code> 一定会给你抛个错然后告诉你 "borrow may still be in use when generator yields"。编译器没有教你怎么修正可能会让你有些恐慌，去不存在的搜索引擎上查了查，你发现这和 <code>generator</code> 的实现有关。</p><p>前文中提到，<code>rust generator</code> 是 <code>stackless</code> 的，即它并不会保留一个完整的栈，而是根据不同的状态保留需要的变量。如果你把上面的代码改成</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">fn</span> <span class="nf">no_ref_generator</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Generator</span><span class="o">&lt;</span><span class="n">Yield</span><span class="o">=</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">Return</span><span class="o">=</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ref_x</span>: <span class="kp">&amp;</span><span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kr">yield</span><span class="w"> </span><span class="o">*</span><span class="n">ref_x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kr">yield</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>在第一次 <code>yield</code> 结束之后，编译器会发现 <code>generator</code> 唯一需要保留的是字面量 <code>0</code>，所以这段代码可以顺利编译通过。但是，对于前面的 <code>generator</code>，第一次 <code>yield</code> 过后，编译器发现你需要同时保留 <code>x</code> 和它的引用 <code>ref_x</code>，这样的话 <code>generator</code> 就会变成类似这样的结构（仅供参考）：</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">enum</span> <span class="nc">SomeGenerator</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">SomeState</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">_yield</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span>: <span class="kt">u64</span>
        <span class="nc">ref_x</span>: <span class="kp">&amp;</span><span class="na">'a</span><span class="w"> </span><span class="kt">u64</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>这就是 <code>rust</code> 中“臭名昭著” 的自引用，下面这段代码会发生什么呢</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">struct</span> <span class="nc">A</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ref_b</span>: <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="na">'a</span><span class="w"> </span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">{</span><span class="n">b</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ref_b</span>: <span class="nb">None</span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="n">ref_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>你会发现它编译不过，当然这是很合理的，栈上的 a 变量拷贝出去之后其成员 b 的引用会失效，<code>rust</code>的生命周期机制帮你规避了这个问题。但即使你改成这样</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">borrow</span>::<span class="p">{</span><span class="n">BorrowMut</span><span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">A</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ref_b</span>: <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="na">'a</span><span class="w"> </span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">boxed</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">A</span><span class="p">{</span><span class="n">b</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ref_b</span>: <span class="nb">None</span><span class="p">});</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">mut_ref</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">mut_ref</span><span class="p">.</span><span class="n">ref_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mut_ref</span><span class="p">.</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>这样按道理来说是没问题的，因为 a 的实体已经在堆上了，即使你拷贝它在栈上的引用，也不会改变其成员 b 的地址，引用一直是有效的 —— 但问题是，你没法跟编译器解释这事，编译器认为函数里面的 <code>&amp;mut_ref.b</code>只能活到函数结束，这样含有这个引用的 a 自然也不能 move 出来。</p><p>那你可能会想，那我就在外面再取引用就好了</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">struct</span> <span class="nc">A</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ref_b</span>: <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="na">'a</span><span class="w"> </span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">{</span><span class="n">b</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ref_b</span>: <span class="nb">None</span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">ref_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>这样的确没啥毛病，但是，你会发现自引用不仅阻止了 move，还阻止了你对 A 可变引用。。比如这样就编译不过</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">struct</span> <span class="nc">A</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ref_b</span>: <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="na">'a</span><span class="w"> </span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">{</span><span class="n">b</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ref_b</span>: <span class="nb">None</span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">mute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">ref_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">mute</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>但远古的 <code>Future::poll</code> 签名就长这样</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>而直到现在 <code>Generator::resume</code> 的签名还是这样</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">resume</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">GeneratorState</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Yield</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Return</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</code></pre></div><p>这样的话自引用会导致 <code>generator</code> 无法实现 <code>Generator</code> 和 <code>Future</code> </p><p>在这种情况下，我们可以使用 <code>NonNull</code>来避过编译器的检查</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">NonNull</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ref_b</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">{</span><span class="n">b</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ref_b</span>: <span class="nc">NonNull</span>::<span class="n">dangling</span><span class="p">()}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">ref_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>这样的确没有了烦人的生命周期约束，但也意味着你要自己保证内存安全 —— 绝对不能 move，也不能对其可变引用使用 <code>mem::replace</code> 或 <code>mem::swap</code> ，这样非常不妙。</p><h2>Pin</h2><p>那有没有办法通过其它方式来保证能保证它不能被 move 或者取可变引用呢？这就是 <code>pin</code>的应用场景了。<code>pin</code>具体的内容可以看这篇 <a href="http://link.zhihu.com/?target=https%3A//github.com/rust-lang/rfcs/blob/master/text/2349-pin.md" class=" wrap external" target="_blank" rel="nofollow noreferrer">RFC</a>，本文只是简要说明一下。</p><p><code>rust</code> 默认给大部分类型实现了 <code>trait std::marker::Unpin</code>，这只是一个标记，表示这个类型 move 是安全的，这时候，<code>Pin&lt;'a, T&gt;</code> 跟 <code>&amp;'a mut T</code> 没有区别，你也可以安全地通过 <code>Pin::new(&amp;mut T)</code> 和 <code>Pin::as_mut(self: &amp;mut Pin&lt;T&gt;)</code>相互转换。</p><p>但对于不能安全 move 的类型，比如上面的 <code>A</code>，我们得先把它标记为 <code>!Unpin</code>，安全的标记方法是给它一个 <code>!Unpin</code>的成员，比如 <code>Pinned</code>。</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="cp">#![feature(pin)]</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">marker</span>::<span class="p">{</span><span class="n">Pinned</span><span class="p">};</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">NonNull</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ref_b</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">_pin</span>: <span class="nc">Pinned</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">b</span>: <span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">ref_b</span>: <span class="nc">NonNull</span>::<span class="n">dangling</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="n">_pin</span>: <span class="nc">Pinned</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">pinned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinned</span><span class="p">.</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">mut_ref</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinned</span><span class="p">.</span><span class="n">as_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="n">Pin</span>::<span class="n">get_mut_unchecked</span><span class="p">(</span><span class="n">mut_ref</span><span class="p">).</span><span class="n">ref_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref_b</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">unmoved</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinned</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">unmoved</span><span class="p">.</span><span class="n">ref_b</span><span class="p">,</span><span class="w"> </span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unmoved</span><span class="p">.</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>从 <code>!Unpin</code> 的类型构建 <code>Pin</code> 总是 <code>unsafe</code> 的，它们通过 <code>Pin::new_unchecked</code> 和 <code>Pin::get_mut_unchecked</code> 相互转换。当然，我们在构建时是可以保证它是 <code>safe</code> ，我们只要完成这两个 <code>unsafe</code>的操作，就可以保证：</p><ul><li>永远不能 <code>safe</code> 地获得可变引用： <code>Pin::get_mut_unchecked</code> 是 <code>unsafe</code> 的</li><li>永远不能 <code>safe</code> 地 move：因为 <code>Pin</code> 只拥有可变引用，且由于<code>Pin::get_mut_unchecked</code> 是 <code>unsafe</code> 的，你不能 <code>safe</code> 地对其可变引用使用 <code>mem::replace</code> 或 <code>mem::swap</code></li></ul><p>当然，如果你不想在构建时使用 <code>unsafe</code>或者想获得 <code>a</code> 的所有权以便在函数间传递，你可以使用 <code>Box::pinned</code>从而把它分配在堆上</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">struct</span> <span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ref_b</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">_pin</span>: <span class="nc">Pinned</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">boxed</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">boxed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">pinned</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">b</span>: <span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">ref_b</span>: <span class="nc">NonNull</span>::<span class="n">dangling</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="n">_pin</span>: <span class="nc">Pinned</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">});</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ref_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boxed</span><span class="p">.</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">mut_ref</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boxed</span><span class="p">.</span><span class="n">as_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">get_mut_unchecked</span><span class="p">(</span><span class="n">mut_ref</span><span class="p">).</span><span class="n">ref_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref_b</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="n">boxed</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">boxed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>::<span class="n">boxed</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">unmoved</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boxed</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">unmoved</span><span class="p">.</span><span class="n">ref_b</span><span class="p">,</span><span class="w"> </span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unmoved</span><span class="p">.</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>有了 <code>Pin</code> 之后，新版 <code>Future</code> 的定义就是这样的了</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">lw</span>: <span class="kp">&amp;</span><span class="nc">LocalWaker</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><h2>合理的抽象</h2><p>既然已经打算钦定了 <code>coroutine</code> 作为异步 <code>IO</code> 的 <code>API</code> 抽象，那应该把哪些东西加入标准库、哪些东西加入语法支持、哪些东西交给第三方实现呢？让开发者手动调用 <code>unsafe</code> 的 <code>Generator::resume</code> 终归不是很妙，也不好把 <code>mio</code> 作为唯一的底层异步 <code>IO</code> 实现（如果这样的话不如把 <code>mio</code> 也并入标准库）。</p><p>现在的 <code>rust</code> 提供了 <code>async</code> 的语法支持（以前是用过程宏的实现的）、<code>await!</code>的标准库宏支持，标准库 <code>std::future</code> 的 <code>trait Future</code> 和 <code>struct GenFuture</code> ， 标准库 <code>std::task</code> 的  <code>enum Poll&lt;T&gt;, struct LocalWaker, struct Waker</code> 和 <code>trait UnsafeWaker</code>。</p><p>你需要给你的 <code>MyWaker</code> 实现 <code>trait UnsafeWaker</code>，用 <code>mio</code> 的话就用 <code>SetReadiness</code>，<code>unsafe fn wake(&amp;self)</code> 用 <code>SetReadiness::set_readiness</code> 实现。然后把 <code>MyWaker</code> 包在 <code>Waker, LocalWaker</code> 里面。</p><h2>Poll&lt;T&gt;</h2><p><code>Poll&lt;T&gt;</code> 的定义为</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Ready</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Pending</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><h2>await!</h2><p><code>await!</code> 宏只能在 <code>async</code> 函数或者块里面用，传入一个 <code>Future</code></p><p><code>await!(future)</code>会被展开成</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">Poll</span>::<span class="n">Ready</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>::<span class="n">future</span>::<span class="n">poll_with_tls</span><span class="p">(</span><span class="k">unsafe</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">future</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kr">yield</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p><code>::future::poll_with_tls</code> 即 <code>thread-local waker</code>，就是你传给这个 <code>GenFuture::poll</code> 的 <code>LocalWaker</code>，</p><h2>async</h2><p><code>async</code>则会把 <code>Generator</code> 包装成 <code>Future(GenFuture)</code> 。</p><p><code>GenFuture</code> 的相关定义如下</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">struct</span> <span class="nc">GenFuture</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Generator</span><span class="o">&lt;</span><span class="n">Yield</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Generator</span><span class="o">&lt;</span><span class="n">Yield</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">!</span><span class="n">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GenFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Generator</span><span class="o">&lt;</span><span class="n">Yield</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GenFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">Return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">lw</span>: <span class="kp">&amp;</span><span class="nc">LocalWaker</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">set_task_waker</span><span class="p">(</span><span class="n">lw</span><span class="p">,</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">get_mut_unchecked</span><span class="p">(</span><span class="bp">self</span><span class="p">).</span><span class="mf">0.</span><span class="n">resume</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">GeneratorState</span>::<span class="n">Yielded</span><span class="p">(())</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Poll</span>::<span class="n">Pending</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">GeneratorState</span>::<span class="n">Complete</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Poll</span>::<span class="n">Ready</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">from_generator</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Generator</span><span class="o">&lt;</span><span class="n">Yield</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">Return</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">GenFuture</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>这里可以看到，<code>GenFuture</code> 在每次调用 <code>self.0.resume</code> 之前会 <code>set_task_waker</code>，通过一个 <code>thread_local</code> 的变量中转，从而 <code>generator</code> 里面的 <code>future::poll</code> 能通过 <code>poll_with_tls</code> 拿到这个 <code>LocalWaker</code>。</p><p>所以，下面的代码</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="n">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">async_recv</span><span class="p">(</span><span class="n">string_channel</span>: <span class="nc">Receiver</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">await</span><span class="o">!</span><span class="p">(</span><span class="n">string_channel</span><span class="p">.</span><span class="n">recv_future</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><p>会被类似地展开为这样</p><div class="highlight"><pre><code class="language-rust"><span></span><span class="k">fn</span> <span class="nf">async_recv</span><span class="p">(</span><span class="n">string_channel</span>: <span class="nc">Receiver</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">Return</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">from_generator</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">recv_future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">string_channel</span><span class="p">.</span><span class="n">recv_future</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">Poll</span>::<span class="n">Ready</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>::<span class="n">future</span>::<span class="n">poll_with_tls</span><span class="p">(</span><span class="k">unsafe</span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">recv_future</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="kr">yield</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div><h2>asynchronous coroutine</h2><p>掌握了上文的基础知识后，我们就可以开始实践了。</p><p>coroutine 本身并不意味着“异步”，你完全可以在两次 <code>yield</code> 之间调用同步 <code>IO</code> 的 <code>API</code> 从而导致 <code>IO</code> 阻塞。 异步的关键在于，在将要阻塞的时候（比如某个 <code>API</code> 返回了 <code>io::ErrorKind::WouldBlock</code>），<code>GenFuture::poll</code>中 用底层异步接口注册一个事件和唤醒回调（<code>waker</code>）然后自身休眠（<code>yield</code>），底层异步调度在特定事件发生的时候回调唤醒这个 <code>Future</code>。</p><p>下面我参照 <code>romio</code> 的异步调度实现了 <code>Executor</code> <code>block_on, spawn, TcpListener</code> 和 <code>TcpStream</code>，代码较长，建议 <code>clone</code> 后用编辑器看。（请注意区分 <code>Poll(mio::Poll)</code> 与 <code>task::Poll</code> 以及 <code>net::{TcpListener, TcpStream}(mio::net::{TcpListener, TcpStream})</code> 与 <code>TcpListener, TcpStream</code>）</p><p><a href="http://link.zhihu.com/?target=https%3A//github.com/Hexilee/async-io-demo/blob/master/src/executor.rs" class=" wrap external" target="_blank" rel="nofollow noreferrer">src/executor.rs</a></p><h2>Executor</h2><p><code>Executor</code> 中包含 <code>mio::Poll</code>，<code>main task waker</code> 及用来管理 <code>task</code> 和 <code>source</code> 的 <code>Slab</code> 各一个。其本身并没有实现什么特别的方法，主要是初始化为 <code>thread_local</code> 的 <code>EXECUTOR</code> 供其它函数借用。</p><h2>block_on</h2><p><code>block_on</code> 函数会阻塞当前线程，传入参数是一个 <code>future: Future&lt;Output=T&gt;</code>，被称为 <code>main task</code>；返回值类型是 <code>T</code>。该函数一般在最外层被调用。</p><p><code>block_on</code> 会引用 <code>thread_local EXECUTOR</code>，主要逻辑是调用 <code>mio::Poll::poll</code> 来响应事件。<code>block_on</code> 把 <code>0 - MAX_RESOURCE_NUM(1 &lt;&lt; 31)</code> 个 <code>Token</code> 分为三类。</p><ul><li><code>main task token</code></li></ul><p>收到 <code>Token</code> 为 <code>MAIN_TASK_TOKEN</code> 的事件即表示需要唤醒 <code>main task</code>，执行 <code>main_task.poll</code>，返回 <code>task::Poll::Ready(T)</code> 则 <code>block_on</code> 函数返回。</p><ul><li><code>task token</code></li></ul><p>奇数 <code>token</code> 表示由 <code>spawn</code> 函数分发的其它任务需要被唤醒，执行相应的 <code>task.poll</code>，<code>token</code> 和该事件在 <code>EXECUTOR.tasks</code> 中的 <code>index</code> 一一映射。</p><ul><li><code>source token</code></li></ul><p>偶数 <code>token</code> 表示由 <code>register_source</code> 函数注册的 <code>source</code>需要被分发，执行相应 <code>source</code> 的 <code>waker()</code> 以唤醒分发它们的 <code>task</code>。</p><h2>spawn</h2><p>分发任务</p><h2>TcpListener</h2><p>包装了 <code>mio::net::TcpListener</code>，<code>accept</code> 方法返回一个 <code>Future</code>。</p><h2>TcpStream</h2><p>包装了 <code>mio::net::TcpStream</code>, <code>read</code>和 <code>write</code> 方法均返回 <code>Future</code>。</p><h2>后记</h2><p>实现了 <code>executor</code> 之后，我们就可以运行文章开头给的 <code>example</code>    了，</p><div class="highlight"><pre><code class="language-bash"><span></span><span class="nv">RUST_LOG</span><span class="o">=</span>info cargo run --example async-echo
</code></pre></div><p>可以用 <code>telnet</code> 连连试试看。</p><p>当然最后还留了一个问题，就是把文件 <code>IO</code> 也封装为 <code>coroutine</code> 的异步 <code>IO</code>，当然我还没有写，读者有兴趣可以试着实现一下，我们接下来再谈谈现在 <code>coroutine API</code> 的不足。</p><p>我目前发现的主要问题就是不能在 <code>Future::poll</code> 或者 <code>async</code> 中使用 <code>try</code>，导致出现 <code>Result</code> 的地方只能 <code>match</code>，希望之后会有比较好的解决方案。</p><p>第二个问题是 <code>Waker</code> 最里面装的是 <code>UnsafeWaker</code>的 <code>Non</code>)?<code>ull</code> 指针，当然我能理解 <code>rust</code> 团队有性能等其它方面的考虑，但如果用 <code>mio</code> 的 <code>set_readiness</code> 封装出 <code>MyWaker</code> 的话，<code>clone</code> 完全不需要 <code>NonNull</code>，而且我在实际编码时因为这个出过空指针错误。。希望以后能提供一个更安全的选择。?let (handler, addr) = server.accept()?; println!("accept from addr: {}", &amp;addr); poll.register(&amp;handler, SERVER_WRITE, Ready::readable() | Ready::writable(), PollOpt::oneshot())?; server_handler = Some(handler);let (handler, addr) = server.accept()?; println!("accept from addr: {}", &amp;addr); poll.register(&amp;handler, SERVER_WRITE, Ready::readable() | Ready::writable(), PollOpt::oneshot())?; server_handler = Some(handler);</p>