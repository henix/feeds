<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Rust - RFC 导读: async/await 特性（二）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/37269342">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-b357cf4b2202c2f3e9edb6c3b6204680_r.jpg" alt=""></div><blockquote>由于本篇文章代码较多，如果知乎的排版伤害了你的眼睛，可以暂时移步到 <a href="https://github.com/andylokandy/article/blob/master/Rust%20-%20RFC%20%E5%AF%BC%E8%AF%BB%20async%20%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89.md">这里</a>。</blockquote><p><br></p><p>上一篇我们讲到了编译器对 <code class="inline">async/await</code> 的特性支持，相应的，我们要让编译器知道 <code class="inline">Future</code> 是什么，编译器才能生成匿名的 <code class="inline">Future</code> 类型。为此，我们就有了第二份 RFC —— 将 <code class="inline">Future</code> 加入标准库（准确来说是 <code class="inline">libcore</code>）。</p><p><br></p><p><a href="https://github.com/aturon/rfcs/blob/async-trait/text/0000-async.md">RFC 2418 companion libs</a></p><p><br></p><p><i>注意这篇 RFC 还在讨论阶段并未被 merge，因此最终方案可能会改变，目前已经可以看见讨论区提出了相较于 <code class="inline">arbitrary self type</code>（<code class="inline">Pin&lt;self&gt;</code>） 更好的解决方案，这部分是最有可能发生变化的。</i></p><p><br></p><h2>Summary</h2><p>这篇文章将会深入 <code class="inline">async/await</code> 的实现原理，如果读者只是希望使用现成的库和 <code class="inline">async/await</code> 语法，仅看上一篇文章就已经足够了。而如果你希望开发使用异步实现的库，或者天生有着强烈的好奇心，那么这篇文章就是专门为你定做的。</p><p><br></p><p>这篇 RFC 并不打算将整个 <code class="inline">futures-rs</code> 移入标准库，相反极力精简，仅仅加入必要的最基础的构件，把剩余的功能留给社区的库来实现。就算如此，我们也将迎来帮数量众多的新朋友: <code class="inline">core::task::{Context, Poll, Wake, Waker, UnsafeWake, Executor, TaskObj, SpawnErrorKind, SpawnObjError}</code> 和 <code class="inline">core::ops::Async</code>。</p><p><br></p><p>如果加上另一篇 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md">RFC: 2349-pin</a>，那就还有 <code class="inline">core::marker::Unpin</code> 和 <code class="inline">core::mem::Pin</code>。</p><p><br></p><p>我们可以看到，新加入的东西真心不少，但是别担心，它们的存在都是必要而且符合直觉的，接下来我会逐个解释这些东西到底用来干什么的。</p><p><br></p><p>另外，读者可能注意到，这篇 RFC 中并没有出现 <code class="inline">Future</code>，这是因为这篇 RFC 写在上一篇 RFC 之后，在这期间社区讨论决定了并不引入 <code class="inline">Future</code> 全部的功能(比如 <code class="inline">map()</code>, <code class="inline">and_then()</code>)，而是只定义其中关键一部分 <code class="inline">poll()</code>，剩余的功能依旧留给 <code class="inline">futures-rs</code> 库来提供，所以这个被精简的 <code class="inline">trait</code> 不能叫做 <code class="inline">Future</code>，那就改名叫作了 <code class="inline">Async</code>。也就是说，async 函数的返回值应该是 <code class="inline">impl Async&lt;Output = T&gt;</code>。</p><p><br></p><h2><code class="inline">Async</code> </h2><p>让我们先从关键的 <code class="inline">Async trait</code> 入手，下面是它的定义： </p><code lang="text">pub trait Async {
    type Output;
    /// Attempt to resolve the computation to a final value, registering
    /// the current task for wakeup if the value is not yet available.
    fn poll(self: Pin&lt;Self&gt;, cx: &amp;mut task::Context) -&gt; Poll&lt;Self::Output&gt;;
}</code><p><br></p><p><code class="inline">Async</code> 只定义了一个函数 <code class="inline">poll()</code>，作用是尝试获取异步操作的结果， 熟悉使用 <code class="inline">futures-rs</code> 的读者想必已经对它十分了解了。如果不是也没关系，我会从头解释一遍。我们先忽略传入参数，只看返回值，它返回的是 <code class="inline">Poll</code> 类型：</p><code lang="text">pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}</code><p><br></p><p><code class="inline">Poll</code> 有两个 variance: <code class="inline">Ready(T)</code> 表示异步操作已经完成并获得返回值, <code class="inline">Pendding</code> 表示异步操作还在进行中，你过会儿再过来看看。<code class="inline">Poll</code> 的概念很简单，就不多说了。</p><p><br></p><p>这就带来了一个问题，我们该什么时候调用 <code class="inline">poll()</code> 呢？它仅仅在完成之后才能给出有用的结果，万一如果返回的是 <code class="inline">Pending</code>, 我们怎么知道什么时候需要再次 <code class="inline">poll()</code> 呢？又由谁来负责 <code class="inline">poll()</code> 呢？</p><p><br></p><p>答案是我们需要一个 <code class="inline">event loop</code>（比如线程池）来帮助我们完成这个调度(scheduling)工作。标准库并不会提供一个现成的 <code class="inline">event loop</code>，但标准库提供了定义它们的 <code class="inline">trait</code>。</p><p><br></p><h2><code class="inline">Executor</code> </h2><p>我们来看一个具体的例子，比如说我们正在打算从 <code class="inline">socket</code> 接收数据，我们得到了一个 <code class="inline">Async</code>，这时候 <code class="inline">socket</code> 可能还没准备好，所以第一次 <code class="inline">poll()</code> 返回了 <code class="inline">Poll::Pending</code>，这时我们必须把这个 <code class="inline">Async</code> 交给一个 <code class="inline">event loop</code> 保管（就比如说一个由 <code class="inline">futures-rs</code> 库提供的线程池 <code class="inline">ThreadPool</code>），以备过会 <code class="inline">socket</code> 准备好了再回来 <code class="inline">poll()</code>。</p><p><br></p><p>在这个例子里 <code class="inline">ThreadPool</code> 实现了 <code class="inline">Executor</code>。我们来看看这个东西的定义：</p><p><br></p><code lang="text">pub trait Executor {
    fn spawn_obj(&amp;mut self, task: TaskObj) -&gt; Result&lt;(), SpawnObjError&gt;;
}</code><p><br></p><p>这里的 <code class="inline">TaskObj</code> 实际上是一个 <code class="inline">Box&lt;Async&lt;Output = ())&gt;&gt;</code>。</p><p><br></p><p><code class="inline">spawn_obj()</code> 用于给 <code class="inline">Executor</code> 安排工作，让 <code class="inline">Executor</code> 负责稍后的 <code class="inline">poll()</code> 工作。</p><p><br></p><p>这里说个题外话，因为 <code class="inline">TaskObj</code> 使用了动态派发 （<code class="inline">trait object</code>），所以目前这里的堆分配是必须的。然而我们还有另一套用于 <code class="inline">no_std</code> 的 <code class="inline">unsafe</code> 的解决方案可以避免堆分配，有兴趣的读者可以在原文拉到最后了解一下。在不久的将来，在 Rust 支持在栈上存储 <code class="inline">dynamic size type(DST)</code> 的时候 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1909-unsized-rvalues.md">[Merged] RFC 1909:unsized-rvalues</a>，这里的 <code class="inline">TaskObj</code> 也会取消，取而代之的是栈上的 <code class="inline">Task</code>，这也是现在取个这么难听名字的原因。</p><p><br></p><h2><code class="inline">Wake</code> </h2><p>解决了 who 的问题，那还有 when 问题。我们让 ThreadPool 来负责重新 poll() ，那到底什么时候 poll() 呢？只有 socket 知道自己什么时候准备好，所以 socket 需要在准备好的时候 “通知” ThreadPool 重新 poll()。这个操作叫做 wake （唤醒），这意味着，我们要给 socket 提供通知 ThreadPool 的方法 —— 让 socket 拿着 Arc&lt;ThreadPool&gt;。完美。</p><p><br></p><p>为了让 <code class="inline">socket</code> 能够唤醒 <code class="inline">Executor</code>，标准库提供了 <code class="inline">Wake</code>。<code class="inline">socket</code> 只需握着 <code class="inline">Wake</code>，就能在准备好的时候调用 <code class="inline">wake()</code>，通知 <code class="inline">Executor</code> 该 <code class="inline">poll()</code>了。 下面是 <code class="inline">Wake</code> 的定义：</p><code lang="text">pub trait Wake: Send + Sync {
    fn wake(&amp;self);
}</code><p><br></p><p>但是实现 <code class="inline">Wake</code> 的可以是 <code class="inline">Executor</code> 自己吗？不可以。因为一个 <code class="inline">Executor</code> 上可能托管着成百上千的 <code class="inline">TaskObj</code>，直接 <code class="inline">wake()</code> 并不能告诉 <code class="inline">Executor</code> 究竟是哪个 <code class="inline">TaskObj</code> 需要 <code class="inline">poll()</code>。因此 <code class="inline">Executor</code> 会给每个 <code class="inline">TaskObj</code> 提供一个唯一标识，然后把这个标识和自己的引用计数指针打包装在一起，弄一个类似 <code class="inline">WakeHandler</code> 的玩意。</p><code lang="text">struct WakeHandler {
    exec: Arc&lt;ThreadPool&gt;,
    id: u64,
}

impl Wake for WakeHandler { .. }</code><p><br></p><p>所以这里 <code class="inline">Async</code> 在被第一次 <code class="inline">poll()</code> 的时候 <code class="inline">socket</code> 就会记下这个 <code class="inline">WakeHandler</code>（因为这里 <code class="inline">Async</code> 的实际类型是 <code class="inline">socket</code> 提供的），准备好后  <code class="inline">socket</code>  调用 <code class="inline">wake()</code>，<code class="inline">Excutor</code> 根据唯一标识找到对应的 <code class="inline">Async</code> 然后 <code class="inline">poll()</code>, <code class="inline">poll()</code> 就会从 <code class="inline">socket</code> 拿回完成的 <code class="inline">Poll::Ready(T)</code>。完美。</p><p><br></p><h2><code class="inline">Context</code> </h2><p>明白了 <code class="inline">Excutor</code> 和 <code class="inline">Wake</code> 之后，让我们回过头看看 <code class="inline">Async</code> 的函数签名：</p><code lang="text">fn poll(self: Pin&lt;Self&gt;, cx: &amp;mut task::Context) -&gt; Poll&lt;Self::Output&gt;;</code><p><br></p><p>我们看 <code class="inline">poll()</code> 的第二个参数: <code class="inline">task::Context</code>:</p><code lang="text">pub struct Context&lt;'a&gt; { .. }

impl&lt;'a&gt; Context&lt;'a&gt; {
    pub fn new(waker: &amp;'a Waker, executor: &amp;'a mut Executor) -&gt; Context&lt;'a&gt;;
    /// Get the `Waker` associated with the current task.
    pub fn waker(&amp;self) -&gt; &amp;Waker;
    /// Run an asynchronous computation to completion on the default executor.
    pub fn spawn(&amp;mut self, f: impl Async&lt;Output = ()&gt; + 'static + Send);
    /// Get the default executor associated with this task.
    pub fn executor(&amp;mut self) -&gt; &amp;mut BoxExecutor;
}</code><p><br></p><p><code class="inline">Context</code> 的主要工作十分明了：</p><p><br>-   提供 <code class="inline">Wake</code> <br>-   提供默认 <code class="inline">Excutor</code>。</p><p><br></p><p><code class="inline">spawn()</code> 是 <code class="inline">executor().spawn()</code> 的捷径（顺带一些错误处理）。</p><p><br></p><p>这里出现了 <code class="inline">Waker</code> 不是 <code class="inline">Wake</code>, <code class="inline">Waker</code> 又是一个这次标准库新加入的类型，里面装着 <code class="inline">Wake</code> trait object:</p><code lang="text">pub struct Waker {
    wake: &amp;Wake
}

impl Waker {
    pub fn wake(&amp;self) {
        self.wake.wake();
    }
}</code><p><br></p><h2><code class="inline">Pin</code> </h2><p><code class="inline">Pin</code> 类型不在本篇 RFC 范围之内，而且展开了说篇幅会非常的长，有兴趣的话可以前去 RFC 阅读，或者看看 <code class="inline">@withoutboat</code> 关于 <code class="inline"><i>borrow across yield point</i></code> 的长篇系列，那里详细地解释了设计上遇到了什么难点，以及为什么一定要引入 <code class="inline">Pin</code> 概念。</p><p><br></p><p><a href="https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md">RFC: 2349-pin</a></p><p><a href="https://boats.gitlab.io/blog/post/2018-01-25-async-i-self-referential-structs/">Async/Await I: Self-Referential Structs</a></p><p><br></p><p>目前在这篇 RFC 中，我们只需要知道 Pin 是什么就足够了。简单来说，一般的类型自动实现 <code class="inline">Unpin</code>，而有些特殊的的类型会反向实现 <code class="inline">!Unpin</code>，这样特殊的类型在被装进 <code class="inline">Pin&lt;T&gt;</code> 之后就不能再移动了(immovable type)。异步函数返回类型也正是这种特殊类型。</p><p><br></p><p><code class="inline">Pin&lt;T&gt;</code> 是指针类型，提供比 <code class="inline">&amp;mut T</code> 更严格的规则：</p><p><br></p><ul><li><code class="inline">Pin&lt;T: Unpin&gt;</code> 和普通 <code class="inline">&amp;mut T</code> 完全一样。</li><li><code class="inline">Pin&lt;T: !Unpin&gt;</code> 只提供 <code class="inline">Deref&lt;&amp;T&gt;</code>，以防止 T 被移动 (mem::replace())。</li></ul><p><br></p><p>我们来明确一下:</p><p><br></p><ul><li><code class="inline">Future</code>: <code class="inline">Unpin</code> </li><li>async fn 返回的 <code class="inline">impl Async</code>: <code class="inline">!Unpin</code> </li><li><code class="inline">Box&lt;Async&gt;</code>: <code class="inline">Unpin</code></li></ul><p><br></p><h2>Conclusion</h2><p>这篇文章介绍了标准库中加入的 <code class="inline">Async</code> 和任务类型，通过这些类型的加入，我们可以方便地定义自己的事件循环或者使用现成的库来驱动异步任务。文章并没有涵盖用于 <code class="inline">no_std</code> 环境的类型和解决方案，有兴趣的读者需要自己去阅读一下 RFC。</p><p><br></p><p>下一篇文章可能会讲 <code class="inline">Pin</code> 类型和关于 Rust <code class="inline">immovable type</code> 的故事，但是这玩意讲起来比裹脚布还长，到时懒起来分分钟就跳票了。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
