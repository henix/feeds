<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>从计算复杂度往上往前（和两个没什么卵用的定理）</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/32476294">原文</a></p>
<p><b>在P和NP出现之前计算复杂性是怎么度量的？</b></p><p>SPACE(f(n))，TIME(f(n))……这是在Scott Aaronson在<a href="https://www.scottaaronson.com/democritus/">《Quantum Computing Since Democritus》</a>中PaleoComplexity一章里面所给出的答案。再翻翻其它的书，我们会得到的答案是，P=DTIME(n^c)。EXP=DTIME(2^(n^c))。（DTIME的意思是对于确定性图灵机的时间，Deterministic）NP的定义是“被非确定图灵机（Non-Deterministic）在多项式时间内解决的问题”，所以是NTIME(n^c)。</p><p>所以这真的就是Complexity的源头嘛？那么Complexity和Recursion Theory之间的关系究竟是什么呢？</p><p>这篇文章很短，因为我看书的速度比我打字的速度要快很多，所以我想偷懒（逃）不想写那么多；以及深觉文笔乏力，光看着一堆证明过程就已经觉得很爽很发光。</p><p>怀着很憋屈又很尊敬的心情去读书，书中的定理自然是不止那么多，很想安利人来入坑，对，这篇文章是一篇很憋屈很憋屈的安利文_(:з」∠)_</p><p>－－－－－－－－</p><h2><a href="https://en.wikipedia.org/wiki/Blum_axioms">Blum公理</a>和<a href="http://port70.net/~nsz/articles/classic/blum_complexity_1976.pdf">计算复杂性的尺度</a></h2><p><equation>\{\varphi_i\}</equation> 是所有的<a href="https://en.wikipedia.org/wiki/%CE%9C-recursive_function">递归函数</a>（以及mu是一个<a href="https://en.wikipedia.org/wiki/Theory_of_descriptions">摹状词</a>）的枚举，其中i是第i个递归函数所对应的编号（对应到图灵机上就是哥德尔编号i所对应的图灵机）， <equation>\{\Phi_i\}</equation> 是一组递归函数的序列。称 <equation>\Phi</equation> 是计算复杂性的尺度（意味着计算复杂性尺度也是一个函数），当且仅当以下两个条件被满足：</p><ol><li><equation>\varphi_i(x)</equation> 有值当且仅当 <equation>\Phi_i(x)</equation> 有值；</li><li>特征函数K是一个完全递归函数： <equation>K(i, x, y) = \begin{equation} \left\{ \begin{array}{lr} 1 &amp; \Phi_i(x) = y,\\ 0 &amp; otherwise(例如无定义) \end{array} \right. \end{equation} </equation> </li></ol><p>所以来看看所谓的<b>时间复杂度</b>是怎么对应上来的嘛？</p><p><equation>T_i(x) = \begin{equation} \left\{ \begin{array}{lr} y &amp; 多带图灵机\varphi_i(x)有值且计算步数为y,\\ undefined &amp; otherwise \end{array} \right. \end{equation} </equation> </p><a href="https://en.wikipedia.org/wiki/Multitape_Turing_machine" data-draft-node="block" data-draft-type="link-card">Multitape Turing Machine</a><blockquote>（问：证明这个“尺度”是一个<a href="https://en.wikipedia.org/wiki/Partial_function">完全递归函数</a>，如果追求更完整的话，证明存在一个K与这个尺度对应）<br>（Extra Credit：证明<b>量子计算机</b>的时间复杂度类是存在合法尺度的）</blockquote><p>那么<b>空间复杂度</b>呢？</p><p><equation>T_i(x) = \begin{equation} \left\{ \begin{array}{lr} y &amp; 脱线图灵机\varphi_i(x)有值且工作区使用的格子数为y,\\ undefined &amp; otherwise \end{array} \right. \end{equation} </equation> </p><blockquote>（问：同上）</blockquote><h2>计算复杂度尺度的一些性质</h2><p><b>为什么“如果计算不会太复杂的话，函数的值就不会太大”</b></p><p>定理：存在完全递归函数h，使得 <equation>\forall i \ h(x, \Phi_i(x) \ge \varphi_i(x))\ a.e.(almost\ everywhere)</equation> 。</p><p>证明：令</p><p><equation>H(i, x, y) = \begin{equation} \left\{ \begin{array}{lr} \varphi_i(x) &amp; \Phi_i(x) = y\\ 1 &amp; otherwise \end{array} \right. \end{equation} </equation> ，</p><p>又令</p><p><equation>h(x, y) = \mathop{max}_{i \le x}H(i, x, y)</equation>，</p><p>则按照<a href="https://en.wikipedia.org/wiki/Primitive_recursive_function">原始递归函数</a>的定义，这两个函数都是完全递归函数。令 <equation>x \ge i</equation> 且<equation>\varphi_i(x)</equation> 定义，则 <equation>h(x, \Phi_i(x)) \ge H(i, x, \Phi_i(x)) = \varphi_i(x)</equation> 。</p><p><b>为什么“一个算法可以有任意复杂（而非简单）的算法”</b></p><p>定理：f、h为两个完全递归函数。则存在f的号码（如哥德尔编号或者康托尔的配对编号）使得 <equation>\Phi_j(x) \ge h(x)</equation> 。f的号码的意思是计算函数f的图灵机。</p><p>证明：令</p><p><equation>g(i, x) = \begin{equation} \left\{ \begin{array}{lr} f(x) &amp; \Phi_i(x) &gt; h(x)\\ 1 + \varphi_i(x) &amp; otherwise \end{array} \right. \end{equation} </equation> ，</p><p>则g是递归函数。那么，存在这样的函数q，使得：</p><p><equation>\begin{equation} \varphi_{q(i)}(x)\xlongequal{s-m-n定理}g(i, x) \end{equation}</equation> ；</p><p><a href="https://en.wikipedia.org/wiki/Smn_theorem">s-m-n定理</a>还有一个名字，叫做参数化定理。接下来，又由<a href="https://en.wikipedia.org/wiki/Kleene%27s_recursion_theorem">递归定理</a>，存在编号j使得 <equation>\varphi_{q(j)}(x)＝\varphi_{j}(x)</equation> ，所以有</p><p><equation>g(j, x) = \varphi_j(x) \ne 1+\varphi_j(x)</equation> ，因此不可能有 <equation>\Phi_i(x) \le h(x)</equation> ，因此j是f的号码。没错，到头回来，又是万恶的<a href="https://en.wikipedia.org/wiki/Diagonal_method">对角线</a>。</p><blockquote>为什么两个定理不矛盾<br>（答案：...）</blockquote><p>－－－－－－－－</p><p>最后，真的以为计算复杂性的源头就到此为止了吗？</p><p>或许还会有下次更新以让这篇文章没有那么寒酸。。。</p><p>（嗷嗷嗷嗷嗷嗷嗷呜啊_(:з」∠)_）</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
