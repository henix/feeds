<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Do not claim, show me the proof：记一个困扰了我小一年的问题</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/22166332">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/2b0990c19b7cb65a19f593ccd1d3b07e_r.jpg" alt=""></div><h2>题注<br></h2><br>更新：密码学交流群的朋友们说，更快速的方法是利用FFT，而且还可以并行加速。因为本质上我们计算的是卷积结果，FFT后到做乘法即可。才疏学浅，拜服！<br><br><blockquote>Do not claim, show me the proof.<br></blockquote><p>这是我和知乎密码学交流群共同的群主<a href="https://www.zhihu.com/people/9cec268fa4cf3647f54f57703f8cc3d8" data-hash="9cec268fa4cf3647f54f57703f8cc3d8" class="member_mention" data-editable="true" data-title="@玄星" data-hovercard="p$b$9cec268fa4cf3647f54f57703f8cc3d8">@玄星</a>同学日常交流时，他常常提到的一句话。在本篇专栏中，我也想把这句话送给所有做密码学，乃至其他数学或计算机科学相关的朋友们。很多时候，所看到的问题并没有想象的那么简单。</p><p>当然了，我这个问题可能根本就不难，可能好多人都知道，我比较白痴了？但我确实是不知道… 而且我咨询了很多周围的人，大家也都不知道。因此，看起来这确实是一个似乎很简单，但解决起来却没那么轻松的问题，特别适合证明<a href="https://www.zhihu.com/people/9cec268fa4cf3647f54f57703f8cc3d8" data-hash="9cec268fa4cf3647f54f57703f8cc3d8" class="member_mention" data-hovercard="p$b$9cec268fa4cf3647f54f57703f8cc3d8" data-editable="true" data-title="@玄星">@玄星</a>同学态度的好问题。因此我这里也想把这个问题分享给大家。</p><p>本篇专栏还要特别感谢一个人，就是我实验室的师弟<a href="https://www.zhihu.com/people/hai-wen-57" data-editable="true" data-title="海文" class="">海文</a>同学。我是在一次很偶然的机会中和他讨论了这个问题，当时我们也都没有想到一个比较好的解决方法。不曾想，<a href="https://www.zhihu.com/people/hai-wen-57" data-editable="true" data-title="海文">海文</a>同学把这个问题一直留在了脑海中，并在阅读论文的过程中不断寻找问题的答案。直到上周五，<a href="https://www.zhihu.com/people/hai-wen-57" data-editable="true" data-title="海文">海文</a>同学终于兴高采烈的告诉我，他在一个论文中找到了这个问题的解决方法！至此，这个困扰了我将近一年的问题终于在<a href="https://www.zhihu.com/people/hai-wen-57" data-editable="true" data-title="海文" class="">海文</a>同学的帮助下得到了解决~ 特别感谢<a href="https://www.zhihu.com/people/hai-wen-57" data-editable="true" data-title="海文">海文</a>同学长时间以来的努力。因此，我也希望在我的专栏中向关注我动向的朋友们推荐这个将要入学读研究生，来自数学学院的小伙子，未来主要做Lattice-Based Cryptography以及Fully Homomorphic Encryption。相信经过未来几年的锤炼，他一定至少可以超过我，成为年轻一代应用密码学的杰出人才。各位业界的大佬们，求关注他哈~</p><p>本专栏文章的相关代码已经同步到我的CloudCrypto密码学函数库中：<a href="https://github.com/liuweiran900217/CloudCrypto" data-editable="true" data-title="GitHub - liuweiran900217/CloudCrypto: A library for cryptographic primitive implementations for Cloud Storage applications." class="">GitHub - liuweiran900217/CloudCrypto: A library for cryptographic primitive implementations for Cloud Storage applications.</a>。相关代数问题解决方法的核心代码位于：</p><code lang="text">src/main/java/cn/edu/buaa/crypto/algebra/HornerRule.java
</code><p>对应密码学原语实现的核心代码位于：</p><code lang="text">src/main/java/cn/edu/buaa/crypto/encryption/ibbe/del07</code><p>对应密码学原语的使用例子位于：</p><code lang="text">src/test/java/com/example/encryption/ibbe</code><p>如果有需要代码的朋友，请自行浏览或下载上述代码。如果觉得我写的能读，恳请留个star，让更多需要的朋友们看见，没准可以帮助他们解决更多的问题呢？</p><p>题图来自：<a href="http://pic.baike.soso.com/p/20140430/20140430141100-761898745.jpg" data-editable="true" data-title="soso.com 的页面">http://pic.baike.soso.com/p/20140430/20140430141100-761898745.jpg</a>。其他图片为本人自绘。</p><h2>背景</h2><p>先来回顾一下所遇到问题的背景。这部分属于现代密码学的科普，如果觉得不太好理解的话可以跳过… 如果试着理解一下的话，有助于了解问题是如何引入的。不过，这部分内容不可避免地有不少公式，看着会令人头大…</p><p>早在2014年，我在导师的指导下开始着手构造一个被称为分层基于身份的广播加密（Hierarchical Identity-Based Broadcast Encryption，HIBBE）[1,2]。从这个密码学原语的名字上就可以看出，想构造这个密码学原语，肯定要参考诸如基于身份的加密（Identity-Based Encryption，IBE）[3,4]、广播加密（Broadcast Encryption，BE）[5,6]、分层基于身份的加密（Hierarchical Identity-Based Encryption，HIBE）[7,8]，以及基于身份的广播加密（Identity-Based Broadcast Encryption，IBBE）[9]。</p><p>前面所有的密码学原语都还好说，但这最后一个IBBE理解起来可是让我犯了难，因为这个方案的构造中用到了一个看起来特别简单，但是细想起来缺觉得无从下手的问题。而正是这个问题，使得我一直无法正确实现IBBE方案。无法实现IBBE的话，那我的Crypto库岂不是有很多遗憾了…</p><p>在阐述遇到的核心问题之前，我们先来简单聊聊什么叫做IBBE。朋友们最熟知的公钥加密体制是RSA了。RSA允许接收方运行密钥生成算法（Key Generation，KeyGen）生成一个公钥（Public Key，PK）和一个私钥（Secret Key，SK）。接收方把公钥公开，这样任何人都可以用公钥加密（Encrypt），只有拥有私钥的接收方才能够解密（Decrypt）。现在我们把这个问题扩展一下：如果接收方不止有1个人，而是有好多好多人，如何<b>同时</b>给他们发送加密信息呢？</p><p>最简单的方法是按照下图所示，每个人都公开自己的公钥，加密时候用不同的公钥给不同的人加密。这种方法最大的缺点是，加密结果的长度，也就是密文（Ciphertext，CT）长度和接收者人数相关，接收者人数越多，密文长度越长。如果团体人数过多的话，这种方法的效率就不太高了。</p><img src="https://pic1.zhimg.com/1b40551f9c6da52ac2c7f7e19590e742_r.jpg" data-rawwidth="866" data-rawheight="548"><p>解决这个问题的方法是引入BE的概念。在BE中，接收方组成一个小群体。我们找一个可信第三方（一般叫做Dealer），由它来生成公钥，并且给小群体中的每个人发送不同的私钥。发送方此时只运行一次加密算法，然后把这一份密文同时发送给所有人。如果密文长度和接收者人数数量无关，或者说密文长度为常数的话，就可以一次给很多很多人发送加密信息，大大降低通信的开销。同时，广播加密进一步可以选择接收者人数。比如我的加密信息可以只允许编号为1、3、5的用户解密，那么编号为2、4等的其他用户虽然也有自己的私钥，但即使它们联合起来也无法解密信息。这种加密方法在有线电视信号、音视频信息订阅中有着广泛的应用。</p><p><img src="https://pic1.zhimg.com/2938212e08375f022a1a703fcbfdd1c7_r.jpg" data-rawwidth="1089" data-rawheight="548">BE看起来已经足够好了，但是还有问题：因为群体中每个人有一个编号，发送者进行加密时需要知道群体中每个人的编号对应的是多少。但用编号标示一个人多么不方便啊。最好的方法是，每个人的编号是一个有意义的字符串，比如这个人的名字，这个人的邮箱什么的。不过，有意义的字符串的情况个数太多了，我们这时候让Dealer事先执行Setup算法，产生公钥和一个称为主私钥（Master Secret Key，MSK）的东西。每一个用户加入群体的时候，就用自己的名字什么的向Dealer申请私钥。这时候，Dealer运行KeyGen算法，用主私钥生成各个用户对应的私钥。加密的时候，发送方利用公钥，和每个人的名字作为参数运行加密算法。这就是IBBE的概念了。有关IBBE的具体内容，可以看看我在《密码学报》灌水的一篇论文《选择密文安全的基于身份的广播加密方案》（<a href="http://www.jcr.cacrnet.org.cn:8080/mmxb/EN/article/downloadArticleFile.do?attachType=PDF&amp;id=74" data-editable="true" data-title="cacrnet.org.cn 的页面" class="">http://www.jcr.cacrnet.org.cn:8080/mmxb/EN/article/downloadArticleFile.do?attachType=PDF&amp;id=74</a>），这是个中文论文，写的更系统一些。</p><img src="https://pic4.zhimg.com/36a7df997ec579629ed84482f9386c2a_r.jpg" data-rawwidth="1095" data-rawheight="581"><p>由于我们可以在有意义的字符串中增加诸如时间信息、次数信息等等有意义的信息，因此IBBE天生也带有<b>撤销</b>的功能。举个例子，Dealer可以要求每个申请私钥的人拿到的都是“姓名+日期”所对应的私钥，比如Alice拿到的是"Alice20160805"所对应的私钥。第二天，加密所用的信息统一变成"Alice20160806"，这样一来，前面一天的私钥就作废了。</p><p>这么一看，IBBE的功能简直强大的不要不要的。2007年，Cécile Delerablée基于双线性群（Bilinear Group）构造了第一个IBBE方案。朋友们也不用太纠结双线性群是什么，简单来说就是，这个东西涉及到3个代数群：<equation>\mathbb{G}_1,\mathbb{G}_2,\mathbb{G}_T</equation>，还有一个函数<equation>e(\cdot,\cdot):\mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T</equation>就好了。我们着重来看看这个方案的构造。这里我们只回顾Setup算法和Encrypt算法就够了。方案的构造沿用我自己《密码学报》论文的描述。</p><ul><li><equation>(PK,MSK) \leftarrow \textsf{Setup}(\lambda, m)</equation>。首先生成一个满足安全常数<equation>\lambda \in \mathbb{N}</equation>的双线性群<equation>(p, \mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T, e)</equation>。随后，算法随机选择元素<equation>g \overset{R}{\leftarrow} \mathbb{G}_1</equation>，<equation>h\overset{R}{\leftarrow} \mathbb{G}_2</equation>，<equation>\gamma \overset{R}{\leftarrow} \mathbb{Z}_p</equation>，并选择一个安全的哈希函数<equation>H:\{0,1\}^* \rightarrow \mathbb{Z}_p</equation>。主私钥为<equation>MSK=(g,\gamma)</equation>，公钥为<equation>PK=\left(w,v,h,h^{\gamma}, \ldots, h^{\gamma^m}\right)=\left(g^{\gamma}, e(g, h), h,h^{\gamma}, \ldots, h^{\gamma^m}\right)</equation>。<br></li><li><equation>(CT,K)\leftarrow \textsf{Encrypt}(PK,S)</equation>。给定公钥PK以及广播身份集合<equation>S=\{ID_1, \cdots, ID_s\}</equation>，其中<equation>s \leq m</equation>,加密算法随机选择<equation>k\overset{R}{\leftarrow}\mathbb{Z}_p</equation>，计算密文为<equation>C_1 = w^{-k}</equation>，<equation>C_2=h^{k \cdot \prod_{i=1}^{s}(\gamma + H(ID_i))}</equation>。封装的会话密钥为<equation>K=v^k</equation>。<br></li></ul><p>好了，看到这里我想问个问题：<b><equation>C_2</equation>怎么求？</b>这里面有两个比较坑的地方。</p><p>有的朋友说了，这不简单嘛，所有的参数都给出了，直接求就可以了啊。这就是第一个比较坑的地方。在加密算法中，我们是不知道<equation>\gamma</equation>具体值的。因此，h指数上面的东西似乎求不了？怎么办呢？</p><p><b><u>如果你看到这里没有想明白这个问题，请暂停一下，想明白以后再继续往下看。</u></b></p><p>如果你想明白了这个问题，那么你一定会为<equation>\prod_{i=1}^{s}(\gamma + H(ID_i))</equation>的展开式发愁了。而一直困扰我的也就是这个问题了。</p><h2>问题</h2>我们把这个问题再一般化一点。实际上，我们要解决的问题是这个：<p><equation>x^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0 = \prod_{i=1}^{n}(x + b_i)</equation>，给定所有的<equation>b_i</equation>，求每一个<equation>a_i</equation>。这个问题看上去特别的简单，很像二项式展开啊有没有？的确，<equation>a_1</equation>和<equation>a_{n-1}</equation>的计算非常简单。然而，其他的似乎就没那么直观了，我们有：</p><p><equation>a_0=b_1b_2\cdots b_n=\prod_{i=1}^{n}b_i </equation>，</p><equation>a_1=b_2b_3 \ldots b_n + b_1b_3 \ldots b_n + \cdots + b_1b_2\ldots b_{n-1}</equation><br><p>...</p><p><equation>a_{n-1}=b_1 + b_2 + \cdots + b_n = \sum_{i=1}^{n}{b_i} </equation>。</p><p>实际上，上述这些多项式还有个名字，叫做基本对称多项式（Elementary Symmetric Polynomials，ESP）。基本对称多项式后在数学中的很多领域都得到了应用。然而，即使是维基百科（<a href="https://en.wikipedia.org/wiki/Elementary_symmetric_polynomial" class="" data-editable="true" data-title="Elementary symmetric polynomial">Elementary symmetric polynomial</a>）也没有提到这个多项式求值的方法。我们先不谈具体的算法。我们来分析一下：如果硬算的话，需要多少次加法运算和多少次乘法运算。</p><p>加法运算次数很容易得到。</p><br><ul><li><equation>a_0</equation>需要<equation>C_n^n-1=0</equation>次加法；<br></li><li><equation>a_1</equation>需要<equation>C_n^{n-1}-1=n-1</equation>次加法；<br></li><li>...</li><li><equation>a_i</equation>需要<equation>C_n^{n-i}-1</equation>次加法；</li></ul><p>因此加法运算总次数为：<equation>\sum_{i=0}^{n-1}{(C_n^{n-i}-1)}=2^{n} -n-1</equation>。</p><p>乘法运算次数也是类似的。</p><ul><li><equation>a_0</equation>需要<equation>C_n^0(n-1)=n-1</equation>次乘法；<br></li><li><equation>a_1</equation>需要<equation>C_n^1(n-2)=n(n-2)</equation>次乘法；<br></li><li>...</li><li><equation>a_i</equation>需要<equation>C_n^i(n-1-i)</equation>次乘法；<br></li></ul><p>因此乘法运算总次数为：<equation>\sum_{i=0}^{n-1}{C_n^{i}(n-1-i)} </equation>。</p><p>可以看到，即使是加法运算也已经是指数级的了，乘法运算次数甚至比加法运算还要多。<b>如果这是真的，就意味着IBBE方案随着广播用户数量的增加，算法的复杂度也将以指数级增长，因此这根本就不是一个高效的算法</b>。难道，AISACRYPT上的论文有这么明显的错误吗？是否存在一种高效的算法，可以让我们快速求解<equation>a_0,\ldots,a_{n-1}</equation>呢？</p><br><h2>解决</h2>这个问题我一直都没有找到有效的算法，直到上周五，<a href="https://www.zhihu.com/people/hai-wen-57" data-editable="true" data-title="海文" class="">海文</a>师弟说他在PKC 2010上的一篇论文的附录部分找到了这个算法[10]。由于师弟是做Fully Homomorphic Encryption（FHE）的，因此他会时常阅读相关的论文。一看论文的名字《Fully Homomorphic Encryption with Relatively Small Key and Ciphertext Size》就知道，这也是个FHE的论文了。<p>在论文[10]的第20页，作者提到了一句话：</p><blockquote>To compute the <equation>S</equation> symmetric polynomials on (the encryptions of) <equation>s_1</equation> bits we proceed in a recursive manner, essentially using Horner’s Rule to compute the last <equation>S+1</equation> coefficients of the product <equation>\prod_{i=1}^{s_1}{(b_i\cdot x + 1)} </equation>。</blockquote><p>这不正是我们要解决的问题吗！不过，所谓的Horner's Rule又是什么呢？这个所谓的Horner's Rule，又叫做秦九昭算法，是几百年前中国数学家秦九昭提出的一种多项式快速求值方法。19世纪，英国数学家William George Horner重新发现并提出了这个算法，所以才叫Horner's Rule。</p><p>Horner's Rule解决的问题是求解高次多项式<equation>f(x)=a_nx^n + a_{n-1}x^{n-1}+\cdots+a_1x+a_0</equation>在某个点<equation>x=x_0</equation>处值的快速算法。如果直接从多项式本身求<equation>x=x_0</equation>处值的话，很显然需要<equation>O(n)</equation>次加法和<equation>O(n^2)</equation>次乘法，速度很慢。Horner's Rule的方法利用了一个迭代关系：</p><equation>f(x)=a_0+x(a_1+x(a_2+\cdots+x(a_{n-1}+a_nx)))</equation><br><p>因此，我们可以依次可以从括号最里面开始进行迭代求值，即依次求</p><ul><equation>c_{n-1}=a_{n-1}+a_nx_0</equation><br><equation>c_{n-2}=a_{n-2}+a_{n-1}c_{n-1}</equation><br><li>...<br></li><equation>c_{1}=a_{1}+a_2c_2</equation><br><equation>c_{0}=a_{0}+a_1c_1</equation><br></ul><br><p>最后的<equation>c_0</equation>就是我们要求的<equation>f(x_0)</equation>。如果按照这种方式计算，只需要进行<equation>O(n)</equation>次加法和<equation>O(n)</equation>次乘法即可，大大降低了计算量。</p><br><br><p>Horner's Rule能够降低求解高次多项式的计算量的原因在于充分利用了迭代关系，那么，能否找到类似的迭代关系，从而解决我们的问题呢？实际上，基本对称多项式也有类似的关系。很容易可以看出，<equation>a_i</equation>是从n个<equation>b_j</equation>中依次保留n-i个<equation>b_j</equation>后相乘再相加的结果，因此我们称<equation>a_i</equation>是n元n-i次基本对称多项式，记为<equation>ESP(n, n-i)</equation>。对于n元k次基本对称多项式，其迭代关系如下：</p><equation>\[{ESP(n,k) = }\left\{ {\begin{array}{*{20}{c}}
  {ESP(n - 1,k) + {b_n}}&amp;{k = 1} \\ 
  {{b_n}ESP(n - 1,k - 1)}&amp;{n = k} \\ 
  {ESP(n - 1,k) + {b_n}ESP(n - 1,k - 1)}&amp;{n &gt; k} 
\end{array}} \right.\]</equation><br><p>看起来有点麻烦？我们用下面的图来描述就好了：</p><p><img src="https://pic4.zhimg.com/632f120bf907ea014c2cd4c5a92dab79_r.jpg" data-rawwidth="477" data-rawheight="209">每一个竖线代表一次加法，每一个斜线代表一次乘法，所乘的内容就是<equation>b_i</equation>了。而最后一行就是我们想得到的结果。图中可以清晰的看出，所需要的运算量为<equation>O(n^2)</equation>次加法和<equation>O(n^2)</equation>次乘法。原来，论文没有骗我们…</p><h2>实现</h2>有了迭代关系，代码的实现异常简单，直接看图说话即可：<code lang="java">/**
 * Created by Weiran Liu on 2016/8/22.
 *
 * Given coefficients of n fundamental polynomials, computes the coefficients of the extended n-degree polynomial.
 *
 * The algorithm is called Horner's Rule, or Qin Jiu Zhao algorithm.
 * The detailed algorithm is shown in the paper:
 * Nigel P. Smart, Frederik Vercauteren. Fully Homomorphic Encryption with Relatively Small Key and Ciphertext Sizes.
 * PKC 2010, pp. 420 - 443, 2010.
 *
 * @author Hanwen Feng &lt;A HREF="mailto:feng_hanwen@buaa.edu.cn"&gt; (feng_hanwen@buaa.edu.cn) &lt;/A&gt; and
 * Weiran Liu
 */
public class HornerRule {
    /**
     * Compute n coefficients for n-degree polynomials by given n elementary coefficients
     * @param elementaryCoefficient
     * @return n coefficients
     */
    public static Element[] ComputeEfficients(Pairing pairing, Element[] elementaryCoefficient) {
        int n = elementaryCoefficient.length;
        Element[] allCoefficients = new Element[n+1];
        //set a_{n} to be 1
        allCoefficients[n] = pairing.getZr().newOneElement().getImmutable();
        //set all other efficients to be initially zero
        for (int i = 0; i &lt; n; i++) {
            allCoefficients[i] = pairing.getZr().newZeroElement().getImmutable();
        }
        for (int k = 0; k &lt; n; k++) {
            for (int i = n - k - 1; i &lt; n - 1; i++) {
                allCoefficients[i] = allCoefficients[i].add(allCoefficients[i + 1].mulZn(elementaryCoefficient[k])).getImmutable();
            }
            allCoefficients[n-1] = allCoefficients[n-1].add(elementaryCoefficient[k]).getImmutable();
        }
        return allCoefficients;
    }
}
</code><h2>总结</h2><p>很多看起来很显然的东西，可能都经不起推敲。看似我们懂了，其实还是有很多不懂，甚至根本没有理解的地方。学习也好，工作也罢，还是知其然又知其所以然比较好。开始的时候真的要做到刨根问底，不要以讹传讹哦！</p><h2>参考文献</h2><p>[1] Weiran Liu, Jianwei Liu, Qianhong Wu, Bo Qin. Hierarchical Identity-Based Broadcast Encryption. ACISP 2014, pp. 242-257, 2014.</p><p>[2] Weiran Liu, Jianwei Liu, Qianhong Wu, Bo Qin, Yan Li. Practical Chosen-Ciphertext Secure Hierarchical Identity-Based Broadcast Encryption. International Journal of Information Security, 2016, 15(1): 35-50.</p><p>[3] Adi Shamir. Identity-Based Cryptosystems and Signature Schemes. CRYPTO 1984, pp. 47-53, 1984.</p><p>[4] Dan Boneh, Matt Franklin. Identity-Based Encryption from the Weil Pairing. CRYPTO 2001, pp. 213-229, 2001.</p><p>[5] Amos Fiat, Moni Naor. Broadcast Encryption. CRYPTO 1993, pp. 480-491, 1993.</p><p>[6] Dan Boneh, Craig Gentry, Brent Waters. Collusion Resistant Broadcast Encryption with Short Ciphertexts and Private Keys. CRYPTO 2005, pp. 258-275, 2005.</p><p>[7] Jeremy Horwitz, Ben Lynn. Towards Hierarchical Identity-Based Encryption. EUROCRYPT 2002, pp. 466-481, 2002.</p><p>[8] Craig Gentry, Alice Silverberg. Hierarchical ID-Based Cryptography. ASIACRYPT 2002, pp. 548-566, 2002.</p><p>[9] Cécile Delerablée. Identity-Based Broadcast Encryption with Constant Size Ciphertexts and Private Keys. ASIACRYPT 2007, pp. 200-215, 2007.</p><p>[10] Nigel P. Smart, Frederik Vercauteren. Fully Homomorphic Encryption with Relatively Small Key and Ciphertext Size. PKC 2010, pp. 420-443, 2010.</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
