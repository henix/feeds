<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>TiDB 源码阅读系列文章（二十一）基于规则的优化 II</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/52138596">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-180de02d6f7269fdf95e2294d895caf8_r.jpg" alt=""></div><blockquote>在 <a href="https://pingcap.com/blog-cn/tidb-source-code-reading-7/">TiDB 源码阅读系列文章（七）基于规则的优化</a> 一文中，我们介绍了几种 TiDB 中的逻辑优化规则，包括列剪裁，最大最小消除，投影消除，谓词下推和构建节点属性，本篇将继续介绍更多的优化规则：聚合消除、外连接消除和子查询优化。</blockquote><h2><b>聚合消除</b></h2><p>聚合消除会检查 SQL 查询中 <code class="inline">Group By</code> 语句所使用的列是否具有唯一性属性，如果满足，则会将执行计划中相应的 <code class="inline">LogicalAggregation</code> 算子替换为 <code class="inline">LogicalProjection</code> 算子。这里的逻辑是当聚合函数按照具有唯一性属性的一列或多列分组时，下层算子输出的每一行都是一个单独的分组，这时就可以将聚合函数展开成具体的参数列或者包含参数列的普通函数表达式，具体的代码实现在 <code class="inline"><a href="https://github.com/eurekaka/tidb/blob/logical_rules_reading/planner/core/rule_aggregation_elimination.go">rule_aggregation_elimination.go</a></code> 文件中。下面举一些具体的例子。</p><p>例一：</p><p>下面这个 Query 可以将聚合函数展开成列的查询：</p><code lang="text">select max(a) from t group by t.pk;</code><p>被等价地改写成：</p><code lang="text">select a from t;</code><p>例二：</p><p>下面这个 Query 可以将聚合函数展开为包含参数列的内置函数的查询：</p><code lang="text">select count(a) from t group by t.pk;</code><p>被等价地改写成：</p><code lang="text">select if(isnull(a), 0, 1) from t;</code><p>这里其实还可以做进一步的优化：如果列 <code class="inline">a</code> 具有 <code class="inline">Not Null</code> 的属性，那么可以将 <code class="inline">if(isnull(a), 0, 1)</code> 直接替换为常量 1（目前 TiDB 还没做这个优化，感兴趣的同学可以来贡献一个 PR）。</p><p>另外提一点，对于大部分聚合函数，参数的类型和返回结果的类型一般是不同的，所以在展开聚合函数的时候一般会在参数列上构造 cast 函数做类型转换，展开后的表达式会保存在作为替换 <code class="inline">LogicalAggregation</code> 算子的 <code class="inline">LogicalProjection</code> 算子中。</p><p>这个优化过程中，有一点非常关键，就是如何知道 <code class="inline">Group By</code> 使用的列是否满足唯一性属性，尤其是当聚合算子的下层节点不是 <code class="inline">DataSource</code> 的时候？我们在 <a href="https://pingcap.com/blog-cn/tidb-source-code-reading-7/">基于规则的优化</a> 一文中的“构建节点属性”章节提到过，执行计划中每个算子节点会维护这样一个信息：当前算子的输出会按照哪一列或者哪几列满足唯一性属性。因此，在聚合消除中，我们可以通过查看下层算子保存的这个信息，再结合 <code class="inline">Group By</code> 用到的列判断当前聚合算子是否可以被消除。</p><h2><b>外连接消除</b></h2><p>不同于 <a href="https://pingcap.com/blog-cn/tidb-source-code-reading-7/">基于规则的优化</a> 一文中“谓词下推”章节提到的将外连接转换为内连接，这里外连接消除指的是将整个连接操作从查询中移除。</p><p>外连接消除需要满足一定条件：</p><ul><li>条件 1 : <code class="inline">LogicalJoin</code> 的父亲算子只会用到 <code class="inline">LogicalJoin</code> 的 outer plan 所输出的列</li><li>条件 2 :</li><ul><li>条件 2.1 : <code class="inline">LogicalJoin</code> 中的 join key 在 inner plan 的输出结果中满足唯一性属性</li><li>条件 2.2 : <code class="inline">LogicalJoin</code> 的父亲算子会对输入的记录去重</li></ul></ul><p>条件 1 和条件 2 必须同时满足，但条件 2.1 和条件 2.2 只需满足一条即可。</p><p>满足条件 1 和 条件 2.1 的一个例子：</p><code lang="text">select t1.a from t1 left join t2 on t1.b = t2.pk;</code><p>可以被改写成：</p><code lang="text">select t1.a from t1;</code><p>满足条件 1 和条件 2.2 的一个例子：</p><code lang="text">select distinct(t1.a) from t1 left join t2 on t1.b = t2.b;</code><p>可以被改写成：</p><code lang="text">select distinct(t1.a) from t1;</code><p>具体的原理是，对于外连接，outer plan 的每一行记录肯定会在连接的结果集里出现一次或多次，当 outer plan 的行不能找到匹配时，或者只能找到一行匹配时，这行 outer plan 的记录在连接结果中只出现一次；当 outer plan 的行能找到多行匹配时，它会在连接结果中出现多次；那么如果 inner plan 在 join key 上满足唯一性属性，就不可能存在 outer plan 的行能够找到多行匹配，所以这时 outer plan 的每一行都会且仅会在连接结果中出现一次。同时，上层算子只需要 outer plan 的数据，那么外连接可以直接从查询中被去除掉。同理就可以很容易理解当上层算子只需要 outer plan 的去重后结果时，外连接也可以被消除。</p><p>这部分优化的具体代码实现在 <a href="https://github.com/eurekaka/tidb/blob/logical_rules_reading/planner/core/rule_join_elimination.go">rule_join_elimination.go</a> 文件中。</p><h2><b>子查询优化 / 去相关</b></h2><p>子查询分为非相关子查询和相关子查询，例如：</p><code lang="text">-- 非相关子查询
select * from t1 where t1.a &gt; (select t2.a from t2 limit 1);
-- 相关子查询
select * from t1 where t1.a &gt; (select t2.a from t2 where t2.b &gt; t1.b limit 1);</code><p>对于非相关子查询， TiDB 会在 <code class="inline">expressionRewriter</code> 的逻辑中做两类操作：</p><ul><li><b>子查询展开</b></li></ul><p>即直接执行子查询获得结果，再利用这个结果改写原本包含子查询的表达式；比如上述的非相关子查询，如果其返回的结果为一行记录 “1” ，那么整个查询会被改写为：</p><code lang="text">select * from t1 where t1.a &gt; 1;</code><p>详细的代码逻辑可以参考<a href="https://github.com/eurekaka/tidb/blob/logical_rules_reading/planner/core/expression_rewriter.go">expression_rewriter.go</a>中的<a href="https://github.com/eurekaka/tidb/blob/logical_rules_reading/planner/core/expression_rewriter.go#L685">handleScalarSubquery</a>和<a href="https://github.com/eurekaka/tidb/blob/logical_rules_reading/planner/core/expression_rewriter.go#L535">handleExistSubquery</a>函数。</p><ul><li><b>子查询转为 Join</b></li></ul><p>对于包含 IN (subquery) 的查询，比如：</p><code lang="text">select * from t1 where t1.a in (select t2.a from t2);</code><p>会被改写成：</p><code lang="text">select t1.* from t1 inner join (select distinct(t2.a) as a from t2) as sub on t1.a = sub.a;</code><p>如果 <code class="inline">t2.a</code> 满足唯一性属性，根据上面介绍的聚合消除规则，查询会被进一步改写成：</p><code lang="text">select t1.* from t1 inner join t2 on t1.a = t2.a;</code><p>这里选择将子查询转化为 inner join 的 inner plan 而不是执行子查询的原因是：以上述查询为例，子查询的结果集可能会很大，展开子查询需要一次性将 <code class="inline">t2</code> 的全部数据从 TiKV 返回到 TiDB 中缓存，并作为 <code class="inline">t1</code> 扫描的过滤条件；如果将子查询转化为 inner join 的 inner plan ，我们可以更灵活地对 <code class="inline">t2</code> 选择访问方式，比如我们可以对 join 选择 <code class="inline">IndexLookUpJoin</code> 实现方式，那么对于拿到的每一条 <code class="inline">t1</code> 表数据，我们只需拿 <code class="inline">t1.a</code> 作为 range 对 <code class="inline">t2</code> 做一次索引扫描，如果 <code class="inline">t1</code> 表很小，相比于展开子查询返回 <code class="inline">t2</code> 全部数据，我们可能总共只需要从 <code class="inline">t2</code> 返回很少的几条数据。</p><p>注意这个转换的结果不一定会比展开子查询更好，其具体情况会受 <code class="inline">t1</code> 表和 <code class="inline">t2</code> 表数据的影响，如果在上述查询中， <code class="inline">t1</code>表很大而 <code class="inline">t2</code> 表很小，那么展开子查询再对 <code class="inline">t1</code> 选择索引扫描可能才是最好的方案，所以现在有参数控制这个转化是否打开，详细的代码可以参考 <a href="https://github.com/eurekaka/tidb/blob/logical_rules_reading/planner/core/expression_rewriter.go">expression_rewriter.go</a> 中的 <a href="https://github.com/eurekaka/tidb/blob/logical_rules_reading/planner/core/expression_rewriter.go#L596">handleInSubquery</a> 函数。</p><ul><li><b>相关子查询</b></li></ul><p>对于相关子查询，TiDB 会在<code class="inline">expressionRewriter</code>中将整个包含相关子查询的表达式转化为<code class="inline">LogicalApply</code>算子。<code class="inline">LogicalApply</code>算子是一类特殊的<code class="inline">LogicalJoin</code>，特殊之处体现在执行逻辑上：对于 outer plan 返回的每一行记录，取出相关列的具体值传递给子查询，再执行根据子查询生成的 inner plan ，即<code class="inline">LogicalApply</code>在执行时只能选择类似 循环嵌套连接的方式，而普通的<code class="inline">LogicalJoin</code>则可以在物理优化阶段根据代价模型选择最合适的执行方式，包括<code class="inline">HashJoin</code>，<code class="inline">MergeJoin</code>和<code class="inline">IndexLookUpJoin</code>，理论上后者生成的物理执行计划一定会比前者更优，所以在逻辑优化阶段我们会检查是否可以应用“去相关”这一优化规则，试图将<code class="inline">LogicalApply</code>转化为等价的<code class="inline">LogicalJoin</code>。其核心思想是将<code class="inline">LogicalApply</code>的 inner plan 中包含相关列的那些算子提升到<code class="inline">LogicalApply</code>之中或之上，在算子提升后如果 inner plan 中不再包含任何的相关列，即不再引用任何 outer plan 中的列，那么<code class="inline">LogicalApply</code>就会被转换为普通的<code class="inline">LogicalJoin</code>，这部分代码逻辑实现在<a href="https://github.com/eurekaka/tidb/blob/logical_rules_reading/planner/core/rule_decorrelate.go">rule_decorrelate.go</a>文件中。</p><p>具体的算子提升方式分为以下几种情况：</p><p><b>1. inner plan 的根节点是<code class="inline">LogicalSelection</code></b> </p><p>则将其过滤条件添加到 <code class="inline">LogicalApply</code> 的 join condition 中，然后将该 <code class="inline">LogicalSelection</code> 从 inner plan 中删除，再递归地对 inner plan 提升算子。</p><p>以如下查询为例：</p><code lang="text">select * from t1 where t1.a in (select t2.a from t2 where t2.b = t1.b);</code><p>其生成的最初执行计划片段会是：</p><p><br></p><img src="https://pic2.zhimg.com/v2-a5982ed5121da2abdc05167506e48e09_r.jpg" data-caption="" data-size="normal" data-rawwidth="383" data-rawheight="277" data-watermark="watermark" data-original-src="v2-a5982ed5121da2abdc05167506e48e09" data-watermark-src="v2-8a2d9d63bd08f8d908fd93ad370a140d" data-private-watermark-src=""><p><code class="inline">LogicalSelection</code> 提升后会变成如下片段：</p><img src="https://pic2.zhimg.com/v2-62f3075f148145ff308de465a07ff53b_r.jpg" data-caption="" data-size="normal" data-rawwidth="404" data-rawheight="191" data-watermark="watermark" data-original-src="v2-62f3075f148145ff308de465a07ff53b" data-watermark-src="v2-62cff68b480f307f9001d16bba429797" data-private-watermark-src=""><p>到此 inner plan 中不再包含相关列，于是 <code class="inline">LogicalApply</code> 会被转换为如下 LogicalJoin ：</p><u><img src="https://pic1.zhimg.com/v2-22d5560a1d5a1513063c1083de52c887_r.jpg" data-caption="" data-size="normal" data-rawwidth="418" data-rawheight="202" data-watermark="watermark" data-original-src="v2-22d5560a1d5a1513063c1083de52c887" data-watermark-src="v2-7bb00d9abf4fffa883e0ca832215cc93" data-private-watermark-src=""></u><p><b>2.inner plan 的根节点是<code class="inline">LogicalMaxOneRow</code></b><br>即要求子查询最多输出一行记录，比如这个例子：</p><code lang="text">select *, (select t2.a from t2 where t2.pk = t1.a) from t1;</code><p>因为子查询出现在整个查询的投影项里，所以 <code class="inline">expressionRewriter</code> 在处理子查询时会对其生成的执行计划在根节点上加一个 <code class="inline">LogicalMaxOneRow</code> 限制最多产生一行记录，如果在执行时发现下层输出多于一行记录，则会报错。在这个例子中，子查询的过滤条件是 <code class="inline">t2</code> 表的主键上的等值条件，所以子查询肯定最多只会输出一行记录，而这个信息在“构建节点属性”这一步时会被发掘出来并记录在算子节点的 <code class="inline">MaxOneRow</code> 属性中，所以这里的 <code class="inline">LogicalMaxOneRow</code> 节点实际上是冗余的，于是我们可以将其从 inner plan 中移除，然后再递归地对 inner plan 做算子提升。</p><p><b>3.inner plan 的根节点是<code class="inline">LogicalProjection</code></b> </p><p>则首先将这个投影算子从 inner plan 中移除，再根据<code class="inline">LogicalApply</code>的连接类型判断是否需要在<code class="inline">LogicalApply</code>之上再加上一个<code class="inline">LogicalProjection</code>，具体来说是：对于非 semi-join 这一类的连接（包括 inner join 和 left join ），inner plan 的输出列会保留在<code class="inline">LogicalApply</code>的结果中，所以这个投影操作需要保留，反之则不需要。最后，再递归地对删除投影后的 inner plan 提升下层算子。</p><p><b>4.inner plan 的根节点是<code class="inline">LogicalAggregation</code></b> </p><p><b>a.</b>首先我们会检查这个聚合算子是否可以被提升到 <code class="inline">LogicalApply</code> 之上再执行。以如下查询为例：</p><code lang="text">select *, (select sum(t2.b) from t2 where t2.a = t1.pk) from t1;</code><p>其最初生成的执行计划片段会是：</p><img src="https://pic1.zhimg.com/v2-3a476443a3930e657a52023f7ec82983_r.jpg" data-caption="" data-size="normal" data-rawwidth="427" data-rawheight="414" data-watermark="watermark" data-original-src="v2-3a476443a3930e657a52023f7ec82983" data-watermark-src="v2-2f0771f0f6b99f56ef089d61c847b1e0" data-private-watermark-src=""><p>将聚合提升到 <code class="inline">LogicalApply</code> 后的执行计划片段会是：</p><img src="https://pic2.zhimg.com/v2-bcbb359b6fc8771c984fe21351e599bc_r.jpg" data-caption="" data-size="normal" data-rawwidth="385" data-rawheight="331" data-watermark="watermark" data-original-src="v2-bcbb359b6fc8771c984fe21351e599bc" data-watermark-src="v2-bab6573026a3946820f9e4b66b465ead" data-private-watermark-src=""><p>即先对 <code class="inline">t1</code> 和 <code class="inline">t2</code> 做连接，再在连接结果上按照 <code class="inline">t1.pk</code> 分组后做聚合。这里有两个关键变化：第一是不管提升前 <code class="inline">LogicalApply</code> 的连接类型是 inner join 还是 left join ，提升后必须被改为 left join ；第二是提升后的聚合新增了 <code class="inline">Group By</code> 的列，即要按照 outer plan 传进 inner plan 中的相关列做分组。这两个变化背后的原因都会在后面进行阐述。因为提升后 inner plan 不再包含相关列，去相关后最终生成的执行计划片段会是：</p><img src="https://pic1.zhimg.com/v2-3af11844da7786a930af425723d7ec90_r.jpg" data-caption="" data-size="normal" data-rawwidth="383" data-rawheight="343" data-watermark="watermark" data-original-src="v2-3af11844da7786a930af425723d7ec90" data-watermark-src="v2-c2e2c8792666624bcfe5ae7b5c39813c" data-private-watermark-src=""><p>聚合提升有很多限定条件：</p><ul><li><code class="inline">LogicalApply</code> 的连接类型必须是 inner join 或者 left join 。 <code class="inline">LogicalApply</code> 是根据相关子查询生成的，只可能有 3 类连接类型，除了 inner join 和 left join 外，第三类是 semi join （包括 <code class="inline">SemiJoin</code>，<code class="inline">LeftOuterSemiJoin</code>，<code class="inline">AntiSemiJoin</code>，<code class="inline">AntiLeftOuterSemiJoin</code>），具体可以参考 <code class="inline">expression_rewriter.go</code> 中的代码，限于篇幅在这里就不对此做展开了。对于 semi join 类型的 <code class="inline">LogicalApply</code> ，因为 inner plan 的输出列不会出现在连接的结果中，所以很容易理解我们无法将聚合算子提升到 <code class="inline">LogicalApply</code> 之上。</li><li><code class="inline">LogicalApply</code> 本身不能包含 join condition 。以上面给出的查询为例，可以看到聚合提升后会将子查询中包含相关列的过滤条件 (<code class="inline">t2.a = t1.pk</code>) 添加到 <code class="inline">LogicalApply</code> 的 join condition 中，如果 <code class="inline">LogicalApply</code> 本身存在 join condition ，那么聚合提升后聚合算子的输入（连接算子的输出）就会和在子查询中时聚合算子的输入不同，导致聚合算子结果不正确。</li><li>子查询中用到的相关列在 outer plan 输出里具有唯一性属性。以上面查询为例，如果 <code class="inline">t1.pk</code> 不满足唯一性，假设 <code class="inline">t1</code> 有两条记录满足 <code class="inline">t1.pk = 1</code>，<code class="inline">t2</code> 只有一条记录 <code class="inline">{ (t2.a: 1, t2.b: 2) }</code> ，那么该查询会输出两行结果 <code class="inline">{ (sum(t2.b): 2), (sum(t2.b): 2) }</code> ；但对于聚合提升后的执行计划，则会生成错误的一行结果<code class="inline">{ (sum(t2.b): 4) }</code>。当 <code class="inline">t1.pk</code> 满足唯一性后，每一行 outer plan 的记录都对应连接结果中的一个分组，所以其聚合结果会和在子查询中的聚合结果一致，这也解释了为什么聚合提升后需要按照 <code class="inline">t1.pk</code> 做分组。</li><li>聚合函数必须满足当输入为 <code class="inline">null</code> 时输出结果也一定是 <code class="inline">null</code> 。这是为了在子查询中没有匹配的特殊情况下保证结果的正确性，以上面查询为例，当 <code class="inline">t2</code> 表没有任何记录满足 <code class="inline">t2.a = t1.pk</code> 时，子查询中不管是什么聚合函数都会返回 <code class="inline">null</code> 结果，为了保留这种特殊情况，在聚合提升的同时， <code class="inline">LogicalApply</code> 的连接类型会被强制改为 left join（改之前可能是 inner join ），所以在这种没有匹配的情况下，<code class="inline">LogicalApply</code> 输出结果中 inner plan 部分会是 <code class="inline">null</code> ，而这个 <code class="inline">null</code> 会作为新添加的聚合算子的输入，为了和提升前结果一致，其结果也必须是 <code class="inline">null</code> 。</li></ul><p><b>b.</b>对于根据上述条件判定不能提升的聚合算子，我们再检查这个聚合算子的子节点是否为 <code class="inline">LogicalSelection</code> ，如果是，则将其从 inner plan 中移除并将过滤条件添加到 <code class="inline">LogicalApply</code> 的 join condition 中。这种情况下 <code class="inline">LogicalAggregation</code> 依然会被保留在 inner plan 中，但会将 <code class="inline">LogicalSelection</code> 过滤条件中涉及的 inner 表的列添加到聚合算子的 <code class="inline">Group By</code>中。比如对于查询：</p><code lang="text">select *, (select count(*) from t2 where t2.a = t1.a) from t1;</code><p>其生成的最初的执行计划片段会是：</p><img src="https://pic4.zhimg.com/v2-7036cbfd4a1bd928df9b68a82ae2c39d_r.jpg" data-caption="" data-size="normal" data-rawwidth="404" data-rawheight="402" data-watermark="watermark" data-original-src="v2-7036cbfd4a1bd928df9b68a82ae2c39d" data-watermark-src="v2-1436664d60cbe58ed392024ac79a0d9d" data-private-watermark-src=""><p>因为聚合函数是 <code class="inline">count(*)</code> ，不满足当输入为 <code class="inline">null</code> 时输出也为 <code class="inline">null</code> 的条件，所以它不能被提升到 <code class="inline">LogicalApply</code> 之上，但它可以被改写成：</p><img src="https://pic3.zhimg.com/v2-fff11f20b805a30654aa08f8351c1c3e_r.jpg" data-caption="" data-size="normal" data-rawwidth="429" data-rawheight="306" data-watermark="watermark" data-original-src="v2-fff11f20b805a30654aa08f8351c1c3e" data-watermark-src="v2-59380836f03d5ed5d926d7465b523973" data-private-watermark-src=""><p>注意 <code class="inline">LogicalAggregation</code> 的 <code class="inline">Group By</code> 新加了 <code class="inline">t2.a</code> ，这一步将原本的先做过滤再做聚合转换为了先按照 <code class="inline">t2.a</code> 分组做聚合，再将聚合结果与 <code class="inline">t1</code> 做连接。 <code class="inline">LogicalSelection</code> 提升后 inner plan 已经不再依赖 outer plan 的结果了，整个查询去相关后将会变为：</p><img src="https://pic2.zhimg.com/v2-eca50e9e7bf56e429defc6cf6a266a4c_r.jpg" data-caption="" data-size="normal" data-rawwidth="449" data-rawheight="325" data-watermark="watermark" data-original-src="v2-eca50e9e7bf56e429defc6cf6a266a4c" data-watermark-src="v2-0d186aabdcfc7d5ecfb758a6cb92d7d3" data-private-watermark-src=""><h2><b>总结</b></h2><p>这是基于规则优化的第二篇文章，后续我们还将介绍更多逻辑优化规则：聚合下推，TopN 下推和 Join Reorder 。</p><p><br></p><p>更多 TiDB 源码阅读系列文章：</p><a href="https://www.pingcap.com/blog-cn/#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB" data-draft-node="block" data-draft-type="link-card" data-image="v2-60ab5bd867c2434d70c957a02a2169e1" data-image-width="1200" data-image-height="1200" data-image-size="ipico">博客</a><p></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
