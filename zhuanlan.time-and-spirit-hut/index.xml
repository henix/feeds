<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>时光与精神小屋</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/</link>
<description>编程、读书、学习、境界提升</description>
<language>zh-cn</language>
<lastBuildDate>Wed, 16 Oct 2019 00:32:55 +0800</lastBuildDate>
<item>
<title>分享：如何在阅读Rust项目源码中学习</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2019-10-14-86352307.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/86352307&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1899a8ccbe3f918f6324a2082dcbd7af_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;今天做了一个Substrate相关的小分享，公开出来。&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;因为我平时也比较忙，昨天才选定了本次分享的主题，准备比较仓促，细节可能不是很充足，但分享的目的也是给大家提供一个学习的思路，更多的细节大家可以在平时学习中自行探索。&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以下正文，阅读时间10分钟左右。&lt;/p&gt;&lt;hr/&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d06e29975446c05851dc1aa61c7a6e16_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;846&quot; data-rawheight=&quot;628&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;846&quot; data-original=&quot;https://pic3.zhimg.com/v2-d06e29975446c05851dc1aa61c7a6e16_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d06e29975446c05851dc1aa61c7a6e16_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;846&quot; data-rawheight=&quot;628&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;846&quot; data-original=&quot;https://pic3.zhimg.com/v2-d06e29975446c05851dc1aa61c7a6e16_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d06e29975446c05851dc1aa61c7a6e16_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;今天我要分享的内容呢，是《如何在阅读Rust项目源码中学习》，一共分成两大部分内容。 &lt;/p&gt;&lt;p&gt;想要在阅读源码中学习，首先得学会如何阅读源码。然后才是在源码中学习。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d9c252192eba22f38d38e005bc68efff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;851&quot; data-rawheight=&quot;626&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;851&quot; data-original=&quot;https://pic4.zhimg.com/v2-d9c252192eba22f38d38e005bc68efff_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d9c252192eba22f38d38e005bc68efff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;851&quot; data-rawheight=&quot;626&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;851&quot; data-original=&quot;https://pic4.zhimg.com/v2-d9c252192eba22f38d38e005bc68efff_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d9c252192eba22f38d38e005bc68efff_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;那么如何阅读Rust项目源码呢？&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3712c5b528788e22187c07f4da082a29_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;840&quot; data-rawheight=&quot;532&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;840&quot; data-original=&quot;https://pic2.zhimg.com/v2-3712c5b528788e22187c07f4da082a29_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3712c5b528788e22187c07f4da082a29_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;840&quot; data-rawheight=&quot;532&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;840&quot; data-original=&quot;https://pic2.zhimg.com/v2-3712c5b528788e22187c07f4da082a29_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3712c5b528788e22187c07f4da082a29_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;其实阅读源码和读一本书是一样的。我们是如何阅读一本书的呢？&lt;/p&gt;&lt;p&gt;第一步，是找书。你选择一本书去学习，是因为你有一个学习目标。&lt;/p&gt;&lt;p&gt;所以，阅读源码也是一样的，先确定自己的学习小目标。&lt;/p&gt;&lt;p&gt;确定一个小目标，非常关键。 如果没有目标，就会迷失在纷繁复杂的代码里，只有确定了目标，你才能从源码中发现线索。&lt;/p&gt;&lt;p&gt;但确定了目标之后，我们还不能马上就陷入到细节中。我们在选择好一本书之后，第一眼要看它的目录和文前。 这样有助于我们从整体上来把握整本书的内容。&lt;/p&gt;&lt;p&gt;所以，第二步就是要从整体出发。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4572b4077ea97f4eee54865b623b34e6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;821&quot; data-rawheight=&quot;619&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;821&quot; data-original=&quot;https://pic3.zhimg.com/v2-4572b4077ea97f4eee54865b623b34e6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4572b4077ea97f4eee54865b623b34e6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;821&quot; data-rawheight=&quot;619&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;821&quot; data-original=&quot;https://pic3.zhimg.com/v2-4572b4077ea97f4eee54865b623b34e6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4572b4077ea97f4eee54865b623b34e6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那Rust项目源码的结构是什么呢？&lt;/p&gt;&lt;p&gt;首先肯定是它的包组织结构。&lt;/p&gt;&lt;p&gt;现代化的编程语言，要考虑到协作和开发效率，良好的包管理和模块化是必不可少的。Rust语言作为现代化的编程语言，自然全都包含了。但它最突出的其实就是包管理工具，Cargo。&lt;/p&gt;&lt;p&gt;Cargo其实已经突破了包管理工具，它其实已经算是一个工作流工具了。而Cargo管理的包，在rust里就叫crate，它是编译的最小单元。&lt;/p&gt;&lt;p&gt;要确定一个Rust开源项目代码写的好不好，首先要看它的组织结构，是不是按crate来划分的。像Substrate源码就划分的非常好，这样细粒度的划分也极大地提升了可读性。&lt;/p&gt;&lt;p&gt;所以，阅读一个Rust项目之前，先要了解Rust包管理、模块化等相关概念。关于Cargo的资料可以在&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//crates.io&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;crates.io&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;中找到详细的文档。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a255a0cf24472f102e4b4564d7d54abb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;832&quot; data-rawheight=&quot;574&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;832&quot; data-original=&quot;https://pic4.zhimg.com/v2-a255a0cf24472f102e4b4564d7d54abb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a255a0cf24472f102e4b4564d7d54abb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;832&quot; data-rawheight=&quot;574&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;832&quot; data-original=&quot;https://pic4.zhimg.com/v2-a255a0cf24472f102e4b4564d7d54abb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a255a0cf24472f102e4b4564d7d54abb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;一个项目的结构，除了最直观的模块组织结构之外，还有一个内在的结构，那就是抽象架构。&lt;/p&gt;&lt;p&gt;抽象架构是和程序想表达的业务思想相关联的。要分析一个项目的抽象架构，必须从两个方面着手：&lt;/p&gt;&lt;p&gt;1. 业务/领域知识&lt;/p&gt;&lt;p&gt;2. 所用语言的抽象工具。在Rust里呢，就是trait、泛型和结构体、枚举&lt;/p&gt;&lt;p&gt;所以，在阅读源码之前，先得对这两方面的知识有所了解。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d8e8d2427e4ba0681d1018db2dab17b4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;821&quot; data-rawheight=&quot;543&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;821&quot; data-original=&quot;https://pic1.zhimg.com/v2-d8e8d2427e4ba0681d1018db2dab17b4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d8e8d2427e4ba0681d1018db2dab17b4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;821&quot; data-rawheight=&quot;543&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;821&quot; data-original=&quot;https://pic1.zhimg.com/v2-d8e8d2427e4ba0681d1018db2dab17b4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d8e8d2427e4ba0681d1018db2dab17b4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那么接下来，我们以substrate-network为例来实践一下上面的方法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97907bba515dae56a5080673106cec4e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;810&quot; data-rawheight=&quot;506&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;810&quot; data-original=&quot;https://pic3.zhimg.com/v2-97907bba515dae56a5080673106cec4e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97907bba515dae56a5080673106cec4e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;810&quot; data-rawheight=&quot;506&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;810&quot; data-original=&quot;https://pic3.zhimg.com/v2-97907bba515dae56a5080673106cec4e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97907bba515dae56a5080673106cec4e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先，我们来确定一个小目标。 &lt;/p&gt;&lt;p&gt;需要了解如何使用substrate框架写上层的应用，有很多资料，包括一块链习这个课程。但是如果要写更复杂的项目，就需要往深入探索。&lt;/p&gt;&lt;p&gt;拿我自己来说，我对libp2p就比较好奇。有人说，libp2p是未来的web协议，虽然这话有点夸张，但也说明了一个趋势。十多年前，我刚开始学习网络相关内容的时候，接触的是C/S结构，但是现在，网络已经开始向去中心化迁移，分布式对等网络很难说不会成为主流。所以我对libp2p比较感兴趣。&lt;/p&gt;&lt;p&gt;但是在深入libp2p之前，我想知道它是如何使用的，所以，substrate的network crate正好是一个起点。&lt;/p&gt;&lt;p&gt;那么就定了这个小目标：想要通过阅读network crate来了解libp2p。 &lt;/p&gt;&lt;p&gt;正好趁这次分享的机会，来了解下libp2p。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ae85bc4e2d15fe6f4bc7a073ef843c62_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;835&quot; data-rawheight=&quot;594&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;835&quot; data-original=&quot;https://pic3.zhimg.com/v2-ae85bc4e2d15fe6f4bc7a073ef843c62_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ae85bc4e2d15fe6f4bc7a073ef843c62_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;835&quot; data-rawheight=&quot;594&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;835&quot; data-original=&quot;https://pic3.zhimg.com/v2-ae85bc4e2d15fe6f4bc7a073ef843c62_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ae85bc4e2d15fe6f4bc7a073ef843c62_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在确定了小目标之后，我们就来观察一下具体的代码组织结构了。先来看看substrate整个项目的组织结构。&lt;/p&gt;&lt;p&gt;首先它是一个大的workspace，也就是说，它包含了很多的子crate。这是非常好的代码组织习惯，不愧是substrate。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c056d6ceb89e94154746136871f1f700_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;841&quot; data-rawheight=&quot;634&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;841&quot; data-original=&quot;https://pic1.zhimg.com/v2-c056d6ceb89e94154746136871f1f700_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c056d6ceb89e94154746136871f1f700_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;841&quot; data-rawheight=&quot;634&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;841&quot; data-original=&quot;https://pic1.zhimg.com/v2-c056d6ceb89e94154746136871f1f700_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c056d6ceb89e94154746136871f1f700_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接下来打开 core/network 的目录，可以看到，代码量其实不是很多。这就是划分为子crate的好处，让阅读代码的人，不会感到有太大压力。&lt;/p&gt;&lt;p&gt;通过Cargo.toml可以看得出来，这个库里依赖了哪些重要的库。libp2p是最基本的，最常用的serde序列化反序列化库，还有futures库，表示其代码里用到了异步功能，看版本是0.3，说明使用了Rust最新的异步语法。&lt;/p&gt;&lt;p&gt;通过这些初步的信息可以给我们留下一个整体的印象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-264f4cfbf9614de5925dc1c7bc2a3366_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;804&quot; data-rawheight=&quot;532&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;804&quot; data-original=&quot;https://pic3.zhimg.com/v2-264f4cfbf9614de5925dc1c7bc2a3366_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-264f4cfbf9614de5925dc1c7bc2a3366_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;804&quot; data-rawheight=&quot;532&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;804&quot; data-original=&quot;https://pic3.zhimg.com/v2-264f4cfbf9614de5925dc1c7bc2a3366_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-264f4cfbf9614de5925dc1c7bc2a3366_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接下来我们需要了解这个库的抽象架构。&lt;/p&gt;&lt;p&gt;抽象架构离不开业务领域知识。所以我们需要先去了解业务相关的知识，这里就不多说了，我们已经知道network库是substrate的底层网络组件，区块节点之间的通信和交易都将由它来提供底层的网络服务，包括交易池。&lt;/p&gt;&lt;p&gt;network是严重依赖于libp2p实现的。当然，这也是我选择这个库的原因，正好学习一下libp2p的用法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cb2fef90232a05cc6d24f5ec96e5c773_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;832&quot; data-rawheight=&quot;545&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;832&quot; data-original=&quot;https://pic4.zhimg.com/v2-cb2fef90232a05cc6d24f5ec96e5c773_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cb2fef90232a05cc6d24f5ec96e5c773_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;832&quot; data-rawheight=&quot;545&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;832&quot; data-original=&quot;https://pic4.zhimg.com/v2-cb2fef90232a05cc6d24f5ec96e5c773_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-cb2fef90232a05cc6d24f5ec96e5c773_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接下来要看看trait和结构体。&lt;/p&gt;&lt;p&gt;在Rust里，trait可以说是灵魂般的存在，它是抽象的基石。trait可以作为接口，也可以作为类型的限定，但我把它统一看作是一种「行为的抽象」。&lt;/p&gt;&lt;p&gt;而结构体，则是实体的抽象。&lt;/p&gt;&lt;p&gt;实体和行为，构成了这个世界。以这种视角来看待源码，理解起来更容易一些。&lt;/p&gt;&lt;p&gt;然后我们可以直接打开这个包的文档来看具体的结构体和trait。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1bf70209a9d15985f7c1ca155958d035_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;853&quot; data-rawheight=&quot;610&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;853&quot; data-original=&quot;https://pic2.zhimg.com/v2-1bf70209a9d15985f7c1ca155958d035_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1bf70209a9d15985f7c1ca155958d035_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;853&quot; data-rawheight=&quot;610&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;853&quot; data-original=&quot;https://pic2.zhimg.com/v2-1bf70209a9d15985f7c1ca155958d035_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-1bf70209a9d15985f7c1ca155958d035_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;首先看一下这个trait，这只是公开的trait，但从这些trait中可以发现一些蛛丝马迹。&lt;/p&gt;&lt;p&gt;首先，这个包里包含了client的本地抽象，以及网络相关的上下文信息。&lt;/p&gt;&lt;p&gt;其次，还有用于节点发现的网络行为 DiscoveryBehaviour &lt;/p&gt;&lt;p&gt;还有交易池接口等等。&lt;/p&gt;&lt;p&gt;看到这里，你可以结合业务来思考一下，为什么要这么抽象。比如交易池为什么是个接口，为什么是个trait呢？这样的思考就可以帮助你学习如何用Rust来思考和抽象业务。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2ae8276e5de58c697bfbb2804b9962c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;844&quot; data-rawheight=&quot;609&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;844&quot; data-original=&quot;https://pic1.zhimg.com/v2-a2ae8276e5de58c697bfbb2804b9962c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2ae8276e5de58c697bfbb2804b9962c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;844&quot; data-rawheight=&quot;609&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;844&quot; data-original=&quot;https://pic1.zhimg.com/v2-a2ae8276e5de58c697bfbb2804b9962c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a2ae8276e5de58c697bfbb2804b9962c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;再来看结构体&lt;/p&gt;&lt;p&gt;你会发现很多和网络 networker相关的实体，包括Peerid，看到Peerid我很自然地想到了操作系统里的进程，每个进程都有进程ID，这样类比的话，理解起来就比较具象化，尤其是初次接触分布式网络的人。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2766d50f67c49759584a1d74ba8d4a1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;837&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;837&quot; data-original=&quot;https://pic2.zhimg.com/v2-2766d50f67c49759584a1d74ba8d4a1d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2766d50f67c49759584a1d74ba8d4a1d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;837&quot; data-rawheight=&quot;604&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;837&quot; data-original=&quot;https://pic2.zhimg.com/v2-2766d50f67c49759584a1d74ba8d4a1d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2766d50f67c49759584a1d74ba8d4a1d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;经过上面的探索，我们基本了解了network的一些抽象架构。但是对于libp2p的知识还是有些朦胧。&lt;/p&gt;&lt;p&gt;但是好在网上还有很多资料，可以让我们从libp2p有一个整体认知。&lt;/p&gt;&lt;p&gt;做分布式网络，要面对复杂的异构的网络环境。有句话怎么说来着，「计算机科学中的任何问题，都可以通过加上一层逻辑层来解决」。那么libp2p就是在传统的网络协议上，重新做了统一的抽象层。&lt;/p&gt;&lt;p&gt;就像右边这个图，在传统的tcp协议上，又加了secio加密层，yamux多路复用层等等。 重点在于多路复用，同一个端口就把所有的事干了。开发者再也不用去为了兼容复杂的网络环境去干那些脏活累活了，可以专心专注于业务。&lt;/p&gt;&lt;p&gt;这就是分层的好处。当然，libp2p还有很多功能，这里就不列了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a64b13684bb98500c584119ab05599ed_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;825&quot; data-rawheight=&quot;628&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;825&quot; data-original=&quot;https://pic2.zhimg.com/v2-a64b13684bb98500c584119ab05599ed_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a64b13684bb98500c584119ab05599ed_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;825&quot; data-rawheight=&quot;628&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;825&quot; data-original=&quot;https://pic2.zhimg.com/v2-a64b13684bb98500c584119ab05599ed_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a64b13684bb98500c584119ab05599ed_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;经过这些梳理，然后再去看代码，线索就非常清晰了。&lt;/p&gt;&lt;p&gt;这份简单的脑图是我做PPT的时候同时整理出来的，大家可以根据这个思路自己去看看源码，自己去整理一下。&lt;/p&gt;&lt;p&gt;简单来说明一下这个结构。&lt;/p&gt;&lt;p&gt;network crate源码主要可以分成这么6个结构。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;service主要用于处理网络I/O和管理连接，也包括交易池的管理，广播交易什么的。&lt;/li&gt;&lt;li&gt;而discorery部分，主要定义了通用的网络行为，这里整合了所有的网络协议。用于发现节点。&lt;/li&gt;&lt;li&gt;protocol部分，是用于处理请求，主要是协议升级，比如从tcp按需给请求升级到相应的协议。这里面有一个substream 子流的概念，子流才是真正的请求。具体这里处理的时候使用了Rust的异步。&lt;/li&gt;&lt;li&gt;transpot是底层的公共传输基础，相当于是对libp2p底层的网络初始配置，比如配置yamux的多路复用之类。&lt;/li&gt;&lt;li&gt;chains是对本地客户端的抽象&lt;/li&gt;&lt;li&gt;config是网络初始化的一些配置。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;总的来说，这个库内容并不多。&lt;/p&gt;&lt;p&gt;但是看的过程中，发现了很多还不太懂的知识点，比如我罗列的这些问题列表。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-513cebff03f5f1eea9b8f7079759deca_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;830&quot; data-rawheight=&quot;589&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;830&quot; data-original=&quot;https://pic3.zhimg.com/v2-513cebff03f5f1eea9b8f7079759deca_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-513cebff03f5f1eea9b8f7079759deca_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;830&quot; data-rawheight=&quot;589&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;830&quot; data-original=&quot;https://pic3.zhimg.com/v2-513cebff03f5f1eea9b8f7079759deca_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-513cebff03f5f1eea9b8f7079759deca_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;交易池的具体细节是什么？优先级啊，还有什么双花交易啊，标准交易啊，这些如何体现？&lt;/p&gt;&lt;p&gt;yamux多路复用的细节，cossip协议和共识、kademlia算法和结构化网络、以及如何自定义网络协议等。&lt;/p&gt;&lt;p&gt;这些知识点，是从看源码过程中挖掘出来的，如果没有看这些源码，我根本不知道我不懂这些，甚至不知道这些知识点的存在。&lt;/p&gt;&lt;p&gt;这些问题也可以成为我后面深入学习的方向。&lt;/p&gt;&lt;h3&gt;小结&lt;/h3&gt;&lt;p&gt;希望这篇分享，能给大家带来一些启迪。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2019-10-14-86352307</guid>
<pubDate>Mon, 14 Oct 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>通告</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2019-09-13-82357718.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/82357718&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢大家订阅我的专栏。&lt;/p&gt;&lt;p&gt;Rust周报有段时间没有更新了，主要是本人这段时间事情比较多，没有抽出时间梳理。昨天看到有人问起，特此说明。&lt;/p&gt;&lt;p&gt;忙完这段时间，专栏会给大家带来更多精彩。&lt;/p&gt;&lt;p&gt;顺祝大家中秋快乐！&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2019-09-13-82357718</guid>
<pubDate>Fri, 13 Sep 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Facebook如何引入Rust</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2019-08-17-78549374.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/78549374&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c2c5f4a560bb472893b71db23185a769_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;今天刚看到Facebook内部meetup流出的Slides，原文标题很有意思：&lt;b&gt;Bringing Rust Home to Meet the Parents （带Rust去见父母）。&lt;/b&gt;该分享主要是讲了Facebook引入Rust的过程，我也没有看过Meetup的内容，&lt;b&gt;只是想通过Slides来解读并还原一下Facebook引入Rust的历程&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;Slides地址：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.google.com/presentation/d/1RLNyr3riO2LyqQsMAOvMMyGTllhx1wPmfkXXcbtOB00/edit%23slide%3Did.p&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;docs.google.com/present&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ation/d/1RLNyr3riO2LyqQsMAOvMMyGTllhx1wPmfkXXcbtOB00/edit#slide=id.p&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;/p&gt;&lt;hr/&gt;&lt;p&gt;该Topic的作者是一名资深的工程师，他在操作系统内核领域&lt;b&gt;使用C语言有30多年&lt;/b&gt;，入职Facebook三年。作者坦言：&lt;b&gt;C语言只是他趁手的工具，但不是他喜欢的工具&lt;/b&gt;。Facebook是他有意加入，为了学习在大规模的组织中如何工作。看得出来，是一名非常有独立思想的工程师。当他看到Facebook内部还没有人使用Rust，他就想，为什么不尝试引入Rust呢？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;引入的条件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在大公司中引入新技术本身是一件非常困难的事情，更何况还是Facebook如此巨大的公司，而且Rust还是要替代C来做很多基础设施。所以，要想在Facebook中引入Rust，需要满足以下条件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rust不仅仅是「好」而已。它还需要在某些地方「突出地好（much better）」。（什么叫突出的好呢？在《从0到1》一书中有过相关的考量，那就是「十倍」的好）&lt;/li&gt;&lt;li&gt;在其他方面至少能持平现有技术（比如，持平C）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而且，引入新的语言不仅仅是技术问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;新语言具有潜在的风险：这个赌注是长期的，无法马上获得回报&lt;/li&gt;&lt;li&gt;大多数人对完成工作比使用新语言更加感兴趣&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，必须让大家了解：Rust是胜任工作的最佳工具。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust的10倍优势&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;那么Rust的十倍优势是什么呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rust可以在编译期检测到大量严重的错误。&lt;/li&gt;&lt;li&gt;编译期出错的成本要比生产时出错的成本低好几个数量级&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于Facebook这种企业，生产时出错的成本可想而知会很高。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;引入的起点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Facebook内部使用的主流语言是：Cpp、Java和Python。但其实有很多通晓多种语言的人，他们可以自由选择语言和技术。但他们通常都是务实的，在选择语言的时候，必须有充分的理由去选择它。&lt;/p&gt;&lt;p&gt;庞大的代码仓库，有数亿行代码。这些庞大的代码资源，都是通过自定义的专门工具来处理，从源码控制、构建、CI到测试、部署，以及监控和分析等生产基础设施。那么想引入Rust该从何入手？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;聪明的选择&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;他回顾了Rust的世界观：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;安全。安全是一切的基础。&lt;/li&gt;&lt;li&gt;新语言，意味着，新的项目，或者是实验性项目可以使用。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;等等。&lt;/p&gt;&lt;p&gt;同时，他思考，如何才能让Facebook内部这个庞大的生态系统感受到Rust的好呢？这是一个很好的出发点，于是他选择了一个「版本管理系统 Mercurial」。因为版本管理系统是在内部应用最广的，而且Mercurial之前是Python实现的，性能急需改进。&lt;/p&gt;&lt;p&gt;所以，用Rust从头开始实现源码版本控制系统的后端被提上了日程。于是就有了现在的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/facebookexperimental/mononoke&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;mononoke&lt;/a&gt; 项目（差不多快3年了）。&lt;/p&gt;&lt;p&gt;Mononoke项目的生产实践，证明了Rust值得进一步投资。并且，Rust帮助他们降低了Bug的成本。&lt;/p&gt;&lt;p&gt;Facebook运行中出问题是一个非常恐怖的事情，因为会造成很大的损失。所以FB在代码的质量上投入了大量的资源：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;代码审查&lt;/li&gt;&lt;li&gt;静态分析&lt;/li&gt;&lt;li&gt;测试基础设施&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;等等，这些属于内部开发循环。工程师们会在不同的上下文中切换，来修复其中的问题。而使用Rust，则可以减少内部循环中的大量错误，因此可以帮助工程师们减少不必要的上下文切换。&lt;/p&gt;&lt;p&gt;但是Rust也并不是万能的，如何量化那些未在编译期发现的Bug的成本呢？在这一点，Rust也给予了很大的帮助：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;升级了代码审查的体验：审查人员不需要关心底层的细节，只需要专注于更高层次的抽象架构设计。因为Rust的类型系统，和强调显式表达等特性。&lt;/li&gt;&lt;li&gt;降低了代码维护的风险。即便一个完全不了解业务背景的工程师（或者几个月之后的原作者）接手了一个Rust程序，在修改Bug的时候也能得心应手，因为有类型和生命周期（lifetime）约束等信息。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过这个实际的案例，他们明显地体会到了Rust的十倍优势，因此有更多人想使用Rust。&lt;/p&gt;&lt;p&gt;FB内部最先积极采用Rust的群体是Python开发者，它们想寻求性能上的改进，对于Rust推广者来说，这是一个惊喜的转变。&lt;/p&gt;&lt;p&gt;然后Rust就越来越受更多人关注了，最后是那些只追求于完成任务的群体，他们也开始尝试Rust。现在FB已经有很多高价值的项目采用Rust，比如最近流行的Libra。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Facebook在招人&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;并且该Topic作者还透露了一个重点信息：&lt;b&gt;Facebook在招Rust开发者&lt;/b&gt;！ Rust在Facebook的旅程才走了1%，需要更多的人参与，走完剩下的99%。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ec4f45c53ad73e44bfcf111693f3402a_b.jpg&quot; data-rawwidth=&quot;1142&quot; data-rawheight=&quot;625&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1142&quot; data-original=&quot;https://pic3.zhimg.com/v2-ec4f45c53ad73e44bfcf111693f3402a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ec4f45c53ad73e44bfcf111693f3402a_b.jpg&quot; data-rawwidth=&quot;1142&quot; data-rawheight=&quot;625&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1142&quot; data-original=&quot;https://pic3.zhimg.com/v2-ec4f45c53ad73e44bfcf111693f3402a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ec4f45c53ad73e44bfcf111693f3402a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;在这次分享中，还包含了作者如何看待Rust发展前景中要解决的各种问题，这里就不细说了，感兴趣的去看Slides吧。后续如果有视频，我也会补上来链接。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;如果你想在自己的公司推广Rust，那么Facebook的这段经历可能对你有帮助。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;感谢阅读。&lt;/b&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2019-08-17-78549374</guid>
<pubDate>Sat, 17 Aug 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust官网翻译那些事</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2019-07-02-71899874.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71899874&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dae7b88292e96b0abe749562eae2226e_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;上个月17个号，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.rust-lang.org/zh-CN&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust官网简体中文版&lt;/a&gt;上线了。本来计划在上线那几天就写这篇文章，可是被种种事情耽误了。今天终于抽时间来写下这篇纪念文。&lt;br/&gt;谨以此文感谢参与Rust官网翻译活动的每个小伙伴！&lt;/blockquote&gt;&lt;h2&gt;缘起&lt;/h2&gt;&lt;p&gt;Rust官网召集中文翻译这件事，最早是在日报小组内部讨论组由Mike（Rustcc坛主）发出来的。当时Mike说，要不要咱们翻译一下？我一想，官网那么多页面，这翻译得多久，于是就跟Mike说，我恐怕没有时间搞这个事。然后就搁置了。&lt;br/&gt;&lt;br/&gt;过了两天，Aimee（from 秘猿）在社区QQ群里也在召集中文译者，想把这事推动起来。此时，我又一想，也许召集大伙一起干这事，可以高效完成这件事。而且，如果官网有了中文的支持，对于Rust在中国的推广更有好处。于是我和Mike一起创建了一个翻译小组群，开始在社区招募感兴趣的译者参与。与此同时，联络Aimee。此时Aimee已经和Rust官方网站翻译负责人Florian联系好了。&lt;/p&gt;&lt;p&gt;最初还以为不会有很多人参与，没想到大家的热情还挺高涨，而且远在澳洲的Rust tg群群主Xidorn Quan也热心参与了进来。由此还发现原来社区里默默隐藏着一个翻译组织（主要成员Aaran Xu和OlingCat），&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang-cn&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/rust-lang-cn&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;，已经翻译了不少Rust官方的相关资源。后来就干脆以该组织为基地，来组织这次官网的翻译工作。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1db1d73533f7ec377da36c03a7310b72_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3268&quot; data-rawheight=&quot;2556&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;3268&quot; data-original=&quot;https://pic3.zhimg.com/v2-1db1d73533f7ec377da36c03a7310b72_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1db1d73533f7ec377da36c03a7310b72_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3268&quot; data-rawheight=&quot;2556&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;3268&quot; data-original=&quot;https://pic3.zhimg.com/v2-1db1d73533f7ec377da36c03a7310b72_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1db1d73533f7ec377da36c03a7310b72_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;于是翻译就这样顺利开始进行了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-54d24d022b8be82072770df4bf72c866_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;991&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1200&quot; data-original=&quot;https://pic3.zhimg.com/v2-54d24d022b8be82072770df4bf72c866_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-54d24d022b8be82072770df4bf72c866_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;991&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1200&quot; data-original=&quot;https://pic3.zhimg.com/v2-54d24d022b8be82072770df4bf72c866_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-54d24d022b8be82072770df4bf72c866_b.jpg&quot;/&gt;&lt;figcaption&gt;成员和协作方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;协作&lt;/h2&gt;&lt;p&gt;Rust官网多语言支持是通过Fluent和Pontoon共同支持完成的。关于Fluent可以参考我这篇文章: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/67402361&quot; class=&quot;internal&quot;&gt;Rust I18N 方案梳理&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;简单来说，Fluent是一个翻译规范，它的特点是翻译和项目分离，并且可以独立于源语言（比如说英语），让翻译人员释放更多的自然语言表现力。&lt;/p&gt;&lt;p&gt;在Rust官网源码中，使用flt文件对应不同的页面内容，为翻译工作的协作也提供了方便。再配合Pontoon这个所见即所得的编辑工具，可以很方便地进行各种语言翻译工作的审校和协作。&lt;/p&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-26623857e9a48d5780c7e563d03aec01_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1000&quot; data-rawheight=&quot;1614&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1000&quot; data-original=&quot;https://pic2.zhimg.com/v2-26623857e9a48d5780c7e563d03aec01_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-26623857e9a48d5780c7e563d03aec01_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1000&quot; data-rawheight=&quot;1614&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1000&quot; data-original=&quot;https://pic2.zhimg.com/v2-26623857e9a48d5780c7e563d03aec01_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-26623857e9a48d5780c7e563d03aec01_b.jpg&quot;/&gt;&lt;figcaption&gt;Rust官网github源码i18n文件&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在最初敲定协作方案的时候，大家下意识地都默认使用GitHub fork仓库的方式，因为大家都是技术开发，习惯了以往的这种方式。很快，我们敲定了协作的方式： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;分为翻译和校对两种角色。&lt;/li&gt;&lt;li&gt;按flt文件来领任务。&lt;/li&gt;&lt;li&gt;先翻译，后通过发PR的方式来进行校对。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;基本上任务推进的非常快、非常自然。两三天的功能基本上页面都翻译完了。虽然速度很快，但是大家都很认真对待这件事。常常因为某个术语的翻译而讨论半天，所以大部分时间都在校对上。&lt;/p&gt;&lt;p&gt;比如官网首页的两处翻译。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Rust的宣传语：「Rust，一门赋予每个人构建可靠且高效软件能力的语言。」&lt;/li&gt;&lt;li&gt;npm工程师对Rust的赞美： 「“对 Rust 最大的赞美，就是它让我太无聊了。这太令人惊叹了！”  – Chris Dickinson，来自 npm 公司的工程师」&lt;/li&gt;&lt;/ol&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7ee189661c8a3360278c8f34b2608de5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;652&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1240&quot; data-original=&quot;https://pic2.zhimg.com/v2-7ee189661c8a3360278c8f34b2608de5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7ee189661c8a3360278c8f34b2608de5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;652&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1240&quot; data-original=&quot;https://pic2.zhimg.com/v2-7ee189661c8a3360278c8f34b2608de5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7ee189661c8a3360278c8f34b2608de5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Rust的宣传语，原文是「A language empowering everyone to build reliable and efficient software.」这句话原文含有「赋能（empowering）」之意。短短的几个字，大家讨论了半天，最终才决定了现在这句话。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-338e061c04fa119b769a44d35cfad7f0_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2570&quot; data-rawheight=&quot;420&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2570&quot; data-original=&quot;https://pic1.zhimg.com/v2-338e061c04fa119b769a44d35cfad7f0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-338e061c04fa119b769a44d35cfad7f0_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2570&quot; data-rawheight=&quot;420&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2570&quot; data-original=&quot;https://pic1.zhimg.com/v2-338e061c04fa119b769a44d35cfad7f0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-338e061c04fa119b769a44d35cfad7f0_b.png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;npm工程师对于Rust的赞美，不了解Rust的人恐怕看了之后会一头雾水。最初的翻译是：「对Rust最大的赞美，就是它太无聊了，这是令人惊叹的赞美」。&lt;/p&gt;&lt;p&gt;其实，这句话是出自npm的一次分享，大概意思是：他们用Rust写了一个服务，在线上稳定运行了一年半，他们几乎都要忘记这个服务的存在了。所以，他说Rust让他太无聊了，连修Bug的机会都没有。他同时也十分惊叹Rust语言的这种能力，如果是其他语言写的程序，他肯定就不会无聊了。&lt;/p&gt;&lt;p&gt;所以，这句话的翻译最终改为了：「对 Rust 最大的赞美，就是它让我太无聊了。这太令人惊叹了！」&lt;/p&gt;&lt;p&gt;除了首页的这两处之外，还有很多地方大家都十分认真地参与了讨论和建议。最终展现在大家面前的翻译结果，不敢说信雅达，但一定是做到了正确和通顺。&lt;/p&gt;&lt;h2&gt;交付&lt;/h2&gt;&lt;p&gt;本来以为翻译完，直接通过GitHub给官方提交PR即可。但是后来和Florian聊天才发现，官方本就没有打算让翻译小队通过GitHub PR的方式来交付翻译成果。&lt;/p&gt;&lt;p&gt;所以，只能通过Pontoon来直接交付。不过，经过GitHub的一番严格认真的协作，我们只需要复制粘贴即可。然后官方运维组成员Manish，会处理翻译好的文件。经过和Manish的交流，得知官方源码仓库和Pontoon已经设置了自动同步，Pontoon这边的修改，都会定时自动地同步到官方源码仓库。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8c215ba3551effe91fa2868bd9efeeff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;5114&quot; data-rawheight=&quot;2662&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;5114&quot; data-original=&quot;https://pic4.zhimg.com/v2-8c215ba3551effe91fa2868bd9efeeff_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8c215ba3551effe91fa2868bd9efeeff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;5114&quot; data-rawheight=&quot;2662&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;5114&quot; data-original=&quot;https://pic4.zhimg.com/v2-8c215ba3551effe91fa2868bd9efeeff_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8c215ba3551effe91fa2868bd9efeeff_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当我们把翻译成果交付到Pontoon上面之后，把Pontoon的链接公布到社区里，让更多的人来参与校对。事实证明，这个决定是正确的。有好几个社区的热心朋友，虽然没有加入翻译小组的QQ群，但是可以通过GitHub登录到Pontoon直接参与审校，并且提出了好几个漂亮的改进翻译和错误。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8592ca724a1d1fa9e4b9cdbc75b77370_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2126&quot; data-rawheight=&quot;2608&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2126&quot; data-original=&quot;https://pic1.zhimg.com/v2-8592ca724a1d1fa9e4b9cdbc75b77370_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8592ca724a1d1fa9e4b9cdbc75b77370_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2126&quot; data-rawheight=&quot;2608&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2126&quot; data-original=&quot;https://pic1.zhimg.com/v2-8592ca724a1d1fa9e4b9cdbc75b77370_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8592ca724a1d1fa9e4b9cdbc75b77370_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;Rust的开源文化，深深的影响着社区。包括这次翻译活动，也是一次开源协作的尝试。最终的翻译成果，是中文社区共同完成的。最后，再次感谢每个参与翻译的朋友。&lt;/p&gt;&lt;p&gt;这次翻译活动，也带动了台湾Rust群组翻译官网的兴致和热情，台湾繁体翻译也在近日上线了官网。&lt;/p&gt;&lt;p&gt;预告：Rust中文社区翻译小组，还在计划翻译官方Rustc导读，感兴趣的朋友也可以参与进来。可以加QQ群：7 1 6 3 4 8 0 5 6。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2019-07-02-71899874</guid>
<pubDate>Tue, 02 Jul 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>「源码阅读」qrcode-rs源码学习分享</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2019-06-15-69269688.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69269688&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f2b909b8160155ad662ea6e38e98ab48_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;本篇的分享是基于&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59517478&quot; class=&quot;internal&quot;&gt;混沌学社&lt;/a&gt;的某位学员，近两周的学习成果分享。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;他的学习任务是： &lt;/p&gt;&lt;p&gt;阅读 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/kennytm/qrcode-rust&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;qrcode-rs&lt;/a&gt; （该代码的作者是Rust运维团队成员，也是Rust重要贡献者之一）的代码去学习。主要目的不是为了学习如何创建二维码，而是为了通过阅读一个实际的项目，去学习利用Rust思维抽象问题的方法，以及训练如何阅读Rust项目代码，在阅读源码中学习。&lt;/p&gt;&lt;p&gt;下面是脑图分享，目前只有图。&lt;/p&gt;&lt;p&gt;完整清晰图片地址： &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/RustStudy/rust_daily_news/blob/master/img/%25E4%25BA%258C%25E7%25BB%25B4%25E7%25A0%2581%25E7%2594%259F%25E6%2588%2590.png&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/RustStudy/ru&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;st_daily_news/blob/master/img/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90.png&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br/&gt;结构：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-62e311bfd6ae569cef5252778dff65f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3137&quot; data-rawheight=&quot;4207&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;3137&quot; data-original=&quot;https://pic1.zhimg.com/v2-62e311bfd6ae569cef5252778dff65f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-62e311bfd6ae569cef5252778dff65f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3137&quot; data-rawheight=&quot;4207&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;3137&quot; data-original=&quot;https://pic1.zhimg.com/v2-62e311bfd6ae569cef5252778dff65f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-62e311bfd6ae569cef5252778dff65f4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2019-06-15-69269688</guid>
<pubDate>Sat, 15 Jun 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust日报」2019每周精选 • 第十八期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2019-06-03-67895055.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/67895055&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23599072636a1820bba7b49b9d586092_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言：&lt;br/&gt;从2018年开始，我每天会花1个小时关注Rust社区动态，并且分享我每天的见闻，偶尔也夹杂了一些个人的观点。新的一年过去了，Rust日报已经成为了Rust社区群大家每天必看的内容。&lt;br/&gt;从2019年开始，日报小组成立，目前的动态由：@Chaos、 @Mike、 @Damody(台湾)轮番为大家播报。也欢迎感兴趣的朋友加入小组。&lt;br/&gt;每周也会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。&lt;br/&gt;独立日报订阅地址： - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//t.me/rust_daily_news&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Telgram Channel&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/chaosbot/rustnews&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;阿里云语雀订阅&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//steemit.com/%40blackanger&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Steemit&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/RustStudy/rust_daily_news&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub&lt;/a&gt;&lt;br/&gt;社区学习交流平台订阅： - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust.cc/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust.cc论坛&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rustforce.net/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust Force&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust.cc/article%3Fid%3Ded7c9379-d681-47cb-9532-0db97d883f62&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;微信公众号：Rust语言学习交流&lt;/a&gt;&lt;br/&gt;截止 2019-06-02&lt;/blockquote&gt;&lt;hr/&gt;&lt;h2&gt;官方新闻&lt;/h2&gt;&lt;h3&gt;异步await语法最终确定&lt;/h3&gt;&lt;p&gt;官方核心成员无船大佬在博客上披露，异步await语法的最终提议是继续推进后缀关键字语法： &lt;code&gt;future.await&lt;/code&gt;。另外无船大佬还针对Rust语言设计给出了两点说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Rust语言很少有绝对的情况出现。除了一些必须要做的事，比如类型系统必须健壮之外，其他绝大多数的问题都是权衡问题。也就是说，需要权衡不同种类的方案，选择团队认为优先的道路。这样做必然会带来很多正面或负面的想法，所以我们需要避免非黑即白的二分思想。&lt;/li&gt;&lt;li&gt;点关键字，只是一个方案的草图，并不带有某种角度的暗示或保证。它仍然需要走RFC流程。&lt;/li&gt;&lt;li&gt;引入&lt;code&gt;@await&lt;/code&gt;语法，也是因为权衡成本的问题，因为引入新的符号会带来成本。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下一步：&lt;/p&gt;&lt;p&gt;准备在Rust 1.37稳定版中引入async/await的最小稳定化版本， 1.37将于8月中旬发布，并于7月4日发布。这不会是async/await功能的结束 - 最小功能将会有很多扩展 - 但对于每个想要使用Rust进行高性能网络服务的人来说，这将是一个重要的里程碑。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//boats.gitlab.io/blog/post/await-decision-ii/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Unsafe代码指南现在线上可用&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust-lang.github.io/unsafe-code-guidelines/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Rust标准库已经开始尝试使用 Const Generics 进行重写数组的一些实现&lt;/h3&gt;&lt;p&gt;相关&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/rust/pull/60466&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PR&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;const generics&lt;/a&gt; 就是“基于常量值的泛型”。简单来说，Rust 中的 &lt;code&gt;[T; LEN]&lt;/code&gt;，它的很多特性在之前的版本中，只支持最多 [T; 32]，而且是人 [T; 0]，[T; 1], [T;2] ... 一直到 [T; 31] 这样，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/primitive.array.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;纯手撸实现&lt;/a&gt;的，丑不？&lt;/p&gt;&lt;p&gt;现在，有了 const generics，就可以把数组这种常用的类型从二等公民提升到一等公民来了。对于处女座来讲，简直要欢呼。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;社区新闻&lt;/h2&gt;&lt;h3&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//rust.cc&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;rust.cc&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;社区提供了国内crates镜像&lt;/h3&gt;&lt;p&gt;快来试试&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rustcc/lernaean-deploy/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rustcc/lernaean-deploy&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;知乎开源Rust实现的搜索引擎Rucene&lt;/h3&gt;&lt;p&gt;据了解，目前开源的部分只包括 lucene library 部分，搜索引擎的部分太多业务内容而且跟内部的一个分布式框架有强绑定就没开源，等后续弄好了应该还会出一篇文章，详细介绍这个项目。未来估计还会有一次代码重构，可能会带来break change的修改，想要贡献的朋友可以缓一缓。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/zhihu/rucene&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;支持Rust的多种方式&lt;/h3&gt;&lt;p&gt;如果你想支持Rust的发展，有很多方法可以支持Rust：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;贡献代码。&lt;/li&gt;&lt;li&gt;写文档、书、博客、视频等。&lt;/li&gt;&lt;li&gt;在论坛，Stack Overflow，Reddit，Matrix或Discord上回答问题。&lt;/li&gt;&lt;li&gt;财务支持。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;尤其是财务支持，可以帮助补偿这些重点贡献人员的时间，使得开源更具可持续性。如果你愿意，可以查看Aaron发起的捐助人员列表。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//readrust.net/support.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//aturon.github.io/sponsor/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Aaron发起的捐助人员列表&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Rust官网简体中文翻译工作正在如火如荼地进行着&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang-cn/www.rust-lang.org&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rust-lang-cn/www.rust-lang.org&lt;/a&gt;&lt;/p&gt;&lt;p&gt;相关阅读 : &lt;a href=&quot;https://zhuanlan.zhihu.com/p/67402361&quot; class=&quot;internal&quot;&gt;从官网挖掘的Rust I18N方案&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Rust Audio论坛 - 讨论和询问有关Rust中音频开发的问题的地方&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust-audio.discourse.group/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;使用WASI对区块链进行通用计算&lt;/h3&gt;&lt;p&gt;本文来自于OasisLabs，介绍了WASI（Web Assembly System Interface ）在区块链上的应用。目前Oasis平台的技术架构目前正在围绕WASM、WASI和区块链来实施。&lt;/p&gt;&lt;p&gt;（OasisLabs是来自加州大学伯克利分校的Dawn Song教授和同事们创立的区块链项目，基于区块链和可信硬件想构建高性能的可信云平台。）&lt;/p&gt;&lt;p&gt;为什么他们想把WASI用于区块链？&lt;/p&gt;&lt;p&gt;WASI用于区块链的目标是利用围绕WASI快速发展的社区和基础设施。 与创建另一个Wasm接口的替代方法相比，WASI允许区块链开发人员利用更广泛的开发人员社区的资源。 通过这种方式，可以想象未来区块链将成为云开发人员工具箱中的另一个工具。&lt;/p&gt;&lt;p&gt;OasisLabs团队还专门提交了一个区块链WASI的RFC，想做成适合区块链上下文的WASI标注扩展。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/oasislabs/blockchain-flavored-wasi-50e3612b8eba&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/oasislabs/rfcs/pull/1&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Blockchain WASI RFC&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Rust vs C++ ： 基于36核CPU的并行性能测试&lt;/h3&gt;&lt;h2&gt;cpp #rayon&lt;/h2&gt;&lt;p&gt;有人针对Rust/Rayon（Rust实现的多线程并发库）和C++/OpenMP（c++的类似于rayon的库）在36核的机器上进行了性能测试。&lt;/p&gt;&lt;p&gt;Rust 36个线程：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;n&quot;&gt;Running&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Threads&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BabelStream&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Version&lt;/span&gt;: &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Implmentation&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;Rust&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Running&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kernels&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Precision&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;: &lt;span class=&quot;mf&quot;&gt;268.4&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MB&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Total&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;: &lt;span class=&quot;mf&quot;&gt;805.3&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MB&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.8&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mbytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Min&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Max&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Average&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Copy&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;50552.817&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01062&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.02924&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01143&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mul&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;39680.038&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01353&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01510&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01443&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;45828.953&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01757&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01874&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01820&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Triad&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;       &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;41769.002&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01928&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.02206&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.02029&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dot&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;43584.260&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01232&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01327&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01273&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;CPP/OMP 36个线程：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Running&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Threads&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;BabelStream&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;Version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.4&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;Implementation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpenMP&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Running&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kernels&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;Precision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;268.4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Total&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;805.3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.8&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;MBytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Min&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;Max&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;Average&lt;/span&gt;     
&lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt;        &lt;span class=&quot;mf&quot;&gt;87745.870&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;0.00612&lt;/span&gt;     &lt;span class=&quot;mf&quot;&gt;0.00710&lt;/span&gt;     &lt;span class=&quot;mf&quot;&gt;0.00684&lt;/span&gt;     
&lt;span class=&quot;n&quot;&gt;Mul&lt;/span&gt;         &lt;span class=&quot;mf&quot;&gt;79315.382&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;0.00677&lt;/span&gt;     &lt;span class=&quot;mf&quot;&gt;0.00762&lt;/span&gt;     &lt;span class=&quot;mf&quot;&gt;0.00736&lt;/span&gt;     
&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;         &lt;span class=&quot;mf&quot;&gt;89995.047&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;0.00895&lt;/span&gt;     &lt;span class=&quot;mf&quot;&gt;0.01029&lt;/span&gt;     &lt;span class=&quot;mf&quot;&gt;0.00992&lt;/span&gt;     
&lt;span class=&quot;n&quot;&gt;Triad&lt;/span&gt;       &lt;span class=&quot;mf&quot;&gt;91574.889&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;0.00879&lt;/span&gt;     &lt;span class=&quot;mf&quot;&gt;0.01012&lt;/span&gt;     &lt;span class=&quot;mf&quot;&gt;0.00975&lt;/span&gt;     
&lt;span class=&quot;n&quot;&gt;Dot&lt;/span&gt;         &lt;span class=&quot;mf&quot;&gt;118144.442&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.00454&lt;/span&gt;     &lt;span class=&quot;mf&quot;&gt;0.00504&lt;/span&gt;     &lt;span class=&quot;mf&quot;&gt;0.00490&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于这个结果，可以看看Reddit讨论贴里的一些反馈。评论区有一半的人都认为Rust之所以慢，是因为rayon目前不支持NUMA感知（Numa aware）的原因。无论是Rust语言，还是Rayon目前都不支持该功能，除非等内存分配器稳定下来再做打算。&lt;/p&gt;&lt;p&gt;（NUMA 用于 x86 和 IBM® POWER® 体系结构平台上的多处理器系统。在具有 NUMA 特性的系统中，每个处理器都具有可用的本地内存，也可以访问分配给其他处理器的内存。对本地内存的内存访问速度更快。NUMA 节点是相互紧密联系的处理器和内存的集合。 在节点内的内存访问速度比在节点外更快。如果程序能够感知NUMA，那就相关计算资源，将会被放置到一个不同的物理NUMA节点。尽管仍旧在两个NUMA节点之间扩展，但资源使用将会得到优化。）&lt;/p&gt;&lt;p&gt;但未可知OpenMP的测试代码是否利用了NUMA感知来提升性能，但OpenMP好像是支持NUMA（不确定）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bto10h/update_a_scaling_comparison_between_rustrayon_and/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reddit 讨论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/andrewpsuedonym/Dissertation-Project&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;相关代码&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rayon-rs/rayon/issues/319&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rayon issues: Schedulling should be NUMA aware&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cenalulu.github.io/linux/numa/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;介绍NUMA的一篇文章&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;「讨论」ndarray vs nalgebra&lt;/h3&gt;&lt;p&gt;该贴针对此问题展开讨论：ndarray和nalgebra这两个库有什么区别？优缺点？哪个库更有机会被机器学习和科学计算领域应用？&lt;/p&gt;&lt;p&gt;评论摘要：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Ndarray和nalgebra针对两个不同的问题域。&lt;/li&gt;&lt;li&gt;Ndarray和nalgebra重复的部分只是线性代数系统，而nalgebra更侧重于线性代数系统，但仅限于1D向量和2D矩阵。&lt;/li&gt;&lt;li&gt;Ndarray类似于numpy，适用于n维数据处理。&lt;/li&gt;&lt;li&gt;一旦Rust的const generics功能稳定以后，这两个库将深受影响，也许将来会有更多的功能重叠。&lt;/li&gt;&lt;li&gt;nalgebra是纯Rust的，ndarray有一个OpenBLAS后端。所以在性能上，一些程序可能ndarray执行的更好（纯Rust实现的有待优化）。&lt;/li&gt;&lt;li&gt;如果是用于工程和数学目的，nalgebra是迄今为止最好的选择。nalgebra的最佳功能是在编译时进行维度检查，这意味着错误数学运算的代码将无法通过编译。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/btn1cz/ndarray_vs_nalgebra/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reddit讨论&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;dotenv易主了&lt;/h3&gt;&lt;p&gt;dotenv易主了，之前是diesel作者维护的，但是有段时间不维护了，连仓库都删了，现在有人接手它了，并且准备发1.0了，&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/dotenv-rs/dotenv&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;新仓库&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Rust和Blender&lt;/h3&gt;&lt;p&gt;Blender是一个免费的开源3D创作套件。该文作者曾经在Blender工作过，编写过Python API。为了探索Blender二进制文件格式并提供读取和使用它们的工具，该文作者创建了一个Rust项目&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.janwalter.org/jekyll/blender/rust/blendinfo/2019/05/28/blend_info.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//codeberg.org/wahn/rs_blender&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rs_blender&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Steam 上有哪些游戏是用 Rust 实现的&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//store.steampowered.com/app/808160/UniverCity/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;城市模拟游戏 UniverCity&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//store.steampowered.com/app/1032170/Robo_Instructus/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;编程游戏 Robo Instructus（预计2019 Q3上线）&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bvtfni/which_rust_games_have_made_it_to_steam/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;学习资源&lt;/h2&gt;&lt;h3&gt;「异步系列文章」Part 2: Async/Await语法之外的挑战 : 取消（Cancellation）&lt;/h3&gt;&lt;p&gt;在这篇文章里，作者讨论了如果在应用中取消正在进行的异步任务，这非常有用，主要是因为对它们的结果不再有任何兴趣，所以继续操作就会成为资源占用。比如在超时范围内没有收到响应并且应该将错误发送回用户，则应该取消子操作。&lt;/p&gt;&lt;p&gt;先来看看在同步中如何取消任务：&lt;/p&gt;&lt;p&gt;例如&lt;/p&gt;&lt;p&gt;在C＃中，使用CancellationToken类型的变量传递给每个方法，该方法是可取消工作流的一部分。这些方法可以不时地检查CancellationToken.IsCancellationRequested，以便发现父任务是否已请求取消。在这种情况下，子任务可以提前返回（例如通过抛出异常）。&lt;/p&gt;&lt;p&gt;其他语言是这种方法的变体：&lt;/p&gt;&lt;p&gt;Go使用Context结构将取消请求传播到子任务。在Go中，取消请求通过Channel发出信号，因为它可以轻松地使程序等待取消请求或来自其他来源的状态更新。&lt;/p&gt;&lt;p&gt;Java利用线程局部中断状态。如果一个线程获得&lt;code&gt;.interrupted()&lt;/code&gt;，那么如果不处理异常，某些操作将抛出并强制返回子任务。这可以被视为某种线程局部的CancellationToken，它在方法之间没有明确地传递。它具有不能在异步上下文中使用的缺点。&lt;/p&gt;&lt;p&gt;这些行为具有一组特定的共性:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;取消始终只是通过取消请求来完成，它无法执行，即使请求已发出，子进程也可能运行一段时间。&lt;/li&gt;&lt;li&gt;所有方法都可以观察是否发生了取消，如果子方法受到影响，并且能够对其做出反应&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在async/await异步中如何取消：&lt;/p&gt;&lt;p&gt;Rust之外的语言，和同步取消任务的模式类似：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通过专用参数或隐式任务本地参数请求取消&lt;/li&gt;&lt;li&gt;需要方法来观察取消状态。&lt;/li&gt;&lt;li&gt;即使取消后，异步方法也会完成。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;比如，&lt;code&gt;C＃ async Tasks&lt;/code&gt;通过CancellationToken发出取消信号。许多&lt;code&gt;.NET&lt;/code&gt; core框架函数支持此参数以传播取消请求。Kotlin协程标准库识别取消请求并允许操作在取消时提前中止。Javascript没有取消的标准化类型，由于异步Javascript函数将始终运行完成，因此该机制还需要遵循上述所描述的模式。&lt;code&gt;C++&lt;/code&gt;协程可以使用cppcoro库中定义的CancellationToken。&lt;/p&gt;&lt;p&gt;Rust对Cancellation的支持与其他支持async/await的语言有所不同。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;只需删除表示异步操作的Future即可触发取消&lt;/li&gt;&lt;li&gt;不需要方法来转发取消请求或取消能力（例如，通过传递CancellationToken）&lt;/li&gt;&lt;li&gt;取消是同步的 - 因为drop()是同步的&lt;/li&gt;&lt;li&gt;取消不包括单独的取消请求并等待操作完成的步骤。只有一个取消/删除步骤。&lt;/li&gt;&lt;li&gt;取消被强制执行 - 子方法不能忽视或推迟取消&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些特性有优点也有缺点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;取消任务将变得简单&lt;/li&gt;&lt;li&gt;主要缺点是底层操作必须支持同步取消，比如处理操作系统底层IO的时候，会比较麻烦。但该文章中也给出了一些解决办法。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更多内容请查看原文。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gist.github.com/Matthias247/ffc0f189742abf6aa41a226fe07398a8&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gist.github.com/Matthias247&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;文章列表&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;如何用Rust实现一个Chat App&lt;/h3&gt;&lt;p&gt;本文介绍了如何使用Rust和简单的JavaScript在本地机器上构建简单的聊天应用程序。主要的技术栈是Rocket/websocket/JavaScript（你也可以使用TypeScript）&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/%40steadylearner/how-to-start-rust-chat-app-499a194d0820&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;禅与系统中移除阻塞（block）的艺术&lt;/h3&gt;&lt;p&gt;标题仿自《禅与摩托车维修的艺术》。该文是servo的某个贡献者写的文章，他介绍了如何从并行系统中删除阻塞逻辑。长文预警！&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/%40polyglot_factotum/programming-servo-zen-and-the-art-of-removing-blocks-from-your-system-51c1b7d404e3&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「系列」 使用Rust创建静态文件服务器 Part 2&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//concisecoder.io/2019/05/27/creating-a-static-http-server-with-rust-part-2/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;小技巧：cargo clean的时候，不想重新编译依赖，怎么办？&lt;/h3&gt;&lt;p&gt;&lt;code&gt;cargo clean&lt;/code&gt; 之后，会重头开始编译，各种依赖会重新编译。那么如果只想重头编自己工程中的代码，不想把依赖全部重新编译呢？答案很简单：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;cargo clean -p &amp;lt;your_crate_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bvo0j9/how_to_cargo_clean_without_cleaning_compiled/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Rust 中最好的 2D 游戏开发框架一览&lt;/h3&gt;&lt;p&gt;作者为了对比，用以下框架分别写了同一个小游戏，以做出对比。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;ggez&lt;/li&gt;&lt;li&gt;tetra&lt;/li&gt;&lt;li&gt;quicksilver&lt;/li&gt;&lt;li&gt;coffee&lt;/li&gt;&lt;li&gt;Piston&lt;/li&gt;&lt;li&gt;Amethyst&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;文章比较长，内容非常详实，做游戏开发的同学值得一读。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//wiki.alopex.li/AGuideToRustGameFrameworks2019&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;项目与库&lt;/h2&gt;&lt;h3&gt;toast: 支持在docker容器中运行任务的工具&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;image&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;ubuntu&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;tasks&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;greet&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;command&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;echo&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;Hello, World!&amp;#39;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# Toast will run this in a container.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;当然你还可以用它完成更多更复杂的任务：交叉编译、监控文件变化等等。但是Toast不会并行运行任务，而必须使用顺序执行计划，这是受Docker限制的，但是在单个任务中使用并行。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/stepchowfun/toast&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;toast&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Plotters：Rust的绘图库&lt;/h3&gt;&lt;p&gt;虽然在大多数情况下渲染图形并不需要太多的计算能力，并且诸如Python和Javascript的编程语言用于可视化目的。有时我们需要根据大量数据制作一个数字，例如，渲染一些人类基因数据可能需要对数万亿个数据点进行下采样，这对于许多高级编程语言来说甚至都不可行。在这种情况下，Rust是渲染数字的完美候选者，因为它具有高级抽象能力，但运行速度非常快。&lt;/p&gt;&lt;p&gt;Plotter目前支持使用HTML5画布的后端，也支持wasm，在其项目demo里有plotters+wasm的示例。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9f7f50111a7ab088739ddeb1c611ee5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic4.zhimg.com/v2-9f7f50111a7ab088739ddeb1c611ee5f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9f7f50111a7ab088739ddeb1c611ee5f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic4.zhimg.com/v2-9f7f50111a7ab088739ddeb1c611ee5f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9f7f50111a7ab088739ddeb1c611ee5f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0fa0e3be7e947292d0251eb54eac3067_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;480&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;640&quot; data-original=&quot;https://pic4.zhimg.com/v2-0fa0e3be7e947292d0251eb54eac3067_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0fa0e3be7e947292d0251eb54eac3067_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;480&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;640&quot; data-original=&quot;https://pic4.zhimg.com/v2-0fa0e3be7e947292d0251eb54eac3067_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0fa0e3be7e947292d0251eb54eac3067_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/38/plotters&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;plotters&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「物理模拟」Calcify 0.5.6 发布&lt;/h3&gt;&lt;p&gt;Calcify是用于3-D和4-D矢量和矩阵代数的crate，被设想用于物理模拟。它基于一个基本的ThreeVec结构构建，包括内置的最常用操作。它包括物理常量，3和4-D向量和矩阵以及许多相关的操作，集合，直方图和输出树，可以在json或MessagePack中序列化。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/JTPond/calcify&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;calcify&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;terminal-typeracer: 命令行打字游戏&lt;/h3&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1f89d8206efee584bba8a0bd72c3765e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1812&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1812&quot; data-original=&quot;https://pic3.zhimg.com/v2-1f89d8206efee584bba8a0bd72c3765e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1f89d8206efee584bba8a0bd72c3765e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1812&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1812&quot; data-original=&quot;https://pic3.zhimg.com/v2-1f89d8206efee584bba8a0bd72c3765e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1f89d8206efee584bba8a0bd72c3765e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitlab.com/DarrienG/terminal-typeracer&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;terminal-typeracer&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;pris:一种用于设计幻灯片和其他图形的特定领域语言&lt;/h3&gt;&lt;p&gt;特性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;可以编译为PDF&lt;/li&gt;&lt;li&gt;完整的排版控制&lt;/li&gt;&lt;li&gt;一流的检查和操作支持&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ruuda/pris&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;pris&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;limber: 用于备份Elasticsearch文档的简单（但快速）工具&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/whitfin/limber&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;limber&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「嵌入式」Hawk-Rust系列：树莓派相机的驱动&lt;/h3&gt;&lt;p&gt;Raspberry Pi提供了一组GPIO（通用输入/输出）引脚，允许您控制用于物理计算的电子组件并探索物联网（IoT）。 相机模块是Raspberry Pi的绝佳配件，它允许用户拍摄静态照片并以全高清录制视频。&lt;/p&gt;&lt;p&gt;HAWK是一个基于Rust的图像识别项目，它通过使用RFID卡进行用户识别和Image进行用户验证来实现双因素身份验证。本文展示了如何使用Rust程序触发树莓派的摄像头。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.knoldus.com/hawk-rust-series-actuation-of-raspberry-pi-camera/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/knoldus/hawk&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;hawk&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;orkhon: 机器学习框架和运行时&lt;/h3&gt;&lt;p&gt;Orkhon是用于机器学习的Rust框架，用于运行/使用用Python编写的推理/预测代码，冻结模型和处理未知（unseen）数据。 &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/vertexclique/orkhon&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;orkhon&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;metrics: 高性能metrics(性能指标)库&lt;/h3&gt;&lt;p&gt;基于trait抽象，提供稳定API，支持Prometheus&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/metrics-rs/metrics&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;metrics&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;leg: 用于美化命令行输出的库&lt;/h3&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-07327f4969b98f39da9270e418d33a1a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;555&quot; data-rawheight=&quot;266&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;555&quot; data-original=&quot;https://pic3.zhimg.com/v2-07327f4969b98f39da9270e418d33a1a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-07327f4969b98f39da9270e418d33a1a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;555&quot; data-rawheight=&quot;266&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;555&quot; data-original=&quot;https://pic3.zhimg.com/v2-07327f4969b98f39da9270e418d33a1a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-07327f4969b98f39da9270e418d33a1a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/jesusprubio/leg&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;leg&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;nameof - 替代 stringify! 的一个宏&lt;/h3&gt;&lt;p&gt;设计这个库的目的是改进调试体验，对比 stringify!() 来说，有利于更方便地重构。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/SilentByte/nameof&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;j4rs 從rust调用java&lt;/h3&gt;&lt;p&gt;在rust裡面建立 JvmBuilder 再调用 java 函數&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bur020/announcing_j4rs_calling_java_code_from_rust/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;一個乒乓球的遊戲使用WASM&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bv41o9/a_pong_game_with_wasmbindgen_websys_and_jssys/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;rust-battop: 交互式终端笔记本电池电量可视化工具&lt;/h3&gt;&lt;p&gt;基于Tui-rs实现。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/svartalf/rust-battop&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rust-battop&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;从Rust调用Go库：使用SQIP进行案例研究&lt;/h3&gt;&lt;p&gt;SQIP 是基于SVG 的LQIO 方案，其能够用于生成可用的SVG格式。作者之前用Node.js中的SQIP包，但是不够稳定，然后又打算用Rust重新实现，又不打算重头编写，所以找到了SQIP的Go绑定库，想通过FFI在Rust中调用Go代码。但是和Cgo打交道，性能不知道如何。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.arranfrance.com/post/cgo-sqip-rust/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;dua - 并行的文件统计工具&lt;/h3&gt;&lt;p&gt;也就是 du 的翻版啦。这个用上了Rust的并行化技术。速度比原来的 du 更快，特别是在SSD下更快。比如像下面这样测试&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;time du -sh real 0m1.003s

time dua -t 8 real 0m0.378s

time dua -t 1 real 0m0.971s&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Byron/dua-cli&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;sunfish 国际象棋游戏&lt;/h3&gt;&lt;p&gt;是对之前的实现的Rust重写。可以在&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//lichess.org/%40/sunfish_rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;试玩。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Recursing/sunfish_rs/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;minisketch-rs - @sipa 的 minisketch 库的 Rust 绑定&lt;/h3&gt;&lt;p&gt;minisketch 是一种用于提升比特币网络的交易传输效率的技术。@sipa 是比特币开发者。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/eupn/minisketch-rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Weave - 终端 http 路由/代理&lt;/h3&gt;&lt;p&gt;是一个命令行工具。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/jsdw/weave&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;wgpu - 用 Rust 实现 WebGPU 协议&lt;/h3&gt;&lt;p&gt;这个库基于 gfx-hal 来做。这个库会同时支持 WebGPU 和 WebGL。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/gfx-rs/wgpu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;最近出现的Rust实现的新的语言&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//sites.google.com/view/lcore&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;LambdaCore: Lisp家族又多了一员&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ffwff/hana&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;haha: 一个简单的动态脚本语言，受js和Ruby启发。使用C实现的VM，Rust来实现解析编译为特定字节码haru&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2019-06-03-67895055</guid>
<pubDate>Mon, 03 Jun 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust I18N 方案梳理</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2019-05-29-67402361.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/67402361&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0fa226d3612f254ff9b1e8d1a2b2b1ea_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;借着为Rust官网翻译的这次机会，仔细看了下Rust官网项目的I18N方案，发现这个方案很不错的。也顺便梳理了一些Rust生态中的其他方案，做了一个脑图分享，供有需要者参考。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-01b267665d80cbcbce47ce428a9a65c2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2718&quot; data-rawheight=&quot;4096&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;2718&quot; data-original=&quot;https://pic3.zhimg.com/v2-01b267665d80cbcbce47ce428a9a65c2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-01b267665d80cbcbce47ce428a9a65c2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2718&quot; data-rawheight=&quot;4096&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;2718&quot; data-original=&quot;https://pic3.zhimg.com/v2-01b267665d80cbcbce47ce428a9a65c2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-01b267665d80cbcbce47ce428a9a65c2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2019-05-29-67402361</guid>
<pubDate>Wed, 29 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust日报」2019每周精选 • 第十七期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2019-05-27-67120477.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/67120477&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23599072636a1820bba7b49b9d586092_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言：&lt;br/&gt;从2018年开始，我每天会花1个小时关注Rust社区动态，并且分享我每天的见闻，偶尔也夹杂了一些个人的观点。新的一年过去了，Rust日报已经成为了Rust社区群大家每天必看的内容。&lt;br/&gt;从2019年开始，日报小组成立，目前的动态由：@Chaos、 @Mike、 @Damody(台湾)轮番为大家播报。也欢迎感兴趣的朋友加入小组。&lt;br/&gt;每周也会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。&lt;br/&gt;独立日报订阅地址： - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//t.me/rust_daily_news&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Telgram Channel&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/chaosbot/rustnews&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;阿里云语雀订阅&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//steemit.com/%40blackanger&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Steemit&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/RustStudy/rust_daily_news&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub&lt;/a&gt;&lt;br/&gt;社区学习交流平台订阅： - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust.cc/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust.cc论坛&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rustforce.net/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust Force&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust.cc/article%3Fid%3Ded7c9379-d681-47cb-9532-0db97d883f62&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;微信公众号：Rust语言学习交流&lt;/a&gt;&lt;br/&gt;2019-05-26&lt;/blockquote&gt;&lt;hr/&gt;&lt;h2&gt;官方新闻&lt;/h2&gt;&lt;h3&gt;「官方」Rust 2019年活动记录&lt;/h3&gt;&lt;p&gt;记录了从2018年12月到未来12月的一些活动。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.rust-lang.org/2019/05/20/The-2019-Rust-Event-Lineup.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Rust 1.35 稳定版预发布&lt;/h3&gt;&lt;p&gt;1.35增加的一些特性摘要：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;为&lt;code&gt;Box&amp;lt;FnOnce&amp;gt;&lt;/code&gt;, &lt;code&gt;Box&amp;lt;FnMut&amp;gt;&lt;/code&gt;, 和&lt;code&gt;Box&amp;lt;Fn&amp;gt;&lt;/code&gt;实现了FnOnce/FnMut/Fn。（来自社区 @crlf0710的贡献 ），相关PR：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/rust/pull/59500&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;#59500&lt;/a&gt;&lt;/li&gt;&lt;li&gt;支持将闭包转换为usnafe的函数指针。&lt;/li&gt;&lt;li&gt;增加了&lt;code&gt;wasm32-unknown-wasi&lt;/code&gt; Target。&lt;/li&gt;&lt;li&gt;线程在Debug模式下将显示ID。&lt;/li&gt;&lt;li&gt;&lt;code&gt;alloc::System&lt;/code&gt;实现了&lt;code&gt;Default&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;&lt;code&gt;dbg!()&lt;/code&gt;支持无参数调用。&lt;/li&gt;&lt;li&gt;ASCII转换速度提升了4倍速。&lt;/li&gt;&lt;li&gt;稳定了一些API。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/rust/blob/stable/RELEASES.md%23version-1350-2019-05-23&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust 1.35 release note&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「官方」Unsafe Rust安全检查：栈借用模型 2.1&lt;/h3&gt;&lt;p&gt;ralfj比较高产，他负责Unsafe下内存模型相关的工作，目的是用miri来检测unsafe中的UB行为。为了达成这个目标，他陆续研究出以下一些借用模型：&lt;/p&gt;&lt;p&gt;栈借用模型1：&lt;/p&gt;&lt;p&gt;他在去年引入了栈借用模型1用于定义在unsafe内存模型中允许哪种别名。建立合理的别名规则，才能基于miri来检查unsafe下的UB行为。&lt;/p&gt;&lt;p&gt;该模型的核心思想是： 对于一个内存位置，逐步建立可跟踪的引用，形成一个栈结构。比如有一个&amp;amp;mut i32，可以对其重新借用获得一个新引用。这个新引用是必须用于此位置的引用，建立在旧引用之上。当新引用过期的时候，旧引用会被激活，就好像是栈结构push和pop。&lt;/p&gt;&lt;p&gt;在Safe Rust中，通常有借用检查来保护内存。但是在编写Unsafe代码的时候，借用检查就无法提供帮助了。所以，Rust核心团队就必须要定义一组规则，即使对于Unsafe代码来说也是非常有意义的。&lt;/p&gt;&lt;p&gt;栈借用模型2:&lt;/p&gt;&lt;p&gt;在上一篇文章中，ralfj又带来了栈借用模型的升级，栈借用2。&lt;/p&gt;&lt;p&gt;在栈借用1模型中，有一个概念叫做「frozen」，处于frozen位置的指针，只能读取，不能写入。它允许可变借用也能读取（检查粒度比较粗，把可变指针和共享指针同一化处理）。但是现在该模型被发现一个问题：当使用可变借用的时候，在该模型下可能会把某些未定义行为判断为合法。为了改进这个问题，栈借用模型2将精确跟踪允许访问的原生指针（更细粒度的检查，区分了共享指针和可变指针），而不是「frozen」。检查粒度比模型1更细。&lt;/p&gt;&lt;p&gt;栈借用模型2还有很多已知的问题，比如其实并没有真正使用到「栈」，反而更像「树」。但这还不是最后的结论。本文比较长，去原文阅读更多信息。&lt;/p&gt;&lt;p&gt;栈借用模型2.1:&lt;/p&gt;&lt;p&gt;在今天这篇文章中，ralfj又发现了上次的栈借用2模型存在一些问题：结合内部可变性，行为并不总是他们想要的。在模型2.0中，说到其实没有真正使用「栈结构」是在读取访问的时候，事实上进行「写访问」的时候，还是可以维护一个「栈结构」。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnsafeCell&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnsafeCell&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner_uniq&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// stack: [c: SharedReadWrite, inner_uniq: Unique]
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner_shr&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner_uniq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// adds a SharedReadWrite
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// stack: [c: SharedReadWrite, inner_uniq: Unique, inner_shr: SharedReadWrite]
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnsafeCell&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// invalidates inner_shr
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// stack: [c: SharedReadWrite]
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_val&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner_shr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// error because the tag is not on the stack any more
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于这段代码，之前是「合法的」，但是用栈模型2.1来处理的话，就是UB。UnsafeCell是一个内部可变性容器，栈借用模型2.1会在栈中维护SharedReadWrite指针。像上面代码第4行，如果在设置了inner_shr之后，又重置了c变量容器内的值，栈借用结构就会改变，最后一行再使用inner_shr指针就可以检测到非法了，它是一个UB。但是在栈借用模式2.0中，最后代码执行的时候，堆栈将改为[c：SharedReadWrite，inner_shr：SharedReadWrite]，从而允许最终访问，这就是问题所在。&lt;/p&gt;&lt;p&gt;这样一来，相当于是栈模型1.0和栈模型2.0的结合？还可以在Unsafe代码导读中看到栈借用模型2.1的完整描述。&lt;/p&gt;&lt;p&gt;后续：ralfj将会写一篇关于栈借用模型的完整论文，当然，可能还是他自己的博士论文更重要吧，毕业最重要了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.ralfj.de/blog/2019/04/30/stacked-borrows-2.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Unsafe代码导读：wip/stacked-borrows&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Rust Nightly 1.36.0中已经弃用了&lt;code&gt;mem::uninitialized&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Rust的臭名昭著的&lt;code&gt;mem::uninitialized&lt;/code&gt;方法在今天的每晚构建中已被弃用。它的替代品&lt;code&gt;MaybeUninit&lt;/code&gt;已经开始稳定。如果你正在使用前者，则应尽快迁移到使用后者（可能在6周内达到稳定）。因为这是一个break change的修改。&lt;/p&gt;&lt;p&gt;这篇文章主要讨论了未初始化内存的性质以及如何在Rust中使用它。并且探讨了&lt;code&gt;mem::uninitialized&lt;/code&gt;为什么会被弃用，以及&lt;code&gt;MaybeUninit&lt;/code&gt;是什么。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gankro.github.io/blah/initialize-me-maybe/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/brek0w/heres_my_type_so_initialize_me_maybe/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reddit 讨论&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h2&gt;社区新闻&lt;/h2&gt;&lt;h3&gt;github 推出了beta 版的sponsor功能&lt;/h3&gt;&lt;p&gt;第一批里面就有diesel(Rust的ORM框架)的作者 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/users/sgrif/sponsorship&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;sgrif/sponsorship&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;经过3年零8个月的工作，WebRender将向稳定的用户发货！&lt;/h3&gt;&lt;p&gt;今年5月21日，5％的稳定用户将开始启用WebRender。 &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bqmyzm/after_3_years_and_8_months_of_work_webrender_will/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;WebRender使用与游戏相同的基于GPU的加速技术重写了Firefox渲染架构，现在适用于一些选定的Win10设备。WebRender使用的现代架构主要是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;合成器中页面的表示不再是一组栅格化图层，而是现在的一个未经过图形化的显示列表。&lt;/li&gt;&lt;li&gt;合成和光栅化步骤已加入到单个GPU驱动的渲染步骤中。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;有关更多详细信息，请参阅Lin Clark的Hacks系列文章。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mozillagfx.wordpress.com/2019/05/21/graphics-team-ships-webrender-mvp/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lin Clark的Hacks系列文章：WebRender如何摆脱jank&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/servo/webrender&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;webrender&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;actix-web已经发布了1.0 rc版本&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/actix/actix-web/tree/web-v1.0.0-rc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;web-v1.0.0-rc&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;为什么选择Rust - 一个视频&lt;/h3&gt;&lt;p&gt;Buoyant CTO Oliver Gould (@olix0r) 和他的一个同事，参加了 The Open Source Show，大谈为什么选择Rust。&lt;/p&gt;&lt;p&gt;Buoyant 就是开发 Linkerd 这个 service mesh 产品的那个公司，懂了吧。&lt;/p&gt;&lt;p&gt;00:51 哪种类型的程序员使用Rust？ 02:29 为什么Linkerd使用Rust? 03:12 Rust的历史 04:24 Oliver使用Rust的经历&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//channel9.msdn.com/Shows/The-Open-Source-Show/All-About-Rust&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;俄罗斯的一家计算机夜校的Rust课程回顾记录&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//matklad.github.io/2019/05/19/rust-course-retrospective.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/playlist%3Flist%3DPLlb7e2G7aSpTfhiECYNI2EZ1uAluUqE_e&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/matklad/rust-course&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Slides&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Cargo 5730号issues的解决办法&lt;/h3&gt;&lt;p&gt;Cargo无法处理启用了不同feature的不同类型的依赖项，这对于no_std项目来说是一个大问题。所以有人写了一个cargo-5730库，来帮助解决此问题。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/cargo/issues/5730&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;#5730&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/auxoncorp/cargo-5730&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;cargo-5730&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;「学术」gbdt-rs: 用纯Safe Rust编写的梯度提升决策树库&lt;/h3&gt;&lt;p&gt;gbdt-rs提供训练和推理功能。 它可以使用xgboost训练的模型来完成推理任务。gbdt-rs论文已被IEEE S＆P&amp;#39;19接受！&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/mesalock-linux/gbdt-rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;gbdt-rs&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/mesalock-linux/gbdt-rs/blob/master/gbdt.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;相关论文&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;「Rust编写命令行应用」是悲剧？&lt;/h3&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1323bd359788b6a77401b20417557620_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1323bd359788b6a77401b20417557620_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-1323bd359788b6a77401b20417557620_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;他说的很对，Rust近两年确实是开启了一场轰轰烈烈的命令行大替换运动。但是不是悲剧呢？&lt;/p&gt;&lt;p&gt;按他的说法：Rust产出的这个命令行工具大小基本是4MB以上，性能要59ms，所以，这个太悲剧了。&lt;/p&gt;&lt;p&gt;拿Rust编写的替代ls命令的exa来说，brew安装大小是1.4MB，其实也没超过2MB。9012年了，你的磁盘空间就这么不够用吗，都干啥了？运行一次的时间我没测过，但我觉得就算真的是59ms我也是可以接受的，因为在我的反应时间之外，并没有多卡。我在本地尝试用exa列出TiKV（算得上一个大型项目了）的树形列表，也没有感觉到有卡顿。所以悲剧在哪？&lt;/p&gt;&lt;p&gt;软件写出来是让人用的吧？&lt;/p&gt;&lt;p&gt;exa的介绍第一句话就是： You list files hundreds of times a day. Why spend your time squinting at black and white text? 你每天列出数百次文件，为什么你要花时间眯着眼睛看黑白文字？&lt;/p&gt;&lt;p&gt;exa提供了很多功能，其中，高亮显示文本（区分各种元数据、文件、目录、或其他格式，比如symlinks），是大多数Rust编写的命令行工具的底线。这是Rust社区，Rust文化的体现，就是让大家感受到更好的「人体工程学」。除了高亮显示，还有很多功能，比如支持git、扩展属性等。&lt;/p&gt;&lt;p&gt;所以，为什么要重写exa呢？是为了给大家节省时间，提升工作效率啊，同志们！&lt;/p&gt;&lt;p&gt;同样，有很多优秀的Rust重写的命令行工具，比如ripgrep，你怎么不说说它的搜索性能呢？ &lt;/p&gt;&lt;p&gt;说了这么多，主要是想说明：&lt;/p&gt;&lt;p&gt;用Rust重写或者新开发的命令行App，是为了让咱们这个世界更加安全、美好。这个重写，并不是盲目的。在需要安全、需要性能的地方，也不会含糊。大家都试试新工具吧。&lt;/p&gt;&lt;p&gt;所以，到底什么是悲剧呢？大家想一想吧。  &lt;/p&gt;&lt;h3&gt;「讨论」对于单人主力维护的项目如何看待&lt;/h3&gt;&lt;p&gt;楼主覺得 actix 和 rust-postgres 很棒&lt;/p&gt;&lt;p&gt;但發現這兩個庫都只有一個大佬在當主力開發，他覺得庫只有一人維護對大公司來說不是問題&lt;/p&gt;&lt;p&gt;但對無力繼續維護的小客戶來說是個問題，大家覺得呢？&lt;/p&gt;&lt;p&gt;（其实很多项目都是单人在撑）&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bsdnih/concerns_about_some_major_libs_being_onemanshows/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;在 Mac 下面调优 TiKV&lt;/h3&gt;&lt;p&gt;该文介绍了如何在Mac下对TiKV进行了性能测试。&lt;/p&gt;&lt;p&gt;里面介绍了一个工具：DTrace，可以方便在Mac下对Rust项目进行性能测试，并可以支持生成火焰图等报告。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/a80010878def&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;学习资源&lt;/h2&gt;&lt;h3&gt;case-studies: Rust实例探究&lt;/h3&gt;&lt;p&gt;该库展示了一些棘手的Rust代码示例，这些代码是dtolnay（syn作者，Rust宏的高手）在使用Rust（他自己和其他人）中的各种高级宏库时遇到的问题集合。该项目致力于对Rust宏开发的一个深刻洞察：擅长使用宏的人和宏专家之间的区别主要与他们擅长“宏”的程度是无关的。&lt;/p&gt;&lt;p&gt;这也许是学习Rust宏的一个非常好的案例。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/dtolnay/case-studies&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;case-studies&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;多语言混合项目的一些经验&lt;/h3&gt;&lt;p&gt;长文预警！作者在写自己的库bitvec的时候，开始考虑，如何将其用于其他语言，比如他如果在一个C++程序中想用bitvec怎么办？所以他开始设计一套针对为Rust crate编写FFI的惯用法。这篇文章记录了他从API设计到实现的一些经验，值得一读。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//myrrlyn.net/blog/misc/polyglot-projects&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/myrrlyn/bitvec&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;bitvec&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/myrrlyn/bitvec/tree/feature/ffi&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;bitvec ffi branch&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;一篇好文，教你如何在编程的过程中避免克隆&lt;/h3&gt;&lt;p&gt;作者分享了一些技巧和经验，推荐阅读。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//thenewwazoo.github.io/clone.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;用Rust写编译器&lt;/h3&gt;&lt;p&gt;其实用Rust尝试和玩儿写编译器的已经很多了。这篇文章讲得很详细。作者发现用Rust写编译器很舒服。他个人编码只花了大约 60 个小时。&lt;/p&gt;&lt;p&gt;做编译方面工作的朋友推荐阅读。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//thume.ca/2019/04/18/writing-a-compiler-in-rust/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「小技巧」操作数组应该使用Chain而非Concat&lt;/h3&gt;&lt;p&gt;当应用程序需要迭代来自不同源的大量数组，那么具有C/C++背景的人可能会将所有数组复制到单个Vec中并迭代此Vec。在为连续Vec缓冲区分配堆内存方面，此策略将导致高成本。相反，将数据保留在原来的位置，使用Chain将它们链在一起去迭代会省不少成本。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//frehberg.com/2019/05/rust-arrays-make-chains-no-concat/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;交叉编译和静态链接Rust库&lt;/h3&gt;&lt;p&gt;该文作者的团队几年前用Rust重写了Python的特定后端服务，取得了巨大的成功。 现在，为了便于开发和测试，正在探索将部分C/C++代码库移动到Rust的想法。作为第一步尝试，他们先将Rust集成到现有代码中，而不是一次性重写所有项目。所以他们做了一系列实验，在C/C++中调用Rust。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/csis-techblog/cross-compiling-and-statically-linking-against-rust-libraries-2c02ee2c01af&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「系列」Rust for OOP系列 ：项目管理&lt;/h3&gt;&lt;p&gt;这位博主打算写一系列主题是Rust for OOP的文章，主要是针对有一定OOP语言开发经验的人来学习。这是第一篇，介绍了Cargo和crate、模块等知识。初学者可以看看。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//oribenshir.github.io/afternoon_rusting/blog/project-management&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「异步Explained系列」Rust异步如何工作&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//levelup.gitconnected.com/explained-how-does-async-work-in-rust-c406f411b2e2&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Explained: How does async work in Rust&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//itnext.io/explained-rust-futures-for-web-development-b1d0632490e7%3Fsk%3D9962ac666e1a56bc4fe53afc902008fa&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Explained: Futures in Rust for Web Development&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;使用Rust加速Ruby MRI&lt;/h3&gt;&lt;p&gt;一个使用Rust加速Ruby程序的案例，以i18n gem为示例讲述。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/swlh/speeding-up-ruby-mri-with-rust-a7c914d2f9d0&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;切片索引检查导致的3倍性能下降问题一例&lt;/h3&gt;&lt;p&gt;作者发现下面这两片代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pub fn insertion_sort(data: &amp;amp;mut [i32]) {
    for sorted in 0..data.len() {
        let min = (sorted..data.len()).min_by_key(|&amp;amp;i| &amp;amp;data[i]).unwrap();
        data.swap(sorted, min);
    }
}

pub fn insertion_sort_fast(data: &amp;amp;mut [i32]) {
    unsafe {
        for sorted in 0..data.len() {
            let min = (sorted..data.len())
                .min_by_key(|&amp;amp;i| data.get_unchecked(i))
                .unwrap();
            std::ptr::swap(data.get_unchecked_mut(sorted), data.get_unchecked_mut(min));
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;性能有3倍左右的差距&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;insertions sort          time:   [551.79 us 553.24 us 555.71 us]                               
insertions sort (fast)   time:   [187.75 us 188.15 us 188.84 us]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;很奇怪。于是很多人给他建议。&lt;/p&gt;&lt;p&gt;换种写法，跟unsafe差不多快。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pub fn insertion_sort(data: &amp;amp;mut [i32]) {
    for sorted in 0..data.len() {
        let min = data
            .iter()
            .enumerate().skip(sorted)
            .min_by_key(|(i, e)| *e)
            .unwrap()
            .0;
        data.swap(sorted, min);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;打开 &lt;code&gt;-C opt-level=z&lt;/code&gt; 编译标志，按下面方式写：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pub fn insertion_sort_fast(data: &amp;amp;mut [i32]) {
    let mut data = data;
    while data.len() &amp;gt; 1 {
        let (head, tail) = data.split_first_mut().unwrap();
        let tailmin = tail.iter_mut().min().unwrap();
        if head &amp;gt; tailmin {
            std::mem::swap(head, tailmin);
        }
        data = tail;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;还有一种写法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pub fn insertion_sort_iter(data: &amp;amp;mut [i32]) {
    for sorted in 0..data.len() {
        let min = data[sorted..].iter().enumerate().min_by_key(|&amp;amp;(_, e)| e).unwrap().0;
        data.swap(sorted, min + sorted);
    }
}

insertions sort (fast) time:  [187.05 us 187.37 us 187.84 us]
insertions sort (iter) time:  [186.87 us 187.30 us 188.00 us]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;跟 unsafe 差不多。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bsvup3/300_performance_penalty_for_slice_index_checks/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;项目、工具与库&lt;/h2&gt;&lt;h3&gt;cargo-permissions: 检测篡改依赖的Cargo权限&lt;/h3&gt;&lt;p&gt;为了在&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//crates.io&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;crates.io&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;中保持健康安全的包（crate），需要尽可能多地强制检测任何类型的漏洞。随着软件包之间依赖关系的使用增加，漏洞传播的风险也会增加。在NPM等其他平台上，我们已经看到了很多这样的安全问题。Rust开发人员需要一个工具来回答有关其依赖关系的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;为什么png库使用网络层？&lt;/li&gt;&lt;li&gt;为什么http库使用文件系统层？&lt;/li&gt;&lt;li&gt;可能的场景（Possible scenarios）&lt;/li&gt;&lt;li&gt;读取未授权文件&lt;/li&gt;&lt;li&gt;请求不可信域名&lt;/li&gt;&lt;li&gt;执行未授权代码&lt;/li&gt;&lt;li&gt;盗取信息&lt;/li&gt;&lt;li&gt;盗用CPU资源&lt;/li&gt;&lt;li&gt;不安全地执行代码&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;cargo-permissions是一个概念证明的库（PoC），基于通过查找代码中的特定路径来检测恶意代码的想法，来保证crate的安全。此项目的主要思想是拥有一组与某些特定标准包列表相关联的权限。另一方面，通过AST分析，检查crate中使用的标准库。例如，如果包A开始使用&lt;code&gt;std::net&lt;/code&gt;库，则将获得net权限。所有使用包A作为依赖的crate都会间接获得net权限。遵循此方法，可以构建具有所有获取权限的依赖关系树。通过这组权限可以获取「超出控制范围的crate」尽可能多的信息。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//internals.rust-lang.org/t/cargo-permissions-to-detect-tampered-dependecies/10236&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;讨论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/fcsonline/cargo-permissions&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;cargo-permissions&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;sauron ： Web 前端开发框架发布0.7 发布&lt;/h3&gt;&lt;h2&gt;frontend&lt;/h2&gt;&lt;p&gt;仿 elm 的风格做的。其实，也是基于 yew 之上的封装。目标是易用，好用。&lt;/p&gt;&lt;p&gt;作者：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ivanceras&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ivanceras&lt;/a&gt;，是一位有趣的开发者。&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ivanceras/svgbob&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;svgbob&lt;/a&gt;，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ivanceras/spongedown&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;spongedown&lt;/a&gt;等，都是他的作品。&lt;/p&gt;&lt;h3&gt;「嵌入式Rust」erkos: 用Rust编写嵌入式操作系统&lt;/h3&gt;&lt;p&gt;erkos是日本的一名Rust开发者编写的嵌入式操作系统原型项目，目标架构是Arm Cortex-M系列。他也写了一篇文章介绍该项目。感兴趣的可以看看。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/garasubo/erkos&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;erkos&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/%40garasubo/my-project-to-write-embedded-os-in-rust-eadf83f5ee37&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;mini-aio: 新的异步IO库&lt;/h3&gt;&lt;p&gt;AdGear公司（一家实时广告平台）开源的库。这个库采用了与Rust中大多数其他异步IO库完全不同的方法：它实际上受到了Pony编程语言的启发。 因此，它不使用Futures，它不使用async/await，它只提供简单的trait。&lt;/p&gt;&lt;p&gt;比如，你想要实现HTTP server，只需要实现TcpListenNotify trait。该trait包含了listening、connected等方法。然后按正常的方式使用就可以，最终使用该库提供的event loop中执行：&lt;code&gt;event_loop.run()&lt;/code&gt;&lt;/p&gt;&lt;p&gt;之前日报里介绍过Pony的并发特点：引用能力（Reference Capabilities），Pony 语言中每种变量的类型都包含了有关如何在 actor 之间分享数据的信息。有点像Rust的借用检查器，同样保证数据安全性。所以Pony的异步是actor模型，和actix差不多。坊间有这样的说法，「Pony，当Rust遇上Erlang」。&lt;/p&gt;&lt;p&gt;所以，mini-aio也提供Handler trait，该trait允许接收从代码任何地方发来的消息并处理。&lt;/p&gt;&lt;p&gt;但要注意，此库处于alpha阶段。该库作者也写了不少Rust项目，可以看看他的个人仓库。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//antoyo.ml/mini-aio-new-async-io-library&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/FTP-rs/ftp-server-mini-aio&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;一个用mini-aio实现的FTP服务器：ftp-server-mini-aio&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/adgear/mini-rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;mini-rs&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/antoyo&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;作者antoyo GitHub仓库&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;coreutils: 为Unix和类Unix系统编写的Rust核心工具集&lt;/h3&gt;&lt;p&gt;该项目无意与GNU的coreutils 100％兼容，如Uutils的coreutils。瞄准最小但完整的实用程序集，只添加实用程序的几个实现和真正有用的函数之间通用的功能。目前该项目在寻求Review、贡献者、和建议。想要学习Rust的朋友，也可以从此项目入手。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/GrayJack/coreutils&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;coreutils&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;pyo3-file: pyo3的辅助库，方便处理类Python文件的对象&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/omerbenamram/pyo3-file/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;pyo3-file&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Rendy 0.2发布&lt;/h3&gt;&lt;p&gt;Rendy是基于gfx-hal的一个渲染引擎，属于Amethyst的项目。提供各种工具，如内存分配，资源管理，渲染图执行等。gfx-hal是99％的Vulkan API。 这就是Rendy存在的原因。而不是解决内存分配和纹理上传等低级任务，用户可以专注于创建令人敬畏的高性能渲染器。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/amethyst/rendy&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rendy&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;强悍性能的 blake2b_simd 和 blake2s_simd 姐妹花&lt;/h3&gt;&lt;p&gt;BLAKE 和 BLAKE2 是密码学哈希函数，来源于 Dan Bernstein 的 ChaCha。特点是在64位机上，性能比 SHA-3, SHA-2, SHA-1, 和 MD5 等都高。属于目前最高性能的哈希函数之一。而这两个库的实现，也在追求性能的极致。&lt;/p&gt;&lt;p&gt;以下是一些性能评测数据：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;╭─────────────────────────┬────────────╮
│ blake2s_simd many::hash │ 2.454 GB/s │
│ blake2s_simd BLAKE2sp   │ 2.421 GB/s │
│ sneves BLAKE2sp         │ 2.316 GB/s │
│ blake2b_simd many::hash │ 2.223 GB/s │
│ blake2b_simd BLAKE2bp   │ 2.211 GB/s │
│ sneves BLAKE2bp         │ 2.150 GB/s │
│ blake2b_simd BLAKE2b    │ 1.008 GB/s │
│ OpenSSL SHA-1           │ 0.971 GB/s │
│ sneves BLAKE2b          │ 0.949 GB/s │
│ libsodium BLAKE2b       │ 0.940 GB/s │
│ OpenSSL SHA-512         │ 0.666 GB/s │
│ blake2s_simd BLAKE2s    │ 0.647 GB/s │
╰─────────────────────────┴────────────╯&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与 &lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;╭─────────────────────┬────────────╮
│ b2sum --blake2sp    │ 1.727 GB/s │
│ b2sum --blake2bp    │ 1.618 GB/s │
│ b2sum --blake2b     │ 0.887 GB/s │
│ coreutils sha1sum   │ 0.854 GB/s │
│ coreutils b2sum     │ 0.713 GB/s │
│ coreutils md5sum    │ 0.632 GB/s │
│ coreutils sha512sum │ 0.620 GB/s │
│ b2sum --blake2s     │ 0.603 GB/s │
╰─────────────────────┴────────────╯&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;评测的环境和对比请进下面的 Repo 查看。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/BLAKE_%28hash_function%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Blake&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blake2.net/blake2.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;论文&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/oconnor663/blake2_simd%23performance&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt; &lt;/p&gt;&lt;h3&gt;cargo-play&lt;/h3&gt;&lt;p&gt;一個好用的工具，讓你可以快速的編譯執行单个rust文件，并且可以支持第三方crate。不再需要把整個編譯项目目錄创建好&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/fanzeyi/cargo-play&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Into The Wild&lt;/h3&gt;&lt;p&gt;有人用rust寫了一個很像lf2(Little Fighter 2)的2.5D動作遊戲&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//azriel.im/will/2019/05/24/into-the-wild/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;hors 0.3.0&lt;/h3&gt;&lt;p&gt;一個類似 google search 找解答的工具&lt;/p&gt;&lt;p&gt;howdoi 的 rust 實作版本&lt;/p&gt;&lt;p&gt;比如你有個問題叫 &amp;#34;how to parse json in rust&amp;#34;&lt;/p&gt;&lt;p&gt;使用下列指令&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;hors &amp;#34;how to parse json in rust&amp;#34; -a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;得到解答&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;- Answer from https://stackoverflow.com/questions/30292752/how-do-i-parse-a-json-file

Solved by the many helpful members of the Rust community:

extern crate rustc_serialize;
use rustc_serialize::json::Json;
use std::fs::File;
use std::io::Read;

fn main() {
    let mut file = File::open(&amp;#34;text.json&amp;#34;).unwrap();
    let mut data = String::new();
    file.read_to_string(&amp;amp;mut data).unwrap();

    let json = Json::from_str(&amp;amp;data).unwrap();
    println!(&amp;#34;{}&amp;#34;, json.find_path(&amp;amp;[&amp;#34;Address&amp;#34;, &amp;#34;Street&amp;#34;]).unwrap());
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bsg9w4/hors_030_is_released_it_supports_google_search/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Mockiato ：一個嚴格友好的Mock測試庫&lt;/h3&gt;&lt;p&gt;對測試有需求的同學可以試試看&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#[cfg(test)]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mockiato&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;mockable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#[cfg_attr(test, mockable)]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Greeter&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;greet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#[cfg(test)]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tests&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;::&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#[test]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;greet_the_world&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greeter&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GreeterMock&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greeter&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expect_greet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;partial_eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;world&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;Hello world&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assert_eq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;Hello world&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greeter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;world&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bshn0f/announcing_mockiato_a_strict_yet_friendly_mocking/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;cargo-cache 0.2.1&lt;/h3&gt;&lt;p&gt;這個工具可以幫助你管理 ~/.cargo/ 或 ${CARGO_HOME}&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Cargo cache &amp;#39;/home/matthias/.cargo&amp;#39;:

Total size:                             7.22 GB
Size of 101 installed binaries:           909.51 MB
Size of registry:                         1.46 GB
Size of registry index:                     63.65 MB
Size of 3082 crate archives:                435.72 MB
Size of 2038 crate source checkouts:        963.10 MB
Size of git db:                           4.84 GB
Size of 107 bare git repos:                 980.81 MB
Size of 100 git repo checkouts:             3.86 GB
cargo cache query &amp;#34;^serde*&amp;#34;

Registry cache sorted by name:
    serde-0.6.15: 16988
    serde-0.7.15: 22719
    serde-0.8.23: 25824
[...]

Registry source cache sorted by name:
    serde-0.8.23: 168461
    serde-1.0.80: 477759
    serde-1.0.82: 485084&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bspb17/cargocache_021_released_conquer_your_cargo_home/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;漫游 Tox-rs，第一部分&lt;/h3&gt;&lt;p&gt;长文预警。&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tox-rs/tox&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tox&lt;/a&gt; 是一个安全的P2P核心服务，加密传输，易于使用的基于DHT的网络。是toxcore的Rust实现，toxcore目前被用来做P2P安全IM服务核心。&lt;/p&gt;&lt;p&gt;Tox 原来是个C项目，作者用Rust通过审视发现，实现里面有不少漏洞，易被攻击。所以他用Rust重写了它。就是上面那个项目地址。现在作者，开始整理这几年的工作，开始生成文档。&lt;/p&gt;&lt;p&gt;有很多客户端可以使用，比如qTox。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//habr.com/ru/post/447994/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;ccl - 据说是目前为止性能最高的并发哈希库&lt;/h3&gt;&lt;p&gt;ccl 目前包含一个并发hashmap和一个并发时限缓存，初步的评测很强力。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;20k inserts + 20k mut lookups with replace 16C/32T Xeon 2.1Ghz Hetzner CXX51

hashbrown_rwlock        time:   [64.199 ms 64.234 ms 64.266 ms]                              

chashmap                time:   [15.190 ms 15.220 ms 15.251 ms]                      

dhashmap_ccl            time:   [1.0199 ms 1.0244 ms 1.0303 ms]     

concache                time:   [126.15 ms 126.61 ms 127.03 ms]   

crossbeam-skiplist      time:   [10.648 ms 10.681 ms 10.713 ms]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitlab.nebulanet.cc/xacrimon/rs-hm-bench&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitlab.nebulanet.cc/xacrimon/ccl&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2019-05-27-67120477</guid>
<pubDate>Mon, 27 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust日报」2019每周精选 • 第十六期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2019-05-21-66310889.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66310889&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23599072636a1820bba7b49b9d586092_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言：&lt;br/&gt;从2018年开始，我每天会花1个小时关注Rust社区动态，并且分享我每天的见闻，偶尔也夹杂了一些个人的观点。新的一年过去了，Rust日报已经成为了Rust社区群大家每天必看的内容。&lt;br/&gt;从2019年开始，日报小组成立，目前的动态由：@Chaos、 @Mike、 @Damody(台湾)轮番为大家播报。也欢迎感兴趣的朋友加入小组。&lt;br/&gt;每周也会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。&lt;br/&gt;独立日报订阅地址： - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//t.me/rust_daily_news&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Telgram Channel&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/chaosbot/rustnews&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;阿里云语雀订阅&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//steemit.com/%40blackanger&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Steemit&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/RustStudy/rust_daily_news&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub&lt;/a&gt;&lt;br/&gt;社区学习交流平台订阅： - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust.cc/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust.cc论坛&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rustforce.net/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust Force&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust.cc/article%3Fid%3Ded7c9379-d681-47cb-9532-0db97d883f62&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;微信公众号：Rust语言学习交流&lt;/a&gt;&lt;br/&gt;2019-05-19&lt;/blockquote&gt;&lt;hr/&gt;&lt;h2&gt;官方新闻&lt;/h2&gt;&lt;h3&gt;「官宣」Rust四周年&lt;/h3&gt;&lt;p&gt;从2015年5月15日Rust 1.0版发布至今，取得了如下成绩：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;连续四年StackOverflow的“最受喜爱的编程语言” （日报君感慨：近一年半看了很多社区内的各种动态，大家形容Rust用的最多的一个词是：Amazing，如果非要翻译成中文，我觉得「赞叹」比较好。）&lt;/li&gt;&lt;li&gt;稳定了嵌入式Rust&lt;/li&gt;&lt;li&gt;rustc成为第一个专注于支持WASM的编译器&lt;/li&gt;&lt;li&gt;Rust 2018 edition发布&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//Crates.io&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;Crates.io&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;通过了10亿次下载，拥有超过25,000个crate&lt;/li&gt;&lt;li&gt;现在全世界有超过100个聚会，分布在42个国家&lt;/li&gt;&lt;li&gt;6场新的大会在世界各地涌现（RustRush，RustCon Asia，Oxidize，Rust LATAM，Colorado Gold Rust，RustLab Italy）&lt;/li&gt;&lt;li&gt;很多大公司大平台陆续引入了Rust&lt;/li&gt;&lt;li&gt;也涌现了不少优秀的开源项目和产品&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个清单如果继续写下去会很长，Rust已经在众多领域陆续开花了。Rust社区感谢有你！&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.rust-lang.org/2019/05/15/4-Years-Of-Rust.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;稳定cargo 离线模式 pr合并了&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/cargo/pull/6934&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pr&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这个的意思是，以后可以指示 cargo 去本地找依赖包缓存。而不是每次都检查网络了。非常实用的进展。&lt;/p&gt;&lt;p&gt;等等稳定版的发布，到时有使用说明。&lt;/p&gt;&lt;h3&gt;Rust 1.34.2发布&lt;/h3&gt;&lt;p&gt;该版本属于紧急发布，主要是修复CVE-2019-12083的安全问题：&lt;/p&gt;&lt;p&gt;Error类型提供了一个向下转换函数(downcast_ref)，可以将指定的类型转换为&lt;code&gt;Error::type_id&lt;/code&gt;对应的类型。 问题是，如果你自己的类型实现Error，并让type_id返回与实际类型不同的东西。然后，当有人在你的类型上调用downcast时，它将完全通过安全代码转换为你想要的任何东西。&lt;/p&gt;&lt;p&gt;在Safe Rust中出现内存不安全的问题是无法容忍的。新版本的发布主要是将已经稳定的&lt;code&gt;Error::type_id&lt;/code&gt;紧急改为了Unstable。后续再慢慢考虑&lt;code&gt;Error::type_id&lt;/code&gt;的重新稳定化方案。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2019-12083&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CVE-2019-12083&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.rust-lang.org/2019/05/14/Rust-1.34.2.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2018%26gist%3D90a7a46a265ac5cf46d51bd71d2e98e6&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;安全问题演示demo：Playground&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;wasm-bindgen v0.2.44 开始支持futures 0.3和async/await&lt;/h3&gt;&lt;p&gt;wasm 已經可以使用 async了，快看看怎麼用吧&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bphw68/wasmbindgen_v0244_has_support_for_futures_03_and/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reddit讨论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rustwasm/wasm-bindgen/blob/master/CHANGELOG.md%230244&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;rust 1.36.0 加入了Cargo流水線加速編譯技術&lt;/h3&gt;&lt;p&gt;利用下圖的方式加速&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[-libA----|--------]
          [-libB----|--------]
                             [-binary-----------]
0s        5s       10s       15s                25s&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Cargo在内部构建了一个DAG来表示crate之间的依赖关系，通常需要等待crate依赖关系构建完成才会启动编译，但是现在对Cargo进行了优化，现在只要得到编译器为了开始下一次编译而生成的“元数据”即可开始编译，这就是所谓的「流水线（pipeline，就像工厂流水线一样，节省加工时间）」加速编译技术。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bpucwt/evaluating_pipelined_rustc_compilation/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reddit 讨论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;安全代码工作组正在为创建可重现的构建和构建时间沙盒化而努力&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-secure-code/wg&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust 安全代码工作组&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-secure-code/cargo-repro&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;cargo-repro&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-secure-code/cargo-sandbox&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;cargo-sandbox&lt;/a&gt;&lt;/p&gt;&lt;p&gt;相关博文：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64586315&quot; class=&quot;internal&quot;&gt;「警惕」存在于crate中的安全风险&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;社区新闻&lt;/h2&gt;&lt;h3&gt;「论文」从理论到系统：编程语言教育的基础方法&lt;/h3&gt;&lt;p&gt;来自斯坦福大学CS242课程的设计者Will Crichton发表的关于将Rust和WebAssembly应用于编程教育的论文。&lt;/p&gt;&lt;p&gt;国内外高等学府，比如清华大学、斯坦福都在陆续开始将Rust应用于学生的编程教育中，国内最早教授Rust的大学没记错的话，还有新兴的上海科技大学。为什么呢？因为他们看到了Rust的教育价值。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cs242.stanford.edu/f18/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CS242&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1904.06750&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;论文pdf&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Rust 职位：东京，机器人创业公司&lt;/h3&gt;&lt;p&gt;用 Rust 开发机器人？好诱惑。 这个职位在日本可能比较新鲜，创业公司，（估计）没有祖传代码，并且可以帮助办理签证，英语交流也可以，不强制要求日语。感兴趣的可以看看。&lt;/p&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7cef0c56c72348e076a374bf130e0d63_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1590&quot; data-rawheight=&quot;2408&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1590&quot; data-original=&quot;https://pic4.zhimg.com/v2-7cef0c56c72348e076a374bf130e0d63_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7cef0c56c72348e076a374bf130e0d63_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1590&quot; data-rawheight=&quot;2408&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1590&quot; data-original=&quot;https://pic4.zhimg.com/v2-7cef0c56c72348e076a374bf130e0d63_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-7cef0c56c72348e076a374bf130e0d63_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.linkedin.com/jobs/cap/view/1162802661&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;job link&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;使用 Rust 來加速 Elixir 服務1100萬用戶&lt;/h3&gt;&lt;p&gt;discord過去一直使用erlang來做為主要服務的程式語言現在他們使用了rustler讓rust為 elixir 加速。去年他们的业务有了一项新的变化，就是更新会员列表的方式：只发送更新的部分，而不是给每个会员发送更新。这个变化给服务器端造成了一个大问题：我们需要一个能够容纳数十万个条目的数据结构，以特定的方式排序，可以接受和处理大量的变动，并且可以报告添加和删除事物的位置索引。&lt;/p&gt;&lt;p&gt;Elixir是一种函数式语言;它的数据结构是不可变的。这非常适合在编写elixir对代码进行正确性论证以及并可以享受的大量并发性。不可变数据结构的双刃剑是通过采用现有数据结构和操作以及创建全新数据结构来对变动建模。这意味着当有人加入服务器（内部称为公会）并拥有100,000名成员的成员列表时，他们必须构建一个包含100,001名成员的新列表。 BEAM VM非常快，并且每天都在变得更快。它试图在可能的情况下利用持久性数据结构，但在我们运营的规模上，这些大型列表无法足够快地更新。&lt;/p&gt;&lt;p&gt;因此团队在erlang和elixir提供的各种高性能数据结构中寻找解决办法，试过MapSet、List、OrderedSet到他们自己实现的SortedSet，终于找到了一个解决方案，但是在超过250,000名成员的公会时性能达到了上限。于是Discord团队准备尝试使用Rust来加速。&lt;/p&gt;&lt;p&gt;这不是Discord团队第一次使用Rust了，在他们的游戏商城里也大量用到了Rust，但Discord的核心服务是Elixir，主要是因为Elixir比较适合他们的场景。为了为Elixir加速，他们预留了一周时间使用Rustler（提供了安全的NIF绑定，方便为elixir编写rust扩展）进行概念验证，最终发现，Rust支持的NIF提供了巨大的性能优势，而无需牺牲易用性或内存（可以支持100w名成员）。&lt;/p&gt;&lt;p&gt;从此以后，Discord团队便快乐地享受着Rust带给他们的「快感」。Discord也开源了他们的SortedSet库，点击原文看更多详细。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bpw1aw/using_rust_to_scale_elixir_for_11_million/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reddit 讨论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.discordapp.com/using-rust-to-scale-elixir-for-11-million-concurrent-users-c6f19fc029d3%3Fgi%3Df41b3f0ac2b3&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rusterlium/rustler&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rustler&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;使用BinaryAST快速加载脚本&lt;/h3&gt;&lt;p&gt;关于JavaScript二进制AST&lt;/p&gt;&lt;p&gt;随着网站变得越来越复杂，JavaScript源代码的数量不断增加。依赖于大型JavaScript代码库会导致网站启动缓慢 - 通常速度慢得令人无法接受。这是因为存在两个瓶颈：解析和字节码编译JavaScript。不幸的是，浏览器几乎达到了两种操作的效率峰值。&lt;/p&gt;&lt;p&gt;我们（Mozilla，Bloomberg，Facebook，CloudFlare）目前正致力于针对JavaScript的特定领域编码，称为“BinAST”（“JavaScript二进制AST”的缩写）。 JavaScript二进制AST旨在打破瓶颈。当前的高级原型已经在所有最常见的框架上显示了JS解析改进了30％-50％，只需更改格式，我们相信我们可以进一步提高这一改进。编码可以构建为webdev工具链的一部分，或者由代理或CDN注入，因此可以在不更改原始网站的情况下自动提高最终用户的性能。&lt;/p&gt;&lt;p&gt;此编码目前在JavaScript TC39标准化过程中。它可以与现有的压缩技术（gzip，brotli等）一起使用，目前有cloudflare的一个Rust实现：binjs-ref。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/binast/binjs-ref&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;binjs-ref&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.cloudflare.com/binary-ast/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;「视频」ChromeOS使用Rust为在Chromebook上运行的Linux应用构建安全的Linux环境&lt;/h3&gt;&lt;p&gt;本演讲视频将解释Linux for Chromebooks的架构以及使其易于使用的设计决策，包括使用Rust来构建安全的Linux沙箱环境。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bokgxr/chromeos_uses_rust_to_build_a_secure_linux/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reddit 讨论&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Rust之父Graydon Hoare 在一个讲座中叙述了编译器的历史&lt;/h3&gt;&lt;p&gt;是给不列颠哥伦比亚大学（在加拿大）的学生开的讲座。&lt;/p&gt;&lt;p&gt;分别讲了 clang, swiftc, rustc, 和 gcc 等。文章有意思。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//venge.net/graydon/talks/CompilerTalk-2019.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Slide&lt;/a&gt; 在这里。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//thenewstack.io/rust-creator-graydon-hoare-recounts-the-history-of-compilers/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;一个查看编程语言发展趋势的方法：Wikipedia Pageviews Analysis&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c19ea3dacd937ee6c5ccd947321613fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;680&quot; data-rawheight=&quot;412&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;680&quot; data-original=&quot;https://pic2.zhimg.com/v2-c19ea3dacd937ee6c5ccd947321613fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c19ea3dacd937ee6c5ccd947321613fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;680&quot; data-rawheight=&quot;412&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;680&quot; data-original=&quot;https://pic2.zhimg.com/v2-c19ea3dacd937ee6c5ccd947321613fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c19ea3dacd937ee6c5ccd947321613fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tools.wmflabs.org/pageviews/%3Fproject%3Den.wikipedia.org%26platform%3Dall-access%26agent%3Duser%26start%3D2015-07%26end%3D2019-04%26pages%3DRust_%28programming_language%29%257CPython%257CC%252B%252B%257CC%252B%252B11%257CC%252B%252B20%257CC&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「视频」Rust：后40年的语言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DA3AdN7U24iU&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Are we await!(yet)?&lt;/h3&gt;&lt;p&gt;有人做了个网页，可以实时关注async/await的动态，特别是await。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//await.pietroalbini.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Rust在demoscene圈子中开始流行&lt;/h3&gt;&lt;p&gt;demoscene是一个国际计算机艺术亚文化，专注于制作演示：自成一体，有时甚至是极小的计算机程序，产生视听演示。 演示的目的是展示编程，视觉艺术和音乐技巧。 演示和其他demoscene制作在称为demoparties的节日上分享，由参加者投票并在线发布。&lt;/p&gt;&lt;p&gt;引用一段文章里提到的谈话：&lt;/p&gt;&lt;blockquote&gt; It&amp;#39;s a pretty good language. Better than C++, worse than C... Fucking awful learning curve, at least for me, but I&amp;#39;m having tons of fun with it, it kind of forces you to write better code, instead of crappy single use code.&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;看来Rust很受这群极客的喜爱。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.pouet.net/topic.php%3Fwhich%3D11664&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Manticore: 一个用Rust编写的研究性操作系统&lt;/h3&gt;&lt;p&gt;旨在探索parakernel OS架构。&lt;/p&gt;&lt;blockquote&gt; 对于希望最大限度利用硬件的服务器应用程序而言，操作系统越来越成为瓶颈。当I/O明显慢于CPU时，设计了许多传统的内核接口（例如POSIX）。但是，今天I/O变得越来越快，但单线程CPU性能却停滞不前。例如，40 GbE NIC可以比CPU访问其最后一级缓存（LLC）更快地接收缓存行大小的数据包，这使得操作系统跟上来自网络的数据包变得棘手。类似地，非易失性存储器（NVM）访问速度越来越接近DRAM速度，这对存储器的OS抽象提出了挑战。&lt;br/&gt; 为解决此操作系统瓶颈，服务器应用程序越来越多地采用内核旁路技术。例如，Seastar框架是在用户空间中实现的操作系统，它实现了自己的CPU和I/O调度程序，并尽可能地绕过Linux内核。 Parakernel是一种OS体系结构，它消除了许多操作系统抽象（类似于exokernel）并分区硬件资源（类似于多内核），以便通过增加应用程序级并行性和可预测的尾部延迟来促进高性能服务器应用程序。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/manticoreos/manticore&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;manticore&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;一个视频，从 Node.js 到 Deno(v8+Rust)&lt;/h3&gt;&lt;p&gt;Deno 是一个 JavaScript/TypeScript 运行时，作者其实就是 Node.js 作者。他觉得 nodejs 生态已经没办法再提高质量了，就创建了这个新项目 deno。下面是 Rafał Pocztarski 的视频分享。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bo0zk0/rafa%25C5%2582_pocztarski_from_nodejs_to_deno/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Video&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitpitch.com/rsp/ntd/ntd%23/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Slides&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;一篇博文：Rust语言目前在机器学习领域的状态&lt;/h3&gt;&lt;p&gt;这篇文章作者非常喜欢 Rust，分析了一下目前 Rust 中的机器学习生态的情况。比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;const-generics&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//crates.io/crates/generic-array&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;generic-array&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang-nursery/packed_simd&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;packed_simd&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/bheisler/RustaCUDA&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RustaCUDA&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/bsteinb/rsmpi&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rsmpi&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rayon-rs/rayon&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rayon&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-ndarray/ndarray&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ndarray&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//crates.io/crates/ndarray-linalg&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ndarray-linalg&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//crates.io/crates/ndarray-stats&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ndarray-stats&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后，作者打赌 Rust 在 ML/DL 领域能大展宏图。进一步的讨论可以进 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-ml&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rust-ml&lt;/a&gt; 进行。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ehsanmkermani.com/2019/05/13/state-of-machine-learning-in-rust/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;为什么越来越多的知名项目用Rust来开发？&lt;/h3&gt;&lt;p&gt;社区@Mike写的一篇文章，侧重分享了为什么Rust适合区块链开发。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/DjQlyQeushrXM7QNxbY-cA&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「比原生更快：在 Linux 内核中运行 WebAssembly」&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/F6yAE3-l_LI8l1ls5yLHqw&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;中文&lt;/a&gt; &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/wasmer/running-webassembly-on-the-kernel-8e04761f1d8e&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;英文&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;学习资源&lt;/h2&gt;&lt;h3&gt;「中文」Rust Async: 标准库futures api解析&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66028983&quot; class=&quot;internal&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;如何使用纯Rust实现命令行自动补全&lt;/h3&gt;&lt;p&gt;命令行自动补全可深可浅，深的可以对子命令，参数项等，都自动补全。文章可以借鉴。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.joshmcguigan.com/blog/shell-completions-pure-rust/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「系列」Rust for OOP系列介绍&lt;/h3&gt;&lt;p&gt;这位博主打算写一系列主题是Rust for OOP的文章，主要是针对有一定OOP语言开发经验的人来学习。可以先关注下。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//oribenshir.github.io/afternoon_rusting/blog/rust-for-oop&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;在Rust中创建C/C++ API&lt;/h3&gt;&lt;p&gt;这篇文章介绍了一些可以帮助自动生成C/C++ API的优秀工具。比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;bindgen， 可以根据给定的头文件自动创建Rust绑定代码。对C语言比较友好，但是对C++来说，用途有限。因为C++的继承处理比较麻烦。&lt;/li&gt;&lt;li&gt;cbindgen，可以方便地为Rust项目生成C API。它还支持以C++风格输出数据类型和模板等。&lt;/li&gt;&lt;li&gt;cpp，这是一个Rust crate，可以帮忙编写C++ API。它提供了一个&lt;code&gt;cpp!&lt;/code&gt;宏，可以在其中嵌入c++代码。它可以方便和cbindgen搭配使用。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;作者还总结了一些在Rust中创建C/C++API的准则：核心逻辑和FFI层之间应该明确分离，最好把FFI代码置于一个单独的crate中，这样做的好处是设计Rust API不会受到FFI的太多影响。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//karroffel.gitlab.io/post/2019-05-15-rust/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;[教程]如何用rust为redis写一个client&lt;/h3&gt;&lt;p&gt;主要讲解了如何通过RESP实现一个redis client，并用rust实现了一个简单的demo，目前只实现了set和get命令，可以很方便的添加命令，项目地址如下redis-simple-rs欢迎大家完善。&lt;/p&gt;&lt;p&gt;@readlnh 投稿 &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/readlnh/redis-simple-rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「小技巧」利用&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;和From实现可选参数&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//blog.keiruaprod.fr/2019/05/11/optional-parameters-in-rust/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;一个很有价值的问题：Rust中哪些特性是零开销抽象的&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bo13qq/what_specifically_are_all_the_zerocost/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;link&lt;/a&gt; 在这里讨论的，现在我来整理一下，下面的都是零开销的抽象：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;tuple&lt;/li&gt;&lt;li&gt;gererics&lt;/li&gt;&lt;li&gt;traits&lt;/li&gt;&lt;li&gt;Option - 编译器最后（视情况）会把这一层包装优化掉&lt;/li&gt;&lt;li&gt;Vec&lt;/li&gt;&lt;li&gt;Box&lt;/li&gt;&lt;li&gt;Range&lt;/li&gt;&lt;li&gt;for-loops&lt;/li&gt;&lt;li&gt;mod&lt;/li&gt;&lt;li&gt;zero-sized types (C++ can&amp;#39;t do that because every value needs to have an address)&lt;/li&gt;&lt;li&gt;enum discriminant optimizations which I hope are done for Option and friends (storing None as 0)&lt;/li&gt;&lt;li&gt;链式迭代器可以产生更快的代码，有时比for循环还快&lt;/li&gt;&lt;li&gt;await和Futures的实现估计也会比C++的实现消耗更少的内存分配，await不是零开销的，但是会保持很少&lt;/li&gt;&lt;li&gt;宏、构建脚本和常量初始化可以输出结构化的值，也是零开销&lt;/li&gt;&lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不是零开销的部分：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&amp;amp;dyn Trait&lt;/li&gt;&lt;li&gt;..&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;有人总结得好：&lt;/p&gt;&lt;p&gt;&lt;b&gt;零开销不是指没有开销，而是指与不用（Rust给出的）抽象而用手动直接模拟实现相比，没有额外的开销。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;通常来讲：当 Rust 有一个特性 F，它实现了一个编程的方面（解决了那样一种问题） A，现在你的程序要实现方面 A（解决那样一种问题），一般来说，只需要直接拿起 F 使用就对了，你手动重新实现（用 Rust 或 C 或其它语言），并不能带来更好的性能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;C++的实现遵从零开销原则：你用不到的东西，不会为其付出代价。更进一步：对于你用到的东西，你没法再做得更好。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于Rust的情况来说，编译器会承担大部分的优化工作，所以在这方面（相对于C++来说）走得更远。换句话说，&lt;b&gt;实践中往往更容易写出慢的C++代码，而不是慢的Rust代码&lt;/b&gt;。对于你描述的情况，元组慢是因为它们实现在编译器的上面一层，因此优化工作留给了程序员来做。而在Rust中，元组是一等公民，它们会被编译器自动优化掉。&lt;/p&gt;&lt;h3&gt;零成本抽象&lt;/h3&gt;&lt;p&gt;官方核心团队无船同志的新博文，探讨了「零成本抽象」。&lt;/p&gt;&lt;p&gt;零成本抽象在C++跟Rust是一個很重要的概念&lt;/p&gt;&lt;p&gt;簡單來說就是：不希望有很大很重的runtime，並且可以在編譯時被優化。&lt;/p&gt;&lt;p&gt;作者覺得 rust 有幾個很棒的 零成本抽象&lt;/p&gt;&lt;ol&gt;&lt;li&gt;所有權、借用&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;保證内存的正確使用&lt;/p&gt;&lt;ol&gt;&lt;li&gt;迭代器、閉包函數&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;可以輕鬆的串接 map, filter 等函數做處理&lt;/p&gt;&lt;ol&gt;&lt;li&gt;await 异步函數&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;當前的await語法雖然還沒有確定，但使用pinning 做到零成本抽象是確定的&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Unsafe 函數、模块邊界&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由於rust的語法複雜性，有很多實作會需要Unsafe的底層實作&lt;/p&gt;&lt;p&gt;這些Unsafe函數實作了零成本抽象的底層&lt;/p&gt;&lt;p&gt;讓我們在上層能安全的使用這些模块&lt;/p&gt;&lt;p&gt;另外无船同志还表示：trait对象目前不是零成本抽象，他想花点时间（至少需要18个月）去研究这个问题，然而总是有更优先的事情。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bpep6h/zero_cost_abstractions/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reddit 讨论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//boats.gitlab.io/blog/post/zero-cost-abstractions/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;「讨论」mio异步計時器如何使用？&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.rs/mio-extras/2.0.5/mio_extras/timer/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;官方說明文件&lt;/a&gt;&lt;/p&gt;&lt;p&gt;沒有範例程式碼，其實很難了解怎麼用&lt;/p&gt;&lt;p&gt;回覆中有人給出了答案&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bpbrux/could_someone_explain_to_me_how_mio_asynchronous/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;开发Rust的最佳IDE是什么？&lt;/h3&gt;&lt;p&gt;本文是网络里的各种意见汇总，尝试阐明利弊，供大家参考：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;IntelliJ IDEA 中使用IntelliJ Rust插件。褒贬各一。&lt;/li&gt;&lt;li&gt;CLion中使用Rust插件。 官方评论：可能是最接近「Rust专用IDE」的IDE。&lt;/li&gt;&lt;li&gt;VSCode中使用Rust插件。好评比例比较多。&lt;/li&gt;&lt;li&gt;(Neo)vim使用Rust插件。喜欢VIM的人用吧，也够用了。&lt;/li&gt;&lt;li&gt;Sublime。 抱怨比例比较多。&lt;/li&gt;&lt;li&gt;Atom。没啥评论。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;你推荐哪个？&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/cloud-native-the-gathering/whats-the-best-ide-for-developing-in-rust-5087d46006f5&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;cerebrallib - 使用Rust写的brainfuck语言的虚拟机库&lt;/h3&gt;&lt;p&gt;练手项目&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// src/main.rs code
use cerebrallib::cerebral;
use std::io
fn main() {
    let code = String::from(&amp;#34;++++&amp;#34;);
    let mut vm = cerebral::CerebralVM::new(code, io::stdin(), io::stdout());
    vm.execute();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/dsouzadyn/cerebrallib&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;项目、工具与库&lt;/h2&gt;&lt;h3&gt;zemeroth - 一个六边形回合制游戏&lt;/h3&gt;&lt;p&gt;可以在线玩儿：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ozkriff.itch.io/zemeroth&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Online Play&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;这篇文章详细讲述了这个游戏的技术选型发展过程。目前，它综合使用了：ggez, WASM, itch.io, visuals, AI, campaign, tests 等技术。文章写得非常好，强烈推荐阅读。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ozkriff/zemeroth&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;zemeroth源码&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Couchbase Rust SDK 1.0 alpha.1 发布&lt;/h3&gt;&lt;p&gt;这是官方的 Rust SDK。Couchbase 是一个商业的 NOSQL 数据库。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/couchbaselabs/couchbase-rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;ggez制作的小游戏：ggezFlappyCrabby&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DcPF41tl3-3c%26feature%3Dyoutu.be&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/AndrewJakubowicz/ggezFlappyCrabby&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ggezFlappyCrabby&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Jazz：又一个用Rust实现的编程语言&lt;/h3&gt;&lt;p&gt;（可能是个人玩票的语言）&lt;/p&gt;&lt;p&gt;特点是使用了GCCJIT的静态语言，也就是libgccjit库，它提供了C接口，社区里也有它的Rust绑定库。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/jazz-lang/Jazz&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Jazz&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;google-apis-rs: 适用于所有Google API的绑定和CLI生成器&lt;/h3&gt;&lt;p&gt;这个项目的gen目录下包含了很多相关组件&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Byron/google-apis-rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;google-apis-rs&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;pegcel: syn风格的PEG解析器生成器&lt;/h3&gt;&lt;p&gt;可以创建syn风格的语法树，配合syn库使用。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/CAD97/pegcel&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;pegcel&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;wgpu-rs: wgpu的进一步封装&lt;/h3&gt;&lt;p&gt;适用于Rust社区的通用图形和计算需求，未来还会支持wasm和emscripten。wgpu是WebGPU的Rust实现，基于&lt;code&gt;gfx-hal&lt;/code&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/gfx-rs/wgpu-rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;wgpu-rs&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/gfx-rs/wgpu&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;wgpu&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;multiqueue2 - 支持广播能力的 mpmc 管道&lt;/h3&gt;&lt;p&gt;MultiQueue是由Sam Schetterer开发的mpmc库，但有一段时间没有更新。MultiQueue2是另外一个人觉得它非常有用，就接手开发了，修复了一些过时的API和bug，并且升级到2018 edition。基于crossbeam和futures 0.1实现。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/abbychau/multiqueue&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt; &lt;/p&gt;&lt;h3&gt;使用gir crate生成GNOME库&lt;/h3&gt;&lt;p&gt;gir是一个用于为基于glib的库生成Rust绑定和用户API的工具，可以生成sys级的crate和安全API。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gtk-rs.org/docs-src/tutorial/gir_tutorial&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;cloud-hypervisor： 一个在KVM上运行的开源虚拟机监视器（VMM）&lt;/h3&gt;&lt;p&gt;intel又一个开源项目，目前还是实验性项目，基于rust-vmm实现。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/intel/cloud-hypervisor&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;cloud-hypervisor&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;meta: 用于解析人类可读性文本的DSL解析库&lt;/h3&gt;&lt;p&gt;可用于语言设计，自定义格式和数据驱动开发。该库提供了一种叫做「meta语言」的规则，用来告诉程序如何阅读要解析的文档。这些文档都是人类可读格式的。&lt;/p&gt;&lt;p&gt;最小化示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;piston_meta&lt;/span&gt;::&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r#&amp;#34;hi James!&amp;#34;#&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;say_hi&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;hi&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;James&amp;#34;&lt;/span&gt;:&lt;span class=&quot;s&quot;&gt;&amp;#34;james&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;Peter&amp;#34;&lt;/span&gt;:&lt;span class=&quot;s&quot;&gt;&amp;#34;peter&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;!&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;say_hi&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#34;#&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// Parse rules with meta language and convert to rules for parsing text.
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syntax_errstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_errstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;code&gt;&amp;#34;james&amp;#34;:true&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/pistondevelopers/meta&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;meta&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「嵌入式Rust」一个通用型嵌入式芯片烧录软件&lt;/h3&gt;&lt;p&gt;目前还只支持windows和st-link，长远目标是代替OpenOCD。目前比竞品好的地方是可以同时烧两个芯片，这样做双机通讯测试就不用插拔dongle了&lt;/p&gt;&lt;p&gt;来自 @洛佳&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/luojia65/nihao&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;serde-wasm-bindgen：让wasm-bindgen支持serde&lt;/h3&gt;&lt;p&gt;cloudflare出品&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/cloudflare/serde-wasm-bindgen&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;serde-wasm-bindgen&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;【嵌入式】为ESP32构建Rust开发环境&lt;/h3&gt;&lt;p&gt;文章在&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//quickhack.net/nom/blog/2019-05-14-build-rust-environment-for-esp32.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;，不复杂。&lt;/p&gt;&lt;h3&gt;diesel-factories - 为测试要构建 factory_bot 的库&lt;/h3&gt;&lt;p&gt;在单元测试/集成测试中，你经常会需要插入一些数据到数据库中。而 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/thoughtbot/factory_bot&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;factory_bot&lt;/a&gt; 就是这样一种库，diesel-factories  是它基于 diesel 的实现。 如果你来自Ruby社区，肯定听说过factory_girl，理念相似。&lt;/p&gt;&lt;p&gt;这个库像下面一样使用。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// A normal Diesel model
#[derive(Clone, Queryable)]
struct Country {
    pub id: i32,
    pub name: String,
}

// Our factory
#[derive(Clone, Factory)]
#[factory(model = &amp;#34;Country&amp;#34;, table = &amp;#34;crate::schema::countries&amp;#34;)]
struct CountryFactory {
    pub name: String,
}

// Setting up what the default values are
impl Default for CountryFactory {
    fn default() -&amp;gt; Self {
        Self {
            name: &amp;#34;Denmark&amp;#34;.into(),
        }
    }
}

#[test]
fn some_test() {
    let con = establish_connection();

    // Using all the defaults
    let denmark = CountryFactory::default().insert(&amp;amp;con);
    assert_eq!(&amp;#34;Denmark&amp;#34;, denmark.name);

    // Defaults can be changed through builder methods
    let netherlands = CountryFactory::default()
        .name(&amp;#34;Netherlands&amp;#34;)
        .insert(&amp;amp;con);
    assert_eq!(&amp;#34;Netherlands&amp;#34;, netherlands.name);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/davidpdrsn/diesel-factories&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;memory-profiler - Nokia 用 Rust 写了一个 Linux 内存调优工具&lt;/h3&gt;&lt;p&gt;内存调优工具，主要用来分析内存泄漏什么的。当然，还有很多其它更详细的特性。我们来先睹为快。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7639fecd833ea385091c85749a0a2768_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1300&quot; data-rawheight=&quot;611&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1300&quot; data-original=&quot;https://pic1.zhimg.com/v2-7639fecd833ea385091c85749a0a2768_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7639fecd833ea385091c85749a0a2768_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1300&quot; data-rawheight=&quot;611&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1300&quot; data-original=&quot;https://pic1.zhimg.com/v2-7639fecd833ea385091c85749a0a2768_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7639fecd833ea385091c85749a0a2768_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/nokia/memory-profiler&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2019-05-21-66310889</guid>
<pubDate>Tue, 21 May 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust日报」2019每周精选 • 第十五期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2019-05-12-65509043.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65509043&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23599072636a1820bba7b49b9d586092_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言：&lt;br/&gt;从2018年开始，我每天会花1个小时关注Rust社区动态，并且分享我每天的见闻，偶尔也夹杂了一些个人的观点。新的一年过去了，Rust日报已经成为了Rust社区群大家每天必看的内容。&lt;br/&gt;从2019年开始，日报小组成立，目前的动态由：@Chaos、 @Mike、 @Damody(台湾)轮番为大家播报。也欢迎感兴趣的朋友加入小组。&lt;br/&gt;每周也会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。&lt;br/&gt;独立日报订阅地址： - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//t.me/rust_daily_news&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Telgram Channel&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/chaosbot/rustnews&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;阿里云语雀订阅&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//steemit.com/%40blackanger&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Steemit&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/RustStudy/rust_daily_news&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub&lt;/a&gt;&lt;br/&gt;社区学习交流平台订阅： - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust.cc/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust.cc论坛&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rustforce.net/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust Force&lt;/a&gt; - &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust.cc/article%3Fid%3Ded7c9379-d681-47cb-9532-0db97d883f62&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;微信公众号：Rust语言学习交流&lt;/a&gt;&lt;br/&gt;2019-05-12 &lt;/blockquote&gt;&lt;hr/&gt;&lt;h2&gt;官方新闻&lt;/h2&gt;&lt;h3&gt;Await 语法预告&lt;/h3&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2d1e5c7e407e5735abd3f888c81fac43_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2d1e5c7e407e5735abd3f888c81fac43_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2d1e5c7e407e5735abd3f888c81fac43_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64916694&quot; class=&quot;internal&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;await语法，官方代码里已经安排上了&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3516815c6b0b84b1ec359ae06fbd33e8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1708&quot; data-rawheight=&quot;1082&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1708&quot; data-original=&quot;https://pic1.zhimg.com/v2-3516815c6b0b84b1ec359ae06fbd33e8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3516815c6b0b84b1ec359ae06fbd33e8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1708&quot; data-rawheight=&quot;1082&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1708&quot; data-original=&quot;https://pic1.zhimg.com/v2-3516815c6b0b84b1ec359ae06fbd33e8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3516815c6b0b84b1ec359ae06fbd33e8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这里，还有一个工具 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/taiki-e/replace-await&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;replace-await&lt;/a&gt; 用于把之前的 await!(xxx) 这种宏代码迁移到 xxx.await 的写法。&lt;/p&gt;&lt;h3&gt;Cargo Vender 子命令即将登陆Cargo&lt;/h3&gt;&lt;p&gt;cargo vender支持将&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//crates.io&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;crates.io&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;中的依赖项保存到你本地目录下。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/cargo/pull/6869&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「嵌入式工作组」μAMP: 微控制器上的非对称多处理&lt;/h3&gt;&lt;p&gt;microamp（就是μAMP）是用于构建针对AMP系统的裸机应用程序，它是Real Time For the Masses（RTFM）多核版本的核心基础。&lt;/p&gt;&lt;p&gt;从历史上看，微控制器被设计为单核系统（SoC），但较新的设计越来越多地选择异构多核架构。例如，恩智浦的LPC43xx系列将Cortex-M4处理器与一个（或多个）Cortex-M0协处理器配对在一个封装中。这些设计的目标通常是优化功耗：例如，较低功率M0可以处理所有I/O，而M4内核仅被激活以执行昂贵的浮点/ DSP计算。&lt;/p&gt;&lt;p&gt;μAMP模型让我们可以针对这类系统，但也可以应用于同类多核系统，如Zynq UltraScale+EG或LPC55S69（2 ARM Cortex）上的双核实时处理器（2个ARM Cortex-R5内核）微控制器。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.japaric.io/microamp/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/japaric/microamp&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;microamp&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;「Rust Wasm工作组」：wasm-tracing-allocator&lt;/h3&gt;&lt;p&gt;一個全局的分配器追踨器，可以追到wasm内存分配的情況&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rustwasm/wasm-tracing-allocator&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;wasm-tracing-allocator&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「官方文档」Rust API 指南(api-guidelines)&lt;/h3&gt;&lt;p&gt;今天有个Reddit讨论贴，有人指出每个发布到&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//crates.io&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;crates.io&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;的crate都应该加上Readme说明和Repository地址（GitHub、GitLab等），以方便用户。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cargo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toml&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readme&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;README.md&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;https://github.com/user/my_awesome_crate&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;评论中有人提到Rust官方出品的「Rust API 指南(api-guidelines)」， Rust crate作者应该将它们视为开发Rust库时的一组重要参考因素（非必须遵守）。该指南还在完善中。该指南包含两部分：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Checklist，用于发布crate时快速检查&lt;/li&gt;&lt;li&gt; 详细说明，对checklist中的内容做详细的说明&lt;br/&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bngvml/psa_please_put_readme_and_repository_links_in/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;br/&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//rust-lang-nursery.github.io/api-guidelines/about.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;api-guidelines&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;「Cli工作组」新工具：paw&lt;/h3&gt;&lt;p&gt;为了使Rust开发Cli应用的体验更加一流，更方便地解析命令行参数，官方Cli工作组开发了这个Paw库，目前还是WIP状态。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#[paw::main]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;paw&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;{:?}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;paw::main&lt;/code&gt;宏允许&lt;code&gt;fn main&lt;/code&gt;接受任何实现&lt;code&gt;paw::ParseArgs trait&lt;/code&gt;的参数，所以，支持将&lt;code&gt;std::env::Args&lt;/code&gt;传递给&lt;code&gt;main&lt;/code&gt;，还允许传递&lt;code&gt;structopt&lt;/code&gt;实例。&lt;/p&gt;&lt;p&gt;假如paw的反响比较好，官方还将走RFC流程，将它引入标准库中。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.yoshuawuyts.com/paw/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-cli/paw&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;paw&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h2&gt;社区新闻&lt;/h2&gt;&lt;h3&gt;Snip开源神经网络推理引擎Tract&lt;/h3&gt;&lt;p&gt;tract是Snips.ai公司嵌入式自然语言语音处理系统SnipFlow中的重要组件。该公司两年前在TensorFlow Lite出现之前打算将TensorFlow嵌入到库中方便他们执行模型，但是后来因为TensorFlow太过庞大复杂，不得不更改了计划。&lt;/p&gt;&lt;p&gt;新的计划就是使用Rust作为SnipFlow的主要语言，两年过去了，团队已经非常享受现代化软件环境带来的舒适感，而且比TensorFlow更容易交叉编译。&lt;/p&gt;&lt;p&gt;(其实tract上个月就开源了，只是这篇文章最近几天才发布)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/snips-ai/snips-open-sources-tract-cdc50f437ef2&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/snipsco/tract&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;tract&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//snips.ai/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;snips.ai&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;JavaScript二进制AST格式的参考实现&lt;/h3&gt;&lt;p&gt;关于JavaScript二进制AST&lt;/p&gt;&lt;p&gt;随着网站变得越来越复杂，JavaScript源代码的数量不断增加。依赖于大型JavaScript代码库会导致网站启动缓慢 - 通常速度慢得令人无法接受。这是因为存在两个瓶颈：解析和字节码编译JavaScript。不幸的是，浏览器几乎达到了两种操作的效率峰值。&lt;/p&gt;&lt;p&gt;我们（Mozilla，Bloomberg，Facebook，CloudFlare）目前正致力于针对JavaScript的特定领域编码，称为“BinAST”（“JavaScript二进制AST”的缩写）。 JavaScript二进制AST旨在打破瓶颈。当前的高级原型已经在所有最常见的框架上显示了JS解析改进了30％-50％，只需更改格式，我们相信我们可以进一步提高这一改进。编码可以构建为webdev工具链的一部分，或者由代理或CDN注入，因此可以在不更改原始网站的情况下自动提高最终用户的性能。&lt;/p&gt;&lt;p&gt;此编码目前在JavaScript TC39标准化过程中。它可以与现有的压缩技术（gzip，brotli等）一起使用&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/binast/binjs-ref&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;binjs-ref&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;柏林都举行了 100 场 Rust 碰面聚会了&lt;/h3&gt;&lt;p&gt;欧洲人很爱 Rust？大家都爱嘛。他们从 2014 年起就开始进行Rust聚会了。国内要更多点才好。不仅是大会，各个城市的小会也搞起来。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//berline.rs/2019/05/15/rust-hack-and-learn.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt; &lt;/p&gt;&lt;h3&gt;RubyGems将支持带有Rust内置扩展的gem&lt;/h3&gt;&lt;p&gt;将添加一个新的构建器CargoBuilder，它将检测Cargo.toml文件并使用Cargo构建gem原生扩展。这减轻了为Ruby用户开发和发布Rust扩展的负担。现在希望找寻贡献者来落实这项计划。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rubygems/rubygems/issues/2726%23issuecomment-491482467&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;rubygems/issues/2726&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;尝试在Cloudsmith上发布你的crate&lt;/h3&gt;&lt;p&gt;Cloudsmith是Puppet Labs旗下的DevOps平台，目前支持Cargo。你可以把Cloudsmith作为&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//crates.io&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;crates.io&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;之外的私人registry。&lt;/p&gt;&lt;p&gt;本文介绍了如何使用cloudsmith-cli工具将你的crate发布到它的平台上。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.cloudsmith.io/2019/05/01/worlds-first-private-cargo-registry/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/cargo/reference/registries.html%23using-an-alternate-registry&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;cargo registry 相关文档&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64917441&quot; class=&quot;internal&quot;&gt;通过此文了解下Cargo Registry： 乱谈Cargo Registry &lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;「论文」Rust并发的实践研究&lt;/h3&gt;&lt;p&gt;该论文通过实现一个并发无锁HashMap来研究Rust类型系统如何影响并发数据结构的开发和改进。他们的代码库concache在GitHub上公开，是Rust语言中最快的并发HashMap之一，可以帮助降低并发程序中的瓶颈。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1904.12210&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1904.12210&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Paper pdf&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/saligrama/concache&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;concache&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;combine-4.0.0-alpha.1 发布&lt;/h3&gt;&lt;p&gt;combine和nom的功能类似，但它的特点是建立在Rust的trait和类型系统之上，而不是宏。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Marwes/combine/blob/master/CHANGELOG.md%23400-alpha1-2019-05-07&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;完整的更新列表&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Xi-Editor作者新博文：现代GPU上的2D图形&lt;/h3&gt;&lt;p&gt;该作者花了一周的时间对「传统2D成像模型在现代图形世界中的未来」做了深入思考。2D图形建立在GPU之上是否是未来？作者认为是可行的，并且阐述了他的研究。感兴趣可以看看。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//raphlinus.github.io/rust/graphics/gpu/2019/05/08/modern-2d.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「社区讨论」命名异步函数的返回类型&lt;/h3&gt;&lt;p&gt;该贴的作者认为，在async趋于稳定之前，还有个重要的讨论，就是支持异步函数的返回类型的自定义命名。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/**/&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// or even to make the return type nameable
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FooReturn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;FooReturn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/**/&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//internals.rust-lang.org/t/naming-the-return-type-of-an-async-function/10085&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;学习资源&lt;/h2&gt;&lt;h3&gt;使用Chrome对Rust进行全自动单元测试&lt;/h3&gt;&lt;p&gt;stretch的作者写的一篇博客。stretch是一个跨平台的FlexBox引擎。在Visly公司，该作者正参与一个为前端工程师构建的设计工具，其中用到FlexBox，需要在不使用WebView的情况下保持Web、iOS和Android三端保持相同的布局。意味着在移动设备上复制Web的布局。&lt;/p&gt;&lt;p&gt;这篇文章里，作者介绍了使用stretch的单元测试方案，是一套自动编写自动化测试的方案，他们称其为gentest系统。大概原理如下图：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5fceb421ee21786bf3df64c00edfe45b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1184&quot; data-rawheight=&quot;954&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1184&quot; data-original=&quot;https://pic4.zhimg.com/v2-5fceb421ee21786bf3df64c00edfe45b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5fceb421ee21786bf3df64c00edfe45b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1184&quot; data-rawheight=&quot;954&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1184&quot; data-original=&quot;https://pic4.zhimg.com/v2-5fceb421ee21786bf3df64c00edfe45b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-5fceb421ee21786bf3df64c00edfe45b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;所有的测试用例都用html文件来描述，并且包含&lt;code&gt;id =“test-root”&lt;/code&gt;的布局。然后gentest使用WebDriver将此文件加载到Chrome head-less浏览器中。加载后，gentest将通过WebDriver向浏览器询问每个DOM节点的样式，大小和位置等信息，然后利用此信息，gentest再生成Rust单元测试，用于构建三端等效的FlexBox树给stretch api使用。最后可以统一通过&lt;code&gt;cargo test&lt;/code&gt;来完成测试。&lt;/p&gt;&lt;p&gt;gentest的另一个好处是，因为每个测试只是一个html文件，只需打开文件就可以在浏览器中显示它。并且他们还利用gentest生成一套基准测试，确保性能不会退化。&lt;/p&gt;&lt;p&gt;gentest有什么黑科技吗？&lt;/p&gt;&lt;p&gt;它也是开源的，我翻了一下源码，主要是三步：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用quote!来构建待生成测试代码的模板（TokenSteam）&lt;/li&gt;&lt;li&gt;将这些模板填充以后从TokenSteam转称字符串。&lt;/li&gt;&lt;li&gt; 使用&lt;code&gt;fs::write&lt;/code&gt;写到指定的目录文件中。&lt;br/&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/visly/unit-testing-rust-using-chrome-b8b93572a91d&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;br/&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//vislyhq.github.io/stretch/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;stretch&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.w3.org/TR/webdriver/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;webdriver&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/vislyhq/stretch/blob/master/scripts/gentest&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;gentest&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;使用sccache在CircleCI上进行Rust缓存&lt;/h3&gt;&lt;p&gt;如果你的crates有很多依赖项，你可能已经注意到Rust编译阶段与实际运行测试相比需要花费很多时间。&lt;/p&gt;&lt;p&gt;缓解该问题的一种方法是缓存Rust编译的中间对象：大多数博客文章建议缓存Rust目标文件夹以减少编译时间。这种方法有一个主要问题，这个缓存文件会越来越大。&lt;/p&gt;&lt;p&gt;因此你需要定时清理这个缓存目录。该文推荐Mozilla的这个库sccache。该库的一个优点是可以配置文件夹的最大大小，当大小超过该限制时，会启动LRU清除算法（和Redis的差不多），清理掉部分缓存。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/mozilla/sccache&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;sccache&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/%40edouard.oger/rust-caching-on-circleci-using-sccache-c996344f0115&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;「Handmade Rust系列」Part 4 : 创建Vulkan绑定&lt;/h3&gt;&lt;p&gt;该系列将以Rust手工制作方式开发Vulkan渲染引擎，这是第四篇博文。该项目的特点是，不使用标准库，只使用核心库。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//stevenlr.com/posts/handmade-rust-4-vulkan-bindings/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/stevenlr/HandmadeRust&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HandmadeRust&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Graphlib v0.3.0已经发布！&lt;/h3&gt;&lt;p&gt;Graphlib，用于Rust编程语言的简单而强大的图库。提供了图数据结构的一些API。比如BFS/DFS等迭代器。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/purpleprotocol/graphlib&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;graphlib&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Rust并发模式：通过共享sender通信&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/%40polyglot_factotum/rust-concurrency-patterns-communicate-by-sharing-your-sender-re-visited-9d42e6dfecfa&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;使用Usher和Hyper构建简单的API&lt;/h3&gt;&lt;p&gt;Usher是在基于Hyper实现的一个简单的库，用于开发简单的HTTP API服务。Usher的特色是提供了一些方便从URL中提取参数的方法，类似于actix的提取器，但是它更加轻量。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//whitfin.io/building-simple-apis-with-hyper-and-usher/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「系列文章：WebAssembly」Part II： 开始Rust&lt;/h3&gt;&lt;p&gt;该系列文章旨在使用Rust和WASM构建一个生产级的Web应用。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/tech-lah/webassembly-part-ii-a-wasm-with-rust-2356dbc6526e&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;使用自定义工具链解决Rust和Glibc的问题&lt;/h3&gt;&lt;p&gt;Rust和Glibc在动态链接的时候可能会失效，该文作者建议使用自定义工具链来解决此问题。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//redbeardlab.com/2019/05/07/rust-and-glibc-version/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「视频」用Rust实现TCP Part3&lt;/h3&gt;&lt;p&gt;我们的老朋友Jon Gjengset，他的视频通常都是5小时左右。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3D8GE6ltLRJA4&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「系列」使用Rust创建静态HTTP服务 Part I&lt;/h3&gt;&lt;p&gt;该教程没有使用http等基础crate，而是从零开始构建http 1.0服务，可供学习使用。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//concisecoder.io/2019/05/11/creating-a-static-http-server-with-rust-part-1/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;项目、工具与库&lt;/h2&gt;&lt;h3&gt;swirlr-wasm：Swirlr的wasm版本&lt;/h3&gt;&lt;h2&gt;wasm&lt;/h2&gt;&lt;p&gt;日报Chaos君向你问好：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-880d0af74be099813075df60c752150c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;996&quot; data-rawheight=&quot;944&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;996&quot; data-original=&quot;https://pic1.zhimg.com/v2-880d0af74be099813075df60c752150c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-880d0af74be099813075df60c752150c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;996&quot; data-rawheight=&quot;944&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;996&quot; data-original=&quot;https://pic1.zhimg.com/v2-880d0af74be099813075df60c752150c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-880d0af74be099813075df60c752150c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;(很有意思，小图可以展示的比较清晰，但是放大以后就模糊了，感觉可以用来保护头像隐私)&lt;/p&gt;&lt;p&gt;swirlr可以将采集的图像沿阿基米德螺线路径的采样点渲染SVG。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//willdady.github.io/swirlr-wasm/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;demo&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/willdady/swirlr-wasm&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;swirlr-wasm&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;muscli ： 基于Pandora和音乐播放器实现的Tui&lt;/h3&gt;&lt;p&gt;音乐数据来自于Pandora流媒体平台&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/CMatri/muscli&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;muscli&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;stevenarella: 用Rust编写的多协议兼容Minecraft客户端&lt;/h3&gt;&lt;p&gt;作者声明：just doing this for fun。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/iceiix/stevenarella&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;stevenarella&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;ifmt - 插值式格式化宏库&lt;/h3&gt;&lt;p&gt;其实其它语言很多都有了。Rust一直显得比较生硬，格式化一个带变量值的字符串，要这样写：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;println!(&amp;#34;x: {x}, y: {y}, x + y: {sum}&amp;#34;, x=x, y=y, sum=x+y);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用这个库，可以这么写了。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let four = 4;
iprintln!(&amp;#34;four plus four is: {four + 4}&amp;#34;);
// four plus four is: 8
iprintln!(&amp;#34;here&amp;#39;s a hex number: 0x{0xb0bi64 * 1321517i64 :x}&amp;#34;);
// here&amp;#39;s a hex number: 0xdeadbeef
iprintln!(&amp;#34;here&amp;#39;s a debugging value: {Some(four):?}&amp;#34;);
// here&amp;#39;s a debugging value: Some(4)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;作者把一套宏全部“升级”了。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;format!      -&amp;gt; iformat!
print!       -&amp;gt; iprint!
println!     -&amp;gt; iprintln!
eprint!      -&amp;gt; ieprint!
eprintln!    -&amp;gt; ieprintln!
write!       -&amp;gt; iwrite!
writeln!     -&amp;gt; iwriteln!
format_args! -&amp;gt; iformat_args!&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ct-austin/ifmt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ifmt&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;ansi-parser - ANSI转义序列解析库&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/ANSI%25E8%25BD%25AC%25E4%25B9%2589%25E5%25BA%258F%25E5%2588%2597&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ANSI转义序列&lt;/a&gt; 就是这种 &amp;#34;This is \u{1b}[3Asome text!&amp;#34;，我们平时在终端下看到的文字的色彩啊，一些特效格式啊什么的，都是按这个标准来做的。&lt;/p&gt;&lt;p&gt;相似的库还有 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/jwilm/vte&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;vte&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitlab.com/davidbittner/ansi-parser&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;test-exec - 用于测试命令行工具的库&lt;/h3&gt;&lt;p&gt;作者也是写命令行工具的时候，觉得测试很不舒服，于是写了这个方便测试的工具。很不错。&lt;/p&gt;&lt;p&gt;比如：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let output = exec!{
    &amp;#34;my_bin&amp;#34;,
    args: [&amp;#34;-p&amp;#34;, &amp;#34;/&amp;#34;],
    cwd: &amp;#34;/tmp&amp;#34;,
    env: {
        THREADS: &amp;#34;4&amp;#34;
    },
    stdin: b&amp;#34;show-hidden&amp;#34;,
    timeout: 60000,
    log: true,

    code: 0,
    stdout: b&amp;#34;Started program... Done.&amp;#34;,
    stderr: []
};

// output can be used here like a normal process::Output&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Draphar/test-exec&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;dystopia - 匿名防追踪的网络代理&lt;/h3&gt;&lt;p&gt;用了Tor技术，其貌似是要提供一种匿名服务。比如要访问&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//google.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;google.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;curl https://google.com -x 54.95.171.65:2888 -L&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;项目还在早期阶段，值得关注。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/tbrand/dystopia&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Rust与sed命令不得不说的故事&lt;/h3&gt;&lt;p&gt;x12pp是用Rust实现的可以漂亮地打印X12 EDI格式的Cli工具。作者写了一篇博文，阐述了他使用sed命令处理X12的问题，这些问题促使他使用Rust来写x12pp。并且写出来的工具性能上可以轻松击败sed这样的通用工具。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/clarkema/x12pp&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;x12pp&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.lambdafunctions.com/articles/racing-sed-with-rust&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;finshir - 一种 Low&amp;amp;Slow 流量产生器&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cloudflare.com/learning/ddos/ddos-low-and-slow-attack/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Low&amp;amp;Slow&lt;/a&gt; 是一种DDos攻击方法，利用产生大量的慢请求来保持住对服务器资源的消耗，从而影响正常请求的访问。finshir 就是这样一种用Rust写的工具。有两点高光：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Xudong-Huang/may&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;may&lt;/a&gt;，对，就是黄旭东大佬的May协程库&lt;/li&gt;&lt;li&gt;可以配合 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Tor_%2528anonymity_network%2529&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tor&lt;/a&gt; 使用，实现匿名性&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Gymmasssorla/finshir&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;riv - 图片查看工具&lt;/h3&gt;&lt;p&gt;这是一个命令行工具。其使用 SDL2 来渲染图片显示。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/davejkane/riv&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Repo&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;「系列」使用 Rust 实现一种新语言 Part I&lt;/h3&gt;&lt;p&gt;作者正在练习实现一种语言 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/epellis/esta&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;esta&lt;/a&gt;。第一步就是生成 AST（Abstract Syntax Tree 抽象语法树）。作者详尽地记录了怎样从头开始撸一门语言，这个文章是一个系列文章，想要自己设计语言和学习编译原理的同学强烈推荐阅读。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//nedellis.com/2019/05/08/esta_1/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;rust-hypervisor-firmware: 一個簡單的 kvm firmware&lt;/h3&gt;&lt;p&gt;intel出品，代码不多，看上去确实简单，可以学习如何用rust实现一个kvm。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.reddit.com/r/rust/comments/bn1b47/simple_kvm_firmware_written_in_rust_from_intel/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Read more&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/intel/rust-hypervisor-firmware&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;intel/rust-hypervisor-firmware&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;wasm-flate: 使用WASM对客户端文件进行超快压缩的工具&lt;/h3&gt;&lt;p&gt;支持GZIP，ZLIB和DEFLATE压缩和解压缩&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/drbh/wasm-flate&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;wasm-flate&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;hors: howdoi的Rust实现&lt;/h3&gt;&lt;p&gt;Howdoi是Go实现的通过命令行获取即时的编程问题解答的工具，hors是它的Rust实现版本。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-22373089579b211685fc3a38517d289e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;680&quot; data-rawheight=&quot;426&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;680&quot; data-original=&quot;https://pic3.zhimg.com/v2-22373089579b211685fc3a38517d289e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-22373089579b211685fc3a38517d289e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;680&quot; data-rawheight=&quot;426&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;680&quot; data-original=&quot;https://pic3.zhimg.com/v2-22373089579b211685fc3a38517d289e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-22373089579b211685fc3a38517d289e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/WindSoilder/hors&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;hors&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2019-05-12-65509043</guid>
<pubDate>Sun, 12 May 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
