<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Rust编程</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/</link>
<description>In Rust We Trust 与 Rust 语言相关的方方面面</description>
<language>zh-cn</language>
<lastBuildDate>Sat, 04 Jan 2020 19:08:45 +0800</lastBuildDate>
<item>
<title>两百行Rust代码解析绿色线程原理（三）栈</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2020-01-04-100964432.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/100964432&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt; 原文: Green threads explained in 200 lines of rust language&lt;br/&gt; 地址: &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cfsamson.gitbook.io/gre&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;en-threads-explained-in-200-lines-of-rust/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;  &lt;br/&gt; 作者: Carl Fredrik Samson(cfsamson@Github)&lt;br/&gt; 翻译: 耿腾&lt;br/&gt; &lt;/blockquote&gt;&lt;hr/&gt;&lt;blockquote&gt; 栈只不过是一块连续的内存。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;这一点很重要。计算机只有内存，它没有特殊的“栈”内存和“堆”内存，它们都是同一个内存的某一部分。&lt;/p&gt;&lt;p&gt;它们不同之处在于如何访问和使用该部分内存。栈支持在内存的连续部分上使用简单的入栈/弹栈指令，这使得它使用起来很快。堆内存由内存分配器按需分配，并且可以分散在不同的位置。&lt;/p&gt;&lt;p&gt;我们不会在这里讨论栈和堆之间的差异，因为有很多文章详细解释它们，包括 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html%23the-stack-and-the-heap&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust 编程语言&lt;/a&gt; 中的一章。&lt;/p&gt;&lt;h3&gt;栈是什么样的&lt;/h3&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d330ba49f6e8fd9dde5ad579a16442ea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;465&quot; data-rawheight=&quot;1024&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;465&quot; data-original=&quot;https://pic3.zhimg.com/v2-d330ba49f6e8fd9dde5ad579a16442ea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d330ba49f6e8fd9dde5ad579a16442ea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;465&quot; data-rawheight=&quot;1024&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;465&quot; data-original=&quot;https://pic3.zhimg.com/v2-d330ba49f6e8fd9dde5ad579a16442ea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d330ba49f6e8fd9dde5ad579a16442ea_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;让我们从这张简化的栈示意图开始。64 位 CPU 一次读取 8 个字节，尽管我们看到栈的自然方式是一长行的 &lt;code&gt;u8&lt;/code&gt; ；所以当我们传递指针时，我们需要确保传入的指针指向 &lt;code&gt;0016&lt;/code&gt;,&lt;code&gt;0008&lt;/code&gt; 或上例中的 &lt;code&gt;0000&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;栈向下增长，因此我们从顶部开始向下工作。&lt;/p&gt;&lt;p&gt;当我们将栈指针设置为 &lt;i&gt;16 字节对齐&lt;/i&gt; 的栈时，我们需要确保栈指针指向那些地址值为 16 的倍数的位置。在上面的示例中，满足此要求的唯一地址是 0008（记住栈从顶部开始）。&lt;/p&gt;&lt;p&gt;如果我们在上一章中添加以下代码行，就在我们在 &lt;code&gt;main&lt;/code&gt; 函数中进行切换之前，我们可以有效地打印出我们的栈并查看它：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;mem: {}, val: {}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;isize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;isize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们得到的输出是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;mem: 94846750517871, val: 0
mem: 94846750517870, val: 0
mem: 94846750517869, val: 0
mem: 94846750517868, val: 0
mem: 94846750517867, val: 0
mem: 94846750517866, val: 0
mem: 94846750517865, val: 0
mem: 94846750517864, val: 0
mem: 94846750517863, val: 0
mem: 94846750517862, val: 0
mem: 94846750517861, val: 86
mem: 94846750517860, val: 67
mem: 94846750517859, val: 56
mem: 94846750517858, val: 252
mem: 94846750517857, val: 205
mem: 94846750517856, val: 240
mem: 94846750517855, val: 0
mem: 94846750517854, val: 0
mem: 94846750517853, val: 0
mem: 94846750517852, val: 0
mem: 94846750517851, val: 0
mem: 94846750517850, val: 0
mem: 94846750517849, val: 0
mem: 94846750517848, val: 0
mem: 94846750517847, val: 0
mem: 94846750517846, val: 0
mem: 94846750517845, val: 0
mem: 94846750517844, val: 0
mem: 94846750517843, val: 0
mem: 94846750517842, val: 0
mem: 94846750517841, val: 0
mem: 94846750517840, val: 0
mem: 94846750517839, val: 0
mem: 94846750517838, val: 0
mem: 94846750517837, val: 0
mem: 94846750517836, val: 0
mem: 94846750517835, val: 0
mem: 94846750517834, val: 0
mem: 94846750517833, val: 0
mem: 94846750517832, val: 0
mem: 94846750517831, val: 0
mem: 94846750517830, val: 0
mem: 94846750517829, val: 0
mem: 94846750517828, val: 0
mem: 94846750517827, val: 0
mem: 94846750517826, val: 0
mem: 94846750517825, val: 0
mem: 94846750517824, val: 0
I LOVE WAKING UP ON A NEW STACK!&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我已经在这里把内存地址打印成 &lt;code&gt;u64&lt;/code&gt; 类型，这样如果你不熟悉十六进制也容易肉眼解析。&lt;/p&gt;&lt;p&gt;首先要注意的是，这只是一块连续的内存，从地址 94846750517824 开始，到 94846750517871 结束。&lt;/p&gt;&lt;p&gt;地址 94846750517856 到 94846750517863 应该需要我们特别注意。第一个地址是我们的“栈指针”的地址，我们写入 CPU 的 &lt;code&gt;%rsp&lt;/code&gt; 寄存器的值。范围表示在我们进行切换之前写入栈的值。&lt;/p&gt;&lt;p&gt;换句话说，值 &lt;code&gt;240,205,252,56,67,86,0,0&lt;/code&gt; 是指向我们的 &lt;code&gt;hello()&lt;/code&gt; 函数的指针，只是写成了多个 &lt;code&gt;u8&lt;/code&gt; 类型的值。&lt;/p&gt;&lt;blockquote&gt; 这里有一个有趣的注意事项是 CPU 将 &lt;code&gt;u64&lt;/code&gt; 写为 &lt;code&gt;u8&lt;/code&gt; 字节的顺序取决于它的字节顺序。我将简单地参考&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Endianness&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;维基百科的文章&lt;/a&gt;，但如果你试图手动解析这些数字，你必须牢记这一点。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;当我们编写更复杂的函数时，我们极小的 48 字节栈将很快耗尽空间，你看，当我们运行我们在 Rust 中编写的函数时，我们的代码将指示 CPU 在我们的栈上入栈和弹出值来执行我们的程序。&lt;/p&gt;&lt;h3&gt;栈尺寸&lt;/h3&gt;&lt;p&gt;当你在大多数现代操作系统中启动进程时，标准栈大小通常为 8 MB，但可以进行不同的配置，这对于大多数程序来说已经足够了，但是需要由我们开发者保证使用的时候不会超出这个大小。这就是我们大多数人经历过的可怕的 “栈溢出” 的原因。&lt;/p&gt;&lt;p&gt;但是，当我们自己控制栈时，我们可以选择我们想要的大小。例如，在 Web 服务器中运行简单函数时，每个上下文都用 8 MB 是超出我们的需要的，因此通过减少栈大小，我们可以在一台机器上运行数百万个绿色线程，而如果使用操作系统提供的栈，我们会更快把内存用光。&lt;/p&gt;&lt;h3&gt;可增长的栈&lt;/h3&gt;&lt;p&gt;某些实现使用可增长的栈。这让我们可以只分配一小部分内存就足够为大多数任务使用，但是当我们用光这个栈时它不会导致栈溢出，而是分配一个新的更大的栈并将所有内容从当前栈中移到这个新的更大的栈上，并可以恢复程序继续执行。&lt;/p&gt;&lt;p&gt;Go 语言就是一个这样的例子。它从一个 8 KB 的栈开始，当它的空间用完时，它会重新分配到一个更大的栈。但是正如编程中的每一件事都是有代价的，所有指针都需要正确地被更新，这不是一件容易的事。如果你对 Go 如何处理它的栈更感兴趣（这是可增长栈的使用和权衡的一个很好的例子）可以参看这篇文章： &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.cloudflare.com/how-stacks-are-handled-in-go/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;blog.cloudflare.com/how&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;-stacks-are-handled-in-go/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt; 请注意稍后会很重要的一件事：我们使用 Rust 标准库中普通的 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;。对我们来说非常方便，但也有一些问题。除了其它之外，我们无法保证它会留在内存中的同一位置。 你可能会想到，如果栈移动到不同的地址空间，我们的程序会崩溃，因为我们的所有指针都将变为无效。比如对我们的栈执行 &lt;code&gt;push()&lt;/code&gt; 这样简单的操作可能会触发一次增长，当 &lt;code&gt;Vec&lt;/code&gt; 扩展它时会请求一个新的、更大的内存块并将值移动到新位置。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;好了，现在我们已经了解了栈的外观和工作原理，我们已准备好继续实现绿色线程。你已经完成了很多艰苦的工作，所以我答应你开始写代码。&lt;/p&gt;&lt;h3&gt;如何设置栈&lt;/h3&gt;&lt;p&gt;Windows x64-86 的栈设置与 x64-86 psABI 调用约定略有不同。我将在 &lt;b&gt;附录：支持Windows&lt;/b&gt; 的章节中花更多时间介绍 Windows 栈，但重要的是要知道如果用那些并不接受多个参数的简单函数设置栈，两者的差异不是很大，就像我们目前做的这样。&lt;/p&gt;&lt;p&gt;&lt;b&gt;psABI 的栈布局如下：&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-71b61c872fa05291a636904c8e51e257_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;404&quot; data-rawheight=&quot;263&quot; class=&quot;content_image&quot; width=&quot;404&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-71b61c872fa05291a636904c8e51e257_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;404&quot; data-rawheight=&quot;263&quot; class=&quot;content_image lazy&quot; width=&quot;404&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-71b61c872fa05291a636904c8e51e257_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如你所知，&lt;code&gt;%rsp&lt;/code&gt; 是我们的栈指针。你可以看到，我们需要将栈指针放在距离我们的基地址为 16 的倍数位置。返回的地址位于相邻的 8 个字节中，如你所见，上面有一个内存参数的空间。当我们想要做比迄今为止更复杂的事情时，我们需要牢记这一点。&lt;/p&gt;&lt;h3&gt;幕后花絮&lt;/h3&gt;&lt;p&gt;如果你足够好奇，你可能想知道切换到栈后它发生了什么？&lt;/p&gt;&lt;p&gt;答案是我们用 Rust 编写的代码被编译成 CPU 的指令，然后就像使用任何其他的栈一样，接管并使用我们的栈。&lt;/p&gt;&lt;p&gt;遗憾的是，为了清楚地展示这一点，我得将栈大小增加到 1024 字节，才能为打印出栈本身获得足够的空间，所以目前这样我们无法打印。&lt;/p&gt;&lt;h3&gt;看一下栈&lt;/h3&gt;&lt;p&gt;不过，我制作了一个示例的更改版本，在运行时它会打印出两个文本文件，一个是 &lt;code&gt;BEFORE.txt&lt;/code&gt;，在我们切换到栈之前打印出我们的栈，一个 &lt;code&gt;AFTER.txt&lt;/code&gt; 打印出我们切换后的栈。然后，你可以自己查看栈现在是如何存活并由我们的代码使用的。&lt;/p&gt;&lt;blockquote&gt; 如果你在此代码中看到任何你无法识别的内容，请稍作休息，我们会尽快搞清楚它们。&lt;br/&gt; &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#![feature(asm)]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#![feature(naked_functions)]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSIZE&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;isize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_PTR&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#[derive(Debug, Default)]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#[repr(C)]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadContext&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsp&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r15&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r14&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r13&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r12&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbx&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbp&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeln&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;                &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;                &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;mem: {}, val: {}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;                &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_PTR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;isize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;                &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_PTR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;isize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;Error writing to file.&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;I LOVE WAKING UP ON A NEW STACK!&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;AFTER.txt&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gt_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mov&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;:
    : &lt;span class=&quot;s&quot;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;:
    : &lt;span class=&quot;s&quot;&gt;&amp;#34;alignstack&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadContext&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0_&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSIZE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_ptr&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;as_mut_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_PTR&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSIZE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;BEFORE.txt&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSIZE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gt_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>不明觉疼</author>
<guid isPermaLink="false">2020-01-04-100964432</guid>
<pubDate>Sat, 04 Jan 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>两百行Rust代码解析绿色线程原理（二）一个能跑通的例子</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2020-01-03-100846626.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/100846626&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt; 原文: Green threads explained in 200 lines of rust language&lt;br/&gt; 地址: &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cfsamson.gitbook.io/gre&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;en-threads-explained-in-200-lines-of-rust/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;  &lt;br/&gt; 作者: Carl Fredrik Samson(cfsamson@Github)&lt;br/&gt; 翻译: 耿腾&lt;br/&gt; &lt;/blockquote&gt;&lt;hr/&gt;&lt;blockquote&gt; 在这个例子中，我们将创建自己的栈，并使 CPU 从它当前执行的上下文切换到到我们创建的栈。我们将在后面的章节中基于这些概念进行构建（不过我们不会在这些代码的基础上构建）。&lt;br/&gt; 译者注：阅读本章时建议读者自己也动手写代码运行一下，很多问题就容易理解了。&lt;br/&gt; &lt;/blockquote&gt;&lt;h3&gt;创建我们的项目&lt;/h3&gt;&lt;p&gt;首先，让我们在名为 &lt;code&gt;green_threads&lt;/code&gt; 的文件夹中启动一个新项目。命令行执行：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;cargo init&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们需要使用 nightly 版本的 Rust，因为我们将使用一些尚未稳定的功能：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;rustup override set nightly&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我们的 &lt;code&gt;main.rs&lt;/code&gt; 文件中，我们首先启用一个功能，它允许我们使用 &lt;code&gt;asm!&lt;/code&gt; 宏：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#![feature(asm)]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们在这里设置一个较小的栈尺寸，只有 48 个字节，这样我们可以在切换上下文之前打印并查看这个栈：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSIZE&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;isize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;48&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt; 在 OSX 中使用这么小的栈的好像有些问题。此代码运行的最小值是 624 字节的栈大小。如果你想要遵循这个确切的例子，代码可以在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//play.rust-lang.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust Playground&lt;/a&gt; 上运行（但是由于最终代码中的循环，你需要等待大概 30 秒的超时时间）。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;然后，我们添加一个表示 CPU 状态的结构。我们现在只关注存储 “栈指针” 的寄存器，所以只需要添加下面的代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#[derive(Debug, Default)]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#[repr(C)]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadContext&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsp&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在后面的示例中，我们将使用之前链接中的规范文档中标记为 &lt;b&gt;“callee saved”（由被调用者保存的）&lt;/b&gt; 的所有寄存器。这些就是 x86-64 ABI 描述的寄存器中那些用来保存上下文的寄存器，但是现在我们只需要一个寄存器来使 CPU 跳转到我们的栈。&lt;/p&gt;&lt;p&gt;需要注意的是，这个结构定义需要加上 &lt;code&gt;#[repr(C)]&lt;/code&gt;，因为我们需要按照汇编代码的方式去访问数据。 Rust 没有稳定的 ABI，因此我们无法确保它会在内存中以  &lt;code&gt;rsp&lt;/code&gt; 作为前 8 个字节来表示。 C 具有稳定的 ABI，这一属性正是在告诉编译器使用兼容 C-ABI 的内存布局。当然，我们的结构现在只有一个字段，但我们稍后会添加更多字段。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;I LOVE WAKING UP ON A NEW STACK!&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于这个非常简单的例子，我们将定义一个函数，它只打印一条消息，然后永远循环：&lt;/p&gt;&lt;p&gt;接下来是我们的内联汇编，我们切换到自己的栈。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gt_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mov&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;:
    : &lt;span class=&quot;s&quot;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;:
    : &lt;span class=&quot;s&quot;&gt;&amp;#34;alignstack&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 目前没有这句也可以工作，不过后面会用到
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们在这里使用了一个技巧。我们写入要在新栈上运行的函数的地址。然后我们将存储此地址的第一个字节的地址传递给 rsp 寄存器（我们设置给 &lt;code&gt;new.rsp&lt;/code&gt; 的地址值将指向 &lt;i&gt;位于我们自己的栈上的地址，该地址将导致上述函数被调用&lt;/i&gt;）。我讲清楚了吗？&lt;/p&gt;&lt;p&gt;&lt;code&gt;ret&lt;/code&gt; 关键字将程序控制转移到位于栈顶部的返回地址。由于我们将地址推送到 &lt;code&gt;%rsp&lt;/code&gt; 寄存器，因此CPU会认为它是当前运行的函数的返回地址，因此当我们传递 &lt;code&gt;ret&lt;/code&gt; 指令时，它会直接返回到我们自己的栈中。&lt;/p&gt;&lt;p&gt;CPU 做的第一件事就是读取函数的地址并运行它。&lt;/p&gt;&lt;h3&gt;Rust 内联汇编宏的快速入门&lt;/h3&gt;&lt;p&gt;如果您之前没有使用内联汇编，可能会看起来很陌生，但我们稍后会使用扩展版本来切换上下文，所以我将逐行解释我们正在做什么：&lt;/p&gt;&lt;p&gt;&lt;code&gt;unsafe&lt;/code&gt; 是一个关键字，表示 Rust 无法在我们编写的函数中强制执行安全保证。由于我们直接操作 CPU，这绝对是不安全的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;n&quot;&gt;gt_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里我们获取一个指向 &lt;code&gt;ThreadContext&lt;/code&gt; 实例的指针，我们只读取一个字段。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是 Rust 标准库中的 &lt;code&gt;asm!&lt;/code&gt; 宏。它将检查我们的语法，在遇到看起来不像 AT&amp;amp;T（默认情况下）汇编语法的情况时会产生一个错误消息。&lt;/p&gt;&lt;p&gt;这个宏里第一个输入是汇编模板：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;mov 0x00($0), %rsp&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是一个简单的指令，它将存储在基地址为 &lt;code&gt;$0&lt;/code&gt; 偏移量为 &lt;code&gt;0x00&lt;/code&gt; 处的值（这意味着在十六进制中完全没有偏移）移动到 &lt;code&gt;rsp&lt;/code&gt; 寄存器。由于 &lt;code&gt;rsp&lt;/code&gt; 寄存器存储指向栈上下一个值的指针，因此我们有效地将我们提供的地址压到当前的栈上，覆盖了当前已有的值。&lt;/p&gt;&lt;p&gt;在普通的汇编代码中，你不会看到这样使用的 &lt;code&gt;$0&lt;/code&gt;。这是汇编模板的一部分，是第一个参数的占位符。参数编号为 0,1,2 ...... 从输出参数开始，然后继续输入参数。我们这里只有一个输入参数，对应于 &lt;code&gt;$0&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果在普通汇编中遇到 &lt;code&gt;$&lt;/code&gt;，它很可能意味着一个立即值（一个整数常量），但也要看具体情况（是的，$可以代表方言之间以及 x86 汇编和 x86-64 汇编之间的不同之处）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;ret&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;ret&lt;/code&gt; 关键字指示 CPU 从栈顶部弹出一个内存位置，然后无条件跳转到该位置。实际上我们已经劫持了我们的 CPU 并使其返回到我们的栈。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;:&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;内联 ASM 与普通 ASM 略有不同。我们在汇编模板后传递了四个附加参数。这是第一个被称为 &lt;code&gt;output&lt;/code&gt;（输出） 的，它是我们传递输出参数的地方，这些参数是我们想要在Rust函数中用作返回值的参数。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;: &amp;#34;r&amp;#34;(new)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第二个是我们的输入参数。在编写内联汇编时，&lt;code&gt;&amp;#34;r&amp;#34;&lt;/code&gt; 被称为一个 &lt;code&gt;constraint&lt;/code&gt;（约束）。您可以使用这些约束来有效地指导编译器决定放置输入的位置（例如，在一个寄存器中作为值或将其用作“内存”位置）。 &lt;code&gt;&amp;#34;r&amp;#34;&lt;/code&gt; 仅表示将其放入编译器选择的通用寄存器中。内联汇编中的约束本身是一个很大的课题，幸运的是我们的需求很简单。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;:&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下一个选项是 &lt;code&gt;clobber&lt;/code&gt; 列表，您可以在其中指定编译器不应触及的寄存器，并让它知道我们要在汇编代码中管理这些寄存器。如果我们弹出栈的任何值，我们需要在这里指定哪些寄存器并让编译器知道，因此它知道它不能自由地使用这些寄存器。我们不需要它，因为我们返回了一个全新的栈。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;: &amp;#34;alignstack&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后一个是我们的 &lt;code&gt;options&lt;/code&gt;（选项）。这些对于 Rust 来说是独一无二的，我们可以设置的选项由三种：&lt;code&gt;alignstack&lt;/code&gt;，&lt;code&gt;volatile&lt;/code&gt; 和 &lt;code&gt;intel&lt;/code&gt;。我会向你介绍文档以了解它们，在&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/stable/unstable-book/library-features/asm.html%23options&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这里&lt;/a&gt;有具体解释。值得注意的是，我们需要为代码指定 “对齐栈（&lt;code&gt;alignstack&lt;/code&gt;）” 才能在 Windows 上运行。&lt;/p&gt;&lt;h3&gt;运行我们的例子&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadContext&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0_&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSIZE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_ptr&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;as_mut_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSIZE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSIZE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gt_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以这实际上是在设计我们的新栈。 &lt;code&gt;hello&lt;/code&gt; 已经是一个指针了（一个函数指针），所以我们可以直接把它转换为一个 &lt;code&gt;u64&lt;/code&gt;，因为 64 位系统上的所有指针都是 64 位，然后我们将这个指针写入我们的新栈。&lt;/p&gt;&lt;blockquote&gt; 我们将在下一章中详细讨论栈，但现在我们需要知道的一件事是栈向下增长。如果我们的 &lt;i&gt;48&lt;/i&gt; 字节栈在索引 &lt;i&gt;0&lt;/i&gt; 处开始，并在索引 &lt;i&gt;47&lt;/i&gt; 处结束，则索引 &lt;i&gt;32&lt;/i&gt; 将是从栈末尾开始的 16 字节偏移量的第一个索引。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;请注意，我们将指针写入距离栈底部16字节的偏移量（还记得我写的关于16字节对齐的内容吗？）。&lt;/p&gt;&lt;p&gt;我们把它作为指向 &lt;code&gt;u64&lt;/code&gt; 的指针而不是指向 &lt;code&gt;u8&lt;/code&gt; 的指针。我们想要写入位置 32、33、34、35、36、37、38、39，这是我们存储 &lt;code&gt;u64&lt;/code&gt; 所需的 8 字节空间。如果我们不进行这个类型转换，我们实际上是在尝试将 &lt;code&gt;u64&lt;/code&gt; 写入位置 32（译者注：即将一个 &lt;code&gt;u64&lt;/code&gt; 写入到一个 &lt;code&gt;u8&lt;/code&gt; 中，显然存不下），这不是我们想要的。&lt;/p&gt;&lt;blockquote&gt; 译者注：&lt;code&gt;stack_ptr&lt;/code&gt; 的类型为 &lt;code&gt;* mut u8&lt;/code&gt;，&lt;code&gt;stack_ptr.offset(SSIZE - 16)&lt;/code&gt; 也是 &lt;code&gt;* mut u8&lt;/code&gt;。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;我们将 &lt;code&gt;rsp&lt;/code&gt;（栈指针）设置为 &lt;i&gt;栈中索引为 32 的内存地址&lt;/i&gt;，我们传递的不是存储在该位置的 &lt;code&gt;u64&lt;/code&gt; 值而是首字节的地址。&lt;/p&gt;&lt;blockquote&gt; 译者注：如果传递的是存储在该位置的值，代码就应该是 &lt;code&gt;(stack_ptr.offset(SSIZE - 16) as * mut u64).read()&lt;/code&gt;，即 &lt;code&gt;hello&lt;/code&gt; 函数指针的值；如果是首字节地址，就是上面那段代码中的 &lt;code&gt;stack_ptr.offset(SSIZE - 16) as u64&lt;/code&gt;（这个地址以 &lt;code&gt;u64&lt;/code&gt; 类型存储，因为我们要把它赋值给 &lt;code&gt;u64&lt;/code&gt; 类型的 &lt;code&gt;ctx.rsp&lt;/code&gt;）。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;当我们执行 &lt;code&gt;cargo run&lt;/code&gt; 命令时，我们将看到如下输出：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Finished dev [unoptimized + debuginfo] target(s) in 0.58s
Running `target\debug\green_thread_start.exe`
I LOVE WAKING UP ON A NEW STACK!&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;好的，究竟发生了什么？ 我们在任何时候都没有调用函数 &lt;code&gt;hello&lt;/code&gt;，但它仍然运行了。发生的事情是我们实际上让 CPU 跳转到我们自己的栈并在那里执行代码。我们迈出了实现上下文切换的第一步。&lt;/p&gt;&lt;p&gt;在接下来的章节中，我们会在实现绿色线程之前先探讨一点栈相关的内容，这个过程会更加容易，因为目前我们已经涵盖了很多基础知识。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/cfsamson/example-greenthreads&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;如果要运行它，可以在这里查看完整代码。&lt;/a&gt;&lt;/p&gt;</description>
<author>不明觉疼</author>
<guid isPermaLink="false">2020-01-03-100846626</guid>
<pubDate>Fri, 03 Jan 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>两百行Rust代码解析绿色线程原理（一）绪论及基本概念</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2020-01-02-100058478.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/100058478&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt; 原文: Green threads explained in 200 lines of rust language&lt;br/&gt; 地址: &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cfsamson.gitbook.io/gre&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;en-threads-explained-in-200-lines-of-rust/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;  &lt;br/&gt; 作者: Carl Fredrik Samson(cfsamson@Github)&lt;br/&gt; 翻译: 耿腾 翟堃&lt;br/&gt;&lt;br/&gt; 本书旨在通过一个小例子解释绿色线程。我们会实现一个简单但能工作的程序，在这个程序中我们可以使用自己实现的绿色线程来执行代码。&lt;br/&gt;&lt;br/&gt; 译者注：原书前三章分别为 &lt;b&gt;绪论(Introduction)&lt;/b&gt;、&lt;b&gt;绿色线程(Green Threads)&lt;/b&gt;、&lt;b&gt;背景信息(Background Information)&lt;/b&gt;，因篇幅较短，我在本译文系列中把它们合并为 &lt;b&gt;绪论及基本概念&lt;/b&gt;。&lt;br/&gt; &lt;/blockquote&gt;&lt;h2&gt;绪论&lt;/h2&gt;&lt;blockquote&gt; 我们在这里使用的所有代码都存储在一个&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/cfsamson/example-greenthreads&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Github仓库&lt;/a&gt;中。该库有两个分支，主分支（master）只包含代码，注释分支（commented）包含代码以及注释，其中的注释解释了我们所做的工作。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;绿色线程&lt;/b&gt;，或称用户态线程、goroutine、纤程（译者注：也叫“协程”、“coroutine”），它有许多名称，但为了简单起见，我将从现在开始将它们全部称为 &lt;b&gt;绿色线程&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;在本文中，我想通过实现一个非常简单的示例来探索它们是如何工作的，用 200 行 Rust 代码创建自己的绿色线程。我们将在整个过程中解析所有相关内容，因此我们关注的重点是通过使用简单但有效的示例来理解它们并学习它们的工作原理。&lt;/p&gt;&lt;blockquote&gt; 我们不会使用任何外部库或帮助程序，并将从零开始做所有事情，因此我们得确保我们真正了解整个过程中发生了什么。&lt;br/&gt; &lt;/blockquote&gt;&lt;h3&gt;这篇文章是写给谁的？&lt;/h3&gt;&lt;p&gt;在这篇文章中，我们会探索兔子洞中的世界（译者注：引喻爱丽丝漫游奇境记中的新世界），如果这听起来很可怕，那么这篇文章可能不适合你，回去过自己幸福的小日子吧。&lt;/p&gt;&lt;p&gt;如果你是一个好奇的人，想要了解这些东西的运作方式，那么请继续读下去。也许你已经听说过 Go 及其提供的 goroutine，或者 Ruby、Julia 中的等价物，你知道如何使用它们但想知道它们是如何工作的——那么也请继续读下去。&lt;/p&gt;&lt;p&gt;此外，这应该会很有趣，如果：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;你是 Rust 的新手，想要了解有关其功能的更多信息。&lt;/li&gt;&lt;li&gt;你已经跟进 Rust 社区中有关 async / await 、Pin-API 以及我们需要 Generator 的原因的讨论。考虑这种情况，我尝试将所有这些一并放在本文中。&lt;/li&gt;&lt;li&gt;你想学习Rust中内联汇编的基础知识。&lt;/li&gt;&lt;li&gt;你只是好奇。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;好吧，加入我，我们将试图弄清楚我们需要了解的关于它们的一切。&lt;/p&gt;&lt;p&gt;你不必是 Rust 程序员就能理解本文，但强烈建议你首先阅读一些基本语法。如果你想长时间跟踪或克隆代码仓库并且跑一下代码，你应该安装 Rust 并学习相关的基础知识。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.rust-lang.org/tools/install&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;你可以在这找到安装 Rust 所需要的一切。&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;继续&lt;/h3&gt;&lt;p&gt;我在这里提供的所有代码都在一个文件中并且没有依赖项，这意味着你可以轻松地启动自己的工程并跟着本文完成编码，只要你真的想（我建议你想）。你甚至可以在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//play.rust-lang.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rust 的代码演练页面&lt;/a&gt; 上运行大部分代码。只是要记得使用编译器的 nightly 版本。&lt;/p&gt;&lt;h3&gt;可移植性和一些问题&lt;/h3&gt;&lt;p&gt;目前 &lt;code&gt;asm！&lt;/code&gt; 宏存在一个问题，它不能在 &lt;code&gt;release&lt;/code&gt; 模式下编译。它似乎与我在内联宏中使用的 &lt;code&gt;&amp;#34;= m&amp;#34;&lt;/code&gt; 约束有关。&lt;/p&gt;&lt;h3&gt;2019-06-21 补充编辑：&lt;/h3&gt;&lt;p&gt;我决定解决这个问题并更改内联汇编以在发布版本上编译和运行。 我已经在OSX，Linux 和 Windows 上测试了代码。&lt;/p&gt;&lt;h3&gt;免责声明&lt;/h3&gt;&lt;p&gt;我不打算在这里做一个完美的实现。我正在一步步的尝试深入了解本质，并将其融入原本打算成为文章的内容，而不是扩展为一本小书。这个实现并不能体现 Rust 语言的最大优势——Rust的安全保证机制——不过这确实显示了 Rust 的一个有趣的用法，代码大多非常干净，易于跟进。&lt;/p&gt;&lt;p&gt;但是，如果你发现了可以使代码更安全而不会显著增加复杂性的地方，欢迎你在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/cfsamson/example-greenthreads&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Github 仓库&lt;/a&gt;中创建一个问题，甚至能提一个 Pull Request 就更棒了。&lt;/p&gt;&lt;h3&gt;鸣谢&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/mpu&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quentin Carbonneaux&lt;/a&gt; 在 2013 年写了一篇&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//c9x.me/articles/gthreads/intro.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;很棒的文章&lt;/a&gt;，我以它作为主要的代码示例的灵感来源。感谢 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/nickelpro&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;nickelpro&lt;/a&gt; 提供有关 Windows 支持的帮助和反馈。&lt;/p&gt;&lt;h3&gt;补充编辑&lt;/h3&gt;&lt;p&gt;2019-06-18：实现 Windows 支持的新章节.&lt;/p&gt;&lt;p&gt;2019-06-21：相当大的改变和清理。Valgrind 报告了一些代码问题并且崩溃了。现在已经修复，目前还没有未解决的问题。此外，代码现在可以在 &lt;code&gt;debug&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt; 两种 build 模式上运行，而不会在所有平台上出现任何问题。感谢各位报告你们发现的问题。&lt;/p&gt;&lt;p&gt;2019-06-26：支持 Windows 附录将 &lt;code&gt;XMM&lt;/code&gt; 字段视为 64 位，但它们是 128 位，这是我的疏忽。纠正这一点为那一章增加了一些有趣的材料，但不幸的是也增加了一些复杂性。不管怎样，它现在已得到纠正和解释。&lt;/p&gt;&lt;p&gt;2019-12-22: 增加一行代码来确保我们从分配器获取的内存是 16 字节对齐的。重构为在写入堆栈时使用“高”内存地址作为偏移量的基地址，因为这使对齐更加容易。 感谢 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Veetaha&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;@Veetaha&lt;/a&gt; 解决了这个问题。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;绿色线程&lt;/h2&gt;&lt;p&gt;绿色线程解决了一个开发中的常见问题。你不希望代码阻塞 CPU，使它无法执行有意义的工作。我们通过使用多任务来解决这个问题，它允许我们暂停执行某一段代码同时唤醒执行另一段代码，并在他们的 &lt;b&gt;“上下文”&lt;/b&gt; 之间切换。&lt;/p&gt;&lt;p&gt;不要把它与并行性（parallelism）混淆，虽然这确实容易混淆，但它们是两个不同的东西。可以这样理解，绿色线程让我们更爽也更高效地工作，从而更有效地利用资源，而并行性就像在问题上投入更多资源。&lt;/p&gt;&lt;p&gt;通常有两种方法可以做到这一点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;抢占式多任务处理&lt;/li&gt;&lt;li&gt;非抢占式多任务处理（或协同多任务处理）&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;抢占式多任务处理&lt;/h3&gt;&lt;p&gt;某个外部调度程序停止当前任务并在切换回去之前运行另一个任务。在这种情况下，任务本身没有什么发言权，决定是由 “另外的东西”（通常是某种调度程序）做出的。操作系统内核用的就是这种方式，即允许你在一个单线程系统上使用 UI 界面的同时还进行 CPU 进行计算。我们不打算探讨这种线程，但我觉得当你理解一个其中一个范式时，你会更好的理解这两种范式。&lt;/p&gt;&lt;h3&gt;非抢占式多任务处理&lt;/h3&gt;&lt;p&gt;这就是我们要探讨的内容。一个任务由自己决定什么时候 CPU 会更好地做其他事情而不是等待当前任务会发生的事情。通常，它是通过对调度程序 &lt;b&gt;产生&lt;/b&gt;（&lt;code&gt;yielding&lt;/code&gt;） 控制来实现的。一个正常的用例是，在会造成阻塞的事情发生时产生控制，比如 IO 操作。当控制产生时，中央调度程序会指示 CPU 继续处理另一个就绪的任务，而不会阻塞。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;背景信息&lt;/h2&gt;&lt;p&gt;这是本书中最技术性的部分，但如果我们真的想要理解，这是必经之路。我将保证尽可能快地回归重点，我们很快就会开始写代码。&lt;/p&gt;&lt;p&gt;让我们开始吧! 首先，我们将直接干扰和控制 CPU。这样可移植性不是很好，因为有很多种CPU。不过主要思路是一样的，但实现细节的一小部分将有所不同。&lt;/p&gt;&lt;p&gt;我们将介绍一种比较常用的体系结构：x86-64。&lt;/p&gt;&lt;p&gt;在这种架构中，CPU 具有一组16个寄存器：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b08d89d2f6e065e2dea1b6e1f7e11b37_b.jpg&quot; data-rawwidth=&quot;582&quot; data-rawheight=&quot;765&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;582&quot; data-original=&quot;https://pic4.zhimg.com/v2-b08d89d2f6e065e2dea1b6e1f7e11b37_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b08d89d2f6e065e2dea1b6e1f7e11b37_b.jpg&quot; data-rawwidth=&quot;582&quot; data-rawheight=&quot;765&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;582&quot; data-original=&quot;https://pic4.zhimg.com/v2-b08d89d2f6e065e2dea1b6e1f7e11b37_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b08d89d2f6e065e2dea1b6e1f7e11b37_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果你有兴趣，可以在这里找到规范的其余部分：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/hjl-tools/x86-psABI/wiki/X86-psABI&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/hjl-tools/x8&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;6-psABI/wiki/X86-psABI&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;我们现在感兴趣的是标记为 “callee saved” 的寄存器。正是这些寄存器记录我们程序的上下文：下一个的运行指令、基本指针、栈指针等等。我们稍后会详细了解这一点。&lt;/p&gt;&lt;p&gt;如果我们想直接向 CPU 发号施令，我们需要一些用汇编语言编写的最小代码，幸运的是我们只需要知道一些非常基本的汇编指令。比如如何在寄存器之间移动值：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;mov     %rsp, %rax&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt; Windows 的约定略有不同。在 Windows 上，寄存器 XMM6:XMM15 也是被调用者保存的，如果我们的函数使用它们，则必须保存和恢复。我们的代码在 Windows 上运行正常，即使我们在此示例中仅使用 psABI 约定。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;还有一个细微的区别，你可以在 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/100058478/edit&quot; class=&quot;internal&quot;&gt;附录：支持 Windows&lt;/a&gt; 中读到我们解决的整个过程。你仍然可以继续跟进，因为所有内容都可以在 Windows 上运行，但这不会是一个正确的实现。&lt;/p&gt;&lt;h3&gt;汇编语言的超级快速介绍&lt;/h3&gt;&lt;p&gt;首先，也是最重要的，汇编语言的可移植性不是很好，每个 CPU 可能都有一组特殊的指令，但有些指令在今天的大多数台式计算机上很常见。&lt;/p&gt;&lt;p&gt;有两种流行的方言： AT&amp;amp;T 方言和英特尔方言。&lt;/p&gt;&lt;p&gt;在 Rust 中编写内联汇编时，AT&amp;amp;T 方言是标准，但在 Rust 中我们可以指定我们想要使用 “英特尔”方言。 Rust 主要将它留给 LLVM （译者注：LLVM 是 Rust 编译器的后端）来处理内联汇编，而 LLVM 的内联汇编非常类似于在 C 中编写内联汇编时使用的语法。这样可以更容易地查看 C 内联 ASM 以进行学习，因为语法将非常熟悉（虽然不完全相同）。&lt;/p&gt;&lt;p&gt;&lt;i&gt;我们将在示例中使用AT&amp;amp;T方言。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;汇编语言具有强大的向后兼容性保证。这就是为什么你会看到相同的寄存器以不同的方式处理。让我们看一下我们先前那个例子里的 &lt;code&gt;%rax&lt;/code&gt; 寄存器：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;%rax  # 64位寄存器（8字节）
%eax  # “rax”寄存器的低32位
%ax   # “rax”寄存器的低16位
%ah   # “rax”寄存器的“ax”部分的高8位
%al   # “rax”寄存器的“ax”部分的低8位&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正如你所看到的，这基本上就是 CPU 发展的历史。由于目前大多数 CPU 都是 64 位，我们将在代码中使用 64 位寄存器。&lt;/p&gt;&lt;p&gt;汇编中的 &lt;b&gt;字长&lt;/b&gt;（原文: the &lt;code&gt;word&lt;/code&gt; size）也有历史原因。它起源于 CPU 拥有 16 位数据总线的时候，因此一个字是 16 位。这与我们的主题相关，因为在 AT&amp;amp;T 方言中，你会看到许多带有 “&lt;b&gt;q&lt;/b&gt;”（四字，quad-word）或 “&lt;b&gt;l&lt;/b&gt;”（长字，long-word）的说明。因此，&lt;code&gt;movq&lt;/code&gt; 意味着移动 &lt;code&gt;4 * 16位 = 64位&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;而一个普通的 &lt;code&gt;mov&lt;/code&gt; 将使用寄存器的大小。这是英特尔方言的标准，也是我们在代码中使用的标准。&lt;/p&gt;&lt;p&gt;我们将在下一章中详细介绍更多内联汇编的语法。&lt;/p&gt;&lt;p&gt;还有一点需要注意的是，&lt;b&gt;x86-64 上的堆栈对齐方式&lt;/b&gt; 是 &lt;b&gt;16 字节&lt;/b&gt;。记住这一点，后面要用。&lt;/p&gt;</description>
<author>不明觉疼</author>
<guid isPermaLink="false">2020-01-02-100058478</guid>
<pubDate>Thu, 02 Jan 2020 00:00:00 +0800</pubDate>
</item>
<item>
<title>正确的Rust引用类型心智模型</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2019-12-23-88926962.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/88926962&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;这是一篇译文，翻译自 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/dtolnay&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;David Tolnay&lt;/a&gt; 的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.rs/dtolnay/0.0.6/dtolnay/macro._02__reference_types.html%23accurate-mental-model-for-rusts-reference-types&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Accurate mental model for Rust’s reference types&lt;/a&gt;，MIT 协议授权。&lt;/blockquote&gt;&lt;p&gt;Rust 的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/book/ch04-01-what-is-ownership.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;所有权和借用模型&lt;/a&gt;涉及使用&lt;i&gt;引用&lt;/i&gt;（references）去操作借来的数据，类型系统区分了两种不同的基本引用类型。在代码中写成 &lt;code&gt;&amp;amp;T&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut T&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;amp;mut T&lt;/code&gt; 一般称为对类型为 &lt;code&gt;T&lt;/code&gt; 的数据的「可变引用」（mutable reference）。而 &lt;code&gt;&amp;amp;T&lt;/code&gt; 则是一个对于 &lt;code&gt;T&lt;/code&gt; 的「不可变引用」（immutable reference）或者「常量引用」（const reference）。这些名字不错，对 Rust 新手能建立合理的直觉。但这篇文章会讲一些理由来说明，对于新手阶段之后的 Rust 使用者来说，更好的名字是「共享引用」（shared reference）和「独占引用」（exclusive reference）。&lt;/p&gt;&lt;h2&gt;初学者的理解&lt;/h2&gt;&lt;p&gt;如同 Rust 书中的「&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/book/ch04-02-references-and-borrowing.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;引用和借用&lt;/a&gt;」一章所述，函数如果获取了一个不可变引用的参数，那就可以读取引用指向的数据：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;x={} y={}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但不允许改变数据：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;embiggen_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E0594&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;cannot&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;which&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;behind&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;embiggen_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;                   &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;------&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;consider&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;changing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;be&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutable&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;: &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^^^^^^^^^^^^^^^&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;the&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;refers&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cannot&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;be&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;written&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要改变结构的字段或者调用那些修改类方法，参数必须通过 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 引用获取。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;embiggen_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// okay
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用 Rust 写一些玩具程序的话，这种区分，这种「不可变引用」和「可变引用」的术语通常也足够了。&lt;/p&gt;&lt;h2&gt;散架啦&lt;/h2&gt;&lt;p&gt;迟早你会遇到一个库签名，直截了当地相悖于初学者对 Rust 引用的心智模型。作为一个例子，来看看标准库中 &lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/sync/atomic/struct.AtomicU32.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;AtomicU32&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;store&lt;/code&gt; 方法的签名：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AtomicU32&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;给一个 u32 值，它原子地将 &lt;code&gt;AtomicU32&lt;/code&gt; 的中的数字改成了你给的那个。可以像这样调用 &lt;code&gt;store&lt;/code&gt; 方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COUNTER&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;AtomicU32&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AtomicU32&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COUNTER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ordering&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;SeqCst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个讨论中可以忽略 &lt;code&gt;Ordering&lt;/code&gt; 参数，它根据&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/nomicon/atomics.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;C11 原子操作的内存模型&lt;/a&gt;来运作。&lt;/p&gt;&lt;p&gt;在初学者的心智模型下，&lt;code&gt;AtomicU32::store&lt;/code&gt; 方法获取自身的不可变引用这件事将会让人感觉浑身难受。确实修改是原子的，但修改不可变引用之下的数据怎么会是正确的呢？如果这是刻意为之，确实会令人感觉很魔法（hacky）甚至危险。为什么这个方法是 safe 的？为什么不是 Undefined Behavior？&lt;/p&gt;&lt;p&gt;这会让前 C++ 程序员想起 C++ 中一些 &lt;code&gt;const_cast&lt;/code&gt;的滥用，也许作者根本没法保证代码不会因为违背一些幽深的语言法则而在未来炸掉，即使现在代码看上去运作正常。&lt;/p&gt;&lt;p&gt;当然 C++ 中所有像 &lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/atomic/atomic/store&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;std::atomic&amp;lt;T&amp;gt;::store&lt;/a&gt;&lt;/code&gt; 这样的原子性修改方法只能用于可变引用。通过常量引用来储存值如同预料中那样不会通过编译。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// C++
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;atomic&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;cc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matching&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;~~~~^~~~~&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;5.4.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic_base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;367&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;note&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;viable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;known&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conversion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__atomic_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argument&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__int_type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;5.4.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic_base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;378&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;note&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;viable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;known&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conversion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__atomic_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argument&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__int_type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有什么地方出了问题。这超出了初学者对 Rust &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 引用类型意义的理解。&lt;/p&gt;&lt;h2&gt;更好的名字&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&amp;amp;T&lt;/code&gt; 不是对那些类型为 &lt;code&gt;T&lt;/code&gt; 的数据的 「不可变引用」或者「常量引用」，而是「共享引用」。&lt;code&gt;&amp;amp;mut T&lt;/code&gt; 不是「可变引用」而是「独占引用」。&lt;/p&gt;&lt;p&gt;独占引用意味着在同一时刻，同一个值不可能存在别的引用。共享引用则意味着&lt;i&gt;可能&lt;/i&gt;存在对同一个值的其它引用，也许是在别的线程（如果 &lt;code&gt;T&lt;/code&gt; 实现了 &lt;code&gt;Sync&lt;/code&gt; 的话）或是当前线程的调用栈中。Rust 借用检查器的一个关键职能就是确保独占引用真的是独占性的。&lt;/p&gt;&lt;p&gt;再看看 &lt;code&gt;AtomicU32::store&lt;/code&gt; 的签名。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AtomicU32&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;Ordering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于函数用共享引用获取原子式的 u32，此时应该&lt;b&gt;感到完全自然&lt;/b&gt;。同一时刻对同一个 &lt;code&gt;AtomicU32&lt;/code&gt; 有别的引用当然没问题。原子性就是为了并发读写而不导致数据争用（data race）而存在的。如果库在调用 &lt;code&gt;store&lt;/code&gt; 时不允许别的引用存在，那就没什么理由用原子性了。&lt;/p&gt;&lt;p&gt;独占引用一直是可变的原因是如果没有别的代码看着同一个数据，我们可以大胆地修改数据而不引发数据争用。数据争用（data race）是指多个地方同时操作同一个数据，并且至少有一个在修改，从而产生意外的结果或者内存不安全的情况。但是通过原子性或者下述内部可变性的方式，通过共享引用修改数据也是安全的。&lt;/p&gt;&lt;p&gt;充分内化「共享引用」和「独占引用」，学会这样思考，是学会充分利用 Rust 与其强大的安全性保证的重要一步。&lt;/p&gt;&lt;h2&gt;怎么教&lt;/h2&gt;&lt;p&gt;一开始将 &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 作为不可变和可变来介绍的做法，我不觉得不好。学习曲线已经足够难了，即使不算上本文的内容。对于初学者而言，修改能力的不同是两种引用类型最显著的实际差异。&lt;/p&gt;&lt;p&gt;我觉得建立从「不可变引用」/「可变引用」到「共享引用」/「独占引用」的心智模型转变是必要的一步。应该鼓励初学者在正确的时间走出这一步，而本页可以帮助他们走出这一步。当有人困惑于一些库函数预料需要 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 却只获取 &lt;code&gt;&amp;amp;&lt;/code&gt; 时，就是发本页链接的好时机了。&lt;/p&gt;&lt;p&gt;在内化了共享和独占引用之后，我觉得继续说「可变引用」也不错，毕竟关键字是 &lt;code&gt;mut&lt;/code&gt;。只要别忘了共享引用背后的数据有时也&lt;i&gt;可能&lt;/i&gt;是可变的。另一方面，对于共享引用，我建议始终说「共享引用」而不是「不可变引用」或者「常量引用」。&lt;/p&gt;&lt;h2&gt;附录：内部可变性&lt;/h2&gt;&lt;p&gt;在 Rust 中，术语「内部可变性」（interior mutability）表示支持通过共享引用修改数据。&lt;/p&gt;&lt;p&gt;我用 &lt;code&gt;AtomicU32&lt;/code&gt; 作为例子的缘故是当你从初学者的心智模型切换到正确的心智模型时，它最能唤起从「浑身难受」到「完全自然」的深刻转变。尽管原子性是多线程代码的重要一块，但内部可变性在单线程中也同样重要。&lt;/p&gt;&lt;p&gt;通过共享引用持有可变数据的&lt;i&gt;唯一&lt;/i&gt;方法是标准库类型 &lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/cell/struct.UnsafeCell.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt; 。它是一种 unsafe 的底层工具，一般不会直接去使用。所有别的内部可变性方式都是建立在它之上的安全抽象，有着不同的性质和需求，适用于不同的情况。（根本上来说，Rust 就是一个建立安全抽象的语言，而内部可变性就是其中一个最明显的部分。）&lt;/p&gt;&lt;p&gt;除了原子操作以外，其它建立在内部可变性上的标准库安全抽象还包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/cell/struct.Cell.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cell&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;： 修改是安全的，哪怕可能存在其它对同一个 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 的引用，因为API施行：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;多个线程不可能同时持有对同一个 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 的应用，因为 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 没有实现 &lt;code&gt;Sync&lt;/code&gt;trait，也就是说 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 是单线程的；&lt;/li&gt;&lt;li&gt;不可能获取对 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 中的内容的引用，因为这种引用可能因为修改而失效，作为替代所有的访问通过复制数据来完成。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/cell/struct.RefCell.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RefCell&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;：修改是安全的，哪怕可能存在其它对同一个 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 的引用，因为API施行：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;类似 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;，&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 是单线程的，所以不同的线程不可能引用同一个值。&lt;/li&gt;&lt;li&gt;在一个线程之内，当有读者持有内容的引用时，运行时的借用检查会阻止对内容的修改。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/sync/struct.Mutex.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;：修改是安全的，哪怕可能存在其它对同一个 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 的引用，因为API施行：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;同一时刻只有一个引用可以对内部的 &lt;code&gt;T&lt;/code&gt; 读写。其他访问会被阻塞到现在的引用释放了锁为止。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/std/sync/struct.RwLock.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RwLock&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;：修改是安全的，哪怕可能存在其它对同一个 &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; 的引用，因为 API 施行：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;同一时刻只有一个引用可以用来修改 &lt;code&gt;T&lt;/code&gt;，且仅当此时没有别的引用在被读。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>延迟炸裂火球</author>
<guid isPermaLink="false">2019-12-23-88926962</guid>
<pubDate>Mon, 23 Dec 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>零成本异步I/O</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2019-12-19-97574385.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/97574385&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt; 这是 Withoutboats 在 2019 年 3 月的 Rust Latam 上所做报告的一个翻译和整理。这个报告主要介绍他参与开发了一年半的语言特性，包括 Rust 异步 I/O 的发展历程，以及目前已经稳定的零成本抽象的&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; 语法的关键实现原理。&lt;br/&gt;&lt;br/&gt; Withoutboats 是就职于 Mozilla 的一名研究员，主要从事 Rust 语言开发。他开发的这个语言特性叫做 &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;，这可能是本年度我们在 Rust 语言上做的最重要的事。这解决了困扰我们很久的问题，即我们如何能在 Rust 中拥有零成本抽象的异步IO。&lt;br/&gt;&lt;br/&gt; 注：报告视频中的幻灯片比较模糊，我对其进行了重绘与翻译；因个人水平有限，翻译和整理难免有错误或疏漏之处，欢迎读者批评指正。&lt;br/&gt; &lt;/blockquote&gt;&lt;h2&gt;&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;首先，介绍一下 &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;async&lt;/code&gt; 是一个修饰符，它可以应用在函数上，这种函数不会在调用时一句句运行完成，而是立即返回一个 &lt;code&gt;Future&lt;/code&gt; 对象，这个 &lt;code&gt;Future&lt;/code&gt; 对象最终将给出这个函数的实际返回结果。而在一个这样的 &lt;code&gt;async&lt;/code&gt; 函数中，我们可以使用await运算符，将它用在其它会返回 &lt;code&gt;Future&lt;/code&gt; 的函数上，直到那些 &lt;code&gt;Future&lt;/code&gt; 返回实际结果。通过这种方法，异步并发开发更加方便了。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;withoutboats&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;select FROM users WHERE username = {}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db_response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是一段简短的代码样例，我们具体解释一下 &lt;code&gt;Future&lt;/code&gt; 。这段代码基本上做的就是一种类似于 ORM 框架所作的事。你有一个叫 &lt;code&gt;get_user&lt;/code&gt; 的函数，它接受一个字符串类型的用户名参数，并通过在数据库中查找对应用户的记录来返回一个User对象。它使用的是异步 I/O ，这意味着它得是一个异步函数，而不是普通函数，因此当你调用它时，你可以异步等待（&lt;code&gt;await&lt;/code&gt;）它；然后我们看一下函数的实现，首先是用用户名参数拼接出要执行的 SQL 语句，然后是查询数据库，这就是我们实际执行 I/O 的地方，所以这个查询（query）返回的是 &lt;code&gt;Future&lt;/code&gt; ，因为它使用的是异步 I/O 。所以在查询数据库时，你只需要使用异步等待（&lt;code&gt;await&lt;/code&gt;）来等待响应，在获得响应后就可以从中解析出用户。这个函数看起来像个玩具，但我想强调的是，它与使用阻塞式 I/O 的唯一区别就是这些注解（指&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;）了，你只需将函数标记为异步（&lt;code&gt;async&lt;/code&gt;），并在调用它们时加上 &lt;code&gt;await&lt;/code&gt; 就行了，开发的心智负担很小，以至于你会忘了自己是在写异步 I/O 而不是阻塞 I/O 。而 Rust 的这种实现让我尤其感到兴奋的是，它的 &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; 和 &lt;code&gt;Future&lt;/code&gt; 都是零成本抽象的。&lt;/p&gt;&lt;h2&gt;零成本抽象&lt;/h2&gt;&lt;p&gt;零成本抽象是 Rust 比较独特的一项准则，这是使 Rust 与其他许多语言相区别的原因之一。在添加新功能时，我们非常关心这些新功能是不是零成本的。不过这并不是我们想出来的点子，它在 C++ 中也很重要，所以我认为最好的解释是 Bjarne Stroustrup 的这句话：&lt;/p&gt;&lt;blockquote&gt; 零成本抽象意味着你不使用的东西，你不用为它付出任何代价，进一步讲，你使用的东西，你无法写出比这更好的代码。&lt;br/&gt; Zero Cost Abstractions: What you don&amp;#39;t use, you don&amp;#39;t pay for. And further: What you do use, you couldn&amp;#39;t hand code any better.&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;也就是说零成本抽象有两个方面：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;该功能不会给不使用该功能的用户增加成本，因此我们不能为了增加新的特性而增加那些会减慢所有程序运行的全局性开销。&lt;/li&gt;&lt;li&gt;当你确实要使用该功能时，它的速度不会比不使用它的速度慢。如果你觉得，我想使用这个非常好用的功能把开发工作变得轻松，但是它会使我的程序变慢，所以我打算自己造一个，那么这实际上是带来了更大的痛苦。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以，我将回顾一下我们如何尝试解决异步 I/O 和 Rust 的问题，以及在我们实现这一目标的过程中，某些未能通过这两项零成本测试的特性。&lt;/p&gt;&lt;h2&gt;绿色线程的尝试&lt;/h2&gt;&lt;p&gt;我们要解决的问题是 &lt;b&gt;异步 I/O&lt;/b&gt; 。通常 I/O 处于阻塞状态，因此当你使用 I/O 时，它会阻塞线程，中止你的程序，然后必须通过操作系统重新调度。阻塞式 I/O 的问题是当你尝试通过同一程序提供大量连接时，它无法真正实现扩展。因此对于真正的大规模网络服务，你需要某种形式的非阻塞的或者说异步的 I/O 。尤其是 Rust 是针对具有真正的高性能要求而设计的语言，它是一种系统编程语言，面向那些真正在乎计算资源的人。要在网络的世界中真正取得成功，我们就需要某种解决方案来解决这个异步 I/O 问题。&lt;/p&gt;&lt;p&gt;但是 &lt;b&gt;异步 I/O 的最大问题是它的工作方式&lt;/b&gt; ：在你调用 I/O 时，系统调用会立即返回，然后你可以继续进行其他工作，但你的程序需要决定如何回到调用该异步 I/O 暂停的那个任务线上，这就使得在编码上，异步 I/O 的代码要比阻塞 I/O 的代码复杂得多。所以，很多，尤其是以可扩展的网络服务这类特性为目标的语言，一直在试图解决这个问题。比如，让它不再是最终用户需要解决的问题，而是编程语言的一部分或者某个库的一部分等等。&lt;/p&gt;&lt;p&gt;Rust 最初使用的第一个解决方案是 &lt;b&gt;绿色线程&lt;/b&gt;，它已经在许多语言中获得成功。绿色线程基本上就像阻塞式 I/O 一样，使用的时候就像是普通的线程，它们会在执行 I/O 时阻塞，一切看起来就跟你在使用操作系统的原生方式一样。但是，它们被设计为语言运行时的一部分，来对那些需要同时运行成千上万甚至数百万个绿色线程的网络服务用例进行优化。一个使用该模型的典型的成功案例就是 Go 语言，它的绿色线程被称为 goroutine。对于 Go 程序来说，同时运行成千上万个 goroutine 是很正常的，因为与操作系统线程不同，创建它们的成本很低。&lt;/p&gt;&lt;p&gt;即 &lt;b&gt;绿色线程的优点&lt;/b&gt; 在于：产生操作系统线程时的内存开销要高得多，因为每个操作系统线程会创建一个很大的堆栈，而绿色线程通常的工作方式是，你将产生一个以很小的堆栈，它只会随着时间的推移而增长，而产生一堆不使用大量内存的新线程并不便宜；并且使用类似操作系统原语的问题还在于你依赖于操作系统调度，这意味着你必须从程序的内存空间切换到内核空间，如果成千上万的线程都在快速切换，上下文切换就会增加很多开销。而将调度保持在同一程序中，你将避免使用这些上下文，进而减少开销。所以我相信绿色线程是一个非常好的模型，适用于许多语言，包括 Go 和 Java。&lt;/p&gt;&lt;p&gt;在很长一段时间内， Rust 都有绿色线程，但是在 1.0 版本之前删掉了。我们删掉它是因为它不是零成本抽象的，准确的说就是我在第一个问题中谈到的，它给那些不需要它的人增加了成本。比如你只想编写一个不是网络服务的屏幕打印的 Rust 程序，你必须引入负责调度所有绿色线程的语言运行时。这种方法，尤其是对于试图把 Rust 集成到一个大的 C 应用程序中的人来说，就成为一个问题。很多 Rust 的采用者拥有一些大型C程序，他们想开始使用 Rust 并将 Rust 集成到他们的程序中，只是一小段 Rust 代码。问题是，如果你必须设置运行时才能调用 Rust ，那么这一小部分的 Rust 程序的成本就太高了。因此从 1.0 开始，我们就从语言中删除了绿色线程，并删除了语言的运行时。现在我们都知道它的运行时与 C 基本上相同，这就使得在 Rust 和 C 之间调用非常容易，而且成本很低，这是使 Rust 真正成功的关键因素之一。删除了绿色线程，我们还是需要某种异步 I/O 解决方案；但是我们意识到 &lt;b&gt;这应该是一个基于库的解决方案，我们需要为异步 I/O 提供良好的抽象，它不是语言的一部分，也不是每个程序附带的运行时的一部分，只是可选的并按需使用的库。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;Future 的解决方案&lt;/h2&gt;&lt;p&gt;最成功的库解决方案是一个叫做 &lt;code&gt;Future&lt;/code&gt; 的概念，在 JavaScript 中也叫做 &lt;code&gt;Promise&lt;/code&gt;。&lt;code&gt;Future&lt;/code&gt; 表示一个尚未得出的值，你可以在它被解决（resolved）以得出那个值之前对它进行各种操作。在许多语言中，对 &lt;code&gt;Future&lt;/code&gt; 所做的工作并不多，这种实现支持很多特性比如组合器（Combinator），尤其是能让我们在此基础上实现更符合人体工程学的 &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; 语法。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 可以表示各种各样的东西，尤其适用于表示异步 I/O ：当你发起一次网络请求时，你将立即获得一个 &lt;code&gt;Future&lt;/code&gt; 对象，而一旦网络请求完成，它将返回任何响应可能包含的值；你也可以表示诸如“超时”之类的东西，“超时”其实就是一个在过了特定时间后被解决的 &lt;code&gt;Future&lt;/code&gt; ；甚至不属于 I/O 的工作或者需要放到某个线程池中运行的CPU密集型的工作，也可以通过一个 &lt;code&gt;Future&lt;/code&gt; 来表示，这个 &lt;code&gt;Future&lt;/code&gt; 将会在线程池完成工作后被解决。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;FnOnce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;&lt;code&gt;Future&lt;/code&gt; 存在的问题&lt;/b&gt; 是它在大多数语言中的表示方式是这种基于回调的方法，使用这种方式时，你可以指定在 &lt;code&gt;Future&lt;/code&gt; 被解决之后运行什么回调函数。也就是说， &lt;code&gt;Future&lt;/code&gt; 负责弄清楚什么时候被解决，无论你的回调是什么，它都会运行；而所有的不便也都建立在此模型上，它非常难用，因为已经有很多开发者进行了大量的尝试，发现他们不得不写很多分配性的代码以及使用动态派发；实际上，你尝试调度的每个回调都必须获得自己独立的存储空间，例如 crate 对象、堆内存分配，这些分配以及动态派发无处不在。这种方法没有满足零成本抽象的第二个原则，如果你要使用它，它将比你自己写要慢很多，那你为什么还要用它。&lt;/p&gt;&lt;h2&gt;基于轮询的 Future &lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waker&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个非常出色的基于轮询的新方案——我们编写了这个模型，我归功于 Alex 和 Aaron Turon，是他们提出了这个想法——不是由 &lt;code&gt;Future&lt;/code&gt; 来调度回调函数，而是由我们去轮询 &lt;code&gt;Future&lt;/code&gt;，所以还有另一个被称为执行器（executor）的组件，它负责实际运行 &lt;code&gt;Future&lt;/code&gt; ；执行器的工作就是轮询 &lt;code&gt;Future&lt;/code&gt; ，而 &lt;code&gt;Future&lt;/code&gt; 可能返回“尚未准备就绪（Pending）”，也可能被解决就返回“已就绪（Ready）”。&lt;/p&gt;&lt;p&gt;该模型有很多优点。其中一个优点是，你可以非常容易地取消 &lt;code&gt;Future&lt;/code&gt; ，因为取消 &lt;code&gt;Future&lt;/code&gt; 只需要停止持有 &lt;code&gt;Future&lt;/code&gt;。而如果采用基于回调的方法，要通过调度来取消并使其停止就没这么容易了。&lt;/p&gt;&lt;p&gt;同时它还能够使我们在程序的不同部分之间建立真正清晰的抽象边界，大多数 &lt;code&gt;Future&lt;/code&gt; 库都带有事件循环（event loop），这也是调度你的 &lt;code&gt;Future&lt;/code&gt; 执行 I/O 的方法，但你实际上对此没有任何控制权。而在 Rust 中，各组件之间的边界非常整洁，执行器（executor）负责调度你的 &lt;code&gt;Future&lt;/code&gt; ，反应器（reactor）处理所有的 I/O ，然后是你的实际代码。因此最终用户可以自行决定使用什么执行器，使用他们想使用的反应器，从而获得更强的控制力，这在系统编程语言中真的很重要。而此模型最重要的真正优势在于，它使我们能够以一种真正零成本的完美方式实现这种状态机式的 &lt;code&gt;Future&lt;/code&gt; 。也就是当你编写的 &lt;code&gt;Future&lt;/code&gt; 代码被编译成实际的本地（native）代码时，它就像一个状态机；在该状态机中，每次 I/O 的暂停点都有一个变体（variant），而每个变体都保存了恢复执行所需的状态。这表示为一个枚举（enum）结构，即一个包含变体判别式及所有可能状态的联合体（union）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2db492125cda72829cbefdde5c25e216_b.jpg&quot; data-rawwidth=&quot;890&quot; data-rawheight=&quot;658&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;890&quot; data-original=&quot;https://pic3.zhimg.com/v2-2db492125cda72829cbefdde5c25e216_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2db492125cda72829cbefdde5c25e216_b.jpg&quot; data-rawwidth=&quot;890&quot; data-rawheight=&quot;658&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;890&quot; data-original=&quot;https://pic3.zhimg.com/v2-2db492125cda72829cbefdde5c25e216_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2db492125cda72829cbefdde5c25e216_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;上面的幻灯片尽可能直观地表示了这个状态机模型。可以看到，你执行了两个 I/O 事件，所以它有这几个状态。对于每个状态它都提供了所需的内存空间，足够你在 I/O 事件后恢复执行。&lt;/p&gt;&lt;p&gt;整个 &lt;code&gt;Future&lt;/code&gt; 只需要一次堆内存分配，其大小就是你将这个状态机分配到堆中的大小，并且没有额外的开销。你不需要装箱、回调之类的东西，只有真正零成本的完美模型。这些概念对于很多人来说比较难于理解，所以这是我力求做到最好的幻灯片，直观地呈现这个过程中发生了什么：你创建一个 &lt;code&gt;Future&lt;/code&gt;，它被分配到某个内存中特定的位置，然后你可以在执行器（executor）中启动它。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b4ec7067068f316149df482749baed99_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic2.zhimg.com/v2-b4ec7067068f316149df482749baed99_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b4ec7067068f316149df482749baed99_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic2.zhimg.com/v2-b4ec7067068f316149df482749baed99_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b4ec7067068f316149df482749baed99_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;执行器会轮询 &lt;code&gt;Future&lt;/code&gt;，直到最终 &lt;code&gt;Future&lt;/code&gt; 需要执行某种 I/O 。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9e6dd5a637c296fd2b78eb4e67bb0866_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-9e6dd5a637c296fd2b78eb4e67bb0866_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9e6dd5a637c296fd2b78eb4e67bb0866_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-9e6dd5a637c296fd2b78eb4e67bb0866_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9e6dd5a637c296fd2b78eb4e67bb0866_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在这种情况下，该 &lt;code&gt;Future&lt;/code&gt; 将被移交给处理 I/O 的反应器，即 &lt;code&gt;Future&lt;/code&gt; 会等待该特定 I/O 。最终，在该 I/O 事件发生时，反应器将使用你在轮询它时传递的Waker 参数唤醒 &lt;code&gt;Future&lt;/code&gt; ，将其传回执行器；&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a60db9a1fc1ffdff80b915803c4bb9a_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a60db9a1fc1ffdff80b915803c4bb9a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a60db9a1fc1ffdff80b915803c4bb9a_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a60db9a1fc1ffdff80b915803c4bb9a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4a60db9a1fc1ffdff80b915803c4bb9a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;然后当需要再次执行I/O时，执行器再将其放回反应器；它将像这样来回穿梭，直到最终被解决（resolved）。在被解决并得出最终结果时，执行器知道它已经完成，就会释放句柄和整个&lt;code&gt;Future&lt;/code&gt;，整个调用过程就完成了。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2d1bdb39189796d63f286fe40965ab8_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;784&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic1.zhimg.com/v2-a2d1bdb39189796d63f286fe40965ab8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2d1bdb39189796d63f286fe40965ab8_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;784&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic1.zhimg.com/v2-a2d1bdb39189796d63f286fe40965ab8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a2d1bdb39189796d63f286fe40965ab8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;总结一下：这种模型形成了一种循环，我们轮询 &lt;code&gt;Future&lt;/code&gt; ，然后等待 I/O 将其唤醒，然后一次又一次地轮询和唤醒，直到最终整个过程完成为止。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1b3a43e1d072bd76825a9946bd89f042_b.jpg&quot; data-rawwidth=&quot;824&quot; data-rawheight=&quot;561&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;824&quot; data-original=&quot;https://pic3.zhimg.com/v2-1b3a43e1d072bd76825a9946bd89f042_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1b3a43e1d072bd76825a9946bd89f042_b.jpg&quot; data-rawwidth=&quot;824&quot; data-rawheight=&quot;561&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;824&quot; data-original=&quot;https://pic3.zhimg.com/v2-1b3a43e1d072bd76825a9946bd89f042_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1b3a43e1d072bd76825a9946bd89f042_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;并且这种模型相当高效。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-72e011276307d3c04b9611565530db4a_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;559&quot; data-size=&quot;normal&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-72e011276307d3c04b9611565530db4a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-72e011276307d3c04b9611565530db4a_b.jpg&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;559&quot; data-size=&quot;normal&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-72e011276307d3c04b9611565530db4a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-72e011276307d3c04b9611565530db4a_b.jpg&quot;/&gt;&lt;figcaption&gt;有关 Future 的第一篇文章中发布的基准测试&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这是在有关 &lt;code&gt;Future&lt;/code&gt; 的第一篇文章中发布的基准测试，与其他语言的许多不同实现进行了对比。柱形越高表示性能越好，我们的 &lt;code&gt;Future&lt;/code&gt; 模型在最左侧，所以说我们有了非常出色的零成本抽象，即使是与许多其他语言中最快的异步 I/O 实现相比也是相当有竞争力的。&lt;/p&gt;&lt;p&gt;但是，问题在于，你并不希望手动编写这些状态机，把整个应用程序所有状态写成一个状态机并不是件轻松愉快的事。而这种 &lt;code&gt;Future&lt;/code&gt; 抽象的真正有用之处在于，我们可以在其之上构建其他 API 。&lt;/p&gt;&lt;h2&gt;其它API&lt;/h2&gt;&lt;h3&gt;组合器（Combinator）&lt;/h3&gt;&lt;p&gt;我们能使用的第一个解决方案是 &lt;code&gt;Future&lt;/code&gt; 组合器（Combinator）。你可以通过将这些组合器方法应用于 &lt;code&gt;Future&lt;/code&gt; 来构建状态机，它们的工作方式类似于迭代器（&lt;code&gt;Iterator&lt;/code&gt;）的适配器（如 &lt;code&gt;filter&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch_rust_lang&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;rust-lang.org&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;and_then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;concat_body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;from_utf8_lossy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个函数的作用是请求 “rust-lang.org”，然后将响应转换为字符串。它并不返回一个字符串，而是返回一个字符串的 &lt;code&gt;Future&lt;/code&gt; ，因为它是一个异步函数。函数体中有这样一个 &lt;code&gt;Future&lt;/code&gt;，它包含一些会被调用的 I/O 操作，用 &lt;code&gt;and_then&lt;/code&gt; 和 &lt;code&gt;map&lt;/code&gt; 之类的组合器将这些操作全部组合在一起。我们构建了所有这些用处各异的组合器，例如，&lt;code&gt;and_then&lt;/code&gt;，&lt;code&gt;map&lt;/code&gt;，&lt;code&gt;filter&lt;/code&gt;，&lt;code&gt;map_error&lt;/code&gt;等等。我们已经知道这种方式是有一些缺点的，尤其是诸如嵌套回调之类，可读性非常差。&lt;/p&gt;&lt;h3&gt;&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 的实现&lt;/h3&gt;&lt;p&gt;因为组合器有这样的缺点，所以我们开始尝试实现 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;。&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 的第一个版本并不是 Rust 语言的一部分，而是由该库像语法插件一样提供的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#[async]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch_rust_lang&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;rust-lang.org&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;concat_body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;from_utf9_lossy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个函数与之前那个版本的一样，它只是获取 Rust 官网并将其转换为字符串；但是它使用 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 来实现，所以更像是顺序执行，看起来更像普通的阻塞 I/O 的工作方式；就像开头那个实例中呈现的一样，它们唯一区别是注解（指 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;）。我们已经知道，&lt;code&gt;async&lt;/code&gt; 注解会将此函数转换为一个返回 &lt;code&gt;Future&lt;/code&gt; 的函数，而不是立即返回结果，并且我们需要异步等待（&lt;code&gt;await&lt;/code&gt;）这些在函数内部构造的 &lt;code&gt;Future&lt;/code&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;$future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;$future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我们的轮询模型中，&lt;code&gt;await&lt;/code&gt; 是一种语法糖；它会进入上面这种循环，你要做的就是在循环中轮询，在一段时间内你将一直得到“尚未准备就绪（Pending）”，然后一直等到它再次被唤醒，终于你等待的 &lt;code&gt;Future&lt;/code&gt; 完成了，然后你使用该值跳出了循环，这就是这些 &lt;code&gt;await&lt;/code&gt; 表达式的计算结果。&lt;/p&gt;&lt;p&gt;这似乎是一个非常不错的解决方案，&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 的写法会被编译成我们超棒的零成本的 &lt;code&gt;Future&lt;/code&gt;。不过从已发布的 &lt;code&gt;Future&lt;/code&gt; 的使用者的反馈看，我们还是发现了一些问题。&lt;/p&gt;&lt;h3&gt;新的问题&lt;/h3&gt;&lt;p&gt;基本上所有试图使用 &lt;code&gt;Future&lt;/code&gt; 的人都会遇到非常令人困惑的错误消息。在这些消息中，编译器会提示你的&lt;code&gt;Future&lt;/code&gt;的生命周期不是静态的（&lt;code&gt;&amp;#39;static&lt;/code&gt;）或没有实现某个 &lt;code&gt;trait&lt;/code&gt; 等等；这些提示你并不真正理解，但编译器想提出有用的建议，你也就跟着这个建议去做，直到编译成功；你可能会给闭包加上 &lt;code&gt;move&lt;/code&gt; 关键字，或者把某些值放到引用计数的指针（&lt;code&gt;Rc&lt;/code&gt;）中，然后复制（&lt;code&gt;clone&lt;/code&gt;）它；你将所有这些开销添加到了似乎并不必要的事情上，却不明白为什么要这样做，而当你已经疲于处理这些时，代码已经乱成一锅粥了，所以很多人都被 &lt;code&gt;Future&lt;/code&gt; 的问题卡住了。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b1fa5d83cda8788404bb2dc3fd1c927a_b.jpg&quot; data-rawwidth=&quot;780&quot; data-rawheight=&quot;384&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;780&quot; data-original=&quot;https://pic3.zhimg.com/v2-b1fa5d83cda8788404bb2dc3fd1c927a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b1fa5d83cda8788404bb2dc3fd1c927a_b.jpg&quot; data-rawwidth=&quot;780&quot; data-rawheight=&quot;384&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;780&quot; data-original=&quot;https://pic3.zhimg.com/v2-b1fa5d83cda8788404bb2dc3fd1c927a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b1fa5d83cda8788404bb2dc3fd1c927a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;而且它对于组合器产生这种非常大的类型也没什么办法，你的整个终端窗口（terminal）将被其中一个组合器链的类型填满。你用了&lt;code&gt;and_then&lt;/code&gt;，以及又一个 &lt;code&gt;and_then&lt;/code&gt;，然后是 &lt;code&gt;map_err&lt;/code&gt; 紧跟一个 TCP 流等等等等，你必须仔细研究一下，才能弄清楚所遇到的实际错误是什么。&lt;/p&gt;&lt;blockquote&gt; “When using Futures, error messages are inscrutable.” “当使用 Future 时，错误信息难以理解。” “Having to use RefCell or clone everything for each future leads to overcomplicated code that makes me wish Rust had garbage collection.” “不得不使用 RefCell 以及为每个 future 克隆所有它需要的值产生了过于复杂的代码，这让我开始期待 Rust 能具备垃圾回收功能了。”&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;我在 reddit 上发现了这条消息，我认为它确实很好地总结了所有有关 &lt;code&gt;Future&lt;/code&gt; 的抱怨。使用 &lt;code&gt;Future&lt;/code&gt; 时，错误消息难以理解；不得不使用 RefCell 以及为每个 future 克隆所有它需要的值产生了过于复杂的代码，这让我开始期待 Rust 能具备垃圾回收功能了（观众笑）。是的，这不是什么好反馈。&lt;/p&gt;&lt;p&gt;因此，从大约一年半前的情况来看，很明显，有两个问题需要解决，才能让大家更容易使用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;首先&lt;/b&gt;，我们需要更好的错误消息，最简单的方法就是将语法构建到语言中，然后它们就可以在你所有的诊断和错误处理代码中加入钩子，从而使你能够真正拥有良好的 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 的错误消息。&lt;b&gt;其次&lt;/b&gt;，人们遇到的大多数错误实际上是因为他们被一个晦涩难解的问题卡住了——借用问题。正是因为 &lt;code&gt;Future&lt;/code&gt; 的设计方式存在着这种根本的局限性，导致一些很普通的编程范式都无法表达。所谓借用问题，就是在最初的 &lt;code&gt;Future&lt;/code&gt; 的设计中你不能跨过&lt;b&gt;异步等待点&lt;/b&gt;（await point）进行借用，也就是说，如果你要异步等待（await）某件事，你就不能在那个时候持有任何存活的引用。当人们遇到了这种问题，他们通常会被卡住，最终他们会尝试在 &lt;code&gt;await&lt;/code&gt; 的时候进行借用然后发现实际上做不到。所以如果我们能够使这种借用被允许，那么大多数这些错误将消失，一切都将变得更易于使用，你可以使用 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 编写普通的 Rust 代码，并且一切都会正常进行。&lt;/p&gt;&lt;p&gt;这种跨越 &lt;code&gt;await&lt;/code&gt; 的借用是非常普遍的，因为 Rust 的 API 天然就具有引用。当你实际编译 &lt;code&gt;Future&lt;/code&gt; 时，它必须能够恢复所有状态，而当你拥有某些其它东西的引用时，它们位于同一栈帧中，最终你会得到一个&lt;b&gt;自引用&lt;/b&gt;的 &lt;code&gt;Future&lt;/code&gt; 结构（Self-Referential Future）。这是开头的那个 &lt;code&gt;get_user&lt;/code&gt; 方法，我们有这样一个 SQL 字符串，而在使用 SQL 字符串调用 &lt;code&gt;query&lt;/code&gt; 方法时，我们传递的是 SQL 字符串的引用。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;SELECT FROM users WHERE username = {}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db_response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里存在的问题是，对 SQL 字符串的引用是对存储在相同 &lt;code&gt;Future&lt;/code&gt; 状态中的其他内容的引用，因此它成为一种自引用结构。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9fbfa65f3218487b457b4ff272f68c96_b.jpg&quot; data-rawwidth=&quot;604&quot; data-rawheight=&quot;440&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;604&quot; data-original=&quot;https://pic3.zhimg.com/v2-9fbfa65f3218487b457b4ff272f68c96_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9fbfa65f3218487b457b4ff272f68c96_b.jpg&quot; data-rawwidth=&quot;604&quot; data-rawheight=&quot;440&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;604&quot; data-original=&quot;https://pic3.zhimg.com/v2-9fbfa65f3218487b457b4ff272f68c96_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9fbfa65f3218487b457b4ff272f68c96_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果把这个 &lt;code&gt;Future&lt;/code&gt; 视作一个真的结构体的话，这就是理论上它所拥有的字段。除了代表数据库句柄的 &lt;code&gt;self&lt;/code&gt; 之外，还有 SQL 字符串以及对这个 SQL 字符串的引用，即一个最终指回同一结构体中某个字段的引用。&lt;/p&gt;&lt;p&gt;一些新的潜在结构会成为非常棘手的问题，因为我们没有通用的解决方案。当你移动该结构时，我们不允许你使用自引用，是因为我们会在新位置创建一个原有结构的新副本，旧副本会变为无效，但是在复制时，新副本的引用仍指向旧副本的字段，该指针就变成了悬空指针（dangling pointer），而这正是 Rust 必须避免的内存问题。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5601cb4bf7ae8092550226cc27fe5a1_b.jpg&quot; data-rawwidth=&quot;944&quot; data-rawheight=&quot;480&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;944&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5601cb4bf7ae8092550226cc27fe5a1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5601cb4bf7ae8092550226cc27fe5a1_b.jpg&quot; data-rawwidth=&quot;944&quot; data-rawheight=&quot;480&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;944&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5601cb4bf7ae8092550226cc27fe5a1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a5601cb4bf7ae8092550226cc27fe5a1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;所以我们不能使用自引用结构，因为如果你移动它们，那么它们将失效。然而，我们实际上并不需要真正移动这些 &lt;code&gt;Future&lt;/code&gt; 。如果你还记得在堆中通过句柄使用 &lt;code&gt;Future&lt;/code&gt; 的模型，它在反应器和执行器之间来回传递，所以 &lt;code&gt;Future&lt;/code&gt; 本身永远不会真正移动；而只要你保证不移动，&lt;code&gt;Future&lt;/code&gt; 包含自引用就完全没问题。&lt;/p&gt;&lt;p&gt;所以我们需要通过采用某种方式在 &lt;code&gt;Future&lt;/code&gt; 的 API 中表达 “在你轮询时，你不允许随意移动它” 来解决这个问题。如果我们能够表达这一点，我们就可以允许 &lt;code&gt;Future&lt;/code&gt; 中出现自引用，进而就可以在异步函数中真正使用这些引用，并且一切都会正常工作。因此我们研究了这个问题，最终开发出了被称为 &lt;code&gt;Pin&lt;/code&gt; 的新 API 。&lt;/p&gt;&lt;h3&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Pin&lt;/code&gt; 是一种围绕其他指针类型的适配器，可以将其它指针变为 &lt;b&gt;固定引用&lt;/b&gt;（pinned reference）。除了原有指针的保证外，它还保证这个引用再也不会被移动，所以我们可以确保它将一直处在同一内存位置，直到最终被释放。如果你的 API 中有一些内容已表明必须使用 &lt;code&gt;Pin&lt;/code&gt;，那么你就知道了它再也不会被移动，这样就你可以使用那种自引用的结构体了。因此，我们修改了 &lt;code&gt;Future&lt;/code&gt; 的工作方式，现在它变成了一个经过装箱（boxed）的 &lt;code&gt;Future&lt;/code&gt; ，实际上是一个由 &lt;code&gt;Pin&lt;/code&gt; 封装的 &lt;code&gt;Box&amp;lt;Future&amp;gt;&lt;/code&gt; ；这样无论在哪里装箱，我们把它放在堆内存中，它可以保证永远不会再移动；而当你轮询 &lt;code&gt;Future&lt;/code&gt; 时，不再使用一个普通引用，而是使用一个固定引用，这样 &lt;code&gt;Future&lt;/code&gt; 就知道它不会被移动。而使这一切起作用的诀窍是，要从固定引用中获取非固定引用，你只能使用不安全的代码。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boxed&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;as_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_unchecked_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以 Pin API 大致就像这样。在这里你有一个 &lt;code&gt;Pin&lt;/code&gt; 结构，它只是另一个指针类型的封装，它没有任何运行时开销或者其它东西，仅仅是将其划分为一个固定的（pinned）对象，然后一个固定的 &lt;code&gt;Box&lt;/code&gt; 指针可以转换为一个固定引用，但是将一个固定引用转换为一个非固定引用的唯一方法是使用一个不安全的（unsafe）函数。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waker&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样一来，我们要做的就是修改 &lt;code&gt;Future&lt;/code&gt; 的 API ，其轮询方法将不再接受一个普通引用，而是接受一个固定引用，而这其实就是我们将要稳定发布的 &lt;code&gt;Future&lt;/code&gt; API。而做了这个修改之后，第一个示例的写法就能正常工作了。这样你就可以像写阻塞 I/O 的代码那样编写异步 I/O 的代码了，只需要加上 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 注解，你就能得到这个出色的零成本抽象的异步实现，而即便你自己手写，这基本上也是你能写出的开销最低的实现了。&lt;/p&gt;&lt;h2&gt;&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 的现状及未来&lt;/h2&gt;&lt;p&gt;目前的情况是，Pinning 大约在一个月前的最新版本中稳定了，我们正在稳定 &lt;code&gt;Future&lt;/code&gt; 的 API ，因此大概会在 1.35，也可能会推到 1.36 稳定，基本上在两三个月内就会知道了。并且我们希望今年的某个时候我们能够拥有 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;，希望今年夏末能将其稳定下来，这样人们就可以使用这种类似阻塞 I/O 的语法编写无阻塞的 I/O 网络服务了。除了这些稳定化工作，我们也已经开始研究某些更长期的功能，比如流（Stream），我认为它可能是异步的下一个大功能。我们知道一个 &lt;code&gt;Future&lt;/code&gt; 只产生一个值，而一个流可以异步地产生很多值；异步地产生值本质上就像是一个异步迭代器，你能够在一个流上进行异步的循环；这个功能对于许多用例来说非常重要，比如流式传输HTTP、WebSocket 推送请求之类的东西，不用像我们的 RPC 模型那样发出网络请求然后获得单个响应，而是能够使用请求流和响应流，在两者之间来回调用。&lt;/p&gt;&lt;p&gt;目前使用异步仍然存在一个限制，即不能在 &lt;code&gt;trait&lt;/code&gt; 中使用 &lt;code&gt;async&lt;/code&gt;。有许多编译器开发工作正在进行，使其能够支持这个特性。除了这些功能，有时候我们也希望能拥有生成器（Generator），类似于 Python 或 JavaScript 的生成器，除了拥有可以 &lt;code&gt;return&lt;/code&gt; 的函数，还能使用可以 &lt;code&gt;yield&lt;/code&gt; 的函数，这样你就可以在 &lt;code&gt;yield&lt;/code&gt; 之后再次恢复执行；并且你可以将这些函数作为编写迭代器和流的方式，就像异步函数能够让你像编写普通函数那样编写 &lt;code&gt;Future&lt;/code&gt; 一样。&lt;/p&gt;&lt;p&gt;最后，我想回顾一下成就这种零成本异步 I/O 的关键点：首先就是这种基于轮询的 &lt;code&gt;Future&lt;/code&gt;，它将这些 &lt;code&gt;Future&lt;/code&gt; 编译到这种相当紧凑的状态机中；其次是这种实现 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 语法的方式，即因为有了 &lt;code&gt;Pin&lt;/code&gt;，我们能够跨越异步等待点使用引用。&lt;/p&gt;&lt;p&gt;谢谢大家。&lt;/p&gt;&lt;blockquote&gt; 译者注：报告中计划稳定的特性均已稳定发布，参见 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//areweasyncyet.rs/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;areweasyncyet.rs&lt;/a&gt;。 按照目前稳定的版本，&lt;code&gt;await&lt;/code&gt; 已改为后置运算符 &lt;code&gt;.await&lt;/code&gt;，所以本文开头的 &lt;code&gt;get_user&lt;/code&gt; 方法应当修改为：&lt;br/&gt; &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;withoutboats&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;select FROM users WHERE username = {}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db_response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
<author>不明觉疼</author>
<guid isPermaLink="false">2019-12-19-97574385</guid>
<pubDate>Thu, 19 Dec 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>使用Rust实现Tcp加速</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2019-12-18-97200083.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/97200083&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目地址 [gkd-rs](&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/importcjj/gkd-rs&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/importcjj/gk&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;d-rs&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;为了让自己的代理更加稳定，试着用Rust去做了个Tcp加速库。效果的话，我目前还在试用，另外库还没有完善，就先不上对比图了。&lt;/p&gt;&lt;h2&gt;原理及概念&lt;/h2&gt;&lt;p&gt;简单来说，就是原来通过一条Tcp连接收发的数据包现在借助N条Tcp来进行收发，达到提速的效果。&lt;/p&gt;&lt;h3&gt;Connection&lt;/h3&gt;&lt;p&gt;这里及下文中所提到的Connection并未一般意义上的TCP连接，在我们的项目里，它是一个抽象出来的东西。Connection在客户端和服务端的行为具有差异。客户端的Connection借助多个Tunnel进行通信，这些Connection在处理上游请求时，会先把从上游读取的data封装成带有自增ID和Connection ID的packet，然后通过channel发送给Tunnel Manager，于此同时，我们预先建立的N条Tunnel会通过poll channel的方式获取这些packet，并通过自己的TCP连接发送给服务端。服务端的Tunnel Manager收到这些packet后，会根据每个packet的Connection ID分发给对应的存在于服务端的Connection，而每个Connection会重新这些调整packet的顺序。&lt;/p&gt;&lt;h3&gt;Client&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;客户端会有自己的Peer ID&lt;/li&gt;&lt;li&gt;客户端启动时会与服务端建立起N条Tunnel, 即真实的TCP连接。&lt;/li&gt;&lt;li&gt;处理上游的请求时，新建Connection，并发送一个不带任何数据的connect packet。接着就是边读取上游data，边封packet交由Tunnel Manager发送给服务端。需要注意的是，服务端返回的数据packet是乱序的，客户端Connection在接收server端的发来的packet时，应调整顺序，这样上游方收到的数据才是正确的。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;Server&lt;/h3&gt;&lt;p&gt;注: 服务端应该支持服务多个Peer，Peer通过ID区分，彼此之间隔离，互不影响&lt;/p&gt;&lt;p&gt;以下过程仅针对一个Peer来讲&lt;/p&gt;&lt;p&gt;Tunnel Manager从N个Tunnel的recv channel中读取packet，并根据packet携带的connection ID找到对应的Connection(如不存在则新建)，然后将packet交由该Connection处理。服务端的Connection处理packet时，若该packet为connect类型，则读取包中含有的dest server地址并与其建立TCP连接。Connection从Tunnel Manager得到的packet很大概率是乱序的，所以需要借助内部缓存来调整顺序，从而保证发送给dest server的数据是正常的原始数据。相对的，Connection在写数据时，直接将数据封成packet，然后直接交由Tunnel Manager发送给相应的客户端。&lt;/p&gt;&lt;h2&gt;Usage&lt;/h2&gt;&lt;p&gt;echo server&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async_std&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async_std&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gkd&lt;/span&gt;::&lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gkd&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#[async_std::main]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env_logger&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;Listening on :9990&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;0.0.0.0:9990&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;serve {}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;spawn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(())&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;client&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async_std&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;prelude&lt;/span&gt;::&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gkd&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gkd&lt;/span&gt;::&lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#[async_std::main]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nb&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env_logger&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tunnel_num&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;127.0.0.1:9990&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tunnel_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_i&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_exact&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;read [{:?}]&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(())&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>importcjj</author>
<guid isPermaLink="false">2019-12-18-97200083</guid>
<pubDate>Wed, 18 Dec 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>手把手教你用Rust写Proxy，开坑篇</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2019-12-18-90459884.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90459884&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7fa14b9260bcffa27fa35165f6610eab_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;项目地址 [rust-miniproxy](&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/importcjj/rust-miniproxy&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/importcjj/ru&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;st-miniproxy&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;&gt;&lt;/span&gt;&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;使用Rust 1.39.0实现的简易代理，同时支持HTTP，HTTPS和SOCKS5协议。本项目仅用于学习交流。&lt;/p&gt;&lt;h2&gt;如何编译&lt;/h2&gt;&lt;p&gt;首先安装Rust，如何安装请移步&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.rust-lang.org/learn/get-started&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;官网&lt;/a&gt; 注意由于需要使用async/await，所以需要指定rust版本为1.39(stable)&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;cargo build --release&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认开启TCP加速，使用&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/importcjj/gkd-rs&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;gkd-rs&lt;/a&gt;提供加速功能。 可在编译时使用--no-default-features关闭加速功能。&lt;/p&gt;&lt;p&gt;二进制文件会在项目目录的target/release文件夹下，找到两个名为&lt;code&gt;minilocal&lt;/code&gt;和&lt;code&gt;miniserver&lt;/code&gt;的二进制文件即可。关于如何交叉编译，请自行搜索。不过我自己在macbook上交叉编译就没成功过。&lt;/p&gt;&lt;h2&gt;如何使用&lt;/h2&gt;&lt;p&gt;本代理分为两部分：&lt;code&gt;minilocal&lt;/code&gt;和&lt;code&gt;miniserver&lt;/code&gt;。&lt;code&gt;miniserver&lt;/code&gt;运行于网络服务器上，&lt;code&gt;minilocal&lt;/code&gt;运行于本地。&lt;/p&gt;&lt;p&gt;a. 先在服务器上部署&lt;code&gt;miniserver&lt;/code&gt;，启动的时候会随机产生一个base64编码的密码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;RUST_LOG=mini=info ./miniserver -h 0.0.0.0 -p 59999 -d&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;b. 然后在本地启动&lt;code&gt;minilocal&lt;/code&gt;，需要指定server的通讯密码&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;RUST_LOG=mini=info ./minilocal -s &amp;#34;xxx.xx.xx.xx:59999&amp;#34; -p 9998 -P xxxxxx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;c. 进行系统代理设定，代理地址为&lt;code&gt;127.0.0.0:9998&lt;/code&gt;，或者也可以设置自动代理，PAC文件地址为&lt;code&gt;http://127.0.0.1:9998/pac&lt;/code&gt;。本代理同时支持HTTP，HTTPS和SOCKS5协议&lt;/p&gt;&lt;h2&gt;原理&lt;/h2&gt;&lt;h2&gt;什么是代理?&lt;/h2&gt;&lt;p&gt;客户端与服务器之前通讯时，需要经过中间的网络终端中转，这个中间的服务器就是代理服务器。&lt;/p&gt;&lt;h2&gt;代理的功能?&lt;/h2&gt;&lt;blockquote&gt;以下内容摘自网络百科&lt;/blockquote&gt;&lt;p&gt;提供代理服务的计算机系统或其它类型的网络终端称为代理服务器（英文：Proxy Server）。一个完整的代理请求过程为：客户端首先与代理服务器创建连接，接着根据代理服务器所使用的代理协议，请求对目标服务器创建连接、或者获得目标服务器的指定资源（如：文件）。在后一种情况中，代理服务器可能对目标服务器的资源下载至本地缓存，如果客户端所要获取的资源在代理服务器的缓存之中，则代理服务器并不会向目标服务器发送请求，而是直接传回已缓存的资源。一些代理协议允许代理服务器改变客户端的原始请求、目标服务器的原始响应，以满足代理协议的需要。代理服务器的选项和设置在计算机程序中，通常包括一个“防火墙”，允许用户输入代理地址，它会遮盖他们的网络活动，可以允许绕过互联网过滤实现网络访问。&lt;/p&gt;&lt;p&gt;代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。&lt;/p&gt;&lt;h2&gt;代理协议有哪些？&lt;/h2&gt;&lt;p&gt;本系列中只涉及几种常用的协议&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SOCKS5&lt;/li&gt;&lt;li&gt;HTTP代理&lt;/li&gt;&lt;li&gt;HTTPS代理&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;这些代理协议存在什么问题？&lt;/h2&gt;&lt;p&gt;这些代理协议在通讯或者建立通讯的时候存在明文传输的情况，所以使用时可能会被网络提供者监测。这样的话就存在一定的隐私泄露问题。比如你通过HTTPS代理服务器访问pornhub时，由于浏览器会先发出一个CONNECT请求，报文内容中会包含pornhub服务器的地址。网管就会知道你在逛什么网站了。&lt;/p&gt;&lt;p&gt;那么该如何解决这一问题呢？有人就提出将代理服务器分成两部分，程序A运行在用户本地，它支持常规的代理协议，另一部分程序B运行在我们的服务器上。A和B之间的通讯采用我们自己定义的协议及加密方式。这样一来我们的网络访问请求将变得非常隐秘，不容易被识别。&lt;/p&gt;&lt;p&gt;综上所述，整个代理结构如下:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-57071cb35d69a3d8b8e4aafddedee092_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;855&quot; data-rawheight=&quot;393&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;855&quot; data-original=&quot;https://pic3.zhimg.com/v2-57071cb35d69a3d8b8e4aafddedee092_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-57071cb35d69a3d8b8e4aafddedee092_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;855&quot; data-rawheight=&quot;393&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;855&quot; data-original=&quot;https://pic3.zhimg.com/v2-57071cb35d69a3d8b8e4aafddedee092_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-57071cb35d69a3d8b8e4aafddedee092_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>importcjj</author>
<guid isPermaLink="false">2019-12-18-90459884</guid>
<pubDate>Wed, 18 Dec 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>零成本异步I/O</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2019-12-17-97574385.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/97574385&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt; 这是 Withoutboats 在 2019 年 3 月的 Rust Latam 上所做报告的一个翻译和整理。这个报告主要介绍他参与开发了一年半的语言特性，包括 Rust 异步 I/O 的发展历程，以及目前已经稳定的零成本抽象的&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; 语法的关键实现原理。&lt;br/&gt;&lt;br/&gt; Withoutboats 是就职于 Mozilla 的一名研究员，主要从事 Rust 语言开发。他开发的这个语言特性叫做 &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;，这可能是本年度我们在 Rust 语言上做的最重要的事。这解决了困扰我们很久的问题，即我们如何能在 Rust 中拥有零成本抽象的异步IO。&lt;br/&gt;&lt;br/&gt; 注：报告视频中的幻灯片比较模糊，我对其进行了重绘与翻译；因个人水平有限，翻译和整理难免有错误或疏漏之处，欢迎读者批评指正。&lt;br/&gt; &lt;/blockquote&gt;&lt;h2&gt;&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;首先，介绍一下 &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;async&lt;/code&gt; 是一个修饰符，它可以应用在函数上，这种函数不会在调用时一句句运行完成，而是立即返回一个 &lt;code&gt;Future&lt;/code&gt; 对象，这个 &lt;code&gt;Future&lt;/code&gt; 对象最终将给出这个函数的实际返回结果。而在一个这样的 &lt;code&gt;async&lt;/code&gt; 函数中，我们可以使用await运算符，将它用在其它会返回 &lt;code&gt;Future&lt;/code&gt; 的函数上，直到那些 &lt;code&gt;Future&lt;/code&gt; 返回实际结果。通过这种方法，异步并发开发更加方便了。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;withoutboats&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;select FROM users WHERE username = {}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db_response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是一段简短的代码样例，我们具体解释一下 &lt;code&gt;Future&lt;/code&gt; 。这段代码基本上做的就是一种类似于 ORM 框架所作的事。你有一个叫 &lt;code&gt;get_user&lt;/code&gt; 的函数，它接受一个字符串类型的用户名参数，并通过在数据库中查找对应用户的记录来返回一个User对象。它使用的是异步 I/O ，这意味着它得是一个异步函数，而不是普通函数，因此当你调用它时，你可以异步等待（&lt;code&gt;await&lt;/code&gt;）它；然后我们看一下函数的实现，首先是用用户名参数拼接出要执行的 SQL 语句，然后是查询数据库，这就是我们实际执行 I/O 的地方，所以这个查询（query）返回的是 &lt;code&gt;Future&lt;/code&gt; ，因为它使用的是异步 I/O 。所以在查询数据库时，你只需要使用异步等待（&lt;code&gt;await&lt;/code&gt;）来等待响应，在获得响应后就可以从中解析出用户。这个函数看起来像个玩具，但我想强调的是，它与使用阻塞式 I/O 的唯一区别就是这些注解（指&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;）了，你只需将函数标记为异步（&lt;code&gt;async&lt;/code&gt;），并在调用它们时加上 &lt;code&gt;await&lt;/code&gt; 就行了，开发的心智负担很小，以至于你会忘了自己是在写异步 I/O 而不是阻塞 I/O 。而 Rust 的这种实现让我尤其感到兴奋的是，它的 &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; 和 &lt;code&gt;Future&lt;/code&gt; 都是零成本抽象的。&lt;/p&gt;&lt;h2&gt;零成本抽象&lt;/h2&gt;&lt;p&gt;零成本抽象是 Rust 比较独特的一项准则，这是使 Rust 与其他许多语言相区别的原因之一。在添加新功能时，我们非常关心这些新功能是不是零成本的。不过这并不是我们想出来的点子，它在 C++ 中也很重要，所以我认为最好的解释是 Bjarne Stroustrup 的这句话：&lt;/p&gt;&lt;blockquote&gt; 零成本抽象意味着你不使用的东西，你不用为它付出任何代价，进一步讲，你使用的东西，你无法写出比这更好的代码。&lt;br/&gt; Zero Cost Abstractions: What you don&amp;#39;t use, you don&amp;#39;t pay for. And further: What you do use, you couldn&amp;#39;t hand code any better.&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;也就是说零成本抽象有两个方面：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;该功能不会给不使用该功能的用户增加成本，因此我们不能为了增加新的特性而增加那些会减慢所有程序运行的全局性开销。&lt;/li&gt;&lt;li&gt;当你确实要使用该功能时，它的速度不会比不使用它的速度慢。如果你觉得，我想使用这个非常好用的功能把开发工作变得轻松，但是它会使我的程序变慢，所以我打算自己造一个，那么这实际上是带来了更大的痛苦。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以，我将回顾一下我们如何尝试解决异步 I/O 和 Rust 的问题，以及在我们实现这一目标的过程中，某些未能通过这两项零成本测试的特性。&lt;/p&gt;&lt;h2&gt;绿色线程的尝试&lt;/h2&gt;&lt;p&gt;我们要解决的问题是 &lt;b&gt;异步 I/O&lt;/b&gt; 。通常 I/O 处于阻塞状态，因此当你使用 I/O 时，它会阻塞线程，中止你的程序，然后必须通过操作系统重新调度。阻塞式 I/O 的问题是当你尝试通过同一程序提供大量连接时，它无法真正实现扩展。因此对于真正的大规模网络服务，你需要某种形式的非阻塞的或者说异步的 I/O 。尤其是 Rust 是针对具有真正的高性能要求而设计的语言，它是一种系统编程语言，面向那些真正在乎计算资源的人。要在网络的世界中真正取得成功，我们就需要某种解决方案来解决这个异步 I/O 问题。&lt;/p&gt;&lt;p&gt;但是 &lt;b&gt;异步 I/O 的最大问题是它的工作方式&lt;/b&gt; ：在你调用 I/O 时，系统调用会立即返回，然后你可以继续进行其他工作，但你的程序需要决定如何回到调用该异步 I/O 暂停的那个任务线上，这就使得在编码上，异步 I/O 的代码要比阻塞 I/O 的代码复杂得多。所以，很多，尤其是以可扩展的网络服务这类特性为目标的语言，一直在试图解决这个问题。比如，让它不再是最终用户需要解决的问题，而是编程语言的一部分或者某个库的一部分等等。&lt;/p&gt;&lt;p&gt;Rust 最初使用的第一个解决方案是 &lt;b&gt;绿色线程&lt;/b&gt;，它已经在许多语言中获得成功。绿色线程基本上就像阻塞式 I/O 一样，使用的时候就像是普通的线程，它们会在执行 I/O 时阻塞，一切看起来就跟你在使用操作系统的原生方式一样。但是，它们被设计为语言运行时的一部分，来对那些需要同时运行成千上万甚至数百万个绿色线程的网络服务用例进行优化。一个使用该模型的典型的成功案例就是 Go 语言，它的绿色线程被称为 goroutine。对于 Go 程序来说，同时运行成千上万个 goroutine 是很正常的，因为与操作系统线程不同，创建它们的成本很低。&lt;/p&gt;&lt;p&gt;即 &lt;b&gt;绿色线程的优点&lt;/b&gt; 在于：产生操作系统线程时的内存开销要高得多，因为每个操作系统线程会创建一个很大的堆栈，而绿色线程通常的工作方式是，你将产生一个以很小的堆栈，它只会随着时间的推移而增长，而产生一堆不使用大量内存的新线程并不便宜；并且使用类似操作系统原语的问题还在于你依赖于操作系统调度，这意味着你必须从程序的内存空间切换到内核空间，如果成千上万的线程都在快速切换，上下文切换就会增加很多开销。而将调度保持在同一程序中，你将避免使用这些上下文，进而减少开销。所以我相信绿色线程是一个非常好的模型，适用于许多语言，包括 Go 和 Java。&lt;/p&gt;&lt;p&gt;在很长一段时间内， Rust 都有绿色线程，但是在 1.0 版本之前删掉了。我们删掉它是因为它不是零成本抽象的，准确的说就是我在第一个问题中谈到的，它给那些不需要它的人增加了成本。比如你只想编写一个不是网络服务的屏幕打印的 Rust 程序，你必须引入负责调度所有绿色线程的语言运行时。这种方法，尤其是对于试图把 Rust 集成到一个大的 C 应用程序中的人来说，就成为一个问题。很多 Rust 的采用者拥有一些大型C程序，他们想开始使用 Rust 并将 Rust 集成到他们的程序中，只是一小段 Rust 代码。问题是，如果你必须设置运行时才能调用 Rust ，那么这一小部分的 Rust 程序的成本就太高了。因此从 1.0 开始，我们就从语言中删除了绿色线程，并删除了语言的运行时。现在我们都知道它的运行时与 C 基本上相同，这就使得在 Rust 和 C 之间调用非常容易，而且成本很低，这是使 Rust 真正成功的关键因素之一。删除了绿色线程，我们还是需要某种异步 I/O 解决方案；但是我们意识到 &lt;b&gt;这应该是一个基于库的解决方案，我们需要为异步 I/O 提供良好的抽象，它不是语言的一部分，也不是每个程序附带的运行时的一部分，只是可选的并按需使用的库。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;Future 的解决方案&lt;/h2&gt;&lt;p&gt;最成功的库解决方案是一个叫做 &lt;code&gt;Future&lt;/code&gt; 的概念，在 JavaScript 中也叫做 &lt;code&gt;Promise&lt;/code&gt;。&lt;code&gt;Future&lt;/code&gt; 表示一个尚未得出的值，你可以在它被解决（resolved）以得出那个值之前对它进行各种操作。在许多语言中，对 &lt;code&gt;Future&lt;/code&gt; 所做的工作并不多，这种实现支持很多特性比如组合器（Combinator），尤其是能让我们在此基础上实现更符合人体工程学的 &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; 语法。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 可以表示各种各样的东西，尤其适用于表示异步 I/O ：当你发起一次网络请求时，你将立即获得一个 &lt;code&gt;Future&lt;/code&gt; 对象，而一旦网络请求完成，它将返回任何响应可能包含的值；你也可以表示诸如“超时”之类的东西，“超时”其实就是一个在过了特定时间后被解决的 &lt;code&gt;Future&lt;/code&gt; ；甚至不属于 I/O 的工作或者需要放到某个线程池中运行的CPU密集型的工作，也可以通过一个 &lt;code&gt;Future&lt;/code&gt; 来表示，这个 &lt;code&gt;Future&lt;/code&gt; 将会在线程池完成工作后被解决。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;FnOnce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;&lt;code&gt;Future&lt;/code&gt; 存在的问题&lt;/b&gt; 是它在大多数语言中的表示方式是这种基于回调的方法，使用这种方式时，你可以指定在 &lt;code&gt;Future&lt;/code&gt; 被解决之后运行什么回调函数。也就是说， &lt;code&gt;Future&lt;/code&gt; 负责弄清楚什么时候被解决，无论你的回调是什么，它都会运行；而所有的不便也都建立在此模型上，它非常难用，因为已经有很多开发者进行了大量的尝试，发现他们不得不写很多分配性的代码以及使用动态派发；实际上，你尝试调度的每个回调都必须获得自己独立的存储空间，例如 crate 对象、堆内存分配，这些分配以及动态派发无处不在。这种方法没有满足零成本抽象的第二个原则，如果你要使用它，它将比你自己写要慢很多，那你为什么还要用它。&lt;/p&gt;&lt;h2&gt;基于轮询的 Future &lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waker&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个非常出色的基于轮询的新方案——我们编写了这个模型，我归功于 Alex 和 Aaron Turon，是他们提出了这个想法——不是由 &lt;code&gt;Future&lt;/code&gt; 来调度回调函数，而是由我们去轮询 &lt;code&gt;Future&lt;/code&gt;，所以还有另一个被称为执行器（executor）的组件，它负责实际运行 &lt;code&gt;Future&lt;/code&gt; ；执行器的工作就是轮询 &lt;code&gt;Future&lt;/code&gt; ，而 &lt;code&gt;Future&lt;/code&gt; 可能返回“尚未准备就绪（Pending）”，也可能被解决就返回“已就绪（Ready）”。&lt;/p&gt;&lt;p&gt;该模型有很多优点。其中一个优点是，你可以非常容易地取消 &lt;code&gt;Future&lt;/code&gt; ，因为取消 &lt;code&gt;Future&lt;/code&gt; 只需要停止持有 &lt;code&gt;Future&lt;/code&gt;。而如果采用基于回调的方法，要通过调度来取消并使其停止就没这么容易了。&lt;/p&gt;&lt;p&gt;同时它还能够使我们在程序的不同部分之间建立真正清晰的抽象边界，大多数 &lt;code&gt;Future&lt;/code&gt; 库都带有事件循环（event loop），这也是调度你的 &lt;code&gt;Future&lt;/code&gt; 执行 I/O 的方法，但你实际上对此没有任何控制权。而在 Rust 中，各组件之间的边界非常整洁，执行器（executor）负责调度你的 &lt;code&gt;Future&lt;/code&gt; ，反应器（reactor）处理所有的 I/O ，然后是你的实际代码。因此最终用户可以自行决定使用什么执行器，使用他们想使用的反应器，从而获得更强的控制力，这在系统编程语言中真的很重要。而此模型最重要的真正优势在于，它使我们能够以一种真正零成本的完美方式实现这种状态机式的 &lt;code&gt;Future&lt;/code&gt; 。也就是当你编写的 &lt;code&gt;Future&lt;/code&gt; 代码被编译成实际的本地（native）代码时，它就像一个状态机；在该状态机中，每次 I/O 的暂停点都有一个变体（variant），而每个变体都保存了恢复执行所需的状态。这表示为一个枚举（enum）结构，即一个包含变体判别式及所有可能状态的联合体（union）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2db492125cda72829cbefdde5c25e216_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;890&quot; data-rawheight=&quot;658&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;890&quot; data-original=&quot;https://pic3.zhimg.com/v2-2db492125cda72829cbefdde5c25e216_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2db492125cda72829cbefdde5c25e216_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;890&quot; data-rawheight=&quot;658&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;890&quot; data-original=&quot;https://pic3.zhimg.com/v2-2db492125cda72829cbefdde5c25e216_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2db492125cda72829cbefdde5c25e216_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;上面的幻灯片尽可能直观地表示了这个状态机模型。可以看到，你执行了两个 I/O 事件，所以它有这几个状态。对于每个状态它都提供了所需的内存空间，足够你在 I/O 事件后恢复执行。&lt;/p&gt;&lt;p&gt;整个 &lt;code&gt;Future&lt;/code&gt; 只需要一次堆内存分配，其大小就是你将这个状态机分配到堆中的大小，并且没有额外的开销。你不需要装箱、回调之类的东西，只有真正零成本的完美模型。这些概念对于很多人来说比较难于理解，所以这是我力求做到最好的幻灯片，直观地呈现这个过程中发生了什么：你创建一个 &lt;code&gt;Future&lt;/code&gt;，它被分配到某个内存中特定的位置，然后你可以在执行器（executor）中启动它。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b4ec7067068f316149df482749baed99_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic2.zhimg.com/v2-b4ec7067068f316149df482749baed99_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b4ec7067068f316149df482749baed99_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic2.zhimg.com/v2-b4ec7067068f316149df482749baed99_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b4ec7067068f316149df482749baed99_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;执行器会轮询 &lt;code&gt;Future&lt;/code&gt;，直到最终 &lt;code&gt;Future&lt;/code&gt; 需要执行某种 I/O 。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9e6dd5a637c296fd2b78eb4e67bb0866_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-9e6dd5a637c296fd2b78eb4e67bb0866_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9e6dd5a637c296fd2b78eb4e67bb0866_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-9e6dd5a637c296fd2b78eb4e67bb0866_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9e6dd5a637c296fd2b78eb4e67bb0866_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在这种情况下，该 &lt;code&gt;Future&lt;/code&gt; 将被移交给处理 I/O 的反应器，即 &lt;code&gt;Future&lt;/code&gt; 会等待该特定 I/O 。最终，在该 I/O 事件发生时，反应器将使用你在轮询它时传递的Waker 参数唤醒 &lt;code&gt;Future&lt;/code&gt; ，将其传回执行器；&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a60db9a1fc1ffdff80b915803c4bb9a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a60db9a1fc1ffdff80b915803c4bb9a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a60db9a1fc1ffdff80b915803c4bb9a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;783&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-4a60db9a1fc1ffdff80b915803c4bb9a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4a60db9a1fc1ffdff80b915803c4bb9a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;然后当需要再次执行I/O时，执行器再将其放回反应器；它将像这样来回穿梭，直到最终被解决（resolved）。在被解决并得出最终结果时，执行器知道它已经完成，就会释放句柄和整个&lt;code&gt;Future&lt;/code&gt;，整个调用过程就完成了。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2d1bdb39189796d63f286fe40965ab8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;784&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic1.zhimg.com/v2-a2d1bdb39189796d63f286fe40965ab8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2d1bdb39189796d63f286fe40965ab8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;784&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic1.zhimg.com/v2-a2d1bdb39189796d63f286fe40965ab8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a2d1bdb39189796d63f286fe40965ab8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;总结一下：这种模型形成了一种循环，我们轮询 &lt;code&gt;Future&lt;/code&gt; ，然后等待 I/O 将其唤醒，然后一次又一次地轮询和唤醒，直到最终整个过程完成为止。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1b3a43e1d072bd76825a9946bd89f042_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;824&quot; data-rawheight=&quot;561&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;824&quot; data-original=&quot;https://pic3.zhimg.com/v2-1b3a43e1d072bd76825a9946bd89f042_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1b3a43e1d072bd76825a9946bd89f042_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;824&quot; data-rawheight=&quot;561&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;824&quot; data-original=&quot;https://pic3.zhimg.com/v2-1b3a43e1d072bd76825a9946bd89f042_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1b3a43e1d072bd76825a9946bd89f042_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;并且这种模型相当高效。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-72e011276307d3c04b9611565530db4a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;559&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-72e011276307d3c04b9611565530db4a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-72e011276307d3c04b9611565530db4a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;559&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;1024&quot; data-original=&quot;https://pic3.zhimg.com/v2-72e011276307d3c04b9611565530db4a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-72e011276307d3c04b9611565530db4a_b.jpg&quot;/&gt;&lt;figcaption&gt;有关 Future 的第一篇文章中发布的基准测试&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这是在有关 &lt;code&gt;Future&lt;/code&gt; 的第一篇文章中发布的基准测试，与其他语言的许多不同实现进行了对比。柱形越高表示性能越好，我们的 &lt;code&gt;Future&lt;/code&gt; 模型在最左侧，所以说我们有了非常出色的零成本抽象，即使是与许多其他语言中最快的异步 I/O 实现相比也是相当有竞争力的。&lt;/p&gt;&lt;p&gt;但是，问题在于，你并不希望手动编写这些状态机，把整个应用程序所有状态写成一个状态机并不是件轻松愉快的事。而这种 &lt;code&gt;Future&lt;/code&gt; 抽象的真正有用之处在于，我们可以在其之上构建其他 API 。&lt;/p&gt;&lt;h2&gt;其它API&lt;/h2&gt;&lt;h3&gt;组合器（Combinator）&lt;/h3&gt;&lt;p&gt;我们能使用的第一个解决方案是 &lt;code&gt;Future&lt;/code&gt; 组合器（Combinator）。你可以通过将这些组合器方法应用于 &lt;code&gt;Future&lt;/code&gt; 来构建状态机，它们的工作方式类似于迭代器（&lt;code&gt;Iterator&lt;/code&gt;）的适配器（如 &lt;code&gt;filter&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch_rust_lang&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;rust-lang.org&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;and_then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;concat_body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;from_utf8_lossy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个函数的作用是请求 “rust-lang.org”，然后将响应转换为字符串。它并不返回一个字符串，而是返回一个字符串的 &lt;code&gt;Future&lt;/code&gt; ，因为它是一个异步函数。函数体中有这样一个 &lt;code&gt;Future&lt;/code&gt;，它包含一些会被调用的 I/O 操作，用 &lt;code&gt;and_then&lt;/code&gt; 和 &lt;code&gt;map&lt;/code&gt; 之类的组合器将这些操作全部组合在一起。我们构建了所有这些用处各异的组合器，例如，&lt;code&gt;and_then&lt;/code&gt;，&lt;code&gt;map&lt;/code&gt;，&lt;code&gt;filter&lt;/code&gt;，&lt;code&gt;map_error&lt;/code&gt;等等。我们已经知道这种方式是有一些缺点的，尤其是诸如嵌套回调之类，可读性非常差。&lt;/p&gt;&lt;h3&gt;&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 的实现&lt;/h3&gt;&lt;p&gt;因为组合器有这样的缺点，所以我们开始尝试实现 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;。&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 的第一个版本并不是 Rust 语言的一部分，而是由该库像语法插件一样提供的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#[async]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch_rust_lang&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;rust-lang.org&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;concat_body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;from_utf9_lossy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个函数与之前那个版本的一样，它只是获取 Rust 官网并将其转换为字符串；但是它使用 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 来实现，所以更像是顺序执行，看起来更像普通的阻塞 I/O 的工作方式；就像开头那个实例中呈现的一样，它们唯一区别是注解（指 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;）。我们已经知道，&lt;code&gt;async&lt;/code&gt; 注解会将此函数转换为一个返回 &lt;code&gt;Future&lt;/code&gt; 的函数，而不是立即返回结果，并且我们需要异步等待（&lt;code&gt;await&lt;/code&gt;）这些在函数内部构造的 &lt;code&gt;Future&lt;/code&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;$future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;$future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;            &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Poll&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我们的轮询模型中，&lt;code&gt;await&lt;/code&gt; 是一种语法糖；它会进入上面这种循环，你要做的就是在循环中轮询，在一段时间内你将一直得到“尚未准备就绪（Pending）”，然后一直等到它再次被唤醒，终于你等待的 &lt;code&gt;Future&lt;/code&gt; 完成了，然后你使用该值跳出了循环，这就是这些 &lt;code&gt;await&lt;/code&gt; 表达式的计算结果。&lt;/p&gt;&lt;p&gt;这似乎是一个非常不错的解决方案，&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 的写法会被编译成我们超棒的零成本的 &lt;code&gt;Future&lt;/code&gt;。不过从已发布的 &lt;code&gt;Future&lt;/code&gt; 的使用者的反馈看，我们还是发现了一些问题。&lt;/p&gt;&lt;h3&gt;新的问题&lt;/h3&gt;&lt;p&gt;基本上所有试图使用 &lt;code&gt;Future&lt;/code&gt; 的人都会遇到非常令人困惑的错误消息。在这些消息中，编译器会提示你的&lt;code&gt;Future&lt;/code&gt;的生命周期不是静态的（&lt;code&gt;&amp;#39;static&lt;/code&gt;）或没有实现某个 &lt;code&gt;trait&lt;/code&gt; 等等；这些提示你并不真正理解，但编译器想提出有用的建议，你也就跟着这个建议去做，直到编译成功；你可能会给闭包加上 &lt;code&gt;move&lt;/code&gt; 关键字，或者把某些值放到引用计数的指针（&lt;code&gt;Rc&lt;/code&gt;）中，然后将复制（&lt;code&gt;clone&lt;/code&gt;）它；你将所有这些开销添加到了似乎并不必要的事情上，却不明白为什么要这样做，而当你已经疲于处理这些时，代码已经乱成一锅粥了，所以很多人都被 &lt;code&gt;Future&lt;/code&gt; 的问题卡住了。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b1fa5d83cda8788404bb2dc3fd1c927a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;780&quot; data-rawheight=&quot;384&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;780&quot; data-original=&quot;https://pic3.zhimg.com/v2-b1fa5d83cda8788404bb2dc3fd1c927a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b1fa5d83cda8788404bb2dc3fd1c927a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;780&quot; data-rawheight=&quot;384&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;780&quot; data-original=&quot;https://pic3.zhimg.com/v2-b1fa5d83cda8788404bb2dc3fd1c927a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b1fa5d83cda8788404bb2dc3fd1c927a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;而且它对于组合器产生这种非常大的类型也没什么办法，你的整个终端窗口（terminal）将被其中一个组合器链的类型填满。你用了&lt;code&gt;and_then&lt;/code&gt;，以及又一个 &lt;code&gt;and_then&lt;/code&gt;，然后是 &lt;code&gt;map_err&lt;/code&gt; 紧跟一个 TCP 流等等等等，你必须仔细研究一下，才能弄清楚所遇到的实际错误是什么。&lt;/p&gt;&lt;blockquote&gt; “When using Futures, error messages are inscrutable.” “当使用 Future 时，错误信息难以理解。” “Having to use RefCell or clone everything for each future leads to overcomplicated code that makes me wish Rust had garbage collection.” “不得不使用 RefCell 以及为每个 future 克隆所有它需要的值产生了过于复杂的代码，这让我开始期待 Rust 能具备垃圾回收功能了。”&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;我在 reddit 上发现了这条消息，我认为它确实很好地总结了所有有关 &lt;code&gt;Future&lt;/code&gt; 的抱怨。使用 &lt;code&gt;Future&lt;/code&gt; 时，错误消息难以理解；不得不使用 RefCell 以及为每个 future 克隆所有它需要的值产生了过于复杂的代码，这让我开始期待 Rust 能具备垃圾回收功能了（观众笑）。是的，这不是什么好反馈。&lt;/p&gt;&lt;p&gt;因此，从大约一年半前的情况来看，很明显，有两个问题需要解决，才能让大家更容易使用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;首先&lt;/b&gt;，我们需要更好的错误消息，最简单的方法就是将语法构建到语言中，然后它们就可以在你所有的诊断和错误处理代码中加入钩子，从而使你能够真正拥有良好的 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 的错误消息。&lt;b&gt;其次&lt;/b&gt;，人们遇到的大多数错误实际上是因为他们被一个晦涩难解的问题卡住了——借用问题。正是因为 &lt;code&gt;Future&lt;/code&gt; 的设计方式存在着这种根本的局限性，导致一些很普通的编程范式都无法表达。所谓借用问题，就是在最初的 &lt;code&gt;Future&lt;/code&gt; 的设计中你不能跨过&lt;b&gt;异步等待点&lt;/b&gt;（await point）进行借用，也就是说，如果你要异步等待（await）某件事，你就不能在那个时候持有任何存活的引用。当人们遇到了这种问题，他们通常会被卡住，最终他们会尝试在 &lt;code&gt;await&lt;/code&gt; 的时候进行借用然后发现实际上做不到。所以如果我们能够使这种借用被允许，那么大多数这些错误将消失，一切都将变得更易于使用，你可以使用 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 编写普通的 Rust 代码，并且一切都会正常进行。&lt;/p&gt;&lt;p&gt;这种跨越 &lt;code&gt;await&lt;/code&gt; 的借用是非常普遍的，因为 Rust 的 API 天然就具有引用。当你实际编译 &lt;code&gt;Future&lt;/code&gt; 时，它必须能够恢复所有状态，而当你拥有某些其它东西的引用时，它们位于同一栈帧中，最终你会得到一个&lt;b&gt;自引用&lt;/b&gt;的 &lt;code&gt;Future&lt;/code&gt; 结构（Self-Referential Future）。这是开头的那个 &lt;code&gt;get_user&lt;/code&gt; 方法，我们有这样一个 SQL 字符串，而在使用 SQL 字符串调用 &lt;code&gt;query&lt;/code&gt; 方法时，我们传递的是 SQL 字符串的引用。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;SELECT FROM users WHERE username = {}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db_response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里存在的问题是，对 SQL 字符串的引用是对存储在相同 &lt;code&gt;Future&lt;/code&gt; 状态中的其他内容的引用，因此它成为一种自引用结构。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9fbfa65f3218487b457b4ff272f68c96_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;604&quot; data-rawheight=&quot;440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;604&quot; data-original=&quot;https://pic3.zhimg.com/v2-9fbfa65f3218487b457b4ff272f68c96_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9fbfa65f3218487b457b4ff272f68c96_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;604&quot; data-rawheight=&quot;440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;604&quot; data-original=&quot;https://pic3.zhimg.com/v2-9fbfa65f3218487b457b4ff272f68c96_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9fbfa65f3218487b457b4ff272f68c96_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果把这个 &lt;code&gt;Future&lt;/code&gt; 视作一个真的结构体的话，这就是理论上它所拥有的字段。除了代表数据库句柄的 &lt;code&gt;self&lt;/code&gt; 之外，还有 SQL 字符串以及对这个 SQL 字符串的引用，即一个最终指回同一结构体中某个字段的引用。&lt;/p&gt;&lt;p&gt;一些新的潜在结构会成为非常棘手的问题，因为我们没有通用的解决方案。当你移动该结构时，我们不允许你使用自引用，是因为我们会在新位置创建一个原有结构的新副本，旧副本会变为无效，但是在复制时，新副本的引用仍指向旧副本的字段，该指针就变成了悬空指针（dangling pointer），而这正是 Rust 必须避免的内存问题。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5601cb4bf7ae8092550226cc27fe5a1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;944&quot; data-rawheight=&quot;480&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;944&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5601cb4bf7ae8092550226cc27fe5a1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a5601cb4bf7ae8092550226cc27fe5a1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;944&quot; data-rawheight=&quot;480&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;944&quot; data-original=&quot;https://pic2.zhimg.com/v2-a5601cb4bf7ae8092550226cc27fe5a1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a5601cb4bf7ae8092550226cc27fe5a1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;所以我们不能使用自引用结构，因为如果你移动它们，那么它们将失效。然而，我们实际上并不需要真正移动这些 &lt;code&gt;Future&lt;/code&gt; 。如果你还记得在堆中通过句柄使用 &lt;code&gt;Future&lt;/code&gt; 的模型，它在反应器和执行器之间来回传递，所以 &lt;code&gt;Future&lt;/code&gt; 本身永远不会真正移动；而只要你保证不移动，&lt;code&gt;Future&lt;/code&gt; 包含自引用就完全没问题。&lt;/p&gt;&lt;p&gt;所以我们需要通过采用某种方式在 &lt;code&gt;Future&lt;/code&gt; 的 API 中表达 “在你轮询时，你不允许随意移动它” 来解决这个问题。如果我们能够表达这一点，我们就可以允许 &lt;code&gt;Future&lt;/code&gt; 中出现自引用，进而就可以在异步函数中真正使用这些引用，并且一切都会正常工作。因此我们研究了这个问题，最终开发出了被称为 &lt;code&gt;Pin&lt;/code&gt; 的新 API 。&lt;/p&gt;&lt;h3&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Pin&lt;/code&gt; 是一种围绕其他指针类型的适配器，可以将其它指针变为 &lt;b&gt;固定引用&lt;/b&gt;（pinned reference）。除了原有指针的保证外，它还保证这个引用再也不会被移动，所以我们可以确保它将一直处在同一内存位置，直到最终被释放。如果你的 API 中有一些内容已表明必须使用 &lt;code&gt;Pin&lt;/code&gt;，那么你就知道了它再也不会被移动，这样就你可以使用那种自引用的结构体了。因此，我们修改了 &lt;code&gt;Future&lt;/code&gt; 的工作方式，现在它变成了一个经过装箱（boxed）的 &lt;code&gt;Future&lt;/code&gt; ，实际上是一个由 &lt;code&gt;Pin&lt;/code&gt; 封装的 &lt;code&gt;Box&amp;lt;Future&amp;gt;&lt;/code&gt; ；这样无论在哪里装箱，我们把它放在堆内存中，它可以保证永远不会再移动；而当你轮询 &lt;code&gt;Future&lt;/code&gt; 时，不再使用一个普通引用，而是使用一个固定引用，这样 &lt;code&gt;Future&lt;/code&gt; 就知道它不会被移动。而使这一切起作用的诀窍是，要从固定引用中获取非固定引用，你只能使用不安全的代码。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boxed&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Box&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;as_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_unchecked_mut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以 Pin API 大致就像这样。在这里你有一个 &lt;code&gt;Pin&lt;/code&gt; 结构，它只是另一个指针类型的封装，它没有任何运行时开销或者其它东西，仅仅是将其划分为一个固定的（pinned）对象，然后一个固定的 &lt;code&gt;Box&lt;/code&gt; 指针可以转换为一个固定引用，但是将一个固定引用转换为一个非固定引用的唯一方法是使用一个不安全的（unsafe）函数。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;: &lt;span class=&quot;nc&quot;&gt;Pin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waker&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Waker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;Poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样一来，我们要做的就是修改 &lt;code&gt;Future&lt;/code&gt; 的 API ，其轮询方法将不再接受一个普通引用，而是接受一个固定引用，而这其实就是我们将要稳定发布的 &lt;code&gt;Future&lt;/code&gt; API。而做了这个修改之后，第一个示例的写法就能正常工作了。这样你就可以像写阻塞 I/O 的代码那样编写异步 I/O 的代码了，只需要加上 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 注解，你就能得到这个出色的零成本抽象的异步实现，而即便你自己手写，这基本上也是你能写出的开销最低的实现了。&lt;/p&gt;&lt;h2&gt;&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 的现状及未来&lt;/h2&gt;&lt;p&gt;目前的情况是，Pinning 大约在一个月前的最新版本中稳定了，我们正在稳定 &lt;code&gt;Future&lt;/code&gt; 的 API ，因此大概会在 1.35，也可能会推到 1.36 稳定，基本上在两三个月内就会知道了。并且我们希望今年的某个时候我们能够拥有 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;，希望今年夏末能将其稳定下来，这样人们就可以使用这种类似阻塞 I/O 的语法编写无阻塞的 I/O 网络服务了。除了这些稳定化工作，我们也已经开始研究某些更长期的功能，比如流（Stream），我认为它可能是异步的下一个大功能。我们知道一个 &lt;code&gt;Future&lt;/code&gt; 只产生一个值，而一个流可以异步地产生很多值；异步地产生值本质上就像是一个异步迭代器，你能够在一个流上进行异步的循环；这个功能对于许多用例来说非常重要，比如流式传输HTTP、WebSocket 推送请求之类的东西，不用像我们的 RPC 模型那样发出网络请求然后获得单个响应，而是能够使用请求流和响应流，在两者之间来回调用。&lt;/p&gt;&lt;p&gt;目前使用异步仍然存在一个限制，即不能在 &lt;code&gt;trait&lt;/code&gt; 中使用 &lt;code&gt;async&lt;/code&gt;。有许多编译器开发工作正在进行，使其能够支持这个特性。除了这些功能，有时候我们也希望能拥有生成器（Generator），类似于 Python 或 JavaScript 的生成器，除了拥有可以 &lt;code&gt;return&lt;/code&gt; 的函数，还能使用可以 &lt;code&gt;yield&lt;/code&gt; 的函数，这样你就可以在 &lt;code&gt;yield&lt;/code&gt; 之后再次恢复执行；并且你可以将这些函数作为编写迭代器和流的方式，就像异步函数能够让你像编写普通函数那样编写 &lt;code&gt;Future&lt;/code&gt; 一样。&lt;/p&gt;&lt;p&gt;最后，我想回顾一下成就这种零成本异步 I/O 的关键点：首先就是这种基于轮询的 &lt;code&gt;Future&lt;/code&gt;，它将这些 &lt;code&gt;Future&lt;/code&gt; 编译到这种相当紧凑的状态机中；其次是这种实现 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 语法的方式，即因为有了 &lt;code&gt;Pin&lt;/code&gt;，我们能够跨越异步等待点使用引用。&lt;/p&gt;&lt;p&gt;谢谢大家。&lt;/p&gt;&lt;blockquote&gt; 译者注：报告中计划稳定的特性均已稳定发布，参见 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//areweasyncyet.rs/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;areweasyncyet.rs&lt;/a&gt;。 按照目前稳定的版本，&lt;code&gt;await&lt;/code&gt; 已改为后置运算符 &lt;code&gt;.await&lt;/code&gt;，所以本文开头的 &lt;code&gt;get_user&lt;/code&gt; 方法应当修改为：&lt;br/&gt; &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;withoutboats&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;: &lt;span class=&quot;kp&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#34;select FROM users WHERE username = {}&amp;#34;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db_response&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;::&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>不明觉疼</author>
<guid isPermaLink="false">2019-12-17-97574385</guid>
<pubDate>Tue, 17 Dec 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>RFC#2457——Rust 语言选择支持非 ASCII 码标识符在 GitHub 引发的激辩（二）</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2019-11-17-92057476.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/92057476&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d223c87280a1862a8b7839886e43bb90_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 难难难，道德玄，不对知音不可谈。对了知音谈几句，不对知音枉费舌尖！ &lt;/blockquote&gt;&lt;p&gt;书接&lt;a href=&quot;https://zhuanlan.zhihu.com/p/91710113&quot; class=&quot;internal&quot;&gt;上文&lt;/a&gt;，至 2018 年 6 月 5 日，RFC#2457刚创建三天，已看到了不少反对声。在非英语母语的参与者中，华人开发者群体尤为突出。形成对比的是其他非英语社区的积极反馈。包括韩语命名的经验之谈，葡萄牙语、德语命名的实例代码（Java，PHP，C++等）。&lt;/p&gt;&lt;p&gt;之前说到 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/eggrobin&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;eggrobin&lt;/a&gt;&lt;/b&gt; 受 Rust 开发组的 @Manishearth 邀请，来谈他使用非英文标识符的经验。开篇自称未写过 Rust，是 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/mockingbirdnest/Principia/blob/2018051512-Darboux/numerics/%25D1%2587%25D0%25B5%25D0%25B1%25D1%258B%25D1%2588%25D1%2591%25D0%25B2_series.hpp%23L44-L45&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Principia&lt;/a&gt; 的合作者。【之后至少十余日他一直参与讨论，觉得值得多了解一点，下面的方括号内容都为本人旁白】&lt;/p&gt;&lt;p&gt;地道法国人，2002 年开始学 VB6， 2003 年开始学 VB .NET，2004 开始 Ada95。看着头像很年轻，果然！他 2004 年进入collège，时年 11 岁，开始学英语，到 2006 年可交流。&lt;/p&gt;&lt;p&gt;期间读法语编程书籍（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.amazon.fr/Programmer-en-Ada-95-2e-%25C3%25A9dition/dp/271178651X&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Amazon.fr - Programmer en Ada 95 - 2e édition - John Barnes, Hughes Fauconnier - Livres&lt;/a&gt;，不知是否也用了法语命名），同时&lt;b&gt;用他能写能读的语言命名标识符——法语&lt;/b&gt;（字母有音调）。2006 年开始，他转为用英文标识符，因为英文关键字+标准库 API 和法语标识符混搭看着乱。接下来十年间，编程，大学读纯数学，成为软件工程师。&lt;/p&gt;&lt;p&gt;下面他开始回应楼上。提到虽然 Ada95 IDE 存在非 ASCII 码的 bug（把非 ASCII 字符后的 ASCII 字符自动大写，形成像&lt;code&gt;TrèS_ÉLéGant&lt;/code&gt;），但他那时捏着鼻子忍了【真能忍】。 在同一标识符中混合英文+非英文也有，因为计算机术语在非英文社区往往仍是用英文进行交流，而业务领域相关的概念就像之前 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/kimhyunkang&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;@kimhyunkang&lt;/a&gt; 提到的，适合用母语命名。【关于技术 NFKC 和 NFC 的一段略去】&lt;/p&gt;&lt;p&gt;接下来提到一个很喜欢用 unicode 命名的编程领域：数学。【因为是本行，应该挺有发言权】因为如果用英文缩写，经常会有不一致的情况：&lt;/p&gt;&lt;blockquote&gt;several decades of academic code show that what happens in the absence  of Unicode is that they write wonderful tersest possible yet  inconsistent abbreviations for the letters, such as &lt;code&gt;om&lt;/code&gt; or &lt;code&gt;w&lt;/code&gt; for &lt;code&gt;ω&lt;/code&gt;, not &lt;code&gt;argument_of_periapsis&lt;/code&gt;, &lt;code&gt;gamma&lt;/code&gt; for &lt;code&gt;γ&lt;/code&gt; followed by &lt;code&gt;gsq&lt;/code&gt; for &lt;code&gt;γ²&lt;/code&gt;, etc. (dig up your favourite pile of astronomical FORTRAN or FORTRAN-like C for entertaining examples).&lt;/blockquote&gt;&lt;p&gt;更指出在语音学者中也有类似需求：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gcc.gnu.org/bugzilla/show_bug.cgi%3Fid%3D67224%23c22&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;UTF-8 support for identifier names in GCC&lt;/a&gt;【GCC，你也是个拖后腿的，不过GCC 10 搞定了】&lt;/p&gt;&lt;p&gt;接下来引用了&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/huangjj27&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;huangjj27&lt;/a&gt;&lt;/b&gt;提到的中文输入法切换导致写码效率问题，但是，看他的回应似乎并未领会切换这个问题，而是理解成了非 ASCII 码标识符的阅读难度问题，回应与之前一位类似（用英化的日文命名仍然只有日本人看得懂）。【这倒是个不同文化间英文交流有误解的实例】&lt;/p&gt;&lt;p&gt;【台下各位，已经写了一个钟头了，今天且看看能不能看到华人声影吧】&lt;/p&gt;&lt;p&gt;哦哦，说什么来着。还是来自北京的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/3442853561&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;3442853561&lt;/a&gt; ，&lt;/b&gt;指出导出 crates 会有问题。以及，（自称无偏见的信息）在中文和日语为母语的地区，这个（非 ASCII 标识符）功能极少使用。【还替日本社区发声了居然，大期待后面有日本开发者现身】&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/whitequark&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;whitequark&lt;/a&gt;&lt;/b&gt; 提到，OCaml 也在考虑从 ISO-8859-1 转到 UTF-8。&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/mark-i-m&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;mark-i-m&lt;/a&gt;&lt;/b&gt; 又来了，表示不乐意看到代码中出现&lt;code&gt;const π&lt;/code&gt;，用起来痛苦、也并不特别容易读、也不能让代码的受众更广【有点耳熟的怨念呢】&lt;/p&gt;&lt;p&gt;有趣的是，他在三号打的第一枪，下面有 50 👍9踩；而今天的这楼，三赞三踩五困惑。看来喷的实在是捧不起来。&lt;/p&gt;&lt;p&gt;果然立马被数学小子&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/eggrobin&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;eggrobin&lt;/a&gt;&lt;/b&gt;怼了，顺带更多NFKC相关内容【也许之后要多了解一下】&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/clarfon&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;clarfon&lt;/a&gt;&lt;/b&gt; 同意数学公式用非 ASCII 的数学字符能更可读。但建议除非目标用户是非英语社区，否则库的 API 用英文。【听起来有点多余，本身是否使用非 ASCII 码标识符就应该是作者自愿。刻意强调 API 部分的确反映了API 的特殊性】&lt;/p&gt;&lt;p&gt;由于 PR 的 review 和评论排列顺序，跳播一个 7 日的来自&lt;b&gt;JelteF&lt;/b&gt;的PR review。荷兰人，指出小时候英语不流利时用母语命名标识符更加容易，&lt;b&gt;不用同时学编程和英语&lt;/b&gt;。他自己就是实例。紧接着 PR 的创建者&lt;b&gt; pyfisch &lt;/b&gt;也应声附和表示有类似经历。&lt;/p&gt;&lt;p&gt;下面 10 号来自坐标日本东京的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/CAFxX&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CAFxX&lt;/a&gt;&lt;/b&gt; （意大利人）对这两种老生常谈的谬论简直一针见血：&lt;/p&gt;&lt;blockquote&gt; The underlying argument is that one needs to write in English so  other people can read it. &lt;br/&gt;”要写英文其他人才能懂“&lt;br/&gt;他的回应： Then the underlying argument is proved false by the existence and size  of huge Chinese communities where English is definitely not the primary  way of expressing yourself, nor it is required to look up information.&lt;br/&gt;“在庞大的中文社区，英文绝不是首选的表达和问讯途径”&lt;br/&gt;&lt;br/&gt;And even if you write code just for yourself  you should write in English to learn it.&lt;br/&gt;”即使只是写代码给自己，也该用英文，正好学习英语“&lt;br/&gt;他的回应：I think this corollary is preposterous because it boils down to: &amp;#34;since somebody &lt;i&gt;arbitrarily decided for convenience&lt;/i&gt;  that everybody else should write code in English, you have to learn  English even if you are the only person you will ever read the code you  write&amp;#34;. To see how tone deaf this argument is, replace &amp;#34;code&amp;#34; with any  of &amp;#34;letter&amp;#34;, &amp;#34;notes&amp;#34;, &amp;#34;book&amp;#34; or &amp;#34;song&amp;#34; and then tell me if it makes  sense...&lt;br/&gt;“这个论调简直荒谬。就像是说‘既然有某人裁断，&lt;i&gt;为方便起见&lt;/i&gt;，所有人都必须用英文写代码，所以你必须学英文，哪怕你是自始至终唯一一个读代码的人’。还没get到这有多扯淡的话，可以试试把上句中的‘代码’换成‘信’，‘笔记’，‘书’或者‘歌’，再告诉我是不是扯。&lt;/blockquote&gt;&lt;p&gt;回到 5 日时间线，&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/mark-i-m&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;mark-i-m&lt;/a&gt;&lt;/b&gt; 附和&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/clarfon&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;clarfon&lt;/a&gt;&lt;/b&gt;的建议 API 用英文。【别告诉我这被最后从技术上限制了！】&lt;/p&gt;&lt;p&gt;又见来自韩国的&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/kimhyunkang&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;kimhyunkang&lt;/a&gt;， &lt;/b&gt;回应之前有关键盘输入的质疑，听起来就是说韩国和朝鲜的键盘都是标准键盘，可以用韩文输入法。【情况和国内类似】&lt;/p&gt;&lt;p&gt;终于，坐标中国的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/liigo&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;liigo&lt;/a&gt;&lt;/b&gt; 对之前提出 GBK 的那位回应，既然 rustc 只支持 UTF-8 编码，GBK 什么的应该不是问题。【难得的来自华人的中性声音】&lt;/p&gt;&lt;p&gt;5 日接下来的讨论都围绕 NFKC 和 NFC，略过。&lt;/p&gt;&lt;p&gt;【又是一小时，休息片刻继续，好不容易看完了一天的】&lt;/p&gt;&lt;p&gt;6 月 6 日，&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/ssokolow&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ssokolow&lt;/a&gt;&lt;/b&gt; 不知道如何输入π。Rust 组的&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/eddyb&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;eddyb&lt;/a&gt;&lt;/b&gt; 回应他装了希腊输入法，可以输入λ，π等等【我中文输入法威武，通吃】&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/lambda&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;lambda&lt;/a&gt; 表示&lt;/b&gt;基本支持，结尾仍希望不建议 API 使用非 ASCII 字符，并开发相关 lint【编译器的代码检查？】补充说没怎么看到过包含非 ASCII 字符的 API，除了一些数学领域和 APL。&lt;/p&gt;&lt;p&gt;今天就以韩国的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/kimhyunkang&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;kimhyunkang&lt;/a&gt;&lt;/b&gt; 的19高赞楼结束吧。&lt;/p&gt;&lt;blockquote&gt;...one of the major reasons my Korean colleagues don&amp;#39;t use Hangul in  their code is tooling problems, the biggest of them being Windows&amp;#39; poor  support of Unicode. Windows treated Unicode as a second-class citizen  for decades. ... Some compilers, IDEs, and build tools have  the same problem, too. They often fail to assume there can be non-ASCII  characters in source code or resource files.&lt;br/&gt;”我的韩国同事不用韩语命名的一个主要原因是工具，为首的是Windows对 Unicode 的烂支持。Windows 视 Unicode 低一等已有数十年。... 一些编译器、IDE 和构建工具也类似，并不顾及源码和资源文件中可能出现的非 ASCII 字符。”&lt;br/&gt;I&amp;#39;m fine with English being the lingua franca. But I find it absurd  when some people go further and assert that non-English-speaking  communities have to exclusively use English in their code. And I think  that is the reason why software in general has poor Unicode support,  despite Unicode being almost 30 years old.&lt;br/&gt;“我能接受英文作为国际交流用语。但有些人将之泛化号称非英语母语社区必须毫无例外地在代码中使用英文，简直荒唐。那恰恰是软件普遍对 Unicode 支持不佳的原因，尽管 Unicode 已有 30 年历史。“&lt;br/&gt;If you live in an English-speaking country and contribute to an  English-speaking open source community, it seems OK to assume that all  programmers speak English. But it isn&amp;#39;t. All my Korean colleagues and  friends use at least 1 or 2 open source software in their work, but less  than 10% of them contribute back to the software, mainly because they  are not confident enough in their English skills to have discussions in  an English-only community. The reason you don&amp;#39;t see many people with  problems in English is not because people are OK with that, but because  your community is English-only, and the software industry has a long  tradition of treating non-English languages as second-class citizens.&lt;br/&gt;”如果你在英语母语国家，参与一个英语开源社区，似乎很可以假定所有程序员都说英语。但绝非如此。我所有的韩国同事和朋友在工作中都用至少一两个开源工具，但只有不到一成参与项目，就是因为他们不自信英文水平能够参与英语社区的讨论。你们没看到很多英语不好的人不是因为大家英语都很好，而只是因为社区本身是纯英文的，软件行业俯视非英文语言由来久矣。&lt;br/&gt;I really love Rust, and I&amp;#39;d be sad if Rust as a community repeats this mistake.&lt;/blockquote&gt;&lt;p&gt;点赞的号中，看到了三位法国人以及来自俄罗斯、德国、意大利、中国、日本、罗马尼亚、阿根廷的开发者。【法国，果然五常】&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;【个人还比较期待的是来自日本开发者的现身说法，以及最后对于 API 的处理。如有其他特别想了解的方面请留言，否则接下来就走哪算哪了】&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;2019/11/16 粗搜了一下没发现日本开发者发声，动力下降不少。也看到了更加激烈的碰撞，但是更刺激的早就亲身在国内论坛参与过。虽然觉得看国外不同文化间的交锋相比内战更能使旁观者清，但，现在有点看够了的感觉。更主要的，对Rust本身的知识匮乏也使这个系列注定向说书方向发展，而离技术研讨越来越远。也许哪天有兴致（或者再被某些言论刺激到）再开书吧。下面是写&lt;a href=&quot;https://zhuanlan.zhihu.com/p/91710113&quot; class=&quot;internal&quot;&gt;前一篇&lt;/a&gt;时就完成了的结尾部分。&lt;/p&gt;&lt;h3&gt;Rust 语言初创一锤定音&lt;/h3&gt;&lt;p&gt;RFC#2457 提出之后，Rust 语言的设计者 Graydon Hoare 一直保持沉默，没有参与讨论与修订。在两个多月后的 8 月17 日，他终于发声，这也是这场论战中他唯一的发言：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6fc79831d2e91c046975d2d1cc9c3b59_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;750&quot; data-rawheight=&quot;309&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;750&quot; data-original=&quot;https://pic2.zhimg.com/v2-6fc79831d2e91c046975d2d1cc9c3b59_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6fc79831d2e91c046975d2d1cc9c3b59_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;750&quot; data-rawheight=&quot;309&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;750&quot; data-original=&quot;https://pic2.zhimg.com/v2-6fc79831d2e91c046975d2d1cc9c3b59_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-6fc79831d2e91c046975d2d1cc9c3b59_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;他指出，“很多年前，我们（Rust 主创们）就早已确认，将标识符限定于用英文命名是设计上的错误，我们应该改用 unicide 标识符”。并在最后恳请：“这（RFC）本不应再次开启一场围绕标识符命名限于 ASCII 码是否正确的辩论。这绝不正确。不要再纠结于此，拜托。”&lt;/p&gt;&lt;p&gt;最后一句：&lt;/p&gt;&lt;p&gt;&lt;i&gt;&lt;b&gt;“从Python到C++都默认支持非 ASCII 码标识符。这是正确的作为。”&lt;/b&gt;&lt;/i&gt;&lt;/p&gt;&lt;h3&gt;后记&lt;/h3&gt;&lt;p&gt;围绕在英文编程语言中添加对非 ASCII 码命名标识符的支持，类似的论战绝不会是最后一次。就正反双方对立的激烈程度而言，是否前无古人已不重要，只是但愿，再无来者。&lt;/p&gt;&lt;p&gt;因为，这一特性本该成为所有新编程语言的标配，而不需再经过这样的争辩。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>吴烜</author>
<guid isPermaLink="false">2019-11-17-92057476</guid>
<pubDate>Sun, 17 Nov 2019 00:00:00 +0800</pubDate>
</item>
<item>
<title>RFC#2457——Rust语言选择支持非ASCII码标识符在 GitHub 引发的激辩（一）</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2019-11-17-91710113.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/91710113&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7c2deff64ca35378228728485d984eec_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;Everything from Python to C++ supports non-ASCII idents by default. It&amp;#39;s the correct behaviour. —— &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/graydon&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Graydon Hoare&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;2018年10月31日，Rust 语言历史上最受争议的 RFC 之一在经历了将近5个月的争辩和修订后，终于圆满完成。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-15fc2cf0f49487b1a85b3a782da33305_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;983&quot; data-rawheight=&quot;374&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;983&quot; data-original=&quot;https://pic2.zhimg.com/v2-15fc2cf0f49487b1a85b3a782da33305_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-15fc2cf0f49487b1a85b3a782da33305_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;983&quot; data-rawheight=&quot;374&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;983&quot; data-original=&quot;https://pic2.zhimg.com/v2-15fc2cf0f49487b1a85b3a782da33305_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-15fc2cf0f49487b1a85b3a782da33305_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;684条评论，75人参与。虽未亲历，但前事不忘后事之师。此文就来回顾这个 RFC 以及那些激烈💥的声音。&lt;/p&gt;&lt;h2&gt;什么是非 ASCII 码标识符&lt;/h2&gt;&lt;p&gt;ASCII 码问世于20世纪六十年代。标准 ASCII 码只有 128 个，仅包含了英文字符与其他少量标点、运算等特殊符号。多数现今常用的编程语言在上世纪被设计出来时，设计者和使用者也大多数在英文母语国家，因此早期并不支持使用英文之外的语言文字来命名代码中的标识符。&lt;/p&gt;&lt;p&gt;时至今日，有不少国内开发者还认为，在代码中必须用英文命名变量，因此代码中会出现 redEnvelope 甚至 hongbao 这样的命名。&lt;/p&gt;&lt;p&gt;但实际上大多数英文编程语言早已支持使用英文之外的字符命名变量、方法、类名等等。比如 Python3 中完全可以这样写：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;&lt;span class=&quot;n&quot;&gt;红包金额&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;888&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;红包数&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;开销&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;红包数&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;红包金额&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;苹果公司主导的 Swift 编程语言官网的手册中，也用了中文和其他符号进行命名演示：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6dcb1324dee984b4f49e7b951e0020e9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;590&quot; data-rawheight=&quot;193&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;590&quot; data-original=&quot;https://pic2.zhimg.com/v2-6dcb1324dee984b4f49e7b951e0020e9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6dcb1324dee984b4f49e7b951e0020e9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;590&quot; data-rawheight=&quot;193&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; width=&quot;590&quot; data-original=&quot;https://pic2.zhimg.com/v2-6dcb1324dee984b4f49e7b951e0020e9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-6dcb1324dee984b4f49e7b951e0020e9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;此文的主角，RFC#2457 就是为了让 Rust 语言也具备这一特性。&lt;/p&gt;&lt;h2&gt;RFC#2457&lt;/h2&gt;&lt;p&gt;2018 年六月三日 10 点 25 分（太平洋时间）， PR 2457 被 &lt;b&gt;pyfisch&lt;/b&gt; 创建，开始了这个 RFC 的审议过程。&lt;/p&gt;&lt;p&gt;题目很直接：“Allow non-ASCII identifiers”——“允许非 ASCII 标识符”。在它的初稿中，在“动机”部分开篇，指出了“许多开发者的英文并不流利，使用母语命名标识符使得写和读代码更轻松。”&lt;/p&gt;&lt;p&gt;更引用了 Python 语言于 2007 年的 PEP 3131：&lt;/p&gt;&lt;blockquote&gt;Such developers often desire to define classes and functions with names in their native languages, rather than having to come up with an (often incorrect) English translation of the concept they want to name. By using identifiers in their native language, code clarity and maintainability of the code among speakers of that language improves.&lt;br/&gt;（并不熟悉英文语言的）开发者常希望用他们的母语定义类和函数，而不是被逼着用（往往是不正确的）英文翻译来命名一个概念。通过用母语命名标识符，对同一母语的开发者来说，代码清晰度和可维护性得以改进。&lt;/blockquote&gt;&lt;p&gt;RFC 的更多篇幅包含相关的技术细节，有兴趣的可以深究。本文更关注的是 684 个评论中占大多数的对该 RFC 初衷的质疑（尤其是来自于华人开发者的）以及相应回应。&lt;/p&gt;&lt;h2&gt;风波起&lt;/h2&gt;&lt;p&gt;RFC 提交审议的当日下午4 点，一位 Rust 项目参与者 &lt;b&gt;mark-i-m&lt;/b&gt; 提出了首个异议，表示（非 ASCII 码）字符难打以及有时会显示乱码。并在之后用教学经历阐释：有时学生从网上拷贝的代码段中有无法显示的 unicode 字符（其中误称 Java 不支持非 ASCII 码标识符）；有位教授喜欢用希腊字符在 Julia 代码中命名，而 ta 本人输入这样的字符非常麻烦。&lt;/p&gt;&lt;p&gt;接着，一位标示为中国广州的学生 &lt;b&gt;shingtaklam1324&lt;/b&gt; 提出，中文字符会在不支持 unicode 的某些编辑器上变为乱码。&lt;b&gt;pyfisch&lt;/b&gt; 回应：编译器支持 UTF-8编码的源代码文件，修改编辑器设置即可。&lt;/p&gt;&lt;p&gt;四日 10 点，一位 Rust 组织成员 &lt;b&gt;joshtriplett&lt;/b&gt; 提出个人立场：希望标识符命名仅限于 ASCII。他之后发布了一系列跟帖，在七月二十六的总结中，提到他由于源码中出现非 ASCII 码的字符导致各种调试的麻烦，但未给出具体例子。他在四日的一个帖中的发言很有代表性：&lt;/p&gt;&lt;blockquote&gt;It&amp;#39;s a tradeoff between &amp;#34;should people be able to write identifiers in languages that can&amp;#39;t be represented in ASCII&amp;#34; versus &amp;#34;should people be able to read arbitrary code&amp;#34;. Both of those are important, and I don&amp;#39;t want to discount either, but I&amp;#39;d favor the latter.&lt;br/&gt;在“人们能用英文之外的语言写标识符”和“人们能读懂任何代码”之间权衡，虽然两者都很重要，但我更偏向后者。&lt;/blockquote&gt;&lt;p&gt;这种“天下皆（应）会英文”的思维很常见，似乎英文标识符就能被世界上所有人读懂。要知道，世界上有八成多的人口并不会英文。&lt;/p&gt;&lt;p&gt;立刻，来自 Mozilla 的开发者 &lt;b&gt;SimonSapin&lt;/b&gt; 回应：&lt;/p&gt;&lt;blockquote&gt;it is up to the author of a given piece of code to make that choice. It is not our place to dictate what language people should speak or write in contexts we can’t even think of.&lt;br/&gt;这（用母语还是英文命名）应该是代码作者的选择。我们（语言设计者）并不该裁断开发者用什么语言读写代码，尤其是在我们料想不到的场景下。&lt;/blockquote&gt;&lt;p&gt;5 日，&lt;b&gt;Ixrec&lt;/b&gt; 提问：“真的会有人在实用项目代码中用非 ASCII 标识符吗？”他还提到，他是占全世界会日语的 58%的美国男士之一，但他也想不到除了日语在写注释之外的用处。&lt;/p&gt;&lt;p&gt;来自 Mozilla 的 &lt;b&gt;Manishearth&lt;/b&gt; 回应称，代码中看到过一些欧洲语言如葡萄牙文；暂没看到中文或俄语的，但看到过注释中使用。有些日语和葡萄牙语英文化后的代码，可见的确有使用非 ASCII 码命名的需求。另外，中国有个庞大的 Rust 社区，并未与英语 Rust 社区有太多交流。他在中文 Rust 的 QQ 群众征求过相关意见，有几方面收获：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;限于工具，代码中不用中文&lt;/li&gt;&lt;li&gt;有时在新手教程中使用&lt;/li&gt;&lt;li&gt;大多数人不用中文命名&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;他的结论是，至少益处是使得音调可以使用，比如 método。&lt;/p&gt;&lt;p&gt;接下来是来自中国广州的 &lt;b&gt;huangjj27&lt;/b&gt; 指出，输入法切换会降低写代码的效率。不过也提到更多人会因此学 Rust。希望将此特性作为选项，而非标配。&lt;/p&gt;&lt;p&gt;又一位坐标北京的 &lt;b&gt;crlf0710&lt;/b&gt; 表示，大陆主流没有使用非 ASCII 码命名。偶尔用拼音的会被认为不专业。易语言有用户，但并未进入主流。新手教程有用，但也许需要改名关键字，使文字看起来更一致。也希望特性作为用户可选项，而非标配。&lt;/p&gt;&lt;p&gt;又是北京的 &lt;b&gt;ZhangHanDong&lt;/b&gt; 干脆来一句“绝对不要！”&lt;/p&gt;&lt;p&gt;坐标加州的 &lt;b&gt;KiChjang&lt;/b&gt; 表示，一些中国 Rust 用户担心生态被分裂。比如某个库用的语言是用户不知如何输入的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Manishearth&lt;/b&gt; 对此回应&lt;b&gt;：&lt;/b&gt;早已有大量库除了命名之外的所有文档都用非英文编写，比如腾讯的 wepy，他就不会用。用了中文命名之后，也不会更糟。如果一个库流行到有英文文档的程度，很可能那时也会用英文命名了。至于如果库用了不认识的语言，那就——不用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;至此，华人开发者，成为一个批量发声反对此特性成为标配的群体。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;下面，&lt;b&gt;Manishearth&lt;/b&gt; 获得一些葡萄牙 Rust 社区反馈，表示听到不同意见。也得到了一些使用葡萄牙语的代码例子，包括 C++，Java 和 PHP。&lt;/p&gt;&lt;p&gt;来自韩国的 &lt;b&gt;kimhyunkang&lt;/b&gt; 回应 lxrec：之前在韩国公司工作时，看到一些 C++ 和 Java 开发者用英文化的韩语命名，&lt;b&gt;原因是需求文档是韩文写的，而不少术语很难翻译成英文&lt;/b&gt;，因为韩语没有从拉丁文或者希腊文借用的词语，而英语没有从中文借用的词。&lt;b&gt;如果要翻译成英文，命名更长也更不可读。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;est31&lt;/b&gt; 提供了一些使用德文命名的 Java 和 PHP 代码。&lt;/p&gt;&lt;p&gt;来自北京的 &lt;b&gt;3442853561：&lt;/b&gt;工作中不应用（中文命名），但不支持的话会显得 Rust 不合群（很多其他编程语言都支持），也对新手不友好。建议设置为对新手默认使能，老手可关闭。&lt;/p&gt;&lt;p&gt;接下来是来自瑞士的 &lt;b&gt;eggrobin&lt;/b&gt; 以他的用非 ASCII 码和非英文标识符的亲身经历，包括在编写编程书籍的例程中使用法语等等。&lt;/p&gt;&lt;p&gt;欲知后事如何，且听下回分解！&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;【写到这里，已经三个多小时，远远超出了两小时写完的预计。而上面仅仅浏览了前三天内的 20 多个评论，已经有了很多收获。决定分为一个系列进行连载，如期待后文，敬请关注专栏！】&lt;/p&gt;&lt;p&gt;下篇：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/92057476&quot; class=&quot;internal&quot;&gt;RFC#2457——Rust 语言选择支持非 ASCII 码标识符在 GitHub 引发的激辩（二）&lt;/a&gt;&lt;/p&gt;</description>
<author>吴烜</author>
<guid isPermaLink="false">2019-11-17-91710113</guid>
<pubDate>Sun, 17 Nov 2019 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
