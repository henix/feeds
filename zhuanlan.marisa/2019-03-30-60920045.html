<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>PFPL 读书笔记 1 —— 语法对象</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/60920045">原文</a></p>
<div class="title-image"><img src="https://pic1.zhimg.com/v2-7f919b07f53a8fc3dbd8ea7551513998_b.jpg" alt=""></div><h2>前记</h2><p>PFPL，即 Practical Foundations for Programming Languages，是关于编程语言的类型结构和语法表现的一本书。有一定编程经验的人都知道不同的语言有不同的特点。通俗地举例来说，一些语言的变量类型在编写的时候就确定了，而有一些要在运行的时候才知道；有一些语言对变量类型的检查比较“严格”，而有一些则比较“宽松”。继续深入地思考，就会发现它们有很多奇妙的地方。其中似乎有一些规律，但又无法清楚地描述究竟是什么。PFPL 就是一本解释这方面内容的书。</p><p>纸上得来终觉浅，但目前又没有合适的方式让我将其运用到实践中，只好把书上的内容复述一遍，记录下想法，希望能对自己的理解有所帮助。</p><h2>语法对象</h2><p>编程语言是一种语言，它们用于表示计算机和人类都能理解的计算过程。一门编程语言的语法确定了它可以由哪些语句组成。那么这些语句是如何确定的，程序是如何组成的呢？</p><p>当提到语法的时候，可能表示的是几个不同的概念。一个是 <i>表层语法</i>，表示语句是如何输入并展示在计算机上的，通常是一些字符串等形式。而 <i>抽象语法</i> 表示语句之间是如何组合在一起的。从这个层面来说，语法是一颗树，称为 <i>抽象语法树</i>。这种树的节点是运算符，将几个语句组合在一起。另外还有关于标识符的声明和使用的问题，这部分结构称为 <i>绑定</i>。这个层次的语法称为 <i>抽象绑定树</i>，它在 <i>抽象语法树</i> 的基础上增加了绑定和作用域的概念。</p><h2>抽象语法树</h2><p>一棵 <i>抽象语法树</i>（<i>abstract syntax tree</i>，简称为 <i>ast</i>），是一棵有序树。它的叶子节点是 <i>变量</i>，内部节点是 <i>运算符</i>，<i>运算符</i> 的参数是它的子树。Ast 可以分为很多种 <i>类别</i>，表示不同形式的语法。<i>变量</i> 代表特定类别的语法中一个未确定的片段。Ast 可以用 <i>运算符</i> 组合起来。<i>运算符</i> 具有类别和 <i>参数表</i>，<i>参数表</i> 使用类别的有限序列来表示它的参数数量和每个参数的类别。举例来说，如果一个运算符具有类别 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> 和参数表 <img src="https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_n" alt="s_1,…,s_n" eeimg="1"> ，那么它可以将 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"> 个分别属于类别 <img src="https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_n" alt="s_1,…,s_n" eeimg="1"> 的 ast 组合成一个类别 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> 的 ast。如果一个运算符不接受参数，那么称它为 <i>零元</i> 运算符，同理还有 <i>一元</i> 运算符、<i>二元</i> 运算符等等。</p><p>变量在其中是一个很重要的概念。在数学领域，变量一般表示某个作用域下的未知对象（如未知的实数），而在这里变量表示的是某个类别的 ast。因为这是一个未知的量，所以只有在 <i>代换</i> 的时候变量才能获得意义。例如数学中我们可能会将 <img src="https://www.zhihu.com/equation?tex=%5Cpi" alt="\pi" eeimg="1"> 代入 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 计算结果。在 ast 中也是类似的，只需要将一个 ast 中的变量换成另一个 ast 即可。</p><p>举例来说，有一门简单的语言用于表示数字、加法和乘法。它的语法中只有一个类别 Exp，以及一个无限的运算符集合：<img src="https://www.zhihu.com/equation?tex=num%5Bn%5D" alt="num[n]" eeimg="1"> , <img src="https://www.zhihu.com/equation?tex=n+%5Cin+N" alt="n \in N" eeimg="1"> ，包含 Exp 类别的零元运算符， <img src="https://www.zhihu.com/equation?tex=plus" alt="plus" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=times" alt="times" eeimg="1"> 是二元运算符，且参数都是 Exp 类别的。如这个含 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 的表达式 <img src="https://www.zhihu.com/equation?tex=2+%2B+%283+%5Ctimes+x%29" alt="2 + (3 \times x)" eeimg="1"> 可以表示为 ast</p><p><img src="https://www.zhihu.com/equation?tex=plus%28num%5B2%5D%3Btimes%28num%5B3%5D%3B+x%29%29%5C%5C+" alt="plus(num[2];times(num[3]; x))\\ " eeimg="1"> </p><p>如果将 <img src="https://www.zhihu.com/equation?tex=num%5B4%5D" alt="num[4]" eeimg="1"> 代入 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> ，就能得到 ast</p><p><img src="https://www.zhihu.com/equation?tex=plus%28num%5B2%5D%3Btimes%28num%5B3%5D%3B+num%5B4%5D%29%29%5C%5C" alt="plus(num[2];times(num[3]; num[4]))\\" eeimg="1"> </p><p>即表达式 <img src="https://www.zhihu.com/equation?tex=2+%2B+%283+%5Ctimes+4%29" alt="2 + (3 \times 4)" eeimg="1"> 。当然也可以将其它 ast 代入 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 得到更加复杂的结果。</p><p>Ast 的树形结构支持一种非常有用的原则推理，称为 <i>结构归纳</i>。假设我们想证明对于一个类别中所有的 ast， <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> ，都具有性质 <img src="https://www.zhihu.com/equation?tex=+P%28a%29+%E2%80%8B" alt=" P(a) ​" eeimg="1"> ，那么可以考虑所有 <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> 是怎么生成的，并且证明在每种情况下都具有该性质。所以根据刚才对 Exp 的定义，我们需要证明</p><ol><li>所有 Exp 类别的变量 $ x $ 都具有该性质： <img src="https://www.zhihu.com/equation?tex=P%28x%29" alt="P(x)" eeimg="1"> .</li><li>对于所有 <img src="https://www.zhihu.com/equation?tex=+n+%5Cin+N+" alt=" n \in N " eeimg="1"> ， <img src="https://www.zhihu.com/equation?tex=num%5Bn%5D+" alt="num[n] " eeimg="1"> 都具有该性质： <img src="https://www.zhihu.com/equation?tex=+P%28num%5Bn%5D%29" alt=" P(num[n])" eeimg="1"> , <img src="https://www.zhihu.com/equation?tex=+n+%5Cin+N+" alt=" n \in N " eeimg="1">.</li><li>假设 <img src="https://www.zhihu.com/equation?tex=a_1" alt="a_1" eeimg="1"> ， <img src="https://www.zhihu.com/equation?tex=a_2" alt="a_2" eeimg="1"> 都具有该性质，证明 <img src="https://www.zhihu.com/equation?tex=plus%28a_1%3Ba_2%29+" alt="plus(a_1;a_2) " eeimg="1"> ， <img src="https://www.zhihu.com/equation?tex=times%28a_1%3Ba_2%29+" alt="times(a_1;a_2) " eeimg="1"> 都具有该性质：if <img src="https://www.zhihu.com/equation?tex=P%28a_1%29" alt="P(a_1)" eeimg="1"> and <img src="https://www.zhihu.com/equation?tex=P%28a_2%29" alt="P(a_2)" eeimg="1"> , then <img src="https://www.zhihu.com/equation?tex=+P%28plus%28a_1%3Ba_2%29%29" alt=" P(plus(a_1;a_2))" eeimg="1"> and <img src="https://www.zhihu.com/equation?tex=+P%28times%28a_1%3Ba_2%29%29+" alt=" P(times(a_1;a_2)) " eeimg="1"> .</li></ol><p>因为以上过程说明了所有 <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> 的可能性，所以可以证明 <img src="https://www.zhihu.com/equation?tex=P%28a%29" alt="P(a)" eeimg="1"> 对所有 Exp 类别的 ast 成立。</p><p>接下来考虑更加一般的情况。设 <img src="https://www.zhihu.com/equation?tex=S" alt="S" eeimg="1"> 是类别的有限集合， <img src="https://www.zhihu.com/equation?tex=+%5C%7B+O_s+%5C%7D%7Bs+%5Cin+S%7D+" alt=" \{ O_s \}{s \in S} " eeimg="1">是运算符族，其中的运算符 <img src="https://www.zhihu.com/equation?tex=o" alt="o" eeimg="1"> 都属于类别 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> ，参数表为 <img src="https://www.zhihu.com/equation?tex=ar%28o%29+%3D+%28s_1%2C%E2%80%A6s_n%29+" alt="ar(o) = (s_1,…s_n) " eeimg="1"> 。设 <img src="https://www.zhihu.com/equation?tex=%5C%7BX_s%5C%7D_%7Bs+%5Cin+S%7D" alt="\{X_s\}_{s \in S}" eeimg="1"> 为类别 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> 的变量族。那么类别 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> 的 ast 族 <img src="https://www.zhihu.com/equation?tex=A%5BX%5D+%3D+%5C%7BA%5Bx%5D_s%5C%7D_%7Bs+%5Cin+S%7D" alt="A[X] = \{A[x]_s\}_{s \in S}" eeimg="1"> 的定义如下：</p><ol><li>一个类别 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> 的变量是 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> 的一个 ast：if <img src="https://www.zhihu.com/equation?tex=+x+%5Cin+X_s" alt=" x \in X_s" eeimg="1"> , then <img src="https://www.zhihu.com/equation?tex=x+%5Cin+A%5BX%5D_s" alt="x \in A[X]_s" eeimg="1"> .</li><li>运算符可以组合 ast：if <img src="https://www.zhihu.com/equation?tex=o+%5Cin+O_s" alt="o \in O_s" eeimg="1"> , <img src="https://www.zhihu.com/equation?tex=+ar%28o%29+%3D+%28s_1%2C%E2%80%A6s_n%29+" alt=" ar(o) = (s_1,…s_n) " eeimg="1"> and <img src="https://www.zhihu.com/equation?tex=+a_1+%5Cin+A%5BX%5D_%7Bs_1%7D" alt=" a_1 \in A[X]_{s_1}" eeimg="1"> ,…, <img src="https://www.zhihu.com/equation?tex=+a_n+%5Cin+A%5BX%5D_%7Bs_n%7D+" alt=" a_n \in A[X]_{s_n} " eeimg="1"> , then <img src="https://www.zhihu.com/equation?tex=+o%28a_1%3B%E2%80%A6%3Ba_n%29+%5Cin+A%5BX%5D_s" alt=" o(a_1;…;a_n) \in A[X]_s" eeimg="1"> .</li></ol><p>同样地，这个方法也可以用于证明所有 ast 具有性质 <img src="https://www.zhihu.com/equation?tex=P" alt="P" eeimg="1"> 。要证明所有 <img src="https://www.zhihu.com/equation?tex=+a+%5Cin+A%5BX%5D+" alt=" a \in A[X] " eeimg="1"> 具有性质 <img src="https://www.zhihu.com/equation?tex=P%28a%29" alt="P(a)" eeimg="1"> ，只需要证明：</p><ol><li>if <img src="https://www.zhihu.com/equation?tex=x+%5Cin+X_s" alt="x \in X_s" eeimg="1"> , then <img src="https://www.zhihu.com/equation?tex=P_s%28x%29" alt="P_s(x)" eeimg="1"> .</li><li>if <img src="https://www.zhihu.com/equation?tex=+o+%5Cin+O_s" alt=" o \in O_s" eeimg="1"> and <img src="https://www.zhihu.com/equation?tex=+ar%28o%29+%3D+%28s_1%2C%E2%80%A6%2Cs_n%29" alt=" ar(o) = (s_1,…,s_n)" eeimg="1"> , then if <img src="https://www.zhihu.com/equation?tex=+P_%7Bs_1%7D%28a_1%29" alt=" P_{s_1}(a_1)" eeimg="1"> and … and <img src="https://www.zhihu.com/equation?tex=P_%7Bs_n%7D%28a_n%29" alt="P_{s_n}(a_n)" eeimg="1"> , then <img src="https://www.zhihu.com/equation?tex=P_s%28o%28a_1%3B%E2%80%A6%3Ba_n%29%29" alt="P_s(o(a_1;…;a_n))" eeimg="1"> .</li></ol><p>根据上面的原理，我们可以轻松地证明如果 <img src="https://www.zhihu.com/equation?tex=X+%5Csubseteq+Y" alt="X \subseteq Y" eeimg="1"> ，则 <img src="https://www.zhihu.com/equation?tex=A%5BX%5D+%5Csubseteq+A%5BY%5D" alt="A[X] \subseteq A[Y]" eeimg="1"> 。</p><p>如果 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"> 是一个变量族， <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 是一个类别 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> 的变量且 <img src="https://www.zhihu.com/equation?tex=x+%5Cnotin+X_s" alt="x \notin X_s" eeimg="1"> ，那么称 <img src="https://www.zhihu.com/equation?tex=X%2C+x+" alt="X, x " eeimg="1"> 为将 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 邻接于 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"> ，具体含义如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D++X%2Cx+%3D+%5Cbegin%7Bcases%7D++X_i+%5Ccup+%7Bx%7D%26+i%3Ds%5C%5C++X_i%26+i+%5Cneq+s++%5Cend%7Bcases%7D+%5Cquad+i+%5Cin+S++%5Cend%7Bequation%7D+%5C%5C" alt="\begin{equation}  X,x = \begin{cases}  X_i \cup {x}&amp; i=s\\  X_i&amp; i \neq s  \end{cases} \quad i \in S  \end{equation} \\" eeimg="1"> </p><p><i>代换</i> 赋予变量意义。如果 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 是 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> 类别的变量， <img src="https://www.zhihu.com/equation?tex=a+%5Cin+A%5BX%2C+x%5D_%7Bs%27%7D" alt="a \in A[X, x]_{s'}" eeimg="1"> ，且 <img src="https://www.zhihu.com/equation?tex=b+%5Cin+A%5BX%5D_s" alt="b \in A[X]_s" eeimg="1"> ，那么可以将 <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> 中出现的所有 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 使用 <img src="https://www.zhihu.com/equation?tex=b" alt="b" eeimg="1"> 进行代换，记为 <img src="https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da" alt="[b/x]a" eeimg="1"> ，且 <img src="https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da+%5Cin+A%5BX%5D_%7Bs%27%7D" alt="[b/x]a \in A[X]_{s'}" eeimg="1"> 。其中 <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> 被称为 <i>代换目标</i>， <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 被称为 <i>代换项</i>。代换可以定义为以下等式：</p><ol><li><img src="https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Dx+%3D+b+" alt="[b/x]x = b " eeimg="1"> and <img src="https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Dy+%3D+y+%E2%80%8B" alt=" [b/x]y = y ​" eeimg="1"> if <img src="https://www.zhihu.com/equation?tex=x+%5Cneq+y+%E2%80%8B" alt="x \neq y ​" eeimg="1"> .</li><li><img src="https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Do%28a_1%3B%E2%80%A6%3Ba_n%29+%3D+o%28%5Bb%2Fx%5Da1%3B%E2%80%A6%3B%5Bb%2Fx%5Da_n%29+" alt="[b/x]o(a_1;…;a_n) = o([b/x]a1;…;[b/x]a_n) " eeimg="1"> .</li></ol><p>例如 <img src="https://www.zhihu.com/equation?tex=+%5Bnum%5B2%5D%2Fx%5Dplus%28x%3Bnum%5B3%5D%29+%3D+plus%28num%5B2%5D%3Bnum%5B3%5D%29+" alt=" [num[2]/x]plus(x;num[3]) = plus(num[2];num[3]) " eeimg="1"> 。</p><p><b>定理 1.1.</b> 如果 <img src="https://www.zhihu.com/equation?tex=a+%5Cin+A%5BX%2Cx%5D+" alt="a \in A[X,x] " eeimg="1"> ，那么对于每一个 <img src="https://www.zhihu.com/equation?tex=+b+%5Cin+A%5BX%5D+" alt=" b \in A[X] " eeimg="1"> 都存在唯一的 <img src="https://www.zhihu.com/equation?tex=c+%5Cin+A%5BX%5D+" alt="c \in A[X] " eeimg="1"> 且 <img src="https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da+%3D+c+" alt="[b/x]a = c " eeimg="1"> 。</p><p><i>证明：</i>如果 <img src="https://www.zhihu.com/equation?tex=+a+%3D+x" alt=" a = x" eeimg="1"> ，根据定义 <img src="https://www.zhihu.com/equation?tex=b+%3D+c" alt="b = c" eeimg="1"> 。如果 <img src="https://www.zhihu.com/equation?tex=a+%3D+y+%5Cneq+x+" alt="a = y \neq x " eeimg="1"> ，同样根据定义 <img src="https://www.zhihu.com/equation?tex=+y+%3D+c+" alt=" y = c " eeimg="1"> 。否则 <img src="https://www.zhihu.com/equation?tex=a+%3D+o%28a_1%2C%E2%80%A6%2Ca_n%29+" alt="a = o(a_1,…,a_n) " eeimg="1"> ，使用归纳法假设存在 <img src="https://www.zhihu.com/equation?tex=c_1%2C%E2%80%A6%2Cc_n" alt="c_1,…,c_n" eeimg="1"> 使得 <img src="https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Da_1+%3D+c_1" alt=" [b/x]a_1 = c_1" eeimg="1"> , …, <img src="https://www.zhihu.com/equation?tex=%5Bb%2Fx%5Da_n+%3D+c_n" alt="[b/x]a_n = c_n" eeimg="1"> ，那么 <img src="https://www.zhihu.com/equation?tex=+c+%3D+o%28c_1%3B%E2%80%A6%3Bc_n%29+" alt=" c = o(c_1;…;c_n) " eeimg="1"> 。可得对于所有的情况都成立。</p><p>大部分情况下可以提前枚举出所有运算符，但是在一些情况下却不行，有些运算符只能在固定的上下文生效，此时运算符的集合 <img src="https://www.zhihu.com/equation?tex=O" alt="O" eeimg="1"> 不是确定的，所以必须留出扩展性。这时可以将 <i>形式参数</i> 作为运算符族的索引。如有一个零元运算符族 <img src="https://www.zhihu.com/equation?tex=cls%5Bu%5D" alt="cls[u]" eeimg="1"> ，其中 <img src="https://www.zhihu.com/equation?tex=u" alt="u" eeimg="1"> 是 <i>活跃</i> 的形式参数集合中的元素，其中不同的形式参数对应不同的运算符：如果 <img src="https://www.zhihu.com/equation?tex=u" alt="u" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=v" alt="v" eeimg="1"> 是活跃的形式参数且 <img src="https://www.zhihu.com/equation?tex=+u+%5Cneq+v" alt=" u \neq v" eeimg="1"> ，则 <img src="https://www.zhihu.com/equation?tex=cls%5Bu%5D+%5Cneq+cls%5Bv%5D" alt="cls[u] \neq cls[v]" eeimg="1"> 。需要扩展新的运算符时，只需要添加新的形式参数即可。如果 <img src="https://www.zhihu.com/equation?tex=u" alt="u" eeimg="1"> 是不活跃的， <img src="https://www.zhihu.com/equation?tex=+cls%5Bu%5D" alt=" cls[u]" eeimg="1"> 没有意义，但当它活跃时， <img src="https://www.zhihu.com/equation?tex=+cls%5Bu%5D" alt=" cls[u]" eeimg="1"> 就是一个零元运算符。</p><p>形式参数可能会和变量混淆，但它们是根本不相同的两个概念。变量是一个未知的 ast，而形式参数不代表任何东西，它只是用来区分其它的形式参数。我们用 <img src="https://www.zhihu.com/equation?tex=+A%5BU%3BX%5D" alt=" A[U;X]" eeimg="1"> 表示一个 ast 的集合，其中的变量属于集合 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"> ，形式参数属于集合 <img src="https://www.zhihu.com/equation?tex=U" alt="U" eeimg="1"> 。</p><h2>抽象绑定树</h2><p>抽象绑定树（<i>abstract binding tree</i>，简称为 <i>abt</i>）,为 ast 添加了新变量和形式参数的声明，称为 <i>绑定</i>，以及他们的有效范围，称为 <i>作用域</i>，一个绑定的作用域是被绑定的标识符所在的 abt。因此一棵子树的活跃标识符集合可能比外层的集合大，不同的子树也可能会包含不同的标识符。但是所有的标识符都只是一个引用，也就是说选用不同的标识符所表达的含义是一致的，因此我们总是可以给绑定关联一个不同的标识符。</p><p>比如有一个表达式 <img src="https://www.zhihu.com/equation?tex=let+%7E+x+%7E+be+%7E+a_1+%7E+in+%7E+a_2" alt="let ~ x ~ be ~ a_1 ~ in ~ a_2" eeimg="1"> ，声明了一个变量 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 在表达式 <img src="https://www.zhihu.com/equation?tex=a_2+" alt="a_2 " eeimg="1"> 中代表 <img src="https://www.zhihu.com/equation?tex=a_1" alt="a_1" eeimg="1"> ，而 <img src="https://www.zhihu.com/equation?tex=a_1" alt="a_1" eeimg="1"> 中的 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 即使拥有相同的名字，也是不同的变量。相同的绑定更换名字不改变它的含义，如表达式 <img src="https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+x%2Ax+%7E+in+%7E+x+%2B+x+" alt=" let ~ x ~ be ~ x*x ~ in ~ x + x " eeimg="1">与<img src="https://www.zhihu.com/equation?tex=+let+%7E+y+%7E+be+%7E+x%2Ax+%7E+in+%7E+y+%2B+y+" alt=" let ~ y ~ be ~ x*x ~ in ~ y + y " eeimg="1"> 是等价的。而 <img src="https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+y%2Ay+%7E+in+%7E+x+%2B+x+" alt=" let ~ x ~ be ~ y*y ~ in ~ x + x " eeimg="1"> 与前面两个表达式都不同，因为这里的 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"> 代表的可能是外层 abt 中的另一个变量。另外在改变变量命名时不能改变引用的结构，如 <img src="https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+2+%7E+in+%7E+let+%7E+y+%7E+be+%7E+3+%7E+in+%7E+x+%2B+x+" alt=" let ~ x ~ be ~ 2 ~ in ~ let ~ y ~ be ~ 3 ~ in ~ x + x " eeimg="1"> 与 <img src="https://www.zhihu.com/equation?tex=let+%7E+y+%7E+be+%7E+2+%7E+in+%7E+let+%7E+y+%7E+be+%7E+3+%7E+in+%7E+y+%2B+y" alt="let ~ y ~ be ~ 2 ~ in ~ let ~ y ~ be ~ 3 ~ in ~ y + y" eeimg="1"> 所表示的意义不同。后者的 <img src="https://www.zhihu.com/equation?tex=+y+%2B+y" alt=" y + y" eeimg="1"> 中的 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"> 表示的是内部结构的 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"> 而不是外部的。</p><div class="highlight"><pre><code class="language-text"><span></span>let x be 2 in
    let y be 3 in
        x + x

let y be 2 in
    let y be 3 in
        y + y
</code></pre></div><p>Abt 可以给运算符参数绑定有限个变量，记作 <img src="https://www.zhihu.com/equation?tex=x_1%2C%E2%80%A6%2Cx_k.a+" alt="x_1,…,x_k.a " eeimg="1"> 。变量序列 <img src="https://www.zhihu.com/equation?tex=+x_1%2C%E2%80%A6%2Cx_k" alt=" x_1,…,x_k" eeimg="1"> 绑定在 abt <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> 中，当 <img src="https://www.zhihu.com/equation?tex=+k+%3D+0+" alt=" k = 0 " eeimg="1"> 时 <img src="https://www.zhihu.com/equation?tex=.a" alt=".a" eeimg="1"> 可以省略为 <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> 。如表达式 <img src="https://www.zhihu.com/equation?tex=+let+%7E+x+%7E+be+%7E+a_1+%7E+in+%7E+a_2" alt=" let ~ x ~ be ~ a_1 ~ in ~ a_2" eeimg="1"> 写作 abt 就是 <img src="https://www.zhihu.com/equation?tex=let%28a_1%3Bx.a_2%29" alt="let(a_1;x.a_2)" eeimg="1"> 。另外使用 <img src="https://www.zhihu.com/equation?tex=+%5Cvec%7Bx%7D" alt=" \vec{x}" eeimg="1"> 表示有限不重复序列 <img src="https://www.zhihu.com/equation?tex=x_1%2C%E2%80%A6%2Cx_n+" alt="x_1,…,x_n " eeimg="1"> ，所以 <img src="https://www.zhihu.com/equation?tex=x_1%2C%E2%80%A6%2Cx_n.a" alt="x_1,…,x_n.a" eeimg="1"> 也可以写作 <img src="https://www.zhihu.com/equation?tex=+%5Cvec%7Bx%7D.a" alt=" \vec{x}.a" eeimg="1"> 。</p><p>为了表示绑定，abt 中运算符的参数表使用 <i>格</i> 的有限序列表示。这个序列的长度表示参数的数量，其中每个格表示一个参数的类别和绑定的变量类别。一个格用 <img src="https://www.zhihu.com/equation?tex=+%28s_1%2C%E2%80%A6%2Cs_k%29s" alt=" (s_1,…,s_k)s" eeimg="1"> 的形式表示 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 个类别分别为 <img src="https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_k+" alt="s_1,…,s_k " eeimg="1"> 的变量绑定在类别为 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> 的参数上，并且使用 <img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bs%7D" alt="\vec{s}" eeimg="1"> 表示有限序列 <img src="https://www.zhihu.com/equation?tex=s_1%2C%E2%80%A6%2Cs_n" alt="s_1,…,s_n" eeimg="1"> 。如果变量序列 <img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bx%7D" alt="\vec{x}" eeimg="1"> 和类别序列 <img src="https://www.zhihu.com/equation?tex=+%5Cvec%7Bs%7D" alt=" \vec{s}" eeimg="1"> 具有相同的长度，且每个 <img src="https://www.zhihu.com/equation?tex=x_i+" alt="x_i " eeimg="1"> 都属于类别 <img src="https://www.zhihu.com/equation?tex=s_i+" alt="s_i " eeimg="1"> ，那么称 <img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bx%7D" alt="\vec{x}" eeimg="1"> 属于类别 <img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bs%7D" alt="\vec{s}" eeimg="1"> 。举例来说， <img src="https://www.zhihu.com/equation?tex=let" alt="let" eeimg="1"> 运算符的参数表为 <img src="https://www.zhihu.com/equation?tex=+%28%5Ctext%7BExp%7D%2C+%28%5Ctext%7BExp%7D%29%5Ctext%7BExp%7D%29" alt=" (\text{Exp}, (\text{Exp})\text{Exp})" eeimg="1"> ，表示第一个参数是 Exp 类别的且没有绑定的变量，第二个参数是 Exp 类别的且绑定了一个 Exp 类别的变量。表达式 <img src="https://www.zhihu.com/equation?tex=let+%7E+x+%7E+be+%7E+2+%2B+2+%7E+in+%7E+x+%5Ctimes+x+" alt="let ~ x ~ be ~ 2 + 2 ~ in ~ x \times x " eeimg="1"> 写作 abt 是</p><p><img src="https://www.zhihu.com/equation?tex=let%28plus%28num%5B2%5D%3Bnum%5B2%5D%29%3Bx.times%28x%3Bx%29%29%5C%5C" alt="let(plus(num[2];num[2]);x.times(x;x))\\" eeimg="1"> </p><p>设 <img src="https://www.zhihu.com/equation?tex=O" alt="O" eeimg="1"> 是运算符族，其中的运算符 <img src="https://www.zhihu.com/equation?tex=o" alt="o" eeimg="1"> 的参数表为 <img src="https://www.zhihu.com/equation?tex=ar%28o%29" alt="ar(o)" eeimg="1"> 。对于变量族 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"> ，对应的 abt 族 <img src="https://www.zhihu.com/equation?tex=B%5BX%5D" alt="B[X]" eeimg="1"> 的定义与 <img src="https://www.zhihu.com/equation?tex=A%5BX%5D" alt="A[X]" eeimg="1"> 类似，但是它活跃的变量会随着绑定的变量而改变：</p><ol><li>如果 <img src="https://www.zhihu.com/equation?tex=x+%5Cin+X_s" alt="x \in X_s" eeimg="1"> , 则 <img src="https://www.zhihu.com/equation?tex=x+%5Cin+B%5BX%5D_s" alt="x \in B[X]_s" eeimg="1"> .</li><li>如果 <img src="https://www.zhihu.com/equation?tex=ar%28o%29+%3D+%28%28%5Cvec%7Bs_1%7D%29s_1%2C%E2%80%A6%2C%28%5Cvec%7Bs_n%7D%29s_n%29+" alt="ar(o) = ((\vec{s_1})s_1,…,(\vec{s_n})s_n) " eeimg="1"> ， <img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bx_i%7D+" alt="\vec{x_i} " eeimg="1"> 属于类别 <img src="https://www.zhihu.com/equation?tex=+%5Cvec%7Bs_i%7D+" alt=" \vec{s_i} " eeimg="1"> 且 <img src="https://www.zhihu.com/equation?tex=a_i+%5Cin+B%5BX%2C+%5Cvec%7Bx_i%7D%5D_%7Bs_i%7D+" alt="a_i \in B[X, \vec{x_i}]_{s_i} " eeimg="1"> ，则 <img src="https://www.zhihu.com/equation?tex=o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+%5Cin+B%5BX%5D_s+" alt="o(\vec{x_1}.a_1;…;\vec{x_n}.a_n) \in B[X]_s " eeimg="1"> .</li></ol><p>这个定义有一点问题，考虑下面这个 abt： <img src="https://www.zhihu.com/equation?tex=+let%28a_1%3Bx.let%28a_2%3Bx.a_3%29%29" alt=" let(a_1;x.let(a_2;x.a_3))" eeimg="1"> 。根据上面的定义，这个 abt 是不合法的。内层的 abt 在构造的时候引入了变量 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> ，因此变量族从 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"> 变为了 <img src="https://www.zhihu.com/equation?tex=X%2Cx" alt="X,x" eeimg="1"> 。接下来考虑外层的时候，需要把 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 邻接于 <img src="https://www.zhihu.com/equation?tex=X%2Cx" alt="X,x" eeimg="1"> ，这就产生了冲突。因为两个 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 的符号相同，但是表示的意思是不同的。实际上选取不同的变量名不应该造成含义上的区别，因此可以修改第二条定义，考虑重命名变量：</p><p>如果 <img src="https://www.zhihu.com/equation?tex=ar%28o%29+%3D+%28%28%5Cvec%7Bx_1%7D%29s_1%2C%E2%80%A6%2C%28%5Cvec%7Bx_n%7D%29s_n%29+" alt="ar(o) = ((\vec{x_1})s_1,…,(\vec{x_n})s_n) " eeimg="1"> ，且对于每个重命名 <img src="https://www.zhihu.com/equation?tex=%5Cpi_i%3A%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bx_i%27%7D+%7E%7E%7E%7E+%28%24+%5Cvec%7Bx_i%27%7D+%5Cnotin+X+%24%29" alt="\pi_i:\vec{x_i} \leftrightarrow \vec{x_i'} ~~~~ ($ \vec{x_i'} \notin X $)" eeimg="1"> ，都有 <img src="https://www.zhihu.com/equation?tex=+%5Cpi_i+%5Ccdot+a_i+%5Cin+B%5BX%2C%5Cvec%7Bx_i%27%7D%5D+" alt=" \pi_i \cdot a_i \in B[X,\vec{x_i'}] " eeimg="1"> ，则 <img src="https://www.zhihu.com/equation?tex=o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+%5Cin+B%5BX%5D_s+%E2%80%8B" alt="o(\vec{x_1}.a_1;…;\vec{x_n}.a_n) \in B[X]_s ​" eeimg="1"> 。</p><p>这个重命名规则避免了外部的变量和内部的变量冲突的情况。它保证了所有绑定的变量都与外围环境无关。</p><p>类似于 ast，如果需要证明一个性质 <img src="https://www.zhihu.com/equation?tex=P%28a%29%5BX%5D+" alt="P(a)[X] " eeimg="1"> 对于所有的 abt <img src="https://www.zhihu.com/equation?tex=a+%5Cin+B%5BX%5D" alt="a \in B[X]" eeimg="1"> 都成立，那么只需要证明：</p><ol><li>如果 <img src="https://www.zhihu.com/equation?tex=x+%5Cin+X_s" alt="x \in X_s" eeimg="1"> ，那么 <img src="https://www.zhihu.com/equation?tex=+P%5BX%5D_s%28x%29+" alt=" P[X]_s(x) " eeimg="1"> .</li><li>对于任意属于类别 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> ，具有参数表 <img src="https://www.zhihu.com/equation?tex=+%28%5Cvec%7Bs_1%7D%29s_1%2C%E2%80%A6%2C%28%5Cvec%7Bs_n%7D%29s_n+" alt=" (\vec{s_1})s_1,…,(\vec{s_n})s_n " eeimg="1"> 的运算符 <img src="https://www.zhihu.com/equation?tex=o" alt="o" eeimg="1"> ，如果对于每个重命名 <img src="https://www.zhihu.com/equation?tex=%5Cpi_i%3A%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bx_i%27%7D+" alt="\pi_i:\vec{x_i} \leftrightarrow \vec{x_i'} " eeimg="1"> 都有 <img src="https://www.zhihu.com/equation?tex=+P%5BX%2C+%5Cvec%7Bx_i%27%7D%5D_%7Bs_i%7D%28%5Cpi_i+%5Ccdot+a_i%29" alt=" P[X, \vec{x_i'}]_{s_i}(\pi_i \cdot a_i)" eeimg="1"> ，那么 <img src="https://www.zhihu.com/equation?tex=+P%5BX%5D_s%28o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29%29" alt=" P[X]_s(o(\vec{x_1}.a_1;…;\vec{x_n}.a_n))" eeimg="1"> .</li></ol><p>这也是一个归纳性的推理，遵循了上面构造 abt 的过程。举例来说，我们定义一个命题 <img src="https://www.zhihu.com/equation?tex=+x+%5Cin+a+%7E%7E%7E+%28a+%5Cin+B%5BX%2C+x%5D+%29" alt=" x \in a ~~~ (a \in B[X, x] )" eeimg="1"> ，表示 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 在 <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> 中是自由变量。具体来说，它的意思是 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 变量绑定在 <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> 之外，而不是 <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> 内部。那么要证明这个命题只需要说明：</p><ol><li><img src="https://www.zhihu.com/equation?tex=x+%5Cin+x" alt="x \in x" eeimg="1"> .</li><li>如果存在 <img src="https://www.zhihu.com/equation?tex=+1+%5Cle+i+%5Cle+n" alt=" 1 \le i \le n" eeimg="1"> 对于每个重命名 <img src="https://www.zhihu.com/equation?tex=+%5Cpi+%3A+%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bz_i%7D" alt=" \pi : \vec{x_i} \leftrightarrow \vec{z_i}" eeimg="1"> 使得 <img src="https://www.zhihu.com/equation?tex=+x+%5Cin+%5Cpi+%5Ccdot+a_i+" alt=" x \in \pi \cdot a_i " eeimg="1"> ，则 <img src="https://www.zhihu.com/equation?tex=+x+%5Cin+o%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29" alt=" x \in o(\vec{x_1}.a_1;…;\vec{x_n}.a_n)" eeimg="1"> .</li></ol><p>第一个条件说明 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 在 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 本身中是自由的，但是在任何其它的变量中不是自由的。第二个条件表面如果 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 在某个参数中，无论使用那个绑定的变量名称，都是自由的，那么 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 在整个 abt 中是自由的。</p><p>如果两个 abt， <img src="https://www.zhihu.com/equation?tex=a" alt="a" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="b" eeimg="1"> ，无论选取什么绑定变量名都是相同的，则称为 <i>α 等价</i>，记为 <img src="https://www.zhihu.com/equation?tex=a+%3D_%5Calpha+b+" alt="a =_\alpha b " eeimg="1"> 。它的具体定义如下：</p><ol><li><img src="https://www.zhihu.com/equation?tex=+x+%3D_%5Calpha+x+" alt=" x =_\alpha x " eeimg="1"> .</li><li>对于每个 <img src="https://www.zhihu.com/equation?tex=+1+%5Cle+i+%5Cle+n+" alt=" 1 \le i \le n " eeimg="1"> 和所有新的重命名 <img src="https://www.zhihu.com/equation?tex=+%5Cpi_i+%3A+%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bz_i%7D+" alt=" \pi_i : \vec{x_i} \leftrightarrow \vec{z_i} " eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=%5Cpi_i%27%3A%5Cvec%7Bx_i%27%7D+%5Cleftrightarrow+%5Cvec%7Bz_i%7D" alt="\pi_i':\vec{x_i'} \leftrightarrow \vec{z_i}" eeimg="1"> ，都有 <img src="https://www.zhihu.com/equation?tex=+o%28%5Cvec%7Bx_i%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+" alt=" o(\vec{x_i}.a_1;…;\vec{x_n}.a_n) " eeimg="1"> .</li></ol><p>如果 <img src="https://www.zhihu.com/equation?tex=a+%3D_%5Calpha+b" alt="a =_\alpha b" eeimg="1"> ，那么称它们互为 <i>α 变体</i>。</p><p>考虑 abt 中将某个自由变量 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 的 <i>代换</i> 为同类别的 abt，可以粗略地定义为：</p><ol><li><img src="https://www.zhihu.com/equation?tex=%5Bb%2Fx%5D%3Db+" alt="[b/x]=b " eeimg="1"> ， <img src="https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Dy+%3D+y+%7E+%28x+%5Cneq+y%29" alt=" [b/x]y = y ~ (x \neq y)" eeimg="1"> .</li><li>对于每个 <img src="https://www.zhihu.com/equation?tex=+1+%5Cle+i+%5Cle+n" alt=" 1 \le i \le n" eeimg="1"> ，要求 <img src="https://www.zhihu.com/equation?tex=+%5Cvec%7Bx_i%7D+%5Cnotin+b+" alt=" \vec{x_i} \notin b " eeimg="1"> ，且若 <img src="https://www.zhihu.com/equation?tex=+x+%5Cnotin+%5Cvec%7Bx_i%7D+" alt=" x \notin \vec{x_i} " eeimg="1"> ，设 <img src="https://www.zhihu.com/equation?tex=+a_i%27+%3D+%5Bb%2Fx%5Da_i+" alt=" a_i' = [b/x]a_i " eeimg="1"> ，否则设 <img src="https://www.zhihu.com/equation?tex=+a_i%27+%3D+a_i+" alt=" a_i' = a_i " eeimg="1"> ，那么 <img src="https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Do%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29" alt=" [b/x]o(\vec{x_1}.a_1;…;\vec{x_n}.a_n)" eeimg="1"> .</li></ol><p>从第二个条件可以看出，如果 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 绑定于某个参数中，那么参数中的 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 不会进行代换，因为这两个 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 的含义是不同的，所以需要判断是否 <img src="https://www.zhihu.com/equation?tex=x+%5Cnotin+%5Cvec%7Bx_i%7D+" alt="x \notin \vec{x_i} " eeimg="1"> 。同样地， <img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bx_i%7D+%5Cnotin+b" alt="\vec{x_i} \notin b" eeimg="1"> 也是为了保证代换后的变量不会与原来的绑定变量发生冲突，造成含义的混淆。如果这两个条件不都成立，那么这个代换是没有定义的。为了解决这种没有定义的问题，可以在条件中添加新的重命名的设定。我们知道对于任意新的重命名 <img src="https://www.zhihu.com/equation?tex=+%5Cpi_i+%3A+%5Cvec%7Bx_i%7D+%5Cleftrightarrow+%5Cvec%7Bx_i%27%7D+" alt=" \pi_i : \vec{x_i} \leftrightarrow \vec{x_i'} " eeimg="1"> ，代换 <img src="https://www.zhihu.com/equation?tex=%5Bb%2Fx%5D+%28%5Cpi_i+%5Ccdot+a_i%29+" alt="[b/x] (\pi_i \cdot a_i) " eeimg="1"> 都是合法的。所以对于选定的新的重命名，我们可以定义</p><p><img src="https://www.zhihu.com/equation?tex=+%5Bb%2Fx%5Do%28%5Cvec%7Bx_1%7D.a_1%3B%E2%80%A6%3B%5Cvec%7Bx_n%7D.a_n%29+%3D+o%28%5Cvec%7Bx_1%27%7D.%5Bb%2Fx%5D+%28%5Cpi_1+%5Ccdot+a_1%29%3B%E2%80%A6%3B%5Cvec%7Bx_n%27%7D.%5Bb%2Fx%5D+%28%5Cpi_n+%5Ccdot+a_n%29%29%5C%5C" alt=" [b/x]o(\vec{x_1}.a_1;…;\vec{x_n}.a_n) = o(\vec{x_1'}.[b/x] (\pi_1 \cdot a_1);…;\vec{x_n'}.[b/x] (\pi_n \cdot a_n))\\" eeimg="1"> </p><p>这样我们就不需要关注 <img src="https://www.zhihu.com/equation?tex=x+%5Cnotin+%5Cvec%7Bx_i%7D+" alt="x \notin \vec{x_i} " eeimg="1"> 这个条件了，因为通过重命名可以保证这个条件的成立。另外，我们也可以通过选择一个不包含冲突变量名的 α 变体作为代换目标，这样就可以安全地进行代换。换句话说，abt 的代换是定义在整个 α 等价类上的。为了避免绑定带来的其它问题，我们将所有 α 等价的 abt 看成是相同的。也就是说所有对于 abt 的讨论都针对整个 α 等价类，而非某个 abt 本身。因此当我们研究一个 abt 时，只需要选择一个具有代表性的 abt，而不用关系它的变量名。</p><p>和变量类似，形式参数也可以绑定在运算符的参数上。为了表示形式参数，我们把格扩展为 <img src="https://www.zhihu.com/equation?tex=%28%5Cvec%7Bs_1%7D%3B%5Cvec%7Bs_2%7D%29s" alt="(\vec{s_1};\vec{s_2})s" eeimg="1"> ，表示类别为 <img src="https://www.zhihu.com/equation?tex=+s_1+" alt=" s_1 " eeimg="1"> 的形式参数和类别为 <img src="https://www.zhihu.com/equation?tex=s_2" alt="s_2" eeimg="1"> 的变量绑定在类别为 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1"> 的参数上。Abt 族 <img src="https://www.zhihu.com/equation?tex=+B%5BU%3BX%5D+" alt=" B[U;X] " eeimg="1"> 的形式参数来源于集合 <img src="https://www.zhihu.com/equation?tex=U" alt="U" eeimg="1"> ，变量来源于集合 <img src="https://www.zhihu.com/equation?tex=X" alt="X" eeimg="1"> 。按照习惯，用 <img src="https://www.zhihu.com/equation?tex=u" alt="u" eeimg="1"> , <img src="https://www.zhihu.com/equation?tex=v" alt="v" eeimg="1"> 表示形式参数，用 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> , <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"> 表示变量。</p><h2>总结</h2><p>这部分介绍了语法的基本概念，将 <i>表层语法</i> 和 <i>抽象语法</i> 进行了区分。在抽象语法中又分为仅包含语句结构的 <i>抽象语法树</i> 和包含标识符定义和作用域的 <i>抽象绑定树</i>，并提出了相关的定义和定理。其中运用了大量的归纳法，从定义出发按照构造的过程对一些定义进行了说明。这部分是后面更为深入的内容的基础，需要熟悉里面的符号表示并理解概念。</p><p>区分这几个不同层次的概念可以帮助我们更好地理解语法结构，也能够知道在遇到什么问题时要从什么地方下手。如重构代码时，需要保证重命名前后的变量在语义上保持一致，且不与其它的变量名产生冲突。这部分涉及到变量的绑定问题，就需要从 abt 层面进行解决。以 JavaScript 为例，@babel/parser 可以将代码转化为 ast，但根据刚刚的分析，仅仅根据这个是很难帮助我们完成重命名的操作的。这时候可以借助 @babel/traverse 遍历 ast，在遍历的过程中能够访问到当前节点的作用域以及绑定等信息，这样就有了更多的信息，可以保证重命名前后语法的一致性。</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
