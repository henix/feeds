<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>用密码学代替法官玩狼人杀 -- 闲聊乱码电路</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/25986848">原文</a></p>
<div class="title-image"><img src="https://pic2.zhimg.com/v2-4a3d7eb4b99fcc7fe1398e82eb9ccd6d_r.jpg" alt=""></div>在今天的文章里，我们结合最近大火的狼人杀游戏，介绍姚期智老师在安全多方计算领域的开山神作 -- <b>乱码电路</b>。在看完本文之后，你会知道用乱码电路，不用法官也能玩狼人杀！<br><h2>乱码电路 </h2><p><b>安全多方计算 </b>是姚期智老师在80年代提出的一个概念。假设甲有数字<img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1">，乙有数字 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1">，他们在不向对方披露自己数字的情况下，共同计算一个二元函数 <img src="https://www.zhihu.com/equation?tex=f%28x%2Cy%29" alt="f(x,y)" eeimg="1">。乱码电路 [1] 是姚老师对安全多方计算的经典解决方案。下面我们来简单介绍一下它是如何实现的。</p><br><h2>预处理：将函数转换成电路</h2><p>首先，我们需要将函数转化成布尔电路。布尔电路概念其实很简单，由一些线路（wire）和一些门（gate) 组成。每条线路上面输送一个比特，也就是0或者1。而门有与门（AND），非门（NOT），或门（OR）等等。门的作用是把两个输入比特变成一个输出比特，而门上的具体逻辑由<b>真值表 </b>给出。例如XOR门的真值表长这个样子<b>：</b></p><img src="https://pic3.zhimg.com/50/v2-e562312d5fbde4058048345a3678c326_b.png" data-rawwidth="162" data-rawheight="145" class="content_image" width="162"><p>通常使用的所有函数都可以用布尔电路来表示。例如狼人杀中，法官判断守卫是否守中人，就是在执行一个相等函数：假设 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 和<img src="https://www.zhihu.com/equation?tex=y%0A" alt="y
" eeimg="1"> 是整数，代表狼刀玩家和守卫守护玩家的编号。如果 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1">等于<img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1">，那么输出1（守卫守中人），否则输出0（没有守中）。对应的布尔电路见下图，为了简单起见，我们假设 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1">和<img src="https://www.zhihu.com/equation?tex=y%0A" alt="y
" eeimg="1">是0到3之间的整数。</p><br><img src="https://pic1.zhimg.com/50/v2-a217d7ff2cf9de6e2d3be42db57a23b8_b.png" data-rawwidth="1188" data-rawheight="724" class="origin_image zh-lightbox-thumb" width="1188" data-original="https://pic1.zhimg.com/50/v2-a217d7ff2cf9de6e2d3be42db57a23b8_r.png"><h2>步骤一：将电路乱码化</h2><p>好的, 现在我们jiA-一个布尔电路。但是怎样让在乙不知道甲的输入的情况下，还能执行电路，得到结果呢？姚老师的绝妙想法是：对电路中的每一条线路进行加密！在上面的电路中，每条线路上有一个比特--0或者1。而在乱码电路中，对于<b>每条线路</b>，甲选取两个随机的<b>标签</b><img src="https://www.zhihu.com/equation?tex=k_0%2C+k_1" alt="k_0, k_1" eeimg="1"> 来代表这个线路上的值。即<img src="https://www.zhihu.com/equation?tex=k_0%0A" alt="k_0
" eeimg="1">对应0，<img src="https://www.zhihu.com/equation?tex=k_1" alt="k_1" eeimg="1">对应1。</p><p>这样，乙就不知道线路上实际的比特是什么了，但是糟糕的是：由于线路上都是乱码，乙要怎么执行这个电路呢？解决方法简单而奇妙，对于每个电路中的门，甲建立一个对应于真值表的<b>乱码真值表</b>。我们以XOR门为例，来看看乱码真值表是怎么写出来的。 </p><p>假设XOR的两条输入线路对应的标签是分别是<img src="https://www.zhihu.com/equation?tex=A_0%2C+A_1%2C+B_0%2C+B_1." alt="A_0, A_1, B_0, B_1." eeimg="1"> 而输出线路的标签是<img src="https://www.zhihu.com/equation?tex=C_0%2C+C_1." alt="C_0, C_1." eeimg="1"> 为了建立乱码真值表，甲首先把XOR真值表中的比特转换成对应的标签，于是真值表就变成了下面的样子。。。</p><img src="https://pic2.zhimg.com/50/v2-571616ca98ed9b85e41645359eaf0691_b.png" data-rawwidth="710" data-rawheight="255" class="origin_image zh-lightbox-thumb" width="710" data-original="https://pic2.zhimg.com/50/v2-571616ca98ed9b85e41645359eaf0691_r.png">现在关键的步骤来了，对于表中的每一行，甲依次用两个输入标签作为<b>密钥</b>，对输出标签进行<b>加密</b> 。以第一行为例，见下图<img src="https://pic2.zhimg.com/50/v2-8e4290f336609937c0d5dfc16046b81d_b.png" data-rawwidth="1812" data-rawheight="520" class="origin_image zh-lightbox-thumb" width="1812" data-original="https://pic2.zhimg.com/50/v2-8e4290f336609937c0d5dfc16046b81d_r.png"><p>这样，得到的乱码真值表的每一行都包含两个输入标签，和一个加密过的输出标签。</p><p>最后，甲把生成的所有乱码真值表（每个门一个），和自己的输入值对应的标签一同发送给乙。有了这些乱码真值表和输入标签，乙就可以执行电路运算了。</p><h2>步骤二： 忘性传输（Oblivious Transfer）</h2><p>我们刚才有意忽略了一个问题，多方计算中，不光甲有输入，乙也是有输入的啊。那么乙怎么获得跟自己的输入值对应的标签呢？ 当然，她不能直接向甲要求标签，因为这样的话，甲立刻就知道她的输入值了。解决的方法，是使用一个叫做 <b>忘性传输( OT ) </b>的协议。由于篇幅关系，我们只讲忘性传输的功能，而不细讲如何实现了。在 OT协议开始时， 甲拥有两个文件<img src="https://www.zhihu.com/equation?tex=F_0" alt="F_0" eeimg="1">，<img src="https://www.zhihu.com/equation?tex=F_1%0A" alt="F_1
" eeimg="1">，乙想获得其中的一个文件。协议完成之后，乙会得到他所选择的文件，但是甲不知道乙获得的是哪个文件。</p><p>不得不说，OT又是密码学的又一项令人瞠目的黑科技。。。我们先回到乱码电路：乙只需要对自己的每个输入比特和甲执行一次OT协议，就可以得到对应的标签了！而根据OT的定义，甲是不知道乙要求的是哪个标签的，这样就保护了乙的隐私。<br></p><h2>步骤三：执行乱码电路</h2><p>现在乙有了乱码真值表和输入标签，她要如何执行电路呢？ 对于每个门，乙都拥有四个输入标签中的两个，所以她只需要用这两个标签来解密乱码真值表的第三列，就可以得到对应的输出标签。乙就可以这样一步步执行所有的门，得到最终结果。在执行完所有门后。乙得到输出值对应的标签， 并把这些标签告诉甲，由甲来公布最后的明文输出值，协议完成！</p><br><p>我们回顾一下这个协议是怎么保护隐私的。甲的隐私是由标签和加密保护的。由于所有标签都是甲随机选取的字符串，而字符串和比特之间的对应只有甲知道，所以乙只能“盲目执行”这个乱码电路。无论是甲的输入，还是电路执行过程中的中间结果，乙都一无所知。而乙的隐私是由上面的忘性传输来保护。</p><h2>------------------------ 分割线 ------------------------------</h2><h2>狼人杀可以不用法官玩吗</h2><p>狼人杀游戏是一种信息不完全的博弈，安全多方计算可以应用。首先，我们来想一想为什么玩狼人杀需要法官。在白天法官的行动是公开的，所以任何玩家都可以在白天充当法官。晚上，法官说的话都是一样的， 所以可以用预先准备好的录音来代替。那么法官真正的关键功能在哪里呢？没错，是<b>对玩家的隐私输入进行计算 。</b>例如守卫守人的过程<b>，</b>要知道有没有守中人，必须得有一个人（法官）同时知道守人和刀人的信息，但是按照规则，任何玩家都无权得到这两份信息。所以是不可以用一个玩家来代替法官的。</p><p>但是！用上面所述的密码学协议，我们可以仅通过玩家们互相之间的计算，来代替法官。在把乱码电路应用到狼人杀上之前，我们先需要解决两个问题。</p><p>第一，我们可能需要计算参与者得到不同的输出，在上面狼人－守卫的例子里，输出是对双方公开的，所以没有这个问题。然而如果是狼人－预言家进行计算的话，预言家会知道他选验的人是否是狼，而狼人是不知道预言家晚上有没有查到狼的，所以就需要多方计算的每一方有不同的输出。而上面的协议稍加修改后，是可以计算两个函数，把一个结果给甲，第二个给乙的。这里就不谈细节了。</p><p>第二，乱码电路解决的是两方计算问题，而在狼人杀中，我们需要的是所有玩家同时参与计算，不然玩家的身份就暴露了。所以我们的协议也需要做相应的修改，来处理参与计算人数大于2的情形。这里略去细节~</p><h2>用多方计算代替法官</h2><p>先回顾一下法官在夜晚进行的活动[3]  --- </p><p>１. 守卫睁眼，比手势告知法官守谁。<br></p><p>２. 狼人睁眼，狼人睁眼相互确认同伴，狼人比号码，狼人闭眼。</p><p>３. 预言家睁眼以手势号码告知法官验几号，法官以手势回应，预言家闭眼。</p><p>４. 女巫睁眼，如当晚无人死亡或解药已用，法官摇手表示无人死亡，并且不告知女巫谁被杀。如有人被杀死，法官用手势号码告诉女巫刚才狼人杀死的是谁。法官都说“昨晚死的是他，你要救吗？”，女巫以点头摇头表示，然后法官说“你要毒人吗”，女巫以点头和摇头表示，如点头，以手势告知法官要毒的是谁。女巫闭眼。</p><p>从上面的流程中，我们可以提炼出法官需要做的三个计算：给预言家信息，给女巫信息，计算出当晚谁死去。为了简单起见，我们做一个假设：<b>所有玩家均遵循游戏规则，不会背离协议</b>。在此基础上，我们把狼人杀晚上的活动解释为三轮的多方计算，然后就可以轻松实现了。</p><p>第一轮输入：所有人输入自己的身份牌。在此基础上，狼人 -- 输入要杀的人的编号 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1">, 守卫 -- 输入要守的人的编号 <img src="https://www.zhihu.com/equation?tex=s" alt="s" eeimg="1">, 预言家 -- 输入验人编号 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1">，女巫 -- 输入解药是否已用。已经死亡的角色输入-1。</p><p>第一轮输出：向预言家输出验人信息，向女巫输出死亡信息，其他所有人输出为-1。 计算验人信息的函数是 ： 如果玩家 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"> 是狼，输出1；否则输出0。 输出死亡信息的函数是，如果女巫已经使用解药或者没有人死亡(<img src="https://www.zhihu.com/equation?tex=k%3D-1" alt="k=-1" eeimg="1"> 或 <img src="https://www.zhihu.com/equation?tex=k%3D+s" alt="k= s" eeimg="1">)，那么女巫输出0。否则女巫输出 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1">。</p><p>第二轮输入： 女巫 -- 输入是否使用解药 <img src="https://www.zhihu.com/equation?tex=j" alt="j" eeimg="1">（如果没有解药则女巫输入-1），以及毒药使用对象编号 <img src="https://www.zhihu.com/equation?tex=d" alt="d" eeimg="1">（如果没有毒药，输入-1）。其他所有人输入为空。 </p><br>第二轮输出（白天）：向所有人输出死亡玩家的编号，以及游戏是否结束的信息。死亡玩家的计算方法为 [被毒的玩家] 和[被刀，且没有被救或被守的玩家] （为叙述简单起见，我们不考虑同守同救的情况）。用伪代码表示就是<p>                            死亡玩家 = <img src="https://www.zhihu.com/equation?tex=d" alt="d" eeimg="1"> if( <img src="https://www.zhihu.com/equation?tex=k+%3D+s" alt="k = s" eeimg="1"> or <img src="https://www.zhihu.com/equation?tex=j+%3D+1" alt="j = 1" eeimg="1"> or <img src="https://www.zhihu.com/equation?tex=k+%3D+-1" alt="k = -1" eeimg="1">); else <img src="https://www.zhihu.com/equation?tex=%28k%2C+d%29%0A" alt="(k, d)
" eeimg="1">。</p><p>计算游戏是否结束：如存活玩家 （= 参与计算玩家 减去 死去玩家）里没有狼人，那么好人胜利。狼人胜利的判断条件随规则而变，这里就留给大家练习了。<br></p><p>其他问题<br></p><p>在多方计算的应用中还会遇到各式各样的问题。例如我们需要考虑到玩家恶意违背规则，以及多个玩家共谋来坑害其他玩家的情形。这就需要对乱码电路的协议再进行修改，来惩罚或者揭露违背规则的玩家。今天就不展开谈了。最后留一道思考题。各位下回再见～</p><p>思考题：<i>在乱码电路协议中，一个步骤是对“标签真值表”的输出列加密两次，这是必要的吗?</i><br></p><br><h2>参考文献</h2><br>[1] Yao, Andrew Chi-Chih. "How to generate and exchange secrets." <i>Foundations of Computer Science, 1986., 27th Annual Symposium on</i>. IEEE, 1986<br><p>[2] Rosulek, Mike. "Secure Your Data and Compute on It, Too." <i>XRDS: Crossroads, The ACM Magazine for Students</i> 21.3 (2015): 36-41.</p><p>[3] <a href="https://link.zhihu.com/?target=http%3A//fanwen.wenku1.com/article/30754744.html" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">fanwen.wenku1.com/artic</span><span class="invisible">le/30754744.html</span><span class="ellipsis"></span><i class="icon-external"></i></a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
