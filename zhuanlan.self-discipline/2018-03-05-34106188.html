<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Emacs之魂（三）：列表，引用和求值策略</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/34106188">原文</a></p>
<h2><b>回顾</b></h2><p>上文我们介绍了Emacs的用法，发现一分钟学会使用它并不是难事，<br>而且，我们没有让快捷键束缚住，因为Emacs的精髓在于Emacs Lisp中。</p><p>本文我们开始探讨Emacs Lisp，不过在这之前我们还要先熟悉一下Lisp的特点和Lisp家族的成员，<br>随后本文重点分析和介绍了列表，引用和求值策略，<br>这几个概念，尤其是引用，对学习者来说非常容易引起困惑，<br>本文采用了不同的角度来描述这些概念。</p><h2><b>1. 强大的Lisp</b></h2><img src="https://pic2.zhimg.com/v2-ed3328dd316a5def2a30193901d87fab_r.jpg" data-caption="" data-size="normal" data-rawwidth="533" data-rawheight="353"><p>1960年，John McCarthy发表了一篇计算机领域的<a href="https://web.archive.org/web/20131004232653/http://www-formal.stanford.edu/jmc/recursive.pdf">文章</a>，这是一篇“惊世之作”，<br>它的作用简直就像欧几里得《<a href="https://zh.wikipedia.org/wiki/%E5%87%A0%E4%BD%95%E5%8E%9F%E6%9C%AC">几何原本</a>》对几何学的贡献一样。<br>John McCarthy只用了一些简单的的运算符和函数，构建出了一门<a href="https://en.wikipedia.org/wiki/Turing_completeness">图灵完备</a>的编程语言，<br>称之为<a href="https://en.wikipedia.org/wiki/Lisp">Lisp</a>，Lisp是列表处理（List Processing）的简称。<br>这门语言的关键思想是，不论代码还是数据，都用统一的数据结构（列表）进行表示。</p><p>Lisp语言具有很强的表达能力，我们可以用更少的代码做更多的事情。<br>通常而言，语言具有表达能力就必须提供丰富的内置功能和强大的扩展性。</p><p>语言的内置功能指的是语言默认提供的功能，它能减少程序员的重复劳动，帮助他们快速完成工作。<br>语言的扩展性，指的是当语言内置功能不能满足需要的时候，程序员可以怎样做。<br>同时具有丰富的功能和强大的扩展性是很困难的，这需要在语言的设计阶段就考虑好，<br>语言的内置功能越多，就会越复杂，扩展功能的与内置功能的一致性就很难被保证。</p><p>现代的高级编程语言，离不开编译器和解释器，<br>编译器将高级语言的代码转换成更底层的语言，例如C语言或者汇编，<br>解释器提供了一个运行时环境，直接解释执行高级语言的源代码。</p><p>一般而言，编译器是由语言的开发商提供的，使用者并不会参与到编译器的开发工作之中，<br>如果想要在语言中支持一等函数（first-class function），就必须让语言的开发商改写编译器，<br>如果需要增加新的类似if-else的控制结构，或者让语言支持面向对象编程，也要改写编译器才行。<br>因此，语言支持什么功能，以及源代码被如何编译，完全取决于开发商。</p><p>而Lisp语言则不同，它允许程序员对编译器进行编程，（<a href="https://en.wikipedia.org/wiki/Metaprogramming">元编程</a><br>Lisp程序员可以决定代码被如何编译甚至如何被读取，像是半个编译器的开发者一样。</p><h2><b>2. Lisp-1和Lisp-2</b></h2><p>Lisp语言构成了一个家族，具有成百上千种方言，<br>用的最多的几种是，Common Lisp，Scheme，Racket，和Emacs Lisp。<br>其中<a href="http://www.schemers.org/">Scheme</a>的目标是简洁，<a href="https://common-lisp.net/">Common Lisp</a>提供了强大的工业级支持，<br><a href="https://racket-lang.org/">Racket</a>提供了一种创造语言和设计实践的平台，<a href="https://www.gnu.org/software/emacs/manual/elisp.html">Emacs Lisp</a>主要用于Emacs中。</p><img src="https://pic2.zhimg.com/v2-99b4245a059b33e76b3c79d0b9d296bc_r.jpg" data-caption="" data-size="normal" data-rawwidth="559" data-rawheight="268"><p>Emacs Lisp更像Common Lisp，它们都是<a href="https://en.wikipedia.org/wiki/LISP_2">Lisp-2</a>，<br>即同一个符号在不同的上下文中，可以分别用来表示变量和函数，<br>而Scheme和Racket则只能用来表示同一个实体，称为Lisp-1。</p><p>出现Lisp-2，主要是因为有效率方面的考虑，<br>在Lisp-2中，函数和变量分属不同的名字空间，在不同的环境中，由不同的求值器进行处理。<br>这样做也使语义更加复杂了，以后的文章中，我们会介绍Emacs Lisp中符号（Symbol）的概念。</p><h2><b>3. 列表对象和它的文本表示</b></h2><p>列表是Lisp语言中一种常用的数据结构，用来表示一批数据。<br>例如，由整数<code class="inline">1</code>，<code class="inline">2</code>和<code class="inline">3</code>构成的列表对象，Lisp会将它打印为，<code class="inline">(1 2 3)</code>。<br>各个列表元素用空格分隔，用圆括号括起来。</p><p>然而，在Lisp代码中直接写<code class="inline">(1 2 3)</code>，并不会创建一个列表对象，<br>因为Lisp程序也是用括号方式表示的，例如，<code class="inline">(+ 1 2)</code>表示对整数<code class="inline">1</code>和<code class="inline">2</code>进行加法运算。</p><p>那么如何才能创建一个列表对象呢？<br>我们需要调用<code class="inline">list</code>函数，<code class="inline">(list 1 2 3)</code>，这段代码将会创建一个由整数<code class="inline">1</code>，<code class="inline">2</code>和<code class="inline">3</code>构成的列表对象，<br>这个列表对象打印为<code class="inline">(1 2 3)</code>。</p><p>注意，以上我们严谨的区分了Lisp对象和它的打印结果，<br>是因为对象和它的文本表示（textual representation）是不同的概念。</p><p>例如，在C语言中我们写，</p><code lang="c">int result = 1 + 2;</code><p>我们实际上是用“1”表示了整数<code class="inline">1</code>，“1”只是一段文本，是印刷符号，而整数<code class="inline">1</code>是一个数学对象，<br>同样的，“+”是一段文本，它表示了加法运算符。</p><p>在Lisp语言中，我们用文本来写程序，而Lisp读取器得到的是Lisp对象，<br>经过对这些Lisp对象进行计算，得到了计算结果，也是一个Lisp对象，<br>最终，反馈给我们的是这个对象的文本表示。</p><img src="https://pic3.zhimg.com/v2-dc38e4a71fa145cbd6f9dfff6fb25188_r.jpg" data-caption="" data-size="normal" data-rawwidth="468" data-rawheight="366"><h2><b>4. 字面量和引用</b></h2><p>在Lisp中，我们用文本“1”可以直接表示整数<code class="inline">1</code>，用“#t”表示真值，<br>类似的“1”和“#t”，称之为对象的字面量表示（literal representation）。</p><p>其它语言中，也提供了广泛的字面量表示法，例如，JavaScript提供了数组和对象字面量，</p><code lang="js">const obj = {
    x: 1,
    y: [2, 3, 4]
};</code><p>这段代码创建了一个JavaScript <code class="inline">Object</code>，它的<code class="inline">x</code>属性值是<code class="inline">1</code>，<code class="inline">y</code>属性值是一个数组。<br>字面量表示法，使得我们不必调用<code class="inline">new Object</code>和<code class="inline">new Array</code>来创建它。</p><p>Lisp中列表对象用的非常多，每次都使用<code class="inline">list</code>函数来创建是一件麻烦的事情，<br>因此，Lisp语言提供了列表对象的字面量写法，我们只需要调用<code class="inline">quote</code>就可以了。</p><code lang="emacs">(quote (1 2 3))</code><p>以上Lisp代码会创建一个打印形式为<code class="inline">(1 2 3)</code>的列表对象。</p><img src="https://pic2.zhimg.com/v2-e99ff21ef98ac1ca9ecbd36880c0c5b4_r.jpg" data-caption="" data-size="normal" data-rawwidth="556" data-rawheight="334"><p>对于嵌套列表，使用<code class="inline">quote</code>是非常方便的，</p><code lang="emacs">(quote (1 (2 3) ((4 5) (6 7))))</code><p>像这样创建列表的方式，称为引用（quoting），<br>这不同于按引用调用（call by reference）中的“引用”（reference）。</p><p><code class="inline">quote</code>还有一个便捷的写法，就是用单引号来表示它，<code class="inline">(quote (1 2 3))</code>可以表示为，</p><code lang="emacs">'(1 2 3)</code><p>我们只需要在列表前加一个单引号即可，因为列表的右括号表明了它在引用这个列表。</p><h2><b>5. quote和list</b></h2><p>值得一提的是，引用并不保证每次都会重新创建列表。</p><p>例如，在Emacs Lisp中我们使用<code class="inline">defun</code>创建函数，</p><code lang="emacs">(defun foo ()
    '(1 2 3))</code><p>然后，用以下方式进行函数调用，注意<code class="inline">foo</code>参数个数为0个，</p><code lang="emacs">(foo)</code><p>多次调用<code class="inline">foo</code>，编译器可能返回同一个列表对象。</p><p>而<code class="inline">list</code>则不同，每次调用它会返回一个全新的列表对象，</p><code lang="emacs">(defun foo ()
    (list 1 2 3))</code><h2><b>6. 求值策略</b></h2><p>Lisp代码是由表达式构成的，Lisp程序的执行过程就是表达式的求值过程，</p><code lang="emacs">(* (+ 1 2) (+ 3 4))</code><p>以上表达式的求值结果为<code class="inline">21</code>。</p><img src="https://pic4.zhimg.com/v2-801a08365d845657db004290d09c44d3_r.jpg" data-caption="" data-size="normal" data-rawwidth="547" data-rawheight="281"><p>在程序的列表表示法中，从左到右位于第一个位置的元素，是比较特殊的，<br>它表示一个函数（function），一个宏（macro），或者一个内置的特殊命令（special form）。<br>位于其他位置的元素称为参数。</p><p>函数被调用的时候，它的每个参数都必须首先被求值，<br>例如，以上程序中<code class="inline">*</code>，<code class="inline">+</code>都是函数，<br>在调用乘法函数<code class="inline">*</code>时，它的参数<code class="inline">(+ 1 2)</code>和<code class="inline">(+ 3 4)</code>都首先要被求值，分别求值为<code class="inline">3</code>和<code class="inline">7</code>，<br>然后再进行乘法运算，结果为<code class="inline">21</code>。</p><p>而宏和内置的特殊命令，并不要求如此，它们有自己的对参数的求值策略。</p><p>其中“1”称之为自求值对象，对它进行求值将得到它本身，</p><code lang="emacs">1
(eval 1)
(eval (eval 1))</code><p>其结果都为<code class="inline">1</code>，其它的自求值对象还包括布尔值，字符串，向量，等等。<br><code class="inline">(+ 1 2)</code>中<code class="inline">1</code>和<code class="inline">2</code>之前没有<code class="inline">quote</code>，是因为它们是自求值对象，<code class="inline">(+ '1 '2)</code>和<code class="inline">(+ 1 2)</code>的计算结果是相等的。</p><h2><b>7. 在Emacs中求值表达式</b></h2><p>Emacs可以直接求值文本中的Lisp代码，我们只需要将光标定位到列表尾部，<br>然后按快捷键<code class="inline">C-x C-e</code>即可。（指的是按<code class="inline">Ctrl+x</code>，然后再按<code class="inline">Ctrl+e</code> </p><img src="https://pic1.zhimg.com/v2-b6e5134cdbf76fc3f2656b42cbd0c103_r.jpg" data-caption="" data-size="normal" data-rawwidth="642" data-rawheight="595"><p>我们还可以试试<code class="inline">quote</code>和自求值对象，<code class="inline">1</code>求值为<code class="inline">1</code>，<code class="inline">'1</code>求值为<code class="inline">1</code>。</p><p>然而<code class="inline">''1</code>却求值为<code class="inline">(quote 1)</code>，是因为<code class="inline">''1</code>实际是<code class="inline">(quote (quote 1))</code>，<br>它表示用字面量方式创建了一个形如<code class="inline">(quote 1)</code>的列表对象。</p><p>下文，我们来讨论Emacs Lisp的控制结构和基本的数据类型，<br>使用Lisp编程是一件有趣的事情。</p><hr><h2><b>参考</b></h2><p><a href="http://languagelog.ldc.upenn.edu/myl/ldc/llog/jmc.pdf">The Roots of Lisp</a> <br><a href="https://book.douban.com/subject/3704991/">Land of Lisp</a> <br><a href="https://book.douban.com/subject/1456904/">Lisp in small pieces</a> <br><a href="https://book.douban.com/subject/1432501/">An Introduction to Programming in Emacs Lisp</a> <br><a href="https://www.gnu.org/software/emacs/manual/elisp.html">GNU Emacs Lisp Reference Manual</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
