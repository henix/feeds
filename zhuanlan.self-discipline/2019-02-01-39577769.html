<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>设计模式奏鸣曲（七）：依赖管理</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/39577769">原文</a></p>
<p></p><figure><noscript><img src="https://pic1.zhimg.com/v2-2520a9e764b1e552afc9c142470093b8_b.jpg" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="1080" class="origin_image zh-lightbox-thumb" width="1920" data-original="https://pic1.zhimg.com/v2-2520a9e764b1e552afc9c142470093b8_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-2520a9e764b1e552afc9c142470093b8_b.jpg" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="1080" class="origin_image zh-lightbox-thumb lazy" width="1920" data-original="https://pic1.zhimg.com/v2-2520a9e764b1e552afc9c142470093b8_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-2520a9e764b1e552afc9c142470093b8_b.jpg"></figure><h2><b>1. 系统</b></h2><p><b>系统</b>（system）是人们常用的术语，<br>常见的系统，包括财务系统，计算机系统，血液循环系统，等等，<br>它为我们描述、理解、划分和分析组织中的现象，提供了有用的框架。</p><blockquote>系统的概念，就本质而言是一定环境中一类为达到某种目的，而相互联系、相互作用的事物有机集合体。<br>——《<a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/1666873/" class=" wrap external" target="_blank" rel="nofollow noreferrer">信息系统开发方法</a>》</blockquote><p>系统中各组成要素之间存在着密切的<b>联系</b>，这种联系决定了整个系统的性质。<br>系统内部的要素本身，也可能构成了一个较小的<b>子系统</b>，<br>一个系统也可能包含在更大的系统中，这称之为系统的<b>层次性</b>。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-f482952eafe6c99428dcda72151a6365_b.jpg" data-caption="" data-size="normal" data-rawwidth="464" data-rawheight="260" class="origin_image zh-lightbox-thumb" width="464" data-original="https://pic2.zhimg.com/v2-f482952eafe6c99428dcda72151a6365_r.jpg"></noscript><img src="https://pic2.zhimg.com/v2-f482952eafe6c99428dcda72151a6365_b.jpg" data-caption="" data-size="normal" data-rawwidth="464" data-rawheight="260" class="origin_image zh-lightbox-thumb lazy" width="464" data-original="https://pic2.zhimg.com/v2-f482952eafe6c99428dcda72151a6365_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-f482952eafe6c99428dcda72151a6365_b.jpg"></figure><p>计算机科学中的<b>面向对象编程</b>，构建了一个<b>对象系统</b>。</p><p>Smalltalk的设计者之一<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Alan_Kay" class=" wrap external" target="_blank" rel="nofollow noreferrer">Alan Kay</a>，<br>在答复<a href="http://link.zhihu.com/?target=http%3A//userpage.fu-berlin.de/%7Eram/pub/pub_jf47ht81Ht/doc_kay_oop_en" class=" wrap external" target="_blank" rel="nofollow noreferrer">Meaning of "Object-Oriented Programming"</a>的邮件中提到了，</p><blockquote>I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages.</blockquote><p>Alan Kay将对象（object）类比为生物学中的细胞，计算过程通过对象之间交换信息来完成。</p><h2><b>2. 依赖</b></h2><p>系统中个组成要素之间可能具有<b>依赖关系</b>，<br>某一部分改变了，其它部分可能会受到影响。</p><p>在面向对象的软件系统中，过多的依赖，意味着系统更<b>脆弱</b>。</p><figure><noscript><img src="https://pic4.zhimg.com/v2-a6d153e8dd927ca768a7181b666ecc9f_b.jpg" data-caption="" data-size="normal" data-rawwidth="700" data-rawheight="391" class="origin_image zh-lightbox-thumb" width="700" data-original="https://pic4.zhimg.com/v2-a6d153e8dd927ca768a7181b666ecc9f_r.jpg"></noscript><img src="https://pic4.zhimg.com/v2-a6d153e8dd927ca768a7181b666ecc9f_b.jpg" data-caption="" data-size="normal" data-rawwidth="700" data-rawheight="391" class="origin_image zh-lightbox-thumb lazy" width="700" data-original="https://pic4.zhimg.com/v2-a6d153e8dd927ca768a7181b666ecc9f_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-a6d153e8dd927ca768a7181b666ecc9f_b.jpg"></figure><p>有两个测量指标，可用于衡量系统中各要素之间的依赖情况，<br>分别称为<b>传入耦合</b>（afferent coupling）与<b>传出耦合</b>（efferent coupling），<br>它们反映了系统架构的可维护性问题。</p><p>要么对象对其他太多对象负有责任——高传入耦合，<br>要么这个对象不够独立于其他对象——高传出耦合。</p><p>修改一个高传入耦合的对象，是有风险的，依赖该对象的其他对象，都有可能受到影响。<br>而具有高传出耦合的对象，则更容易受到系统中其它变更的影响。</p><blockquote>传入耦合高的对象会造成破坏，传出耦合高的配件则会受到破坏。</blockquote><p>我们可以用以下公式，计算系统中每个对象的<b>不稳定性</b>，<br>其中，<code>1</code>表示不稳定，<code>0</code>表示稳定。</p><div class="highlight"><pre><code class="language-text"><span></span>不稳定性 = 传出耦合 / (传出耦合 + 传入耦合)
</code></pre></div><h2><b>3. 兼容</b></h2><figure><noscript><img src="https://pic3.zhimg.com/v2-806c0c80c6ceb7387c79492c5f5da00e_b.jpg" data-caption="" data-size="normal" data-rawwidth="679" data-rawheight="198" class="origin_image zh-lightbox-thumb" width="679" data-original="https://pic3.zhimg.com/v2-806c0c80c6ceb7387c79492c5f5da00e_r.jpg"></noscript><img src="https://pic3.zhimg.com/v2-806c0c80c6ceb7387c79492c5f5da00e_b.jpg" data-caption="" data-size="normal" data-rawwidth="679" data-rawheight="198" class="origin_image zh-lightbox-thumb lazy" width="679" data-original="https://pic3.zhimg.com/v2-806c0c80c6ceb7387c79492c5f5da00e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-806c0c80c6ceb7387c79492c5f5da00e_b.jpg"></figure><p>一般而言，依赖是由自身进行管理的，<br>但是，自身被哪些对象所依赖，是不可控的。<br>因此，我们应该尽可能进行<b>兼容更新</b>。</p><blockquote>兼容更新：这些更新中会新增接口，所有先前可用的接口仍保持不变。<br>不兼容更新：这些更新会更改现有接口，使此接口的现有用户操作失败或不正确地执行操作。<br>—— <a href="http://link.zhihu.com/?target=https%3A//docs.oracle.com/cd/E24847_01/html/E22196/chapter5-90363.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">接口兼容性</a></blockquote><p>兼容更新，遵循了<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%25E5%25BC%2580%25E9%2597%25AD%25E5%258E%259F%25E5%2588%2599" class=" wrap external" target="_blank" rel="nofollow noreferrer">开闭原则</a>，<br>即，软件中的对象（类，模块，函数等等），应该对于扩展是开放的，但是对于修改是封闭的。</p><figure><noscript><img src="https://pic1.zhimg.com/v2-8441f4e15502b7b231c2671c87bdb154_b.jpg" data-caption="" data-size="normal" data-rawwidth="700" data-rawheight="390" class="origin_image zh-lightbox-thumb" width="700" data-original="https://pic1.zhimg.com/v2-8441f4e15502b7b231c2671c87bdb154_r.jpg"></noscript><img src="https://pic1.zhimg.com/v2-8441f4e15502b7b231c2671c87bdb154_b.jpg" data-caption="" data-size="normal" data-rawwidth="700" data-rawheight="390" class="origin_image zh-lightbox-thumb lazy" width="700" data-original="https://pic1.zhimg.com/v2-8441f4e15502b7b231c2671c87bdb154_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-8441f4e15502b7b231c2671c87bdb154_b.jpg"></figure><p>保持兼容性的另一个办法是，对<b>反向依赖</b>进行管理，<br><a href="https://zhuanlan.zhihu.com/p/35929167" class="internal">超大型 JavaScript 应用的设计哲学</a>，这篇文章中提到了一些实践，</p><blockquote>如果你 enhance 一个模块，你会让这个模块对你产生依赖。</blockquote><h2><b>4. 版本</b></h2><p>在进行软件开发的时候，我们都希望依赖是稳定的，<br>如果在开发时，测试时，或者在用户使用时，系统的依赖都是不同的，<br>那就很难保证功能的<b>稳定性</b>。</p><p>除此之外，很多软件系统并不是运行在源代码之上的，<br>而是运行在“目标代码”之上，<br>源代码经过编译，构建，或者打包，最终生成了可“执行”的目标代码。</p><p>我们期望，不同时期对源代码进行的任一次构建，<br>都应当生成<b>同样的</b>一份目标代码，至少也应具有<b>相同的功能</b>，<br>特别是当依赖项是通过网络进行传输的时候。</p><figure><noscript><img src="https://pic2.zhimg.com/v2-85f333015f28d5798135ab73a8162989_b.jpg" data-caption="" data-size="normal" data-rawwidth="188" data-rawheight="268" class="content_image" width="188"></noscript><img src="https://pic2.zhimg.com/v2-85f333015f28d5798135ab73a8162989_b.jpg" data-caption="" data-size="normal" data-rawwidth="188" data-rawheight="268" class="content_image lazy" width="188" data-actualsrc="https://pic2.zhimg.com/v2-85f333015f28d5798135ab73a8162989_b.jpg"></figure><p>添加版本号，是一个不错的主意，<br>但是，每一次升级，都必须让<b>所有用户</b>更新依赖项才会生效，<br>于是人们提出了<a href="http://link.zhihu.com/?target=https%3A//semver.org/lang/zh-CN/" class=" wrap external" target="_blank" rel="nofollow noreferrer">语义化版本</a>的概念。</p><p>语义化版本是一个约定，<br><b>被认为是</b>兼容性的变更，会在下一次构建中自动生效，<br>而<b>被认为是</b>非兼容性的变更，则需要用户手动更新依赖。</p><h2><b>结语</b></h2><p>本文讨论了系统中各要素之间的<b>依赖</b>，以及对依赖进行管理所衍生出来的问题，<br>增加依赖可能会减少重复，但也会让系统变得更脆弱。</p><p>为依赖项添加版本号是一个好习惯，<br>因为不添加意味着总是使用<b>最新</b>的版本。</p><p>最后，现阶段进行<b>反向依赖管理</b>仍然是困难的，<br>这使得我们不得不坚持开闭原则，<br>改动一个已发布的功能，其<b>影响范围</b>是不可控的。</p><hr><h2><b>参考</b></h2><p><a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Compatibility" class=" wrap external" target="_blank" rel="nofollow noreferrer">Compatibility</a><br><a href="http://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DZZmUwXEiPm4" class=" wrap external" target="_blank" rel="nofollow noreferrer">Malte Ubl - Designing very large JavaScript applications</a><br><a href="https://zhuanlan.zhihu.com/p/35929167" class="internal">超大型 JavaScript 应用的设计哲学</a><br><a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/1666873/" class=" wrap external" target="_blank" rel="nofollow noreferrer">信息系统开发方法</a><br><a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/2580604/" class=" wrap external" target="_blank" rel="nofollow noreferrer">持续集成</a><br><a href="http://link.zhihu.com/?target=https%3A//semver.org/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Semantic Versioning</a><br></p><hr><p>下一篇：<a href="https://zhuanlan.zhihu.com/p/40075765" class="internal">设计模式奏鸣曲（八）：要不要相信类型</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
