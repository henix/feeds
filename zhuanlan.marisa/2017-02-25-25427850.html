<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Curry Howard Isomorphism -&gt; (Leibniz Equality * Programming By Refinement)</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/25427850">原文</a></p>
<p>Abstract：这文章旨意用Coq介绍一下Leibniz Equality，并慢慢引出Curry Howard Isomorphism。</p><p>前置知识：Haskell</p><p>首先，一些设置： </p><code lang="haskell">{-# LANGUAGE MonomorphismRestriction, Rank2Types #-}

module Main (
    main
) where
import Prelude hiding(EQ)

main :: IO ()
main = return ()
</code><p>会给出一定的Haskell代码以辅助理解Coq。<br></p><br><code lang="coq">Set Implicit Arguments.
Set Universe Polymorphism.
</code><p>第零行开启Coq中的隐式参数。</p><p>第一行开启了Universe Polymorphism，详情见<a href="http://adam.chlipala.net/cpdt/html/Universes.html" data-editable="true" data-title="Universes" class="">Universes</a>，<a href="https://coq.inria.fr/news/128.html" class="" data-editable="true" data-title="The Coq Proof Assistant">The Coq Proof Assistant</a>，<a href="https://www.zhihu.com/question/55594352/answer/145387977" data-editable="true" data-title="Girard悖论是什么？ - 雾雨魔理沙的回答 - 知乎" class="">Girard悖论是什么？ - 雾雨魔理沙的回答 - 知乎</a>。不知道这是啥不会影响你的阅读。<br></p><p>当我们认为两个Type相等的时候，我们在说什么？</p><p>Monad的创始人（雾，此Monad非彼Monad，不过玄乎程度有过之而不及）Leibniz给出了一个很优雅的解释：当A=B的时候，如果一个命题为真，把里面的任意A替换成B，依然为真。用更formal的话说， </p><code lang="text">Given any x and y, x = y if and only if, given any predicate P, P(x) if and only if P(y).
</code><p>-<a href="https://en.wikipedia.org/wiki/Equality_(mathematics)" data-editable="true" data-title="Equality (mathematics)" class="">Equality (mathematics)</a><br></p><p>用代码表示，就是： <br></p><code lang="coq">Definition EQ (x y: Type) := forall (p: Type -&gt; Type), ((p x -&gt; p y) * (p y -&gt; p x)). (*这是Comment*) (*为了方便阅读，p x y都显式地标出了类型。*)
</code><p>换成haskell代码，这是：</p><code lang="haskell">newtype EQ x y = EQ {unEQ :: forall p. (p x -&gt; p y, p y -&gt; p x)} 
</code><p>你现在也许在困惑：什么叫做‘用代码表示一个命题’？</p><p><b>我们不严谨的定义是：如果一个类型有值，当且仅当一个命题是定理，这个类型表示这个命题。这时候，这个类型的值就表示了这个命题的证明。</b></p><p>相对应的，如果一个命题不是定理，这个命题对应的定理就没有值-换句话说，同构于bottom type，一个没有任何constructor的type。<br></p><p>我们现在看看，我们这段代码‘代不代表’Leibniz给出的Equality（简称Leibniz Equality）。</p><p>假设“P(x)当且仅当P(y)”。</p><p>现在有两种情况：P(x)，P(y)皆为定理，或皆不是定理。</p><p>如果是前者，p x，p y都有值（我们可以构造出p x, p y）。所以，我们可以通过忽略传进来的参数，构造出p x -&gt; p y, p y -&gt; p x。然后，我们可以构造出p x -&gt; p y跟p y -&gt; p x的pair。</p><p>如果是后者，p x，p y都同构于bottom type。但是我们可以从bottom type得出一切-如果没明白什么回事，这样想：如果要从有两constructor的sum type返回一个类型A的值，需要进行pattern match，对得出的两个case皆返回A。如果要从有一个constructor的top type返回一个类型A的值，需要进行pattern match，对得出的一个case返回A。如果要从有零个constructor的bottom type返回一个类型A的值，需要进行pattern match，对得出的零个case返回A-而因为只需要对零个case进行操作，什么也不需要做，换句话说我们可以无条件得出A。从另一个角度来想，这是因为我们永远不可能构造出bottom type的值，所以当bottom type作为参数的时候，这个函数永远不可能被调用，自然可以返回随便啥（包括另一个bottom）。<br></p><p>我们现在假设EQ x y有值。</p><p>如果如此，当p x有值，换句话说P(x)为真的时候，我们可以通过调用p x -&gt; p y得出p y也有值，换句话说P(y)也为真。 反之亦然。<b>顺着这条路想想，我们发现，如果类型x对应命题X，y对应Y，类型x -&gt; y对应X imply Y：给我一个X的证明，我能给你一个Y的证明。相似的，(x * y)对应X and Y：X的证明在左边，Y的证明在右边。x + y则对应或：x有证明，或者y有证明。Bottom Type跟Top Type则分别对应False, True，而x -&gt; bottom则对应not x。这几个都很明显，自己试试看。</b><br></p><p>所以我们可以认为这个EQ代表了Leibniz Equality。</p><p>我们现在试下证明EQ是reflexive，symmetric，transitive的吧。</p><p>首先，reflexive的证明：</p><img src="https://pic3.zhimg.com/v2-2a3113202f881c5d46d00179c28b44d6_r.png" data-rawwidth="1082" data-rawheight="123"><p>当我们敲下“EQRefl x: EQ x x.”的时候，由于我们没有给出定义，Coq进入了一个特殊的模式（见右边那奇怪的东西），辅助我们找出证明。这里，-----上面的是我们已知的东西，下面是我们要证明的东西。这只是在说：已知x是一个类型，你需要构造出EQ x x - 我们漏掉没证明的东西。</p><p><img src="https://pic4.zhimg.com/v2-f3d343b0cedda0e2919ef003c5f91900_r.png" data-rawwidth="1149" data-rawheight="131"> 我们在这个奇怪的mode（叫proof-editing mode）中输入了unfold EQ，命令Coq把EQ展开成定义。于是Coq表示：你需要证明出，对于所有p，(p x -&gt; p x) * (p x -&gt; p x)。</p><p><img src="https://pic3.zhimg.com/v2-a9df8f20c87b12387a7678fce804baa8_r.png" data-rawwidth="1080" data-rawheight="390">我们做了两件事：我们先用“intros p.”引入p这个假设。</p><p>然后我们用“Show Proof.”打印出Coq给我们生成的EQRefl。</p><p>引入p后，我们只需要证明p x -&gt; p x跟p x -&gt; p x，只需要两个id就能证出来了。</p><p>下面打印的是EQRefl。由于我们还没证明完EQRefl，有一个叫?Goal的东西存在：这代表我们剩下的Goal（或者说，subgoal），为右上角的东西。</p><p>这个完成了一半的EQRefl有一个参数，p : Type -&gt; Type，就是上面刚刚引入的p。<b>引入假设，相当于lambda abstraction。</b></p><p><img src="https://pic1.zhimg.com/v2-4a9ed648553731de1ec4b82bc240aaf5_r.png" data-rawwidth="1082" data-rawheight="403">然后，我们用refine直接给出((p x -&gt; p x) * (p x -&gt; p x))。当Coq遇到fun px =&gt; _中的_的时候，并不知道如何处理，于是接着想为我们要求给出_的值。用refine，我们可以从Coq中的proof-editing-mode跳到带_的普通mode。</p><p><b>这些各种各样的命令，都旨在对Show Proof产生的partial term发生影响，并且使之更具体，所以这样编程就叫Programming By Refinement。 </b><br></p><p>最后剩下的，很简单-就在假设中，我们用intuition让Coq自动帮我们填入。</p><p>最后，用Defined完成这个证明。</p><p>相对应的Haskell代码是，</p><code lang="text">eqRefl :: EQ x x
eqRefl = EQ (id, id)
</code><p>然后下一个。 <br></p><p><img src="https://pic1.zhimg.com/v2-a6aa964113331eaff395999629b929c3_r.png" data-rawwidth="962" data-rawheight="401">我们先想想可以怎么证明EQSym吧。</p><p>首先，我们有EQ x y，所以对于出现在任意地方的x，我们可以转成y，也可以y转x。</p><p>然后，我们可以生成EQ x x。</p><p>所以，我们只需要把EQ x x的第一个x改成y，就可以。</p><p><img src="https://pic3.zhimg.com/v2-5f10c1e21b7049213c4a1cf6cc7a70ec_r.png" data-rawwidth="1167" data-rawheight="341">我们把第一个EQ unfold掉，剩下的不动，然后用intros引入所有可以引入的假设。;代表把两个命令串联在一起。<br></p><p><img src="https://pic2.zhimg.com/v2-021eeedb64b802dd17776598c3729361_r.png" data-rawwidth="1339" data-rawheight="498">我们指定X的p是(fun h =&gt; EQ h x)，换句话说，我们要把第一个EQ x x的x变成y。</p><p>Show Proof.中，出现了一个let X0 := X (fun h =&gt; EQ h x)，就是specialize后的X。<b>把一个定理变成更特殊的形式，就是定死一个参数。</b></p><p><img src="https://pic4.zhimg.com/v2-2fed6a30f822ea41c8dde5fa913381be_r.png" data-rawwidth="1340" data-rawheight="485">既然X是个pair，就由两部分构成，我们就可以对之进行case analysis，对于每一个constructor C，假设存在参数x0 x1...，并假设X = x0 x1，由于只有一个case，就会给出这个pair的左右两边。在“普通”Coq中，这是let (e, e0) := X0。<b>case analysis就是pattern matching。</b></p><p><img src="https://pic1.zhimg.com/v2-a95efd845486b63e82c33144f8e63d9d_r.png" data-rawwidth="1330" data-rawheight="482">然后，因为e: EQ x x -&gt; EQ y x，所以，我们倒着推理，如果我们需要EQ y x，我们只需要找到EQ x x则可。我们用apply完成这一任务。这是e ?Goal。<b>使用implication就是函数调用。</b></p><p><img src="https://pic1.zhimg.com/v2-eda18b095bfca78230b42e498ce5c001_r.png" data-rawwidth="1185" data-rawheight="516">我们再apply以前证明过的定理，EQRefl，结束证明（你没想错，这也只是函数调用）</p><code lang="haskell">newtype EQSwap x y = EQSwap {unEQSwap :: EQ y x}
eqSym :: EQ x y -&gt; EQ y x
eqSym (EQ x) = unEQSwap $ fst x $ EQSwap eqRefl
</code><p>然后，我们证明EQTrans。具体思路挺简单，我们把EQ x y的y换成z。</p><p>我们先unfold并intros。</p><p><img src="https://pic1.zhimg.com/v2-305c6f4de0a08b08d1a52595ade29963_r.png" data-rawwidth="1086" data-rawheight="526">specialize一次。。。</p><p><img src="https://pic1.zhimg.com/v2-5b039dca5f281bc7806c229bbf62dfd9_r.png" data-rawwidth="1098" data-rawheight="599">然后用intuition帮我们做。</p><code lang="haskell">eqTrans :: EQ x y -&gt; EQ y z -&gt; EQ x z
eqTrans xy (EQ (yz, _)) = yz xy
</code><p>Proof Editing Mode的一个好处是，我们可以通过元编程（或者调用已有的命令），使得Coq自动帮我们证明类型，不需要什么都自己来。</p><p>然后，Coq自己标准库里面也有一个equality，“=”。我们可以用eq_refl创造x = x，并，给出H: x = y，可以用rewrite H把出现的x变成y。</p><p><img src="https://pic3.zhimg.com/v2-a3aeec6dda2a9ce9c507f72e15d44007_r.png" data-rawwidth="956" data-rawheight="612">我们“证明” EQ x y imply x = y。这下，我们直接给出证明，不进入proof editing mode：对于一个x = x，我们改写第二个x。你可以看到，证明只是一个普通的类型的值。</p><p><img src="https://pic1.zhimg.com/v2-4e27c80e949cdec8c8880166b8012c4e_r.png" data-rawwidth="949" data-rawheight="644">我们最后证明另一边。跟前面一样，我们直接给出定义。但是，跟以前不一样的是，我们用ltac:(LTAC)在定义中让Coq去进入某种意义上的proof editing mode，并且用LTAC证明整个Goal：LTAC用rewrite把EQ x y改写成EQ y y，然后用EQRefl。用ltac:，我们能在普通mode进入proof editing mode（technically不是，不过为了简化问题，可以暂时这样认为），用refine，我们可以在proof editing mode中进入普通mode，两个互相连接，获得了生命的大和谐。</p><p>至于Leibniz Equality比Coq默认的好在那？这个可以用在Scala中，在Haskell中不需要GADT支持，<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.193.1552" class="" data-editable="true" data-title="psu.edu 的页面">Typing Dynamic Typing</a>也是用的这。</p><p>PS：EQ的两个参数不一定是Type，但是为了跟Haskell版对应就这么做了。</p><p>同时，这些代码比对应的HS代码长很多，因为这是在展示CH同构，而不是用最简单的方法做事。</p><p>并且，发现我们只用了左边的转换了吗？其实<br></p><code lang="coq">forall (p: Type -&gt; Type), ((p x -&gt; p y) * (p y -&gt; p x))</code><code lang="coq">forall (p: Type -&gt; Type), (p x -&gt; p y)</code><code lang="coq">x = y</code><p>三者等价。可以自己用纸跟笔试试看，或者在Haskell中证明前两个一样。 <br></p><p>最后：这个文章很不严谨，只是引起兴趣作用，Coq/CH同构都没介绍多少，有兴趣的话，最好看看下列的文章。<br></p><p>Future Reading:</p><p>Curry Howard Isomorphism:</p><p><a href="http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf" class="" data-editable="true" data-title="Propositions as Types">Propositions as Types</a><br></p><p><a href="http://www.dcc.fc.up.pt/~nam/aulas/0405/tia/lectures-on-the-curry.pdf" data-editable="true" data-title="Lectures on The Curry Howard Isomorphism" class="">Lectures on The Curry Howard Isomorphism</a></p><p>Coq:</p><p><a href="https://www.cis.upenn.edu/~bcpierce/sf/current/index.html" class="" data-editable="true" data-title="Software Foundations">Software Foundations</a></p><p>顺带打个广告，有个Coq的QQ群，372347110<br></p><p>Leibniz Equality:<br></p><p><a href="http://okmij.org/ftp/Computation/extra-polymorphism.html#injectivity" data-editable="true" data-title="Leibniz equality can be made injective" class="">Leibniz equality can be made injective</a></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
