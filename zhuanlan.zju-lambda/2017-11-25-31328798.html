<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lens: 从入门到再次入门</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/31328798">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-28c51979d43ba132a98057d07b183025_b.jpg" alt=""></div><h2>类型补全计画</h2><p>从上一篇我们可以看出，Lens 就是整合在一起的 <code>Getter</code>和 <code>Setter</code>，借助<code>set</code><i>, </i><code>over</code><i>, </i><code>view</code>这三个函数，我们可以分别使用 Lens 的<code>Getter</code>和<code>Setter</code>。但是我们目前的 Lens 类型定义并不是完整的，因此我们首先对 Lens 的类型进行补全。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Lens</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">s</span><span class="p">)</span>
</code></pre></div><p>首先让我们看这样一个例子： </p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">set</span> <span class="n">_1</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span> <span class="mi">3</span>
<span class="nf">set</span> <span class="n">_1</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span> <span class="kt">True</span>
</code></pre></div><p>在我们目前的类型定义上面的代码第一行可以正常工作，而第二行则不可以。但是第二行确实是合乎逻辑的，我们的确有时候需要讲一个原本是数字的地方设置为布尔值或是其他的什么东西。</p><p>让我们将原先的 Lens 类型定义进行简单的改变，这样就可以在通过 Lens 对数据操作时改变数据的类型。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Lens</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span>
</code></pre></div><p>我们可以可以直观地解读这个新的类型定义的含义，对<code>s</code>类型的量的一个<code>a</code>类型的域进行某种操作，之后该域变为<code>b</code>，相应的<code>s</code>变为<code>t</code>。当然这里的<code>s</code>与<code>t</code>的关系并不是随意的，而是依赖于<code>a</code>和<code>b</code>的关系。</p><p>现在我们之前使用的 Lens 类型将定义如下：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Lens'</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Lens</span> <span class="n">s</span> <span class="n">s</span> <span class="n">a</span> <span class="n">a</span>
<span class="c1">-- Or</span>
<span class="cm">{-# LANGUAGE LiberalTypeSynonyms #-}</span>
<span class="kr">type</span> <span class="kt">Simple</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b</span>
<span class="kr">type</span> <span class="kt">Lens'</span> <span class="ow">=</span> <span class="kt">Simple</span> <span class="kt">Lens</span> 
</code></pre></div><p>在这个定义下我们可以定义出由<code>getter</code>与<code>setter</code>构建 Lens 的函数</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">lens</span> <span class="ow">::</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Lens</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span>
<span class="nf">lens</span> <span class="n">getter</span> <span class="n">setter</span> <span class="n">f</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">setter</span> <span class="n">s</span> <span class="o">&lt;$&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">getter</span> <span class="n">s</span><span class="p">)</span>
</code></pre></div><p>下面让我们来回忆一下<code>over</code>与<code>view</code>的定义</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">over</span> <span class="n">lens</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">runIdentity</span> <span class="o">.</span> <span class="n">lens</span> <span class="p">(</span><span class="kt">Identity</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
<span class="nf">view</span> <span class="n">lens</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">getConst</span> <span class="o">$</span> <span class="n">lens</span> <span class="kt">Const</span> <span class="n">b</span> 
</code></pre></div><p>我们发现在<code>f</code>分别取<code>Identity</code>与<code>Const</code>的时候，Lens 就分别表现出了 <code>Setter</code>与<code>Getter</code>的特性。对于<code>view</code>与<code>over</code>而言，他们只需要使用单一的 Functor ，因此我们可以专门定义<code>Getter</code>与<code>Setter</code>的类型。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Getting</span> <span class="n">r</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Const</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="kt">Const</span> <span class="n">r</span> <span class="n">s</span>
<span class="kr">type</span> <span class="kt">Setter</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Identity</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="kt">Identity</span> <span class="n">t</span>
<span class="kr">type</span> <span class="kt">Setting</span> <span class="ow">=</span> <span class="kt">Simple</span> <span class="kt">Setter</span> 
</code></pre></div><p>在有了这个定义之后，我们就可以修改之前三个常用函数的类型签名：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">view</span> <span class="ow">::</span> <span class="kt">Getting</span> <span class="n">a</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">over</span> <span class="ow">::</span> <span class="kt">Setter</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">t</span>
<span class="nf">set</span>  <span class="ow">::</span> <span class="kt">Setter</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">t</span>
</code></pre></div><p>这样的改变看似没有什么作用，但通过这样的改变，三个常用函数不再以 Lens 为作用对象，而是更加聚焦于一类更加通用的类型。</p><p><br></p><h2>作为概念积类型的类型与作为概念的值</h2><p>通过之前的例子，我们可以看到我们用 Lens 来操作一个<b>积类型(Product Type)</b>，例如元组、Record ；于此相对，Lens 不能用来操作<b>和类型(Sum Type)</b>。我们可以用 Lens 改变或是读取积类型的某个<b>部分(Component)</b>的值。但是实际上，我们不需要一个<b>实在的</b>积类型，也不需要一个实在的部分，只需要概念上的积类型与概念上的部分即可。这样的表述显得非常抽象，让我们来看几个例子。</p><p>第一个例子是列表，我们将要操作的不是列表的元素这些实在的部分，而是抽象的部分，<b>列表的长度</b>。</p><p>让我们定义这个玄乎的<code>_length</code>Lens ：</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">_length</span> <span class="ow">::</span> <span class="kt">Lens'</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">_length</span> <span class="n">f</span> <span class="n">l</span> <span class="ow">=</span> <span class="n">const</span> <span class="n">l</span> <span class="o">&lt;$&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">length</span> <span class="n">l</span><span class="p">)</span>
</code></pre></div><p>可以看出，它可以从一个列表中提取出它的长度，但是不会改变它的长度</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">view</span> <span class="p">(</span><span class="n">_1</span><span class="o">.</span><span class="n">_length</span><span class="p">)</span> <span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">--&gt;</span> <span class="mi">5</span>
<span class="nf">set</span> <span class="p">(</span><span class="n">_1</span><span class="o">.</span><span class="n">_length</span><span class="p">)</span> <span class="mi">9</span> <span class="p">(</span><span class="s">"world"</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> 
<span class="o">--&gt;</span> <span class="p">(</span><span class="s">"world"</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div><p>在这个例子中，长度并不是列表的一个实在的部分，我们操作的积类型也不是一个实在的积类型，而是概念中的某种包含长度的积类型。</p><p>再看第二个例子，我们操作一个数字的绝对值。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">_abs</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Lens'</span> <span class="n">a</span> <span class="n">a</span>
<span class="nf">_abs</span> <span class="n">f</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">setabs</span> <span class="o">&lt;$&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">abs</span> <span class="n">i</span><span class="p">)</span>
  <span class="kr">where</span> <span class="n">sgn</span> <span class="n">x</span>
            <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
            <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span>  <span class="mi">0</span> <span class="ow">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">setabs</span> <span class="n">x</span>
               <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">x</span><span class="o">*</span><span class="n">sgn</span> <span class="n">i</span>
               <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span>  <span class="mi">0</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"Abs must be non-negative"</span>
<span class="nf">view</span> <span class="n">_abs</span> <span class="o">-</span><span class="mi">123</span>
<span class="o">--&gt;</span> <span class="mi">123</span>
<span class="nf">set</span> <span class="n">_abs</span> <span class="mi">13</span> <span class="o">-</span><span class="mi">99</span>
<span class="o">--&gt;</span> <span class="o">-</span><span class="mi">13</span>
</code></pre></div><p>可以看出，概念上，数字确实含有“绝对值”这一部分的值，但是数字与绝对值的关系同样也不是“元组与每个元素”之间的关系，也不是“记录与它的域”的关系。同时，数字本身，并不明显是那种积类型，这里我们同样是将其看作了概念上的积类型。</p><p>引入这两个例子的目的是说明，Lens 是某种更加抽象与普遍化的工具，它不仅仅用来处理具体的数据结构与数据结构内部的值，也可以用来处理各种各样的情况；Lens 聚焦于某个数据结构（实在的或是概念上的）的某个值上，这无关乎这个值是实在地存在于这个数据结构里，还是抽象地、概念上地存在于这个数据上，这为我们以后利用 Lens 完成语义的表达提供了可行性。</p><p><br></p><h2>多焦点数据操作</h2><p>Lens 在工作的过程中，对某个数据结构内某个值应用了一个<code>a -&gt; f b</code>的函数，并最终得到一个<code>f t</code>类型的新数据结构。假设现在我们想要操作某个列表<code>[a]</code>中的所有元素，那么我们期望对列表中的每个元素应用<code>a -&gt; f b</code>的函数，并且最终得到一个<code>f [b]</code>。</p><p>对于应用某个函数于列表中的每个元素这一任务，我们有非常熟悉的解决方案<code>map</code>。 </p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">map</span> <span class="p">(</span><span class="n">f</span><span class="ow">::</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">xs</span><span class="ow">::</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="ow">::</span> <span class="p">[</span><span class="n">f</span> <span class="n">b</span><span class="p">]</span> 
</code></pre></div><p>但是我们期望得到的类型是<code>f [b]</code>而不是<code>[f b]</code>，我们需要一个将函子的列表转换为列表的函子的函数，而实际上，函子没有足够的约束来支持这样的操作，最简单的例子就是，一个空函子的列表我们没法直接找到对应的空列表的函子；此外更一般的场合我们需要将<code>f a</code>合并至<code>f [a]</code>得到一个新的<code>f [a]</code>的函数，其类型为<code>f a -&gt; f [a] -&gt; f [a]</code>，而我们有的列表拼接函数的类型为<code>a -&gt; [a] -&gt; [a]</code>，这也不是函子的升格可以直接完成的。而应用函子恰巧有我们需要的<code>pure</code>函数处理第一种情况，又有可以对双参数函数升格的<code>liftA2</code>。由此看来，我们需要的是使用应用函子代替函子完成我们的需要。</p><p>有了这些分析，我们不难写出将函子的列表提取为列表的函子的函数。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="p">(</span><span class="o">&lt;:&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">[</span><span class="n">a</span><span class="p">],</span>
<span class="p">(</span><span class="o">&lt;:&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">liftA2</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span>
<span class="nf">sequenceA</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">f</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>  
<span class="nf">sequenceA</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">pure</span> <span class="kt">[]</span>  
<span class="nf">sequenceA</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&lt;:&gt;</span> <span class="n">sequenceA</span> <span class="n">xs</span>
</code></pre></div><p>接下来我们需要的操作列表中全部元素的 Lens 的实现也可以容易给出，因为我们先前已经通过<code>map</code>实现了<code>(a -&gt; f b) -&gt; [a] -&gt; [f b]</code>，只需再对结果应用刚实现的<code>sequenceA</code>就可以恰好得到我们需要的 Lens 类型。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">_every</span> <span class="ow">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">_every</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">sequenceA</span> <span class="o">$</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>

<span class="nf">over</span> <span class="n">_every</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">--&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div><p>由于应用函子是特殊的函子，所以<code>_every</code>是特殊的 Lens， 我们将这类 Lens 命名为 Traversal。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">type</span> <span class="kt">Traversal</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">t</span>
<span class="kr">type</span> <span class="kt">Traversal'</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Traversal</span> <span class="n">s</span> <span class="n">s</span> <span class="n">a</span> <span class="n">a</span>
</code></pre></div><p>取这个名字的原因是，在标准库<code>Data.Traversal</code>中实际上恰好有一个函数<code>traverse</code>符合我们的要求， 这个函数并非为 Lens 专门设计，但它的类型恰好与我们先前的<code>_every</code> 相同，不仅如此这个函数不仅可以在列表上工作，也可以在所有<code>Traversable</code>类型上工作。由于这类 Lens 操作均依赖于<code>traverse</code>， 所以取名为 Traversal 。</p><p>让我们简单地看一下 Traversal 是如何与<code>over</code>一通工作的： </p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">traverse</span> <span class="ow">::</span> <span class="kt">Traversable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="kt">Traversal</span> <span class="p">(</span><span class="n">t</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">t</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span>
<span class="nf">over</span> <span class="n">traverse</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">runIdentity</span> <span class="o">.</span> <span class="n">traverse</span> <span class="p">(</span><span class="kt">Identity</span> <span class="o">.</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">runIdentity</span> <span class="o">$</span> <span class="n">sequenceA</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="kt">Identity</span> <span class="o">.</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">runIdentity</span> <span class="o">$</span> <span class="n">sequenceA</span> <span class="p">[</span><span class="kt">Identity</span> <span class="mi">3</span><span class="p">,</span> <span class="kt">Identity</span> <span class="mi">4</span><span class="p">,</span> <span class="kt">Identity</span> <span class="mi">5</span><span class="p">]</span>
<span class="nf">runIdentity</span> <span class="o">$</span> <span class="kt">Identity</span> <span class="mi">3</span> <span class="o">&lt;:&gt;</span> <span class="kt">Identity</span> <span class="mi">4</span> <span class="o">&lt;:&gt;</span> <span class="kt">Identity</span> <span class="mi">5</span> <span class="o">&lt;:&gt;</span> <span class="kt">Identity</span> <span class="kt">[]</span>
<span class="nf">runIdentity</span> <span class="o">$</span> <span class="kt">Identity</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="o">--&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div><p>但是，现在我们的 Traversal 不能正确与<code>view</code>工作。 例如，对于下面的代码</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">view</span> <span class="n">traverse</span> <span class="p">[</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">]</span>
<span class="nf">view</span> <span class="n">traverse</span> <span class="p">[</span><span class="sc">'1'</span><span class="p">,</span><span class="sc">'2'</span><span class="p">,</span><span class="sc">'3'</span><span class="p">]</span>
</code></pre></div><p>我们期望的结果是这样的，我们只需要它原封不动地返回即可</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="p">[</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div><p>而实际上，我们得到了看似匪夷所思的结果</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="s">"123"</span>
<span class="c1">-- error: No instance for (Monoid Char) arising from a use of ‘traverse’</span>
</code></pre></div><p>让我们展开 Traversal 与<code>view</code>工作的过程 </p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">view</span> <span class="n">traverse</span> <span class="p">[</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">]</span>
<span class="nf">getConst</span> <span class="o">$</span> <span class="n">traverse</span> <span class="p">(</span><span class="kt">Const</span> <span class="n">b</span><span class="p">)</span> <span class="p">[</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">]</span>
<span class="nf">getConst</span> <span class="o">$</span> <span class="n">sequenceA</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="kt">Const</span> <span class="n">b</span><span class="p">)</span> <span class="p">[</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">]</span>
<span class="nf">getConst</span> <span class="o">$</span> <span class="n">sequenceA</span>  <span class="p">[</span><span class="kt">Const</span> <span class="s">"1"</span><span class="p">,</span> <span class="kt">Const</span> <span class="s">"2"</span><span class="p">,</span> <span class="kt">Const</span> <span class="s">"3"</span><span class="p">]</span>
<span class="nf">getConst</span> <span class="o">$</span> <span class="n">sequenceA</span> <span class="o">$</span> <span class="kt">Const</span> <span class="s">"1"</span> <span class="o">&lt;:&gt;</span> <span class="kt">Const</span> <span class="s">"2"</span> <span class="o">&lt;:&gt;</span> <span class="kt">Const</span> <span class="s">"3"</span> <span class="o">&lt;:&gt;</span> <span class="n">pure</span> <span class="kt">[]</span>
</code></pre></div><p>我们实际上清楚<code>Const a</code>本身并非应用函子,<code>Monoid a =&gt; Const a</code>才是 ，这个<code>a</code>类型的值不是“容器”内的值，而是“容器”的一部分，容器内并不存在值。于是，将应用函子范畴上的值应用到应用函子范畴上的函数时，内部并无操作，有的只是“容器”的合并。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Const</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Const</span> <span class="n">empty</span>
  <span class="p">(</span><span class="kt">Const</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="kt">Const</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Const</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div><p>列表的默认<code>mappend</code>操作是列表合并，所以我们就可以将上面的计算继续写下去了</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">getConst</span> <span class="o">$</span> <span class="n">sequenceA</span>  <span class="kt">Const</span> <span class="s">"1"</span> <span class="o">&lt;:&gt;</span> <span class="kt">Const</span> <span class="s">"2"</span> <span class="o">&lt;:&gt;</span> <span class="kt">Const</span> <span class="s">"3"</span> <span class="o">&lt;:&gt;</span> <span class="n">pure</span> <span class="kt">[]</span>
<span class="nf">getConst</span> <span class="o">$</span> <span class="n">sequenceA</span>  <span class="kt">Const</span> <span class="s">"1"</span> <span class="o">&lt;:&gt;</span> <span class="kt">Const</span> <span class="s">"2"</span> <span class="o">&lt;:&gt;</span> <span class="kt">Const</span> <span class="s">"3"</span> <span class="o">&lt;:&gt;</span> <span class="kt">Const</span> <span class="s">""</span>
<span class="nf">getConst</span> <span class="o">$</span> <span class="n">sequenceA</span>  <span class="kt">Const</span> <span class="s">"1"</span> <span class="o">&lt;:&gt;</span> <span class="kt">Const</span> <span class="s">"2"</span> <span class="o">&lt;:&gt;</span> <span class="kt">Const</span> <span class="s">"3"</span>
<span class="nf">getConst</span> <span class="o">$</span> <span class="n">sequenceA</span>  <span class="kt">Const</span> <span class="s">"1"</span> <span class="o">&lt;:&gt;</span> <span class="kt">Const</span> <span class="s">"23"</span>
<span class="nf">getConst</span> <span class="o">$</span> <span class="n">sequenceA</span>  <span class="kt">Const</span> <span class="s">"123"</span>
<span class="s">"123"</span>
</code></pre></div><p>可以看出，这并不是匪夷所思的结果，而是在这些定义下的合理结果。实际上，从<code>view</code>类型上我们也可以看出它的确做了它应当的工作。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">view</span> <span class="ow">::</span> <span class="kt">Getting</span> <span class="n">a</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">view</span> <span class="n">traverse</span> <span class="p">[</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">]</span>
<span class="c1">-- view :: Getting String [String] String -&gt; [String] -&gt; String</span>
</code></pre></div><p>它最终确实给了我们一个字符串。</p><p>所以，我们需要构建专用于 Traversal 的<code>view</code>函数。考虑之前<code>view</code>的定义</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">view</span> <span class="ow">::</span> <span class="kt">Getting</span> <span class="n">a</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">view</span> <span class="n">lens</span> <span class="ow">=</span> <span class="n">getConst</span> <span class="o">.</span> <span class="n">lens</span> <span class="kt">Const</span> 
</code></pre></div><p>这里他将原来的值不加改变地喂给了<code>getConst</code>， 我们可以讲原始值套在一个 Monoid 里完成我们需要的效果。这里，我们需要的就是最终得到一个列表，因此只需要再套一层列表的 Monoid 即可，外面套的这层 Monoid 会互相合并，最终只剩下一个列表，里面排满了原来的元素。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">toListOf</span> <span class="ow">::</span> <span class="kt">Getting</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">toListOf</span> <span class="n">lens</span> <span class="ow">=</span> <span class="n">getConst</span> <span class="o">.</span> <span class="n">lens</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Const</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span>

<span class="nf">toListOf</span> <span class="n">traverse</span> <span class="p">[</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">]</span>
<span class="o">--&gt;</span> <span class="p">[</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">]</span>
<span class="nf">toListOf</span> <span class="n">traverse</span> <span class="p">[</span><span class="sc">'1'</span><span class="p">,</span><span class="sc">'2'</span><span class="p">,</span><span class="sc">'3'</span><span class="p">]</span>
<span class="o">--&gt;</span> <span class="p">[</span><span class="sc">'1'</span><span class="p">,</span><span class="sc">'2'</span><span class="p">,</span><span class="sc">'3'</span><span class="p">]</span>
</code></pre></div><p>这个函数似乎没有多大用处，它原封不动地返回了原本的列表。但是，我们可以依托于<code>traverse</code> 构建更多更有用的 Traversal。</p><p>例如聚焦于一个列表中全部满足某个条件的 Traversal</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">_all</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Traversal'</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="n">a</span>
<span class="nf">_all</span> <span class="n">st</span> <span class="n">f</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">traverse</span> <span class="n">update</span> <span class="n">s</span>
  <span class="kr">where</span>
    <span class="n">update</span> <span class="n">old</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">st</span> <span class="n">old</span> <span class="kr">then</span> <span class="n">f</span> <span class="n">old</span> <span class="kr">else</span> <span class="n">pure</span> <span class="n">old</span>
    
<span class="nf">toListOf</span> <span class="p">(</span><span class="n">_all</span> <span class="p">(</span><span class="o">/=</span><span class="mi">0</span><span class="p">))</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">--&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> 
</code></pre></div><p>同时，我们描述过 Traversal 是一种特殊的 Lens， 所以它具有 Lens 各种有用的性质，例如通过互相复合来处理嵌套的列表。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">toListOf</span> <span class="p">(</span><span class="n">traverse</span><span class="o">.</span><span class="n">traverse</span><span class="p">)</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="o">--&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">xs</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">23</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">over</span> <span class="p">(</span><span class="n">_all</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="ow">-&gt;</span> <span class="n">length</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">.</span><span class="n">traverse</span><span class="p">)</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">xs</span>
<span class="c1">-- &gt;[[2,3],[1,2,3,4],[5,6,7],[23,4,5,5,4],[2],[3,4]]</span>
</code></pre></div><p>或者与普通的 Lens 复合，来完成复杂的操作。</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="nf">toListOf</span> <span class="p">(</span><span class="n">traverse</span><span class="o">.</span><span class="n">_1</span><span class="p">)</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)]</span>
<span class="o">--&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div><p>需要注意的是，Traversal 是特殊的 Lens，也就是说在 Lens 上多出一些特定的限制，因此 Traversal 与普通 Lens 的复合将会仍然继承这些限制，即 Traversal 与 Lens 的复合仍是 Traversal。</p><p><br></p><h2>使用更多 Monoid 来获得多种效果</h2><p>在上面我们使用了<code>[]</code>这一 Monoid 来实现了合成列表的效果，实际上，我们还可以使用其他Monoid。下面让我们看几个例子。</p><p>第一个例子是将包装过的 <code>Maybe</code>作为一个 Monoid，并取名为 <code>First</code> 。从名字我们也可以看出来，它的作用就是取出列表的首个元素。 </p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">newtype</span> <span class="kt">First</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">First</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">First</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">First</span> <span class="kt">Nothing</span>
  <span class="n">mappend</span> <span class="p">(</span><span class="kt">First</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">y</span>
  <span class="n">mappend</span>        <span class="n">x</span>        <span class="kr">_</span> <span class="ow">=</span> <span class="n">x</span>

<span class="nf">preview</span> <span class="ow">::</span> <span class="kt">Getting</span> <span class="p">(</span><span class="kt">First</span> <span class="n">a</span><span class="p">)</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">preview</span> <span class="n">lens</span> <span class="ow">=</span> <span class="n">getFirst</span> <span class="o">.</span> <span class="n">getConst</span> <span class="o">.</span> <span class="n">lens</span> <span class="p">(</span><span class="kt">Const</span> <span class="o">.</span> <span class="kt">First</span> <span class="o">.</span> <span class="kt">Just</span><span class="p">)</span>

<span class="nf">preview</span> <span class="p">(</span><span class="n">_all</span> <span class="p">(</span><span class="o">/=</span><span class="mi">0</span><span class="p">))</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="o">--&gt;</span> <span class="kt">Just</span> <span class="mi">3</span>

<span class="nf">preview</span> <span class="p">(</span><span class="n">_all</span> <span class="p">(</span><span class="o">/=</span><span class="mi">0</span><span class="p">))</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="o">--&gt;</span> <span class="kt">Nothing</span>
</code></pre></div><p>同样，修改 <code>mappend</code>的定义我们可以得到 <code>Last</code>，这里不再具体给出。 </p><p><br></p><p>第二个例子是包装过的<code>Bool</code>，我们可以用它来判断一个列表中是否含有某个元素</p><div class="highlight"><pre><code class="language-haskell"><span></span><span class="kr">newtype</span> <span class="kt">Any</span> <span class="ow">=</span> <span class="kt">Any</span> <span class="p">{</span> <span class="n">getAny</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Any</span> <span class="kr">where</span>
  <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">Any</span> <span class="kt">False</span>
  <span class="kt">Any</span> <span class="n">x</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Any</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Any</span> <span class="p">(</span><span class="n">x</span> <span class="o">||</span> <span class="n">y</span><span class="p">)</span>
  
<span class="nf">has</span> <span class="ow">::</span> <span class="kt">Getting</span> <span class="kt">Any</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">has</span> <span class="n">l</span> <span class="ow">=</span> <span class="n">getAny</span> <span class="o">.</span> <span class="n">getConst</span> <span class="o">.</span> <span class="n">l</span> <span class="p">(</span><span class="n">const</span> <span class="o">$</span> <span class="kt">Const</span> <span class="p">(</span><span class="kt">Any</span> <span class="kt">True</span><span class="p">))</span> 

<span class="nf">has</span> <span class="p">(</span><span class="n">_all</span> <span class="p">(</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="o">--&gt;</span> <span class="kt">True</span>
</code></pre></div><p>我们发现，由于 Traversal 具有良好的抽象能力，我们仅仅选用不同的 Monoid 就实现了多种多用的效果，这无疑是非常令人振奋的。</p><p><br></p><p>-- 2017/11/25日更新</p><p>出现了各种错误（捂脸），谢谢 <a class="member_mention" href="http://www.zhihu.com/people/0251012c87c2d3f56ac34de7d71cdcbc" data-hash="0251012c87c2d3f56ac34de7d71cdcbc" data-hovercard="p$b$0251012c87c2d3f56ac34de7d71cdcbc">@脚本少女魔理沙</a> 指正╮(╯▽╰)╭</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
</body>
</html>
