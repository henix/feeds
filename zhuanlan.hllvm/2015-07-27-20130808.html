<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>学习编程语言与编译优化的一个书单</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/20130808">原文</a></p>
<div class="title-image"><img src="https://pic3.zhimg.com/b806999aa557e5e839cf51bccbd4d8e2_r.jpg" alt=""></div>其实是想放张图：<img src="https://pic3.zhimg.com/21e2e4bb3586ece2078fd6c3c65d4cbe_r.jpg" data-rawwidth="1024" data-rawheight="1228"><br><p>（这个书单帖居然有那么多点赞，完全没料到。我这帖说的应该是很小众的内容才对？压力好大…）</p><p>要学习编程语言原理与编译/优化原理，有许多书可读。我的生活乐趣之一就是不断的读这个领域的各种书 &gt;_&lt;</p><p>但毕竟很多书覆盖的知识点或者说切入点都是类似的，只是为了学习知识而不是纯为了生活乐趣的话，倒没必要全都读了。每个方面挑些<b>适合自己偏好</b>的好书读读就好。</p><p>这里挑了我放在办公室里的书的其中几本，供大家参考一下从入门到深入学习<b>偏编译优化方向的编程语言知识的路线图</b>。编程语言原理涉及的知识面相当广，也有许多不同的细分方向，这里就只针对编译优化这个比较窄的方向做些推荐。</p><p>上图的书的阅读顺序是从上到下。欢迎大家评论和推荐更好的书 ^_^</p><br><br><h2><b>书单</b></h2><p>这些书从上到下分别是：</p><ol><li><a href="http://book.douban.com/subject/3743526/" data-editable="true" data-title="《Programming Language Pragmatics, Third Edition》" class="">《Programming Language Pragmatics, Third Edition》</a>（中译版：<a href="http://book.douban.com/subject/10802357/" class="" data-editable="true" data-title="《程序设计语言——实践之路（第三版）》">《程序设计语言——实践之路（第三版）》</a>）<br></li><li><a href="http://book.douban.com/subject/5407246/" class="" data-editable="true" data-title="《深入理解计算机系统（英文版·第2版）》">《深入理解计算机系统（英文版·第2版）》</a>（原版：<a href="http://book.douban.com/subject/3023631/" class="" data-editable="true" data-title="《Computer Systems: A Programmer's Perspective, Second Edition》">《Computer Systems: A Programmer's Perspective, Second Edition》</a>，中译版：<a href="http://book.douban.com/subject/5333562/" class="" data-editable="true" data-title="《深入理解计算机系统（原书第2版）》">《深入理解计算机系统（原书第2版）》</a>）<br></li><li><a href="http://book.douban.com/subject/4117971/" class="" data-editable="true" data-title="『ふつうのコンパイラをつくろう——言語処理系をつくりながら学ぶコンパイルと実行環境の仕組み』">『ふつうのコンパイラをつくろう——言語処理系をつくりながら学ぶコンパイルと実行環境の仕組み』</a>（中译版即将上市，译者是想能的信息科技的严圣逸和支付宝的前端架构专家绝云）<br></li><li><a href="http://book.douban.com/subject/5288601/" class="" data-editable="true" data-title="《Engineering a Compiler, Second Edition》">《Engineering a Compiler, Second Edition》</a>（中译版：<a href="http://book.douban.com/subject/20436488/" class="" data-editable="true" data-title="《编译器设计》">《编译器设计》</a>）<br></li><li><a href="http://book.douban.com/subject/1821532/" class="" data-editable="true" data-title="《Advanced Compiler Design and Implementation》">《Advanced Compiler Design and Implementation》</a>（中译版：<a href="http://book.douban.com/subject/1400374/" class="" data-editable="true" data-title="《高级编译器设计与实现》">《高级编译器设计与实现》</a>）<br></li><li><a href="http://book.douban.com/subject/2359859/" class="" data-editable="true" data-title="《High-Performance Compilers for Parallel Computing》">《High-Performance Compilers for Parallel Computing》</a>（尚无中译版）<br></li><li><a href="http://book.douban.com/subject/2126867/" data-editable="true" data-title="《Optimizing Compilers for Modern Architectures》" class="">《Optimizing Compilers for Modern Architectures》</a>（中译版：<a href="http://book.douban.com/subject/1171448/" class="" data-editable="true" data-title="《现代体系结构的优化编译器》">《现代体系结构的优化编译器》</a>）<br></li></ol><br><br><h2><b>学习路线图</b></h2><p>这份书单中，</p><ul><li>头两本书用于了解大背景的。To get the big picture；<br></li><li>中间两本是用来做编译原理入门的；<br></li><li>最后三本用于深入学习编译与优化的知识。</li></ul><p>这三个阶段里，每个阶段都可以有其它书可以替代。这些只是<b>适合我的偏好</b>的选择而已。</p><br><br><p>1. <a href="http://book.douban.com/subject/3743526/" data-editable="true" data-title="《Programming Language Pragmatics, Third Edition》" class="">《Programming Language Pragmatics, Third Edition》</a>（中译版：<a href="http://book.douban.com/subject/10802357/" class="" data-editable="true" data-title="《程序设计语言——实践之路（第三版）》">《程序设计语言——实践之路（第三版）》</a>）</p><p>2009年出版。简称PLP。这本书主要用于掌握编程语言方面的大背景——编程语言是什么、有哪些种类，实现编程语言的大体流程是怎样，在编程语言的设计与实现里都会用到些什么术语等。它的Part I和Part II不但讲解了编程语言常见的结构，也顺带提到了它们背后涉及的一些实现，其实比专门的编译原理书更适用于最初的入门。<br></p><p>第三版目录在此：<a href="https://www.cs.rochester.edu/u/scott/pragmatics/3e/toc.shtml" data-editable="true" data-title="rochester.edu 的页面" class="">PLP 3e Table of Contents</a></p><br><p>书中对许多概念的讲解在编程语言中有普适意义。例如说书中提到了“display”的概念，在讲stack frame的static link/static chain时提到可以使用display来减少需要的递归搜索的次数——对递归深度有固定上限的问题，可以把递归搜索的结果事先放在一个小数组里，这个数组就是“display”（裘老师译为“区头向量”）。这个“display”的概念其实可以引伸到各种递归问题，例如基于类的面向对象语言里的快速子类型检查就可以用上display；相关的，像是面向对象语言所用的虚函数表（vtable）其实也是一个变种display。</p><p>这本书顺带充当了我学习许多语言的入门书，拓宽了我的知识面。Scheme、Ada、Prolog之类的好些语言我都是从这本书开始真的接触并写代码来学习的。</p><p>我最初读的是裘宗燕老师翻译的<a href="http://book.douban.com/subject/2152385/" class="" data-editable="true" data-title="《程序设计语言——实践之路（第二版）》">《程序设计语言——实践之路（第二版）》</a>。这是我喜欢的中译版技术书之一。虽然里面的术语译法跟我所喜欢的不完全一致，但完全没影响阅读。</p><p>评论里<a href="https://www.zhihu.com/people/6f8a5a4cb5218434cf962c835b21afde" data-hash="6f8a5a4cb5218434cf962c835b21afde" class="member_mention" data-editable="true" data-title="@Snow Liang">@Snow Liang</a>提醒说这本书今年11月就要出第四版了：<a href="http://book.douban.com/subject/26424018/" data-editable="true" data-title="《Programming Language Pragmatics, Fourth Edition》" class="">《Programming Language Pragmatics, Fourth Edition》</a>。真好！</p><p>作者<a href="http://www.cs.rochester.edu/u/scott/" data-editable="true" data-title="Michael L. Scott">Michael L. Scott</a>是<a href="http://www.rochester.edu/" data-editable="true" data-title="University of Rochester">Rochester大学</a>的教授，虽然本职教学并不主要是编程语言相关，而是诸如事物内存（transactional memory）之类，但是他对这本书颇为投入而且也对成果感到很满意。</p><br><br><p>2. <a href="http://book.douban.com/subject/5407246/" class="" data-editable="true" data-title="《深入理解计算机系统（英文版·第2版）》">《深入理解计算机系统（英文版·第2版）》</a>（原版：<a href="http://book.douban.com/subject/3023631/" class="" data-editable="true" data-title="《Computer Systems: A Programmer's Perspective, Second Edition》">《Computer Systems: A Programmer's Perspective, Second Edition》</a>，中译版：<a href="http://book.douban.com/subject/5333562/" class="" data-editable="true" data-title="《深入理解计算机系统（原书第2版）》">《深入理解计算机系统（原书第2版）》</a>）</p><p>原书2008年出版。大名鼎鼎的CS:APP，是从软件角度学习系统知识必备的一本入门书，不用多说。这本书刚新出了第三版不过我还没舍得买，所以书单上只能先放着第二版。</p><p>前一本书PLP主要从上层介绍编程语言上的概念，而这本书主要介绍编程语言的概念会映射到怎样的系统层概念上。从编译器的角度看，PLP主要覆盖的是编程语言的词法、语法、语义的部分，是编译器前端的知识；而CS:APP则更关注把编程语言的概念映射到实际的CPU、内存、操作系统层面上，是编译器后端的知识。两者结合起来就完美的覆盖了学习编译器所需的知识面，对编译原理的全貌有一个把握。</p><p>国内的同学们是幸福的，这本书的影印版质量非常非常好，纸张、印刷都极其高质量，不能再多赞了！买本影印版感觉赚大了。中译版我没读过不过据说质量也不错。</p><br><br><p>3. <a href="http://book.douban.com/subject/4117971/" class="" data-editable="true" data-title="『ふつうのコンパイラをつくろう——言語処理系をつくりながら学ぶコンパイルと実行環境の仕組み』">『ふつうのコンパイラをつくろう——言語処理系をつくりながら学ぶコンパイルと実行環境の仕組み』</a></p><p>（书名可以直译为：《写个普通的编译器——通过编写语言处理器来学习编译与运行时环境的原理》。呃真引进的话肯定不会这么译…）</p><p>2009年出版。这是本日文书。有那么多入门级编译器书，为啥我要选它来推荐？</p><p>因为我觉得这本书写得很实在，适合入门学习时形象地掌握整个编译流程，其中都有哪些环节，每个环节间又是如何互动的。在<a href="http://book.douban.com/people/RednaxelaFX/all?sort=time&amp;tags_sort=count&amp;filter=all&amp;tag=%E7%BC%96%E8%AF%91%E5%99%A8&amp;mode=grid" data-editable="true" data-title="我读过或接触过的编译器书" class="">我读过或接触过的编译器书</a>里，它算是我最推荐的用于指导实际写第一个编译器的入门书。</p><p>这本书的知识点和难度大致都跟斯坦福的编译原理入门课CS143相近，结合两者来学习也是不错的选择。请参考另一帖：<a href="http://www.zhihu.com/question/28679215/answer/43883727" data-editable="true" data-title="斯坦福大学编译原理课程质量怎么样？ - RednaxelaFX 的回答">斯坦福大学编译原理课程质量怎么样？ - RednaxelaFX 的回答</a></p><p>这本书吸引我的特点有两个：</p><ul><li>从头到尾围绕一个完整可运行的简易编译器来讲解；完整配套源码在Github就有：<a href="https://github.com/aamine/cbc" data-editable="true" data-title="aamine/cbc · GitHub" class="">aamine/cbc · GitHub</a></li><li>覆盖了从词法/语法分析 -&gt; 语义分析 -&gt; 中间代码生成 -&gt; 目标代码生成 -&gt; 链接 -&gt; 运行时环境的完整流程。并没有过于纠缠于其中的任一环节（特别是没有过于纠缠于前端部分），而是更关注整体流程，注重大局观。</li></ul><p>这本书描述的是一个名为<a href="https://github.com/aamine/cbc" class="" data-editable="true" data-title="C♭">C♭</a>（读作C-flat）语言的编译器cbc，使用Java实现，目标运行环境是Linux/x86。</p><p>C♭是一个C的简化版，简化的主要是宏相关的部分以及早期C一直延续下来的许多小细节；保留下来的部分覆盖了C的绝大部分功能，例如基本类型、函数、指针，struct/union等等，作为入门级编译器的源语言功能上正好适中。</p><p>cbc编译器的整体工作流程是：</p><code lang="text">Cb源码
=&gt; [ 词法分析 + 语法分析 ] =&gt; // 由JavaCC生成
抽象语法树（AST）
=&gt; [ Visitor模式的语义分析 ] =&gt;
标注的抽象语法树（Annotated AST）
=&gt; [ 中间代码生成 ] =&gt; // 跟虎书的C版本非常相似，但代码风格比虎书好
树形中间代码（Tree IR）
=&gt; [ 简单优化 ] =&gt;
优化过的中间代码
=&gt; [ 代码生成 ] =&gt;    // 使用Java写的内部DSL来生成GNU as格式的汇编
                     // 支持可重定位与不可重定位两种版本的代码生成
GNU as格式的汇编
=&gt; [[ GNU as ]] =&gt;   // 汇编器
目标代码
=&gt; [[ GNU ld ]] =&gt;   // 链接器
ELF可执行文件 / 动态链接库</code><p>其中用单中括号标注的环节是cbc自己实现的，而双中括号标注的部分则是依赖现成的工具实现。cbc生成的代码符合Linux/x86的C ABI，可以跟libc或者其它导出C ABI的库链接起来。</p><p>以此，C♭程序从源码到可执行文件到运行时环境的整个流程都在本书中有所体现。<br></p><p>细心的读者可能会问：cbc不用分配寄存器么？答案是它用了非常非常简易的分配方式——“栈顶缓存”——直接融合在代码生成环节中。详细请见另一帖：<a href="http://www.zhihu.com/question/29355187/answer/51935409" data-editable="true" data-title="寄存器分配问题？ - RednaxelaFX 的回答" class="">寄存器分配问题？ - RednaxelaFX 的回答</a></p><p>要在中文社区推广这本书，光靠日文原版还是太困难。就等有爱人士到图灵社区去接下翻译任务啦：<a href="http://www.ituring.com.cn/book/1308" data-editable="true" data-title="图灵社区 : 图书 : 自制编译器" class="">图灵社区 : 图书 : 自制编译器</a>，我可以提供充分的技术支持 :-)</p><p>更新：这本书已经有译者接下了，是想能的信息科技的严圣逸和支付宝的前端架构专家绝云。太好了！据说2016年4月底可以上市。</p><br><br><p>4. <a href="http://book.douban.com/subject/5288601/" class="" data-editable="true" data-title="《Engineering a Compiler, Second Edition》">《Engineering a Compiler, Second Edition》</a>（中译版：<a href="http://book.douban.com/subject/20436488/" class="" data-editable="true" data-title="《编译器设计》">《编译器设计》</a>）</p><p>2011年出版。简称EAC2。据说有人把这本书称为“橡书”但我不知道这种叫法的来源是啥。书的封面图是“The Landing of the Ark”。</p><p>这本书是编译原理教材里我最喜欢的一本，没有之一。它用作入门时的第一本书也行，放在『ふつうのコンパイラをつくろう』之类的简易入门书之后作为正式学习编译原理的教材也很合适。它覆盖的知识面足以应付初级到中级编译原理的学习，内容夯实，脉络清晰，语言既干练又不失形象。</p><p>而且它选择讲解的知识点都是相当实用且与时俱进的——可能就除了寄存器分配的地方没有专门的小节讲线性扫描寄存器分配算法（Linear-scan register allocation）不够与时俱进——其它讲的都是当代编译器里常见而实用的内容。</p><p>例如说第9章讲数据流分析的部分，主要结合SSA形式来展开，比起特别传统的非要从非SSA形式讲起、最后在进阶部分提一下SSA形式的做法要现代多了。</p><p>EAC2目录在此：<a href="http://www.elsevier.com/wps/find/bookdescription.cws_home/724559/description#description" data-editable="true" data-title="Elsevier's site for Engineering a Compiler">Elsevier's site for <em>Engineering a Compiler</em></a></p><p>本书作者<a href="http://www.cs.rice.edu/~keith/" data-editable="true" data-title="Keith D. Cooper" class="">Keith D. Cooper</a>和<a href="http://www.cs.rice.edu/~linda/" data-editable="true" data-title="Linda Torczon" class="">Linda Torczon</a>都是<a href="http://www.rice.edu/" data-editable="true" data-title="Rice University">Rice大学</a>的名教授，而且两人同为<a href="http://www.cs.rice.edu/~ken/" data-editable="true" data-title="Ken Kennedy's Home Page">Ken Kennedy</a>的学生。后面会再提到他们的关系。</p><br><br><p>5. <a href="http://book.douban.com/subject/1821532/" class="" data-editable="true" data-title="《Advanced Compiler Design and Implementation》">《Advanced Compiler Design and Implementation》</a>（中译版：<a href="http://book.douban.com/subject/1400374/" class="" data-editable="true" data-title="《高级编译器设计与实现》">《高级编译器设计与实现》</a>）</p><p>1997年出版。大名鼎鼎的“鲸书”，在编译原理的经典动物书“龙虎鲸”中排得上号的进阶读物。从这本书开始就要深入学习编译优化了。</p><p>这本书只关心优化编译器的中、后端涉及优化的部分，而完全不涉及前端的词法/语法分析或语言相关的语义分析。因而它虽然不适合作为初学教材，但在进阶学习时非常好用——完全没废话，直达痛点。</p><p>本书作者Steven Stanley Muchnick不但在学术界很有影响，在业界也参与了一些重量级项目，例如HP的PA-RISC的设计及其优化编译器的实现，然后是Sun的SPARC的设计及其优化编译器的实现。鲸书里介绍的编译器优化技术都是实打实的，理论结合实际，边读边实践很痛快。</p><p>要是还能再来个新版本就好了…</p><br><p>接下来要介绍的两本其实只是在鲸书的基础上拓展一下视野用的，免得受单一作者的偏好而限制了自己的选择范围。这两本都是相对偏老的书，以Fortran编译器中的优化为主要介绍对象，重点介绍数据依赖分析、循环优化、自动向量化之类的话题，在现在各种主流CPU都强力推出SIMD指令的潮流下并不过时，反而相当值得参考。<br></p><br><br><p>6. <a href="http://book.douban.com/subject/2359859/" class="" data-editable="true" data-title="《High-Performance Compilers for Parallel Computing》">《High-Performance Compilers for Parallel Computing》</a></p><p>1995年出版的老书。尚未有中译版，以后也不太可能会有吧。</p><p>作者Michael Wolfe。我现在就职的Azul Systems有位元老员工叫做Michael Wolf，是我们的pauseless GC算法的设计者之一，非常牛。一开始我是因为把名字看错了才买的这本书，却有意想不到的收获。</p><p>因为这本书很奇葩！</p><br><br><br><p>7. <a href="http://book.douban.com/subject/2126867/" data-editable="true" data-title="《Optimizing Compilers for Modern Architectures》" class="">《Optimizing Compilers for Modern Architectures》</a>（中译版：<a href="http://book.douban.com/subject/1171448/" class="" data-editable="true" data-title="《现代体系结构的优化编译器》">《现代体系结构的优化编译器》</a>）</p><br><p>（待补充）</p><br><br><p>8. <a href="http://ssabook.gforge.inria.fr/latest/book.pdf" class="" data-editable="true" data-title="《Single Static Assignment Book》">《Static Single Assignment Book》</a></p><p>Bonus：这是一本还在写作中的书，因此没有纸质版，暂时只有电子版。不过对许多本来就不想买书的同学们来说或许是个福音吧（逃</p><p>静态单赋值形式（SSA Form）是现代主流编译器都会采用的IR形式，而且越来越多编译器开始以SSA形式的IR为主。</p><p>最极致的是像LLVM那样采用单层IR，而且这个IR必须是SSA形式的。许多人觉得LLVM IR操作起来方便的原因之一就是许多算法在SSA形式下表达起来很简洁直观。说来，因为LLVM IR本身不是Memory-SSA或Heap-SSA形式，并不显式跟踪内存中的赋值，所以前端在生成LLVM IR时倒不必总是自己构建SSA形式，而可以用alloca分配局部变量然后让LLVM自带的mem2reg去构建SSA形式，所以这种SSA形式的IR也没有给前端增加负担，是个双赢。</p><p>既然SSA形式这么重要这么流行，应该有本书专门以它为线索来介绍编译原理的知识对不对？这本书就是如此。它是许多作者合写的，每一章都像是一篇相对独立的论文一样，围绕SSA形式介绍了编译器中后端的方方面面。</p><br><br><h2><b>还缺什么？</b></h2><p>其实我还很希望能在书单里有几本介绍对JIT编译器或者说运行时编译做重点讲解的书，以及对动态类型语言的编译优化做重点讲解的书。可惜这些方面的论文虽然不少，但却没有现成的书对其做系统性的讲解。</p><p>好在万变不离其宗，JIT编译器与动态语言优化其实都还是在传统的编译原理基础上的进化，掌握好基础的话这些话题都会变得更易于理解。</p><br><br><h2><b>一些背景</b></h2><p>“<a href="http://www.rice.edu/" data-editable="true" data-title="Rice">Rice</a>系”的编译器大牛们：<a href="http://www.cs.rice.edu/CS/compilers/" class="" data-editable="true" data-title="Rice Compiler Group">Rice Compiler Group</a></p><p>“<a href="http://www.stanford.edu/" data-editable="true" data-title="Stanford">Stanford</a>系”的编译器大牛们：<a href="http://suif.stanford.edu/" class="" data-editable="true" data-title="The SUIF Group">The SUIF Group</a></p><p>==========================================================</p><p>顺带给想八卦的同学们，这是我办公室书架的全景：</p><img src="https://pic4.zhimg.com/a25fcec4cae70aaa039802eaa94a9a4e_r.jpg" data-rawwidth="2048" data-rawheight="1085"><br><p>有不少眼熟的书对不对？^_^</p><p>还有更多书放在家里的书架上。家里的书架已经快溢出了所以不得不把越来越多书搬到办公室来…</p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
