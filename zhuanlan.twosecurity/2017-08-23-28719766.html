<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>浏览器漏洞挖掘思路</title>
</head>
<body>
<p><a href="https://zhuanlan.zhihu.com/p/28719766">原文</a></p>
<div class="title-image"><img src="https://pic4.zhimg.com/v2-a72d7f79e57a6b71c628133327a02c2b_r.jpg" alt=""></div><p>在 Web 安全中，服务端一直扮演着十分重要的角色。然而浏览器的问题也不容小觑，它也会导致信息泄露等诸如此类的问题。然而许多人还没有意识到浏览器对于安全的重要性。在这篇讲座（文章）中，我们会给读者带来挖掘浏览器漏洞的思路。</p><h2><b>挖掘漏洞的思路</b></h2><h2><b>确定目标</b></h2><p>我们先来看看浏览器的大概结构：</p><ul><li>DOM 解析 （HTML, XML, SVG, MathML, XUL）</li><li>脚本处理 （JavaScript, VBScript, asm.js, WebAssembly）</li><li>协议支持 （HTTP, FTP, WebSocket, HTTP/2, QUIC, DNS, mDNS, WebRTC）</li><li>媒体流支持 （JPG, GIF, PNG, WebM, Ogg, AAC, MP3, MP4, FLAC）</li><li>包含的中间件（Skia, ffmpeg, ICU, NSS, OpenVR, libpng, sqlite）</li><li>各种 API（Fetch API, Push API, Extension API, Fullscreen API, Web Speech API）</li><li>UI 组建（Location Bar, History, Bookmark, Context Menu）</li><li>安全功能（SOP, XSS Filter, CSP, SRI, TLS, Mixed Content, HSTS, HPKP, CT）</li><li>便利功能（Chrome Extension, Reading View, Secret Mode）</li><li>其它</li></ul><p>我们应该如何从诸多功能中选取攻击目标？这时，我们可以这样入手：</p><h2><b>检查新功能</b></h2><p>刚刚公布的功能往往没有被太多的人研究，因此更有可能存在潜在的隐患。因此，我们可以试着在下列产品挖掘漏洞：</p><ul><li>Firefox Nightly</li><li>Chrome Dev, Canary</li><li>Safari Technology Preview</li><li>Edge的最新版本</li></ul><p>更新时，我们最好注意一下它们的发行日记或者开发者的 blog。这样我们可以在最短的时间内得知新加入的特性。</p><img src="https://pic4.zhimg.com/v2-a72d7f79e57a6b71c628133327a02c2b_r.png" data-rawwidth="1443" data-rawheight="802"><p>Firefox 在该版本中提供了 link 预加载，这看上去十分有趣!这时，白帽子们可以以此功能为基础，对其进行安全检测，或者思考能否用它扩展供给面。</p><p>这是能让我们获取一手消息的相关平台：</p><img src="https://pic3.zhimg.com/v2-d40caea4feadfe3a02b054646eca5ce3_r.png" data-rawwidth="1414" data-rawheight="800"><p><br></p><img src="https://pic4.zhimg.com/v2-2924dbf45789ca2671a1958ee68303a1_r.png" data-rawwidth="1422" data-rawheight="796"><p><br></p><img src="https://pic4.zhimg.com/v2-38275fbaa221dddae9e46d09d8cc6983_r.png" data-rawwidth="1419" data-rawheight="800"><p><br></p><img src="https://pic1.zhimg.com/v2-c487104798c0c32b6a535fdfe87e3add_r.png" data-rawwidth="1296" data-rawheight="725"><p><br></p><h2><b>检查冷门的老功能</b></h2><p>这些功能常常不被人们重视：</p><ul><li>非标准化功能</li><li>冷门功能</li><li>常规插件</li></ul><p>同样地，我们也可以通过发行记录，或者从已有的研究报告中来探索这些功能。</p><p>打个比方：</p><img src="https://pic1.zhimg.com/v2-1b282742cbc694cbd423b4c1044cbac9_r.png" data-rawwidth="864" data-rawheight="656"><p>我用 dialogArguments/returnValue 时，发现数据可以传输到任意窗口，此处是否有 SOP 绕过漏洞呢？</p><p>在用 Dailog 时，用户不能操作其它窗口，这有没有可能引发 UI 相关的问题呢？</p><h2><b>枚举法 — 延伸已经存在的漏洞</b></h2><p>我们可以去挖掘一下常见机制的问题：</p><ul><li>JavaScript 的 HTTP 通信机制（sendBeacon，Fetch，Worker）</li><li>浏览器弹窗机制（alert，confirm，getUserMedia）</li><li>MIME 类型（text / javascript, image / svg + xml, application / octet-stream ...）</li></ul><p>研究已经被列为高危的功能也很奏效：</p><ul><li>windows 对象</li><li>HTTP 泄露</li><li>HTML5 Security Cheatsheet</li></ul><img src="https://pic2.zhimg.com/v2-70f4c79d48f1a6e95a6b857dcef07332_r.png" data-rawwidth="1390" data-rawheight="793"><p><br></p><p>通过枚举法，我们能更好地集中到有效目标上。比方说：</p><img src="https://pic3.zhimg.com/v2-c6308c273bcfe3f16501809ef54ee9a0_r.png" data-rawwidth="1403" data-rawheight="797"><p>在这里，我们可以得知IE可以运行 CSS 里的脚本，这是否意味着我们可以用它来进行 XSS 或者过滤器绕过呢？</p><h2><b>从 commit 历史中挖掘漏洞</b></h2><p>我们可以通过 git 历史来发现有趣的特性，比如说：</p><ul><li>对移动系统的支持（3d Touch, Spotlight, Universal Links)</li><li>正在完善中的功能（Web App Manifest, Geckoview)</li></ul><img src="https://pic3.zhimg.com/v2-173aca2d5f67a43f9e733ea87bac986a_r.png" data-rawwidth="1431" data-rawheight="794"><p><br></p><p>那么，我们如何发现值得关注的点呢：</p><ul><li>已经被开发者标明为高危的功能</li><li>实现复杂的第三方库(SQLite, Alamofire)</li></ul><p>我们再来看个例子，这是一个 Chrome 的 commit 记录：<a href="https://goo.gl/xo6MMV">Https://goo.gl/xo6MMV</a></p><p>在 commit 之前，chrome 并没有对国际化字符进行一个良好的处理，以下图片的 a 实际上是Cyrillic 字符集的 U+0430（并不是英语的a0）:</p><img src="https://pic1.zhimg.com/v2-57709447a88ff7b3d6c95830185eaf09_r.png" data-rawwidth="368" data-rawheight="84"><p>而:则是 U+0589，/是 U+2215</p><img src="https://pic2.zhimg.com/v2-1f890692dea45a6649e1a5ef08a2d97d_r.png" data-rawwidth="376" data-rawheight="65"><p><br></p><p>我汇报了这个问题，不过谷歌的解决方法是简单粗暴地禁用国际化域名。</p><img src="https://pic3.zhimg.com/v2-c632d565eaccb34623c0705081bfa436_r.png" data-rawwidth="853" data-rawheight="154"><p><br></p><p>这个 commit 记录则增加了两个潜在的攻击点：</p><ul><li>用 SQLite 存储数据是否意味着有 SQL 注入？</li><li>将变量插入到页面中时候会导致 XSS?</li></ul><p>当浏览器的一个功能有如下特点时，就往往意味着该功能有问题：</p><ul><li>将 URL 给 API，它会返回特定的标志</li><li>CSP 运行异常</li><li>你能发送任意 header 给一个目标</li></ul><p>如果你知道要攻击的具体目标，那么你可以检查：</p><ul><li>location 返回的值</li><li>函数的行为</li><li>CSP 实现是否正确？</li></ul><h2><b>寻找字符集漏洞</b></h2><p>通过浏览器对字符集处理的不当，我们可以挖掘许多问题。</p><p>各个浏览器对字符集的支持：</p><img src="https://pic4.zhimg.com/v2-e208f0fc6ac38df5bb25e02b6e79a46d_r.png" data-rawwidth="938" data-rawheight="533"><p>比方说 CVE-2013-5612，当你在 POST 请求中不指定字符集，那么它就会默认使用上一个被指定的字符集。我们可以利用支持上的差异性来达到绕过 XSS Auditor</p><h2><b>寻找第三方库的漏洞</b></h2><p>在 Pwn2Own 比赛中，来自长亭科技的研究人员成功地利用 SQLite 的内存损坏攻破了 Safari。同理，我们也可以在下面的lib中寻找漏洞：</p><img src="https://pic1.zhimg.com/v2-c45843420bc4a2ac0560d7d79bb53d35_r.png" data-rawwidth="1655" data-rawheight="609"><p><br></p><h2><b>其它攻击面</b></h2><p>浏览器解析特殊协议（比如 about）也可能产生种种问题。当我们在 firefox 输入about:neterror?e=nssBadCert&amp;d=Hello%20Guys!时，会有：</p><img src="https://pic4.zhimg.com/v2-5cdd1073973d2976fad03494e5bc7070_r.png" data-rawwidth="975" data-rawheight="522"><p><br></p><h2><b>不忘学习前人经验</b></h2><p>在我们找漏洞的同时，不要忘记学习前人的思路，我们应该多想想这些问题：漏洞是什么类型的？他们是怎么找到漏洞的？这个漏洞又为何出现的？<br>我们可以通过 Security Advisor（<a href="https://www.mozilla.org/en-US/security/advisories/">mozilla</a>，<a href="https://chromereleases.googleblog.com/2017/07/stable-channel-update-for-desktop.html">chrome</a>），以及私人 blog 来学习寻找漏洞的过程。</p><h2><b>深入研究目标</b></h2><p>为了深入探索一个目标，我们需要了解一下特性：</p><ul><li>这个功能是用来干什么的</li><li>如何使用它</li><li>输入和输出是什么</li><li>有没有什么过滤</li><li>我们能否利用它绕过安全机制</li><li>我们能否用它攻击安全站点</li></ul><p>那么，我们应该用什么手段去深度挖掘呢？</p><ul><li>亲自使用一遍</li><li>审计代码</li><li>审计可执行文件（反汇编）</li><li>查看软件 log</li></ul><p>就拿 Fetch API 来说：</p><code lang="js">fetch('http://api.example.jp/path',{  //我在这里能代入哪些地址？
  method:'POST',                        //我还能添加哪些方法?
  headers: {
    'Content-Type':'text/plain'           //这里是否能插入其它header或者MIME类型?
  },
  body:'Hello World!'                   //body能插入哪些文字?
  }).then(function(res){
    console.log(res.headers.get('Content-Type')); //我能读取哪些header的值?
  }).catch(function(err){
  console.error(err);                   //抛出的错误时候包含了敏感信息?
});
</code><p>一个通过逆向找漏洞的例子：</p><img src="https://pic1.zhimg.com/v2-32a99fc8cdf79b70414afc5ac8616b9c_r.png" data-rawwidth="942" data-rawheight="536"><p>edge 的一个 dll 包含了 XSS 过滤器的正则表达式，我们通过反向推导，或许可以找出 bypass payload。</p><h2><b>探索有趣的行为</b></h2><p>当我们发现了一些异常行为时，我们需要继续留心，因为这往往意味着更深层次的漏洞：</p><ul><li>跳转后，地址栏不更新 (URL Spoof)</li><li>某个输入导致浏览器崩溃或者暂停响应</li><li>HTML tag 不正常运行</li><li>文字乱码</li></ul><p>比方说 CVE-2012-3695，我们输入https://aaa%2F@example.com/时，%2F会被解码，并返回https://aaa/@example.com/。本来被用做认证的 aaa%2F 被转化成了一个域名，这很有可能导致网络钓鱼。</p><p>挖掘这类漏洞有什么技巧呢？我们可以通过检查如下功能：</p><ul><li>URL scheme (http:, https:, ftp:, data:, resource:, about:, chrome-extension:)</li><li>Request method (GET, POST, HEAD, OPTIONS, TRACE)</li><li>浏览器怎么输出相关信息 (iframe, object / embed tag, svg foreignobject, Reading View)</li><li>浏览器怎么获取资源(img标签, video/audio标签, Worker的importScripts)</li><li>打开新 URL 的方法(Location头, meta刷新, window.open, 浏览器的返回键)</li><li>非常规输入（过长的字符串，HPP，空值，过大的数字，负数）</li><li>枚举各种其他元素<br>来快速发现可能的隐患。</li></ul><p>举几个例子：</p><p>在 CVE-2017-7789中，如果 firefox 在响应中收到多个 HSTS 头，那么 HSTS 就不会被启用。这时只要攻击者在普通的 HTTP 响应中包含几个 HSTS 头，那么他/她就可以绕过 HSTS 机制。</p><p>而在CVE-2015-4483里,我们在`feed:`后添加 URL，就可以绕过 Content Mixed Blocker</p><img src="https://pic1.zhimg.com/v2-b3e06c855ea6ce8dfd7e1a8391d2defc_r.png" data-rawwidth="561" data-rawheight="230"><p><br></p><h2><b>漏洞利用</b></h2><p>当你找到一个漏洞后，你应该如何利用它呢：</p><ul><li>想象如何在现有 Web 应用中利用</li><ul><li>因为这一漏洞，我们可以攻击原本安全的网页</li><li>这个漏洞会导致浏览器安全机制失效</li></ul></ul><p><br></p><ul><li>就算不能在某些场景利用，你也要考虑可以利用它的理想环境</li><ul><li>如果这个网站是这样（设想状态）实现的，那么我们可以如何如何（攻击）</li><li>如果这个设想相对靠谱，那么该漏洞可能在特定环境有效</li></ul></ul><p><br></p><p>让我们来看看 firefox 插件的一<a href="https://github.com/nishimunea/securitycamp2017">怪异行为</a>，虽然我们可以利用该漏洞对页面的 title（标签页的标题）进行 HTML 注入，然而由于 CSP，我们并不能触发 XSS。</p><p>当我们仔细观察%TITLE%，%CONTENT%的顺序后，就会发现一个模板注入漏洞：</p><img src="https://pic4.zhimg.com/v2-7496b4fb635f52a6e22ada51c9f04b7c_r.png" data-rawwidth="752" data-rawheight="224"><p>这样的话，只要我们插入 form 元素到%TITLE%时，即使不能 XSS，也能外带%CONTENT%给攻击者。</p><img src="https://pic4.zhimg.com/v2-ff757bf5f8992c3ae819e35d6cc9b5b1_r.png" data-rawwidth="660" data-rawheight="159"><p><br></p><p>在实际情境中，许多网站会将用户输入插入到页面 title，就拿 Google 来说：</p><img src="https://pic2.zhimg.com/v2-955aa85d635560b8780ff9281dbc45f5_r.png" data-rawwidth="929" data-rawheight="531"><p>然而获取别人的搜索结果似乎没什么卵用，我们是否能得到更敏感的资料呢？</p><p>Gmail 似乎是一个不错的目标，我们可以发送一封恶意邮件给目标，当他/她展开该邮件时，页面 title 会更换为邮件标题：</p><img src="https://pic4.zhimg.com/v2-2677277016ff50b67e07b1c6089af265_r.png" data-rawwidth="874" data-rawheight="308"><p>当用户点击 <i>Click Me</i> 时，邮箱信息就会被传送给攻击者</p><img src="https://pic1.zhimg.com/v2-5464544040c91aedcb2eeaca584f1b22_r.png" data-rawwidth="876" data-rawheight="308"><p><br></p><p>至此，我们成功地将该漏洞变废为宝。</p><p><br></p><p><i>作者：<b>Masato Kinugawa</b></i></p>
<script async defer="defer" src="https://www.googletagmanager.com/gtag/js?id=UA-7909075-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){ dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'UA-7909075-5');
</script>
<script>
var _hmt = _hmt || [];
</script>
<script async defer="defer" src="https://hm.baidu.com/hm.js?e3d40295e416616ddc21287da9646d31"></script>
</body>
</html>
