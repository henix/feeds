<p>前言：这篇文章是由陈智罡博士于2013年写的博客文章，当时全同态加密研究刚起步，方案非常复杂。陈博士的这篇博客文章，成为了每个进入全同态加密领域同学的必读文章，也为很多学习全同态加密的同学解答了很多学习困惑。今天读起来，会让我们很好的了解当初全同态加密是如何被解决的。</p><p>———————————这是一条美丽的分割线——————————————</p><h2><b>6、</b> <b>压缩解密电路</b></h2><p>如何把电路变浅呢？一个直观的方法就是替别人承担一些工作，这样原来的任务量就变小了。</p><p>还是先来仔细打量一下问题出在的地方：</p><h3><i>c× p-1</i></h3><p class="ztext-empty-paragraph"><br/></p><p>这是一个乘积，要想把它变成一个较浅的运算电路，应该如何做呢？最直观的方法就是：把乘积变成和，也就是说把c·p-1 →∑zi。c是密文，我们不可能拿它开刀，唯一可以做处理的地方就是p-1，也就是说应该把p-1 转换成一个和的形式即： p-1 →∑yi，</p><p>要知道p是私钥是不能公开的，所以可以把p隐藏在∑yi中，同时这种隐藏要不会泄露p才可行，所以要有一个陷门才可以，这个陷门就是Sparse Subset Sum Prob (SSSP)，就是给一串整数x1,x2,……，xn，存在一个{1,……，n}的子集S，使得∑si * xi=0 (其中i∈S)，让你求这个S是不可行的。</p><p class="ztext-empty-paragraph"><br/></p><p>这个问题据说是困难的，好像没有被well studied。有了这个陷门就可以构造出：</p><p>取y1,y2,…,yn ∈[0, 2)，存在一个稀疏子集S，使得∑si · yi ≈ 1/p mod 2 (i∈S) (因为是实数所以用近似等于1/p表示，是存在一个误差的，这个误差不影响取整后的结果) 。</p><p>令 zi←c· yi  mod 2，zi保留一定的精确度，从而有：∑si · zi ≈ c/p  mod 2。所以解密电路中的「c/p」可以替换成「∑si * zi 」。解密电路变成：</p><p>    Lsb(c) XOR Lsb(「∑si·zi 」)。</p><p class="ztext-empty-paragraph"><br/></p><p>这个变换后的方案，公钥除了原来的公钥pk之外还多加了一个向量{yi}。密文除了原来的c之外多出了一个向量{zi}。</p><p>这个多出来的zi可以看做是提前拿出来计算以减轻解密电路负担的，这个方法叫预处理（post-process）。私钥由原来的sk变成了{si}。可以看到公钥变大，密文也变大，这个代价就是为了换得更浅的电路。那么电路变浅了吗？下面来分析一下：</p><p class="ztext-empty-paragraph"><br/></p><p>主要分析一下∑si·zi的多项式次数，然后和我们前面分析的f所能执行的最大次数比较就OK。</p><p>假设zi的精确度为n位（我们考虑的都是二进制表示），整数位只考虑最低位，因为Lsb(「∑si·zi 」)是对和先取整，然后再取最低有效位。如下所示：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_b.jpg" data-caption="" data-size="normal" data-rawwidth="566" data-rawheight="182" class="origin_image zh-lightbox-thumb" width="566" data-original="https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_b.jpg" data-caption="" data-size="normal" data-rawwidth="566" data-rawheight="182" class="origin_image zh-lightbox-thumb lazy" width="566" data-original="https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-8f2264be83feecf03e719f1f397ad6e0_b.jpg"/></figure><p>如果上述t个数应用“3-for-2 trick”相加，电路深度也不会满足要求。所以得另寻它法。<br/></p><p>有个概念说一下：HammingWeight，海明重量通俗的说就是向量中“1”的个数，由于我们是二进制相加，所以上面每一列相加的结果可以看成是该列的海明重量。那么海明重量怎么求呢？有一个定理非常有用，就是：</p><p>对于任意一个二进制向量&lt;a1,a2,……，at&gt;，其海明重量为W，并且其二进制表示为：wn,……w1w0的话，则wi可以表示为关于变元a1,a2,……，at的一个次数是2i多项式。这个多项式很好求，就是对称多项式e2i （a1,a2,……，at），有现成的算法。</p><p>好了我们可以对上面的那些列运用此定理。对最低列求海明重量，则海明重量的最低位是e20 （a1,-n, a2,-n ……，at,-n）mod 2，它就是该列的和，这个海明重量的倒数第二位是e21 （a1,-n, a2,-n ……，at,-n）mod 2，就进位到倒数第二列记为Cn,-(n-1)，如此下去;</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_b.jpg" data-caption="" data-size="normal" data-rawwidth="584" data-rawheight="233" class="origin_image zh-lightbox-thumb" width="584" data-original="https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_b.jpg" data-caption="" data-size="normal" data-rawwidth="584" data-rawheight="233" class="origin_image zh-lightbox-thumb lazy" width="584" data-original="https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-69e46f36c54c646a691c6c989763065c_b.jpg"/></figure><p>最后得到：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_b.jpg" data-caption="" data-size="normal" data-rawwidth="424" data-rawheight="292" class="origin_image zh-lightbox-thumb" width="424" data-original="https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_r.jpg"/></noscript><img src="https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_b.jpg" data-caption="" data-size="normal" data-rawwidth="424" data-rawheight="292" class="origin_image zh-lightbox-thumb lazy" width="424" data-original="https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-b08037e689fea7d51948ed8f85ba056d_b.jpg"/></figure><p>则有：</p><p>b=「∑si * zi 」= (b0 + b-1 ) mod 2  (因为是取整，所以只关心第0列，取整是要取最近的整数，所以和b-1有关，如果b-1是1则要进上去)</p><p>别忘了我们现在的任务：是要计算「∑si * zi 」的电路关于ai,j的多项式次数。开始时可以看成都是一次的：</p><p>然后计算完最后一列，有了向前面各列的进位后,变成如下形式：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-fefbeb046daabb532a0bfa10491439e9_b.jpg" data-caption="" data-size="normal" data-rawwidth="346" data-rawheight="147" class="content_image" width="346"/></noscript><img src="https://pic2.zhimg.com/v2-fefbeb046daabb532a0bfa10491439e9_b.jpg" data-caption="" data-size="normal" data-rawwidth="346" data-rawheight="147" class="content_image lazy" width="346" data-actualsrc="https://pic2.zhimg.com/v2-fefbeb046daabb532a0bfa10491439e9_b.jpg"/></figure><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-02bf69beea057d9bee7406e47871d8ad_b.jpg" data-caption="" data-size="normal" data-rawwidth="327" data-rawheight="158" class="content_image" width="327"/></noscript><img src="https://pic2.zhimg.com/v2-02bf69beea057d9bee7406e47871d8ad_b.jpg" data-caption="" data-size="normal" data-rawwidth="327" data-rawheight="158" class="content_image lazy" width="327" data-actualsrc="https://pic2.zhimg.com/v2-02bf69beea057d9bee7406e47871d8ad_b.jpg"/></figure><p>每一列关于ai,j的次数都变了，例如倒数第二列次数为4了，依次下去：</p><figure data-size="normal"><noscript><img src="https://pic2.zhimg.com/v2-219e11641174db236776d8a2dba6600d_b.jpg" data-caption="" data-size="normal" data-rawwidth="348" data-rawheight="177" class="content_image" width="348"/></noscript><img src="https://pic2.zhimg.com/v2-219e11641174db236776d8a2dba6600d_b.jpg" data-caption="" data-size="normal" data-rawwidth="348" data-rawheight="177" class="content_image lazy" width="348" data-actualsrc="https://pic2.zhimg.com/v2-219e11641174db236776d8a2dba6600d_b.jpg"/></figure><p>每一列关于ai,j的次数都变了，例如倒数第二列次数为4了，依次下去：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_b.jpg" data-caption="" data-size="normal" data-rawwidth="422" data-rawheight="314" class="origin_image zh-lightbox-thumb" width="422" data-original="https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_r.jpg"/></noscript><img src="https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_b.jpg" data-caption="" data-size="normal" data-rawwidth="422" data-rawheight="314" class="origin_image zh-lightbox-thumb lazy" width="422" data-original="https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-163741e238fbf58155be4618bef84c78_b.jpg"/></figure><p>因为最后的结果是(b0 + b-1 ) mod 2，所以我们只关心前面两列的次数（即第0列和第一列）。由于每列计算的结果都是e20(……)，它是关于输入项的一个次数为1次的对称多项式。</p><p class="ztext-empty-paragraph"><br/></p><p>对于第0列，由于其最高次数为2n ，所以其结果e20(……)的最高次数为2n。对于第1列，由于其最高次数为2n-1 ，所以其结果e20(……)的最高次数为2n-1。所以，计算「∑si * zi 」的电路关于ai,j的多项式次数为2n（别忘了n是zi的精确度）。</p><p class="ztext-empty-paragraph"><br/></p><p>回忆一下我们原来说的f所能计算的最高多项式次数为：log p / log Bn （注意2n中的n和此式的n不是一个n）。如何比较呢，得把参数确定一下，按照DGHV方案中的参数，λ为安全参数，取||p|| ～λ2, ||r||～λ，所以p～2λ2，B～2λ，则log p / log Bn～λ。</p><p class="ztext-empty-paragraph"><br/></p><p>要想让Evaluate能够运行「∑si * zi 」电路，zi的精确度要取logλ才可以。现在你知道DGHV论文中zi精确度为什么要取那个数了吧。</p><p class="ztext-empty-paragraph"><br/></p><p>到此为止我们知道了解密电路经过压缩，可以被Evaluate正确运算了，从而解密电路堂而皇之的进入permitted functions集合里了，所以该方案可以对密文做任意功能的运算了，知道这意味着什么吧，全同态实现了。七拐八歪的才修成正果，确实不容易。</p><p class="ztext-empty-paragraph"><br/></p><p>接下来我们总结一下实现步骤，其实上面已经有了。</p><p class="ztext-empty-paragraph"><br/></p><p>==========================================================================</p><p><b>文章首发在微信公众号：btc201800</b><br/><b>知识星球ID：28018093</b></p><p><br/><b>音频发布在喜马拉雅上“区块链杂谈 (第2季)”</b> <b><u><a href="https://link.zhihu.com/?target=http%3A//xima.tv/Bjq4se" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">xima.tv/Bjq4se</span><span class="invisible"></span></a></u></b></p><p><b>解读区块链白皮书</b> <u><a href="https://link.zhihu.com/?target=http%3A//xima.tv/RNU1Q8" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">xima.tv/RNU1Q8</span><span class="invisible"></span></a></u></p><p><br/><b>宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。</b></p>