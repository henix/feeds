<p>Rust 1.39中废弃了<code>std::mem::uninitialized</code>（也即<code>core::mem::uninitialized</code>），因为它可能引发未定义行为。现在应当使用<code>std::mem::MaybeUninit</code>（也即<code>core::mem::MaybeUninit</code>）替代之。</p><h2>未定义的行为</h2><p>最简单的例子就是未初始化的<code>bool</code>：</p><div class="highlight"><pre><code class="language-rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">bool_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">mem</span>::<span class="n">uninitialized</span>::<span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="c1">// 错误：在 bool_value 真正初始化之前就使用它的值
</span><span class="c1"></span><span class="k">if</span><span class="w"> </span><span class="n">bool_value</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="c1">// ......
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在目标平台上，未初始化的内存可能是不确定值，也有可能有某种初始值，例如全零、<code>烫烫烫烫烫</code>、<code>屯屯屯屯屯</code>。无论如何，在Rust语言的层面，在<code>bool_value</code>真正初始化之前，它的值是不确定的。如果其实际值为零，就会被当成<code>false</code>；如果其实际值非零，就会被当成<code>true</code>（1）。此时使用<code>bool_value</code>就会引发未定义的行为。</p><h2>对开发人员的要求</h2><p>可见，<code>mem::uninitialized</code>需要开发人员自行保证，不要「在真正初始化之前使用未初始化内存」。</p><p>这种错误用法很有可能是隐晦的：</p><div class="highlight"><pre><code class="language-rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Read</span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[repr(packed, C)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">MyRecord</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">field1</span>: <span class="kt">u16</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">field2</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">MyRecord</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read_from</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">src</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">MyRecord</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span>::<span class="n">uninitialized</span>::<span class="o">&lt;</span><span class="n">MyRecord</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">src</span><span class="p">.</span><span class="n">read_exact</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="n">std</span>::<span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">MyRecord</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">record</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyRecord</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// ......
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果<code>read_exact</code>出错，就会在<code>record</code>没有有效值的情况下调用<code>drop</code>。 为此，必须先将内容保存到一个没有<code>drop</code>行为的结构，然后在获取了有效值之后再构造需要的结构：</p><div class="highlight"><pre><code class="language-rust"><span class="k">impl</span><span class="w"> </span><span class="n">MyRecord</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read_from</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">src</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">MyRecord</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">raw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">MyRecord</span><span class="o">&gt;</span><span class="p">()];</span><span class="w">
</span><span class="w">        </span><span class="n">src</span><span class="p">.</span><span class="n">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">raw</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="n">raw</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2>mem::MaybeUninit</h2><p>Rust官方推荐用<code>mem::MaybeUninit</code>来实现未初始化的内存：</p><div class="highlight"><pre><code class="language-rust"><span class="k">impl</span><span class="w"> </span><span class="n">MyRecord</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read_from</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">src</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">MyRecord</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span>::<span class="n">MaybeUninit</span>::<span class="o">&lt;</span><span class="n">MyRecord</span><span class="o">&gt;</span>::<span class="n">uninit</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">src</span><span class="p">.</span><span class="n">read_exact</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="n">std</span>::<span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="n">record</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">MyRecord</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">record</span><span class="p">.</span><span class="n">assume_init</span><span class="p">())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>MaybeUninit&lt;MyRecord&gt;</code>本身的失效并不会触发<code>MyRecord</code>的<code>drop</code>，因此<code>MaybeUninit::uninit</code>是safe的。</p><p><code>mem::MaybeUninit</code>是用<code>mem::ManuallyDrop</code>实现的（这里省略了一些细节）：</p><div class="highlight"><pre><code class="language-rust"><span class="cp">#[lang = </span><span class="s">&#34;manually_drop&#34;</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">ManuallyDrop</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="nc">T</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">value</span>: <span class="nc">ManuallyDrop</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// ......
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在对应的lang item实现之前，<code>ManuallyDrop</code>是用union实现的：</p><div class="highlight"><pre><code class="language-rust"><span class="cp">#[allow(unions_with_drop_fields)]</span><span class="w">
</span><span class="w"></span><span class="k">union</span> <span class="nc">ManuallyDrop</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="nc">T</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这利用了「即使union的field是<code>Drop</code>的，编译器也不会隐式为union实现<code>Drop</code>」这一特点。</p><hr/><p>（1）评论指正，只有1才会被认为是true，其他非零值作为bool都是未定义行为。</p>